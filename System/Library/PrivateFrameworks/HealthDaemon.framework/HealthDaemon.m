void HDPowerLogForClient(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  void *v8;
  __CFString *v9;
  __CFString *v10;
  __CFString *v11;
  void *v12;
  void *v13;
  void v14[2];
  void v15[3];

  v15[2] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    v5 = a3;
    v6 = a1;
    v7 = [a2 process];
    v8 = (void *)[v5 mutableCopy];

    v9 = [v7 applicationIdentifier];
    if (!v9)
    {
      v9 = [v7 name];
    }
    v10 = @"missing";
    if (v9) {
      v10 = v9;
    }
    v11 = v10;

    v14[0] = @"clientId";
    v12 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend(v7, "processIdentifier"));
    v14[1] = @"bundleId";
    v15[0] = v12;
    v15[1] = v11;
    v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v15 forKeys:v14 count:2];

    [v8 addEntriesFromDictionary:v13];
    PLLogRegisteredEvent();
  }
}

void sub_1BCB815A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCB817B8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

id HDSampleEntityPredicateForEndDate(uint64_t a1)
{
  v2 = (void *)MEMORY[0x1E4F65D00];
  v3 = _HDSQLiteValueForDate();
  v4 = [v2 predicateWithProperty:@"end_date" value:v3 comparisonType:a1];

  return v4;
}

id HDSampleEntityPredicateForDataTypes(void *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  v2 = [MEMORY[0x1E4F1CA80] set];
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v3 = v1;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        v8 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(*(id *)(*((void *)&v11 + 1) + 8 * i), "code", (void)v11));
        [v2 addObject:v8];
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v5);
  }

  if ([v2 count])
  {
    v9 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"data_type" values:v2];
  }
  else
  {
    v9 = 0;
  }

  return v9;
}

id HDSourceEntityPredicateForAppleWatchSources()
{
  v0 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"product_type" likeValue:@"Watch%%"];
  id v1 = _HDSourceEntityPredicateForNotDeletedWithPredicate(v0);

  return v1;
}

id HDDataEntityPredicateForSourceEntitySet(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = [MEMORY[0x1E4F1CA80] set];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v5 = v3;
  uint64_t v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v14;
    do
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v14 != v8) {
          objc_enumerationMutation(v5);
        }
        v10 = objc_msgSend(NSNumber, "numberWithLongLong:", objc_msgSend(*(id *)(*((void *)&v13 + 1) + 8 * i), "persistentID", (void)v13));
        [v4 addObject:v10];
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v7);
  }

  long long v11 = HDDataEntityPredicateForSourceIdentifierSet(a1, v4);

  return v11;
}

id HDDataEntityPredicateForSourceIdentifierSet(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  switch(a1)
  {
    case 7:
      goto LABEL_17;
    case 2:
      if ([v3 count]) {
        [MEMORY[0x1E4F65D10] doesNotContainPredicateWithProperty:@"data_provenances.source_id" values:v4];
      }
      else {
        [MEMORY[0x1E4F65D58] truePredicate];
      }
      goto LABEL_6;
    case 1:
LABEL_17:
      if ([v3 count]) {
        [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"data_provenances.source_id" values:v4];
      }
      else {
        [MEMORY[0x1E4F65D58] falsePredicate];
      }
      uint64_t v5 = LABEL_6:;
      uint64_t v6 = (void *)v5;
      goto LABEL_12;
  }
  uint64_t v6 = 0;
LABEL_12:

  return v6;
}

id HDDataEntityPredicateForType(uint64_t a1)
{
  id v1 = (void *)MEMORY[0x1E4F65D00];
  v2 = [NSNumber numberWithInteger:a1];
  id v3 = _HDSQLiteValueForNumber();
  uint64_t v4 = [v1 predicateWithProperty:@"type" equalToValue:v3];

  return v4;
}

id HDDeletedObjectPredicateForDeletionDate(uint64_t a1)
{
  v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = _HDSQLiteValueForDate();
  uint64_t v4 = [v2 predicateWithProperty:@"creation_date" value:v3 comparisonType:a1];

  return v4;
}

id HDDataCollectorEnumerateBatches(void *a1, void *a2, void *a3, double a4, double a5)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  id v10 = a2;
  long long v11 = a3;
  if (!v11)
  {
    v56 = [MEMORY[0x1E4F28B00] currentHandler];
    v57 = objc_msgSend(NSString, "stringWithUTF8String:", "id<HDSensorDatum> HDDataCollectorEnumerateBatches(NSArray<id<HDSensorDatum>> *__strong, __strong id<HDSensorDatum>, NSTimeInterval, NSTimeInterval, __strong HDDataCollectorBatchingCallback)");
    [v56 handleFailureInFunction:v57, @"HDDataCollector.m", 909, @"Invalid parameter not satisfying: %@", @"block != nil" file lineNumber description];
  }
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = __HDDataCollectorEnumerateBatches_block_invoke;
  aBlock[3] = &__block_descriptor_40_e53___NSDate_24__0___HDSensorDatum__8___HDSensorDatum__16l;
  *(double *)&aBlock[4] = a5;
  long long v12 = _Block_copy(aBlock);
  long long v13 = [MEMORY[0x1E4F1C9C8] date];
  id v14 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  id v15 = v10;
  [v15 endDate];
  v63 = v62 = (void (**)(void, void, void))v12;
  unint64_t v16 = 0;
  char v17 = 1;
  v58 = v15;
  v59 = v11;
  v61 = v13;
  id v60 = v9;
  while (v16 < [v9 count])
  {
    uint64_t v18 = [v9 objectAtIndexedSubscript:v16];
    v19 = [v18 endDate];
    [v19 timeIntervalSinceReferenceDate];
    double v21 = v20;

    if (v21 < 0.0)
    {
      _HKInitializeLogging();
      v22 = *MEMORY[0x1E4F29F10];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F10], OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138412290;
        v67 = v18;
        _os_log_debug_impl(&dword_1BCB7D000, v22, OS_LOG_TYPE_DEBUG, "Skipping invalid datum: %@", buf, 0xCu);
      }
      ++v16;
      int v23 = 4;
      goto LABEL_43;
    }
    if (!v16 && ((objc_opt_respondsToSelector() & 1) == 0 || [v18 recordID] >= 2) && !v15)
    {
      id v24 = v18;

      id v15 = v24;
    }
    if ([v14 count])
    {
      if (v17) {
        goto LABEL_16;
      }
    }
    else
    {
      [v14 addObject:v18];
      if (v17)
      {
LABEL_16:
        v25 = [v14 firstObject];
        v26 = v15;
        uint64_t v27 = ((void (**)(void, void *, id))v62)[2](v62, v25, v15);

        v63 = (void *)v27;
        goto LABEL_19;
      }
    }
    v26 = v15;
LABEL_19:
    v28 = [v18 endDate];
    if ([v28 compare:v13] == 1)
    {
      _HKInitializeLogging();
      v29 = *MEMORY[0x1E4F29F10];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F10], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v67 = v18;
        _os_log_impl(&dword_1BCB7D000, v29, OS_LOG_TYPE_DEFAULT, "Received sensor datum in the future, aborting (%@)", buf, 0xCu);
      }
      char v17 = 0;
      int v23 = 5;
      goto LABEL_42;
    }
    [v28 timeIntervalSinceDate:v63];
    if (v30 > a4)
    {
      if (v30 < a5)
      {
        [v14 addObject:v18];
        ++v16;
      }
      v31 = [v14 lastObject];
      v32 = (void *)[v14 copy];
      v33 = [v31 endDate];
      v34 = v26;
      int v35 = v11[2](v11, v32, v26, v63, v33);

      if (v35)
      {
        [v14 removeAllObjects];
        id v36 = v31;

        uint64_t v37 = [v36 endDate];

        v63 = (void *)v37;
        v26 = v36;
      }
      else
      {
        v26 = [v14 firstObject];

        [v14 removeObjectAtIndex:0];
      }
      long long v13 = v61;

      int v23 = 0;
      char v17 = 1;
      long long v11 = v59;
      goto LABEL_41;
    }
    if (v30 < 0.0)
    {
      v38 = [v14 lastObject];
      v39 = [v38 endDate];
      id v40 = v63;
      v41 = v40;
      if (v40 && v39)
      {
        if ([v40 compare:v39] == 1) {
          v42 = v39;
        }
        else {
          v42 = v41;
        }
      }
      else if (v40)
      {
        v42 = v40;
      }
      else
      {
        v42 = v39;
      }
      id v64 = v42;

      v43 = (void *)[v14 copy];
      v11[2](v11, v43, v26, v64, v39);

      [v14 removeAllObjects];
      id v44 = v38;

      id v45 = v39;
      v63 = v45;

      int v23 = 0;
      char v17 = 0;
      v26 = v44;
      long long v13 = v61;
LABEL_41:
      id v9 = v60;
      goto LABEL_42;
    }
    [v14 addObject:v18];
    int v23 = 0;
    char v17 = 0;
    ++v16;
LABEL_42:

    id v15 = v26;
LABEL_43:

    if (v23 == 5) {
      break;
    }
  }
  [v13 timeIntervalSinceDate:v63];
  double v47 = v46;
  uint64_t v48 = [v14 count];
  if (v47 > a4 && v48 != 0)
  {
    v50 = [v14 lastObject];
    v51 = [v50 endDate];

    v52 = (void *)[v14 copy];
    int v53 = v11[2](v11, v52, v15, v63, v51);

    if (v53)
    {
      uint64_t v54 = [v14 lastObject];

      id v15 = (id)v54;
    }

    long long v13 = v61;
  }

  return v15;
}

id __HDDataCollectorEnumerateBatches_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  uint64_t v7 = [v6 endDate];
  uint64_t v8 = [v5 endDate];

  [v7 timeIntervalSinceDate:v8];
  double v10 = v9;

  if (v10 >= *(double *)(a1 + 32)) {
    double v10 = *(double *)(a1 + 32);
  }
  long long v11 = [v6 endDate];

  long long v12 = [v11 dateByAddingTimeInterval:-v10];

  return v12;
}

uint64_t _JobNameFromClientAndTaskNames(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [a1 stringByAppendingString:@"###"];
  id v5 = [v4 stringByAppendingString:v3];

  id v6 = v5;
  uint64_t v7 = [v6 UTF8String];

  return v7;
}

void sub_1BCB85CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB8621C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id location)
{
  objc_destroyWeak(v12);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCB89074(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCB892C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB89EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB8AA78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCB8AB1C(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1BCB8AB30(_Unwind_Exception *a1)
{
}

void sub_1BCB8BF3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id HDSampleEntityPredicateForStartDate(uint64_t a1)
{
  v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = _HDSQLiteValueForDate();
  uint64_t v4 = [v2 predicateWithProperty:@"start_date" value:v3 comparisonType:a1];

  return v4;
}

id HDCategorySampleEntityPredicateForValue(uint64_t a1)
{
  v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = _HDSQLiteValueForNumber();
  uint64_t v4 = [v2 predicateWithProperty:@"value" value:v3 comparisonType:a1];

  return v4;
}

void sub_1BCB8CE40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB8D7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB8E664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB8E8E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB902BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB9061C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB9272C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t HDDataEntityPredicateForOriginProductType(uint64_t a1, uint64_t a2)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"data_provenances.origin_product_type" value:a2 comparisonType:a1];
}

void sub_1BCB92CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB94900(void *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a2 == 2)
  {
    id v10 = objc_begin_catch(exc_buf);
    uint64_t v11 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v12 = [v10 reason];
    objc_msgSend(v11, "hk_error:format:", 102, @"hk_readValue file error: %@");
    objc_claimAutoreleasedReturnValue();

    objc_end_catch();
  }
  else
  {
    objc_begin_catch(exc_buf);
  }
  JUMPOUT(0x1BCB948C4);
}

BOOL HDCodableObjectCollectionReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      if (v9++ >= 9)
      {
        unint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = *(HDCodableSource **)(a1 + 160);
        *(void *)(a1 + 160) = v17;
        goto LABEL_94;
      case 2u:
        uint64_t v18 = objc_alloc_init(HDCodableSource);
        objc_storeStrong((id *)(a1 + 152), v18);
        if (!PBReaderPlaceMark() || (HDCodableSourceReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 3u:
        uint64_t v18 = objc_alloc_init(HDCodableCategorySample);
        [(id)a1 addCategorySamples:v18];
        if (!PBReaderPlaceMark() || (HDCodableCategorySampleReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 4u:
        uint64_t v18 = objc_alloc_init(HDCodableQuantitySample);
        [(id)a1 addQuantitySamples:v18];
        if (!PBReaderPlaceMark() || (HDCodableQuantitySampleReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 5u:
        uint64_t v18 = objc_alloc_init(HDCodableWorkout);
        [(id)a1 addWorkouts:v18];
        if (!PBReaderPlaceMark() || (HDCodableWorkoutReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 6u:
        uint64_t v18 = objc_alloc_init(HDCodableCorrelation);
        [(id)a1 addCorrelations:v18];
        if (!PBReaderPlaceMark() || (HDCodableCorrelationReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 7u:
        uint64_t v18 = objc_alloc_init(HDCodableActivityCache);
        [(id)a1 addActivityCaches:v18];
        if (!PBReaderPlaceMark() || (HDCodableActivityCacheReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 8u:
        uint64_t v18 = objc_alloc_init(HDCodableBinarySample);
        [(id)a1 addBinarySamples:v18];
        if (!PBReaderPlaceMark() || !HDCodableBinarySampleReadFrom((uint64_t)v18, a2)) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 9u:
        uint64_t v18 = objc_alloc_init(HDCodableDeletedSample);
        [(id)a1 addDeletedSamples:v18];
        if (!PBReaderPlaceMark() || (HDCodableDeletedSampleReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0xAu:
        uint64_t v18 = objc_alloc_init(HDCodableLocationSeries);
        [(id)a1 addLocationSeries:v18];
        if (!PBReaderPlaceMark() || (HDCodableLocationSeriesReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0xBu:
        uint64_t v18 = objc_alloc_init(HDCodableCDADocumentSample);
        [(id)a1 addCdaDocumentSamples:v18];
        if (!PBReaderPlaceMark() || (HDCodableCDADocumentSampleReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0xDu:
        uint64_t v18 = objc_alloc_init(HDCodableFitnessFriendActivitySnapshot);
        [(id)a1 addFitnessFriendActivitySnapshots:v18];
        if (!PBReaderPlaceMark()
          || (HDCodableFitnessFriendActivitySnapshotReadFrom((uint64_t)v18, a2) & 1) == 0)
        {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0xEu:
        uint64_t v18 = objc_alloc_init(HDCodableFitnessFriendAchievement);
        [(id)a1 addFitnessFriendAchievements:v18];
        if (!PBReaderPlaceMark()
          || (HDCodableFitnessFriendAchievementReadFrom((uint64_t)v18, a2) & 1) == 0)
        {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0xFu:
        uint64_t v18 = objc_alloc_init(HDCodableFitnessFriendWorkout);
        [(id)a1 addFitnessFriendWorkouts:v18];
        if (!PBReaderPlaceMark() || (HDCodableFitnessFriendWorkoutReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x12u:
        uint64_t v18 = objc_alloc_init(HDCodableGeneratedObjectCollection);
        objc_storeStrong((id *)(a1 + 96), v18);
        if (!PBReaderPlaceMark() || (HDCodableGeneratedObjectCollectionReadFrom(v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x14u:
        uint64_t v18 = objc_alloc_init(HDCodableProvenance);
        objc_storeStrong((id *)(a1 + 120), v18);
        if (!PBReaderPlaceMark() || (HDCodableProvenanceReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x15u:
        uint64_t v18 = objc_alloc_init(HDCodableSleepSchedule);
        [(id)a1 addSleepSchedules:v18];
        if (!PBReaderPlaceMark() || (HDCodableSleepScheduleReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x16u:
        uint64_t v18 = objc_alloc_init(HDCodableECGSample);
        [(id)a1 addEcgSamples:v18];
        if (!PBReaderPlaceMark() || (HDCodableECGSampleReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x17u:
        uint64_t v18 = objc_alloc_init(HDCodableVisionSample);
        [(id)a1 addVisionSamples:v18];
        if (!PBReaderPlaceMark() || (HDCodableVisionSampleReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x19u:
        uint64_t v18 = objc_alloc_init(HDCodableStateOfMind);
        [(id)a1 addStateOfMindLogs:v18];
        if (!PBReaderPlaceMark() || (HDCodableStateOfMindReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x1Au:
        uint64_t v18 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 176), v18);
        if (!PBReaderPlaceMark() || !HDCodableSyncIdentityReadFrom((uint64_t)v18, a2)) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x1Bu:
        uint64_t v18 = objc_alloc_init(HDCodableScoredAssessment);
        [(id)a1 addScoredAssessmentSamples:v18];
        if (!PBReaderPlaceMark() || (HDCodableScoredAssessmentReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x1Cu:
        uint64_t v18 = objc_alloc_init(HDCodableWorkoutZones);
        [(id)a1 addWorkoutZones:v18];
        if (!PBReaderPlaceMark() || !HDCodableWorkoutZonesReadFrom((uint64_t)v18, a2)) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x1Du:
        uint64_t v18 = objc_alloc_init(HDCodableActivityGoalSchedule);
        [(id)a1 addActivityGoalSchedules:v18];
        if (!PBReaderPlaceMark() || (HDCodableActivityGoalScheduleReadFrom((uint64_t)v18, a2) & 1) == 0) {
          goto LABEL_98;
        }
        goto LABEL_93;
      case 0x1Eu:
        uint64_t v18 = objc_alloc_init(HDCodablePauseRingsSchedule);
        [(id)a1 addPauseRingsSchedules:v18];
        if PBReaderPlaceMark() && (HDCodablePauseRingsScheduleReadFrom((uint64_t)v18, a2))
        {
LABEL_93:
          PBReaderRecallMark();
LABEL_94:

LABEL_95:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_98:

        return 0;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0) {
          return 0;
        }
        goto LABEL_95;
    }
  }
}

uint64_t HDCodableQuantitySampleReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v18 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 88), v18);
        if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v18, a2)) {
          goto LABEL_66;
        }
        goto LABEL_100;
      case 2u:
        *(_WORD *)(a1 + 100) |= 0x40u;
        uint64_t v20 = *v3;
        unint64_t v21 = *(void *)(a2 + v20);
        if (v21 <= 0xFFFFFFFFFFFFFFF7 && v21 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v22 = 0;
        }
        uint64_t v60 = 56;
        goto LABEL_97;
      case 3u:
        *(_WORD *)(a1 + 100) |= 0x80u;
        uint64_t v23 = *v3;
        unint64_t v24 = *(void *)(a2 + v23);
        if (v24 <= 0xFFFFFFFFFFFFFFF7 && v24 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v24);
          *(void *)(a2 + v23) = v24 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v22 = 0;
        }
        uint64_t v60 = 64;
        goto LABEL_97;
      case 4u:
        uint64_t v25 = PBReaderReadString();
        v26 = *(void **)(a1 + 72);
        *(void *)(a1 + 72) = v25;

        goto LABEL_98;
      case 5u:
        char v27 = 0;
        unsigned int v28 = 0;
        uint64_t v29 = 0;
        *(_WORD *)(a1 + 100) |= 0x200u;
        while (2)
        {
          uint64_t v30 = *v3;
          uint64_t v31 = *(void *)(a2 + v30);
          unint64_t v32 = v31 + 1;
          if (v31 == -1 || v32 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v33 = *(unsigned char *)(*(void *)(a2 + *v7) + v31);
            *(void *)(a2 + v30) = v32;
            v29 |= (unint64_t)(v33 & 0x7F) << v27;
            if (v33 < 0)
            {
              v27 += 7;
              BOOL v15 = v28++ >= 9;
              if (v15)
              {
                uint64_t v29 = 0;
                goto LABEL_73;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v29 = 0;
        }
LABEL_73:
        BOOL v58 = v29 != 0;
        uint64_t v59 = 97;
        goto LABEL_82;
      case 6u:
        char v34 = 0;
        unsigned int v35 = 0;
        uint64_t v36 = 0;
        *(_WORD *)(a1 + 100) |= 1u;
        while (2)
        {
          uint64_t v37 = *v3;
          uint64_t v38 = *(void *)(a2 + v37);
          unint64_t v39 = v38 + 1;
          if (v38 == -1 || v39 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v40 = *(unsigned char *)(*(void *)(a2 + *v7) + v38);
            *(void *)(a2 + v37) = v39;
            v36 |= (unint64_t)(v40 & 0x7F) << v34;
            if (v40 < 0)
            {
              v34 += 7;
              BOOL v15 = v35++ >= 9;
              if (v15)
              {
                uint64_t v36 = 0;
                goto LABEL_77;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v36 = 0;
        }
LABEL_77:
        *(void *)(a1 + 8) = v36;
        goto LABEL_98;
      case 7u:
        char v41 = 0;
        unsigned int v42 = 0;
        uint64_t v43 = 0;
        *(_WORD *)(a1 + 100) |= 0x100u;
        while (2)
        {
          uint64_t v44 = *v3;
          uint64_t v45 = *(void *)(a2 + v44);
          unint64_t v46 = v45 + 1;
          if (v45 == -1 || v46 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v47 = *(unsigned char *)(*(void *)(a2 + *v7) + v45);
            *(void *)(a2 + v44) = v46;
            v43 |= (unint64_t)(v47 & 0x7F) << v41;
            if (v47 < 0)
            {
              v41 += 7;
              BOOL v15 = v42++ >= 9;
              if (v15)
              {
                uint64_t v43 = 0;
                goto LABEL_81;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v43 = 0;
        }
LABEL_81:
        BOOL v58 = v43 != 0;
        uint64_t v59 = 96;
LABEL_82:
        *(unsigned char *)(a1 + v59) = v58;
        goto LABEL_98;
      case 8u:
        *(_WORD *)(a1 + 100) |= 4u;
        uint64_t v48 = *v3;
        unint64_t v49 = *(void *)(a2 + v48);
        if (v49 <= 0xFFFFFFFFFFFFFFF7 && v49 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v49);
          *(void *)(a2 + v48) = v49 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v22 = 0;
        }
        uint64_t v60 = 24;
        goto LABEL_97;
      case 9u:
        *(_WORD *)(a1 + 100) |= 2u;
        uint64_t v50 = *v3;
        unint64_t v51 = *(void *)(a2 + v50);
        if (v51 <= 0xFFFFFFFFFFFFFFF7 && v51 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v51);
          *(void *)(a2 + v50) = v51 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v22 = 0;
        }
        uint64_t v60 = 16;
        goto LABEL_97;
      case 0xAu:
        *(_WORD *)(a1 + 100) |= 8u;
        uint64_t v52 = *v3;
        unint64_t v53 = *(void *)(a2 + v52);
        if (v53 <= 0xFFFFFFFFFFFFFFF7 && v53 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v53);
          *(void *)(a2 + v52) = v53 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v22 = 0;
        }
        uint64_t v60 = 32;
        goto LABEL_97;
      case 0xBu:
        *(_WORD *)(a1 + 100) |= 0x10u;
        uint64_t v54 = *v3;
        unint64_t v55 = *(void *)(a2 + v54);
        if (v55 <= 0xFFFFFFFFFFFFFFF7 && v55 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v55);
          *(void *)(a2 + v54) = v55 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v22 = 0;
        }
        uint64_t v60 = 40;
        goto LABEL_97;
      case 0xCu:
        uint64_t v18 = objc_alloc_init(HDCodableQuantitySeriesDatum);
        [(id)a1 addQuantitySeriesData:v18];
        if (PBReaderPlaceMark() && HDCodableQuantitySeriesDatumReadFrom((uint64_t)v18, a2))
        {
LABEL_66:
          PBReaderRecallMark();

LABEL_98:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_100:

        return 0;
      case 0xDu:
        *(_WORD *)(a1 + 100) |= 0x20u;
        uint64_t v56 = *v3;
        unint64_t v57 = *(void *)(a2 + v56);
        if (v57 <= 0xFFFFFFFFFFFFFFF7 && v57 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v57);
          *(void *)(a2 + v56) = v57 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v22 = 0;
        }
        uint64_t v60 = 48;
LABEL_97:
        *(void *)(a1 + v60) = v22;
        goto LABEL_98;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_98;
    }
  }
}

uint64_t HDCodableSampleReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (2)
    {
      if (!*(unsigned char *)(a2 + *v5))
      {
        char v8 = 0;
        unsigned int v9 = 0;
        unint64_t v10 = 0;
        while (1)
        {
          uint64_t v11 = *v3;
          uint64_t v12 = *(void *)(a2 + v11);
          unint64_t v13 = v12 + 1;
          if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
            break;
          }
          char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
          *(void *)(a2 + v11) = v13;
          v10 |= (unint64_t)(v14 & 0x7F) << v8;
          if ((v14 & 0x80) == 0) {
            goto LABEL_12;
          }
          v8 += 7;
          BOOL v15 = v9++ >= 9;
          if (v15)
          {
            unint64_t v10 = 0;
            int v16 = *(unsigned __int8 *)(a2 + *v5);
            goto LABEL_14;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        if (*(unsigned char *)(a2 + *v5)) {
          unint64_t v10 = 0;
        }
LABEL_14:
        if (v16) {
          BOOL v17 = 1;
        }
        else {
          BOOL v17 = (v10 & 7) == 4;
        }
        if (!v17)
        {
          switch((v10 >> 3))
          {
            case 1u:
              uint64_t v18 = objc_alloc_init(HDCodableHealthObject);
              objc_storeStrong((id *)(a1 + 32), v18);
              if PBReaderPlaceMark() && (HDCodableHealthObjectReadFrom((uint64_t)v18, a2))
              {
                PBReaderRecallMark();

                goto LABEL_46;
              }

              return 0;
            case 2u:
              char v20 = 0;
              unsigned int v21 = 0;
              uint64_t v22 = 0;
              *(unsigned char *)(a1 + 40) |= 1u;
              break;
            case 3u:
              *(unsigned char *)(a1 + 40) |= 4u;
              uint64_t v27 = *v3;
              unint64_t v28 = *(void *)(a2 + v27);
              if (v28 <= 0xFFFFFFFFFFFFFFF7 && v28 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v29 = *(void *)(*(void *)(a2 + *v7) + v28);
                *(void *)(a2 + v27) = v28 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v29 = 0;
              }
              uint64_t v32 = 24;
              goto LABEL_45;
            case 4u:
              *(unsigned char *)(a1 + 40) |= 2u;
              uint64_t v30 = *v3;
              unint64_t v31 = *(void *)(a2 + v30);
              if (v31 <= 0xFFFFFFFFFFFFFFF7 && v31 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v29 = *(void *)(*(void *)(a2 + *v7) + v31);
                *(void *)(a2 + v30) = v31 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v29 = 0;
              }
              uint64_t v32 = 16;
LABEL_45:
              *(void *)(a1 + v32) = v29;
              goto LABEL_46;
            default:
              uint64_t result = PBReaderSkipValueWithTag();
              if (!result) {
                return result;
              }
LABEL_46:
              if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
                return *(unsigned char *)(a2 + *v5) == 0;
              }
              continue;
          }
          while (1)
          {
            uint64_t v23 = *v3;
            uint64_t v24 = *(void *)(a2 + v23);
            unint64_t v25 = v24 + 1;
            if (v24 == -1 || v25 > *(void *)(a2 + *v4)) {
              break;
            }
            char v26 = *(unsigned char *)(*(void *)(a2 + *v7) + v24);
            *(void *)(a2 + v23) = v25;
            v22 |= (unint64_t)(v26 & 0x7F) << v20;
            if ((v26 & 0x80) == 0) {
              goto LABEL_38;
            }
            v20 += 7;
            BOOL v15 = v21++ >= 9;
            if (v15)
            {
              uint64_t v22 = 0;
              goto LABEL_40;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_38:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v22 = 0;
          }
LABEL_40:
          *(void *)(a1 + 8) = v22;
          goto LABEL_46;
        }
      }
      break;
    }
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableCategorySampleReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 24) |= 1u;
        while (1)
        {
          uint64_t v21 = *v3;
          unint64_t v22 = *(void *)(a2 + v21);
          if (v22 == -1 || v22 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v23 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0) {
            goto LABEL_33;
          }
          v18 += 7;
          BOOL v14 = v19++ >= 9;
          if (v14)
          {
            uint64_t v20 = 0;
            goto LABEL_35;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_33:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_35:
        *(void *)(a1 + 8) = v20;
      }
      else if ((v10 >> 3) == 1)
      {
        BOOL v17 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 16), v17);
        if (!PBReaderPlaceMark() || (HDCodableSampleReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCB96A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB97284(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  _Block_object_dispose(&a40, 8);
  _Block_object_dispose((const void *)(v40 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableFitnessFriendActivitySnapshotReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = off_1E62EF000;
  char v8 = &OBJC_IVAR___HDProfile__healthRecordsAccountExistenceNotifier;
  unsigned int v9 = &OBJC_IVAR___HDProfile__healthRecordsAccountExistenceNotifier;
  unint64_t v10 = &OBJC_IVAR___HDProfile__healthRecordsAccountExistenceNotifier;
  uint64_t v11 = (int *)MEMORY[0x1E4F940B8];
  while (1)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v12 = 0;
    unsigned int v13 = 0;
    unint64_t v14 = 0;
    while (1)
    {
      uint64_t v15 = *v3;
      uint64_t v16 = *(void *)(a2 + v15);
      unint64_t v17 = v16 + 1;
      if (v16 == -1 || v17 > *(void *)(a2 + *v4)) {
        break;
      }
      char v18 = *(unsigned char *)(*(void *)(a2 + *v11) + v16);
      *(void *)(a2 + v15) = v17;
      v14 |= (unint64_t)(v18 & 0x7F) << v12;
      if ((v18 & 0x80) == 0) {
        goto LABEL_12;
      }
      v12 += 7;
      BOOL v19 = v13++ >= 9;
      if (v19)
      {
        unint64_t v14 = 0;
        int v20 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v20 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v14 = 0;
    }
LABEL_14:
    if (v20 || (v14 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    unint64_t v22 = v14 >> 3;
    if ((int)(v14 >> 3) <= 39) {
      break;
    }
    if ((int)v22 <= 60)
    {
      if ((int)v22 <= 49)
      {
        if (v22 == 40)
        {
          *(_DWORD *)(a1 + v10[449]) |= 1u;
          uint64_t v72 = *v3;
          unint64_t v73 = *(void *)(a2 + v72);
          if (v73 <= 0xFFFFFFFFFFFFFFF7 && v73 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v73);
            *(void *)(a2 + v72) = v73 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v84 = 8;
        }
        else
        {
          if (v22 != 41) {
            goto LABEL_113;
          }
          *(_DWORD *)(a1 + v10[449]) |= 2u;
          uint64_t v39 = *v3;
          unint64_t v40 = *(void *)(a2 + v39);
          if (v40 <= 0xFFFFFFFFFFFFFFF7 && v40 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v40);
            *(void *)(a2 + v39) = v40 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v84 = 16;
        }
      }
      else
      {
        switch(v22)
        {
          case '2':
            *(_DWORD *)(a1 + v10[449]) |= 0x8000u;
            uint64_t v62 = *v3;
            unint64_t v63 = *(void *)(a2 + v62);
            if (v63 <= 0xFFFFFFFFFFFFFFF7 && v63 + 8 <= *(void *)(a2 + *v4))
            {
              uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v63);
              *(void *)(a2 + v62) = v63 + 8;
            }
            else
            {
              *(unsigned char *)(a2 + *v5) = 1;
              uint64_t v29 = 0;
            }
            uint64_t v84 = 128;
            break;
          case '3':
            *(_DWORD *)(a1 + v10[449]) |= 0x1000u;
            uint64_t v64 = *v3;
            unint64_t v65 = *(void *)(a2 + v64);
            if (v65 <= 0xFFFFFFFFFFFFFFF7 && v65 + 8 <= *(void *)(a2 + *v4))
            {
              uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v65);
              *(void *)(a2 + v64) = v65 + 8;
            }
            else
            {
              *(unsigned char *)(a2 + *v5) = 1;
              uint64_t v29 = 0;
            }
            uint64_t v84 = 104;
            break;
          case '<':
            *(_DWORD *)(a1 + v10[449]) |= 0x400u;
            uint64_t v27 = *v3;
            unint64_t v28 = *(void *)(a2 + v27);
            if (v28 <= 0xFFFFFFFFFFFFFFF7 && v28 + 8 <= *(void *)(a2 + *v4))
            {
              uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v28);
              *(void *)(a2 + v27) = v28 + 8;
            }
            else
            {
              *(unsigned char *)(a2 + *v5) = 1;
              uint64_t v29 = 0;
            }
            uint64_t v84 = 88;
            break;
          default:
            goto LABEL_113;
        }
      }
      goto LABEL_158;
    }
    if ((int)v22 <= 79)
    {
      if (v22 != 61)
      {
        if (v22 != 70) {
          goto LABEL_113;
        }
        *(_DWORD *)(a1 + v10[449]) |= 0x4000u;
        uint64_t v41 = *v3;
        unint64_t v42 = *(void *)(a2 + v41);
        if (v42 <= 0xFFFFFFFFFFFFFFF7 && v42 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v42);
          *(void *)(a2 + v41) = v42 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v29 = 0;
        }
        uint64_t v84 = 120;
        goto LABEL_158;
      }
      char v74 = 0;
      unsigned int v75 = 0;
      uint64_t v32 = 0;
      *(_DWORD *)(a1 + v10[449]) |= 0x10000u;
      while (1)
      {
        uint64_t v76 = *v3;
        uint64_t v77 = *(void *)(a2 + v76);
        unint64_t v78 = v77 + 1;
        if (v77 == -1 || v78 > *(void *)(a2 + *v4)) {
          break;
        }
        char v79 = *(unsigned char *)(*(void *)(a2 + *v11) + v77);
        *(void *)(a2 + v76) = v78;
        v32 |= (unint64_t)(v79 & 0x7F) << v74;
        if ((v79 & 0x80) == 0) {
          goto LABEL_128;
        }
        v74 += 7;
        BOOL v19 = v75++ >= 9;
        if (v19)
        {
          uint64_t v32 = 0;
          goto LABEL_130;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_128:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v32 = 0;
      }
LABEL_130:
      uint64_t v83 = 136;
    }
    else
    {
      if (v22 == 80)
      {
        *(_DWORD *)(a1 + v10[449]) |= 0x200u;
        uint64_t v66 = *v3;
        unint64_t v67 = *(void *)(a2 + v66);
        if (v67 <= 0xFFFFFFFFFFFFFFF7 && v67 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v67);
          *(void *)(a2 + v66) = v67 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v29 = 0;
        }
        uint64_t v84 = 80;
        goto LABEL_158;
      }
      if (v22 == 81)
      {
        *(_DWORD *)(a1 + v10[449]) |= 0x100u;
        uint64_t v68 = *v3;
        unint64_t v69 = *(void *)(a2 + v68);
        if (v69 <= 0xFFFFFFFFFFFFFFF7 && v69 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v69);
          *(void *)(a2 + v68) = v69 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v29 = 0;
        }
        uint64_t v84 = 72;
LABEL_158:
        *(void *)(a1 + v84) = v29;
        goto LABEL_159;
      }
      if (v22 != 82) {
        goto LABEL_113;
      }
      char v30 = 0;
      unsigned int v31 = 0;
      uint64_t v32 = 0;
      *(_DWORD *)(a1 + v10[449]) |= 4u;
      while (1)
      {
        uint64_t v33 = *v3;
        uint64_t v34 = *(void *)(a2 + v33);
        unint64_t v35 = v34 + 1;
        if (v34 == -1 || v35 > *(void *)(a2 + *v4)) {
          break;
        }
        char v36 = *(unsigned char *)(*(void *)(a2 + *v11) + v34);
        *(void *)(a2 + v33) = v35;
        v32 |= (unint64_t)(v36 & 0x7F) << v30;
        if ((v36 & 0x80) == 0) {
          goto LABEL_116;
        }
        v30 += 7;
        BOOL v19 = v31++ >= 9;
        if (v19)
        {
          uint64_t v32 = 0;
          goto LABEL_118;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_116:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v32 = 0;
      }
LABEL_118:
      uint64_t v83 = 24;
    }
LABEL_131:
    *(void *)(a1 + v83) = v32;
LABEL_159:
    if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
  }
  if ((int)v22 > 19)
  {
    if ((int)v22 > 29)
    {
      if (v22 == 30)
      {
        *(_DWORD *)(a1 + v10[449]) |= 8u;
        uint64_t v80 = *v3;
        unint64_t v81 = *(void *)(a2 + v80);
        if (v81 <= 0xFFFFFFFFFFFFFFF7 && v81 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v81);
          *(void *)(a2 + v80) = v81 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v29 = 0;
        }
        uint64_t v84 = 32;
      }
      else
      {
        if (v22 != 31)
        {
LABEL_113:
          uint64_t result = PBReaderSkipValueWithTag();
          unint64_t v10 = &OBJC_IVAR___HDProfile__healthRecordsAccountExistenceNotifier;
          if (!result) {
            return result;
          }
          goto LABEL_159;
        }
        *(_DWORD *)(a1 + v10[449]) |= 0x10u;
        uint64_t v43 = *v3;
        unint64_t v44 = *(void *)(a2 + v43);
        if (v44 <= 0xFFFFFFFFFFFFFFF7 && v44 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v44);
          *(void *)(a2 + v43) = v44 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v29 = 0;
        }
        uint64_t v84 = 40;
      }
    }
    else if (v22 == 20)
    {
      *(_DWORD *)(a1 + v10[449]) |= 0x40u;
      uint64_t v70 = *v3;
      unint64_t v71 = *(void *)(a2 + v70);
      if (v71 <= 0xFFFFFFFFFFFFFFF7 && v71 + 8 <= *(void *)(a2 + *v4))
      {
        uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v71);
        *(void *)(a2 + v70) = v71 + 8;
      }
      else
      {
        *(unsigned char *)(a2 + *v5) = 1;
        uint64_t v29 = 0;
      }
      uint64_t v84 = 56;
    }
    else
    {
      if (v22 != 21) {
        goto LABEL_113;
      }
      *(_DWORD *)(a1 + v10[449]) |= 0x80u;
      uint64_t v37 = *v3;
      unint64_t v38 = *(void *)(a2 + v37);
      if (v38 <= 0xFFFFFFFFFFFFFFF7 && v38 + 8 <= *(void *)(a2 + *v4))
      {
        uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v38);
        *(void *)(a2 + v37) = v38 + 8;
      }
      else
      {
        *(unsigned char *)(a2 + *v5) = 1;
        uint64_t v29 = 0;
      }
      uint64_t v84 = 64;
    }
    goto LABEL_158;
  }
  switch((int)v22)
  {
    case 1:
      char v23 = v9;
      uint64_t v24 = v8;
      unint64_t v25 = v7;
      id v26 = objc_alloc_init(v7[287]);
      objc_storeStrong((id *)(a1 + 152), v26);
      if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v26, a2))
      {
        PBReaderRecallMark();

        uint64_t v7 = v25;
        char v8 = v24;
        unsigned int v9 = v23;
LABEL_67:
        unint64_t v10 = &OBJC_IVAR___HDProfile__healthRecordsAccountExistenceNotifier;
        goto LABEL_159;
      }

      return 0;
    case 2:
      uint64_t v45 = PBReaderReadData();
      uint64_t v46 = v8[447];
      goto LABEL_66;
    case 3:
      uint64_t v45 = PBReaderReadData();
      uint64_t v46 = v9[448];
LABEL_66:
      char v47 = *(void **)(a1 + v46);
      *(void *)(a1 + v46) = v45;

      goto LABEL_67;
    case 4:
      char v48 = 0;
      unsigned int v49 = 0;
      uint64_t v32 = 0;
      *(_DWORD *)(a1 + v10[449]) |= 0x800u;
      while (2)
      {
        uint64_t v50 = *v3;
        uint64_t v51 = *(void *)(a2 + v50);
        unint64_t v52 = v51 + 1;
        if (v51 == -1 || v52 > *(void *)(a2 + *v4))
        {
          *(unsigned char *)(a2 + *v5) = 1;
        }
        else
        {
          char v53 = *(unsigned char *)(*(void *)(a2 + *v11) + v51);
          *(void *)(a2 + v50) = v52;
          v32 |= (unint64_t)(v53 & 0x7F) << v48;
          if (v53 < 0)
          {
            v48 += 7;
            BOOL v19 = v49++ >= 9;
            if (v19)
            {
              uint64_t v32 = 0;
              goto LABEL_122;
            }
            continue;
          }
        }
        break;
      }
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v32 = 0;
      }
LABEL_122:
      uint64_t v83 = 96;
      goto LABEL_131;
    case 5:
      *(_DWORD *)(a1 + v10[449]) |= 0x20u;
      uint64_t v54 = *v3;
      unint64_t v55 = *(void *)(a2 + v54);
      if (v55 <= 0xFFFFFFFFFFFFFFF7 && v55 + 8 <= *(void *)(a2 + *v4))
      {
        uint64_t v29 = *(void *)(*(void *)(a2 + *v11) + v55);
        *(void *)(a2 + v54) = v55 + 8;
      }
      else
      {
        *(unsigned char *)(a2 + *v5) = 1;
        uint64_t v29 = 0;
      }
      uint64_t v84 = 48;
      goto LABEL_158;
    case 6:
      char v56 = 0;
      unsigned int v57 = 0;
      uint64_t v32 = 0;
      *(_DWORD *)(a1 + v10[449]) |= 0x2000u;
      while (2)
      {
        uint64_t v58 = *v3;
        uint64_t v59 = *(void *)(a2 + v58);
        unint64_t v60 = v59 + 1;
        if (v59 == -1 || v60 > *(void *)(a2 + *v4))
        {
          *(unsigned char *)(a2 + *v5) = 1;
        }
        else
        {
          char v61 = *(unsigned char *)(*(void *)(a2 + *v11) + v59);
          *(void *)(a2 + v58) = v60;
          v32 |= (unint64_t)(v61 & 0x7F) << v56;
          if (v61 < 0)
          {
            v56 += 7;
            BOOL v19 = v57++ >= 9;
            if (v19)
            {
              uint64_t v32 = 0;
              goto LABEL_126;
            }
            continue;
          }
        }
        break;
      }
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v32 = 0;
      }
LABEL_126:
      uint64_t v83 = 112;
      goto LABEL_131;
    default:
      goto LABEL_113;
  }
}

uint64_t HDCodableFitnessFriendAchievementReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v15 = v9++ >= 9;
        if (v15)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          char v18 = objc_alloc_init(HDCodableSample);
          objc_storeStrong((id *)(a1 + 40), v18);
          if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v18, a2))
          {
            PBReaderRecallMark();

            continue;
          }

          return 0;
        case 2u:
          uint64_t v19 = PBReaderReadData();
          uint64_t v20 = 32;
          goto LABEL_39;
        case 4u:
          *(unsigned char *)(a1 + 56) |= 1u;
          uint64_t v22 = *v3;
          unint64_t v23 = *(void *)(a2 + v22);
          if (v23 <= 0xFFFFFFFFFFFFFFF7 && v23 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v24 = *(void *)(*(void *)(a2 + *v7) + v23);
            *(void *)(a2 + v22) = v23 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v24 = 0;
          }
          uint64_t v35 = 8;
          goto LABEL_48;
        case 5u:
          *(unsigned char *)(a1 + 56) |= 2u;
          uint64_t v25 = *v3;
          unint64_t v26 = *(void *)(a2 + v25);
          if (v26 <= 0xFFFFFFFFFFFFFFF7 && v26 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v24 = *(void *)(*(void *)(a2 + *v7) + v26);
            *(void *)(a2 + v25) = v26 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v24 = 0;
          }
          uint64_t v35 = 16;
LABEL_48:
          *(void *)(a1 + v35) = v24;
          continue;
        case 6u:
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v29 = 0;
          *(unsigned char *)(a1 + 56) |= 4u;
          break;
        case 0xAu:
          uint64_t v19 = PBReaderReadString();
          uint64_t v20 = 48;
LABEL_39:
          uint64_t v34 = *(void **)(a1 + v20);
          *(void *)(a1 + v20) = v19;

          continue;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v30 = *v3;
        uint64_t v31 = *(void *)(a2 + v30);
        unint64_t v32 = v31 + 1;
        if (v31 == -1 || v32 > *(void *)(a2 + *v4)) {
          break;
        }
        char v33 = *(unsigned char *)(*(void *)(a2 + *v7) + v31);
        *(void *)(a2 + v30) = v32;
        v29 |= (unint64_t)(v33 & 0x7F) << v27;
        if ((v33 & 0x80) == 0) {
          goto LABEL_41;
        }
        v27 += 7;
        BOOL v15 = v28++ >= 9;
        if (v15)
        {
          uint64_t v29 = 0;
          goto LABEL_43;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_41:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v29 = 0;
      }
LABEL_43:
      *(void *)(a1 + 24) = v29;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableMetadataDictionaryReadFrom(void *a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        unint64_t v17 = objc_alloc_init(HDCodableMetadataKeyValuePair);
        [a1 addKeyValuePairs:v17];
        if (!PBReaderPlaceMark() || (HDCodableMetadataKeyValuePairReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableMetadataKeyValuePairReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 40;
        goto LABEL_40;
      case 2u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 56;
        goto LABEL_40;
      case 3u:
        *(unsigned char *)(a1 + 64) |= 1u;
        uint64_t v21 = *v3;
        unint64_t v22 = *(void *)(a2 + v21);
        if (v22 <= 0xFFFFFFFFFFFFFFF7 && v22 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v23 = *(void *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v22 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v23 = 0;
        }
        uint64_t v35 = 8;
        goto LABEL_49;
      case 4u:
        char v24 = 0;
        unsigned int v25 = 0;
        uint64_t v26 = 0;
        *(unsigned char *)(a1 + 64) |= 4u;
        while (2)
        {
          uint64_t v27 = *v3;
          uint64_t v28 = *(void *)(a2 + v27);
          unint64_t v29 = v28 + 1;
          if (v28 == -1 || v29 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v28);
            *(void *)(a2 + v27) = v29;
            v26 |= (unint64_t)(v30 & 0x7F) << v24;
            if (v30 < 0)
            {
              v24 += 7;
              BOOL v15 = v25++ >= 9;
              if (v15)
              {
                uint64_t v26 = 0;
                goto LABEL_44;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v26 = 0;
        }
LABEL_44:
        *(void *)(a1 + 24) = v26;
        goto LABEL_50;
      case 5u:
        *(unsigned char *)(a1 + 64) |= 2u;
        uint64_t v31 = *v3;
        unint64_t v32 = *(void *)(a2 + v31);
        if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v23 = *(void *)(*(void *)(a2 + *v7) + v32);
          *(void *)(a2 + v31) = v32 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v23 = 0;
        }
        uint64_t v35 = 16;
LABEL_49:
        *(void *)(a1 + v35) = v23;
        goto LABEL_50;
      case 6u:
        char v33 = objc_alloc_init(HDCodableQuantity);
        objc_storeStrong((id *)(a1 + 48), v33);
        if PBReaderPlaceMark() && (HDCodableQuantityReadFrom((uint64_t)v33, a2))
        {
          PBReaderRecallMark();

LABEL_50:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }

        return 0;
      case 7u:
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 32;
LABEL_40:
        uint64_t v34 = *(void **)(a1 + v19);
        *(void *)(a1 + v19) = v18;

        goto LABEL_50;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_50;
    }
  }
}

void sub_1BCB994D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB9D250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
}

id HDSampleEntityPredicateForDataType(void *a1)
{
  id v1 = (void *)MEMORY[0x1E4F65D00];
  v2 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(a1, "code"));
  id v3 = [v1 predicateWithProperty:@"data_type" equalToValue:v2];

  return v3;
}

void sub_1BCB9D44C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB9D900(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1BCB9E3C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void sub_1BCB9E490(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCB9E790(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCB9E858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCB9F4D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDSourceEntityPredicateForLocalDeviceSource()
{
  v0 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"local_device" equalToValue:MEMORY[0x1E4F1CC38]];
  uint64_t v1 = _HDSourceEntityPredicateForNotDeletedWithPredicate(v0);

  return v1;
}

void sub_1BCBA04C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBA097C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void sub_1BCBA14C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCBA1FAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1BCBA2048(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id HDActivityCacheEntityPredicateForCacheIndex(uint64_t a1, uint64_t a2)
{
  id v3 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v4 = [NSNumber numberWithLongLong:a1];
  id v5 = [v3 predicateWithProperty:@"cache_index" value:v4 comparisonType:a2];

  return v5;
}

uint64_t HDDataEntityPredicateForSourceIdentifier(uint64_t a1)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"data_provenances.source_id" equalToValue:a1];
}

id HDActivityCacheEntityPredicateForCachesInDateComponentsRange(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = _HKCacheIndexFromDateComponents();
  uint64_t v4 = _HKCacheIndexFromDateComponents();

  id v5 = HDActivityCacheEntityPredicateForCacheIndex(v3, 6);
  id v6 = HDActivityCacheEntityPredicateForCacheIndex(v4, 4);
  uint64_t v7 = [MEMORY[0x1E4F65D58] compoundPredicateWithPredicate:v5 otherPredicate:v6];

  return v7;
}

id HDDataEntityPredicateForDataUUID()
{
  v0 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v1 = _HDSQLiteValueForUUID();
  id v2 = [v0 predicateWithProperty:@"uuid" equalToValue:v1];

  return v2;
}

uint64_t HDSyncAnchorRangeMake(uint64_t a1, uint64_t a2)
{
  if (a2 < a1)
  {
    uint64_t v4 = [MEMORY[0x1E4F28B00] currentHandler];
    id v5 = objc_msgSend(NSString, "stringWithUTF8String:", "HDSyncAnchorRange HDSyncAnchorRangeMake(HDSyncAnchor, HDSyncAnchor)");
    [v4 handleFailureInFunction:v5, @"HDSyncSupport.m", 14, @"Invalid parameter not satisfying: %@", @"end >= start" file lineNumber description];
  }
  return a1;
}

void SetInPersistentUserInfo(void *a1, void *a2)
{
  id v8 = a1;
  id v3 = a2;
  uint64_t v4 = (void *)[v3 copyForPersistentUserInfo];
  id v5 = v4;
  if (v4)
  {
    id v6 = [v4 data];
    uint64_t v7 = [(id)objc_opt_class() persistentUserInfoKey];
    [v8 setObject:v6 forKeyedSubscript:v7];
  }
}

id GetFromPersistentUserInfo(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v4 = [a2 persistentUserInfoKey];
  id v5 = [v3 objectForKeyedSubscript:v4];

  if (v5) {
    id v6 = (void *)[objc_alloc((Class)a2) initWithData:v5];
  }
  else {
    id v6 = 0;
  }

  return v6;
}

uint64_t HDCodableNanoSyncChangeSetReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v18 = objc_alloc_init(HDCodableNanoSyncChange);
        [(id)a1 addChanges:v18];
        if PBReaderPlaceMark() && (HDCodableNanoSyncChangeReadFrom((uint64_t)v18, a2)) {
          goto LABEL_30;
        }
        goto LABEL_46;
      case 2u:
        uint64_t v20 = PBReaderReadData();
        uint64_t v21 = *(void **)(a1 + 32);
        *(void *)(a1 + 32) = v20;

        goto LABEL_44;
      case 3u:
        *(unsigned char *)(a1 + 44) |= 1u;
        uint64_t v22 = *v3;
        unint64_t v23 = *(void *)(a2 + v22);
        if (v23 <= 0xFFFFFFFFFFFFFFF7 && v23 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v24 = *(void *)(*(void *)(a2 + *v7) + v23);
          *(void *)(a2 + v22) = v23 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v24 = 0;
        }
        *(void *)(a1 + 8) = v24;
        goto LABEL_44;
      case 4u:
        uint64_t v18 = objc_alloc_init(HDCodableError);
        objc_storeStrong((id *)(a1 + 24), v18);
        if PBReaderPlaceMark() && (HDCodableErrorReadFrom((uint64_t)v18, a2))
        {
LABEL_30:
          PBReaderRecallMark();

LABEL_44:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_46:

        return 0;
      case 5u:
        char v25 = 0;
        unsigned int v26 = 0;
        uint64_t v27 = 0;
        *(unsigned char *)(a1 + 44) |= 2u;
        while (2)
        {
          uint64_t v28 = *v3;
          uint64_t v29 = *(void *)(a2 + v28);
          unint64_t v30 = v29 + 1;
          if (v29 == -1 || v30 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v31 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
            *(void *)(a2 + v28) = v30;
            v27 |= (unint64_t)(v31 & 0x7F) << v25;
            if (v31 < 0)
            {
              v25 += 7;
              BOOL v15 = v26++ >= 9;
              if (v15)
              {
                LODWORD(v27) = 0;
                goto LABEL_41;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v27) = 0;
        }
LABEL_41:
        *(_DWORD *)(a1 + 40) = v27;
        goto LABEL_44;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_44;
    }
  }
}

uint64_t HDCodableNanoSyncChangeReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v14 = v9++ >= 9;
      if (v14)
      {
        unint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 76) |= 8u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_76;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_78;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_76:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v19) = 0;
        }
LABEL_78:
        *(_DWORD *)(a1 + 48) = v19;
        goto LABEL_101;
      case 2u:
        char v24 = 0;
        unsigned int v25 = 0;
        uint64_t v26 = 0;
        *(unsigned char *)(a1 + 76) |= 4u;
        while (2)
        {
          uint64_t v27 = *v3;
          unint64_t v28 = *(void *)(a2 + v27);
          if (v28 == -1 || v28 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v29 = *(unsigned char *)(*(void *)(a2 + *v7) + v28);
            *(void *)(a2 + v27) = v28 + 1;
            v26 |= (unint64_t)(v29 & 0x7F) << v24;
            if (v29 < 0)
            {
              v24 += 7;
              BOOL v14 = v25++ >= 9;
              if (v14)
              {
                uint64_t v26 = 0;
                goto LABEL_82;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v26 = 0;
        }
LABEL_82:
        uint64_t v53 = 24;
        goto LABEL_95;
      case 3u:
        char v30 = 0;
        unsigned int v31 = 0;
        uint64_t v26 = 0;
        *(unsigned char *)(a1 + 76) |= 1u;
        while (2)
        {
          uint64_t v32 = *v3;
          unint64_t v33 = *(void *)(a2 + v32);
          if (v33 == -1 || v33 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v34 = *(unsigned char *)(*(void *)(a2 + *v7) + v33);
            *(void *)(a2 + v32) = v33 + 1;
            v26 |= (unint64_t)(v34 & 0x7F) << v30;
            if (v34 < 0)
            {
              v30 += 7;
              BOOL v14 = v31++ >= 9;
              if (v14)
              {
                uint64_t v26 = 0;
                goto LABEL_86;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v26 = 0;
        }
LABEL_86:
        uint64_t v53 = 8;
        goto LABEL_95;
      case 4u:
        PBReaderReadData();
        uint64_t v35 = (HDCodableNanoSyncAnchor *)objc_claimAutoreleasedReturnValue();
        if (v35) {
          [(id)a1 addObjectData:v35];
        }
        goto LABEL_74;
      case 5u:
        uint64_t v35 = objc_alloc_init(HDCodableNanoSyncAnchor);
        [(id)a1 addRequiredAnchors:v35];
        if (!PBReaderPlaceMark() || (HDCodableNanoSyncAnchorReadFrom((uint64_t)v35, a2) & 1) == 0) {
          goto LABEL_103;
        }
        goto LABEL_73;
      case 6u:
        char v36 = 0;
        unsigned int v37 = 0;
        uint64_t v38 = 0;
        *(unsigned char *)(a1 + 76) |= 0x20u;
        while (2)
        {
          uint64_t v39 = *v3;
          unint64_t v40 = *(void *)(a2 + v39);
          if (v40 == -1 || v40 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v41 = *(unsigned char *)(*(void *)(a2 + *v7) + v40);
            *(void *)(a2 + v39) = v40 + 1;
            v38 |= (unint64_t)(v41 & 0x7F) << v36;
            if (v41 < 0)
            {
              v36 += 7;
              BOOL v14 = v37++ >= 9;
              if (v14)
              {
                uint64_t v38 = 0;
                goto LABEL_90;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v38 = 0;
        }
LABEL_90:
        BOOL v54 = v38 != 0;
        uint64_t v55 = 73;
        goto LABEL_100;
      case 7u:
        char v42 = 0;
        unsigned int v43 = 0;
        uint64_t v26 = 0;
        *(unsigned char *)(a1 + 76) |= 2u;
        while (2)
        {
          uint64_t v44 = *v3;
          unint64_t v45 = *(void *)(a2 + v44);
          if (v45 == -1 || v45 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v46 = *(unsigned char *)(*(void *)(a2 + *v7) + v45);
            *(void *)(a2 + v44) = v45 + 1;
            v26 |= (unint64_t)(v46 & 0x7F) << v42;
            if (v46 < 0)
            {
              v42 += 7;
              BOOL v14 = v43++ >= 9;
              if (v14)
              {
                uint64_t v26 = 0;
                goto LABEL_94;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v26 = 0;
        }
LABEL_94:
        uint64_t v53 = 16;
LABEL_95:
        *(void *)(a1 + v53) = v26;
        goto LABEL_101;
      case 8u:
        char v47 = 0;
        unsigned int v48 = 0;
        uint64_t v49 = 0;
        *(unsigned char *)(a1 + 76) |= 0x10u;
        while (2)
        {
          uint64_t v50 = *v3;
          unint64_t v51 = *(void *)(a2 + v50);
          if (v51 == -1 || v51 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v52 = *(unsigned char *)(*(void *)(a2 + *v7) + v51);
            *(void *)(a2 + v50) = v51 + 1;
            v49 |= (unint64_t)(v52 & 0x7F) << v47;
            if (v52 < 0)
            {
              v47 += 7;
              BOOL v14 = v48++ >= 9;
              if (v14)
              {
                uint64_t v49 = 0;
                goto LABEL_99;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v49 = 0;
        }
LABEL_99:
        BOOL v54 = v49 != 0;
        uint64_t v55 = 72;
LABEL_100:
        *(unsigned char *)(a1 + v55) = v54;
        goto LABEL_101;
      case 9u:
        uint64_t v35 = objc_alloc_init(HDCodableEntityIdentifier);
        objc_storeStrong((id *)(a1 + 32), v35);
        if (!PBReaderPlaceMark() || (HDCodableEntityIdentifierReadFrom((uint64_t)v35, a2) & 1) == 0) {
          goto LABEL_103;
        }
        goto LABEL_73;
      case 0xAu:
        uint64_t v35 = objc_alloc_init(HDCodableSyncVersionRange);
        objc_storeStrong((id *)(a1 + 64), v35);
        if (PBReaderPlaceMark() && HDCodableSyncVersionRangeReadFrom((uint64_t)v35, a2))
        {
LABEL_73:
          PBReaderRecallMark();
LABEL_74:

LABEL_101:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_103:

        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_101;
    }
  }
}

id HDNanoSyncDescriptionWithArray(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v3 = v1;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v18;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v18 != v6) {
          objc_enumerationMutation(v3);
        }
        char v8 = *(void **)(*((void *)&v17 + 1) + 8 * i);
        unsigned int v9 = [v8 nanoSyncDescription];
        unint64_t v10 = v9;
        if (v9)
        {
          id v11 = v9;
        }
        else
        {
          id v11 = [NSString stringWithFormat:@"<%@:%p>", objc_opt_class(), v8, (void)v17];
        }
        unint64_t v12 = v11;

        [v2 addObject:v12];
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }
    while (v5);
  }

  char v13 = NSString;
  BOOL v14 = [v2 componentsJoinedByString:@", "];
  int v15 = [v13 stringWithFormat:@"(%@)", v14];

  return v15;
}

id FormattedMessageDescription(int a1, int a2, int a3, void *a4, void *a5)
{
  unsigned int v9 = a5;
  id v10 = a4;
  id v11 = HDNanoSyncMessageIDString(a1);
  unint64_t v12 = "outgoing";
  if (a2) {
    unint64_t v12 = "incoming";
  }
  char v13 = "response";
  if (a3) {
    char v13 = "request";
  }
  BOOL v14 = &stru_1F1728D60;
  if (v9) {
    BOOL v14 = v9;
  }
  int v15 = [NSString stringWithFormat:@"%s %@ %s %@ %@", v12, v11, v13, v10, v14];

  return v15;
}

__CFString *HDNanoSyncMessageIDString(int a1)
{
  if ((a1 - 1) > 0xC) {
    return @"Unknown";
  }
  else {
    return off_1E6302D50[(__int16)(a1 - 1)];
  }
}

void sub_1BCBAA194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1BCBAA214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCBAD7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableNanoSyncMessageReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v14 = v9++ >= 9;
      if (v14)
      {
        unint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 2u:
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 68) |= 1u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_49;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_51;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_49:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v19) = 0;
        }
LABEL_51:
        *(_DWORD *)(a1 + 64) = v19;
        goto LABEL_46;
      case 3u:
        uint64_t v23 = PBReaderReadData();
        uint64_t v24 = 48;
        goto LABEL_28;
      case 4u:
        uint64_t v23 = PBReaderReadData();
        uint64_t v24 = 40;
LABEL_28:
        unsigned int v25 = *(void **)(a1 + v24);
        *(void *)(a1 + v24) = v23;

        goto LABEL_46;
      case 7u:
        uint64_t v27 = objc_alloc_init(HDCodableNanoSyncChangeSet);
        objc_storeStrong((id *)(a1 + 16), v27);
        if (!PBReaderPlaceMark() || (HDCodableNanoSyncChangeSetReadFrom((uint64_t)v27, a2) & 1) == 0) {
          goto LABEL_53;
        }
        goto LABEL_45;
      case 8u:
        uint64_t v27 = objc_alloc_init(HDCodableNanoSyncStatus);
        objc_storeStrong((id *)(a1 + 56), v27);
        if (!PBReaderPlaceMark() || (HDCodableNanoSyncStatusReadFrom((uint64_t)v27, a2) & 1) == 0) {
          goto LABEL_53;
        }
        goto LABEL_45;
      case 9u:
        uint64_t v27 = objc_alloc_init(HDCodableNanoSyncActivationRestore);
        objc_storeStrong((id *)(a1 + 8), v27);
        if (!PBReaderPlaceMark()
          || (HDCodableNanoSyncActivationRestoreReadFrom((uint64_t)v27, a2) & 1) == 0)
        {
          goto LABEL_53;
        }
        goto LABEL_45;
      case 0xAu:
        uint64_t v27 = objc_alloc_init(HDCodableSyncEntityVersionMap);
        objc_storeStrong((id *)(a1 + 32), v27);
        if (!PBReaderPlaceMark() || (HDCodableSyncEntityVersionMapReadFrom(v27, a2) & 1) == 0) {
          goto LABEL_53;
        }
        goto LABEL_45;
      case 0xBu:
        uint64_t v27 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 24), v27);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v27, a2))
        {
LABEL_45:
          PBReaderRecallMark();

LABEL_46:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_53:

        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_46;
    }
  }
}

uint64_t HDCodableNanoSyncStatusReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        uint64_t v23 = objc_alloc_init(HDCodableNanoSyncAnchor);
        [(id)a1 addAnchors:v23];
        if (!PBReaderPlaceMark() || (HDCodableNanoSyncAnchorReadFrom((uint64_t)v23, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else if ((v10 >> 3) == 1)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 20) |= 1u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_33;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_35;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_33:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v19) = 0;
        }
LABEL_35:
        *(_DWORD *)(a1 + 16) = v19;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableNanoSyncAnchorReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        uint64_t v24 = objc_alloc_init(HDCodableEntityIdentifier);
        objc_storeStrong((id *)(a1 + 16), v24);
        if (!PBReaderPlaceMark() || (HDCodableEntityIdentifierReadFrom((uint64_t)v24, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else if (v17 == 2)
      {
        char v25 = 0;
        unsigned int v26 = 0;
        uint64_t v27 = 0;
        *(unsigned char *)(a1 + 28) |= 1u;
        while (1)
        {
          uint64_t v28 = *v3;
          unint64_t v29 = *(void *)(a2 + v28);
          if (v29 == -1 || v29 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
          *(void *)(a2 + v28) = v29 + 1;
          v27 |= (unint64_t)(v30 & 0x7F) << v25;
          if ((v30 & 0x80) == 0) {
            goto LABEL_45;
          }
          v25 += 7;
          BOOL v14 = v26++ >= 9;
          if (v14)
          {
            uint64_t v27 = 0;
            goto LABEL_47;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_45:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v27 = 0;
        }
LABEL_47:
        *(void *)(a1 + 8) = v27;
      }
      else if (v17 == 1)
      {
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 28) |= 2u;
        while (1)
        {
          uint64_t v21 = *v3;
          unint64_t v22 = *(void *)(a2 + v21);
          if (v22 == -1 || v22 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v23 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0) {
            goto LABEL_41;
          }
          v18 += 7;
          BOOL v14 = v19++ >= 9;
          if (v14)
          {
            LODWORD(v20) = 0;
            goto LABEL_43;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_41:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v20) = 0;
        }
LABEL_43:
        *(_DWORD *)(a1 + 24) = v20;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

id HDNanoSyncDescriptionSafe(void *a1)
{
  id v1 = a1;
  if ([v1 conformsToProtocol:&unk_1F17FDA90])
  {
    id v2 = [v1 nanoSyncDescription];
  }
  else
  {
    id v3 = (objc_class *)objc_opt_class();

    id v2 = NSStringFromClass(v3);
  }

  return v2;
}

void sub_1BCBB109C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBB115C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCBB19B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1BCBB1C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBB20AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCBB2720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBB30F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HKWorkoutLocationBundle()
{
  if (qword_1EBA18E48 != -1) {
    dispatch_once(&qword_1EBA18E48, &__block_literal_global_215);
  }
  v0 = (void *)_MergedGlobals_224;

  return v0;
}

void __HKWorkoutLocationBundle_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28B50] bundleWithPath:@"/System/Library/LocationBundles/AppleWatchWorkout.bundle"];
  id v1 = (void *)_MergedGlobals_224;
  _MergedGlobals_224 = v0;
}

void HDSetHealthInUseDefaultWithReason(void *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [MEMORY[0x1E4F1CB18] standardUserDefaults];
  char v3 = [v2 BOOLForKey:@"HDHealthInUse"];

  if ((v3 & 1) == 0)
  {
    _HKInitializeLogging();
    uint64_t v4 = *MEMORY[0x1E4F29F28];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F28], OS_LOG_TYPE_DEBUG))
    {
      int v6 = 138543362;
      id v7 = v1;
      _os_log_debug_impl(&dword_1BCB7D000, v4, OS_LOG_TYPE_DEBUG, "Marking health as in use: %{public}@", (uint8_t *)&v6, 0xCu);
    }
    uint64_t v5 = [MEMORY[0x1E4F1CB18] standardUserDefaults];
    [v5 setValue:MEMORY[0x1E4F1CC38] forKey:@"HDHealthInUse"];
  }
}

void sub_1BCBB4384(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCBB442C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCBB4540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1BCBB46C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCBB4A58(_Unwind_Exception *a1, void *a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBB4CFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  char v10 = a3;
  id v7 = operator new(0x20uLL);
  *id v7 = &unk_1F171BA98;
  v7[1] = a2;
  v7[2] = &v10;
  v7[3] = a4;
  v11[3] = v7;
  uint64_t v8 = health::DataStore::performWriteTransactionWithLambda(a1, (uint64_t)v11);
  std::__function::__value_func<BOOL ()(health::DataStore::WriteTransaction &)>::~__value_func[abi:ne180100](v11);
  return v8;
}

void sub_1BCBB4DD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(health::DataStore::WriteTransaction &)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t health::DataStore::performWriteTransactionWithLambda(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x1E4F143B8];
  v4[0] = &unk_1F1727780;
  v4[1] = a1;
  v4[2] = a2;
  v4[3] = v4;
  uint64_t v2 = health::BlockAccessFile::performWriteTransactionWithLambda(a1, (uint64_t)v4);
  std::__function::__value_func<BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__value_func[abi:ne180100](v4);
  return v2;
}

void sub_1BCBB4E78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t health::BlockAccessFile::performWriteTransactionWithLambda(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x1E4F143B8];
  v4[0] = &unk_1F171F6F0;
  v4[1] = a1;
  v4[2] = a2;
  v4[3] = v4;
  uint64_t v2 = health::TransactionalFile::writeTransactionWithLambda(a1, (uint64_t)v4);
  std::__function::__value_func<BOOL ()(health::TransactionalFile::WriteTransaction &)>::~__value_func[abi:ne180100](v4);
  return v2;
}

void sub_1BCBB4F18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(health::TransactionalFile::WriteTransaction &)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t health::TransactionalFile::writeTransactionWithLambda(uint64_t a1, uint64_t a2)
{
  v27[4] = *MEMORY[0x1E4F143B8];
  v23.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 584);
  v23.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 584));
  if (!*(void *)(a1 + 328))
  {
    uint64_t v4 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v22, "isOpen()");
    std::string::basic_string[abi:ne180100]<0>(v21, "writeTransactionWithLambda");
    std::string::basic_string[abi:ne180100]<0>(v20, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"File has not yet been opened.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v4, (uint64_t)v22, (uint64_t)v21, (uint64_t)v20, 259, (uint64_t)&__p);
  }
  pthread_t v5 = pthread_self();
  pthread_t v18 = v5;
  int v6 = std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>(a1 + 768, (unint64_t)v5);
  if ((void *)(a1 + 776) != v6)
  {
    id v7 = v6;
    std::unique_lock<std::mutex>::unlock(&v23);
    uint64_t v8 = *(void *)(a2 + 24);
    if (!v8) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    if (((*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 48))(v8, v7[5]) & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Nested write transaction failed.");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    uint64_t v9 = 1;
    goto LABEL_13;
  }
  if ((void *)(a1 + 704) != std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>(a1 + 696, (unint64_t)v5))
  {
    uint64_t v15 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v15, "Unable to upgrade from a read transaction to a write transaction.");
    goto LABEL_20;
  }
  health::TransactionalFile::_transactionMutex_waitForAvailableWriteTransaction(a1, &v23);
  if (*(unsigned char *)(a1 + 344))
  {
    uint64_t v15 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v15, "Write transaction attempted after file was closed.");
LABEL_20:
    v15->__vftable = (std::runtime_error_vtbl *)&unk_1F171C6F8;
  }
  char v17 = 0;
  int v16 = (std::mutex *)(a1 + 416);
  uint64_t v10 = *(void *)(a1 + 376);
  int v11 = *(_DWORD *)(a1 + 408);
  unint64_t v12 = operator new(0x28uLL);
  *unint64_t v12 = &unk_1F171C430;
  v12[1] = a1;
  v12[2] = &v18;
  v12[3] = &v23;
  v12[4] = a2;
  v27[3] = v12;
  v26[0] = &unk_1F171C4C0;
  v26[1] = &v16;
  v26[2] = a1;
  v26[3] = v26;
  v25[0] = &unk_1F171C540;
  v25[1] = a1;
  v25[3] = v25;
  v24[0] = &unk_1F171C5C0;
  v24[1] = a1;
  v24[2] = &v16;
  v24[3] = v24;
  uint64_t v9 = health::WriteAheadLog::runWriteTransaction((health::WriteAheadLog *)(a1 + 16), v10, v11, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, (uint64_t)v24);
  std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v24);
  std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::~__value_func[abi:ne180100](v25);
  std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v26);
  std::__function::__value_func<BOOL ()(unsigned long long)>::~__value_func[abi:ne180100](v27);
  if (!v23.__owns_) {
    std::unique_lock<std::mutex>::lock(&v23);
  }
  std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::__erase_unique<std::__thread_id>((uint64_t **)(a1 + 768), (unint64_t)v18);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 648));
  if (v17) {
    std::mutex::unlock(v16);
  }
LABEL_13:
  if (v23.__owns_) {
    std::mutex::unlock(v23.__m_);
  }
  return v9;
}

void sub_1BCBB5304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::mutex *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::mutex *a28,char a29)
{
  if (a14) {
    std::mutex::unlock(a13);
  }
  if (a29) {
    std::mutex::unlock(a28);
  }
  _Unwind_Resume(exception_object);
}

void sub_1BCBB530C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::mutex *a28,char a29)
{
  __cxa_free_exception(v29);
  if (a29) {
    std::mutex::unlock(a28);
  }
  _Unwind_Resume(a1);
}

void sub_1BCBB5324(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  if (a2)
  {
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](&a30);
    std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::~__value_func[abi:ne180100]((void *)(v30 - 168));
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100]((void *)(v30 - 136));
    std::__function::__value_func<BOOL ()(unsigned long long)>::~__value_func[abi:ne180100]((void *)(v30 - 104));
    __cxa_begin_catch(a1);
    health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_1::operator()((uint64_t)&a10);
    __cxa_rethrow();
  }
  JUMPOUT(0x1BCBB5420);
}

void sub_1BCBB5370()
{
}

void sub_1BCBB538C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

off_t health::POSIXFile::size(health::POSIXFile *this)
{
  return lseek(*((_DWORD *)this + 2), 0, 2);
}

void std::unique_lock<std::mutex>::unlock(std::unique_lock<std::mutex> *this)
{
  if (this->__owns_)
  {
    std::mutex::unlock(this->__m_);
    this->__owns_ = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    health::POSIXFile::truncate(v2, v3);
  }
}

uint64_t health::POSIXFile::truncate(health::POSIXFile *this, char *a2)
{
  uint64_t v10 = a2;
  uint64_t result = ftruncate(*((_DWORD *)this + 2), (off_t)a2);
  if (result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v4 = *__error();
    pthread_t v5 = std::system_category();
    int v6 = __error();
    id v7 = __error();
    uint64_t v8 = strerror(*v7);
    health::FormatString<long long &,int &,char *>(&v9, &v10, (char **)v6, &v8);
    MEMORY[0x1C187B620](exception, v4, v5, &v9);
    __cxa_throw(exception, MEMORY[0x1E4FBA2F0], MEMORY[0x1E4FBA220]);
  }
  return result;
}

void sub_1BCBB5540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t health::VirtualFile::write<health::WriteAheadLog::LogHeader>(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  std::string v9 = 0;
  unint64_t v10 = 24;
  v6[0] = v8;
  v6[1] = v8;
  v6[2] = 24;
  LODWORD(v7) = *(_DWORD *)a2;
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)v6, &v7);
  LODWORD(v7) = *(_DWORD *)(a2 + 4);
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)v6, &v7);
  uint64_t v7 = *(void *)(a2 + 8);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v6, &v7);
  uint64_t v7 = *(void *)(a2 + 16);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v6, &v7);
  if (v10 <= 0x3FF) {
    uint64_t v4 = v8;
  }
  else {
    uint64_t v4 = v9;
  }
  (*(void (**)(uint64_t, void, unsigned char *))(*(void *)a1 + 24))(a1, 0, v4);
  uint64_t result = (uint64_t)v9;
  std::string v9 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBB56A8(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::SerializationBuffer::appendRaw<unsigned int>(uint64_t result, _DWORD *a2)
{
  if (*(void *)(result + 16) <= 3uLL)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "appendRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Append would overflow serialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 35, (uint64_t)&__p);
  }
  **(_DWORD **)(result + 8) = *a2;
  uint64_t v3 = *(void *)(result + 16) - 4;
  *(void *)(result + 8) += 4;
  *(void *)(result + 16) = v3;
  return result;
}

void sub_1BCBB57DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::SerializationBuffer::appendRaw<unsigned long long>(uint64_t result, void *a2)
{
  if (*(void *)(result + 16) <= 7uLL)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "appendRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Append would overflow serialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 35, (uint64_t)&__p);
  }
  **(void **)(result + 8) = *a2;
  uint64_t v3 = *(void *)(result + 16) - 8;
  *(void *)(result + 8) += 8;
  *(void *)(result + 16) = v3;
  return result;
}

void sub_1BCBB5944(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

ssize_t health::POSIXFile::write(health::POSIXFile *this, char *a2, const unsigned __int8 *__buf, char *__nbyte)
{
  unint64_t v12 = __nbyte;
  char v13 = a2;
  ssize_t result = pwrite(*((_DWORD *)this + 2), __buf, (size_t)__nbyte, (off_t)a2);
  if (result < 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v6 = *__error();
    uint64_t v7 = std::system_category();
    uint64_t v8 = __error();
    std::string v9 = __error();
    unint64_t v10 = strerror(*v9);
    health::FormatString<unsigned long &,long long &,int &,char *>(&v11, (std::string *)"Error occurred writing {0} bytes at {1}: {2} {3}", &v12, &v13, (char **)v8, &v10);
    MEMORY[0x1C187B620](exception, v6, v7, &v11);
    __cxa_throw(exception, MEMORY[0x1E4FBA2F0], MEMORY[0x1E4FBA220]);
  }
  return result;
}

void sub_1BCBB5A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

unint64_t health::VirtualFile::write<health::WriteAheadLog::LogEntryHeader>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  unint64_t v16 = 36;
  unint64_t v10 = (health *)v14;
  std::string v11 = v14;
  uint64_t v12 = 36;
  LODWORD(v13) = *(_DWORD *)a3;
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)&v10, &v13);
  uint64_t v13 = *(void *)(a3 + 8);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)&v10, &v13);
  uint64_t v13 = *(void *)(a3 + 16);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)&v10, &v13);
  uint64_t v13 = *(void *)(a3 + 24);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)&v10, &v13);
  LODWORD(v13) = *(_DWORD *)(a3 + 32);
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)&v10, &v13);
  LODWORD(v13) = health::FletcherChecksum(v10, (char *)(v11 - (unsigned char *)v10));
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)&v10, &v13);
  unint64_t v6 = v16;
  if (v16 <= 0x3FF) {
    uint64_t v7 = v14;
  }
  else {
    uint64_t v7 = v15;
  }
  (*(void (**)(uint64_t, uint64_t, unsigned char *, unint64_t))(*(void *)a1 + 24))(a1, a2, v7, v16);
  uint64_t v8 = v15;
  uint64_t v15 = 0;
  if (v8) {
    MEMORY[0x1C187B880](v8, 0x1000C8077774924);
  }
  return v6;
}

void sub_1BCBB5C2C(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::FletcherChecksum(health *this, char *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = 0;
  unint64_t v3 = 0;
  unint64_t v4 = 0;
  do
  {
    if ((unint64_t)a2 >= 0x16A0A9A) {
      uint64_t v5 = 23726746;
    }
    else {
      uint64_t v5 = (uint64_t)a2;
    }
    unint64_t v6 = (unsigned __int8 *)this + v2;
    uint64_t v7 = v5;
    do
    {
      unsigned int v8 = *v6++;
      v4 += v8;
      v3 += v4;
      --v7;
    }
    while (v7);
    v2 += v5;
    v4 %= 0xFFFFuLL;
    v3 %= 0xFFFFuLL;
    a2 -= v5;
  }
  while (a2);
  return v3 | (v4 << 16);
}

char **std::deque<health::BlockPointer>::deque(char **a1, void *a2)
{
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v3 = a2[4];
  uint64_t v4 = a2[1];
  uint64_t v5 = (char *)(v4 + 8 * (v3 >> 8));
  if (a2[2] == v4)
  {
    unint64_t v6 = 0;
    uint64_t v9 = 0;
    unsigned int v8 = (char *)(v4 + 8 * ((a2[5] + v3) >> 8));
  }
  else
  {
    unint64_t v6 = (long long *)(*(void *)v5 + 16 * v3);
    unint64_t v7 = a2[5] + v3;
    unsigned int v8 = (char *)(v4 + 8 * (v7 >> 8));
    uint64_t v9 = *(void *)v8 + 16 * v7;
  }
  if ((long long *)v9 != v6)
  {
    uint64_t v10 = ((v9 - *(void *)v8) >> 4) + 32 * (v8 - v5);
    uint64_t v11 = (uint64_t)v6 - *(void *)v5;
    uint64_t v12 = v10 - (v11 >> 4);
    if (v10 != v11 >> 4)
    {
      if ((_BYTE)v12 == 0xFF) {
        unint64_t v14 = (unint64_t)(v12 + 1) >> 8;
      }
      else {
        unint64_t v14 = ((unint64_t)(v12 + 1) >> 8) + 1;
      }
      if (v14)
      {
        unsigned int v43 = a1 + 3;
        unint64_t v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>((uint64_t)(a1 + 3), v14);
        char v41 = v40;
        *(void *)&long long v42 = v40;
        *((void *)&v42 + 1) = &v40[8 * v15];
        uint64_t v16 = -(uint64_t)v14;
        do
        {
          uint64_t v39 = operator new(0x1000uLL);
          std::__split_buffer<health::BlockPointer *>::push_back(&v40, &v39);
        }
        while (!__CFADD__(v16++, 1));
        pthread_t v18 = a1[2];
        uint64_t v19 = -7 - (void)v18;
        while (v18 != a1[1])
        {
          v18 -= 8;
          v19 += 8;
          std::__split_buffer<health::BlockPointer *>::push_front((uint64_t)&v40, v18);
        }
        uint64_t v20 = *a1;
        uint64_t v21 = v41;
        *a1 = v40;
        a1[1] = v21;
        unint64_t v40 = v20;
        char v41 = v18;
        unint64_t v22 = (char *)v42;
        long long v23 = *((_OWORD *)a1 + 1);
        *((_OWORD *)a1 + 1) = v42;
        long long v42 = v23;
        if (v18 != (char *)v23) {
          *(void *)&long long v42 = v23 + (-(v23 + v19) & 0xFFFFFFFFFFFFFFF8);
        }
        if (v20)
        {
          operator delete(v20);
          uint64_t v24 = a1[4];
          uint64_t v21 = a1[1];
          char v25 = a1[2];
        }
        else
        {
          uint64_t v24 = a1[4];
          char v25 = v22;
        }
        uint64_t v27 = a1[5];
        unsigned __int8 v29 = (_BYTE)v24 + (_BYTE)v27;
        uint64_t v28 = &v21[8 * ((unint64_t)&v27[(void)v24] >> 8)];
        if (v25 == v21) {
          uint64_t v26 = 0;
        }
        else {
          uint64_t v26 = *(void *)v28 + 16 * v29;
        }
      }
      else
      {
        uint64_t v26 = 0;
        uint64_t v27 = 0;
        uint64_t v28 = 0;
      }
      uint64_t v30 = v12 + ((v26 - *(void *)v28) >> 4);
      if (v30 < 1)
      {
        unint64_t v32 = 255 - v30;
        LOBYTE(v30) = ~(-1 - v30);
        unsigned int v31 = &v28[-8 * (v32 >> 8)];
      }
      else
      {
        unsigned int v31 = &v28[8 * ((unint64_t)v30 >> 8)];
      }
      uint64_t v33 = *(void *)v31 + 16 * v30;
      while (v26 != v33)
      {
        uint64_t v34 = v33;
        if (v28 != v31) {
          uint64_t v34 = *(void *)v28 + 4096;
        }
        if (v26 == v34)
        {
          uint64_t v34 = v26;
        }
        else
        {
          uint64_t v35 = (_OWORD *)v26;
          do
          {
            long long v36 = *v6++;
            *uint64_t v35 = v36;
            if ((long long *)((char *)v6 - *(void *)v5) == (long long *)4096)
            {
              unsigned int v37 = (long long *)*((void *)v5 + 1);
              v5 += 8;
              unint64_t v6 = v37;
            }
            ++v35;
          }
          while (v35 != (_OWORD *)v34);
          uint64_t v27 = a1[5];
        }
        v27 += (v34 - v26) >> 4;
        a1[5] = v27;
        if (v28 == v31) {
          break;
        }
        uint64_t v38 = *((void *)v28 + 1);
        v28 += 8;
        uint64_t v26 = v38;
      }
    }
  }
  return a1;
}

void sub_1BCBB5F70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  std::__split_buffer<std::__thread_id *>::~__split_buffer(v12);
  _Unwind_Resume(a1);
}

uint64_t health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::loadHistoryRoot(uint64_t a1, ObjectIdentifier *a2, int a3)
{
  *(ObjectIdentifier *)(a1 + 72) = *a2;
  if (!health::DataStore::ReadTransaction::retrieveObjectWithIdentifier<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(*(health::DataStore::ReadTransaction **)(a1 + 96), (void *)a1, a2))
  {
    if (!a3)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      _ZN6health15not_found_errorCI1St13runtime_errorEPKc(exception, "The requested sample history does not exist.");
    }
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 48) = 0;
    health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::_updateHistoryRoot(a1);
  }
  return 1;
}

void sub_1BCBB6080(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL health::DataStore::ReadTransaction::retrieveObjectWithIdentifier<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(health::DataStore::ReadTransaction *a1, void *a2, ObjectIdentifier *a3)
{
  health::DataStore::ReadTransaction::_pointerForObject(a1, a3, (uint64_t)v9);
  int v5 = v10;
  if (v10)
  {
    unint64_t v6 = (uint64_t *)*((void *)a1 + 3);
    unint64_t v7 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v9);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v6, *v7, v7[1], a2);
  }
  return v5 != 0;
}

double health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>@<D0>(uint64_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v8 = a1[2];
  bzero(v10, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v8 + 16), *a1, a1[1], (uint64_t)v10);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>((uint64_t)a1, 0, (uint64_t)v10, a2, a3, a4);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  unint64_t v14 = 547;
  health::RawBuffer::RawBuffer(v11, v12, 547);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  uint64_t v8 = v12;
  if (v14 > 0x3FF) {
    uint64_t v8 = v13;
  }
  v10[0] = v8;
  v10[1] = v8;
  v10[2] = 547;
  health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  uint64_t result = (uint64_t)v13;
  uint64_t v13 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBB626C(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void *health::RawBuffer::RawBuffer(void *this, unsigned __int8 *a2, uint64_t a3)
{
  *this = a2;
  this[1] = a3;
  if (!a2)
  {
    if (a3)
    {
      unint64_t v3 = (void *)*MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v7, "_buffer != nullptr || _length == 0");
      std::string::basic_string[abi:ne180100]<0>(v6, "RawBuffer");
      std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
      health::FormatString<>((std::string *)"Unable to create a raw buffer of length > 0 at nullptr", &__p);
      health::_HDAssertImplementation<std::out_of_range>(v3, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 27, (uint64_t)&__p);
    }
  }
  return this;
}

void sub_1BCBB637C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 17) < 0) {
    operator delete(*(void **)(v26 - 40));
  }
  _Unwind_Resume(exception_object);
}

void health::TransactionalFile::ReadTransaction::readBufferAtOffset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  health::RawBuffer::RawBuffer(v6, *(unsigned __int8 **)a2, *(void *)(a2 + 8));
  health::TransactionalFile::_readBufferAtOffset(v4, v5, (health::RawBuffer *)v6, a3);
}

double health::WriteAheadLog::Transaction::pageAtOffset@<D0>(health::WriteAheadLog::Transaction *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = (void *)*((void *)this + 5);
  if (v3)
  {
    uint64_t v4 = (void *)((char *)this + 40);
    do
    {
      unint64_t v5 = v3[4];
      BOOL v6 = v5 >= a2;
      if (v5 >= a2) {
        unint64_t v7 = v3;
      }
      else {
        unint64_t v7 = v3 + 1;
      }
      if (v6) {
        uint64_t v4 = v3;
      }
      unint64_t v3 = (void *)*v7;
    }
    while (*v7);
    if (v4 != (void *)((char *)this + 40) && v4[4] <= a2) {
      health::_PageForEntry((uint64_t *)this + 1, a2, (uint64_t)(v4 + 5), (void *)a3);
    }
  }
  double result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  return result;
}

uint64_t health::TransactionalCache<unsigned long long,health::FilePage>::_touchCacheEntry(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 56) != a2 || *(void *)(result + 64) != a2)
  {
    uint64_t v2 = *(void *)(a2 + 88);
    if (v2)
    {
      uint64_t v3 = *(void *)(v2 + 88);
      uint64_t v4 = *(void *)(a2 + 80);
      if (v3) {
        *(void *)(v3 + 80) = a2;
      }
      *(void *)(v2 + 80) = v4;
      *(void *)(v2 + 88) = a2;
      *(void *)(a2 + 80) = v2;
      *(void *)(a2 + 88) = v3;
      if (v4)
      {
        *(void *)(v4 + 88) = v2;
        uint64_t v3 = *(void *)(a2 + 88);
      }
      if (!v3) {
        *(void *)(result + 56) = a2;
      }
      if (!*(void *)(v2 + 80)) {
        *(void *)(result + 64) = v2;
      }
    }
  }
  return result;
}

uint64_t health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::operator->(uint64_t result)
{
  if (!*(unsigned char *)(result + 56))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempt to indirect through to the value of an invalid optional.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  return result;
}

void sub_1BCBB6550(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *health::RawBuffer::slice@<X0>(health::RawBuffer *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if ((unint64_t)(a3 + a2) > *((void *)this + 1))
  {
    uint64_t v4 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v9, "(start + length) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v8, "slice");
    std::string::basic_string[abi:ne180100]<0>(v7, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
    health::FormatString<>((std::string *)"Slice extends beyond end of buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v4, (uint64_t)v9, (uint64_t)v8, (uint64_t)v7, 61, (uint64_t)&__p);
  }
  return health::RawBuffer::RawBuffer(a4, (unsigned __int8 *)(*(void *)this + a2), a3);
}

void sub_1BCBB6674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

void *health::FilePage::slice@<X0>(health::FilePage *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  if (*(void *)this > a2)
  {
    uint64_t v7 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v24, "offset >= _offset");
    std::string::basic_string[abi:ne180100]<0>(v23, "slice");
    std::string::basic_string[abi:ne180100]<0>(v22, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDFilePage.h");
    health::FormatString<>((std::string *)"Attempt to slice starting before the page start.", &v21);
    health::_HDAssertImplementation<std::out_of_range>(v7, (uint64_t)v24, (uint64_t)v23, (uint64_t)v22, 82, (uint64_t)&v21);
  }
  unint64_t v8 = a2 - *(void *)this;
  if (*((void *)this + 1) - v8 < a3)
  {
    uint64_t v9 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v20, "length <= (_length - localOffset)");
    std::string::basic_string[abi:ne180100]<0>(v19, "slice");
    std::string::basic_string[abi:ne180100]<0>(v18, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDFilePage.h");
    health::FormatString<>((std::string *)"Attempt to slice beyond page end", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v9, (uint64_t)v20, (uint64_t)v19, (uint64_t)v18, 84, (uint64_t)&__p);
  }
  uint64_t v10 = *((void *)this + 2);
  if (!v10)
  {
    uint64_t v10 = (*(uint64_t (**)(void))(**((void **)this + 4) + 16))(*((void *)this + 4));
    if (!v10)
    {
      uint64_t v11 = *MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v16, "rawBytes != nullptr");
      std::string::basic_string[abi:ne180100]<0>(v15, "slice");
      std::string::basic_string[abi:ne180100]<0>(v14, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDFilePage.h");
      health::FormatString<>((std::string *)"Attempt to slice an invalid page.", &v13);
      health::_HDAssertImplementation<std::out_of_range>(v11, (uint64_t)v16, (uint64_t)v15, (uint64_t)v14, 86, (uint64_t)&v13);
    }
  }
  return health::RawBuffer::RawBuffer(a4, (unsigned __int8 *)(v10 + v8), a3);
}

void sub_1BCBB697C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,char a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

void *health::RawBuffer::copyFrom(health::RawBuffer *this, const health::RawBuffer *a2)
{
  if (*((void *)a2 + 1) != *((void *)this + 1))
  {
    uint64_t v2 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v17, "source._length == _length");
    std::string::basic_string[abi:ne180100]<0>(v16, "copyFrom");
    std::string::basic_string[abi:ne180100]<0>(v15, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
    health::FormatString<>((std::string *)"Cannot copy buffers of unequal sizes.", &v14);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v17, (uint64_t)v16, (uint64_t)v15, 73, (uint64_t)&v14);
  }
  if (!*(void *)this)
  {
    uint64_t v3 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v13, "_buffer != nullptr");
    std::string::basic_string[abi:ne180100]<0>(v12, "copyFrom");
    std::string::basic_string[abi:ne180100]<0>(v11, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
    health::FormatString<>((std::string *)"Canot copy to an invalid buffer.", &__p);
    health::_HDAssertImplementation<std::logic_error>(v3, (uint64_t)v13, (uint64_t)v12, (uint64_t)v11, 74, (uint64_t)&__p);
  }
  if (!*(void *)a2)
  {
    uint64_t v4 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v9, "source._buffer != nullptr");
    std::string::basic_string[abi:ne180100]<0>(v8, "copyFrom");
    std::string::basic_string[abi:ne180100]<0>(v7, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
    health::FormatString<>((std::string *)"Cannot copy from an invalid buffer.", &v6);
    health::_HDAssertImplementation<std::logic_error>(v4, (uint64_t)v9, (uint64_t)v8, (uint64_t)v7, 75, (uint64_t)&v6);
  }
  return memcpy(*(void **)this, *(const void **)a2, *((void *)this + 1));
}

void sub_1BCBB6CF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x11)
  {
    uint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 32 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  void v7[2];

  if (a2 >= 0x11)
  {
    uint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 32 * a2;
}

void sub_1BCBB6EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

void *health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((unint64_t)(a5 + a2) >= 0x12)
  {
    unint64_t v5 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v15, "destinationIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v14, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow destination.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 79, (uint64_t)&__p);
  }
  if ((unint64_t)(a5 + a4) >= 0x12)
  {
    std::string v6 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v11, "sourceIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v10, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow source.", &v8);
    health::_HDAssertImplementation<std::out_of_range>(v6, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 80, (uint64_t)&v8);
  }
  return memcpy((void *)(a1 + 32 * a2), (const void *)(a3 + 32 * a4), 32 * a5);
}

void sub_1BCBB7128(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

void *health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::deleteElementAtIndex(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x11)
  {
    uint64_t v2 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "deleteElementAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 65, (uint64_t)&__p);
  }
  return memmove((void *)(a1 + 32 * a2), (const void *)(a1 + 32 * a2 + 32), 512 - 32 * a2);
}

void sub_1BCBB72E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

__n128 health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(uint64_t a1, __n128 *a2, unint64_t a3)
{
  if (a3 >= 0x11)
  {
    uint64_t v4 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v10, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v9, "insertElementAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v8, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v4, (uint64_t)v10, (uint64_t)v9, (uint64_t)v8, 57, (uint64_t)&__p);
  }
  unint64_t v5 = (__n128 *)(a1 + 32 * a3);
  memmove(&v5[2], v5, 512 - 32 * a3);
  __n128 result = a2[1];
  *unint64_t v5 = *a2;
  v5[1] = result;
  return result;
}

void sub_1BCBB7450(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::DeserializationBuffer::extractRaw<long long>(uint64_t result, void *a2)
{
  if (*(void *)(result + 16) <= 7uLL)
  {
    uint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(void **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - 8;
  *(void *)(result + 8) += 8;
  *(void *)(result + 16) = v3;
  return result;
}

void sub_1BCBB75B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::DeserializationBuffer::extractRaw<unsigned long long>(uint64_t result, void *a2)
{
  if (*(void *)(result + 16) <= 7uLL)
  {
    uint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(void **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - 8;
  *(void *)(result + 8) += 8;
  *(void *)(result + 16) = v3;
  return result;
}

void sub_1BCBB7720(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::DeserializationBuffer::extractRaw<unsigned short>(uint64_t result, _WORD *a2)
{
  if (*(void *)(result + 16) <= 1uLL)
  {
    uint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(_WORD **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - 2;
  *(void *)(result + 8) += 2;
  *(void *)(result + 16) = v3;
  return result;
}

void sub_1BCBB7888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::DeserializationBuffer::extractRaw<unsigned char>(uint64_t result, unsigned char *a2)
{
  if (!*(void *)(result + 16))
  {
    uint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(unsigned char **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - 1;
  ++*(void *)(result + 8);
  *(void *)(result + 16) = v3;
  return result;
}

void sub_1BCBB79EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(uint64_t a1, void *a2)
{
  if (!*(_WORD *)(a1 + 544))
  {
    uint64_t v4 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v11, "childCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v10, "childForKey");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for child for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v4, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 58, (uint64_t)&__p);
  }
  if (*(_WORD *)(a1 + 544) == 1)
  {
LABEL_9:
    LOWORD(v5) = 0;
  }
  else
  {
    unint64_t v5 = (unsigned __int16)(*(_WORD *)(a1 + 544) - 1);
    while (1)
    {
      std::string v6 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, v5);
      if (*a2 > *v6 || *a2 >= *v6 && a2[1] >= v6[1]) {
        break;
      }
      if (!(_WORD)--v5) {
        goto LABEL_9;
      }
    }
  }
  return (unsigned __int16)v5;
}

void sub_1BCBB7B8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

void sub_1BCBB7CD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  std::string v13 = 0;
  unint64_t v14 = 578;
  health::RawBuffer::RawBuffer(v11, v12, 578);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  std::string v8 = v12;
  if (v14 > 0x3FF) {
    std::string v8 = v13;
  }
  v10[0] = v8;
  v10[1] = v8;
  void v10[2] = 578;
  health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  uint64_t result = (uint64_t)v13;
  std::string v13 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBB7E28(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::indexForKey(uint64_t a1, void *a2)
{
  int v4 = *(unsigned __int16 *)(a1 + 544);
  if (!*(_WORD *)(a1 + 544))
  {
    unint64_t v5 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v15, "valueCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v14, "indexForKey");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for index for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 72, (uint64_t)&__p);
  }
  unsigned int v6 = v4 - 1;
  while (1)
  {
    LOWORD(v4) = v4 - 1;
    uint64_t v7 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, v6);
    if (*a2 > *v7 || *a2 >= *v7 && a2[1] > v7[1])
    {
      uint64_t v10 = 0x200000000;
      return v10 | (unsigned __int16)v4;
    }
    std::string v8 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, v6);
    if (*a2 == *v8 && a2[1] == v8[1]) {
      break;
    }
    if (!(unsigned __int16)v6--)
    {
      LOWORD(v4) = 0;
      uint64_t v10 = 0x100000000;
      return v10 | (unsigned __int16)v4;
    }
  }
  uint64_t v10 = 0;
  LOWORD(v4) = v6;
  return v10 | (unsigned __int16)v4;
}

void sub_1BCBB7FE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::DataStore::WriteTransaction::storeObjectWithIdentifier<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(uint64_t a1, uint64_t *a2, __n128 *a3)
{
  long long v18 = *(_OWORD *)(a1 + 32);
  uint64_t v19 = a1 + 48;
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v18, a3, 0, v16);
  if (v17)
  {
    uint64_t v6 = *(void *)(health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v16)
                   + 24);
    uint64_t v7 = (health::BlockAccessFile::WriteTransaction *)(a1 + 80);
    uint64_t v8 = health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v16);
    unint64_t v9 = *(void *)(v8 + 16);
    unint64_t v10 = *(void *)(v8 + 24);
    if (v6 == 56) {
      return health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>((uint64_t)v7, v9, v10, a2);
    }
    health::BlockAccessFile::WriteTransaction::freeBlock((uint64_t)v7, v9, v10);
  }
  else
  {
    uint64_t v7 = (health::BlockAccessFile::WriteTransaction *)(a1 + 80);
  }
  unint64_t v12 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v7, 56);
  unint64_t v14 = v13;
  health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>((uint64_t)v7, v12, v13, a2);
  v15.n128_u64[0] = v12;
  v15.n128_u64[1] = v14;
  return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey((uint64_t *)&v18, a3, &v15);
}

double health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>@<D0>(uint64_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v8 = a1[2];
  bzero(v10, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v8 + 24), *a1, a1[1], (uint64_t)v10);
  return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>((uint64_t)a1, 0, (uint64_t)v10, a2, a3, a4);
}

uint64_t health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(health::BlockAccessFile::WriteTransaction *this, uint64_t a2)
{
  uint64_t v9 = a2;
  int v10 = 0;
  uint64_t v4 = *((void *)this + 3);
  unsigned int v5 = *(_DWORD *)(v4 + 4);
  if (!*((unsigned char *)this + 48)) {
    *((unsigned char *)this + 48) = 0;
  }
  if (v5 <= 1) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = a2 + 12;
  }
  uint64_t v7 = *(void *)(v4 + 16);
  *(void *)(v4 + 16) = v7 + v6;
  health::TransactionalFile::WriteTransaction::storeObjectAtOffset<health::BlockAccessFile::BlockAccessFileHeader &>(*((health::TransactionalFile::WriteTransaction **)this + 2), v4, 0);
  health::TransactionalFile::WriteTransaction::storeObjectAtOffset<health::BlockAccessFile::BlockHeader &>(*((health::TransactionalFile::WriteTransaction **)this + 2), (uint64_t)&v9, v7);
  return v7;
}

uint64_t health::TransactionalFile::ReadTransaction::readObjectAtOffset<health::BTreeNode<unsigned long long,health::BlockAccessFile::FreeSpaceList,unsigned long long,17>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  health::SmartBuffer::SmartBuffer((uint64_t)v19, 0x6F2uLL);
  if (v21 <= 0x3FF) {
    uint64_t v6 = v19;
  }
  else {
    uint64_t v6 = v20;
  }
  v17[0] = v6;
  v17[1] = v6;
  void v17[2] = 1778;
  health::RawBuffer::RawBuffer(v16, v6, v21);
  health::RawBuffer::RawBuffer(v15, v16[0], (uint64_t)v16[1]);
  uint64_t v9 = a1 + 8;
  unint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(v9 + 8);
  health::RawBuffer::RawBuffer(v18, v15[0], (uint64_t)v15[1]);
  health::TransactionalFile::_readBufferAtOffset(v8, v7, (health::RawBuffer *)v18, a3);
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v11 = (void *)health::StaticArray<health::BTreeNode<unsigned long long,health::BlockAccessFile::FreeSpaceList,unsigned long long,17>::ValueEntry,17ul>::operator[](a2, i);
    v18[0] = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v17, v18);
    *uint64_t v11 = v18[0];
    health::BlockAccessFile::FreeSpaceList::deserialize((uint64_t)(v11 + 1), (uint64_t)v17);
  }
  for (unint64_t j = 0; j != 18; ++j)
  {
    uint64_t v13 = (void *)health::StaticArray<unsigned long long,18ul>::operator[](a2 + 1632, j);
    v18[0] = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v17, v18);
    *uint64_t v13 = v18[0];
  }
  LOWORD(v18[0]) = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>((uint64_t)v17, v18);
  *(_WORD *)(a2 + 1776) = v18[0];
  uint64_t result = (uint64_t)v20;
  uint64_t v20 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBB83CC(_Unwind_Exception *a1)
{
}

uint64_t health::StaticArray<health::BTreeNode<unsigned long long,health::BlockAccessFile::FreeSpaceList,unsigned long long,17>::ValueEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x11)
  {
    uint64_t v2 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 96 * a2;
}

void sub_1BCBB84F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::StaticArray<unsigned long long,10ul>::operator[](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xA)
  {
    uint64_t v2 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 8 * a2;
}

void sub_1BCBB8640(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::StaticArray<unsigned long long,18ul>::operator[](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x12)
  {
    uint64_t v2 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 8 * a2;
}

void sub_1BCBB878C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::WriteTransaction::_allocateBlockOfLength(health::BlockAccessFile::WriteTransaction *this, uint64_t a2)
{
  unsigned int v5 = (char *)this + 16;
  uint64_t v3 = (health::TransactionalFile::WriteTransaction *)*((void *)this + 2);
  uint64_t v4 = *((void *)v5 + 1);
  uint64_t v6 = *(void *)(v4 + 16);
  *(void *)(v4 + 16) = v6 + a2;
  health::TransactionalFile::WriteTransaction::storeObjectAtOffset<health::BlockAccessFile::BlockAccessFileHeader &>(v3, v4, 0);
  return v6;
}

uint64_t health::TransactionalFile::WriteTransaction::storeObjectAtOffset<health::BlockAccessFile::BlockAccessFileHeader &>(health::TransactionalFile::WriteTransaction *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v10 = 0;
  unint64_t v11 = 68;
  v8[0] = v9;
  v8[1] = v9;
  v8[2] = 68;
  health::BlockAccessFile::BlockAccessFileHeader::serialize(a2, (uint64_t)v8);
  if (v11 <= 0x3FF) {
    unsigned int v5 = v9;
  }
  else {
    unsigned int v5 = v10;
  }
  health::RawBuffer::RawBuffer(v7, v5, v11);
  health::TransactionalFile::WriteTransaction::writeBufferAtOffset(a1, (const health::RawBuffer *)v7, a3);
  uint64_t result = (uint64_t)v10;
  int v10 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBB8900(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void health::TransactionalFile::WriteTransaction::writeBufferAtOffset(health::TransactionalFile::WriteTransaction *this, const health::RawBuffer *a2, uint64_t a3)
{
  health::TransactionalFile::_writeBufferAtOffset(*((health::TransactionalFile **)this + 4), *((void *)this + 1), a2, a3);
  unint64_t v6 = *((void *)a2 + 1) + a3 + *((void *)this + 3);
  if (v6 > *((void *)this + 5)) {
    *((void *)this + 5) = v6;
  }
}

void health::FilePage::copy(health::FilePage *this, void *a2)
{
  uint64_t v2 = a2[1];
  *(void *)this = *a2;
  *((void *)this + 1) = v2;
  operator new[]();
}

void sub_1BCBB8B10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v27 - 33) < 0) {
    operator delete(*(void **)(v27 - 56));
  }
  health::FilePage::~FilePage(v26);
  _Unwind_Resume(a1);
}

void health::TransactionalCache<unsigned long long,health::FilePage>::setValueForKey(void *a1, unint64_t a2, unint64_t *a3, long long *a4, unint64_t a5, int a6)
{
  uint64_t v12 = a1 + 2;
  uint64_t v13 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a1 + 2, *a3, a3);
  for (unint64_t i = (uint64_t *)v13[3]; ; ++i)
  {
    if (i == (uint64_t *)v13[4])
    {
      uint64_t v15 = *((void *)a4 + 3);
      if (v15) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v16 = *((void *)a4 + 5);
      if (v16) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a1 >= a5) {
        unint64_t v17 = *a1 - a5;
      }
      else {
        unint64_t v17 = 0;
      }
      uint64_t v18 = a1[8];
      if (!v18)
      {
LABEL_21:
        uint64_t v24 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v12, *a3, a3);
        uint64_t v26 = v24[3];
        for (uint64_t j = v24[4]; v26 != j; v26 += 8)
        {
          if (*(void *)(*(void *)v26 + 8) > a2) {
            break;
          }
        }
        operator new();
      }
      while (1)
      {
        unint64_t v19 = a1[1];
        if (v19 <= v17) {
          goto LABEL_21;
        }
        uint64_t v20 = *(void *)(v18 + 88);
        if (!*(_DWORD *)v18) {
          goto LABEL_18;
        }
        uint64_t v21 = a1[12];
        if (!v21) {
          goto LABEL_18;
        }
        v56[0] = *(void *)(v18 + 8);
        if ((*(unsigned int (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)v21 + 48))(v21, v56, v18 + 24, v18 + 32))
        {
          break;
        }
LABEL_20:
        uint64_t v18 = v20;
        if (!v20) {
          goto LABEL_21;
        }
      }
      unint64_t v19 = a1[1];
LABEL_18:
      a1[1] = v19 - *(void *)(v18 + 16);
      health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)a1, v18);
      unint64_t v22 = *(void *)(v18 + 24);
      v56[0] = v22;
      long long v23 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v12, v22, v56);
      health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry((uint64_t)(v23 + 3), v18);
      if (v23[4] == v23[3]) {
        std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>(v12, v22);
      }
      goto LABEL_20;
    }
    if (*(void *)(*i + 8) == a2) {
      break;
    }
  }
  long long v50 = *a4;
  uint64_t v28 = *((void *)a4 + 2);
  uint64_t v27 = (std::__shared_weak_count *)*((void *)a4 + 3);
  unint64_t v51 = v27;
  if (v27) {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v30 = *((void *)a4 + 4);
  unsigned __int8 v29 = (std::__shared_weak_count *)*((void *)a4 + 5);
  char v52 = v29;
  if (v29) {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a6 != 1 && *(_DWORD *)*i)
  {
    uint64_t v31 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v56, "(state == CacheEntryState::Dirty) || (entry->state == CacheEntryState::Clean)");
    std::string::basic_string[abi:ne180100]<0>(&v55, "_replaceValueForEntry");
    std::string::basic_string[abi:ne180100]<0>(v54, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDTransactionalCache.hpp");
    health::FormatString<>((std::string *)"Unable to replace a dirty entry with a clean one.", &__p);
    health::_HDAssertImplementation<std::logic_error>(v31, (uint64_t)v56, (uint64_t)&v55, (uint64_t)v54, 89, (uint64_t)&__p);
  }
  uint64_t v32 = v28;
  int v33 = a6;
  unint64_t v34 = a5;
  uint64_t v35 = (void *)*i;
  unint64_t v36 = *(void *)(*i + 16);
  *(_OWORD *)(*i + 32) = v50;
  if (v27) {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v37 = (std::__shared_weak_count *)v35[7];
  v35[6] = v32;
  v35[7] = v27;
  if (v37) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v37);
  }
  if (v29) {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v38 = (std::__shared_weak_count *)v35[9];
  v35[8] = v30;
  v35[9] = v29;
  if (v38) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v38);
  }
  uint64_t v39 = *i;
  *(void *)(v39 + 16) = v34;
  *(_DWORD *)uint64_t v39 = v33;
  health::TransactionalCache<unsigned long long,health::FilePage>::_touchCacheEntry((uint64_t)a1, v39);
  if (v36 != v34)
  {
    unint64_t v40 = a1[1];
    BOOL v41 = v40 >= v36;
    unint64_t v42 = v40 - v36;
    if (!v41) {
      unint64_t v42 = 0;
    }
    a1[1] = v42 + v34;
    uint64_t v43 = a1[8];
    if (v43)
    {
      unint64_t v44 = *a1;
      while (1)
      {
        unint64_t v45 = a1[1];
        if (v45 <= v44)
        {
LABEL_53:
          unsigned __int8 v29 = v52;
          goto LABEL_54;
        }
        uint64_t v46 = *(void *)(v43 + 88);
        if (!*(_DWORD *)v43) {
          goto LABEL_50;
        }
        uint64_t v47 = a1[12];
        if (!v47) {
          goto LABEL_50;
        }
        v57[0] = *(void *)(v43 + 8);
        if ((*(unsigned int (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)v47 + 48))(v47, v57, v43 + 24, v43 + 32))
        {
          break;
        }
LABEL_52:
        uint64_t v43 = v46;
        if (!v46) {
          goto LABEL_53;
        }
      }
      unint64_t v45 = a1[1];
LABEL_50:
      a1[1] = v45 - *(void *)(v43 + 16);
      health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)a1, v43);
      unint64_t v48 = *(void *)(v43 + 24);
      v57[0] = v48;
      uint64_t v49 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v12, v48, v57);
      health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry((uint64_t)(v49 + 3), v43);
      if (v49[4] == v49[3]) {
        std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>(v12, v48);
      }
      goto LABEL_52;
    }
  }
LABEL_54:
  if (v29) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  }
  if (v51) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v51);
  }
}

void sub_1BCBB9334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  std::__split_buffer<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::~__split_buffer((uint64_t)&a36);
  uint64_t v42 = (uint64_t)a30;
  a30 = 0;
  if (v42) {
    std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>::operator()[abi:ne180100]((uint64_t)&a30, v42);
  }
  health::FilePage::~FilePage((health::FilePage *)&a11);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>::operator()[abi:ne180100](i - 8, v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  unint64_t v13 = 578;
  v10[0] = v11;
  v10[1] = v11;
  void v10[2] = 578;
  health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::serialize(a4, (uint64_t)v10);
  if (v13 <= 0x3FF) {
    unint64_t v7 = v11;
  }
  else {
    unint64_t v7 = v12;
  }
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  uint64_t result = (uint64_t)v12;
  uint64_t v12 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBB9520(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::SerializationBuffer::appendRaw<unsigned short>(uint64_t result, _WORD *a2)
{
  if (*(void *)(result + 16) <= 1uLL)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "appendRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Append would overflow serialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 35, (uint64_t)&__p);
  }
  **(_WORD **)(result + 8) = *a2;
  uint64_t v3 = *(void *)(result + 16) - 2;
  *(void *)(result + 8) += 2;
  *(void *)(result + 16) = v3;
  return result;
}

void sub_1BCBB9654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<std::__thread_id *>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

uint64_t **health::WriteAheadLog::Transaction::updatedPage(health::WriteAheadLog::Transaction *this, const health::FilePage *a2)
{
  uint64_t v4 = (void *)*((void *)this + 5);
  unint64_t v5 = *(void *)a2;
  if (!v4) {
    goto LABEL_16;
  }
  unint64_t v6 = (void *)((char *)this + 40);
  do
  {
    unint64_t v7 = v4[4];
    BOOL v8 = v7 >= v5;
    if (v7 >= v5) {
      uint64_t v9 = v4;
    }
    else {
      uint64_t v9 = v4 + 1;
    }
    if (v8) {
      unint64_t v6 = v4;
    }
    uint64_t v4 = (void *)*v9;
  }
  while (*v9);
  if (v6 != (void *)((char *)this + 40) && v5 >= v6[4] && (uint64_t v10 = v6[7], v10 == *((void *)a2 + 1)))
  {
    uint64_t v11 = *(void *)this;
    int v26 = 3;
    uint64_t v27 = v11;
    unint64_t v28 = v5;
    uint64_t v29 = v10;
    int v30 = health::FilePage::checksum(a2);
    uint64_t v12 = v6[6];
    unint64_t v13 = health::VirtualFile::write<health::WriteAheadLog::LogEntryHeader>(*((void *)this + 1), v12, (uint64_t)&v26)
        + v12;
    uint64_t v14 = *((void *)this + 1);
    uint64_t v15 = *((void *)a2 + 2);
    if (!v15) {
      uint64_t v15 = (*(uint64_t (**)(void))(**((void **)a2 + 4) + 16))(*((void *)a2 + 4));
    }
    return (uint64_t **)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t, void))(*(void *)v14 + 24))(v14, v13, v15, *((void *)a2 + 1));
  }
  else
  {
LABEL_16:
    unint64_t v17 = (uint64_t **)((char *)this + 32);
    uint64_t v18 = *(void *)this;
    int v26 = 3;
    uint64_t v27 = v18;
    unint64_t v28 = v5;
    uint64_t v29 = *((void *)a2 + 1);
    int v30 = health::FilePage::checksum(a2);
    uint64_t v19 = (*(uint64_t (**)(void))(**((void **)this + 1) + 48))(*((void *)this + 1));
    unint64_t v20 = health::VirtualFile::write<health::WriteAheadLog::LogEntryHeader>(*((void *)this + 1), v19, (uint64_t)&v26)
        + v19;
    uint64_t v21 = *((void *)this + 1);
    uint64_t v22 = *((void *)a2 + 2);
    if (!v22) {
      uint64_t v22 = (*(uint64_t (**)(void))(**((void **)a2 + 4) + 16))(*((void *)a2 + 4));
    }
    (*(void (**)(uint64_t, unint64_t, uint64_t, void))(*(void *)v21 + 24))(v21, v20, v22, *((void *)a2 + 1));
    long long v23 = *(uint64_t **)this;
    uint64_t v24 = (uint64_t *)*((void *)a2 + 1);
    char v25 = *(uint64_t **)a2;
    uint64_t result = std::__tree<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v17, (unint64_t)v25, &v25);
    result[5] = v23;
    result[6] = (uint64_t *)v19;
    result[7] = v24;
  }
  return result;
}

unint64_t health::WriteAheadLog::Transaction::_writeCompletionEntryOfType(unint64_t result, int a2)
{
  uint64_t v3 = result;
  if (*(_DWORD *)(result + 56))
  {
    uint64_t v4 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v19, "_transactionStatus == Status::Active");
    std::string::basic_string[abi:ne180100]<0>(v18, "_writeCompletionEntryOfType");
    std::string::basic_string[abi:ne180100]<0>(v17, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::WriteAheadLog::EntryTypeToString(&__p, a2);
    health::FormatString<std::string,unsigned long long &>(&v16, (std::string *)"Attempt to {0} transaction {1} but it has already completed.", (uint64_t)&__p, v3);
    health::_HDAssertImplementation<health::transaction_error>(v4, (uint64_t)v19, (uint64_t)v18, (uint64_t)v17, 600, (uint64_t)&v16);
  }
  if (a2 == 1)
  {
    int v5 = 1;
  }
  else
  {
    if (a2 != 2)
    {
      uint64_t v6 = *MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v15, "false");
      std::string::basic_string[abi:ne180100]<0>(v14, "_writeCompletionEntryOfType");
      std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
      health::WriteAheadLog::EntryTypeToString(&__p, a2);
      health::FormatString<std::string,unsigned long long &>(&v12, (std::string *)"Attempt to {0} a transaction {1} with an invalid entry type {0}", (uint64_t)&__p, v3);
      health::_HDAssertImplementation<health::transaction_error>(v6, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 609, (uint64_t)&v12);
    }
    int v5 = 2;
  }
  *(_DWORD *)(result + 56) = v5;
  if (*(_DWORD *)(result + 60) != 1)
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = a2;
    __p.__r_.__value_.__r.__words[2] = 0;
    uint64_t v10 = 0;
    uint64_t v7 = *(void *)(result + 8);
    __p.__r_.__value_.__l.__size_ = *(void *)result;
    int v11 = 0;
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 48))(v7);
    return health::VirtualFile::write<health::WriteAheadLog::LogEntryHeader>(v7, v8, (uint64_t)&__p);
  }
  return result;
}

void sub_1BCBB9B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::POSIXFile::sync(health::POSIXFile *this)
{
  uint64_t result = fcntl(*((_DWORD *)this + 2), 85);
  if (result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v3 = *__error();
    uint64_t v4 = std::system_category();
    int v5 = __error();
    uint64_t v6 = __error();
    uint64_t v7 = strerror(*v6);
    health::FormatString<int &,char *>(&v8, (std::string *)"Error occurred while attempting to sync a file: {0} {1}", (char **)v5, &v7);
    MEMORY[0x1C187B620](exception, v3, v4, &v8);
    __cxa_throw(exception, MEMORY[0x1E4FBA2F0], MEMORY[0x1E4FBA220]);
  }
  return result;
}

void sub_1BCBB9D38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t health::VirtualFile::read<health::WriteAheadLog::LogEntryHeader>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  uint64_t v18 = 36;
  int v11 = (health *)&v15;
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t))(*(void *)a1 + 32))(a1, a2, &v15, 36);
  std::string v12 = (char *)&v16;
  uint64_t v13 = 32;
  *(_DWORD *)a3 = v15;
  uint64_t v14 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)&v11, &v14);
  *(void *)(a3 + 8) = v14;
  uint64_t v14 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)&v11, &v14);
  *(void *)(a3 + 16) = v14;
  uint64_t v14 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)&v11, &v14);
  *(void *)(a3 + 24) = v14;
  LODWORD(v14) = 0;
  health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)&v11, &v14);
  *(_DWORD *)(a3 + 32) = v14;
  uint64_t v6 = v11;
  int v5 = v12;
  LODWORD(v14) = 0;
  health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)&v11, &v14);
  uint64_t v7 = (char *)(v5 - (char *)v6);
  LODWORD(v5) = v14;
  if (health::FletcherChecksum(v11, v7) != v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Invalid checksum on read object.");
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1F171C6B8;
  }
  uint64_t v8 = v17;
  uint64_t v17 = 0;
  if (v8) {
    MEMORY[0x1C187B880](v8, 0x1000C8077774924);
  }
  return v4;
}

void sub_1BCBB9F34(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  unint64_t v3 = STACK[0x428];
  STACK[0x428] = 0;
  if (v3) {
    MEMORY[0x1C187B880](v3, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

ssize_t health::POSIXFile::read(health::POSIXFile *this, char *a2, unsigned __int8 *__buf, char *__nbyte)
{
  std::string v12 = __nbyte;
  uint64_t v13 = a2;
  ssize_t result = pread(*((_DWORD *)this + 2), __buf, (size_t)__nbyte, (off_t)a2);
  if (result < 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v6 = *__error();
    uint64_t v7 = std::system_category();
    uint64_t v8 = __error();
    uint64_t v9 = __error();
    uint64_t v10 = strerror(*v9);
    health::FormatString<unsigned long &,long long &,int &,char *>(&v11, (std::string *)"Error occurred attempting to read {0} bytes at {1}: {2} {3}", &v12, &v13, (char **)v8, &v10);
    MEMORY[0x1C187B620](exception, v6, v7, &v11);
    __cxa_throw(exception, MEMORY[0x1E4FBA2F0], MEMORY[0x1E4FBA220]);
  }
  return result;
}

void sub_1BCBBA050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t health::DeserializationBuffer::extractRaw<unsigned int>(uint64_t result, _DWORD *a2)
{
  if (*(void *)(result + 16) <= 3uLL)
  {
    uint64_t v2 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(_DWORD **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - 4;
  *(void *)(result + 8) += 4;
  *(void *)(result + 16) = v3;
  return result;
}

void sub_1BCBBA194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<unsigned char  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1C187B880);
  }
  return result;
}

uint64_t std::function<void ()(unsigned long long)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t health::VirtualFile::write<health::TransactionalFile::FileHeader>(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  unint64_t v10 = 36;
  v6[0] = v8;
  v6[1] = v8;
  void v6[2] = 36;
  LODWORD(v7) = *(_DWORD *)a2;
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)v6, &v7);
  LODWORD(v7) = *(_DWORD *)(a2 + 4);
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)v6, &v7);
  LODWORD(v7) = *(_DWORD *)(a2 + 8);
  health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)v6, &v7);
  uint64_t v7 = *(void *)(a2 + 16);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v6, &v7);
  uint64_t v7 = *(void *)(a2 + 24);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v6, &v7);
  uint64_t v7 = *(void *)(a2 + 32);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v6, &v7);
  if (v10 <= 0x3FF) {
    uint64_t v4 = v8;
  }
  else {
    uint64_t v4 = v9;
  }
  (*(void (**)(uint64_t, void, unsigned char *))(*(void *)a1 + 24))(a1, 0, v4);
  uint64_t result = (uint64_t)v9;
  uint64_t v9 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBBA3C0(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<health::WriteAheadLog::Transaction>::__on_zero_shared(uint64_t a1)
{
  std::__tree<long>::destroy(*(void **)(a1 + 64));
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void std::unique_lock<std::mutex>::lock(std::unique_lock<std::mutex> *this)
{
  m = this->__m_;
  if (m)
  {
    if (!this->__owns_)
    {
      std::mutex::lock(m);
      this->__owns_ = 1;
      return;
    }
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::lock: references null mutex");
  }
  std::__throw_system_error(11, "unique_lock::lock: already locked");
  [(HDSeriesSampleEntity *)v3 updateSampleCount:v5 withDatabase:v6 error:v7];
}

void sub_1BCBBA5A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCBBAB74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  _Unwind_Resume(a1);
}

void sub_1BCBBAD0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCBBAED8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t health::Optional<health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->(uint64_t result)
{
  if (!*(unsigned char *)(result + 40))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempt to indirect through to the value of an invalid optional.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  return result;
}

void sub_1BCBBAFD4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(uint64_t *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  unint64_t v14 = 56;
  health::RawBuffer::RawBuffer(v11, v12, 56);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  uint64_t v8 = v12;
  if (v14 > 0x3FF) {
    uint64_t v8 = v13;
  }
  v10[0] = v8;
  v10[1] = v8;
  void v10[2] = 56;
  health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot::deserialize(a4, (uint64_t)v10);
  uint64_t result = (uint64_t)v13;
  uint64_t v13 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBBB0D4(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

double health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::insertSample(uint64_t a1, double *a2, uint64_t a3)
{
  id v6 = (health::BlockAccessFile::WriteTransaction *)(*(void *)(a1 + 96) + 80);
  v38[0] = 0;
  v38[1] = 0;
  v38[2] = v6;
  v38[3] = v6;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  if (!v8)
  {
    if (v7)
    {
      uint64_t v8 = 0;
    }
    else
    {
      long long v36 = 0u;
      memset(v37, 0, sizeof(v37));
      long long v34 = 0u;
      long long v35 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      long long v13 = 0u;
      uint64_t v8 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v6, 411);
      uint64_t v7 = v9;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v6, v8, v9, (uint64_t)&v13);
      *(void *)(a1 + 16) = v8;
      *(void *)(a1 + 24) = v7;
    }
  }
  *(void *)&long long v13 = v8;
  *((void *)&v13 + 1) = v7;
  *(void *)&long long v14 = v38;
  int v10 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::setValueForKey((uint64_t *)&v13, a2, a3);
  uint64_t v11 = *(void *)(a1 + 48);
  if (v11)
  {
    if (!v10) {
      *(void *)(a1 + 48) = v11 + 1;
    }
  }
  else
  {
    *(void *)(a1 + 48) = 1;
    *(_OWORD *)a1 = xmmword_1BD324FE0;
  }
  *(void *)&double result = health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::_updateHistoryRoot(a1).n128_u64[0];
  return result;
}

uint64_t health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x11)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 24 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  void v7[2];

  if (a2 >= 0x11)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 24 * a2;
}

void sub_1BCBBB31C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::SerializationBuffer::appendRaw<unsigned char>(uint64_t result, unsigned char *a2)
{
  if (!*(void *)(result + 16))
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "appendRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Append would overflow serialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 35, (uint64_t)&__p);
  }
  **(unsigned char **)(result + 8) = *a2;
  uint64_t v3 = *(void *)(result + 16) - 1;
  ++*(void *)(result + 8);
  *(void *)(result + 16) = v3;
  return result;
}

void sub_1BCBBB480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::setValueForKey(uint64_t *a1, double *a2, uint64_t a3)
{
  uint64_t v6 = a1[2];
  memset(v15, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 24), *a1, a1[1], (uint64_t)v15);
  uint64_t result = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey((uint64_t)a1, 0, a1, (uint64_t)v15, a2, a3);
  if (result >= 2)
  {
    uint64_t v8 = a1[2];
    memset(__src, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v8 + 24), *a1, a1[1], (uint64_t)__src);
    memcpy(v13, __src, sizeof(v13));
    uint64_t v9 = *(health::BlockAccessFile::WriteTransaction **)(a1[2] + 24);
    uint64_t v10 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v9, 411);
    uint64_t v12 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v9, v10, v11, (uint64_t)v13);
    WORD4(__src[25]) = 1;
    *((void *)&__src[0] + 1) = v10;
    *(void *)&__src[1] = v12;
    BYTE10(__src[25]) = 0;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(a1[2] + 24), *a1, a1[1], (uint64_t)__src);
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::setValueForKey(a1, a2, a3);
  }
  return result;
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v13 = 0;
  unint64_t v14 = 411;
  health::RawBuffer::RawBuffer(v11, v12, 411);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  uint64_t v8 = v12;
  if (v14 > 0x3FF) {
    uint64_t v8 = v13;
  }
  v10[0] = v8;
  v10[1] = v8;
  void v10[2] = 411;
  health::bplustree::InteriorNode<double,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  uint64_t result = (uint64_t)v13;
  long long v13 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBBB77C(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void sub_1BCBBB898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::SerializeValues<health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>,unsigned short,health::BlockPointer,health::BlockPointer>(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t *a4, uint64_t *a5)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v11 = (uint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, i);
    uint64_t v12 = v11 + 1;
    uint64_t v14 = *v11;
    health::SerializationBuffer::appendRaw<unsigned long long>(a1, &v14);
    _HDRawLocationDatumV1::serialize(v12, a1);
  }
  LOWORD(v14) = *a3;
  health::SerializationBuffer::appendRaw<unsigned short>(a1, &v14);
  uint64_t v14 = *a4;
  health::SerializationBuffer::appendRaw<unsigned long long>(a1, &v14);
  uint64_t v14 = a4[1];
  health::SerializationBuffer::appendRaw<unsigned long long>(a1, &v14);
  uint64_t v14 = *a5;
  health::SerializationBuffer::appendRaw<unsigned long long>(a1, &v14);
  uint64_t v14 = a5[1];
  return health::SerializationBuffer::appendRaw<unsigned long long>(a1, &v14);
}

uint64_t health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x11)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 48 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  void v7[2];

  if (a2 >= 0x11)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 48 * a2;
}

void sub_1BCBBBADC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  unint64_t v13 = 411;
  v10[0] = v11;
  v10[1] = v11;
  void v10[2] = 411;
  health::bplustree::InteriorNode<double,health::BlockPointer,17>::serialize(a4, (uint64_t)v10);
  if (v13 <= 0x3FF) {
    uint64_t v7 = v11;
  }
  else {
    uint64_t v7 = v12;
  }
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  uint64_t result = (uint64_t)v12;
  uint64_t v12 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBBBC1C(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->(uint64_t result)
{
  if (!*(unsigned char *)(result + 40))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempt to indirect through to the value of an invalid optional.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  return result;
}

void sub_1BCBBBCA8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  unint64_t v13 = 56;
  v10[0] = v11;
  v10[1] = v11;
  void v10[2] = 56;
  health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot::serialize(a4, (uint64_t)v10);
  if (v13 <= 0x3FF) {
    uint64_t v7 = v11;
  }
  else {
    uint64_t v7 = v12;
  }
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  uint64_t result = (uint64_t)v12;
  uint64_t v12 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBBBD98(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(uint64_t a1, double *a2)
{
  if (!*(_WORD *)(a1 + 408))
  {
    SEL v4 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v11, "childCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v10, "childForKey");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for child for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v4, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 58, (uint64_t)&__p);
  }
  unsigned __int16 v5 = *(_WORD *)(a1 + 408);
  do
  {
    if (!--v5) {
      break;
    }
    double v6 = *a2;
  }
  while (v6 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, v5));
  return v5;
}

void sub_1BCBBBEE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v13 = 0;
  unint64_t v14 = 782;
  health::RawBuffer::RawBuffer(v11, v12, 782);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  uint64_t v8 = v12;
  if (v14 > 0x3FF) {
    uint64_t v8 = v13;
  }
  v10[0] = v8;
  v10[1] = v8;
  void v10[2] = 782;
  health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  uint64_t result = (uint64_t)v13;
  unint64_t v13 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBBC034(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void sub_1BCBBC150(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::DeserializationBuffer::extractRaw<int>(uint64_t result, _DWORD *a2)
{
  if (*(void *)(result + 16) <= 3uLL)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "sizeof(T) <= _length");
    std::string::basic_string[abi:ne180100]<0>(v6, "extractRaw");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDEncoder.h");
    health::FormatString<>((std::string *)"Extract would overflow deserialization buffer.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 63, (uint64_t)&__p);
  }
  *a2 = **(_DWORD **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - 4;
  *(void *)(result + 8) += 4;
  *(void *)(result + 16) = v3;
  return result;
}

void sub_1BCBBC2B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::indexForKey(uint64_t a1, double *a2)
{
  int v4 = *(unsigned __int16 *)(a1 + 816);
  if (!*(_WORD *)(a1 + 816))
  {
    unsigned __int16 v5 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v15, "valueCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v14, "indexForKey");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for index for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 72, (uint64_t)&__p);
  }
  unsigned int v6 = v4 - 1;
  while (1)
  {
    double v7 = *a2;
    LOWORD(v4) = v4 - 1;
    if (v7 > *(double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a1, v6))
    {
      uint64_t v10 = 0x200000000;
      return v10 | (unsigned __int16)v4;
    }
    double v8 = *a2;
    if (v8 == *(double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a1, v6))break; {
    if (!(unsigned __int16)v6--)
    }
    {
      LOWORD(v4) = 0;
      uint64_t v10 = 0x100000000;
      return v10 | (unsigned __int16)v4;
    }
  }
  uint64_t v10 = 0;
  LOWORD(v4) = v6;
  return v10 | (unsigned __int16)v4;
}

void sub_1BCBBC48C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

__n128 health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::insertElementAtIndex(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 >= 0x11)
  {
    int v4 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v11, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v10, "insertElementAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v4, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 57, (uint64_t)&__p);
  }
  unsigned __int16 v5 = (_OWORD *)(a1 + 48 * a3);
  memmove(v5 + 3, v5, 48 * (16 - a3));
  long long v7 = *(_OWORD *)(a2 + 16);
  __n128 result = *(__n128 *)(a2 + 32);
  *unsigned __int16 v5 = *(_OWORD *)a2;
  v5[1] = v7;
  v5[2] = result;
  return result;
}

void sub_1BCBBC60C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  unint64_t v13 = 782;
  v10[0] = v11;
  v10[1] = v11;
  void v10[2] = 782;
  health::SerializeValues<health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>,unsigned short,health::BlockPointer,health::BlockPointer>((uint64_t)v10, a4, (_WORD *)(a4 + 816), (uint64_t *)(a4 + 824), (uint64_t *)(a4 + 840));
  if (v13 <= 0x3FF) {
    long long v7 = v11;
  }
  else {
    long long v7 = v12;
  }
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  uint64_t result = (uint64_t)v12;
  uint64_t v12 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCBBC75C(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void *health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((unint64_t)(a5 + a2) >= 0x12)
  {
    unsigned __int16 v5 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v15, "destinationIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v14, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow destination.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 79, (uint64_t)&__p);
  }
  if ((unint64_t)(a5 + a4) >= 0x12)
  {
    unsigned int v6 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v11, "sourceIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v10, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow source.", &v8);
    health::_HDAssertImplementation<std::out_of_range>(v6, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 80, (uint64_t)&v8);
  }
  return memcpy((void *)(a1 + 48 * a2), (const void *)(a3 + 48 * a4), 48 * a5);
}

void sub_1BCBBC95C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

__n128 health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(uint64_t a1, __n128 *a2, unint64_t a3)
{
  if (a3 >= 0x11)
  {
    int v4 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v11, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v10, "insertElementAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v4, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 57, (uint64_t)&__p);
  }
  unsigned __int16 v5 = (__n128 *)(a1 + 24 * a3);
  memmove(&v5[1].n128_i8[8], v5, 24 * (16 - a3));
  unint64_t v6 = a2[1].n128_u64[0];
  __n128 result = *a2;
  *unsigned __int16 v5 = *a2;
  v5[1].n128_u64[0] = v6;
  return result;
}

void sub_1BCBBCB3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t HDDataEntityPredicateForRowID(uint64_t a1, uint64_t a2)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"data_id" value:a1 comparisonType:a2];
}

uint64_t HDCodableErrorReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  int v4 = (int *)MEMORY[0x1E4F940E0];
  unsigned __int16 v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 24;
      }
      else
      {
        if (v17 == 2)
        {
          char v21 = 0;
          unsigned int v22 = 0;
          uint64_t v23 = 0;
          *(unsigned char *)(a1 + 32) |= 1u;
          while (1)
          {
            uint64_t v24 = *v3;
            unint64_t v25 = *(void *)(a2 + v24);
            if (v25 == -1 || v25 >= *(void *)(a2 + *v4)) {
              break;
            }
            char v26 = *(unsigned char *)(*(void *)(a2 + *v7) + v25);
            *(void *)(a2 + v24) = v25 + 1;
            v23 |= (unint64_t)(v26 & 0x7F) << v21;
            if ((v26 & 0x80) == 0) {
              goto LABEL_34;
            }
            v21 += 7;
            BOOL v14 = v22++ >= 9;
            if (v14)
            {
              uint64_t v23 = 0;
              goto LABEL_36;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_34:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v23 = 0;
          }
LABEL_36:
          *(void *)(a1 + 8) = v23;
          continue;
        }
        if (v17 != 1)
        {
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
        }
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 16;
      }
      long long v20 = *(void **)(a1 + v19);
      *(void *)(a1 + v19) = v18;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCBBDF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDDecodeDateForValue()
{
  return objc_msgSend(MEMORY[0x1E4F1C9C8], "dateWithTimeIntervalSinceReferenceDate:");
}

uint64_t HDDispatchQueueName(void *a1, void *a2)
{
  uint64_t v3 = NSString;
  uint64_t v4 = *MEMORY[0x1E4F2BE48];
  unsigned __int16 v5 = a2;
  id v6 = a1;
  long long v7 = (objc_class *)objc_opt_class();
  uint64_t v8 = NSStringFromClass(v7);
  unsigned int v9 = (void *)v8;
  unint64_t v10 = @".";
  uint64_t v11 = &stru_1F1728D60;
  if (v5) {
    uint64_t v11 = v5;
  }
  else {
    unint64_t v10 = &stru_1F1728D60;
  }
  unint64_t v12 = [v3 stringWithFormat:@"%@.%@%@%@.%p", v4, v8, v10, v11, v6];

  id v13 = v12;
  uint64_t v14 = [v13 UTF8String];

  return v14;
}

uint64_t HDCreateSerialUtilityDispatchQueue()
{
  return HKCreateSerialDispatchQueueWithQOSClass();
}

void sub_1BCBC0EF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCBC1D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDDataEntityPredicateForSourceEntity(void *a1)
{
  if (a1)
  {
    uint64_t v1 = objc_msgSend(NSNumber, "numberWithLongLong:", objc_msgSend(a1, "persistentID"));
    unint64_t v2 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"data_provenances.source_id" equalToValue:v1];
  }
  else
  {
    unint64_t v2 = 0;
  }

  return v2;
}

void sub_1BCBC45C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBC53AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1BCBC592C(_Unwind_Exception *exception_object)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(exception_object);
}

void sub_1BCBC5944(void *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a2 == 2)
  {
    id v9 = objc_begin_catch(exc_buf);
    unint64_t v10 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v11 = [v9 reason];
    objc_msgSend(v10, "hk_error:format:", 102, @"hk_writeValue file error: %@");
    objc_claimAutoreleasedReturnValue();

    objc_end_catch();
  }
  else
  {
    objc_begin_catch(exc_buf);
  }
  JUMPOUT(0x1BCBC58C8);
}

void sub_1BCBC61DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1BCBC66C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBC6AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDActivityCacheEntityPredicateForCacheIndices(uint64_t a1)
{
  return [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"cache_index" values:a1];
}

void sub_1BCBC79A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDMetadataKeyPredicateForKey(uint64_t a1)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"key" equalToValue:a1];
}

id HDPredicateForMetadataValues(void *a1)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if ([v1 count])
  {
    unint64_t v2 = [MEMORY[0x1E4F1CA48] array];
    uint64_t v3 = [MEMORY[0x1E4F1CA48] array];
    uint64_t v55 = [MEMORY[0x1E4F1CA48] array];
    BOOL v54 = [MEMORY[0x1E4F1CA48] array];
    [MEMORY[0x1E4F1CA48] array];
    v52 = id v51 = v1;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    id v4 = v1;
    uint64_t v5 = [v4 countByEnumeratingWithState:&v60 objects:v65 count:16];
    uint64_t v53 = (void *)v3;
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)v61;
      do
      {
        uint64_t v8 = 0;
        do
        {
          if (*(void *)v61 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v9 = *(void *)(*((void *)&v60 + 1) + 8 * v8);
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            unint64_t v10 = _HDSQLiteValueForString();
            uint64_t v11 = v2;
          }
          else
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              unint64_t v10 = _HDSQLiteValueForNumber();
              uint64_t v11 = (void *)v3;
            }
            else
            {
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                unint64_t v10 = _HDSQLiteValueForDate();
                uint64_t v11 = v55;
              }
              else
              {
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  [v54 addObject:v9];
                  goto LABEL_19;
                }
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) == 0)
                {
                  unint64_t v10 = [MEMORY[0x1E4F28B00] currentHandler];
                  unint64_t v12 = [NSString stringWithUTF8String:"HDSQLitePredicate * _Nonnull HDPredicateForMetadataValues(NSSet * _Nonnull __strong)"];
                  [v10 handleFailureInFunction:v12 file:@"HDMetadataValueEntity.m" lineNumber:784 description:@"Unsupported metadata value type!"];

                  uint64_t v3 = (uint64_t)v53;
                  goto LABEL_18;
                }
                unint64_t v10 = _HDSQLiteValueForData();
                uint64_t v11 = v52;
              }
            }
          }
          [v11 addObject:v10];
LABEL_18:

LABEL_19:
          ++v8;
        }
        while (v6 != v8);
        uint64_t v13 = [v4 countByEnumeratingWithState:&v60 objects:v65 count:16];
        uint64_t v6 = v13;
      }
      while (v13);
    }

    uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
    if ([v2 count])
    {
      int v15 = (void *)MEMORY[0x1E4F65D00];
      long long v16 = _HDSQLiteValueForNumber();
      unint64_t v17 = [v15 predicateWithProperty:@"value_type" equalToValue:v16];

      uint64_t v18 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"string_value" values:v2];
      uint64_t v19 = [MEMORY[0x1E4F65D58] compoundPredicateWithPredicate:v17 otherPredicate:v18];
      [v14 addObject:v19];
    }
    else
    {
      unint64_t v17 = 0;
      uint64_t v18 = 0;
    }
    if ([v53 count])
    {
      char v21 = (void *)MEMORY[0x1E4F65D00];
      unsigned int v22 = _HDSQLiteValueForNumber();
      uint64_t v23 = [v21 predicateWithProperty:@"value_type" equalToValue:v22];

      uint64_t v24 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"numerical_value" values:v53];

      unint64_t v25 = [MEMORY[0x1E4F65D58] compoundPredicateWithPredicate:v23 otherPredicate:v24];
      [v14 addObject:v25];

      unint64_t v17 = (void *)v23;
      uint64_t v18 = (void *)v24;
    }
    char v26 = v54;
    if ([v55 count])
    {
      long long v27 = (void *)MEMORY[0x1E4F65D00];
      long long v28 = _HDSQLiteValueForNumber();
      uint64_t v29 = [v27 predicateWithProperty:@"value_type" equalToValue:v28];

      uint64_t v30 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"date_value" values:v55];

      long long v31 = [MEMORY[0x1E4F65D58] compoundPredicateWithPredicate:v29 otherPredicate:v30];
      [v14 addObject:v31];

      unint64_t v17 = (void *)v29;
      uint64_t v18 = (void *)v30;
    }
    if ([v54 count])
    {
      long long v50 = v14;
      long long v32 = (void *)MEMORY[0x1E4F65D00];
      long long v33 = _HDSQLiteValueForNumber();
      long long v34 = [v32 predicateWithProperty:@"value_type" equalToValue:v33];

      long long v35 = [MEMORY[0x1E4F1CA48] array];
      long long v56 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      id v36 = v54;
      uint64_t v37 = [v36 countByEnumeratingWithState:&v56 objects:v64 count:16];
      if (v37)
      {
        uint64_t v38 = v37;
        uint64_t v39 = *(void *)v57;
        do
        {
          for (uint64_t i = 0; i != v38; ++i)
          {
            if (*(void *)v57 != v39) {
              objc_enumerationMutation(v36);
            }
            BOOL v41 = _HDMetadataQuantityComparisonPredicate(1, *(void **)(*((void *)&v56 + 1) + 8 * i));
            [v35 addObject:v41];
          }
          uint64_t v38 = [v36 countByEnumeratingWithState:&v56 objects:v64 count:16];
        }
        while (v38);
      }

      uint64_t v42 = [MEMORY[0x1E4F65D08] predicateMatchingAnyPredicates:v35];

      uint64_t v43 = [MEMORY[0x1E4F65D58] compoundPredicateWithPredicate:v34 otherPredicate:v42];
      uint64_t v14 = v50;
      [v50 addObject:v43];

      uint64_t v18 = (void *)v42;
      char v26 = v54;
    }
    else
    {
      long long v34 = v17;
    }
    if (objc_msgSend(v52, "count", v50))
    {
      unint64_t v44 = (void *)MEMORY[0x1E4F65D00];
      unint64_t v45 = _HDSQLiteValueForNumber();
      uint64_t v46 = [v44 predicateWithProperty:@"value_type" equalToValue:v45];

      uint64_t v47 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"data_value" values:v52];

      unint64_t v48 = [MEMORY[0x1E4F65D58] compoundPredicateWithPredicate:v46 otherPredicate:v47];
      [v14 addObject:v48];

      long long v34 = (void *)v46;
      uint64_t v18 = (void *)v47;
    }
    long long v20 = [MEMORY[0x1E4F65D08] predicateMatchingAnyPredicates:v14];

    id v1 = v51;
  }
  else
  {
    long long v20 = [MEMORY[0x1E4F65D08] falsePredicate];
  }

  return v20;
}

uint64_t HDSampleEntityClassForDataType(void *a1)
{
  id v1 = (void *)[a1 dataObjectClass];

  return objc_msgSend(v1, "hd_dataEntityClass");
}

uint64_t HDCodableActivityCacheReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v18 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 208), v18);
        if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v18, a2)) {
          goto LABEL_107;
        }
        goto LABEL_203;
      case 2u:
        char v19 = 0;
        unsigned int v20 = 0;
        uint64_t v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x80u;
        while (2)
        {
          uint64_t v22 = *v3;
          uint64_t v23 = *(void *)(a2 + v22);
          unint64_t v24 = v23 + 1;
          if (v23 == -1 || v24 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v25 = *(unsigned char *)(*(void *)(a2 + *v7) + v23);
            *(void *)(a2 + v22) = v24;
            v21 |= (unint64_t)(v25 & 0x7F) << v19;
            if (v25 < 0)
            {
              v19 += 7;
              BOOL v15 = v20++ >= 9;
              if (v15)
              {
                uint64_t v21 = 0;
                goto LABEL_138;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_138:
        uint64_t v105 = 64;
        goto LABEL_167;
      case 3u:
        *(_DWORD *)(a1 + 220) |= 0x200u;
        uint64_t v26 = *v3;
        unint64_t v27 = *(void *)(a2 + v26);
        if (v27 <= 0xFFFFFFFFFFFFFFF7 && v27 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v27);
          *(void *)(a2 + v26) = v27 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 80;
        goto LABEL_200;
      case 4u:
        *(_DWORD *)(a1 + 220) |= 0x10u;
        uint64_t v29 = *v3;
        unint64_t v30 = *(void *)(a2 + v29);
        if (v30 <= 0xFFFFFFFFFFFFFFF7 && v30 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v30);
          *(void *)(a2 + v29) = v30 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 40;
        goto LABEL_200;
      case 5u:
        *(_DWORD *)(a1 + 220) |= 1u;
        uint64_t v31 = *v3;
        unint64_t v32 = *(void *)(a2 + v31);
        if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v32);
          *(void *)(a2 + v31) = v32 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 8;
        goto LABEL_200;
      case 6u:
        char v33 = 0;
        unsigned int v34 = 0;
        uint64_t v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x40000u;
        while (2)
        {
          uint64_t v35 = *v3;
          uint64_t v36 = *(void *)(a2 + v35);
          unint64_t v37 = v36 + 1;
          if (v36 == -1 || v37 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v38 = *(unsigned char *)(*(void *)(a2 + *v7) + v36);
            *(void *)(a2 + v35) = v37;
            v21 |= (unint64_t)(v38 & 0x7F) << v33;
            if (v38 < 0)
            {
              v33 += 7;
              BOOL v15 = v34++ >= 9;
              if (v15)
              {
                uint64_t v21 = 0;
                goto LABEL_142;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_142:
        uint64_t v105 = 152;
        goto LABEL_167;
      case 7u:
        *(_DWORD *)(a1 + 220) |= 0x400u;
        uint64_t v39 = *v3;
        unint64_t v40 = *(void *)(a2 + v39);
        if (v40 <= 0xFFFFFFFFFFFFFFF7 && v40 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v40);
          *(void *)(a2 + v39) = v40 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 88;
        goto LABEL_200;
      case 8u:
        *(_DWORD *)(a1 + 220) |= 0x100000u;
        uint64_t v41 = *v3;
        unint64_t v42 = *(void *)(a2 + v41);
        if (v42 <= 0xFFFFFFFFFFFFFFF7 && v42 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v42);
          *(void *)(a2 + v41) = v42 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 168;
        goto LABEL_200;
      case 9u:
        *(_DWORD *)(a1 + 220) |= 0x800u;
        uint64_t v43 = *v3;
        unint64_t v44 = *(void *)(a2 + v43);
        if (v44 <= 0xFFFFFFFFFFFFFFF7 && v44 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v44);
          *(void *)(a2 + v43) = v44 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 96;
        goto LABEL_200;
      case 0x12u:
        *(_DWORD *)(a1 + 220) |= 0x100u;
        uint64_t v46 = *v3;
        unint64_t v47 = *(void *)(a2 + v46);
        if (v47 <= 0xFFFFFFFFFFFFFFF7 && v47 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v47);
          *(void *)(a2 + v46) = v47 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 72;
        goto LABEL_200;
      case 0x14u:
        char v48 = 0;
        unsigned int v49 = 0;
        uint64_t v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x10000u;
        while (2)
        {
          uint64_t v50 = *v3;
          uint64_t v51 = *(void *)(a2 + v50);
          unint64_t v52 = v51 + 1;
          if (v51 == -1 || v52 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v53 = *(unsigned char *)(*(void *)(a2 + *v7) + v51);
            *(void *)(a2 + v50) = v52;
            v21 |= (unint64_t)(v53 & 0x7F) << v48;
            if (v53 < 0)
            {
              v48 += 7;
              BOOL v15 = v49++ >= 9;
              if (v15)
              {
                uint64_t v21 = 0;
                goto LABEL_146;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_146:
        uint64_t v105 = 136;
        goto LABEL_167;
      case 0x16u:
        char v54 = 0;
        unsigned int v55 = 0;
        uint64_t v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x1000u;
        while (2)
        {
          uint64_t v56 = *v3;
          uint64_t v57 = *(void *)(a2 + v56);
          unint64_t v58 = v57 + 1;
          if (v57 == -1 || v58 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v59 = *(unsigned char *)(*(void *)(a2 + *v7) + v57);
            *(void *)(a2 + v56) = v58;
            v21 |= (unint64_t)(v59 & 0x7F) << v54;
            if (v59 < 0)
            {
              v54 += 7;
              BOOL v15 = v55++ >= 9;
              if (v15)
              {
                uint64_t v21 = 0;
                goto LABEL_150;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_150:
        uint64_t v105 = 104;
        goto LABEL_167;
      case 0x18u:
        char v60 = 0;
        unsigned int v61 = 0;
        uint64_t v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x200000u;
        while (2)
        {
          uint64_t v62 = *v3;
          uint64_t v63 = *(void *)(a2 + v62);
          unint64_t v64 = v63 + 1;
          if (v63 == -1 || v64 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v65 = *(unsigned char *)(*(void *)(a2 + *v7) + v63);
            *(void *)(a2 + v62) = v64;
            v21 |= (unint64_t)(v65 & 0x7F) << v60;
            if (v65 < 0)
            {
              v60 += 7;
              BOOL v15 = v61++ >= 9;
              if (v15)
              {
                uint64_t v21 = 0;
                goto LABEL_154;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_154:
        uint64_t v105 = 176;
        goto LABEL_167;
      case 0x1Fu:
        uint64_t v18 = objc_alloc_init(HDCodableActivityStatisticsQuantityInfo);
        [(id)a1 addDailyEnergyBurnedStatistics:v18];
        goto LABEL_105;
      case 0x20u:
        uint64_t v18 = objc_alloc_init(HDCodableActivityStatisticsQuantityInfo);
        [(id)a1 addDailyBriskMinutesStatistics:v18];
        goto LABEL_105;
      case 0x21u:
        char v66 = 0;
        unsigned int v67 = 0;
        uint64_t v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x20000u;
        while (2)
        {
          uint64_t v68 = *v3;
          uint64_t v69 = *(void *)(a2 + v68);
          unint64_t v70 = v69 + 1;
          if (v69 == -1 || v70 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v71 = *(unsigned char *)(*(void *)(a2 + *v7) + v69);
            *(void *)(a2 + v68) = v70;
            v21 |= (unint64_t)(v71 & 0x7F) << v66;
            if (v71 < 0)
            {
              v66 += 7;
              BOOL v15 = v67++ >= 9;
              if (v15)
              {
                uint64_t v21 = 0;
                goto LABEL_158;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_158:
        uint64_t v105 = 144;
        goto LABEL_167;
      case 0x22u:
        *(_DWORD *)(a1 + 220) |= 0x20u;
        uint64_t v72 = *v3;
        unint64_t v73 = *(void *)(a2 + v72);
        if (v73 <= 0xFFFFFFFFFFFFFFF7 && v73 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v73);
          *(void *)(a2 + v72) = v73 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 48;
        goto LABEL_200;
      case 0x23u:
        *(_DWORD *)(a1 + 220) |= 2u;
        uint64_t v74 = *v3;
        unint64_t v75 = *(void *)(a2 + v74);
        if (v75 <= 0xFFFFFFFFFFFFFFF7 && v75 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v75);
          *(void *)(a2 + v74) = v75 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 16;
        goto LABEL_200;
      case 0x24u:
        *(_DWORD *)(a1 + 220) |= 0x2000u;
        uint64_t v76 = *v3;
        unint64_t v77 = *(void *)(a2 + v76);
        if (v77 <= 0xFFFFFFFFFFFFFFF7 && v77 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v77);
          *(void *)(a2 + v76) = v77 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 112;
        goto LABEL_200;
      case 0x25u:
        *(_DWORD *)(a1 + 220) |= 0x4000u;
        uint64_t v78 = *v3;
        unint64_t v79 = *(void *)(a2 + v78);
        if (v79 <= 0xFFFFFFFFFFFFFFF7 && v79 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v79);
          *(void *)(a2 + v78) = v79 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 120;
        goto LABEL_200;
      case 0x26u:
        *(_DWORD *)(a1 + 220) |= 0x8000u;
        uint64_t v80 = *v3;
        unint64_t v81 = *(void *)(a2 + v80);
        if (v81 <= 0xFFFFFFFFFFFFFFF7 && v81 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v81);
          *(void *)(a2 + v80) = v81 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 128;
        goto LABEL_200;
      case 0x27u:
        uint64_t v18 = objc_alloc_init(HDCodableActivityStatisticsQuantityInfo);
        [(id)a1 addDailyMoveMinutesStatistics:v18];
LABEL_105:
        if (PBReaderPlaceMark()
          && (HDCodableActivityStatisticsQuantityInfoReadFrom((uint64_t)v18, a2) & 1) != 0)
        {
LABEL_107:
          PBReaderRecallMark();

LABEL_201:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_203:

        return 0;
      case 0x28u:
        *(_DWORD *)(a1 + 220) |= 0x40u;
        uint64_t v82 = *v3;
        unint64_t v83 = *(void *)(a2 + v82);
        if (v83 <= 0xFFFFFFFFFFFFFFF7 && v83 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v83);
          *(void *)(a2 + v82) = v83 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 56;
        goto LABEL_200;
      case 0x29u:
        *(_DWORD *)(a1 + 220) |= 4u;
        uint64_t v84 = *v3;
        unint64_t v85 = *(void *)(a2 + v84);
        if (v85 <= 0xFFFFFFFFFFFFFFF7 && v85 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v85);
          *(void *)(a2 + v84) = v85 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v106 = 24;
LABEL_200:
        *(void *)(a1 + v106) = v28;
        goto LABEL_201;
      case 0x2Au:
        char v86 = 0;
        unsigned int v87 = 0;
        uint64_t v21 = 0;
        *(_DWORD *)(a1 + 220) |= 8u;
        while (2)
        {
          uint64_t v88 = *v3;
          uint64_t v89 = *(void *)(a2 + v88);
          unint64_t v90 = v89 + 1;
          if (v89 == -1 || v90 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v91 = *(unsigned char *)(*(void *)(a2 + *v7) + v89);
            *(void *)(a2 + v88) = v90;
            v21 |= (unint64_t)(v91 & 0x7F) << v86;
            if (v91 < 0)
            {
              v86 += 7;
              BOOL v15 = v87++ >= 9;
              if (v15)
              {
                uint64_t v21 = 0;
                goto LABEL_162;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_162:
        uint64_t v105 = 32;
        goto LABEL_167;
      case 0x2Bu:
        char v92 = 0;
        unsigned int v93 = 0;
        uint64_t v21 = 0;
        *(_DWORD *)(a1 + 220) |= 0x80000u;
        while (2)
        {
          uint64_t v94 = *v3;
          uint64_t v95 = *(void *)(a2 + v94);
          unint64_t v96 = v95 + 1;
          if (v95 == -1 || v96 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v97 = *(unsigned char *)(*(void *)(a2 + *v7) + v95);
            *(void *)(a2 + v94) = v96;
            v21 |= (unint64_t)(v97 & 0x7F) << v92;
            if (v97 < 0)
            {
              v92 += 7;
              BOOL v15 = v93++ >= 9;
              if (v15)
              {
                uint64_t v21 = 0;
                goto LABEL_166;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_166:
        uint64_t v105 = 160;
LABEL_167:
        *(void *)(a1 + v105) = v21;
        goto LABEL_201;
      case 0x2Cu:
        char v98 = 0;
        unsigned int v99 = 0;
        uint64_t v100 = 0;
        *(_DWORD *)(a1 + 220) |= 0x400000u;
        while (2)
        {
          uint64_t v101 = *v3;
          uint64_t v102 = *(void *)(a2 + v101);
          unint64_t v103 = v102 + 1;
          if (v102 == -1 || v103 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v104 = *(unsigned char *)(*(void *)(a2 + *v7) + v102);
            *(void *)(a2 + v101) = v103;
            v100 |= (unint64_t)(v104 & 0x7F) << v98;
            if (v104 < 0)
            {
              v98 += 7;
              BOOL v15 = v99++ >= 9;
              if (v15)
              {
                uint64_t v100 = 0;
                goto LABEL_171;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v100 = 0;
        }
LABEL_171:
        *(unsigned char *)(a1 + 216) = v100 != 0;
        goto LABEL_201;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_201;
    }
  }
}

id HDWorkoutEntityPredicateForWorkoutActivityType(uint64_t a1)
{
  id v1 = (void *)MEMORY[0x1E4F65D00];
  unint64_t v2 = [NSNumber numberWithUnsignedInteger:a1];
  uint64_t v3 = [v1 predicateWithProperty:@"activities.activity_type" value:v2 comparisonType:1];

  return v3;
}

void sub_1BCBCAB34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDNanoSyncEntityClassForObjectType(int a1)
{
  if (a1 - 1) <= 0x31 && ((0x3E1000067FFAFuLL >> (a1 - 1)))
  {
    unint64_t v2 = objc_opt_class();
  }
  else
  {
    unint64_t v2 = 0;
  }
  return v2;
}

void sub_1BCBCBBFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v12 - 120), 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableSourceReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = &OBJC_IVAR___HDEntityEncoder__authorizationFilter;
  char v8 = &OBJC_IVAR___HDEntityEncoder__authorizationFilter;
  unsigned int v9 = &OBJC_IVAR___HDEntityEncoder__authorizationFilter;
  unint64_t v10 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v11 = 0;
    unsigned int v12 = 0;
    unint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = *v3;
      uint64_t v15 = *(void *)(a2 + v14);
      unint64_t v16 = v15 + 1;
      if (v15 == -1 || v16 > *(void *)(a2 + *v4)) {
        break;
      }
      char v17 = *(unsigned char *)(*(void *)(a2 + *v10) + v15);
      *(void *)(a2 + v14) = v16;
      v13 |= (unint64_t)(v17 & 0x7F) << v11;
      if ((v17 & 0x80) == 0) {
        goto LABEL_12;
      }
      v11 += 7;
      BOOL v18 = v12++ >= 9;
      if (v18)
      {
        unint64_t v13 = 0;
        int v19 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v19 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v13 = 0;
    }
LABEL_14:
    if (v19 || (v13 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v13 >> 3))
    {
      case 1u:
        uint64_t v21 = PBReaderReadString();
        uint64_t v22 = v7[445];
        goto LABEL_43;
      case 2u:
        uint64_t v21 = PBReaderReadString();
        uint64_t v22 = v8[446];
        goto LABEL_43;
      case 3u:
        uint64_t v21 = PBReaderReadString();
        uint64_t v22 = v9[447];
        goto LABEL_43;
      case 4u:
        char v24 = 0;
        unsigned int v25 = 0;
        uint64_t v26 = 0;
        *(unsigned char *)(a1 + 76) |= 2u;
        while (2)
        {
          uint64_t v27 = *v3;
          uint64_t v28 = *(void *)(a2 + v27);
          unint64_t v29 = v28 + 1;
          if (v28 == -1 || v29 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v30 = *(unsigned char *)(*(void *)(a2 + *v10) + v28);
            *(void *)(a2 + v27) = v29;
            v26 |= (unint64_t)(v30 & 0x7F) << v24;
            if (v30 < 0)
            {
              v24 += 7;
              BOOL v18 = v25++ >= 9;
              if (v18)
              {
                uint64_t v26 = 0;
                goto LABEL_52;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v26 = 0;
        }
LABEL_52:
        *(void *)(a1 + 16) = v26;
        goto LABEL_44;
      case 5u:
        uint64_t v21 = PBReaderReadData();
        uint64_t v22 = 64;
        goto LABEL_43;
      case 6u:
        *(unsigned char *)(a1 + 76) |= 1u;
        uint64_t v31 = *v3;
        unint64_t v32 = *(void *)(a2 + v31);
        if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v33 = *(void *)(*(void *)(a2 + *v10) + v32);
          *(void *)(a2 + v31) = v32 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v33 = 0;
        }
        *(void *)(a1 + 8) = v33;
        goto LABEL_44;
      case 7u:
        char v34 = 0;
        unsigned int v35 = 0;
        uint64_t v36 = 0;
        *(unsigned char *)(a1 + 76) |= 4u;
        while (2)
        {
          uint64_t v37 = *v3;
          uint64_t v38 = *(void *)(a2 + v37);
          unint64_t v39 = v38 + 1;
          if (v38 == -1 || v39 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v40 = *(unsigned char *)(*(void *)(a2 + *v10) + v38);
            *(void *)(a2 + v37) = v39;
            v36 |= (unint64_t)(v40 & 0x7F) << v34;
            if (v40 < 0)
            {
              v34 += 7;
              BOOL v18 = v35++ >= 9;
              if (v18)
              {
                uint64_t v36 = 0;
                goto LABEL_56;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v36 = 0;
        }
LABEL_56:
        *(unsigned char *)(a1 + 72) = v36 != 0;
        goto LABEL_44;
      case 8u:
        uint64_t v21 = PBReaderReadString();
        uint64_t v22 = 40;
LABEL_43:
        uint64_t v41 = *(void **)(a1 + v22);
        *(void *)(a1 + v22) = v21;

        goto LABEL_44;
      case 9u:
        unint64_t v42 = v9;
        uint64_t v43 = v8;
        unint64_t v44 = v7;
        unint64_t v45 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 56), v45);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v45, a2))
        {
          PBReaderRecallMark();

          uint64_t v7 = v44;
          char v8 = v43;
          unsigned int v9 = v42;
LABEL_44:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }

        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_44;
    }
  }
}

uint64_t HDCodableProvenanceReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 24;
          goto LABEL_49;
        case 3u:
          uint64_t v17 = PBReaderReadData();
          uint64_t v18 = 56;
          goto LABEL_49;
        case 4u:
          uint64_t v17 = PBReaderReadData();
          uint64_t v18 = 16;
          goto LABEL_49;
        case 5u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 64;
          goto LABEL_49;
        case 6u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 48;
          goto LABEL_49;
        case 7u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 72;
          goto LABEL_49;
        case 8u:
          char v20 = 0;
          unsigned int v21 = 0;
          uint64_t v22 = 0;
          *(unsigned char *)(a1 + 80) |= 1u;
          while (2)
          {
            uint64_t v23 = *v3;
            unint64_t v24 = *(void *)(a2 + v23);
            if (v24 == -1 || v24 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v25 = *(unsigned char *)(*(void *)(a2 + *v7) + v24);
              *(void *)(a2 + v23) = v24 + 1;
              v22 |= (unint64_t)(v25 & 0x7F) << v20;
              if (v25 < 0)
              {
                v20 += 7;
                BOOL v14 = v21++ >= 9;
                if (v14)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_53;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_53:
          uint64_t v37 = 32;
          goto LABEL_62;
        case 9u:
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v22 = 0;
          *(unsigned char *)(a1 + 80) |= 2u;
          while (2)
          {
            uint64_t v28 = *v3;
            unint64_t v29 = *(void *)(a2 + v28);
            if (v29 == -1 || v29 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
              *(void *)(a2 + v28) = v29 + 1;
              v22 |= (unint64_t)(v30 & 0x7F) << v26;
              if (v30 < 0)
              {
                v26 += 7;
                BOOL v14 = v27++ >= 9;
                if (v14)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_57;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_57:
          uint64_t v37 = 36;
          goto LABEL_62;
        case 0xAu:
          char v31 = 0;
          unsigned int v32 = 0;
          uint64_t v22 = 0;
          *(unsigned char *)(a1 + 80) |= 4u;
          break;
        case 0xBu:
          uint64_t v17 = PBReaderReadData();
          uint64_t v18 = 8;
LABEL_49:
          uint64_t v36 = *(void **)(a1 + v18);
          *(void *)(a1 + v18) = v17;

          continue;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v33 = *v3;
        unint64_t v34 = *(void *)(a2 + v33);
        if (v34 == -1 || v34 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v35 = *(unsigned char *)(*(void *)(a2 + *v7) + v34);
        *(void *)(a2 + v33) = v34 + 1;
        v22 |= (unint64_t)(v35 & 0x7F) << v31;
        if ((v35 & 0x80) == 0) {
          goto LABEL_59;
        }
        v31 += 7;
        BOOL v14 = v32++ >= 9;
        if (v14)
        {
          LODWORD(v22) = 0;
          goto LABEL_61;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_59:
      if (*(unsigned char *)(a2 + *v5)) {
        LODWORD(v22) = 0;
      }
LABEL_61:
      uint64_t v37 = 40;
LABEL_62:
      *(_DWORD *)(a1 + v37) = v22;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

id HDSourceEntityPredicateForSourceWithUUID(void *a1, int a2)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F65D00];
  id v4 = objc_msgSend(a1, "hk_dataForUUIDBytes");
  uint64_t v5 = [v3 predicateWithProperty:@"uuid" equalToValue:v4];

  if (a2)
  {
    id v6 = v5;
  }
  else
  {
    _HDSourceEntityPredicateForNotDeletedWithPredicate(v5);
    id v6 = (id)objc_claimAutoreleasedReturnValue();
  }
  uint64_t v7 = v6;

  return v7;
}

void sub_1BCBCCCFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBCCDA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HDVersionFromBuildStringForProductType(void *a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  id v9 = a1;
  id v5 = a2;
  if ([v9 isEqualToString:@"UnknownBuild"]) {
    goto LABEL_2;
  }
  if ([v9 isEqualToString:@"[8.0, 8.2"]))
  {
    id v6 = &HDDataProvenanceOperatingSystemVersion8_0_0;
    goto LABEL_7;
  }
  if ([v9 isEqualToString:@"[8.2, 9.0"]))
  {
    id v6 = &HDDataProvenanceOperatingSystemVersion8_2_0;
    goto LABEL_7;
  }
  if ([v5 hasPrefix:@"iPhone"])
  {
    if (qword_1EBA18A98 != -1) {
      dispatch_once(&qword_1EBA18A98, &__block_literal_global_446);
    }
    uint64_t v7 = v9;
    char v8 = (void *)qword_1EBA18A90;
  }
  else
  {
    if (![v5 hasPrefix:@"Watch"])
    {
LABEL_2:
      id v6 = &HDDataProvenanceOperatingSystemVersionUnknown;
LABEL_7:
      *(_OWORD *)a3 = *v6;
      a3[2] = *((void *)v6 + 2);
      goto LABEL_8;
    }
    if (qword_1EBA18AA8 != -1) {
      dispatch_once(&qword_1EBA18AA8, &__block_literal_global_451);
    }
    uint64_t v7 = v9;
    char v8 = (void *)qword_1EBA18AA0;
  }
  versionFromBuildString(a3, v7, v8);
LABEL_8:
}

void __iOSSortedBuildStrings_block_invoke()
{
  uint64_t v0 = (void *)qword_1EBA18A90;
  qword_1EBA18A90 = (uint64_t)&unk_1F17E8FE8;
}

void versionFromBuildString(void *a1, void *a2, void *a3)
{
  id v14 = a2;
  id v5 = a3;
  unint64_t v6 = [v5 count];
  if (qword_1EBA18A88 != -1) {
    dispatch_once(&qword_1EBA18A88, &__block_literal_global_287);
  }
  id v7 = (id)_MergedGlobals_197;
  uint64_t v8 = [v7 objectForKey:v14];
  id v9 = (void *)v8;
  if (v8)
  {
    objc_copyStruct(a1, (const void *)(v8 + 8), 24, 1, 0);
  }
  else
  {
    unint64_t v10 = objc_msgSend(v5, "indexOfObject:inSortedRange:options:usingComparator:", v14, 0, v6, 1024, &__block_literal_global_4);
    if (v10 >= v6)
    {
      *(_OWORD *)a1 = HDDataProvenanceOperatingSystemVersionUnknown;
      a1[2] = 0;
    }
    else
    {
      uint64_t v11 = [v5 objectAtIndexedSubscript:v10];
      uint64_t v12 = [v7 objectForKeyedSubscript:v11];
      char v13 = (void *)v12;
      if (v12)
      {
        objc_copyStruct(a1, (const void *)(v12 + 8), 24, 1, 0);
      }
      else
      {
        *a1 = 0;
        a1[1] = 0;
        a1[2] = 0;
      }
    }
  }
}

void __buildStringToVersionMap_block_invoke()
{
  v55[52] = *MEMORY[0x1E4F143B8];
  v54[0] = @"13A0";
  char v53 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[0] = v53;
  v54[1] = @"13A344";
  unint64_t v52 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 0, 0);
  v55[1] = v52;
  v54[2] = @"13A405";
  uint64_t v51 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 0, 1);
  v55[2] = v51;
  v54[3] = @"13A452";
  uint64_t v50 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 0, 2);
  v55[3] = v50;
  v54[4] = @"13A5325c";
  unsigned int v49 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 0, 0);
  v55[4] = v49;
  v54[5] = @"13B143";
  char v48 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 1, 0);
  v55[5] = v48;
  v54[6] = @"13B5130b";
  unint64_t v47 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 1, 0);
  v55[6] = v47;
  v54[7] = @"13C5060d";
  uint64_t v46 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 2, 0);
  v55[7] = v46;
  v54[8] = @"13D20";
  unint64_t v45 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 2, 1);
  v55[8] = v45;
  v54[9] = @"13E237";
  unint64_t v44 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 0);
  v55[9] = v44;
  v54[10] = @"13E238";
  uint64_t v43 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 1);
  v55[10] = v43;
  v54[11] = @"13E5234a";
  unint64_t v42 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 0);
  v55[11] = v42;
  v54[12] = @"13F69";
  uint64_t v41 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 2);
  v55[12] = v41;
  v54[13] = @"13G34";
  char v40 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 3);
  v55[13] = v40;
  v54[14] = @"13G35";
  unint64_t v39 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 4);
  v55[14] = v39;
  v54[15] = @"13G36";
  uint64_t v38 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 9, 3, 5);
  v55[15] = v38;
  v54[16] = @"14A0";
  uint64_t v37 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[16] = v37;
  v54[17] = @"14A346";
  uint64_t v36 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 0, 0);
  v55[17] = v36;
  v54[18] = @"14A403";
  char v35 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 0, 1);
  v55[18] = v35;
  v54[19] = @"14A456";
  unint64_t v34 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 0, 2);
  v55[19] = v34;
  v54[20] = @"14A551";
  uint64_t v33 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 0, 3);
  v55[20] = v33;
  v54[21] = @"14A5346a";
  unsigned int v32 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 0, 0);
  v55[21] = v32;
  v54[22] = @"14B99999";
  char v31 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 1, 0);
  v55[22] = v31;
  v54[23] = @"14C99999";
  char v30 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 2, 0);
  v55[23] = v30;
  v54[24] = @"14E0";
  unint64_t v29 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[24] = v29;
  v54[25] = @"14E99999";
  uint64_t v28 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 10, 3, 0);
  v55[25] = v28;
  v54[26] = @"150";
  unsigned int v27 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[26] = v27;
  v54[27] = @"15A99999";
  char v26 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 11, 0, 0);
  v55[27] = v26;
  v54[28] = @"12S0";
  char v25 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[28] = v25;
  v54[29] = @"12S507";
  unint64_t v24 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 1, 0, 0);
  v55[29] = v24;
  v54[30] = @"12S632";
  uint64_t v23 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 1, 0, 1);
  v55[30] = v23;
  v54[31] = @"13S0";
  uint64_t v22 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[31] = v22;
  v54[32] = @"13S344";
  unsigned int v21 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 0, 0);
  v55[32] = v21;
  v54[33] = @"13S428";
  char v20 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 0, 1);
  v55[33] = v20;
  v54[34] = @"13S661";
  int v19 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 1, 0);
  v55[34] = v19;
  v54[35] = @"13S5325c";
  uint64_t v18 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 0, 0);
  v55[35] = v18;
  v54[36] = @"13V0";
  uint64_t v17 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[36] = v17;
  v54[37] = @"13V144";
  unint64_t v16 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 2, 0);
  v55[37] = v16;
  v54[38] = @"13V420";
  int v15 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 2, 1);
  v55[38] = v15;
  v54[39] = @"13V604";
  id v14 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 2, 2);
  v55[39] = v14;
  v54[40] = @"13V5143a";
  char v13 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 2, 2, 0);
  v55[40] = v13;
  v54[41] = @"14B0";
  uint64_t v12 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[41] = v12;
  v54[42] = @"14B471";
  uint64_t v0 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 1, 0);
  v55[42] = v0;
  v54[43] = @"14S0";
  uint64_t v1 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[43] = v1;
  v54[44] = @"14S326";
  unint64_t v2 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 0, 0);
  v55[44] = v2;
  v54[45] = @"14S471";
  uint64_t v3 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 1, 0);
  v55[45] = v3;
  v54[46] = @"14S1000";
  id v4 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 1, 1);
  v55[46] = v4;
  v54[47] = @"14S5869b";
  id v5 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 0, 0);
  v55[47] = v5;
  v54[48] = @"14V0";
  unint64_t v6 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[48] = v6;
  v54[49] = @"14V9999";
  id v7 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 3, 3, 0);
  v55[49] = v7;
  v54[50] = @"15R0";
  uint64_t v8 = +[HDNSOperatingSystemVersion unknownVersion]();
  v55[50] = v8;
  v54[51] = @"15R9999";
  id v9 = +[HDNSOperatingSystemVersion versionWithMajor:minor:patch:]((uint64_t)HDNSOperatingSystemVersion, 4, 0, 0);
  v55[51] = v9;
  uint64_t v10 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v55 forKeys:v54 count:52];
  uint64_t v11 = (void *)_MergedGlobals_197;
  _MergedGlobals_197 = v10;
}

uint64_t __versionFromBuildString_block_invoke(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "hk_compareBuildVersionWithString:");
}

void __allowedClasses_block_invoke()
{
  uint64_t v0 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, v7, v8, v9, objc_opt_class(), 0);
  uint64_t v11 = (void *)qword_1EBA18E28;
  qword_1EBA18E28 = v10;
}

void sub_1BCBCEA44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBCEAEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HDPowerLog(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  id v7 = (id)[a2 mutableCopy];
  uint64_t v6 = [NSNumber numberWithInteger:a3];
  [v7 setObject:v6 forKeyedSubscript:@"status"];

  PLLogRegisteredEvent();
}

void sub_1BCBD008C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, long long buf)
{
  if (a2 == 1)
  {
    id v11 = objc_begin_catch(a1);
    _HKInitializeLogging();
    uint64_t v12 = HKLogInfrastructure();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = objc_opt_class();
      LODWORD(buf) = 138543618;
      *(void *)((char *)&buf + 4) = v13;
      WORD6(buf) = 2112;
      _os_log_impl(&dword_1BCB7D000, v12, OS_LOG_TYPE_DEFAULT, "%{public}@: Exception parsing unit string: %@", (uint8_t *)&buf, 0x16u);
    }

    objc_end_catch();
    JUMPOUT(0x1BCBCFFB8);
  }
  _Unwind_Resume(a1);
}

id sub_1BCBD0150(uint64_t a1, uint64_t a2)
{
  return sub_1BCBD01B8(a1, a2, (void (*)(void))sub_1BCBD16F0);
}

uint64_t EpochBasedSyncStateUpdaterDelegate.domain.getter()
{
  uint64_t v0 = sub_1BCBD16F0();
  swift_bridgeObjectRetain();
  return v0;
}

id sub_1BCBD01A0(uint64_t a1, uint64_t a2)
{
  return sub_1BCBD01B8(a1, a2, (void (*)(void))sub_1BCBD1720);
}

id sub_1BCBD01B8(uint64_t a1, uint64_t a2, void (*a3)(void))
{
  a3();
  swift_bridgeObjectRetain();
  uint64_t v3 = (void *)sub_1BD2E4760();
  swift_bridgeObjectRelease();

  return v3;
}

uint64_t EpochBasedSyncStateUpdaterDelegate.key.getter()
{
  uint64_t v0 = sub_1BCBD1720();
  swift_bridgeObjectRetain();
  return v0;
}

uint64_t sub_1BCBD0254()
{
  return EpochBasedSyncStateUpdaterDelegate.supportedSyncVersionRange.getter();
}

uint64_t EpochBasedSyncStateUpdaterDelegate.supportedSyncVersionRange.getter()
{
  return *(void *)((char *)v0 + *(void *)((*MEMORY[0x1E4FBC8C8] & *v0) + 0x80));
}

uint64_t EpochBasedSyncStateUpdaterDelegate.store.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)(*(void *)((*MEMORY[0x1E4FBC8C8] & *(void *)v1)
                                                                            + 0x50)
                                                                - 8)
                                                    + 16))(a1, &v1[*(void *)((*MEMORY[0x1E4FBC8C8] & *(void *)v1) + 0x88)]);
}

id EpochBasedSyncStateUpdaterDelegate.__allocating_init(logger:key:supportedSyncVersionRange:domain:store:maxDataSizeInBytes:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = v8;
  id v18 = objc_allocWithZone(v9);
  id v19 = sub_1BCBD1750(a1, a2, a3, a4, a5, a6, a7, a8);
  (*(void (**)(uint64_t))(*(void *)(*((void *)v9 + 10) - 8) + 8))(a7);
  return v19;
}

id EpochBasedSyncStateUpdaterDelegate.init(logger:key:supportedSyncVersionRange:domain:store:maxDataSizeInBytes:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *MEMORY[0x1E4FBC8C8] & *v8;
  id v11 = sub_1BCBD1750(a1, a2, a3, a4, a5, a6, a7, a8);
  (*(void (**)(uint64_t))(*(void *)(*(void *)(v10 + 80) - 8) + 8))(a7);
  return v11;
}

uint64_t sub_1BCBD0464(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, id *a6)
{
  return sub_1BCBD1978(a1, a2, a3, a6);
}

uint64_t sub_1BCBD046C(void *a1)
{
  return sub_1BD2E4780();
}

uint64_t sub_1BCBD04C0(void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6, void *a7, id *a8)
{
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  id v15 = a6;
  id v16 = a7;
  id v17 = a1;
  uint64_t v18 = sub_1BCBD1978(a3, a4, a5, a8);
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();

  return v18;
}

uint64_t sub_1BCBD0570(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  swift_getObjectType();
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v8 = swift_dynamicCastUnknownClass();
  swift_unknownObjectRetain_n();
  if (v8)
  {
    swift_unknownObjectRetain();
    uint64_t v9 = sub_1BD2E46B0();
    os_log_type_t type = sub_1BD2E4830();
    if (os_log_type_enabled(v9, type))
    {
      uint64_t v10 = swift_slowAlloc();
      uint64_t v29 = swift_slowAlloc();
      v32[0] = v29;
      *(_DWORD *)uint64_t v10 = 136446466;
      uint64_t v11 = sub_1BD2E4AC0();
      uint64_t v33 = sub_1BCBD1058(v11, v12, v32);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      *(_WORD *)(v10 + 12) = 2080;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
      uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 56))(AssociatedTypeWitness, AssociatedConformanceWitness);
      uint64_t v33 = sub_1BCBD1058(v14, v15, v32);
      sub_1BD2E4890();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v9, type, "[%{public}s] Syncing merged state: %s", (uint8_t *)v10, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v29, -1, -1);
      MEMORY[0x1C187C9C0](v10, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
    }

    objc_msgSend(a1, sel_setCodableObject_version_profile_, v8, *(int *)((char *)v4 + *(void *)((*MEMORY[0x1E4FBC8C8] & *v4) + 0x80)), a3);
    return swift_unknownObjectRelease();
  }
  else
  {
    id v16 = sub_1BD2E46B0();
    os_log_type_t v17 = sub_1BD2E4840();
    if (os_log_type_enabled(v16, v17))
    {
      uint64_t v18 = swift_slowAlloc();
      uint64_t v19 = swift_slowAlloc();
      v32[0] = v19;
      *(_DWORD *)uint64_t v18 = 136446466;
      uint64_t v20 = sub_1BD2E4AC0();
      uint64_t v33 = sub_1BCBD1058(v20, v21, v32);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      *(_WORD *)(v18 + 12) = 2080;
      uint64_t v33 = a2;
      sub_1BCBD2ECC();
      swift_unknownObjectRetain();
      uint64_t v22 = sub_1BD2E4780();
      uint64_t v33 = sub_1BCBD1058(v22, v23, v32);
      sub_1BD2E4890();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v16, v17, "[%{public}s] Unexpected object type: %s", (uint8_t *)v18, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v19, -1, -1);
      MEMORY[0x1C187C9C0](v18, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
    }

    v32[3] = swift_getObjectType();
    v32[0] = a2;
    swift_unknownObjectRetain();
    uint64_t v25 = sub_1BCBD046C(v32);
    uint64_t v27 = v26;
    __swift_destroy_boxed_opaque_existential_0((uint64_t)v32);
    type metadata accessor for EpochBasedSyncStateUpdaterDelegate.Failure();
    swift_getWitnessTable();
    swift_allocError();
    uint64_t *v28 = v25;
    v28[1] = v27;
    return swift_willThrow();
  }
}

uint64_t sub_1BCBD0A64(void *a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a3;
  swift_unknownObjectRetain();
  id v9 = a5;
  id v10 = a1;
  sub_1BCBD0570(v8, a4, (uint64_t)v9);

  swift_unknownObjectRelease();
  return 1;
}

uint64_t sub_1BCBD0B28(uint64_t a1)
{
  return sub_1BCBD2F24(a1);
}

uint64_t sub_1BCBD0B40(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  swift_unknownObjectRetain();
  id v7 = a4;
  id v8 = a1;
  sub_1BCBD2F24(a3);

  swift_unknownObjectRelease();
  return 1;
}

void sub_1BCBD0BF0(void *a1)
{
}

uint64_t sub_1BCBD0C08(void *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  id v8 = a4;
  id v9 = a5;
  id v10 = a1;
  sub_1BCBD3440(a3);

  return 1;
}

uint64_t sub_1BCBD0CB4(void *a1, void *a2, uint64_t a3, void *a4)
{
  return sub_1BCBD3738(a1, a2, a4);
}

uint64_t sub_1BCBD0CBC(void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  id v10 = a4;
  id v11 = a5;
  id v12 = a1;
  uint64_t v13 = sub_1BCBD3738(a3, v10, a6);

  return v13;
}

id EpochBasedSyncStateUpdaterDelegate.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);

  return objc_msgSend(v1, sel_init);
}

void EpochBasedSyncStateUpdaterDelegate.init()()
{
}

void sub_1BCBD0DA8()
{
}

id EpochBasedSyncStateUpdaterDelegate.__deallocating_deinit()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for EpochBasedSyncStateUpdaterDelegate();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

uint64_t sub_1BCBD0E60(void *a1)
{
  objc_super v2 = (void *)MEMORY[0x1E4FBC8C8];
  uint64_t v3 = *MEMORY[0x1E4FBC8C8] & *a1;
  uint64_t v4 = (char *)a1 + *(void *)(v3 + 0x68);
  uint64_t v5 = sub_1BD2E46C0();
  (*(void (**)(char *, uint64_t))(*(void *)(v5 - 8) + 8))(v4, v5);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v6 = (char *)a1 + *(void *)((*v2 & *a1) + 0x88);
  id v7 = *(uint64_t (**)(char *))(*(void *)(*(void *)(v3 + 80) - 8) + 8);

  return v7(v6);
}

unint64_t sub_1BCBD0FA4(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0xD000000000000030;
  }
  sub_1BD2E48E0();
  swift_bridgeObjectRelease();
  sub_1BD2E47A0();
  return 0xD00000000000002CLL;
}

unint64_t sub_1BCBD1050()
{
  return sub_1BCBD0FA4(*v0, v0[1]);
}

uint64_t sub_1BCBD1058(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v6 = sub_1BCBD112C(v12, 0, 0, 1, a1, a2);
  uint64_t v7 = v12[0];
  if (v6)
  {
    uint64_t v8 = v6;
    uint64_t ObjectType = swift_getObjectType();
    v12[0] = v8;
    uint64_t v9 = *a3;
    if (*a3)
    {
      sub_1BCBD42D8((uint64_t)v12, *a3);
      *a3 = v9 + 32;
    }
  }
  else
  {
    uint64_t ObjectType = MEMORY[0x1E4FBB9B0];
    v12[0] = a1;
    v12[1] = a2;
    uint64_t v10 = *a3;
    if (*a3)
    {
      sub_1BCBD42D8((uint64_t)v12, *a3);
      *a3 = v10 + 32;
    }
    swift_bridgeObjectRetain();
  }
  __swift_destroy_boxed_opaque_existential_0((uint64_t)v12);
  return v7;
}

uint64_t sub_1BCBD112C(uint64_t *a1, char *__dst, uint64_t a3, char a4, uint64_t a5, unint64_t a6)
{
  if ((a6 & 0x2000000000000000) != 0)
  {
    if ((a4 & 1) == 0)
    {
      if (__dst)
      {
        uint64_t v11 = HIBYTE(a6) & 0xF;
        if (a3 - (uint64_t)__dst > v11)
        {
          __src[0] = a5;
          __src[1] = a6 & 0xFFFFFFFFFFFFFFLL;
          if (__src >= (void *)&__dst[v11] || (char *)__src + v11 <= __dst)
          {
            memcpy(__dst, __src, HIBYTE(a6) & 0xF);
            sub_1BD2E48A0();
            uint64_t result = 0;
            *a1 = (uint64_t)__dst;
            return result;
          }
          goto LABEL_17;
        }
      }
    }
LABEL_13:
    uint64_t result = sub_1BCBD12E8(a5, a6);
    *a1 = v12;
    return result;
  }
  if ((a6 & 0x1000000000000000) != 0) {
    goto LABEL_13;
  }
  if ((a5 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = (a6 & 0xFFFFFFFFFFFFFFFLL) + 32;
    goto LABEL_5;
  }
  uint64_t v8 = sub_1BD2E4920();
  if (!v8)
  {
    sub_1BD2E4990();
    __break(1u);
LABEL_17:
    uint64_t result = sub_1BD2E4A00();
    __break(1u);
    return result;
  }
LABEL_5:
  *a1 = v8;
  if ((a6 & 0x8000000000000000) != 0) {
    return 0;
  }
  else {
    return swift_unknownObjectRetain();
  }
}

uint64_t sub_1BCBD12E8(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = sub_1BCBD1380(a1, a2);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    uint64_t v2 = sub_1BCBD1580(0, *(void *)(v2 + 16) + 1, 1, (char *)v2);
  }
  unint64_t v4 = *(void *)(v2 + 16);
  unint64_t v3 = *(void *)(v2 + 24);
  if (v4 >= v3 >> 1) {
    uint64_t v2 = sub_1BCBD1580(v3 > 1, v4 + 1, 1, (char *)v2);
  }
  *(void *)(v2 + 16) = v4 + 1;
  *(unsigned char *)(v2 + 32 + v4) = 0;
  return v2;
}

uint64_t sub_1BCBD1380(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x1000000000000000) != 0) {
    goto LABEL_10;
  }
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v2 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v2)
  {
    while (1)
    {
      unint64_t v3 = sub_1BCBD14F8(v2, 0);
      if (v2 < 0) {
        break;
      }
      unint64_t v4 = v3;
      uint64_t v5 = sub_1BD2E48F0();
      if (v6) {
        goto LABEL_14;
      }
      if (v5 == v2) {
        return (uint64_t)v4;
      }
      sub_1BD2E4990();
      __break(1u);
LABEL_10:
      uint64_t v2 = sub_1BD2E47B0();
      if (!v2) {
        return MEMORY[0x1E4FBC860];
      }
    }
    sub_1BD2E4A00();
    __break(1u);
LABEL_14:
    uint64_t result = sub_1BD2E4990();
    __break(1u);
  }
  else
  {
    return MEMORY[0x1E4FBC860];
  }
  return result;
}

void *sub_1BCBD14F8(uint64_t a1, uint64_t a2)
{
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return (void *)MEMORY[0x1E4FBC860];
  }
  sub_1BCBD4334(0, &qword_1E9FBDC10, MEMORY[0x1E4FBC358], MEMORY[0x1E4FBBE00]);
  unint64_t v4 = (void *)swift_allocObject();
  size_t v5 = _swift_stdlib_malloc_size(v4);
  v4[2] = a1;
  v4[3] = 2 * v5 - 64;
  return v4;
}

uint64_t sub_1BCBD1580(char a1, int64_t a2, char a3, char *a4)
{
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_30;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  int64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    int64_t v9 = *((void *)a4 + 2);
  }
  else {
    int64_t v9 = v7;
  }
  if (v9)
  {
    sub_1BCBD4334(0, &qword_1E9FBDC10, MEMORY[0x1E4FBC358], MEMORY[0x1E4FBBE00]);
    uint64_t v10 = (char *)swift_allocObject();
    size_t v11 = _swift_stdlib_malloc_size(v10);
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * v11 - 64;
  }
  else
  {
    uint64_t v10 = (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v12 = v10 + 32;
  uint64_t v13 = a4 + 32;
  if (a1)
  {
    if (v10 != a4 || v12 >= &v13[v8]) {
      memmove(v12, v13, v8);
    }
    *((void *)a4 + 2) = 0;
    goto LABEL_28;
  }
  if (v13 >= &v12[v8] || v12 >= &v13[v8])
  {
    memcpy(v12, v13, v8);
LABEL_28:
    swift_bridgeObjectRelease();
    return (uint64_t)v10;
  }
LABEL_30:
  uint64_t result = sub_1BD2E4A00();
  __break(1u);
  return result;
}

uint64_t sub_1BCBD16F0()
{
  return *(void *)((char *)v0 + *(void *)((*MEMORY[0x1E4FBC8C8] & *v0) + 0x70));
}

uint64_t sub_1BCBD1720()
{
  return *(void *)((char *)v0 + *(void *)((*MEMORY[0x1E4FBC8C8] & *v0) + 0x78));
}

id sub_1BCBD1750(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = (void *)MEMORY[0x1E4FBC8C8];
  uint64_t v14 = *MEMORY[0x1E4FBC8C8] & *(void *)v8;
  unint64_t v15 = &v8[*(void *)(v14 + 0x68)];
  uint64_t v16 = sub_1BD2E46C0();
  uint64_t v17 = *(void *)(v16 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))(v15, a1, v16);
  uint64_t v18 = &v8[*(void *)((*v13 & *(void *)v8) + 0x78)];
  *(void *)uint64_t v18 = a2;
  *((void *)v18 + 1) = a3;
  *(void *)&v8[*(void *)((*v13 & *(void *)v8) + 0x80)] = a4;
  uint64_t v19 = &v8[*(void *)((*v13 & *(void *)v8) + 0x70)];
  *(void *)uint64_t v19 = a5;
  *((void *)v19 + 1) = a6;
  (*(void (**)(char *, uint64_t, void))(*(void *)(*(void *)(v14 + 80) - 8) + 16))(&v8[*(void *)((*v13 & *(void *)v8) + 0x88)], a7, *(void *)(v14 + 80));
  *(void *)&v8[*(void *)((*v13 & *(void *)v8) + 0x60)] = a8;
  v26.receiver = v8;
  v26.super_class = (Class)type metadata accessor for EpochBasedSyncStateUpdaterDelegate();
  id v20 = objc_msgSendSuper2(&v26, sel_init);
  (*(void (**)(uint64_t, uint64_t))(v17 + 8))(a1, v16);
  return v20;
}

uint64_t sub_1BCBD1978(void *a1, void *a2, uint64_t a3, id *a4)
{
  size_t v5 = v4;
  swift_getObjectType();
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v125 = swift_dynamicCastUnknownClass();
  if (v125 && (uint64_t v9 = swift_dynamicCastUnknownClass()) != 0)
  {
    uint64_t v10 = v9;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 8);
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    uint64_t v13 = v12(AssociatedTypeWitness, AssociatedConformanceWitness);
    v120 = v12;
    if (v12(AssociatedTypeWitness, AssociatedConformanceWitness) < v13)
    {
      uint64_t v14 = AssociatedConformanceWitness;
      swift_unknownObjectRetain_n();
      swift_unknownObjectRetain_n();
      unint64_t v15 = sub_1BD2E46B0();
      os_log_type_t v16 = sub_1BD2E4850();
      if (os_log_type_enabled(v15, v16))
      {
        uint64_t v17 = swift_slowAlloc();
        os_log_t log = (os_log_t)swift_slowAlloc();
        v131[0] = log;
        *(_DWORD *)uint64_t v17 = 136446722;
        os_log_type_t typea = v16;
        uint64_t v18 = sub_1BD2E4AC0();
        sub_1BCBD1058(v18, v19, (uint64_t *)v131);
        sub_1BD2E4890();
        swift_bridgeObjectRelease();
        *(_WORD *)(v17 + 12) = 2048;
        v12(AssociatedTypeWitness, AssociatedConformanceWitness);
        swift_unknownObjectRelease();
        sub_1BD2E4890();
        swift_unknownObjectRelease();
        *(_WORD *)(v17 + 22) = 2048;
        id v20 = (void *)v12(AssociatedTypeWitness, AssociatedConformanceWitness);
        swift_unknownObjectRelease();
        id v130 = v20;
        unint64_t v21 = a1;
        sub_1BD2E4890();
        swift_unknownObjectRelease();
        _os_log_impl(&dword_1BCB7D000, v15, typea, "[%{public}s] Choosing cloud state, it has a higher epoch (%lld vs %lld)", (uint8_t *)v17, 0x20u);
        swift_arrayDestroy();
        MEMORY[0x1C187C9C0](log, -1, -1);
        MEMORY[0x1C187C9C0](v17, -1, -1);
      }
      else
      {

        swift_unknownObjectRelease_n();
        swift_unknownObjectRelease_n();
        unint64_t v21 = a1;
      }
      uint64_t v62 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v14 + 32))(AssociatedTypeWitness, v14);
      id v63 = v62;
      *unint64_t v21 = v62;
LABEL_20:
      swift_unknownObjectRelease();
      swift_unknownObjectRelease();
      return 2;
    }
    uint64_t v54 = v12(AssociatedTypeWitness, AssociatedConformanceWitness);
    if (v12(AssociatedTypeWitness, AssociatedConformanceWitness) >= v54)
    {
      unint64_t v64 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 32))(AssociatedTypeWitness, AssociatedConformanceWitness);
      swift_unknownObjectRetain_n();
      char v65 = sub_1BD2E46B0();
      os_log_type_t v66 = sub_1BD2E4850();
      if (os_log_type_enabled(v65, v66))
      {
        *(void *)typeb = v64;
        uint64_t v67 = swift_slowAlloc();
        v119 = (void *)swift_slowAlloc();
        v131[0] = v119;
        *(_DWORD *)uint64_t v67 = 136446466;
        uint64_t v68 = sub_1BD2E4AC0();
        sub_1BCBD1058(v68, v69, (uint64_t *)v131);
        sub_1BD2E4890();
        swift_bridgeObjectRelease();
        *(_WORD *)(v67 + 12) = 2048;
        unint64_t v70 = (void *)v120(AssociatedTypeWitness, AssociatedConformanceWitness);
        swift_unknownObjectRelease();
        id v130 = v70;
        sub_1BD2E4890();
        swift_unknownObjectRelease();
        _os_log_impl(&dword_1BCB7D000, v65, v66, "[%{public}s] Merging local and cloud state with same epoch (%lld)", (uint8_t *)v67, 0x16u);
        swift_arrayDestroy();
        MEMORY[0x1C187C9C0](v119, -1, -1);
        uint64_t v71 = v67;
        unint64_t v64 = *(void **)typeb;
        MEMORY[0x1C187C9C0](v71, -1, -1);
      }
      else
      {

        swift_unknownObjectRelease_n();
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(AssociatedConformanceWitness + 40))(v10, AssociatedTypeWitness, AssociatedConformanceWitness);
      os_log_type_t type = v64;
      id v75 = objc_msgSend(v64, sel_data);
      if (!v75)
      {
LABEL_57:
        __break(1u);
        JUMPOUT(0x1BCBD2E54);
      }
      uint64_t v76 = v75;
      uint64_t v77 = sub_1BD2E4640();
      unint64_t v79 = v78;

      switch(v79 >> 62)
      {
        case 1uLL:
          uint64_t v81 = AssociatedConformanceWitness;
          sub_1BCBD44A0(v77, v79);
          LODWORD(v80) = HIDWORD(v77) - v77;
          if (__OFSUB__(HIDWORD(v77), v77)) {
            goto LABEL_56;
          }
          uint64_t v80 = (int)v80;
LABEL_35:
          uint64_t v84 = a1;
          uint64_t AssociatedConformanceWitness = v81;
          goto LABEL_38;
        case 2uLL:
          uint64_t v81 = AssociatedConformanceWitness;
          uint64_t v83 = *(void *)(v77 + 16);
          uint64_t v82 = *(void *)(v77 + 24);
          sub_1BCBD44A0(v77, v79);
          uint64_t v80 = v82 - v83;
          if (!__OFSUB__(v82, v83)) {
            goto LABEL_35;
          }
          __break(1u);
LABEL_56:
          __break(1u);
          goto LABEL_57;
        case 3uLL:
          sub_1BCBD44A0(v77, v79);
          uint64_t v80 = 0;
          goto LABEL_37;
        default:
          sub_1BCBD44A0(v77, v79);
          uint64_t v80 = BYTE6(v79);
LABEL_37:
          uint64_t v84 = a1;
LABEL_38:
          if (*(void *)((char *)v5 + *(void *)((*MEMORY[0x1E4FBC8C8] & *v5) + 0x60)) < v80)
          {
            uint64_t v85 = AssociatedConformanceWitness;
            id v86 = type;
            unsigned int v87 = sub_1BD2E46B0();
            os_log_type_t v88 = sub_1BD2E4840();
            if (os_log_type_enabled(v87, v88))
            {
              uint64_t v89 = swift_slowAlloc();
              v115 = (void *)swift_slowAlloc();
              v131[0] = v115;
              *(_DWORD *)uint64_t v89 = 136446466;
              v114 = v87;
              uint64_t v90 = sub_1BD2E4AC0();
              sub_1BCBD1058(v90, v91, (uint64_t *)v131);
              sub_1BD2E4890();
              swift_bridgeObjectRelease();
              *(_WORD *)(v89 + 12) = 2048;
              char v92 = (void *)v120(AssociatedTypeWitness, v85);

              id v130 = v92;
              sub_1BD2E4890();

              _os_log_impl(&dword_1BCB7D000, v114, v88, "[%{public}s] Merged state's size above the limit, purge metadata and increment epoch, previous: %lld", (uint8_t *)v89, 0x16u);
              swift_arrayDestroy();
              MEMORY[0x1C187C9C0](v115, -1, -1);
              uint64_t v93 = v89;
              uint64_t v84 = a1;
              MEMORY[0x1C187C9C0](v93, -1, -1);
            }
            else
            {
            }
            (*(void (**)(uint64_t, uint64_t))(v85 + 48))(AssociatedTypeWitness, v85);
          }
          id v94 = type;
          *uint64_t v84 = type;
          id v95 = v94;
          if ((objc_msgSend(v95, sel_isEqual_, v125) & 1) == 0)
          {
            char v104 = sub_1BD2E46B0();
            os_log_type_t v105 = sub_1BD2E4850();
            if (os_log_type_enabled(v104, v105))
            {
              uint64_t v106 = (uint8_t *)swift_slowAlloc();
              v107 = (void *)swift_slowAlloc();
              v131[0] = v107;
              *(_DWORD *)uint64_t v106 = 136446210;
              uint64_t v108 = sub_1BD2E4AC0();
              id v130 = (id)sub_1BCBD1058(v108, v109, (uint64_t *)v131);
              sub_1BD2E4890();
              swift_bridgeObjectRelease();
              _os_log_impl(&dword_1BCB7D000, v104, v105, "[%{public}s] Update cloud state", v106, 0xCu);
              swift_arrayDestroy();
              MEMORY[0x1C187C9C0](v107, -1, -1);
              MEMORY[0x1C187C9C0](v106, -1, -1);
            }

            goto LABEL_25;
          }
          unsigned __int8 v96 = objc_msgSend(v95, sel_isEqual_, v10);
          char v97 = sub_1BD2E46B0();
          os_log_type_t v98 = sub_1BD2E4850();
          BOOL v99 = os_log_type_enabled(v97, v98);
          if (v96)
          {
            if (v99)
            {
              uint64_t v100 = (uint8_t *)swift_slowAlloc();
              uint64_t v101 = (void *)swift_slowAlloc();
              v131[0] = v101;
              *(_DWORD *)uint64_t v100 = 136446210;
              uint64_t v102 = sub_1BD2E4AC0();
              id v130 = (id)sub_1BCBD1058(v102, v103, (uint64_t *)v131);
              sub_1BD2E4890();
              swift_bridgeObjectRelease();
              _os_log_impl(&dword_1BCB7D000, v97, v98, "[%{public}s] No update required", v100, 0xCu);
              uint64_t v53 = 1;
              swift_arrayDestroy();
              MEMORY[0x1C187C9C0](v101, -1, -1);
              MEMORY[0x1C187C9C0](v100, -1, -1);

              swift_unknownObjectRelease();
              swift_unknownObjectRelease();
            }
            else
            {

              swift_unknownObjectRelease();
              swift_unknownObjectRelease();
              return 1;
            }
            return v53;
          }
          if (v99)
          {
            v110 = (uint8_t *)swift_slowAlloc();
            v111 = (void *)swift_slowAlloc();
            v131[0] = v111;
            *(_DWORD *)v110 = 136446210;
            uint64_t v112 = sub_1BD2E4AC0();
            id v130 = (id)sub_1BCBD1058(v112, v113, (uint64_t *)v131);
            sub_1BD2E4890();
            swift_bridgeObjectRelease();
            _os_log_impl(&dword_1BCB7D000, v97, v98, "[%{public}s] Update local state", v110, 0xCu);
            swift_arrayDestroy();
            MEMORY[0x1C187C9C0](v111, -1, -1);
            MEMORY[0x1C187C9C0](v110, -1, -1);
          }

          break;
      }
      goto LABEL_20;
    }
    swift_unknownObjectRetain_n();
    swift_unknownObjectRetain_n();
    unsigned int v55 = sub_1BD2E46B0();
    os_log_type_t v56 = sub_1BD2E4850();
    if (os_log_type_enabled(v55, v56))
    {
      uint64_t v57 = swift_slowAlloc();
      v128 = (void *)swift_slowAlloc();
      v131[0] = v128;
      *(_DWORD *)uint64_t v57 = 136446722;
      loga = v55;
      uint64_t v58 = sub_1BD2E4AC0();
      sub_1BCBD1058(v58, v59, (uint64_t *)v131);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      *(_WORD *)(v57 + 12) = 2048;
      os_log_type_t v124 = v56;
      v12(AssociatedTypeWitness, AssociatedConformanceWitness);
      swift_unknownObjectRelease();
      sub_1BD2E4890();
      swift_unknownObjectRelease();
      *(_WORD *)(v57 + 22) = 2048;
      char v60 = (void *)v12(AssociatedTypeWitness, AssociatedConformanceWitness);
      swift_unknownObjectRelease();
      id v130 = v60;
      unsigned int v61 = a1;
      sub_1BD2E4890();
      swift_unknownObjectRelease();
      _os_log_impl(&dword_1BCB7D000, loga, v124, "[%{public}s] Choosing local state, it has a higher epoch (%lld vs %lld)", (uint8_t *)v57, 0x20u);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v128, -1, -1);
      MEMORY[0x1C187C9C0](v57, -1, -1);
    }
    else
    {

      swift_unknownObjectRelease_n();
      swift_unknownObjectRelease_n();
      unsigned int v61 = a1;
    }
    uint64_t v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 32))(AssociatedTypeWitness, AssociatedConformanceWitness);
    id v73 = v72;
    void *v61 = v72;
LABEL_25:
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    return 3;
  }
  else
  {
    swift_unknownObjectRetain_n();
    swift_unknownObjectRetain_n();
    uint64_t v22 = sub_1BD2E46B0();
    os_log_type_t v23 = sub_1BD2E4840();
    if (os_log_type_enabled(v22, v23))
    {
      uint64_t v24 = swift_slowAlloc();
      v126 = (void *)swift_slowAlloc();
      v131[0] = v126;
      *(_DWORD *)uint64_t v24 = 136446722;
      uint64_t v25 = sub_1BD2E4AC0();
      sub_1BCBD1058(v25, v26, (uint64_t *)v131);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      *(_WORD *)(v24 + 12) = 2080;
      sub_1BCBD2ECC();
      swift_unknownObjectRetain();
      uint64_t v27 = sub_1BD2E4780();
      sub_1BCBD1058(v27, v28, (uint64_t *)v131);
      sub_1BD2E4890();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      *(_WORD *)(v24 + 22) = 2080;
      swift_unknownObjectRetain();
      uint64_t v29 = sub_1BD2E4780();
      id v130 = (id)sub_1BCBD1058(v29, v30, (uint64_t *)v131);
      sub_1BD2E4890();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v22, v23, "[%{public}s] Unexpected type for object, cloud: %s local: %s", (uint8_t *)v24, 0x20u);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v126, -1, -1);
      MEMORY[0x1C187C9C0](v24, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
      swift_unknownObjectRelease_n();
    }

    v131[3] = (id)swift_getObjectType();
    v131[0] = a2;
    swift_unknownObjectRetain();
    uint64_t v31 = sub_1BCBD046C(v131);
    uint64_t v33 = v32;
    __swift_destroy_boxed_opaque_existential_0((uint64_t)v131);
    type metadata accessor for EpochBasedSyncStateUpdaterDelegate.Failure();
    swift_getWitnessTable();
    unint64_t v34 = (void *)swift_allocError();
    *char v35 = v31;
    v35[1] = v33;
    swift_willThrow();
    v131[0] = v34;
    sub_1BCBD4408();
    sub_1BCBD4460();
    swift_dynamicCast();
    id v36 = v130;
    if (a4)
    {
      id v37 = v130;
      *a4 = v130;
      id v38 = v37;
    }
    swift_unknownObjectRetain_n();
    swift_unknownObjectRetain_n();
    id v39 = v36;
    char v40 = sub_1BD2E46B0();
    os_log_type_t v41 = sub_1BD2E4840();
    if (os_log_type_enabled(v40, v41))
    {
      uint64_t v42 = swift_slowAlloc();
      uint64_t v127 = swift_slowAlloc();
      uint64_t v129 = v127;
      *(_DWORD *)uint64_t v42 = 136446978;
      uint64_t v43 = sub_1BD2E4AC0();
      sub_1BCBD1058(v43, v44, &v129);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      *(_WORD *)(v42 + 12) = 2080;
      id v45 = objc_msgSend(v39, sel_localizedDescription);
      uint64_t v46 = sub_1BD2E4770();
      unint64_t v48 = v47;

      sub_1BCBD1058(v46, v48, &v129);
      sub_1BD2E4890();

      swift_bridgeObjectRelease();
      *(_WORD *)(v42 + 22) = 2080;
      sub_1BCBD2ECC();
      swift_unknownObjectRetain();
      uint64_t v49 = sub_1BD2E4780();
      sub_1BCBD1058(v49, v50, &v129);
      sub_1BD2E4890();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      *(_WORD *)(v42 + 32) = 2080;
      swift_unknownObjectRetain();
      uint64_t v51 = sub_1BD2E4780();
      sub_1BCBD1058(v51, v52, &v129);
      sub_1BD2E4890();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v40, v41, "[%{public}s] Error when trying to update: %s local: %s cloud: %s", (uint8_t *)v42, 0x2Au);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v127, -1, -1);
      MEMORY[0x1C187C9C0](v42, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
      swift_unknownObjectRelease_n();
    }
    return 0;
  }
}

uint64_t __swift_destroy_boxed_opaque_existential_0(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 24) - 8);
  if ((*(unsigned char *)(v1 + 82) & 2) != 0) {
    return swift_release();
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

uint64_t type metadata accessor for EpochBasedSyncStateUpdaterDelegate.Failure()
{
  return __swift_instantiateGenericMetadata();
}

unint64_t sub_1BCBD2ECC()
{
  unint64_t result = qword_1E9FBD9D8;
  if (!qword_1E9FBD9D8)
  {
    unint64_t result = swift_getExistentialTypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1E9FBD9D8);
  }
  return result;
}

uint64_t sub_1BCBD2F24(uint64_t a1)
{
  uint64_t v2 = v1;
  swift_getObjectType();
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v5 = swift_dynamicCastUnknownClass();
  swift_unknownObjectRetain_n();
  if (v5)
  {
    swift_unknownObjectRetain();
    unint64_t v6 = sub_1BD2E46B0();
    os_log_type_t type = sub_1BD2E4830();
    if (os_log_type_enabled(v6, type))
    {
      uint64_t v7 = swift_slowAlloc();
      uint64_t v26 = swift_slowAlloc();
      v28[0] = v26;
      *(_DWORD *)uint64_t v7 = 136446466;
      uint64_t v8 = sub_1BD2E4AC0();
      uint64_t v29 = sub_1BCBD1058(v8, v9, v28);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      *(_WORD *)(v7 + 12) = 2080;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 56))(AssociatedTypeWitness, AssociatedConformanceWitness);
      uint64_t v29 = sub_1BCBD1058(v11, v12, v28);
      sub_1BD2E4890();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v6, type, "[%{public}s] Persisting cloud state locally: %s", (uint8_t *)v7, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v26, -1, -1);
      MEMORY[0x1C187C9C0](v7, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
    }

    (*(void (**)(uint64_t, void))(*(void *)((*MEMORY[0x1E4FBC8C8] & *v2) + 0x58) + 24))(v5, *(void *)((*MEMORY[0x1E4FBC8C8] & *v2) + 0x50));
    return swift_unknownObjectRelease();
  }
  else
  {
    uint64_t v13 = sub_1BD2E46B0();
    os_log_type_t v14 = sub_1BD2E4840();
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = swift_slowAlloc();
      uint64_t v16 = swift_slowAlloc();
      v28[0] = v16;
      *(_DWORD *)uint64_t v15 = 136446466;
      uint64_t v17 = sub_1BD2E4AC0();
      uint64_t v29 = sub_1BCBD1058(v17, v18, v28);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      *(_WORD *)(v15 + 12) = 2080;
      uint64_t v29 = a1;
      sub_1BCBD2ECC();
      swift_unknownObjectRetain();
      uint64_t v19 = sub_1BD2E4780();
      uint64_t v29 = sub_1BCBD1058(v19, v20, v28);
      sub_1BD2E4890();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v13, v14, "[%{public}s] returned object is not the expected type: %s", (uint8_t *)v15, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v16, -1, -1);
      MEMORY[0x1C187C9C0](v15, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
    }

    v28[3] = swift_getObjectType();
    v28[0] = a1;
    swift_unknownObjectRetain();
    uint64_t v22 = sub_1BCBD046C(v28);
    uint64_t v24 = v23;
    __swift_destroy_boxed_opaque_existential_0((uint64_t)v28);
    type metadata accessor for EpochBasedSyncStateUpdaterDelegate.Failure();
    swift_getWitnessTable();
    swift_allocError();
    uint64_t *v25 = v22;
    v25[1] = v24;
    return swift_willThrow();
  }
}

void sub_1BCBD3440(void *a1)
{
  swift_getObjectType();
  unint64_t v4 = (void *)(*(uint64_t (**)(void, void))(*(void *)((*MEMORY[0x1E4FBC8C8] & *v1) + 0x58) + 32))(*(void *)((*MEMORY[0x1E4FBC8C8] & *v1) + 0x50), *(void *)((*MEMORY[0x1E4FBC8C8] & *v1) + 0x58));
  if (!v2)
  {
    uint64_t v5 = v4;
    id v6 = v4;
    uint64_t v7 = sub_1BD2E46B0();
    os_log_type_t v8 = sub_1BD2E4850();
    if (os_log_type_enabled(v7, v8))
    {
      unint64_t v20 = a1;
      uint64_t v9 = swift_slowAlloc();
      uint64_t v19 = swift_slowAlloc();
      uint64_t v21 = v19;
      *(_DWORD *)uint64_t v9 = 136446466;
      uint64_t v10 = sub_1BD2E4AC0();
      sub_1BCBD1058(v10, v11, &v21);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      *(_WORD *)(v9 + 12) = 2080;
      if (v5)
      {
        swift_getAssociatedTypeWitness();
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
        unint64_t v18 = v7;
        uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 56);
        uint64_t v14 = swift_checkMetadataState();
        uint64_t v15 = v13(v14, AssociatedConformanceWitness);
        uint64_t v7 = v18;
        unint64_t v17 = v16;
      }
      else
      {
        unint64_t v17 = 0xE300000000000000;
        uint64_t v15 = 7104878;
      }
      sub_1BCBD1058(v15, v17, &v21);
      sub_1BD2E4890();

      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v7, v8, "%{public}s Retrieved local state: %s", (uint8_t *)v9, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v19, -1, -1);
      MEMORY[0x1C187C9C0](v9, -1, -1);

      a1 = v20;
    }
    else
    {
    }
    *a1 = v5;
  }
}

uint64_t sub_1BCBD3738(void *a1, void *a2, void *a3)
{
  v46[4] = *MEMORY[0x1E4F143B8];
  swift_getObjectType();
  uint64_t v6 = *MEMORY[0x1E4FBC8C8] & *v3;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t ObjCClassFromMetadata = swift_getObjCClassFromMetadata();
  uint64_t v9 = *(int *)((char *)v3 + *(void *)(v6 + 128));
  id v45 = 0;
  v46[0] = 0;
  unsigned int v10 = objc_msgSend(a2, sel_decodedObjectOfClass_version_decodedObject_error_, ObjCClassFromMetadata, v9, v46, &v45);
  id v12 = v45;
  unint64_t v11 = (void *)v46[0];
  if (!v10)
  {
    id v23 = v45;
    swift_unknownObjectRetain();
    uint64_t v24 = (void *)sub_1BD2E4630();

    swift_willThrow();
    swift_unknownObjectRelease();
    if (!a3)
    {
LABEL_8:

      return 0;
    }
LABEL_7:
    uint64_t v25 = (void *)sub_1BD2E4620();
    id v26 = v25;
    *a3 = v25;
    goto LABEL_8;
  }
  if (!v46[0])
  {
    id v28 = v45;
    return 2;
  }
  uint64_t v13 = (void *)swift_dynamicCastUnknownClass();
  swift_unknownObjectRetain_n();
  if (!v13)
  {
    id v29 = v12;
    swift_unknownObjectRetain();
    unint64_t v30 = sub_1BD2E46B0();
    uint64_t v31 = sub_1BD2E4840();
    if (os_log_type_enabled(v30, (os_log_type_t)v31))
    {
      uint64_t v32 = swift_slowAlloc();
      uint64_t v33 = swift_slowAlloc();
      v46[0] = v33;
      *(_DWORD *)uint64_t v32 = 136446466;
      uint64_t v34 = sub_1BD2E4AC0();
      id v45 = (id)sub_1BCBD1058(v34, v35, v46);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      *(_WORD *)(v32 + 12) = 2080;
      id v45 = v11;
      sub_1BCBD2ECC();
      swift_unknownObjectRetain();
      uint64_t v36 = sub_1BD2E4780();
      id v45 = (id)sub_1BCBD1058(v36, v37, v46);
      sub_1BD2E4890();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v30, (os_log_type_t)v31, "[%{public}s] object is not of the expected type: %s", (uint8_t *)v32, 0x16u);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v33, -1, -1);
      MEMORY[0x1C187C9C0](v32, -1, -1);
    }
    else
    {
      swift_unknownObjectRelease_n();
    }

    v46[3] = swift_getObjectType();
    v46[0] = (uint64_t)v11;
    swift_unknownObjectRetain();
    uint64_t v39 = sub_1BCBD046C(v46);
    uint64_t v41 = v40;
    __swift_destroy_boxed_opaque_existential_0((uint64_t)v46);
    type metadata accessor for EpochBasedSyncStateUpdaterDelegate.Failure();
    swift_getWitnessTable();
    uint64_t v24 = (void *)swift_allocError();
    uint64_t *v42 = v39;
    v42[1] = v41;
    swift_willThrow();
    swift_unknownObjectRelease_n();
    if (!a3) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  swift_unknownObjectRetain_n();
  id v14 = v12;
  uint64_t v15 = sub_1BD2E46B0();
  os_log_type_t v16 = sub_1BD2E4850();
  if (os_log_type_enabled(v15, v16))
  {
    uint64_t v17 = swift_slowAlloc();
    uint64_t v43 = swift_slowAlloc();
    v46[0] = v43;
    *(_DWORD *)uint64_t v17 = 136446466;
    uint64_t v18 = sub_1BD2E4AC0();
    id v45 = (id)sub_1BCBD1058(v18, v19, v46);
    sub_1BD2E4890();
    swift_bridgeObjectRelease();
    *(_WORD *)(v17 + 12) = 2080;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness();
    uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t))(AssociatedConformanceWitness + 56))(AssociatedTypeWitness, AssociatedConformanceWitness);
    id v45 = (id)sub_1BCBD1058(v21, v22, v46);
    sub_1BD2E4890();
    swift_unknownObjectRelease_n();
    swift_bridgeObjectRelease();
    _os_log_impl(&dword_1BCB7D000, v15, v16, "[%{public}s] Retrieved cloud data: %s", (uint8_t *)v17, 0x16u);
    swift_arrayDestroy();
    MEMORY[0x1C187C9C0](v43, -1, -1);
    MEMORY[0x1C187C9C0](v17, -1, -1);
  }
  else
  {
    swift_unknownObjectRelease_n();
  }

  id v38 = v13;
  *a1 = v13;
  swift_unknownObjectRelease_n();
  return 1;
}

void sub_1BCBD3CDC()
{
}

uint64_t type metadata accessor for EpochBasedSyncStateUpdaterDelegate()
{
  return __swift_instantiateGenericMetadata();
}

uint64_t dispatch thunk of LocalStorageProvider.setModel(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of LocalStorageProvider.fetchLocallyPersistedData()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.epoch.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.epoch.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.epoch.modify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.makeCopy()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.merge(with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.purgeCoherentMetadataAndIncrementEpoch()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of EpochBasedLocalStorageCoding.logDescription.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t sub_1BCBD3E2C()
{
  uint64_t result = sub_1BD2E46C0();
  if (v1 <= 0x3F)
  {
    uint64_t result = swift_checkMetadataState();
    if (v2 <= 0x3F)
    {
      uint64_t result = swift_initClassMetadata2();
      if (!result) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t method lookup function for EpochBasedSyncStateUpdaterDelegate(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for EpochBasedSyncStateUpdaterDelegate);
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.__allocating_init(logger:key:supportedSyncVersionRange:domain:store:maxDataSizeInBytes:)()
{
  return (*(uint64_t (**)(void))(v0 + 144))();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.shouldUpdate(withMergedState:cloudState:localState:profile:transaction:error:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xA0))();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.update(_:withMergeState:profile:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xA8))();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.persistCloudState(_:profile:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xB0))();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.fetchLocalState(_:profile:transaction:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xB8))();
}

uint64_t dispatch thunk of EpochBasedSyncStateUpdaterDelegate.fetchCloudState(_:codableSyncState:profile:error:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xC0))();
}

void *__swift_memcpy8_4(void *result, void *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t sub_1BCBD409C(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_1BCBD40BC(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)uint64_t result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 8) = v3;
  return result;
}

void type metadata accessor for HDSyncVersionRange(uint64_t a1)
{
}

void type metadata accessor for os_unfair_lock_s(uint64_t a1)
{
}

uint64_t sub_1BCBD4134(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F41863F8](a1, a2, a3, 16);
}

void *sub_1BCBD413C(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t sub_1BCBD416C()
{
  return swift_bridgeObjectRelease();
}

void *sub_1BCBD4174(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

void *sub_1BCBD41C4(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t sub_1BCBD41F8(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7FFFFFFF && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  }
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  if ((v3 + 1) >= 2) {
    return v3;
  }
  else {
    return 0;
  }
}

uint64_t sub_1BCBD4248(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(void *)__n128 result = 0;
    *(void *)(result + 8) = 0;
    *(_DWORD *)__n128 result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 16) = 0;
    }
    if (a2) {
      *(void *)(result + 8) = a2;
    }
  }
  return result;
}

uint64_t sub_1BCBD429C(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 8);
  if (v1 >= 0xFFFFFFFF) {
    LODWORD(v1) = -1;
  }
  return (v1 + 1);
}

void *sub_1BCBD42B8(void *result, int a2)
{
  if (a2 < 0)
  {
    *__n128 result = a2 ^ 0x80000000;
    result[1] = 0;
  }
  else if (a2)
  {
    result[1] = (a2 - 1);
  }
  return result;
}

uint64_t sub_1BCBD42D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

void sub_1BCBD4334(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t (*a4)(void, uint64_t))
{
  if (!*a2)
  {
    unint64_t v5 = a4(0, a3);
    if (!v6) {
      atomic_store(v5, a2);
    }
  }
}

void *__swift_project_boxed_opaque_existential_0(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80)));
  return result;
}

unint64_t sub_1BCBD43C8()
{
  unint64_t result = qword_1E9FBDC18;
  if (!qword_1E9FBDC18)
  {
    unint64_t result = swift_getExistentialMetatypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1E9FBDC18);
  }
  return result;
}

unint64_t sub_1BCBD4408()
{
  unint64_t result = qword_1E9FBDC20;
  if (!qword_1E9FBDC20)
  {
    unint64_t result = swift_getExistentialTypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1E9FBDC20);
  }
  return result;
}

unint64_t sub_1BCBD4460()
{
  unint64_t result = qword_1E9FBDC28;
  if (!qword_1E9FBDC28)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_1E9FBDC28);
  }
  return result;
}

uint64_t sub_1BCBD44A0(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_release();
  }

  return swift_release();
}

uint64_t __swift_instantiateGenericMetadata()
{
  return swift_getGenericMetadata();
}

uint64_t sub_1BCBD4570()
{
  uint64_t v1 = OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker;
  if (*(void *)((char *)v0 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker))
  {
    uint64_t v2 = *(void *)((char *)v0 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker);
  }
  else
  {
    uint64_t v2 = (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xB8))();
    *(void *)((char *)v0 + v1) = v2;
    swift_unknownObjectRetain();
    swift_unknownObjectRelease();
  }
  swift_unknownObjectRetain();
  return v2;
}

uint64_t sub_1BCBD464C(uint64_t a1)
{
  *(void *)(v1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker) = a1;
  return swift_unknownObjectRelease();
}

uint64_t (*sub_1BCBD4664(uint64_t *a1))(void *a1)
{
  a1[1] = v1;
  *a1 = sub_1BCBD4570();
  return sub_1BCBD46AC;
}

uint64_t sub_1BCBD46AC(void *a1)
{
  *(void *)(a1[1] + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker) = *a1;
  return swift_unknownObjectRelease();
}

char *HDSwimTracker.__allocating_init(profile:)(void *a1)
{
  id v3 = objc_allocWithZone(v1);
  return HDSwimTracker.init(profile:)(a1);
}

char *HDSwimTracker.init(profile:)(void *a1)
{
  *(void *)&v1[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker] = 0;
  uint64_t v3 = OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers;
  unint64_t v4 = (void *)*MEMORY[0x1E4F29FB8];
  id v5 = objc_allocWithZone(MEMORY[0x1E4F2B5F0]);
  uint64_t v6 = v1;
  id v7 = v4;
  os_log_type_t v8 = (void *)sub_1BD2E4760();
  id v9 = objc_msgSend(v5, sel_initWithName_loggingCategory_, v8, v7);

  *(void *)&v1[v3] = v9;
  *(void *)&v6[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData] = 0;
  uint64_t v10 = OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_startLock;
  sub_1BCBD48C4(0, &qword_1E9FBDD70);
  uint64_t v11 = swift_allocObject();
  *(_DWORD *)(v11 + 20) = 0;
  *(unsigned char *)(v11 + 16) = 0;
  *(void *)&v6[v10] = v11;
  uint64_t v12 = OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_generalLock;
  sub_1BCBD48C4(0, &qword_1E9FBDD80);
  uint64_t v13 = swift_allocObject();
  *(_DWORD *)(v13 + 16) = 0;
  *(void *)&v6[v12] = v13;
  id v14 = objc_allocWithZone((Class)type metadata accessor for HDSwimmingDataCollector());
  id v15 = a1;
  *(void *)&v6[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_dataCollector] = HDSwimmingDataCollector.init(profile:)(v15);

  v22.receiver = v6;
  v22.super_class = (Class)type metadata accessor for HDSwimTracker();
  os_log_type_t v16 = (char *)objc_msgSendSuper2(&v22, sel_init);
  uint64_t v17 = *(void **)&v16[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_dataCollector];
  uint64_t v18 = *(void **)&v16[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers];
  unint64_t v19 = v16;
  id v20 = v17;
  objc_msgSend(v18, sel_registerObserver_, v20);

  return v19;
}

void sub_1BCBD48C4(uint64_t a1, unint64_t *a2)
{
  if (!*a2)
  {
    type metadata accessor for os_unfair_lock_s(255);
    unint64_t v3 = sub_1BD2E4910();
    if (!v4) {
      atomic_store(v3, a2);
    }
  }
}

id sub_1BCBD494C()
{
  id v0 = objc_msgSend(objc_allocWithZone(MEMORY[0x1E4F222A8]), sel_init);
  uint64_t v1 = (objc_class *)type metadata accessor for HDCMSwimTracker();
  uint64_t v2 = (char *)objc_allocWithZone(v1);
  *(void *)&v2[OBJC_IVAR____TtC12HealthDaemon15HDCMSwimTracker_tracker] = v0;
  v6.receiver = v2;
  v6.super_class = v1;
  id v3 = v0;
  id v4 = objc_msgSendSuper2(&v6, sel_init);

  return v4;
}

void sub_1BCBD4A94()
{
  uint64_t v1 = v0;
  uint64_t ObjectType = swift_getObjectType();
  id v3 = *(os_unfair_lock_s **)(v0 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_startLock);
  id v4 = v3 + 4;
  id v5 = v3 + 5;
  os_unfair_lock_lock(v3 + 5);
  sub_1BCBD4F54(v4, aBlock);
  os_unfair_lock_unlock(v5);
  if (LOBYTE(aBlock[0]) == 1)
  {
    if (qword_1E9FBD970 != -1) {
      swift_once();
    }
    uint64_t v6 = sub_1BD2E46C0();
    __swift_project_value_buffer(v6, (uint64_t)qword_1E9FC52E8);
    id v7 = sub_1BD2E46B0();
    os_log_type_t v8 = sub_1BD2E4850();
    if (os_log_type_enabled(v7, v8))
    {
      id v9 = (uint8_t *)swift_slowAlloc();
      uint64_t v10 = swift_slowAlloc();
      aBlock[0] = v10;
      *(_DWORD *)id v9 = 136446210;
      uint64_t v11 = sub_1BD2E4AC0();
      uint64_t v36 = sub_1BCBD1058(v11, v12, aBlock);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v7, v8, "%{public}s Starting monitoring for swim updates", v9, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v10, -1, -1);
      MEMORY[0x1C187C9C0](v9, -1, -1);
    }

    id v13 = objc_allocWithZone(MEMORY[0x1E4F222A0]);
    id v14 = (void *)sub_1BD2E4680();
    id v15 = objc_msgSend(v13, sel_initWithSessionId_, v14);

    os_log_type_t v16 = (objc_class *)type metadata accessor for HDCMSwimData();
    uint64_t v17 = (char *)objc_allocWithZone(v16);
    *(void *)&v17[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data] = v15;
    v35.receiver = v17;
    v35.super_class = v16;
    id v18 = objc_msgSendSuper2(&v35, sel_init);
    uint64_t v19 = OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData;
    id v20 = *(void **)(v1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData);
    *(void *)(v1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData) = v18;

    uint64_t v21 = (void *)sub_1BCBD4570();
    objc_super v22 = *(void **)(v1 + v19);
    uint64_t v23 = swift_allocObject();
    swift_unknownObjectWeakInit();
    uint64_t v24 = swift_allocObject();
    *(void *)(v24 + 16) = v23;
    *(void *)(v24 + 24) = ObjectType;
    aBlock[4] = (uint64_t)sub_1BCBD6468;
    void aBlock[5] = v24;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1107296256;
    aBlock[2] = (uint64_t)sub_1BCBD51A8;
    aBlock[3] = (uint64_t)&block_descriptor;
    uint64_t v25 = _Block_copy(aBlock);
    id v26 = v22;
    swift_release();
    objc_msgSend(v21, sel_startUpdatesFromRecord_handler_, v26, v25);
    _Block_release(v25);
    swift_unknownObjectRelease();
  }
  else
  {
    if (qword_1E9FBD970 != -1) {
      swift_once();
    }
    uint64_t v27 = sub_1BD2E46C0();
    __swift_project_value_buffer(v27, (uint64_t)qword_1E9FC52E8);
    osos_log_t log = sub_1BD2E46B0();
    os_log_type_t v28 = sub_1BD2E4850();
    if (os_log_type_enabled(oslog, v28))
    {
      id v29 = (uint8_t *)swift_slowAlloc();
      uint64_t v30 = swift_slowAlloc();
      aBlock[0] = v30;
      *(_DWORD *)id v29 = 136446210;
      uint64_t v31 = sub_1BD2E4AC0();
      uint64_t v36 = sub_1BCBD1058(v31, v32, aBlock);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, oslog, v28, "%{public}s Start called twice. Ignoring...", v29, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v30, -1, -1);
      MEMORY[0x1C187C9C0](v29, -1, -1);
    }
    else
    {
    }
  }
}

unsigned char *sub_1BCBD4F54@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X8>)
{
  if (*result)
  {
    *a2 = 0;
  }
  else
  {
    *uint64_t result = 1;
    *a2 = 1;
  }
  return result;
}

void sub_1BCBD4F74(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (a1 >> 62)
    {
      swift_bridgeObjectRetain();
      uint64_t v7 = sub_1BD2E49B0();
      swift_bridgeObjectRelease();
      if (v7 >= 1)
      {
LABEL_4:
        swift_beginAccess();
        uint64_t v5 = MEMORY[0x1C187CA40](a3 + 16);
        if (v5)
        {
          uint64_t v6 = (void *)v5;
          sub_1BCBD5750(a1);
        }
        return;
      }
    }
    else if (*(uint64_t *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10) >= 1)
    {
      goto LABEL_4;
    }
  }
  if (qword_1E9FBD970 != -1) {
    swift_once();
  }
  uint64_t v8 = sub_1BD2E46C0();
  __swift_project_value_buffer(v8, (uint64_t)qword_1E9FC52E8);
  osos_log_t log = sub_1BD2E46B0();
  os_log_type_t v9 = sub_1BD2E4840();
  if (os_log_type_enabled(oslog, v9))
  {
    uint64_t v10 = (uint8_t *)swift_slowAlloc();
    uint64_t v11 = swift_slowAlloc();
    v15[0] = v11;
    *(_DWORD *)uint64_t v10 = 136446210;
    uint64_t v12 = sub_1BD2E4AC0();
    v15[3] = sub_1BCBD1058(v12, v13, v15);
    sub_1BD2E4890();
    swift_bridgeObjectRelease();
    _os_log_impl(&dword_1BCB7D000, oslog, v9, "%{public}s Received nil or empty swim data from core motion", v10, 0xCu);
    swift_arrayDestroy();
    MEMORY[0x1C187C9C0](v11, -1, -1);
    MEMORY[0x1C187C9C0](v10, -1, -1);
  }
  else
  {
  }
}

uint64_t sub_1BCBD51A8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = *(void (**)(uint64_t, void *))(a1 + 32);
  if (a2)
  {
    type metadata accessor for HDCMSwimData();
    uint64_t v4 = sub_1BD2E47E0();
  }
  swift_retain();
  id v6 = a3;
  v5(v4, a3);
  swift_release();

  return swift_bridgeObjectRelease();
}

void sub_1BCBD5324()
{
  swift_getObjectType();
  if (qword_1E9FBD970 != -1) {
    swift_once();
  }
  uint64_t v0 = sub_1BD2E46C0();
  __swift_project_value_buffer(v0, (uint64_t)qword_1E9FC52E8);
  uint64_t v1 = sub_1BD2E46B0();
  os_log_type_t v2 = sub_1BD2E4850();
  if (os_log_type_enabled(v1, v2))
  {
    id v3 = (uint8_t *)swift_slowAlloc();
    uint64_t v4 = swift_slowAlloc();
    uint64_t v10 = v4;
    *(_DWORD *)id v3 = 136446210;
    uint64_t v5 = sub_1BD2E4AC0();
    sub_1BCBD1058(v5, v6, &v10);
    sub_1BD2E4890();
    swift_bridgeObjectRelease();
    _os_log_impl(&dword_1BCB7D000, v1, v2, "%{public}s Stopping swim updates", v3, 0xCu);
    swift_arrayDestroy();
    MEMORY[0x1C187C9C0](v4, -1, -1);
    MEMORY[0x1C187C9C0](v3, -1, -1);
  }

  uint64_t v7 = ((uint64_t (*)(void))MEMORY[0x1F4188790])();
  MEMORY[0x1F4188790](v7);
  os_log_type_t v9 = v8 + 4;
  os_unfair_lock_lock(v8 + 4);
  sub_1BCBD64A4();
  os_unfair_lock_unlock(v9);
}

uint64_t sub_1BCBD5530(uint64_t a1)
{
  objc_msgSend((id)sub_1BCBD4570(), sel_stopUpdates);
  swift_unknownObjectRelease();
  os_log_type_t v2 = *(void **)(a1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers);
  id v3 = objc_msgSend(v2, sel_allObservers);
  sub_1BCBD6AFC();
  unint64_t v4 = sub_1BD2E47E0();

  if (!(v4 >> 62))
  {
    uint64_t v5 = *(void *)((v4 & 0xFFFFFFFFFFFFFF8) + 0x10);
    uint64_t result = swift_bridgeObjectRetain();
    if (v5) {
      goto LABEL_3;
    }
    return swift_bridgeObjectRelease_n();
  }
  swift_bridgeObjectRetain();
  uint64_t result = sub_1BD2E49B0();
  uint64_t v5 = result;
  if (!result) {
    return swift_bridgeObjectRelease_n();
  }
LABEL_3:
  if (v5 >= 1)
  {
    for (uint64_t i = 0; i != v5; ++i)
    {
      if ((v4 & 0xC000000000000001) != 0)
      {
        uint64_t v8 = MEMORY[0x1C1879860](i, v4);
      }
      else
      {
        uint64_t v8 = *(void *)(v4 + 8 * i + 32);
        swift_unknownObjectRetain();
      }
      objc_msgSend(v2, sel_unregisterObserver_, v8);
      swift_unknownObjectRelease();
    }
    return swift_bridgeObjectRelease_n();
  }
  __break(1u);
  return result;
}

id sub_1BCBD56CC(uint64_t a1)
{
  return sub_1BCBD6528(a1, v1);
}

void sub_1BCBD5750(uint64_t a1)
{
  uint64_t ObjectType = swift_getObjectType();
  unint64_t v4 = *(void **)(v1 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData);
  if (v4)
  {
    id v5 = v4;
    unint64_t v6 = (void *)sub_1BCBD4570();
    uint64_t v7 = swift_allocObject();
    swift_unknownObjectWeakInit();
    uint64_t v8 = (void *)swift_allocObject();
    v8[2] = v5;
    void v8[3] = v7;
    v8[4] = a1;
    v8[5] = ObjectType;
    aBlock[4] = (uint64_t)sub_1BCBD679C;
    void aBlock[5] = (uint64_t)v8;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1107296256;
    aBlock[2] = (uint64_t)sub_1BCBD51A8;
    aBlock[3] = (uint64_t)&block_descriptor_15;
    os_log_type_t v9 = _Block_copy(aBlock);
    id v10 = v5;
    swift_bridgeObjectRetain();
    swift_release();
    objc_msgSend(v6, sel_querySwimUpdatesFromRecord_handler_, v10, v9);
    _Block_release(v9);
    swift_unknownObjectRelease();
  }
  else
  {
    if (qword_1E9FBD970 != -1) {
      swift_once();
    }
    uint64_t v11 = sub_1BD2E46C0();
    __swift_project_value_buffer(v11, (uint64_t)qword_1E9FC52E8);
    osos_log_t log = sub_1BD2E46B0();
    os_log_type_t v12 = sub_1BD2E4840();
    if (os_log_type_enabled(oslog, v12))
    {
      unint64_t v13 = (uint8_t *)swift_slowAlloc();
      uint64_t v14 = swift_slowAlloc();
      aBlock[0] = v14;
      *(_DWORD *)unint64_t v13 = 136446210;
      uint64_t v15 = sub_1BD2E4AC0();
      uint64_t aBlock[6] = sub_1BCBD1058(v15, v16, aBlock);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, oslog, v12, "%{public}s Reference is nil", v13, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v14, -1, -1);
      MEMORY[0x1C187C9C0](v13, -1, -1);
    }
    else
    {
    }
  }
}

void sub_1BCBD5A1C(unint64_t a1, uint64_t a2, char *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v8 = a4 + 16;
  if (!objc_msgSend(*(id *)&a3[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data], sel_recordId))
  {
    swift_beginAccess();
    uint64_t v9 = MEMORY[0x1C187CA40](v8);
    if (v9)
    {
      id v10 = (char *)v9;
      if (a5 >> 62)
      {
        swift_bridgeObjectRetain();
        uint64_t v11 = sub_1BD2E49B0();
        if (v11) {
          goto LABEL_5;
        }
      }
      else
      {
        uint64_t v11 = *(void *)((a5 & 0xFFFFFFFFFFFFFF8) + 0x10);
        swift_bridgeObjectRetain();
        if (v11)
        {
LABEL_5:
          if ((a5 & 0xC000000000000001) != 0)
          {
            id v12 = (id)MEMORY[0x1C1879860](0, a5);
          }
          else
          {
            if (!*(void *)((a5 & 0xFFFFFFFFFFFFFF8) + 0x10))
            {
              __break(1u);
              return;
            }
            id v12 = *(id *)(a5 + 32);
          }
          uint64_t v11 = (uint64_t)v12;
        }
      }
      swift_bridgeObjectRelease();
      unint64_t v13 = *(void **)&v10[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData];
      *(void *)&v10[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData] = v11;
    }
  }
  swift_beginAccess();
  uint64_t v14 = MEMORY[0x1C187CA40](v8);
  if (v14)
  {
    uint64_t v15 = (void *)v14;
    id v16 = *(id *)(v14 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers);

    uint64_t v17 = swift_allocObject();
    *(void *)(v17 + 16) = a5;
    *(void *)(v17 + 24) = a3;
    os_log_type_t v56 = sub_1BCBD67AC;
    uint64_t v57 = v17;
    id aBlock = (id)MEMORY[0x1E4F143A8];
    uint64_t v53 = 1107296256;
    uint64_t v54 = sub_1BCBD616C;
    unsigned int v55 = &block_descriptor_21;
    id v18 = _Block_copy(&aBlock);
    swift_bridgeObjectRetain();
    uint64_t v19 = a3;
    swift_release();
    objc_msgSend(v16, sel_notifyObservers_, v18);
    _Block_release(v18);
  }
  if (!a1) {
    goto LABEL_30;
  }
  if (!(a1 >> 62))
  {
    if (*(uint64_t *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10) >= 1) {
      goto LABEL_15;
    }
LABEL_30:
    if (qword_1E9FBD970 != -1) {
      swift_once();
    }
    uint64_t v45 = sub_1BD2E46C0();
    __swift_project_value_buffer(v45, (uint64_t)qword_1E9FC52E8);
    uint64_t v43 = sub_1BD2E46B0();
    os_log_type_t v46 = sub_1BD2E4840();
    if (os_log_type_enabled(v43, v46))
    {
      unint64_t v47 = (uint8_t *)swift_slowAlloc();
      unint64_t v48 = (void *)swift_slowAlloc();
      id aBlock = v48;
      *(_DWORD *)unint64_t v47 = 136446210;
      uint64_t v49 = sub_1BD2E4AC0();
      sub_1BCBD1058(v49, v50, (uint64_t *)&aBlock);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v43, v46, "%{public}s Queried swim data is nil or empty", v47, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v48, -1, -1);
      MEMORY[0x1C187C9C0](v47, -1, -1);
    }
LABEL_34:

    return;
  }
  swift_bridgeObjectRetain();
  uint64_t v44 = sub_1BD2E49B0();
  swift_bridgeObjectRelease();
  if (v44 < 1) {
    goto LABEL_30;
  }
LABEL_15:
  swift_beginAccess();
  uint64_t v20 = MEMORY[0x1C187CA40](v8);
  if (v20)
  {
    uint64_t v21 = (void *)v20;
    id v22 = *(id *)(v20 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers);

    uint64_t v23 = swift_allocObject();
    *(void *)(v23 + 16) = a1;
    *(void *)(v23 + 24) = a3;
    os_log_type_t v56 = sub_1BCBD6814;
    uint64_t v57 = v23;
    id aBlock = (id)MEMORY[0x1E4F143A8];
    uint64_t v53 = 1107296256;
    uint64_t v54 = sub_1BCBD616C;
    unsigned int v55 = &block_descriptor_27;
    uint64_t v24 = _Block_copy(&aBlock);
    uint64_t v25 = a3;
    swift_bridgeObjectRetain();
    swift_release();
    objc_msgSend(v22, sel_notifyObservers_, v24);
    _Block_release(v24);
  }
  id v26 = a3;
  unint64_t v27 = sub_1BCBD6838(a1, v26);
  char v29 = v28;

  MEMORY[0x1F4188790]();
  if ((v29 & 1) == 0)
  {
    uint64_t v58 = v27;
    sub_1BCBD6A20((unint64_t *)&v58, (unint64_t *)&aBlock);
    id v30 = aBlock;
    if (aBlock)
    {
      uint64_t v31 = qword_1E9FBD970;
      id v32 = aBlock;
      if (v31 != -1) {
        swift_once();
      }
      uint64_t v33 = sub_1BD2E46C0();
      __swift_project_value_buffer(v33, (uint64_t)qword_1E9FC52E8);
      id v34 = v32;
      objc_super v35 = sub_1BD2E46B0();
      os_log_type_t v36 = sub_1BD2E4850();
      if (os_log_type_enabled(v35, v36))
      {
        uint64_t v37 = swift_slowAlloc();
        id v38 = (void *)swift_slowAlloc();
        uint64_t v51 = (void *)swift_slowAlloc();
        id aBlock = v51;
        *(_DWORD *)uint64_t v37 = 136446466;
        uint64_t v39 = sub_1BD2E4AC0();
        uint64_t v58 = sub_1BCBD1058(v39, v40, (uint64_t *)&aBlock);
        sub_1BD2E4890();
        swift_bridgeObjectRelease();
        *(_WORD *)(v37 + 12) = 2112;
        uint64_t v58 = (uint64_t)v34;
        id v41 = v34;
        sub_1BD2E4890();
        void *v38 = v30;

        _os_log_impl(&dword_1BCB7D000, v35, v36, "%{public}s Setting swim reference to %@", (uint8_t *)v37, 0x16u);
        sub_1BCBD6A64();
        swift_arrayDestroy();
        MEMORY[0x1C187C9C0](v38, -1, -1);
        swift_arrayDestroy();
        MEMORY[0x1C187C9C0](v51, -1, -1);
        MEMORY[0x1C187C9C0](v37, -1, -1);
      }
      else
      {
      }
      swift_beginAccess();
      uint64_t v42 = (char *)MEMORY[0x1C187CA40](v8);
      if (!v42)
      {

        return;
      }
      uint64_t v43 = *(NSObject **)&v42[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData];
      *(void *)&v42[OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_referenceSwimData] = v30;

      goto LABEL_34;
    }
  }
}

uint64_t sub_1BCBD616C(uint64_t a1)
{
  uint64_t v1 = *(void (**)(uint64_t))(a1 + 32);
  swift_retain();
  uint64_t v2 = swift_unknownObjectRetain();
  v1(v2);
  swift_release();

  return swift_unknownObjectRelease();
}

void sub_1BCBD61CC(void *a1, uint64_t a2, uint64_t a3, SEL *a4)
{
  type metadata accessor for HDCMSwimData();
  id v7 = (id)sub_1BD2E47D0();
  objc_msgSend(a1, *a4, v7, a3);
}

id HDSwimTracker.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);

  return objc_msgSend(v1, sel_init);
}

void HDSwimTracker.init()()
{
}

id HDSwimTracker.__deallocating_deinit()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for HDSwimTracker();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

uint64_t type metadata accessor for HDSwimTracker()
{
  return self;
}

uint64_t __swift_project_value_buffer(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(*(void *)(a1 - 8) + 82) & 2) != 0) {
    return *(void *)a2;
  }
  return a2;
}

uint64_t sub_1BCBD63F8()
{
  swift_unknownObjectWeakDestroy();

  return MEMORY[0x1F4186498](v0, 24, 7);
}

uint64_t sub_1BCBD6430()
{
  swift_release();

  return MEMORY[0x1F4186498](v0, 32, 7);
}

void sub_1BCBD6468(unint64_t a1, uint64_t a2)
{
  sub_1BCBD4F74(a1, a2, *(void *)(v2 + 16));
}

uint64_t block_copy_helper(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper()
{
  return swift_release();
}

uint64_t sub_1BCBD6488()
{
  return sub_1BCBD5530(*(void *)(v0 + 16));
}

uint64_t sub_1BCBD64A4()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

unint64_t sub_1BCBD64CC(unint64_t result, uint64_t a2)
{
  if ((a2 & 0xC000000000000001) != 0) {
    return MEMORY[0x1C1879860]();
  }
  if ((result & 0x8000000000000000) != 0)
  {
    __break(1u);
  }
  else if (*(void *)((a2 & 0xFFFFFFFFFFFFFF8) + 0x10) > result)
  {
    return (unint64_t)*(id *)(a2 + 8 * result + 32);
  }
  __break(1u);
  return result;
}

id sub_1BCBD6528(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a2 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker_observers), sel_registerObserver_, a1);
}

uint64_t sub_1BCBD6544@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = sub_1BCBD4570();
  *a1 = result;
  return result;
}

uint64_t sub_1BCBD6570(void *a1, void *a2)
{
  *(void *)(*a2 + OBJC_IVAR____TtC12HealthDaemon13HDSwimTracker____lazy_storage___tracker) = *a1;
  swift_unknownObjectRetain();

  return swift_unknownObjectRelease();
}

uint64_t method lookup function for HDSwimTracker(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for HDSwimTracker);
}

uint64_t dispatch thunk of HDSwimTracker.tracker.getter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x80))();
}

uint64_t dispatch thunk of HDSwimTracker.tracker.setter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x88))();
}

uint64_t dispatch thunk of HDSwimTracker.tracker.modify()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x90))();
}

uint64_t dispatch thunk of HDSwimTracker.__allocating_init(profile:)()
{
  return (*(uint64_t (**)(void))(v0 + 176))();
}

uint64_t dispatch thunk of HDSwimTracker.makeSwimTracker()()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xB8))();
}

uint64_t dispatch thunk of HDSwimTracker.start(with:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xC0))();
}

uint64_t dispatch thunk of HDSwimTracker.stop()()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xC8))();
}

uint64_t dispatch thunk of HDSwimTracker.registerObserver(_:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xD0))();
}

uint64_t sub_1BCBD6754()
{
  swift_release();
  swift_bridgeObjectRelease();

  return MEMORY[0x1F4186498](v0, 48, 7);
}

void sub_1BCBD679C(unint64_t a1, uint64_t a2)
{
  sub_1BCBD5A1C(a1, a2, *(char **)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
}

void sub_1BCBD67AC(void *a1)
{
  sub_1BCBD61CC(a1, *(void *)(v1 + 16), *(void *)(v1 + 24), (SEL *)&selRef_onDemandSwimmingDataDidUpdate_reference_);
}

uint64_t objectdestroy_17Tm()
{
  swift_bridgeObjectRelease();

  return MEMORY[0x1F4186498](v0, 32, 7);
}

void sub_1BCBD6814(void *a1)
{
  sub_1BCBD61CC(a1, *(void *)(v1 + 16), *(void *)(v1 + 24), (SEL *)&selRef_historicalSwimmingDataDidUpdate_reference_);
}

unint64_t sub_1BCBD6838(unint64_t a1, char *a2)
{
  if (a1 >> 62) {
    goto LABEL_21;
  }
  unint64_t v4 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  while (v4)
  {
    a2 = *(char **)&a2[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data];
    while (!__OFSUB__(v4--, 1))
    {
      if ((a1 & 0xC000000000000001) != 0)
      {
        unint64_t v6 = (char *)MEMORY[0x1C1879860](v4, a1);
      }
      else
      {
        if ((v4 & 0x8000000000000000) != 0) {
          goto LABEL_19;
        }
        if (v4 >= *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10)) {
          goto LABEL_20;
        }
        unint64_t v6 = (char *)*(id *)(a1 + 32 + 8 * v4);
      }
      id v7 = v6;
      uint64_t v8 = *(void **)&v6[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data];
      id v9 = objc_msgSend(v8, sel_lapCount);
      if ((uint64_t)objc_msgSend(a2, sel_lapCount) < (uint64_t)v9
        || (id v10 = objc_msgSend(v8, sel_segment), (uint64_t)objc_msgSend(a2, sel_segment) < (uint64_t)v10)
        || (objc_msgSend(v8, sel_distance), double v12 = v11, objc_msgSend(a2, sel_distance), v13 < v12))
      {

        return v4;
      }
      id v14 = objc_msgSend(v8, sel_strokeCount);
      id v15 = objc_msgSend(a2, sel_strokeCount);

      if ((uint64_t)v15 < (uint64_t)v14 || !v4) {
        return v4;
      }
    }
    __break(1u);
LABEL_19:
    __break(1u);
LABEL_20:
    __break(1u);
LABEL_21:
    swift_bridgeObjectRetain();
    unint64_t v4 = sub_1BD2E49B0();
    swift_bridgeObjectRelease();
  }
  return v4;
}

unint64_t sub_1BCBD6A20@<X0>(unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = sub_1BCBD64CC(*a1, **(void **)(v2 + 16));
  if (!v3) {
    *a2 = result;
  }
  return result;
}

void sub_1BCBD6A64()
{
  if (!qword_1E9FBDEE0)
  {
    sub_1BCBD6ABC();
    unint64_t v0 = sub_1BD2E4880();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1E9FBDEE0);
    }
  }
}

unint64_t sub_1BCBD6ABC()
{
  unint64_t result = qword_1E9FBDD90;
  if (!qword_1E9FBDD90)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_1E9FBDD90);
  }
  return result;
}

unint64_t sub_1BCBD6AFC()
{
  unint64_t result = qword_1E9FBDD98;
  if (!qword_1E9FBDD98)
  {
    unint64_t result = swift_getExistentialTypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1E9FBDD98);
  }
  return result;
}

id sub_1BCBD6B6C()
{
  uint64_t v1 = OBJC_IVAR___HDDatabaseAccessibilityAssertionStoreServer____lazy_storage___queue;
  uint64_t v2 = *(void **)(v0 + OBJC_IVAR___HDDatabaseAccessibilityAssertionStoreServer____lazy_storage___queue);
  if (v2)
  {
    id v3 = *(id *)(v0 + OBJC_IVAR___HDDatabaseAccessibilityAssertionStoreServer____lazy_storage___queue);
  }
  else
  {
    type metadata accessor for DatabaseAccessibilityAssertionStoreServer();
    id v4 = objc_msgSend((id)swift_getObjCClassFromMetadata(), sel_description);
    if (!v4)
    {
      sub_1BD2E4770();
      id v4 = (id)sub_1BD2E4760();
      swift_bridgeObjectRelease();
    }
    id v5 = (id)HKCreateSerialDispatchQueue();

    unint64_t v6 = *(void **)(v0 + v1);
    *(void *)(v0 + v1) = v5;
    id v3 = v5;

    uint64_t v2 = 0;
  }
  id v7 = v2;
  return v3;
}

id DatabaseAccessibilityAssertionStoreServer.__deallocating_deinit()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for DatabaseAccessibilityAssertionStoreServer();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

uint64_t type metadata accessor for DatabaseAccessibilityAssertionStoreServer()
{
  return self;
}

void DatabaseAccessibilityAssertionStoreServer.remote_invalidateDatabaseAccessibilityAssertion(_:)(void *a1)
{
  if (a1)
  {
    id v7 = a1;
    id v2 = objc_msgSend(v1, sel_client);
    id v3 = objc_msgSend(v2, sel_assertionForHKDatabaseAccessibilityAssertion_, v7);

    if (v3)
    {
      id v4 = v3;
      objc_msgSend(v4, sel_invalidate);
      id v5 = objc_msgSend(v1, sel_client);
      objc_msgSend(v5, sel_removeAssertionMappingForAssertion_, v4);

      unint64_t v6 = v5;
    }
    else
    {
      unint64_t v6 = v7;
    }
  }
}

uint64_t DatabaseAccessibilityAssertionStoreServer.remote_requestDatabaseAccessibilityAssertion(forOwnerIdentifier:completion:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = sub_1BD2E46E0();
  uint64_t v22 = *(void *)(v9 - 8);
  MEMORY[0x1F4188790](v9);
  double v11 = (char *)&v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v21 = sub_1BD2E4700();
  uint64_t v12 = *(void *)(v21 - 8);
  MEMORY[0x1F4188790](v21);
  id v14 = (char *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  id v15 = sub_1BCBD6B6C();
  id v16 = (void *)swift_allocObject();
  _OWORD v16[2] = v4;
  v16[3] = a1;
  v16[4] = a2;
  v16[5] = a3;
  v16[6] = a4;
  aBlock[4] = sub_1BCBD7430;
  void aBlock[5] = v16;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 1107296256;
  aBlock[2] = sub_1BCBD7700;
  aBlock[3] = &block_descriptor_0;
  uint64_t v17 = _Block_copy(aBlock);
  id v18 = v4;
  swift_bridgeObjectRetain();
  swift_retain();
  sub_1BD2E46F0();
  uint64_t v23 = MEMORY[0x1E4FBC860];
  sub_1BCBD77B4(&qword_1EBA189F0, MEMORY[0x1E4FBCB00]);
  sub_1BCBD775C();
  sub_1BCBD77B4((unint64_t *)&unk_1EBA18A00, (void (*)(uint64_t))sub_1BCBD775C);
  sub_1BD2E48C0();
  MEMORY[0x1C18797D0](0, v14, v11, v17);
  _Block_release(v17);

  (*(void (**)(char *, uint64_t))(v22 + 8))(v11, v9);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v21);
  return swift_release();
}

void sub_1BCBD7328(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(id, void))
{
  id v5 = sub_1BCBD7440();
  a4(v5, 0);
}

uint64_t sub_1BCBD73E8()
{
  swift_bridgeObjectRelease();
  swift_release();

  return MEMORY[0x1F4186498](v0, 56, 7);
}

void sub_1BCBD7430()
{
  sub_1BCBD7328(*(void *)(v0 + 16), *(void *)(v0 + 24), *(void *)(v0 + 32), *(void (**)(id, void))(v0 + 40));
}

id sub_1BCBD7440()
{
  id v2 = v0;
  v22[1] = *(id *)MEMORY[0x1E4F143B8];
  uint64_t v3 = sub_1BD2E46A0();
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](v3);
  unint64_t v6 = (char *)v21 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  id v7 = objc_msgSend(v2, sel_profile);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  v21[1] = v1;
  id v9 = objc_msgSend(v7, sel_database);

  uint64_t v10 = (void *)sub_1BD2E4760();
  v22[0] = 0;
  id v11 = objc_msgSend(v9, sel_takeAccessibilityAssertionWithOwnerIdentifier_shouldPerformTransaction_timeout_error_, v10, 0, v22, 600.0);

  if (v11)
  {
    id v12 = v22[0];
    id v13 = v11;
    id v14 = objc_msgSend(v13, sel_UUID);
    sub_1BD2E4690();

    sub_1BD2E4670();
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, v3);
    id v15 = objc_allocWithZone(MEMORY[0x1E4F2AEC8]);
    swift_bridgeObjectRetain();
    id v16 = (void *)sub_1BD2E4760();
    swift_bridgeObjectRelease();
    uint64_t v17 = (void *)sub_1BD2E4760();
    swift_bridgeObjectRelease();
    id v18 = objc_msgSend(v15, sel_initWithOwnerIdentifier_uuidString_, v16, v17);

    id v19 = objc_msgSend(v2, sel_client);
    objc_msgSend(v19, sel_addAssertionMapping_, v13);
  }
  else
  {
    id v18 = v22[0];
    sub_1BD2E4630();

    swift_willThrow();
  }
  return v18;
}

uint64_t sub_1BCBD7700(uint64_t a1)
{
  uint64_t v1 = *(void (**)(uint64_t))(a1 + 32);
  uint64_t v2 = swift_retain();
  v1(v2);

  return swift_release();
}

uint64_t block_copy_helper_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper_0()
{
  return swift_release();
}

void sub_1BCBD775C()
{
  if (!qword_1EBA189F8)
  {
    sub_1BD2E46E0();
    unint64_t v0 = sub_1BD2E4820();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EBA189F8);
    }
  }
}

uint64_t sub_1BCBD77B4(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t method lookup function for DatabaseAccessibilityAssertionStoreServer(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for DatabaseAccessibilityAssertionStoreServer);
}

void sub_1BCBD78CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2) {
    uint64_t v5 = sub_1BD2E4620();
  }
  else {
    uint64_t v5 = 0;
  }
  id v6 = (id)v5;
  (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, a1);
}

uint64_t sub_1BCBD793C()
{
  _Block_release(*(const void **)(v0 + 16));

  return MEMORY[0x1F4186498](v0, 24, 7);
}

void sub_1BCBD7974(uint64_t a1, uint64_t a2)
{
  sub_1BCBD78CC(a1, a2, *(void *)(v2 + 16));
}

uint64_t HDSwimmingDataCollector.__allocating_init(profile:)(void *a1)
{
  id v3 = objc_allocWithZone(v1);
  return HDSwimmingDataCollector.init(profile:)(a1);
}

uint64_t HDSwimmingDataCollector.init(profile:)(void *a1)
{
  swift_unknownObjectWeakInit();
  uint64_t v3 = OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_aggregators;
  uint64_t v4 = self;
  uint64_t v5 = v1;
  *(void *)&v1[v3] = objc_msgSend(v4, sel_mapTableWithKeyOptions_valueOptions_, 0, 5);
  uint64_t v6 = OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_quantityTypes;
  sub_1BCBD7C90();
  uint64_t v7 = swift_allocObject();
  *(_OWORD *)(v7 + 16) = xmmword_1BD324D40;
  sub_1BCBD9D2C(0, &qword_1E9FBDE40);
  *(void *)(v7 + 32) = MEMORY[0x1C18797C0]((id)*MEMORY[0x1E4F2A7D8]);
  *(void *)(v7 + 40) = MEMORY[0x1C18797C0]((id)*MEMORY[0x1E4F2A8F8]);
  uint64_t v26 = v7;
  sub_1BD2E47F0();
  *(void *)&v5[v6] = v7;

  v25.receiver = v5;
  v25.super_class = (Class)type metadata accessor for HDSwimmingDataCollector();
  uint64_t v8 = (char *)objc_msgSendSuper2(&v25, sel_init);
  uint64_t v23 = a1;
  uint64_t v24 = &v8[OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_profile];
  swift_unknownObjectWeakAssign();
  unint64_t v9 = *(void *)&v8[OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_quantityTypes];
  if (!(v9 >> 62))
  {
    uint64_t v10 = *(void *)((v9 & 0xFFFFFFFFFFFFFF8) + 0x10);
    id v11 = v8;
    uint64_t result = swift_bridgeObjectRetain();
    if (v10) {
      goto LABEL_3;
    }
LABEL_16:

    swift_bridgeObjectRelease();
    return (uint64_t)v8;
  }
  uint64_t v22 = v8;
  swift_bridgeObjectRetain();
  uint64_t result = sub_1BD2E49B0();
  uint64_t v10 = result;
  if (!result) {
    goto LABEL_16;
  }
LABEL_3:
  if (v10 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_aggregators;
    do
    {
      if ((v9 & 0xC000000000000001) != 0) {
        id v15 = (id)MEMORY[0x1C1879860](v13, v9);
      }
      else {
        id v15 = *(id *)(v9 + 8 * v13 + 32);
      }
      id v16 = v15;
      uint64_t v17 = (void *)MEMORY[0x1C187CA40](v24);
      id v18 = v17;
      if (v17)
      {
        id v19 = objc_msgSend(v17, sel_dataCollectionManager);

        if (v19)
        {
          id v18 = objc_msgSend(v19, sel_aggregatorForType_, v16);
        }
        else
        {
          id v18 = 0;
        }
      }
      objc_msgSend(*(id *)&v8[v14], sel_setObject_forKey_, v18, v16);
      id v20 = objc_msgSend(objc_allocWithZone(MEMORY[0x1E4F2AEB0]), sel_init);
      if (v18)
      {
        uint64_t v21 = v8;
        objc_msgSend(v18, sel_registerDataCollector_state_, v21, v20);
      }
      ++v13;
    }
    while (v10 != v13);
    goto LABEL_16;
  }
  __break(1u);
  return result;
}

void sub_1BCBD7C90()
{
  if (!qword_1EBA18A38)
  {
    unint64_t v0 = sub_1BD2E4A20();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EBA18A38);
    }
  }
}

uint64_t type metadata accessor for HDSwimmingDataCollector()
{
  return self;
}

void sub_1BCBD7D14(unint64_t a1, void *a2)
{
  swift_getObjectType();
  if (a1 >> 62) {
    goto LABEL_54;
  }
  uint64_t v5 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
  if (v5)
  {
    unint64_t v49 = MEMORY[0x1E4FBC860];
    unint64_t v50 = MEMORY[0x1E4FBC860];
    swift_bridgeObjectRetain();
    id v6 = a2;
    while (1)
    {
      unint64_t v7 = 0;
      char v8 = 0;
      if ((a1 & 0xC000000000000001) != 0)
      {
LABEL_5:
        id v9 = (id)MEMORY[0x1C1879860](v7, a1);
        goto LABEL_8;
      }
      while (1)
      {
        if (v7 >= *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10)) {
          goto LABEL_53;
        }
        id v9 = *(id *)(a1 + 8 * v7 + 32);
LABEL_8:
        uint64_t v10 = v9;
        if (__OFADD__(v7, 1)) {
          break;
        }
        if (v8) {

        }
        id v2 = v10;
        id v11 = sub_1BCBD85C4((char *)a2, (uint64_t)v2);
        if (v11)
        {
          id v12 = v11;
          MEMORY[0x1C1879720]();
          if (*(void *)((v50 & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(void *)((v50 & 0xFFFFFFFFFFFFFF8) + 0x18) >> 1) {
            sub_1BD2E4800();
          }
          sub_1BD2E4810();
          sub_1BD2E47F0();
        }
        id v13 = sub_1BCBD8E48((uint64_t)a2, (uint64_t)v2);
        if (v13)
        {
          id v14 = v13;
          MEMORY[0x1C1879720]();
          if (*(void *)((v49 & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(void *)((v49 & 0xFFFFFFFFFFFFFF8) + 0x18) >> 1) {
            sub_1BD2E4800();
          }
          sub_1BD2E4810();
          sub_1BD2E47F0();
        }
        if (v7 + 1 == v5)
        {
          char v15 = 0;
LABEL_23:
          swift_bridgeObjectRelease();
          uint64_t v16 = v47 + OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_profile;
          uint64_t v17 = (void *)MEMORY[0x1C187CA40](v47 + OBJC_IVAR____TtC12HealthDaemon23HDSwimmingDataCollector_profile);
          if (v17
            && (id v18 = v17,
                id v19 = objc_msgSend(v17, sel_dataCollectionManager),
                v18,
                v19))
          {
            sub_1BCBD9D2C(0, &qword_1E9FBDE40);
            id v20 = (void *)MEMORY[0x1C18797C0]((id)*MEMORY[0x1E4F2A8F8]);
            id v46 = objc_msgSend(v19, sel_aggregatorForType_, v20);
          }
          else
          {
            id v46 = 0;
          }
          uint64_t v21 = (void *)MEMORY[0x1C187CA40](v16);
          if (v21
            && (uint64_t v22 = v21,
                id v23 = objc_msgSend(v21, sel_dataCollectionManager),
                v22,
                v23))
          {
            sub_1BCBD9D2C(0, &qword_1E9FBDE40);
            uint64_t v24 = (void *)MEMORY[0x1C18797C0]((id)*MEMORY[0x1E4F2A7D8]);
            id v25 = objc_msgSend(v23, sel_aggregatorForType_, v24);
          }
          else
          {
            id v25 = 0;
          }
          uint64_t v26 = v46;
          if (qword_1E9FBD970 != -1) {
            swift_once();
          }
          uint64_t v27 = sub_1BD2E46C0();
          __swift_project_value_buffer(v27, (uint64_t)qword_1E9FC52E8);
          unint64_t v29 = v49;
          unint64_t v28 = v50;
          swift_bridgeObjectRetain_n();
          swift_bridgeObjectRetain_n();
          id v30 = sub_1BD2E46B0();
          os_log_type_t v31 = sub_1BD2E4850();
          if (os_log_type_enabled(v30, v31))
          {
            char v32 = v15;
            uint64_t v33 = swift_slowAlloc();
            uint64_t v34 = swift_slowAlloc();
            v48[0] = v34;
            *(_DWORD *)uint64_t v33 = 136446722;
            uint64_t v35 = sub_1BD2E4AC0();
            sub_1BCBD1058(v35, v36, v48);
            sub_1BD2E4890();
            swift_bridgeObjectRelease();
            *(_WORD *)(v33 + 12) = 2048;
            if (v28 >> 62)
            {
              swift_bridgeObjectRetain();
              sub_1BD2E49B0();
              swift_bridgeObjectRelease();
            }
            swift_bridgeObjectRelease();
            sub_1BD2E4890();
            swift_bridgeObjectRelease();
            *(_WORD *)(v33 + 22) = 2048;
            if (v29 >> 62)
            {
              swift_bridgeObjectRetain();
              sub_1BD2E49B0();
              swift_bridgeObjectRelease();
            }
            swift_bridgeObjectRelease();
            sub_1BD2E4890();
            swift_bridgeObjectRelease();
            _os_log_impl(&dword_1BCB7D000, v30, v31, "%{public}s Creating %ld stroke datums and %ld distance datums", (uint8_t *)v33, 0x20u);
            swift_arrayDestroy();
            MEMORY[0x1C187C9C0](v34, -1, -1);
            MEMORY[0x1C187C9C0](v33, -1, -1);

            char v15 = v32;
            uint64_t v26 = v46;
          }
          else
          {

            swift_bridgeObjectRelease_n();
            swift_bridgeObjectRelease_n();
          }
          if (v26)
          {
            swift_beginAccess();
            if (v50 >> 62)
            {
              sub_1BCBD9968();
              id v44 = v26;
              swift_bridgeObjectRetain();
              sub_1BD2E49A0();
              swift_bridgeObjectRelease();
            }
            else
            {
              id v37 = v26;
              swift_bridgeObjectRetain();
              sub_1BD2E4A40();
              sub_1BCBD9968();
            }
            swift_bridgeObjectRelease();
            sub_1BCBD9968();
            id v38 = (void *)sub_1BD2E47D0();
            swift_bridgeObjectRelease();
            id v39 = objc_msgSend(self, sel_localDevice);
            objc_msgSend(v26, sel_dataCollector_didCollectSensorData_device_, v47, v38, v39);

            if (v25)
            {
LABEL_44:
              swift_beginAccess();
              if (v49 >> 62)
              {
                sub_1BCBD9968();
                id v45 = v25;
                swift_bridgeObjectRetain();
                sub_1BD2E49A0();
                swift_bridgeObjectRelease();
              }
              else
              {
                id v40 = v25;
                swift_bridgeObjectRetain();
                sub_1BD2E4A40();
                sub_1BCBD9968();
              }
              swift_bridgeObjectRelease();
              sub_1BCBD9968();
              id v41 = (void *)sub_1BD2E47D0();
              swift_bridgeObjectRelease();
              id v42 = objc_msgSend(self, sel_localDevice);
              objc_msgSend(v25, sel_dataCollector_didCollectSensorData_device_, v47, v41, v42);

              if (v15) {
                return;
              }
LABEL_50:

              return;
            }
          }
          else
          {
            swift_bridgeObjectRelease();
            if (v25) {
              goto LABEL_44;
            }
          }

          swift_bridgeObjectRelease();
          if (v15) {
            return;
          }
          goto LABEL_50;
        }
        ++v7;
        char v8 = 1;
        a2 = v2;
        if ((a1 & 0xC000000000000001) != 0) {
          goto LABEL_5;
        }
      }
      __break(1u);
LABEL_53:
      __break(1u);
LABEL_54:
      swift_bridgeObjectRetain();
      uint64_t v43 = sub_1BD2E49B0();
      swift_bridgeObjectRelease();
      if (v43 <= 0) {
        break;
      }
      unint64_t v49 = MEMORY[0x1E4FBC860];
      unint64_t v50 = MEMORY[0x1E4FBC860];
      swift_bridgeObjectRetain();
      id v2 = a2;
      uint64_t v5 = sub_1BD2E49B0();
      if (!v5)
      {
        char v15 = 1;
        goto LABEL_23;
      }
    }
  }
}

id sub_1BCBD85C4(char *a1, uint64_t a2)
{
  uint64_t ObjectType = swift_getObjectType();
  uint64_t v4 = sub_1BD2E46A0();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4);
  id v73 = (char *)&v66 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = sub_1BD2E4660();
  uint64_t v8 = MEMORY[0x1F4188790](v7 - 8);
  uint64_t v10 = (char *)&v66 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v74 = sub_1BD2E4610();
  uint64_t v11 = *(void *)(v74 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v74);
  id v14 = (char *)&v66 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v76 = (char *)&v66 - v15;
  uint64_t v72 = a2;
  id v75 = *(id *)(a2 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data);
  uint64_t v16 = objc_msgSend(v75, sel_strokeCount);
  uint64_t v17 = objc_msgSend(*(id *)&a1[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data], sel_strokeCount);
  BOOL v18 = __OFSUB__(v16, v17);
  uint64_t v19 = v16 - v17;
  if (v18)
  {
    __break(1u);
    goto LABEL_15;
  }
  if (v19 >= 1)
  {
    uint64_t v69 = v5;
    uint64_t v70 = v4;
    id v20 = v75;
    id v21 = objc_msgSend(v75, sel_startDate);
    sub_1BD2E4650();

    id v22 = objc_msgSend(v20, sel_endDate);
    sub_1BD2E4650();

    a1 = v76;
    sub_1BD2E4600();
    id v23 = objc_msgSend(self, sel_countUnit);
    uint64_t v10 = (char *)objc_msgSend(self, sel_quantityWithUnit_doubleValue_, v23, (double)v19);

    if (qword_1E9FBD970 == -1)
    {
LABEL_4:
      uint64_t v24 = sub_1BD2E46C0();
      __swift_project_value_buffer(v24, (uint64_t)qword_1E9FC52E8);
      uint64_t v25 = v74;
      (*(void (**)(char *, char *, uint64_t))(v11 + 16))(v14, a1, v74);
      uint64_t v26 = v10;
      uint64_t v27 = sub_1BD2E46B0();
      os_log_type_t v28 = sub_1BD2E4850();
      if (os_log_type_enabled(v27, v28))
      {
        uint64_t v29 = swift_slowAlloc();
        os_log_t v67 = v27;
        uint64_t v30 = v29;
        uint64_t v31 = v25;
        os_log_type_t v66 = (void *)swift_slowAlloc();
        uint64_t v68 = swift_slowAlloc();
        v78[0] = v68;
        *(_DWORD *)uint64_t v30 = 136446722;
        uint64_t v32 = sub_1BD2E4AC0();
        uint64_t v77 = sub_1BCBD1058(v32, v33, v78);
        sub_1BD2E4890();
        swift_bridgeObjectRelease();
        *(_WORD *)(v30 + 12) = 2080;
        sub_1BCBD9CD4();
        uint64_t v34 = v26;
        uint64_t v35 = v31;
        uint64_t v36 = sub_1BD2E4A10();
        uint64_t v77 = sub_1BCBD1058(v36, v37, v78);
        sub_1BD2E4890();
        swift_bridgeObjectRelease();
        id v38 = *(void (**)(char *, uint64_t))(v11 + 8);
        uint64_t ObjectType = (v11 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        uint64_t v39 = v35;
        uint64_t v26 = v34;
        v38(v14, v39);
        *(_WORD *)(v30 + 22) = 2112;
        uint64_t v77 = (uint64_t)v34;
        id v40 = v34;
        sub_1BD2E4890();
        id v41 = v66;
        *os_log_type_t v66 = v34;

        id v42 = v38;
        os_log_t v43 = v67;
        _os_log_impl(&dword_1BCB7D000, v67, v28, "%{public}s Creating stroke datum with date interval %s and quantity %@", (uint8_t *)v30, 0x20u);
        sub_1BCBD6A64();
        swift_arrayDestroy();
        MEMORY[0x1C187C9C0](v41, -1, -1);
        uint64_t v44 = v68;
        swift_arrayDestroy();
        MEMORY[0x1C187C9C0](v44, -1, -1);
        MEMORY[0x1C187C9C0](v30, -1, -1);

        uint64_t v25 = v74;
      }
      else
      {
        uint64_t v53 = *(void (**)(char *, uint64_t))(v11 + 8);
        uint64_t ObjectType = (v11 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
        uint64_t v54 = v14;
        id v42 = v53;
        v53(v54, v25);
      }
      id v55 = objc_msgSend(v75, sel_sourceId);
      os_log_type_t v56 = v73;
      sub_1BD2E4690();

      sub_1BCBD9C10();
      uint64_t inited = swift_initStackObject();
      *(_OWORD *)(inited + 16) = xmmword_1BD324D50;
      *(void *)(inited + 32) = sub_1BD2E4770();
      *(void *)(inited + 40) = v58;
      id v59 = objc_msgSend(objc_allocWithZone(NSNumber), sel_initWithInteger_, sub_1BCBDA1F0());
      *(void *)(inited + 72) = sub_1BCBD9D2C(0, &qword_1E9FBDED0);
      *(void *)(inited + 48) = v59;
      sub_1BCBDAF74(inited);
      id v60 = objc_allocWithZone((Class)HDQuantityDatum);
      unsigned int v61 = (void *)sub_1BD2E4680();
      uint64_t v62 = v76;
      id v63 = (void *)sub_1BD2E45F0();
      unint64_t v64 = (void *)sub_1BD2E4750();
      swift_bridgeObjectRelease();
      id v52 = objc_msgSend(v60, sel_initWithIdentifier_dateInterval_quantity_metadata_resumeContextProvider_, v61, v63, v26, v64, 0);

      (*(void (**)(char *, uint64_t))(v69 + 8))(v56, v70);
      v42(v62, v25);
      return v52;
    }
LABEL_15:
    swift_once();
    goto LABEL_4;
  }
  if (qword_1E9FBD970 != -1) {
    swift_once();
  }
  uint64_t v45 = sub_1BD2E46C0();
  __swift_project_value_buffer(v45, (uint64_t)qword_1E9FC52E8);
  id v46 = sub_1BD2E46B0();
  os_log_type_t v47 = sub_1BD2E4850();
  if (os_log_type_enabled(v46, v47))
  {
    unint64_t v48 = (uint8_t *)swift_slowAlloc();
    uint64_t v49 = swift_slowAlloc();
    v78[0] = v49;
    *(_DWORD *)unint64_t v48 = 136446210;
    uint64_t v50 = sub_1BD2E4AC0();
    uint64_t v77 = sub_1BCBD1058(v50, v51, v78);
    sub_1BD2E4890();
    swift_bridgeObjectRelease();
    _os_log_impl(&dword_1BCB7D000, v46, v47, "%{public}s Stroke difference between current and prior swim objects is not greater than zero.", v48, 0xCu);
    swift_arrayDestroy();
    MEMORY[0x1C187C9C0](v49, -1, -1);
    MEMORY[0x1C187C9C0](v48, -1, -1);
  }

  return 0;
}

id sub_1BCBD8E48(uint64_t a1, uint64_t a2)
{
  uint64_t ObjectType = swift_getObjectType();
  uint64_t v4 = sub_1BD2E46A0();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4);
  uint64_t v80 = (char *)&v69 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = sub_1BD2E4660();
  uint64_t v8 = MEMORY[0x1F4188790](v7 - 8);
  MEMORY[0x1F4188790](v8);
  uint64_t v81 = sub_1BD2E4610();
  uint64_t v9 = *(void *)(v81 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v81);
  uint64_t v77 = (char *)&v69 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v69 - v12;
  uint64_t v79 = a2;
  id v14 = *(void **)(a2 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data);
  objc_msgSend(v14, sel_distance);
  double v16 = v15;
  objc_msgSend(*(id *)(a1 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_distance);
  double v18 = v16 - v17;
  if (v18 <= 2.22044605e-16)
  {
    if (qword_1E9FBD970 != -1) {
      swift_once();
    }
    uint64_t v48 = sub_1BD2E46C0();
    __swift_project_value_buffer(v48, (uint64_t)qword_1E9FC52E8);
    uint64_t v49 = sub_1BD2E46B0();
    os_log_type_t v50 = sub_1BD2E4850();
    if (os_log_type_enabled(v49, v50))
    {
      unint64_t v51 = (uint8_t *)swift_slowAlloc();
      uint64_t v52 = swift_slowAlloc();
      v83[0] = v52;
      *(_DWORD *)unint64_t v51 = 136446210;
      uint64_t v53 = sub_1BD2E4AC0();
      uint64_t v82 = sub_1BCBD1058(v53, v54, v83);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      _os_log_impl(&dword_1BCB7D000, v49, v50, "%{public}s Distance difference between current and prior swim objects is too small", v51, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v52, -1, -1);
      MEMORY[0x1C187C9C0](v51, -1, -1);
    }

    return 0;
  }
  else
  {
    uint64_t v75 = v5;
    uint64_t v76 = v4;
    id v19 = objc_msgSend(v14, sel_startDate);
    sub_1BD2E4650();

    id v20 = objc_msgSend(v14, sel_endDate);
    sub_1BD2E4650();

    sub_1BD2E4600();
    id v21 = objc_msgSend(self, sel_meterUnit);
    id v22 = objc_msgSend(self, sel_quantityWithUnit_doubleValue_, v21, v18);

    id v23 = v14;
    if (qword_1E9FBD970 != -1) {
      swift_once();
    }
    uint64_t v24 = sub_1BD2E46C0();
    __swift_project_value_buffer(v24, (uint64_t)qword_1E9FC52E8);
    uint64_t v25 = *(void (**)(char *, char *, uint64_t))(v9 + 16);
    uint64_t v26 = v77;
    uint64_t v74 = v13;
    uint64_t v27 = v13;
    uint64_t v28 = v81;
    v25(v77, v27, v81);
    id v29 = v22;
    uint64_t v30 = sub_1BD2E46B0();
    os_log_type_t v31 = sub_1BD2E4850();
    if (os_log_type_enabled(v30, v31))
    {
      uint64_t v32 = swift_slowAlloc();
      os_log_t v71 = v30;
      uint64_t v33 = v32;
      uint64_t v70 = (void *)swift_slowAlloc();
      uint64_t v72 = swift_slowAlloc();
      v83[0] = v72;
      *(_DWORD *)uint64_t v33 = 136446722;
      uint64_t v34 = sub_1BD2E4AC0();
      uint64_t v82 = sub_1BCBD1058(v34, v35, v83);
      id v73 = v23;
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      *(_WORD *)(v33 + 12) = 2080;
      sub_1BCBD9CD4();
      uint64_t v36 = v29;
      uint64_t v37 = v28;
      uint64_t v38 = sub_1BD2E4A10();
      uint64_t v82 = sub_1BCBD1058(v38, v39, v83);
      sub_1BD2E4890();
      swift_bridgeObjectRelease();
      id v40 = *(void (**)(char *, uint64_t))(v9 + 8);
      uint64_t ObjectType = (v9 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
      uint64_t v41 = v37;
      id v29 = v36;
      v40(v26, v41);
      *(_WORD *)(v33 + 22) = 2112;
      uint64_t v82 = (uint64_t)v36;
      id v42 = v36;
      id v23 = v73;
      sub_1BD2E4890();
      os_log_t v43 = v70;
      *uint64_t v70 = v36;

      uint64_t v44 = v40;
      os_log_t v45 = v71;
      _os_log_impl(&dword_1BCB7D000, v71, v31, "%{public}s Creating distance datum with date interval %s and quantity %@", (uint8_t *)v33, 0x20u);
      sub_1BCBD6A64();
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v43, -1, -1);
      uint64_t v46 = v72;
      swift_arrayDestroy();
      MEMORY[0x1C187C9C0](v46, -1, -1);
      MEMORY[0x1C187C9C0](v33, -1, -1);

      uint64_t v47 = v81;
    }
    else
    {
      os_log_type_t v56 = *(void (**)(char *, uint64_t))(v9 + 8);
      uint64_t ObjectType = (v9 + 8) & 0xFFFFFFFFFFFFLL | 0x4F8000000000000;
      uint64_t v57 = v26;
      uint64_t v44 = v56;
      v56(v57, v28);

      uint64_t v47 = v28;
    }
    id v58 = objc_msgSend(v23, sel_sourceId);
    id v59 = v80;
    sub_1BD2E4690();

    sub_1BCBD9C10();
    uint64_t inited = swift_initStackObject();
    *(_OWORD *)(inited + 16) = xmmword_1BD324D50;
    *(void *)(inited + 32) = sub_1BD2E4770();
    *(void *)(inited + 40) = v61;
    id v62 = objc_msgSend(objc_allocWithZone(NSNumber), sel_initWithInteger_, sub_1BCBDA1F0());
    *(void *)(inited + 72) = sub_1BCBD9D2C(0, &qword_1E9FBDED0);
    *(void *)(inited + 48) = v62;
    sub_1BCBDAF74(inited);
    id v63 = objc_allocWithZone((Class)HDQuantityDatum);
    unint64_t v64 = (void *)sub_1BD2E4680();
    char v65 = v74;
    os_log_type_t v66 = (void *)sub_1BD2E45F0();
    os_log_t v67 = (void *)sub_1BD2E4750();
    swift_bridgeObjectRelease();
    id v55 = objc_msgSend(v63, sel_initWithIdentifier_dateInterval_quantity_metadata_resumeContextProvider_, v64, v66, v29, v67, 0);

    (*(void (**)(char *, uint64_t))(v75 + 8))(v59, v76);
    v44(v65, v47);
  }
  return v55;
}

uint64_t sub_1BCBD96DC()
{
  return sub_1BCBD9D2C(0, (unint64_t *)&unk_1E9FBDE50);
}

id sub_1BCBD9744()
{
  id v0 = objc_msgSend(self, sel__localDeviceSource);

  return v0;
}

id HDSwimmingDataCollector.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);

  return objc_msgSend(v1, sel_init);
}

void HDSwimmingDataCollector.init()()
{
}

id HDSwimmingDataCollector.__deallocating_deinit()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for HDSwimmingDataCollector();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

unint64_t sub_1BCBD9968()
{
  unint64_t result = qword_1E9FBDE48;
  if (!qword_1E9FBDE48)
  {
    unint64_t result = swift_getExistentialTypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1E9FBDE48);
  }
  return result;
}

uint64_t sub_1BCBD99C0()
{
  id v1 = objc_msgSend(v0, sel_description);
  sub_1BD2E4770();

  sub_1BD2E47A0();
  swift_bridgeObjectRelease();
  sub_1BD2E47A0();
  sub_1BD2E4980();
  return 0;
}

uint64_t method lookup function for HDSwimmingDataCollector(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for HDSwimmingDataCollector);
}

uint64_t dispatch thunk of HDSwimmingDataCollector.__allocating_init(profile:)()
{
  return (*(uint64_t (**)(void))(v0 + 152))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.onDemandSwimmingDataDidUpdate(_:reference:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xA8))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.historicalSwimmingDataDidUpdate(_:reference:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xB0))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.beginCollection(for:lastPersistedSensorDatum:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xC8))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.dataAggregator(_:wantsCollectionWith:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xD0))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.sensorDatumClass(for:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xD8))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.source(for:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xE0))();
}

uint64_t dispatch thunk of HDSwimmingDataCollector.identifier(for:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xE8))();
}

void sub_1BCBD9C10()
{
  if (!qword_1E9FBDEC0)
  {
    sub_1BCBD9C68();
    unint64_t v0 = sub_1BD2E4A20();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1E9FBDEC0);
    }
  }
}

void sub_1BCBD9C68()
{
  if (!qword_1E9FBDEC8)
  {
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v1) {
      atomic_store(TupleTypeMetadata2, (unint64_t *)&qword_1E9FBDEC8);
    }
  }
}

unint64_t sub_1BCBD9CD4()
{
  unint64_t result = qword_1E9FBDED8;
  if (!qword_1E9FBDED8)
  {
    sub_1BD2E4610();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E9FBDED8);
  }
  return result;
}

uint64_t sub_1BCBD9D2C(uint64_t a1, unint64_t *a2)
{
  uint64_t result = *a2;
  if (!*a2)
  {
    self;
    uint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, a2);
  }
  return result;
}

uint64_t sub_1BCBD9D6C()
{
  uint64_t v0 = sub_1BD2E46C0();
  __swift_allocate_value_buffer(v0, qword_1E9FC52E8);
  __swift_project_value_buffer(v0, (uint64_t)qword_1E9FC52E8);
  _HKInitializeLogging();
  id v1 = (id)*MEMORY[0x1E4F29F10];
  return sub_1BD2E46D0();
}

void sub_1BCBD9E28()
{
}

void sub_1BCBD9E90()
{
}

id sub_1BCBD9EC8()
{
  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_recordId);
}

id sub_1BCBD9F28(char *a1, uint64_t a2, uint64_t (*a3)(void), SEL *a4, void (*a5)(void), uint64_t (*a6)(void))
{
  uint64_t v10 = a3(0);
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1F4188790](v10);
  uint64_t v13 = (char *)&v19 - v12;
  id v14 = *(void **)&a1[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data];
  double v15 = a1;
  id v16 = [v14 *a4];
  a5();

  double v17 = (void *)a6();
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v10);

  return v17;
}

void sub_1BCBDA064()
{
}

void sub_1BCBDA084(SEL *a1, void (*a2)(void))
{
  id v4 = [*(id *)(v2 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data) *a1];
  a2();
}

id sub_1BCBDA114()
{
  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_lapCount);
}

id sub_1BCBDA144()
{
  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_segment);
}

id sub_1BCBDA174()
{
  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_distance);
}

id sub_1BCBDA1A4()
{
  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_strokeCount);
}

uint64_t sub_1BCBDA1F0()
{
  id v1 = (char *)objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data), sel_strokeType);
  if ((unint64_t)(v1 - 1) > 5) {
    return 0;
  }
  else {
    return qword_1BD324DD0[(void)(v1 - 1)];
  }
}

id HDCMSwimData.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);

  return objc_msgSend(v1, sel_init);
}

void HDCMSwimData.init()()
{
}

id HDCMSwimData.__deallocating_deinit()
{
  return sub_1BCBDAB00(type metadata accessor for HDCMSwimData);
}

uint64_t type metadata accessor for HDCMSwimData()
{
  return self;
}

void sub_1BCBDA3D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1BCBDA400()
{
  swift_release();

  return MEMORY[0x1F4186498](v0, 32, 7);
}

uint64_t sub_1BCBDA438(unint64_t a1, uint64_t a2)
{
  return sub_1BCBDA750(a1, a2, *(void (**)(uint64_t, uint64_t))(v2 + 16));
}

uint64_t sub_1BCBDA454(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = *(void (**)(uint64_t, void *))(a1 + 32);
  if (a2)
  {
    sub_1BCBDAE28();
    uint64_t v4 = sub_1BD2E47E0();
  }
  swift_retain();
  id v6 = a3;
  v5(v4, a3);
  swift_release();

  return swift_bridgeObjectRelease();
}

uint64_t block_copy_helper_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper_1()
{
  return swift_release();
}

void sub_1BCBDA534(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  if (a1)
  {
    type metadata accessor for HDCMSwimData();
    uint64_t v5 = (void *)sub_1BD2E47D0();
  }
  if (a2) {
    uint64_t v6 = sub_1BD2E4620();
  }
  else {
    uint64_t v6 = 0;
  }
  id v7 = (id)v6;
  (*(void (**)(uint64_t, void *))(a3 + 16))(a3, v5);
}

id sub_1BCBDA5CC()
{
  return objc_msgSend(*(id *)(v0 + OBJC_IVAR____TtC12HealthDaemon15HDCMSwimTracker_tracker), sel_stopUpdates);
}

void sub_1BCBDA5FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1BCBDA62C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, SEL *a7)
{
  uint64_t v8 = *(void **)(v7 + OBJC_IVAR____TtC12HealthDaemon15HDCMSwimTracker_tracker);
  if (v8)
  {
    if (a1) {
      id v14 = *(id *)(a1 + OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data);
    }
    else {
      id v14 = 0;
    }
    uint64_t v15 = swift_allocObject();
    *(void *)(v15 + 16) = a2;
    *(void *)(v15 + 24) = a3;
    v18[4] = a5;
    v18[5] = v15;
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 1107296256;
    void v18[2] = sub_1BCBDA454;
    v18[3] = a6;
    id v16 = _Block_copy(v18);
    id v17 = v8;
    swift_retain();
    swift_release();
    objc_msgSend(v17, *a7, v14, v16);
    _Block_release(v16);
  }
}

uint64_t sub_1BCBDA750(unint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t))
{
  if (!a1)
  {
    uint64_t v14 = 0;
LABEL_14:
    a3(v14, a2);
    return swift_bridgeObjectRelease();
  }
  if (!(a1 >> 62))
  {
    uint64_t v6 = *(void *)((a1 & 0xFFFFFFFFFFFFFF8) + 0x10);
    swift_bridgeObjectRetain();
    if (v6) {
      goto LABEL_4;
    }
    goto LABEL_13;
  }
  swift_bridgeObjectRetain();
  uint64_t v6 = sub_1BD2E49B0();
  if (!v6)
  {
LABEL_13:
    swift_bridgeObjectRelease();
    uint64_t v14 = MEMORY[0x1E4FBC860];
    goto LABEL_14;
  }
LABEL_4:
  uint64_t v16 = MEMORY[0x1E4FBC860];
  uint64_t result = sub_1BD2E4950();
  if ((v6 & 0x8000000000000000) == 0)
  {
    uint64_t v8 = 0;
    do
    {
      if ((a1 & 0xC000000000000001) != 0) {
        id v9 = (id)MEMORY[0x1C1879860](v8, a1);
      }
      else {
        id v9 = *(id *)(a1 + 8 * v8 + 32);
      }
      id v10 = v9;
      ++v8;
      uint64_t v11 = (objc_class *)type metadata accessor for HDCMSwimData();
      uint64_t v12 = (char *)objc_allocWithZone(v11);
      *(void *)&v12[OBJC_IVAR____TtC12HealthDaemon12HDCMSwimData_data] = v10;
      v15.receiver = v12;
      v15.super_class = v11;
      objc_msgSendSuper2(&v15, sel_init);
      sub_1BD2E4930();
      sub_1BD2E4960();
      sub_1BD2E4970();
      sub_1BD2E4940();
    }
    while (v6 != v8);
    uint64_t v13 = v16;
    swift_bridgeObjectRelease();
    a3(v13, a2);
    return swift_bridgeObjectRelease();
  }
  __break(1u);
  return result;
}

uint64_t sub_1BCBDA924(void *a1, int a2, void *a3, void *aBlock, uint64_t a5, uint64_t a6, void (*a7)(void *, uint64_t, uint64_t))
{
  uint64_t v11 = _Block_copy(aBlock);
  uint64_t v12 = swift_allocObject();
  *(void *)(v12 + 16) = v11;
  id v13 = a3;
  id v14 = a1;
  a7(a3, a6, v12);

  return swift_release();
}

id HDCMSwimTracker.init()()
{
  *(void *)&v0[OBJC_IVAR____TtC12HealthDaemon15HDCMSwimTracker_tracker] = 0;
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for HDCMSwimTracker();
  return objc_msgSendSuper2(&v2, sel_init);
}

uint64_t type metadata accessor for HDCMSwimTracker()
{
  return self;
}

id HDCMSwimTracker.__deallocating_deinit()
{
  return sub_1BCBDAB00(type metadata accessor for HDCMSwimTracker);
}

id sub_1BCBDAB00(uint64_t (*a1)(void))
{
  v3.receiver = v1;
  v3.super_class = (Class)a1();
  return objc_msgSendSuper2(&v3, sel_dealloc);
}

uint64_t method lookup function for HDCMSwimData(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for HDCMSwimData);
}

uint64_t dispatch thunk of HDCMSwimData.startDate.getter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x58))();
}

uint64_t dispatch thunk of HDCMSwimData.endDate.getter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x60))();
}

uint64_t dispatch thunk of HDCMSwimData.recordId.getter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x68))();
}

uint64_t dispatch thunk of HDCMSwimData.sourceId.getter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x70))();
}

uint64_t dispatch thunk of HDCMSwimData.lapCount.getter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x78))();
}

uint64_t dispatch thunk of HDCMSwimData.segment.getter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x80))();
}

uint64_t dispatch thunk of HDCMSwimData.distance.getter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x88))();
}

uint64_t dispatch thunk of HDCMSwimData.strokeCount.getter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x90))();
}

uint64_t dispatch thunk of HDCMSwimData.strokeType.getter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x98))();
}

uint64_t method lookup function for HDCMSwimTracker(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for HDCMSwimTracker);
}

uint64_t dispatch thunk of HDCMSwimTracker.startUpdates(fromRecord:handler:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x70))();
}

uint64_t dispatch thunk of HDCMSwimTracker.stopUpdates()()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x78))();
}

uint64_t dispatch thunk of HDCMSwimTracker.querySwimUpdates(fromRecord:handler:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x80))();
}

uint64_t sub_1BCBDADE8()
{
  _Block_release(*(const void **)(v0 + 16));

  return MEMORY[0x1F4186498](v0, 24, 7);
}

void sub_1BCBDAE20(void *a1, uint64_t a2)
{
  sub_1BCBDA534(a1, a2, *(void *)(v2 + 16));
}

unint64_t sub_1BCBDAE28()
{
  unint64_t result = qword_1E9FBDEF8;
  if (!qword_1E9FBDEF8)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_1E9FBDEF8);
  }
  return result;
}

uint64_t *__swift_allocate_value_buffer(uint64_t a1, uint64_t *a2)
{
  if ((*(_DWORD *)(*(void *)(a1 - 8) + 80) & 0x20000) != 0)
  {
    uint64_t v3 = swift_slowAlloc();
    *a2 = v3;
    return (uint64_t *)v3;
  }
  return a2;
}

void *sub_1BCBDAEE8(uint64_t a1)
{
  unint64_t result = (void *)sub_1BCBDCC58(a1);
  if (v4) {
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 36) != v3)
  {
    __break(1u);
LABEL_8:
    __break(1u);
    return result;
  }
  if (result == (void *)(1 << *(unsigned char *)(a1 + 32))) {
    return 0;
  }
  else {
    return sub_1BCBDCCE0(&v5, (uint64_t)result, v3, 0, a1);
  }
}

unint64_t sub_1BCBDAF74(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    int v3 = (void *)MEMORY[0x1E4FBC868];
    goto LABEL_9;
  }
  sub_1BCBDCF74();
  uint64_t v2 = sub_1BD2E49E0();
  int v3 = (void *)v2;
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v3;
  }
  uint64_t v5 = v2 + 64;
  uint64_t v6 = a1 + 32;
  swift_retain();
  while (1)
  {
    sub_1BCBDCFE0(v6, (uint64_t)&v15);
    uint64_t v7 = v15;
    uint64_t v8 = v16;
    unint64_t result = sub_1BCBDC030(v15, v16);
    if (v10) {
      break;
    }
    *(void *)(v5 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << result;
    uint64_t v11 = (uint64_t *)(v3[6] + 16 * result);
    *uint64_t v11 = v7;
    v11[1] = v8;
    unint64_t result = (unint64_t)sub_1BCBDD044(&v17, (_OWORD *)(v3[7] + 32 * result));
    uint64_t v12 = v3[2];
    BOOL v13 = __OFADD__(v12, 1);
    uint64_t v14 = v12 + 1;
    if (v13) {
      goto LABEL_11;
    }
    v3[2] = v14;
    v6 += 48;
    if (!--v4)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

unint64_t sub_1BCBDB09C(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v2 = (void *)MEMORY[0x1E4FBC868];
    goto LABEL_9;
  }
  sub_1BCBDCA40();
  uint64_t v2 = (void *)sub_1BD2E49E0();
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3)
  {
LABEL_9:
    swift_bridgeObjectRelease();
    return (unint64_t)v2;
  }
  swift_retain();
  uint64_t v4 = (void **)(a1 + 48);
  while (1)
  {
    uint64_t v5 = (uint64_t)*(v4 - 2);
    uint64_t v6 = (uint64_t)*(v4 - 1);
    uint64_t v7 = *v4;
    swift_bridgeObjectRetain();
    id v8 = v7;
    unint64_t result = sub_1BCBDC030(v5, v6);
    if (v10) {
      break;
    }
    *(void *)((char *)v2 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << result;
    uint64_t v11 = (uint64_t *)(v2[6] + 16 * result);
    *uint64_t v11 = v5;
    v11[1] = v6;
    *(void *)(v2[7] + 8 * result) = v8;
    uint64_t v12 = v2[2];
    BOOL v13 = __OFADD__(v12, 1);
    uint64_t v14 = v12 + 1;
    if (v13) {
      goto LABEL_11;
    }
    v2[2] = v14;
    v4 += 3;
    if (!--v3)
    {
      swift_release();
      goto LABEL_9;
    }
  }
  __break(1u);
LABEL_11:
  __break(1u);
  return result;
}

id HDHealthStoreClientAssertions.__deallocating_deinit()
{
  sub_1BCBDB244();
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for HDHealthStoreClientAssertions();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

id sub_1BCBDB244()
{
  id v1 = (os_unfair_lock_s *)(v0 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v1);
  swift_endAccess();
  objc_super v2 = (uint64_t *)(v0 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions_databaseAccessibilityAssertions);
  swift_beginAccess();
  uint64_t v3 = *v2;
  uint64_t v4 = v3 + 64;
  uint64_t v5 = 1 << *(unsigned char *)(v3 + 32);
  uint64_t v6 = -1;
  if (v5 < 64) {
    uint64_t v6 = ~(-1 << v5);
  }
  unint64_t v7 = v6 & *(void *)(v3 + 64);
  int64_t v8 = (unint64_t)(v5 + 63) >> 6;
  id result = (id)swift_bridgeObjectRetain();
  int64_t v10 = 0;
  while (1)
  {
    if (v7)
    {
      unint64_t v11 = __clz(__rbit64(v7));
      v7 &= v7 - 1;
      unint64_t v12 = v11 | (v10 << 6);
      goto LABEL_5;
    }
    int64_t v13 = v10 + 1;
    if (__OFADD__(v10, 1))
    {
      __break(1u);
      goto LABEL_25;
    }
    if (v13 >= v8) {
      goto LABEL_23;
    }
    unint64_t v14 = *(void *)(v4 + 8 * v13);
    ++v10;
    if (!v14)
    {
      int64_t v10 = v13 + 1;
      if (v13 + 1 >= v8) {
        goto LABEL_23;
      }
      unint64_t v14 = *(void *)(v4 + 8 * v10);
      if (!v14)
      {
        int64_t v10 = v13 + 2;
        if (v13 + 2 >= v8) {
          goto LABEL_23;
        }
        unint64_t v14 = *(void *)(v4 + 8 * v10);
        if (!v14)
        {
          int64_t v10 = v13 + 3;
          if (v13 + 3 >= v8) {
            goto LABEL_23;
          }
          unint64_t v14 = *(void *)(v4 + 8 * v10);
          if (!v14) {
            break;
          }
        }
      }
    }
LABEL_22:
    unint64_t v7 = (v14 - 1) & v14;
    unint64_t v12 = __clz(__rbit64(v14)) + (v10 << 6);
LABEL_5:
    id result = objc_msgSend(*(id *)(*(void *)(v3 + 56) + 8 * v12), sel_invalidate);
  }
  int64_t v15 = v13 + 4;
  if (v15 >= v8)
  {
LABEL_23:
    swift_release();
    swift_beginAccess();
    os_unfair_lock_unlock(v1);
    return (id)swift_endAccess();
  }
  unint64_t v14 = *(void *)(v4 + 8 * v15);
  if (v14)
  {
    int64_t v10 = v15;
    goto LABEL_22;
  }
  while (1)
  {
    int64_t v10 = v15 + 1;
    if (__OFADD__(v15, 1)) {
      break;
    }
    if (v10 >= v8) {
      goto LABEL_23;
    }
    unint64_t v14 = *(void *)(v4 + 8 * v10);
    ++v15;
    if (v14) {
      goto LABEL_22;
    }
  }
LABEL_25:
  __break(1u);
  return result;
}

uint64_t type metadata accessor for HDHealthStoreClientAssertions()
{
  return self;
}

uint64_t sub_1BCBDB488()
{
  id v1 = (os_unfair_lock_s *)(v0 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v1);
  swift_endAccess();
  objc_super v2 = (uint64_t *)(v0 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions_databaseAccessibilityAssertions);
  swift_beginAccess();
  sub_1BCBDAEE8(*v2);
  if (v4)
  {
    uint64_t v5 = v3;
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v5 = 0;
  }
  swift_beginAccess();
  os_unfair_lock_unlock(v1);
  swift_endAccess();
  return v5;
}

unint64_t sub_1BCBDB628()
{
  id v1 = (os_unfair_lock_s *)(v0 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v1);
  swift_endAccess();
  swift_beginAccess();
  uint64_t v2 = swift_bridgeObjectRetain();
  unint64_t v3 = (unint64_t)sub_1BCBDBF48(v2);
  swift_bridgeObjectRelease();
  swift_beginAccess();
  os_unfair_lock_unlock(v1);
  swift_endAccess();
  if ((v3 & 0x8000000000000000) != 0 || (v3 & 0x4000000000000000) != 0)
  {
    swift_bridgeObjectRetain();
    uint64_t v5 = sub_1BD2E49B0();
    swift_release();
    if (v5) {
      return v3;
    }
    goto LABEL_4;
  }
  if (!*(void *)(v3 + 16))
  {
LABEL_4:
    swift_release();
    return 0;
  }
  return v3;
}

void *sub_1BCBDB794(void *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = sub_1BD2E46A0();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4);
  unint64_t v7 = &v20[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  int64_t v8 = (os_unfair_lock_s *)(v2 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v8);
  swift_endAccess();
  id v9 = objc_msgSend(a1, sel_UUID);
  sub_1BD2E4690();

  uint64_t v10 = sub_1BD2E4670();
  uint64_t v12 = v11;
  (*(void (**)(unsigned char *, uint64_t))(v5 + 8))(v7, v4);
  int64_t v13 = (uint64_t *)(v2 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions_databaseAccessibilityAssertions);
  swift_beginAccess();
  uint64_t v14 = *v13;
  if (!*(void *)(v14 + 16)) {
    goto LABEL_6;
  }
  swift_bridgeObjectRetain();
  unint64_t v15 = sub_1BCBDC030(v10, v12);
  if ((v16 & 1) == 0)
  {
    swift_bridgeObjectRelease();
LABEL_6:
    swift_bridgeObjectRelease();
    long long v17 = 0;
    goto LABEL_7;
  }
  long long v17 = *(void **)(*(void *)(v14 + 56) + 8 * v15);
  id v18 = v17;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
LABEL_7:
  swift_beginAccess();
  os_unfair_lock_unlock(v8);
  swift_endAccess();
  return v17;
}

uint64_t sub_1BCBDB9D8(void *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = sub_1BD2E46A0();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4);
  unint64_t v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  int64_t v8 = (os_unfair_lock_s *)(v2 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v8);
  swift_endAccess();
  id v9 = objc_msgSend(a1, sel_UUID);
  sub_1BD2E4690();

  uint64_t v10 = sub_1BD2E4670();
  uint64_t v12 = v11;
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  int64_t v13 = (uint64_t *)(v2 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions_databaseAccessibilityAssertions);
  swift_beginAccess();
  id v14 = a1;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v17 = *v13;
  *int64_t v13 = 0x8000000000000000;
  sub_1BCBDC740((uint64_t)v14, v10, v12, isUniquelyReferenced_nonNull_native);
  *int64_t v13 = v17;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_endAccess();
  swift_beginAccess();
  os_unfair_lock_unlock(v8);
  return swift_endAccess();
}

uint64_t sub_1BCBDBC18(void *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = sub_1BD2E46A0();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4);
  unint64_t v7 = (char *)&v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  int64_t v8 = (os_unfair_lock_s *)(v2 + OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock);
  swift_beginAccess();
  os_unfair_lock_lock(v8);
  swift_endAccess();
  id v9 = objc_msgSend(a1, sel_UUID);
  sub_1BD2E4690();

  uint64_t v10 = sub_1BD2E4670();
  uint64_t v12 = v11;
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  swift_beginAccess();
  int64_t v13 = (void *)sub_1BCBDC18C(v10, v12);
  swift_endAccess();
  swift_bridgeObjectRelease();

  swift_beginAccess();
  os_unfair_lock_unlock(v8);
  return swift_endAccess();
}

id HDHealthStoreClientAssertions.__allocating_init()()
{
  id v1 = objc_allocWithZone(v0);

  return objc_msgSend(v1, sel_init);
}

id HDHealthStoreClientAssertions.init()()
{
  *(_DWORD *)&v0[OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions__dbAssertionLock] = 0;
  uint64_t v1 = OBJC_IVAR____TtC12HealthDaemon29HDHealthStoreClientAssertions_databaseAccessibilityAssertions;
  uint64_t v2 = v0;
  *(void *)&v0[v1] = sub_1BCBDB09C(MEMORY[0x1E4FBC860]);

  v4.receiver = v2;
  v4.super_class = (Class)type metadata accessor for HDHealthStoreClientAssertions();
  return objc_msgSendSuper2(&v4, sel_init);
}

void *sub_1BCBDBF48(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return (void *)MEMORY[0x1E4FBC860];
  }
  sub_1BCBD7C90();
  unint64_t v3 = (void *)swift_allocObject();
  int64_t v4 = _swift_stdlib_malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 25;
  }
  v3[2] = v1;
  v3[3] = (2 * (v5 >> 3)) | 1;
  uint64_t v6 = sub_1BCBDCD70(&v8, v3 + 4, v1, a1);
  swift_bridgeObjectRetain();
  sub_1BCBDCF6C();
  if (v6 != (void *)v1)
  {
    __break(1u);
    return (void *)MEMORY[0x1E4FBC860];
  }
  return v3;
}

unint64_t sub_1BCBDC030(uint64_t a1, uint64_t a2)
{
  sub_1BD2E4AA0();
  sub_1BD2E4790();
  uint64_t v4 = sub_1BD2E4AB0();

  return sub_1BCBDC0A8(a1, a2, v4);
}

unint64_t sub_1BCBDC0A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(v3 + 32);
  unint64_t v6 = a3 & ~v5;
  if ((*(void *)(v3 + 64 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6))
  {
    uint64_t v9 = *(void *)(v3 + 48);
    uint64_t v10 = (void *)(v9 + 16 * v6);
    BOOL v11 = *v10 == a1 && v10[1] == a2;
    if (!v11 && (sub_1BD2E4A30() & 1) == 0)
    {
      uint64_t v12 = ~v5;
      do
      {
        unint64_t v6 = (v6 + 1) & v12;
        if (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) == 0) {
          break;
        }
        int64_t v13 = (void *)(v9 + 16 * v6);
        BOOL v14 = *v13 == a1 && v13[1] == a2;
      }
      while (!v14 && (sub_1BD2E4A30() & 1) == 0);
    }
  }
  return v6;
}

uint64_t sub_1BCBDC18C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  swift_bridgeObjectRetain();
  unint64_t v6 = sub_1BCBDC030(a1, a2);
  LOBYTE(a2) = v7;
  swift_bridgeObjectRelease();
  if ((a2 & 1) == 0) {
    return 0;
  }
  int isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v9 = *v3;
  uint64_t v12 = *v3;
  uint64_t *v3 = 0x8000000000000000;
  if (!isUniquelyReferenced_nonNull_native)
  {
    sub_1BCBDCAA8();
    uint64_t v9 = v12;
  }
  swift_bridgeObjectRelease();
  uint64_t v10 = *(void *)(*(void *)(v9 + 56) + 8 * v6);
  sub_1BCBDC568(v6, v9);
  uint64_t *v3 = v9;
  swift_bridgeObjectRelease();
  return v10;
}

uint64_t sub_1BCBDC25C(uint64_t a1, char a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = *v2;
  sub_1BCBDCA40();
  char v38 = a2;
  uint64_t v6 = sub_1BD2E49D0();
  uint64_t v7 = v6;
  if (!*(void *)(v5 + 16)) {
    goto LABEL_40;
  }
  uint64_t v8 = 1 << *(unsigned char *)(v5 + 32);
  uint64_t v37 = v5 + 64;
  if (v8 < 64) {
    uint64_t v9 = ~(-1 << v8);
  }
  else {
    uint64_t v9 = -1;
  }
  unint64_t v10 = v9 & *(void *)(v5 + 64);
  unint64_t v35 = v2;
  int64_t v36 = (unint64_t)(v8 + 63) >> 6;
  uint64_t v11 = v6 + 64;
  uint64_t result = swift_retain();
  int64_t v13 = 0;
  while (1)
  {
    if (v10)
    {
      unint64_t v19 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      unint64_t v20 = v19 | (v13 << 6);
      goto LABEL_31;
    }
    int64_t v21 = v13 + 1;
    if (__OFADD__(v13, 1))
    {
LABEL_41:
      __break(1u);
LABEL_42:
      __break(1u);
      return result;
    }
    if (v21 >= v36) {
      break;
    }
    id v22 = (void *)(v5 + 64);
    unint64_t v23 = *(void *)(v37 + 8 * v21);
    ++v13;
    if (!v23)
    {
      int64_t v13 = v21 + 1;
      if (v21 + 1 >= v36) {
        goto LABEL_33;
      }
      unint64_t v23 = *(void *)(v37 + 8 * v13);
      if (!v23)
      {
        int64_t v24 = v21 + 2;
        if (v24 >= v36)
        {
LABEL_33:
          swift_release();
          uint64_t v3 = v35;
          if ((v38 & 1) == 0) {
            goto LABEL_40;
          }
          goto LABEL_36;
        }
        unint64_t v23 = *(void *)(v37 + 8 * v24);
        if (!v23)
        {
          while (1)
          {
            int64_t v13 = v24 + 1;
            if (__OFADD__(v24, 1)) {
              goto LABEL_42;
            }
            if (v13 >= v36) {
              goto LABEL_33;
            }
            unint64_t v23 = *(void *)(v37 + 8 * v13);
            ++v24;
            if (v23) {
              goto LABEL_30;
            }
          }
        }
        int64_t v13 = v24;
      }
    }
LABEL_30:
    unint64_t v10 = (v23 - 1) & v23;
    unint64_t v20 = __clz(__rbit64(v23)) + (v13 << 6);
LABEL_31:
    id v29 = (uint64_t *)(*(void *)(v5 + 48) + 16 * v20);
    uint64_t v31 = *v29;
    uint64_t v30 = v29[1];
    uint64_t v32 = *(void **)(*(void *)(v5 + 56) + 8 * v20);
    if ((v38 & 1) == 0)
    {
      swift_bridgeObjectRetain();
      id v33 = v32;
    }
    sub_1BD2E4AA0();
    sub_1BD2E4790();
    uint64_t result = sub_1BD2E4AB0();
    uint64_t v14 = -1 << *(unsigned char *)(v7 + 32);
    unint64_t v15 = result & ~v14;
    unint64_t v16 = v15 >> 6;
    if (((-1 << v15) & ~*(void *)(v11 + 8 * (v15 >> 6))) != 0)
    {
      unint64_t v17 = __clz(__rbit64((-1 << v15) & ~*(void *)(v11 + 8 * (v15 >> 6)))) | v15 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      char v25 = 0;
      unint64_t v26 = (unint64_t)(63 - v14) >> 6;
      do
      {
        if (++v16 == v26 && (v25 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }
        BOOL v27 = v16 == v26;
        if (v16 == v26) {
          unint64_t v16 = 0;
        }
        v25 |= v27;
        uint64_t v28 = *(void *)(v11 + 8 * v16);
      }
      while (v28 == -1);
      unint64_t v17 = __clz(__rbit64(~v28)) + (v16 << 6);
    }
    *(void *)(v11 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v17;
    id v18 = (void *)(*(void *)(v7 + 48) + 16 * v17);
    *id v18 = v31;
    v18[1] = v30;
    *(void *)(*(void *)(v7 + 56) + 8 * v17) = v32;
    ++*(void *)(v7 + 16);
  }
  swift_release();
  uint64_t v3 = v35;
  id v22 = (void *)(v5 + 64);
  if ((v38 & 1) == 0) {
    goto LABEL_40;
  }
LABEL_36:
  uint64_t v34 = 1 << *(unsigned char *)(v5 + 32);
  if (v34 >= 64) {
    bzero(v22, ((unint64_t)(v34 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
  }
  else {
    void *v22 = -1 << v34;
  }
  *(void *)(v5 + 16) = 0;
LABEL_40:
  uint64_t result = swift_release();
  uint64_t *v3 = v7;
  return result;
}

unint64_t sub_1BCBDC568(unint64_t result, uint64_t a2)
{
  int64_t v3 = result;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = (result + 1) & ~v5;
  if (((1 << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    uint64_t result = sub_1BD2E48D0();
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v8 = (result + 1) & v7;
      do
      {
        sub_1BD2E4AA0();
        swift_bridgeObjectRetain();
        sub_1BD2E4790();
        uint64_t v9 = sub_1BD2E4AB0();
        uint64_t result = swift_bridgeObjectRelease();
        unint64_t v10 = v9 & v7;
        if (v3 >= (uint64_t)v8)
        {
          if (v10 < v8) {
            goto LABEL_5;
          }
        }
        else if (v10 >= v8)
        {
          goto LABEL_11;
        }
        if (v3 >= (uint64_t)v10)
        {
LABEL_11:
          uint64_t v11 = *(void *)(a2 + 48);
          uint64_t v12 = (_OWORD *)(v11 + 16 * v3);
          int64_t v13 = (_OWORD *)(v11 + 16 * v6);
          if (v3 != v6 || v12 >= v13 + 1) {
            *uint64_t v12 = *v13;
          }
          uint64_t v14 = *(void *)(a2 + 56);
          unint64_t v15 = (void *)(v14 + 8 * v3);
          unint64_t v16 = (void *)(v14 + 8 * v6);
          if (v3 != v6 || (int64_t v3 = v6, v15 >= v16 + 1))
          {
            *unint64_t v15 = *v16;
            int64_t v3 = v6;
          }
        }
LABEL_5:
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    unint64_t v17 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    uint64_t v18 = *v17;
    uint64_t v19 = (-1 << v3) - 1;
  }
  else
  {
    unint64_t v17 = (uint64_t *)(v4 + 8 * (result >> 6));
    uint64_t v19 = *v17;
    uint64_t v18 = (-1 << result) - 1;
  }
  *unint64_t v17 = v19 & v18;
  uint64_t v20 = *(void *)(a2 + 16);
  BOOL v21 = __OFSUB__(v20, 1);
  uint64_t v22 = v20 - 1;
  if (v21)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a2 + 16) = v22;
    ++*(_DWORD *)(a2 + 36);
  }
  return result;
}

void sub_1BCBDC740(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v10 = *v4;
  unint64_t v12 = sub_1BCBDC030(a2, a3);
  uint64_t v13 = *(void *)(v10 + 16);
  BOOL v14 = (v11 & 1) == 0;
  uint64_t v15 = v13 + v14;
  if (__OFADD__(v13, v14))
  {
    __break(1u);
    goto LABEL_16;
  }
  char v16 = v11;
  uint64_t v17 = *(void *)(v10 + 24);
  if (v17 >= v15 && (a4 & 1) != 0) {
    goto LABEL_7;
  }
  if (v17 >= v15 && (a4 & 1) == 0)
  {
    sub_1BCBDCAA8();
LABEL_7:
    uint64_t v18 = (void *)*v5;
    if (v16)
    {
LABEL_8:
      uint64_t v19 = v18[7];

      *(void *)(v19 + 8 * v12) = a1;
      return;
    }
    goto LABEL_11;
  }
  sub_1BCBDC25C(v15, a4 & 1);
  unint64_t v20 = sub_1BCBDC030(a2, a3);
  if ((v16 & 1) != (v21 & 1))
  {
LABEL_17:
    sub_1BD2E4A50();
    __break(1u);
    return;
  }
  unint64_t v12 = v20;
  uint64_t v18 = (void *)*v5;
  if (v16) {
    goto LABEL_8;
  }
LABEL_11:
  v18[(v12 >> 6) + 8] |= 1 << v12;
  uint64_t v22 = (uint64_t *)(v18[6] + 16 * v12);
  uint64_t *v22 = a2;
  v22[1] = a3;
  *(void *)(v18[7] + 8 * v12) = a1;
  uint64_t v23 = v18[2];
  BOOL v24 = __OFADD__(v23, 1);
  uint64_t v25 = v23 + 1;
  if (v24)
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  void v18[2] = v25;

  swift_bridgeObjectRetain();
}

uint64_t method lookup function for HDHealthStoreClientAssertions(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F4186708](a1, a2, &nominal type descriptor for HDHealthStoreClientAssertions);
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.invalidateAssertions()()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x90))();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.firstAssertion()()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x98))();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.accessibilityAssertions()()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xA0))();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.assertionForHKDatabaseAccessibilityAssertion(hkDatabaseAccessibilityAssertion:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xA8))();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.addAssertionMapping(assertion:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xB0))();
}

uint64_t dispatch thunk of HDHealthStoreClientAssertions.removeAssertionMapping(assertion:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0xB8))();
}

unint64_t sub_1BCBDCA00()
{
  unint64_t result = qword_1EBA18A68;
  if (!qword_1EBA18A68)
  {
    self;
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&qword_1EBA18A68);
  }
  return result;
}

void sub_1BCBDCA40()
{
  if (!qword_1EBA18A70)
  {
    sub_1BCBDCA00();
    unint64_t v0 = sub_1BD2E49F0();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EBA18A70);
    }
  }
}

id sub_1BCBDCAA8()
{
  uint64_t v1 = v0;
  sub_1BCBDCA40();
  uint64_t v2 = *v0;
  uint64_t v3 = sub_1BD2E49C0();
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_26:
    id result = (id)swift_release();
    uint64_t *v1 = v4;
    return result;
  }
  id result = (id)(v3 + 64);
  uint64_t v6 = v2 + 64;
  unint64_t v7 = (unint64_t)((1 << *(unsigned char *)(v4 + 32)) + 63) >> 6;
  if (v4 != v2 || (unint64_t)result >= v2 + 64 + 8 * v7) {
    id result = memmove(result, (const void *)(v2 + 64), 8 * v7);
  }
  int64_t v9 = 0;
  *(void *)(v4 + 16) = *(void *)(v2 + 16);
  uint64_t v10 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v11 = -1;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }
    int64_t v22 = v9 + 1;
    if (__OFADD__(v9, 1))
    {
      __break(1u);
      goto LABEL_28;
    }
    if (v22 >= v13) {
      goto LABEL_26;
    }
    unint64_t v23 = *(void *)(v6 + 8 * v22);
    ++v9;
    if (!v23)
    {
      int64_t v9 = v22 + 1;
      if (v22 + 1 >= v13) {
        goto LABEL_26;
      }
      unint64_t v23 = *(void *)(v6 + 8 * v9);
      if (!v23) {
        break;
      }
    }
LABEL_25:
    unint64_t v12 = (v23 - 1) & v23;
    unint64_t v15 = __clz(__rbit64(v23)) + (v9 << 6);
LABEL_12:
    uint64_t v16 = 16 * v15;
    uint64_t v17 = (void *)(*(void *)(v2 + 48) + 16 * v15);
    uint64_t v18 = v17[1];
    uint64_t v19 = 8 * v15;
    unint64_t v20 = *(void **)(*(void *)(v2 + 56) + v19);
    char v21 = (void *)(*(void *)(v4 + 48) + v16);
    *char v21 = *v17;
    v21[1] = v18;
    *(void *)(*(void *)(v4 + 56) + v19) = v20;
    swift_bridgeObjectRetain();
    id result = v20;
  }
  int64_t v24 = v22 + 2;
  if (v24 >= v13) {
    goto LABEL_26;
  }
  unint64_t v23 = *(void *)(v6 + 8 * v24);
  if (v23)
  {
    int64_t v9 = v24;
    goto LABEL_25;
  }
  while (1)
  {
    int64_t v9 = v24 + 1;
    if (__OFADD__(v24, 1)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    unint64_t v23 = *(void *)(v6 + 8 * v9);
    ++v24;
    if (v23) {
      goto LABEL_25;
    }
  }
LABEL_28:
  __break(1u);
  return result;
}

uint64_t sub_1BCBDCC58(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 64);
  if (v1)
  {
    uint64_t v2 = 0;
    return __clz(__rbit64(v1)) + v2;
  }
  char v5 = *(unsigned char *)(a1 + 32);
  unsigned int v6 = v5 & 0x3F;
  uint64_t v3 = 1 << v5;
  if (v6 < 7) {
    return v3;
  }
  unint64_t v1 = *(void *)(a1 + 72);
  if (v1)
  {
    uint64_t v2 = 64;
    return __clz(__rbit64(v1)) + v2;
  }
  unint64_t v7 = (unint64_t)(v3 + 63) >> 6;
  if (v7 <= 2) {
    unint64_t v7 = 2;
  }
  unint64_t v8 = v7 - 2;
  int64_t v9 = (unint64_t *)(a1 + 80);
  uint64_t v2 = 64;
  while (v8)
  {
    unint64_t v10 = *v9++;
    unint64_t v1 = v10;
    --v8;
    v2 += 64;
    if (v10) {
      return __clz(__rbit64(v1)) + v2;
    }
  }
  return v3;
}

void *sub_1BCBDCCE0(void *result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 < 0 || 1 << *(unsigned char *)(a5 + 32) <= a2)
  {
    __break(1u);
    goto LABEL_7;
  }
  if (((*(void *)(a5 + 8 * ((unint64_t)a2 >> 6) + 64) >> a2) & 1) == 0)
  {
LABEL_7:
    __break(1u);
    goto LABEL_8;
  }
  if (*(_DWORD *)(a5 + 36) == a3)
  {
    uint64_t v5 = *(void *)(*(void *)(a5 + 48) + 16 * a2);
    unsigned int v6 = *(void **)(*(void *)(a5 + 56) + 8 * a2);
    *id result = v6;
    swift_bridgeObjectRetain();
    id v7 = v6;
    return (void *)v5;
  }
LABEL_8:
  __break(1u);
  return result;
}

void *sub_1BCBDCD70(void *result, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = result;
  uint64_t v6 = a4 + 64;
  uint64_t v7 = -1 << *(unsigned char *)(a4 + 32);
  if (-v7 < 64) {
    uint64_t v8 = ~(-1 << -(char)v7);
  }
  else {
    uint64_t v8 = -1;
  }
  unint64_t v9 = v8 & *(void *)(a4 + 64);
  if (!a2)
  {
    int64_t v12 = 0;
    uint64_t v10 = 0;
LABEL_38:
    *uint64_t v5 = a4;
    v5[1] = v6;
    v5[2] = ~v7;
    v5[3] = v12;
    v5[4] = v9;
    return (void *)v10;
  }
  uint64_t v10 = a3;
  if (!a3)
  {
    int64_t v12 = 0;
    goto LABEL_38;
  }
  if (a3 < 0)
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }
  uint64_t v11 = a2;
  int64_t v12 = 0;
  uint64_t v13 = 0;
  int64_t v14 = (unint64_t)(63 - v7) >> 6;
  if (!v9) {
    goto LABEL_9;
  }
LABEL_8:
  unint64_t v15 = __clz(__rbit64(v9));
  v9 &= v9 - 1;
  unint64_t v16 = v15 | (v12 << 6);
  while (1)
  {
    ++v13;
    unint64_t v20 = *(void **)(*(void *)(a4 + 56) + 8 * v16);
    *uint64_t v11 = v20;
    if (v13 == v10)
    {
      id v21 = v20;
      goto LABEL_38;
    }
    ++v11;
    id result = v20;
    if (v9) {
      goto LABEL_8;
    }
LABEL_9:
    int64_t v17 = v12 + 1;
    if (__OFADD__(v12, 1))
    {
      __break(1u);
      goto LABEL_40;
    }
    if (v17 >= v14) {
      goto LABEL_33;
    }
    unint64_t v18 = *(void *)(v6 + 8 * v17);
    if (!v18) {
      break;
    }
LABEL_18:
    unint64_t v9 = (v18 - 1) & v18;
    unint64_t v16 = __clz(__rbit64(v18)) + (v17 << 6);
    int64_t v12 = v17;
  }
  v12 += 2;
  if (v17 + 1 >= v14)
  {
    unint64_t v9 = 0;
    int64_t v12 = v17;
    goto LABEL_37;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v12);
  if (v18) {
    goto LABEL_14;
  }
  int64_t v19 = v17 + 2;
  if (v17 + 2 >= v14) {
    goto LABEL_33;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v19);
  if (v18) {
    goto LABEL_17;
  }
  int64_t v12 = v17 + 3;
  if (v17 + 3 >= v14)
  {
    unint64_t v9 = 0;
    int64_t v12 = v17 + 2;
    goto LABEL_37;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v12);
  if (v18)
  {
LABEL_14:
    int64_t v17 = v12;
    goto LABEL_18;
  }
  int64_t v19 = v17 + 4;
  if (v17 + 4 >= v14)
  {
LABEL_33:
    unint64_t v9 = 0;
LABEL_37:
    uint64_t v10 = v13;
    goto LABEL_38;
  }
  unint64_t v18 = *(void *)(v6 + 8 * v19);
  if (v18)
  {
LABEL_17:
    int64_t v17 = v19;
    goto LABEL_18;
  }
  while (1)
  {
    int64_t v17 = v19 + 1;
    if (__OFADD__(v19, 1)) {
      break;
    }
    if (v17 >= v14)
    {
      unint64_t v9 = 0;
      int64_t v12 = v14 - 1;
      goto LABEL_37;
    }
    unint64_t v18 = *(void *)(v6 + 8 * v17);
    ++v19;
    if (v18) {
      goto LABEL_18;
    }
  }
LABEL_41:
  __break(1u);
  return result;
}

uint64_t sub_1BCBDCF6C()
{
  return swift_release();
}

void sub_1BCBDCF74()
{
  if (!qword_1E9FBDF10)
  {
    unint64_t v0 = sub_1BD2E49F0();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1E9FBDF10);
    }
  }
}

uint64_t sub_1BCBDCFE0(uint64_t a1, uint64_t a2)
{
  sub_1BCBD9C68();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

_OWORD *sub_1BCBDD044(_OWORD *a1, _OWORD *a2)
{
  long long v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  return a2;
}

void HDKeyValueDomain.data(for:)()
{
  id v1 = v0;
  swift_bridgeObjectRetain();
  sub_1BCBDD0C4(v1, &v2);
}

void sub_1BCBDD0C4(void *a1@<X1>, uint64_t *a2@<X8>)
{
  v13[1] = *(id *)MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)sub_1BD2E4760();
  v13[0] = 0;
  id v5 = objc_msgSend(a1, sel_dataForKey_error_, v4, v13);

  id v6 = v13[0];
  if (v5)
  {
    id v7 = v13[0];
    uint64_t v8 = sub_1BD2E4640();
    unint64_t v10 = v9;

    if (v6) {
      goto LABEL_3;
    }
LABEL_6:
    id v11 = a1;
    goto LABEL_7;
  }
  id v12 = v13[0];
  uint64_t v8 = 0;
  unint64_t v10 = 0xF000000000000000;
  if (!v6) {
    goto LABEL_6;
  }
LABEL_3:
  id v11 = v6;
  if (objc_msgSend(v11, sel_hk_isHealthKitErrorWithCode_, 11))
  {

    sub_1BCBDDD38(v8, v10);
    uint64_t v8 = 0;
    unint64_t v10 = 0xF000000000000000;
LABEL_7:

    *a2 = v8;
    a2[1] = v10;
    swift_bridgeObjectRelease();
    return;
  }
  swift_willThrow();
  sub_1BCBDDD38(v8, v10);
  swift_bridgeObjectRelease();
}

void sub_1BCBDD22C(void *a1@<X1>, uint64_t a2@<X8>)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  sub_1BCBDDC18();
  MEMORY[0x1F4188790](v4 - 8);
  id v6 = (char *)v16 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  id v7 = (void *)sub_1BD2E4760();
  v16[0] = 0;
  id v8 = objc_msgSend(a1, sel_dateForKey_error_, v7, v16);

  unint64_t v9 = (void *)v16[0];
  if (v8)
  {
    sub_1BD2E4650();
    id v10 = v9;

    uint64_t v11 = sub_1BD2E4660();
    (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56))(v6, 0, 1, v11);
    if (v9) {
      goto LABEL_3;
    }
LABEL_6:
    sub_1BCBDDC70((uint64_t)v6, a2, (uint64_t (*)(void))sub_1BCBDDC18);
    goto LABEL_7;
  }
  uint64_t v14 = sub_1BD2E4660();
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v14 - 8) + 56))(v6, 1, 1, v14);
  id v15 = v9;
  if (!v9) {
    goto LABEL_6;
  }
LABEL_3:
  id v12 = v9;
  if (objc_msgSend(v12, sel_hk_isHealthKitErrorWithCode_, 11))
  {

    sub_1BCBDDCD8((uint64_t)v6, (uint64_t (*)(void))sub_1BCBDDC18);
    uint64_t v13 = sub_1BD2E4660();
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v13 - 8) + 56))(a2, 1, 1, v13);
LABEL_7:

    swift_bridgeObjectRelease();
    return;
  }
  swift_willThrow();
  sub_1BCBDDCD8((uint64_t)v6, (uint64_t (*)(void))sub_1BCBDDC18);
  swift_bridgeObjectRelease();
}

void sub_1BCBDD4C0(void *a1@<X1>, _OWORD *a2@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)sub_1BD2E4760();
  id v10 = 0;
  id v5 = objc_msgSend(a1, sel_propertyListValueForKey_error_, v4, &v10);

  id v6 = v10;
  if (v5)
  {
    id v7 = v10;
    sub_1BD2E48B0();
    swift_unknownObjectRelease();
    if (v6) {
      goto LABEL_3;
    }
LABEL_6:
    sub_1BCBDDC70((uint64_t)v11, (uint64_t)a2, (uint64_t (*)(void))sub_1BCBDDBBC);
    goto LABEL_7;
  }
  memset(v11, 0, sizeof(v11));
  id v9 = v10;
  if (!v6) {
    goto LABEL_6;
  }
LABEL_3:
  id v8 = v6;
  if (objc_msgSend(v8, sel_hk_isHealthKitErrorWithCode_, 11))
  {

    sub_1BCBDDCD8((uint64_t)v11, (uint64_t (*)(void))sub_1BCBDDBBC);
    *a2 = 0u;
    a2[1] = 0u;
LABEL_7:

    swift_bridgeObjectRelease();
    return;
  }
  swift_willThrow();
  sub_1BCBDDCD8((uint64_t)v11, (uint64_t (*)(void))sub_1BCBDDBBC);
  swift_bridgeObjectRelease();
}

void HDKeyValueDomain.date(for:)(uint64_t a1@<X8>)
{
  id v3 = v1;
  swift_bridgeObjectRetain();
  sub_1BCBDD22C(v3, a1);
}

HKQuantity_optional __swiftcall __spoils<CF,ZF,NF,VF,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X21,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> HDKeyValueDomain.quantity(for:unit:)(Swift::String a1, HKUnit unit)
{
  object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  id v6 = v2;
  swift_bridgeObjectRetain();
  id v7 = unit.super.isa;
  id v8 = (objc_class *)sub_1BCBDD894(v6, countAndFlagsBits, (uint64_t)object, (uint64_t)v7);

  swift_bridgeObjectRelease();
  id v10 = v8;
  result.value.super.isa = v10;
  result.is_nil = v9;
  return result;
}

NSNumber_optional __swiftcall __spoils<CF,ZF,NF,VF,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X21,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> HDKeyValueDomain.number(for:)(Swift::String a1)
{
  id v2 = v1;
  swift_bridgeObjectRetain();
  id v3 = (objc_class *)sub_1BCBDD990(v2);

  swift_bridgeObjectRelease();
  id v5 = v3;
  result.value.super.super.isa = v5;
  result.is_nil = v4;
  return result;
}

Swift::String_optional __swiftcall __spoils<CF,ZF,NF,VF,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X21,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> HDKeyValueDomain.string(for:)(Swift::String a1)
{
  id v2 = v1;
  swift_bridgeObjectRetain();
  uint64_t v3 = sub_1BCBDDA84(v2);
  id v5 = v4;

  swift_bridgeObjectRelease();
  uint64_t v6 = v3;
  id v7 = v5;
  result.value._object = v7;
  result.value._uint64_t countAndFlagsBits = v6;
  return result;
}

void HDKeyValueDomain.propertyListValue(for:)(_OWORD *a1@<X8>)
{
  id v3 = v1;
  swift_bridgeObjectRetain();
  sub_1BCBDD4C0(v3, a1);
}

id sub_1BCBDD894(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v10[1] = *(id *)MEMORY[0x1E4F143B8];
  uint64_t v6 = (void *)sub_1BD2E4760();
  v10[0] = 0;
  id v7 = objc_msgSend(a1, sel_quantityForKey_unit_error_, v6, a4, v10);

  if (v10[0])
  {
    id v8 = v10[0];
    if (objc_msgSend(v8, sel_hk_isHealthKitErrorWithCode_, 11))
    {

      return 0;
    }
    else
    {
      swift_willThrow();
    }
  }
  return v7;
}

id sub_1BCBDD990(void *a1)
{
  v6[1] = *(id *)MEMORY[0x1E4F143B8];
  id v2 = (void *)sub_1BD2E4760();
  v6[0] = 0;
  id v3 = objc_msgSend(a1, sel_numberForKey_error_, v2, v6);

  if (v6[0])
  {
    id v4 = v6[0];
    if (objc_msgSend(v4, sel_hk_isHealthKitErrorWithCode_, 11))
    {

      return 0;
    }
    else
    {
      swift_willThrow();
    }
  }
  return v3;
}

uint64_t sub_1BCBDDA84(void *a1)
{
  v10[1] = *(id *)MEMORY[0x1E4F143B8];
  id v2 = (void *)sub_1BD2E4760();
  v10[0] = 0;
  id v3 = objc_msgSend(a1, sel_stringForKey_error_, v2, v10);

  id v4 = v10[0];
  if (v3)
  {
    uint64_t v5 = sub_1BD2E4770();
    id v6 = v4;

    if (!v4) {
      return v5;
    }
  }
  else
  {
    id v7 = v10[0];
    uint64_t v5 = 0;
    if (!v4) {
      return v5;
    }
  }
  id v8 = v4;
  if (objc_msgSend(v8, sel_hk_isHealthKitErrorWithCode_, 11))
  {

    swift_bridgeObjectRelease();
    return 0;
  }
  else
  {
    swift_willThrow();

    swift_bridgeObjectRelease();
  }
  return v5;
}

void sub_1BCBDDBBC()
{
  if (!qword_1EBA18A78)
  {
    unint64_t v0 = sub_1BD2E4880();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EBA18A78);
    }
  }
}

void sub_1BCBDDC18()
{
  if (!qword_1E9FBDF18)
  {
    sub_1BD2E4660();
    unint64_t v0 = sub_1BD2E4880();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1E9FBDF18);
    }
  }
}

uint64_t sub_1BCBDDC70(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t sub_1BCBDDCD8(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_1BCBDDD38(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60 != 15) {
    return sub_1BCBD44A0(a1, a2);
  }
  return a1;
}

void HDSetRecordClassesForDecoding(id obj)
{
}

id HDRecordClassesForDecoding()
{
  if (_recordClasses) {
    return (id)_recordClasses;
  }
  else {
    return MEMORY[0x1E4F1CBF0];
  }
}

__CFString *HDCloudSyncContextPurposeToString(unint64_t a1)
{
  if (a1 >= 0x14)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%zd)", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E62F2B00[a1];
  }

  return v1;
}

__CFString *HDCloudSyncOperationResultToString(uint64_t a1)
{
  if (a1)
  {
    if (a1 == 1)
    {
      id v2 = @"Success";
    }
    else
    {
      objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%zd)", a1);
      id v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
    }
  }
  else
  {
    id v2 = @"Error";
  }
  return v2;
}

__CFString *HDCloudSyncRebaseReasonToString(uint64_t a1)
{
  if ((unint64_t)(a1 + 1) >= 0xC)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%zd)", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E62F2BA0[a1 + 1];
  }

  return v1;
}

__CFString *HDCloudSyncRebaseTriggerToString(uint64_t a1)
{
  if (a1 == 1)
  {
    id v2 = @"third party deleted samples";
  }
  else if (a1)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%zd)", a1);
    id v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v2 = @"health deleted samples";
  }
  return v2;
}

__CFString *HDCloudSyncRestorePhaseToString(uint64_t a1)
{
  if (a1)
  {
    if (a1 == 1)
    {
      id v2 = @"Restore Phase Ingest Complete";
    }
    else
    {
      objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%zd)", a1);
      id v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
    }
  }
  else
  {
    id v2 = @"Restore Phase Sync Complete";
  }
  return v2;
}

uint64_t isCloudKitManateeEnabled(char a1)
{
  return a1 & 1;
}

void HDCloudSyncUpdateProgressOnQueueForObjectAndLog(void *a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  id v13[2] = __HDCloudSyncUpdateProgressOnQueueForObjectAndLog_block_invoke;
  v13[3] = &unk_1E62F2A70;
  id v14 = v7;
  id v15 = v8;
  id v16 = v9;
  uint64_t v17 = a4;
  id v10 = v9;
  uint64_t v11 = v8;
  id v12 = v7;
  dispatch_async(v11, v13);
}

void __HDCloudSyncUpdateProgressOnQueueForObjectAndLog_block_invoke(uint64_t a1)
{
}

void HDCloudSyncUpdateProgressAssertQueueForObjectAndLog(void *a1, NSObject *a2, void *a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a3;
  dispatch_assert_queue_V2(a2);
  [v7 setCompletedUnitCount:a4];
  _HKInitializeLogging();
  id v9 = *MEMORY[0x1E4F29FA8];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_INFO))
  {
    int v10 = 138543874;
    id v11 = v8;
    __int16 v12 = 2048;
    uint64_t v13 = a4;
    __int16 v14 = 2114;
    id v15 = v7;
    _os_log_impl(&dword_1BCB7D000, v9, OS_LOG_TYPE_INFO, "%{public}@: Update progress.completedUnitCount = (%lld): %{public}@", (uint8_t *)&v10, 0x20u);
  }
}

void HDCloudSyncUpdateProgressOnQueueByAmountForObjectAndLog(void *a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  id v13[2] = __HDCloudSyncUpdateProgressOnQueueByAmountForObjectAndLog_block_invoke;
  v13[3] = &unk_1E62F2A70;
  id v14 = v7;
  id v15 = v8;
  id v16 = v9;
  uint64_t v17 = a4;
  id v10 = v9;
  id v11 = v8;
  id v12 = v7;
  dispatch_async(v11, v13);
}

void __HDCloudSyncUpdateProgressOnQueueByAmountForObjectAndLog_block_invoke(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) completedUnitCount];
  uint64_t v3 = *(void **)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 56) + v2;
  uint64_t v5 = *(void **)(a1 + 32);
  id v6 = *(NSObject **)(a1 + 40);

  HDCloudSyncUpdateProgressAssertQueueForObjectAndLog(v5, v6, v3, v4);
}

HDKeyValueDomain *HDCloudSyncKeyValueDomainWithProfile(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [[HDKeyValueDomain alloc] initWithCategory:0 domainName:@"CloudSync" profile:v1];

  return v2;
}

HDKeyValueDomain *HDCloudSyncProtectedAndSyncedKeyValueDomainWithProfile(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [[HDKeyValueDomain alloc] initWithCategory:105 domainName:@"CloudSync" profile:v1];

  return v2;
}

HDKeyValueDomain *HDCloudSyncUnprotectedAndSyncedKeyValueDomainWithProfile(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [[HDKeyValueDomain alloc] initWithCategory:5 domainName:@"CloudSync" profile:v1];

  return v2;
}

uint64_t HDCloudSyncLastSuccessfulPullKeyForContainerIdentifier(uint64_t a1)
{
  return [NSString stringWithFormat:@"%@%@", @"LastSuccessfulPull-", a1];
}

uint64_t HDCloudSyncLastSuccessfulPushKeyForContainerIdentifier(uint64_t a1)
{
  return [NSString stringWithFormat:@"%@%@", @"LastSuccessfulPush-", a1];
}

uint64_t HDCloudSyncLastSuccessfulLitePushKeyForContainerIdentifier(uint64_t a1)
{
  return [NSString stringWithFormat:@"%@%@", @"LastSuccessfulLitePush-", a1];
}

id HDMostRecentSuccessfulPullDateForProfile(void *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = HDCloudSyncKeyValueDomainWithProfile(v3);
  uint64_t v22 = 0;
  unint64_t v23 = &v22;
  uint64_t v24 = 0x3032000000;
  uint64_t v25 = __Block_byref_object_copy_;
  unint64_t v26 = __Block_byref_object_dispose_;
  id v27 = 0;
  obuint64_t j = 0;
  uint64_t v5 = [v4 allValuesWithError:&obj];
  objc_storeStrong(&v27, obj);
  if (v5 || !v23[5])
  {
    id v6 = [v5 allKeys];
    id v7 = objc_msgSend(v6, "hk_map:", &__block_literal_global);

    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v29 = 0x3032000000;
    uint64_t v30 = __Block_byref_object_copy_;
    uint64_t v31 = __Block_byref_object_dispose_;
    id v32 = 0;
    uint64_t v14 = MEMORY[0x1E4F143A8];
    uint64_t v15 = 3221225472;
    id v16 = __HDMostRecentSuccessfulPullDateForProfile_block_invoke_2;
    uint64_t v17 = &unk_1E62F2AB8;
    int64_t v19 = &v22;
    id v18 = v4;
    p_long long buf = &buf;
    [v7 enumerateObjectsUsingBlock:&v14];
    id v8 = (id)v23[5];
    id v9 = v8;
    if (v8)
    {
      if (a2) {
        *a2 = v8;
      }
      else {
        _HKLogDroppedError();
      }
    }

    id v12 = objc_msgSend(*(id *)(*((void *)&buf + 1) + 40), "copy", v14, v15, v16, v17);
    _Block_object_dispose(&buf, 8);
  }
  else
  {
    _HKInitializeLogging();
    id v10 = *MEMORY[0x1E4F29FA8];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = v23[5];
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_impl(&dword_1BCB7D000, v10, OS_LOG_TYPE_DEFAULT, "Could not get keys/values out of cloud sync domain: %{public}@", (uint8_t *)&buf, 0xCu);
    }
    id v12 = 0;
  }

  _Block_object_dispose(&v22, 8);

  return v12;
}

void sub_1BCBE09CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

id __HDMostRecentSuccessfulPullDateForProfile_block_invoke(uint64_t a1, void *a2)
{
  id v2 = a2;
  if ([v2 hasPrefix:@"LastSuccessfulPull-"]) {
    id v3 = v2;
  }
  else {
    id v3 = 0;
  }

  return v3;
}

void __HDMostRecentSuccessfulPullDateForProfile_block_invoke_2(void *a1, void *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v6 = a2;
  uint64_t v7 = *(void *)(a1[5] + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = 0;

  id v9 = (void *)a1[4];
  uint64_t v10 = *(void *)(a1[5] + 8);
  obuint64_t j = *(id *)(v10 + 40);
  uint64_t v11 = [v9 dateForKey:v6 error:&obj];
  objc_storeStrong((id *)(v10 + 40), obj);
  if (!v11)
  {
    if (*(void *)(*(void *)(a1[5] + 8) + 40))
    {
      _HKInitializeLogging();
      id v12 = *MEMORY[0x1E4F29FA8];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = *(void *)(*(void *)(a1[5] + 8) + 40);
        *(_DWORD *)long long buf = 138543618;
        id v21 = v6;
        __int16 v22 = 2114;
        uint64_t v23 = v13;
        _os_log_impl(&dword_1BCB7D000, v12, OS_LOG_TYPE_DEFAULT, "Could not get date for key: %{public}@ from the cloud sync domain: %{public}@", buf, 0x16u);
      }
    }
    uint64_t v14 = *(void *)(a1[6] + 8);
    uint64_t v15 = *(void **)(v14 + 40);
    *(void *)(v14 + 40) = 0;

    *a4 = 1;
  }
  uint64_t v16 = *(void *)(a1[6] + 8);
  uint64_t v17 = *(void **)(v16 + 40);
  if (!v17) {
    goto LABEL_9;
  }
  id v18 = [v17 laterDate:v11];

  if (v18 == v11)
  {
    uint64_t v16 = *(void *)(a1[6] + 8);
LABEL_9:
    objc_storeStrong((id *)(v16 + 40), v11);
  }
}

id HDOldestSampleStartDate(void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = HDCloudSyncProtectedAndSyncedKeyValueDomainWithProfile(v1);
  id v10 = 0;
  id v3 = [v2 dateForKey:@"OldestSampleStartDate" error:&v10];
  id v4 = v10;
  uint64_t v5 = v4;
  id v6 = (os_log_t *)MEMORY[0x1E4F29FA8];
  if (!v3)
  {
    if (v4)
    {
      _HKInitializeLogging();
      uint64_t v7 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v12 = v5;
        _os_log_error_impl(&dword_1BCB7D000, v7, OS_LOG_TYPE_ERROR, "Failed to get persisted oldest sample start date from key value store, Error %{public}@", buf, 0xCu);
      }
    }
  }
  _HKInitializeLogging();
  id v8 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138543618;
    id v12 = v3;
    __int16 v13 = 2114;
    id v14 = v1;
    _os_log_impl(&dword_1BCB7D000, v8, OS_LOG_TYPE_DEFAULT, "Retrieving oldest sample start date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
  }

  return v3;
}

void HDSetOldestSampleStartDate(void *a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  _HKInitializeLogging();
  uint64_t v5 = (os_log_t *)MEMORY[0x1E4F29FA8];
  id v6 = *MEMORY[0x1E4F29FA8];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138543618;
    id v13 = v3;
    __int16 v14 = 2114;
    id v15 = v4;
    _os_log_impl(&dword_1BCB7D000, v6, OS_LOG_TYPE_DEFAULT, "Setting oldest sample start date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
  }
  uint64_t v7 = HDCloudSyncProtectedAndSyncedKeyValueDomainWithProfile(v4);
  id v11 = 0;
  char v8 = [v7 setDate:v3 forKey:@"OldestSampleStartDate" error:&v11];
  id v9 = v11;
  if ((v8 & 1) == 0)
  {
    _HKInitializeLogging();
    id v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543618;
      id v13 = v3;
      __int16 v14 = 2114;
      id v15 = v9;
      _os_log_error_impl(&dword_1BCB7D000, v10, OS_LOG_TYPE_ERROR, "Failed to persist oldest sample start date %{public}@ to key value store, Error %{public}@", buf, 0x16u);
    }
  }
}

id HDCloudSyncRestorePhaseSyncCompleteStartDate(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v1 = HDCloudSyncKeyValueDomainWithProfile(a1);
  id v7 = 0;
  id v2 = [v1 dateForKey:@"CloudSyncRestoreSyncStartDate" error:&v7];
  id v3 = v7;
  id v4 = v3;
  if (!v2)
  {
    if (v3)
    {
      _HKInitializeLogging();
      uint64_t v5 = *MEMORY[0x1E4F29FA8];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v9 = v4;
        _os_log_error_impl(&dword_1BCB7D000, v5, OS_LOG_TYPE_ERROR, "Failed to retrieve cloud sync restore phase sync complete start date from key value store, Error: %{public}@", buf, 0xCu);
      }
    }
  }

  return v2;
}

void HDSetCloudSyncRestorePhaseSyncCompleteStartDate(void *a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  _HKInitializeLogging();
  uint64_t v5 = (os_log_t *)MEMORY[0x1E4F29FA8];
  id v6 = *MEMORY[0x1E4F29FA8];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 138543618;
    id v13 = v3;
    __int16 v14 = 2114;
    id v15 = v4;
    _os_log_impl(&dword_1BCB7D000, v6, OS_LOG_TYPE_INFO, "Setting cloud sync restore phase sync complete start date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
  }
  id v7 = HDCloudSyncKeyValueDomainWithProfile(v4);
  id v11 = 0;
  char v8 = [v7 setDate:v3 forKey:@"CloudSyncRestoreSyncStartDate" error:&v11];
  id v9 = v11;
  if ((v8 & 1) == 0)
  {
    _HKInitializeLogging();
    uint64_t v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543618;
      id v13 = v3;
      __int16 v14 = 2114;
      id v15 = v9;
      _os_log_error_impl(&dword_1BCB7D000, v10, OS_LOG_TYPE_ERROR, "Failed to persist cloud sync restore phase sync complete end date %{public}@ to key value store, Error: %{public}@", buf, 0x16u);
    }
  }
}

id HDCloudSyncRestorePhaseSyncCompleteEndDate(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v1 = HDCloudSyncKeyValueDomainWithProfile(a1);
  id v7 = 0;
  id v2 = [v1 dateForKey:@"CloudSyncRestoreSyncEndDate" error:&v7];
  id v3 = v7;
  id v4 = v3;
  if (!v2)
  {
    if (v3)
    {
      _HKInitializeLogging();
      uint64_t v5 = *MEMORY[0x1E4F29FA8];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v9 = v4;
        _os_log_error_impl(&dword_1BCB7D000, v5, OS_LOG_TYPE_ERROR, "Failed to retrieve cloud sync restore phase sync complete end date from key value store, Error: %{public}@", buf, 0xCu);
      }
    }
  }

  return v2;
}

void HDSetCloudSyncRestorPhaseSyncCompleteEndDate(void *a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  _HKInitializeLogging();
  uint64_t v5 = (os_log_t *)MEMORY[0x1E4F29FA8];
  id v6 = *MEMORY[0x1E4F29FA8];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 138543618;
    id v13 = v3;
    __int16 v14 = 2114;
    id v15 = v4;
    _os_log_impl(&dword_1BCB7D000, v6, OS_LOG_TYPE_INFO, "Setting cloud sync restore phase sync complete end date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
  }
  id v7 = HDCloudSyncKeyValueDomainWithProfile(v4);
  id v11 = 0;
  char v8 = [v7 setDate:v3 forKey:@"CloudSyncRestoreSyncEndDate" error:&v11];
  id v9 = v11;
  if ((v8 & 1) == 0)
  {
    _HKInitializeLogging();
    uint64_t v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543618;
      id v13 = v3;
      __int16 v14 = 2114;
      id v15 = v9;
      _os_log_error_impl(&dword_1BCB7D000, v10, OS_LOG_TYPE_ERROR, "Failed to persist cloud sync restore phase sync complete end date %{public}@ to key value store, Error: %{public}@", buf, 0x16u);
    }
  }
}

id HDCloudSyncRestorePhaseMergeCompleteEndDate(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v1 = HDCloudSyncKeyValueDomainWithProfile(a1);
  id v7 = 0;
  id v2 = [v1 dateForKey:@"CloudSyncRestoreMergeEndDate" error:&v7];
  id v3 = v7;
  id v4 = v3;
  if (!v2)
  {
    if (v3)
    {
      _HKInitializeLogging();
      uint64_t v5 = *MEMORY[0x1E4F29FA8];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v9 = v4;
        _os_log_error_impl(&dword_1BCB7D000, v5, OS_LOG_TYPE_ERROR, "Failed to retrieve cloud sync restore merge complete end date from key value store, Error: %{public}@", buf, 0xCu);
      }
    }
  }

  return v2;
}

void HDSetCloudSyncRestorPhaseMergeCompleteEndDate(void *a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  _HKInitializeLogging();
  uint64_t v5 = (os_log_t *)MEMORY[0x1E4F29FA8];
  id v6 = *MEMORY[0x1E4F29FA8];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 138543618;
    id v13 = v3;
    __int16 v14 = 2114;
    id v15 = v4;
    _os_log_impl(&dword_1BCB7D000, v6, OS_LOG_TYPE_INFO, "Setting cloud sync restore phase merge complete end date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
  }
  id v7 = HDCloudSyncKeyValueDomainWithProfile(v4);
  id v11 = 0;
  char v8 = [v7 setDate:v3 forKey:@"CloudSyncRestoreMergeEndDate" error:&v11];
  id v9 = v11;
  if ((v8 & 1) == 0)
  {
    _HKInitializeLogging();
    uint64_t v10 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543618;
      id v13 = v3;
      __int16 v14 = 2114;
      id v15 = v9;
      _os_log_error_impl(&dword_1BCB7D000, v10, OS_LOG_TYPE_ERROR, "Failed to persist cloud sync restore phase merge complete end date %{public}@ to key value store, Error: %{public}@", buf, 0x16u);
    }
  }
}

void HDUpdateOldestSampleStartDateForProfile(void *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [v1 daemon];
  id v3 = [v2 behavior];
  int v4 = [v3 tinkerModeEnabled];

  if (v4)
  {
    uint64_t v5 = HDOldestSampleStartDate(v1);
    id v11 = 0;
    id v6 = +[HDSampleEntity minimumSampleStartDateForProfile:v1 error:&v11];
    id v7 = v11;
    if (v6)
    {
      if (v5 && !objc_msgSend(v6, "hk_isBeforeDate:", v5)) {
        goto LABEL_13;
      }
      char v8 = v6;
    }
    else
    {
      _HKInitializeLogging();
      id v9 = *MEMORY[0x1E4F29FA8];
      uint64_t v10 = *MEMORY[0x1E4F29FA8];
      if (v7)
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          id v13 = v7;
          _os_log_error_impl(&dword_1BCB7D000, v9, OS_LOG_TYPE_ERROR, "Error fetching oldest sample date %{public}@", buf, 0xCu);
        }
        goto LABEL_13;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1BCB7D000, v9, OS_LOG_TYPE_DEFAULT, "Setting oldest sample date to nil.", buf, 2u);
      }
      char v8 = 0;
    }
    HDSetOldestSampleStartDate(v8, v1);
LABEL_13:
  }
}

id HDCloudSyncLastPulledUpdateDate(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v1 = HDCloudSyncKeyValueDomainWithProfile(a1);
  id v7 = 0;
  id v2 = [v1 dateForKey:@"HDCloudSyncLastPulledUpdateDate" error:&v7];
  id v3 = v7;
  int v4 = v3;
  if (!v2)
  {
    if (v3)
    {
      _HKInitializeLogging();
      uint64_t v5 = *MEMORY[0x1E4F29FA8];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v9 = v4;
        _os_log_error_impl(&dword_1BCB7D000, v5, OS_LOG_TYPE_ERROR, "Failed to retrieve most recent tinker update date from key value store, Error: %{public}@", buf, 0xCu);
      }
    }
  }

  return v2;
}

void HDCloudSyncDidPullUpdateWithDate(void *a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = [v4 database];
  id v14 = 0;
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  _OWORD v11[2] = __HDCloudSyncDidPullUpdateWithDate_block_invoke;
  v11[3] = &unk_1E62F2AE0;
  id v6 = v4;
  id v12 = v6;
  id v7 = v3;
  id v13 = v7;
  BOOL v8 = +[HDHealthEntity performWriteTransactionWithHealthDatabase:v5 error:&v14 block:v11];
  id v9 = v14;

  if (!v8)
  {
    _HKInitializeLogging();
    uint64_t v10 = *MEMORY[0x1E4F29FA8];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      id v16 = v9;
      _os_log_error_impl(&dword_1BCB7D000, v10, OS_LOG_TYPE_ERROR, "Failed to update most recent tinker update date from key value store, Error: %{public}@", buf, 0xCu);
    }
  }
}

uint64_t __HDCloudSyncDidPullUpdateWithDate_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = HDCloudSyncKeyValueDomainWithProfile(*(void **)(a1 + 32));
  id v12 = 0;
  id v6 = [v5 dateForKey:@"HDCloudSyncLastPulledUpdateDate" error:&v12];
  id v7 = v12;
  BOOL v8 = v7;
  if (v6) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = v7 == 0;
  }
  if (v9)
  {
    if (v6 && !objc_msgSend(v6, "hk_isBeforeDate:", *(void *)(a1 + 40))) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = [v5 setDate:*(void *)(a1 + 40) forKey:@"HDCloudSyncLastPulledUpdateDate" error:a3];
    }
  }
  else if (a3)
  {
    uint64_t v10 = 0;
    *a3 = v7;
  }
  else
  {
    _HKLogDroppedError();
    uint64_t v10 = 0;
  }

  return v10;
}

id HDCloudSyncLastSuccessfulPushDateForCoordinatedSync(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v1 = HDCloudSyncUnprotectedAndSyncedKeyValueDomainWithProfile(a1);
  id v7 = 0;
  id v2 = [v1 dateForKey:@"LastSuccessfulPushForCoordinatedSync" error:&v7];
  id v3 = v7;
  id v4 = v3;
  if (!v2)
  {
    if (v3)
    {
      _HKInitializeLogging();
      uint64_t v5 = *MEMORY[0x1E4F29FA8];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        BOOL v9 = v4;
        _os_log_error_impl(&dword_1BCB7D000, v5, OS_LOG_TYPE_ERROR, "Failed to retrieve last successful push date for coordinated sync from key value store, Error: %{public}@", buf, 0xCu);
      }
    }
  }

  return v2;
}

void HDSetCloudSyncLastSuccessfulPushDateForCoordinatedSync(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = [v4 daemon];
  id v6 = [v5 behavior];
  int v7 = [v6 supportsCoordinatedCloudSync];

  if (v7)
  {
    _HKInitializeLogging();
    BOOL v8 = (os_log_t *)MEMORY[0x1E4F29FA8];
    BOOL v9 = *MEMORY[0x1E4F29FA8];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138543618;
      id v16 = v3;
      __int16 v17 = 2114;
      id v18 = v4;
      _os_log_impl(&dword_1BCB7D000, v9, OS_LOG_TYPE_INFO, "Recording successful push for coordinated sync, date %{public}@ on key-value store for profile: %{public}@", buf, 0x16u);
    }
    uint64_t v10 = HDCloudSyncUnprotectedAndSyncedKeyValueDomainWithProfile(v4);
    id v14 = 0;
    char v11 = [v10 setDate:v3 forKey:@"LastSuccessfulPushForCoordinatedSync" error:&v14];
    id v12 = v14;
    if ((v11 & 1) == 0)
    {
      _HKInitializeLogging();
      id v13 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543618;
        id v16 = v3;
        __int16 v17 = 2114;
        id v18 = v12;
        _os_log_error_impl(&dword_1BCB7D000, v13, OS_LOG_TYPE_ERROR, "Failed to persist successful push for coordinated sync, date %{public}@ to key value store, Error: %{public}@", buf, 0x16u);
      }
    }
  }
}

id HDCloudSyncAttachmentManagementUUID(void *a1, uint64_t a2)
{
  id v3 = HDCloudSyncKeyValueDomainWithProfile(a1);
  id v4 = [v3 stringForKey:@"CloudSyncAttachmentManagement" error:a2];
  uint64_t v5 = (void *)[objc_alloc(MEMORY[0x1E4F29128]) initWithUUIDString:v4];

  return v5;
}

uint64_t HDSetCloudSyncAttachmentManagementUUID(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = HDCloudSyncKeyValueDomainWithProfile(a2);
  int v7 = [v5 UUIDString];

  uint64_t v8 = [v6 setString:v7 forKey:@"CloudSyncAttachmentManagement" error:a3];
  return v8;
}

uint64_t HDCloudSyncAttachmentReferenceEpoch(void *a1, uint64_t a2)
{
  id v3 = HDCloudSyncKeyValueDomainWithProfile(a1);
  id v4 = [v3 numberForKey:@"CloudSyncAttachmentReferenceEpoch" error:a2];
  uint64_t v5 = [v4 longLongValue];

  return v5;
}

uint64_t HDSetCloudSyncAttachmentReferenceEpoch(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = HDCloudSyncKeyValueDomainWithProfile(a2);
  id v6 = [NSNumber numberWithLongLong:a1];
  uint64_t v7 = [v5 setNumber:v6 forKey:@"CloudSyncAttachmentReferenceEpoch" error:a3];

  return v7;
}

uint64_t HDCloudSyncAttachmentReferenceTombstoneEpoch(void *a1, uint64_t a2)
{
  id v3 = HDCloudSyncKeyValueDomainWithProfile(a1);
  id v4 = [v3 numberForKey:@"CloudSyncAttachmentReferenceTombstoneEpoch" error:a2];
  uint64_t v5 = [v4 longLongValue];

  return v5;
}

uint64_t HDSetCloudSyncAttachmentReferenceTombstoneEpoch(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = HDCloudSyncKeyValueDomainWithProfile(a2);
  id v6 = [NSNumber numberWithLongLong:a1];
  uint64_t v7 = [v5 setNumber:v6 forKey:@"CloudSyncAttachmentReferenceTombstoneEpoch" error:a3];

  return v7;
}

uint64_t HDUpgradedToSyncIdentity(void *a1, uint64_t a2)
{
  id v3 = HDCloudSyncKeyValueDomainWithProfile(a1);
  id v4 = [v3 numberForKey:@"CloudSyncUpgradedToSyncIdentity" error:a2];
  uint64_t v5 = v4;
  if (v4) {
    uint64_t v6 = [v4 BOOLValue];
  }
  else {
    uint64_t v6 = _HDIsUnitTesting != 0;
  }

  return v6;
}

uint64_t HDSetUpgradedToSyncIdentity(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = HDCloudSyncKeyValueDomainWithProfile(a2);
  uint64_t v6 = [NSNumber numberWithBool:a1];
  uint64_t v7 = [v5 setNumber:v6 forKey:@"CloudSyncUpgradedToSyncIdentity" error:a3];

  return v7;
}

uint64_t HDCompletedTransitionToSyncIdentity(void *a1, uint64_t a2)
{
  id v3 = HDCloudSyncKeyValueDomainWithProfile(a1);
  id v4 = [v3 numberForKey:@"CloudSyncCompletedTransitionToSyncIdentity" error:a2];
  uint64_t v5 = v4;
  if (v4) {
    uint64_t v6 = [v4 BOOLValue];
  }
  else {
    uint64_t v6 = 0;
  }

  return v6;
}

uint64_t HDSetCompletedTransitionToSyncIdentity(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = HDCloudSyncKeyValueDomainWithProfile(a2);
  uint64_t v6 = [NSNumber numberWithBool:a1];
  uint64_t v7 = [v5 setNumber:v6 forKey:@"CloudSyncCompletedTransitionToSyncIdentity" error:a3];

  return v7;
}

__CFString *HDCKAcceptanceStatusToString(unint64_t a1)
{
  if (a1 >= 4)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"unknown status(%ld)", a1);
    id v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v1 = off_1E62F2C00[a1];
  }

  return v1;
}

__CFString *HDCKPermissionToString(unint64_t a1)
{
  if (a1 >= 4)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"unknown permission (%ld)", a1);
    id v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v1 = off_1E62F2C20[a1];
  }

  return v1;
}

__CFString *HDCKRoleToString(unint64_t a1)
{
  if (a1 < 5 && ((0x1Bu >> a1) & 1) != 0)
  {
    id v1 = off_1E62F2C40[a1];
  }
  else
  {
    objc_msgSend(NSString, "stringWithFormat:", @"unknown role (%ld)", a1);
    id v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }

  return v1;
}

uint64_t HDOptionsForRequest(void *a1)
{
  id v1 = [a1 changesSyncRequest];
  id v2 = v1;
  if (v1)
  {
    if ([v1 push])
    {
      if ([v2 lite]) {
        uint64_t v3 = 128;
      }
      else {
        uint64_t v3 = 0;
      }
    }
    else
    {
      uint64_t v3 = 0;
    }
    if ([v2 pull] && objc_msgSend(v2, "lite")) {
      v3 |= 0x1000uLL;
    }
    if (![v2 push]) {
      v3 |= 4uLL;
    }
    if (![v2 pull]) {
      v3 |= 2uLL;
    }
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

void sub_1BCBE31B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

void sub_1BCBE37EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBE39E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id _allEventCollectorClasses()
{
  v2[3] = *MEMORY[0x1E4F143B8];
  v2[0] = objc_opt_class();
  v2[1] = objc_opt_class();
  v2[2] = objc_opt_class();
  unint64_t v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v2 count:3];

  return v0;
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

void sub_1BCBE62DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCBE6834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1BCBE72E4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 248), 8);
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

__CFString *HDWorkoutDataDestinationStateToString(unint64_t a1)
{
  if (a1 >= 5)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"unknown(%ld)", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E62F30C8[a1];
  }

  return v1;
}

uint64_t HDCodableMedicalIDAllergyReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        id v18 = *(void **)(a1 + 8);
        *(void *)(a1 + 8) = v17;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t __Block_byref_object_copy__3(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void sub_1BCBEC2DC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
}

void sub_1BCBED87C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id HDCloudSyncRecordClassForRecord(void *a1, void *a2)
{
  id v3 = a1;
  if (+[HDCloudSyncSubscriptionRecord isSubscriptionRecord:](HDCloudSyncSubscriptionRecord, "isSubscriptionRecord:", v3)|| +[HDCloudSyncRegistryRecord isRegistryRecord:](HDCloudSyncRegistryRecord, "isRegistryRecord:", v3)|| +[HDCloudSyncMasterRecord isMasterRecord:](HDCloudSyncMasterRecord, "isMasterRecord:", v3)|| +[HDCloudSyncStoreRecord isStoreRecord:](HDCloudSyncStoreRecord, "isStoreRecord:", v3)|| +[HDCloudSyncSequenceRecord isSequenceRecord:](HDCloudSyncSequenceRecord, "isSequenceRecord:", v3)|| +[HDCloudSyncChangeRecord isChangeRecord:](HDCloudSyncChangeRecord, "isChangeRecord:", v3)|| +[HDCloudSyncMedicalIDRecord isMedicalIDRecord:](HDCloudSyncMedicalIDRecord, "isMedicalIDRecord:", v3)|| +[HDCloudSyncSharedSummaryParticipantRecord isParticipantRecord:](HDCloudSyncSharedSummaryParticipantRecord, "isParticipantRecord:", v3)|| +[HDCloudSyncSharedSummaryAuthorizationRecord isAuthorizationRecord:](HDCloudSyncSharedSummaryAuthorizationRecord, "isAuthorizationRecord:",
         v3)
    || +[HDCloudSyncSharedSummaryTransactionRecord isTransactionRecord:](HDCloudSyncSharedSummaryTransactionRecord, "isTransactionRecord:", v3)|| +[HDCloudSyncSharedSummaryRecord isSummaryRecord:](HDCloudSyncSharedSummaryRecord, "isSummaryRecord:", v3)|| +[HDCloudSyncStateRecord isStateRecord:](HDCloudSyncStateRecord, "isStateRecord:", v3)|| +[HDCloudSyncDeviceContextRecord isDeviceContextRecord:](HDCloudSyncDeviceContextRecord, "isDeviceContextRecord:", v3)|| +[HDCloudSyncDeviceKeyValueRecord isDeviceKeyValueRecord:](HDCloudSyncDeviceKeyValueRecord, "isDeviceKeyValueRecord:", v3)|| +[HDCloudSyncAttachmentManagementRecord isAttachmentManagementRecord:](HDCloudSyncAttachmentManagementRecord, "isAttachmentManagementRecord:",
         v3)
    || +[HDCloudSyncAttachmentRecord isAttachmentRecord:](HDCloudSyncAttachmentRecord, "isAttachmentRecord:", v3)|| +[HDCloudSyncAttachmentReferenceRecord isAttachmentReferenceRecord:](HDCloudSyncAttachmentReferenceRecord, "isAttachmentReferenceRecord:", v3)|| +[HDCloudSyncAttachmentReferenceTombstoneRecord isAttachmentReferenceTombstoneRecord:v3])
  {
    id v4 = objc_opt_class();
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_error:format:", 713, @"Record %@ does not appear to be of any known class", v3);
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    if (v6)
    {
      if (a2) {
        *a2 = v6;
      }
      else {
        _HKLogDroppedError();
      }
    }

    id v4 = 0;
  }

  return v4;
}

void sub_1BCBF0068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
}

uint64_t HDCodableOntologyLocalizedEducationContentReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v15 = v9++ >= 9;
        if (v15)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          id v18 = objc_alloc_init(HDCodableOntologyLocalizedEducationContentSection);
          [(id)a1 addSections:v18];
          if (PBReaderPlaceMark()
            && (HDCodableOntologyLocalizedEducationContentSectionReadFrom((uint64_t)v18, a2) & 1) != 0)
          {
            PBReaderRecallMark();

            continue;
          }

          return 0;
        case 2u:
          char v20 = 0;
          unsigned int v21 = 0;
          uint64_t v22 = 0;
          *(unsigned char *)(a1 + 36) |= 2u;
          while (1)
          {
            uint64_t v23 = *v3;
            uint64_t v24 = *(void *)(a2 + v23);
            unint64_t v25 = v24 + 1;
            if (v24 == -1 || v25 > *(void *)(a2 + *v4)) {
              break;
            }
            char v26 = *(unsigned char *)(*(void *)(a2 + *v7) + v24);
            *(void *)(a2 + v23) = v25;
            v22 |= (unint64_t)(v26 & 0x7F) << v20;
            if ((v26 & 0x80) == 0) {
              goto LABEL_42;
            }
            v20 += 7;
            BOOL v15 = v21++ >= 9;
            if (v15)
            {
              uint64_t v22 = 0;
              goto LABEL_44;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_42:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v22 = 0;
          }
LABEL_44:
          *(void *)(a1 + 16) = v22;
          continue;
        case 3u:
          *(unsigned char *)(a1 + 36) |= 1u;
          uint64_t v27 = *v3;
          unint64_t v28 = *(void *)(a2 + v27);
          if (v28 <= 0xFFFFFFFFFFFFFFF7 && v28 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v7) + v28);
            *(void *)(a2 + v27) = v28 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          *(void *)(a1 + 8) = v29;
          continue;
        case 4u:
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v32 = 0;
          *(unsigned char *)(a1 + 36) |= 4u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v33 = *v3;
        uint64_t v34 = *(void *)(a2 + v33);
        unint64_t v35 = v34 + 1;
        if (v34 == -1 || v35 > *(void *)(a2 + *v4)) {
          break;
        }
        char v36 = *(unsigned char *)(*(void *)(a2 + *v7) + v34);
        *(void *)(a2 + v33) = v35;
        v32 |= (unint64_t)(v36 & 0x7F) << v30;
        if ((v36 & 0x80) == 0) {
          goto LABEL_46;
        }
        v30 += 7;
        BOOL v15 = v31++ >= 9;
        if (v15)
        {
          uint64_t v32 = 0;
          goto LABEL_48;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_46:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v32 = 0;
      }
LABEL_48:
      *(unsigned char *)(a1 + 32) = v32 != 0;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDStatisticsCumulative::addSample(uint64_t this, const HDRawQuantitySample *a2, int a3)
{
  *(double *)this = a2->var0 + *(double *)this;
  if (a3) {
    ++*(void *)(this + 8);
  }
  return this;
}

__n128 HDStatisticsCumulative::updateMostRecentSample(__n128 *this, const HDRawQuantitySample *a2)
{
  if (!this[3].n128_u8[0] || (result.n128_u64[0] = this[1].n128_u64[1], result.n128_f64[0] <= a2->var1))
  {
    __n128 result = *(__n128 *)&a2->var0;
    __n128 v3 = *(__n128 *)&a2->var2;
    this[3].n128_u16[0] = *(_WORD *)&a2->var4;
    this[1] = result;
    this[2] = v3;
  }
  return result;
}

double HDStatisticsCumulative::unarchive@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_WORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  double result = *(double *)(a1 + 152);
  *(double *)a2 = result;
  *(void *)(a2 + 8) = *(void *)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 112);
  if (v3)
  {
    double result = *(double *)(v3 + 8);
    uint64_t v4 = *(void *)(v3 + 16);
    *(int8x16_t *)(a2 + 16) = vextq_s8(*(int8x16_t *)(v3 + 24), *(int8x16_t *)(v3 + 24), 8uLL);
    *(double *)(a2 + 32) = result;
    *(void *)(a2 + 40) = v4;
    *(unsigned char *)(a2 + 48) = 1;
  }
  return result;
}

void HDStatisticsCumulative::archive(int8x16_t *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 112) = 0;
  uint64_t v4 = (uint64_t *)(a2 + 112);
  *(void *)(a2 + 160) = 0;
  *(void *)a2 = &unk_1F171B978;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 152) = this->i64[0];
  uint64_t v5 = this->i64[1];
  *(_DWORD *)(a2 + 204) = 1025;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = v5;
  statistics::Statistics::makeMostRecentDatum(a2);
  v6[0] = &unk_1F17206F8;
  int v10 = 127;
  int8x16_t v7 = vextq_s8(this[1], this[1], 8uLL);
  v6[1] = this[2].i64[0];
  id v6[2] = this[2].i64[1];
  __int16 v8 = 0;
  char v9 = 0;
  statistics::RawQuantitySample::operator=(*v4, (uint64_t)v6);
  PB::Base::~Base((PB::Base *)v6);
}

void sub_1BCBF19CC(_Unwind_Exception *a1)
{
  statistics::Statistics::~Statistics(v1);
  _Unwind_Resume(a1);
}

__CFString *NSStringForRapportSchemaIdentifier(uint64_t a1)
{
  if (a1 != 1) {
    return @"HKMirroredWorkoutSession";
  }
  objc_msgSend(MEMORY[0x1E4F1CA00], "raise:format:", *MEMORY[0x1E4F1C3C8], @"Cannot use HDRapportSchemaIdentifierCount", v1, v2);
  return 0;
}

void __watchOSSortedBuildStrings_block_invoke()
{
  unint64_t v0 = (void *)qword_1EBA18AA0;
  qword_1EBA18AA0 = (uint64_t)&unk_1F17E9000;
}

void sub_1BCBF3A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

void sub_1BCBF3F94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_1BCBF73F8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__7(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
}

void sub_1BCBF7A5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDPredicateForDatabaseIDAndRecordZone(uint64_t a1, void *a2, void *a3)
{
  v21[3] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (void *)MEMORY[0x1E4F65D00];
  id v6 = NSNumber;
  id v7 = a3;
  id v8 = a2;
  char v9 = [v6 numberWithLongLong:a1];
  int v10 = [v5 predicateWithProperty:@"database_id" equalToValue:v9];

  uint64_t v11 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v12 = _HDSQLiteValueForString();

  unint64_t v13 = [v11 predicateWithProperty:@"zone_name" equalToValue:v12];

  char v14 = (void *)MEMORY[0x1E4F65D00];
  BOOL v15 = _HDSQLiteValueForString();

  int v16 = [v14 predicateWithProperty:@"owner_name" equalToValue:v15];

  uint64_t v17 = (void *)MEMORY[0x1E4F65D08];
  v21[0] = v10;
  v21[1] = v13;
  void v21[2] = v16;
  id v18 = [MEMORY[0x1E4F1C978] arrayWithObjects:v21 count:3];
  uint64_t v19 = [v17 predicateMatchingAllPredicates:v18];

  return v19;
}

void sub_1BCBFA600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
}

id HDPredicateForDatabaseID(uint64_t a1)
{
  uint64_t v1 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v2 = [NSNumber numberWithLongLong:a1];
  uint64_t v3 = [v1 predicateWithProperty:@"database_id" equalToValue:v2];

  return v3;
}

void sub_1BCBFB1DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1BCBFD490(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__9(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
}

uint64_t HDCodableLocationDatumReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = 0x1E9FB9000uLL;
    unint64_t v8 = 0x1E9FB9000uLL;
    char v9 = (int *)MEMORY[0x1E4F940B8];
    unint64_t v10 = 0x1E9FB9000uLL;
    unint64_t v11 = 0x1E9FB9000uLL;
    unint64_t v12 = 0x1E9FB9000uLL;
    unint64_t v13 = 0x1E9FB9000uLL;
    unint64_t v14 = 0x1E9FB9000uLL;
    unint64_t v15 = 0x1E9FB9000uLL;
    unint64_t v16 = 0x1E9FB9000uLL;
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v17 = 0;
      unsigned int v18 = 0;
      unint64_t v19 = 0;
      while (1)
      {
        uint64_t v20 = *v3;
        uint64_t v21 = *(void *)(a2 + v20);
        unint64_t v22 = v21 + 1;
        if (v21 == -1 || v22 > *(void *)(a2 + *v4)) {
          break;
        }
        char v23 = *(unsigned char *)(*(void *)(a2 + *v9) + v21);
        *(void *)(a2 + v20) = v22;
        v19 |= (unint64_t)(v23 & 0x7F) << v17;
        if ((v23 & 0x80) == 0) {
          goto LABEL_12;
        }
        v17 += 7;
        BOOL v24 = v18++ >= 9;
        if (v24)
        {
          unint64_t v19 = 0;
          int v25 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v25 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v19 = 0;
      }
LABEL_14:
      if (v25 || (v19 & 7) == 4) {
        break;
      }
      switch((v19 >> 3))
      {
        case 1u:
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 0x100u;
          uint64_t v27 = *v3;
          unint64_t v28 = *(void *)(a2 + v27);
          if (v28 <= 0xFFFFFFFFFFFFFFF7 && v28 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v9) + v28);
            *(void *)(a2 + v27) = v28 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v61 = *(int *)(v8 + 1988);
          goto LABEL_82;
        case 2u:
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 0x10u;
          uint64_t v36 = *v3;
          unint64_t v37 = *(void *)(a2 + v36);
          if (v37 <= 0xFFFFFFFFFFFFFFF7 && v37 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v9) + v37);
            *(void *)(a2 + v36) = v37 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v61 = *(int *)(v10 + 1992);
          goto LABEL_82;
        case 3u:
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 0x20u;
          uint64_t v38 = *v3;
          unint64_t v39 = *(void *)(a2 + v38);
          if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v9) + v39);
            *(void *)(a2 + v38) = v39 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v61 = *(int *)(v11 + 1996);
          goto LABEL_82;
        case 4u:
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 1u;
          uint64_t v40 = *v3;
          unint64_t v41 = *(void *)(a2 + v40);
          if (v41 <= 0xFFFFFFFFFFFFFFF7 && v41 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v9) + v41);
            *(void *)(a2 + v40) = v41 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v61 = *(int *)(v12 + 2000);
          goto LABEL_82;
        case 5u:
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 0x40u;
          uint64_t v42 = *v3;
          unint64_t v43 = *(void *)(a2 + v42);
          if (v43 <= 0xFFFFFFFFFFFFFFF7 && v43 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v9) + v43);
            *(void *)(a2 + v42) = v43 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v61 = *(int *)(v13 + 2004);
          goto LABEL_82;
        case 6u:
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 2u;
          uint64_t v44 = *v3;
          unint64_t v45 = *(void *)(a2 + v44);
          if (v45 <= 0xFFFFFFFFFFFFFFF7 && v45 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v9) + v45);
            *(void *)(a2 + v44) = v45 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v61 = *(int *)(v14 + 2008);
          goto LABEL_82;
        case 7u:
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 8u;
          uint64_t v46 = *v3;
          unint64_t v47 = *(void *)(a2 + v46);
          if (v47 <= 0xFFFFFFFFFFFFFFF7 && v47 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v9) + v47);
            *(void *)(a2 + v46) = v47 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v61 = *(int *)(v15 + 2012);
          goto LABEL_82;
        case 8u:
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 0x200u;
          uint64_t v48 = *v3;
          unint64_t v49 = *(void *)(a2 + v48);
          if (v49 <= 0xFFFFFFFFFFFFFFF7 && v49 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v9) + v49);
            *(void *)(a2 + v48) = v49 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v61 = *(int *)(v16 + 2016);
          goto LABEL_82;
        case 9u:
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 0x80u;
          uint64_t v50 = *v3;
          unint64_t v51 = *(void *)(a2 + v50);
          if (v51 <= 0xFFFFFFFFFFFFFFF7 && v51 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v9) + v51);
            *(void *)(a2 + v50) = v51 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v61 = 64;
          goto LABEL_82;
        case 0xAu:
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 4u;
          uint64_t v52 = *v3;
          unint64_t v53 = *(void *)(a2 + v52);
          if (v53 <= 0xFFFFFFFFFFFFFFF7 && v53 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v29 = *(void *)(*(void *)(a2 + *v9) + v53);
            *(void *)(a2 + v52) = v53 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v29 = 0;
          }
          uint64_t v61 = 24;
LABEL_82:
          *(void *)(a1 + v61) = v29;
          continue;
        case 0xBu:
          char v54 = 0;
          unsigned int v55 = 0;
          uint64_t v56 = 0;
          *(_WORD *)(a1 + *(int *)(v7 + 1984)) |= 0x400u;
          break;
        default:
          unint64_t v30 = v8;
          unint64_t v31 = v10;
          unint64_t v32 = v11;
          unint64_t v33 = v7;
          unint64_t v34 = v12;
          uint64_t result = PBReaderSkipValueWithTag();
          unint64_t v12 = v34;
          uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
          unint64_t v7 = v33;
          unint64_t v13 = 0x1E9FB9000;
          unint64_t v11 = v32;
          unint64_t v14 = 0x1E9FB9000;
          unint64_t v10 = v31;
          unint64_t v15 = 0x1E9FB9000;
          unint64_t v8 = v30;
          unint64_t v16 = 0x1E9FB9000;
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v57 = *v3;
        uint64_t v58 = *(void *)(a2 + v57);
        unint64_t v59 = v58 + 1;
        if (v58 == -1 || v59 > *(void *)(a2 + *v4)) {
          break;
        }
        char v60 = *(unsigned char *)(*(void *)(a2 + *v9) + v58);
        *(void *)(a2 + v57) = v59;
        v56 |= (unint64_t)(v60 & 0x7F) << v54;
        if ((v60 & 0x80) == 0) {
          goto LABEL_59;
        }
        v54 += 7;
        BOOL v24 = v55++ >= 9;
        if (v24)
        {
          LODWORD(v56) = 0;
          goto LABEL_61;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_59:
      if (*(unsigned char *)(a2 + *v5)) {
        LODWORD(v56) = 0;
      }
LABEL_61:
      *(_DWORD *)(a1 + 88) = v56;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCloudSyncCodableDeviceKeyValueReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v15 = v9++ >= 9;
        if (v15)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          unsigned int v18 = objc_alloc_init(HDCodableSyncIdentity);
          objc_storeStrong((id *)(a1 + 40), v18);
          if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v18, a2))
          {
            PBReaderRecallMark();

            continue;
          }

          return 0;
        case 2u:
          uint64_t v20 = PBReaderReadString();
          uint64_t v21 = 24;
          goto LABEL_27;
        case 3u:
          uint64_t v20 = PBReaderReadString();
          uint64_t v21 = 32;
          goto LABEL_27;
        case 4u:
          uint64_t v20 = PBReaderReadData();
          uint64_t v21 = 48;
LABEL_27:
          unint64_t v22 = *(void **)(a1 + v21);
          *(void *)(a1 + v21) = v20;

          continue;
        case 5u:
          *(unsigned char *)(a1 + 56) |= 1u;
          uint64_t v23 = *v3;
          unint64_t v24 = *(void *)(a2 + v23);
          if (v24 <= 0xFFFFFFFFFFFFFFF7 && v24 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v25 = *(void *)(*(void *)(a2 + *v7) + v24);
            *(void *)(a2 + v23) = v24 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v25 = 0;
          }
          *(void *)(a1 + 8) = v25;
          continue;
        case 6u:
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          *(unsigned char *)(a1 + 56) |= 2u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v29 = *v3;
        uint64_t v30 = *(void *)(a2 + v29);
        unint64_t v31 = v30 + 1;
        if (v30 == -1 || v31 > *(void *)(a2 + *v4)) {
          break;
        }
        char v32 = *(unsigned char *)(*(void *)(a2 + *v7) + v30);
        *(void *)(a2 + v29) = v31;
        v28 |= (unint64_t)(v32 & 0x7F) << v26;
        if ((v32 & 0x80) == 0) {
          goto LABEL_39;
        }
        v26 += 7;
        BOOL v15 = v27++ >= 9;
        if (v15)
        {
          uint64_t v28 = 0;
          goto LABEL_41;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_39:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v28 = 0;
      }
LABEL_41:
      *(void *)(a1 + 16) = v28;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableRoutineLocationReadFrom(_DWORD *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  unint64_t v7 = 0x1E9FB9000uLL;
  unint64_t v8 = 0x1E9FB9000uLL;
  unsigned int v9 = (int *)MEMORY[0x1E4F940B8];
  unint64_t v10 = 0x1E9FB9000uLL;
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v11 = 0;
    unsigned int v12 = 0;
    unint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = *v3;
      uint64_t v15 = *(void *)(a2 + v14);
      unint64_t v16 = v15 + 1;
      if (v15 == -1 || v16 > *(void *)(a2 + *v4)) {
        break;
      }
      char v17 = *(unsigned char *)(*(void *)(a2 + *v9) + v15);
      *(void *)(a2 + v14) = v16;
      v13 |= (unint64_t)(v17 & 0x7F) << v11;
      if ((v17 & 0x80) == 0) {
        goto LABEL_12;
      }
      v11 += 7;
      BOOL v18 = v12++ >= 9;
      if (v18)
      {
        unint64_t v13 = 0;
        int v19 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v19 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v13 = 0;
    }
LABEL_14:
    if (v19 || (v13 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v13 >> 3))
    {
      case 1u:
        *((unsigned char *)a1 + *(int *)(v7 + 2076)) |= 2u;
        uint64_t v21 = *v3;
        unint64_t v22 = *(void *)(a2 + v21);
        if (v22 <= 0xFFFFFFFFFFFFFFF7 && v22 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v23 = *(void *)(*(void *)(a2 + *v9) + v22);
          *(void *)(a2 + v21) = v22 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v23 = 0;
        }
        uint64_t v45 = *(int *)(v8 + 2080);
        goto LABEL_58;
      case 2u:
        *((unsigned char *)a1 + *(int *)(v7 + 2076)) |= 4u;
        uint64_t v25 = *v3;
        unint64_t v26 = *(void *)(a2 + v25);
        if (v26 <= 0xFFFFFFFFFFFFFFF7 && v26 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v23 = *(void *)(*(void *)(a2 + *v9) + v26);
          *(void *)(a2 + v25) = v26 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v23 = 0;
        }
        uint64_t v45 = *(int *)(v10 + 2084);
        goto LABEL_58;
      case 3u:
        *((unsigned char *)a1 + *(int *)(v7 + 2076)) |= 8u;
        uint64_t v27 = *v3;
        unint64_t v28 = *(void *)(a2 + v27);
        if (v28 <= 0xFFFFFFFFFFFFFFF7 && v28 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v23 = *(void *)(*(void *)(a2 + *v9) + v28);
          *(void *)(a2 + v27) = v28 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v23 = 0;
        }
        uint64_t v45 = 32;
        goto LABEL_58;
      case 4u:
        *((unsigned char *)a1 + *(int *)(v7 + 2076)) |= 1u;
        uint64_t v29 = *v3;
        unint64_t v30 = *(void *)(a2 + v29);
        if (v30 <= 0xFFFFFFFFFFFFFFF7 && v30 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v23 = *(void *)(*(void *)(a2 + *v9) + v30);
          *(void *)(a2 + v29) = v30 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v23 = 0;
        }
        uint64_t v45 = 8;
LABEL_58:
        *(void *)((char *)a1 + v45) = v23;
        goto LABEL_59;
      case 5u:
        uint64_t v31 = PBReaderReadString();
        uint64_t v32 = 14;
        goto LABEL_42;
      case 6u:
        char v33 = 0;
        unsigned int v34 = 0;
        uint64_t v35 = 0;
        *((unsigned char *)a1 + *(int *)(v7 + 2076)) |= 0x10u;
        while (2)
        {
          uint64_t v36 = *v3;
          uint64_t v37 = *(void *)(a2 + v36);
          unint64_t v38 = v37 + 1;
          if (v37 == -1 || v38 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v39 = *(unsigned char *)(*(void *)(a2 + *v9) + v37);
            *(void *)(a2 + v36) = v38;
            v35 |= (unint64_t)(v39 & 0x7F) << v33;
            if (v39 < 0)
            {
              v33 += 7;
              BOOL v18 = v34++ >= 9;
              if (v18)
              {
                LODWORD(v35) = 0;
                goto LABEL_49;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v35) = 0;
        }
LABEL_49:
        a1[12] = v35;
        goto LABEL_59;
      case 7u:
        uint64_t v31 = PBReaderReadData();
        uint64_t v32 = 10;
LABEL_42:
        uint64_t v40 = *(void **)&a1[v32];
        *(void *)&a1[v32] = v31;

        goto LABEL_59;
      case 8u:
        unint64_t v41 = v7;
        unint64_t v42 = v10;
        unint64_t v43 = v8;
        uint64_t v44 = objc_alloc_init(HDCodableRoutineLocationVisit);
        [a1 addVisits:v44];
        if (PBReaderPlaceMark() && HDCodableRoutineLocationVisitReadFrom((uint64_t)v44, a2))
        {
          PBReaderRecallMark();

          unint64_t v8 = v43;
          unint64_t v10 = v42;
          unint64_t v7 = v41;
LABEL_59:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }

        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_59;
    }
  }
}

void sub_1BCC048E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 168), 8);
  _Block_object_dispose((const void *)(v11 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableStateOfMindReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = 0x1E9FB9000uLL;
    unint64_t v8 = (int *)MEMORY[0x1E4F940B8];
    unint64_t v9 = 0x1E9FB9000uLL;
    unint64_t v10 = 0x1E9FB9000uLL;
    while (2)
    {
      if (!*(unsigned char *)(a2 + *v5))
      {
        char v11 = 0;
        unsigned int v12 = 0;
        unint64_t v13 = 0;
        while (1)
        {
          uint64_t v14 = *v3;
          uint64_t v15 = *(void *)(a2 + v14);
          unint64_t v16 = v15 + 1;
          if (v15 == -1 || v16 > *(void *)(a2 + *v4)) {
            break;
          }
          char v17 = *(unsigned char *)(*(void *)(a2 + *v8) + v15);
          *(void *)(a2 + v14) = v16;
          v13 |= (unint64_t)(v17 & 0x7F) << v11;
          if ((v17 & 0x80) == 0) {
            goto LABEL_12;
          }
          v11 += 7;
          BOOL v18 = v12++ >= 9;
          if (v18)
          {
            unint64_t v13 = 0;
            int v19 = *(unsigned __int8 *)(a2 + *v5);
            goto LABEL_14;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
        int v19 = *(unsigned __int8 *)(a2 + *v5);
        if (*(unsigned char *)(a2 + *v5)) {
          unint64_t v13 = 0;
        }
LABEL_14:
        int v20 = v13 & 7;
        if (!v19 && v20 != 4)
        {
          switch((v13 >> 3))
          {
            case 1u:
              unint64_t v22 = v10;
              unint64_t v23 = v9;
              unint64_t v24 = v7;
              uint64_t v25 = objc_alloc_init(HDCodableSample);
              objc_storeStrong((id *)(a1 + 80), v25);
              if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v25, a2))
              {
                PBReaderRecallMark();

                unint64_t v7 = v24;
                unint64_t v9 = v23;
                unint64_t v10 = v22;
                goto LABEL_84;
              }

              return 0;
            case 2u:
              char v26 = 0;
              unsigned int v27 = 0;
              uint64_t v28 = 0;
              *(unsigned char *)(a1 + *(int *)(v7 + 2132)) |= 1u;
              while (2)
              {
                uint64_t v29 = *v3;
                uint64_t v30 = *(void *)(a2 + v29);
                unint64_t v31 = v30 + 1;
                if (v30 == -1 || v31 > *(void *)(a2 + *v4))
                {
                  *(unsigned char *)(a2 + *v5) = 1;
                }
                else
                {
                  char v32 = *(unsigned char *)(*(void *)(a2 + *v8) + v30);
                  *(void *)(a2 + v29) = v31;
                  v28 |= (unint64_t)(v32 & 0x7F) << v26;
                  if (v32 < 0)
                  {
                    v26 += 7;
                    BOOL v18 = v27++ >= 9;
                    if (v18)
                    {
                      uint64_t v28 = 0;
                      goto LABEL_65;
                    }
                    continue;
                  }
                }
                break;
              }
              if (*(unsigned char *)(a2 + *v5)) {
                uint64_t v28 = 0;
              }
LABEL_65:
              *(void *)(a1 + 56) = v28;
              goto LABEL_84;
            case 3u:
              *(unsigned char *)(a1 + *(int *)(v7 + 2132)) |= 2u;
              uint64_t v33 = *v3;
              unint64_t v34 = *(void *)(a2 + v33);
              if (v34 <= 0xFFFFFFFFFFFFFFF7 && v34 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v35 = *(void *)(*(void *)(a2 + *v8) + v34);
                *(void *)(a2 + v33) = v34 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v35 = 0;
              }
              *(void *)(a1 + 64) = v35;
              goto LABEL_84;
            case 4u:
              if (v20 != 2)
              {
                char v53 = 0;
                unsigned int v54 = 0;
                uint64_t v55 = 0;
                while (1)
                {
                  uint64_t v56 = *v3;
                  uint64_t v57 = *(void *)(a2 + v56);
                  unint64_t v58 = v57 + 1;
                  if (v57 == -1 || v58 > *(void *)(a2 + *v4)) {
                    goto LABEL_80;
                  }
                  char v59 = *(unsigned char *)(*(void *)(a2 + *v8) + v57);
                  *(void *)(a2 + v56) = v58;
                  v55 |= (unint64_t)(v59 & 0x7F) << v53;
                  if (v59 < 0)
                  {
                    v53 += 7;
                    BOOL v18 = v54++ >= 9;
                    if (!v18) {
                      continue;
                    }
                  }
                  goto LABEL_81;
                }
              }
              uint64_t result = PBReaderPlaceMark();
              if (!result) {
                return result;
              }
              while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4) && !*(unsigned char *)(a2 + *v5))
              {
                char v37 = 0;
                unsigned int v38 = 0;
                uint64_t v39 = 0;
                while (1)
                {
                  uint64_t v40 = *v3;
                  uint64_t v41 = *(void *)(a2 + v40);
                  unint64_t v42 = v41 + 1;
                  if (v41 == -1 || v42 > *(void *)(a2 + *v4)) {
                    break;
                  }
                  char v43 = *(unsigned char *)(*(void *)(a2 + *v8) + v41);
                  *(void *)(a2 + v40) = v42;
                  v39 |= (unint64_t)(v43 & 0x7F) << v37;
                  if (v43 < 0)
                  {
                    v37 += 7;
                    BOOL v18 = v38++ >= 9;
                    if (!v18) {
                      continue;
                    }
                  }
                  goto LABEL_44;
                }
                *(unsigned char *)(a2 + *v5) = 1;
LABEL_44:
                PBRepeatedInt64Add();
              }
              goto LABEL_61;
            case 5u:
              if (v20 == 2)
              {
                uint64_t result = PBReaderPlaceMark();
                if (!result) {
                  return result;
                }
                while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4) && !*(unsigned char *)(a2 + *v5))
                {
                  char v44 = 0;
                  unsigned int v45 = 0;
                  uint64_t v46 = 0;
                  while (1)
                  {
                    uint64_t v47 = *v3;
                    uint64_t v48 = *(void *)(a2 + v47);
                    unint64_t v49 = v48 + 1;
                    if (v48 == -1 || v49 > *(void *)(a2 + *v4)) {
                      break;
                    }
                    char v50 = *(unsigned char *)(*(void *)(a2 + *v8) + v48);
                    *(void *)(a2 + v47) = v49;
                    v46 |= (unint64_t)(v50 & 0x7F) << v44;
                    if (v50 < 0)
                    {
                      v44 += 7;
                      BOOL v18 = v45++ >= 9;
                      if (!v18) {
                        continue;
                      }
                    }
                    goto LABEL_57;
                  }
                  *(unsigned char *)(a2 + *v5) = 1;
LABEL_57:
                  PBRepeatedInt64Add();
                }
LABEL_61:
                PBReaderRecallMark();
              }
              else
              {
                char v60 = 0;
                unsigned int v61 = 0;
                uint64_t v62 = 0;
                while (1)
                {
                  uint64_t v63 = *v3;
                  uint64_t v64 = *(void *)(a2 + v63);
                  unint64_t v65 = v64 + 1;
                  if (v64 == -1 || v65 > *(void *)(a2 + *v4)) {
                    break;
                  }
                  char v66 = *(unsigned char *)(*(void *)(a2 + *v8) + v64);
                  *(void *)(a2 + v63) = v65;
                  v62 |= (unint64_t)(v66 & 0x7F) << v60;
                  if (v66 < 0)
                  {
                    v60 += 7;
                    BOOL v18 = v61++ >= 9;
                    if (!v18) {
                      continue;
                    }
                  }
                  goto LABEL_81;
                }
LABEL_80:
                *(unsigned char *)(a2 + *v5) = 1;
LABEL_81:
                PBRepeatedInt64Add();
              }
LABEL_84:
              if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
                return *(unsigned char *)(a2 + *v5) == 0;
              }
              continue;
            case 7u:
              uint64_t v51 = PBReaderReadString();
              uint64_t v52 = *(void **)(a1 + 72);
              *(void *)(a1 + 72) = v51;

              goto LABEL_84;
            default:
              if (PBReaderSkipValueWithTag()) {
                goto LABEL_84;
              }
              return 0;
          }
        }
      }
      break;
    }
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCC08DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a71, 8);
  _Block_object_dispose(&STACK[0x220], 8);
  _Block_object_dispose(&STACK[0x240], 8);
  _Block_object_dispose(&STACK[0x270], 8);
  _Block_object_dispose((const void *)(v71 - 192), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__10(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
}

uint64_t HDCodableUserDomainConceptTypeIdentifierReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        char v19 = 0;
        unsigned int v20 = 0;
        uint64_t v21 = 0;
        *(unsigned char *)(a1 + 24) |= 1u;
        while (1)
        {
          uint64_t v22 = *v3;
          unint64_t v23 = *(void *)(a2 + v22);
          if (v23 == -1 || v23 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v24 = *(unsigned char *)(*(void *)(a2 + *v7) + v23);
          *(void *)(a2 + v22) = v23 + 1;
          v21 |= (unint64_t)(v24 & 0x7F) << v19;
          if ((v24 & 0x80) == 0) {
            goto LABEL_31;
          }
          v19 += 7;
          BOOL v14 = v20++ >= 9;
          if (v14)
          {
            uint64_t v21 = 0;
            goto LABEL_33;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_31:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_33:
        *(void *)(a1 + 8) = v21;
      }
      else if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        BOOL v18 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v17;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableDeletedSampleReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 8), v17);
        if (!PBReaderPlaceMark() || (HDCodableSampleReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDBinnedAnalyticsValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a1) {
    return 0;
  }
  if (a1 <= a3) {
    return a3;
  }
  if (a1 <= a2) {
    return (uint64_t)((double)a3 * (double)(a1 / a3));
  }
  a3 = a4;
  if (a1 < a5) {
    return (uint64_t)((double)a3 * (double)(a1 / a3));
  }
  return a5;
}

uint64_t HDBucketedDatabaseSizeInMB(uint64_t a1)
{
  if (a1 > 99)
  {
    if (a1 == 100)
    {
      return 100;
    }
    else
    {
      if ((unint64_t)a1 < 0x3E9)
      {
        uint64_t v2 = 100;
      }
      else
      {
        if ((unint64_t)a1 >> 3 > 0x270) {
          return 5000;
        }
        uint64_t v2 = 1000;
      }
      return (uint64_t)((double)v2 * (double)((unsigned __int16)a1 / v2));
    }
  }
  else if (a1)
  {
    uint64_t v1 = 10;
    if (a1 >= 11) {
      return 10 * (a1 / 0xAu);
    }
  }
  else
  {
    return 0;
  }
  return v1;
}

uint64_t HDDatabaseSizeInMB(void *a1)
{
  uint64_t v1 = [a1 database];
  uint64_t v2 = [v1 databaseSizeInBytes];

  if (v2) {
    uint64_t v3 = [v2 longLongValue] / 0x100000;
  }
  else {
    uint64_t v3 = 0;
  }

  return v3;
}

uint64_t HDDatabaseBucketedSizeInMBForDatabaseType(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = [a1 database];
  id v6 = [v5 databaseSizeInBytesForTypeUnprotected:a2 WAL:a3];

  uint64_t v7 = HDBucketedDatabaseSizeInMB([v6 integerValue] / 0x100000);
  return v7;
}

id HDAnalyticsBucketedNumberOfStandAndIdleHours(void *a1, void *a2, void *a3)
{
  uint64_t v5 = (void *)MEMORY[0x1E4F2ACB8];
  uint64_t v6 = *MEMORY[0x1E4F29770];
  id v7 = a2;
  id v8 = a1;
  unsigned int v9 = [v5 categoryTypeForIdentifier:v6];
  unint64_t v10 = HDSampleEntityPredicateForDateInterval(v7, v9);

  id v16 = 0;
  uint64_t v11 = +[HDSampleEntity countOfSamplesWithType:v9 profile:v8 matchingPredicate:v10 withError:&v16];

  id v12 = v16;
  if (v11) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = v12 == 0;
  }
  if (v13)
  {
    if (v11)
    {
      if ((unint64_t)v11 >= 4)
      {
        if ((unint64_t)(v11 - 4) >= 3)
        {
          if ((unint64_t)(v11 - 7) >= 3)
          {
            if ((unint64_t)(v11 - 10) >= 3)
            {
              if ((unint64_t)(v11 - 13) >= 4)
              {
                if ((unint64_t)(v11 - 17) >= 4)
                {
                  if (v11 <= 20) {
                    id v14 = (id)*MEMORY[0x1E4F29668];
                  }
                  else {
                    id v14 = &unk_1F17EAF68;
                  }
                }
                else
                {
                  id v14 = &unk_1F17EAF50;
                }
              }
              else
              {
                id v14 = &unk_1F17EAF38;
              }
            }
            else
            {
              id v14 = &unk_1F17EAF20;
            }
          }
          else
          {
            id v14 = &unk_1F17EAF08;
          }
        }
        else
        {
          id v14 = &unk_1F17EAEF0;
        }
      }
      else
      {
        id v14 = &unk_1F17EAED8;
      }
    }
    else
    {
      id v14 = &unk_1F17EAEC0;
    }
  }
  else if (a3)
  {
    id v14 = 0;
    *a3 = v12;
  }
  else
  {
    _HKLogDroppedError();
    id v14 = 0;
  }

  return v14;
}

id HDAnalyticsCountOfSamples(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  void v24[2] = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  id v10 = a2;
  id v11 = a4;
  uint64_t v12 = HDSampleEntityPredicateForDateInterval(a3, v10);
  BOOL v13 = (void *)v12;
  if (v11)
  {
    id v14 = (void *)MEMORY[0x1E4F65D08];
    v24[0] = v12;
    v24[1] = v11;
    int v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v24 count:2];
    uint64_t v16 = [v14 predicateMatchingAllPredicates:v15];

    BOOL v13 = (void *)v16;
  }
  id v23 = 0;
  int64_t v17 = +[HDSampleEntity countOfSamplesWithType:v10 profile:v9 matchingPredicate:v13 withError:&v23];
  id v18 = v23;
  char v19 = v18;
  if (v17) {
    BOOL v20 = 1;
  }
  else {
    BOOL v20 = v18 == 0;
  }
  if (v20)
  {
    uint64_t v21 = [NSNumber numberWithInteger:v17];
  }
  else if (a5)
  {
    uint64_t v21 = 0;
    *a5 = v18;
  }
  else
  {
    _HKLogDroppedError();
    uint64_t v21 = 0;
  }

  return v21;
}

id HDAnalyticsCountOfIntervalsForQuantityType(void *a1, void *a2, void *a3, unint64_t a4, void *a5, void *a6, void *a7)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v25 = 0;
  id v9 = HDAnalyticsStatisticsCollectionOfIntervalsForQuantityType(a1, a2, a3, a5, a6, &v25);
  id v10 = v25;
  id v11 = v10;
  if (v9)
  {
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    uint64_t v12 = objc_msgSend(v9, "statistics", 0);
    uint64_t v13 = [v12 countByEnumeratingWithState:&v21 objects:v26 count:16];
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = 0;
      uint64_t v16 = *(void *)v22;
      do
      {
        for (uint64_t i = 0; i != v14; ++i)
        {
          if (*(void *)v22 != v16) {
            objc_enumerationMutation(v12);
          }
          if ([*(id *)(*((void *)&v21 + 1) + 8 * i) dataCount] >= a4) {
            ++v15;
          }
        }
        uint64_t v14 = [v12 countByEnumeratingWithState:&v21 objects:v26 count:16];
      }
      while (v14);
    }
    else
    {
      uint64_t v15 = 0;
    }

    char v19 = [NSNumber numberWithInteger:v15];
  }
  else
  {
    id v18 = v10;
    if (v18)
    {
      if (a7) {
        *a7 = v18;
      }
      else {
        _HKLogDroppedError();
      }
    }

    char v19 = 0;
  }

  return v19;
}

id HDAnalyticsStatisticsCollectionOfIntervalsForQuantityType(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  v41[2] = *MEMORY[0x1E4F143B8];
  id v10 = a2;
  id v11 = a3;
  id v12 = a4;
  id v13 = a5;
  uint64_t v14 = (objc_class *)MEMORY[0x1E4F2B8A8];
  id v15 = a1;
  id v16 = [v14 alloc];
  int64_t v17 = [v12 startDate];
  uint64_t v18 = [v16 initWithAnchorDate:v17 intervalComponents:v10];

  char v37 = (void *)v18;
  char v19 = +[HDStatisticsCollectionCalculator calculatorForQuantityType:v11 intervalCollection:v18 options:_HKStatisticsOptionPresence() mergeStrategy:1];
  uint64_t v20 = HDSampleEntityPredicateForDateInterval(v12, v11);
  long long v21 = (void *)v20;
  if (v13)
  {
    long long v22 = (void *)MEMORY[0x1E4F65D08];
    v41[0] = v20;
    v41[1] = v13;
    long long v23 = [MEMORY[0x1E4F1C978] arrayWithObjects:v41 count:2];
    uint64_t v24 = [v22 predicateMatchingAllPredicates:v23];

    long long v21 = (void *)v24;
  }
  id v25 = [[HDStatisticsCollectionCalculatorDefaultDataSource alloc] initForProfile:v15 quantityType:v11 predicate:v21 restrictedSourceEntities:0];

  [v19 setDataSource:v25];
  id v26 = objc_alloc(MEMORY[0x1E4F2B5B8]);
  uint64_t v27 = [v12 startDate];
  uint64_t v28 = [v26 initWithAnchorDate:v27 statisticsInterval:v10];

  v39[0] = MEMORY[0x1E4F143A8];
  v39[1] = 3221225472;
  v39[2] = __HDAnalyticsStatisticsCollectionOfIntervalsForQuantityType_block_invoke;
  v39[3] = &unk_1E62F4648;
  id v29 = (id)v28;
  id v40 = v29;
  [v19 setStatisticsHandler:v39];
  id v38 = 0;
  LOBYTE(v28) = [v19 queryForInitialStatisticsWithError:&v38];
  id v30 = v38;
  unint64_t v31 = v30;
  if (v28)
  {
    id v32 = v29;
  }
  else
  {
    id v33 = v30;
    unint64_t v34 = v33;
    if (v33)
    {
      if (a6) {
        *a6 = v33;
      }
      else {
        _HKLogDroppedError();
      }
    }

    id v32 = 0;
  }

  return v32;
}

uint64_t __HDAnalyticsStatisticsCollectionOfIntervalsForQuantityType_block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_insertStatistics:");
}

id HDAnalyticsCountOfSleepDaysWithStandHoursPriorToDate(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = (void *)MEMORY[0x1E4F2ACB8];
  uint64_t v10 = *MEMORY[0x1E4F29770];
  id v11 = a3;
  id v12 = a2;
  id v13 = a1;
  uint64_t v14 = [v9 categoryTypeForIdentifier:v10];
  id v15 = objc_msgSend(v12, "hk_sleepDayStartWithCalendar:", v11);

  id v16 = [v11 dateByAddingUnit:16 value:-a4 toDate:v15 options:0];
  id v17 = objc_alloc_init(MEMORY[0x1E4F1C9D8]);
  [v17 setCalendar:v11];

  [v17 setDay:1];
  uint64_t v18 = (void *)[objc_alloc(MEMORY[0x1E4F28C18]) initWithStartDate:v16 endDate:v15];
  char v19 = HDAnalyticsCountOfIntervalsForCategoryType(v13, v17, v14, v18, a5);

  return v19;
}

id HDAnalyticsCountOfIntervalsForCategoryType(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  v58[6] = *MEMORY[0x1E4F143B8];
  id v43 = a1;
  id v48 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = objc_alloc(MEMORY[0x1E4F2B8A8]);
  id v11 = [v9 startDate];
  uint64_t v12 = [v10 initWithAnchorDate:v11 intervalComponents:v48];

  unint64_t v49 = v8;
  uint64_t v46 = (void *)v12;
  unint64_t v42 = +[HDStatisticsCollectionCalculator calculatorForCategoryType:v8 intervalCollection:v12 options:_HKStatisticsOptionPresence() mergeStrategy:1];
  id v13 = (void *)MEMORY[0x1E4F65D08];
  uint64_t v47 = HDSampleEntityPredicateForDataType(v8);
  v58[0] = v47;
  char v44 = HDDataEntityPredicateForObjectsFromAppleWatchSources(1);
  v58[1] = v44;
  uint64_t v41 = [v9 startDate];
  uint64_t v14 = HDSampleEntityPredicateForStartDate(6);
  v58[2] = v14;
  id v15 = [v9 endDate];
  id v16 = HDSampleEntityPredicateForStartDate(3);
  v58[3] = v16;
  id v17 = [v9 endDate];
  uint64_t v18 = HDSampleEntityPredicateForEndDate(4);
  v58[4] = v18;
  char v19 = [v9 startDate];
  uint64_t v20 = HDSampleEntityPredicateForEndDate(6);
  v58[5] = v20;
  long long v21 = [MEMORY[0x1E4F1C978] arrayWithObjects:v58 count:6];
  uint64_t v22 = [v13 predicateMatchingAllPredicates:v21];

  unsigned int v45 = (void *)v22;
  id v23 = [[HDStatisticsCollectionCalculatorDefaultDataSource alloc] initForProfile:v43 categoryType:v49 predicate:v22 restrictedSourceEntities:0];
  [v42 setDataSource:v23];
  id v24 = objc_alloc(MEMORY[0x1E4F2B5B8]);
  id v25 = [v9 startDate];
  uint64_t v26 = [v24 initWithAnchorDate:v25 statisticsInterval:v48];

  v55[0] = MEMORY[0x1E4F143A8];
  v55[1] = 3221225472;
  v55[2] = __HDAnalyticsCountOfIntervalsForCategoryType_block_invoke;
  v55[3] = &unk_1E62F4648;
  id v27 = (id)v26;
  id v56 = v27;
  [v42 setStatisticsHandler:v55];
  id v54 = 0;
  LOBYTE(v26) = [v42 queryForInitialStatisticsWithError:&v54];
  id v28 = v54;
  id v29 = v28;
  if (v26)
  {
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    id v30 = [v27 statistics];
    uint64_t v31 = [v30 countByEnumeratingWithState:&v50 objects:v57 count:16];
    if (v31)
    {
      uint64_t v32 = v31;
      uint64_t v33 = 0;
      uint64_t v34 = *(void *)v51;
      do
      {
        for (uint64_t i = 0; i != v32; ++i)
        {
          if (*(void *)v51 != v34) {
            objc_enumerationMutation(v30);
          }
          if ([*(id *)(*((void *)&v50 + 1) + 8 * i) dataCount]) {
            ++v33;
          }
        }
        uint64_t v32 = [v30 countByEnumeratingWithState:&v50 objects:v57 count:16];
      }
      while (v32);
    }
    else
    {
      uint64_t v33 = 0;
    }

    id v38 = [NSNumber numberWithInteger:v33];
  }
  else
  {
    id v36 = v28;
    char v37 = v36;
    if (v36)
    {
      if (a5) {
        *a5 = v36;
      }
      else {
        _HKLogDroppedError();
      }
    }

    id v38 = 0;
  }

  return v38;
}

uint64_t __HDAnalyticsCountOfIntervalsForCategoryType_block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_insertStatistics:");
}

void sub_1BCC0F560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a71, 8);
  _Unwind_Resume(a1);
}

BOOL HDCloudSyncCodableSharedSummaryTransactionRecordReadFrom(char *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    id v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 32;
          goto LABEL_26;
        case 2u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 16;
          goto LABEL_26;
        case 3u:
          char v19 = PBReaderReadString();
          if (v19) {
            [a1 addSummaryIdentifiers:v19];
          }
          goto LABEL_27;
        case 4u:
          uint64_t v17 = PBReaderReadData();
          uint64_t v18 = 8;
LABEL_26:
          char v19 = *(void **)&a1[v18];
          *(void *)&a1[v18] = v17;
LABEL_27:

          goto LABEL_28;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0;
          }
LABEL_28:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          break;
      }
    }
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCC16710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
  _Block_object_dispose((const void *)(v52 - 192), 8);
  _Block_object_dispose(&a52, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__11(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
}

uint64_t HDCloudSyncCodableLogReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    id v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        uint64_t v21 = PBReaderReadString();
        uint64_t v22 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v21;
      }
      else if ((v10 >> 3) == 1)
      {
        *(unsigned char *)(a1 + 24) |= 1u;
        uint64_t v18 = *v3;
        unint64_t v19 = *(void *)(a2 + v18);
        if (v19 <= 0xFFFFFFFFFFFFFFF7 && v19 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v20 = *(void *)(*(void *)(a2 + *v7) + v19);
          *(void *)(a2 + v18) = v19 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v20 = 0;
        }
        *(void *)(a1 + 8) = v20;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableRoutinePredictedLocationReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    id v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v15 = v9++ >= 9;
        if (v15)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v18 = objc_alloc_init(HDCodableRoutineLocation);
          objc_storeStrong((id *)(a1 + 32), v18);
          if PBReaderPlaceMark() && (HDCodableRoutineLocationReadFrom(v18, a2))
          {
            PBReaderRecallMark();

            continue;
          }

          return 0;
        case 2u:
          *(unsigned char *)(a1 + 48) |= 1u;
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 <= 0xFFFFFFFFFFFFFFF7 && v21 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v21);
            *(void *)(a2 + v20) = v21 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v22 = 0;
          }
          uint64_t v41 = 8;
          goto LABEL_58;
        case 3u:
          *(unsigned char *)(a1 + 48) |= 2u;
          uint64_t v23 = *v3;
          unint64_t v24 = *(void *)(a2 + v23);
          if (v24 <= 0xFFFFFFFFFFFFFFF7 && v24 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v24);
            *(void *)(a2 + v23) = v24 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v22 = 0;
          }
          uint64_t v41 = 16;
LABEL_58:
          *(void *)(a1 + v41) = v22;
          continue;
        case 4u:
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          *(unsigned char *)(a1 + 48) |= 4u;
          while (2)
          {
            uint64_t v28 = *v3;
            uint64_t v29 = *(void *)(a2 + v28);
            unint64_t v30 = v29 + 1;
            if (v29 == -1 || v30 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v31 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
              *(void *)(a2 + v28) = v30;
              v27 |= (unint64_t)(v31 & 0x7F) << v25;
              if (v31 < 0)
              {
                v25 += 7;
                BOOL v15 = v26++ >= 9;
                if (v15)
                {
                  LODWORD(v27) = 0;
                  goto LABEL_48;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v27) = 0;
          }
LABEL_48:
          uint64_t v40 = 40;
          goto LABEL_53;
        case 5u:
          char v32 = 0;
          unsigned int v33 = 0;
          uint64_t v27 = 0;
          *(unsigned char *)(a1 + 48) |= 8u;
          break;
        case 6u:
          uint64_t v38 = PBReaderReadData();
          uint64_t v39 = *(void **)(a1 + 24);
          *(void *)(a1 + 24) = v38;

          continue;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v34 = *v3;
        uint64_t v35 = *(void *)(a2 + v34);
        unint64_t v36 = v35 + 1;
        if (v35 == -1 || v36 > *(void *)(a2 + *v4)) {
          break;
        }
        char v37 = *(unsigned char *)(*(void *)(a2 + *v7) + v35);
        *(void *)(a2 + v34) = v36;
        v27 |= (unint64_t)(v37 & 0x7F) << v32;
        if ((v37 & 0x80) == 0) {
          goto LABEL_50;
        }
        v32 += 7;
        BOOL v15 = v33++ >= 9;
        if (v15)
        {
          LODWORD(v27) = 0;
          goto LABEL_52;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_50:
      if (*(unsigned char *)(a2 + *v5)) {
        LODWORD(v27) = 0;
      }
LABEL_52:
      uint64_t v40 = 44;
LABEL_53:
      *(_DWORD *)(a1 + v40) = v27;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCC194D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__12(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
}

void sub_1BCC19CA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCC19F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__13(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
}

void sub_1BCC1A9B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1BCC1B090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  _Block_object_dispose(&a32, 8);
  _Block_object_dispose((const void *)(v32 - 152), 8);
  _Unwind_Resume(a1);
}

id HDSharedSummaryMergeAuthorizationIdentifiers(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = (void *)MEMORY[0x1E4F1CA80];
  id v6 = a3;
  id v7 = a2;
  char v8 = [v5 setWithArray:a1];
  unsigned int v9 = [MEMORY[0x1E4F1CAD0] setWithArray:v7];

  [v8 unionSet:v9];
  unint64_t v10 = [MEMORY[0x1E4F1CAD0] setWithArray:v6];

  [v8 minusSet:v10];
  uint64_t v11 = [v8 allObjects];

  return v11;
}

id HDCNContactForCodableEntry(void *a1, void *a2)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  _HKInitializeLogging();
  uint64_t v5 = HKLogSharing();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [v3 primaryContactIdentifier];
    id v7 = [v3 uuid];
    *(_DWORD *)long long buf = 138478083;
    uint64_t v77 = (uint64_t)v6;
    __int16 v78 = 2114;
    uint64_t v79 = v7;
    _os_log_impl(&dword_1BCB7D000, v5, OS_LOG_TYPE_DEFAULT, "[summary-sharing] Updating name for entry with identifier %{private}@ and UUID %{public}@", buf, 0x16u);
  }
  id v8 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  id v9 = v3;
  id v10 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  uint64_t v11 = [v9 primaryContactIdentifier];
  int v12 = [v11 _appearsToBePhoneNumber];

  if (v12)
  {
    uint64_t v13 = [v9 primaryContactIdentifier];
    [v10 addObject:v13];
  }
  char v14 = (void *)[v10 copy];

  id v15 = v9;
  id v16 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  uint64_t v17 = [v15 primaryContactIdentifier];
  int v18 = [v17 _appearsToBeEmail];

  if (v18)
  {
    unint64_t v19 = [v15 primaryContactIdentifier];
    [v16 addObject:v19];
  }
  char v59 = (void *)[v16 copy];

  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  id v20 = v14;
  uint64_t v21 = [v20 countByEnumeratingWithState:&v65 objects:v75 count:16];
  if (v21)
  {
    uint64_t v22 = v21;
    uint64_t v23 = *(void *)v66;
    do
    {
      for (uint64_t i = 0; i != v22; ++i)
      {
        if (*(void *)v66 != v23) {
          objc_enumerationMutation(v20);
        }
        char v25 = _HDContactsForContactIdentifier(*(void **)(*((void *)&v65 + 1) + 8 * i), v4);
        if (v25) {
          [v8 addObjectsFromArray:v25];
        }
      }
      uint64_t v22 = [v20 countByEnumeratingWithState:&v65 objects:v75 count:16];
    }
    while (v22);
  }

  uint64_t v26 = [v8 count];
  _HKInitializeLogging();
  uint64_t v27 = HKLogSharing();
  BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
  unint64_t v58 = v15;
  if (v26)
  {
    if (!v28) {
      goto LABEL_34;
    }
    uint64_t v29 = [v8 count];
    unint64_t v30 = [v15 primaryContactIdentifier];
    char v31 = [v15 uuid];
    *(_DWORD *)long long buf = 134218499;
    uint64_t v77 = v29;
    __int16 v78 = 2113;
    uint64_t v79 = v30;
    __int16 v80 = 2114;
    uint64_t v81 = v31;
    goto LABEL_33;
  }
  if (v28)
  {
    uint64_t v32 = [v15 primaryContactIdentifier];
    unsigned int v33 = [v15 uuid];
    *(_DWORD *)long long buf = 138478083;
    uint64_t v77 = (uint64_t)v32;
    __int16 v78 = 2114;
    uint64_t v79 = v33;
    _os_log_impl(&dword_1BCB7D000, v27, OS_LOG_TYPE_DEFAULT, "[summary-sharing] Looking for email address contacts for identifiers %{private}@ and UUID %{public}@", buf, 0x16u);
  }
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  id v34 = v59;
  uint64_t v35 = [v34 countByEnumeratingWithState:&v61 objects:v74 count:16];
  if (v35)
  {
    uint64_t v36 = v35;
    uint64_t v37 = *(void *)v62;
    do
    {
      for (uint64_t j = 0; j != v36; ++j)
      {
        if (*(void *)v62 != v37) {
          objc_enumerationMutation(v34);
        }
        uint64_t v39 = _HDContactsForContactIdentifier(*(void **)(*((void *)&v61 + 1) + 8 * j), v4);
        if (v39) {
          [v8 addObjectsFromArray:v39];
        }
      }
      uint64_t v36 = [v34 countByEnumeratingWithState:&v61 objects:v74 count:16];
    }
    while (v36);
  }

  if ([v8 count])
  {
    _HKInitializeLogging();
    uint64_t v27 = HKLogSharing();
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_34;
    }
    uint64_t v40 = [v8 count];
    unint64_t v30 = [v58 primaryContactIdentifier];
    char v31 = [v58 uuid];
    *(_DWORD *)long long buf = 134218499;
    uint64_t v77 = v40;
    __int16 v78 = 2113;
    uint64_t v79 = v30;
    __int16 v80 = 2114;
    uint64_t v81 = v31;
LABEL_33:
    _os_log_impl(&dword_1BCB7D000, v27, OS_LOG_TYPE_DEFAULT, "[summary-sharing] Found %lu contacts. Finding best match for %{private}@ and UUID %{public}@", buf, 0x20u);

LABEL_34:
    id v41 = v8;
    if ([v41 count])
    {
      long long v72 = 0u;
      long long v73 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      id v42 = v41;
      uint64_t v43 = [v42 countByEnumeratingWithState:&v70 objects:buf count:16];
      if (v43)
      {
        uint64_t v44 = v43;
        id v57 = v41;
        unsigned int v45 = 0;
        uint64_t v46 = *(void *)v71;
        obuint64_t j = v42;
        while (2)
        {
          for (uint64_t k = 0; k != v44; ++k)
          {
            if (*(void *)v71 != v46) {
              objc_enumerationMutation(obj);
            }
            id v48 = *(void **)(*((void *)&v70 + 1) + 8 * k);
            uint64_t v49 = objc_msgSend(v48, "givenName", v57);
            if (v49)
            {
              long long v50 = (void *)v49;
              long long v51 = [v48 familyName];

              if (v51)
              {
                id v54 = v48;

                unsigned int v45 = v54;
                id v41 = v57;
                goto LABEL_54;
              }
            }
            uint64_t v52 = [v48 givenName];

            if (v52)
            {
              id v53 = v48;

              unsigned int v45 = v53;
            }
          }
          id v42 = obj;
          uint64_t v44 = [obj countByEnumeratingWithState:&v70 objects:buf count:16];
          if (v44) {
            continue;
          }
          break;
        }

        id v41 = v57;
        if (v45) {
          goto LABEL_54;
        }
      }
      else
      {
      }
      _HKInitializeLogging();
      uint64_t v55 = HKLogSharing();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v69 = 0;
        _os_log_impl(&dword_1BCB7D000, v55, OS_LOG_TYPE_DEFAULT, "[summary-sharing] No first name found for any requested contacts.", v69, 2u);
      }

      unsigned int v45 = [v42 anyObject];
    }
    else
    {
      unsigned int v45 = 0;
    }
LABEL_54:

    goto LABEL_55;
  }
  unsigned int v45 = 0;
LABEL_55:

  return v45;
}

id _HDContactsForContactIdentifier(void *a1, void *a2)
{
  v27[2] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = objc_alloc(MEMORY[0x1E4F1B908]);
  uint64_t v6 = *MEMORY[0x1E4F1ADE0];
  v27[0] = *MEMORY[0x1E4F1ADF0];
  v27[1] = v6;
  id v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:v27 count:2];
  id v8 = (void *)[v5 initWithKeysToFetch:v7];

  if ([v3 _appearsToBeEmail])
  {
    id v9 = [MEMORY[0x1E4F1B8F8] predicateForContactsMatchingEmailAddress:v3];
    [v8 setPredicate:v9];
  }
  else
  {
    if (![v3 _appearsToBePhoneNumber])
    {
      id v16 = 0;
      goto LABEL_12;
    }
    id v10 = (void *)MEMORY[0x1E4F1B8F8];
    id v9 = [MEMORY[0x1E4F1BA70] phoneNumberWithStringValue:v3];
    uint64_t v11 = [v10 predicateForContactsMatchingPhoneNumber:v9];
    [v8 setPredicate:v11];
  }
  [v8 setUnifyResults:0];
  id v12 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  id v24 = 0;
  uint64_t v19 = MEMORY[0x1E4F143A8];
  uint64_t v20 = 3221225472;
  uint64_t v21 = ___HDContactsForContactIdentifier_block_invoke;
  uint64_t v22 = &unk_1E62F5040;
  id v13 = v12;
  id v23 = v13;
  char v14 = [v4 enumerateContactsWithFetchRequest:v8 error:&v24 usingBlock:&v19];
  id v15 = v24;
  if (v14)
  {
    id v16 = objc_msgSend(v13, "copy", v19, v20, v21, v22);
  }
  else
  {
    _HKInitializeLogging();
    uint64_t v17 = HKLogSharing();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      id v26 = v15;
      _os_log_error_impl(&dword_1BCB7D000, v17, OS_LOG_TYPE_ERROR, "[summary-sharing] Contacts error occured %{public}@", buf, 0xCu);
    }

    id v16 = 0;
  }

LABEL_12:

  return v16;
}

uint64_t HDMergedSharingStatus(uint64_t a1, unint64_t a2)
{
  uint64_t result = a2;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = a1;
      if (a2 < 5)
      {
        id v5 = &unk_1BD324F18;
        goto LABEL_9;
      }
      break;
    case 2:
      uint64_t result = 2;
      break;
    case 3:
      uint64_t result = a1;
      if (a2 < 5)
      {
        id v5 = &unk_1BD324F68;
        goto LABEL_9;
      }
      break;
    case 4:
      uint64_t result = a1;
      if (a2 < 5)
      {
        id v5 = &unk_1BD324F40;
LABEL_9:
        uint64_t result = v5[a2];
      }
      break;
    default:
      uint64_t result = a1;
      break;
  }
  return result;
}

uint64_t HDCodableSyncAnchorRangeMapReadFrom(void *a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    id v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = objc_alloc_init(HDCodableSyncAnchorRange);
        [a1 addAnchorRanges:v17];
        if (!PBReaderPlaceMark() || (HDCodableSyncAnchorRangeReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t statistics::Statistics::Statistics(uint64_t this)
{
  *(void *)(this + 72) = 0;
  *(void *)(this + 80) = 0;
  *(void *)(this + 64) = 0;
  *(void *)(this + 160) = 0;
  *(_DWORD *)(this + 204) = 0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_1F171B978;
  *(void *)(this + 120) = 0;
  *(void *)(this + 128) = 0;
  *(void *)(this + 112) = 0;
  return this;
}

{
  *(void *)(this + 72) = 0;
  *(void *)(this + 80) = 0;
  *(void *)(this + 64) = 0;
  *(void *)(this + 160) = 0;
  *(_DWORD *)(this + 204) = 0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_1F171B978;
  *(void *)(this + 120) = 0;
  *(void *)(this + 128) = 0;
  *(void *)(this + 112) = 0;
  return this;
}

void __clang_call_terminate(void *a1)
{
}

void statistics::Statistics::~Statistics(statistics::Statistics *this)
{
  *(void *)this = &unk_1F171B978;
  uint64_t v2 = *((void *)this + 20);
  *((void *)this + 20) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  char v8 = (void **)((char *)this + 64);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v8);
  uint64_t v6 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v6) {
    std::default_delete<std::string>::operator()[abi:ne180100](v6);
  }
  uint64_t v7 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  PB::Base::~Base(this);
}

{
  uint64_t vars8;

  statistics::Statistics::~Statistics(this);

  JUMPOUT(0x1C187B8A0);
}

uint64_t statistics::Statistics::Statistics(uint64_t this, const statistics::Statistics *a2)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 64) = 0;
  *(void *)this = &unk_1F171B978;
  *(void *)(this + 72) = 0;
  *(void *)(this + 80) = 0;
  *(void *)(this + 112) = 0;
  *(void *)(this + 160) = 0;
  *(_DWORD *)(this + 204) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 120) = 0;
  *(void *)(this + 128) = 0;
  if (*((void *)a2 + 14)) {
    operator new();
  }
  int v2 = *((_DWORD *)a2 + 51);
  if (v2)
  {
    uint64_t v9 = *((void *)a2 + 3);
    *(_DWORD *)(this + 204) |= 1u;
    *(void *)(this + 24) = v9;
    int v2 = *((_DWORD *)a2 + 51);
    if ((v2 & 0x400) == 0)
    {
LABEL_5:
      if ((v2 & 0x40) == 0) {
        goto LABEL_6;
      }
      goto LABEL_34;
    }
  }
  else if ((v2 & 0x400) == 0)
  {
    goto LABEL_5;
  }
  uint64_t v10 = *((void *)a2 + 19);
  *(_DWORD *)(this + 204) |= 0x400u;
  *(void *)(this + 152) = v10;
  int v2 = *((_DWORD *)a2 + 51);
  if ((v2 & 0x40) == 0)
  {
LABEL_6:
    if ((v2 & 0x80) == 0) {
      goto LABEL_7;
    }
    goto LABEL_35;
  }
LABEL_34:
  uint64_t v11 = *((void *)a2 + 12);
  *(_DWORD *)(this + 204) |= 0x40u;
  *(void *)(this + 96) = v11;
  int v2 = *((_DWORD *)a2 + 51);
  if ((v2 & 0x80) == 0)
  {
LABEL_7:
    if ((v2 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_36;
  }
LABEL_35:
  uint64_t v12 = *((void *)a2 + 13);
  *(_DWORD *)(this + 204) |= 0x80u;
  *(void *)(this + 104) = v12;
  int v2 = *((_DWORD *)a2 + 51);
  if ((v2 & 0x20) == 0)
  {
LABEL_8:
    if ((v2 & 0x2000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_37;
  }
LABEL_36:
  uint64_t v13 = *((void *)a2 + 11);
  *(_DWORD *)(this + 204) |= 0x20u;
  *(void *)(this + 88) = v13;
  int v2 = *((_DWORD *)a2 + 51);
  if ((v2 & 0x2000) == 0)
  {
LABEL_9:
    if ((v2 & 0x4000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_38;
  }
LABEL_37:
  uint64_t v14 = *((void *)a2 + 23);
  *(_DWORD *)(this + 204) |= 0x2000u;
  *(void *)(this + 184) = v14;
  int v2 = *((_DWORD *)a2 + 51);
  if ((v2 & 0x4000) == 0)
  {
LABEL_10:
    if ((v2 & 0x10) == 0) {
      goto LABEL_11;
    }
    goto LABEL_39;
  }
LABEL_38:
  uint64_t v15 = *((void *)a2 + 24);
  *(_DWORD *)(this + 204) |= 0x4000u;
  *(void *)(this + 192) = v15;
  int v2 = *((_DWORD *)a2 + 51);
  if ((v2 & 0x10) == 0)
  {
LABEL_11:
    if ((v2 & 8) == 0) {
      goto LABEL_12;
    }
    goto LABEL_40;
  }
LABEL_39:
  uint64_t v16 = *((void *)a2 + 7);
  *(_DWORD *)(this + 204) |= 0x10u;
  *(void *)(this + 56) = v16;
  int v2 = *((_DWORD *)a2 + 51);
  if ((v2 & 8) == 0)
  {
LABEL_12:
    if ((v2 & 4) == 0) {
      goto LABEL_13;
    }
    goto LABEL_41;
  }
LABEL_40:
  uint64_t v17 = *((void *)a2 + 6);
  *(_DWORD *)(this + 204) |= 8u;
  *(void *)(this + 48) = v17;
  int v2 = *((_DWORD *)a2 + 51);
  if ((v2 & 4) == 0)
  {
LABEL_13:
    if ((v2 & 0x800) == 0) {
      goto LABEL_14;
    }
    goto LABEL_42;
  }
LABEL_41:
  uint64_t v18 = *((void *)a2 + 5);
  *(_DWORD *)(this + 204) |= 4u;
  *(void *)(this + 40) = v18;
  int v2 = *((_DWORD *)a2 + 51);
  if ((v2 & 0x800) == 0)
  {
LABEL_14:
    if ((v2 & 0x1000) == 0) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_42:
  uint64_t v19 = *((void *)a2 + 21);
  *(_DWORD *)(this + 204) |= 0x800u;
  *(void *)(this + 168) = v19;
  if ((*((_DWORD *)a2 + 51) & 0x1000) != 0)
  {
LABEL_15:
    uint64_t v3 = *((void *)a2 + 22);
    *(_DWORD *)(this + 204) |= 0x1000u;
    *(void *)(this + 176) = v3;
  }
LABEL_16:
  if (*((void *)a2 + 8) != *((void *)a2 + 9)) {
    PB::PtrVector<statistics::Interval>::emplace_back<statistics::Interval const&>();
  }
  if (*((void *)a2 + 20)) {
    operator new();
  }
  int v4 = *((_DWORD *)a2 + 51);
  if ((v4 & 0x100) != 0)
  {
    uint64_t v20 = *((void *)a2 + 17);
    *(_DWORD *)(this + 204) |= 0x100u;
    *(void *)(this + 136) = v20;
    int v4 = *((_DWORD *)a2 + 51);
    if ((v4 & 2) == 0)
    {
LABEL_22:
      if ((v4 & 0x10000) == 0) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_22;
  }
  uint64_t v21 = *((void *)a2 + 4);
  *(_DWORD *)(this + 204) |= 2u;
  *(void *)(this + 32) = v21;
  if ((*((_DWORD *)a2 + 51) & 0x10000) != 0)
  {
LABEL_23:
    char v5 = *((unsigned char *)a2 + 201);
    *(_DWORD *)(this + 204) |= 0x10000u;
    *(unsigned char *)(this + 201) = v5;
  }
LABEL_24:
  if (*((void *)a2 + 15)) {
    operator new();
  }
  int v6 = *((_DWORD *)a2 + 51);
  if ((v6 & 0x8000) != 0)
  {
    char v7 = *((unsigned char *)a2 + 200);
    *(_DWORD *)(this + 204) |= 0x8000u;
    *(unsigned char *)(this + 200) = v7;
    int v6 = *((_DWORD *)a2 + 51);
  }
  if ((v6 & 0x200) != 0)
  {
    uint64_t v8 = *((void *)a2 + 18);
    *(_DWORD *)(this + 204) |= 0x200u;
    *(void *)(this + 144) = v8;
  }
  if (*((void *)a2 + 2)) {
    operator new();
  }
  if (*((void *)a2 + 16)) {
    operator new();
  }
  if (*((void *)a2 + 1)) {
    operator new();
  }
  return this;
}

void PB::PtrVector<statistics::Interval>::emplace_back<statistics::Interval const&>()
{
}

void sub_1BCC22868(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

statistics *statistics::Statistics::operator=(statistics *a1, const statistics::Statistics *a2)
{
  if (a1 != a2)
  {
    statistics::Statistics::Statistics((uint64_t)v5, a2);
    statistics::swap(a1, (statistics::Statistics *)v5, v3);
    statistics::Statistics::~Statistics((statistics::Statistics *)v5);
  }
  return a1;
}

double statistics::swap(statistics *this, statistics::Statistics *a2, statistics::Statistics *a3)
{
  int v3 = *((_DWORD *)this + 51);
  *((_DWORD *)this + 51) = *((_DWORD *)a2 + 51);
  *((_DWORD *)a2 + 51) = v3;
  uint64_t v4 = *((void *)this + 14);
  *((void *)this + 14) = *((void *)a2 + 14);
  *((void *)a2 + 14) = v4;
  uint64_t v5 = *((void *)this + 8);
  *((void *)this + 8) = *((void *)a2 + 8);
  *((void *)a2 + 8) = v5;
  uint64_t v6 = *((void *)this + 9);
  *((void *)this + 9) = *((void *)a2 + 9);
  *((void *)a2 + 9) = v6;
  uint64_t v7 = *((void *)this + 10);
  *((void *)this + 10) = *((void *)a2 + 10);
  *((void *)a2 + 10) = v7;
  uint64_t v8 = *((void *)this + 20);
  *((void *)this + 20) = *((void *)a2 + 20);
  *((void *)a2 + 20) = v8;
  uint64_t v9 = *((void *)this + 15);
  *((void *)this + 15) = *((void *)a2 + 15);
  *((void *)a2 + 15) = v9;
  uint64_t v11 = *((void *)this + 2);
  uint64_t v10 = *((void *)this + 3);
  uint64_t v12 = *((void *)a2 + 3);
  *((void *)this + 2) = *((void *)a2 + 2);
  *((void *)this + 3) = v12;
  *((void *)a2 + 3) = v10;
  uint64_t v13 = *((void *)this + 6);
  *((void *)this + 6) = *((void *)a2 + 6);
  *((void *)a2 + 6) = v13;
  uint64_t v14 = *((void *)this + 21);
  *((void *)this + 21) = *((void *)a2 + 21);
  *((void *)a2 + 21) = v14;
  *((void *)a2 + 2) = v11;
  uint64_t v16 = *((void *)this + 16);
  uint64_t v15 = *((void *)this + 17);
  uint64_t v17 = *((void *)a2 + 17);
  *((void *)this + 16) = *((void *)a2 + 16);
  *((void *)this + 17) = v17;
  *((void *)a2 + 17) = v15;
  uint64_t v18 = *((void *)this + 4);
  *((void *)this + 4) = *((void *)a2 + 4);
  *((void *)a2 + 4) = v18;
  LOBYTE(v18) = *((unsigned char *)this + 201);
  *((unsigned char *)this + 201) = *((unsigned char *)a2 + 201);
  *((unsigned char *)a2 + 201) = v18;
  LOBYTE(v18) = *((unsigned char *)this + 200);
  *((unsigned char *)this + 200) = *((unsigned char *)a2 + 200);
  *((unsigned char *)a2 + 200) = v18;
  uint64_t v19 = *((void *)this + 18);
  *((void *)this + 18) = *((void *)a2 + 18);
  uint64_t v20 = *((void *)this + 19);
  *((void *)this + 19) = *((void *)a2 + 19);
  *((void *)a2 + 19) = v20;
  uint64_t v21 = *((void *)this + 12);
  *((void *)this + 12) = *((void *)a2 + 12);
  *((void *)a2 + 12) = v21;
  uint64_t v22 = *((void *)this + 13);
  *((void *)this + 13) = *((void *)a2 + 13);
  *((void *)a2 + 13) = v22;
  uint64_t v23 = *((void *)this + 11);
  *((void *)this + 11) = *((void *)a2 + 11);
  *((void *)a2 + 11) = v23;
  uint64_t v24 = *((void *)this + 23);
  *((void *)this + 23) = *((void *)a2 + 23);
  *((void *)a2 + 23) = v24;
  uint64_t v25 = *((void *)this + 24);
  *((void *)this + 24) = *((void *)a2 + 24);
  *((void *)a2 + 24) = v25;
  uint64_t v26 = *((void *)this + 7);
  *((void *)this + 7) = *((void *)a2 + 7);
  *((void *)a2 + 7) = v26;
  uint64_t v27 = *((void *)this + 5);
  *((void *)this + 5) = *((void *)a2 + 5);
  *((void *)a2 + 5) = v27;
  double result = *((double *)this + 22);
  *((void *)this + 22) = *((void *)a2 + 22);
  *((double *)a2 + 22) = result;
  *((void *)a2 + 18) = v19;
  *((void *)a2 + 16) = v16;
  uint64_t v29 = *((void *)this + 1);
  *((void *)this + 1) = *((void *)a2 + 1);
  *((void *)a2 + 1) = v29;
  return result;
}

uint64_t statistics::Statistics::Statistics(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  *(void *)a1 = &unk_1F171B978;
  *(void *)(a1 + 64) = 0;
  uint64_t v5 = (void **)(a1 + 64);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 204) = *(_DWORD *)(a2 + 204);
  *(_DWORD *)(a2 + 204) = 0;
  uint64_t v6 = *(void *)(a2 + 112);
  *(void *)(a2 + 112) = 0;
  uint64_t v7 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = v6;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a1 + 184) = *(void *)(a2 + 184);
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate(v5);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  uint64_t v8 = *(void *)(a2 + 160);
  *(void *)(a2 + 160) = 0;
  uint64_t v9 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = v8;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(unsigned char *)(a1 + 201) = *(unsigned char *)(a2 + 201);
  uint64_t v10 = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = 0;
  uint64_t v11 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = v10;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  *(unsigned char *)(a1 + 200) = *(unsigned char *)(a2 + 200);
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  uint64_t v12 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  uint64_t v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  if (v13) {
    std::default_delete<std::string>::operator()[abi:ne180100](v13);
  }
  uint64_t v14 = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = 0;
  uint64_t v15 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = v14;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v17 = *v4;
  uint64_t *v4 = v16;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  return a1;
}

statistics *statistics::Statistics::operator=(statistics *a1, uint64_t a2)
{
  if (a1 != (statistics *)a2)
  {
    statistics::Statistics::Statistics((uint64_t)v5, a2);
    statistics::swap(a1, (statistics::Statistics *)v5, v3);
    statistics::Statistics::~Statistics((statistics::Statistics *)v5);
  }
  return a1;
}

uint64_t statistics::Statistics::formatText(statistics::Statistics *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 1);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "auxiliaryStatistics");
  }
  if (*((void *)this + 2)) {
    PB::TextFormatter::format();
  }
  int v6 = *((_DWORD *)this + 51);
  if (v6)
  {
    PB::TextFormatter::format(a2, "count");
    int v6 = *((_DWORD *)this + 51);
    if ((v6 & 2) == 0)
    {
LABEL_7:
      if ((v6 & 0x8000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_41;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_7;
  }
  PB::TextFormatter::format(a2, "effectiveCount");
  int v6 = *((_DWORD *)this + 51);
  if ((v6 & 0x8000) == 0)
  {
LABEL_8:
    if ((v6 & 4) == 0) {
      goto LABEL_9;
    }
    goto LABEL_42;
  }
LABEL_41:
  PB::TextFormatter::format(a2, "enableOverlapProcessing");
  int v6 = *((_DWORD *)this + 51);
  if ((v6 & 4) == 0)
  {
LABEL_9:
    if ((v6 & 8) == 0) {
      goto LABEL_10;
    }
    goto LABEL_43;
  }
LABEL_42:
  PB::TextFormatter::format(a2, "freezeTimestamp", *((double *)this + 5));
  int v6 = *((_DWORD *)this + 51);
  if ((v6 & 8) == 0)
  {
LABEL_10:
    if ((v6 & 0x10) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_43:
  PB::TextFormatter::format(a2, "frozenBucketCount");
  if ((*((_DWORD *)this + 51) & 0x10) != 0) {
LABEL_11:
  }
    PB::TextFormatter::format(a2, "frozenMean", *((double *)this + 7));
LABEL_12:
  uint64_t v7 = (uint64_t *)*((void *)this + 8);
  uint64_t v8 = (uint64_t *)*((void *)this + 9);
  while (v7 != v8)
  {
    uint64_t v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, a2, "intervals");
  }
  int v10 = *((_DWORD *)this + 51);
  if ((v10 & 0x20) != 0)
  {
    PB::TextFormatter::format(a2, "max", *((double *)this + 11));
    int v10 = *((_DWORD *)this + 51);
    if ((v10 & 0x40) == 0)
    {
LABEL_16:
      if ((v10 & 0x80) == 0) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
  }
  else if ((v10 & 0x40) == 0)
  {
    goto LABEL_16;
  }
  PB::TextFormatter::format(a2, "mean", *((double *)this + 12));
  if ((*((_DWORD *)this + 51) & 0x80) != 0) {
LABEL_17:
  }
    PB::TextFormatter::format(a2, "min", *((double *)this + 13));
LABEL_18:
  uint64_t v11 = *((void *)this + 14);
  if (v11) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v11 + 32))(v11, a2, "mostRecentDatum");
  }
  uint64_t v12 = *((void *)this + 15);
  if (v12) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v12 + 32))(v12, a2, "overlapProcessorState");
  }
  uint64_t v13 = *((void *)this + 16);
  if (v13) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v13 + 32))(v13, a2, "primaryStatistics");
  }
  int v14 = *((_DWORD *)this + 51);
  if ((v14 & 0x100) != 0)
  {
    PB::TextFormatter::format(a2, "relativeValueState");
    int v14 = *((_DWORD *)this + 51);
    if ((v14 & 0x10000) == 0)
    {
LABEL_26:
      if ((v14 & 0x200) == 0) {
        goto LABEL_27;
      }
      goto LABEL_50;
    }
  }
  else if ((v14 & 0x10000) == 0)
  {
    goto LABEL_26;
  }
  PB::TextFormatter::format(a2, "setAnchorTime");
  int v14 = *((_DWORD *)this + 51);
  if ((v14 & 0x200) == 0)
  {
LABEL_27:
    if ((v14 & 0x400) == 0) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
LABEL_50:
  PB::TextFormatter::format(a2, "sourceID");
  if ((*((_DWORD *)this + 51) & 0x400) != 0) {
LABEL_28:
  }
    PB::TextFormatter::format(a2, "sum", *((double *)this + 19));
LABEL_29:
  uint64_t v15 = *((void *)this + 20);
  if (v15) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v15 + 32))(v15, a2, "unfinishedDatum");
  }
  int v16 = *((_DWORD *)this + 51);
  if ((v16 & 0x800) != 0)
  {
    PB::TextFormatter::format(a2, "unfrozenCount");
    int v16 = *((_DWORD *)this + 51);
    if ((v16 & 0x1000) == 0)
    {
LABEL_33:
      if ((v16 & 0x2000) == 0) {
        goto LABEL_34;
      }
      goto LABEL_54;
    }
  }
  else if ((v16 & 0x1000) == 0)
  {
    goto LABEL_33;
  }
  PB::TextFormatter::format(a2, "unfrozenMean", *((double *)this + 22));
  int v16 = *((_DWORD *)this + 51);
  if ((v16 & 0x2000) == 0)
  {
LABEL_34:
    if ((v16 & 0x4000) == 0) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
LABEL_54:
  PB::TextFormatter::format(a2, "weightTotal", *((double *)this + 23));
  if ((*((_DWORD *)this + 51) & 0x4000) != 0) {
LABEL_35:
  }
    PB::TextFormatter::format(a2, "weightedMean", *((double *)this + 24));
LABEL_36:

  return MEMORY[0x1F4147498](a2);
}

uint64_t statistics::Statistics::readFrom(statistics::Statistics *this, PB::Reader *a2)
{
  unint64_t v2 = *((void *)a2 + 1);
  unint64_t v3 = *((void *)a2 + 2);
  for (int i = *((unsigned __int8 *)a2 + 24); v2 < v3 && i == 0; int i = *((unsigned __int8 *)a2 + 24))
  {
    uint64_t v8 = *(void *)a2;
    if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
    {
      char v15 = 0;
      unsigned int v16 = 0;
      unint64_t v11 = 0;
      if (v2 > v3) {
        unint64_t v3 = v2;
      }
      while (v3 != v2)
      {
        unint64_t v17 = v2 + 1;
        char v18 = *(unsigned char *)(v8 + v2);
        *((void *)a2 + 1) = v17;
        v11 |= (unint64_t)(v18 & 0x7F) << v15;
        if ((v18 & 0x80) == 0) {
          goto LABEL_21;
        }
        v15 += 7;
        unint64_t v2 = v17;
        BOOL v14 = v16++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
      int i = 1;
      *((unsigned char *)a2 + 24) = 1;
      return i == 0;
    }
    char v9 = 0;
    unsigned int v10 = 0;
    unint64_t v11 = 0;
    while (1)
    {
      unint64_t v12 = v2 + 1;
      *((void *)a2 + 1) = v2 + 1;
      char v13 = *(unsigned char *)(v8 + v2);
      v11 |= (unint64_t)(v13 & 0x7F) << v9;
      if ((v13 & 0x80) == 0) {
        break;
      }
      v9 += 7;
      unint64_t v2 = v12;
      BOOL v14 = v10++ > 8;
      if (v14) {
        goto LABEL_19;
      }
    }
LABEL_21:
    if ((v11 & 7) == 4)
    {
      int i = 0;
      return i == 0;
    }
    unint64_t v20 = v11 >> 3;
    if ((int)(v11 >> 3) > 99)
    {
      if ((int)v20 > 999)
      {
        if (v20 == 1000) {
          operator new();
        }
        if (v20 == 1001) {
          operator new();
        }
LABEL_19:
        uint64_t result = PB::Reader::skip(a2);
        if (!result) {
          return result;
        }
        goto LABEL_181;
      }
      if (v20 != 100)
      {
        if (v20 == 101) {
          operator new();
        }
        goto LABEL_19;
      }
      *((_DWORD *)this + 51) |= 0x200u;
      unint64_t v78 = *((void *)a2 + 1);
      unint64_t v79 = *((void *)a2 + 2);
      uint64_t v80 = *(void *)a2;
      if (v78 > 0xFFFFFFFFFFFFFFF5 || v78 + 10 > v79)
      {
        char v106 = 0;
        unsigned int v107 = 0;
        uint64_t v83 = 0;
        if (v79 <= v78) {
          unint64_t v79 = *((void *)a2 + 1);
        }
        while (1)
        {
          if (v79 == v78)
          {
            uint64_t v83 = 0;
            *((unsigned char *)a2 + 24) = 1;
            goto LABEL_180;
          }
          unint64_t v108 = v78 + 1;
          char v109 = *(unsigned char *)(v80 + v78);
          *((void *)a2 + 1) = v108;
          v83 |= (unint64_t)(v109 & 0x7F) << v106;
          if ((v109 & 0x80) == 0) {
            break;
          }
          v106 += 7;
          unint64_t v78 = v108;
          BOOL v14 = v107++ > 8;
          if (v14)
          {
LABEL_154:
            uint64_t v83 = 0;
            goto LABEL_180;
          }
        }
        if (*((unsigned char *)a2 + 24)) {
          uint64_t v83 = 0;
        }
      }
      else
      {
        char v81 = 0;
        unsigned int v82 = 0;
        uint64_t v83 = 0;
        while (1)
        {
          unint64_t v84 = v78 + 1;
          *((void *)a2 + 1) = v78 + 1;
          char v85 = *(unsigned char *)(v80 + v78);
          v83 |= (unint64_t)(v85 & 0x7F) << v81;
          if ((v85 & 0x80) == 0) {
            break;
          }
          v81 += 7;
          unint64_t v78 = v84;
          BOOL v14 = v82++ > 8;
          if (v14) {
            goto LABEL_154;
          }
        }
      }
LABEL_180:
      *((void *)this + 18) = v83;
    }
    else
    {
      switch((int)v20)
      {
        case 1:
          operator new();
        case 2:
          *((_DWORD *)this + 51) |= 1u;
          unint64_t v21 = *((void *)a2 + 1);
          unint64_t v22 = *((void *)a2 + 2);
          uint64_t v23 = *(void *)a2;
          if (v21 <= 0xFFFFFFFFFFFFFFF5 && v21 + 10 <= v22)
          {
            char v24 = 0;
            unsigned int v25 = 0;
            uint64_t v26 = 0;
            do
            {
              unint64_t v27 = v21 + 1;
              *((void *)a2 + 1) = v21 + 1;
              char v28 = *(unsigned char *)(v23 + v21);
              v26 |= (unint64_t)(v28 & 0x7F) << v24;
              if ((v28 & 0x80) == 0) {
                goto LABEL_160;
              }
              v24 += 7;
              unint64_t v21 = v27;
              BOOL v14 = v25++ > 8;
            }
            while (!v14);
LABEL_115:
            uint64_t v26 = 0;
            goto LABEL_160;
          }
          char v86 = 0;
          unsigned int v87 = 0;
          uint64_t v26 = 0;
          if (v22 <= v21) {
            unint64_t v22 = *((void *)a2 + 1);
          }
          while (2)
          {
            if (v22 == v21)
            {
              uint64_t v26 = 0;
              *((unsigned char *)a2 + 24) = 1;
            }
            else
            {
              unint64_t v88 = v21 + 1;
              char v89 = *(unsigned char *)(v23 + v21);
              *((void *)a2 + 1) = v88;
              v26 |= (unint64_t)(v89 & 0x7F) << v86;
              if (v89 < 0)
              {
                v86 += 7;
                unint64_t v21 = v88;
                BOOL v14 = v87++ > 8;
                if (v14) {
                  goto LABEL_115;
                }
                continue;
              }
              if (*((unsigned char *)a2 + 24)) {
                uint64_t v26 = 0;
              }
            }
            break;
          }
LABEL_160:
          *((void *)this + 3) = v26;
          goto LABEL_181;
        case 3:
          *((_DWORD *)this + 51) |= 0x400u;
          unint64_t v29 = *((void *)a2 + 1);
          if (v29 > 0xFFFFFFFFFFFFFFF7 || v29 + 8 > *((void *)a2 + 2)) {
            goto LABEL_79;
          }
          *((void *)this + 19) = *(void *)(*(void *)a2 + v29);
          goto LABEL_156;
        case 4:
          *((_DWORD *)this + 51) |= 0x40u;
          unint64_t v30 = *((void *)a2 + 1);
          if (v30 > 0xFFFFFFFFFFFFFFF7 || v30 + 8 > *((void *)a2 + 2)) {
            goto LABEL_79;
          }
          *((void *)this + 12) = *(void *)(*(void *)a2 + v30);
          goto LABEL_156;
        case 5:
          *((_DWORD *)this + 51) |= 0x80u;
          unint64_t v31 = *((void *)a2 + 1);
          if (v31 > 0xFFFFFFFFFFFFFFF7 || v31 + 8 > *((void *)a2 + 2)) {
            goto LABEL_79;
          }
          *((void *)this + 13) = *(void *)(*(void *)a2 + v31);
          goto LABEL_156;
        case 6:
          *((_DWORD *)this + 51) |= 0x20u;
          unint64_t v32 = *((void *)a2 + 1);
          if (v32 > 0xFFFFFFFFFFFFFFF7 || v32 + 8 > *((void *)a2 + 2)) {
            goto LABEL_79;
          }
          *((void *)this + 11) = *(void *)(*(void *)a2 + v32);
          goto LABEL_156;
        case 7:
          *((_DWORD *)this + 51) |= 0x2000u;
          unint64_t v33 = *((void *)a2 + 1);
          if (v33 > 0xFFFFFFFFFFFFFFF7 || v33 + 8 > *((void *)a2 + 2)) {
            goto LABEL_79;
          }
          *((void *)this + 23) = *(void *)(*(void *)a2 + v33);
          goto LABEL_156;
        case 8:
          *((_DWORD *)this + 51) |= 0x4000u;
          unint64_t v34 = *((void *)a2 + 1);
          if (v34 > 0xFFFFFFFFFFFFFFF7 || v34 + 8 > *((void *)a2 + 2)) {
            goto LABEL_79;
          }
          *((void *)this + 24) = *(void *)(*(void *)a2 + v34);
          goto LABEL_156;
        case 9:
          *((_DWORD *)this + 51) |= 0x10u;
          unint64_t v35 = *((void *)a2 + 1);
          if (v35 > 0xFFFFFFFFFFFFFFF7 || v35 + 8 > *((void *)a2 + 2)) {
            goto LABEL_79;
          }
          *((void *)this + 7) = *(void *)(*(void *)a2 + v35);
          goto LABEL_156;
        case 10:
          *((_DWORD *)this + 51) |= 8u;
          unint64_t v36 = *((void *)a2 + 1);
          unint64_t v37 = *((void *)a2 + 2);
          uint64_t v38 = *(void *)a2;
          if (v36 <= 0xFFFFFFFFFFFFFFF5 && v36 + 10 <= v37)
          {
            char v39 = 0;
            unsigned int v40 = 0;
            uint64_t v41 = 0;
            do
            {
              unint64_t v42 = v36 + 1;
              *((void *)a2 + 1) = v36 + 1;
              char v43 = *(unsigned char *)(v38 + v36);
              v41 |= (unint64_t)(v43 & 0x7F) << v39;
              if ((v43 & 0x80) == 0) {
                goto LABEL_164;
              }
              v39 += 7;
              unint64_t v36 = v42;
              BOOL v14 = v40++ > 8;
            }
            while (!v14);
LABEL_122:
            uint64_t v41 = 0;
            goto LABEL_164;
          }
          char v90 = 0;
          unsigned int v91 = 0;
          uint64_t v41 = 0;
          if (v37 <= v36) {
            unint64_t v37 = *((void *)a2 + 1);
          }
          while (2)
          {
            if (v37 == v36)
            {
              uint64_t v41 = 0;
              *((unsigned char *)a2 + 24) = 1;
            }
            else
            {
              unint64_t v92 = v36 + 1;
              char v93 = *(unsigned char *)(v38 + v36);
              *((void *)a2 + 1) = v92;
              v41 |= (unint64_t)(v93 & 0x7F) << v90;
              if (v93 < 0)
              {
                v90 += 7;
                unint64_t v36 = v92;
                BOOL v14 = v91++ > 8;
                if (v14) {
                  goto LABEL_122;
                }
                continue;
              }
              if (*((unsigned char *)a2 + 24)) {
                uint64_t v41 = 0;
              }
            }
            break;
          }
LABEL_164:
          *((void *)this + 6) = v41;
          goto LABEL_181;
        case 11:
          *((_DWORD *)this + 51) |= 4u;
          unint64_t v44 = *((void *)a2 + 1);
          if (v44 > 0xFFFFFFFFFFFFFFF7 || v44 + 8 > *((void *)a2 + 2)) {
            goto LABEL_79;
          }
          *((void *)this + 5) = *(void *)(*(void *)a2 + v44);
          goto LABEL_156;
        case 12:
          *((_DWORD *)this + 51) |= 0x800u;
          unint64_t v45 = *((void *)a2 + 1);
          unint64_t v46 = *((void *)a2 + 2);
          uint64_t v47 = *(void *)a2;
          if (v45 <= 0xFFFFFFFFFFFFFFF5 && v45 + 10 <= v46)
          {
            char v48 = 0;
            unsigned int v49 = 0;
            uint64_t v50 = 0;
            do
            {
              unint64_t v51 = v45 + 1;
              *((void *)a2 + 1) = v45 + 1;
              char v52 = *(unsigned char *)(v47 + v45);
              v50 |= (unint64_t)(v52 & 0x7F) << v48;
              if ((v52 & 0x80) == 0) {
                goto LABEL_168;
              }
              v48 += 7;
              unint64_t v45 = v51;
              BOOL v14 = v49++ > 8;
            }
            while (!v14);
LABEL_129:
            uint64_t v50 = 0;
            goto LABEL_168;
          }
          char v94 = 0;
          unsigned int v95 = 0;
          uint64_t v50 = 0;
          if (v46 <= v45) {
            unint64_t v46 = *((void *)a2 + 1);
          }
          while (2)
          {
            if (v46 == v45)
            {
              uint64_t v50 = 0;
              *((unsigned char *)a2 + 24) = 1;
            }
            else
            {
              unint64_t v96 = v45 + 1;
              char v97 = *(unsigned char *)(v47 + v45);
              *((void *)a2 + 1) = v96;
              v50 |= (unint64_t)(v97 & 0x7F) << v94;
              if (v97 < 0)
              {
                v94 += 7;
                unint64_t v45 = v96;
                BOOL v14 = v95++ > 8;
                if (v14) {
                  goto LABEL_129;
                }
                continue;
              }
              if (*((unsigned char *)a2 + 24)) {
                uint64_t v50 = 0;
              }
            }
            break;
          }
LABEL_168:
          *((void *)this + 21) = v50;
          goto LABEL_181;
        case 13:
          *((_DWORD *)this + 51) |= 0x1000u;
          unint64_t v53 = *((void *)a2 + 1);
          if (v53 <= 0xFFFFFFFFFFFFFFF7 && v53 + 8 <= *((void *)a2 + 2))
          {
            *((void *)this + 22) = *(void *)(*(void *)a2 + v53);
LABEL_156:
            *((void *)a2 + 1) += 8;
          }
          else
          {
LABEL_79:
            *((unsigned char *)a2 + 24) = 1;
          }
          goto LABEL_181;
        case 14:
          PB::PtrVector<statistics::Interval>::emplace_back<>();
        case 15:
          operator new();
        case 16:
          *((_DWORD *)this + 51) |= 0x100u;
          unint64_t v54 = *((void *)a2 + 1);
          unint64_t v55 = *((void *)a2 + 2);
          uint64_t v56 = *(void *)a2;
          if (v54 <= 0xFFFFFFFFFFFFFFF5 && v54 + 10 <= v55)
          {
            char v57 = 0;
            unsigned int v58 = 0;
            uint64_t v59 = 0;
            do
            {
              unint64_t v60 = v54 + 1;
              *((void *)a2 + 1) = v54 + 1;
              char v61 = *(unsigned char *)(v56 + v54);
              v59 |= (unint64_t)(v61 & 0x7F) << v57;
              if ((v61 & 0x80) == 0) {
                goto LABEL_172;
              }
              v57 += 7;
              unint64_t v54 = v60;
              BOOL v14 = v58++ > 8;
            }
            while (!v14);
LABEL_136:
            uint64_t v59 = 0;
            goto LABEL_172;
          }
          char v98 = 0;
          unsigned int v99 = 0;
          uint64_t v59 = 0;
          if (v55 <= v54) {
            unint64_t v55 = *((void *)a2 + 1);
          }
          while (2)
          {
            if (v55 == v54)
            {
              uint64_t v59 = 0;
              *((unsigned char *)a2 + 24) = 1;
            }
            else
            {
              unint64_t v100 = v54 + 1;
              char v101 = *(unsigned char *)(v56 + v54);
              *((void *)a2 + 1) = v100;
              v59 |= (unint64_t)(v101 & 0x7F) << v98;
              if (v101 < 0)
              {
                v98 += 7;
                unint64_t v54 = v100;
                BOOL v14 = v99++ > 8;
                if (v14) {
                  goto LABEL_136;
                }
                continue;
              }
              if (*((unsigned char *)a2 + 24)) {
                uint64_t v59 = 0;
              }
            }
            break;
          }
LABEL_172:
          *((void *)this + 17) = v59;
          goto LABEL_181;
        case 17:
          *((_DWORD *)this + 51) |= 2u;
          unint64_t v62 = *((void *)a2 + 1);
          unint64_t v63 = *((void *)a2 + 2);
          uint64_t v64 = *(void *)a2;
          if (v62 <= 0xFFFFFFFFFFFFFFF5 && v62 + 10 <= v63)
          {
            char v65 = 0;
            unsigned int v66 = 0;
            uint64_t v67 = 0;
            do
            {
              unint64_t v68 = v62 + 1;
              *((void *)a2 + 1) = v62 + 1;
              char v69 = *(unsigned char *)(v64 + v62);
              v67 |= (unint64_t)(v69 & 0x7F) << v65;
              if ((v69 & 0x80) == 0) {
                goto LABEL_176;
              }
              v65 += 7;
              unint64_t v62 = v68;
              BOOL v14 = v66++ > 8;
            }
            while (!v14);
LABEL_143:
            uint64_t v67 = 0;
            goto LABEL_176;
          }
          char v102 = 0;
          unsigned int v103 = 0;
          uint64_t v67 = 0;
          if (v63 <= v62) {
            unint64_t v63 = *((void *)a2 + 1);
          }
          break;
        case 18:
          *((_DWORD *)this + 51) |= 0x10000u;
          unint64_t v70 = *((void *)a2 + 1);
          if (v70 >= *((void *)a2 + 2))
          {
            BOOL v73 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            unint64_t v71 = v70 + 1;
            int v72 = *(unsigned __int8 *)(*(void *)a2 + v70);
            *((void *)a2 + 1) = v71;
            BOOL v73 = v72 != 0;
          }
          *((unsigned char *)this + 201) = v73;
          goto LABEL_181;
        case 19:
          operator new();
        case 20:
          *((_DWORD *)this + 51) |= 0x8000u;
          unint64_t v74 = *((void *)a2 + 1);
          if (v74 >= *((void *)a2 + 2))
          {
            BOOL v77 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            unint64_t v75 = v74 + 1;
            int v76 = *(unsigned __int8 *)(*(void *)a2 + v74);
            *((void *)a2 + 1) = v75;
            BOOL v77 = v76 != 0;
          }
          *((unsigned char *)this + 200) = v77;
          goto LABEL_181;
        default:
          goto LABEL_19;
      }
      while (1)
      {
        if (v63 == v62)
        {
          uint64_t v67 = 0;
          *((unsigned char *)a2 + 24) = 1;
          goto LABEL_176;
        }
        unint64_t v104 = v62 + 1;
        char v105 = *(unsigned char *)(v64 + v62);
        *((void *)a2 + 1) = v104;
        v67 |= (unint64_t)(v105 & 0x7F) << v102;
        if ((v105 & 0x80) == 0) {
          break;
        }
        v102 += 7;
        unint64_t v62 = v104;
        BOOL v14 = v103++ > 8;
        if (v14) {
          goto LABEL_143;
        }
      }
      if (*((unsigned char *)a2 + 24)) {
        uint64_t v67 = 0;
      }
LABEL_176:
      *((void *)this + 4) = v67;
    }
LABEL_181:
    unint64_t v2 = *((void *)a2 + 1);
    unint64_t v3 = *((void *)a2 + 2);
  }
  return i == 0;
}

void PB::PtrVector<statistics::Interval>::emplace_back<>()
{
}

void sub_1BCC23F68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t statistics::Statistics::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *(const PB::Base **)(this + 112);
  if (v4) {
    this = PB::Writer::writeSubmessage(a2, v4);
  }
  int v5 = *(_DWORD *)(v3 + 204);
  if (v5)
  {
    this = PB::Writer::writeVarInt(a2);
    int v5 = *(_DWORD *)(v3 + 204);
    if ((v5 & 0x400) == 0)
    {
LABEL_5:
      if ((v5 & 0x40) == 0) {
        goto LABEL_6;
      }
      goto LABEL_41;
    }
  }
  else if ((v5 & 0x400) == 0)
  {
    goto LABEL_5;
  }
  this = PB::Writer::write(a2, *(double *)(v3 + 152));
  int v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x40) == 0)
  {
LABEL_6:
    if ((v5 & 0x80) == 0) {
      goto LABEL_7;
    }
    goto LABEL_42;
  }
LABEL_41:
  this = PB::Writer::write(a2, *(double *)(v3 + 96));
  int v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x80) == 0)
  {
LABEL_7:
    if ((v5 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_43;
  }
LABEL_42:
  this = PB::Writer::write(a2, *(double *)(v3 + 104));
  int v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x20) == 0)
  {
LABEL_8:
    if ((v5 & 0x2000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_44;
  }
LABEL_43:
  this = PB::Writer::write(a2, *(double *)(v3 + 88));
  int v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x2000) == 0)
  {
LABEL_9:
    if ((v5 & 0x4000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_45;
  }
LABEL_44:
  this = PB::Writer::write(a2, *(double *)(v3 + 184));
  int v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x4000) == 0)
  {
LABEL_10:
    if ((v5 & 0x10) == 0) {
      goto LABEL_11;
    }
    goto LABEL_46;
  }
LABEL_45:
  this = PB::Writer::write(a2, *(double *)(v3 + 192));
  int v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x10) == 0)
  {
LABEL_11:
    if ((v5 & 8) == 0) {
      goto LABEL_12;
    }
    goto LABEL_47;
  }
LABEL_46:
  this = PB::Writer::write(a2, *(double *)(v3 + 56));
  int v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 8) == 0)
  {
LABEL_12:
    if ((v5 & 4) == 0) {
      goto LABEL_13;
    }
    goto LABEL_48;
  }
LABEL_47:
  this = PB::Writer::writeVarInt(a2);
  int v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 4) == 0)
  {
LABEL_13:
    if ((v5 & 0x800) == 0) {
      goto LABEL_14;
    }
LABEL_49:
    this = PB::Writer::writeVarInt(a2);
    if ((*(_DWORD *)(v3 + 204) & 0x1000) == 0) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_48:
  this = PB::Writer::write(a2, *(double *)(v3 + 40));
  int v5 = *(_DWORD *)(v3 + 204);
  if ((v5 & 0x800) != 0) {
    goto LABEL_49;
  }
LABEL_14:
  if ((v5 & 0x1000) != 0) {
LABEL_15:
  }
    this = PB::Writer::write(a2, *(double *)(v3 + 176));
LABEL_16:
  int v6 = *(const PB::Base ***)(v3 + 64);
  uint64_t v7 = *(const PB::Base ***)(v3 + 72);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    this = PB::Writer::writeSubmessage(a2, v8);
  }
  char v9 = *(const PB::Base **)(v3 + 160);
  if (v9) {
    this = PB::Writer::writeSubmessage(a2, v9);
  }
  int v10 = *(_DWORD *)(v3 + 204);
  if ((v10 & 0x100) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    int v10 = *(_DWORD *)(v3 + 204);
    if ((v10 & 2) == 0)
    {
LABEL_23:
      if ((v10 & 0x10000) == 0) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }
  }
  else if ((v10 & 2) == 0)
  {
    goto LABEL_23;
  }
  this = PB::Writer::writeVarInt(a2);
  if ((*(_DWORD *)(v3 + 204) & 0x10000) != 0) {
LABEL_24:
  }
    this = PB::Writer::write(a2);
LABEL_25:
  unint64_t v11 = *(const PB::Base **)(v3 + 120);
  if (v11) {
    this = PB::Writer::writeSubmessage(a2, v11);
  }
  int v12 = *(_DWORD *)(v3 + 204);
  if ((v12 & 0x8000) != 0)
  {
    this = PB::Writer::write(a2);
    int v12 = *(_DWORD *)(v3 + 204);
  }
  if ((v12 & 0x200) != 0) {
    this = PB::Writer::writeVarInt(a2);
  }
  if (*(void *)(v3 + 16)) {
    this = PB::Writer::write();
  }
  char v13 = *(const PB::Base **)(v3 + 128);
  if (v13) {
    this = PB::Writer::writeSubmessage(a2, v13);
  }
  BOOL v14 = *(const PB::Base **)(v3 + 8);
  if (v14)
  {
    return PB::Writer::writeSubmessage(a2, v14);
  }
  return this;
}

uint64_t statistics::Statistics::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v5 = *(void *)(a2 + 112);
  if (v4)
  {
    if (!v5 || !statistics::RawQuantitySample::operator==(v4, v5)) {
      return 0;
    }
  }
  else if (v5)
  {
    return 0;
  }
  int v6 = *(_DWORD *)(a1 + 204);
  int v7 = *(_DWORD *)(a2 + 204);
  if (v6)
  {
    if ((v7 & 1) == 0 || *(void *)(a1 + 24) != *(void *)(a2 + 24)) {
      return 0;
    }
  }
  else if (v7)
  {
    return 0;
  }
  if ((v6 & 0x400) != 0)
  {
    if ((v7 & 0x400) == 0 || *(double *)(a1 + 152) != *(double *)(a2 + 152)) {
      return 0;
    }
  }
  else if ((v7 & 0x400) != 0)
  {
    return 0;
  }
  if ((v6 & 0x40) != 0)
  {
    if ((v7 & 0x40) == 0 || *(double *)(a1 + 96) != *(double *)(a2 + 96)) {
      return 0;
    }
  }
  else if ((v7 & 0x40) != 0)
  {
    return 0;
  }
  if ((v6 & 0x80) != 0)
  {
    if ((v7 & 0x80) == 0 || *(double *)(a1 + 104) != *(double *)(a2 + 104)) {
      return 0;
    }
  }
  else if ((v7 & 0x80) != 0)
  {
    return 0;
  }
  if ((v6 & 0x20) != 0)
  {
    if ((v7 & 0x20) == 0 || *(double *)(a1 + 88) != *(double *)(a2 + 88)) {
      return 0;
    }
  }
  else if ((v7 & 0x20) != 0)
  {
    return 0;
  }
  if ((v6 & 0x2000) != 0)
  {
    if ((v7 & 0x2000) == 0 || *(double *)(a1 + 184) != *(double *)(a2 + 184)) {
      return 0;
    }
  }
  else if ((v7 & 0x2000) != 0)
  {
    return 0;
  }
  if ((v6 & 0x4000) != 0)
  {
    if ((v7 & 0x4000) == 0 || *(double *)(a1 + 192) != *(double *)(a2 + 192)) {
      return 0;
    }
  }
  else if ((v7 & 0x4000) != 0)
  {
    return 0;
  }
  if ((v6 & 0x10) != 0)
  {
    if ((v7 & 0x10) == 0 || *(double *)(a1 + 56) != *(double *)(a2 + 56)) {
      return 0;
    }
  }
  else if ((v7 & 0x10) != 0)
  {
    return 0;
  }
  if ((v6 & 8) != 0)
  {
    if ((v7 & 8) == 0 || *(void *)(a1 + 48) != *(void *)(a2 + 48)) {
      return 0;
    }
  }
  else if ((v7 & 8) != 0)
  {
    return 0;
  }
  if ((v6 & 4) != 0)
  {
    if ((v7 & 4) == 0 || *(double *)(a1 + 40) != *(double *)(a2 + 40)) {
      return 0;
    }
  }
  else if ((v7 & 4) != 0)
  {
    return 0;
  }
  if ((v6 & 0x800) != 0)
  {
    if ((v7 & 0x800) == 0 || *(void *)(a1 + 168) != *(void *)(a2 + 168)) {
      return 0;
    }
  }
  else if ((v7 & 0x800) != 0)
  {
    return 0;
  }
  if ((v6 & 0x1000) != 0)
  {
    if ((v7 & 0x1000) == 0 || *(double *)(a1 + 176) != *(double *)(a2 + 176)) {
      return 0;
    }
  }
  else if ((v7 & 0x1000) != 0)
  {
    return 0;
  }
  uint64_t result = PB::PtrVector<statistics::Interval>::operator==((uint64_t *)(a1 + 64), a2 + 64);
  if (!result) {
    return result;
  }
  uint64_t v9 = *(void *)(a1 + 160);
  uint64_t v10 = *(void *)(a2 + 160);
  if (v9)
  {
    if (!v10 || !statistics::RawQuantitySample::operator==(v9, v10)) {
      return 0;
    }
  }
  else if (v10)
  {
    return 0;
  }
  int v11 = *(_DWORD *)(a1 + 204);
  int v12 = *(_DWORD *)(a2 + 204);
  if ((v11 & 0x100) != 0)
  {
    if ((v12 & 0x100) == 0 || *(void *)(a1 + 136) != *(void *)(a2 + 136)) {
      return 0;
    }
  }
  else if ((v12 & 0x100) != 0)
  {
    return 0;
  }
  if ((v11 & 2) != 0)
  {
    if ((v12 & 2) == 0 || *(void *)(a1 + 32) != *(void *)(a2 + 32)) {
      return 0;
    }
  }
  else if ((v12 & 2) != 0)
  {
    return 0;
  }
  if ((v11 & 0x10000) != 0)
  {
    if ((v12 & 0x10000) == 0 || *(unsigned __int8 *)(a1 + 201) != *(unsigned __int8 *)(a2 + 201)) {
      return 0;
    }
  }
  else if ((v12 & 0x10000) != 0)
  {
    return 0;
  }
  uint64_t v13 = *(void *)(a1 + 120);
  uint64_t v14 = *(void *)(a2 + 120);
  if (v13)
  {
    if (!v14
      || !statistics::QuantityOverlapProcessorState::operator==(v13, v14)
      && *(void *)(a1 + 120) | *(void *)(a2 + 120))
    {
      return 0;
    }
  }
  else if (v14)
  {
    return 0;
  }
  int v15 = *(_DWORD *)(a1 + 204);
  int v16 = *(_DWORD *)(a2 + 204);
  if ((v15 & 0x8000) != 0)
  {
    if ((v16 & 0x8000) == 0 || *(unsigned __int8 *)(a1 + 200) != *(unsigned __int8 *)(a2 + 200)) {
      return 0;
    }
  }
  else if ((v16 & 0x8000) != 0)
  {
    return 0;
  }
  if ((v15 & 0x200) != 0)
  {
    if ((v16 & 0x200) == 0 || *(void *)(a1 + 144) != *(void *)(a2 + 144)) {
      return 0;
    }
  }
  else if ((v16 & 0x200) != 0)
  {
    return 0;
  }
  unint64_t v17 = *(unsigned __int8 **)(a1 + 16);
  char v18 = *(unsigned __int8 **)(a2 + 16);
  if (v17)
  {
    if (!v18 || !std::operator==[abi:ne180100]<std::allocator<char>>(v17, v18)) {
      return 0;
    }
  }
  else if (v18)
  {
    return 0;
  }
  uint64_t v19 = *(void *)(a2 + 128);
  if (*(void *)(a1 + 128))
  {
    if (!v19 || (statistics::Statistics::operator==() & 1) == 0 && *(void *)(a1 + 128) | *(void *)(a2 + 128)) {
      return 0;
    }
LABEL_114:
    if (!*(void *)(a1 + 8)) {
      return *(void *)(a2 + 8) == 0;
    }
    if (*(void *)(a2 + 8))
    {
      if (statistics::Statistics::operator==()) {
        return 1;
      }
      if (!*(void *)(a1 + 8)) {
        return *(void *)(a2 + 8) == 0;
      }
    }
    return 0;
  }
  if (!v19) {
    goto LABEL_114;
  }
  return 0;
}

BOOL PB::PtrVector<statistics::Interval>::operator==(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v4 = *(uint64_t **)a2;
  if (v3 - *a1 != *(void *)(a2 + 8) - *(void *)a2) {
    return 0;
  }
  if (v2 == v3) {
    return 1;
  }
  uint64_t v5 = v2 + 8;
  do
  {
    uint64_t v6 = *v4++;
    BOOL result = statistics::Interval::operator==(*(void *)(v5 - 8), v6);
    BOOL v8 = !result || v5 == v3;
    v5 += 8;
  }
  while (!v8);
  return result;
}

BOOL std::operator==[abi:ne180100]<std::allocator<char>>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1;
  }
  uint64_t v6 = v2 - 1;
  do
  {
    int v8 = *a1++;
    int v7 = v8;
    int v10 = *a2++;
    int v9 = v10;
    BOOL v12 = v6-- != 0;
    BOOL v13 = v7 == v9;
    BOOL v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

unint64_t statistics::Statistics::hash_value(statistics::Statistics *this)
{
  uint64_t v2 = (statistics::RawQuantitySample *)*((void *)this + 14);
  if (v2) {
    uint64_t v3 = statistics::RawQuantitySample::hash_value(v2);
  }
  else {
    uint64_t v3 = 0;
  }
  int v4 = *((_DWORD *)this + 51);
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = 0;
    if ((v4 & 0x400) != 0) {
      goto LABEL_6;
    }
LABEL_44:
    uint64_t v6 = 0;
    if ((v4 & 0x40) != 0) {
      goto LABEL_10;
    }
LABEL_45:
    uint64_t v7 = 0;
    if ((v4 & 0x80) != 0) {
      goto LABEL_14;
    }
LABEL_46:
    uint64_t v8 = 0;
    if ((v4 & 0x20) != 0) {
      goto LABEL_18;
    }
LABEL_47:
    uint64_t v9 = 0;
    if ((v4 & 0x2000) != 0) {
      goto LABEL_22;
    }
LABEL_48:
    uint64_t v10 = 0;
    if ((v4 & 0x4000) != 0) {
      goto LABEL_26;
    }
LABEL_49:
    uint64_t v11 = 0;
    if ((v4 & 0x10) != 0) {
      goto LABEL_30;
    }
LABEL_50:
    uint64_t v12 = 0;
    if ((v4 & 8) != 0) {
      goto LABEL_34;
    }
    goto LABEL_51;
  }
  uint64_t v5 = *((void *)this + 3);
  if ((v4 & 0x400) == 0) {
    goto LABEL_44;
  }
LABEL_6:
  if (*((double *)this + 19) == 0.0) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *((void *)this + 19);
  }
  if ((v4 & 0x40) == 0) {
    goto LABEL_45;
  }
LABEL_10:
  if (*((double *)this + 12) == 0.0) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *((void *)this + 12);
  }
  if ((v4 & 0x80) == 0) {
    goto LABEL_46;
  }
LABEL_14:
  if (*((double *)this + 13) == 0.0) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = *((void *)this + 13);
  }
  if ((v4 & 0x20) == 0) {
    goto LABEL_47;
  }
LABEL_18:
  if (*((double *)this + 11) == 0.0) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = *((void *)this + 11);
  }
  if ((v4 & 0x2000) == 0) {
    goto LABEL_48;
  }
LABEL_22:
  if (*((double *)this + 23) == 0.0) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = *((void *)this + 23);
  }
  if ((v4 & 0x4000) == 0) {
    goto LABEL_49;
  }
LABEL_26:
  if (*((double *)this + 24) == 0.0) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *((void *)this + 24);
  }
  if ((v4 & 0x10) == 0) {
    goto LABEL_50;
  }
LABEL_30:
  if (*((double *)this + 7) == 0.0) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = *((void *)this + 7);
  }
  if ((v4 & 8) != 0)
  {
LABEL_34:
    uint64_t v13 = *((void *)this + 6);
    if ((v4 & 4) != 0) {
      goto LABEL_35;
    }
LABEL_52:
    uint64_t v14 = 0;
    if ((v4 & 0x800) != 0) {
      goto LABEL_39;
    }
    goto LABEL_53;
  }
LABEL_51:
  uint64_t v13 = 0;
  if ((v4 & 4) == 0) {
    goto LABEL_52;
  }
LABEL_35:
  if (*((double *)this + 5) == 0.0) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = *((void *)this + 5);
  }
  if ((v4 & 0x800) != 0)
  {
LABEL_39:
    uint64_t v15 = *((void *)this + 21);
    if ((v4 & 0x1000) != 0) {
      goto LABEL_40;
    }
LABEL_54:
    uint64_t v16 = 0;
    goto LABEL_55;
  }
LABEL_53:
  uint64_t v15 = 0;
  if ((v4 & 0x1000) == 0) {
    goto LABEL_54;
  }
LABEL_40:
  if (*((double *)this + 22) == 0.0) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = *((void *)this + 22);
  }
LABEL_55:
  unint64_t v17 = (uint64_t *)*((void *)this + 8);
  char v18 = (uint64_t *)*((void *)this + 9);
  uint64_t v129 = v12;
  uint64_t v130 = v11;
  for (uint64_t i = 0; v17 != v18; ++v17)
  {
    uint64_t v20 = *v17;
    if ((*(unsigned char *)(*v17 + 24) & 2) != 0)
    {
      double v21 = *(double *)(v20 + 16);
      if (v21 == 0.0) {
        double v21 = 0.0;
      }
      if (*(unsigned char *)(*v17 + 24))
      {
LABEL_58:
        double v22 = *(double *)(v20 + 8);
        if (v22 == 0.0) {
          double v22 = 0.0;
        }
        goto LABEL_65;
      }
    }
    else
    {
      double v21 = 0.0;
      if (*(unsigned char *)(*v17 + 24)) {
        goto LABEL_58;
      }
    }
    double v22 = 0.0;
LABEL_65:
    i ^= *(void *)&v21 ^ *(void *)&v22;
  }
  uint64_t v23 = (statistics::RawQuantitySample *)*((void *)this + 20);
  uint64_t v127 = v14;
  uint64_t v128 = v13;
  uint64_t v125 = v16;
  uint64_t v126 = v15;
  if (v23)
  {
    uint64_t v24 = statistics::RawQuantitySample::hash_value(v23);
    if ((v4 & 0x100) == 0) {
      goto LABEL_68;
    }
  }
  else
  {
    uint64_t v24 = 0;
    if ((v4 & 0x100) == 0)
    {
LABEL_68:
      uint64_t v25 = 0;
      if ((v4 & 2) != 0) {
        goto LABEL_69;
      }
LABEL_73:
      uint64_t v26 = 0;
      if ((v4 & 0x10000) != 0) {
        goto LABEL_70;
      }
      goto LABEL_74;
    }
  }
  uint64_t v25 = *((void *)this + 17);
  if ((v4 & 2) == 0) {
    goto LABEL_73;
  }
LABEL_69:
  uint64_t v26 = *((void *)this + 4);
  if ((v4 & 0x10000) != 0)
  {
LABEL_70:
    uint64_t v27 = *((unsigned __int8 *)this + 201);
    goto LABEL_75;
  }
LABEL_74:
  uint64_t v27 = 0;
LABEL_75:
  char v28 = (statistics::QuantityOverlapProcessorState *)*((void *)this + 15);
  uint64_t v123 = v25;
  uint64_t v124 = v24;
  uint64_t v121 = v27;
  uint64_t v122 = v26;
  if (v28)
  {
    char v28 = (statistics::QuantityOverlapProcessorState *)statistics::QuantityOverlapProcessorState::hash_value(v28);
    int v4 = *((_DWORD *)this + 51);
  }
  if ((v4 & 0x8000) != 0)
  {
    uint64_t v29 = *((unsigned __int8 *)this + 200);
    if ((v4 & 0x200) != 0) {
      goto LABEL_79;
    }
  }
  else
  {
    uint64_t v29 = 0;
    if ((v4 & 0x200) != 0)
    {
LABEL_79:
      uint64_t v30 = *((void *)this + 18);
      goto LABEL_82;
    }
  }
  uint64_t v30 = 0;
LABEL_82:
  unint64_t v31 = (unsigned __int8 *)*((void *)this + 2);
  uint64_t v132 = v9;
  v133 = v28;
  uint64_t v131 = v8;
  if (!v31)
  {
    uint64_t v34 = v5;
    uint64_t v35 = v3;
    unint64_t v39 = 0;
    goto LABEL_99;
  }
  unint64_t v32 = *((void *)v31 + 1);
  if ((v31[23] & 0x80u) == 0)
  {
    unint64_t v33 = v31[23];
  }
  else
  {
    unint64_t v31 = *(unsigned __int8 **)v31;
    unint64_t v33 = v32;
  }
  uint64_t v34 = v5;
  uint64_t v35 = v3;
  if (v33 > 0x20)
  {
    if (v33 > 0x40)
    {
      unint64_t v65 = 0x9DDFEA08EB382D69;
      uint64_t v75 = *(void *)&v31[v33 - 48];
      uint64_t v74 = *(void *)&v31[v33 - 40];
      uint64_t v76 = *(void *)&v31[v33 - 24];
      uint64_t v78 = *(void *)&v31[v33 - 64];
      uint64_t v77 = *(void *)&v31[v33 - 56];
      uint64_t v79 = *(void *)&v31[v33 - 16];
      uint64_t v80 = *(void *)&v31[v33 - 8];
      unint64_t v81 = v77 + v79;
      unint64_t v82 = 0x9DDFEA08EB382D69
          * (v76 ^ ((0x9DDFEA08EB382D69 * (v76 ^ (v75 + v33))) >> 47) ^ (0x9DDFEA08EB382D69 * (v76 ^ (v75 + v33))));
      unint64_t v83 = 0x9DDFEA08EB382D69 * (v82 ^ (v82 >> 47));
      unint64_t v84 = v75 + v77 + v78 + v33;
      uint64_t v85 = v84 + v74;
      unint64_t v86 = __ROR8__(v84, 44) + v78 + v33 + __ROR8__(v78 + v33 + v74 - 0x622015F714C7D297 * (v82 ^ (v82 >> 47)), 21);
      uint64_t v87 = v77 + v79 + *(void *)&v31[v33 - 32] - 0x4B6D499041670D8DLL;
      uint64_t v88 = v76 + v79 + v87;
      uint64_t v89 = __ROR8__(v88, 44);
      uint64_t v90 = v88 + v80;
      uint64_t v91 = v89 + v87 + __ROR8__(v87 + v74 + v80, 21);
      uint64_t v93 = *(void *)v31;
      unint64_t v92 = v31 + 32;
      unint64_t v94 = v93 - 0x4B6D499041670D8DLL * v74;
      uint64_t v95 = -(uint64_t)((v33 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        uint64_t v96 = *(v92 - 3);
        uint64_t v97 = v94 + v85 + v81 + v96;
        uint64_t v98 = v92[2];
        uint64_t v99 = v92[3];
        uint64_t v100 = v92[1];
        unint64_t v81 = v100 + v85 - 0x4B6D499041670D8DLL * __ROR8__(v81 + v86 + v98, 42);
        uint64_t v101 = v83 + v90;
        uint64_t v102 = *(v92 - 2);
        uint64_t v103 = *(v92 - 1);
        uint64_t v104 = *(v92 - 4) - 0x4B6D499041670D8DLL * v86;
        uint64_t v105 = v104 + v90 + v103;
        uint64_t v106 = v104 + v96 + v102;
        uint64_t v85 = v106 + v103;
        uint64_t v107 = __ROR8__(v106, 44) + v104;
        unint64_t v108 = (0xB492B66FBE98F273 * __ROR8__(v97, 37)) ^ v91;
        unint64_t v94 = 0xB492B66FBE98F273 * __ROR8__(v101, 33);
        unint64_t v86 = v107 + __ROR8__(v105 + v108, 21);
        unint64_t v109 = v94 + v91 + *v92;
        uint64_t v90 = v100 + v98 + v109 + v99;
        uint64_t v91 = __ROR8__(v100 + v98 + v109, 44) + v109 + __ROR8__(v81 + v102 + v109 + v99, 21);
        v92 += 8;
        unint64_t v83 = v108;
        v95 += 64;
      }
      while (v95);
      unint64_t v110 = 0x9DDFEA08EB382D69
           * (v90 ^ ((0x9DDFEA08EB382D69 * (v90 ^ v85)) >> 47) ^ (0x9DDFEA08EB382D69 * (v90 ^ v85)));
      unint64_t v111 = v94
           - 0x622015F714C7D297
           * ((0x9DDFEA08EB382D69
             * (v91 ^ ((0x9DDFEA08EB382D69 * (v91 ^ v86)) >> 47) ^ (0x9DDFEA08EB382D69 * (v91 ^ v86)))) ^ ((0x9DDFEA08EB382D69 * (v91 ^ ((0x9DDFEA08EB382D69 * (v91 ^ v86)) >> 47) ^ (0x9DDFEA08EB382D69 * (v91 ^ v86)))) >> 47));
      unint64_t v112 = 0x9DDFEA08EB382D69
           * (v111 ^ (v108 - 0x4B6D499041670D8DLL * (v81 ^ (v81 >> 47)) - 0x622015F714C7D297 * (v110 ^ (v110 >> 47))));
      unint64_t v66 = 0x9DDFEA08EB382D69 * (v111 ^ (v112 >> 47) ^ v112);
    }
    else
    {
      unsigned int v40 = &v31[v33];
      uint64_t v41 = *(void *)&v31[v33 - 16];
      uint64_t v42 = *(void *)&v31[v33 - 8];
      uint64_t v43 = *((void *)v31 + 1);
      uint64_t v44 = *(void *)v31 - 0x3C5A37A36834CED9 * (v41 + v33);
      uint64_t v47 = v31 + 16;
      uint64_t v45 = *((void *)v31 + 2);
      uint64_t v46 = *((void *)v47 + 1);
      uint64_t v48 = __ROR8__(v44 + v46, 52);
      uint64_t v49 = __ROR8__(v44, 37);
      uint64_t v50 = v44 + v43;
      uint64_t v51 = __ROR8__(v50, 7);
      uint64_t v52 = v50 + v45;
      uint64_t v53 = v51 + v49;
      uint64_t v54 = *((void *)v40 - 4) + v45;
      uint64_t v55 = v42 + v46;
      uint64_t v56 = __ROR8__(v55 + v54, 52);
      uint64_t v57 = v53 + v48;
      uint64_t v58 = __ROR8__(v54, 37);
      uint64_t v59 = *((void *)v40 - 3) + v54;
      uint64_t v60 = __ROR8__(v59, 7);
      uint64_t v61 = v57 + __ROR8__(v52, 31);
      uint64_t v62 = v59 + v41;
      uint64_t v63 = v62 + v55;
      uint64_t v64 = v52 + v46 + v58 + v60 + v56 + __ROR8__(v62, 31);
      unint64_t v65 = 0x9AE16A3B2F90404FLL;
      unint64_t v66 = v61
          - 0x3C5A37A36834CED9
          * ((0xC3A5C85C97CB3127 * (v63 + v61) - 0x651E95C4D06FBFB1 * v64) ^ ((0xC3A5C85C97CB3127 * (v63 + v61)
                                                                                 - 0x651E95C4D06FBFB1 * v64) >> 47));
    }
    unint64_t v39 = (v66 ^ (v66 >> 47)) * v65;
  }
  else
  {
    if (v33 > 0x10)
    {
      uint64_t v67 = *((void *)v31 + 1);
      unint64_t v68 = 0xB492B66FBE98F273 * *(void *)v31;
      unint64_t v69 = 0x9AE16A3B2F90404FLL * *(void *)&v31[v33 - 8];
      uint64_t v70 = __ROR8__(v69, 30) + __ROR8__(v68 - v67, 43);
      unint64_t v71 = v68 + v33 + __ROR8__(v67 ^ 0xC949D7C7509E6557, 20) - v69;
      unint64_t v72 = 0x9DDFEA08EB382D69 * ((v70 - 0x3C5A37A36834CED9 * *(void *)&v31[v33 - 16]) ^ v71);
      unint64_t v73 = v71 ^ (v72 >> 47) ^ v72;
LABEL_94:
      unint64_t v39 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v73) ^ ((0x9DDFEA08EB382D69 * v73) >> 47));
      goto LABEL_99;
    }
    if (v33 >= 9)
    {
      uint64_t v36 = *(void *)v31;
      uint64_t v37 = *(void *)&v31[v33 - 8];
      uint64_t v38 = __ROR8__(v37 + v33, v33);
      unint64_t v39 = (0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69
             * (v38 ^ ((0x9DDFEA08EB382D69 * (v38 ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * (v38 ^ v36)))) ^ ((0x9DDFEA08EB382D69 * (v38 ^ ((0x9DDFEA08EB382D69 * (v38 ^ v36)) >> 47) ^ (0x9DDFEA08EB382D69 * (v38 ^ v36)))) >> 47))) ^ v37;
      goto LABEL_99;
    }
    if (v33 >= 4)
    {
      int v117 = *(_DWORD *)v31;
      uint64_t v118 = *(unsigned int *)&v31[v33 - 4];
      unint64_t v119 = 0x9DDFEA08EB382D69 * ((v33 + (8 * v117)) ^ v118);
      unint64_t v73 = v118 ^ (v119 >> 47) ^ v119;
      goto LABEL_94;
    }
    unint64_t v39 = 0x9AE16A3B2F90404FLL;
    if (v33)
    {
      unint64_t v120 = (0xC949D7C7509E6557 * (v33 + 4 * v31[v33 - 1])) ^ (0x9AE16A3B2F90404FLL
                                                                  * (*v31 | ((unint64_t)v31[v33 >> 1] << 8)));
      unint64_t v39 = 0x9AE16A3B2F90404FLL * (v120 ^ (v120 >> 47));
    }
  }
LABEL_99:
  unint64_t v113 = (statistics::Statistics *)*((void *)this + 16);
  if (v113) {
    uint64_t v114 = statistics::Statistics::hash_value(v113);
  }
  else {
    uint64_t v114 = 0;
  }
  unint64_t v115 = *((void *)this + 1);
  if (v115) {
    unint64_t v115 = statistics::Statistics::hash_value((statistics::Statistics *)v115);
  }
  return v34 ^ v35 ^ v6 ^ v7 ^ v131 ^ v132 ^ v10 ^ v130 ^ v129 ^ v128 ^ v127 ^ v126 ^ v125 ^ i ^ v124 ^ v123 ^ v122 ^ v121 ^ (unint64_t)v133 ^ v29 ^ v30 ^ v39 ^ v114 ^ v115;
}

uint64_t statistics::Statistics::makeMostRecentDatum(uint64_t this)
{
  if (!*(void *)(this + 112)) {
    operator new();
  }
  return this;
}

uint64_t statistics::Statistics::makeUnfinishedDatum(uint64_t this)
{
  if (!*(void *)(this + 160)) {
    operator new();
  }
  return this;
}

uint64_t statistics::Statistics::makeOverlapProcessorState(uint64_t this)
{
  if (!*(void *)(this + 120)) {
    operator new();
  }
  return this;
}

uint64_t statistics::Statistics::makePrimaryStatistics(uint64_t this)
{
  if (!*(void *)(this + 128)) {
    operator new();
  }
  return this;
}

uint64_t statistics::Statistics::makeAuxiliaryStatistics(uint64_t this)
{
  if (!*(void *)(this + 8)) {
    operator new();
  }
  return this;
}

void std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<statistics::Interval>>::__clear[abi:ne180100](v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void *std::vector<std::unique_ptr<statistics::Interval>>::__clear[abi:ne180100](void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = (void *)*result;
  uint64_t v3 = (void *)result[1];
  while (v3 != v2)
  {
    int v4 = (void *)*--v3;
    BOOL result = v4;
    void *v3 = 0;
    if (v4) {
      BOOL result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  v1[1] = v2;
  return result;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  uint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    uint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E62F22B0, MEMORY[0x1E4FBA1C8]);
}

void sub_1BCC253DC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  BOOL result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

void std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate(void **a1)
{
  if (*a1)
  {
    std::vector<std::unique_ptr<statistics::Interval>>::__clear[abi:ne180100](a1);
    operator delete(*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::default_delete<std::string>::operator()[abi:ne180100](uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }

  JUMPOUT(0x1C187B8A0);
}

uint64_t std::vector<std::unique_ptr<statistics::Interval>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Interval>>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  id v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    uint64_t v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::Interval>>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::Interval>>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::Interval>>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

void *std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::Interval>>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>>::operator()[abi:ne180100](void *result)
{
  uint64_t v1 = *(void ***)(result[2] + 8);
  uint64_t v2 = *(void ***)(result[1] + 8);
  while (v1 != v2)
  {
    uint64_t result = *v1;
    std::bad_array_new_length *v1 = 0;
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
    ++v1;
  }
  return result;
}

void **std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *std::__split_buffer<std::unique_ptr<statistics::Interval>>::__destruct_at_end[abi:ne180100](void *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2 != a2)
  {
    int v4 = result;
    do
    {
      v4[2] = v2 - 8;
      uint64_t result = *(void **)(v2 - 8);
      *(void *)(v2 - 8) = 0;
      if (result) {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
      uint64_t v2 = v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

double statistics::StatisticsBucket::StatisticsBucket(statistics::StatisticsBucket *this)
{
  *(void *)this = &unk_1F171B9C8;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 47) = 0;
  double result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_1F171B9C8;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 47) = 0;
  double result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = 0;
  return result;
}

void statistics::StatisticsBucket::~StatisticsBucket(statistics::StatisticsBucket *this)
{
  *(void *)this = &unk_1F171B9C8;
  uint64_t v3 = (void **)((char *)this + 160);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)((char *)this + 136);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)((char *)this + 112);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v2 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (void **)((char *)this + 80);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

{
  uint64_t vars8;

  statistics::StatisticsBucket::~StatisticsBucket(this);

  JUMPOUT(0x1C187B8A0);
}

uint64_t statistics::StatisticsBucket::StatisticsBucket(uint64_t this, const statistics::StatisticsBucket *a2)
{
  *(void *)this = &unk_1F171B9C8;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 56) = 0;
  *(_OWORD *)(this + 80) = 0u;
  *(_OWORD *)(this + 112) = 0u;
  *(_OWORD *)(this + 160) = 0u;
  *(_DWORD *)(this + 188) = 0;
  *(_OWORD *)(this + 96) = 0u;
  *(_OWORD *)(this + 128) = 0u;
  *(_OWORD *)(this + 144) = 0u;
  *(void *)(this + 176) = 0;
  __int16 v2 = *((_WORD *)a2 + 94);
  if ((v2 & 2) != 0)
  {
    uint64_t v4 = *((void *)a2 + 2);
    __int16 v3 = 2;
    *(_WORD *)(this + 188) = 2;
    *(void *)(this + 16) = v4;
    __int16 v2 = *((_WORD *)a2 + 94);
    if ((v2 & 1) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  __int16 v3 = 0;
  if (v2)
  {
LABEL_5:
    uint64_t v5 = *((void *)a2 + 1);
    v3 |= 1u;
    *(_WORD *)(this + 188) = v3;
    *(void *)(this + 8) = v5;
    __int16 v2 = *((_WORD *)a2 + 94);
  }
LABEL_6:
  if ((v2 & 0x10) != 0)
  {
    uint64_t v7 = *((void *)a2 + 8);
    v3 |= 0x10u;
    *(_WORD *)(this + 188) = v3;
    *(void *)(this + 64) = v7;
    __int16 v2 = *((_WORD *)a2 + 94);
    if ((v2 & 0x80) == 0)
    {
LABEL_8:
      if ((v2 & 0x200) == 0) {
        goto LABEL_9;
      }
      goto LABEL_30;
    }
  }
  else if ((v2 & 0x80) == 0)
  {
    goto LABEL_8;
  }
  char v8 = *((unsigned char *)a2 + 185);
  v3 |= 0x80u;
  *(_WORD *)(this + 188) = v3;
  *(unsigned char *)(this + 185) = v8;
  __int16 v2 = *((_WORD *)a2 + 94);
  if ((v2 & 0x200) == 0)
  {
LABEL_9:
    if ((v2 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_31;
  }
LABEL_30:
  char v9 = *((unsigned char *)a2 + 187);
  v3 |= 0x200u;
  *(_WORD *)(this + 188) = v3;
  *(unsigned char *)(this + 187) = v9;
  __int16 v2 = *((_WORD *)a2 + 94);
  if ((v2 & 0x100) == 0)
  {
LABEL_10:
    if ((v2 & 0x40) == 0) {
      goto LABEL_11;
    }
    goto LABEL_32;
  }
LABEL_31:
  char v10 = *((unsigned char *)a2 + 186);
  v3 |= 0x100u;
  *(_WORD *)(this + 188) = v3;
  *(unsigned char *)(this + 186) = v10;
  __int16 v2 = *((_WORD *)a2 + 94);
  if ((v2 & 0x40) == 0)
  {
LABEL_11:
    if ((v2 & 8) == 0) {
      goto LABEL_12;
    }
    goto LABEL_33;
  }
LABEL_32:
  char v11 = *((unsigned char *)a2 + 184);
  v3 |= 0x40u;
  *(_WORD *)(this + 188) = v3;
  *(unsigned char *)(this + 184) = v11;
  __int16 v2 = *((_WORD *)a2 + 94);
  if ((v2 & 8) == 0)
  {
LABEL_12:
    if ((v2 & 4) == 0) {
      goto LABEL_13;
    }
    goto LABEL_34;
  }
LABEL_33:
  uint64_t v12 = *((void *)a2 + 4);
  v3 |= 8u;
  *(_WORD *)(this + 188) = v3;
  *(void *)(this + 32) = v12;
  __int16 v2 = *((_WORD *)a2 + 94);
  if ((v2 & 4) == 0)
  {
LABEL_13:
    if ((v2 & 0x20) == 0) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
LABEL_34:
  uint64_t v13 = *((void *)a2 + 3);
  v3 |= 4u;
  *(_WORD *)(this + 188) = v3;
  *(void *)(this + 24) = v13;
  if ((*((_WORD *)a2 + 94) & 0x20) != 0)
  {
LABEL_14:
    uint64_t v6 = *((void *)a2 + 9);
    *(_WORD *)(this + 188) = v3 | 0x20;
    *(void *)(this + 72) = v6;
  }
LABEL_15:
  if (*((void *)a2 + 10) != *((void *)a2 + 11)) {
    PB::PtrVector<statistics::RawQuantitySample>::emplace_back<statistics::RawQuantitySample const&>();
  }
  if (*((void *)a2 + 13)) {
    operator new();
  }
  if (*((void *)a2 + 20) != *((void *)a2 + 21)) {
    PB::PtrVector<statistics::Statistics>::emplace_back<statistics::Statistics const&>();
  }
  if (*((void *)a2 + 14) != *((void *)a2 + 15)) {
    PB::PtrVector<statistics::Statistics>::emplace_back<statistics::Statistics const&>();
  }
  if (*((void *)a2 + 17) != *((void *)a2 + 18)) {
    PB::PtrVector<statistics::Statistics>::emplace_back<statistics::Statistics const&>();
  }
  if (*((void *)a2 + 5) != *((void *)a2 + 6)) {
    PB::PtrVector<statistics::Interval>::emplace_back<statistics::Interval const&>();
  }
  return this;
}

void PB::PtrVector<statistics::RawQuantitySample>::emplace_back<statistics::RawQuantitySample const&>()
{
}

void sub_1BCC25CEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void PB::PtrVector<statistics::Statistics>::emplace_back<statistics::Statistics const&>()
{
}

void sub_1BCC25E34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

statistics *statistics::StatisticsBucket::operator=(statistics *a1, const statistics::StatisticsBucket *a2)
{
  if (a1 != a2)
  {
    statistics::StatisticsBucket::StatisticsBucket((uint64_t)v5, a2);
    statistics::swap(a1, (statistics::StatisticsBucket *)v5, v3);
    statistics::StatisticsBucket::~StatisticsBucket((statistics::StatisticsBucket *)v5);
  }
  return a1;
}

double statistics::swap(statistics *this, statistics::StatisticsBucket *a2, statistics::StatisticsBucket *a3)
{
  int v3 = *((_DWORD *)this + 47);
  *((_DWORD *)this + 47) = *((_DWORD *)a2 + 47);
  *((_DWORD *)a2 + 47) = v3;
  uint64_t v4 = *((void *)this + 2);
  *((void *)this + 2) = *((void *)a2 + 2);
  *((void *)a2 + 2) = v4;
  uint64_t v5 = *((void *)this + 1);
  *((void *)this + 1) = *((void *)a2 + 1);
  *((void *)a2 + 1) = v5;
  uint64_t v6 = *((void *)this + 8);
  *((void *)this + 8) = *((void *)a2 + 8);
  *((void *)a2 + 8) = v6;
  LOBYTE(v3) = *((unsigned char *)this + 185);
  *((unsigned char *)this + 185) = *((unsigned char *)a2 + 185);
  *((unsigned char *)a2 + 185) = v3;
  LOBYTE(v3) = *((unsigned char *)this + 187);
  *((unsigned char *)this + 187) = *((unsigned char *)a2 + 187);
  *((unsigned char *)a2 + 187) = v3;
  LOBYTE(v3) = *((unsigned char *)this + 186);
  *((unsigned char *)this + 186) = *((unsigned char *)a2 + 186);
  *((unsigned char *)a2 + 186) = v3;
  LOBYTE(v3) = *((unsigned char *)this + 184);
  *((unsigned char *)this + 184) = *((unsigned char *)a2 + 184);
  *((unsigned char *)a2 + 184) = v3;
  uint64_t v7 = *((void *)this + 4);
  *((void *)this + 4) = *((void *)a2 + 4);
  *((void *)a2 + 4) = v7;
  uint64_t v8 = *((void *)this + 3);
  *((void *)this + 3) = *((void *)a2 + 3);
  *((void *)a2 + 3) = v8;
  double result = *((double *)this + 9);
  *((void *)this + 9) = *((void *)a2 + 9);
  *((double *)a2 + 9) = result;
  uint64_t v10 = *((void *)this + 10);
  *((void *)this + 10) = *((void *)a2 + 10);
  *((void *)a2 + 10) = v10;
  uint64_t v11 = *((void *)this + 11);
  *((void *)this + 11) = *((void *)a2 + 11);
  *((void *)a2 + 11) = v11;
  uint64_t v12 = *((void *)this + 12);
  *((void *)this + 12) = *((void *)a2 + 12);
  *((void *)a2 + 12) = v12;
  uint64_t v13 = *((void *)this + 13);
  *((void *)this + 13) = *((void *)a2 + 13);
  *((void *)a2 + 13) = v13;
  uint64_t v14 = *((void *)this + 20);
  *((void *)this + 20) = *((void *)a2 + 20);
  *((void *)a2 + 20) = v14;
  uint64_t v15 = *((void *)this + 21);
  *((void *)this + 21) = *((void *)a2 + 21);
  *((void *)a2 + 21) = v15;
  uint64_t v16 = *((void *)this + 22);
  *((void *)this + 22) = *((void *)a2 + 22);
  *((void *)a2 + 22) = v16;
  uint64_t v17 = *((void *)this + 14);
  *((void *)this + 14) = *((void *)a2 + 14);
  *((void *)a2 + 14) = v17;
  uint64_t v18 = *((void *)this + 15);
  *((void *)this + 15) = *((void *)a2 + 15);
  *((void *)a2 + 15) = v18;
  uint64_t v19 = *((void *)this + 16);
  *((void *)this + 16) = *((void *)a2 + 16);
  *((void *)a2 + 16) = v19;
  uint64_t v20 = *((void *)this + 17);
  *((void *)this + 17) = *((void *)a2 + 17);
  *((void *)a2 + 17) = v20;
  uint64_t v21 = *((void *)this + 18);
  *((void *)this + 18) = *((void *)a2 + 18);
  *((void *)a2 + 18) = v21;
  uint64_t v22 = *((void *)this + 19);
  *((void *)this + 19) = *((void *)a2 + 19);
  *((void *)a2 + 19) = v22;
  uint64_t v23 = *((void *)this + 5);
  *((void *)this + 5) = *((void *)a2 + 5);
  *((void *)a2 + 5) = v23;
  uint64_t v24 = *((void *)this + 6);
  *((void *)this + 6) = *((void *)a2 + 6);
  *((void *)a2 + 6) = v24;
  uint64_t v25 = *((void *)this + 7);
  *((void *)this + 7) = *((void *)a2 + 7);
  *((void *)a2 + 7) = v25;
  return result;
}

uint64_t statistics::StatisticsBucket::StatisticsBucket(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F171B9C8;
  *(void *)(a1 + 40) = 0;
  uint64_t v4 = (void **)(a1 + 40);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  uint64_t v5 = (_OWORD *)(a1 + 80);
  *(void *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 188) = *(_DWORD *)(a2 + 188);
  *(_DWORD *)(a2 + 188) = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(unsigned char *)(a1 + 185) = *(unsigned char *)(a2 + 185);
  *(unsigned char *)(a1 + 187) = *(unsigned char *)(a2 + 187);
  *(unsigned char *)(a1 + 186) = *(unsigned char *)(a2 + 186);
  *(unsigned char *)(a1 + 184) = *(unsigned char *)(a2 + 184);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate((void **)(a1 + 80));
  *uint64_t v5 = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  uint64_t v6 = *(void *)(a2 + 104);
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  uint64_t v7 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = v6;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate((void **)(a1 + 160));
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(void *)(a2 + 160) = 0;
  *(void *)(a2 + 168) = 0;
  *(void *)(a2 + 176) = 0;
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate((void **)(a1 + 112));
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate((void **)(a1 + 136));
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 152) = 0;
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate(v4);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return a1;
}

statistics *statistics::StatisticsBucket::operator=(statistics *a1, uint64_t a2)
{
  if (a1 != (statistics *)a2)
  {
    statistics::StatisticsBucket::StatisticsBucket((uint64_t)v5, a2);
    statistics::swap(a1, (statistics::StatisticsBucket *)v5, v3);
    statistics::StatisticsBucket::~StatisticsBucket((statistics::StatisticsBucket *)v5);
  }
  return a1;
}

uint64_t statistics::StatisticsBucket::formatText(statistics::StatisticsBucket *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  __int16 v5 = *((_WORD *)this + 94);
  if (v5)
  {
    PB::TextFormatter::format(a2, "bucketEndTime", *((double *)this + 1));
    __int16 v5 = *((_WORD *)this + 94);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_32;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "bucketStartTime", *((double *)this + 2));
  __int16 v5 = *((_WORD *)this + 94);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_33;
  }
LABEL_32:
  PB::TextFormatter::format(a2, "dataEndTime", *((double *)this + 3));
  __int16 v5 = *((_WORD *)this + 94);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x40) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_33:
  PB::TextFormatter::format(a2, "dataStartTime", *((double *)this + 4));
  if ((*((_WORD *)this + 94) & 0x40) != 0) {
LABEL_6:
  }
    PB::TextFormatter::format(a2, "inclusiveEndTimeBoundary");
LABEL_7:
  uint64_t v6 = (uint64_t *)*((void *)this + 5);
  uint64_t v7 = (uint64_t *)*((void *)this + 6);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "maskedIntervals");
  }
  __int16 v9 = *((_WORD *)this + 94);
  if ((v9 & 0x10) != 0)
  {
    PB::TextFormatter::format(a2, "mergeGranularity", *((double *)this + 8));
    __int16 v9 = *((_WORD *)this + 94);
  }
  if ((v9 & 0x20) != 0) {
    PB::TextFormatter::format(a2, "mergePoint", *((double *)this + 9));
  }
  uint64_t v10 = (uint64_t *)*((void *)this + 10);
  uint64_t v11 = (uint64_t *)*((void *)this + 11);
  while (v10 != v11)
  {
    uint64_t v12 = *v10++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v12 + 32))(v12, a2, "remainders");
  }
  __int16 v13 = *((_WORD *)this + 94);
  if ((v13 & 0x80) != 0)
  {
    PB::TextFormatter::format(a2, "shouldCombineSources");
    __int16 v13 = *((_WORD *)this + 94);
    if ((v13 & 0x100) == 0)
    {
LABEL_17:
      if ((v13 & 0x200) == 0) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
  }
  else if ((*((_WORD *)this + 94) & 0x100) == 0)
  {
    goto LABEL_17;
  }
  PB::TextFormatter::format(a2, "shouldComputePerBundleIDStatistics");
  if ((*((_WORD *)this + 94) & 0x200) != 0) {
LABEL_18:
  }
    PB::TextFormatter::format(a2, "shouldComputePerSourceIDStatistics");
LABEL_19:
  uint64_t v14 = *((void *)this + 13);
  if (v14) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v14 + 32))(v14, a2, "statistics");
  }
  uint64_t v15 = (uint64_t *)*((void *)this + 14);
  uint64_t v16 = (uint64_t *)*((void *)this + 15);
  while (v15 != v16)
  {
    uint64_t v17 = *v15++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v17 + 32))(v17, a2, "statisticsByBundleIdentifier");
  }
  uint64_t v18 = (uint64_t *)*((void *)this + 17);
  uint64_t v19 = (uint64_t *)*((void *)this + 18);
  while (v18 != v19)
  {
    uint64_t v20 = *v18++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v20 + 32))(v20, a2, "statisticsByCanonicalSourceID");
  }
  uint64_t v21 = (uint64_t *)*((void *)this + 20);
  uint64_t v22 = (uint64_t *)*((void *)this + 21);
  while (v21 != v22)
  {
    uint64_t v23 = *v21++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v23 + 32))(v23, a2, "statisticsBySourceID");
  }

  return MEMORY[0x1F4147498](a2);
}

uint64_t statistics::StatisticsBucket::readFrom(statistics::StatisticsBucket *this, PB::Reader *a2)
{
  unint64_t v2 = *((void *)a2 + 1);
  unint64_t v3 = *((void *)a2 + 2);
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)a2;
    if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
      break;
    }
    char v9 = 0;
    unsigned int v10 = 0;
    unint64_t v11 = 0;
    while (1)
    {
      unint64_t v12 = v2 + 1;
      *((void *)a2 + 1) = v2 + 1;
      char v13 = *(unsigned char *)(v8 + v2);
      v11 |= (unint64_t)(v13 & 0x7F) << v9;
      if ((v13 & 0x80) == 0) {
        break;
      }
      v9 += 7;
      unint64_t v2 = v12;
      BOOL v14 = v10++ > 8;
      if (v14) {
        goto LABEL_19;
      }
    }
LABEL_21:
    if ((v11 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        *((_WORD *)this + 94) |= 2u;
        unint64_t v21 = *((void *)a2 + 1);
        if (v21 > 0xFFFFFFFFFFFFFFF7 || v21 + 8 > *((void *)a2 + 2)) {
          goto LABEL_52;
        }
        *((void *)this + 2) = *(void *)(*(void *)a2 + v21);
        goto LABEL_66;
      case 2u:
        *((_WORD *)this + 94) |= 1u;
        unint64_t v22 = *((void *)a2 + 1);
        if (v22 > 0xFFFFFFFFFFFFFFF7 || v22 + 8 > *((void *)a2 + 2)) {
          goto LABEL_52;
        }
        *((void *)this + 1) = *(void *)(*(void *)a2 + v22);
        goto LABEL_66;
      case 3u:
        *((_WORD *)this + 94) |= 0x10u;
        unint64_t v23 = *((void *)a2 + 1);
        if (v23 > 0xFFFFFFFFFFFFFFF7 || v23 + 8 > *((void *)a2 + 2)) {
          goto LABEL_52;
        }
        *((void *)this + 8) = *(void *)(*(void *)a2 + v23);
        goto LABEL_66;
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        goto LABEL_19;
      case 0xAu:
        *((_WORD *)this + 94) |= 0x80u;
        unint64_t v24 = *((void *)a2 + 1);
        if (v24 >= *((void *)a2 + 2))
        {
          BOOL v27 = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          unint64_t v25 = v24 + 1;
          int v26 = *(unsigned __int8 *)(*(void *)a2 + v24);
          *((void *)a2 + 1) = v25;
          BOOL v27 = v26 != 0;
        }
        *((unsigned char *)this + 185) = v27;
        break;
      case 0xBu:
        *((_WORD *)this + 94) |= 0x200u;
        unint64_t v28 = *((void *)a2 + 1);
        if (v28 >= *((void *)a2 + 2))
        {
          BOOL v31 = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          unint64_t v29 = v28 + 1;
          int v30 = *(unsigned __int8 *)(*(void *)a2 + v28);
          *((void *)a2 + 1) = v29;
          BOOL v31 = v30 != 0;
        }
        *((unsigned char *)this + 187) = v31;
        break;
      case 0xCu:
        *((_WORD *)this + 94) |= 0x100u;
        unint64_t v32 = *((void *)a2 + 1);
        if (v32 >= *((void *)a2 + 2))
        {
          BOOL v35 = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          unint64_t v33 = v32 + 1;
          int v34 = *(unsigned __int8 *)(*(void *)a2 + v32);
          *((void *)a2 + 1) = v33;
          BOOL v35 = v34 != 0;
        }
        *((unsigned char *)this + 186) = v35;
        break;
      case 0xDu:
        *((_WORD *)this + 94) |= 0x40u;
        unint64_t v36 = *((void *)a2 + 1);
        if (v36 >= *((void *)a2 + 2))
        {
          BOOL v39 = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          unint64_t v37 = v36 + 1;
          int v38 = *(unsigned __int8 *)(*(void *)a2 + v36);
          *((void *)a2 + 1) = v37;
          BOOL v39 = v38 != 0;
        }
        *((unsigned char *)this + 184) = v39;
        break;
      case 0x14u:
        *((_WORD *)this + 94) |= 8u;
        unint64_t v40 = *((void *)a2 + 1);
        if (v40 > 0xFFFFFFFFFFFFFFF7 || v40 + 8 > *((void *)a2 + 2)) {
          goto LABEL_52;
        }
        *((void *)this + 4) = *(void *)(*(void *)a2 + v40);
        goto LABEL_66;
      case 0x15u:
        *((_WORD *)this + 94) |= 4u;
        unint64_t v42 = *((void *)a2 + 1);
        if (v42 > 0xFFFFFFFFFFFFFFF7 || v42 + 8 > *((void *)a2 + 2)) {
          goto LABEL_52;
        }
        *((void *)this + 3) = *(void *)(*(void *)a2 + v42);
        goto LABEL_66;
      case 0x16u:
        *((_WORD *)this + 94) |= 0x20u;
        unint64_t v41 = *((void *)a2 + 1);
        if (v41 > 0xFFFFFFFFFFFFFFF7 || v41 + 8 > *((void *)a2 + 2))
        {
LABEL_52:
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          *((void *)this + 9) = *(void *)(*(void *)a2 + v41);
LABEL_66:
          *((void *)a2 + 1) += 8;
        }
        break;
      default:
        switch((int)v20)
        {
          case '(':
            operator new();
          case ')':
            PB::PtrVector<statistics::Statistics>::emplace_back<>();
          case '*':
            PB::PtrVector<statistics::Statistics>::emplace_back<>();
          case '+':
            PB::PtrVector<statistics::Statistics>::emplace_back<>();
          case ',':
          case '-':
          case '.':
          case '/':
          case '0':
          case '1':
            goto LABEL_19;
          case '2':
            PB::PtrVector<statistics::Interval>::emplace_back<>();
          default:
            if (v20 == 30) {
              PB::PtrVector<statistics::RawQuantitySample>::emplace_back<>();
            }
            return result;
        }
        goto LABEL_19;
    }
LABEL_67:
    unint64_t v2 = *((void *)a2 + 1);
    unint64_t v3 = *((void *)a2 + 2);
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
      return v4 == 0;
    }
  }
  char v15 = 0;
  unsigned int v16 = 0;
  unint64_t v11 = 0;
  if (v2 > v3) {
    unint64_t v3 = v2;
  }
  do
  {
    if (v3 == v2)
    {
      int v4 = 1;
      *((unsigned char *)a2 + 24) = 1;
      return v4 == 0;
    }
    unint64_t v17 = v2 + 1;
    char v18 = *(unsigned char *)(v8 + v2);
    *((void *)a2 + 1) = v17;
    v11 |= (unint64_t)(v18 & 0x7F) << v15;
    if ((v18 & 0x80) == 0) {
      goto LABEL_21;
    }
    v15 += 7;
    unint64_t v2 = v17;
    BOOL v14 = v16++ > 8;
  }
  while (!v14);
LABEL_19:
  uint64_t result = PB::Reader::skip(a2);
  if (result) {
    goto LABEL_67;
  }
  return result;
}

void PB::PtrVector<statistics::RawQuantitySample>::emplace_back<>()
{
}

void sub_1BCC26CE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void PB::PtrVector<statistics::Statistics>::emplace_back<>()
{
}

void sub_1BCC26E5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t statistics::StatisticsBucket::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  __int16 v4 = *(_WORD *)(this + 188);
  if ((v4 & 2) != 0)
  {
    this = PB::Writer::write(a2, *(double *)(this + 16));
    __int16 v4 = *(_WORD *)(v3 + 188);
    if ((v4 & 1) == 0)
    {
LABEL_3:
      if ((v4 & 0x10) == 0) {
        goto LABEL_4;
      }
      goto LABEL_32;
    }
  }
  else if ((v4 & 1) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::write(a2, *(double *)(v3 + 8));
  __int16 v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 0x10) == 0)
  {
LABEL_4:
    if ((v4 & 0x80) == 0) {
      goto LABEL_5;
    }
    goto LABEL_33;
  }
LABEL_32:
  this = PB::Writer::write(a2, *(double *)(v3 + 64));
  __int16 v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 0x80) == 0)
  {
LABEL_5:
    if ((v4 & 0x200) == 0) {
      goto LABEL_6;
    }
    goto LABEL_34;
  }
LABEL_33:
  this = PB::Writer::write(a2);
  __int16 v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 0x200) == 0)
  {
LABEL_6:
    if ((v4 & 0x100) == 0) {
      goto LABEL_7;
    }
    goto LABEL_35;
  }
LABEL_34:
  this = PB::Writer::write(a2);
  __int16 v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 0x100) == 0)
  {
LABEL_7:
    if ((v4 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_36;
  }
LABEL_35:
  this = PB::Writer::write(a2);
  __int16 v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 0x40) == 0)
  {
LABEL_8:
    if ((v4 & 8) == 0) {
      goto LABEL_9;
    }
    goto LABEL_37;
  }
LABEL_36:
  this = PB::Writer::write(a2);
  __int16 v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 8) == 0)
  {
LABEL_9:
    if ((v4 & 4) == 0) {
      goto LABEL_10;
    }
LABEL_38:
    this = PB::Writer::write(a2, *(double *)(v3 + 24));
    if ((*(_WORD *)(v3 + 188) & 0x20) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_37:
  this = PB::Writer::write(a2, *(double *)(v3 + 32));
  __int16 v4 = *(_WORD *)(v3 + 188);
  if ((v4 & 4) != 0) {
    goto LABEL_38;
  }
LABEL_10:
  if ((v4 & 0x20) != 0) {
LABEL_11:
  }
    this = PB::Writer::write(a2, *(double *)(v3 + 72));
LABEL_12:
  __int16 v5 = *(const PB::Base ***)(v3 + 80);
  uint64_t v6 = *(const PB::Base ***)(v3 + 88);
  while (v5 != v6)
  {
    uint64_t v7 = *v5++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  uint64_t v8 = *(const PB::Base **)(v3 + 104);
  if (v8) {
    this = PB::Writer::writeSubmessage(a2, v8);
  }
  char v9 = *(const PB::Base ***)(v3 + 160);
  unsigned int v10 = *(const PB::Base ***)(v3 + 168);
  while (v9 != v10)
  {
    unint64_t v11 = *v9++;
    this = PB::Writer::writeSubmessage(a2, v11);
  }
  unint64_t v12 = *(const PB::Base ***)(v3 + 112);
  char v13 = *(const PB::Base ***)(v3 + 120);
  while (v12 != v13)
  {
    BOOL v14 = *v12++;
    this = PB::Writer::writeSubmessage(a2, v14);
  }
  char v15 = *(const PB::Base ***)(v3 + 136);
  unsigned int v16 = *(const PB::Base ***)(v3 + 144);
  while (v15 != v16)
  {
    unint64_t v17 = *v15++;
    this = PB::Writer::writeSubmessage(a2, v17);
  }
  uint64_t v19 = *(const PB::Base ***)(v3 + 40);
  char v18 = *(const PB::Base ***)(v3 + 48);
  while (v19 != v18)
  {
    unint64_t v20 = *v19++;
    this = PB::Writer::writeSubmessage(a2, v20);
  }
  return this;
}

BOOL statistics::StatisticsBucket::operator==(uint64_t a1, uint64_t a2)
{
  __int16 v4 = *(_WORD *)(a1 + 188);
  __int16 v5 = *(_WORD *)(a2 + 188);
  if ((v4 & 2) != 0)
  {
    if ((v5 & 2) == 0 || *(double *)(a1 + 16) != *(double *)(a2 + 16)) {
      return 0;
    }
  }
  else if ((v5 & 2) != 0)
  {
    return 0;
  }
  if (v4)
  {
    if ((v5 & 1) == 0 || *(double *)(a1 + 8) != *(double *)(a2 + 8)) {
      return 0;
    }
  }
  else if (v5)
  {
    return 0;
  }
  if ((v4 & 0x10) != 0)
  {
    if ((v5 & 0x10) == 0 || *(double *)(a1 + 64) != *(double *)(a2 + 64)) {
      return 0;
    }
  }
  else if ((v5 & 0x10) != 0)
  {
    return 0;
  }
  if ((v4 & 0x80) != 0)
  {
    if ((v5 & 0x80) == 0 || *(unsigned __int8 *)(a1 + 185) != *(unsigned __int8 *)(a2 + 185)) {
      return 0;
    }
  }
  else if ((v5 & 0x80) != 0)
  {
    return 0;
  }
  if ((*(_WORD *)(a1 + 188) & 0x200) != 0)
  {
    if ((*(_WORD *)(a2 + 188) & 0x200) == 0 || *(unsigned __int8 *)(a1 + 187) != *(unsigned __int8 *)(a2 + 187)) {
      return 0;
    }
  }
  else if ((*(_WORD *)(a2 + 188) & 0x200) != 0)
  {
    return 0;
  }
  if ((*(_WORD *)(a1 + 188) & 0x100) != 0)
  {
    if ((*(_WORD *)(a2 + 188) & 0x100) == 0 || *(unsigned __int8 *)(a1 + 186) != *(unsigned __int8 *)(a2 + 186)) {
      return 0;
    }
  }
  else if ((*(_WORD *)(a2 + 188) & 0x100) != 0)
  {
    return 0;
  }
  if ((v4 & 0x40) != 0)
  {
    if ((v5 & 0x40) == 0 || *(unsigned __int8 *)(a1 + 184) != *(unsigned __int8 *)(a2 + 184)) {
      return 0;
    }
  }
  else if ((v5 & 0x40) != 0)
  {
    return 0;
  }
  if ((v4 & 8) != 0)
  {
    if ((v5 & 8) == 0 || *(double *)(a1 + 32) != *(double *)(a2 + 32)) {
      return 0;
    }
  }
  else if ((v5 & 8) != 0)
  {
    return 0;
  }
  if ((v4 & 4) != 0)
  {
    if ((v5 & 4) == 0 || *(double *)(a1 + 24) != *(double *)(a2 + 24)) {
      return 0;
    }
  }
  else if ((v5 & 4) != 0)
  {
    return 0;
  }
  if ((v4 & 0x20) != 0)
  {
    if ((v5 & 0x20) == 0 || *(double *)(a1 + 72) != *(double *)(a2 + 72)) {
      return 0;
    }
  }
  else if ((v5 & 0x20) != 0)
  {
    return 0;
  }
  if (!PB::PtrVector<statistics::RawQuantitySample>::operator==((uint64_t *)(a1 + 80), a2 + 80)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 104);
  uint64_t v7 = *(void *)(a2 + 104);
  if (!v6)
  {
    if (!v7) {
      goto LABEL_58;
    }
    return 0;
  }
  if (!v7 || (statistics::Statistics::operator==(v6, v7) & 1) == 0 && *(void *)(a1 + 104) | *(void *)(a2 + 104)) {
    return 0;
  }
LABEL_58:
  if (!PB::PtrVector<statistics::Statistics>::operator==((uint64_t **)(a1 + 160), *(uint64_t **)(a2 + 160), *(void *)(a2 + 168))|| !PB::PtrVector<statistics::Statistics>::operator==((uint64_t **)(a1 + 112), *(uint64_t **)(a2 + 112), *(void *)(a2 + 120))|| !PB::PtrVector<statistics::Statistics>::operator==((uint64_t **)(a1 + 136), *(uint64_t **)(a2 + 136), *(void *)(a2 + 144)))
  {
    return 0;
  }

  return PB::PtrVector<statistics::Interval>::operator==((uint64_t *)(a1 + 40), a2 + 40);
}

BOOL PB::PtrVector<statistics::RawQuantitySample>::operator==(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  __int16 v4 = *(uint64_t **)a2;
  if (v3 - *a1 != *(void *)(a2 + 8) - *(void *)a2) {
    return 0;
  }
  if (v2 == v3) {
    return 1;
  }
  uint64_t v5 = v2 + 8;
  do
  {
    uint64_t v6 = *v4++;
    BOOL result = statistics::RawQuantitySample::operator==(*(void *)(v5 - 8), v6);
    BOOL v8 = !result || v5 == v3;
    v5 += 8;
  }
  while (!v8);
  return result;
}

uint64_t PB::PtrVector<statistics::Statistics>::operator==(uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  __int16 v4 = *a1;
  uint64_t v3 = a1[1];
  if ((char *)v3 - (char *)*a1 != a3 - (void)a2) {
    return 0;
  }
  if (v4 == v3) {
    return 1;
  }
  uint64_t v5 = a2;
  do
  {
    uint64_t result = statistics::Statistics::operator==(*v4, *v5);
    if (!result) {
      break;
    }
    ++v4;
    ++v5;
  }
  while (v4 != a1[1]);
  return result;
}

unint64_t statistics::StatisticsBucket::hash_value(statistics::StatisticsBucket *this)
{
  __int16 v2 = *((_WORD *)this + 94);
  if ((v2 & 2) == 0)
  {
    double v41 = 0.0;
    if (v2) {
      goto LABEL_3;
    }
LABEL_26:
    double v40 = 0.0;
    if ((v2 & 0x10) != 0) {
      goto LABEL_6;
    }
LABEL_27:
    double v39 = 0.0;
    if ((v2 & 0x80) != 0) {
      goto LABEL_9;
    }
    goto LABEL_28;
  }
  double v8 = *((double *)this + 2);
  if (v8 == 0.0) {
    double v8 = 0.0;
  }
  double v41 = v8;
  if ((v2 & 1) == 0) {
    goto LABEL_26;
  }
LABEL_3:
  double v3 = *((double *)this + 1);
  if (v3 == 0.0) {
    double v3 = 0.0;
  }
  double v40 = v3;
  if ((v2 & 0x10) == 0) {
    goto LABEL_27;
  }
LABEL_6:
  double v4 = *((double *)this + 8);
  if (v4 == 0.0) {
    double v4 = 0.0;
  }
  double v39 = v4;
  if ((v2 & 0x80) != 0)
  {
LABEL_9:
    uint64_t v38 = *((unsigned __int8 *)this + 185);
    if ((*((_WORD *)this + 94) & 0x200) != 0) {
      goto LABEL_10;
    }
    goto LABEL_29;
  }
LABEL_28:
  uint64_t v38 = 0;
  if ((*((_WORD *)this + 94) & 0x200) != 0)
  {
LABEL_10:
    uint64_t v37 = *((unsigned __int8 *)this + 187);
    if ((*((_WORD *)this + 94) & 0x100) != 0) {
      goto LABEL_11;
    }
    goto LABEL_30;
  }
LABEL_29:
  uint64_t v37 = 0;
  if ((*((_WORD *)this + 94) & 0x100) != 0)
  {
LABEL_11:
    uint64_t v36 = *((unsigned __int8 *)this + 186);
    if ((v2 & 0x40) != 0) {
      goto LABEL_12;
    }
    goto LABEL_31;
  }
LABEL_30:
  uint64_t v36 = 0;
  if ((v2 & 0x40) != 0)
  {
LABEL_12:
    uint64_t v35 = *((unsigned __int8 *)this + 184);
    if ((v2 & 8) != 0) {
      goto LABEL_13;
    }
LABEL_32:
    double v34 = 0.0;
    if ((v2 & 4) != 0) {
      goto LABEL_16;
    }
    goto LABEL_33;
  }
LABEL_31:
  uint64_t v35 = 0;
  if ((v2 & 8) == 0) {
    goto LABEL_32;
  }
LABEL_13:
  double v5 = *((double *)this + 4);
  if (v5 == 0.0) {
    double v5 = 0.0;
  }
  double v34 = v5;
  if ((v2 & 4) != 0)
  {
LABEL_16:
    if (*((double *)this + 3) == 0.0) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = *((void *)this + 3);
    }
    if ((v2 & 0x20) != 0) {
      goto LABEL_20;
    }
    goto LABEL_34;
  }
LABEL_33:
  uint64_t v6 = 0;
  if ((v2 & 0x20) != 0)
  {
LABEL_20:
    if (*((double *)this + 9) == 0.0) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = *((void *)this + 9);
    }
    goto LABEL_35;
  }
LABEL_34:
  uint64_t v7 = 0;
LABEL_35:
  char v9 = (statistics::RawQuantitySample **)*((void *)this + 10);
  unsigned int v10 = (statistics::RawQuantitySample **)*((void *)this + 11);
  if (v9 == v10)
  {
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = 0;
    do
    {
      unint64_t v12 = *v9++;
      v11 ^= statistics::RawQuantitySample::hash_value(v12);
    }
    while (v9 != v10);
  }
  char v13 = (statistics::Statistics *)*((void *)this + 13);
  if (v13) {
    unint64_t v14 = statistics::Statistics::hash_value(v13);
  }
  else {
    unint64_t v14 = 0;
  }
  char v15 = (statistics::Statistics **)*((void *)this + 20);
  unsigned int v16 = (statistics::Statistics **)*((void *)this + 21);
  if (v15 == v16)
  {
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v17 = 0;
    do
    {
      char v18 = *v15++;
      v17 ^= statistics::Statistics::hash_value(v18);
    }
    while (v15 != v16);
  }
  uint64_t v19 = (statistics::Statistics **)*((void *)this + 14);
  unint64_t v20 = (statistics::Statistics **)*((void *)this + 15);
  if (v19 == v20)
  {
    uint64_t v21 = 0;
  }
  else
  {
    uint64_t v21 = 0;
    do
    {
      unint64_t v22 = *v19++;
      v21 ^= statistics::Statistics::hash_value(v22);
    }
    while (v19 != v20);
  }
  unint64_t v23 = (statistics::Statistics **)*((void *)this + 17);
  unint64_t v24 = (statistics::Statistics **)*((void *)this + 18);
  if (v23 == v24)
  {
    uint64_t v25 = 0;
  }
  else
  {
    uint64_t v25 = 0;
    do
    {
      int v26 = *v23++;
      v25 ^= statistics::Statistics::hash_value(v26);
    }
    while (v23 != v24);
  }
  BOOL v27 = (uint64_t *)*((void *)this + 5);
  unint64_t v28 = (uint64_t *)*((void *)this + 6);
  if (v27 != v28)
  {
    uint64_t v29 = 0;
    while (1)
    {
      uint64_t v30 = *v27;
      if ((*(unsigned char *)(*v27 + 24) & 2) != 0)
      {
        double v31 = *(double *)(v30 + 16);
        if (v31 == 0.0) {
          double v31 = 0.0;
        }
        if (*(unsigned char *)(*v27 + 24))
        {
LABEL_62:
          double v32 = *(double *)(v30 + 8);
          if (v32 == 0.0) {
            double v32 = 0.0;
          }
          goto LABEL_69;
        }
      }
      else
      {
        double v31 = 0.0;
        if (*(unsigned char *)(*v27 + 24)) {
          goto LABEL_62;
        }
      }
      double v32 = 0.0;
LABEL_69:
      v29 ^= *(void *)&v31 ^ *(void *)&v32;
      if (++v27 == v28) {
        return *(void *)&v40 ^ *(void *)&v41 ^ *(void *)&v39 ^ v38 ^ v37 ^ v36 ^ v35 ^ *(void *)&v34 ^ v6 ^ v7 ^ v11 ^ v14 ^ v17 ^ v21 ^ v25 ^ v29;
      }
    }
  }
  uint64_t v29 = 0;
  return *(void *)&v40 ^ *(void *)&v41 ^ *(void *)&v39 ^ v38 ^ v37 ^ v36 ^ v35 ^ *(void *)&v34 ^ v6 ^ v7 ^ v11 ^ v14 ^ v17 ^ v21 ^ v25 ^ v29;
}

uint64_t statistics::StatisticsBucket::makeStatistics(uint64_t this)
{
  if (!*(void *)(this + 104)) {
    operator new();
  }
  return this;
}

uint64_t std::vector<std::unique_ptr<statistics::RawQuantitySample>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<statistics::RawQuantitySample>>,std::reverse_iterator<std::unique_ptr<statistics::RawQuantitySample>*>,std::reverse_iterator<std::unique_ptr<statistics::RawQuantitySample>*>,std::reverse_iterator<std::unique_ptr<statistics::RawQuantitySample>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<statistics::RawQuantitySample>>,std::reverse_iterator<std::unique_ptr<statistics::RawQuantitySample>*>,std::reverse_iterator<std::unique_ptr<statistics::RawQuantitySample>*>,std::reverse_iterator<std::unique_ptr<statistics::RawQuantitySample>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  id v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    char v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::RawQuantitySample>>,std::reverse_iterator<std::unique_ptr<statistics::RawQuantitySample>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::RawQuantitySample>>,std::reverse_iterator<std::unique_ptr<statistics::RawQuantitySample>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::Interval>>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<statistics::Statistics>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Statistics>>,std::reverse_iterator<std::unique_ptr<statistics::Statistics>*>,std::reverse_iterator<std::unique_ptr<statistics::Statistics>*>,std::reverse_iterator<std::unique_ptr<statistics::Statistics>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<statistics::Statistics>>,std::reverse_iterator<std::unique_ptr<statistics::Statistics>*>,std::reverse_iterator<std::unique_ptr<statistics::Statistics>*>,std::reverse_iterator<std::unique_ptr<statistics::Statistics>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  id v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    char v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::Statistics>>,std::reverse_iterator<std::unique_ptr<statistics::Statistics>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::Statistics>>,std::reverse_iterator<std::unique_ptr<statistics::Statistics>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::Interval>>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

BOOL HDCodableTinkerPairingResponseReadFrom(uint64_t a1, uint64_t a2)
{
  double v3 = (int *)MEMORY[0x1E4F940E8];
  double v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3) {
        break;
      }
      if (v17 == 2)
      {
        uint64_t v19 = objc_alloc_init(HDCodableSharingSetupMetadata);
        objc_storeStrong((id *)(a1 + 24), v19);
        if (!PBReaderPlaceMark() || !HDCodableSharingSetupMetadataReadFrom((char *)v19, a2)) {
          goto LABEL_33;
        }
LABEL_27:
        PBReaderRecallMark();
        goto LABEL_28;
      }
      if (v17 == 1)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = *(HDCodableSharingSetupMetadata **)(a1 + 16);
        *(void *)(a1 + 16) = v18;
LABEL_28:

        goto LABEL_30;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_30:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v19 = objc_alloc_init(HDCodableError);
    objc_storeStrong((id *)(a1 + 8), v19);
    if (!PBReaderPlaceMark() || (HDCodableErrorReadFrom((uint64_t)v19, a2) & 1) == 0)
    {
LABEL_33:

      return 0;
    }
    goto LABEL_27;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCC28B40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__14(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
}

void sub_1BCC28CE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC299EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC29BB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC29D34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC29E18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC29F18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC29FB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2A0F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2A1B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2A278(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2A30C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2A514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCC2A60C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2A6A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2A724(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2A968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void sub_1BCC2AAB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2ABAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2AC84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2AD94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2AE28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2AEAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2B04C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC2B15C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__15(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
}

void sub_1BCC2B288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<BOOL ()(health::DataStore::WriteTransaction &)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE7__cloneEv(uint64_t a1)
{
  __int16 v2 = (char *)operator new(0x20uLL);
  *(void *)__int16 v2 = &unk_1F171BA18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE7__cloneEPNS0_6__baseIS9_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171BA18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEEclES8_(uint64_t a1, uint64_t a2)
{
  double v4 = [**(id **)(a1 + 8) transaction];
  uint64_t v5 = [v4 protectedDatabase];
  uint64_t v6 = **(void **)(a1 + 16);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  id v10[2] = ___ZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionE_block_invoke;
  void v10[3] = &__block_descriptor_48_e26_B24__0__HDSQLiteRow__8__16l;
  uint64_t v7 = *(void *)(a1 + 24);
  v10[4] = a2;
  v10[5] = v7;
  uint64_t v8 = [v5 executeUncachedSQL:@"SELECT data_id FROM data_series ds INNER JOIN samples s USING (data_id) WHERE data_type = 102" error:v6 bindingHandler:0 enumerationHandler:v10];

  return v8;
}

void sub_1BCC2B40C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _ZNKSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE11target_typeEv()
{
  return &_ZTIZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_E3__0;
}

uint64_t ___ZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionE_block_invoke(uint64_t a1)
{
  void v13[4] = *MEMORY[0x1E4F143B8];
  unint64_t v2 = HDSQLiteColumnAsInt64();
  v8.objectType = 0;
  v8.identifier = v2;
  uint64_t v3 = *(void *)(a1 + 32);
  long long v11 = *(_OWORD *)(v3 + 32);
  uint64_t v12 = v3;
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v11, &v8, 0, &v9);
  if (!v10) {
    return 1;
  }
  v9.objectType = -1;
  v9.identifier = v2;
  health::DataStore::WriteTransaction::renameObjectWithIdentifier(*(health::DataStore::WriteTransaction **)(a1 + 32), &v8, (__n128 *)&v9);
  double v4 = *(uint64_t **)(a1 + 40);
  uint64_t v5 = *v4;
  v13[0] = &unk_1F171BB58;
  v13[1] = v4;
  id v13[2] = &v9;
  void v13[3] = v13;
  uint64_t v6 = health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(v5, (uint64_t)&v8, 1, (uint64_t)v13);
  std::__function::__value_func<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>::~__value_func[abi:ne180100](v13);
  return v6;
}

void sub_1BCC2B578(_Unwind_Exception *a1)
{
  std::__function::__value_func<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>::~__value_func[abi:ne180100]((void *)(v1 - 56));
  _Unwind_Resume(a1);
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::~__func()
{
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = &unk_1F171BA98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171BA98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::operator()(uint64_t a1, uint64_t a2)
{
  return std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1} &,health::DataStore::WriteTransaction &>(a1 + 8, a2);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target_type()
{
}

uint64_t std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1} &,health::DataStore::WriteTransaction &>(uint64_t a1, uint64_t a2)
{
  long long v7 = 0u;
  long long v6 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  uint64_t v10 = a2;
  uint64_t v11 = a2;
  uint64_t result = health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)a1, **(unsigned __int8 **)(a1 + 8));
  if (result)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 16) + 24);
    if (!v4) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    return (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v4 + 48))(v4, v5);
  }
  return result;
}

__n128 health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::_updateHistoryRoot(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  uint64_t v3 = *(void *)(a1 + 96);
  if (v2 == 56)
  {
    uint64_t v4 = v3 + 80;
    uint64_t v5 = *(void *)(a1 + 56);
    health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v4, v5, 56, (uint64_t *)a1);
  }
  else
  {
    health::DataStore::WriteTransaction::storeObjectWithIdentifier<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v3, (uint64_t *)a1, (__n128 *)(a1 + 72));
    health::DataStore::ReadTransaction::_pointerForObject(*(health::DataStore::ReadTransaction **)(a1 + 96), (ObjectIdentifier *)(a1 + 72), (uint64_t)v8);
    long long v7 = (__n128 *)health::Optional<health::BlockPointer>::get((uint64_t)v8);
    __n128 result = *v7;
    *(__n128 *)(a1 + 56) = *v7;
  }
  return result;
}

std::runtime_error *_ZN6health15not_found_errorCI1St13runtime_errorEPKc(std::runtime_error *a1, const char *a2)
{
  __n128 result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_1F171BB20;
  return result;
}

uint64_t health::Optional<health::BlockPointer>::get(uint64_t result)
{
  if (!*(unsigned char *)(result + 16))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempt to get the value from an invalid optional.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  return result;
}

void sub_1BCC2B850(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::_HDAssertImplementation<std::out_of_range>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v10 = a1;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  *(_OWORD *)double v39 = 0u;
  long long v40 = 0u;
  int v11 = backtrace(v39, 20);
  uint64_t v12 = backtrace_symbols(v39, v11);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v37);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v37, (uint64_t)"Critical Error: ", 16);
  int v14 = *(char *)(a6 + 23);
  if (v14 >= 0) {
    uint64_t v15 = a6;
  }
  else {
    uint64_t v15 = *(void *)a6;
  }
  if (v14 >= 0) {
    uint64_t v16 = *(unsigned __int8 *)(a6 + 23);
  }
  else {
    uint64_t v16 = *(void *)(a6 + 8);
  }
  unint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v15, v16);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"\n", 1);
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v37, (uint64_t)"Failed assertion '", 18);
  int v19 = *(char *)(a2 + 23);
  if (v19 >= 0) {
    uint64_t v20 = a2;
  }
  else {
    uint64_t v20 = *(void *)a2;
  }
  if (v19 >= 0) {
    uint64_t v21 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v21 = *(void *)(a2 + 8);
  }
  unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, v20, v21);
  unint64_t v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"' in '", 6);
  int v24 = *(char *)(a3 + 23);
  if (v24 >= 0) {
    uint64_t v25 = a3;
  }
  else {
    uint64_t v25 = *(void *)a3;
  }
  if (v24 >= 0) {
    uint64_t v26 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v26 = *(void *)(a3 + 8);
  }
  BOOL v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, v25, v26);
  unint64_t v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)"' at ", 5);
  int v29 = *(char *)(a4 + 23);
  if (v29 >= 0) {
    uint64_t v30 = a4;
  }
  else {
    uint64_t v30 = *(void *)a4;
  }
  if (v29 >= 0) {
    uint64_t v31 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v31 = *(void *)(a4 + 8);
  }
  double v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, v30, v31);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)":", 1);
  unint64_t v33 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)"\n", 1);
  if (!v11)
  {
    free(v12);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v38, &v36);
    std::logic_error::logic_error(exception, &v36);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, *v12);
  health::HDDemangleBacktraceLine();
}

void sub_1BCC2BAEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  a21 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a21 + *(void *)(a21 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a22 = MEMORY[0x1E4FBA470] + 16;
  if (a35 < 0) {
    operator delete(a30);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&a38);

  _Unwind_Resume(a1);
}

void health::FormatString<>(std::string *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<>(a1, a2, 0);
}

void sub_1BCC2BC9C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  uint64_t v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1BCC2BE28(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x1C187B850](v1);
  _Unwind_Resume(a1);
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1C187B630](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      id v10 = std::locale::use_facet(&v14, MEMORY[0x1E4FBA258]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x1C187B640](v13);
  return a1;
}

void sub_1BCC2BF8C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x1C187B640](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1BCC2BF6CLL);
}

void sub_1BCC2BFE0(_Unwind_Exception *a1)
{
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      uint64_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_1BCC2C160(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::string::basic_string[abi:ne180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

uint64_t std::stringbuf::str[abi:ne180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = std::stringbuf::view[abi:ne180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v5 = (const void *)result;
  size_t v6 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    int v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((unsigned char *)a2 + 23) = v4;
    if (!v4) {
      goto LABEL_9;
    }
  }
  uint64_t result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((unsigned char *)a2 + v6) = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:ne180100](uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    unint64_t v3 = *(void *)(a1 + 48);
    if (*(void *)(a1 + 88) < v3) {
      *(void *)(a1 + 88) = v3;
    }
    return *(void *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(void *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

void *std::string::basic_string[abi:ne180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    size_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    size_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void health::FormatImplementation<>(std::string *a1, std::string *this, std::string::size_type a3)
{
  uint64_t v6 = 0;
  char v7 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    uint64_t v16 = i;
    if (*i != 123) {
      break;
    }
    int v9 = i[1];
    if (v9 != 123)
    {
      if (v9 == 42)
      {
        uint64_t v16 = i + 2;
        int v10 = i[2];
        if ((v10 - 48) > 9)
        {
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
        }
        else
        {
          uint64_t v11 = 0;
          int64_t v12 = i + 3;
          do
          {
            uint64_t v16 = v12;
            uint64_t v11 = (v10 - 48) + 10 * v11;
            int v13 = *v12++;
            int v10 = v13;
          }
          while ((v13 - 58) >= 0xFFFFFFF6);
          uint64_t v16 = v12;
          if (*(v12 - 1) == 125) {
            health::FormatterParameters<0ul>::formatOptionsAtIndex<>();
          }
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
        }
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
      health::FormatOptions::FormatOptions((uint64_t)&v15, (const char **)&v16);
      health::FormatterParameters<0ul>::formatParameterAtIndex<health::FormatterParameters<0ul>>();
    }
    uint64_t v16 = i + 1;
    char v7 = 1;
    ++i;
LABEL_7:
    --v6;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(this, a3 - v6, 0);
  if (v6)
  {
    health::CopyFormatSectionToResult(a1, this, a3, -v6, v7 & 1);
  }
}

void sub_1BCC2C5D8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul>::formatOptionsAtIndex<>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCC2C638(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul>::formatParameterAtIndex<health::FormatterParameters<0ul>>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCC2C694(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot::deserialize(void *a1, uint64_t a2)
{
  size_t v4 = a1 + 2;
  size_t v5 = a1 + 4;
  uint64_t v7 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>(a2, &v7);
  *a1 = v7;
  uint64_t v7 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>(a2, &v7);
  a1[1] = v7;
  health::BlockPointer::deserialize(v4, a2);
  health::BlockPointer::deserialize(v5, a2);
  uint64_t v7 = 0;
  uint64_t result = health::DeserializationBuffer::extractRaw<long long>(a2, &v7);
  a1[6] = v7;
  return result;
}

uint64_t health::BlockPointer::deserialize(void *a1, uint64_t a2)
{
  uint64_t v5 = 0;
  health::DeserializationBuffer::extractRaw<unsigned long long>(a2, &v5);
  *a1 = v5;
  uint64_t v5 = 0;
  uint64_t result = health::DeserializationBuffer::extractRaw<unsigned long long>(a2, &v5);
  a1[1] = v5;
  return result;
}

uint64_t health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot::serialize(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = *a1;
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[1];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[2];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[3];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[4];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[5];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[6];
  return health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey(uint64_t *a1, __n128 *a2, __n128 *a3)
{
  uint64_t v6 = a1[2];
  bzero(v15, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v6 + 24), *a1, a1[1], (uint64_t)v15);
  uint64_t result = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey((uint64_t)a1, 0, a1, (uint64_t)v15, a2, a3);
  if (result >= 2)
  {
    uint64_t v8 = a1[2];
    bzero(__src, 0x223uLL);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v8 + 24), *a1, a1[1], (uint64_t)__src);
    memcpy(__dst, __src, sizeof(__dst));
    int v9 = *(health::BlockAccessFile::WriteTransaction **)(a1[2] + 24);
    uint64_t v10 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v9, 547);
    uint64_t v12 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>((uint64_t)v9, v10, v11, (uint64_t)__dst);
    LOWORD(__src[68]) = 1;
    void __src[2] = v10;
    __src[3] = v12;
    BYTE2(__src[68]) = 0;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(a1[2] + 24), *a1, a1[1], (uint64_t)__src);
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey(a1, a2, a3);
  }
  return result;
}

double health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>@<D0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X4>, _OWORD *a6@<X8>)
{
  if (*(_WORD *)(a3 + 544))
  {
    signed int v12 = health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(a3, a4);
    uint64_t v13 = (a2 + 1);
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKeyInChildAtIndex<health::DataStore::ObjectIdentifier>(a1, v13, a3, v12, a4, a5, (uint64_t)v16);
    if (BYTE8(v17) || *(unsigned __int16 *)(a3 + 544) - 1 <= v12)
    {
      long long v15 = v16[1];
      *a6 = v16[0];
      a6[1] = v15;
      double result = *(double *)&v17;
      a6[2] = v17;
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKeyInChildAtIndex<health::DataStore::ObjectIdentifier>(a1, v13, a3, (unsigned __int16)(v12 + 1), a4, a5, (uint64_t)a6);
    }
  }
  else
  {
    double result = 0.0;
    *(_OWORD *)((char *)a6 + 25) = 0u;
    *a6 = 0u;
    a6[1] = 0u;
  }
  return result;
}

uint64_t health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v5 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    uint64_t v6 = v5 + 2;
    health::DataStore::ObjectIdentifier::deserialize(v5, a2);
    health::BlockPointer::deserialize(v6, a2);
  }
  __int16 v8 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v8);
  *(_WORD *)(a1 + 544) = v8;
  char v9 = 0;
  uint64_t result = health::DeserializationBuffer::extractRaw<unsigned char>(a2, &v9);
  *(unsigned char *)(a1 + 546) = v9 != 0;
  return result;
}

uint64_t health::DataStore::ObjectIdentifier::deserialize(void *a1, uint64_t a2)
{
  uint64_t v5 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  *a1 = v5;
  uint64_t v5 = 0;
  uint64_t result = health::DeserializationBuffer::extractRaw<unsigned long long>(a2, &v5);
  a1[1] = v5;
  return result;
}

void health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKeyInChildAtIndex<health::DataStore::ObjectIdentifier>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned int a4@<W3>, void *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  if (*(unsigned __int16 *)(a3 + 544) <= a4)
  {
    signed int v12 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v23, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v22, "_valueForKeyInChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v20);
    health::_HDAssertImplementation<health::btree_access_error>(v12, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 158, (uint64_t)&v20);
  }
  if (*(unsigned char *)(a3 + 546))
  {
    uint64_t v13 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
    uint64_t v14 = *(void *)(v13 + 16);
    uint64_t v15 = *(void *)(v13 + 24);
    uint64_t v16 = *(void *)(a1 + 16);
    bzero(v17, 0x222uLL);
    long long v18 = 0u;
    long long v19 = 0u;
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v16 + 24), v14, v15, (uint64_t)v17);
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>((uint64_t)v17, a5, a6, a7);
  }
  else
  {
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(a1, a2, a3, a4, v17);
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>(a1, a2, v17, a5, a6);
  }
}

void sub_1BCC2CD20(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 153) < 0) {
    operator delete(*(void **)(v1 - 176));
  }
  if (*(char *)(v1 - 129) < 0) {
    operator delete(*(void **)(v1 - 152));
  }
  if (*(char *)(v1 - 105) < 0) {
    operator delete(*(void **)(v1 - 128));
  }
  if (*(char *)(v1 - 81) < 0) {
    operator delete(*(void **)(v1 - 104));
  }
  _Unwind_Resume(exception_object);
}

void health::_HDAssertImplementation<health::btree_access_error>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v10 = a1;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  *(_OWORD *)double v39 = 0u;
  long long v40 = 0u;
  int v11 = backtrace(v39, 20);
  signed int v12 = backtrace_symbols(v39, v11);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v37);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v37, (uint64_t)"Critical Error: ", 16);
  int v14 = *(char *)(a6 + 23);
  if (v14 >= 0) {
    uint64_t v15 = a6;
  }
  else {
    uint64_t v15 = *(void *)a6;
  }
  if (v14 >= 0) {
    uint64_t v16 = *(unsigned __int8 *)(a6 + 23);
  }
  else {
    uint64_t v16 = *(void *)(a6 + 8);
  }
  long long v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v15, v16);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"\n", 1);
  long long v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v37, (uint64_t)"Failed assertion '", 18);
  int v19 = *(char *)(a2 + 23);
  if (v19 >= 0) {
    uint64_t v20 = a2;
  }
  else {
    uint64_t v20 = *(void *)a2;
  }
  if (v19 >= 0) {
    uint64_t v21 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v21 = *(void *)(a2 + 8);
  }
  unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, v20, v21);
  unint64_t v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"' in '", 6);
  int v24 = *(char *)(a3 + 23);
  if (v24 >= 0) {
    uint64_t v25 = a3;
  }
  else {
    uint64_t v25 = *(void *)a3;
  }
  if (v24 >= 0) {
    uint64_t v26 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v26 = *(void *)(a3 + 8);
  }
  BOOL v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, v25, v26);
  unint64_t v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)"' at ", 5);
  int v29 = *(char *)(a4 + 23);
  if (v29 >= 0) {
    uint64_t v30 = a4;
  }
  else {
    uint64_t v30 = *(void *)a4;
  }
  if (v29 >= 0) {
    uint64_t v31 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v31 = *(void *)(a4 + 8);
  }
  double v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, v30, v31);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)":", 1);
  unint64_t v33 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)"\n", 1);
  if (!v11)
  {
    free(v12);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v38, &v36);
    std::runtime_error::runtime_error(exception, &v36);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1F171BDC0;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, *v12);
  health::HDDemangleBacktraceLine();
}

void sub_1BCC2D00C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  a21 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a21 + *(void *)(a21 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a22 = MEMORY[0x1E4FBA470] + 16;
  if (a35 < 0) {
    operator delete(a30);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&a38);

  _Unwind_Resume(a1);
}

void health::btree_access_error::~btree_access_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x1C187B8A0);
}

double health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>@<D0>(uint64_t a1@<X2>, void *a2@<X3>, int a3@<W4>, uint64_t a4@<X8>)
{
  if (!*(_WORD *)(a1 + 544)) {
    goto LABEL_16;
  }
  uint64_t v7 = health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::indexForKey(a1, a2);
  if (!HIDWORD(v7))
  {
    char v9 = (long long *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, (unsigned __int16)v7);
    long long v8 = *v9;
    long long v10 = v9[1];
    *(_OWORD *)a4 = *v9;
    *(_OWORD *)(a4 + 16) = v10;
    *(_DWORD *)(a4 + 32) = 0;
    goto LABEL_15;
  }
  switch(a3)
  {
    case 2:
      if (HIDWORD(v7) != 2) {
        goto LABEL_16;
      }
      int v11 = (long long *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, (unsigned __int16)v7);
      long long v8 = *v11;
      long long v12 = v11[1];
      *(_OWORD *)a4 = *v11;
      *(_OWORD *)(a4 + 16) = v12;
      *(_DWORD *)(a4 + 32) = 2;
LABEL_15:
      *(unsigned char *)(a4 + 40) = 1;
      return *(double *)&v8;
    case 1:
      if (HIDWORD(v7) == 1)
      {
        unint64_t v13 = (unsigned __int16)v7;
LABEL_14:
        int v14 = (long long *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, v13);
        long long v8 = *v14;
        long long v15 = v14[1];
        *(_OWORD *)a4 = *v14;
        *(_OWORD *)(a4 + 16) = v15;
        *(_DWORD *)(a4 + 32) = 1;
        goto LABEL_15;
      }
      if ((unsigned __int16)v7 < *(unsigned __int16 *)(a1 + 544) - 1)
      {
        unint64_t v13 = (unsigned __int16)v7 + 1;
        goto LABEL_14;
      }
LABEL_16:
      *(void *)&long long v8 = 0;
      *(_OWORD *)(a4 + 25) = 0u;
      *(_OWORD *)a4 = 0u;
      *(_OWORD *)(a4 + 16) = 0u;
      return *(double *)&v8;
    case 0:
      goto LABEL_16;
  }
  return *(double *)&v8;
}

void *health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, unsigned int a4@<W3>, void *a5@<X8>)
{
  if (*(unsigned __int16 *)(a3 + 544) <= a4)
  {
    char v9 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v34, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v33, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v32, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v31);
    health::_HDAssertImplementation<health::btree_access_error>(v9, (uint64_t)v34, (uint64_t)v33, (uint64_t)v32, 137, (uint64_t)&v31);
  }
  if (a2 >= 64)
  {
    long long v10 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v30, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v29, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v28, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v30, (uint64_t)v29, (uint64_t)v28, 138, (uint64_t)&__p);
  }
  uint64_t v11 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
  uint64_t v12 = *(void *)(v11 + 16);
  uint64_t v13 = *(void *)(v11 + 24);
  uint64_t v14 = *(void *)(a1 + 16);
  bzero(a5, 0x223uLL);
  uint64_t result = (void *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v14 + 24), v12, v13, (uint64_t)a5);
  if (*((_WORD *)a5 + 272))
  {
    uint64_t result = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
    if (*a5 <= *result && (*a5 < *result || a5[1] < result[1]))
    {
      uint64_t v16 = (void *)*MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v26, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v25, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v24, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v23);
      health::_HDAssertImplementation<health::btree_access_error>(v16, (uint64_t)v26, (uint64_t)v25, (uint64_t)v24, 144, (uint64_t)&v23);
    }
    if (*(unsigned __int16 *)(a3 + 544) - 1 > (int)a4)
    {
      long long v17 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)a5, *((unsigned __int16 *)a5 + 272) - 1);
      uint64_t result = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4 + 1);
      if (*v17 >= *result && (*v17 > *result || v17[1] >= result[1]))
      {
        long long v18 = (void *)*MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(v22, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v21, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v20, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v19);
        health::_HDAssertImplementation<health::btree_access_error>(v18, (uint64_t)v22, (uint64_t)v21, (uint64_t)v20, 146, (uint64_t)&v19);
      }
    }
  }
  return result;
}

void sub_1BCC2D67C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v5 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    uint64_t v6 = v5 + 2;
    health::DataStore::ObjectIdentifier::deserialize(v5, a2);
    health::BlockPointer::deserialize(v6, a2);
  }
  __int16 v8 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v8);
  *(_WORD *)(a1 + 544) = v8;
  health::BlockPointer::deserialize((void *)(a1 + 552), a2);
  return health::BlockPointer::deserialize((void *)(a1 + 568), a2);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, __n128 *a5, __n128 *a6)
{
  if (*(_WORD *)(a4 + 544))
  {
    int v10 = a2 + 1;
    if (*(unsigned char *)(a4 + 546))
    {
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKeyWithLeafChildren(a1, v10, a3, a4, a5, a6);
    }
    else
    {
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKeyWithInteriorChildren(a1, v10, a3, a4, a5, (uint64_t)a6);
    }
  }
  else
  {
    memset(&v18[2], 0, 512);
    uint64_t v12 = *(long long **)(a1 + 16);
    long long v20 = *v12;
    long long v21 = *v12;
    __int16 v19 = 1;
    __n128 v13 = *a6;
    v18[0] = *a5;
    v18[1] = v13;
    uint64_t v14 = (health::BlockAccessFile::WriteTransaction *)*((void *)v12 + 3);
    uint64_t v15 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v14, 578);
    uint64_t v17 = v16;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>((uint64_t)v14, v15, v16, (uint64_t)v18);
    *(__n128 *)a4 = *a5;
    *(void *)(a4 + 16) = v15;
    *(void *)(a4 + 24) = v17;
    *(_WORD *)(a4 + 544) = 1;
    *(unsigned char *)(a4 + 546) = 1;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 0;
  }
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKeyWithLeafChildren(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, __n128 *a5, __n128 *a6)
{
  unsigned int v12 = health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(a4, a5);
  long long v57 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12)+ 16);
  uint64_t v13 = *(void *)(a1 + 16);
  bzero(v53, 0x222uLL);
  long long v55 = 0u;
  long long v56 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v13 + 24), v57, *((uint64_t *)&v57 + 1), (uint64_t)v53);
  uint64_t v14 = (a2 + 1);
  uint64_t v15 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(a1, v14, (uint64_t *)&v57, (uint64_t)v53, a5, a6);
  uint64_t v16 = v15;
  if (v15 > 1)
  {
    int v18 = *(unsigned __int16 *)(a4 + 544);
    if (v18 == 17)
    {
      if (v15 == 4) {
        unsigned int v19 = 4;
      }
      else {
        unsigned int v19 = 2;
      }
      if (v15 == 3) {
        int v20 = 3;
      }
      else {
        int v20 = 2;
      }
      if (v12) {
        unsigned int v21 = 2;
      }
      else {
        unsigned int v21 = v20;
      }
      if (v12 == 16) {
        return v19;
      }
      else {
        return v21;
      }
    }
    else if (v15 == 4 && v18 - 1 == v12)
    {
      memset(&v49[2], 0, 512);
      __int16 v50 = 1;
      __n128 v22 = *a6;
      v49[0] = *a5;
      v49[1] = v22;
      long long v51 = v57;
      long long v52 = v56;
      std::string v23 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
      uint64_t v24 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v23, 578);
      uint64_t v26 = v25;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>((uint64_t)v23, v24, v25, (uint64_t)v49);
      *(void *)&long long v56 = v24;
      *((void *)&v56 + 1) = v26;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v57, *((uint64_t *)&v57 + 1), (uint64_t)v53);
      uint64_t v27 = *(void *)(a1 + 16);
      long long v28 = v52;
      if (v52 != *(_OWORD *)v27)
      {
        bzero(&v44, 0x222uLL);
        long long v47 = 0u;
        long long v48 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v27 + 24), v28, *((uint64_t *)&v28 + 1), (uint64_t)&v44);
        *(void *)&long long v47 = v24;
        *((void *)&v47 + 1) = v26;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v52, *((uint64_t *)&v52 + 1), (uint64_t)&v44);
      }
      unint64_t v29 = *(unsigned __int16 *)(a4 + 544);
      uint64_t v30 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v29);
      *(void *)(v30 + 16) = v24;
      *(void *)(v30 + 24) = v26;
      *(__n128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v29) = *a5;
      ++*(_WORD *)(a4 + 544);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
      return 0;
    }
    else
    {
      long long v41 = a3;
      long long v43 = v57;
      bzero(v49, 0x222uLL);
      long long v51 = v57;
      long long v52 = v56;
      health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v49, 0, (uint64_t)v53, v54 - 8, 8);
      v54 -= 8;
      __int16 v50 = 8;
      std::string v31 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
      uint64_t v32 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v31, 578);
      uint64_t v34 = v33;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>((uint64_t)v31, v32, v33, (uint64_t)v49);
      *(void *)&long long v42 = v32;
      *((void *)&v42 + 1) = v34;
      long long v56 = v42;
      uint64_t v35 = *(void *)(a1 + 16);
      uint64_t v36 = v52;
      if (v52 != *(_OWORD *)v35)
      {
        uint64_t v40 = *((void *)&v52 + 1);
        bzero(&v44, 0x222uLL);
        long long v47 = 0u;
        long long v48 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v35 + 24), v36, v40, (uint64_t)&v44);
        long long v47 = v42;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v52, *((uint64_t *)&v52 + 1), (uint64_t)&v44);
      }
      __n128 v44 = (__n128)v49[0];
      uint64_t v45 = v32;
      uint64_t v46 = v34;
      health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, &v44, v12 + 1);
      ++*(_WORD *)(a4 + 544);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v43, *((uint64_t *)&v43 + 1), (uint64_t)v53);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *v41, v41[1], a4);
      if ((int64_t)a5->n128_u64[0] <= *(uint64_t *)&v49[0]
        && ((int64_t)a5->n128_u64[0] < *(uint64_t *)&v49[0] || a5->n128_u64[1] <= *((void *)&v49[0] + 1)))
      {
        uint64_t v37 = (uint64_t *)&v43;
        uint64_t v38 = v53;
      }
      else
      {
        uint64_t v37 = (uint64_t *)&v42;
        uint64_t v38 = v49;
      }
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(a1, v14, v37, (uint64_t)v38, a5, a6);
    }
  }
  else
  {
    uint64_t v17 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12);
    if ((int64_t)a5->n128_u64[0] < *v17 || (int64_t)a5->n128_u64[0] <= *v17 && a5->n128_u64[1] < v17[1])
    {
      *(__n128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12) = *a5;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    }
  }
  return v16;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKeyWithInteriorChildren(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, void *a5, uint64_t a6)
{
  unsigned int v12 = health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(a4, a5);
  unint64_t v13 = v12;
  long long v36 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12)+ 16);
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(a1, a2, a4, v12, v33);
  uint64_t v14 = (a2 + 1);
  uint64_t v15 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(a1, v14, &v36, v33, a5, a6);
  if (v15 > 1)
  {
    if (*(_WORD *)(a4 + 544) == 17)
    {
      return 2;
    }
    else
    {
      long long v32 = v36;
      bzero(&v29, 0x223uLL);
      char v31 = v35;
      health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)&v29, 0, (uint64_t)v33, v34 - 8, 8);
      v34 -= 8;
      __int16 v30 = 8;
      int v18 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
      uint64_t v19 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v18, 547);
      uint64_t v21 = v20;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>((uint64_t)v18, v19, v20, (uint64_t)&v29);
      v28[0] = v19;
      v28[1] = v21;
      __n128 v25 = v29;
      uint64_t v26 = v19;
      uint64_t v27 = v21;
      health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, &v25, v13 + 1);
      ++*(_WORD *)(a4 + 544);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v32, *((uint64_t *)&v32 + 1), (uint64_t)v33);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
      if (*a5 <= v29.n128_i64[0] && (*a5 < v29.n128_i64[0] || a5[1] <= v29.n128_u64[1]))
      {
        __n128 v22 = &v32;
        std::string v23 = (__n128 *)v33;
      }
      else
      {
        __n128 v22 = (long long *)v28;
        std::string v23 = &v29;
      }
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(a1, v14, v22, v23, a5, a6);
    }
  }
  else
  {
    uint64_t v16 = v15;
    uint64_t v17 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v13);
    if (*a5 < *v17 || *a5 <= *v17 && a5[1] < v17[1])
    {
      *(_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v13) = *(_OWORD *)a5;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    }
  }
  return v16;
}

uint64_t health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::serialize(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v5 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry::serialize(v5, a2);
  }
  LOWORD(v7) = *(_WORD *)(a1 + 544);
  health::SerializationBuffer::appendRaw<unsigned short>(a2, &v7);
  uint64_t v7 = *(void *)(a1 + 552);
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v7);
  uint64_t v7 = *(void *)(a1 + 560);
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v7);
  uint64_t v7 = *(void *)(a1 + 568);
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v7);
  uint64_t v7 = *(void *)(a1 + 576);
  return health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v7);
}

uint64_t health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry::serialize(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = *a1;
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[1];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[2];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[3];
  return health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_setValueForKey(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, __n128 *a5, __n128 *a6)
{
  uint64_t v11 = health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::indexForKey(a4, a5);
  if (HIDWORD(v11))
  {
    if (*(_WORD *)(a4 + 544) == 17)
    {
      uint64_t v12 = a5->n128_u64[0];
      if ((int64_t)a5->n128_u64[0] < *(void *)a4
        || (int64_t)a5->n128_u64[0] <= *(void *)a4 && a5->n128_u64[1] < *(void *)(a4 + 8))
      {
        return 3;
      }
      else
      {
        uint64_t v16 = *(void *)(a4 + 512);
        if (v12 > v16 || v12 >= v16 && a5->n128_u64[1] > *(void *)(a4 + 520)) {
          return 4;
        }
        else {
          return 2;
        }
      }
    }
    else
    {
      if (HIDWORD(v11) == 2) {
        unint64_t v14 = (unsigned __int16)v11 + 1;
      }
      else {
        unint64_t v14 = (unsigned __int16)v11;
      }
      __n128 v15 = *a6;
      v17[0] = *a5;
      v17[1] = v15;
      health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, v17, v14);
      ++*(_WORD *)(a4 + 544);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
      return 0;
    }
  }
  else
  {
    *(__n128 *)(health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, (unsigned __int16)v11)+ 16) = *a6;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 1;
  }
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  unint64_t v13 = 547;
  v10[0] = v11;
  v10[1] = v11;
  id v10[2] = 547;
  health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::serialize(a4, (uint64_t)v10);
  if (v13 <= 0x3FF) {
    uint64_t v7 = v11;
  }
  else {
    uint64_t v7 = v12;
  }
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  uint64_t result = (uint64_t)v12;
  uint64_t v12 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCC2E4E0(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::serialize(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v5 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry::serialize(v5, a2);
  }
  __int16 v7 = *(_WORD *)(a1 + 544);
  health::SerializationBuffer::appendRaw<unsigned short>(a2, &v7);
  char v8 = *(unsigned char *)(a1 + 546);
  return health::SerializationBuffer::appendRaw<unsigned char>(a2, &v8);
}

void health::not_found_error::~not_found_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x1C187B8A0);
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x1C187B8A0);
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

void _ZNSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EE7__cloneEv(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F171BB58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EE7__cloneEPNS0_6__baseISE_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171BB58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EEclESA_(uint64_t a1, uint64_t a2)
{
  v8[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = **(void **)(a1 + 8);
  v7[0] = &unk_1F171BC68;
  v7[1] = a2;
  v7[3] = v7;
  char v6 = 0;
  size_t v4 = operator new(0x20uLL);
  void *v4 = &unk_1F171BBD8;
  v4[1] = v2;
  v4[2] = v7;
  v4[3] = &v6;
  void v8[3] = v4;
  health::DataStore::performReadTransactionWithLambda(v3, (uint64_t)v8);
  std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100](v8);
  std::__function::__value_func<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>::~__value_func[abi:ne180100](v7);
  return 1;
}

void sub_1BCC2E80C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_NS_9allocatorISB_EEFbSA_EE11target_typeEv()
{
  return &_ZTIZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_EUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_;
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::~__func()
{
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F171BBD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171BBD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::operator()(uint64_t a1, health::DataStore::ReadTransaction *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v16 = 0u;
  ObjectIdentifier v17 = (ObjectIdentifier)0;
  int v18 = a2;
  size_t v4 = *(ObjectIdentifier **)(a1 + 8);
  health::DataStore::ReadTransaction::_pointerForObject(a2, v4, (uint64_t)v19);
  if (v19[16])
  {
    uint64_t v5 = (uint64_t *)*((void *)a2 + 3);
    uint64_t v6 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v19);
    uint64_t v7 = *v6;
    uint64_t v8 = v6[1];
    uint64_t v24 = 0;
    unint64_t v25 = 56;
    v21[0] = v23;
    v21[1] = 56;
    health::BlockAccessFile::ReadTransaction::retrieveBlock(v5, v7, v8, (uint64_t)v21);
    if (v25 <= 0x3FF) {
      char v9 = v23;
    }
    else {
      char v9 = v24;
    }
    v20[0] = v9;
    v20[1] = v9;
    v20[2] = 56;
    uint64_t v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    v12[0] = v22;
    uint64_t v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    v12[1] = v22;
    uint64_t v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    *(void *)&long long v13 = v22;
    uint64_t v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    *((void *)&v13 + 1) = v22;
    uint64_t v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    *(void *)&long long v14 = v22;
    uint64_t v22 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v20, &v22);
    *((void *)&v14 + 1) = v22;
    uint64_t v22 = 0;
    health::DeserializationBuffer::extractRaw<long long>((uint64_t)v20, &v22);
    uint64_t v15 = v22;
    int v10 = v24;
    uint64_t v24 = 0;
    if (v10) {
      MEMORY[0x1C187B880](v10, 0x1000C8077774924);
    }
    ObjectIdentifier v17 = *v4;
    long long v16 = *(_OWORD *)health::Optional<health::BlockPointer>::get((uint64_t)v19);
    uint64_t v11 = *(void *)(*(void *)(a1 + 16) + 24);
    if (!v11) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v12);
    **(unsigned char **)(a1 + 24) = 1;
  }
}

void sub_1BCC2EB30(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x4A8];
  STACK[0x4A8] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target_type()
{
}

void *std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F171BC68;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EE7__cloneEPNS0_6__baseISK_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F171BC68;
  a2[1] = v2;
  return result;
}

void *_ZNSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EEclESG_(uint64_t a1, void *a2)
{
  v10[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  v9[0] = &unk_1F171BCE8;
  v9[1] = v2;
  v9[3] = v9;
  if (a2[6])
  {
    uint64_t v3 = *(uint64_t **)(a2[11] + 24);
    v7[0] = 0;
    v7[1] = 0;
    void v7[2] = v3;
    uint64_t v4 = a2[3];
    v6[0] = a2[2];
    v6[1] = v4;
    id v6[2] = (uint64_t)v7;
    void v10[3] = v10;
    v10[0] = &unk_1F171BCE8;
    v10[1] = v2;
    memset(v8, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v3, v6[0], v4, (uint64_t)v8);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV0>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>)::{lambda(double const&,_HDRawLocationDatumV0 const&)#1}>((uint64_t)v6, 0, (uint64_t)v8, (uint64_t)v10);
    std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>::~__value_func[abi:ne180100](v10);
  }
  return std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>::~__value_func[abi:ne180100](v9);
}

void sub_1BCC2EDFC(_Unwind_Exception *a1)
{
  std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>::~__value_func[abi:ne180100]((void *)(v1 - 56));
  std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>::~__value_func[abi:ne180100]((void *)(v1 - 88));
  _Unwind_Resume(a1);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clES7_EUlRKNS1_13SampleHistoryI25LocationHistoryBehaviorV0EEE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_EUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_NS_9allocatorISH_EEFvSG_EE11target_typeEv()
{
  return &_ZTIZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clES7_EUlRKNS1_13SampleHistoryI25LocationHistoryBehaviorV0EEE_;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV0>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>)::{lambda(double const&,_HDRawLocationDatumV0 const&)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  if (*(_WORD *)(a3 + 408))
  {
    uint64_t v6 = result;
    if (*(unsigned char *)(a3 + 410))
    {
      uint64_t v7 = *(void *)(a3 + 8);
      uint64_t v8 = *(void *)(a3 + 16);
      uint64_t v37 = result;
      uint64_t v9 = *(void *)(result + 16);
      bzero(__p, 0x222uLL);
      long long v40 = 0u;
      long long v41 = 0u;
      __n128 result = health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>>(*(uint64_t **)(v9 + 16), v7, v8, (uint64_t)__p);
      int v10 = (void **)MEMORY[0x1E4F29F18];
      if (v39)
      {
        unint64_t v11 = 0;
        double v12 = 0.0;
        while (1)
        {
          long long v13 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)__p, v11);
          uint64_t v14 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)__p, v11);
          if (v11)
          {
            v15.n128_u64[0] = *v13;
            if (*(double *)v13 <= v12)
            {
              long long v16 = *v10;
              std::string::basic_string[abi:ne180100]<0>(v57, "key > lastKey");
              std::string::basic_string[abi:ne180100]<0>(v56, "_enumerateLeaves");
              std::string::basic_string[abi:ne180100]<0>(&v55, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
              health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v54);
              health::_HDAssertImplementation<health::btree_access_error>(v16, (uint64_t)v57, (uint64_t)v56, (uint64_t)&v55, 382, (uint64_t)&v54);
            }
          }
          uint64_t v17 = *(void *)(a4 + 24);
          if (!v17) {
LABEL_35:
          }
            std::__throw_bad_function_call[abi:ne180100]();
          double v12 = *(double *)v13;
          __n128 result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(void *)v17 + 48))(v17, v13, v14 + 8, v15);
          if ((result & 1) == 0) {
            break;
          }
          if (++v11 >= v39) {
            goto LABEL_23;
          }
        }
      }
      else
      {
        double v12 = 0.0;
LABEL_23:
        uint64_t v28 = *((void *)&v41 + 1);
        for (uint64_t i = v41; ; uint64_t i = v46)
        {
          uint64_t v29 = *(void *)(v37 + 16);
          if (i == *(void *)v29 && v28 == *(void *)(v29 + 8)) {
            break;
          }
          bzero(v43, 0x222uLL);
          long long v45 = 0u;
          long long v46 = 0u;
          health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>>(*(uint64_t **)(v29 + 16), i, v28, (uint64_t)v43);
          if (!v44)
          {
            __int16 v30 = *v10;
            std::string::basic_string[abi:ne180100]<0>(v53, "leaf.valueCount > 0");
            std::string::basic_string[abi:ne180100]<0>(v52, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(&v51, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v50);
            health::_HDAssertImplementation<health::btree_access_error>(v30, (uint64_t)v53, (uint64_t)v52, (uint64_t)&v51, 392, (uint64_t)&v50);
          }
          for (unint64_t j = 0; j < v44; ++j)
          {
            long long v32 = (double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v43, j);
            uint64_t v33 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v43, j);
            if (*v32 <= v12)
            {
              char v35 = *v10;
              std::string::basic_string[abi:ne180100]<0>(v49, "key > lastKey");
              std::string::basic_string[abi:ne180100]<0>(v48, "_enumerateLeaves");
              std::string::basic_string[abi:ne180100]<0>(&v47, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
              health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v42);
              health::_HDAssertImplementation<health::btree_access_error>(v35, (uint64_t)v49, (uint64_t)v48, (uint64_t)&v47, 396, (uint64_t)&v42);
            }
            uint64_t v36 = *(void *)(a4 + 24);
            if (!v36) {
              goto LABEL_35;
            }
            double v12 = *v32;
            v34.n128_f64[0] = *v32;
            __n128 result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(void *)v36 + 48))(v36, v32, v33 + 8, v34);
            if ((result & 1) == 0) {
              return result;
            }
          }
          uint64_t v28 = *((void *)&v46 + 1);
        }
      }
    }
    else
    {
      if (a2 >= 64)
      {
        uint64_t v19 = (void *)*MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(__p, "depth < kMaximumRecursionDepth");
        std::string::basic_string[abi:ne180100]<0>(v57, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v56, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Maximum recursion depth reached.", &v55);
        health::_HDAssertImplementation<health::btree_access_error>(v19, (uint64_t)__p, (uint64_t)v57, (uint64_t)v56, 138, (uint64_t)&v55);
      }
      uint64_t v20 = *(void *)(a3 + 8);
      uint64_t v21 = *(void *)(a3 + 16);
      uint64_t v22 = *(void *)(result + 16);
      memset(v43, 0, 411);
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v22 + 16), v20, v21, (uint64_t)v43);
      if (WORD4(v43[25]))
      {
        v23.n128_u64[0] = *(void *)&v43[0];
        if (*(double *)v43 < *(double *)a3)
        {
          uint64_t v24 = (void *)*MEMORY[0x1E4F29F18];
          std::string::basic_string[abi:ne180100]<0>(&v54, "child.children[0].key >= node.children[index].key");
          std::string::basic_string[abi:ne180100]<0>(v53, "_interiorChildAtIndex");
          std::string::basic_string[abi:ne180100]<0>(v52, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v51);
          health::_HDAssertImplementation<health::btree_access_error>(v24, (uint64_t)&v54, (uint64_t)v53, (uint64_t)v52, 144, (uint64_t)&v51);
        }
        if (*(unsigned __int16 *)(a3 + 408) >= 2u)
        {
          unint64_t v25 = (unint64_t *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v43, WORD4(v43[25]) - 1);
          v23.n128_u64[0] = *v25;
          if (*(double *)v25 >= *(double *)(a3 + 24))
          {
            uint64_t v26 = (void *)*MEMORY[0x1E4F29F18];
            std::string::basic_string[abi:ne180100]<0>(&v50, "child.children[child.childCount - 1].key < node.children[index + 1].key");
            std::string::basic_string[abi:ne180100]<0>(v49, "_interiorChildAtIndex");
            std::string::basic_string[abi:ne180100]<0>(v48, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v47);
            health::_HDAssertImplementation<health::btree_access_error>(v26, (uint64_t)&v50, (uint64_t)v49, (uint64_t)v48, 146, (uint64_t)&v47);
          }
        }
      }
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV0>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>)::{lambda(double const&,_HDRawLocationDatumV0 const&)#1}>(v6, (a2 + 1), v43, a4, v23);
    }
  }
  return result;
}

void sub_1BCC2F54C(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x4D7]) < 0) {
    operator delete((void *)STACK[0x4C0]);
  }
  if (SLOBYTE(STACK[0x4EF]) < 0) {
    operator delete((void *)STACK[0x4D8]);
  }
  if (SLOBYTE(STACK[0x507]) < 0) {
    operator delete((void *)STACK[0x4F0]);
  }
  if (SLOBYTE(STACK[0x51F]) < 0) {
    operator delete((void *)STACK[0x508]);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::InteriorNode<double,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v5 = (void *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    uint64_t v7 = 0;
    health::DeserializationBuffer::extractRaw<long long>(a2, &v7);
    *uint64_t v5 = v7;
    health::BlockPointer::deserialize(v5 + 1, a2);
  }
  __int16 v8 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v8);
  *(_WORD *)(a1 + 408) = v8;
  char v9 = 0;
  uint64_t result = health::DeserializationBuffer::extractRaw<unsigned char>(a2, &v9);
  *(unsigned char *)(a1 + 410) = v9 != 0;
  return result;
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  long long v16 = 0;
  unint64_t v17 = 578;
  health::RawBuffer::RawBuffer(v13, v15, 578);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v13);
  unint64_t v8 = 0;
  char v9 = v15;
  if (v17 > 0x3FF) {
    char v9 = v16;
  }
  v12[0] = v9;
  v12[1] = v9;
  void v12[2] = 578;
  do
  {
    uint64_t v10 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a4, v8);
    uint64_t v14 = 0;
    health::DeserializationBuffer::extractRaw<long long>((uint64_t)v12, &v14);
    *(void *)uint64_t v10 = v14;
    uint64_t v14 = 0;
    health::DeserializationBuffer::extractRaw<long long>((uint64_t)v12, &v14);
    *(void *)(v10 + 8) = v14;
    uint64_t v14 = 0;
    health::DeserializationBuffer::extractRaw<long long>((uint64_t)v12, &v14);
    *(void *)(v10 + 16) = v14;
    LODWORD(v14) = 0;
    health::DeserializationBuffer::extractRaw<int>((uint64_t)v12, &v14);
    *(_DWORD *)(v10 + 24) = v14;
    LODWORD(v14) = 0;
    health::DeserializationBuffer::extractRaw<int>((uint64_t)v12, &v14);
    *(_DWORD *)(v10 + 28) = v14;
    ++v8;
  }
  while (v8 != 17);
  LOWORD(v14) = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>((uint64_t)v12, &v14);
  *(_WORD *)(a4 + 544) = v14;
  health::BlockPointer::deserialize((void *)(a4 + 552), (uint64_t)v12);
  health::BlockPointer::deserialize((void *)(a4 + 568), (uint64_t)v12);
  uint64_t result = (uint64_t)v16;
  long long v16 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCC2F9D8(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x438];
  STACK[0x438] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV0,health::BlockPointer,17>::ValueEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x11)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 32 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  void v7[2];

  if (a2 >= 0x11)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 32 * a2;
}

void sub_1BCC2FAF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

void sub_1BCC2FC40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

void _ZNSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F171BCE8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EE7__cloneEPNS0_6__baseISQ_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F171BCE8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EEclESP_SK_(uint64_t a1, uint64_t *a2, long long *a3)
{
  uint64_t v8 = *a2;
  long long v4 = *a3;
  uint64_t v5 = *((void *)a3 + 2);
  uint64_t v6 = 3212836864;
  int v7 = 0;
  health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1>::insertSample(*(void *)(a1 + 8), (double *)&v8, (uint64_t)&v4);
  return 1;
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clES7_ENKUlRKNS1_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESD_EUldRK21_HDRawLocationDatumV0E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS4_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clESA_ENKUlRKNS4_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESG_EUldRK21_HDRawLocationDatumV0E_NS_9allocatorISL_EEFbRKdSK_EE11target_typeEv()
{
  return &_ZTIZZZZZZ69__HDDatabaseMigrator_Whitetail___addFieldsToLocationSeriesWithError__EUb_ENK3__0clERN6health9DataStore16WriteTransactionEEUb_ENKUlRNS1_20MutableSampleHistoryI25LocationHistoryBehaviorV1EEE_clES7_ENKUlRKNS1_13SampleHistoryI25LocationHistoryBehaviorV0EEE_clESD_EUldRK21_HDRawLocationDatumV0E_;
}

uint64_t health::bplustree::InteriorNode<double,health::BlockPointer,17>::serialize(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v5 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry::serialize(v5, a2);
  }
  __int16 v7 = *(_WORD *)(a1 + 408);
  health::SerializationBuffer::appendRaw<unsigned short>(a2, &v7);
  char v8 = *(unsigned char *)(a1 + 410);
  return health::SerializationBuffer::appendRaw<unsigned char>(a2, &v8);
}

uint64_t health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry::serialize(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = *a1;
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[1];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[2];
  return health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, double *a5, uint64_t a6)
{
  if (*(_WORD *)(a4 + 408))
  {
    int v11 = a2 + 1;
    if (*(unsigned char *)(a4 + 410))
    {
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKeyWithLeafChildren(a1, v11, a3, a4, a5, a6);
    }
    else
    {
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKeyWithInteriorChildren(a1, v11, a3, a4, a5, a6);
    }
  }
  else
  {
    bzero(v23, 0x300uLL);
    long long v13 = *(long long **)(a1 + 16);
    long long v24 = *v13;
    long long v25 = *v13;
    double v19 = *a5;
    long long v14 = *(_OWORD *)(a6 + 16);
    long long v20 = *(_OWORD *)a6;
    long long v21 = v14;
    v23[384] = 1;
    uint64_t v22 = *(void *)(a6 + 32);
    __n128 v15 = (health::BlockAccessFile::WriteTransaction *)*((void *)v13 + 3);
    uint64_t v16 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v15, 782);
    uint64_t v18 = v17;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>((uint64_t)v15, v16, v17, (uint64_t)&v19);
    *(double *)a4 = *a5;
    *(void *)(a4 + 8) = v16;
    *(void *)(a4 + 16) = v18;
    *(_WORD *)(a4 + 408) = 1;
    *(unsigned char *)(a4 + 410) = 1;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 0;
  }
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKeyWithLeafChildren(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, double *a5, uint64_t a6)
{
  unsigned int v12 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
  long long v62 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12)+ 8);
  uint64_t v13 = *(void *)(a1 + 16);
  bzero(v58, 0x332uLL);
  long long v60 = 0u;
  long long v61 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v13 + 24), v62, *((uint64_t *)&v62 + 1), (uint64_t)v58);
  uint64_t v14 = (a2 + 1);
  uint64_t v15 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(a1, v14, (uint64_t *)&v62, (uint64_t)v58, a5, (long long *)a6);
  uint64_t v16 = v15;
  if (v15 > 1)
  {
    int v19 = *(unsigned __int16 *)(a4 + 408);
    if (v19 == 17)
    {
      if (v15 == 4) {
        unsigned int v20 = 4;
      }
      else {
        unsigned int v20 = 2;
      }
      if (v15 == 3) {
        int v21 = 3;
      }
      else {
        int v21 = 2;
      }
      if (v12) {
        unsigned int v22 = 2;
      }
      else {
        unsigned int v22 = v21;
      }
      if (v12 == 16) {
        return v20;
      }
      else {
        return v22;
      }
    }
    else if (v15 == 4 && v19 - 1 == v12)
    {
      bzero(&v54, 0x300uLL);
      double v50 = *a5;
      long long v23 = *(_OWORD *)a6;
      long long v52 = *(_OWORD *)(a6 + 16);
      __int16 v55 = 1;
      uint64_t v53 = *(void *)(a6 + 32);
      long long v51 = v23;
      long long v56 = v62;
      long long v57 = v61;
      long long v24 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
      uint64_t v25 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v24, 782);
      uint64_t v27 = v26;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>((uint64_t)v24, v25, v26, (uint64_t)&v50);
      *(void *)&long long v61 = v25;
      *((void *)&v61 + 1) = v27;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v62, *((uint64_t *)&v62 + 1), (uint64_t)v58);
      uint64_t v28 = *(void *)(a1 + 16);
      long long v29 = v57;
      if (v57 != *(_OWORD *)v28)
      {
        bzero(&v46, 0x332uLL);
        long long v48 = 0u;
        long long v49 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v28 + 24), v29, *((uint64_t *)&v29 + 1), (uint64_t)&v46);
        *(void *)&long long v48 = v25;
        *((void *)&v48 + 1) = v27;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v57, *((uint64_t *)&v57 + 1), (uint64_t)&v46);
      }
      unint64_t v30 = *(unsigned __int16 *)(a4 + 408);
      uint64_t v31 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v30);
      *(void *)(v31 + 8) = v25;
      *(void *)(v31 + 16) = v27;
      double v32 = *a5;
      *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v30) = v32;
      ++*(_WORD *)(a4 + 408);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
      return 0;
    }
    else
    {
      long long v43 = a3;
      long long v45 = v62;
      bzero(&v50, 0x332uLL);
      long long v56 = v62;
      long long v57 = v61;
      health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)&v50, 0, (uint64_t)v58, v59 - 8, 8);
      v59 -= 8;
      __int16 v55 = 8;
      uint64_t v33 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
      unint64_t v34 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v33, 782);
      uint64_t v36 = v35;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>((uint64_t)v33, v34, v35, (uint64_t)&v50);
      *(void *)&long long v44 = v34;
      *((void *)&v44 + 1) = v36;
      long long v61 = v44;
      uint64_t v37 = *(void *)(a1 + 16);
      uint64_t v38 = v57;
      if (v57 != *(_OWORD *)v37)
      {
        uint64_t v42 = *((void *)&v57 + 1);
        bzero(&v46, 0x332uLL);
        long long v48 = 0u;
        long long v49 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v37 + 24), v38, v42, (uint64_t)&v46);
        long long v48 = v44;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v57, *((uint64_t *)&v57 + 1), (uint64_t)&v46);
      }
      v46.n128_f64[0] = v50;
      v46.n128_u64[1] = v34;
      uint64_t v47 = v36;
      health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, &v46, v12 + 1);
      ++*(_WORD *)(a4 + 408);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v45, *((uint64_t *)&v45 + 1), (uint64_t)v58);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *v43, v43[1], a4);
      if (*a5 <= v50)
      {
        unsigned __int16 v39 = (uint64_t *)&v45;
        long long v40 = (double *)v58;
      }
      else
      {
        unsigned __int16 v39 = (uint64_t *)&v44;
        long long v40 = &v50;
      }
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(a1, v14, v39, (uint64_t)v40, a5, (long long *)a6);
    }
  }
  else
  {
    double v17 = *a5;
    if (v17 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12))
    {
      double v18 = *a5;
      *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12) = v18;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    }
  }
  return v16;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKeyWithInteriorChildren(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, double *a5, uint64_t a6)
{
  unsigned int v12 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
  unint64_t v13 = v12;
  long long v34 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v12)+ 8);
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_interiorChildAtIndex(a1, a2, a4, v12, (uint64_t)v31);
  uint64_t v14 = (a2 + 1);
  uint64_t v15 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(a1, v14, &v34, v31, a5, a6);
  if (v15 > 1)
  {
    if (*(_WORD *)(a4 + 408) == 17)
    {
      return 2;
    }
    else
    {
      long long v30 = v34;
      memset(v29, 0, 411);
      BYTE10(v29[25]) = v33;
      health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v29, 0, (uint64_t)v31, v32 - 8, 8);
      v32 -= 8;
      WORD4(v29[25]) = 8;
      int v19 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
      unint64_t v20 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v19, 411);
      uint64_t v22 = v21;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v19, v20, v21, (uint64_t)v29);
      v28[0] = v20;
      v28[1] = v22;
      v26.n128_u64[0] = *(void *)&v29[0];
      v26.n128_u64[1] = v20;
      uint64_t v27 = v22;
      health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, &v26, v13 + 1);
      ++*(_WORD *)(a4 + 408);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v30, *((uint64_t *)&v30 + 1), (uint64_t)v31);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
      if (*a5 <= *(double *)v29)
      {
        long long v23 = &v30;
        long long v24 = v31;
      }
      else
      {
        long long v23 = (long long *)v28;
        long long v24 = v29;
      }
      return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(a1, v14, v23, v24, a5, a6);
    }
  }
  else
  {
    uint64_t v16 = v15;
    double v17 = *a5;
    if (v17 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v13))
    {
      double v18 = *a5;
      *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v13) = v18;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    }
  }
  return v16;
}

uint64_t _HDRawLocationDatumV1::serialize(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = *a1;
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  uint64_t v5 = a1[1];
  health::SerializationBuffer::appendRaw<unsigned long long>(a2, &v5);
  LODWORD(v5) = *((_DWORD *)a1 + 4);
  health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
  LODWORD(v5) = *((_DWORD *)a1 + 5);
  health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
  LODWORD(v5) = *((_DWORD *)a1 + 6);
  health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
  LODWORD(v5) = *((_DWORD *)a1 + 7);
  health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
  LODWORD(v5) = *((_DWORD *)a1 + 8);
  return health::SerializationBuffer::appendRaw<unsigned int>(a2, &v5);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_setValueForKey(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, double *a5, long long *a6)
{
  uint64_t v11 = health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::indexForKey(a4, a5);
  if (HIDWORD(v11))
  {
    if (*(_WORD *)(a4 + 816) == 17)
    {
      if (*a5 >= *(double *)a4)
      {
        if (*a5 <= *(double *)(a4 + 768)) {
          return 2;
        }
        else {
          return 4;
        }
      }
      else
      {
        return 3;
      }
    }
    else
    {
      if (HIDWORD(v11) == 2) {
        unint64_t v16 = (unsigned __int16)v11 + 1;
      }
      else {
        unint64_t v16 = (unsigned __int16)v11;
      }
      double v17 = *a5;
      long long v18 = a6[1];
      long long v20 = *a6;
      long long v21 = v18;
      uint64_t v22 = *((void *)a6 + 4);
      double v19 = v17;
      health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::insertElementAtIndex(a4, (uint64_t)&v19, v16);
      ++*(_WORD *)(a4 + 816);
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
      return 0;
    }
  }
  else
  {
    uint64_t v13 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a4, (unsigned __int16)v11);
    uint64_t v14 = *((void *)a6 + 4);
    long long v15 = a6[1];
    *(_OWORD *)(v13 + 8) = *a6;
    *(_OWORD *)(v13 + 24) = v15;
    *(void *)(v13 + 40) = v14;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 1;
  }
}

uint64_t health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v5 = (void *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a1, i);
    uint64_t v7 = 0;
    health::DeserializationBuffer::extractRaw<long long>(a2, &v7);
    *uint64_t v5 = v7;
    _HDRawLocationDatumV1::deserialize((uint64_t)(v5 + 1), a2);
  }
  __int16 v8 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v8);
  *(_WORD *)(a1 + 816) = v8;
  health::BlockPointer::deserialize((void *)(a1 + 824), a2);
  return health::BlockPointer::deserialize((void *)(a1 + 840), a2);
}

float _HDRawLocationDatumV1::deserialize(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  *(void *)a1 = v5;
  uint64_t v5 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  *(void *)(a1 + 8) = v5;
  LODWORD(v5) = 0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v5);
  *(_DWORD *)(a1 + 16) = v5;
  LODWORD(v5) = 0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v5);
  *(_DWORD *)(a1 + 20) = v5;
  LODWORD(v5) = 0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v5);
  *(_DWORD *)(a1 + 24) = v5;
  LODWORD(v5) = 0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v5);
  *(_DWORD *)(a1 + 28) = v5;
  LODWORD(v5) = 0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v5);
  float result = *(float *)&v5;
  *(_DWORD *)(a1 + 32) = v5;
  return result;
}

double *health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_interiorChildAtIndex@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  if (*(unsigned __int16 *)(a3 + 408) <= a4)
  {
    char v9 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v35, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v34, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v33, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v32);
    health::_HDAssertImplementation<health::btree_access_error>(v9, (uint64_t)v35, (uint64_t)v34, (uint64_t)v33, 137, (uint64_t)&v32);
  }
  if (a2 >= 64)
  {
    uint64_t v10 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v31, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v30, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v29, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29, 138, (uint64_t)&__p);
  }
  uint64_t v11 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
  uint64_t v12 = *(void *)(v11 + 8);
  uint64_t v13 = *(void *)(v11 + 16);
  uint64_t v14 = *(void *)(a1 + 16);
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  *(_OWORD *)(a5 + 160) = 0u;
  *(_OWORD *)(a5 + 176) = 0u;
  *(_OWORD *)(a5 + 192) = 0u;
  *(_OWORD *)(a5 + 208) = 0u;
  *(_OWORD *)(a5 + 224) = 0u;
  *(_OWORD *)(a5 + 240) = 0u;
  *(_OWORD *)(a5 + 256) = 0u;
  *(_OWORD *)(a5 + 272) = 0u;
  *(_OWORD *)(a5 + 288) = 0u;
  *(_OWORD *)(a5 + 304) = 0u;
  *(_OWORD *)(a5 + 320) = 0u;
  *(_OWORD *)(a5 + 336) = 0u;
  *(_OWORD *)(a5 + 352) = 0u;
  *(_OWORD *)(a5 + 368) = 0u;
  *(_OWORD *)(a5 + 384) = 0u;
  *(_OWORD *)(a5 + 395) = 0u;
  float result = (double *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v14 + 24), v12, v13, a5);
  if (*(_WORD *)(a5 + 408))
  {
    double v16 = *(double *)a5;
    float result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
    if (v16 < *result)
    {
      double v17 = (void *)*MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v27, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v26, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v24);
      health::_HDAssertImplementation<health::btree_access_error>(v17, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 144, (uint64_t)&v24);
    }
    if (*(unsigned __int16 *)(a3 + 408) - 1 > (int)a4)
    {
      double v18 = *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, *(unsigned __int16 *)(a5 + 408) - 1);
      float result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4 + 1);
      if (v18 >= *result)
      {
        double v19 = (void *)*MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(v23, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v22, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v20);
        health::_HDAssertImplementation<health::btree_access_error>(v19, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 146, (uint64_t)&v20);
      }
    }
  }
  return result;
}

void sub_1BCC30E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

void *health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::copyElementsFromArrayToIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((unint64_t)(a5 + a2) >= 0x12)
  {
    uint64_t v5 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v15, "destinationIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v14, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow destination.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 79, (uint64_t)&__p);
  }
  if ((unint64_t)(a5 + a4) >= 0x12)
  {
    uint64_t v6 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v11, "sourceIndex + elementCount <= Length");
    std::string::basic_string[abi:ne180100]<0>(v10, "copyElementsFromArrayToIndex");
    std::string::basic_string[abi:ne180100]<0>(v9, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Copy would overflow source.", &v8);
    health::_HDAssertImplementation<std::out_of_range>(v6, (uint64_t)v11, (uint64_t)v10, (uint64_t)v9, 80, (uint64_t)&v8);
  }
  return memcpy((void *)(a1 + 24 * a2), (const void *)(a3 + 24 * a4), 24 * a5);
}

void sub_1BCC311CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV0 const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV0> const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<BOOL ()(health::DataStore::MutableSampleHistory<LocationHistoryBehaviorV1> &)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<BOOL ()(health::DataStore::WriteTransaction &)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1BCC31668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__16(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
}

void sub_1BCC318C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableNanoSyncActivationRestoreReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  long long v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = PBReaderReadData();
          uint64_t v18 = 32;
          goto LABEL_35;
        case 2u:
          char v19 = 0;
          unsigned int v20 = 0;
          uint64_t v21 = 0;
          *(unsigned char *)(a1 + 44) |= 1u;
          while (2)
          {
            uint64_t v22 = *v3;
            unint64_t v23 = *(void *)(a2 + v22);
            if (v23 == -1 || v23 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v24 = *(unsigned char *)(*(void *)(a2 + *v7) + v23);
              *(void *)(a2 + v22) = v23 + 1;
              v21 |= (unint64_t)(v24 & 0x7F) << v19;
              if (v24 < 0)
              {
                v19 += 7;
                BOOL v14 = v20++ >= 9;
                if (v14)
                {
                  uint64_t v21 = 0;
                  goto LABEL_44;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v21 = 0;
          }
LABEL_44:
          *(void *)(a1 + 8) = v21;
          continue;
        case 3u:
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          *(unsigned char *)(a1 + 44) |= 2u;
          break;
        case 4u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 16;
LABEL_35:
          uint64_t v31 = *(void **)(a1 + v18);
          *(void *)(a1 + v18) = v17;

          continue;
        case 6u:
          char v33 = PBReaderReadData();
          if (v33) {
            [(id)a1 addObliteratedHealthPairingUUIDs:v33];
          }

          continue;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v28 = *v3;
        unint64_t v29 = *(void *)(a2 + v28);
        if (v29 == -1 || v29 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
        *(void *)(a2 + v28) = v29 + 1;
        v27 |= (unint64_t)(v30 & 0x7F) << v25;
        if ((v30 & 0x80) == 0) {
          goto LABEL_46;
        }
        v25 += 7;
        BOOL v14 = v26++ >= 9;
        if (v14)
        {
          LODWORD(v27) = 0;
          goto LABEL_48;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_46:
      if (*(unsigned char *)(a2 + *v5)) {
        LODWORD(v27) = 0;
      }
LABEL_48:
      *(_DWORD *)(a1 + 40) = v27;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCategorySampleEntityPredicateEqualToValues(uint64_t a1)
{
  return [MEMORY[0x1E4F65D08] predicateWithProperty:@"value" equalToValues:a1];
}

uint64_t HDDatabaseCurrentSchemaVersion(uint64_t a1, int a2)
{
  uint64_t v2 = 100002;
  if (a1 == 2) {
    uint64_t v2 = 100017;
  }
  uint64_t v3 = 18201;
  if (a1 == 2) {
    uint64_t v3 = 18006;
  }
  if (a2) {
    return v2;
  }
  else {
    return v3;
  }
}

uint64_t HDCodableRoutineLocationResponseReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  long long v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = objc_alloc_init(HDCodableRoutineLocation);
        objc_storeStrong((id *)(a1 + 8), v17);
        if (!PBReaderPlaceMark() || (HDCodableRoutineLocationReadFrom(v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCC385B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a66, 8);
  _Block_object_dispose(&a70, 8);
  _Block_object_dispose(&STACK[0x208], 8);
  _Block_object_dispose(&STACK[0x228], 8);
  _Block_object_dispose(&STACK[0x248], 8);

  _Block_object_dispose((const void *)(v70 - 240), 8);
  _Block_object_dispose(&STACK[0x2A0], 8);
  unint64_t v72 = (void *)STACK[0x2D8];
  if (STACK[0x2D8])
  {
    STACK[0x2E0] = (unint64_t)v72;
    operator delete(v72);
  }
  _Block_object_dispose(&STACK[0x300], 8);
  _Block_object_dispose((const void *)(v70 - 192), 8);

  _Block_object_dispose(&STACK[0x320], 8);
  _Unwind_Resume(a1);
}

void sub_1BCC38A40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC38AB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC38B60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__17(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__17(uint64_t a1)
{
}

__n128 __Block_byref_object_copy__308(__n128 *a1, uint64_t a2)
{
  unsigned __int32 v2 = *(_DWORD *)(a2 + 48);
  a1[3].n128_u8[4] = *(unsigned char *)(a2 + 52);
  a1[3].n128_u32[0] = v2;
  a1[4].n128_u64[0] = 0;
  a1[4].n128_u64[1] = 0;
  a1[3].n128_u64[1] = 0;
  *(__n128 *)((char *)a1 + 56) = *(__n128 *)(a2 + 56);
  a1[4].n128_u64[1] = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  __n128 result = *(__n128 *)(a2 + 80);
  a1[5] = result;
  return result;
}

void __Block_byref_object_dispose__309(uint64_t a1)
{
  unsigned __int32 v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
}

void sub_1BCC38C70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC39390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14)
{
  _Block_object_dispose((const void *)(v20 - 168), 8);
  _Unwind_Resume(a1);
}

void sub_1BCC395F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1BCC39A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1BCC39D38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC39E70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC39F08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC39F88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC3A0D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC3A178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double _overlappingSampleDistanceForInterval(void *a1, double *a2, BOOL *a3)
{
  id v5 = a1;
  uint64_t v6 = [v5 startDate];
  [v6 timeIntervalSinceReferenceDate];
  double v8 = v7;

  unsigned int v9 = [v5 endDate];
  [v9 timeIntervalSinceReferenceDate];
  double v11 = v10;

  double v12 = *a2;
  double v13 = a2[1];
  double v14 = a2[2];
  if (a3) {
    *a3 = v13 < v11;
  }
  double v15 = v14 / (v13 - v12);
  if (v11 < v13) {
    double v13 = v11;
  }
  if (v8 >= v12) {
    double v12 = v8;
  }
  double v16 = v15 * fmax(v13 - v12, 0.0);

  return v16;
}

void sub_1BCC3A240(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC3A598(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC3A810(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC3AA3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a1);
}

void __cxx_global_array_dtor()
{
  for (uint64_t i = 0; i != -21; i -= 3)
  {
  }
}

void sub_1BCC3C1B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__18(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
}

void sub_1BCC3C5A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id unimplementedError()
{
  v6[1] = *MEMORY[0x1E4F143B8];
  unint64_t v0 = (void *)MEMORY[0x1E4F28C58];
  uint64_t v1 = *MEMORY[0x1E4F29B70];
  uint64_t v5 = *MEMORY[0x1E4F28568];
  v6[0] = @"Unimplemented";
  unsigned __int32 v2 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v6 forKeys:&v5 count:1];
  uint64_t v3 = [v0 errorWithDomain:v1 code:100 userInfo:v2];

  return v3;
}

void sub_1BCC3EAA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1BCC3ED70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__19(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
}

void sub_1BCC3FA00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1BCC400D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1BCC42B64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__20(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
}

void sub_1BCC44444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
}

uint64_t __Block_byref_object_copy__21(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__21(uint64_t a1)
{
}

void sub_1BCC464A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCC47D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCC48B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDPauseRingsScheduleEntityPredicateForCacheIndexRange(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F65D00];
  long long v4 = [NSNumber numberWithLongLong:a2];
  uint64_t v5 = [v3 predicateWithProperty:@"start_date_index" value:v4 comparisonType:4];

  uint64_t v6 = (void *)MEMORY[0x1E4F65D00];
  double v7 = [NSNumber numberWithLongLong:a1];
  double v8 = [v6 predicateWithProperty:@"end_date_index" value:v7 comparisonType:6];

  unsigned int v9 = [MEMORY[0x1E4F65D58] compoundPredicateWithPredicate:v5 otherPredicate:v8];

  return v9;
}

void sub_1BCC4EC94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__22(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__22(uint64_t a1)
{
}

BOOL HDCodableSharingSetupMetadataReadFrom(char *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  long long v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  double v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      if (v9++ >= 9)
      {
        unint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = 48;
        goto LABEL_28;
      case 2u:
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 24;
        goto LABEL_28;
      case 3u:
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 40;
        goto LABEL_28;
      case 4u:
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 32;
        goto LABEL_28;
      case 5u:
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = 16;
LABEL_28:
        char v19 = *(HDCodableSharingSetupInvitationToken **)&a1[v18];
        *(void *)&a1[v18] = v17;
        goto LABEL_29;
      default:
        if ((v10 >> 3) != 100)
        {
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0;
          }
LABEL_30:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
        char v19 = objc_alloc_init(HDCodableSharingSetupInvitationToken);
        [a1 addInvitationToken:v19];
        if (PBReaderPlaceMark() && HDCodableSharingSetupInvitationTokenReadFrom((uint64_t)v19, a2))
        {
          PBReaderRecallMark();
LABEL_29:

          goto LABEL_30;
        }

        return 0;
    }
  }
}

void sub_1BCC51338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__23(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__23(uint64_t a1)
{
}

void sub_1BCC52684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
}

uint64_t __Block_byref_object_copy__24(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__24(uint64_t a1)
{
}

uint64_t HDCodableStartWorkoutAppResponseReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  long long v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    double v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        uint64_t v20 = objc_alloc_init(HDCodableError);
        objc_storeStrong((id *)(a1 + 8), v20);
        if (!PBReaderPlaceMark() || (HDCodableErrorReadFrom((uint64_t)v20, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else if (v17 == 2)
      {
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v23 = 0;
        *(unsigned char *)(a1 + 28) |= 1u;
        while (1)
        {
          uint64_t v24 = *v3;
          unint64_t v25 = *(void *)(a2 + v24);
          if (v25 == -1 || v25 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v26 = *(unsigned char *)(*(void *)(a2 + *v7) + v25);
          *(void *)(a2 + v24) = v25 + 1;
          v23 |= (unint64_t)(v26 & 0x7F) << v21;
          if ((v26 & 0x80) == 0) {
            goto LABEL_35;
          }
          v21 += 7;
          BOOL v14 = v22++ >= 9;
          if (v14)
          {
            uint64_t v23 = 0;
            goto LABEL_37;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_35:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v23 = 0;
        }
LABEL_37:
        *(unsigned char *)(a1 + 24) = v23 != 0;
      }
      else if (v17 == 1)
      {
        uint64_t v18 = PBReaderReadString();
        char v19 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v18;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDBackgroundObservationSupportedForDataTypeCode(uint64_t a1)
{
  uint64_t result = 0;
  if (a1 <= 174)
  {
    unint64_t v3 = a1 - 64;
    if (v3 <= 0x27 && ((1 << v3) & 0x9001730007) != 0) {
      return result;
    }
    return 1;
  }
  if ((unint64_t)(a1 - 175) >= 3 && a1 != 218 && a1 != 257) {
    return 1;
  }
  return result;
}

void sub_1BCC54088(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 104));
  _Unwind_Resume(a1);
}

void *health::TransactionalFile::ReadTransaction::ReadTransaction(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *uint64_t result = &unk_1F171C0C8;
  result[1] = a3;
  result[2] = a2;
  result[3] = a4;
  return result;
}

{
  *uint64_t result = &unk_1F171C0C8;
  result[1] = a3;
  result[2] = a2;
  result[3] = a4;
  return result;
}

void health::TransactionalFile::_readBufferAtOffset(uint64_t a1, unint64_t a2, health::RawBuffer *a3, uint64_t a4)
{
  char v8 = (std::mutex *)(a1 + 416);
  std::mutex::lock((std::mutex *)(a1 + 416));
  unint64_t v9 = *((void *)a3 + 1);
  if (v9)
  {
    uint64_t v10 = 0;
    unint64_t v11 = *(unsigned int *)(a1 + 360) + a4;
    do
    {
      health::TransactionalFile::_cacheMutex_pageForOffset(a1, a2, v11, 0, (uint64_t)&v15);
      if (v15 - v11 + v16 >= v9) {
        unint64_t v12 = v9;
      }
      else {
        unint64_t v12 = v15 - v11 + v16;
      }
      health::RawBuffer::slice(a3, v10, v12, v14);
      health::FilePage::slice((health::FilePage *)&v15, v11, v12, v13);
      health::RawBuffer::copyFrom((health::RawBuffer *)v14, (const health::RawBuffer *)v13);
      if (v18) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v18);
      }
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      }
      v10 += v12;
      v11 += v12;
      v9 -= v12;
    }
    while (v9);
  }
  std::mutex::unlock(v8);
}

void sub_1BCC557B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  health::FilePage::~FilePage((health::FilePage *)va);
  std::mutex::unlock(v5);
  _Unwind_Resume(a1);
}

uint64_t health::TransactionalFile::ReadTransaction::size(health::TransactionalFile::ReadTransaction *this)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 2) + 328) + 48))(*(void *)(*((void *)this + 2) + 328));
  uint64_t v3 = health::WriteAheadLog::maximumCommittedSizeForTransaction((std::mutex *)(*((void *)this + 2) + 16), *((void *)this + 1));
  if (v2 <= v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = v2;
  }
  return (v4 - *((void *)this + 3)) & ~((v4 - *((void *)this + 3)) >> 63);
}

health::TransactionalFile::WriteTransaction *health::TransactionalFile::WriteTransaction::WriteTransaction(health::TransactionalFile::WriteTransaction *this, health::TransactionalFile *a2, uint64_t a3, uint64_t a4)
{
  *((void *)this + 1) = a3;
  *((void *)this + 2) = a2;
  *((void *)this + 3) = a4;
  *((void *)this + 4) = a2;
  *(void *)this = &unk_1F171C0F0;
  *((void *)this + 5) = health::TransactionalFile::ReadTransaction::size(this) + a4;
  return this;
}

{
  *((void *)this + 1) = a3;
  *((void *)this + 2) = a2;
  *((void *)this + 3) = a4;
  *((void *)this + 4) = a2;
  *(void *)this = &unk_1F171C0F0;
  *((void *)this + 5) = health::TransactionalFile::ReadTransaction::size(this) + a4;
  return this;
}

void health::TransactionalFile::_writeBufferAtOffset(health::TransactionalFile *this, unint64_t a2, const health::RawBuffer *a3, uint64_t a4)
{
  uint64_t v8 = *((unsigned int *)this + 90);
  unint64_t v9 = *((void *)a3 + 1);
  uint64_t v16 = (std::mutex *)((char *)this + 416);
  std::mutex::lock((std::mutex *)((char *)this + 416));
  if (v9)
  {
    uint64_t v10 = 0;
    unint64_t v11 = v8 + a4;
    unint64_t v12 = (uint64_t *)MEMORY[0x1E4F29F18];
    do
    {
      health::TransactionalFile::_cacheMutex_pageForOffset((uint64_t)this, a2, v11, 1, (uint64_t)&v22);
      if (v25)
      {
        uint64_t v13 = *v12;
        std::string::basic_string[abi:ne180100]<0>(v21, "!page.is_mapped()");
        std::string::basic_string[abi:ne180100]<0>(v20, "_writeBufferAtOffset");
        std::string::basic_string[abi:ne180100]<0>(v19, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
        health::FormatString<>((std::string *)"Attempt to write to a mapped page.", &__p);
        health::_HDAssertImplementation<std::logic_error>(v13, (uint64_t)v21, (uint64_t)v20, (uint64_t)v19, 465, (uint64_t)&__p);
      }
      if (v22 - v11 + v23 >= v9) {
        unint64_t v14 = v9;
      }
      else {
        unint64_t v14 = v22 - v11 + v23;
      }
      if (v14 + v10 > *((void *)a3 + 1))
      {
        uint64_t v15 = *v12;
        std::string::basic_string[abi:ne180100]<0>(v30, "(start + length) <= _length");
        std::string::basic_string[abi:ne180100]<0>(v29, "slice");
        std::string::basic_string[abi:ne180100]<0>(v28, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDRawBuffer.h");
        health::FormatString<>((std::string *)"Slice extends beyond end of buffer.", &v27);
        health::_HDAssertImplementation<std::out_of_range>(v15, (uint64_t)v30, (uint64_t)v29, (uint64_t)v28, 67, (uint64_t)&v27);
      }
      health::RawBuffer::RawBuffer(v17, (unsigned __int8 *)(*(void *)a3 + v10), v14);
      health::FilePage::slice((health::FilePage *)&v22, v11, v14, v30);
      health::RawBuffer::copyFrom((health::RawBuffer *)v30, (const health::RawBuffer *)v17);
      health::TransactionalFile::_cacheMutex_writePage(this, a2, (health::FilePage *)&v22);
      if (v26) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      }
      if (v24) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v24);
      }
      v11 += v14;
      v10 += v14;
      v9 -= v14;
    }
    while (v9);
  }
  std::mutex::unlock(v16);
}

void sub_1BCC55B74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::mutex *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a47 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v47 - 137) < 0) {
    operator delete(*(void **)(v47 - 160));
  }
  if (*(char *)(v47 - 113) < 0) {
    operator delete(*(void **)(v47 - 136));
  }
  if (*(char *)(v47 - 89) < 0) {
    operator delete(*(void **)(v47 - 112));
  }
  health::FilePage::~FilePage((health::FilePage *)&a36);
  std::mutex::unlock(a9);
  _Unwind_Resume(a1);
}

uint64_t health::TransactionalFile::WriteTransaction::size(health::TransactionalFile::WriteTransaction *this)
{
  return *((void *)this + 5) - *((void *)this + 3);
}

uint64_t health::TransactionalFile::TransactionalFile(uint64_t a1, long long *a2)
{
  v3[0] = 0;
  v3[1] = 0;
  return health::TransactionalFile::TransactionalFile(a1, a2, v3);
}

{
  void v3[2];

  v3[0] = 0;
  v3[1] = 0;
  return health::TransactionalFile::TransactionalFile(a1, a2, v3);
}

uint64_t health::TransactionalFile::TransactionalFile(uint64_t a1, long long *a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*a3)
  {
    *(void *)a1 = *a3;
    uint64_t v5 = a3[1];
    *(void *)(a1 + 8) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v6 = operator new(0x20uLL);
    v6[1] = 0;
    void v6[2] = 0;
    *uint64_t v6 = &unk_1F1727340;
    uint64_t v6[3] = &unk_1F1727260;
    *(void *)a1 = v6 + 3;
    *(void *)(a1 + 8) = v6;
  }
  if (*((char *)a2 + 23) >= 0) {
    size_t v7 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v7 = *((void *)a2 + 1);
  }
  uint64_t v8 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v7 + 4);
  if (v18 < 0) {
    uint64_t v8 = (void **)__p[0];
  }
  if (v7)
  {
    if (*((char *)a2 + 23) >= 0) {
      unint64_t v9 = (const std::string::value_type *)a2;
    }
    else {
      unint64_t v9 = *(const std::string::value_type **)a2;
    }
    memmove(v8, v9, v7);
  }
  strcpy((char *)v8 + v7, "-wal");
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 8);
  v15[0] = *(void *)a1;
  v15[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  health::WriteAheadLog::WriteAheadLog(a1 + 16, (long long *)__p, v15);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  unint64_t v11 = (std::string *)(a1 + 304);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v12 = *a2;
    *(void *)(a1 + 320) = *((void *)a2 + 2);
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
  }
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = 0x1484B5446;
  *(_DWORD *)(a1 + 360) = 1024;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 368) = 0;
  int v13 = getpagesize();
  *(void *)(a1 + 392) = v13;
  *(void *)(a1 + 400) = -(uint64_t)v13;
  *(_DWORD *)(a1 + 408) = 1;
  *(void *)(a1 + 416) = 850045863;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(void *)(a1 + 472) = 0;
  *(void *)(a1 + 480) = 16 * v13;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(void *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 528) = 1065353216;
  *(void *)(a1 + 576) = 0;
  *(void *)(a1 + 544) = 0;
  *(void *)(a1 + 536) = 0;
  *(void *)(a1 + 584) = 850045863;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(void *)(a1 + 640) = 0;
  *(void *)(a1 + 648) = 1018212795;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(void *)(a1 + 688) = 0;
  *(void *)(a1 + 704) = 0;
  *(void *)(a1 + 712) = 0;
  *(void *)(a1 + 696) = a1 + 704;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(void *)(a1 + 776) = 0;
  *(void *)(a1 + 784) = 0;
  *(void *)(a1 + 768) = a1 + 776;
  v16[0] = &unk_1F171C140;
  v16[1] = a1;
  v16[3] = v16;
  char v19 = __p;
  __p[0] = &unk_1F171C140;
  __p[1] = (void *)a1;
  if (__p != (void **)(a1 + 552))
  {
    *(void *)(a1 + 552) = &unk_1F171C140;
    *(void *)(a1 + 560) = a1;
    char v19 = 0;
    *(void *)(a1 + 576) = a1 + 552;
  }
  std::__function::__value_func<BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::~__value_func[abi:ne180100](__p);
  std::__function::__value_func<BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::~__value_func[abi:ne180100](v16);
  return a1;
}

void sub_1BCC55FB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  health::WriteAheadLog::~WriteAheadLog(v22);
  uint64_t v24 = *(std::__shared_weak_count **)(v21 + 8);
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }
  _Unwind_Resume(a1);
}

uint64_t health::TransactionalFile::open(uint64_t *a1, int a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (a1[41])
  {
    uint64_t v4 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v39, "!isOpen()");
    std::string::basic_string[abi:ne180100]<0>(v38, "open");
    std::string::basic_string[abi:ne180100]<0>(v37, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"File is already open.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v4, (uint64_t)v39, (uint64_t)v38, (uint64_t)v37, 101, (uint64_t)&__p);
  }
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  size_t v7 = a1 + 41;
  uint64_t v8 = *a1;
  *(void *)&v48[0].__padding_ = 0x100000000;
  LODWORD(p_token) = 2;
  do
  {
    unsigned int padding = v48[v5].__padding_;
    if (padding >= 4) {
      std::__throw_out_of_range[abi:ne180100]("bitset set argument out of range");
    }
    v6 |= 1 << padding;
    ++v5;
  }
  while (v5 != 3);
  (*(void (**)(std::string *__return_ptr))(*(void *)v8 + 16))(&__token);
  long long v10 = *(_OWORD *)&__token.__r_.__value_.__l.__data_;
  *(_OWORD *)&__token.__r_.__value_.__l.__data_ = 0uLL;
  unint64_t v11 = (std::__shared_weak_count *)a1[42];
  *(_OWORD *)size_t v7 = v10;
  if (v11)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    if (__token.__r_.__value_.__l.__size_) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__token.__r_.__value_.__l.__size_);
    }
    if (!*v7)
    {
LABEL_12:
      uint64_t v12 = *MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v35, "isOpen()");
      std::string::basic_string[abi:ne180100]<0>(v34, "open");
      std::string::basic_string[abi:ne180100]<0>(v33, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
      health::FormatString<>((std::string *)"File failed to open as expected.", &v32);
      health::_HDAssertImplementation<health::transaction_error>(v12, (uint64_t)v35, (uint64_t)v34, (uint64_t)v33, 106, (uint64_t)&v32);
    }
  }
  else if (!(void)v10)
  {
    goto LABEL_12;
  }
  if (a2 == 2) {
    *((_DWORD *)a1 + 102) = 0;
  }
  if ((*(uint64_t (**)(void))(*(void *)*v7 + 48))())
  {
    uint64_t v13 = a1[41];
    uint64_t v42 = 0;
    uint64_t v43 = 36;
    *(void *)&v48[0].__padding_ = &__token;
    p_token = &__token;
    uint64_t v50 = 36;
    uint64_t v14 = (*(uint64_t (**)(uint64_t, void, std::string *, uint64_t))(*(void *)v13 + 32))(v13, 0, &__token, 36);
    LODWORD(v40) = 0;
    health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)v48, &v40);
    *((_DWORD *)a1 + 88) = v40;
    LODWORD(v40) = 0;
    health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)v48, &v40);
    *((_DWORD *)a1 + 89) = v40;
    LODWORD(v40) = 0;
    health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)v48, &v40);
    *((_DWORD *)a1 + 90) = v40;
    uint64_t v40 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v48, &v40);
    a1[46] = v40;
    uint64_t v40 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v48, &v40);
    a1[47] = v40;
    uint64_t v40 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)v48, &v40);
    a1[48] = v40;
    uint64_t v15 = v42;
    uint64_t v42 = 0;
    if (v15) {
      MEMORY[0x1C187B880](v15, 0x1000C8077774924);
    }
    if (v14 != 36)
    {
      uint64_t v16 = *MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v31, "headerBytes == _header.serializedSize()");
      std::string::basic_string[abi:ne180100]<0>(v30, "open");
      std::string::basic_string[abi:ne180100]<0>(v29, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
      health::FormatString<>((std::string *)"Failed to read full file header.", &v28);
      health::_HDAssertImplementation<health::file_access_error>(v16, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29, 118, (uint64_t)&v28);
    }
    if (*((_DWORD *)a1 + 89) == 1)
    {
      if (*((_DWORD *)a1 + 88) == 1212896326)
      {
        health::WriteAheadLog::open((std::mutex *)(a1 + 2), a1[47]);
        unint64_t v17 = a1[48];
        uint64_t v18 = a1[49];
        if (v17 == v18)
        {
          if (a2 == 1)
          {
LABEL_35:
            __token.__r_.__value_.__s.__data_[0] = 0;
            uint64_t v26 = a1[47];
            v47[0] = &unk_1F171C210;
            v47[3] = v47;
            v46[0] = &unk_1F171C2A0;
            v46[1] = a1;
            v46[2] = &__token;
            v46[3] = v46;
            v45[0] = &unk_1F171C330;
            v45[1] = a1;
            v45[3] = v45;
            health::WriteAheadLog::checkpoint((std::mutex *)(a1 + 2), v26, (uint64_t)v47, (uint64_t)v46, (uint64_t)v45);
            std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v45);
            std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::~__value_func[abi:ne180100](v46);
            std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v47);
            if (__token.__r_.__value_.__s.__data_[0]) {
              return 2;
            }
            else {
              return 1;
            }
          }
        }
        else
        {
          if (a2 != 2 || !v17)
          {
            a1[48] = v18;
            goto LABEL_35;
          }
          health::TransactionalFile::_configurePageSize((health::TransactionalFile *)a1, v17);
        }
        return 3;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Transactional file header has incorrect magic word.");
    }
    else
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid header version for transactional file.");
    }
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1F171C6B8;
  }
  health::WriteAheadLog::discardLog((std::mutex *)(a1 + 2));
  std::string::basic_string[abi:ne180100]<0>(&__token, "/dev/urandom");
  std::random_device::random_device(v48, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__token.__r_.__value_.__l.__data_);
  }
  uint32_t v19 = arc4random();
  uint64_t v20 = 1;
  std::string::size_type v21 = v19;
  do
  {
    std::string::size_type v21 = v20 + 0x5851F42D4C957F2DLL * (v21 ^ (v21 >> 62));
    __token.__r_.__value_.__r.__words[v20++] = v21;
  }
  while (v20 != 312);
  unint64_t v22 = v44 ^ ((__token.__r_.__value_.__r.__words[1] & 0x7FFFFFFE | (unint64_t)(v19 & 0x80000000)) >> 1) ^ ((uint64_t)(__token.__r_.__value_.__l.__size_ << 63) >> 63) & 0xB5026F5AA96619E9;
  uint64_t v23 = (((v22 >> 29) & 0x5555555555555555 ^ v22) << 17) & 0x71D67FFFEDA60000 ^ (v22 >> 29) & 0x5555555555555555 ^ v22;
  uint64_t v24 = a1[49];
  a1[47] = (v23 << 37) & 0xFFF7EEE000000000 ^ v23 ^ (((v23 << 37) & 0xFFF7EEE000000000 ^ v23) >> 43);
  a1[48] = v24;
  health::VirtualFile::write<health::TransactionalFile::FileHeader>(a1[41], (uint64_t)(a1 + 44));
  (*(void (**)(void))(*(void *)*v7 + 16))();
  health::WriteAheadLog::open((std::mutex *)(a1 + 2), a1[47]);
  std::random_device::~random_device(v48);
  return 0;
}

void sub_1BCC56760(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100]((void *)(v4 - 176));
    std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::~__value_func[abi:ne180100]((void *)(v4 - 144));
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100]((void *)(v4 - 112));
    __cxa_begin_catch(a1);
    uint64_t v6 = *(std::__shared_weak_count **)(v2 + 336);
    void *v3 = 0;
    v3[1] = 0;
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
    health::WriteAheadLog::reset((std::mutex *)(v2 + 16));
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_1BCC5695C(_Unwind_Exception *a1)
{
}

void sub_1BCC56968(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void health::_HDAssertImplementation<health::transaction_error>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v39 = 0u;
  int v10 = backtrace(v38, 20);
  unint64_t v11 = backtrace_symbols(v38, v10);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v36);
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Critical Error: ", 16);
  int v13 = *(char *)(a6 + 23);
  if (v13 >= 0) {
    uint64_t v14 = a6;
  }
  else {
    uint64_t v14 = *(void *)a6;
  }
  if (v13 >= 0) {
    uint64_t v15 = *(unsigned __int8 *)(a6 + 23);
  }
  else {
    uint64_t v15 = *(void *)(a6 + 8);
  }
  uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, v14, v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  unint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Failed assertion '", 18);
  int v18 = *(char *)(a2 + 23);
  if (v18 >= 0) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = *(void *)a2;
  }
  if (v18 >= 0) {
    uint64_t v20 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v20 = *(void *)(a2 + 8);
  }
  std::string::size_type v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"' in '", 6);
  int v23 = *(char *)(a3 + 23);
  if (v23 >= 0) {
    uint64_t v24 = a3;
  }
  else {
    uint64_t v24 = *(void *)a3;
  }
  if (v23 >= 0) {
    uint64_t v25 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v25 = *(void *)(a3 + 8);
  }
  uint64_t v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
  std::string v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' at ", 5);
  int v28 = *(char *)(a4 + 23);
  if (v28 >= 0) {
    uint64_t v29 = a4;
  }
  else {
    uint64_t v29 = *(void *)a4;
  }
  if (v28 >= 0) {
    uint64_t v30 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v30 = *(void *)(a4 + 8);
  }
  uint64_t v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v29, v30);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)":", 1);
  std::string v32 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  if (!v10)
  {
    free(v11);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v37, &v35);
    std::runtime_error::runtime_error(exception, &v35);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1F171C6F8;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, *v11);
  health::HDDemangleBacktraceLine();
}

void sub_1BCC56C00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  a21 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a21 + *(void *)(a21 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a22 = MEMORY[0x1E4FBA470] + 16;
  if (a35 < 0) {
    operator delete(a30);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&a38);
  _Unwind_Resume(a1);
}

void health::_HDAssertImplementation<health::file_access_error>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v39 = 0u;
  int v10 = backtrace(v38, 20);
  unint64_t v11 = backtrace_symbols(v38, v10);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v36);
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Critical Error: ", 16);
  int v13 = *(char *)(a6 + 23);
  if (v13 >= 0) {
    uint64_t v14 = a6;
  }
  else {
    uint64_t v14 = *(void *)a6;
  }
  if (v13 >= 0) {
    uint64_t v15 = *(unsigned __int8 *)(a6 + 23);
  }
  else {
    uint64_t v15 = *(void *)(a6 + 8);
  }
  uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, v14, v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  unint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Failed assertion '", 18);
  int v18 = *(char *)(a2 + 23);
  if (v18 >= 0) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = *(void *)a2;
  }
  if (v18 >= 0) {
    uint64_t v20 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v20 = *(void *)(a2 + 8);
  }
  std::string::size_type v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"' in '", 6);
  int v23 = *(char *)(a3 + 23);
  if (v23 >= 0) {
    uint64_t v24 = a3;
  }
  else {
    uint64_t v24 = *(void *)a3;
  }
  if (v23 >= 0) {
    uint64_t v25 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v25 = *(void *)(a3 + 8);
  }
  uint64_t v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
  std::string v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' at ", 5);
  int v28 = *(char *)(a4 + 23);
  if (v28 >= 0) {
    uint64_t v29 = a4;
  }
  else {
    uint64_t v29 = *(void *)a4;
  }
  if (v28 >= 0) {
    uint64_t v30 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v30 = *(void *)(a4 + 8);
  }
  uint64_t v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v29, v30);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)":", 1);
  std::string v32 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  if (!v10)
  {
    free(v11);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v37, &v35);
    std::runtime_error::runtime_error(exception, &v35);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1F171C1E8;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, *v11);
  health::HDDemangleBacktraceLine();
}

void sub_1BCC56FD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  a21 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a21 + *(void *)(a21 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a22 = MEMORY[0x1E4FBA470] + 16;
  if (a35 < 0) {
    operator delete(a30);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&a38);
  _Unwind_Resume(a1);
}

void health::TransactionalFile::_configurePageSize(health::TransactionalFile *this, unint64_t a2)
{
  if (a2 < 2 || (uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)a2), v4.i16[0] = vaddlv_u8(v4), v4.u32[0] >= 2uLL))
  {
    uint64_t v5 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v16, "pageSize > 1 && !(pageSize & (pageSize - 1))");
    std::string::basic_string[abi:ne180100]<0>(v15, "_configurePageSize");
    std::string::basic_string[abi:ne180100]<0>(v14, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"pageSize must be a power of 2", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v5, (uint64_t)v16, (uint64_t)v15, (uint64_t)v14, 408, (uint64_t)&__p);
  }
  if (*((void *)this + 49) != a2)
  {
    std::mutex::lock((std::mutex *)((char *)this + 416));
    uint64_t v6 = *((void *)this + 60);
    *((void *)this + 60) = 0;
    uint64_t v7 = *((void *)this + 68);
    if (v7)
    {
      while (1)
      {
        uint64_t v8 = *((void *)this + 61);
        if (!v8) {
          goto LABEL_14;
        }
        uint64_t v9 = *(void *)(v7 + 88);
        if (!*(_DWORD *)v7) {
          goto LABEL_11;
        }
        uint64_t v10 = *((void *)this + 72);
        if (!v10) {
          goto LABEL_11;
        }
        unint64_t v17 = *(void *)(v7 + 8);
        if ((*(unsigned int (**)(uint64_t, unint64_t *, uint64_t, uint64_t))(*(void *)v10 + 48))(v10, &v17, v7 + 24, v7 + 32))
        {
          break;
        }
LABEL_13:
        uint64_t v7 = v9;
        if (!v9) {
          goto LABEL_14;
        }
      }
      uint64_t v8 = *((void *)this + 61);
LABEL_11:
      *((void *)this + 61) = v8 - *(void *)(v7 + 16);
      health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)this + 480, v7);
      unint64_t v11 = *(void *)(v7 + 24);
      unint64_t v17 = v11;
      uint64_t v12 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t *)this + 62, v11, &v17);
      health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry((uint64_t)(v12 + 3), v7);
      if (v12[4] == v12[3]) {
        std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>((void *)this + 62, v11);
      }
      goto LABEL_13;
    }
LABEL_14:
    *((void *)this + 60) = v6;
    *((void *)this + 49) = a2;
    *((void *)this + 50) = -(uint64_t)a2;
    std::mutex::unlock((std::mutex *)((char *)this + 416));
  }
}

void sub_1BCC57344(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

void health::TransactionalFile::invalidate(health::TransactionalFile *this)
{
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 584);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 584));
  pthread_t v2 = pthread_self();
  uint64_t v3 = (health::TransactionalFile *)std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>((uint64_t)this + 696, (unint64_t)v2);
  uint8x8_t v4 = (uint64_t *)MEMORY[0x1E4F29F18];
  if ((health::TransactionalFile *)((char *)this + 704) != v3)
  {
    uint64_t v5 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v16, "_activeReadTransactions.find(threadID) == _activeReadTransactions.end()");
    std::string::basic_string[abi:ne180100]<0>(v15, "invalidate");
    std::string::basic_string[abi:ne180100]<0>(v14, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"Attempt to invalidate the transactional file from within a read transaction.", &__p);
    health::_HDAssertImplementation<std::logic_error>(v5, (uint64_t)v16, (uint64_t)v15, (uint64_t)v14, 183, (uint64_t)&__p);
  }
  if ((void *)((char *)this + 776) != std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>((uint64_t)this + 768, (unint64_t)v2))
  {
    uint64_t v6 = *v4;
    std::string::basic_string[abi:ne180100]<0>(v12, "_activeWriteTransactions.find(threadID) == _activeWriteTransactions.end()");
    std::string::basic_string[abi:ne180100]<0>(v11, "invalidate");
    std::string::basic_string[abi:ne180100]<0>(v10, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"Attempt to invalidate the transactional file from within a write transaction.", &v9);
    health::_HDAssertImplementation<std::logic_error>(v6, (uint64_t)v12, (uint64_t)v11, (uint64_t)v10, 184, (uint64_t)&v9);
  }
  if (!*((unsigned char *)this + 344))
  {
    *((unsigned char *)this + 344) = 1;
    while (*((void *)this + 89) || *((void *)this + 98))
      std::condition_variable::wait((std::condition_variable *)((char *)this + 648), &__lk);
    uint64_t v7 = *((void *)this + 41);
    if (v7)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 64))(v7);
      uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 42);
      *((void *)this + 41) = 0;
      *((void *)this + 42) = 0;
      if (v8) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v8);
      }
      health::WriteAheadLog::reset((std::mutex *)((char *)this + 16));
    }
  }
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
}

void sub_1BCC57614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  std::mutex::unlock(v44);
  _Unwind_Resume(a1);
}

void health::_HDAssertImplementation<std::logic_error>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v39 = 0u;
  int v10 = backtrace(v38, 20);
  unint64_t v11 = backtrace_symbols(v38, v10);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v36);
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Critical Error: ", 16);
  int v13 = *(char *)(a6 + 23);
  if (v13 >= 0) {
    uint64_t v14 = a6;
  }
  else {
    uint64_t v14 = *(void *)a6;
  }
  if (v13 >= 0) {
    uint64_t v15 = *(unsigned __int8 *)(a6 + 23);
  }
  else {
    uint64_t v15 = *(void *)(a6 + 8);
  }
  uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, v14, v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  unint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Failed assertion '", 18);
  int v18 = *(char *)(a2 + 23);
  if (v18 >= 0) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = *(void *)a2;
  }
  if (v18 >= 0) {
    uint64_t v20 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v20 = *(void *)(a2 + 8);
  }
  std::string::size_type v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"' in '", 6);
  int v23 = *(char *)(a3 + 23);
  if (v23 >= 0) {
    uint64_t v24 = a3;
  }
  else {
    uint64_t v24 = *(void *)a3;
  }
  if (v23 >= 0) {
    uint64_t v25 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v25 = *(void *)(a3 + 8);
  }
  uint64_t v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
  std::string v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' at ", 5);
  int v28 = *(char *)(a4 + 23);
  if (v28 >= 0) {
    uint64_t v29 = a4;
  }
  else {
    uint64_t v29 = *(void *)a4;
  }
  if (v28 >= 0) {
    uint64_t v30 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v30 = *(void *)(a4 + 8);
  }
  uint64_t v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v29, v30);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)":", 1);
  std::string v32 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  if (!v10)
  {
    free(v11);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v37, &v35);
    std::logic_error::logic_error(exception, &v35);
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, *v11);
  health::HDDemangleBacktraceLine();
}

void sub_1BCC57954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  a21 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a21 + *(void *)(a21 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a22 = MEMORY[0x1E4FBA470] + 16;
  if (a35 < 0) {
    operator delete(a30);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&a38);
  _Unwind_Resume(a1);
}

void health::TransactionalFile::setCacheSize(health::TransactionalFile *this, unint64_t a2)
{
  uint8x8_t v4 = (std::mutex *)((char *)this + 416);
  std::mutex::lock((std::mutex *)((char *)this + 416));
  if (!a2)
  {
    uint64_t v5 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v21, "maxSize > 0");
    std::string::basic_string[abi:ne180100]<0>(v20, "setMaxSize");
    std::string::basic_string[abi:ne180100]<0>(v19, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDTransactionalCache.hpp");
    health::FormatString<>((std::string *)"Cache max size must be greater than 0.", &__p);
    health::_HDAssertImplementation<std::logic_error>(v5, (uint64_t)v21, (uint64_t)v20, (uint64_t)v19, 30, (uint64_t)&__p);
  }
  *((void *)this + 60) = a2;
  uint64_t v6 = *((void *)this + 68);
  if (v6)
  {
    do
    {
      unint64_t v7 = *((void *)this + 61);
      if (v7 <= a2) {
        break;
      }
      uint64_t v8 = *(void *)(v6 + 88);
      if (!*(_DWORD *)v6)
      {
        *((void *)this + 61) = v7 - *(void *)(v6 + 16);
        health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)this + 480, v6);
        unint64_t v9 = *(void *)(v6 + 24);
        unint64_t v22 = v9;
        int v10 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t *)this + 62, v9, &v22);
        health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry((uint64_t)(v10 + 3), v6);
        if (v10[4] == v10[3]) {
          std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>((void *)this + 62, v9);
        }
      }
      uint64_t v6 = v8;
    }
    while (v8);
    uint64_t v11 = *((void *)this + 68);
    if (v11)
    {
      unint64_t v12 = *((void *)this + 60);
      while (1)
      {
        unint64_t v13 = *((void *)this + 61);
        if (v13 <= v12) {
          goto LABEL_19;
        }
        uint64_t v14 = *(void *)(v11 + 88);
        if (!*(_DWORD *)v11) {
          goto LABEL_16;
        }
        uint64_t v15 = *((void *)this + 72);
        if (!v15) {
          goto LABEL_16;
        }
        unint64_t v22 = *(void *)(v11 + 8);
        if ((*(unsigned int (**)(uint64_t, unint64_t *, uint64_t, uint64_t))(*(void *)v15 + 48))(v15, &v22, v11 + 24, v11 + 32))
        {
          break;
        }
LABEL_18:
        uint64_t v11 = v14;
        if (!v14) {
          goto LABEL_19;
        }
      }
      unint64_t v13 = *((void *)this + 61);
LABEL_16:
      *((void *)this + 61) = v13 - *(void *)(v11 + 16);
      health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)this + 480, v11);
      unint64_t v16 = *(void *)(v11 + 24);
      unint64_t v22 = v16;
      unint64_t v17 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t *)this + 62, v16, &v22);
      health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry((uint64_t)(v17 + 3), v11);
      if (v17[4] == v17[3]) {
        std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>((void *)this + 62, v16);
      }
      goto LABEL_18;
    }
  }
LABEL_19:

  std::mutex::unlock(v4);
}

void sub_1BCC57D1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  std::mutex::unlock(v33);
  _Unwind_Resume(a1);
}

void health::TransactionalFile::readTransactionWithLambda(uint64_t a1, uint64_t a2)
{
  void v24[4] = *MEMORY[0x1E4F143B8];
  pthread_t v4 = pthread_self();
  pthread_t v23 = v4;
  v22.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 584);
  v22.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 584));
  if (*(unsigned char *)(a1 + 344))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Read transaction attempted after file was closed.");
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1F171C6F8;
  }
  if (!*(void *)(a1 + 328))
  {
    uint64_t v5 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v21, "isOpen()");
    std::string::basic_string[abi:ne180100]<0>(v20, "readTransactionWithLambda");
    std::string::basic_string[abi:ne180100]<0>(v19, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"File has not yet been opened.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v5, (uint64_t)v21, (uint64_t)v20, (uint64_t)v19, 220, (uint64_t)&__p);
  }
  uint64_t v6 = std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>(a1 + 696, (unint64_t)v4);
  if ((void *)(a1 + 704) != v6)
  {
    unint64_t v7 = v6;
    std::unique_lock<std::mutex>::unlock(&v22);
    uint64_t v8 = *(void *)(a2 + 24);
    if (!v8) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    goto LABEL_6;
  }
  int v10 = *(void **)(a1 + 776);
  if (!v10) {
    goto LABEL_30;
  }
  unint64_t v7 = (void *)(a1 + 776);
  do
  {
    uint64_t v11 = (_opaque_pthread_t *)v10[4];
    if (v11)
    {
      if (!v4 || v11 != v4)
      {
        if (v11 >= v4) {
          char v12 = 1;
        }
        else {
          char v12 = -1;
        }
        goto LABEL_18;
      }
    }
    else if (v4)
    {
      char v12 = -1;
      goto LABEL_18;
    }
    char v12 = 0;
LABEL_18:
    BOOL v13 = (v12 & 0x80) == 0;
    if (v12 < 0) {
      uint64_t v14 = v10 + 1;
    }
    else {
      uint64_t v14 = v10;
    }
    if (v13) {
      unint64_t v7 = v10;
    }
    int v10 = (void *)*v14;
  }
  while (*v14);
  if ((void *)(a1 + 776) == v7) {
    goto LABEL_30;
  }
  unint64_t v15 = v7[4];
  if (!v4)
  {
    if (!v15) {
      goto LABEL_27;
    }
    goto LABEL_30;
  }
  if (v15 > (unint64_t)v4)
  {
LABEL_30:
    int v9 = 1;
    goto LABEL_31;
  }
LABEL_27:
  std::unique_lock<std::mutex>::unlock(&v22);
  uint64_t v8 = *(void *)(a2 + 24);
  if (!v8) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
LABEL_6:
  (*(void (**)(uint64_t, void))(*(void *)v8 + 48))(v8, v7[5]);
  int v9 = 0;
LABEL_31:
  if (v22.__owns_) {
    std::mutex::unlock(v22.__m_);
  }
  if (v9)
  {
    unint64_t v16 = operator new(0x20uLL);
    void *v16 = &unk_1F171C3B0;
    v16[1] = a1;
    void v16[2] = &v23;
    v16[3] = a2;
    void v24[3] = v16;
    health::WriteAheadLog::runReadTransaction(a1 + 16, (uint64_t)v24);
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v24);
  }
}

void sub_1BCC580AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,std::mutex *a33,char a34)
{
  if (a34) {
    std::mutex::unlock(a33);
  }
  _Unwind_Resume(exception_object);
}

BOOL health::TransactionalFile::_transactionMutex_waitForAvailableWriteTransaction(uint64_t a1, std::unique_lock<std::mutex> *a2)
{
  pthread_t v4 = pthread_self();
  uint64_t v5 = *(char **)(a1 + 736);
  uint64_t v6 = *(char **)(a1 + 728);
  uint64_t v7 = v5 - v6;
  if (v5 == v6) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = ((v5 - v6) << 6) - 1;
  }
  unint64_t v9 = *(void *)(a1 + 752);
  uint64_t v10 = *(void *)(a1 + 760);
  unint64_t v11 = v10 + v9;
  if (v8 == v10 + v9)
  {
    if (v9 < 0x200)
    {
      uint64_t v26 = v7 >> 3;
      std::string v27 = *(char **)(a1 + 744);
      int v28 = *(char **)(a1 + 720);
      if (v7 >> 3 >= (unint64_t)((v27 - v28) >> 3))
      {
        if (v27 == v28) {
          unint64_t v31 = 1;
        }
        else {
          unint64_t v31 = (v27 - v28) >> 2;
        }
        std::string v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v31);
        uint64_t v34 = v33;
        std::string v35 = operator new(0x1000uLL);
        uint64_t v36 = &v32[8 * v26];
        uint64_t v37 = v34;
        uint64_t v38 = &v32[8 * v34];
        if (v26 == v37)
        {
          uint64_t v39 = 8 * v26;
          long long v40 = (uint64_t *)(a1 + 728);
          if (v7 < 1)
          {
            long long v60 = v35;
            uint64_t v61 = v39 >> 2;
            if (v5 == v6) {
              unint64_t v62 = 1;
            }
            else {
              unint64_t v62 = v61;
            }
            uint64_t v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v62);
            uint64_t v36 = &v63[8 * (v62 >> 2)];
            uint64_t v38 = &v63[8 * v64];
            if (v32) {
              operator delete(v32);
            }
            std::string v32 = v63;
            std::string v35 = v60;
          }
          else
          {
            uint64_t v41 = v39 >> 3;
            if (v41 >= -1) {
              unint64_t v42 = v41 + 1;
            }
            else {
              unint64_t v42 = v41 + 2;
            }
            v36 -= 8 * (v42 >> 1);
          }
        }
        else
        {
          long long v40 = (uint64_t *)(a1 + 728);
        }
        *(void *)uint64_t v36 = v35;
        unint64_t v65 = v36 + 8;
        uint64_t v66 = *(void *)(a1 + 736);
        for (uint64_t i = *(void *)(a1 + 728); v66 != i; uint64_t i = *v40)
        {
          if (v36 == v32)
          {
            if (v65 >= v38)
            {
              if (v38 == v32) {
                unint64_t v72 = 1;
              }
              else {
                unint64_t v72 = (v38 - v32) >> 2;
              }
              unint64_t v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v72);
              uint64_t v75 = v73;
              uint64_t v36 = &v73[(2 * v72 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v76 = v65 - v32;
              BOOL v43 = v65 == v32;
              unint64_t v65 = v36;
              if (!v43)
              {
                unint64_t v65 = &v36[v76 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v77 = 8 * (v76 >> 3);
                uint64_t v78 = v36;
                uint64_t v79 = (uint64_t *)v32;
                do
                {
                  uint64_t v80 = *v79++;
                  *(void *)uint64_t v78 = v80;
                  v78 += 8;
                  v77 -= 8;
                }
                while (v77);
              }
              uint64_t v38 = &v73[8 * v74];
              if (v32) {
                operator delete(v32);
              }
              std::string v32 = v75;
            }
            else
            {
              uint64_t v68 = (v38 - v65) >> 3;
              if (v68 >= -1) {
                uint64_t v69 = v68 + 1;
              }
              else {
                uint64_t v69 = v68 + 2;
              }
              uint64_t v70 = v69 >> 1;
              uint64_t v36 = &v32[8 * (v69 >> 1)];
              unint64_t v71 = v32;
              if (v65 != v32)
              {
                memmove(v36, v32, v65 - v32);
                unint64_t v71 = v65;
              }
              unint64_t v65 = &v71[8 * v70];
            }
          }
          uint64_t v81 = *(void *)(v66 - 8);
          v66 -= 8;
          *((void *)v36 - 1) = v81;
          v36 -= 8;
        }
        unint64_t v82 = *(void **)(a1 + 720);
        *(void *)(a1 + 720) = v32;
        *(void *)(a1 + 728) = v36;
        *(void *)(a1 + 736) = v65;
        *(void *)(a1 + 744) = v38;
        if (v82) {
          operator delete(v82);
        }
        goto LABEL_37;
      }
      uint64_t v29 = operator new(0x1000uLL);
      uint64_t v30 = v29;
      if (v27 == v5)
      {
        if (v6 == v28)
        {
          if (v5 == v6) {
            unint64_t v83 = 1;
          }
          else {
            unint64_t v83 = (v27 - v6) >> 2;
          }
          uint64_t v84 = 2 * v83;
          uint64_t v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v83);
          uint64_t v6 = &v85[(v84 + 6) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v87 = *(uint64_t **)(a1 + 728);
          uint64_t v88 = v6;
          uint64_t v89 = *(void *)(a1 + 736) - (void)v87;
          unsigned __int16 v59 = (const void **)(a1 + 728);
          if (v89)
          {
            uint64_t v88 = &v6[v89 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v90 = 8 * (v89 >> 3);
            uint64_t v91 = &v85[(v84 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v92 = *v87++;
              *(void *)uint64_t v91 = v92;
              v91 += 8;
              v90 -= 8;
            }
            while (v90);
          }
          uint64_t v93 = *(void **)(a1 + 720);
          *(void *)(a1 + 720) = v85;
          *(void *)(a1 + 728) = v6;
          *(void *)(a1 + 736) = v88;
          *(void *)(a1 + 744) = &v85[8 * v86];
          if (v93)
          {
            operator delete(v93);
            uint64_t v6 = *(char **)(a1 + 728);
          }
        }
        else
        {
          unsigned __int16 v59 = (const void **)(a1 + 728);
        }
        *((void *)v6 - 1) = v30;
        unint64_t v94 = *(char **)(a1 + 728);
        *(void *)(a1 + 728) = v94 - 8;
        uint64_t v95 = *((void *)v94 - 1);
        *(void *)(a1 + 728) = v94;
        uint64_t v96 = *(char **)(a1 + 736);
        if (v96 == *(char **)(a1 + 744))
        {
          unint64_t v97 = *(void *)(a1 + 720);
          uint64_t v98 = (uint64_t)&v94[-v97];
          if ((unint64_t)v94 <= v97)
          {
            uint64_t v106 = (uint64_t)&v96[-v97];
            BOOL v43 = v106 == 0;
            uint64_t v107 = v106 >> 2;
            if (v43) {
              unint64_t v108 = 1;
            }
            else {
              unint64_t v108 = v107;
            }
            unint64_t v109 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v108);
            unint64_t v111 = &v109[8 * (v108 >> 2)];
            unint64_t v112 = *(uint64_t **)(a1 + 728);
            uint64_t v96 = v111;
            uint64_t v113 = *(void *)(a1 + 736) - (void)v112;
            if (v113)
            {
              uint64_t v96 = &v111[v113 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v114 = 8 * (v113 >> 3);
              unint64_t v115 = &v109[8 * (v108 >> 2)];
              do
              {
                uint64_t v116 = *v112++;
                *(void *)unint64_t v115 = v116;
                v115 += 8;
                v114 -= 8;
              }
              while (v114);
            }
            int v117 = *(void **)(a1 + 720);
            *(void *)(a1 + 720) = v109;
            *(void *)(a1 + 728) = v111;
            *(void *)(a1 + 736) = v96;
            *(void *)(a1 + 744) = &v109[8 * v110];
            if (v117)
            {
              operator delete(v117);
              uint64_t v96 = *(char **)(a1 + 736);
            }
          }
          else
          {
            uint64_t v99 = v98 >> 3;
            BOOL v18 = v98 >> 3 < -1;
            uint64_t v100 = (v98 >> 3) + 2;
            if (v18) {
              uint64_t v101 = v100;
            }
            else {
              uint64_t v101 = v99 + 1;
            }
            uint64_t v102 = -(v101 >> 1);
            uint64_t v103 = v101 >> 1;
            uint64_t v104 = &v94[-8 * v103];
            int64_t v105 = v96 - v94;
            if (v96 != v94)
            {
              memmove(&v94[-8 * v103], v94, v96 - v94);
              unint64_t v94 = (char *)*v59;
            }
            uint64_t v96 = &v104[v105];
            *(void *)(a1 + 736) = &v104[v105];
            *(void *)(a1 + 728) = &v94[8 * v102];
          }
        }
        *(void *)uint64_t v96 = v95;
      }
      else
      {
        *(void *)uint64_t v5 = v29;
      }
    }
    else
    {
      *(void *)(a1 + 752) = v9 - 512;
      uint64_t v14 = *(void *)v6;
      char v12 = v6 + 8;
      uint64_t v13 = v14;
      *(void *)(a1 + 728) = v12;
      if (v5 == *(char **)(a1 + 744))
      {
        unint64_t v15 = *(void *)(a1 + 720);
        uint64_t v16 = (uint64_t)&v12[-v15];
        if ((unint64_t)v12 <= v15)
        {
          uint64_t v44 = (uint64_t)&v5[-v15];
          BOOL v43 = v44 == 0;
          uint64_t v45 = v44 >> 2;
          if (v43) {
            unint64_t v46 = 1;
          }
          else {
            unint64_t v46 = v45;
          }
          long long v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v46);
          long long v49 = &v47[8 * (v46 >> 2)];
          uint64_t v50 = *(uint64_t **)(a1 + 728);
          uint64_t v5 = v49;
          uint64_t v51 = *(void *)(a1 + 736) - (void)v50;
          if (v51)
          {
            uint64_t v5 = &v49[v51 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v52 = 8 * (v51 >> 3);
            uint64_t v53 = &v47[8 * (v46 >> 2)];
            do
            {
              uint64_t v54 = *v50++;
              *(void *)uint64_t v53 = v54;
              v53 += 8;
              v52 -= 8;
            }
            while (v52);
          }
          __int16 v55 = *(void **)(a1 + 720);
          *(void *)(a1 + 720) = v47;
          *(void *)(a1 + 728) = v49;
          *(void *)(a1 + 736) = v5;
          *(void *)(a1 + 744) = &v47[8 * v48];
          if (v55)
          {
            operator delete(v55);
            uint64_t v5 = *(char **)(a1 + 736);
          }
        }
        else
        {
          uint64_t v17 = v16 >> 3;
          BOOL v18 = v16 >> 3 < -1;
          uint64_t v19 = (v16 >> 3) + 2;
          if (v18) {
            uint64_t v20 = v19;
          }
          else {
            uint64_t v20 = v17 + 1;
          }
          uint64_t v21 = -(v20 >> 1);
          uint64_t v22 = v20 >> 1;
          pthread_t v23 = &v12[-8 * v22];
          int64_t v24 = v5 - v12;
          if (v5 != v12)
          {
            memmove(&v12[-8 * v22], v12, v5 - v12);
            uint64_t v5 = *(char **)(a1 + 728);
          }
          uint64_t v25 = &v5[8 * v21];
          uint64_t v5 = &v23[v24];
          *(void *)(a1 + 736) = &v23[v24];
          *(void *)(a1 + 728) = v25;
        }
      }
      *(void *)uint64_t v5 = v13;
    }
    *(void *)(a1 + 736) += 8;
LABEL_37:
    uint64_t v10 = *(void *)(a1 + 760);
    uint64_t v6 = *(char **)(a1 + 728);
    unint64_t v11 = *(void *)(a1 + 752) + v10;
  }
  *(void *)(*(void *)&v6[(v11 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v11 & 0x1FF)) = v4;
  *(void *)(a1 + 760) = v10 + 1;
  v56.__id_ = v4;
  for (BOOL result = health::TransactionalFile::_transactionMutex_canStartWriteTransaction((health::TransactionalFile *)a1, v56);
        !result;
        BOOL result = health::TransactionalFile::_transactionMutex_canStartWriteTransaction((health::TransactionalFile *)a1, v58))
  {
    if (*(unsigned char *)(a1 + 344)) {
      break;
    }
    std::condition_variable::wait((std::condition_variable *)(a1 + 648), a2);
    v58.__id_ = v4;
  }
  return result;
}

void sub_1BCC586E8(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

BOOL health::TransactionalFile::_transactionMutex_canStartWriteTransaction(health::TransactionalFile *this, std::__thread_id a2)
{
  if (*((unsigned char *)this + 344) || *((void *)this + 98)) {
    return 0;
  }
  if (!*((void *)this + 95)) {
    return 1;
  }
  uint64_t v3 = *(_opaque_pthread_t **)(*(void *)(*((void *)this + 91) + ((*((void *)this + 94) >> 6) & 0x3FFFFFFFFFFFFF8))
                             + 8 * (*((void *)this + 94) & 0x1FFLL));
  if (!v3) {
    return !a2.__id_;
  }
  BOOL result = 0;
  if (a2.__id_ && v3 == a2.__id_) {
    return 1;
  }
  return result;
}

void health::TransactionalFile::configurePageSize(health::TransactionalFile *this, unint64_t a2)
{
  if (*((void *)this + 41))
  {
    uint64_t v2 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v6, "!isOpen()");
    std::string::basic_string[abi:ne180100]<0>(v5, "configurePageSize");
    std::string::basic_string[abi:ne180100]<0>(v4, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
    health::FormatString<>((std::string *)"Page size must be configured before the file is opened.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v2, (uint64_t)v6, (uint64_t)v5, (uint64_t)v4, 423, (uint64_t)&__p);
  }
  health::TransactionalFile::_configurePageSize(this, a2);
}

void sub_1BCC58868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

void health::TransactionalFile::_cacheMutex_writePage(health::TransactionalFile *this, unint64_t a2, health::FilePage *a3)
{
  unint64_t v12 = *(void *)a3;
  long long v7 = *(_OWORD *)a3;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)a3 + 3);
  uint64_t v8 = *((void *)a3 + 2);
  unint64_t v9 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *((void *)a3 + 4);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)a3 + 5);
  uint64_t v10 = v4;
  unint64_t v11 = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v4 = *((void *)a3 + 4);
  }
  if (v4) {
    unint64_t v6 = 48;
  }
  else {
    unint64_t v6 = *((void *)a3 + 1);
  }
  health::TransactionalCache<unsigned long long,health::FilePage>::setValueForKey((void *)this + 60, a2, &v12, &v7, v6, 1);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void sub_1BCC5898C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void health::FilePage::~FilePage(health::FilePage *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void health::TransactionalFile::_cacheMutex_pageForOffset(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  unint64_t v9 = -*(void *)(a1 + 392) & a3;
  unint64_t v49 = v9;
  uint64_t v10 = (void *)(a1 + 480);
  unint64_t v11 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>((void *)(a1 + 496), v9);
  if (v11)
  {
    uint64_t v12 = v11[4];
    while (v12 != v11[3])
    {
      uint64_t v14 = *(void *)(v12 - 8);
      v12 -= 8;
      uint64_t v13 = v14;
      if (*(void *)(v14 + 8) <= a2)
      {
        health::TransactionalCache<unsigned long long,health::FilePage>::_touchCacheEntry((uint64_t)v10, v13);
        uint64_t v15 = *(void *)(v13 + 8);
        long long v45 = *(_OWORD *)(v13 + 32);
        uint64_t v17 = *(void *)(v13 + 48);
        uint64_t v16 = *(void *)(v13 + 56);
        if (v16) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v19 = *(void *)(v13 + 64);
        uint64_t v18 = *(void *)(v13 + 72);
        if (v18) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
        }
        *(_OWORD *)((char *)v48 + 8) = v45;
        *(void *)&v48[0] = v15;
        *((void *)&v48[1] + 1) = v17;
        *(void *)&std::random_device v48[2] = v16;
        *((void *)&v48[2] + 1) = v19;
        *(void *)&uint64_t v48[3] = v18;
        BYTE8(v48[3]) = 1;
        health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::operator->((uint64_t)v48);
        if (*(void *)&v48[0] == a2)
        {
          health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::operator->((uint64_t)v48);
          health::TransactionalFile::_sanitizedPageForTransaction((void *)v48 + 1, a4, (health::FilePage *)a5);
          goto LABEL_39;
        }
        goto LABEL_12;
      }
    }
  }
  memset(v48, 0, 57);
LABEL_12:
  health::WriteAheadLog::pageAtOffset((std::mutex *)(a1 + 16), a2, v9, &v45);
  uint64_t v20 = v47;
  if ((unint64_t)v46 | (unint64_t)v47)
  {
    v42[0] = v45;
    uint64_t v21 = (std::__shared_weak_count *)*((void *)&v46 + 1);
    v42[1] = v46;
    if (*((void *)&v46 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v46 + 1) + 8), 1uLL, memory_order_relaxed);
      uint64_t v20 = v47;
    }
    uint64_t v22 = (std::__shared_weak_count *)*((void *)&v47 + 1);
    uint64_t v43 = v20;
    uint64_t v44 = *((void *)&v47 + 1);
    if (*((void *)&v47 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v47 + 1) + 8), 1uLL, memory_order_relaxed);
      uint64_t v20 = v47;
    }
    if (v20) {
      unint64_t v23 = 48;
    }
    else {
      unint64_t v23 = *((void *)&v45 + 1);
    }
    health::TransactionalCache<unsigned long long,health::FilePage>::setValueForKey(v10, a2, &v49, v42, v23, 0);
    if (v22) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v22);
    }
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v21);
    }
    long long v24 = v46;
    *(_OWORD *)a5 = v45;
    *(_OWORD *)(a5 + 16) = v24;
    long long v46 = 0uLL;
    *(_OWORD *)(a5 + 32) = v47;
    long long v47 = 0uLL;
  }
  else if (BYTE8(v48[3]))
  {
    if (a4 == 1)
    {
      health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::operator->((uint64_t)v48);
      health::FilePage::copy((health::FilePage *)a5, (void *)v48 + 1);
    }
    health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::operator->((uint64_t)v48);
    *(_OWORD *)a5 = *(_OWORD *)((char *)v48 + 8);
    uint64_t v26 = *(void *)&v48[2];
    *(void *)(a5 + 16) = *((void *)&v48[1] + 1);
    *(void *)(a5 + 24) = v26;
    if (v26) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v27 = *(void *)&v48[3];
    *(void *)(a5 + 32) = *((void *)&v48[2] + 1);
    *(void *)(a5 + 40) = v27;
    if (v27) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v25 = *(void *)(a1 + 392);
    if (a4 || (*(uint64_t (**)(void))(**(void **)(a1 + 328) + 48))(*(void *)(a1 + 328)) < v25 + v9)
    {
      *(void *)a5 = v9;
      *(void *)(a5 + 8) = v25;
      operator new[]();
    }
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 328) + 40))(&v40);
    uint64_t v29 = v40;
    int v28 = v41;
    if (v41) {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)a5 = *(_OWORD *)(v29 + 8);
    *(void *)(a5 + 16) = 0;
    *(void *)(a5 + 24) = 0;
    *(void *)(a5 + 32) = v29;
    *(void *)(a5 + 40) = v28;
    if (v28)
    {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v28);
      uint64_t v31 = *(void *)(a5 + 16);
      uint64_t v30 = *(std::__shared_weak_count **)(a5 + 24);
      long long v35 = *(_OWORD *)a5;
      uint64_t v36 = v31;
      uint64_t v37 = v30;
      if (v30) {
        atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    else
    {
      long long v35 = *(_OWORD *)a5;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
    }
    uint64_t v32 = *(void *)(a5 + 32);
    uint64_t v33 = *(std::__shared_weak_count **)(a5 + 40);
    uint64_t v38 = v32;
    uint64_t v39 = v33;
    if (v33)
    {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v32 = *(void *)(a5 + 32);
    }
    if (v32) {
      unint64_t v34 = 48;
    }
    else {
      unint64_t v34 = *(void *)(a5 + 8);
    }
    health::TransactionalCache<unsigned long long,health::FilePage>::setValueForKey(v10, a2, &v49, &v35, v34, 0);
    if (v33) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v33);
    }
    if (v37) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v37);
    }
    if (v41) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v41);
    }
  }
  if (*((void *)&v47 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v47 + 1));
  }
  if (*((void *)&v46 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v46 + 1));
  }
LABEL_39:
  if (*(void *)&v48[3]) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v48[3]);
  }
  if (*(void *)&v48[2]) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v48[2]);
  }
}

void sub_1BCC58E68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  health::FilePage::~FilePage((health::FilePage *)&a9);
  health::FilePage::~FilePage(v29);
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  health::FilePage::~FilePage((health::FilePage *)&a23);
  health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::~Optional((uint64_t)&a29);
  _Unwind_Resume(a1);
}

void health::TransactionalFile::_sanitizedPageForTransaction(void *a1@<X1>, int a2@<W2>, health::FilePage *a3@<X8>)
{
  uint64_t v3 = a1[2];
  uint64_t v4 = a1[4];
  if (v3 | v4)
  {
    if (a2 == 1 && v4) {
      health::FilePage::copy(a3, a1);
    }
    *(_OWORD *)a3 = *(_OWORD *)a1;
    uint64_t v7 = a1[3];
    *((void *)a3 + 2) = v3;
    *((void *)a3 + 3) = v7;
    if (v7)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      uint64_t v4 = a1[4];
    }
    uint64_t v8 = a1[5];
    *((void *)a3 + 4) = v4;
    *((void *)a3 + 5) = v8;
    if (v8)
    {
      unint64_t v9 = (atomic_ullong *)(v8 + 8);
LABEL_14:
      atomic_fetch_add_explicit(v9, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *(_OWORD *)a3 = *(_OWORD *)a1;
    uint64_t v5 = a1[3];
    *((void *)a3 + 2) = 0;
    *((void *)a3 + 3) = v5;
    if (v5)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      uint64_t v6 = a1[4];
    }
    else
    {
      uint64_t v6 = 0;
    }
    uint64_t v10 = a1[5];
    *((void *)a3 + 4) = v6;
    *((void *)a3 + 5) = v10;
    if (v10)
    {
      unint64_t v9 = (atomic_ullong *)(v10 + 8);
      goto LABEL_14;
    }
  }
}

uint64_t health::Optional<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntryDescriptor>::~Optional(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return a1;
}

uint64_t health::TransactionalFile::_resize(health::TransactionalFile *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 41) + 56))();
}

uint64_t health::TransactionalFile::_finishCheckpoint(health::TransactionalFile *this)
{
  health::VirtualFile::write<health::TransactionalFile::FileHeader>(*((void *)this + 41), (uint64_t)this + 352);
  uint64_t v2 = *(uint64_t (**)(void))(**((void **)this + 41) + 16);

  return v2();
}

void health::TransactionalFile::ReadTransaction::~ReadTransaction(health::TransactionalFile::ReadTransaction *this)
{
}

void health::TransactionalFile::WriteTransaction::~WriteTransaction(health::TransactionalFile::WriteTransaction *this)
{
}

void health::_HDAssertImplementation<std::out_of_range>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v39 = 0u;
  int v10 = backtrace(v38, 20);
  unint64_t v11 = backtrace_symbols(v38, v10);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v36);
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Critical Error: ", 16);
  int v13 = *(char *)(a6 + 23);
  if (v13 >= 0) {
    uint64_t v14 = a6;
  }
  else {
    uint64_t v14 = *(void *)a6;
  }
  if (v13 >= 0) {
    uint64_t v15 = *(unsigned __int8 *)(a6 + 23);
  }
  else {
    uint64_t v15 = *(void *)(a6 + 8);
  }
  uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, v14, v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Failed assertion '", 18);
  int v18 = *(char *)(a2 + 23);
  if (v18 >= 0) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = *(void *)a2;
  }
  if (v18 >= 0) {
    uint64_t v20 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v20 = *(void *)(a2 + 8);
  }
  uint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  uint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"' in '", 6);
  int v23 = *(char *)(a3 + 23);
  if (v23 >= 0) {
    uint64_t v24 = a3;
  }
  else {
    uint64_t v24 = *(void *)a3;
  }
  if (v23 >= 0) {
    uint64_t v25 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v25 = *(void *)(a3 + 8);
  }
  uint64_t v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
  uint64_t v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' at ", 5);
  int v28 = *(char *)(a4 + 23);
  if (v28 >= 0) {
    uint64_t v29 = a4;
  }
  else {
    uint64_t v29 = *(void *)a4;
  }
  if (v28 >= 0) {
    uint64_t v30 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v30 = *(void *)(a4 + 8);
  }
  uint64_t v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v29, v30);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)":", 1);
  uint64_t v32 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  if (!v10)
  {
    free(v11);
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v37, &v35);
    std::logic_error::logic_error(exception, &v35);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, *v11);
  health::HDDemangleBacktraceLine();
}

void sub_1BCC592EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  a21 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a21 + *(void *)(a21 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a22 = MEMORY[0x1E4FBA470] + 16;
  if (a35 < 0) {
    operator delete(a30);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&a38);
  _Unwind_Resume(a1);
}

uint64_t std::string::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    uint64_t v6 = operator new(v4 + 1);
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    *(unsigned char *)(a1 + 23) = a2;
  }
  return a1;
}

uint64_t std::deque<std::__thread_id>::~deque[abi:ne180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 512;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return std::__split_buffer<std::__thread_id *>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__deallocate_node(a1, *(char **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__deallocate_node(uint64_t a1, char *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = *(char **)v2;
      unint64_t v4 = (void **)(v2 + 24);
      std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__destroy_vector::operator()[abi:ne180100](&v4);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = (uint64_t **)*a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4 != a2)
  {
    unint64_t v5 = v4 - 1;
    do
    {
      uint64_t v6 = *v5;
      *unint64_t v5 = 0;
      if (v6) {
        std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>::operator()[abi:ne180100]((uint64_t)v5, v6);
      }
    }
    while (v5-- != a2);
  }
  *(void *)(a1 + 8) = a2;
}

void std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a2 + 72);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    unint64_t v4 = *(std::__shared_weak_count **)(a2 + 56);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
    JUMPOUT(0x1C187B8A0);
  }
}

void health::data_corruption_error::~data_corruption_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x1C187B8A0);
}

void health::transaction_error::~transaction_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x1C187B8A0);
}

void std::__shared_weak_count::__release_shared[abi:ne180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void std::shared_ptr<unsigned char>::shared_ptr[abi:ne180100]<unsigned char,std::default_delete<unsigned char []>,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1BCC5986C(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    MEMORY[0x1C187B880](v1, 0x1000C8077774924);
  }
  __cxa_rethrow();
}

void sub_1BCC59894(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<unsigned char  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C187B8A0);
}

uint64_t std::__shared_ptr_pointer<unsigned char  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void *std::__function::__value_func<BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

void std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::~__func()
{
}

void *std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1F171C140;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F171C140;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::operator()(uint64_t a1, unint64_t *a2, uint64_t a3, const health::FilePage *a4)
{
  return 1;
}

uint64_t std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0,std::allocator<health::TransactionalFile::TransactionalFile(std::string const&,std::shared_ptr<health::VirtualFilesystem>)::$_0>,BOOL ()(unsigned long long,unsigned long long const&,health::FilePage const&)>::target_type()
{
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
}

void sub_1BCC59B48(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  BOOL result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
  return result;
}

void health::file_access_error::~file_access_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x1C187B8A0);
}

void std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0>,void ()(unsigned long long)>::~__func()
{
}

void *std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0>,void ()(unsigned long long)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F171C210;
  return result;
}

void std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0>,void ()(unsigned long long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F171C210;
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_0>,void ()(unsigned long long)>::target_type()
{
}

void *std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::~__func()
{
}

__n128 std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F171C2A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171C2A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 328);
  uint64_t v6 = *a3;
  uint64_t v7 = a3[2];
  if (!v7) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a3[4] + 16))(a3[4]);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v5 + 24))(v5, v6, v7, a3[1]);
  **(unsigned char **)(a1 + 16) = 1;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_1>,void ()(unsigned long long,health::FilePage const&)>::target_type()
{
}

void *std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::~__func()
{
}

void *std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F171C330;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F171C330;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  health::VirtualFile::write<health::TransactionalFile::FileHeader>(*(void *)(v1 + 328), v1 + 352);
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(v1 + 328) + 16);

  return v2();
}

uint64_t std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2,std::allocator<health::TransactionalFile::open(health::TransactionalFile::OpenMethod)::$_2>,void ()(unsigned long long)>::target_type()
{
}

void *std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void **)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  uint64_t v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    if (v6)
    {
      if (!a2 || v6 != a2)
      {
        if (v6 >= a2) {
          char v7 = 1;
        }
        else {
          char v7 = -1;
        }
        goto LABEL_12;
      }
    }
    else if (a2)
    {
      char v7 = -1;
      goto LABEL_12;
    }
    char v7 = 0;
LABEL_12:
    BOOL v8 = (v7 & 0x80) == 0;
    if (v7 < 0) {
      unint64_t v9 = v3 + 1;
    }
    else {
      unint64_t v9 = v3;
    }
    if (v8) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v9;
  }
  while (*v9);
  if (v2 == v5) {
    return v2;
  }
  unint64_t v10 = v5[4];
  if (!a2)
  {
    if (!v10) {
      return v5;
    }
    return v2;
  }
  if (v10 > a2) {
    return v2;
  }
  return v5;
}

uint64_t health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 80);
  if (v2) {
    *(void *)(v2 + 88) = *(void *)(a2 + 88);
  }
  uint64_t v3 = *(void *)(a2 + 88);
  if (v3) {
    *(void *)(v3 + 80) = v2;
  }
  if (*(void *)(result + 64) == a2) {
    *(void *)(result + 64) = v3;
  }
  if (*(void *)(result + 56) == a2) {
    *(void *)(result + 56) = *(void *)(a2 + 80);
  }
  return result;
}

void health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)a1;
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  if (*(uint64_t **)a1 != v3)
  {
    while (*v2 != a2)
    {
      if (++v2 == v3) {
        return;
      }
    }
    if (v2 != v3)
    {
      unint64_t v6 = v2 + 1;
      if (v2 + 1 != v3)
      {
        do
        {
          uint64_t v7 = *v6;
          if (*v6 != a2)
          {
            *unint64_t v6 = 0;
            uint64_t v8 = *v2;
            uint64_t *v2 = v7;
            if (v8) {
              std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>::operator()[abi:ne180100]((uint64_t)v2, v8);
            }
            ++v2;
          }
          ++v6;
        }
        while (v6 != v3);
        uint64_t v3 = *(uint64_t **)(a1 + 8);
      }
    }
    if (v2 != v3)
    {
      unint64_t v9 = std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *>(v3, v3, v2);
      std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__base_destruct_at_end[abi:ne180100](a1, v9);
    }
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v12 = a1 + 2;
  uint64_t i = operator new(0x30uLL);
  *uint64_t i = 0;
  i[1] = v5;
  i[2] = *a3;
  i[3] = 0;
  i[4] = 0;
  i[5] = 0;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
    goto LABEL_64;
  }
  BOOL v15 = 1;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    int8x8_t prime = (int8x8_t)v17;
  }
  else {
    int8x8_t prime = (int8x8_t)v16;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = a1[1];
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }
    else
    {
      uint64_t v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }
    if (*(void *)&prime <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = a1[1];
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      unint64_t v34 = (void *)*a1;
      *a1 = 0;
      if (v34) {
        operator delete(v34);
      }
      unint64_t v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v19 = operator new(8 * *(void *)&prime);
  uint64_t v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = 0;
  a1[1] = (uint64_t)prime;
  do
    *(void *)(*a1 + 8 * v21++) = 0;
  while (*(void *)&prime != v21);
  uint64_t v22 = (void *)*v12;
  if (*v12)
  {
    unint64_t v23 = v22[1];
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&prime) {
        v23 %= *(void *)&prime;
      }
    }
    else
    {
      v23 &= *(void *)&prime - 1;
    }
    *(void *)(*a1 + 8 * v23) = v12;
    int v28 = (void *)*v22;
    if (*v22)
    {
      do
      {
        unint64_t v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }
        else
        {
          v29 &= *(void *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(void *)(*a1 + 8 * v29))
          {
            *(void *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          void *v22 = *v28;
          void *v28 = **(void **)(*a1 + 8 * v29);
          **(void **)(*a1 + 8 * v29) = v28;
          int v28 = v22;
        }
        unint64_t v29 = v23;
LABEL_56:
        uint64_t v22 = v28;
        int v28 = (void *)*v28;
        unint64_t v23 = v29;
      }
      while (v28);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  uint64_t v30 = *a1;
  uint64_t v31 = *(void **)(*a1 + 8 * v5);
  if (v31)
  {
    *uint64_t i = *v31;
LABEL_72:
    void *v31 = i;
    goto LABEL_73;
  }
  *uint64_t i = *v12;
  *uint64_t v12 = i;
  *(void *)(v30 + 8 * v5) = v12;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    uint64_t v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return i;
}

void sub_1BCC5A5F4(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  if (a1)
  {
    unint64_t v3 = __p + 3;
    std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  if (__p) {
    operator delete(__p);
  }
}

uint64_t *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *,std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  if (a1 != a2)
  {
    unint64_t v5 = a1;
    do
    {
      uint64_t v6 = *v5;
      *unint64_t v5 = 0;
      uint64_t v7 = *a3;
      *a3 = v6;
      if (v7) {
        std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>::operator()[abi:ne180100]((uint64_t)a3, v7);
      }
      ++v5;
      ++a3;
    }
    while (v5 != a2);
  }
  return a3;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>(void *a1, unint64_t a2)
{
  unint64_t v3 = (void **)std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>(a1, a2);
  if (v3)
  {
    unint64_t v4 = v3;
    int8x8_t v5 = (int8x8_t)a1[1];
    uint64_t v6 = *v3;
    unint64_t v7 = (unint64_t)v3[1];
    uint8x8_t v8 = (uint8x8_t)vcnt_s8(v5);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      if (v7 >= *(void *)&v5) {
        v7 %= *(void *)&v5;
      }
    }
    else
    {
      v7 &= *(void *)&v5 - 1;
    }
    unint64_t v9 = *(void ***)(*a1 + 8 * v7);
    do
    {
      unint64_t v10 = v9;
      unint64_t v9 = (void **)*v9;
    }
    while (v9 != v3);
    if (v10 == a1 + 2) {
      goto LABEL_19;
    }
    unint64_t v11 = (unint64_t)v10[1];
    if (v8.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v5) {
        v11 %= *(void *)&v5;
      }
    }
    else
    {
      v11 &= *(void *)&v5 - 1;
    }
    if (v11 != v7)
    {
LABEL_19:
      if (v6)
      {
        unint64_t v12 = v6[1];
        if (v8.u32[0] > 1uLL)
        {
          unint64_t v13 = v6[1];
          if (v12 >= *(void *)&v5) {
            unint64_t v13 = v12 % *(void *)&v5;
          }
        }
        else
        {
          unint64_t v13 = v12 & (*(void *)&v5 - 1);
        }
        if (v13 == v7) {
          goto LABEL_23;
        }
      }
      *(void *)(*a1 + 8 * v7) = 0;
      uint64_t v6 = *v3;
    }
    if (!v6)
    {
LABEL_29:
      void *v10 = v6;
      uint64_t *v3 = 0;
      --a1[3];
      float v14 = v3 + 3;
      std::vector<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>::__destroy_vector::operator()[abi:ne180100](&v14);
      operator delete(v4);
      return;
    }
    unint64_t v12 = v6[1];
LABEL_23:
    if (v8.u32[0] > 1uLL)
    {
      if (v12 >= *(void *)&v5) {
        v12 %= *(void *)&v5;
      }
    }
    else
    {
      v12 &= *(void *)&v5 - 1;
    }
    if (v12 != v7)
    {
      *(void *)(*a1 + 8 * v12) = v10;
      uint64_t v6 = *v3;
    }
    goto LABEL_29;
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  int8x8_t v5 = *(void **)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  uint64_t result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(void *)&v2) {
            v7 %= *(void *)&v2;
          }
        }
        else
        {
          v7 &= *(void *)&v2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::~__func()
{
}

__n128 std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::__clone(uint64_t a1)
{
  int8x8_t v2 = (char *)operator new(0x20uLL);
  *(void *)int8x8_t v2 = &unk_1F171C3B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171C3B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::operator()(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a1[1];
  v20.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v4 + 584);
  v20.__owns_ = 1;
  std::mutex::lock((std::mutex *)(v4 + 584));
  uint64_t v5 = *(unsigned int *)(v4 + 360);
  v19[0] = &unk_1F171C0C8;
  v19[1] = v3;
  void v19[2] = v4;
  v19[3] = v5;
  uint64_t v6 = (unint64_t *)a1[2];
  uint64_t v7 = a1[3];
  uint8x8_t v8 = (void **)(v4 + 696);
  unint64_t v9 = *v6;
  unint64_t v10 = *(void **)(v4 + 704);
  if (v10)
  {
    while (1)
    {
      unint64_t v11 = v10;
      unint64_t v12 = v10[4];
      if (!v9) {
        break;
      }
      if (v12) {
        BOOL v13 = v12 == v9;
      }
      else {
        BOOL v13 = 0;
      }
      if (v13)
      {
LABEL_18:
        float v14 = v11;
        goto LABEL_19;
      }
      if (v12 > v9)
      {
LABEL_12:
        unint64_t v10 = (void *)*v11;
        int v18 = (uint64_t **)v11;
        if (!*v11) {
          goto LABEL_15;
        }
      }
      else
      {
        if (v12 >= v9) {
          goto LABEL_18;
        }
        unint64_t v10 = (void *)v11[1];
        if (!v10)
        {
          int v18 = (uint64_t **)(v11 + 1);
          goto LABEL_15;
        }
      }
    }
    if (!v12) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }
  int v18 = (uint64_t **)(v4 + 704);
  unint64_t v11 = (void *)(v4 + 704);
LABEL_15:
  float v14 = (uint64_t *)operator new(0x30uLL);
  v14[4] = v9;
  v14[5] = 0;
  *float v14 = 0;
  v14[1] = 0;
  void v14[2] = (uint64_t)v11;
  *int v18 = v14;
  BOOL v15 = (void *)**v8;
  unint64_t v16 = v14;
  if (v15)
  {
    std::__shared_weak_count *v8 = v15;
    unint64_t v16 = *v18;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 704), v16);
  ++*(void *)(v4 + 712);
LABEL_19:
  v14[5] = (uint64_t)v19;
  std::unique_lock<std::mutex>::unlock(&v20);
  uint64_t v17 = *(void *)(v7 + 24);
  if (!v17) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, void *))(*(void *)v17 + 48))(v17, v19);
  std::unique_lock<std::mutex>::lock(&v20);
  std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::__erase_unique<std::__thread_id>((uint64_t **)(v4 + 696), *v6);
  std::condition_variable::notify_all((std::condition_variable *)(v4 + 648));
  if (v20.__owns_) {
    std::mutex::unlock(v20.__m_);
  }
}

void sub_1BCC5AB30(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::unique_lock<std::mutex> a13)
{
}

void sub_1BCC5AB64()
{
}

uint64_t std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0,std::allocator<health::TransactionalFile::readTransactionWithLambda(std::function<void ()(health::TransactionalFile::ReadTransaction const&)>)::$_0>,void ()(unsigned long long)>::target_type()
{
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      int8x8_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), uint64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            unint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            unint64_t v9 = (uint64_t **)v2[1];
            unint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              id v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            void v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            uint64_t *v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            int8x8_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), uint64_t v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        int8x8_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        void v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *uint64_t v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::__erase_unique<std::__thread_id>(uint64_t **a1, unint64_t a2)
{
  uint64_t v3 = std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::find<std::__thread_id>((uint64_t)a1, a2);
  if (a1 + 1 != (uint64_t **)v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = (uint64_t *)v3[1];
    if (v5)
    {
      do
      {
        int v6 = v5;
        uint64_t v5 = (uint64_t *)*v5;
      }
      while (v5);
    }
    else
    {
      uint64_t v7 = v3;
      do
      {
        int v6 = (uint64_t *)v7[2];
        BOOL v8 = *v6 == (void)v7;
        uint64_t v7 = v6;
      }
      while (!v8);
    }
    if (*a1 == v3) {
      *a1 = v6;
    }
    unint64_t v9 = a1[1];
    a1[2] = (uint64_t *)((char *)a1[2] - 1);
    std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v9, v4);
    operator delete(v4);
  }
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      uint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      uint64_t v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  int v6 = (uint64_t **)v3[2];
  uint64_t v7 = *v6;
  if (*v6 == v3)
  {
    *int v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      uint64_t v7 = 0;
      __n128 result = (uint64_t *)v2;
    }
    else
    {
      uint64_t v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    void v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    uint64_t *v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      __n128 result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 != v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v18 = v7[1];
      *(void *)uint64_t v12 = v18;
      if (v18) {
        *(void *)(v18 + 16) = v12;
      }
      void v7[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(void *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12) {
        __n128 result = v7;
      }
      uint64_t v7 = *(uint64_t **)v12;
    }
    uint64_t v19 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v19 + 24)) {
      goto LABEL_68;
    }
    std::unique_lock<std::mutex> v20 = (uint64_t *)v7[1];
    if (v20 && !*((unsigned char *)v20 + 24))
    {
      if (v19 && !*((unsigned char *)v19 + 24))
      {
LABEL_68:
        std::unique_lock<std::mutex> v20 = v7;
      }
      else
      {
        *((unsigned char *)v20 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v26 = *v20;
        v7[1] = *v20;
        if (v26) {
          *(void *)(v26 + 16) = v7;
        }
        v20[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
        *std::unique_lock<std::mutex> v20 = (uint64_t)v7;
        void v7[2] = (uint64_t)v20;
        uint64_t v19 = v7;
      }
      uint64_t v23 = v20[2];
      *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v19 + 24) = 1;
      uint8x8_t v24 = *(uint64_t **)v23;
      uint64_t v27 = *(void *)(*(void *)v23 + 8);
      *(void *)uint64_t v23 = v27;
      if (v27) {
        *(void *)(v27 + 16) = v23;
      }
      void v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
LABEL_49:
    uint64_t v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v13 = *(uint64_t **)(v12 + 8);
    uint64_t v14 = *v13;
    *(void *)(v12 + 8) = *v13;
    if (v14) {
      *(void *)(v14 + 16) = v12;
    }
    void v13[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
    *uint64_t v13 = v12;
    *(void *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7) {
      __n128 result = v7;
    }
    uint64_t v7 = *(uint64_t **)(*v7 + 8);
  }
  BOOL v15 = (void *)*v7;
  if (!*v7 || *((unsigned char *)v15 + 24))
  {
    unint64_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_59;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  unint64_t v16 = (uint64_t *)v7[1];
  if (v16 && !*((unsigned char *)v16 + 24))
  {
LABEL_59:
    BOOL v15 = v7;
  }
  else
  {
    *((unsigned char *)v15 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v22 = v15[1];
    *uint64_t v7 = v22;
    if (v22) {
      *(void *)(v22 + 16) = v7;
    }
    void v15[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
    v15[1] = v7;
    void v7[2] = (uint64_t)v15;
    unint64_t v16 = v7;
  }
  uint64_t v23 = v15[2];
  *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v16 + 24) = 1;
  uint8x8_t v24 = *(uint64_t **)(v23 + 8);
  uint64_t v25 = *v24;
  *(void *)(v23 + 8) = *v24;
  if (v25) {
    *(void *)(v25 + 16) = v23;
  }
  void v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  *uint8x8_t v24 = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a1);
}

void health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_1::operator()(uint64_t a1)
{
  uint64_t v2 = *(std::unique_lock<std::mutex> **)a1;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v2->__owns_) {
    std::unique_lock<std::mutex>::lock(v2);
  }
  std::__tree<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::__map_value_compare<std::__thread_id,std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>,std::less<std::__thread_id>,true>,std::allocator<std::__value_type<std::__thread_id,health::TransactionalFile::ReadTransaction *>>>::__erase_unique<std::__thread_id>((uint64_t **)(v3 + 768), **(void **)(a1 + 16));

  std::condition_variable::notify_all((std::condition_variable *)(v3 + 648));
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::~__func()
{
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F171C430;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171C430;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::operator()(uint64_t a1, unint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(v3 + 360);
  unint64_t v30 = *a2;
  uint64_t v31 = v3;
  uint64_t v32 = v4;
  uint64_t v33 = v3;
  unint64_t v29 = &unk_1F171C0F0;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(v3 + 328) + 48))(*(void *)(v3 + 328));
  uint64_t v6 = health::WriteAheadLog::maximumCommittedSizeForTransaction((std::mutex *)(v3 + 16), v30);
  if (v5 <= v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v5;
  }
  uint64_t v34 = ((v7 - v32) & ~((v7 - v32) >> 63)) + v4;
  int v8 = **(uint64_t ***)(a1 + 16);
  uint64_t v9 = *(uint64_t **)(v3 + 776);
  if (!v9)
  {
    uint8x8_t v24 = (uint64_t **)(v3 + 776);
    uint64_t v10 = (uint64_t **)(v3 + 776);
    goto LABEL_18;
  }
  do
  {
    while (1)
    {
      uint64_t v10 = (uint64_t **)v9;
      unint64_t v11 = v9[4];
      if (!v8)
      {
        if (!v11) {
          goto LABEL_21;
        }
        goto LABEL_15;
      }
      if (v11) {
        BOOL v12 = v11 == (void)v8;
      }
      else {
        BOOL v12 = 0;
      }
      if (v12) {
        goto LABEL_21;
      }
      if (v11 <= (unint64_t)v8) {
        break;
      }
LABEL_15:
      uint64_t v9 = *v10;
      uint8x8_t v24 = v10;
      if (!*v10) {
        goto LABEL_18;
      }
    }
    if (v11 >= (unint64_t)v8) {
      goto LABEL_21;
    }
    uint64_t v9 = v10[1];
  }
  while (v9);
  uint8x8_t v24 = v10 + 1;
LABEL_18:
  uint64_t v13 = (uint64_t *)v10;
  uint64_t v10 = (uint64_t **)operator new(0x30uLL);
  v10[4] = v8;
  void v10[5] = 0;
  uint64_t *v10 = 0;
  v10[1] = 0;
  id v10[2] = v13;
  *uint8x8_t v24 = (uint64_t *)v10;
  uint64_t v14 = **(void **)(v3 + 768);
  BOOL v15 = (uint64_t *)v10;
  if (v14)
  {
    *(void *)(v3 + 768) = v14;
    BOOL v15 = *v24;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 776), v15);
  ++*(void *)(v3 + 784);
LABEL_21:
  void v10[5] = (uint64_t *)&v29;
  unint64_t v16 = *(_opaque_pthread_t **)(*(void *)(*(void *)(v3 + 728) + ((*(void *)(v3 + 752) >> 6) & 0x3FFFFFFFFFFFFF8))
                              + 8 * (*(void *)(v3 + 752) & 0x1FFLL));
  pthread_t v17 = pthread_self();
  if (v16)
  {
    if (!v17 || v16 != v17)
    {
LABEL_26:
      uint64_t v18 = *MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v28, "_waitingWriterThreads.front() == std::this_thread::get_id()");
      std::string::basic_string[abi:ne180100]<0>(v27, "operator()");
      std::string::basic_string[abi:ne180100]<0>(v26, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDTransactionalFile.cpp");
      health::FormatString<>((std::string *)"Improper thread at write transaction start.", &__p);
      health::_HDAssertImplementation<std::logic_error>(v18, (uint64_t)v28, (uint64_t)v27, (uint64_t)v26, 309, (uint64_t)&__p);
    }
  }
  else if (v17)
  {
    goto LABEL_26;
  }
  int64x2_t v19 = vaddq_s64(*(int64x2_t *)(v3 + 752), (int64x2_t)xmmword_1BD325E90);
  *(int64x2_t *)(v3 + 752) = v19;
  if (v19.i64[0] >= 0x400uLL)
  {
    operator delete(**(void ***)(v3 + 728));
    *(void *)(v3 + 728) += 8;
    *(void *)(v3 + 752) -= 512;
  }
  std::unique_lock<std::mutex>::unlock(*(std::unique_lock<std::mutex> **)(a1 + 24));
  uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 24);
  if (!v20) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v21 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v20 + 48))(v20, &v29);
  if (v21)
  {
    std::mutex::lock((std::mutex *)(v3 + 416));
    for (uint64_t i = *(void *)(v3 + 536); i; uint64_t i = *(void *)(i + 80))
    {
      if (*(_DWORD *)i == 1)
      {
        health::WriteAheadLog::updatedPage((std::mutex *)(v3 + 16), *(void *)(i + 8), (const health::FilePage *)(i + 32));
        *(_DWORD *)uint64_t i = 0;
      }
    }
  }
  else
  {
    std::mutex::lock((std::mutex *)(v3 + 416));
    health::TransactionalCache<unsigned long long,health::FilePage>::discardEntriesForTransaction(v3 + 480, v30);
  }
  std::mutex::unlock((std::mutex *)(v3 + 416));
  return v21;
}

void sub_1BCC5B610(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34)
{
}

void sub_1BCC5B700()
{
  std::mutex::unlock(v0);
  __cxa_end_catch();
  JUMPOUT(0x1BCC5B718);
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::target_type()
{
}

void health::TransactionalCache<unsigned long long,health::FilePage>::discardEntriesForTransaction(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    uint64_t v5 = (uint64_t *)(a1 + 16);
    do
    {
      uint64_t v6 = (void *)v2[11];
      if (v2[1] == a2)
      {
        unint64_t v7 = v2[3];
        *(void *)(a1 + 8) -= v2[2];
        unint64_t v9 = v7;
        health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList(a1, (uint64_t)v2);
        int v8 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v5, v7, &v9);
        health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine::removeEntry((uint64_t)(v8 + 3), (uint64_t)v2);
        if (v8[4] == v8[3]) {
          std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>(v5, v7);
        }
      }
      uint64_t v2 = v6;
    }
    while (v6);
  }
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::~__func()
{
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F171C4C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171C4C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  std::unique_lock<std::mutex>::lock(*(std::unique_lock<std::mutex> **)(a1 + 8));
  health::VirtualFile::write<health::TransactionalFile::FileHeader>(*(void *)(v1 + 328), v1 + 352);
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(v1 + 328) + 16);

  return v2();
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#2}>,void ()(unsigned long long)>::target_type()
{
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::~__func()
{
}

void *std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F171C540;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F171C540;
  a2[1] = v2;
  return result;
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::operator()(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v4 = *a2;
  uint64_t v5 = *(void **)(a1 + 8);
  uint64_t v6 = v5[41];
  unint64_t v7 = *(void *)a3;
  uint64_t v8 = *(void *)(a3 + 16);
  if (!v8) {
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a3 + 32) + 16))(*(void *)(a3 + 32));
  }
  (*(void (**)(uint64_t, unint64_t, uint64_t, void))(*(void *)v6 + 24))(v6, v7, v8, *(void *)(a3 + 8));
  unint64_t v9 = *(void *)a3;
  uint64_t v10 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>(v5 + 62, *(void *)a3);
  if (v10)
  {
    unint64_t v11 = (uint64_t *)v10[3];
    BOOL v12 = (uint64_t *)v10[4];
    while (v11 != v12)
    {
      uint64_t v13 = *v11++;
      v5[61] -= *(void *)(v13 + 16);
      health::TransactionalCache<unsigned long long,health::FilePage>::_removeEntryFromList((uint64_t)(v5 + 60), v13);
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::__erase_unique<unsigned long long>(v5 + 62, v9);
    unint64_t v9 = *(void *)a3;
  }
  unint64_t v23 = v9;
  long long v18 = *(_OWORD *)a3;
  uint64_t v14 = *(std::__shared_weak_count **)(a3 + 24);
  uint64_t v19 = *(void *)(a3 + 16);
  uint64_t v20 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = *(void *)(a3 + 32);
  unint64_t v16 = *(std::__shared_weak_count **)(a3 + 40);
  uint64_t v21 = v15;
  uint64_t v22 = v16;
  if (v16)
  {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v15 = *(void *)(a3 + 32);
  }
  if (v15) {
    unint64_t v17 = 48;
  }
  else {
    unint64_t v17 = *(void *)(a3 + 8);
  }
  health::TransactionalCache<unsigned long long,health::FilePage>::setValueForKey(v5 + 60, v4, &v23, &v18, v17, 0);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  if (v14)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
}

void sub_1BCC5BBB4(_Unwind_Exception *exception_object)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long,health::FilePage const&)#1}>,void ()(unsigned long long,health::FilePage const&)>::target_type()
{
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::~__func()
{
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F171C5C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171C5C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  health::VirtualFile::write<health::TransactionalFile::FileHeader>(*(void *)(v2 + 328), v2 + 352);
  (*(void (**)(void))(**(void **)(v2 + 328) + 16))(*(void *)(v2 + 328));
  uint64_t v3 = *(std::unique_lock<std::mutex> **)(a1 + 16);

  std::unique_lock<std::mutex>::unlock(v3);
}

uint64_t std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3},std::allocator<health::TransactionalFile::writeTransactionWithLambda(std::function<BOOL ()(health::TransactionalFile::WriteTransaction &)>)::$_0::operator() const(void)::{lambda(unsigned long long)#3}>,void ()(unsigned long long)>::target_type()
{
}

void *std::__function::__value_func<BOOL ()(unsigned long long)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1BCC5D16C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC5D2B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC5D3BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC5D4C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC5D5B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC5D7BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1BCC5E928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,void *a21,void *a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,void *a28,void *a29,void *a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,_Unwind_Exception *exception_objecta,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50)
{
  _Block_object_dispose(&STACK[0x238], 8);
  uint64_t v50 = (void *)STACK[0x268];
  if (STACK[0x268])
  {
    STACK[0x270] = (unint64_t)v50;
    operator delete(v50);
  }

  _Block_object_dispose(&a43, 8);
  std::__tree<long>::destroy((void *)a50);

  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__25(void *result, void *a2)
{
  result[6] = a2[6];
  uint64_t v2 = a2 + 7;
  uint64_t v3 = a2[7];
  result[7] = v3;
  unint64_t v4 = result + 7;
  uint64_t v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[6] = v2;
    void *v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__25(uint64_t a1)
{
}

void sub_1BCC5EE88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC5EF20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC5F008(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC5F358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__304(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__305(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void std::__tree<long>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<long>::destroy(*a1);
    std::__tree<long>::destroy(a1[1]);
    operator delete(a1);
  }
}

uint64_t *std::__tree<long>::__emplace_unique_key_args<long,long const&>(uint64_t *result, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = result;
  uint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    unint64_t v9 = (uint64_t *)operator new(0x28uLL);
    void v9[4] = a3;
    uint64_t *v9 = 0;
    v9[1] = 0;
    void v9[2] = (uint64_t)v7;
    *uint64_t v6 = v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      uint64_t *v4 = v10;
      unint64_t v11 = *v6;
    }
    else
    {
      unint64_t v11 = v9;
    }
    __n128 result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

uint64_t *HKIntervalMask<double>::_insertInterval(uint64_t *result, double a2, double a3)
{
  uint64_t v3 = result;
  uint64_t v4 = 0;
  *(double *)uint64_t v13 = a2;
  *(double *)&v13[1] = a3;
  uint64_t v5 = (char *)*result;
  uint64_t v6 = result[1];
  do
  {
    if ((char *)(v6 + v4) == v5)
    {
      unint64_t v11 = std::vector<HKRawInterval<double>>::insert((uint64_t)result, v5, (char *)v13);
      return HKIntervalMask<double>::_compactIntervalsForwardFrom<std::__wrap_iter<HKRawInterval<double> *>>(v3, (uint64_t)v11);
    }
    double v7 = *(double *)(v6 + v4 - 16);
    v4 -= 16;
  }
  while (v7 > a2);
  uint64_t v8 = v6 + v4;
  double v9 = *(double *)(v6 + v4 + 8);
  if (v9 >= a2)
  {
    if (a3 <= v9) {
      return result;
    }
    *(double *)(v8 + 8) = a3;
    if (v4 == -16) {
      return result;
    }
    uint64_t v10 = (char *)(v6 + v4);
    goto LABEL_15;
  }
  uint64_t v10 = (char *)(v8 + 16);
  if (v4 == -16 || a3 < *(double *)(v8 + 16)) {
    return (uint64_t *)std::vector<HKRawInterval<double>>::insert((uint64_t)result, v10, (char *)v13);
  }
  *(double *)(v8 + 16) = a2;
  uint64_t v12 = v6 + v4;
  if (a3 > *(double *)(v12 + 24))
  {
    *(double *)(v12 + 24) = a3;
LABEL_15:
    return HKIntervalMask<double>::_compactIntervalsForwardFrom<std::__wrap_iter<HKRawInterval<double> *>>(result, (uint64_t)v10);
  }
  return result;
}

uint64_t *HKIntervalMask<double>::_compactIntervalsForwardFrom<std::__wrap_iter<HKRawInterval<double> *>>(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = (double *)result[1];
  uint64_t v4 = (a2 - *result) >> 4;
  unint64_t v5 = v4 + 1;
  if (v4 + 1 < (unint64_t)(((uint64_t)v3 - *result) >> 4))
  {
    uint64_t v6 = result;
    do
    {
      double v7 = (double *)(v2 + 16 * v4);
      double v8 = v7[1];
      double v9 = (double *)(v2 + 16 * v5);
      if (v8 < *v9) {
        break;
      }
      double v10 = *v7;
      if (v8 < v9[1]) {
        double v8 = v9[1];
      }
      if (v8 >= v10) {
        double v11 = *v7;
      }
      else {
        double v11 = v8;
      }
      if (v10 >= v8) {
        double v8 = *v7;
      }
      *double v7 = v11;
      v7[1] = v8;
      uint64_t v12 = v7 + 2;
      int64_t v13 = (char *)v3 - (char *)(v7 + 4);
      if (v3 != v7 + 4)
      {
        __n128 result = (uint64_t *)memmove(v7 + 2, v7 + 4, (char *)v3 - (char *)(v7 + 4));
        uint64_t v2 = *v6;
      }
      uint64_t v3 = (double *)((char *)v12 + v13);
      v6[1] = (uint64_t)v12 + v13;
    }
    while (v5 < ((uint64_t)v12 + v13 - v2) >> 4);
  }
  return result;
}

char *std::vector<HKRawInterval<double>>::insert(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    int64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 4) + 1;
    if (v14 >> 60) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 4;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 3 > v14) {
      unint64_t v14 = v17 >> 3;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HKRawInterval<double>>>(a1 + 16, v18);
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v20 = &v19[16 * v16];
    std::string __p = v19;
    uint64_t v27 = v20;
    int v28 = v20;
    unint64_t v29 = &v19[16 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 3;
        }
        unint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HKRawInterval<double>>>(v8, v22);
        uint64_t v20 = &v23[16 * (v22 >> 2)];
        std::string __p = v23;
        uint64_t v27 = v20;
        unint64_t v29 = &v23[16 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 16 * (v21 >> 1);
        uint64_t v27 = v20;
      }
    }
    *(_OWORD *)uint64_t v20 = *(_OWORD *)v3;
    int v28 = v20 + 16;
    uint64_t v4 = (char *)std::vector<HKRawInterval<double>>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(_OWORD *)__src = *(_OWORD *)a3;
    *(void *)(a1 + 8) = __src + 16;
  }
  else
  {
    double v9 = __src + 16;
    double v10 = v6 - 16;
    double v11 = *(_OWORD **)(a1 + 8);
    while (v10 < v6)
    {
      long long v12 = *(_OWORD *)v10;
      v10 += 16;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-16 * ((v6 - v9) >> 4)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 16 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(_OWORD *)uint64_t v4 = *(_OWORD *)v3;
  }
  return v4;
}

void sub_1BCC5F9E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<HKRawInterval<double>>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  unint64_t v5 = *(void **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  unint64_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      unint64_t v7 = (void *)(v9 - 16);
      *(_OWORD *)(v9 - 16) = *((_OWORD *)v8 - 1);
      v8 -= 16;
      v9 -= 16;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  double v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    unint64_t v7 = *(void **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  int64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<HKRawInterval<double>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a2);
}

void _HDMakeSleepIntervalAverageInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 <= 1) {
    uint64_t v3 = 1;
  }
  *(void *)(a1 + 16) = 0;
  *(float64x2_t *)a1 = vrndmq_f64(vdivq_f64(*(float64x2_t *)(a2 + 16), (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v3), 0)));
  *(void *)(a1 + 16) = [*(id *)(a2 + 32) copy];
  uint64_t v4 = *(void **)(a2 + 32);
}

void sub_1BCC5FB98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC60314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34)
{
  _Unwind_Resume(a1);
}

void sub_1BCC606F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  _Unwind_Resume(a1);
}

void sub_1BCC60B04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC62614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a58, 8);
  _Block_object_dispose(&a64, 8);
  _Block_object_dispose(&a70, 8);
  _Block_object_dispose((const void *)(v70 - 232), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__26(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__26(uint64_t a1)
{
}

void sub_1BCC66970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__27(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__27(uint64_t a1)
{
}

void sub_1BCC67244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__28(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__28(uint64_t a1)
{
}

void sub_1BCC676EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCC6937C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id *location, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23)
{
}

BOOL HDCodableSharingAuthorizationReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3) {
        break;
      }
      if (v17 == 2)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 16;
        goto LABEL_24;
      }
      if (v17 == 1)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 8;
LABEL_24:
        uint64_t v20 = *(void **)(a1 + v19);
        *(void *)(a1 + v19) = v18;

        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_26:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v18 = PBReaderReadString();
    uint64_t v19 = 24;
    goto LABEL_24;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

BOOL HDCodableNotificationInstructionRequestReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = *(HDCodableNotificationInstructionMessage **)(a1 + 16);
        *(void *)(a1 + 16) = v17;
LABEL_24:

        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_26:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v18 = objc_alloc_init(HDCodableNotificationInstructionMessage);
    objc_storeStrong((id *)(a1 + 8), v18);
    if (!PBReaderPlaceMark()
      || (HDCodableNotificationInstructionMessageReadFrom((uint64_t)v18, a2) & 1) == 0)
    {

      return 0;
    }
    PBReaderRecallMark();
    goto LABEL_24;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

id getSOSUtilitiesClass()
{
  uint64_t v4 = 0;
  unint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  unint64_t v0 = (void *)_MergedGlobals_199;
  uint64_t v7 = _MergedGlobals_199;
  if (!_MergedGlobals_199)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    void v3[2] = __getSOSUtilitiesClass_block_invoke;
    v3[3] = &unk_1E62F6B28;
    v3[4] = &v4;
    __getSOSUtilitiesClass_block_invoke((uint64_t)v3);
    unint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_1BCC6F0C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getSOSUtilitiesClass_block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  v6[0] = 0;
  if (!qword_1EBA18B20)
  {
    v6[1] = (void *)MEMORY[0x1E4F143A8];
    void v6[2] = (void *)3221225472;
    uint64_t v6[3] = __SOSLibraryCore_block_invoke;
    v6[4] = &__block_descriptor_40_e5_v8__0l;
    v6[5] = v6;
    long long v7 = xmmword_1E62F6B48;
    uint64_t v8 = 0;
    qword_1EBA18B20 = _sl_dlopen();
  }
  if (!qword_1EBA18B20)
  {
    uint64_t v3 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v4 = [NSString stringWithUTF8String:"void *SOSLibrary(void)"];
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, @"HDMedicalIDDataManager.m", 42, @"%s", v6[0]);

    goto LABEL_10;
  }
  if (v6[0]) {
    free(v6[0]);
  }
  Class result = objc_getClass("SOSUtilities");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    uint64_t v3 = [MEMORY[0x1E4F28B00] currentHandler];
    unint64_t v5 = [NSString stringWithUTF8String:"Class getSOSUtilitiesClass(void)_block_invoke"];
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v5, @"HDMedicalIDDataManager.m", 43, @"Unable to find class %s", "SOSUtilities");

LABEL_10:
    __break(1u);
  }
  _MergedGlobals_199 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __SOSLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  qword_1EBA18B20 = result;
  return result;
}

void sub_1BCC712A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCC71FFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC722EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC726A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__29(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__29(uint64_t a1)
{
}

void sub_1BCC7294C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::vector<std::tuple<long long,HKSample * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);

  _Unwind_Resume(a1);
}

void sub_1BCC72A68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC72B10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC72BD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC72E24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCC73000(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::tuple<long long,HKSample * {__strong}>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *std::vector<std::tuple<long long,HKSample * {__strong}>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HKRawInterval<double>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void std::vector<std::tuple<long long,HKSample * {__strong}>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  id v1 = *a1;
  uint64_t v2 = (id *)**a1;
  if (v2)
  {
    uint64_t v4 = (id *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 2;

        uint64_t v4 = v6;
      }
      while (v6 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::tuple<long long,HKSample * {__strong}>>::__vdeallocate(void **a1)
{
  id v1 = (id *)*a1;
  if (*a1)
  {
    uint64_t v3 = (id *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        unint64_t v5 = v3 - 2;

        uint64_t v3 = v5;
      }
      while (v5 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void *std::vector<std::tuple<long long,HKSample * {__strong}>>::__init_with_size[abi:ne180100]<std::tuple<long long,HKSample * {__strong}>*,std::tuple<long long,HKSample * {__strong}>*>(void *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<std::tuple<long long,HKSample * {__strong}>>::__vallocate[abi:ne180100](result, a4);
    return std::vector<std::tuple<long long,HKSample * {__strong}>>::__construct_at_end<std::tuple<long long,HKSample * {__strong}>*,std::tuple<long long,HKSample * {__strong}>*>(v6, a2, a3);
  }
  return result;
}

void sub_1BCC732CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void *std::vector<std::tuple<long long,HKSample * {__strong}>>::__construct_at_end<std::tuple<long long,HKSample * {__strong}>*,std::tuple<long long,HKSample * {__strong}>*>(void *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = result;
  uint64_t v4 = (void *)result[1];
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      uint64_t v7 = *v6;
      uint64_t v8 = (void *)v6[1];
      v6 += 2;
      void *v4 = v7;
      uint64_t result = v8;
      v4[1] = result;
      v4 += 2;
    }
    while (v6 != a3);
  }
  v3[1] = v4;
  return result;
}

void *std::vector<std::tuple<long long,HKDeletedObject * {__strong}>>::__init_with_size[abi:ne180100]<std::tuple<long long,HKDeletedObject * {__strong}>*,std::tuple<long long,HKDeletedObject * {__strong}>*>(void *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<std::tuple<long long,HKSample * {__strong}>>::__vallocate[abi:ne180100](result, a4);
    return std::vector<std::tuple<long long,HKSample * {__strong}>>::__construct_at_end<std::tuple<long long,HKSample * {__strong}>*,std::tuple<long long,HKSample * {__strong}>*>(v6, a2, a3);
  }
  return result;
}

void sub_1BCC733A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t HDCloudSyncCodableSharedSummaryParticipantRecordReadFrom(unsigned char *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = 0x1E9FB9000uLL;
    unint64_t v8 = 0x1E9FB9000uLL;
    unint64_t v9 = 0x1E9FB9000uLL;
    unint64_t v10 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v11 = 0;
      unsigned int v12 = 0;
      unint64_t v13 = 0;
      while (1)
      {
        uint64_t v14 = *v3;
        uint64_t v15 = *(void *)(a2 + v14);
        unint64_t v16 = v15 + 1;
        if (v15 == -1 || v16 > *(void *)(a2 + *v4)) {
          break;
        }
        char v17 = *(unsigned char *)(*(void *)(a2 + *v10) + v15);
        *(void *)(a2 + v14) = v16;
        v13 |= (unint64_t)(v17 & 0x7F) << v11;
        if ((v17 & 0x80) == 0) {
          goto LABEL_12;
        }
        v11 += 7;
        BOOL v18 = v12++ >= 9;
        if (v18)
        {
          unint64_t v13 = 0;
          int v19 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v19 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v13 = 0;
      }
LABEL_14:
      if (v19 || (v13 & 7) == 4) {
        break;
      }
      switch((v13 >> 3))
      {
        case 1u:
          uint64_t v21 = PBReaderReadString();
          uint64_t v22 = *(int *)(v7 + 3112);
          goto LABEL_70;
        case 2u:
          uint64_t v21 = PBReaderReadString();
          uint64_t v22 = *(int *)(v8 + 3116);
          goto LABEL_70;
        case 3u:
          uint64_t v21 = PBReaderReadString();
          uint64_t v22 = *(int *)(v9 + 3120);
          goto LABEL_70;
        case 4u:
          uint64_t v21 = PBReaderReadString();
          uint64_t v22 = 88;
          goto LABEL_70;
        case 5u:
          uint64_t v21 = PBReaderReadString();
          uint64_t v22 = 112;
          goto LABEL_70;
        case 0xAu:
          uint64_t v21 = PBReaderReadString();
          uint64_t v22 = 104;
          goto LABEL_70;
        case 0xBu:
          uint64_t v21 = PBReaderReadString();
          uint64_t v22 = 120;
          goto LABEL_70;
        case 0xCu:
          unint64_t v24 = v9;
          unint64_t v25 = v8;
          unint64_t v26 = v7;
          uint64_t v27 = PBReaderReadString();
          if (v27) {
            [a1 addAllContactIdentifiers:v27];
          }

          unint64_t v7 = v26;
          unint64_t v8 = v25;
          unint64_t v9 = v24;
          continue;
        case 0x14u:
          char v28 = 0;
          unsigned int v29 = 0;
          uint64_t v30 = 0;
          a1[152] |= 0x40u;
          while (2)
          {
            uint64_t v31 = *v3;
            uint64_t v32 = *(void *)(a2 + v31);
            unint64_t v33 = v32 + 1;
            if (v32 == -1 || v33 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v34 = *(unsigned char *)(*(void *)(a2 + *v10) + v32);
              *(void *)(a2 + v31) = v33;
              v30 |= (unint64_t)(v34 & 0x7F) << v28;
              if (v34 < 0)
              {
                v28 += 7;
                BOOL v18 = v29++ >= 9;
                if (v18)
                {
                  uint64_t v30 = 0;
                  goto LABEL_81;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v30 = 0;
          }
LABEL_81:
          uint64_t v67 = 56;
          goto LABEL_98;
        case 0x15u:
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v30 = 0;
          a1[152] |= 1u;
          while (2)
          {
            uint64_t v37 = *v3;
            uint64_t v38 = *(void *)(a2 + v37);
            unint64_t v39 = v38 + 1;
            if (v38 == -1 || v39 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v40 = *(unsigned char *)(*(void *)(a2 + *v10) + v38);
              *(void *)(a2 + v37) = v39;
              v30 |= (unint64_t)(v40 & 0x7F) << v35;
              if (v40 < 0)
              {
                v35 += 7;
                BOOL v18 = v36++ >= 9;
                if (v18)
                {
                  uint64_t v30 = 0;
                  goto LABEL_85;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v30 = 0;
          }
LABEL_85:
          uint64_t v67 = 8;
          goto LABEL_98;
        case 0x16u:
          char v41 = 0;
          unsigned int v42 = 0;
          uint64_t v30 = 0;
          a1[152] |= 0x20u;
          while (2)
          {
            uint64_t v43 = *v3;
            uint64_t v44 = *(void *)(a2 + v43);
            unint64_t v45 = v44 + 1;
            if (v44 == -1 || v45 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v46 = *(unsigned char *)(*(void *)(a2 + *v10) + v44);
              *(void *)(a2 + v43) = v45;
              v30 |= (unint64_t)(v46 & 0x7F) << v41;
              if (v46 < 0)
              {
                v41 += 7;
                BOOL v18 = v42++ >= 9;
                if (v18)
                {
                  uint64_t v30 = 0;
                  goto LABEL_89;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v30 = 0;
          }
LABEL_89:
          uint64_t v67 = 48;
          goto LABEL_98;
        case 0x17u:
          char v47 = 0;
          unsigned int v48 = 0;
          uint64_t v30 = 0;
          a1[152] |= 0x10u;
          while (2)
          {
            uint64_t v49 = *v3;
            uint64_t v50 = *(void *)(a2 + v49);
            unint64_t v51 = v50 + 1;
            if (v50 == -1 || v51 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v52 = *(unsigned char *)(*(void *)(a2 + *v10) + v50);
              *(void *)(a2 + v49) = v51;
              v30 |= (unint64_t)(v52 & 0x7F) << v47;
              if (v52 < 0)
              {
                v47 += 7;
                BOOL v18 = v48++ >= 9;
                if (v18)
                {
                  uint64_t v30 = 0;
                  goto LABEL_93;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v30 = 0;
          }
LABEL_93:
          uint64_t v67 = 40;
          goto LABEL_98;
        case 0x1Eu:
          a1[152] |= 8u;
          uint64_t v53 = *v3;
          unint64_t v54 = *(void *)(a2 + v53);
          if (v54 <= 0xFFFFFFFFFFFFFFF7 && v54 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v55 = *(void *)(*(void *)(a2 + *v10) + v54);
            *(void *)(a2 + v53) = v54 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v55 = 0;
          }
          uint64_t v68 = 32;
          goto LABEL_105;
        case 0x1Fu:
          a1[152] |= 4u;
          uint64_t v56 = *v3;
          unint64_t v57 = *(void *)(a2 + v56);
          if (v57 <= 0xFFFFFFFFFFFFFFF7 && v57 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v55 = *(void *)(*(void *)(a2 + *v10) + v57);
            *(void *)(a2 + v56) = v57 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v55 = 0;
          }
          uint64_t v68 = 24;
          goto LABEL_105;
        case 0x20u:
          a1[152] |= 2u;
          uint64_t v58 = *v3;
          unint64_t v59 = *(void *)(a2 + v58);
          if (v59 <= 0xFFFFFFFFFFFFFFF7 && v59 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v55 = *(void *)(*(void *)(a2 + *v10) + v59);
            *(void *)(a2 + v58) = v59 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v55 = 0;
          }
          uint64_t v68 = 16;
LABEL_105:
          *(void *)&a1[v68] = v55;
          continue;
        case 0x21u:
          uint64_t v21 = PBReaderReadData();
          uint64_t v22 = 128;
          goto LABEL_70;
        case 0x28u:
          uint64_t v21 = PBReaderReadData();
          uint64_t v22 = 136;
LABEL_70:
          long long v60 = *(void **)&a1[v22];
          *(void *)&a1[v22] = v21;

          continue;
        case 0x29u:
          char v61 = 0;
          unsigned int v62 = 0;
          uint64_t v30 = 0;
          a1[152] |= 0x80u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v63 = *v3;
        uint64_t v64 = *(void *)(a2 + v63);
        unint64_t v65 = v64 + 1;
        if (v64 == -1 || v65 > *(void *)(a2 + *v4)) {
          break;
        }
        char v66 = *(unsigned char *)(*(void *)(a2 + *v10) + v64);
        *(void *)(a2 + v63) = v65;
        v30 |= (unint64_t)(v66 & 0x7F) << v61;
        if ((v66 & 0x80) == 0) {
          goto LABEL_95;
        }
        v61 += 7;
        BOOL v18 = v62++ >= 9;
        if (v18)
        {
          uint64_t v30 = 0;
          goto LABEL_97;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_95:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v30 = 0;
      }
LABEL_97:
      uint64_t v67 = 64;
LABEL_98:
      *(void *)&a1[v67] = v30;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCC7A8AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableVisionSampleReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        BOOL v18 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 208), v18);
        if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v18, a2)) {
          goto LABEL_102;
        }
        goto LABEL_154;
      case 2u:
        char v19 = 0;
        unsigned int v20 = 0;
        uint64_t v21 = 0;
        *(_DWORD *)(a1 + 224) |= 0x800u;
        while (2)
        {
          uint64_t v22 = *v3;
          uint64_t v23 = *(void *)(a2 + v22);
          unint64_t v24 = v23 + 1;
          if (v23 == -1 || v24 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v25 = *(unsigned char *)(*(void *)(a2 + *v7) + v23);
            *(void *)(a2 + v22) = v24;
            v21 |= (unint64_t)(v25 & 0x7F) << v19;
            if (v25 < 0)
            {
              v19 += 7;
              BOOL v15 = v20++ >= 9;
              if (v15)
              {
                uint64_t v21 = 0;
                goto LABEL_106;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_106:
        *(void *)(a1 + 96) = v21;
        goto LABEL_152;
      case 3u:
        *(_DWORD *)(a1 + 224) |= 0x200u;
        uint64_t v26 = *v3;
        unint64_t v27 = *(void *)(a2 + v26);
        if (v27 <= 0xFFFFFFFFFFFFFFF7 && v27 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v27);
          *(void *)(a2 + v26) = v27 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 80;
        goto LABEL_151;
      case 4u:
        *(_DWORD *)(a1 + 224) |= 0x200000u;
        uint64_t v29 = *v3;
        unint64_t v30 = *(void *)(a2 + v29);
        if (v30 <= 0xFFFFFFFFFFFFFFF7 && v30 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v30);
          *(void *)(a2 + v29) = v30 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 176;
        goto LABEL_151;
      case 5u:
        *(_DWORD *)(a1 + 224) |= 0x10u;
        uint64_t v31 = *v3;
        unint64_t v32 = *(void *)(a2 + v31);
        if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v32);
          *(void *)(a2 + v31) = v32 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 40;
        goto LABEL_151;
      case 6u:
        *(_DWORD *)(a1 + 224) |= 0x10000u;
        uint64_t v33 = *v3;
        unint64_t v34 = *(void *)(a2 + v33);
        if (v34 <= 0xFFFFFFFFFFFFFFF7 && v34 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v34);
          *(void *)(a2 + v33) = v34 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 136;
        goto LABEL_151;
      case 7u:
        *(_DWORD *)(a1 + 224) |= 2u;
        uint64_t v35 = *v3;
        unint64_t v36 = *(void *)(a2 + v35);
        if (v36 <= 0xFFFFFFFFFFFFFFF7 && v36 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v36);
          *(void *)(a2 + v35) = v36 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 16;
        goto LABEL_151;
      case 8u:
        *(_DWORD *)(a1 + 224) |= 0x2000u;
        uint64_t v37 = *v3;
        unint64_t v38 = *(void *)(a2 + v37);
        if (v38 <= 0xFFFFFFFFFFFFFFF7 && v38 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v38);
          *(void *)(a2 + v37) = v38 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 112;
        goto LABEL_151;
      case 9u:
        *(_DWORD *)(a1 + 224) |= 1u;
        uint64_t v39 = *v3;
        unint64_t v40 = *(void *)(a2 + v39);
        if (v40 <= 0xFFFFFFFFFFFFFFF7 && v40 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v40);
          *(void *)(a2 + v39) = v40 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 8;
        goto LABEL_151;
      case 0xAu:
        *(_DWORD *)(a1 + 224) |= 0x1000u;
        uint64_t v41 = *v3;
        unint64_t v42 = *(void *)(a2 + v41);
        if (v42 <= 0xFFFFFFFFFFFFFFF7 && v42 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v42);
          *(void *)(a2 + v41) = v42 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 104;
        goto LABEL_151;
      case 0x1Eu:
        *(_DWORD *)(a1 + 224) |= 0x400u;
        uint64_t v44 = *v3;
        unint64_t v45 = *(void *)(a2 + v44);
        if (v45 <= 0xFFFFFFFFFFFFFFF7 && v45 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v45);
          *(void *)(a2 + v44) = v45 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 88;
        goto LABEL_151;
      case 0x1Fu:
        *(_DWORD *)(a1 + 224) |= 0x400000u;
        uint64_t v46 = *v3;
        unint64_t v47 = *(void *)(a2 + v46);
        if (v47 <= 0xFFFFFFFFFFFFFFF7 && v47 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v47);
          *(void *)(a2 + v46) = v47 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 184;
        goto LABEL_151;
      case 0x20u:
        *(_DWORD *)(a1 + 224) |= 0x80u;
        uint64_t v48 = *v3;
        unint64_t v49 = *(void *)(a2 + v48);
        if (v49 <= 0xFFFFFFFFFFFFFFF7 && v49 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v49);
          *(void *)(a2 + v48) = v49 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 64;
        goto LABEL_151;
      case 0x21u:
        *(_DWORD *)(a1 + 224) |= 0x80000u;
        uint64_t v50 = *v3;
        unint64_t v51 = *(void *)(a2 + v50);
        if (v51 <= 0xFFFFFFFFFFFFFFF7 && v51 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v51);
          *(void *)(a2 + v50) = v51 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 160;
        goto LABEL_151;
      case 0x22u:
        *(_DWORD *)(a1 + 224) |= 0x100u;
        uint64_t v52 = *v3;
        unint64_t v53 = *(void *)(a2 + v52);
        if (v53 <= 0xFFFFFFFFFFFFFFF7 && v53 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v53);
          *(void *)(a2 + v52) = v53 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 72;
        goto LABEL_151;
      case 0x23u:
        *(_DWORD *)(a1 + 224) |= 0x100000u;
        uint64_t v54 = *v3;
        unint64_t v55 = *(void *)(a2 + v54);
        if (v55 <= 0xFFFFFFFFFFFFFFF7 && v55 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v55);
          *(void *)(a2 + v54) = v55 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 168;
        goto LABEL_151;
      case 0x24u:
        *(_DWORD *)(a1 + 224) |= 0x20u;
        uint64_t v56 = *v3;
        unint64_t v57 = *(void *)(a2 + v56);
        if (v57 <= 0xFFFFFFFFFFFFFFF7 && v57 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v57);
          *(void *)(a2 + v56) = v57 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 48;
        goto LABEL_151;
      case 0x25u:
        *(_DWORD *)(a1 + 224) |= 0x20000u;
        uint64_t v58 = *v3;
        unint64_t v59 = *(void *)(a2 + v58);
        if (v59 <= 0xFFFFFFFFFFFFFFF7 && v59 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v59);
          *(void *)(a2 + v58) = v59 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 144;
        goto LABEL_151;
      case 0x26u:
        *(_DWORD *)(a1 + 224) |= 0x40u;
        uint64_t v60 = *v3;
        unint64_t v61 = *(void *)(a2 + v60);
        if (v61 <= 0xFFFFFFFFFFFFFFF7 && v61 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v61);
          *(void *)(a2 + v60) = v61 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 56;
        goto LABEL_151;
      case 0x27u:
        *(_DWORD *)(a1 + 224) |= 0x40000u;
        uint64_t v62 = *v3;
        unint64_t v63 = *(void *)(a2 + v62);
        if (v63 <= 0xFFFFFFFFFFFFFFF7 && v63 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v63);
          *(void *)(a2 + v62) = v63 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 152;
        goto LABEL_151;
      case 0x29u:
        uint64_t v64 = PBReaderReadString();
        uint64_t v65 = 200;
        goto LABEL_99;
      case 0x32u:
        *(_DWORD *)(a1 + 224) |= 4u;
        uint64_t v66 = *v3;
        unint64_t v67 = *(void *)(a2 + v66);
        if (v67 <= 0xFFFFFFFFFFFFFFF7 && v67 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v67);
          *(void *)(a2 + v66) = v67 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 24;
        goto LABEL_151;
      case 0x33u:
        *(_DWORD *)(a1 + 224) |= 0x4000u;
        uint64_t v68 = *v3;
        unint64_t v69 = *(void *)(a2 + v68);
        if (v69 <= 0xFFFFFFFFFFFFFFF7 && v69 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v69);
          *(void *)(a2 + v68) = v69 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 120;
        goto LABEL_151;
      case 0x34u:
        *(_DWORD *)(a1 + 224) |= 8u;
        uint64_t v70 = *v3;
        unint64_t v71 = *(void *)(a2 + v70);
        if (v71 <= 0xFFFFFFFFFFFFFFF7 && v71 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v71);
          *(void *)(a2 + v70) = v71 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 32;
        goto LABEL_151;
      case 0x35u:
        *(_DWORD *)(a1 + 224) |= 0x8000u;
        uint64_t v72 = *v3;
        unint64_t v73 = *(void *)(a2 + v72);
        if (v73 <= 0xFFFFFFFFFFFFFFF7 && v73 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v73);
          *(void *)(a2 + v72) = v73 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v75 = 128;
LABEL_151:
        *(void *)(a1 + v75) = v28;
        goto LABEL_152;
      case 0x36u:
        uint64_t v64 = PBReaderReadString();
        uint64_t v65 = 192;
LABEL_99:
        uint64_t v74 = *(void **)(a1 + v65);
        *(void *)(a1 + v65) = v64;

        goto LABEL_152;
      case 0x37u:
        BOOL v18 = objc_alloc_init(HDCodableVerifiableData);
        objc_storeStrong((id *)(a1 + 216), v18);
        if PBReaderPlaceMark() && (HDCodableVerifiableDataReadFrom((uint64_t)v18, a2))
        {
LABEL_102:
          PBReaderRecallMark();

LABEL_152:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_154:

        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_152;
    }
  }
}

void sub_1BCC7FB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCC806D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
}

void sub_1BCC81508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__30(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__30(uint64_t a1)
{
}

uint64_t HDCodableAuthorizationResponseMessageReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 8;
          goto LABEL_32;
        case 2u:
          uint64_t v17 = PBReaderReadData();
          uint64_t v18 = 32;
          goto LABEL_32;
        case 0xAu:
          char v20 = 0;
          unsigned int v21 = 0;
          uint64_t v22 = 0;
          *(unsigned char *)(a1 + 44) |= 1u;
          break;
        case 0xBu:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 24;
          goto LABEL_32;
        case 0xCu:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 16;
LABEL_32:
          uint64_t v26 = *(void **)(a1 + v18);
          *(void *)(a1 + v18) = v17;

          continue;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v23 = *v3;
        unint64_t v24 = *(void *)(a2 + v23);
        if (v24 == -1 || v24 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v25 = *(unsigned char *)(*(void *)(a2 + *v7) + v24);
        *(void *)(a2 + v23) = v24 + 1;
        v22 |= (unint64_t)(v25 & 0x7F) << v20;
        if ((v25 & 0x80) == 0) {
          goto LABEL_34;
        }
        v20 += 7;
        BOOL v14 = v21++ >= 9;
        if (v14)
        {
          uint64_t v22 = 0;
          goto LABEL_36;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_34:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v22 = 0;
      }
LABEL_36:
      *(unsigned char *)(a1 + 40) = v22 != 0;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCC843F4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1BCC85DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCC8945C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCC8B430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1BCC8BD9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1BCC8CF80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *location, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  objc_destroyWeak(v24);
  objc_destroyWeak(location);
  objc_destroyWeak(&a24);
  _Unwind_Resume(a1);
}

void sub_1BCC8E2B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a60, 8);
  _Block_object_dispose(&a66, 8);
  _Unwind_Resume(a1);
}

void sub_1BCC9003C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location)
{
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v10 - 184));
  _Unwind_Resume(a1);
}

id _StringFromSyncOptions(char a1)
{
  uint64_t v2 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v3 = v2;
  if (a1)
  {
    [v2 addObject:@"pull request"];
    if ((a1 & 2) == 0)
    {
LABEL_3:
      if ((a1 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((a1 & 2) == 0)
  {
    goto LABEL_3;
  }
  [v3 addObject:@"last chance"];
  if ((a1 & 4) == 0)
  {
LABEL_4:
    if ((a1 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_11:
  [v3 addObject:@"active only"];
  if ((a1 & 8) != 0) {
LABEL_5:
  }
    [v3 addObject:@"requested by remote"];
LABEL_6:
  uint64_t v4 = [v3 componentsJoinedByString:@", "];

  return v4;
}

void sub_1BCC90924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__31(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__31(uint64_t a1)
{
}

void sub_1BCC92B20(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 184), 8);
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

uint64_t HDAddStateHandler(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v9 = a3;
  id v4 = v8;
  id v5 = v9;
  uint64_t v6 = os_state_add_handler();

  return v6;
}

_DWORD *__HDAddStateHandler_block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  id v3 = *(id *)(a1 + 32);
  id v12 = 0;
  id v4 = [MEMORY[0x1E4F28F98] dataWithPropertyList:v2 format:200 options:0 error:&v12];
  id v5 = v12;
  if (v4)
  {
    unsigned int v6 = [v4 length];
    size_t v7 = v6 + 200;
    id v8 = malloc_type_malloc(v7, 0xBD14D538uLL);
    id v9 = v8;
    if (v8)
    {
      bzero(v8, v7);
      _DWORD *v9 = 1;
      v9[1] = v6;
      [v3 UTF8String];
      __strlcpy_chk();
      [v4 getBytes:v9 + 50 length:v6];
    }
  }
  else
  {
    _HKInitializeLogging();
    uint64_t v10 = HKLogInfrastructure();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138543362;
      id v14 = v5;
      _os_log_impl(&dword_1BCB7D000, v10, OS_LOG_TYPE_DEFAULT, "Error serializing dictionary into data for State Data: %{public}@", buf, 0xCu);
    }

    id v9 = 0;
  }

  return v9;
}

void sub_1BCC9944C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t __Block_byref_object_copy__32(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__32(uint64_t a1)
{
}

BOOL HDCloudSyncCodableMedicalIDReadFrom(id *a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    size_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = objc_alloc_init(HDCodableMedicalIDData);
        objc_storeStrong(a1 + 1, v17);
        if (!PBReaderPlaceMark() || !-[HDCodableMedicalIDData readFrom:](v17, "readFrom:", a2, 0, 0)) {
          goto LABEL_30;
        }
LABEL_25:
        PBReaderRecallMark();

        goto LABEL_27;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_27:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v17 = objc_alloc_init(HDCloudSyncCodableLog);
    [a1 addMedicalIDLogs:v17];
    if (!PBReaderPlaceMark() || (HDCloudSyncCodableLogReadFrom((uint64_t)v17, a2) & 1) == 0)
    {
LABEL_30:

      return 0;
    }
    goto LABEL_25;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCC9B7EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__33(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__33(uint64_t a1)
{
}

void sub_1BCC9C35C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1BCC9D0E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDWorkoutActivityEntityPredicateForActivityType(uint64_t a1)
{
  uint64_t v1 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v2 = [NSNumber numberWithUnsignedInteger:a1];
  id v3 = [v1 predicateWithProperty:@"activity_type" value:v2 comparisonType:1];

  return v3;
}

id HDWorkoutActivityEntityPredicateForDuration(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = objc_msgSend(NSNumber, "numberWithDouble:");
  id v4 = [v2 predicateWithProperty:@"duration" value:v3 comparisonType:a1];

  return v4;
}

id HDWorkoutActivityEntityPredicateForStartDate(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = _HDSQLiteValueForDate();
  id v4 = [v2 predicateWithProperty:@"start_date" value:v3 comparisonType:a1];

  return v4;
}

id HDWorkoutActivityEntityPredicateForEndDate(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = _HDSQLiteValueForDate();
  id v4 = [v2 predicateWithProperty:@"end_date" value:v3 comparisonType:a1];

  return v4;
}

void sub_1BCC9F090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCA1278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__34(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__34(uint64_t a1)
{
}

void sub_1BCCA1A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCA1C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__35(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__35(uint64_t a1)
{
}

void sub_1BCCA2BA8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCA36EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_1BCCA3A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCA51F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCA6CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
}

uint64_t __Block_byref_object_copy__36(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__36(uint64_t a1)
{
}

id QuantityCharacteristicTypes()
{
  v5[3] = *MEMORY[0x1E4F143B8];
  unint64_t v0 = [MEMORY[0x1E4F2B2C0] characteristicTypeForIdentifier:*MEMORY[0x1E4F2B9F8]];
  uint64_t v1 = objc_msgSend(MEMORY[0x1E4F2B2C0], "characteristicTypeForIdentifier:", *MEMORY[0x1E4F2BA10], v0);
  v5[1] = v1;
  uint64_t v2 = [MEMORY[0x1E4F2B2C0] characteristicTypeForIdentifier:*MEMORY[0x1E4F2BA08]];
  v5[2] = v2;
  id v3 = [MEMORY[0x1E4F1C978] arrayWithObjects:v5 count:3];

  return v3;
}

void sub_1BCCACE74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_1BCCADBB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__37(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__37(uint64_t a1)
{
}

void sub_1BCCAEBEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id location,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,id a38)
{
  objc_destroyWeak(v38);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

BOOL HDCodableStartWorkoutAppRequestReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      if (v9++ >= 9)
      {
        unint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = 16;
        goto LABEL_27;
      case 2u:
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = 8;
        goto LABEL_27;
      case 3u:
        char v19 = objc_alloc_init(HDCodableWorkoutConfiguration);
        objc_storeStrong((id *)(a1 + 24), v19);
        if PBReaderPlaceMark() && (HDCodableWorkoutConfigurationReadFrom((uint64_t)v19, a2))
        {
          PBReaderRecallMark();
LABEL_28:

LABEL_29:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }

        return 0;
      case 4u:
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 32;
LABEL_27:
        char v19 = *(HDCodableWorkoutConfiguration **)(a1 + v18);
        *(void *)(a1 + v1_Block_object_dispose(&a9, 8) = v17;
        goto LABEL_28;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0) {
          return 0;
        }
        goto LABEL_29;
    }
  }
}

id HDAlarmEventEntityAllProperties()
{
  v2[6] = *MEMORY[0x1E4F143B8];
  v2[0] = @"client_identifier";
  v2[1] = @"event_identifier";
  v2[2] = @"due_date";
  v2[3] = @"due_date_components";
  void v2[4] = @"event_options";
  v2[5] = @"client_options";
  unint64_t v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v2 count:6];

  return v0;
}

void sub_1BCCB2604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__38(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__38(uint64_t a1)
{
}

void sub_1BCCB7A28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCCB8B8C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__39(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__39(uint64_t a1)
{
}

void sub_1BCCB8E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCB9160(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCB9754(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 192), 8);
  _Unwind_Resume(a1);
}

id HDAuthorizationIdentifiersFromCodableSharingAuthorizations(void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    id v2 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    long long v10 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    id v3 = v1;
    uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(void *)v11;
      do
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          if (*(void *)v11 != v6) {
            objc_enumerationMutation(v3);
          }
          char v8 = objc_msgSend(*(id *)(*((void *)&v10 + 1) + 8 * i), "authorizationIdentifier", (void)v10);
          [v2 addObject:v8];
        }
        uint64_t v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
      }
      while (v5);
    }
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

id HDSharingAuthorizationsFromCodableSharingAuthorizations(void *a1)
{
  if (a1)
  {
    a1 = objc_msgSend(a1, "hk_map:", &__block_literal_global_47);
    uint64_t v1 = vars8;
  }
  return a1;
}

id __HDSharingAuthorizationsFromCodableSharingAuthorizations_block_invoke(uint64_t a1, void *a2)
{
  id v2 = (objc_class *)MEMORY[0x1E4F2B4D8];
  id v3 = a2;
  id v4 = [v2 alloc];
  uint64_t v5 = [v3 authorizationIdentifier];
  uint64_t v6 = [v3 displayName];
  uint64_t v7 = [v3 displaySubtitle];

  char v8 = (void *)[v4 initWithAuthorizationIdentifier:v5 displayName:v6 displaySubtitle:v7];

  return v8;
}

id HDCodableSharingAuthorizationsFromSharingAuthorizations(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    id v2 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    id v3 = v1;
    uint64_t v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(void *)v13;
      do
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          if (*(void *)v13 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void *)(*((void *)&v12 + 1) + 8 * i);
          unsigned int v9 = [HDCodableSharingAuthorization alloc];
          long long v10 = -[HDCodableSharingAuthorization initWithSharingAuthorization:](v9, "initWithSharingAuthorization:", v8, (void)v12);
          [v2 addObject:v10];
        }
        uint64_t v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }
      while (v5);
    }
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

id HDCodableSharingAuthorizationsFromAuthorizationIdentifiers(void *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    id v2 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    long long v11 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    id v3 = v1;
    uint64_t v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(void *)v12;
      do
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          if (*(void *)v12 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void *)(*((void *)&v11 + 1) + 8 * i);
          unsigned int v9 = objc_alloc_init(HDCodableSharingAuthorization);
          -[HDCodableSharingAuthorization setAuthorizationIdentifier:](v9, "setAuthorizationIdentifier:", v8, (void)v11);
          [v2 addObject:v9];
        }
        uint64_t v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }
      while (v5);
    }
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

uint64_t HDCPSDefaultEnvironment()
{
  return [MEMORY[0x1E4F2B860] isAppleInternalInstall];
}

__CFString *HDCPSNameForEnvironment(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 0xD) {
    return @"Production";
  }
  else {
    return off_1E62F8E08[a1 - 1];
  }
}

id HDHealthDaemonFrameworkBundle()
{
  unint64_t v0 = (void *)HDHealthDaemonFrameworkBundle___ClassBundle;
  if (!HDHealthDaemonFrameworkBundle___ClassBundle)
  {
    uint64_t v1 = [MEMORY[0x1E4F28B50] bundleForClass:objc_opt_class()];
    id v2 = (void *)HDHealthDaemonFrameworkBundle___ClassBundle;
    HDHealthDaemonFrameworkBundle___ClassBundle = v1;

    unint64_t v0 = (void *)HDHealthDaemonFrameworkBundle___ClassBundle;
  }

  return v0;
}

__CFString *HDStringFromDatabaseJournalType(unint64_t a1)
{
  if (a1 >= 3)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%ld)", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E62F8E78[a1];
  }

  return v1;
}

void sub_1BCCBB038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCBC438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__40(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__40(uint64_t a1)
{
}

void sub_1BCCBD614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCBDC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__41(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__41(uint64_t a1)
{
}

void sub_1BCCBF200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__42(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__42(uint64_t a1)
{
}

uint64_t HDCloudSyncCodableAttachmentManagementReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = *(void **)(a1 + 8);
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = v17;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

BOOL HDCodableSourceAuthorizationReadFrom(id *a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      if (v9++ >= 9)
      {
        unint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 4;
        goto LABEL_26;
      case 2u:
        char v19 = objc_alloc_init(HDCodableAuthorization);
        [a1 addAuthorizations:v19];
        if (!PBReaderPlaceMark() || (HDCodableAuthorizationReadFrom((uint64_t)v19, a2) & 1) == 0) {
          goto LABEL_34;
        }
        goto LABEL_29;
      case 3u:
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 2;
LABEL_26:
        char v19 = (HDCodableAuthorization *)a1[v18];
        a1[v18] = (id)v17;
        goto LABEL_30;
      case 4u:
        char v19 = objc_alloc_init(HDCodableSource);
        objc_storeStrong(a1 + 3, v19);
        if PBReaderPlaceMark() && (HDCodableSourceReadFrom((uint64_t)v19, a2))
        {
LABEL_29:
          PBReaderRecallMark();
LABEL_30:

LABEL_31:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_34:

        return 0;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0) {
          return 0;
        }
        goto LABEL_31;
    }
  }
}

uint64_t HDSharingTypeFromCodableType(int a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  if (a1 == 1) {
    return 1;
  }
  _HKInitializeLogging();
  id v3 = *MEMORY[0x1E4F29FA8];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_FAULT))
  {
    int v4 = 134217984;
    uint64_t v5 = a1;
    _os_log_fault_impl(&dword_1BCB7D000, v3, OS_LOG_TYPE_FAULT, "Unexpected codable type %ld", (uint8_t *)&v4, 0xCu);
  }
  return 0;
}

uint64_t HDSharingMessageDirectionFromCodableDirection(int a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a1 == 1) {
    return 1;
  }
  if (!a1) {
    return 0;
  }
  _HKInitializeLogging();
  id v3 = *MEMORY[0x1E4F29FA8];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_FAULT))
  {
    int v4 = 134217984;
    uint64_t v5 = a1;
    _os_log_fault_impl(&dword_1BCB7D000, v3, OS_LOG_TYPE_FAULT, "Unexpected codable direction %ld", (uint8_t *)&v4, 0xCu);
  }
  return 1;
}

uint64_t HDSharingStatusFromCodableStatus(uint64_t result)
{
  int v1 = result;
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (result < 5) {
    return result;
  }
  _HKInitializeLogging();
  id v2 = *MEMORY[0x1E4F29FA8];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_FAULT))
  {
    int v3 = 134217984;
    uint64_t v4 = v1;
    _os_log_fault_impl(&dword_1BCB7D000, v2, OS_LOG_TYPE_FAULT, "Unexpected codable status %ld", (uint8_t *)&v3, 0xCu);
  }
  return 0;
}

unint64_t HDCodableSharingStatusFromStatus(unint64_t a1)
{
  unint64_t v1 = a1;
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a1 >= 5)
  {
    _HKInitializeLogging();
    id v2 = *MEMORY[0x1E4F29FA8];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_FAULT))
    {
      int v4 = 134217984;
      unint64_t v5 = v1;
      _os_log_fault_impl(&dword_1BCB7D000, v2, OS_LOG_TYPE_FAULT, "Unexpected status %ld", (uint8_t *)&v4, 0xCu);
    }
    return 0;
  }
  return v1;
}

uint64_t HDSharingNotificationStatusFromCodableStatus(uint64_t result)
{
  int v1 = result;
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (result < 3) {
    return result;
  }
  _HKInitializeLogging();
  id v2 = *MEMORY[0x1E4F29FA8];
  if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_FAULT))
  {
    int v3 = 134217984;
    uint64_t v4 = v1;
    _os_log_fault_impl(&dword_1BCB7D000, v2, OS_LOG_TYPE_FAULT, "Unexpected codable notification status %ld", (uint8_t *)&v3, 0xCu);
  }
  return 0;
}

unint64_t HDCodableSharingNotificationStatusFromStatus(unint64_t a1)
{
  unint64_t v1 = a1;
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a1 >= 3)
  {
    _HKInitializeLogging();
    id v2 = *MEMORY[0x1E4F29FA8];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_FAULT))
    {
      int v4 = 134217984;
      unint64_t v5 = v1;
      _os_log_fault_impl(&dword_1BCB7D000, v2, OS_LOG_TYPE_FAULT, "Unexpected notification status %ld", (uint8_t *)&v4, 0xCu);
    }
    return 0;
  }
  return v1;
}

void sub_1BCCC5BC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDOntologyShardRegistryPredicateForEntry(uint64_t a1, void *a2, uint64_t a3)
{
  v16[3] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = (void *)MEMORY[0x1E4F65D08];
  uint64_t v6 = (void *)MEMORY[0x1E4F65D00];
  id v7 = a2;
  char v8 = [v6 predicateWithProperty:@"identifier" equalToValue:a1];
  unsigned int v9 = objc_msgSend(MEMORY[0x1E4F65D00], "predicateWithProperty:equalToValue:", @"schema_type", v7, v8);

  v16[1] = v9;
  unint64_t v10 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v11 = [NSNumber numberWithInteger:a3];
  unint64_t v12 = [v10 predicateWithProperty:@"schema_version" equalToValue:v11];
  void v16[2] = v12;
  char v13 = [MEMORY[0x1E4F1C978] arrayWithObjects:v16 count:3];
  long long v14 = [v5 predicateMatchingAllPredicates:v13];

  return v14;
}

uint64_t __Block_byref_object_copy__43(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__43(uint64_t a1)
{
}

void sub_1BCCC6614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCC6A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCC796C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCC7CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCC82F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

id HDOntologyShardRegistryPredicateForCurrentSchemaEntry(void *a1)
{
  id v1 = a1;
  id v2 = HKOntologyShardSchemaTypeForShardIdentifier();
  uint64_t v3 = HKCurrentSchemaVersionForShardIdentifier();
  int v4 = HDOntologyShardRegistryPredicateForEntry((uint64_t)v1, v2, v3);

  return v4;
}

uint64_t HDCloudSyncCodableStateReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  int v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    id v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = *(void **)(a1 + 8);
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = v17;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCCC9BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCCCA1B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__44(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__44(uint64_t a1)
{
}

void sub_1BCCCD288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  _Block_object_dispose((const void *)(v48 - 176), 8);
  _Block_object_dispose(&a48, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCCD61C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCCE6D0(_Unwind_Exception *a1)
{
  unint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1BCCCE77C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCCCE8B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCCCE96C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double std::normal_distribution<double>::operator()<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(uint64_t a1, unsigned int *a2, double *a3)
{
  if (*(unsigned char *)(a1 + 24))
  {
    *(unsigned char *)(a1 + 24) = 0;
    double v5 = *(double *)(a1 + 16);
  }
  else
  {
    do
    {
      do
      {
        double v7 = std::generate_canonical[abi:ne180100]<double,53ul,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(a2)
           * 2.0
           + -1.0;
        double v8 = std::generate_canonical[abi:ne180100]<double,53ul,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(a2)
           * 2.0
           + -1.0;
        double v9 = v8 * v8 + v7 * v7;
      }
      while (v9 > 1.0);
    }
    while (v9 == 0.0);
    double v10 = sqrt(log(v8 * v8 + v7 * v7) * -2.0 / v9);
    *(double *)(a1 + 16) = v8 * v10;
    *(unsigned char *)(a1 + 24) = 1;
    double v5 = v7 * v10;
  }
  return *a3 + v5 * a3[1];
}

double std::generate_canonical[abi:ne180100]<double,53ul,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(unsigned int *a1)
{
  unsigned int v1 = 48271 * (*a1 % 0xADC8);
  unsigned int v2 = 3399 * (*a1 / 0xADC8);
  BOOL v3 = v1 >= v2;
  unsigned int v4 = v1 - v2;
  if (v3) {
    int v5 = 0;
  }
  else {
    int v5 = 0x7FFFFFFF;
  }
  unsigned int v6 = v5 + v4;
  unsigned int v7 = v6 - 1;
  unsigned int v8 = v6 / 0xADC8;
  unsigned int v9 = 48271 * (v6 % 0xADC8);
  v8 *= 3399;
  BOOL v3 = v9 >= v8;
  unsigned int v10 = v9 - v8;
  if (v3) {
    int v11 = 0;
  }
  else {
    int v11 = 0x7FFFFFFF;
  }
  unsigned int v12 = v11 + v10;
  *a1 = v12;
  return ((double)v7 + (double)(v12 - 1) * 2147483650.0) / 4.61168601e18;
}

void sub_1BCCCFADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__45(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__45(uint64_t a1)
{
}

void sub_1BCCCFE0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCCFFA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id _HDSourceEntityPredicateForNotDeletedWithPredicate(void *a1)
{
  unsigned int v1 = (void *)MEMORY[0x1E4F65D00];
  id v2 = a1;
  BOOL v3 = [v1 predicateWithProperty:@"deleted" notEqualToValue:MEMORY[0x1E4F1CC38]];
  unsigned int v4 = [MEMORY[0x1E4F65D58] compoundPredicateWithPredicate:v2 otherPredicate:v3];

  return v4;
}

void sub_1BCCD06E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD09E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD0F10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD126C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD2014(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD2588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD2A3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDSourceEntityPredicateForLocalSourcesWithBundleIdentifier(uint64_t a1)
{
  uint64_t v1 = (void *)MEMORY[0x1E4F65D58];
  id v2 = HDSourceEntityPredicateForSourceWithBundleIdentifier(a1);
  BOOL v3 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"provenance" equalToValue:&unk_1F17EB430];
  unsigned int v4 = [v1 compoundPredicateWithPredicate:v2 otherPredicate:v3];

  return v4;
}

id HDSourceEntityPredicateForSourceWithBundleIdentifier(uint64_t a1)
{
  uint64_t v1 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"logical_sources.bundle_id" equalToValue:a1];
  id v2 = _HDSourceEntityPredicateForNotDeletedWithPredicate(v1);

  return v2;
}

id HDSourceEntityPredicateForSourcesWithUUIDs(void *a1)
{
  uint64_t v1 = objc_msgSend(a1, "hk_map:", &__block_literal_global_588);
  id v2 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"uuid" values:v1];

  return v2;
}

uint64_t __HDSourceEntityPredicateForSourcesWithUUIDs_block_invoke()
{
  return _HDSQLiteValueForUUID();
}

uint64_t HDSourceEntityPredicateForSourcesWithBundleIdentifiers(uint64_t a1)
{
  return [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"logical_sources.bundle_id" values:a1];
}

uint64_t HDSourceEntityPredicateForSourcesWithOwnerBundleIdentifiers(uint64_t a1)
{
  return [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"logical_sources.owner_bundle_id" values:a1];
}

id HDSourceEntityPredicateForLocalSourcesWithLogicalSourceIDs(uint64_t a1)
{
  uint64_t v1 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"logical_source_id" values:a1];
  id v2 = (void *)MEMORY[0x1E4F65D58];
  BOOL v3 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"provenance" equalToValue:&unk_1F17EB430];
  unsigned int v4 = [v2 compoundPredicateWithPredicate:v1 otherPredicate:v3];

  return v4;
}

uint64_t HDSourceEntityPredicateForSourcesWithLogicalSourceIDs(uint64_t a1)
{
  return [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"logical_source_id" values:a1];
}

void sub_1BCCD6068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  _Block_object_dispose(&a63, 8);
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&a57, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__46(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__46(uint64_t a1)
{
}

void sub_1BCCD7900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v37 - 224), 8);
  _Block_object_dispose((const void *)(v37 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD7DA8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD83EC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD8FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD9570(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCD9DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCDAA44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCDAE04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCDB40C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

HDAssociationEntityParentIDPredicate *HDAssociationEntityPredicateForChildObjectsAssociatedWithParentObject(uint64_t a1)
{
  return +[HDAssociationEntityParentIDPredicate predicateWithParentID:a1];
}

HDAssociationEntityParentIDExistsPredicate *HDAssociationEntityPredicateForChildObjectsWhereAssocationExistsWithParentObject(uint64_t a1, uint64_t a2)
{
  return +[HDAssociationEntityParentIDExistsPredicate predicateWithParentID:a1 exists:a2];
}

HDAssociationEntityIsAssociatedPredicate *HDAssociationEntityPredicateForAssociatedObjects(uint64_t a1)
{
  return +[HDAssociationEntityIsAssociatedPredicate predicateWithInvertedCondition:a1];
}

uint64_t HDAssociationEntityPredicateForChildEndDate(uint64_t a1, uint64_t a2)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"child_id_samples.end_date" value:a2 comparisonType:a1];
}

id HDAssociationEntityPredicateForAssociationEntityWithType(uint64_t a1)
{
  uint64_t v1 = (void *)MEMORY[0x1E4F65D00];
  id v2 = [NSNumber numberWithUnsignedInteger:a1];
  BOOL v3 = [v1 predicateWithProperty:@"type" equalToValue:v2];

  return v3;
}

id HDAssociationEntityPredicateForAssociationEntityForNotType(uint64_t a1)
{
  uint64_t v1 = (void *)MEMORY[0x1E4F65D00];
  id v2 = [NSNumber numberWithUnsignedInteger:a1];
  BOOL v3 = [v1 predicateWithProperty:@"type" notEqualToValue:v2];

  return v3;
}

HDAssociationEntityParentIDForTypePredicate *HDAssociationEntityPredicateForChildObjectsAssociatedWithParentObjectForType(uint64_t a1, uint64_t a2)
{
  return +[HDAssociationEntityParentIDForTypePredicate predicateWithParentID:a1 type:a2];
}

uint64_t *HDStatisticsTimeInterval::addSample(uint64_t *this, const HDRawQuantitySample *a2, int a3)
{
  if (a2->var4 && !a2->var5)
  {
    if (a3) {
      ++*this;
    }
    unsigned int v4 = this + 1;
    double var1 = a2->var1;
    double var2 = a2->var2;
    if (var2 >= var1) {
      double v7 = a2->var1;
    }
    else {
      double v7 = a2->var2;
    }
    if (var1 < var2) {
      double var1 = a2->var2;
    }
    return HKIntervalMask<double>::_insertInterval(v4, v7, var1);
  }
  return this;
}

double HDStatisticsTimeInterval::totalDuration(HDStatisticsTimeInterval *this)
{
  uint64_t v1 = (double *)*((void *)this + 1);
  double v2 = 0.0;
  while (v1 != *((double **)this + 2))
  {
    double v4 = *v1;
    double v3 = v1[1];
    v1 += 2;
    double v2 = v2 + v3 - v4;
  }
  return v2 + *((double *)this + 4);
}

double HDStatisticsTimeInterval::didMergeTo(double **this, double a2)
{
  double result = HKIntervalMask<double>::removeIntervalsBefore(this + 1, a2) + *((double *)this + 4);
  *((double *)this + 4) = result;
  return result;
}

double HKIntervalMask<double>::removeIntervalsBefore(double **a1, double a2)
{
  double v3 = *a1;
  double v2 = a1[1];
  if (*a1 == v2) {
    return 0.0;
  }
  double v5 = 0.0;
  unsigned int v6 = *a1;
  while (1)
  {
    double v7 = *v6;
    if (*v6 >= a2) {
      break;
    }
    double v8 = v6[1];
    if (v8 >= a2)
    {
      double v5 = v5 + a2 - v7;
      *unsigned int v6 = a2;
      break;
    }
    double v5 = v5 + v8 - v7;
    v6 += 2;
    if (v6 == v2)
    {
      unsigned int v6 = a1[1];
      break;
    }
  }
  if (v3 != v6)
  {
    int64_t v9 = (char *)v2 - (char *)v6;
    if (v2 != v6) {
      memmove(v3, v6, (char *)v2 - (char *)v6);
    }
    a1[1] = (double *)((char *)v3 + v9);
  }
  return v5;
}

double HDStatisticsTimeInterval::unarchive@<D0>(HDStatisticsTimeInterval *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + _Block_object_dispose(&a9, 8) = 0u;
  double v5 = (uint64_t *)(a2 + 8);
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = *((void *)this + 3);
  uint64_t v6 = *((void *)this + 8);
  uint64_t v7 = *((void *)this + 9);
  while (v6 != v7)
  {
    double v9 = *(double *)(*(void *)v6 + 8);
    double v8 = *(double *)(*(void *)v6 + 16);
    if (v9 >= v8) {
      double v10 = *(double *)(*(void *)v6 + 16);
    }
    else {
      double v10 = *(double *)(*(void *)v6 + 8);
    }
    if (v8 < v9) {
      double v8 = *(double *)(*(void *)v6 + 8);
    }
    HKIntervalMask<double>::_insertInterval(v5, v10, v8);
    v6 += 8;
  }
  double result = *((double *)this + 7);
  *(double *)(a2 + 32) = result;
  return result;
}

void sub_1BCCDC0FC(_Unwind_Exception *exception_object)
{
  double v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

double HDStatisticsTimeInterval::archive@<D0>(HDStatisticsTimeInterval *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)this;
  double v4 = (int8x16_t *)*((void *)this + 1);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = v3;
  *(_DWORD *)(a2 + 204) = 17;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 160) = 0;
  *(void *)a2 = &unk_1F171B978;
  *(void *)(a2 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 12_Block_object_dispose(&a9, 8) = 0;
  *(void *)(a2 + 112) = 0;
  double result = *((double *)this + 4);
  *(double *)(a2 + 56) = result;
  if (v4 != *((int8x16_t **)this + 2))
  {
    uint64_t v6 = &unk_1F1727540;
    int v8 = 3;
    int8x16_t v7 = vextq_s8(*v4, *v4, 8uLL);
    PB::PtrVector<statistics::Interval>::emplace_back<statistics::Interval&>();
  }
  return result;
}

void sub_1BCCDC200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PB::Base::~Base((PB::Base *)&a9);
  statistics::Statistics::~Statistics(v9);
  _Unwind_Resume(a1);
}

void PB::PtrVector<statistics::Interval>::emplace_back<statistics::Interval&>()
{
}

void sub_1BCCDC320(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<statistics::Interval>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void sub_1BCCDD61C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__47(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__47(uint64_t a1)
{
}

void sub_1BCCDDA1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCCDE140()
{
}

void sub_1BCCDE14C()
{
}

void sub_1BCCDE158()
{
}

void sub_1BCCDE164(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c92_ZTSKZ79__HDQuantitySeriesHFDMigrationEntity_migrateDataToSQLFromStore_database_error__E3__0(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[3].n128_u64[0] = a2[3].n128_u64[0];
  a1[2] = result;
  return result;
}

void sub_1BCCDE3F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCCDE9C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
}

__n128 __copy_helper_block_ea8_32c112_ZTSKZ99__HDQuantitySeriesHFDMigrationEntity_migrateDataFromDataStore_to_database_recoveryAnalytics_error__E3__1(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 32);
  long long v3 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&a9, 8) = v3;
  return result;
}

uint64_t health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v8 = 0;
  uint64_t v6 = operator new(0x20uLL);
  *uint64_t v6 = &unk_1F171CE00;
  v6[1] = a2;
  void v6[2] = a3;
  uint64_t v6[3] = &v8;
  v9[3] = v6;
  health::DataStore::performReadTransactionWithLambda(a1, (uint64_t)v9);
  std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100](v9);
  return v8;
}

void sub_1BCCDEC38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::~__func()
{
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1)
{
  double v2 = (char *)operator new(0x20uLL);
  *(void *)double v2 = &unk_1F171CE00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171CE00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(a1 + 8, a2);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target_type()
{
}

uint64_t std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(uint64_t a1, uint64_t a2)
{
  memset(&v5[16], 0, 32);
  memset(&v5[56], 0, 32);
  uint64_t v6 = a2;
  uint64_t result = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)a1);
  if (result)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 24);
    if (!v4) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v4 + 48))(v4, v5);
    **(unsigned char **)(a1 + 16) = 1;
  }
  return result;
}

BOOL health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot(uint64_t a1, ObjectIdentifier *a2)
{
  health::DataStore::ReadTransaction::_pointerForObject(*(health::DataStore::ReadTransaction **)(a1 + 88), a2, (uint64_t)v8);
  int v4 = v9;
  if (v9)
  {
    double v5 = *(uint64_t **)(*(void *)(a1 + 88) + 24);
    uint64_t v6 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v8);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v5, *v6, v6[1], (void *)a1);
    *(ObjectIdentifier *)(a1 + 72) = *a2;
    *(_OWORD *)(a1 + 56) = *(_OWORD *)health::Optional<health::BlockPointer>::get((uint64_t)v8);
  }
  return v4 != 0;
}

void _ZNSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE7__cloneEv(uint64_t a1)
{
  double v2 = (char *)operator new(0x30uLL);
  *(void *)double v2 = &unk_1F171CE80;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE7__cloneEPNS0_6__baseISY_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171CE80;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEEclESX_(uint64_t a1, uint64_t a2)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3321888768;
  v5[2] = ___ZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO__block_invoke;
  v5[3] = &__block_descriptor_72_ea8_32c280_ZTSKZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_EUlSL_E__e9_B16__0__8l;
  uint64_t v2 = *(void *)(a1 + 8);
  long long v6 = *(_OWORD *)(a1 + 16);
  uint64_t v7 = v2;
  uint64_t v8 = a2;
  long long v3 = *(id **)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 32);
  if (v3)
  {
    obunint64_t j = *v3;
    hfd_catchExceptionsAsErrors(v5, (uint64_t)&obj, 0);
    objc_storeStrong(v3, obj);
  }
  else
  {
    hfd_catchExceptionsAsErrors(v5, 0, 0);
  }
}

uint64_t _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSB_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE11target_typeEv()
{
  return &_ZTIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSB_E_;
}

BOOL ___ZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO__block_invoke(void *a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  char v18 = 0;
  id v17 = 0;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v7 = a1[6];
  uint64_t v6 = a1[7];
  uint64_t v8 = operator new(0x28uLL);
  void *v8 = &unk_1F171CFB0;
  v8[1] = v7;
  v8[2] = &v17;
  void v8[3] = &v18;
  v8[4] = v6;
  void v20[3] = v8;
  char v19 = 1;
  uint64_t v9 = operator new(0x20uLL);
  void *v9 = &unk_1F171CF30;
  v9[1] = v5;
  void v9[2] = &v19;
  v9[3] = v20;
  uint64_t v22 = v9;
  health::DataStore::performWriteTransactionWithLambda(v4, (uint64_t)v21);
  std::__function::__value_func<BOOL ()(health::DataStore::WriteTransaction &)>::~__value_func[abi:ne180100](v21);
  std::__function::__value_func<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>::~__value_func[abi:ne180100](v20);
  id v10 = v17;
  if (v17)
  {
    id v11 = v17;
    uint64_t v12 = v11;
    if (a2) {
      *a2 = v11;
    }
    else {
      _HKLogDroppedError();
    }
  }
  else
  {
    if (v18) {
      goto LABEL_7;
    }
    uint64_t v13 = *(void *)(a1[8] + 24);
    if (!v13) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13) & 1) == 0)
    {
LABEL_7:
      uint64_t v14 = a1[4];
      uint64_t v15 = a1[5];
      v21[0] = &unk_1F171D0D0;
      v21[1] = v15;
      uint64_t v22 = v21;
      health::DataStore::performWriteTransactionWithLambda(v14, (uint64_t)v21);
      std::__function::__value_func<BOOL ()(health::DataStore::WriteTransaction &)>::~__value_func[abi:ne180100](v21);
    }
  }

  return v10 == 0;
}

void sub_1BCCDF1E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c280_ZTSKZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_EUlSL_E_(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 32);
  long long v3 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&a9, 8) = v3;
  return result;
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::~__func()
{
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F171CF30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171CF30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::operator()(uint64_t a1, uint64_t a2)
{
  long long v8 = 0u;
  long long v7 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v11 = a2;
  uint64_t v12 = a2;
  double HistoryRoot = health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot((uint64_t)v6, *(ObjectIdentifier **)(a1 + 8), **(unsigned __int8 **)(a1 + 16));
  uint64_t v4 = *(void *)(*(void *)(a1 + 24) + 24);
  if (!v4) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, unsigned char *, double))(*(void *)v4 + 48))(v4, v6, HistoryRoot);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target_type()
{
}

double health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot(uint64_t a1, ObjectIdentifier *a2, int a3)
{
  *(ObjectIdentifier *)(a1 + 72) = *a2;
  uint64_t v5 = *(health::DataStore::ReadTransaction **)(a1 + 96);
  health::DataStore::ReadTransaction::_pointerForObject(v5, a2, (uint64_t)v10);
  if (v10[16])
  {
    uint64_t v6 = (uint64_t *)*((void *)v5 + 3);
    long long v7 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v10);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v6, *v7, v7[1], (void *)a1);
  }
  else
  {
    if (!a3)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      _ZN6health15not_found_errorCI1St13runtime_errorEPKc(exception, "The requested sample history does not exist.");
    }
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    *(void *)&double result = health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::_updateHistoryRoot(a1).n128_u64[0];
  }
  return result;
}

void sub_1BCCDF4A4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::_updateHistoryRoot(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (*(void *)(a1 + 64) != 56)
  {
    long long v17 = *(_OWORD *)(v2 + 32);
    uint64_t v18 = v2 + 48;
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v17, (void *)(a1 + 72), 0, v15);
    if (v16)
    {
      uint64_t v5 = *(void *)(health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v15)
                     + 24);
      uint64_t v6 = (health::BlockAccessFile::WriteTransaction *)(v2 + 80);
      uint64_t v7 = health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v15);
      unint64_t v8 = *(void *)(v7 + 16);
      unint64_t v9 = *(void *)(v7 + 24);
      if (v5 == 56)
      {
        health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::SampleHistoryRoot>((uint64_t)v6, v8, v9, (void *)a1);
LABEL_11:
        health::DataStore::ReadTransaction::_pointerForObject(*(health::DataStore::ReadTransaction **)(a1 + 96), (ObjectIdentifier *)(a1 + 72), (uint64_t)v15);
        uint64_t v13 = (__n128 *)health::Optional<health::BlockPointer>::get((uint64_t)v15);
        __n128 result = *v13;
        *(__n128 *)(a1 + 56) = *v13;
        return result;
      }
      health::BlockAccessFile::WriteTransaction::freeBlock((uint64_t)v6, v8, v9);
    }
    else
    {
      uint64_t v6 = (health::BlockAccessFile::WriteTransaction *)(v2 + 80);
    }
    unint64_t v10 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v6, 56);
    unint64_t v12 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::SampleHistoryRoot>((uint64_t)v6, v10, v11, (void *)a1);
    v14.n128_u64[0] = v10;
    v14.n128_u64[1] = v12;
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey((uint64_t *)&v17, (__n128 *)(a1 + 72), &v14);
    goto LABEL_11;
  }
  uint64_t v3 = *(void *)(a1 + 56);

  health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::SampleHistoryRoot>(v2 + 80, v3, 56, (void *)a1);
  return result;
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::SampleHistoryRoot>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  unint64_t v14 = 56;
  v11[0] = v12;
  v11[1] = v12;
  _OWORD v11[2] = 56;
  v10[0] = *a4;
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[1];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[2];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[3];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[4];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[5];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[6];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  if (v14 <= 0x3FF) {
    unint64_t v8 = v12;
  }
  else {
    unint64_t v8 = v13;
  }
  health::RawBuffer::RawBuffer(v10, v8, v14);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v10);
  uint64_t result = (uint64_t)v13;
  uint64_t v13 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCCDF770(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE7__cloneEv(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v2 = &unk_1F171CFB0;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE7__cloneEPNS0_6__baseIS14_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171CFB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEEclES13_(uint64_t a1, uint64_t a2)
{
  v8[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 8);
  long long v7 = *(_OWORD *)(a1 + 16);
  uint64_t v5 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v5 = &unk_1F171D030;
  *((void *)v5 + 1) = v4;
  *((void *)v5 + 2) = a2;
  *(_OWORD *)(v5 + 24) = v7;
  void v8[3] = v5;
  health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(v3, (uint64_t)v8);
  std::__function::__value_func<BOOL ()(double const&,double const&)>::~__value_func[abi:ne180100](v8);
  return 1;
}

void sub_1BCCDF8FC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(bufa, a4);
  long long buf = va_arg(va1, _OWORD);
  uint64_t v15 = va_arg(va1, void);
  if (a2)
  {
    std::__function::__value_func<BOOL ()(double const&,double const&)>::~__value_func[abi:ne180100]((uint64_t *)va1);
    uint64_t v6 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      long long v7 = v6;
      _HKInitializeLogging();
      unint64_t v8 = (void *)*MEMORY[0x1E4F29F18];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F18], OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v9 = *(uint64_t (**)(void *))(*(void *)v7 + 16);
        unint64_t v10 = v8;
        uint64_t v11 = v9(v7);
        LODWORD(buf) = 136315138;
        *(void *)(bufa + 4) = v11;
        _os_log_impl(&dword_1BCB7D000, v10, OS_LOG_TYPE_DEFAULT, "Caught std::exception during ignore block; ignoring: %s",
          (uint8_t *)bufa,
          0xCu);
      }
    }
    else
    {
      _HKInitializeLogging();
      unint64_t v12 = *MEMORY[0x1E4F29F18];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F18], OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_1BCB7D000, v12, OS_LOG_TYPE_DEFAULT, "Caught unknown during ignore block; ignoring.",
          (uint8_t *)bufa,
          2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x1BCCDF8C8);
  }
  _Unwind_Resume(a1);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_EUlRSB_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE11target_typeEv()
{
  return &_ZTIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_EUlRSB_E_;
}

void *health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(void *result, uint64_t a2)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  if (result[6])
  {
    uint64_t v2 = *(void *)(result[11] + 24);
    v5[0] = 0;
    v5[1] = 0;
    v5[2] = v2;
    long long v3 = *((_OWORD *)result + 1);
    uint64_t v4 = v5;
    std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>((uint64_t *)&v3, (uint64_t)v6, 0);
    return std::__function::__value_func<BOOL ()(double const&,double const&)>::~__value_func[abi:ne180100](v6);
  }
  return result;
}

void sub_1BCCDFB2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::__function::__value_func<BOOL ()(double const&,double const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[2];
  memset(v8, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 16), *a1, a1[1], (uint64_t)v8);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>((uint64_t)a1, 0, (uint64_t)v8, a2, a3);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_WORD *)(a3 + 408))
  {
    uint64_t v7 = result;
    unsigned __int16 v8 = *(_WORD *)(a3 + 408) - 1;
    if (!a5) {
      unsigned __int16 v8 = 0;
    }
    if (*(unsigned char *)(a3 + 410))
    {
      uint64_t v9 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v8);
      uint64_t v10 = *(void *)(v9 + 8);
      uint64_t v11 = *(void *)(v9 + 16);
      uint64_t v12 = *(void *)(v7 + 16);
      memset(v14, 0, sizeof(v14));
      __int16 v15 = 0;
      long long v16 = 0u;
      long long v17 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v12 + 16), v10, v11, (uint64_t)v14);
      uint64_t v18 = a4;
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>(int,health::bplustree::LeafNode<double,double,health::BlockPointer,17> const&,health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,double const&)#1}>(v7, (uint64_t)v14, (uint64_t)&v18, a5);
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex(result, a2, a3, v8, (uint64_t)v14);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>(v7, (a2 + 1), v14, a4, a5);
    }
  }
  return result;
}

double *health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  if (*(unsigned __int16 *)(a3 + 408) <= a4)
  {
    uint64_t v9 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v35, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v34, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v33, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v32);
    health::_HDAssertImplementation<health::btree_access_error>(v9, (uint64_t)v35, (uint64_t)v34, (uint64_t)v33, 137, (uint64_t)&v32);
  }
  if (a2 >= 64)
  {
    uint64_t v10 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v31, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v30, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v29, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29, 138, (uint64_t)&__p);
  }
  uint64_t v11 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
  uint64_t v12 = *(void *)(v11 + 8);
  uint64_t v13 = *(void *)(v11 + 16);
  uint64_t v14 = *(void *)(a1 + 16);
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 4_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 12_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  *(_OWORD *)(a5 + 160) = 0u;
  *(_OWORD *)(a5 + 176) = 0u;
  *(_OWORD *)(a5 + 192) = 0u;
  *(_OWORD *)(a5 + 20_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a5 + 224) = 0u;
  *(_OWORD *)(a5 + 240) = 0u;
  *(_OWORD *)(a5 + 256) = 0u;
  *(_OWORD *)(a5 + 272) = 0u;
  *(_OWORD *)(a5 + 28_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a5 + 304) = 0u;
  *(_OWORD *)(a5 + 320) = 0u;
  *(_OWORD *)(a5 + 336) = 0u;
  *(_OWORD *)(a5 + 352) = 0u;
  *(_OWORD *)(a5 + 36_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a5 + 384) = 0u;
  *(_OWORD *)(a5 + 395) = 0u;
  __n128 result = (double *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v14 + 16), v12, v13, a5);
  if (*(_WORD *)(a5 + 408))
  {
    double v16 = *(double *)a5;
    __n128 result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
    if (v16 < *result)
    {
      long long v17 = (void *)*MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v27, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v26, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v24);
      health::_HDAssertImplementation<health::btree_access_error>(v17, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 144, (uint64_t)&v24);
    }
    if (*(unsigned __int16 *)(a3 + 408) - 1 > (int)a4)
    {
      double v18 = *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, *(unsigned __int16 *)(a5 + 408) - 1);
      __n128 result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4 + 1);
      if (v18 >= *result)
      {
        char v19 = (void *)*MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(v23, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v22, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v20);
        health::_HDAssertImplementation<health::btree_access_error>(v19, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 146, (uint64_t)&v20);
      }
    }
  }
  return result;
}

void sub_1BCCE00BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  unint64_t v14 = 306;
  health::RawBuffer::RawBuffer(v11, v12, 306);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  unsigned __int16 v8 = v12;
  if (v14 > 0x3FF) {
    unsigned __int16 v8 = v13;
  }
  v10[0] = v8;
  v10[1] = v8;
  void v10[2] = 306;
  health::bplustree::LeafNode<double,double,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  uint64_t result = (uint64_t)v13;
  uint64_t v13 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCCE0324(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x11)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 16 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  void v7[2];

  if (a2 >= 0x11)
  {
    unint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 16 * a2;
}

void sub_1BCCE043C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::LeafNode<double,double,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v5 = (double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a1, i);
    health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry::deserialize(v5, a2);
  }
  __int16 v7 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v7);
  *(_WORD *)(a1 + 272) = v7;
  health::BlockPointer::deserialize((void *)(a1 + 280), a2);
  return health::BlockPointer::deserialize((void *)(a1 + 296), a2);
}

void sub_1BCCE0618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

double health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry::deserialize(double *a1, uint64_t a2)
{
  double v5 = 0.0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  *a1 = v5;
  double v5 = 0.0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  double result = v5;
  a1[1] = v5;
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1}>(int,health::bplustree::LeafNode<double,double,health::BlockPointer,17> const&,health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(std::function<BOOL ()(double const&,double const&)>)::{lambda(double const&,double const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,double const&)#1}>(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v43 = result;
  if (a4 == 1)
  {
    if (*(_WORD *)(a2 + 272))
    {
      unint64_t v14 = *(unsigned __int16 *)(a2 + 272) - 1;
      unint64_t v15 = 1;
      double v16 = 0.0;
      while (1)
      {
        long long v17 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        uint64_t v18 = health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        if (v15 >= 2)
        {
          v19.n128_u64[0] = *v17;
          if (*(double *)v17 >= v16)
          {
            std::string v20 = (void *)*MEMORY[0x1E4F29F18];
            std::string::basic_string[abi:ne180100]<0>(v55, "key < lastKey");
            std::string::basic_string[abi:ne180100]<0>(v54, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v53, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &__p);
            health::_HDAssertImplementation<health::btree_access_error>(v20, (uint64_t)v55, (uint64_t)v54, (uint64_t)v53, 412, (uint64_t)&__p);
          }
        }
        uint64_t v21 = *(void *)(*(void *)a3 + 24);
        if (!v21) {
          break;
        }
        double v16 = *(double *)v17;
        double result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(void *)v21 + 48))(v21, v17, v18 + 8, v19);
        if ((result & 1) == 0) {
          return result;
        }
        ++v15;
        if (--v14 == -1) {
          goto LABEL_35;
        }
      }
LABEL_48:
      std::__throw_bad_function_call[abi:ne180100]();
    }
    double v16 = 0.0;
LABEL_35:
    std::string v32 = (void **)MEMORY[0x1E4F29F18];
    uint64_t v33 = *(void *)(a2 + 280);
    uint64_t v34 = *(void *)(a2 + 288);
    while (1)
    {
      uint64_t v35 = *(void *)(v43 + 16);
      if (v33 == *(void *)v35 && v34 == *(void *)(v35 + 8)) {
        break;
      }
      unsigned __int16 v81 = 0;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v64 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v35 + 16), v33, v34, (uint64_t)&v64);
      if (!v81)
      {
        unint64_t v36 = *v32;
        std::string::basic_string[abi:ne180100]<0>(v51, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v50, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v48);
        health::_HDAssertImplementation<health::btree_access_error>(v36, (uint64_t)v51, (uint64_t)v50, (uint64_t)v49, 422, (uint64_t)&v48);
      }
      unint64_t v37 = v81 - 1;
      do
      {
        unint64_t v38 = (double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)&v64, v37);
        uint64_t v39 = health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)&v64, v37);
        if (*v38 >= v16)
        {
          uint64_t v41 = *v32;
          std::string::basic_string[abi:ne180100]<0>(v47, "key < lastKey");
          std::string::basic_string[abi:ne180100]<0>(v46, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v45, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v44);
          health::_HDAssertImplementation<health::btree_access_error>(v41, (uint64_t)v47, (uint64_t)v46, (uint64_t)v45, 427, (uint64_t)&v44);
        }
        uint64_t v42 = *(void *)(*(void *)a3 + 24);
        if (!v42) {
          goto LABEL_48;
        }
        double v16 = *v38;
        v40.n128_f64[0] = *v38;
        double result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(void *)v42 + 48))(v42, v38, v39 + 8, v40);
        if ((result & 1) == 0) {
          return result;
        }
        --v37;
      }
      while (v37 != -1);
      uint64_t v34 = *((void *)&v82 + 1);
      uint64_t v33 = v82;
    }
  }
  else if (!a4)
  {
    uint64_t v6 = (void **)MEMORY[0x1E4F29F18];
    if (*(_WORD *)(a2 + 272))
    {
      unint64_t v7 = 0;
      double v8 = 0.0;
      while (1)
      {
        uint64_t v9 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        uint64_t v10 = health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        if (v7)
        {
          v11.n128_u64[0] = *v9;
          if (*(double *)v9 <= v8)
          {
            uint64_t v12 = *v6;
            std::string::basic_string[abi:ne180100]<0>(v87, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v86, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v85, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v84);
            health::_HDAssertImplementation<health::btree_access_error>(v12, (uint64_t)v87, (uint64_t)v86, (uint64_t)v85, 382, (uint64_t)&v84);
          }
        }
        uint64_t v13 = *(void *)(*(void *)a3 + 24);
        if (!v13) {
          goto LABEL_48;
        }
        double v8 = *(double *)v9;
        double result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(void *)v13 + 48))(v13, v9, v10 + 8, v11);
        if ((result & 1) == 0) {
          return result;
        }
        if (++v7 >= *(unsigned __int16 *)(a2 + 272)) {
          goto LABEL_22;
        }
      }
    }
    double v8 = 0.0;
LABEL_22:
    uint64_t v22 = *(void *)(a2 + 296);
    uint64_t v23 = *(void *)(a2 + 304);
    while (1)
    {
      uint64_t v24 = *(void *)(v43 + 16);
      if (v22 == *(void *)v24 && v23 == *(void *)(v24 + 8)) {
        break;
      }
      unsigned __int16 v81 = 0;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v64 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v24 + 16), v22, v23, (uint64_t)&v64);
      if (!v81)
      {
        char v25 = *v6;
        std::string::basic_string[abi:ne180100]<0>(v63, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v62, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v61, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v60);
        health::_HDAssertImplementation<health::btree_access_error>(v25, (uint64_t)v63, (uint64_t)v62, (uint64_t)v61, 392, (uint64_t)&v60);
      }
      for (unint64_t i = 0; i < v81; ++i)
      {
        unint64_t v27 = (double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)&v64, i);
        uint64_t v28 = health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)&v64, i);
        if (*v27 <= v8)
        {
          unint64_t v30 = *v6;
          std::string::basic_string[abi:ne180100]<0>(v59, "key > lastKey");
          std::string::basic_string[abi:ne180100]<0>(v58, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v57, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v56);
          health::_HDAssertImplementation<health::btree_access_error>(v30, (uint64_t)v59, (uint64_t)v58, (uint64_t)v57, 396, (uint64_t)&v56);
        }
        uint64_t v31 = *(void *)(*(void *)a3 + 24);
        if (!v31) {
          goto LABEL_48;
        }
        double v8 = *v27;
        v29.n128_f64[0] = *v27;
        double result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(void *)v31 + 48))(v31, v27, v28 + 8, v29);
        if ((result & 1) == 0) {
          return result;
        }
      }
      uint64_t v23 = *((void *)&v83 + 1);
      uint64_t v22 = v83;
    }
  }
  return result;
}

void sub_1BCCE0E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a46 < 0) {
    operator delete(a41);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<BOOL ()(double const&,double const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EE7__cloneEv(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v2 = &unk_1F171D030;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EE7__cloneEPNS0_6__baseIS1A_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171D030;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EEclES19_S19_(void *a1, void *a2, void **a3)
{
  uint64_t v4 = *a3;
  uint64_t v5 = *(void *)(a1[1] + 24);
  v12[0] = *a2;
  id v13 = v4;
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  double v7 = (*(double (**)(uint64_t, void *, id *))(*(void *)v5 + 48))(v5, v12, &v13);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  void v12[2] = ___ZZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvENKUlSO_RKS9_E_clIddEEbSO_S12__block_invoke;
  void v12[3] = &__block_descriptor_56_e9_B16__0__8l;
  double v8 = (id *)a1[3];
  v12[4] = a1[2];
  v12[5] = a2;
  *(double *)&v12[6] = v7;
  if (v8) {
    uint64_t v9 = &v13;
  }
  else {
    uint64_t v9 = 0;
  }
  if (v8) {
    id v13 = *v8;
  }
  uint64_t v10 = hfd_catchExceptionsAsErrors(v12, (uint64_t)v9, 0);
  if (v8) {
    objc_storeStrong(v8, v13);
  }
  return v10;
}

void sub_1BCCE1310(void *a1)
{
  __cxa_begin_catch(a1);
  **(unsigned char **)(v1 + 32) = 1;
  __cxa_end_catch();
  JUMPOUT(0x1BCCE12F0);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvEUlSO_RKS9_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdS19_EE11target_typeEv()
{
  return &_ZTIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvEUlSO_RKS9_E_;
}

uint64_t ___ZZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV0S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvENKUlSO_RKS9_E_clIddEEbSO_S12__block_invoke(uint64_t a1)
{
  uint64_t v1 = *(int64x2_t **)(a1 + 32);
  unint64_t v2 = *(double **)(a1 + 40);
  uint64_t v3 = (uint64_t *)(a1 + 48);
  uint64_t v4 = (health::BlockAccessFile::WriteTransaction *)(v1[6].i64[0] + 80);
  v36[0] = 0;
  v36[1] = 0;
  v36[2] = v4;
  v36[3] = v4;
  uint64_t v6 = v1[1].i64[0];
  uint64_t v5 = v1[1].i64[1];
  if (!v6)
  {
    if (v5)
    {
      uint64_t v6 = 0;
    }
    else
    {
      long long v34 = 0u;
      memset(v35, 0, sizeof(v35));
      long long v32 = 0u;
      long long v33 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      long long v12 = 0u;
      long long v13 = 0u;
      long long v11 = 0u;
      uint64_t v6 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v4, 411);
      uint64_t v5 = v7;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v4, v6, v7, (uint64_t)&v11);
      v1[1].i64[0] = v6;
      v1[1].i64[1] = v5;
    }
  }
  *(void *)&long long v11 = v6;
  *((void *)&v11 + 1) = v5;
  *(void *)&long long v12 = v36;
  int v8 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::setValueForKey((uint64_t *)&v11, v2, v3);
  uint64_t v9 = v1[3].i64[0];
  if (v9)
  {
    if (!v8) {
      v1[3].i64[0] = v9 + 1;
    }
  }
  else
  {
    v1[3].i64[0] = 1;
    int64x2_t *v1 = vdupq_n_s64(8uLL);
  }
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::_updateHistoryRoot((uint64_t)v1);
  return 1;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::setValueForKey(uint64_t *a1, double *a2, uint64_t *a3)
{
  uint64_t v6 = a1[2];
  memset(v15, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 24), *a1, a1[1], (uint64_t)v15);
  uint64_t result = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey((uint64_t)a1, 0, a1, (uint64_t)v15, a2, a3);
  if (result >= 2)
  {
    uint64_t v8 = a1[2];
    memset(__src, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v8 + 24), *a1, a1[1], (uint64_t)__src);
    memcpy(v13, __src, sizeof(v13));
    uint64_t v9 = *(health::BlockAccessFile::WriteTransaction **)(a1[2] + 24);
    uint64_t v10 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v9, 411);
    uint64_t v12 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v9, v10, v11, (uint64_t)v13);
    WORD4(__src[25]) = 1;
    *((void *)&__src[0] + 1) = v10;
    *(void *)&__src[1] = v12;
    BYTE10(__src[25]) = 0;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(a1[2] + 24), *a1, a1[1], (uint64_t)__src);
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::setValueForKey(a1, a2, a3);
  }
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, double *a5, uint64_t *a6)
{
  if (!*(_WORD *)(a4 + 408))
  {
    long long v123 = 0u;
    long long v122 = 0u;
    long long v121 = 0u;
    long long v120 = 0u;
    long long v119 = 0u;
    long long v118 = 0u;
    long long v116 = 0u;
    long long v117 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v110 = 0u;
    long long v111 = 0u;
    long long v108 = 0u;
    long long v109 = 0u;
    long long v19 = *(long long **)(a1 + 16);
    long long v125 = *v19;
    long long v126 = *v19;
    unsigned __int16 v124 = 1;
    uint64_t v20 = *a6;
    *(double *)&long long v107 = *a5;
    *((void *)&v107 + 1) = v20;
    long long v21 = (health::BlockAccessFile::WriteTransaction *)*((void *)v19 + 3);
    uint64_t v22 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v21, 306);
    uint64_t v24 = v23;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>((uint64_t)v21, v22, v23, (uint64_t)&v107);
    *(double *)a4 = *a5;
    *(void *)(a4 + _Block_object_dispose(&a9, 8) = v22;
    *(void *)(a4 + 16) = v24;
    *(_WORD *)(a4 + 40_Block_object_dispose(&a9, 8) = 1;
    *(unsigned char *)(a4 + 410) = 1;
LABEL_8:
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 0;
  }
  if (*(unsigned char *)(a4 + 410))
  {
    unsigned int v11 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
    *(_OWORD *)uint64_t v85 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11)+ 8);
    uint64_t v12 = *(void *)(a1 + 16);
    long long v107 = 0u;
    long long v108 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v116 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    long long v119 = 0u;
    long long v120 = 0u;
    long long v121 = 0u;
    long long v122 = 0u;
    long long v123 = 0u;
    unsigned __int16 v124 = 0;
    long long v125 = 0u;
    long long v126 = 0u;
    long long v13 = *(_OWORD *)v85;
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v12 + 24), v85[0], v85[1], (uint64_t)&v107);
    uint64_t v14 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(a1, v85, (uint64_t)&v107, a5, a6);
    uint64_t v15 = v14;
    if (v14 <= 1)
    {
      double v16 = *a5;
      if (v16 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11))
      {
        double v17 = *a5;
        *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11) = v17;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
      }
      return v15;
    }
    int v33 = *(unsigned __int16 *)(a4 + 408);
    if (v33 == 17)
    {
      uint64_t v18 = 2;
      if (v11 == 16)
      {
        if (v14 == 4) {
          return 4;
        }
        else {
          return 2;
        }
      }
      else if (!v11)
      {
        if (v14 == 3) {
          return 3;
        }
        else {
          return 2;
        }
      }
      return v18;
    }
    if (v14 == 4 && v33 - 1 == v11)
    {
      long long v104 = 0u;
      long long v105 = 0u;
      long long v102 = 0u;
      long long v103 = 0u;
      long long v100 = 0u;
      long long v101 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
      long long v96 = 0u;
      long long v97 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      LOWORD(v106[0]) = 1;
      uint64_t v34 = *a6;
      *(double *)&long long v89 = *a5;
      *((void *)&v89 + 1) = v34;
      *(_OWORD *)((char *)v106 + _Block_object_dispose(&a9, 8) = *(_OWORD *)v85;
      *(_OWORD *)((char *)&v106[1] + _Block_object_dispose(&a9, 8) = v126;
      uint64_t v35 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
      uint64_t v36 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v35, 306);
      uint64_t v38 = v37;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>((uint64_t)v35, v36, v37, (uint64_t)&v89);
      *(void *)&long long v126 = v36;
      *((void *)&v126 + 1) = v38;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v13, *((uint64_t *)&v13 + 1), (uint64_t)&v107);
      uint64_t v39 = *(void *)(a1 + 16);
      if (*(_OWORD *)((char *)&v106[1] + 8) != *(_OWORD *)v39)
      {
        __int16 v82 = 0;
        long long v80 = 0u;
        long long v81 = 0u;
        long long v78 = 0u;
        long long v79 = 0u;
        long long v76 = 0u;
        long long v77 = 0u;
        long long v74 = 0u;
        long long v75 = 0u;
        long long v72 = 0u;
        long long v73 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        *(_OWORD *)long long v65 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v39 + 24), *((uint64_t *)&v106[1] + 1), *(uint64_t *)&v106[2], (uint64_t)v65);
        *(void *)&long long v83 = v36;
        *((void *)&v83 + 1) = v38;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *((uint64_t *)&v106[1] + 1), *(uint64_t *)&v106[2], (uint64_t)v65);
      }
      unint64_t v40 = *(unsigned __int16 *)(a4 + 408);
      uint64_t v41 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v40);
      *(void *)(v41 + _Block_object_dispose(&a9, 8) = v36;
      *(void *)(v41 + 16) = v38;
      double v42 = *a5;
      *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v40) = v42;
      ++*(_WORD *)(a4 + 408);
      goto LABEL_8;
    }
    long long v64 = *(_OWORD *)v85;
    long long v104 = 0u;
    long long v105 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    long long v100 = 0u;
    long long v101 = 0u;
    long long v98 = 0u;
    long long v99 = 0u;
    long long v97 = 0u;
    *(_OWORD *)((char *)v106 + _Block_object_dispose(&a9, 8) = *(_OWORD *)v85;
    *(_OWORD *)((char *)&v106[1] + _Block_object_dispose(&a9, 8) = v126;
    if (v124 >= 0x12uLL)
    {
      unint64_t v49 = (void *)*MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v65, "sourceIndex + elementCount <= Length");
      std::string::basic_string[abi:ne180100]<0>(v88, "copyElementsFromArrayToIndex");
      std::string::basic_string[abi:ne180100]<0>(v87, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
      health::FormatString<>((std::string *)"Copy would overflow source.", &__p);
      health::_HDAssertImplementation<std::out_of_range>(v49, (uint64_t)v65, (uint64_t)v88, (uint64_t)v87, 80, (uint64_t)&__p);
    }
    uint64_t v50 = &v107 + v124 - 8;
    long long v51 = v50[5];
    long long v93 = v50[4];
    long long v94 = v51;
    long long v52 = v50[7];
    long long v95 = v50[6];
    long long v96 = v52;
    long long v53 = v50[1];
    long long v89 = *v50;
    long long v90 = v53;
    long long v54 = v50[3];
    long long v91 = v50[2];
    long long v92 = v54;
    v124 -= 8;
    strcpy((char *)v106, "\b");
    unint64_t v55 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
    std::string v56 = (void *)health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v55, 306);
    uint64_t v58 = (void *)v57;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>((uint64_t)v55, (uint64_t)v56, v57, (uint64_t)&v89);
    v88[0] = v56;
    v88[1] = v58;
    long long v126 = *(_OWORD *)v88;
    uint64_t v59 = *(void *)(a1 + 16);
    if (*(_OWORD *)((char *)&v106[1] + 8) != *(_OWORD *)v59)
    {
      __int16 v82 = 0;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      long long v76 = 0u;
      long long v77 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      *(_OWORD *)long long v65 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v59 + 24), *((uint64_t *)&v106[1] + 1), *(uint64_t *)&v106[2], (uint64_t)v65);
      long long v83 = *(_OWORD *)v88;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *((uint64_t *)&v106[1] + 1), *(uint64_t *)&v106[2], (uint64_t)v65);
    }
    v65[0] = (void *)v89;
    v65[1] = v56;
    *(void *)&long long v66 = v58;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, (__n128 *)v65, v11 + 1);
    ++*(_WORD *)(a4 + 408);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v64, *((uint64_t *)&v64 + 1), (uint64_t)&v107);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    if (*a5 <= *(double *)&v89)
    {
      std::string v60 = (uint64_t *)&v64;
      unint64_t v61 = &v107;
    }
    else
    {
      std::string v60 = (uint64_t *)v88;
      unint64_t v61 = &v89;
    }
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(a1, v60, (uint64_t)v61, a5, a6);
  }
  int v26 = a2 + 1;
  unsigned int v27 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
  uint64_t v28 = v27;
  *(_OWORD *)uint64_t v88 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v27)+ 8);
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)&v107, a1, v26, a4, v27);
  uint64_t v29 = (a2 + 2);
  uint64_t v30 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(a1, v29, v88, &v107, a5, a6);
  if (v30 > 1)
  {
    if (*(_WORD *)(a4 + 408) == 17) {
      return 2;
    }
    *(_OWORD *)uint64_t v87 = *(_OWORD *)v88;
    memset(v106, 0, 139);
    long long v104 = 0u;
    long long v105 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    long long v100 = 0u;
    long long v101 = 0u;
    long long v98 = 0u;
    long long v99 = 0u;
    long long v96 = 0u;
    long long v97 = 0u;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v92 = 0u;
    long long v93 = 0u;
    long long v90 = 0u;
    long long v91 = 0u;
    BYTE10(v106[8]) = v128;
    long long v89 = 0u;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)&v89, 0, (uint64_t)&v107, v127 - 8, 8);
    v127 -= 8;
    WORD4(v106[8]) = 8;
    uint64_t v43 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
    std::string v44 = (void *)health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v43, 411);
    std::string::size_type v46 = v45;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v43, (uint64_t)v44, v45, (uint64_t)&v89);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v44;
    __p.__r_.__value_.__l.__size_ = v46;
    v65[0] = (void *)v89;
    v65[1] = v44;
    *(void *)&long long v66 = v46;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, (__n128 *)v65, v28 + 1);
    ++*(_WORD *)(a4 + 408);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), (uint64_t)v87[0], (uint64_t)v87[1], (uint64_t)&v107);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    if (*a5 <= *(double *)&v89)
    {
      p_p = (std::string *)v87;
      std::string v48 = &v107;
    }
    else
    {
      p_p = &__p;
      std::string v48 = &v89;
    }
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(a1, v29, p_p, v48, a5, a6);
  }
  uint64_t v18 = v30;
  double v31 = *a5;
  if (v31 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v27))
  {
    double v32 = *a5;
    *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v27) = v32;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
  }
  return v18;
}

void sub_1BCCE1EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62,void *a63)
{
  if (a62 < 0) {
    operator delete(__p);
  }
  if (a68 < 0) {
    operator delete(a63);
  }
  if (a72 < 0) {
    operator delete(a70);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = 0;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  unint64_t v16 = 306;
  v13[0] = v14;
  v13[1] = v14;
  void v13[2] = 306;
  do
  {
    uint64_t v9 = (void *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a4, v8);
    v12[0] = *v9;
    health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
    v12[0] = v9[1];
    health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
    ++v8;
  }
  while (v8 != 17);
  LOWORD(v12[0]) = *(_WORD *)(a4 + 272);
  health::SerializationBuffer::appendRaw<unsigned short>((uint64_t)v13, v12);
  v12[0] = *(void *)(a4 + 280);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(void *)(a4 + 288);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(void *)(a4 + 296);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(void *)(a4 + 304);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  if (v16 <= 0x3FF) {
    uint64_t v10 = v14;
  }
  else {
    uint64_t v10 = v15;
  }
  health::RawBuffer::RawBuffer(v12, v10, v16);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v12);
  uint64_t result = (uint64_t)v15;
  uint64_t v15 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCCE20B4(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_setValueForKey(uint64_t a1, uint64_t *a2, uint64_t a3, double *a4, uint64_t *a5)
{
  if (!*(_WORD *)(a3 + 272))
  {
    uint64_t v10 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v27, "valueCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v26, "indexForKey");
    std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for index for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 72, (uint64_t)&__p);
  }
  unsigned int v11 = *(unsigned __int16 *)(a3 + 272) - 1;
  uint64_t v12 = 1;
  while (1)
  {
    double v13 = *a4;
    if (v13 > *(double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a3, v11))break; {
    double v14 = *a4;
    }
    uint64_t v15 = (double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a3, v11);
    int v16 = (unsigned __int16)v11;
    if (v14 == *v15)
    {
      uint64_t v23 = *a5;
      *(void *)(health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a3, (unsigned __int16)v11)+ _Block_object_dispose(&a9, 8) = v23;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a2, a2[1], a3);
      return 1;
    }
    --v11;
    if (!v16)
    {
      uint64_t v12 = 0;
      LOWORD(v11) = 0;
      break;
    }
  }
  if (*(_WORD *)(a3 + 272) == 17)
  {
    if (*a4 >= *(double *)a3)
    {
      if (*a4 <= *(double *)(a3 + 256)) {
        return 2;
      }
      else {
        return 4;
      }
    }
    else
    {
      return 3;
    }
  }
  else
  {
    unint64_t v18 = v12 + (unsigned __int16)v11;
    double v19 = *a4;
    uint64_t v20 = *a5;
    if (v18 >= 0x11)
    {
      long long v21 = (void *)*MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v27, "index < Length");
      std::string::basic_string[abi:ne180100]<0>(v26, "insertElementAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
      health::FormatString<>((std::string *)"Index out of bounds.", &__p);
      health::_HDAssertImplementation<std::out_of_range>(v21, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 57, (uint64_t)&__p);
    }
    uint64_t v22 = (double *)(a3 + 16 * v18);
    memmove(v22 + 2, v22, 256 - 16 * v18);
    double *v22 = v19;
    *((void *)v22 + 1) = v20;
    ++*(_WORD *)(a3 + 272);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a2, a2[1], a3);
    return 0;
  }
}

void sub_1BCCE23B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

double *health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5)
{
  if (*(unsigned __int16 *)(a4 + 408) <= a5)
  {
    uint64_t v9 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v35, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v34, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v33, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v32);
    health::_HDAssertImplementation<health::btree_access_error>(v9, (uint64_t)v35, (uint64_t)v34, (uint64_t)v33, 137, (uint64_t)&v32);
  }
  if (a3 >= 64)
  {
    uint64_t v10 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v31, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v30, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v29, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29, 138, (uint64_t)&__p);
  }
  uint64_t v11 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5);
  uint64_t v12 = *(void *)(v11 + 8);
  uint64_t v13 = *(void *)(v11 + 16);
  uint64_t v14 = *(void *)(a2 + 16);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 28_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 36_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 395) = 0u;
  uint64_t result = (double *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v14 + 24), v12, v13, a1);
  if (*(_WORD *)(a1 + 408))
  {
    double v16 = *(double *)a1;
    uint64_t result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5);
    if (v16 < *result)
    {
      uint64_t v17 = (void *)*MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v27, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v26, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v24);
      health::_HDAssertImplementation<health::btree_access_error>(v17, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 144, (uint64_t)&v24);
    }
    if (*(unsigned __int16 *)(a4 + 408) - 1 > (int)a5)
    {
      double v18 = *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, *(unsigned __int16 *)(a1 + 408) - 1);
      uint64_t result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5 + 1);
      if (v18 >= *result)
      {
        double v19 = (void *)*MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(v23, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v22, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v20);
        health::_HDAssertImplementation<health::btree_access_error>(v19, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 146, (uint64_t)&v20);
      }
    }
  }
  return result;
}

void sub_1BCCE2800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<BOOL ()(double const&,double const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0> &)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::~__func()
{
}

void *std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F171D0D0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F171D0D0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::operator()(uint64_t a1, health::DataStore::WriteTransaction *a2)
{
  long long v6 = 0u;
  long long v7 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v11 = a2;
  uint64_t v12 = a2;
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)(a1 + 8), 0);
  v15[0] = 0;
  v15[1] = 0;
  _OWORD v15[2] = (char *)v12 + 80;
  v15[3] = (char *)v12 + 80;
  if (v6 != 0)
  {
    long long v13 = v6;
    uint64_t v14 = v15;
    memset(__src, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t *)v12 + 10, v6, *((uint64_t *)&v6 + 1), (uint64_t)__src);
    memcpy(__dst, __src, sizeof(__dst));
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::deleteAllSamples(void)::{lambda(double const&,double const&)#1}>((uint64_t)&v13, 0, (unint64_t *)&v13, (uint64_t)__dst);
  }
  uint64_t v8 = 0;
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::_updateHistoryRoot((uint64_t)v5);
  health::DataStore::WriteTransaction::removeObjectWithIdentifier(a2, *(ObjectIdentifier **)(a1 + 8));
  return 1;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target_type()
{
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::deleteAllSamples(void)::{lambda(double const&,double const&)#1}>(uint64_t a1, int a2, unint64_t *a3, uint64_t a4)
{
  if (*(_WORD *)(a4 + 408))
  {
    unint64_t v7 = 0;
    unsigned int v16 = a2 + 1;
    do
    {
      if (*(unsigned char *)(a4 + 410))
      {
        uint64_t v8 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v7);
        uint64_t v9 = *(void *)(a1 + 16);
        memset(v19, 0, sizeof(v19));
        unsigned __int16 v20 = 0;
        long long v21 = 0u;
        long long v22 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(uint64_t **)(v9 + 24), *(void *)(v8 + 8), *(void *)(v8 + 16), (uint64_t)v19);
        if (v20)
        {
          for (unint64_t i = 0;
                i < v20;
                health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v19, i++))
          {
            health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v19, i);
          }
        }
        uint64_t v11 = *(unint64_t **)(a1 + 16);
        unint64_t v12 = v22;
        if (v22 != *(_OWORD *)v11)
        {
          memset(__src, 0, 274);
          *(_OWORD *)((char *)&__src[17] + _Block_object_dispose(&a9, 8) = 0u;
          *(_OWORD *)((char *)&__src[18] + _Block_object_dispose(&a9, 8) = 0u;
          health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>((uint64_t *)v11[3], v22, *((uint64_t *)&v22 + 1), (uint64_t)__src);
          *(_OWORD *)((char *)&__src[17] + _Block_object_dispose(&a9, 8) = v21;
          health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v22, *((uint64_t *)&v22 + 1), (uint64_t)__src);
          uint64_t v11 = *(unint64_t **)(a1 + 16);
          unint64_t v12 = *v11;
        }
        if (v21 != __PAIR128__(v11[1], v12))
        {
          memset(__src, 0, 274);
          *(_OWORD *)((char *)&__src[17] + _Block_object_dispose(&a9, 8) = 0u;
          *(_OWORD *)((char *)&__src[18] + _Block_object_dispose(&a9, 8) = 0u;
          health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>((uint64_t *)v11[3], v21, *((uint64_t *)&v21 + 1), (uint64_t)__src);
          *(_OWORD *)((char *)&__src[18] + _Block_object_dispose(&a9, 8) = v22;
          health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v21, *((uint64_t *)&v21 + 1), (uint64_t)__src);
          uint64_t v11 = *(unint64_t **)(a1 + 16);
        }
        health::BlockAccessFile::WriteTransaction::freeBlock(v11[3], *(void *)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)__src, a1, a2, a4, (unsigned __int16)v7);
        uint64_t v13 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v7)+ 8;
        memcpy(__dst, __src, sizeof(__dst));
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,double>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV0>::deleteAllSamples(void)::{lambda(double const&,double const&)#1}>(a1, v16, v13, __dst);
      }
      ++v7;
    }
    while (v7 < *(unsigned __int16 *)(a4 + 408));
  }
  return health::BlockAccessFile::WriteTransaction::freeBlock(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1]);
}

void *std::__function::__value_func<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<double ()(double,double)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v8 = 0;
  long long v6 = operator new(0x20uLL);
  *long long v6 = &unk_1F171D280;
  v6[1] = a2;
  void v6[2] = a3;
  uint64_t v6[3] = &v8;
  v9[3] = v6;
  health::DataStore::performReadTransactionWithLambda(a1, (uint64_t)v9);
  std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100](v9);
  return v8;
}

void sub_1BCCE3518(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::~__func()
{
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F171D280;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171D280;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(a1 + 8, a2);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target_type()
{
}

uint64_t std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(uint64_t a1, uint64_t a2)
{
  memset(&v5[16], 0, 32);
  memset(&v5[56], 0, 32);
  uint64_t v6 = a2;
  uint64_t result = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)a1);
  if (result)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 24);
    if (!v4) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v4 + 48))(v4, v5);
    **(unsigned char **)(a1 + 16) = 1;
  }
  return result;
}

void _ZNSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE7__cloneEv(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1F171D300;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE7__cloneEPNS0_6__baseISY_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171D300;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEEclESX_(uint64_t a1, uint64_t a2)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3321888768;
  v5[2] = ___ZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO__block_invoke;
  void v5[3] = &__block_descriptor_72_ea8_32c280_ZTSKZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_EUlSL_E__e9_B16__0__8l;
  uint64_t v2 = *(void *)(a1 + 8);
  long long v6 = *(_OWORD *)(a1 + 16);
  uint64_t v7 = v2;
  uint64_t v8 = a2;
  long long v3 = *(id **)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 32);
  if (v3)
  {
    obunint64_t j = *v3;
    hfd_catchExceptionsAsErrors(v5, (uint64_t)&obj, 0);
    objc_storeStrong(v3, obj);
  }
  else
  {
    hfd_catchExceptionsAsErrors(v5, 0, 0);
  }
}

uint64_t _ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSB_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSD_E_NS_9allocatorISR_EEFvRKNS5_13SampleHistoryIS3_EEEE11target_typeEv()
{
  return &_ZTIZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvEUlRKSB_E_;
}

BOOL ___ZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO__block_invoke(void *a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  char v18 = 0;
  id v17 = 0;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v7 = a1[6];
  uint64_t v6 = a1[7];
  uint64_t v8 = operator new(0x28uLL);
  void *v8 = &unk_1F171D430;
  v8[1] = v7;
  v8[2] = &v17;
  void v8[3] = &v18;
  v8[4] = v6;
  void v20[3] = v8;
  char v19 = 1;
  uint64_t v9 = operator new(0x20uLL);
  void *v9 = &unk_1F171D3B0;
  v9[1] = v5;
  void v9[2] = &v19;
  v9[3] = v20;
  long long v22 = v9;
  health::DataStore::performWriteTransactionWithLambda(v4, (uint64_t)v21);
  std::__function::__value_func<BOOL ()(health::DataStore::WriteTransaction &)>::~__value_func[abi:ne180100](v21);
  std::__function::__value_func<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>::~__value_func[abi:ne180100](v20);
  id v10 = v17;
  if (v17)
  {
    id v11 = v17;
    unint64_t v12 = v11;
    if (a2) {
      *a2 = v11;
    }
    else {
      _HKLogDroppedError();
    }
  }
  else
  {
    if (v18) {
      goto LABEL_7;
    }
    uint64_t v13 = *(void *)(a1[8] + 24);
    if (!v13) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13) & 1) == 0)
    {
LABEL_7:
      uint64_t v14 = a1[4];
      uint64_t v15 = a1[5];
      v21[0] = &unk_1F171D550;
      v21[1] = v15;
      long long v22 = v21;
      health::DataStore::performWriteTransactionWithLambda(v14, (uint64_t)v21);
      std::__function::__value_func<BOOL ()(health::DataStore::WriteTransaction &)>::~__value_func[abi:ne180100](v21);
    }
  }

  return v10 == 0;
}

void sub_1BCCE3A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c280_ZTSKZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_EUlSL_E_(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 32);
  long long v3 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&a9, 8) = v3;
  return result;
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::~__func()
{
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F171D3B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171D3B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::operator()(uint64_t a1, uint64_t a2)
{
  long long v8 = 0u;
  long long v7 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v11 = a2;
  uint64_t v12 = a2;
  double HistoryRoot = health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::loadHistoryRoot((uint64_t)v6, *(ObjectIdentifier **)(a1 + 8), **(unsigned __int8 **)(a1 + 16));
  uint64_t v4 = *(void *)(*(void *)(a1 + 24) + 24);
  if (!v4) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, unsigned char *, double))(*(void *)v4 + 48))(v4, v6, HistoryRoot);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForWriting<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&,BOOL,std::function<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target_type()
{
}

double health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::loadHistoryRoot(uint64_t a1, ObjectIdentifier *a2, int a3)
{
  *(ObjectIdentifier *)(a1 + 72) = *a2;
  uint64_t v5 = *(health::DataStore::ReadTransaction **)(a1 + 96);
  health::DataStore::ReadTransaction::_pointerForObject(v5, a2, (uint64_t)v10);
  if (v10[16])
  {
    uint64_t v6 = (uint64_t *)*((void *)v5 + 3);
    long long v7 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v10);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::SampleHistoryRoot>(v6, *v7, v7[1], (void *)a1);
  }
  else
  {
    if (!a3)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      _ZN6health15not_found_errorCI1St13runtime_errorEPKc(exception, "The requested sample history does not exist.");
    }
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    *(void *)&double result = health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::_updateHistoryRoot(a1).n128_u64[0];
  }
  return result;
}

void sub_1BCCE3CFC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::_updateHistoryRoot(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (*(void *)(a1 + 64) != 56)
  {
    long long v17 = *(_OWORD *)(v2 + 32);
    uint64_t v18 = v2 + 48;
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v17, (void *)(a1 + 72), 0, v15);
    if (v16)
    {
      uint64_t v5 = *(void *)(health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v15)
                     + 24);
      uint64_t v6 = (health::BlockAccessFile::WriteTransaction *)(v2 + 80);
      uint64_t v7 = health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v15);
      unint64_t v8 = *(void *)(v7 + 16);
      unint64_t v9 = *(void *)(v7 + 24);
      if (v5 == 56)
      {
        health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::SampleHistoryRoot>((uint64_t)v6, v8, v9, (void *)a1);
LABEL_11:
        health::DataStore::ReadTransaction::_pointerForObject(*(health::DataStore::ReadTransaction **)(a1 + 96), (ObjectIdentifier *)(a1 + 72), (uint64_t)v15);
        uint64_t v13 = (__n128 *)health::Optional<health::BlockPointer>::get((uint64_t)v15);
        __n128 result = *v13;
        *(__n128 *)(a1 + 56) = *v13;
        return result;
      }
      health::BlockAccessFile::WriteTransaction::freeBlock((uint64_t)v6, v8, v9);
    }
    else
    {
      uint64_t v6 = (health::BlockAccessFile::WriteTransaction *)(v2 + 80);
    }
    unint64_t v10 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v6, 56);
    unint64_t v12 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::SampleHistoryRoot>((uint64_t)v6, v10, v11, (void *)a1);
    v14.n128_u64[0] = v10;
    v14.n128_u64[1] = v12;
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey((uint64_t *)&v17, (__n128 *)(a1 + 72), &v14);
    goto LABEL_11;
  }
  uint64_t v3 = *(void *)(a1 + 56);

  health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::SampleHistoryRoot>(v2 + 80, v3, 56, (void *)a1);
  return result;
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::SampleHistoryRoot>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  unint64_t v14 = 56;
  v11[0] = v12;
  v11[1] = v12;
  void v11[2] = 56;
  v10[0] = *a4;
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[1];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[2];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[3];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[4];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[5];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  v10[0] = a4[6];
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v11, v10);
  if (v14 <= 0x3FF) {
    unint64_t v8 = v12;
  }
  else {
    unint64_t v8 = v13;
  }
  health::RawBuffer::RawBuffer(v10, v8, v14);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v10);
  uint64_t result = (uint64_t)v13;
  uint64_t v13 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCCE3FC8(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE7__cloneEv(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v2 = &unk_1F171D430;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE7__cloneEPNS0_6__baseIS14_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171D430;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEEclES13_(uint64_t a1, uint64_t a2)
{
  v8[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 8);
  long long v7 = *(_OWORD *)(a1 + 16);
  uint64_t v5 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v5 = &unk_1F171D4B0;
  *((void *)v5 + 1) = v4;
  *((void *)v5 + 2) = a2;
  *(_OWORD *)(v5 + 24) = v7;
  void v8[3] = v5;
  health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(v3, (uint64_t)v8);
  std::__function::__value_func<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>::~__value_func[abi:ne180100](v8);
  return 1;
}

void sub_1BCCE4154(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(bufa, a4);
  long long buf = va_arg(va1, _OWORD);
  uint64_t v15 = va_arg(va1, void);
  if (a2)
  {
    std::__function::__value_func<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>::~__value_func[abi:ne180100]((uint64_t *)va1);
    uint64_t v6 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      long long v7 = v6;
      _HKInitializeLogging();
      unint64_t v8 = (void *)*MEMORY[0x1E4F29F18];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F18], OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v9 = *(uint64_t (**)(void *))(*(void *)v7 + 16);
        unint64_t v10 = v8;
        uint64_t v11 = v9(v7);
        LODWORD(buf) = 136315138;
        *(void *)(bufa + 4) = v11;
        _os_log_impl(&dword_1BCB7D000, v10, OS_LOG_TYPE_DEFAULT, "Caught std::exception during ignore block; ignoring: %s",
          (uint8_t *)bufa,
          0xCu);
      }
    }
    else
    {
      _HKInitializeLogging();
      unint64_t v12 = *MEMORY[0x1E4F29F18];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F18], OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_1BCB7D000, v12, OS_LOG_TYPE_DEFAULT, "Caught unknown during ignore block; ignoring.",
          (uint8_t *)bufa,
          2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x1BCCE4120);
  }
  _Unwind_Resume(a1);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_EUlRSB_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_EUlRSD_E_NS_9allocatorISY_EEFbRNS5_20MutableSampleHistoryIS3_EEEE11target_typeEv()
{
  return &_ZTIZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_EUlRSB_E_;
}

void *health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(void *result, uint64_t a2)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  if (result[6])
  {
    uint64_t v2 = *(void *)(result[11] + 24);
    v5[0] = 0;
    v5[1] = 0;
    v5[2] = v2;
    long long v3 = *((_OWORD *)result + 1);
    uint64_t v4 = v5;
    std::__function::__value_func<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>((uint64_t *)&v3, (uint64_t)v6, 0);
    return std::__function::__value_func<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>::~__value_func[abi:ne180100](v6);
  }
  return result;
}

void sub_1BCCE4384(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::__function::__value_func<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[2];
  memset(v8, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 16), *a1, a1[1], (uint64_t)v8);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>((uint64_t)a1, 0, (uint64_t)v8, a2, a3);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_WORD *)(a3 + 408))
  {
    uint64_t v7 = result;
    unsigned __int16 v8 = *(_WORD *)(a3 + 408) - 1;
    if (!a5) {
      unsigned __int16 v8 = 0;
    }
    if (*(unsigned char *)(a3 + 410))
    {
      uint64_t v9 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v8);
      uint64_t v10 = *(void *)(v9 + 8);
      uint64_t v11 = *(void *)(v9 + 16);
      uint64_t v12 = *(void *)(v7 + 16);
      memset(v14, 0, 410);
      memset(&v14[26], 0, 32);
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v12 + 16), v10, v11, (uint64_t)v14);
      uint64_t v15 = a4;
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17> const&,health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(v7, (uint64_t)v14, (uint64_t)&v15, a5);
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex(result, a2, a3, v8, (uint64_t)v14);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(v7, (a2 + 1), v14, a4, a5);
    }
  }
  return result;
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = 0;
  unint64_t v14 = 374;
  health::RawBuffer::RawBuffer(v11, v12, 374);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  unsigned __int16 v8 = v12;
  if (v14 > 0x3FF) {
    unsigned __int16 v8 = v13;
  }
  v10[0] = v8;
  v10[1] = v8;
  void v10[2] = 374;
  health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  uint64_t result = (uint64_t)v13;
  uint64_t v13 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCCE4640(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v5 = (void *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, i);
    uint64_t v7 = 0;
    health::DeserializationBuffer::extractRaw<long long>(a2, &v7);
    *uint64_t v5 = v7;
    _HDRawQuantitySampleValueV1::deserialize((uint64_t)(v5 + 1), a2);
  }
  __int16 v8 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v8);
  *(_WORD *)(a1 + 40_Block_object_dispose(&a9, 8) = v8;
  health::BlockPointer::deserialize((void *)(a1 + 416), a2);
  return health::BlockPointer::deserialize((void *)(a1 + 432), a2);
}

float _HDRawQuantitySampleValueV1::deserialize(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v5);
  *(void *)a1 = v5;
  float v6 = 0.0;
  health::DeserializationBuffer::extractRaw<int>(a2, &v6);
  float result = v6;
  *(float *)(a1 + _Block_object_dispose(&a9, 8) = v6;
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_enumerateAllValues<health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17> const&,health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v43 = result;
  if (a4 == 1)
  {
    if (*(_WORD *)(a2 + 408))
    {
      unint64_t v14 = *(unsigned __int16 *)(a2 + 408) - 1;
      unint64_t v15 = 1;
      double v16 = 0.0;
      while (1)
      {
        long long v17 = (unint64_t *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v14);
        uint64_t v18 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v14);
        if (v15 >= 2)
        {
          v19.n128_u64[0] = *v17;
          if (*(double *)v17 >= v16)
          {
            unsigned __int16 v20 = (void *)*MEMORY[0x1E4F29F18];
            std::string::basic_string[abi:ne180100]<0>(v55, "key < lastKey");
            std::string::basic_string[abi:ne180100]<0>(v54, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v53, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &__p);
            health::_HDAssertImplementation<health::btree_access_error>(v20, (uint64_t)v55, (uint64_t)v54, (uint64_t)v53, 412, (uint64_t)&__p);
          }
        }
        uint64_t v21 = *(void *)(*(void *)a3 + 24);
        if (!v21) {
          break;
        }
        double v16 = *(double *)v17;
        float result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(void *)v21 + 48))(v21, v17, v18 + 8, v19);
        if ((result & 1) == 0) {
          return result;
        }
        ++v15;
        if (--v14 == -1) {
          goto LABEL_35;
        }
      }
LABEL_48:
      std::__throw_bad_function_call[abi:ne180100]();
    }
    double v16 = 0.0;
LABEL_35:
    std::string v32 = (void **)MEMORY[0x1E4F29F18];
    uint64_t v33 = *(void *)(a2 + 416);
    uint64_t v34 = *(void *)(a2 + 424);
    while (1)
    {
      uint64_t v35 = *(void *)(v43 + 16);
      if (v33 == *(void *)v35 && v34 == *(void *)(v35 + 8)) {
        break;
      }
      long long v87 = 0u;
      memset(v88, 0, 26);
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v64 = 0u;
      long long v89 = 0u;
      long long v90 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v35 + 16), v33, v34, (uint64_t)&v64);
      if (!WORD4(v88[1]))
      {
        uint64_t v36 = *v32;
        std::string::basic_string[abi:ne180100]<0>(v51, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v50, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v48);
        health::_HDAssertImplementation<health::btree_access_error>(v36, (uint64_t)v51, (uint64_t)v50, (uint64_t)v49, 422, (uint64_t)&v48);
      }
      unint64_t v37 = WORD4(v88[1]) - 1;
      do
      {
        uint64_t v38 = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)&v64, v37);
        uint64_t v39 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)&v64, v37);
        if (*v38 >= v16)
        {
          uint64_t v41 = *v32;
          std::string::basic_string[abi:ne180100]<0>(v47, "key < lastKey");
          std::string::basic_string[abi:ne180100]<0>(v46, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v45, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v44);
          health::_HDAssertImplementation<health::btree_access_error>(v41, (uint64_t)v47, (uint64_t)v46, (uint64_t)v45, 427, (uint64_t)&v44);
        }
        uint64_t v42 = *(void *)(*(void *)a3 + 24);
        if (!v42) {
          goto LABEL_48;
        }
        double v16 = *v38;
        v40.n128_f64[0] = *v38;
        float result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(void *)v42 + 48))(v42, v38, v39 + 8, v40);
        if ((result & 1) == 0) {
          return result;
        }
        --v37;
      }
      while (v37 != -1);
      uint64_t v34 = *((void *)&v89 + 1);
      uint64_t v33 = v89;
    }
  }
  else if (!a4)
  {
    float v6 = (void **)MEMORY[0x1E4F29F18];
    if (*(_WORD *)(a2 + 408))
    {
      unint64_t v7 = 0;
      double v8 = 0.0;
      while (1)
      {
        uint64_t v9 = (unint64_t *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v7);
        uint64_t v10 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v7);
        if (v7)
        {
          v11.n128_u64[0] = *v9;
          if (*(double *)v9 <= v8)
          {
            uint64_t v12 = *v6;
            std::string::basic_string[abi:ne180100]<0>(v94, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v93, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v92, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v91);
            health::_HDAssertImplementation<health::btree_access_error>(v12, (uint64_t)v94, (uint64_t)v93, (uint64_t)v92, 382, (uint64_t)&v91);
          }
        }
        uint64_t v13 = *(void *)(*(void *)a3 + 24);
        if (!v13) {
          goto LABEL_48;
        }
        double v8 = *(double *)v9;
        float result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(void *)v13 + 48))(v13, v9, v10 + 8, v11);
        if ((result & 1) == 0) {
          return result;
        }
        if (++v7 >= *(unsigned __int16 *)(a2 + 408)) {
          goto LABEL_22;
        }
      }
    }
    double v8 = 0.0;
LABEL_22:
    uint64_t v22 = *(void *)(a2 + 432);
    uint64_t v23 = *(void *)(a2 + 440);
    while (1)
    {
      uint64_t v24 = *(void *)(v43 + 16);
      if (v22 == *(void *)v24 && v23 == *(void *)(v24 + 8)) {
        break;
      }
      long long v87 = 0u;
      memset(v88, 0, 26);
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v64 = 0u;
      long long v89 = 0u;
      long long v90 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v24 + 16), v22, v23, (uint64_t)&v64);
      if (!WORD4(v88[1]))
      {
        long long v25 = *v6;
        std::string::basic_string[abi:ne180100]<0>(v63, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v62, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v61, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v60);
        health::_HDAssertImplementation<health::btree_access_error>(v25, (uint64_t)v63, (uint64_t)v62, (uint64_t)v61, 392, (uint64_t)&v60);
      }
      unint64_t v26 = 0;
      do
      {
        unsigned int v27 = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)&v64, v26);
        uint64_t v28 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)&v64, v26);
        if (*v27 <= v8)
        {
          uint64_t v30 = *v6;
          std::string::basic_string[abi:ne180100]<0>(v59, "key > lastKey");
          std::string::basic_string[abi:ne180100]<0>(v58, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v57, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v56);
          health::_HDAssertImplementation<health::btree_access_error>(v30, (uint64_t)v59, (uint64_t)v58, (uint64_t)v57, 396, (uint64_t)&v56);
        }
        uint64_t v31 = *(void *)(*(void *)a3 + 24);
        if (!v31) {
          goto LABEL_48;
        }
        double v8 = *v27;
        v29.n128_f64[0] = *v27;
        float result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(void *)v31 + 48))(v31, v27, v28 + 8, v29);
        if ((result & 1) == 0) {
          return result;
        }
        ++v26;
      }
      while (v26 < WORD4(v88[1]));
      uint64_t v23 = *((void *)&v90 + 1);
      uint64_t v22 = v90;
    }
  }
  return result;
}

void sub_1BCCE4F64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a46 < 0) {
    operator delete(a41);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EE7__cloneEv(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v2 = &unk_1F171D4B0;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EE7__cloneEPNS0_6__baseIS1D_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171D4B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EEclES19_S1C_(void *a1, void **a2, long long *a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1[1] + 24);
  long long v13 = *a3;
  id v20 = v4;
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, id *, long long *))(*(void *)v5 + 48))(v5, &v20, &v13);
  *(void *)&long long v13 = MEMORY[0x1E4F143A8];
  *((void *)&v13 + 1) = 3221225472;
  unint64_t v14 = ___ZZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvENKUlSO_RKS9_E_clId27_HDRawQuantitySampleValueV1EEbSO_S12__block_invoke;
  unint64_t v15 = &__block_descriptor_64_e9_B16__0__8l;
  double v8 = (id *)a1[3];
  uint64_t v16 = a1[2];
  long long v17 = a2;
  uint64_t v18 = v7;
  uint64_t v19 = v9;
  if (v8) {
    uint64_t v10 = &v20;
  }
  else {
    uint64_t v10 = 0;
  }
  if (v8) {
    id v20 = *v8;
  }
  uint64_t v11 = hfd_catchExceptionsAsErrors(&v13, (uint64_t)v10, 0);
  if (v8) {
    objc_storeStrong(v8, v20);
  }
  return v11;
}

void sub_1BCCE53E4(void *a1)
{
  __cxa_begin_catch(a1);
  **(unsigned char **)(v1 + 32) = 1;
  __cxa_end_catch();
  JUMPOUT(0x1BCCE53C4);
}

uint64_t _ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvEUlSO_RKS9_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S3_EbRKN6health9DataStoreERS5_NS5_16ObjectIdentifierENS_8functionIFNT0_9ValueTypeENT_7KeyTypeENSD_9ValueTypeEEEENSA_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSD_E_clINS5_13SampleHistoryIS3_EEEEDaSQ_ENKUlSN_E_clESN_ENKUlRSD_E_clINS5_20MutableSampleHistoryIS3_EEEEbSX_ENKUlvE_clEvEUlSQ_RKSB_E_NS_9allocatorIS15_EEFbRKdRK27_HDRawQuantitySampleValueV1EE11target_typeEv()
{
  return &_ZTIZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvEUlSO_RKS9_E_;
}

uint64_t ___ZZZZZZZL15HDMigrateDatumsI29QuantitySampleValueBehaviorV1S0_EbRKN6health9DataStoreERS2_NS2_16ObjectIdentifierENSt3__18functionIFNT0_9ValueTypeENT_7KeyTypeENSB_9ValueTypeEEEENS8_IFbvEEEPU15__autoreleasingP7NSErrorENKUlvE_clEvENKUlRKSB_E_clINS2_13SampleHistoryIS0_EEEEDaSO_ENKUlSL_E_clESL_ENKUlRSB_E_clINS2_20MutableSampleHistoryIS0_EEEEbSV_ENKUlvE_clEvENKUlSO_RKS9_E_clId27_HDRawQuantitySampleValueV1EEbSO_S12__block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unint64_t v2 = *(double **)(a1 + 40);
  uint64_t v3 = (_OWORD *)(a1 + 48);
  uint64_t v4 = (health::BlockAccessFile::WriteTransaction *)(*(void *)(v1 + 96) + 80);
  v36[0] = 0;
  v36[1] = 0;
  v36[2] = v4;
  v36[3] = v4;
  uint64_t v6 = *(void *)(v1 + 16);
  uint64_t v5 = *(void *)(v1 + 24);
  if (!v6)
  {
    if (v5)
    {
      uint64_t v6 = 0;
    }
    else
    {
      long long v34 = 0u;
      memset(v35, 0, sizeof(v35));
      long long v32 = 0u;
      long long v33 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      long long v12 = 0u;
      long long v13 = 0u;
      long long v11 = 0u;
      uint64_t v6 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v4, 411);
      uint64_t v5 = v7;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v4, v6, v7, (uint64_t)&v11);
      *(void *)(v1 + 16) = v6;
      *(void *)(v1 + 24) = v5;
    }
  }
  *(void *)&long long v11 = v6;
  *((void *)&v11 + 1) = v5;
  *(void *)&long long v12 = v36;
  int v8 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::setValueForKey((uint64_t *)&v11, v2, v3);
  uint64_t v9 = *(void *)(v1 + 48);
  if (v9)
  {
    if (!v8) {
      *(void *)(v1 + 4_Block_object_dispose(&a9, 8) = v9 + 1;
    }
  }
  else
  {
    *(void *)(v1 + 4_Block_object_dispose(&a9, 8) = 1;
    *(_OWORD *)uint64_t v1 = xmmword_1BD326B50;
  }
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::_updateHistoryRoot(v1);
  return 1;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::setValueForKey(uint64_t *a1, double *a2, _OWORD *a3)
{
  uint64_t v6 = a1[2];
  memset(v15, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 24), *a1, a1[1], (uint64_t)v15);
  uint64_t result = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey((uint64_t)a1, 0, a1, (uint64_t)v15, a2, a3);
  if (result >= 2)
  {
    uint64_t v8 = a1[2];
    memset(__src, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v8 + 24), *a1, a1[1], (uint64_t)__src);
    memcpy(v13, __src, sizeof(v13));
    uint64_t v9 = *(health::BlockAccessFile::WriteTransaction **)(a1[2] + 24);
    uint64_t v10 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v9, 411);
    uint64_t v12 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v9, v10, v11, (uint64_t)v13);
    WORD4(__src[25]) = 1;
    *((void *)&__src[0] + 1) = v10;
    *(void *)&__src[1] = v12;
    BYTE10(__src[25]) = 0;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(a1[2] + 24), *a1, a1[1], (uint64_t)__src);
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::setValueForKey(a1, a2, a3);
  }
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, double *a5, _OWORD *a6)
{
  if (!*(_WORD *)(a4 + 408))
  {
    memset(&v95[24], 0, 384);
    long long v19 = *(long long **)(a1 + 16);
    long long v97 = *v19;
    long long v98 = *v19;
    *(_WORD *)&v95[408] = 1;
    *(double *)long long v95 = *a5;
    *(_OWORD *)&v95[8] = *a6;
    long long v20 = (health::BlockAccessFile::WriteTransaction *)*((void *)v19 + 3);
    uint64_t v21 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v20, 374);
    uint64_t v23 = v22;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>((uint64_t)v20, v21, v22, (uint64_t)v95);
    *(double *)a4 = *a5;
    *(void *)(a4 + _Block_object_dispose(&a9, 8) = v21;
    *(void *)(a4 + 16) = v23;
    *(_WORD *)(a4 + 40_Block_object_dispose(&a9, 8) = 1;
    *(unsigned char *)(a4 + 410) = 1;
LABEL_8:
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    return 0;
  }
  if (*(unsigned char *)(a4 + 410))
  {
    unsigned int v11 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
    *(_OWORD *)long long v99 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11)+ 8);
    uint64_t v12 = *(void *)(a1 + 16);
    memset(v95, 0, sizeof(v95));
    long long v98 = 0u;
    long long v97 = 0u;
    long long v13 = *(_OWORD *)v99;
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v12 + 24), v99[0], v99[1], (uint64_t)v95);
    uint64_t v14 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(a1, v99, (uint64_t)v95, a5, a6);
    uint64_t v15 = v14;
    if (v14 <= 1)
    {
      double v16 = *a5;
      if (v16 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11))
      {
        double v17 = *a5;
        *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v11) = v17;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
      }
      return v15;
    }
    int v32 = *(unsigned __int16 *)(a4 + 408);
    if (v32 == 17)
    {
      uint64_t v18 = 2;
      if (v11 == 16)
      {
        if (v14 == 4) {
          return 4;
        }
        else {
          return 2;
        }
      }
      else if (!v11)
      {
        if (v14 == 3) {
          return 3;
        }
        else {
          return 2;
        }
      }
      return v18;
    }
    if (v14 == 4 && v32 - 1 == v11)
    {
      memset((char *)&v92[1] + 8, 0, 384);
      WORD4(v92[25]) = 1;
      *(double *)long long v92 = *a5;
      *(_OWORD *)((char *)v92 + _Block_object_dispose(&a9, 8) = *a6;
      long long v93 = *(_OWORD *)v99;
      long long v94 = v98;
      long long v33 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
      uint64_t v34 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v33, 374);
      uint64_t v36 = v35;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>((uint64_t)v33, v34, v35, (uint64_t)v92);
      *(void *)&long long v98 = v34;
      *((void *)&v98 + 1) = v36;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v13, *((uint64_t *)&v13 + 1), (uint64_t)v95);
      uint64_t v37 = *(void *)(a1 + 16);
      if (v94 != *(_OWORD *)v37)
      {
        long long v87 = 0u;
        long long v88 = 0u;
        long long v85 = 0u;
        long long v86 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v75 = 0u;
        long long v76 = 0u;
        long long v73 = 0u;
        long long v74 = 0u;
        long long v71 = 0u;
        long long v72 = 0u;
        long long v69 = 0u;
        long long v70 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        *(_OWORD *)std::string __p = 0u;
        long long v66 = 0u;
        long long v90 = 0u;
        long long v91 = 0u;
        memset(v89, 0, sizeof(v89));
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v37 + 24), v94, *((uint64_t *)&v94 + 1), (uint64_t)__p);
        *(void *)&long long v90 = v34;
        *((void *)&v90 + 1) = v36;
        health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v94, *((uint64_t *)&v94 + 1), (uint64_t)__p);
      }
      unint64_t v38 = *(unsigned __int16 *)(a4 + 408);
      uint64_t v39 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v38);
      *(void *)(v39 + _Block_object_dispose(&a9, 8) = v34;
      *(void *)(v39 + 16) = v36;
      double v40 = *a5;
      *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v3_Block_object_dispose(&a9, 8) = v40;
      ++*(_WORD *)(a4 + 408);
      goto LABEL_8;
    }
    long long v64 = *(_OWORD *)v99;
    memset(&v92[12], 0, 216);
    long long v93 = *(_OWORD *)v99;
    long long v94 = v98;
    if (*(unsigned __int16 *)&v95[408] >= 0x12uLL)
    {
      unint64_t v47 = (void *)*MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(__p, "sourceIndex + elementCount <= Length");
      std::string::basic_string[abi:ne180100]<0>(&v102, "copyElementsFromArrayToIndex");
      std::string::basic_string[abi:ne180100]<0>(&v101, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
      health::FormatString<>((std::string *)"Copy would overflow source.", &v100);
      health::_HDAssertImplementation<std::out_of_range>(v47, (uint64_t)__p, (uint64_t)&v102, (uint64_t)&v101, 80, (uint64_t)&v100);
    }
    std::string v48 = &v95[24 * *(unsigned __int16 *)&v95[408] - 192];
    long long v49 = v48[9];
    v92[8] = v48[8];
    v92[9] = v49;
    long long v50 = v48[11];
    v92[10] = v48[10];
    v92[11] = v50;
    long long v51 = v48[5];
    v92[4] = v48[4];
    v92[5] = v51;
    long long v52 = v48[7];
    v92[6] = v48[6];
    v92[7] = v52;
    long long v53 = v48[1];
    v92[0] = *v48;
    v92[1] = v53;
    long long v54 = v48[3];
    void v92[2] = v48[2];
    v92[3] = v54;
    *(_WORD *)&v95[408] -= 8;
    WORD4(v92[25]) = 8;
    unint64_t v55 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
    std::string v56 = (void *)health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v55, 374);
    uint64_t v58 = v57;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>((uint64_t)v55, (uint64_t)v56, v57, (uint64_t)v92);
    *(void *)&long long v102 = v56;
    *((void *)&v102 + 1) = v58;
    long long v98 = v102;
    uint64_t v59 = *(void *)(a1 + 16);
    if (v94 != *(_OWORD *)v59)
    {
      long long v87 = 0u;
      long long v88 = 0u;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      *(_OWORD *)std::string __p = 0u;
      long long v66 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      memset(v89, 0, sizeof(v89));
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v59 + 24), v94, *((uint64_t *)&v94 + 1), (uint64_t)__p);
      long long v90 = v102;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v94, *((uint64_t *)&v94 + 1), (uint64_t)__p);
    }
    __p[0] = *(void **)&v92[0];
    __p[1] = v56;
    *(void *)&long long v66 = v58;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, (__n128 *)__p, v11 + 1);
    ++*(_WORD *)(a4 + 408);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v64, *((uint64_t *)&v64 + 1), (uint64_t)v95);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    if (*a5 <= *(double *)v92)
    {
      std::string v60 = (uint64_t *)&v64;
      unint64_t v61 = v95;
    }
    else
    {
      std::string v60 = (uint64_t *)&v102;
      unint64_t v61 = v92;
    }
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(a1, v60, (uint64_t)v61, a5, a6);
  }
  int v25 = a2 + 1;
  unsigned int v26 = health::bplustree::InteriorNode<double,health::BlockPointer,17>::childForKey(a4, a5);
  uint64_t v27 = v26;
  long long v102 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v26)+ 8);
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_interiorChildAtIndex((uint64_t)v95, a1, v25, a4, v26);
  uint64_t v28 = (a2 + 2);
  uint64_t v29 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(a1, v28, &v102, v95, a5, a6);
  if (v29 > 1)
  {
    if (*(_WORD *)(a4 + 408) == 17) {
      return 2;
    }
    long long v101 = v102;
    memset(&v92[1], 0, 395);
    BYTE10(v92[25]) = v96;
    v92[0] = 0u;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v92, 0, (uint64_t)v95, *(unsigned __int16 *)&v95[408] - 8, 8);
    *(_WORD *)&v95[408] -= 8;
    WORD4(v92[25]) = 8;
    uint64_t v41 = *(health::BlockAccessFile::WriteTransaction **)(*(void *)(a1 + 16) + 24);
    uint64_t v42 = (void *)health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v41, 411);
    std::string::size_type v44 = v43;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t)v41, (uint64_t)v42, v43, (uint64_t)v92);
    v100.__r_.__value_.__r.__words[0] = (std::string::size_type)v42;
    v100.__r_.__value_.__l.__size_ = v44;
    __p[0] = *(void **)&v92[0];
    __p[1] = v42;
    *(void *)&long long v66 = v44;
    health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::insertElementAtIndex(a4, (__n128 *)__p, v27 + 1);
    ++*(_WORD *)(a4 + 408);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v101, *((uint64_t *)&v101 + 1), (uint64_t)v95);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
    if (*a5 <= *(double *)v92)
    {
      uint64_t v45 = (std::string *)&v101;
      std::string::size_type v46 = v95;
    }
    else
    {
      uint64_t v45 = &v100;
      std::string::size_type v46 = v92;
    }
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(a1, v28, v45, v46, a5, a6);
  }
  uint64_t v18 = v29;
  double v30 = *a5;
  if (v30 < *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v26))
  {
    double v31 = *a5;
    *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v26) = v31;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1], a4);
  }
  return v18;
}

void sub_1BCCE603C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (*(char *)(v16 - 177) < 0) {
    operator delete(*(void **)(v16 - 200));
  }
  if (*(char *)(v16 - 153) < 0) {
    operator delete(*(void **)(v16 - 176));
  }
  if (*(char *)(v16 - 121) < 0) {
    operator delete(*(void **)(v16 - 144));
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = 0;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  unint64_t v16 = 374;
  v13[0] = v14;
  v13[1] = v14;
  void v13[2] = 374;
  do
  {
    uint64_t v9 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v8);
    v12[0] = *(void *)v9;
    health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
    v12[0] = *(void *)(v9 + 8);
    health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
    LODWORD(v12[0]) = *(_DWORD *)(v9 + 16);
    health::SerializationBuffer::appendRaw<unsigned int>((uint64_t)v13, v12);
    ++v8;
  }
  while (v8 != 17);
  LOWORD(v12[0]) = *(_WORD *)(a4 + 408);
  health::SerializationBuffer::appendRaw<unsigned short>((uint64_t)v13, v12);
  v12[0] = *(void *)(a4 + 416);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(void *)(a4 + 424);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(void *)(a4 + 432);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  v12[0] = *(void *)(a4 + 440);
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v13, v12);
  if (v16 <= 0x3FF) {
    uint64_t v10 = v14;
  }
  else {
    uint64_t v10 = v15;
  }
  health::RawBuffer::RawBuffer(v12, v10, v16);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v12);
  uint64_t result = (uint64_t)v15;
  uint64_t v15 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCCE6240(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_setValueForKey(uint64_t a1, uint64_t *a2, uint64_t a3, double *a4, _OWORD *a5)
{
  if (!*(_WORD *)(a3 + 408))
  {
    uint64_t v10 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v26, "valueCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v25, "indexForKey");
    std::string::basic_string[abi:ne180100]<0>(v24, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Looking for index for key in an empty node.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v26, (uint64_t)v25, (uint64_t)v24, 72, (uint64_t)&__p);
  }
  unsigned int v11 = *(unsigned __int16 *)(a3 + 408) - 1;
  uint64_t v12 = 1;
  while (1)
  {
    double v13 = *a4;
    if (v13 > *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v11))break; {
    double v14 = *a4;
    }
    uint64_t v15 = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v11);
    int v16 = (unsigned __int16)v11;
    if (v14 == *v15)
    {
      *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, (unsigned __int16)v11)+ _Block_object_dispose(&a9, 8) = *a5;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a2, a2[1], a3);
      return 1;
    }
    --v11;
    if (!v16)
    {
      uint64_t v12 = 0;
      LOWORD(v11) = 0;
      break;
    }
  }
  if (*(_WORD *)(a3 + 408) == 17)
  {
    if (*a4 >= *(double *)a3)
    {
      if (*a4 <= *(double *)(a3 + 384)) {
        return 2;
      }
      else {
        return 4;
      }
    }
    else
    {
      return 3;
    }
  }
  else
  {
    unint64_t v18 = v12 + (unsigned __int16)v11;
    double v19 = *a4;
    long long v22 = *a5;
    if (v18 >= 0x11)
    {
      long long v20 = (void *)*MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v26, "index < Length");
      std::string::basic_string[abi:ne180100]<0>(v25, "insertElementAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v24, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
      health::FormatString<>((std::string *)"Index out of bounds.", &__p);
      health::_HDAssertImplementation<std::out_of_range>(v20, (uint64_t)v26, (uint64_t)v25, (uint64_t)v24, 57, (uint64_t)&__p);
    }
    uint64_t v21 = (double *)(a3 + 24 * v18);
    memmove(v21 + 3, v21, 24 * (16 - v18));
    *uint64_t v21 = v19;
    *(_OWORD *)(v21 + 1) = v22;
    ++*(_WORD *)(a3 + 408);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a2, a2[1], a3);
    return 0;
  }
}

void sub_1BCCE655C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  _Unwind_Resume(exception_object);
}

double *health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_interiorChildAtIndex(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5)
{
  if (*(unsigned __int16 *)(a4 + 408) <= a5)
  {
    uint64_t v9 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v35, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v34, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v33, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v32);
    health::_HDAssertImplementation<health::btree_access_error>(v9, (uint64_t)v35, (uint64_t)v34, (uint64_t)v33, 137, (uint64_t)&v32);
  }
  if (a3 >= 64)
  {
    uint64_t v10 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v31, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v30, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v29, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &__p);
    health::_HDAssertImplementation<health::btree_access_error>(v10, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29, 138, (uint64_t)&__p);
  }
  uint64_t v11 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5);
  uint64_t v12 = *(void *)(v11 + 8);
  uint64_t v13 = *(void *)(v11 + 16);
  uint64_t v14 = *(void *)(a2 + 16);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 28_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 36_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 395) = 0u;
  uint64_t result = (double *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v14 + 24), v12, v13, a1);
  if (*(_WORD *)(a1 + 408))
  {
    double v16 = *(double *)a1;
    uint64_t result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5);
    if (v16 < *result)
    {
      uint64_t v17 = (void *)*MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v27, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v26, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v24);
      health::_HDAssertImplementation<health::btree_access_error>(v17, (uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 144, (uint64_t)&v24);
    }
    if (*(unsigned __int16 *)(a4 + 408) - 1 > (int)a5)
    {
      double v18 = *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a1, *(unsigned __int16 *)(a1 + 408) - 1);
      uint64_t result = (double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5 + 1);
      if (v18 >= *result)
      {
        double v19 = (void *)*MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(v23, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v22, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v20);
        health::_HDAssertImplementation<health::btree_access_error>(v19, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 146, (uint64_t)&v20);
      }
    }
  }
  return result;
}

void sub_1BCCE69A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<BOOL ()(health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1> &)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::~__func()
{
}

void *std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F171D550;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F171D550;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::operator()(uint64_t a1, health::DataStore::WriteTransaction *a2)
{
  long long v6 = 0u;
  long long v7 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v11 = a2;
  uint64_t v12 = a2;
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)(a1 + 8), 0);
  v15[0] = 0;
  v15[1] = 0;
  _OWORD v15[2] = (char *)v12 + 80;
  v15[3] = (char *)v12 + 80;
  if (v6 != 0)
  {
    long long v13 = v6;
    uint64_t v14 = v15;
    memset(__src, 0, 411);
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>((uint64_t *)v12 + 10, v6, *((uint64_t *)&v6 + 1), (uint64_t)__src);
    memcpy(__dst, __src, sizeof(__dst));
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::deleteAllSamples(void)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>((uint64_t)&v13, 0, (unint64_t *)&v13, (uint64_t)__dst);
  }
  uint64_t v8 = 0;
  health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::_updateHistoryRoot((uint64_t)v5);
  health::DataStore::WriteTransaction::removeObjectWithIdentifier(a2, *(ObjectIdentifier **)(a1 + 8));
  return 1;
}

uint64_t std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1},std::allocator<void health::DataStore::deleteSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier const&)::{lambda(health::DataStore::WriteTransaction &)#1}>,BOOL ()(health::DataStore::WriteTransaction &)>::target_type()
{
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::deleteAllSamples(void)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(uint64_t a1, int a2, unint64_t *a3, uint64_t a4)
{
  if (*(_WORD *)(a4 + 408))
  {
    unint64_t v8 = 0;
    uint64_t v9 = (a2 + 1);
    do
    {
      if (*(unsigned char *)(a4 + 410))
      {
        uint64_t v10 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v8);
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_removeLeaf<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::deleteAllSamples(void)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(a1, (uint64_t *)(v10 + 8));
      }
      else
      {
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_interiorChildAtIndex((uint64_t)__src, a1, a2, a4, (unsigned __int16)v8);
        uint64_t v11 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v8)+ 8;
        memcpy(v13, __src, sizeof(v13));
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_removeSubtree<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::deleteAllSamples(void)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(a1, v9, v11, v13);
      }
      ++v8;
    }
    while (v8 < *(unsigned __int16 *)(a4 + 408));
  }
  return health::BlockAccessFile::WriteTransaction::freeBlock(*(void *)(*(void *)(a1 + 16) + 24), *a3, a3[1]);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<double,_HDRawQuantitySampleValueV1>>::_removeLeaf<health::DataStore::MutableSampleHistory<QuantitySampleValueBehaviorV1>::deleteAllSamples(void)::{lambda(double const&,_HDRawQuantitySampleValueV1 const&)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  memset(v9, 0, 410);
  long long v10 = 0u;
  long long v11 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(uint64_t **)(v4 + 24), *a2, a2[1], (uint64_t)v9);
  if (WORD4(v9[25]))
  {
    unint64_t v5 = 0;
    do
    {
      health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v9, v5);
      health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v9, v5++);
    }
    while (v5 < WORD4(v9[25]));
  }
  long long v6 = *(unint64_t **)(a1 + 16);
  unint64_t v7 = v11;
  if (v11 != *(_OWORD *)v6)
  {
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    memset(v36, 0, sizeof(v36));
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>((uint64_t *)v6[3], v11, *((uint64_t *)&v11 + 1), (uint64_t)&v12);
    long long v37 = v10;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v11, *((uint64_t *)&v11 + 1), (uint64_t)&v12);
    long long v6 = *(unint64_t **)(a1 + 16);
    unint64_t v7 = *v6;
  }
  if (v10 != __PAIR128__(v6[1], v7))
  {
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    memset(v36, 0, sizeof(v36));
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>((uint64_t *)v6[3], v10, *((uint64_t *)&v10 + 1), (uint64_t)&v12);
    long long v38 = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v10, *((uint64_t *)&v10 + 1), (uint64_t)&v12);
    long long v6 = *(unint64_t **)(a1 + 16);
  }
  return health::BlockAccessFile::WriteTransaction::freeBlock(v6[3], *a2, a2[1]);
}

void *std::__function::__value_func<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<_HDRawQuantitySampleValueV1 ()(double,_HDRawQuantitySampleValueV1)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1BCCE74A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1BCCE77B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(double const&,double const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1BCCE81D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCCE8EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__48(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__48(uint64_t a1)
{
}

void sub_1BCCE9ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose((const void *)(v11 - 128), 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__49(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__49(uint64_t a1)
{
}

void sub_1BCCEC140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v12 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1BCCEC504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCloudSyncCodableRegistryReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 0x14u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 32;
        goto LABEL_27;
      case 0x15u:
        *(unsigned char *)(a1 + 76) |= 1u;
        uint64_t v21 = *v3;
        unint64_t v22 = *(void *)(a2 + v21);
        if (v22 <= 0xFFFFFFFFFFFFFFF7 && v22 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v23 = *(void *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v22 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v23 = 0;
        }
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = v23;
        goto LABEL_42;
      case 0x16u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 40;
LABEL_27:
        long long v24 = *(void **)(a1 + v19);
        *(void *)(a1 + v19) = v18;

        goto LABEL_42;
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
LABEL_33:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_42;
      case 0x1Eu:
        long long v20 = objc_alloc_init(HDCloudSyncCodableProfileIdentifier);
        uint64_t v25 = 48;
        goto LABEL_30;
      case 0x1Fu:
        long long v20 = objc_alloc_init(HDCloudSyncCodableProfileIdentifier);
        uint64_t v25 = 56;
LABEL_30:
        objc_storeStrong((id *)(a1 + v25), v20);
        if (PBReaderPlaceMark()
          && (HDCloudSyncCodableProfileIdentifierReadFrom((uint64_t)v20, a2) & 1) != 0)
        {
LABEL_40:
          PBReaderRecallMark();
LABEL_41:

LABEL_42:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_58:

        return 0;
      default:
        switch((v10 >> 3))
        {
          case 1u:
            PBReaderReadString();
            long long v20 = (HDCloudSyncCodableProfileIdentifier *)objc_claimAutoreleasedReturnValue();
            if (v20) {
              [(id)a1 addDisabledOwnerIdentifiers:v20];
            }
            goto LABEL_41;
          case 2u:
            long long v20 = objc_alloc_init(HDCloudSyncCodableRegisteredStore);
            [(id)a1 addStores:v20];
            if (!PBReaderPlaceMark() || !HDCloudSyncCodableRegisteredStoreReadFrom((uint64_t)v20, a2)) {
              goto LABEL_58;
            }
            goto LABEL_40;
          case 3u:
            long long v20 = objc_alloc_init(HDCodableSyncIdentity);
            [(id)a1 addDisabledSyncIdentities:v20];
            if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v20, a2)) {
              goto LABEL_40;
            }
            goto LABEL_58;
          case 0xAu:
            char v27 = 0;
            unsigned int v28 = 0;
            uint64_t v29 = 0;
            *(unsigned char *)(a1 + 76) |= 2u;
            break;
          default:
            goto LABEL_33;
        }
        while (2)
        {
          uint64_t v30 = *v3;
          uint64_t v31 = *(void *)(a2 + v30);
          unint64_t v32 = v31 + 1;
          if (v31 == -1 || v32 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v33 = *(unsigned char *)(*(void *)(a2 + *v7) + v31);
            *(void *)(a2 + v30) = v32;
            v29 |= (unint64_t)(v33 & 0x7F) << v27;
            if (v33 < 0)
            {
              v27 += 7;
              BOOL v15 = v28++ >= 9;
              if (v15)
              {
                uint64_t v29 = 0;
                goto LABEL_54;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v29 = 0;
        }
LABEL_54:
        *(unsigned char *)(a1 + 72) = v29 != 0;
        goto LABEL_42;
    }
  }
}

BOOL HDCodableMedicalCodingReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 16;
          goto LABEL_25;
        case 2u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 24;
          goto LABEL_25;
        case 3u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 8;
          goto LABEL_25;
        case 4u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 32;
LABEL_25:
          uint64_t v19 = *(void **)(a1 + v18);
          *(void *)(a1 + v1_Block_object_dispose(&a9, 8) = v17;

          goto LABEL_26;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0;
          }
LABEL_26:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          break;
      }
    }
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCloudSyncCodableAttachmentManagementRecordReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = *(void **)(a1 + 8);
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = v17;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCCF55A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__50(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__50(uint64_t a1)
{
}

void sub_1BCCF5798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableGeneratedObjectCollectionReadFrom(void *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 273)
      {
        uint64_t v17 = objc_alloc_init(HDCodableMedicationDoseEvent);
        [a1 addMedicationDoseEvent:v17];
        if (!PBReaderPlaceMark() || (HDCodableMedicationDoseEventReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCCFCA6C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableMedicalIDDataReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    unint64_t v18 = v10 >> 3;
    if ((int)(v10 >> 3) <= 99)
    {
      switch(v18)
      {
        case 1:
          uint64_t v36 = PBReaderReadData();
          uint64_t v37 = 328;
LABEL_188:
          char v128 = *(void **)(a1 + v37);
          *(void *)(a1 + v37) = v36;

          break;
        case 2:
          *(void *)(a1 + 404) |= 0x200uLL;
          uint64_t v129 = *v3;
          unint64_t v130 = *(void *)(a2 + v129);
          if (v130 <= 0xFFFFFFFFFFFFFFF7 && v130 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v130);
            *(void *)(a2 + v129) = v130 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v35 = 0;
          }
          uint64_t v136 = 80;
LABEL_283:
          *(void *)(a1 + v136) = v35;
          break;
        case 3:
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          *(void *)(a1 + 404) |= 0x100000000uLL;
          while (1)
          {
            uint64_t v29 = *v3;
            uint64_t v30 = *(void *)(a2 + v29);
            unint64_t v31 = v30 + 1;
            if (v30 == -1 || v31 > *(void *)(a2 + *v4)) {
              break;
            }
            char v32 = *(unsigned char *)(*(void *)(a2 + *v7) + v30);
            *(void *)(a2 + v29) = v31;
            v28 |= (unint64_t)(v32 & 0x7F) << v26;
            if ((v32 & 0x80) == 0) {
              goto LABEL_199;
            }
            v26 += 7;
            BOOL v15 = v27++ >= 9;
            if (v15)
            {
              LODWORD(v2_Block_object_dispose(&a9, 8) = 0;
              goto LABEL_201;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_199:
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v2_Block_object_dispose(&a9, 8) = 0;
          }
LABEL_201:
          uint64_t v134 = 384;
LABEL_206:
          *(_DWORD *)(a1 + v134) = v28;
          break;
        default:
LABEL_192:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          break;
      }
      goto LABEL_284;
    }
    switch((int)v18)
    {
      case 100:
        char v19 = 0;
        unsigned int v20 = 0;
        uint64_t v21 = 0;
        *(void *)(a1 + 404) |= 0x200000000uLL;
        while (2)
        {
          uint64_t v22 = *v3;
          uint64_t v23 = *(void *)(a2 + v22);
          unint64_t v24 = v23 + 1;
          if (v23 == -1 || v24 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v25 = *(unsigned char *)(*(void *)(a2 + *v7) + v23);
            *(void *)(a2 + v22) = v24;
            v21 |= (unint64_t)(v25 & 0x7F) << v19;
            if (v25 < 0)
            {
              v19 += 7;
              BOOL v15 = v20++ >= 9;
              if (v15)
              {
                uint64_t v21 = 0;
                goto LABEL_197;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_197:
        BOOL v132 = v21 != 0;
        uint64_t v133 = 400;
        goto LABEL_215;
      case 101:
        *(void *)(a1 + 404) |= 0x2000uLL;
        uint64_t v33 = *v3;
        unint64_t v34 = *(void *)(a2 + v33);
        if (v34 <= 0xFFFFFFFFFFFFFFF7 && v34 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v34);
          *(void *)(a2 + v33) = v34 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 112;
        goto LABEL_283;
      case 102:
        uint64_t v36 = PBReaderReadData();
        uint64_t v37 = 368;
        goto LABEL_188;
      case 103:
        *(void *)(a1 + 404) |= 0x800000uLL;
        uint64_t v38 = *v3;
        unint64_t v39 = *(void *)(a2 + v38);
        if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v39);
          *(void *)(a2 + v3_Block_object_dispose(&a9, 8) = v39 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 192;
        goto LABEL_283;
      case 104:
        uint64_t v36 = PBReaderReadString();
        uint64_t v37 = 360;
        goto LABEL_188;
      case 105:
        *(void *)(a1 + 404) |= 0x400000uLL;
        uint64_t v40 = *v3;
        unint64_t v41 = *(void *)(a2 + v40);
        if (v41 <= 0xFFFFFFFFFFFFFFF7 && v41 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v41);
          *(void *)(a2 + v40) = v41 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 184;
        goto LABEL_283;
      case 106:
        uint64_t v42 = objc_alloc_init(HDCodableDateComponents);
        objc_storeStrong((id *)(a1 + 304), v42);
        if (!PBReaderPlaceMark() || (HDCodableDateComponentsReadFrom((uint64_t)v42, a2) & 1) == 0) {
          goto LABEL_286;
        }
        goto LABEL_173;
      case 107:
        *(void *)(a1 + 404) |= 0x800uLL;
        uint64_t v43 = *v3;
        unint64_t v44 = *(void *)(a2 + v43);
        if (v44 <= 0xFFFFFFFFFFFFFFF7 && v44 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v44);
          *(void *)(a2 + v43) = v44 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 96;
        goto LABEL_283;
      case 108:
        uint64_t v42 = objc_alloc_init(HDCodableQuantity);
        uint64_t v45 = 312;
        goto LABEL_59;
      case 109:
        *(void *)(a1 + 404) |= 0x1000uLL;
        uint64_t v46 = *v3;
        unint64_t v47 = *(void *)(a2 + v46);
        if (v47 <= 0xFFFFFFFFFFFFFFF7 && v47 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v47);
          *(void *)(a2 + v46) = v47 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 104;
        goto LABEL_283;
      case 110:
        uint64_t v42 = objc_alloc_init(HDCodableQuantity);
        uint64_t v45 = 392;
LABEL_59:
        objc_storeStrong((id *)(a1 + v45), v42);
        if (!PBReaderPlaceMark() || (HDCodableQuantityReadFrom((uint64_t)v42, a2) & 1) == 0) {
          goto LABEL_286;
        }
        goto LABEL_173;
      case 111:
        *(void *)(a1 + 404) |= 0x40000000uLL;
        uint64_t v48 = *v3;
        unint64_t v49 = *(void *)(a2 + v48);
        if (v49 <= 0xFFFFFFFFFFFFFFF7 && v49 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v49);
          *(void *)(a2 + v4_Block_object_dispose(&a9, 8) = v49 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 248;
        goto LABEL_283;
      case 112:
        char v50 = 0;
        unsigned int v51 = 0;
        uint64_t v28 = 0;
        *(void *)(a1 + 404) |= 0x80000000uLL;
        while (2)
        {
          uint64_t v52 = *v3;
          uint64_t v53 = *(void *)(a2 + v52);
          unint64_t v54 = v53 + 1;
          if (v53 == -1 || v54 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v55 = *(unsigned char *)(*(void *)(a2 + *v7) + v53);
            *(void *)(a2 + v52) = v54;
            v28 |= (unint64_t)(v55 & 0x7F) << v50;
            if (v55 < 0)
            {
              v50 += 7;
              BOOL v15 = v51++ >= 9;
              if (v15)
              {
                LODWORD(v2_Block_object_dispose(&a9, 8) = 0;
                goto LABEL_205;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v2_Block_object_dispose(&a9, 8) = 0;
        }
LABEL_205:
        uint64_t v134 = 272;
        goto LABEL_206;
      case 113:
        *(void *)(a1 + 404) |= 0x10uLL;
        uint64_t v56 = *v3;
        unint64_t v57 = *(void *)(a2 + v56);
        if (v57 <= 0xFFFFFFFFFFFFFFF7 && v57 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v57);
          *(void *)(a2 + v56) = v57 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 40;
        goto LABEL_283;
      case 114:
        char v58 = 0;
        unsigned int v59 = 0;
        uint64_t v60 = 0;
        *(void *)(a1 + 404) |= 0x4000uLL;
        while (2)
        {
          uint64_t v61 = *v3;
          uint64_t v62 = *(void *)(a2 + v61);
          unint64_t v63 = v62 + 1;
          if (v62 == -1 || v63 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v64 = *(unsigned char *)(*(void *)(a2 + *v7) + v62);
            *(void *)(a2 + v61) = v63;
            v60 |= (unint64_t)(v64 & 0x7F) << v58;
            if (v64 < 0)
            {
              v58 += 7;
              BOOL v15 = v59++ >= 9;
              if (v15)
              {
                uint64_t v60 = 0;
                goto LABEL_210;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v60 = 0;
        }
LABEL_210:
        uint64_t v135 = 120;
        goto LABEL_228;
      case 115:
        *(void *)(a1 + 404) |= 0x8000uLL;
        uint64_t v65 = *v3;
        unint64_t v66 = *(void *)(a2 + v65);
        if (v66 <= 0xFFFFFFFFFFFFFFF7 && v66 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v66);
          *(void *)(a2 + v65) = v66 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 128;
        goto LABEL_283;
      case 116:
        uint64_t v42 = objc_alloc_init(HDCodableEmergencyContact);
        [(id)a1 addEmergencyContacts:v42];
        if (!PBReaderPlaceMark() || !HDCodableEmergencyContactReadFrom((uint64_t)v42, a2)) {
          goto LABEL_286;
        }
        goto LABEL_173;
      case 117:
        *(void *)(a1 + 404) |= 0x400uLL;
        uint64_t v67 = *v3;
        unint64_t v68 = *(void *)(a2 + v67);
        if (v68 <= 0xFFFFFFFFFFFFFFF7 && v68 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v68);
          *(void *)(a2 + v67) = v68 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 88;
        goto LABEL_283;
      case 118:
        uint64_t v42 = objc_alloc_init(HDCodableClinicalContact);
        [(id)a1 addClinicalContacts:v42];
        if (!PBReaderPlaceMark() || !HDCodableClinicalContactReadFrom((uint64_t)v42, a2)) {
          goto LABEL_286;
        }
        goto LABEL_173;
      case 119:
        *(void *)(a1 + 404) |= 0x20uLL;
        uint64_t v69 = *v3;
        unint64_t v70 = *(void *)(a2 + v69);
        if (v70 <= 0xFFFFFFFFFFFFFFF7 && v70 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v70);
          *(void *)(a2 + v69) = v70 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 48;
        goto LABEL_283;
      case 120:
        uint64_t v36 = PBReaderReadString();
        uint64_t v37 = 320;
        goto LABEL_188;
      case 121:
        *(void *)(a1 + 404) |= 0x10000uLL;
        uint64_t v71 = *v3;
        unint64_t v72 = *(void *)(a2 + v71);
        if (v72 <= 0xFFFFFFFFFFFFFFF7 && v72 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v72);
          *(void *)(a2 + v71) = v72 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 136;
        goto LABEL_283;
      case 122:
        uint64_t v36 = PBReaderReadString();
        uint64_t v37 = 336;
        goto LABEL_188;
      case 123:
        *(void *)(a1 + 404) |= 0x20000uLL;
        uint64_t v73 = *v3;
        unint64_t v74 = *(void *)(a2 + v73);
        if (v74 <= 0xFFFFFFFFFFFFFFF7 && v74 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v74);
          *(void *)(a2 + v73) = v74 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 144;
        goto LABEL_283;
      case 124:
        uint64_t v36 = PBReaderReadString();
        uint64_t v37 = 264;
        goto LABEL_188;
      case 125:
        *(void *)(a1 + 404) |= 8uLL;
        uint64_t v75 = *v3;
        unint64_t v76 = *(void *)(a2 + v75);
        if (v76 <= 0xFFFFFFFFFFFFFFF7 && v76 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v76);
          *(void *)(a2 + v75) = v76 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 32;
        goto LABEL_283;
      case 126:
        uint64_t v36 = PBReaderReadString();
        uint64_t v37 = 344;
        goto LABEL_188;
      case 127:
        *(void *)(a1 + 404) |= 0x40000uLL;
        uint64_t v77 = *v3;
        unint64_t v78 = *(void *)(a2 + v77);
        if (v78 <= 0xFFFFFFFFFFFFFFF7 && v78 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v78);
          *(void *)(a2 + v77) = v78 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 152;
        goto LABEL_283;
      case 128:
        char v79 = 0;
        unsigned int v80 = 0;
        uint64_t v81 = 0;
        *(void *)(a1 + 404) |= 0x400000000uLL;
        while (2)
        {
          uint64_t v82 = *v3;
          uint64_t v83 = *(void *)(a2 + v82);
          unint64_t v84 = v83 + 1;
          if (v83 == -1 || v84 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v85 = *(unsigned char *)(*(void *)(a2 + *v7) + v83);
            *(void *)(a2 + v82) = v84;
            v81 |= (unint64_t)(v85 & 0x7F) << v79;
            if (v85 < 0)
            {
              v79 += 7;
              BOOL v15 = v80++ >= 9;
              if (v15)
              {
                uint64_t v81 = 0;
                goto LABEL_214;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v81 = 0;
        }
LABEL_214:
        BOOL v132 = v81 != 0;
        uint64_t v133 = 401;
LABEL_215:
        *(unsigned char *)(a1 + v133) = v132;
        goto LABEL_284;
      case 129:
        *(void *)(a1 + 404) |= 0x20000000uLL;
        uint64_t v86 = *v3;
        unint64_t v87 = *(void *)(a2 + v86);
        if (v87 <= 0xFFFFFFFFFFFFFFF7 && v87 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v87);
          *(void *)(a2 + v86) = v87 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 240;
        goto LABEL_283;
      case 130:
        uint64_t v36 = PBReaderReadString();
        uint64_t v37 = 376;
        goto LABEL_188;
      case 131:
        *(void *)(a1 + 404) |= 0x10000000uLL;
        uint64_t v88 = *v3;
        unint64_t v89 = *(void *)(a2 + v88);
        if (v89 <= 0xFFFFFFFFFFFFFFF7 && v89 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v89);
          *(void *)(a2 + v8_Block_object_dispose(&a9, 8) = v89 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 232;
        goto LABEL_283;
      case 132:
        *(void *)(a1 + 404) |= 0x4000000uLL;
        uint64_t v90 = *v3;
        unint64_t v91 = *(void *)(a2 + v90);
        if (v91 <= 0xFFFFFFFFFFFFFFF7 && v91 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v91);
          *(void *)(a2 + v90) = v91 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 216;
        goto LABEL_283;
      case 133:
        *(void *)(a1 + 404) |= 0x8000000uLL;
        uint64_t v92 = *v3;
        unint64_t v93 = *(void *)(a2 + v92);
        if (v93 <= 0xFFFFFFFFFFFFFFF7 && v93 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v93);
          *(void *)(a2 + v92) = v93 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 224;
        goto LABEL_283;
      case 136:
        *(void *)(a1 + 404) |= 0x1000000uLL;
        uint64_t v94 = *v3;
        unint64_t v95 = *(void *)(a2 + v94);
        if (v95 <= 0xFFFFFFFFFFFFFFF7 && v95 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v95);
          *(void *)(a2 + v94) = v95 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 200;
        goto LABEL_283;
      case 137:
        *(void *)(a1 + 404) |= 0x2000000uLL;
        uint64_t v96 = *v3;
        unint64_t v97 = *(void *)(a2 + v96);
        if (v97 <= 0xFFFFFFFFFFFFFFF7 && v97 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v97);
          *(void *)(a2 + v96) = v97 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 208;
        goto LABEL_283;
      case 138:
        uint64_t v42 = objc_alloc_init(HDCodableMedicalIDMedication);
        [(id)a1 addMedicationsList:v42];
        if (!PBReaderPlaceMark() || (HDCodableMedicalIDMedicationReadFrom((uint64_t)v42, a2) & 1) == 0) {
          goto LABEL_286;
        }
        goto LABEL_173;
      case 139:
        *(void *)(a1 + 404) |= 0x80000uLL;
        uint64_t v98 = *v3;
        unint64_t v99 = *(void *)(a2 + v98);
        if (v99 <= 0xFFFFFFFFFFFFFFF7 && v99 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v99);
          *(void *)(a2 + v9_Block_object_dispose(&a9, 8) = v99 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 160;
        goto LABEL_283;
      case 140:
        char v100 = 0;
        unsigned int v101 = 0;
        uint64_t v60 = 0;
        *(void *)(a1 + 404) |= 0x100000uLL;
        while (2)
        {
          uint64_t v102 = *v3;
          uint64_t v103 = *(void *)(a2 + v102);
          unint64_t v104 = v103 + 1;
          if (v103 == -1 || v104 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v105 = *(unsigned char *)(*(void *)(a2 + *v7) + v103);
            *(void *)(a2 + v102) = v104;
            v60 |= (unint64_t)(v105 & 0x7F) << v100;
            if (v105 < 0)
            {
              v100 += 7;
              BOOL v15 = v101++ >= 9;
              if (v15)
              {
                uint64_t v60 = 0;
                goto LABEL_219;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v60 = 0;
        }
LABEL_219:
        uint64_t v135 = 168;
        goto LABEL_228;
      case 141:
        *(void *)(a1 + 404) |= 0x200000uLL;
        uint64_t v106 = *v3;
        unint64_t v107 = *(void *)(a2 + v106);
        if (v107 <= 0xFFFFFFFFFFFFFFF7 && v107 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v107);
          *(void *)(a2 + v106) = v107 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 176;
        goto LABEL_283;
      case 142:
        uint64_t v42 = objc_alloc_init(HDCodableMedicalIDAllergy);
        [(id)a1 addAllergiesList:v42];
        if (!PBReaderPlaceMark() || (HDCodableMedicalIDAllergyReadFrom((uint64_t)v42, a2) & 1) == 0) {
          goto LABEL_286;
        }
        goto LABEL_173;
      case 143:
        *(void *)(a1 + 404) |= 1uLL;
        uint64_t v108 = *v3;
        unint64_t v109 = *(void *)(a2 + v108);
        if (v109 <= 0xFFFFFFFFFFFFFFF7 && v109 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v109);
          *(void *)(a2 + v10_Block_object_dispose(&a9, 8) = v109 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 8;
        goto LABEL_283;
      case 144:
        char v110 = 0;
        unsigned int v111 = 0;
        uint64_t v60 = 0;
        *(void *)(a1 + 404) |= 2uLL;
        while (2)
        {
          uint64_t v112 = *v3;
          uint64_t v113 = *(void *)(a2 + v112);
          unint64_t v114 = v113 + 1;
          if (v113 == -1 || v114 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v115 = *(unsigned char *)(*(void *)(a2 + *v7) + v113);
            *(void *)(a2 + v112) = v114;
            v60 |= (unint64_t)(v115 & 0x7F) << v110;
            if (v115 < 0)
            {
              v110 += 7;
              BOOL v15 = v111++ >= 9;
              if (v15)
              {
                uint64_t v60 = 0;
                goto LABEL_223;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v60 = 0;
        }
LABEL_223:
        uint64_t v135 = 16;
        goto LABEL_228;
      case 145:
        *(void *)(a1 + 404) |= 4uLL;
        uint64_t v116 = *v3;
        unint64_t v117 = *(void *)(a2 + v116);
        if (v117 <= 0xFFFFFFFFFFFFFFF7 && v117 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v117);
          *(void *)(a2 + v116) = v117 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 24;
        goto LABEL_283;
      case 146:
        uint64_t v42 = objc_alloc_init(HDCodableMedicalIDCondition);
        [(id)a1 addConditionsList:v42];
        if PBReaderPlaceMark() && (HDCodableMedicalIDConditionReadFrom((uint64_t)v42, a2))
        {
LABEL_173:
          PBReaderRecallMark();

LABEL_284:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_286:

        return 0;
      case 147:
        *(void *)(a1 + 404) |= 0x40uLL;
        uint64_t v118 = *v3;
        unint64_t v119 = *(void *)(a2 + v118);
        if (v119 <= 0xFFFFFFFFFFFFFFF7 && v119 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v119);
          *(void *)(a2 + v11_Block_object_dispose(&a9, 8) = v119 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 56;
        goto LABEL_283;
      case 148:
        char v120 = 0;
        unsigned int v121 = 0;
        uint64_t v60 = 0;
        *(void *)(a1 + 404) |= 0x80uLL;
        while (2)
        {
          uint64_t v122 = *v3;
          uint64_t v123 = *(void *)(a2 + v122);
          unint64_t v124 = v123 + 1;
          if (v123 == -1 || v124 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v125 = *(unsigned char *)(*(void *)(a2 + *v7) + v123);
            *(void *)(a2 + v122) = v124;
            v60 |= (unint64_t)(v125 & 0x7F) << v120;
            if (v125 < 0)
            {
              v120 += 7;
              BOOL v15 = v121++ >= 9;
              if (v15)
              {
                uint64_t v60 = 0;
                goto LABEL_227;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v60 = 0;
        }
LABEL_227:
        uint64_t v135 = 64;
LABEL_228:
        *(void *)(a1 + v135) = v60;
        goto LABEL_284;
      case 149:
        *(void *)(a1 + 404) |= 0x100uLL;
        uint64_t v126 = *v3;
        unint64_t v127 = *(void *)(a2 + v126);
        if (v127 <= 0xFFFFFFFFFFFFFFF7 && v127 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v127);
          *(void *)(a2 + v126) = v127 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v35 = 0;
        }
        uint64_t v136 = 72;
        goto LABEL_283;
      default:
        goto LABEL_192;
    }
  }
}

uint64_t _HDAddFrozenAndExpectedSyncAnchorColumns(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E92B8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddSyncAnchorUpdateDateColumns(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E92D0 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddUniqueConstraintToSessionControllersTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E92E8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddAlarmEventsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"CREATE TABLE IF NOT EXISTS alarm_events (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, client_identifier TEXT NOT NULL, due_date REAL, due_date_components BLOB, event_identifier TEXT NOT NULL, UNIQUE(client_identifier, event_identifier), CHECK((due_date IS NULL AND due_date_components IS NOT NULL) OR (due_date IS NOT NULL AND due_date_components IS NULL)))", a4 error] ^ 1;

  return v6;
}

uint64_t _HDAddSourceOwnerBundleIdentifierAndDropSyncPrimary(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9318 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddSourceOrderModificationDate(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void v10[5] = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  v10[0] = @"CREATE TABLE datatype_source_order_new (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, data_type INTEGER NOT NULL, source INTEGER NOT NULL REFERENCES sources (ROWID) ON DELETE CASCADE, user_preferred INTEGER NOT NULL, provenance INTEGER NOT NULL, modification_date REAL NOT NULL);";
  uint64_t v6 = [NSString stringWithFormat:@"INSERT INTO datatype_source_order_new (data_type, source, user_preferred, provenance, modification_date) SELECT data_type, source, user_preferred, provenance, %lf FROM datatype_source_order ORDER BY ROWID ASC", CFAbsoluteTimeGetCurrent()];
  v10[1] = v6;
  void v10[2] = @"DROP TABLE datatype_source_order";
  void v10[3] = @"ALTER TABLE datatype_source_order_new RENAME TO datatype_source_order";
  v10[4] = @"CREATE INDEX datatype_source_order_data_type ON datatype_source_order (data_type, ROWID)";
  unint64_t v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:v10 count:5];

  char v8 = [v5 unprotectedDatabase];

  LODWORD(a4) = [v8 executeSQLStatements:v7 error:a4];
  return a4 ^ 1;
}

uint64_t _HDAddLatestActivityDateToWorkoutSessionsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9330 error:a4] ^ 1;

  return v6;
}

uint64_t _HDResetReceivedAnchorsForCategoryAndQuantitySamples(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = a2;
  unint64_t v7 = [a1 behavior];
  int v8 = [v7 isAppleWatch];

  if (v8)
  {
    unsigned int v9 = [v6 unprotectedDatabase];
    uint64_t v10 = [v9 executeSQLStatements:&unk_1F17E9348 error:a4] ^ 1;
  }
  else
  {
    uint64_t v10 = 0;
  }

  return v10;
}

uint64_t _HDAddEventOptionsToAlarmEventsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9300 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddQuantitySampleStatisticsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9360 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddMenstrualCycleDaySummaryTable()
{
  return 0;
}

uint64_t _HDUpdateActivityCacheTableForYukon(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9378 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddConceptIndexTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9390 error:a4] ^ 1;

  return v6;
}

uint64_t _HDRemoveDuplicatedHeartRateContextMetadata(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"DELETE FROM metadata_values WHERE key_id=(SELECT rowid FROM metadata_keys WHERE key='HKMetadataKeyHeartRateMotionContext') AND (EXISTS (SELECT * FROM metadata_values mvprivate WHERE mvprivate.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateHeartRateContext') AND mvprivate.object_id=metadata_values.object_id))" error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddLocaleToMedicalRecords(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"ALTER TABLE medical_records ADD COLUMN locale TEXT" error:a4] ^ 1;

  return v6;
}

uint64_t _HDUpdateFitnessFriendActivitySnapshotsTableForYukon(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E93A8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDUpdateDiagnosticTestReportColumnNames(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = objc_msgSend(v5, "executeUncachedSQL:error:", @"ALTER TABLE diagnostic_test_report_samples RENAME COLUMN status TO status_coding;",
                       a4) ^ 1;

  return v6;
}

uint64_t _HDUpdateFitnessFriendWorkoutTableForYukon(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E93C0 error:a4] ^ 1;

  return v6;
}

uint64_t _HDUpdateConceptIndexTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E93D8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDUpdateVaccinationRecordColumnNames(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = objc_msgSend(v5, "executeUncachedSQL:error:", @"ALTER TABLE vaccination_record_samples RENAME COLUMN body_site_coding TO body_site_codings;",
                       a4) ^ 1;

  return v6;
}

uint64_t _HDMoveClinicalCredentialsToKeychain(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  uint64_t v6 = [v5 protectedDatabase];
  int v7 = [v6 executeSQLStatements:&unk_1F17E93F0 error:a4];

  if (v7)
  {
    int v8 = objc_alloc_init(HDLegacyClinicalCredentialManager);
    id v15 = 0;
    BOOL v9 = [(HDLegacyClinicalCredentialManager *)v8 deleteCredentialKeyFromKeychainWithError:&v15];
    id v10 = v15;
    if (!v9)
    {
      _HKInitializeLogging();
      uint64_t v11 = *MEMORY[0x1E4F29F18];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F18], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v17 = v10;
        _os_log_error_impl(&dword_1BCB7D000, v11, OS_LOG_TYPE_ERROR, "Failed to delete credential key from keychain during migration: %{public}@", buf, 0xCu);
      }
    }
    uint64_t v12 = [v5 protectedDatabase];
    uint64_t v13 = [v12 executeUncachedSQL:@"DROP TABLE clinical_credentials_old" error:a4] ^ 1;
  }
  else
  {
    uint64_t v13 = 1;
  }

  return v13;
}

uint64_t _HDRemoveMenstrualCycleDaySummaryTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 dumpSchemaWithError:a4];
  if (v6)
  {
    if ([MEMORY[0x1E4F65D18] databaseSchemas:v6 containTable:@"menstrual_cycle_day_summary_samples"])
    {
      uint64_t v7 = [v5 deleteDataEntitySubclassTable:@"menstrual_cycle_day_summary_samples" intermediateTables:&unk_1F17E9408 error:a4] ^ 1;
    }
    else
    {
      _HKInitializeLogging();
      int v8 = *MEMORY[0x1E4F29F18];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F18], OS_LOG_TYPE_INFO))
      {
        int v10 = 138412290;
        uint64_t v11 = @"menstrual_cycle_day_summary_samples";
        _os_log_impl(&dword_1BCB7D000, v8, OS_LOG_TYPE_INFO, "Skipping deletion from nonexistent table \"%@\"", (uint8_t *)&v10, 0xCu);
      }
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = 1;
  }

  return v7;
}

uint64_t _HDAddAllergyIntoleranceStatus(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"ALTER TABLE allergy_record_samples ADD COLUMN status_coding BLOB" error:a4] ^ 1;

  return v6;
}

uint64_t _HDResetClinicalAccountEntityLastSubmittedRow(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"UPDATE clinical_accounts SET last_submitted_rowid = NULL" error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddOntologyVersionToConceptIndex(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"ALTER TABLE concept_index ADD COLUMN ontology_version INTEGER NOT NULL DEFAULT 0" error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddDerivedFlagsToDataProvenances(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = a2;
  uint64_t v6 = [v5 protectedDatabase];
  int v7 = [v6 executeSQLStatements:&unk_1F17E9420 error:a4];

  if (v7)
  {
    int v8 = [v5 protectedDatabase];
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    void v12[2] = ___HDAddDerivedFlagsToDataProvenances_block_invoke;
    void v12[3] = &unk_1E62FA460;
    id v13 = v5;
    char v14 = @"SELECT (product_type LIKE 'Watch%%') FROM sources WHERE ROWID=? LIMIT 1";
    id v15 = @"UPDATE data_provenances SET derived_flags=? WHERE ROWID=?";
    int v9 = [v8 executeUncachedSQL:@"SELECT ROWID, source_id FROM data_provenances", a4, 0, v12 error bindingHandler enumerationHandler];

    uint64_t v10 = v9 ^ 1u;
  }
  else
  {
    uint64_t v10 = 1;
  }

  return v10;
}

uint64_t _HDAddCountryToMedicalRecord(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  LODWORD(a4) = [v5 executeSQLStatements:&unk_1F17E9438 error:a4];

  return a4 ^ 1;
}

uint64_t _HDAddMedicalRecordState(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"ALTER TABLE medical_records ADD COLUMN state INTEGER NOT NULL DEFAULT 0" error:a4] ^ 1;

  return v6;
}

uint64_t _HDWipeWorkoutAnchors(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = objc_msgSend(v5, "executeUncachedSQL:error:", @"DELETE FROM sync_anchors WHERE schema = 'main' AND type = 5;",
                       a4) ^ 1;

  return v6;
}

void sub_1BCD07360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  _Block_object_dispose((const void *)(v15 - 96), 8);
  _Unwind_Resume(a1);
}

id HDSimpleGraphAttributeEntityPredicateForNodeID(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v4 = [NSNumber numberWithLongLong:a1];
  id v5 = [v3 predicateWithProperty:@"node_id" value:v4 comparisonType:a2];

  return v5;
}

uint64_t HDCodableUserDomainConceptLinkReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    int v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        uint64_t v23 = PBReaderReadData();
        unint64_t v24 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v23;
      }
      else if ((v10 >> 3) == 1)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 24) |= 1u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_31;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            uint64_t v19 = 0;
            goto LABEL_33;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_31:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v19 = 0;
        }
LABEL_33:
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = v19;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCD0C484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1BCD0DB8C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__51(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__51(uint64_t a1)
{
}

uint64_t HDCodableRoutinePredictedLocationsResponseReadFrom(void *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    int v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        char v17 = objc_alloc_init(HDCodableRoutinePredictedLocation);
        [a1 addPredictedLocationsOfInterest:v17];
        if (!PBReaderPlaceMark()
          || (HDCodableRoutinePredictedLocationReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCD113D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__52(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__52(uint64_t a1)
{
}

uint64_t HDCloudSyncCodableDeviceContextReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    int v7 = (int *)MEMORY[0x1E4F940B8];
    while (2)
    {
      if (!*(unsigned char *)(a2 + *v5))
      {
        char v8 = 0;
        unsigned int v9 = 0;
        unint64_t v10 = 0;
        while (1)
        {
          uint64_t v11 = *v3;
          uint64_t v12 = *(void *)(a2 + v11);
          unint64_t v13 = v12 + 1;
          if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
            break;
          }
          char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
          *(void *)(a2 + v11) = v13;
          v10 |= (unint64_t)(v14 & 0x7F) << v8;
          if ((v14 & 0x80) == 0) {
            goto LABEL_12;
          }
          v8 += 7;
          BOOL v15 = v9++ >= 9;
          if (v15)
          {
            unint64_t v10 = 0;
            int v16 = *(unsigned __int8 *)(a2 + *v5);
            goto LABEL_14;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        if (*(unsigned char *)(a2 + *v5)) {
          unint64_t v10 = 0;
        }
LABEL_14:
        if (v16) {
          BOOL v17 = 1;
        }
        else {
          BOOL v17 = (v10 & 7) == 4;
        }
        if (!v17)
        {
          switch((v10 >> 3))
          {
            case 1u:
              unsigned int v18 = objc_alloc_init(HDCodableSyncIdentity);
              objc_storeStrong((id *)(a1 + 48), v18);
              if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v18, a2))
              {
                PBReaderRecallMark();

                goto LABEL_44;
              }

              return 0;
            case 2u:
              char v20 = 0;
              unsigned int v21 = 0;
              uint64_t v22 = 0;
              *(unsigned char *)(a1 + 56) |= 2u;
              break;
            case 3u:
              uint64_t v27 = PBReaderReadString();
              uint64_t v28 = 24;
              goto LABEL_34;
            case 4u:
              uint64_t v27 = PBReaderReadString();
              uint64_t v28 = 32;
              goto LABEL_34;
            case 5u:
              uint64_t v27 = PBReaderReadString();
              uint64_t v28 = 40;
LABEL_34:
              uint64_t v29 = *(void **)(a1 + v28);
              *(void *)(a1 + v2_Block_object_dispose(&a9, 8) = v27;

              goto LABEL_44;
            case 6u:
              *(unsigned char *)(a1 + 56) |= 1u;
              uint64_t v30 = *v3;
              unint64_t v31 = *(void *)(a2 + v30);
              if (v31 <= 0xFFFFFFFFFFFFFFF7 && v31 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v32 = *(void *)(*(void *)(a2 + *v7) + v31);
                *(void *)(a2 + v30) = v31 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v32 = 0;
              }
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = v32;
              goto LABEL_44;
            default:
              uint64_t result = PBReaderSkipValueWithTag();
              if (!result) {
                return result;
              }
LABEL_44:
              if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
                return *(unsigned char *)(a2 + *v5) == 0;
              }
              continue;
          }
          while (1)
          {
            uint64_t v23 = *v3;
            uint64_t v24 = *(void *)(a2 + v23);
            unint64_t v25 = v24 + 1;
            if (v24 == -1 || v25 > *(void *)(a2 + *v4)) {
              break;
            }
            char v26 = *(unsigned char *)(*(void *)(a2 + *v7) + v24);
            *(void *)(a2 + v23) = v25;
            v22 |= (unint64_t)(v26 & 0x7F) << v20;
            if ((v26 & 0x80) == 0) {
              goto LABEL_39;
            }
            v20 += 7;
            BOOL v15 = v21++ >= 9;
            if (v15)
            {
              uint64_t v22 = 0;
              goto LABEL_41;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_39:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v22 = 0;
          }
LABEL_41:
          *(void *)(a1 + 16) = v22;
          goto LABEL_44;
        }
      }
      break;
    }
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCD13424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD143F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__53(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__53(uint64_t a1)
{
}

void sub_1BCD14D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__54(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__54(uint64_t a1)
{
}

void sub_1BCD150B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v14 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1BCD19914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__55(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__55(uint64_t a1)
{
}

void sub_1BCD19B9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL HDCodableEmergencyContactReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    int v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 8;
          goto LABEL_27;
        case 2u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 16;
          goto LABEL_27;
        case 3u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 24;
          goto LABEL_27;
        case 4u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 32;
          goto LABEL_27;
        case 5u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 40;
          goto LABEL_27;
        case 6u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 48;
LABEL_27:
          uint64_t v19 = *(void **)(a1 + v18);
          *(void *)(a1 + v1_Block_object_dispose(&a9, 8) = v17;

          goto LABEL_28;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0;
          }
LABEL_28:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          break;
      }
    }
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

id _EntityClasses()
{
  v2[112] = *MEMORY[0x1E4F143B8];
  v2[0] = objc_opt_class();
  v2[1] = objc_opt_class();
  v2[2] = objc_opt_class();
  v2[3] = objc_opt_class();
  void v2[4] = objc_opt_class();
  v2[5] = objc_opt_class();
  v2[6] = objc_opt_class();
  void v2[7] = objc_opt_class();
  v2[8] = objc_opt_class();
  v2[9] = objc_opt_class();
  v2[10] = objc_opt_class();
  v2[11] = objc_opt_class();
  v2[12] = objc_opt_class();
  v2[13] = objc_opt_class();
  v2[14] = objc_opt_class();
  v2[15] = objc_opt_class();
  v2[16] = objc_opt_class();
  v2[17] = objc_opt_class();
  v2[18] = objc_opt_class();
  v2[19] = objc_opt_class();
  v2[20] = objc_opt_class();
  v2[21] = objc_opt_class();
  v2[22] = objc_opt_class();
  v2[23] = objc_opt_class();
  v2[24] = objc_opt_class();
  v2[25] = objc_opt_class();
  v2[26] = objc_opt_class();
  v2[27] = objc_opt_class();
  v2[28] = objc_opt_class();
  v2[29] = objc_opt_class();
  v2[30] = objc_opt_class();
  v2[31] = objc_opt_class();
  v2[32] = objc_opt_class();
  v2[33] = objc_opt_class();
  v2[34] = objc_opt_class();
  v2[35] = objc_opt_class();
  v2[36] = objc_opt_class();
  v2[37] = objc_opt_class();
  v2[38] = objc_opt_class();
  v2[39] = objc_opt_class();
  v2[40] = objc_opt_class();
  v2[41] = objc_opt_class();
  v2[42] = objc_opt_class();
  v2[43] = objc_opt_class();
  v2[44] = objc_opt_class();
  v2[45] = objc_opt_class();
  v2[46] = objc_opt_class();
  v2[47] = objc_opt_class();
  v2[48] = objc_opt_class();
  v2[49] = objc_opt_class();
  v2[50] = objc_opt_class();
  v2[51] = objc_opt_class();
  v2[52] = objc_opt_class();
  v2[53] = objc_opt_class();
  v2[54] = objc_opt_class();
  v2[55] = objc_opt_class();
  v2[56] = objc_opt_class();
  v2[57] = objc_opt_class();
  v2[58] = objc_opt_class();
  v2[59] = objc_opt_class();
  v2[60] = objc_opt_class();
  v2[61] = objc_opt_class();
  v2[62] = objc_opt_class();
  v2[63] = objc_opt_class();
  v2[64] = objc_opt_class();
  v2[65] = objc_opt_class();
  v2[66] = objc_opt_class();
  v2[67] = objc_opt_class();
  v2[68] = objc_opt_class();
  v2[69] = objc_opt_class();
  v2[70] = objc_opt_class();
  v2[71] = objc_opt_class();
  v2[72] = objc_opt_class();
  v2[73] = objc_opt_class();
  v2[74] = objc_opt_class();
  v2[75] = objc_opt_class();
  v2[76] = objc_opt_class();
  v2[77] = objc_opt_class();
  v2[78] = objc_opt_class();
  v2[79] = objc_opt_class();
  v2[80] = objc_opt_class();
  v2[81] = objc_opt_class();
  v2[82] = objc_opt_class();
  v2[83] = objc_opt_class();
  v2[84] = objc_opt_class();
  v2[85] = objc_opt_class();
  v2[86] = objc_opt_class();
  v2[87] = objc_opt_class();
  v2[88] = objc_opt_class();
  v2[89] = objc_opt_class();
  v2[90] = objc_opt_class();
  v2[91] = objc_opt_class();
  v2[92] = objc_opt_class();
  v2[93] = objc_opt_class();
  v2[94] = objc_opt_class();
  v2[95] = objc_opt_class();
  v2[96] = objc_opt_class();
  v2[97] = objc_opt_class();
  v2[98] = objc_opt_class();
  v2[99] = objc_opt_class();
  v2[100] = objc_opt_class();
  v2[101] = objc_opt_class();
  v2[102] = objc_opt_class();
  v2[103] = objc_opt_class();
  v2[104] = objc_opt_class();
  v2[105] = objc_opt_class();
  v2[106] = objc_opt_class();
  v2[107] = objc_opt_class();
  v2[108] = objc_opt_class();
  v2[109] = objc_opt_class();
  v2[110] = objc_opt_class();
  v2[111] = objc_opt_class();
  unint64_t v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v2 count:112];

  return v0;
}

id _FutureEntityClasses()
{
  v2[1] = *MEMORY[0x1E4F143B8];
  v2[0] = objc_opt_class();
  unint64_t v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v2 count:1];

  return v0;
}

void health::_PageForEntry(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  int v12 = 0;
  uint64_t v11 = 0;
  health::VirtualFile::read<health::WriteAheadLog::LogEntryHeader>(*a1, *(void *)(a3 + 8), (uint64_t)v8);
  uint64_t v7 = *(void *)(a3 + 16);
  *a4 = a2;
  a4[1] = v7;
  operator new[]();
}

void sub_1BCD1F0B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  health::FilePage::~FilePage(v51);
  _Unwind_Resume(a1);
}

uint64_t health::FilePage::checksum(health::FilePage *this)
{
  uint64_t v2 = (health *)*((void *)this + 2);
  if (!v2) {
    uint64_t v2 = (health *)(*(uint64_t (**)(void))(**((void **)this + 4) + 16))(*((void *)this + 4));
  }
  uint64_t v3 = (char *)*((void *)this + 1);

  return health::FletcherChecksum(v2, v3);
}

void health::_HDAssertImplementation<health::data_corruption_error>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v39 = 0u;
  int v10 = backtrace(v38, 20);
  uint64_t v11 = backtrace_symbols(v38, v10);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v36);
  int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Critical Error: ", 16);
  int v13 = *(char *)(a6 + 23);
  if (v13 >= 0) {
    uint64_t v14 = a6;
  }
  else {
    uint64_t v14 = *(void *)a6;
  }
  if (v13 >= 0) {
    uint64_t v15 = *(unsigned __int8 *)(a6 + 23);
  }
  else {
    uint64_t v15 = *(void *)(a6 + 8);
  }
  uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, v14, v15);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
  uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Failed assertion '", 18);
  int v18 = *(char *)(a2 + 23);
  if (v18 >= 0) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = *(void *)a2;
  }
  if (v18 >= 0) {
    uint64_t v20 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v20 = *(void *)(a2 + 8);
  }
  unsigned int v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
  uint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"' in '", 6);
  int v23 = *(char *)(a3 + 23);
  if (v23 >= 0) {
    uint64_t v24 = a3;
  }
  else {
    uint64_t v24 = *(void *)a3;
  }
  if (v23 >= 0) {
    uint64_t v25 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v25 = *(void *)(a3 + 8);
  }
  char v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, v24, v25);
  uint64_t v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"' at ", 5);
  int v28 = *(char *)(a4 + 23);
  if (v28 >= 0) {
    uint64_t v29 = a4;
  }
  else {
    uint64_t v29 = *(void *)a4;
  }
  if (v28 >= 0) {
    uint64_t v30 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v30 = *(void *)(a4 + 8);
  }
  unint64_t v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, v29, v30);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)":", 1);
  uint64_t v32 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  if (!v10)
  {
    free(v11);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v37, &v35);
    std::runtime_error::runtime_error(exception, &v35);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1F171C6B8;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, *v11);
  health::HDDemangleBacktraceLine();
}

void sub_1BCD1F460(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  a21 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a21 + *(void *)(a21 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a22 = MEMORY[0x1E4FBA470] + 16;
  if (a35 < 0) {
    operator delete(a30);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&a38);
  _Unwind_Resume(a1);
}

uint64_t health::WriteAheadLog::WriteAheadLog(uint64_t a1, long long *a2)
{
  uint64_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727340;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727260;
  v6[0] = v4 + 1;
  v6[1] = v4;
  health::WriteAheadLog::WriteAheadLog(a1, a2, v6);
  std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  return a1;
}

{
  std::__shared_weak_count *v4;
  void v6[2];

  uint64_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727340;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727260;
  v6[0] = v4 + 1;
  v6[1] = v4;
  health::WriteAheadLog::WriteAheadLog(a1, a2, v6);
  std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  return a1;
}

void sub_1BCD1F658(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t health::WriteAheadLog::WriteAheadLog(uint64_t a1, long long *a2, void *a3)
{
  *(void *)a1 = 850045863;
  *(_OWORD *)(a1 + _Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 1018212795;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8_Block_object_dispose(&a9, 8) = 0u;
  *(void *)(a1 + 104) = 0;
  uint64_t v4 = a3[1];
  *(void *)(a1 + 112) = *a3;
  *(void *)(a1 + 120) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  id v5 = (std::string *)(a1 + 128);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    *(void *)(a1 + 144) = *((void *)a2 + 2);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 16_Block_object_dispose(&a9, 8) = 1;
  *(unsigned char *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(void *)(a1 + 24_Block_object_dispose(&a9, 8) = 0;
  *(_DWORD *)(a1 + 256) = 1065353216;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 264) = a1 + 272;
  return a1;
}

void sub_1BCD1F754(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 120);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  std::condition_variable::~condition_variable(v2);
  std::mutex::~mutex((std::mutex *)v1);
  _Unwind_Resume(a1);
}

void sub_1BCD1F81C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void health::WriteAheadLog::~WriteAheadLog(health::WriteAheadLog *this)
{
  health::WriteAheadLog::reset((std::mutex *)this);
  std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy((uint64_t)this + 264, *((void **)this + 34));
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)this + 224);
  uint64_t v4 = (void **)((char *)this + 200);
  std::vector<std::shared_ptr<health::WriteAheadLog::Transaction>>::__destroy_vector::operator()[abi:ne180100](&v4);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*((char *)this + 151) < 0) {
    operator delete(*((void **)this + 16));
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 64));
  std::mutex::~mutex((std::mutex *)this);
}

void health::WriteAheadLog::reset(std::mutex *this)
{
  std::mutex::lock(this);
  if (*(void *)&this[3].__m_.__opaque[8] != *(void *)this[3].__m_.__opaque)
  {
    uint64_t v2 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v23, "_transactionStack.size() == 0");
    std::string::basic_string[abi:ne180100]<0>(v22, "reset");
    std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to discard the log while a write transaction is open.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v2, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 60, (uint64_t)&__p);
  }
  uint64_t v3 = *(void *)this[3].__m_.__opaque;
  for (uint64_t i = *(void *)&this[3].__m_.__opaque[8]; i != v3; i -= 16)
  {
    id v5 = *(std::__shared_weak_count **)(i - 8);
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
  }
  *(void *)&this[3].__m_.__opaque[8] = v3;
  uint64_t v6 = *(void *)&this[3].__m_.__opaque[32];
  if (v6)
  {
    for (uint64_t j = 0; j != v6; ++j)
      *(void *)(*(void *)&this[3].__m_.__opaque[24] + 8 * j) = 0;
    char v8 = *(void **)&this[3].__m_.__opaque[40];
    *(void *)&this[3].__m_.__opaque[40] = 0;
    *(void *)&this[3].__m_.__opaque[48] = 0;
    if (v8)
    {
      do
      {
        uint64_t v9 = (void *)*v8;
        operator delete(v8);
        char v8 = v9;
      }
      while (v9);
    }
  }
  if (*(void *)&this[4].__m_.__opaque[16])
  {
    int v10 = *(void **)this[4].__m_.__opaque;
    uint64_t v11 = *(void *)&this[4].__m_.__opaque[8];
    *(void *)this[4].__m_.__opaque = (char *)this + 272;
    *(void *)(v11 + 16) = 0;
    *(void *)&this[4].__m_.__opaque[8] = 0;
    *(void *)&this[4].__m_.__opaque[16] = 0;
    if (v10[1]) {
      int v12 = (void *)v10[1];
    }
    else {
      int v12 = v10;
    }
    if (v12 && (int v13 = (void *)v12[2]) != 0)
    {
      uint64_t v14 = (void *)*v13;
      if ((void *)*v13 == v12)
      {
        *int v13 = 0;
        while (1)
        {
          uint64_t v19 = (void *)v13[1];
          if (!v19) {
            break;
          }
          do
          {
            int v13 = v19;
            uint64_t v19 = (void *)*v19;
          }
          while (v19);
        }
      }
      else
      {
        for (v13[1] = 0; v14; uint64_t v14 = (void *)v13[1])
        {
          do
          {
            int v13 = v14;
            uint64_t v14 = (void *)*v14;
          }
          while (v14);
        }
      }
      std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy((uint64_t)this[4].__m_.__opaque, v12);
      for (uint64_t k = (void *)v13[2]; k; uint64_t k = (void *)k[2])
        int v13 = k;
      opaque = this[4].__m_.__opaque;
      int v12 = v13;
    }
    else
    {
      opaque = this[4].__m_.__opaque;
    }
    std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy((uint64_t)opaque, v12);
  }
  uint64_t v17 = *(void *)&this[2].__m_.__opaque[16];
  if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 64))(v17);
    int v18 = *(std::__shared_weak_count **)&this[2].__m_.__opaque[24];
    *(void *)&this[2].__m_.__opaque[16] = 0;
    *(void *)&this[2].__m_.__opaque[24] = 0;
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
    }
  }
  std::mutex::unlock(this);
}

void sub_1BCD1FAF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v27 - 33) < 0) {
    operator delete(*(void **)(v27 - 56));
  }
  std::mutex::unlock(v26);
  _Unwind_Resume(a1);
}

void health::WriteAheadLog::open(std::mutex *this, uint64_t a2)
{
  std::mutex::lock(this);
  health::WriteAheadLog::_walLock_openLogForFileIdentifier(&this->__m_.__sig, a2);

  std::mutex::unlock(this);
}

void sub_1BCD1FBB8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t *health::WriteAheadLog::_walLock_openLogForFileIdentifier(uint64_t *this, uint64_t a2)
{
  uint64_t v2 = this;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v31 = a2;
  if (this[26] != this[25])
  {
    uint64_t v3 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v30, "_transactionStack.size() == 0");
    std::string::basic_string[abi:ne180100]<0>(v29, "_walLock_openLogForFileIdentifier");
    std::string::basic_string[abi:ne180100]<0>(v28, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to open the log while transactions are active.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v3, (uint64_t)v30, (uint64_t)v29, (uint64_t)v28, 241, (uint64_t)&__p);
  }
  uint64_t v4 = this[19];
  if (!v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = this[14];
    uint64_t v33 = 0x200000001;
    LODWORD(v34) = 0;
    do
    {
      unsigned int v7 = *(_DWORD *)((char *)&v33 + v4);
      if (v7 >= 4) {
        std::__throw_out_of_range[abi:ne180100]("bitset set argument out of range");
      }
      v5 |= 1 << v7;
      v4 += 4;
    }
    while (v4 != 12);
    (*(void (**)(long long *__return_ptr))(*(void *)v6 + 16))(&v36);
    long long v8 = v36;
    long long v36 = 0uLL;
    uint64_t v9 = (std::__shared_weak_count *)v2[20];
    *(_OWORD *)(v2 + 19) = v8;
    if (v9)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
      if (*((void *)&v36 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v36 + 1));
      }
      if (!v2[19])
      {
LABEL_13:
        uint64_t v10 = *MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(v26, "_walFile");
        std::string::basic_string[abi:ne180100]<0>(v25, "_walLock_openLogForFileIdentifier");
        std::string::basic_string[abi:ne180100]<0>(v24, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
        health::FormatString<>((std::string *)"Failed to open WAL file.", &v23);
        health::_HDAssertImplementation<health::transaction_error>(v10, (uint64_t)v26, (uint64_t)v25, (uint64_t)v24, 249, (uint64_t)&v23);
      }
    }
    else if (!(void)v8)
    {
      goto LABEL_13;
    }
    uint64_t v20 = 0x24857414CLL;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v19 = 0;
    uint64_t v11 = v2[19];
    uint64_t v39 = 0;
    uint64_t v40 = 24;
    uint64_t v33 = (uint64_t)&v36;
    unint64_t v34 = &v36;
    uint64_t v35 = 24;
    uint64_t v12 = (*(uint64_t (**)(uint64_t, void, long long *, uint64_t))(*(void *)v11 + 32))(v11, 0, &v36, 24);
    LODWORD(v32) = 0;
    health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)&v33, &v32);
    LODWORD(v20) = v32;
    LODWORD(v32) = 0;
    health::DeserializationBuffer::extractRaw<unsigned int>((uint64_t)&v33, &v32);
    HIDWORD(v20) = v32;
    uint64_t v32 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)&v33, &v32);
    uint64_t v21 = v32;
    uint64_t v32 = 0;
    health::DeserializationBuffer::extractRaw<unsigned long long>((uint64_t)&v33, &v32);
    uint64_t v22 = v32;
    uint64_t v13 = v39;
    uint64_t v39 = 0;
    if (v13) {
      MEMORY[0x1C187B880](v13, 0x1000C8077774924);
    }
    uint64_t v19 = v12;
    if (v12 < 1)
    {
      if (!v12)
      {
        *(void *)&long long v36 = 0x24857414CLL;
        *((void *)&v36 + 1) = v31;
        uint64_t v37 = 0;
        return (uint64_t *)health::VirtualFile::write<health::WriteAheadLog::LogHeader>(v2[19], (uint64_t)&v36);
      }
    }
    else if (v20 == 1213677900 && HIDWORD(v20) <= 2)
    {
      if (v21 != v31)
      {
        uint64_t v14 = *MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(v18, "header.fileIdentifier == fileIdentifier");
        std::string::basic_string[abi:ne180100]<0>(v17, "_walLock_openLogForFileIdentifier");
        std::string::basic_string[abi:ne180100]<0>(v16, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
        uint64_t v33 = 24;
        *(void *)&long long v36 = &v31;
        *((void *)&v36 + 1) = &v21;
        uint64_t v37 = &v33;
        uint64_t v38 = &v19;
        memset(&v15, 0, sizeof(v15));
        health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>((std::string *)"WAL file identifier does not match transactional file identifier; ignoring WAL file. (offset %l"
                         "d, header size %ld, header identifier %ld, file identifier %ld",
          &v15,
          0,
          (uint64_t)&v36);
        health::_HDAssertImplementation<health::data_corruption_error>(v14, (uint64_t)v18, (uint64_t)v17, (uint64_t)v16, 256, (uint64_t)&v15);
      }
      return (uint64_t *)health::WriteAheadLog::_walLock_loadExistingEntriesStartingAtOffset((health::WriteAheadLog *)v2, (std::__shared_weak_count_vtbl *)v19, HIDWORD(v20) == 1);
    }
    (*(void (**)(uint64_t, void))(*(void *)v2[19] + 56))(v2[19], 0);
    *(void *)&long long v36 = 0x24857414CLL;
    *((void *)&v36 + 1) = v31;
    uint64_t v37 = 0;
    return (uint64_t *)health::VirtualFile::write<health::WriteAheadLog::LogHeader>(v2[19], (uint64_t)&v36);
  }
  return this;
}

void sub_1BCD200D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(a1);
}

uint64_t health::WriteAheadLog::maximumCommittedSizeForTransaction(std::mutex *this, unint64_t a2)
{
  std::mutex::lock(this);
  uint64_t v4 = &this[4].__m_.__opaque[8];
  uint64_t v5 = *(health::WriteAheadLog **)this[4].__m_.__opaque;
  if (&this[4].__m_.__opaque[8] != (char *)v5)
  {
    do
    {
      uint64_t v6 = *(char **)v4;
      unsigned int v7 = *(char **)v4;
      long long v8 = v4;
      if (*(void *)v4)
      {
        do
        {
          uint64_t v9 = v7;
          unsigned int v7 = (char *)*((void *)v7 + 1);
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v9 = (char *)*((void *)v8 + 2);
          BOOL v10 = *(void *)v9 == (void)v8;
          long long v8 = v9;
        }
        while (v10);
      }
      uint64_t v11 = *((void *)v9 + 6);
      while (1)
      {
        uint64_t v12 = v11;
        uint64_t v13 = *(char **)v4;
        uint64_t v14 = v4;
        if (v6)
        {
          do
          {
            std::string v15 = v13;
            uint64_t v13 = (char *)*((void *)v13 + 1);
          }
          while (v13);
        }
        else
        {
          do
          {
            std::string v15 = (char *)*((void *)v14 + 2);
            BOOL v10 = *(void *)v15 == (void)v14;
            uint64_t v14 = v15;
          }
          while (v10);
        }
        if (v12 == *((void *)v15 + 5)) {
          break;
        }
        uint64_t v11 = v12 - 24;
        if (*(void *)(v12 - 24) <= a2)
        {
          if (v6)
          {
            do
            {
              int v18 = v6;
              uint64_t v6 = (char *)*((void *)v6 + 1);
            }
            while (v6);
          }
          else
          {
            do
            {
              int v18 = (char *)*((void *)v4 + 2);
              BOOL v10 = *(void *)v18 == (void)v4;
              uint64_t v4 = v18;
            }
            while (v10);
          }
          uint64_t v17 = *(void *)(v12 - 8) + *((void *)v18 + 4);
          goto LABEL_25;
        }
      }
      if (v6)
      {
        do
        {
          uint64_t v16 = (health::WriteAheadLog *)v6;
          uint64_t v6 = (char *)*((void *)v6 + 1);
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v16 = (health::WriteAheadLog *)*((void *)v4 + 2);
          BOOL v10 = *(void *)v16 == (void)v4;
          uint64_t v4 = (char *)v16;
        }
        while (v10);
      }
      uint64_t v4 = (char *)v16;
    }
    while (v16 != v5);
  }
  uint64_t v17 = 0;
LABEL_25:
  std::mutex::unlock(this);
  return v17;
}

void health::WriteAheadLog::discardLog(std::mutex *this)
{
  std::mutex::lock(this);
  if (*(void *)&this[3].__m_.__opaque[8] != *(void *)this[3].__m_.__opaque)
  {
    uint64_t v2 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v8, "_transactionStack.size() == 0");
    std::string::basic_string[abi:ne180100]<0>(v7, "discardLog");
    std::string::basic_string[abi:ne180100]<0>(v6, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to discard the log while a write transaction is open.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v2, (uint64_t)v8, (uint64_t)v7, (uint64_t)v6, 91, (uint64_t)&__p);
  }
  uint64_t v3 = *(void *)&this[2].__m_.__opaque[16];
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 56))(v3, 0);
    uint64_t v4 = *(std::__shared_weak_count **)&this[2].__m_.__opaque[24];
    *(void *)&this[2].__m_.__opaque[16] = 0;
    *(void *)&this[2].__m_.__opaque[24] = 0;
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  std::mutex::unlock(this);
}

void sub_1BCD2051C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v27 - 17) < 0) {
    operator delete(*(void **)(v27 - 40));
  }
  std::mutex::unlock(v26);
  _Unwind_Resume(a1);
}

void health::WriteAheadLog::_walLock_checkpointWhenIdle(uint64_t a1, std::unique_lock<std::mutex> *__lk, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v13[4] = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 192) = 1;
  BOOL v10 = (std::condition_variable *)(a1 + 64);
  while (*(void *)(a1 + 208) != *(void *)(a1 + 200) || *(void *)(a1 + 248))
    std::condition_variable::wait(v10, __lk);
  if (*(unsigned char *)(a1 + 192))
  {
    std::__function::__value_func<void ()(unsigned long long)>::__value_func[abi:ne180100]((uint64_t)v13, a3);
    std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::__value_func[abi:ne180100]((uint64_t)v12, a4);
    std::__function::__value_func<void ()(unsigned long long)>::__value_func[abi:ne180100]((uint64_t)v11, a5);
    health::WriteAheadLog::_walLock_checkpoint(a1, (uint64_t)v13);
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v11);
    std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::~__value_func[abi:ne180100](v12);
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v13);
  }
}

void sub_1BCD2068C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a2)
  {
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](&a10);
    std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::~__value_func[abi:ne180100](&a14);
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](&a18);
    __cxa_begin_catch(exception_object);
    *(unsigned char *)(v18 + 192) = 0;
    std::condition_variable::notify_all(v19);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void health::WriteAheadLog::_walLock_waitOnTransactionIdle(void *a1, std::unique_lock<std::mutex> *__lk)
{
  uint64_t v4 = (std::condition_variable *)(a1 + 8);
  while (a1[26] != a1[25] || a1[31])
    std::condition_variable::wait(v4, __lk);
}

void health::WriteAheadLog::_walLock_checkpoint(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 208) != *(void *)(a1 + 200))
  {
    uint64_t v4 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v19, "_transactionStack.size() == 0");
    std::string::basic_string[abi:ne180100]<0>(v18, "_walLock_checkpoint");
    std::string::basic_string[abi:ne180100]<0>(v17, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to checkpoint the WAL while a write transaction is active", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v4, (uint64_t)v19, (uint64_t)v18, (uint64_t)v17, 457, (uint64_t)&__p);
  }
  if (*(void *)(a1 + 248))
  {
    uint64_t v5 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v15, "_readTransactionIdentifiers.size() == 0");
    std::string::basic_string[abi:ne180100]<0>(v14, "_walLock_checkpoint");
    std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to checkpoint the WAL while a read transaction is active", &v12);
    health::_HDAssertImplementation<health::transaction_error>(v5, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 458, (uint64_t)&v12);
  }
  (*(void (**)(void))(**(void **)(a1 + 152) + 16))(*(void *)(a1 + 152));
  uint64_t v6 = *(void **)(a1 + 264);
  unsigned int v7 = (void *)(a1 + 272);
  if (v6 != (void *)(a1 + 272))
  {
    do
    {
      if (v6[6] != v6[5])
      {
        std::function<void ()(unsigned long long)>::operator()(a2, *(void *)(a1 + 176));
        health::_PageForEntry((uint64_t *)(a1 + 152), v6[4], v6[6] - 24, v11);
      }
      long long v8 = (void *)v6[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          long long v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v6[2];
          BOOL v10 = *v9 == (void)v6;
          uint64_t v6 = v9;
        }
        while (!v10);
      }
      uint64_t v6 = v9;
    }
    while (v9 != v7);
  }
  *(void *)(a1 + 184) = 0;
  std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy(a1 + 264, *(void **)(a1 + 272));
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 264) = v7;
  *(unsigned char *)(a1 + 192) = 0;
  (*(void (**)(void, void))(**(void **)(a1 + 152) + 56))(*(void *)(a1 + 152), 0);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 64));
}

void sub_1BCD20A80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  _Unwind_Resume(exception_object);
}

void health::WriteAheadLog::checkpoint(std::mutex *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v13[4] = *MEMORY[0x1E4F143B8];
  __lk.__m_ = a1;
  __lk.__owns_ = 1;
  std::mutex::lock(a1);
  health::WriteAheadLog::_walLock_openLogForFileIdentifier(&a1->__m_.__sig, a2);
  std::__function::__value_func<void ()(unsigned long long)>::__value_func[abi:ne180100]((uint64_t)v13, a3);
  std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::__value_func[abi:ne180100]((uint64_t)v12, a4);
  std::__function::__value_func<void ()(unsigned long long)>::__value_func[abi:ne180100]((uint64_t)v11, a5);
  health::WriteAheadLog::_walLock_checkpointWhenIdle((uint64_t)a1, &__lk, (uint64_t)v13, (uint64_t)v12, (uint64_t)v11);
  std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v11);
  std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::~__value_func[abi:ne180100](v12);
  std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v13);
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
}

void sub_1BCD20C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, char a11, int a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a11) {
    std::mutex::unlock(a10);
  }
  _Unwind_Resume(a1);
}

unint64_t health::WriteAheadLog::_prepareReadTransaction(health::WriteAheadLog *this)
{
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)this;
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)this);
  while (*((unsigned char *)this + 192))
    std::condition_variable::wait((std::condition_variable *)((char *)this + 64), &__lk);
  unint64_t v4 = *((void *)this + 22);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_multi<unsigned long long const&>((void *)this + 28, &v4);
  unint64_t v2 = v4;
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
  return v2;
}

void sub_1BCD20D1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, char a12)
{
  if (a12) {
    std::mutex::unlock(a11);
  }
  _Unwind_Resume(exception_object);
}

void health::WriteAheadLog::_walLock_waitOnCheckpointCompletion(uint64_t a1, std::unique_lock<std::mutex> *__lk)
{
  if (*(unsigned char *)(a1 + 192))
  {
    unint64_t v4 = (std::condition_variable *)(a1 + 64);
    do
      std::condition_variable::wait(v4, __lk);
    while (*(unsigned char *)(a1 + 192));
  }
}

void health::WriteAheadLog::runReadTransaction(uint64_t a1, uint64_t a2)
{
  unint64_t Transaction = health::WriteAheadLog::_prepareReadTransaction((health::WriteAheadLog *)a1);
  std::function<void ()(unsigned long long)>::operator()(a2, Transaction);
  std::mutex::lock((std::mutex *)a1);
  unint64_t v4 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>((void *)(a1 + 224), &Transaction);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase((void *)(a1 + 224), v4);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 64));
  std::mutex::unlock((std::mutex *)a1);
}

void sub_1BCD20DF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  std::mutex::unlock(v10);
  _Unwind_Resume(a1);
}

std::__shared_weak_count_vtbl *health::WriteAheadLog::_prepareWriteTransaction(health::WriteAheadLog *this, uint64_t a2)
{
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)this;
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)this);
  unint64_t v4 = (std::__shared_weak_count_vtbl *)*((void *)this + 21);
  *((void *)this + 21) = (char *)&v4->~__shared_weak_count + 1;
  while (*((unsigned char *)this + 192))
    std::condition_variable::wait((std::condition_variable *)((char *)this + 64), &__lk);
  health::WriteAheadLog::_walLock_openLogForFileIdentifier((uint64_t *)this, a2);
  uint64_t v5 = (std::__shared_weak_count_vtbl *)(*(uint64_t (**)(void))(**((void **)this + 19) + 48))(*((void *)this + 19));
  if (!v5)
  {
    v8[0] = 0x24857414CLL;
    v8[1] = a2;
    void v8[2] = 0;
    health::VirtualFile::write<health::WriteAheadLog::LogHeader>(*((void *)this + 19), (uint64_t)v8);
  }
  health::WriteAheadLog::_walLock_startTransaction(this, v4, v5, 0);
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
  return v4;
}

void sub_1BCD20F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, char a11)
{
  if (a11) {
    std::mutex::unlock(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::WriteAheadLog::_walLock_writeHeaderForIdentifier(health::WriteAheadLog *this, uint64_t a2)
{
  v3[0] = 0x24857414CLL;
  v3[1] = a2;
  void v3[2] = 0;
  return health::VirtualFile::write<health::WriteAheadLog::LogHeader>(*((void *)this + 19), (uint64_t)v3);
}

void health::WriteAheadLog::_walLock_startTransaction(void *a1, std::__shared_weak_count_vtbl *a2, std::__shared_weak_count_vtbl *a3, int a4)
{
  for (uint64_t i = (std::__shared_weak_count_vtbl ***)a1[25]; i != (std::__shared_weak_count_vtbl ***)a1[26]; i += 2)
  {
    if (**i == a2)
    {
      uint64_t v9 = *MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v38, "_walLock_transactionForIdentifier(transactionIdentifier) == nullptr");
      std::string::basic_string[abi:ne180100]<0>(v37, "_walLock_startTransaction");
      std::string::basic_string[abi:ne180100]<0>(v36, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
      health::FormatString<>((std::string *)"Attempt to start a transaction which is already active.", &__p);
      health::_HDAssertImplementation<health::transaction_error>(v9, (uint64_t)v38, (uint64_t)v37, (uint64_t)v36, 353, (uint64_t)&__p);
    }
  }
  BOOL v10 = (std::__shared_weak_count *)operator new(0x58uLL);
  v10->__shared_owners_ = 0;
  v10->__shared_weak_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F171DAF0;
  uint64_t v12 = a1[19];
  uint64_t v11 = (std::__shared_weak_count *)a1[20];
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    v10[1].__vftable = a2;
    v10[1].__shared_owners_ = v12;
    v10[1].__shared_weak_owners_ = (uint64_t)v11;
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    v10[2].__shared_weak_owners_ = 0;
    v10[3].__vftable = 0;
    v10[2].__vftable = a3;
    v10[2].__shared_owners_ = (uint64_t)&v10[2].__shared_weak_owners_;
    LODWORD(v10[3].__shared_owners_) = 0;
    HIDWORD(v10[3].__shared_owners_) = a4;
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  else
  {
    v10[2].__shared_weak_owners_ = 0;
    v10[1].__vftable = a2;
    v10[1].__shared_owners_ = v12;
    v10[1].__shared_weak_owners_ = 0;
    v10[2].__vftable = a3;
    v10[3].__vftable = 0;
    v10[2].__shared_owners_ = (uint64_t)&v10[2].__shared_weak_owners_;
    LODWORD(v10[3].__shared_owners_) = 0;
    HIDWORD(v10[3].__shared_owners_) = a4;
  }
  if (a4 != 1)
  {
    int v30 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    uint64_t v31 = a2;
    int v34 = 0;
    uint64_t v13 = a1[19];
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    health::VirtualFile::write<health::WriteAheadLog::LogEntryHeader>(v13, v14, (uint64_t)&v30);
  }
  std::string v15 = v10 + 1;
  uint64_t v17 = (char *)a1[26];
  unint64_t v16 = a1[27];
  if ((unint64_t)v17 >= v16)
  {
    uint64_t v19 = (char *)a1[25];
    uint64_t v20 = (v17 - v19) >> 4;
    unint64_t v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) >> 60) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v22 = v16 - (void)v19;
    if (v22 >> 3 > v21) {
      unint64_t v21 = v22 >> 3;
    }
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v23 = v21;
    }
    if (v23 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v24 = (char *)operator new(16 * v23);
    uint64_t v25 = &v24[16 * v20];
    char v26 = &v24[16 * v23];
    *(void *)uint64_t v25 = v15;
    *((void *)v25 + 1) = v10;
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v18 = v25 + 16;
    if (v17 == v19)
    {
      a1[25] = v25;
      a1[26] = v18;
      a1[27] = v26;
    }
    else
    {
      do
      {
        long long v27 = *((_OWORD *)v17 - 1);
        v17 -= 16;
        *((_OWORD *)v25 - 1) = v27;
        v25 -= 16;
        *(void *)uint64_t v17 = 0;
        *((void *)v17 + 1) = 0;
      }
      while (v17 != v19);
      uint64_t v17 = (char *)a1[25];
      int v28 = (char *)a1[26];
      a1[25] = v25;
      a1[26] = v18;
      a1[27] = v26;
      while (v28 != v17)
      {
        uint64_t v29 = (std::__shared_weak_count *)*((void *)v28 - 1);
        if (v29) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v29);
        }
        v28 -= 16;
      }
    }
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    *(void *)uint64_t v17 = v15;
    *((void *)v17 + 1) = v10;
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v18 = v17 + 16;
  }
  a1[26] = v18;
  ++a1[23];
  std::__shared_weak_count::__release_shared[abi:ne180100](v10);
}

void sub_1BCD212AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (*(char *)(v32 - 65) < 0) {
    operator delete(*(void **)(v32 - 88));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::WriteAheadLog::runWriteTransaction(health::WriteAheadLog *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v15 = a3;
  __int16 v14 = 0;
  void v12[7] = a7;
  uint64_t v13 = health::WriteAheadLog::_prepareWriteTransaction(a1, a2);
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v13;
  void v12[3] = (char *)&v14 + 1;
  void v12[4] = &v15;
  v12[5] = a5;
  v12[6] = a6;
  LOBYTE(v14) = std::function<BOOL ()(unsigned long long)>::operator()(a4, (uint64_t)v13);
  health::WriteAheadLog::runWriteTransaction(unsigned long long,health::WriteAheadLog::CommitMode,std::function<BOOL ()(unsigned long long)>,std::function<void ()(unsigned long long)>,std::function<void ()(unsigned long long,health::FilePage const&)>,std::function<void ()(unsigned long long)>)::$_1::operator()((uint64_t)v12);
  return HIBYTE(v14);
}

void sub_1BCD213B8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1BCD213CC(_Unwind_Exception *a1)
{
}

void health::WriteAheadLog::pageAtOffset(std::mutex *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  std::mutex::lock(this);
  if (*(void *)&this[3].__m_.__opaque[8] == *(void *)this[3].__m_.__opaque
    && !*(void *)&this[3].__m_.__opaque[48])
  {
    uint64_t v8 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v17, "(_transactionStack.size() > 0) || (_readTransactionIdentifiers.size() > 0)");
    std::string::basic_string[abi:ne180100]<0>(v16, "pageAtOffset");
    std::string::basic_string[abi:ne180100]<0>(v15, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to retrieve a page while no transaction is active.", &__p);
    health::_HDAssertImplementation<health::transaction_error>(v8, (uint64_t)v17, (uint64_t)v16, (uint64_t)v15, 198, (uint64_t)&__p);
  }
  uint64_t v9 = *(void *)&this[3].__m_.__opaque[8];
  while (v9 != *(void *)this[3].__m_.__opaque)
  {
    uint64_t v11 = *(unint64_t **)(v9 - 16);
    v9 -= 16;
    BOOL v10 = (health::WriteAheadLog::Transaction *)v11;
    if (*v11 <= a2)
    {
      health::WriteAheadLog::Transaction::pageAtOffset(v10, a3, (uint64_t)a4);
      if (a4[2] | a4[4]) {
        goto LABEL_13;
      }
      uint64_t v12 = (std::__shared_weak_count *)a4[5];
      if (v12) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      }
      uint64_t v13 = (std::__shared_weak_count *)a4[3];
      if (v13) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      }
    }
  }
  health::WriteAheadLog::_walLock_committedPageAtOffsetForTransaction((health::WriteAheadLog *)this, a2, a3, (uint64_t)a4);
LABEL_13:
  std::mutex::unlock(this);
}

void sub_1BCD21558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  std::mutex::unlock(v32);
  _Unwind_Resume(a1);
}

double health::WriteAheadLog::_walLock_committedPageAtOffsetForTransaction@<D0>(health::WriteAheadLog *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v4 = (void *)*((void *)this + 34);
  if (v4)
  {
    uint64_t v5 = (void *)((char *)this + 272);
    do
    {
      unint64_t v6 = v4[4];
      BOOL v7 = v6 >= a3;
      if (v6 >= a3) {
        uint64_t v8 = v4;
      }
      else {
        uint64_t v8 = v4 + 1;
      }
      if (v7) {
        uint64_t v5 = v4;
      }
      unint64_t v4 = (void *)*v8;
    }
    while (*v8);
    if (v5 != (void *)((char *)this + 272) && v5[4] <= a3)
    {
      uint64_t v12 = v5 + 5;
      uint64_t v11 = v5[5];
      uint64_t v10 = v12[1];
      while (v10 != v11)
      {
        unint64_t v13 = *(void *)(v10 - 24);
        v10 -= 24;
        if (v13 <= a2) {
          health::_PageForEntry((uint64_t *)this + 19, a3, v10, (void *)a4);
        }
      }
    }
  }
  double result = 0.0;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  return result;
}

void health::WriteAheadLog::updatedPage(std::mutex *this, unint64_t a2, const health::FilePage *a3)
{
  unint64_t v24 = a2;
  std::mutex::lock(this);
  if (*(void *)&this[3].__m_.__opaque[8] == *(void *)this[3].__m_.__opaque)
  {
    uint64_t v5 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v23, "_transactionStack.size() > 0");
    std::string::basic_string[abi:ne180100]<0>(v22, "updatedPage");
    std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<>((std::string *)"Attempt to store an updated page while no transaction is active.", &v20);
    health::_HDAssertImplementation<health::transaction_error>(v5, (uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 218, (uint64_t)&v20);
  }
  uint64_t v6 = *(void *)&this[3].__m_.__opaque[8];
  do
  {
    if (v6 == *(void *)this[3].__m_.__opaque)
    {
      if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(&this[3].__m_.__opaque[24], &v24))
      {
        uint64_t v9 = *MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(v19, "_readTransactionIdentifiers.find(transactionIdentifier) == _readTransactionIdentifiers.end()");
        std::string::basic_string[abi:ne180100]<0>(v18, "updatedPage");
        std::string::basic_string[abi:ne180100]<0>(v17, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
        health::FormatString<>((std::string *)"Attempt to update a page from a read transaction.", &__p);
        health::_HDAssertImplementation<health::transaction_error>(v9, (uint64_t)v19, (uint64_t)v18, (uint64_t)v17, 228, (uint64_t)&__p);
      }
      uint64_t v10 = *MEMORY[0x1E4F29F18];
      std::string::basic_string[abi:ne180100]<0>(v15, "false");
      std::string::basic_string[abi:ne180100]<0>(v14, "updatedPage");
      std::string::basic_string[abi:ne180100]<0>(v13, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
      uint64_t v11 = **(void **)(*(void *)&this[3].__m_.__opaque[8] - 16);
      health::FormatString<unsigned long long &,unsigned long long>(&v12, (std::string *)"Attempt to record updated page for inactive transaction {0}; current transaction is {1}.",
        (uint64_t)&v24,
        (uint64_t)&v11);
      health::_HDAssertImplementation<health::transaction_error>(v10, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 229, (uint64_t)&v12);
    }
    uint64_t v8 = *(health::WriteAheadLog::Transaction **)(v6 - 16);
    v6 -= 16;
    BOOL v7 = v8;
  }
  while (*(void *)v8 != v24);
  health::WriteAheadLog::Transaction::updatedPage(v7, a3);
  std::mutex::unlock(this);
}

void sub_1BCD218DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  if (*(char *)(v52 - 137) < 0) {
    operator delete(*(void **)(v52 - 160));
  }
  std::mutex::unlock(v51);
  _Unwind_Resume(a1);
}

void health::FormatString<unsigned long long &,unsigned long long>(std::string *a1, std::string *a2, uint64_t a3, uint64_t a4)
{
  v4[0] = a4;
  v4[1] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<unsigned long long &,unsigned long long>(a2, a1, 0, (uint64_t)v4);
}

void sub_1BCD21A54(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::WriteAheadLog::_walLock_loadExistingEntriesStartingAtOffset(health::WriteAheadLog *this, std::__shared_weak_count_vtbl *a2, int a3)
{
  memset(v30, 0, sizeof(v30));
  int v31 = 1065353216;
  int v25 = 99;
  unint64_t v27 = 0;
  int v28 = 0;
  unint64_t v26 = 0;
  int v29 = 0;
  while ((uint64_t)a2 < (*(uint64_t (**)(void))(**((void **)this + 19) + 48))(*((void *)this + 19)))
  {
    uint64_t v6 = health::VirtualFile::read<health::WriteAheadLog::LogEntryHeader>(*((void *)this + 19), (uint64_t)a2, (uint64_t)&v25);
    int v7 = v25;
    uint64_t v8 = (std::__shared_weak_count_vtbl *)((char *)a2 + v6);
    switch(v25)
    {
      case 0:
        unint64_t v9 = v26;
        health::WriteAheadLog::_walLock_startTransaction(this, (std::__shared_weak_count_vtbl *)v26, a2, 1);
        if (v9 + 1 > *((void *)this + 21)) {
          unint64_t v10 = v9 + 1;
        }
        else {
          unint64_t v10 = *((void *)this + 21);
        }
        *((void *)this + 21) = v10;
        a2 = v8;
        continue;
      case 1:
        unint64_t v15 = v26;
        if (!a3) {
          goto LABEL_20;
        }
        a2 = (std::__shared_weak_count_vtbl *)((char *)a2 + v6);
        if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(*(uint64_t *)&v30[0], *((unint64_t *)&v30[0] + 1), v26))
        {
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((float *)v30, v15, v15);
LABEL_20:
          health::WriteAheadLog::_walLock_commitTransaction(this, v15);
          a2 = v8;
        }
        break;
      case 2:
        unint64_t v11 = v26;
        if (!a3) {
          goto LABEL_11;
        }
        a2 = (std::__shared_weak_count_vtbl *)((char *)a2 + v6);
        if (!std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(*(uint64_t *)&v30[0], *((unint64_t *)&v30[0] + 1), v26))
        {
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((float *)v30, v11, v11);
LABEL_11:
          health::WriteAheadLog::_walLock_rollbackTransaction(this, v11);
          a2 = v8;
        }
        break;
      case 3:
        std::string v12 = (void **)*((void *)this + 25);
        unint64_t v13 = (void **)*((void *)this + 26);
        if (v12 == v13) {
          goto LABEL_25;
        }
        unint64_t v14 = v26;
        while (**v12 != v26)
        {
          v12 += 2;
          if (v12 == v13)
          {
LABEL_25:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Invalid WAL entry: found a page update for a transaction that is not active.");
            exception->__vftable = (std::runtime_error_vtbl *)&unk_1F171C6B8;
          }
        }
        unint64_t v16 = v28;
        uint64_t v17 = (uint64_t **)(*v12 + 4);
        v24.__r_.__value_.__r.__words[0] = v27;
        uint64_t v18 = std::__tree<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v17, v27, (uint64_t **)&v24);
        v18[5] = (uint64_t *)v14;
        void v18[6] = (uint64_t *)a2;
        a2 = (std::__shared_weak_count_vtbl *)((char *)v8 + (void)v16);
        v18[7] = v16;
        break;
      default:
        uint64_t v22 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        int v23 = v7;
        health::FormatString<int>((std::string *)"Invalid WAL entry type {0}.", &v23, &v24);
        std::runtime_error::runtime_error(v22, &v24);
        v22->__vftable = (std::runtime_error_vtbl *)&unk_1F171C6B8;
    }
  }
  while (1)
  {
    uint64_t v19 = *((void *)this + 26);
    if (v19 == *((void *)this + 25)) {
      break;
    }
    health::WriteAheadLog::_walLock_rollbackTransaction(this, **(void **)(v19 - 16));
  }
  return std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)v30);
}

void sub_1BCD21D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((v23 & 1) == 0)
    {
LABEL_6:
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)&a22);
      _Unwind_Resume(a1);
    }
  }
  else if (!v23)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v22);
  goto LABEL_6;
}

void std::vector<std::shared_ptr<health::WriteAheadLog::Transaction>>::erase(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    uint64_t v4 = std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::shared_ptr<health::WriteAheadLog::Transaction> *,std::shared_ptr<health::WriteAheadLog::Transaction> *,std::shared_ptr<health::WriteAheadLog::Transaction> *>(a3, *(long long **)(a1 + 8), a2);
    for (uint64_t i = *(void *)(a1 + 8); i != v4; i -= 16)
    {
      uint64_t v6 = *(std::__shared_weak_count **)(i - 8);
      if (v6) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v6);
      }
    }
    *(void *)(a1 + _Block_object_dispose(&a9, 8) = v4;
  }
}

void health::Print<char const*>(std::string *a1, const char **a2)
{
  health::FormatString<char const*>(a1, a2, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)p_p, size);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"\n", 1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1BCD21E98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void health::WriteAheadLog::_walLock_commitTransaction(health::WriteAheadLog *this, uint64_t a2)
{
  void v24[4] = *MEMORY[0x1E4F143B8];
  uint64_t v23 = a2;
  if (*((void *)this + 26) == *((void *)this + 25))
  {
    uint64_t v3 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v22, "_transactionStack.size() > 0");
    std::string::basic_string[abi:ne180100]<0>(v21, "_walLock_commitTransaction");
    std::string::basic_string[abi:ne180100]<0>(v20, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<unsigned long long &>(&__p, (std::string *)"Attempt to commit transaction {0} when no transaction is active.", (uint64_t)&v23);
    health::_HDAssertImplementation<health::transaction_error>(v3, (uint64_t)v22, (uint64_t)v21, (uint64_t)v20, 367, (uint64_t)&__p);
  }
  uint64_t v4 = *((void *)this + 25);
  uint64_t v5 = (*((void *)this + 26) - v4) >> 4;
  uint64_t v6 = v4 + 16 * (v5 - 1);
  uint64_t v8 = *(health::WriteAheadLog::Transaction **)v6;
  int v7 = *(std::__shared_weak_count **)(v6 + 8);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(void *)v8 != v23)
  {
    uint64_t v9 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v18, "transaction->identifier() == transactionIdentifier");
    std::string::basic_string[abi:ne180100]<0>(v17, "_walLock_commitTransaction");
    std::string::basic_string[abi:ne180100]<0>(v16, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    uint64_t v14 = *(void *)v8;
    health::FormatString<unsigned long long &,unsigned long long>(&v15, (std::string *)"Attempt to commit transaction ({0}) which is not the innermost transaction ({1}).", (uint64_t)&v23, (uint64_t)&v14);
    health::_HDAssertImplementation<health::transaction_error>(v9, (uint64_t)v18, (uint64_t)v17, (uint64_t)v16, 370, (uint64_t)&v15);
  }
  uint64_t v10 = std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::shared_ptr<health::WriteAheadLog::Transaction> *,std::shared_ptr<health::WriteAheadLog::Transaction> *,std::shared_ptr<health::WriteAheadLog::Transaction> *>((long long *)(*((void *)this + 25) + 16 * v5), *((long long **)this + 26), *((void *)this + 25) + 16 * (v5 - 1));
  for (uint64_t i = *((void *)this + 26); i != v10; i -= 16)
  {
    std::string v12 = *(std::__shared_weak_count **)(i - 8);
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
  }
  *((void *)this + 26) = v10;
  uint64_t v13 = *((void *)this + 25);
  if (v10 == v13)
  {
    v24[0] = &unk_1F171DB40;
    v24[1] = this;
    void v24[2] = &v23;
    void v24[3] = v24;
    health::WriteAheadLog::Transaction::commit((unint64_t)v8, (uint64_t)v24);
    std::__function::__value_func<void ()(long long,health::WriteAheadLog::PageEntry)>::~__value_func[abi:ne180100](v24);
    *((void *)this + 22) = v23;
    if (!v7) {
      return;
    }
  }
  else
  {
    health::WriteAheadLog::Transaction::commitAndMerge(v8, *(health::WriteAheadLog::Transaction **)(v13 + 16 * v5 - 32));
    if (!v7) {
      return;
    }
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v7);
}

void sub_1BCD2217C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  std::__function::__value_func<void ()(long long,health::WriteAheadLog::PageEntry)>::~__value_func[abi:ne180100]((void *)(v53 - 104));
  if (v52) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v52);
  }
  _Unwind_Resume(a1);
}

void health::WriteAheadLog::_walLock_rollbackTransaction(health::WriteAheadLog *this, uint64_t a2)
{
  uint64_t v22 = a2;
  if (*((void *)this + 26) == *((void *)this + 25))
  {
    uint64_t v3 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v21, "_transactionStack.size() > 0");
    std::string::basic_string[abi:ne180100]<0>(v20, "_walLock_rollbackTransaction");
    std::string::basic_string[abi:ne180100]<0>(v19, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    health::FormatString<unsigned long long &>(&__p, (std::string *)"Attempt to roll back transaction {0} when no transaction is active.", (uint64_t)&v22);
    health::_HDAssertImplementation<health::transaction_error>(v3, (uint64_t)v21, (uint64_t)v20, (uint64_t)v19, 394, (uint64_t)&__p);
  }
  uint64_t v4 = *((void *)this + 25);
  uint64_t v5 = (*((void *)this + 26) - v4) >> 4;
  uint64_t v6 = v4 + 16 * (v5 - 1);
  uint64_t v8 = *(uint64_t **)v6;
  int v7 = *(std::__shared_weak_count **)(v6 + 8);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*v8 != v22)
  {
    uint64_t v9 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v17, "transaction->identifier() == transactionIdentifier");
    std::string::basic_string[abi:ne180100]<0>(v16, "_walLock_rollbackTransaction");
    std::string::basic_string[abi:ne180100]<0>(v15, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDWriteAheadLog.cpp");
    uint64_t v13 = *v8;
    health::FormatString<unsigned long long &,unsigned long long>(&v14, (std::string *)"Attempt to roll back transaction ({0}) which is not the innermost transaction ({1}).", (uint64_t)&v22, (uint64_t)&v13);
    health::_HDAssertImplementation<health::transaction_error>(v9, (uint64_t)v17, (uint64_t)v16, (uint64_t)v15, 397, (uint64_t)&v14);
  }
  uint64_t v10 = std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::shared_ptr<health::WriteAheadLog::Transaction> *,std::shared_ptr<health::WriteAheadLog::Transaction> *,std::shared_ptr<health::WriteAheadLog::Transaction> *>((long long *)(*((void *)this + 25) + 16 * v5), *((long long **)this + 26), *((void *)this + 25) + 16 * (v5 - 1));
  for (uint64_t i = *((void *)this + 26); i != v10; i -= 16)
  {
    std::string v12 = *(std::__shared_weak_count **)(i - 8);
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
  }
  *((void *)this + 26) = v10;
  health::WriteAheadLog::Transaction::_writeCompletionEntryOfType((unint64_t)v8, 2);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
}

void sub_1BCD224AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (*(char *)(v45 - 97) < 0) {
    operator delete(*(void **)(v45 - 120));
  }
  if (*(char *)(v45 - 73) < 0) {
    operator delete(*(void **)(v45 - 96));
  }
  _Unwind_Resume(exception_object);
}

void *health::WriteAheadLog::_walLock_transactionForIdentifier(health::WriteAheadLog *this, uint64_t a2)
{
  unint64_t v2 = (uint64_t *)*((void *)this + 25);
  uint64_t v3 = (uint64_t *)*((void *)this + 26);
  while (v2 != v3)
  {
    double result = (void *)*v2;
    if (*(void *)*v2 == a2) {
      return result;
    }
    v2 += 2;
  }
  return 0;
}

{
  uint64_t *v2;
  uint64_t *v3;
  void *result;

  unint64_t v2 = (uint64_t *)*((void *)this + 25);
  uint64_t v3 = (uint64_t *)*((void *)this + 26);
  while (v2 != v3)
  {
    double result = (void *)*v2;
    if (*(void *)*v2 == a2) {
      return result;
    }
    v2 += 2;
  }
  return 0;
}

std::runtime_error *_ZN6health21data_corruption_errorCI1St13runtime_errorEPKc(std::runtime_error *a1, const char *a2)
{
  double result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_1F171C6B8;
  return result;
}

uint64_t **health::WriteAheadLog::Transaction::storePageEntry(uint64_t **this, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v6 = *this;
  uint64_t v8 = a2;
  double result = std::__tree<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(this + 4, (unint64_t)a2, &v8);
  result[5] = v6;
  result[6] = a3;
  result[7] = a4;
  return result;
}

void health::FormatString<int>(std::string *a1@<X0>, int *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v3 = a2;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<int>(a1, a3, 0, &v3);
}

void sub_1BCD22674(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatString<unsigned long long &>(std::string *a1, std::string *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<unsigned long long &>(a2, a1, 0, &v3);
}

void sub_1BCD226D8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

unint64_t health::WriteAheadLog::Transaction::commit(unint64_t a1, uint64_t a2)
{
  unint64_t result = health::WriteAheadLog::Transaction::_writeCompletionEntryOfType(a1, 1);
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = (void *)(a1 + 40);
  if (v5 != v6)
  {
    do
    {
      uint64_t v7 = v5[4];
      long long v12 = *(_OWORD *)(v5 + 5);
      uint64_t v13 = v5[7];
      uint64_t v14 = v7;
      uint64_t v8 = *(void *)(a2 + 24);
      if (!v8) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, long long *))(*(void *)v8 + 48))(v8, &v14, &v12);
      uint64_t v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v11 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v11);
      }
      uint64_t v5 = v10;
    }
    while (v10 != v6);
  }
  return result;
}

void *health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction *this, health::WriteAheadLog::Transaction *a2)
{
  v3[4] = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1F171DBD0;
  v3[1] = a2;
  void v3[3] = v3;
  health::WriteAheadLog::Transaction::commit((unint64_t)this, (uint64_t)v3);
  return std::__function::__value_func<void ()(long long,health::WriteAheadLog::PageEntry)>::~__value_func[abi:ne180100](v3);
}

void sub_1BCD22848(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(long long,health::WriteAheadLog::PageEntry)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

unint64_t health::WriteAheadLog::Transaction::rollback(health::WriteAheadLog::Transaction *this)
{
  return health::WriteAheadLog::Transaction::_writeCompletionEntryOfType((unint64_t)this, 2);
}

uint64_t health::WriteAheadLog::_walLock_shouldCheckpoint(health::WriteAheadLog *this)
{
  uint64_t result = *((void *)this + 19);
  if (result) {
    return *((uint64_t *)this + 23) > 9
  }
        || (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result) >= 0x200000;
  return result;
}

BOOL health::WriteAheadLog::_walLock_shouldCheckpointForMode(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 == 2) {
    return 1;
  }
  if (a2 != 1) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 152);
  if (!v2) {
    return 0;
  }
  if (*(uint64_t *)(a1 + 184) <= 9) {
    return (*(uint64_t (**)(void))(*(void *)v2 + 48))(*(void *)(a1 + 152)) >= 0x200000;
  }
  return 1;
}

void *health::WriteAheadLog::_walLock_pruneCommittedPages(void *this)
{
  unint64_t v1 = this[22];
  for (uint64_t i = (void *)this[30]; i; uint64_t i = (void *)*i)
  {
    if (i[2] < v1) {
      unint64_t v1 = i[2];
    }
  }
  uint64_t v3 = (void *)this[33];
  uint64_t v4 = this + 34;
  if (v3 != this + 34)
  {
    do
    {
      uint64_t v6 = v3[5];
      uint64_t v5 = v3[6];
      if (0xAAAAAAAAAAAAAAABLL * ((v5 - v6) >> 3) >= 2)
      {
        uint64_t v7 = 0;
        while (v5 + v7 != v6)
        {
          unint64_t v8 = *(void *)(v5 + v7 - 24);
          v7 -= 24;
          if (v8 <= v1)
          {
            if (v5 + v7 != v6)
            {
              uint64_t v9 = -v7;
              if (v7) {
                this = memmove((void *)v3[5], (const void *)(v5 + v7), -v7);
              }
              v3[6] = v6 + v9;
            }
            break;
          }
        }
      }
      uint64_t v10 = (void *)v3[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v3[2];
          BOOL v12 = *v11 == (void)v3;
          uint64_t v3 = v11;
        }
        while (!v12);
      }
      uint64_t v3 = v11;
    }
    while (v11 != v4);
  }
  return this;
}

uint64_t health::WriteAheadLog::Transaction::Transaction(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4, int a5)
{
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  *(void *)uint64_t result = a2;
  *(void *)(result + _Block_object_dispose(&a9, 8) = v6;
  *(void *)(result + 16) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(result + 40) = 0;
  *(void *)(result + 4_Block_object_dispose(&a9, 8) = 0;
  *(void *)(result + 24) = a4;
  *(void *)(result + 32) = result + 40;
  *(_DWORD *)(result + 56) = 0;
  *(_DWORD *)(result + 60) = a5;
  return result;
}

{
  uint64_t v5;
  uint64_t v6;

  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  *(void *)uint64_t result = a2;
  *(void *)(result + _Block_object_dispose(&a9, 8) = v6;
  *(void *)(result + 16) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(result + 40) = 0;
  *(void *)(result + 4_Block_object_dispose(&a9, 8) = 0;
  *(void *)(result + 24) = a4;
  *(void *)(result + 32) = result + 40;
  *(_DWORD *)(result + 56) = 0;
  *(_DWORD *)(result + 60) = a5;
  return result;
}

void health::FormatString<std::string,unsigned long long &>(std::string *a1, std::string *a2, uint64_t a3, uint64_t a4)
{
  v4[0] = a4;
  v4[1] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<std::string,unsigned long long &>(a2, a1, 0, v4);
}

void sub_1BCD22B2C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::WriteAheadLog::EntryTypeToString(std::string *a1, int a2)
{
  switch(a2)
  {
    case 0:
      uint64_t v2 = "Start";
      goto LABEL_8;
    case 1:
      uint64_t v2 = "Commit";
      goto LABEL_8;
    case 2:
      uint64_t v2 = "Rollback";
      goto LABEL_8;
    case 3:
      uint64_t v2 = "PageUpdate";
      goto LABEL_8;
    default:
      if (a2 == 99)
      {
        uint64_t v2 = "Unknown";
LABEL_8:
        std::string::basic_string[abi:ne180100]<0>(a1, v2);
      }
      else
      {
        int v3 = a2;
        uint64_t v4 = (unsigned int *)&v3;
        a1->__r_.__value_.__l.__size_ = 0;
        a1->__r_.__value_.__r.__words[2] = 0;
        a1->__r_.__value_.__r.__words[0] = 0;
        health::FormatImplementation<unsigned int>((std::string *)"Invalid({0})", a1, 0, &v4);
      }
      return;
  }
}

void sub_1BCD22C2C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::shared_ptr<health::WriteAheadLog::Transaction>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::shared_ptr<health::WriteAheadLog::Transaction>>::__clear[abi:ne180100]((uint64_t *)v2);
    int v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::shared_ptr<health::WriteAheadLog::Transaction>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  a1[1] = v2;
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::shared_ptr<health::WriteAheadLog::Transaction> *,std::shared_ptr<health::WriteAheadLog::Transaction> *,std::shared_ptr<health::WriteAheadLog::Transaction> *>(long long *a1, long long *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      long long v6 = *v5;
      *(void *)uint64_t v5 = 0;
      *((void *)v5 + 1) = 0;
      uint64_t v7 = *(std::__shared_weak_count **)(a3 + 8);
      *(_OWORD *)a3 = v6;
      if (v7) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v7);
      }
      ++v5;
      a3 += 16;
    }
    while (v5 != a2);
  }
  return a3;
}

void health::FormatImplementation<unsigned int>(std::string *a1, std::string *a2, std::string::size_type a3, unsigned int **a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  for (uint64_t i = (char *)a1; ; ++i)
  {
    int v28 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    int v28 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    int v28 = i + 2;
    int v18 = i[2];
    if ((v18 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v19 = 0;
      std::string v20 = i + 3;
      do
      {
        int v28 = v20;
        uint64_t v19 = (v18 - 48) + 10 * v19;
        int v21 = *v20++;
        int v18 = v21;
      }
      while ((v21 - 58) >= 0xFFFFFFF6);
      int v28 = v20;
      if (*(v20 - 1) == 125) {
        health::FormatterParameters<0ul,unsigned int>::formatOptionsAtIndex<unsigned int>(v19);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v24, (const char **)&v28);
  if (v25)
  {
    uint64_t v23 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v23, "Parameter index out of bounds.");
    __cxa_throw(v23, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  BOOL v12 = v28;
  health::TypeFormatter<unsigned int,void>::TypeFormatter((uint64_t)v29, **a4, (uint64_t)v24);
  if (v30 && !*(unsigned char *)(v29[0] + 48)) {
    uint64_t v13 = 32;
  }
  else {
    uint64_t v13 = 33;
  }
  unint64_t v14 = v13 - v29[5];
  if (*(unsigned char *)(v29[0] + 50) && v14 <= *(void *)(v29[0] + 24)) {
    unint64_t v14 = *(void *)(v29[0] + 24);
  }
  unint64_t v15 = v27;
  if (v27 <= v14) {
    unint64_t v15 = v14;
  }
  if (v26) {
    unint64_t v16 = v15;
  }
  else {
    unint64_t v16 = v14;
  }
  health::FormatImplementation<unsigned int>(v12, a2, v16 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v17 = (char *)a2;
  }
  else {
    uint64_t v17 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned int>(v24, &v17[a3 - v8], v29);
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BCD23050(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned int>::formatOptionsAtIndex<unsigned int>(uint64_t a1)
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  int v3 = exception;
  if (a1) {
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else {
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v3, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD230DC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned int>(char *result, char *a2, uint64_t *a3)
{
  int v3 = a2;
  uint64_t v4 = result;
  uint64_t v5 = *a3;
  if (*((unsigned char *)a3 + 48) && !*(unsigned char *)(v5 + 48)) {
    uint64_t v6 = 32;
  }
  else {
    uint64_t v6 = 33;
  }
  unint64_t v7 = v6 - a3[5];
  if (*(unsigned char *)(v5 + 50))
  {
    unint64_t v8 = *(void *)(v5 + 24);
    if (v7 <= v8) {
      unint64_t v7 = v8;
    }
  }
  if (!result[16] || (unint64_t v9 = *((void *)result + 3), v10 = v9 - v7, v9 <= v7))
  {
LABEL_16:
    return health::TypeFormatter<unsigned int,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
  }
  int v11 = *(_DWORD *)result;
  if (*(_DWORD *)result)
  {
    if (v11 != 1)
    {
      if (v11 != 2) {
        return result;
      }
      if (v9 != v7)
      {
        BOOL v12 = a2;
        int v3 = &a2[v9 - v7];
        do
        {
          *v12++ = result[52];
          --v10;
        }
        while (v10);
      }
      goto LABEL_16;
    }
    unint64_t v14 = v10 >> 1;
    if (v10 >= 2)
    {
      if (v14 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = v10 >> 1;
      }
      do
      {
        *v3++ = result[52];
        --v15;
      }
      while (v15);
    }
    uint64_t result = health::TypeFormatter<unsigned int,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
    if (v10 != v14)
    {
      unint64_t v16 = v10 - (v10 >> 1);
      uint64_t v17 = &v3[v7];
      if (v16 <= 1) {
        unint64_t v16 = 1;
      }
      uint64_t v18 = -(uint64_t)v16;
      do
        *v17++ = v4[52];
      while (!__CFADD__(v18++, 1));
    }
  }
  else
  {
    uint64_t result = health::TypeFormatter<unsigned int,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, a2);
    if (v9 != v7)
    {
      uint64_t v13 = &v3[v7];
      do
      {
        *v13++ = v4[52];
        --v10;
      }
      while (v10);
    }
  }
  return result;
}

uint64_t health::TypeFormatter<unsigned int,void>::TypeFormatter(uint64_t result, unsigned int a2, uint64_t a3)
{
  *(void *)uint64_t result = a3;
  *(void *)(result + 40) = 0;
  *(unsigned char *)(result + 4_Block_object_dispose(&a9, 8) = 1;
  switch(*(_DWORD *)(a3 + 4))
  {
    case 0:
      uint64_t v3 = 39;
      do
      {
        *(unsigned char *)(result + v3--) = (a2 % 0xA) | 0x30;
        BOOL v4 = a2 >= 0xA;
        a2 /= 0xAu;
      }
      while (v4);
      goto LABEL_16;
    case 1:
      uint64_t v3 = 39;
      do
      {
        *(unsigned char *)(result + v3--) = a2 & 7 | 0x30;
        BOOL v4 = a2 >= 8;
        a2 >>= 3;
      }
      while (v4);
      goto LABEL_16;
    case 2:
      if (*(unsigned char *)(a3 + 51)) {
        uint64_t v5 = &health::TypeFormatterUpperHexMapping;
      }
      else {
        uint64_t v5 = &health::TypeFormatterLowerHexMapping;
      }
      uint64_t v3 = 39;
      do
      {
        *(unsigned char *)(result + v3--) = v5[a2 & 0xF];
        BOOL v4 = a2 >= 0x10;
        a2 >>= 4;
      }
      while (v4);
      goto LABEL_16;
    case 3:
      uint64_t v3 = 39;
      do
      {
        *(unsigned char *)(result + v3--) = a2 & 1 | 0x30;
        BOOL v4 = a2 >= 2;
        a2 >>= 1;
      }
      while (v4);
LABEL_16:
      *(void *)(result + 40) = v3 - 7;
      break;
    default:
      return result;
  }
  return result;
}

char *health::TypeFormatter<unsigned int,void>::formatAtLocation<std::__wrap_iter<char *>>(char *result, char *a2)
{
  uint64_t v3 = result + 40;
  uint64_t v2 = *((void *)result + 5);
  if (result[48])
  {
    uint64_t v4 = *(void *)result;
    if (!*(unsigned char *)(*(void *)result + 48))
    {
      uint64_t v6 = 0;
      goto LABEL_7;
    }
    char v5 = *(unsigned char *)(v4 + 49);
  }
  else
  {
    char v5 = 45;
  }
  *a2++ = v5;
  uint64_t v4 = *(void *)result;
  uint64_t v6 = 1;
LABEL_7:
  if (*(unsigned char *)(v4 + 16))
  {
    if (*(unsigned char *)(v4 + 50))
    {
      unint64_t v7 = v6 - v2 + 32;
      if (v7 < *(void *)(v4 + 24))
      {
        do
        {
          *a2++ = 48;
          ++v7;
        }
        while (v7 < *(void *)(*(void *)result + 24));
      }
    }
  }
  unint64_t v8 = &result[*((void *)result + 5) + 8];
  if (v3 != v8) {
    return (char *)memmove(a2, v8, v3 - v8);
  }
  return result;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](a1 + 112);
  return a1;
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<health::WriteAheadLog::PageEntry>>>>::destroy(a1, a2[1]);
    uint64_t v4 = (void *)a2[5];
    if (v4)
    {
      a2[6] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  float v7 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    BOOL v9 = 1;
    if (v6 >= 3) {
      BOOL v9 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v10 = v9 | (2 * v6);
    unint64_t v11 = vcvtps_u32_f32(v7 / v8);
    if (v10 <= v11) {
      int8x8_t prime = (int8x8_t)v11;
    }
    else {
      int8x8_t prime = (int8x8_t)v10;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *(void *)(a1 + 8);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_74;
    }
    if (*(void *)&prime >= v6) {
      goto LABEL_43;
    }
    unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v6 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
    {
      unint64_t v19 = std::__next_prime(v19);
    }
    else
    {
      uint64_t v21 = 1 << -(char)__clz(v19 - 1);
      if (v19 >= 2) {
        unint64_t v19 = v21;
      }
    }
    if (*(void *)&prime <= v19) {
      int8x8_t prime = (int8x8_t)v19;
    }
    if (*(void *)&prime >= v6)
    {
      unint64_t v6 = *(void *)(a1 + 8);
      goto LABEL_43;
    }
    if (prime)
    {
LABEL_74:
      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v13 = operator new(8 * *(void *)&prime);
      unint64_t v14 = *(void **)a1;
      *(void *)a1 = v13;
      if (v14) {
        operator delete(v14);
      }
      uint64_t v15 = 0;
      *(int8x8_t *)(a1 + _Block_object_dispose(&a9, 8) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v15++) = 0;
      while (*(void *)&prime != v15);
      unint64_t v16 = *(void **)(a1 + 16);
      if (v16)
      {
        unint64_t v17 = v16[1];
        uint8x8_t v18 = (uint8x8_t)vcnt_s8(prime);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          if (v17 >= *(void *)&prime) {
            v17 %= *(void *)&prime;
          }
        }
        else
        {
          v17 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)a1 + 8 * v17) = a1 + 16;
        for (uint64_t i = (void *)*v16; *v16; uint64_t i = (void *)*v16)
        {
          unint64_t v23 = i[1];
          if (v18.u32[0] > 1uLL)
          {
            if (v23 >= *(void *)&prime) {
              v23 %= *(void *)&prime;
            }
          }
          else
          {
            v23 &= *(void *)&prime - 1;
          }
          if (v23 == v17)
          {
            unint64_t v16 = i;
          }
          else
          {
            std::string v24 = i;
            if (*(void *)(*(void *)a1 + 8 * v23))
            {
              do
              {
                uint64_t v25 = v24;
                std::string v24 = (void *)*v24;
              }
              while (v24 && i[2] == v24[2]);
              void *v16 = v24;
              void *v25 = **(void **)(*(void *)a1 + 8 * v23);
              **(void **)(*(void *)a1 + 8 * v23) = i;
            }
            else
            {
              *(void *)(*(void *)a1 + 8 * v23) = v16;
              unint64_t v16 = i;
              unint64_t v17 = v23;
            }
          }
        }
      }
      unint64_t v6 = (unint64_t)prime;
    }
    else
    {
      uint64_t v35 = *(void **)a1;
      *(void *)a1 = 0;
      if (v35) {
        operator delete(v35);
      }
      unint64_t v6 = 0;
      *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
    }
  }
LABEL_43:
  uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v26.i16[0] = vaddlv_u8(v26);
  if (v26.u32[0] > 1uLL)
  {
    unint64_t v27 = a2;
    if (v6 <= a2) {
      unint64_t v27 = a2 % v6;
    }
  }
  else
  {
    unint64_t v27 = (v6 - 1) & a2;
  }
  int v28 = *(void **)(*(void *)a1 + 8 * v27);
  if (!v28) {
    return 0;
  }
  int v29 = 0;
  do
  {
    uint64_t result = v28;
    int v28 = (void *)*v28;
    if (!v28) {
      break;
    }
    unint64_t v31 = v28[1];
    if (v26.u32[0] > 1uLL)
    {
      unint64_t v32 = v28[1];
      if (v31 >= v6) {
        unint64_t v32 = v31 % v6;
      }
    }
    else
    {
      unint64_t v32 = v31 & (v6 - 1);
    }
    if (v32 != v27) {
      break;
    }
    BOOL v33 = v31 == a2 && v28[2] == *a3;
    int v34 = v29 & !v33;
    v29 |= v33;
  }
  while (v34 != 1);
  return result;
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_perform(void *result, void *a2, void *a3)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(void *)(*result + 8 * v4) = result + 2;
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
LABEL_18:
    *(void *)(*result + 8 * v6) = a2;
    goto LABEL_19;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
    if (v6 != v4) {
      goto LABEL_18;
    }
  }
LABEL_19:
  ++result[3];
  return result;
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_multi<unsigned long long const&>(void *a1, unint64_t *a2)
{
  unint64_t v4 = operator new(0x18uLL);
  unint64_t v5 = *a2;
  uint64_t v4[2] = *a2;
  void *v4 = 0;
  v4[1] = v5;
  inserted = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_prepare((uint64_t)a1, v5, v4 + 2);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_perform(a1, v4, inserted);
  return v4;
}

void sub_1BCD23A78(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(unsigned long long)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  unint64_t v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  uint64_t result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }
        else
        {
          v8 &= *(void *)&v2 - 1;
        }
        if (v8 != v5) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = __p;
  std::string __p = 0;
  if (v3) {
    operator delete(v3);
  }
  return v2;
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  unint64_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    float v7 = v6;
    unint64_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  *float v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + _Block_object_dispose(&a9, 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void health::WriteAheadLog::runWriteTransaction(unsigned long long,health::WriteAheadLog::CommitMode,std::function<BOOL ()(unsigned long long)>,std::function<void ()(unsigned long long)>,std::function<void ()(unsigned long long,health::FilePage const&)>,std::function<void ()(unsigned long long)>)::$_1::operator()(uint64_t a1)
{
  void v7[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(std::mutex **)a1;
  __lk.__m_ = v2;
  __lk.__owns_ = 1;
  std::mutex::lock(v2);
  uint64_t v3 = **(void **)(a1 + 16);
  if (**(unsigned char **)(a1 + 8))
  {
    health::WriteAheadLog::_walLock_commitTransaction((health::WriteAheadLog *)v2, v3);
    **(unsigned char **)(a1 + 24) = 1;
  }
  else
  {
    health::WriteAheadLog::_walLock_rollbackTransaction((health::WriteAheadLog *)v2, v3);
  }
  if (health::WriteAheadLog::_walLock_shouldCheckpointForMode((uint64_t)v2, **(_DWORD **)(a1 + 32)))
  {
    std::__function::__value_func<void ()(unsigned long long)>::__value_func[abi:ne180100]((uint64_t)v7, *(void *)(a1 + 40));
    std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::__value_func[abi:ne180100]((uint64_t)v6, *(void *)(a1 + 48));
    std::__function::__value_func<void ()(unsigned long long)>::__value_func[abi:ne180100]((uint64_t)v5, *(void *)(a1 + 56));
    health::WriteAheadLog::_walLock_checkpointWhenIdle((uint64_t)v2, &__lk, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5);
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v5);
    std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::~__value_func[abi:ne180100](v6);
    std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](v7);
  }
  health::WriteAheadLog::_walLock_pruneCommittedPages(v2);
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
}

void sub_1BCD23F04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, char a11, int a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100](&a13);
  std::__function::__value_func<void ()(unsigned long long,health::FilePage const&)>::~__value_func[abi:ne180100](&a17);
  std::__function::__value_func<void ()(unsigned long long)>::~__value_func[abi:ne180100]((void *)(v17 - 56));
  if (a11) {
    std::mutex::unlock(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t std::function<BOOL ()(unsigned long long)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

void health::FormatImplementation<unsigned long long &,unsigned long long>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (char *)a1;
  for (std::string::size_type i = a3; ; ++i)
  {
    char v55 = v10;
    if (*v10 == 123) {
      break;
    }
    if (!*v10)
    {
      std::string::resize(a2, i, 0);
      if (i != a3)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, i - a3, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v10;
    ++v8;
  }
  int v12 = v10[1];
  if (v12 == 123)
  {
    char v55 = v10 + 1;
    char v9 = 1;
    ++v10;
    goto LABEL_7;
  }
  if (v12 == 42)
  {
    char v55 = v10 + 2;
    int v42 = v10[2];
    if ((v42 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v43 = 0;
      long long v44 = v10 + 3;
      do
      {
        char v55 = v44;
        uint64_t v43 = (v42 - 48) + 10 * v43;
        int v45 = *v44++;
        int v42 = v45;
      }
      while ((v45 - 58) >= 0xFFFFFFF6);
      char v55 = v44;
      if (*(v44 - 1) == 125) {
        health::FormatterParameters<0ul,unsigned long long &,unsigned long long>::formatOptionsAtIndex<unsigned long long &,unsigned long long>(v43);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v49, (const char **)&v55);
  uint64_t v13 = v55;
  if (v50)
  {
    if (v50 != 1)
    {
      long long v47 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v47, "Parameter index out of bounds.");
      __cxa_throw(v47, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    unint64_t v14 = **(void **)a4;
    uint64_t v15 = v49;
    __p[0] = v49;
    uint64_t v58 = 0;
    int v16 = 1;
    unsigned __int8 v59 = 1;
    switch(v49[1])
    {
      case 0:
        uint64_t v17 = 71;
        do
        {
          *((unsigned char *)__p + v17--) = (v14 % 0xA) | 0x30;
          BOOL v18 = v14 >= 0xA;
          v14 /= 0xAuLL;
        }
        while (v18);
        goto LABEL_40;
      case 1:
        uint64_t v17 = 71;
        do
        {
          *((unsigned char *)__p + v17--) = v14 & 7 | 0x30;
          BOOL v18 = v14 >= 8;
          v14 >>= 3;
        }
        while (v18);
        goto LABEL_40;
      case 2:
        unint64_t v23 = &health::TypeFormatterUpperHexMapping;
        if (!v53) {
          unint64_t v23 = &health::TypeFormatterLowerHexMapping;
        }
        uint64_t v17 = 71;
        do
        {
          *((unsigned char *)__p + v17--) = v23[v14 & 0xF];
          BOOL v18 = v14 >= 0x10;
          v14 >>= 4;
        }
        while (v18);
        goto LABEL_40;
      case 3:
        uint64_t v17 = 71;
        do
        {
          *((unsigned char *)__p + v17--) = v14 & 1 | 0x30;
          BOOL v18 = v14 >= 2;
          v14 >>= 1;
        }
        while (v18);
LABEL_40:
        uint64_t v24 = v17 - 7;
        uint64_t v58 = v17 - 7;
        int v16 = v59;
        uint64_t v15 = __p[0];
        if (!v59) {
          goto LABEL_44;
        }
        goto LABEL_43;
      default:
        uint64_t v24 = 0;
LABEL_43:
        if (*((unsigned char *)v15 + 48)) {
LABEL_44:
        }
          uint64_t v25 = 65;
        else {
          uint64_t v25 = 64;
        }
        unint64_t v26 = v25 - v24;
        if (*((unsigned char *)v15 + 50) && v26 <= *((void *)v15 + 3)) {
          unint64_t v26 = *((void *)v15 + 3);
        }
        unint64_t v27 = v52;
        if (v52 <= v26) {
          unint64_t v27 = v26;
        }
        if (v51) {
          unint64_t v26 = v27;
        }
        health::FormatImplementation<unsigned long long &,unsigned long long>(v13, a2, v26 + i, a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v28 = (std::string::size_type)a2;
        }
        else {
          std::string::size_type v28 = a2->__r_.__value_.__r.__words[0];
        }
        if (v16 && !*((unsigned char *)v15 + 48)) {
          uint64_t v29 = 64;
        }
        else {
          uint64_t v29 = 65;
        }
        char v30 = (char *)(v28 + i);
        unint64_t v31 = v29 - v24;
        if (*((unsigned char *)v15 + 50) && v31 <= *((void *)v15 + 3)) {
          unint64_t v31 = *((void *)v15 + 3);
        }
        if (!v51) {
          goto LABEL_72;
        }
        unint64_t v32 = v52;
        unint64_t v33 = v52 - v31;
        if (v52 <= v31) {
          goto LABEL_72;
        }
        if (v49[0])
        {
          if (v49[0] == 1)
          {
            unint64_t v35 = v33 >> 1;
            if (v33 >= 2)
            {
              if (v35 <= 1) {
                uint64_t v38 = 1;
              }
              else {
                uint64_t v38 = v33 >> 1;
              }
              long long v36 = (char *)(v28 + v8 + a3 + v38);
              do
              {
                *v30++ = v54;
                --v38;
              }
              while (v38);
            }
            else
            {
              long long v36 = (char *)(v28 + i);
            }
            health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)__p, v36);
            if (v33 != v35)
            {
              unint64_t v39 = v33 - (v33 >> 1);
              uint64_t v40 = &v30[v31];
              if (v39 <= 1) {
                unint64_t v39 = 1;
              }
              uint64_t v41 = -(uint64_t)v39;
              do
              {
                *v40++ = v54;
                BOOL v18 = __CFADD__(v41++, 1);
              }
              while (!v18);
            }
          }
          else if (v49[0] == 2)
          {
            if (v52 != v31)
            {
              uint64_t v34 = -(uint64_t)v28;
              do
              {
                *(unsigned char *)(v28 + i) = v54;
                ++v28;
                --v34;
                --v33;
              }
              while (v33);
              char v30 = (char *)(i - v34);
            }
LABEL_72:
            health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)__p, v30);
          }
        }
        else
        {
          health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)__p, (char *)(v28 + i));
          if (v32 != v31)
          {
            std::string::size_type v37 = v28 + v31;
            do
            {
              *(unsigned char *)(v37 + i) = v54;
              ++v37;
              --v33;
            }
            while (v33);
          }
        }
        uint64_t v22 = a1;
        break;
    }
  }
  else
  {
    health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)__p, *(void *)(a4 + 8), (uint64_t)v49);
    unint64_t v19 = v57;
    if ((v57 & 0x80u) != 0) {
      unint64_t v19 = (unint64_t)__p[1];
    }
    unint64_t v20 = v52;
    if (v52 <= v19) {
      unint64_t v20 = v19;
    }
    if (v51) {
      unint64_t v19 = v20;
    }
    health::FormatImplementation<unsigned long long &,unsigned long long>(v13, a2, v19 + i, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v21 = (char *)a2;
    }
    else {
      uint64_t v21 = (char *)a2->__r_.__value_.__r.__words[0];
    }
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v49, &v21[i], (const void **)__p);
    uint64_t v22 = a1;
    if ((char)v57 < 0) {
      operator delete(__p[0]);
    }
  }
  if (i != a3) {
    health::CopyFormatSectionToResult(v22, a2, a3, i - a3, v9 & 1);
  }
}

void sub_1BCD2457C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned long long &,unsigned long long>::formatOptionsAtIndex<unsigned long long &,unsigned long long>(uint64_t a1)
{
  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v1 = exception;
    if (a1 == 1) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD24658(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned char *health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(unsigned char *result, char *__dst, const void **a3)
{
  size_t v4 = *((unsigned __int8 *)a3 + 23);
  char v5 = v4;
  size_t v6 = (size_t)a3[1];
  if ((v4 & 0x80u) == 0) {
    size_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v7 = (size_t)a3[1];
  }
  if (!result[16] || (uint64_t v8 = result, v9 = *((void *)result + 3), v10 = v9 - v7, v9 <= v7))
  {
    if (!v7) {
      return result;
    }
    if ((v4 & 0x80u) == 0) {
      int v12 = a3;
    }
    else {
      int v12 = *a3;
    }
    uint64_t v13 = __dst;
    size_t v14 = v7;
    goto LABEL_24;
  }
  int v11 = *(_DWORD *)result;
  if (*(_DWORD *)result)
  {
    if (v11 == 1)
    {
      unint64_t v17 = v10 >> 1;
      if (v10 >= 2)
      {
        if (v17 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v10 >> 1;
        }
        do
        {
          *__dst++ = result[52];
          --v18;
        }
        while (v18);
        size_t v4 = *((unsigned __int8 *)a3 + 23);
        size_t v6 = (size_t)a3[1];
        char v5 = *((unsigned char *)a3 + 23);
      }
      if (v5 < 0) {
        size_t v4 = v6;
      }
      if (v4)
      {
        if (v5 >= 0) {
          unint64_t v19 = a3;
        }
        else {
          unint64_t v19 = *a3;
        }
        uint64_t result = memmove(__dst, v19, v4);
      }
      if (v10 != v17)
      {
        unint64_t v20 = v10 - (v10 >> 1);
        uint64_t v21 = &__dst[v7];
        if (v20 <= 1) {
          unint64_t v20 = 1;
        }
        uint64_t v22 = -(uint64_t)v20;
        do
          *v21++ = v8[52];
        while (!__CFADD__(v22++, 1));
      }
    }
    else if (v11 == 2)
    {
      if (v9 != v7)
      {
        do
        {
          *__dst++ = result[52];
          --v10;
        }
        while (v10);
        size_t v4 = *((unsigned __int8 *)a3 + 23);
        size_t v6 = (size_t)a3[1];
        char v5 = *((unsigned char *)a3 + 23);
      }
      if (v5 < 0) {
        size_t v4 = v6;
      }
      if (v4)
      {
        if (v5 >= 0) {
          int v12 = a3;
        }
        else {
          int v12 = *a3;
        }
        uint64_t v13 = __dst;
        size_t v14 = v4;
LABEL_24:
        return memmove(v13, v12, v14);
      }
    }
  }
  else
  {
    if (v7)
    {
      if ((v4 & 0x80u) == 0) {
        uint64_t v15 = a3;
      }
      else {
        uint64_t v15 = *a3;
      }
      uint64_t result = memmove(__dst, v15, v7);
    }
    if (v9 != v7)
    {
      int v16 = &__dst[v7];
      do
      {
        *v16++ = v8[52];
        --v10;
      }
      while (v10);
    }
  }
  return result;
}

char *health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>(char *result, char *a2)
{
  uint64_t v3 = result + 72;
  uint64_t v2 = *((void *)result + 9);
  if (result[80])
  {
    uint64_t v4 = *(void *)result;
    if (!*(unsigned char *)(*(void *)result + 48))
    {
      uint64_t v6 = 0;
      goto LABEL_7;
    }
    char v5 = *(unsigned char *)(v4 + 49);
  }
  else
  {
    char v5 = 45;
  }
  *a2++ = v5;
  uint64_t v4 = *(void *)result;
  uint64_t v6 = 1;
LABEL_7:
  if (*(unsigned char *)(v4 + 16))
  {
    if (*(unsigned char *)(v4 + 50))
    {
      unint64_t v7 = v6 - v2 + 64;
      if (v7 < *(void *)(v4 + 24))
      {
        do
        {
          *a2++ = 48;
          ++v7;
        }
        while (v7 < *(void *)(*(void *)result + 24));
      }
    }
  }
  uint64_t v8 = &result[*((void *)result + 9) + 8];
  if (v3 != v8) {
    return (char *)memmove(a2, v8, v3 - v8);
  }
  return result;
}

uint64_t health::TypeFormatter<unsigned long long &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  uint64_t v5 = v12;
  if (*(unsigned char *)(a3 + 16)) {
    *(void *)((char *)&v13[2] + *(void *)(v12 - 24)) = *(void *)(a3 + 24);
  }
  if (*(unsigned char *)(a3 + 32)) {
    *(void *)((char *)&v13[1] + *(void *)(v5 - 24)) = *(void *)(a3 + 40);
  }
  uint64_t v6 = (const std::ios_base *)((char *)&v13[-1] + *(void *)(v5 - 24));
  std::ios_base::fmtflags v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    uint64_t v8 = std::locale::use_facet(v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(void *)(a1 + 16) = v11;
  uint64_t v12 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v13[-1] + *(void *)(v12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v13[0] = MEMORY[0x1E4FBA470] + 16;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v15);
  return a1;
}

void sub_1BCD24B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0) {
    operator delete(*(void **)v13);
  }
  _Unwind_Resume(a1);
}

void health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  for (std::string::size_type i = (char *)a1; ; ++i)
  {
    unint64_t v35 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    unint64_t v35 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    unint64_t v35 = i + 2;
    int v25 = i[2];
    if ((v25 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v26 = 0;
      unint64_t v27 = i + 3;
      do
      {
        unint64_t v35 = v27;
        uint64_t v26 = (v25 - 48) + 10 * v26;
        int v28 = *v27++;
        int v25 = v28;
      }
      while ((v28 - 58) >= 0xFFFFFFF6);
      unint64_t v35 = v27;
      if (*(v27 - 1) == 125) {
        health::FormatterParameters<0ul,long long &,unsigned long,unsigned long long &,unsigned long long &>::formatOptionsAtIndex<long long &,unsigned long,unsigned long long &,unsigned long long &>(v26);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v31, (const char **)&v35);
  uint64_t v12 = v35;
  switch(v32)
  {
    case 0:
      health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, *(void *)(a4 + 24), (uint64_t)v31);
      unint64_t v13 = v38;
      if ((v38 & 0x80u) != 0) {
        unint64_t v13 = v37;
      }
      unint64_t v14 = v34;
      if (v34 <= v13) {
        unint64_t v14 = v13;
      }
      if (v33) {
        unint64_t v13 = v14;
      }
      health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = (char *)a2;
      }
      else {
        uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_41;
    case 1:
      health::TypeFormatter<unsigned long,void>::TypeFormatter((uint64_t)&__p, **(void **)(a4 + 16), (uint64_t)v31);
      if (v40 && !*((unsigned char *)__p + 48)) {
        uint64_t v20 = 64;
      }
      else {
        uint64_t v20 = 65;
      }
      unint64_t v21 = v20 - v39;
      if (*((unsigned char *)__p + 50) && v21 <= *((void *)__p + 3)) {
        unint64_t v21 = *((void *)__p + 3);
      }
      unint64_t v22 = v34;
      if (v34 <= v21) {
        unint64_t v22 = v21;
      }
      if (v33) {
        unint64_t v23 = v22;
      }
      else {
        unint64_t v23 = v21;
      }
      health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>(v12, a2, v23 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v24 = (char *)a2;
      }
      else {
        uint64_t v24 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long>(v31, &v24[a3 + v8], (uint64_t *)&__p);
      goto LABEL_59;
    case 2:
      health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)&__p, *(void *)(a4 + 8), (uint64_t)v31);
      unint64_t v16 = v38;
      if ((v38 & 0x80u) != 0) {
        unint64_t v16 = v37;
      }
      unint64_t v17 = v34;
      if (v34 <= v16) {
        unint64_t v17 = v16;
      }
      if (v33) {
        unint64_t v16 = v17;
      }
      health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>(v12, a2, v16 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = (char *)a2;
      }
      else {
        uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_41;
    case 3:
      health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)&__p, *(void *)a4, (uint64_t)v31);
      unint64_t v18 = v38;
      if ((v38 & 0x80u) != 0) {
        unint64_t v18 = v37;
      }
      unint64_t v19 = v34;
      if (v34 <= v18) {
        unint64_t v19 = v18;
      }
      if (v33) {
        unint64_t v18 = v19;
      }
      health::FormatImplementation<long long &,unsigned long,unsigned long long &,unsigned long long &>(v12, a2, v18 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = (char *)a2;
      }
      else {
        uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
LABEL_41:
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v31, &v15[a3 + v8], (const void **)&__p);
      if ((char)v38 < 0) {
        operator delete(__p);
      }
LABEL_59:
      if (v8) {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      break;
    default:
      char v30 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(v30, "Parameter index out of bounds.");
      __cxa_throw(v30, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
}

void sub_1BCD24FE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,unsigned long,unsigned long long &,unsigned long long &>::formatOptionsAtIndex<long long &,unsigned long,unsigned long long &,unsigned long long &>(uint64_t a1)
{
  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    uint64_t v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3) {
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
    }
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD25110(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long>(char *result, char *a2, uint64_t *a3)
{
  uint64_t v3 = a2;
  uint64_t v4 = result;
  uint64_t v5 = *a3;
  if (*((unsigned char *)a3 + 80) && !*(unsigned char *)(v5 + 48)) {
    uint64_t v6 = 64;
  }
  else {
    uint64_t v6 = 65;
  }
  unint64_t v7 = v6 - a3[9];
  if (*(unsigned char *)(v5 + 50))
  {
    unint64_t v8 = *(void *)(v5 + 24);
    if (v7 <= v8) {
      unint64_t v7 = v8;
    }
  }
  if (!result[16] || (unint64_t v9 = *((void *)result + 3), v10 = v9 - v7, v9 <= v7))
  {
LABEL_16:
    return health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
  }
  int v11 = *(_DWORD *)result;
  if (*(_DWORD *)result)
  {
    if (v11 != 1)
    {
      if (v11 != 2) {
        return result;
      }
      if (v9 != v7)
      {
        uint64_t v12 = a2;
        uint64_t v3 = &a2[v9 - v7];
        do
        {
          *v12++ = result[52];
          --v10;
        }
        while (v10);
      }
      goto LABEL_16;
    }
    unint64_t v14 = v10 >> 1;
    if (v10 >= 2)
    {
      if (v14 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = v10 >> 1;
      }
      do
      {
        *v3++ = result[52];
        --v15;
      }
      while (v15);
    }
    uint64_t result = health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, v3);
    if (v10 != v14)
    {
      unint64_t v16 = v10 - (v10 >> 1);
      unint64_t v17 = &v3[v7];
      if (v16 <= 1) {
        unint64_t v16 = 1;
      }
      uint64_t v18 = -(uint64_t)v16;
      do
        *v17++ = v4[52];
      while (!__CFADD__(v18++, 1));
    }
  }
  else
  {
    uint64_t result = health::TypeFormatter<unsigned long long,void>::formatAtLocation<std::__wrap_iter<char *>>((char *)a3, a2);
    if (v9 != v7)
    {
      unint64_t v13 = &v3[v7];
      do
      {
        *v13++ = v4[52];
        --v10;
      }
      while (v10);
    }
  }
  return result;
}

uint64_t health::TypeFormatter<unsigned long,void>::TypeFormatter(uint64_t result, unint64_t a2, uint64_t a3)
{
  *(void *)uint64_t result = a3;
  *(void *)(result + 72) = 0;
  *(unsigned char *)(result + 80) = 1;
  switch(*(_DWORD *)(a3 + 4))
  {
    case 0:
      uint64_t v3 = 71;
      do
      {
        *(unsigned char *)(result + v3--) = (a2 % 0xA) | 0x30;
        BOOL v4 = a2 >= 0xA;
        a2 /= 0xAuLL;
      }
      while (v4);
      goto LABEL_16;
    case 1:
      uint64_t v3 = 71;
      do
      {
        *(unsigned char *)(result + v3--) = a2 & 7 | 0x30;
        BOOL v4 = a2 >= 8;
        a2 >>= 3;
      }
      while (v4);
      goto LABEL_16;
    case 2:
      if (*(unsigned char *)(a3 + 51)) {
        uint64_t v5 = &health::TypeFormatterUpperHexMapping;
      }
      else {
        uint64_t v5 = &health::TypeFormatterLowerHexMapping;
      }
      uint64_t v3 = 71;
      do
      {
        *(unsigned char *)(result + v3--) = v5[a2 & 0xF];
        BOOL v4 = a2 >= 0x10;
        a2 >>= 4;
      }
      while (v4);
      goto LABEL_16;
    case 3:
      uint64_t v3 = 71;
      do
      {
        *(unsigned char *)(result + v3--) = a2 & 1 | 0x30;
        BOOL v4 = a2 >= 2;
        a2 >>= 1;
      }
      while (v4);
LABEL_16:
      *(void *)(result + 72) = v3 - 7;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t health::TypeFormatter<long long &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  uint64_t v5 = v12;
  if (*(unsigned char *)(a3 + 16)) {
    *(void *)((char *)&v13[2] + *(void *)(v12 - 24)) = *(void *)(a3 + 24);
  }
  if (*(unsigned char *)(a3 + 32)) {
    *(void *)((char *)&v13[1] + *(void *)(v5 - 24)) = *(void *)(a3 + 40);
  }
  uint64_t v6 = (const std::ios_base *)((char *)&v13[-1] + *(void *)(v5 - 24));
  std::ios_base::fmtflags v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    unint64_t v8 = std::locale::use_facet(v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(void *)(a1 + 16) = v11;
  uint64_t v12 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v13[-1] + *(void *)(v12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v13[0] = MEMORY[0x1E4FBA470] + 16;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v15);
  return a1;
}

void sub_1BCD25610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0) {
    operator delete(*(void **)v13);
  }
  _Unwind_Resume(a1);
}

void health::FormatString<char const*>(std::string *a1@<X0>, const char **a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v3 = a2;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<char const*>(a1, a3, 0, &v3);
}

void sub_1BCD25694(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<char const*>(std::string *a1, std::string *this, std::string::size_type a3, const char ***a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (std::string::size_type i = (char *)a1; ; ++i)
  {
    uint64_t v18 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(this, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    uint64_t v18 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    uint64_t v18 = i + 2;
    int v12 = i[2];
    if ((v12 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v13 = 0;
      char v14 = i + 3;
      do
      {
        uint64_t v18 = v14;
        uint64_t v13 = (v12 - 48) + 10 * v13;
        int v15 = *v14++;
        int v12 = v15;
      }
      while ((v15 - 58) >= 0xFFFFFFF6);
      uint64_t v18 = v14;
      if (*(v14 - 1) == 125) {
        health::FormatterParameters<0ul,char const*>::formatOptionsAtIndex<char const*>((uint64_t)a4, (uint64_t)a4, v13);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v17, (const char **)&v18);
  health::FormatterParameters<0ul,char const*>::formatParameterAtIndex<char const*>(a4, (int)a4, *((uint64_t *)&v17[0] + 1), v17, this, a3 - v8, (int)v18);
  if (v8) {
    health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
  }
}

void sub_1BCD258C0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,char const*>::formatOptionsAtIndex<char const*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    health::FormatterParameters<1ul>::formatOptionsAtIndex<char const*>();
  }
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD25940(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned char *health::FormatterParameters<0ul,char const*>::formatParameterAtIndex<char const*>(const char ***a1, int a2, uint64_t a3, long long *a4, std::string *this, uint64_t a6, int a7)
{
  if (a3)
  {
    health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,char const*>>();
  }
  int v11 = **a1;
  v15[0] = v11;
  if (v11) {
    int v11 = (const char *)strlen(v11);
  }
  v15[1] = v11;
  long long v12 = a4[1];
  long long v16 = *a4;
  long long v17 = v12;
  long long v18 = a4[2];
  uint64_t v19 = *((void *)a4 + 6);
  health::FormatImplementation<char const*>(a7, this);
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v13 = this;
  }
  else {
    uint64_t v13 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  return health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(a4, (unsigned char *)v13 + a6, (uint64_t)v15);
}

void health::FormatterParameters<1ul>::formatOptionsAtIndex<char const*>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD25AA4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,char const*>>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD25B00(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned char *health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(unsigned char *result, unsigned char *__dst, uint64_t a3)
{
  uint64_t v3 = __dst;
  size_t v4 = *(void *)(a3 + 8);
  size_t v5 = v4;
  if (!result[16] || (uint64_t v6 = result, v7 = *((void *)result + 3), v8 = v7 - v4, v7 <= v4))
  {
LABEL_9:
    if (v5)
    {
      unint64_t v10 = *(const void **)a3;
      return memmove(v3, v10, v5);
    }
    return result;
  }
  int v9 = *(_DWORD *)result;
  if (*(_DWORD *)result)
  {
    if (v9 != 1)
    {
      if (v9 != 2) {
        return result;
      }
      if (v7 != v4)
      {
        do
        {
          *v3++ = result[52];
          --v8;
        }
        while (v8);
        size_t v5 = *(void *)(a3 + 8);
      }
      goto LABEL_9;
    }
    unint64_t v12 = v8 >> 1;
    if (v8 >= 2)
    {
      if (v12 <= 1) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v8 >> 1;
      }
      do
      {
        *v3++ = result[52];
        --v13;
      }
      while (v13);
      size_t v5 = *(void *)(a3 + 8);
    }
    if (v5) {
      uint64_t result = memmove(v3, *(const void **)a3, v5);
    }
    if (v8 != v12)
    {
      unint64_t v14 = v8 - (v8 >> 1);
      int v15 = &v3[v4];
      if (v14 <= 1) {
        unint64_t v14 = 1;
      }
      uint64_t v16 = -(uint64_t)v14;
      do
        *v15++ = v6[52];
      while (!__CFADD__(v16++, 1));
    }
  }
  else
  {
    if (v4) {
      uint64_t result = memmove(__dst, *(const void **)a3, *(void *)(a3 + 8));
    }
    if (v7 != v4)
    {
      int v11 = &v3[v4];
      do
      {
        *v11++ = v6[52];
        --v8;
      }
      while (v8);
    }
  }
  return result;
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  size_t v5 = *(void **)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  uint64_t result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a3)
      {
        if (result[2] == a3) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= a2) {
            v7 %= a2;
          }
        }
        else
        {
          v7 &= a2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(float *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (std::string::size_type i = (void *)*v9; i; std::string::size_type i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  unint64_t v12 = operator new(0x18uLL);
  *unint64_t v12 = 0;
  v12[1] = v5;
  void v12[2] = a3;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
    goto LABEL_64;
  }
  BOOL v15 = 1;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    int8x8_t prime = (int8x8_t)v17;
  }
  else {
    int8x8_t prime = (int8x8_t)v16;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }
    else
    {
      uint64_t v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }
    if (*(void *)&prime <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      char v33 = *(void **)a1;
      *(void *)a1 = 0;
      if (v33) {
        operator delete(v33);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v19 = operator new(8 * *(void *)&prime);
  uint64_t v20 = *(void **)a1;
  *(void *)a1 = v19;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v21++) = 0;
  while (*(void *)&prime != v21);
  unint64_t v22 = (void *)*((void *)a1 + 2);
  if (v22)
  {
    unint64_t v23 = v22[1];
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&prime) {
        v23 %= *(void *)&prime;
      }
    }
    else
    {
      v23 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v23) = a1 + 4;
    int v28 = (void *)*v22;
    if (*v22)
    {
      do
      {
        unint64_t v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }
        else
        {
          v29 &= *(void *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(void *)(*(void *)a1 + 8 * v29))
          {
            *(void *)(*(void *)a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          void *v22 = *v28;
          void *v28 = **(void **)(*(void *)a1 + 8 * v29);
          **(void **)(*(void *)a1 + 8 * v29) = v28;
          int v28 = v22;
        }
        unint64_t v29 = v23;
LABEL_56:
        unint64_t v22 = v28;
        int v28 = (void *)*v28;
        unint64_t v23 = v29;
      }
      while (v28);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  char v30 = *(void **)a1;
  unint64_t v31 = *(void **)(*(void *)a1 + 8 * v5);
  if (v31)
  {
    *unint64_t v12 = *v31;
LABEL_72:
    void *v31 = v12;
    goto LABEL_73;
  }
  *unint64_t v12 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v12;
  v30[v5] = a1 + 4;
  if (*v12)
  {
    unint64_t v32 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    unint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
}

void sub_1BCD260E0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<int>(std::string *a1, std::string *this, std::string::size_type a3, int **a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (std::string::size_type i = (char *)a1; ; ++i)
  {
    uint64_t v19 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(this, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    uint64_t v19 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    uint64_t v19 = i + 2;
    int v12 = i[2];
    if ((v12 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v13 = 0;
      float v14 = i + 3;
      do
      {
        uint64_t v19 = v14;
        uint64_t v13 = (v12 - 48) + 10 * v13;
        int v15 = *v14++;
        int v12 = v15;
      }
      while ((v15 - 58) >= 0xFFFFFFF6);
      uint64_t v19 = v14;
      if (*(v14 - 1) == 125) {
        health::FormatterParameters<0ul,int>::formatOptionsAtIndex<int>((uint64_t)a4, (uint64_t)a4, v13);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v17, (const char **)&v19);
  health::FormatterParameters<0ul,int>::formatParameterAtIndex<int>(a4, (uint64_t)a4, v18, v17, this, a3 - v8, (int)v19);
  if (v8) {
    health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
  }
}

void sub_1BCD26304(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,int>::formatOptionsAtIndex<int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    health::FormatterParameters<1ul>::formatOptionsAtIndex<int>();
  }
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD26384(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *health::FormatterParameters<0ul,int>::formatParameterAtIndex<int>(int **a1, uint64_t a2, uint64_t a3, char *a4, std::string *a5, uint64_t a6, int a7)
{
  v13[7] = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,int>>();
  }
  health::TypeFormatter<int,void>::TypeFormatter((uint64_t)v13, **a1, (uint64_t)a4);
  health::FormatImplementation<int>(a7, a5);
  if ((a5->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v11 = (char *)a5;
  }
  else {
    int v11 = (char *)a5->__r_.__value_.__r.__words[0];
  }
  return health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned int>(a4, &v11[a6], v13);
}

void health::FormatterParameters<1ul>::formatOptionsAtIndex<int>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD2654C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,int>>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD265A8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<int,void>::TypeFormatter(uint64_t result, int a2, uint64_t a3)
{
  *(void *)uint64_t result = a3;
  *(void *)(result + 40) = 0;
  *(unsigned char *)(result + 4_Block_object_dispose(&a9, 8) = a2 >= 0;
  switch(*(_DWORD *)(a3 + 4))
  {
    case 0:
      uint64_t v3 = 39;
      if (a2 < 0)
      {
        do
        {
          int v11 = -a2;
          unsigned int v12 = a2 + 9;
          a2 /= 10;
          *(unsigned char *)(result + v3--) = v11 + 10 * a2 + 48;
        }
        while (v12 >= 0x13);
      }
      else
      {
        do
        {
          *(unsigned char *)(result + v3--) = (a2 % 0xAu) | 0x30;
          BOOL v4 = a2 >= 0xA;
          a2 /= 0xAu;
        }
        while (v4);
      }
      goto LABEL_26;
    case 1:
      if (a2 >= 0) {
        unsigned int v5 = a2;
      }
      else {
        unsigned int v5 = -a2;
      }
      uint64_t v3 = 39;
      do
      {
        *(unsigned char *)(result + v3--) = v5 & 7 | 0x30;
        BOOL v4 = v5 >= 8;
        v5 >>= 3;
      }
      while (v4);
      goto LABEL_26;
    case 2:
      uint64_t v6 = &health::TypeFormatterUpperHexMapping;
      if (!*(unsigned char *)(a3 + 51)) {
        uint64_t v6 = &health::TypeFormatterLowerHexMapping;
      }
      if (a2 >= 0) {
        unsigned int v7 = a2;
      }
      else {
        unsigned int v7 = -a2;
      }
      uint64_t v8 = 39;
      do
      {
        *(unsigned char *)(result + v8--) = v6[v7 & 0xF];
        BOOL v4 = v7 >= 0x10;
        v7 >>= 4;
      }
      while (v4);
      uint64_t v9 = v8 - 7;
      goto LABEL_27;
    case 3:
      if (a2 >= 0) {
        unsigned int v10 = a2;
      }
      else {
        unsigned int v10 = -a2;
      }
      uint64_t v3 = 39;
      do
      {
        *(unsigned char *)(result + v3--) = v10 & 1 | 0x30;
        BOOL v4 = v10 >= 2;
        v10 >>= 1;
      }
      while (v4);
LABEL_26:
      uint64_t v9 = v3 - 7;
LABEL_27:
      *(void *)(result + 40) = v9;
      break;
    default:
      return result;
  }
  return result;
}

void std::__shared_ptr_emplace<health::WriteAheadLog::Transaction>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F171DAF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<health::WriteAheadLog::Transaction>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F171DAF0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C187B8A0);
}

void health::FormatImplementation<unsigned long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (std::string::size_type i = (char *)a1; ; ++i)
  {
    unint64_t v25 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    unint64_t v25 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    unint64_t v25 = i + 2;
    int v16 = i[2];
    if ((v16 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v17 = 0;
      uint64_t v18 = i + 3;
      do
      {
        unint64_t v25 = v18;
        uint64_t v17 = (v16 - 48) + 10 * v17;
        int v19 = *v18++;
        int v16 = v19;
      }
      while ((v19 - 58) >= 0xFFFFFFF6);
      unint64_t v25 = v18;
      if (*(v18 - 1) == 125) {
        health::FormatterParameters<0ul,unsigned long long &>::formatOptionsAtIndex<unsigned long long &>(v17);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_35:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v21, (const char **)&v25);
  if (v22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    goto LABEL_35;
  }
  unsigned int v12 = v25;
  health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)__p, *a4, (uint64_t)v21);
  unint64_t v13 = v27;
  if ((v27 & 0x80u) != 0) {
    unint64_t v13 = (unint64_t)__p[1];
  }
  unint64_t v14 = v24;
  if (v24 <= v13) {
    unint64_t v14 = v13;
  }
  if (v23) {
    unint64_t v13 = v14;
  }
  health::FormatImplementation<unsigned long long &>(v12, a2, v13 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v15 = (char *)a2;
  }
  else {
    int v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v21, &v15[a3 - v8], (const void **)__p);
  if ((char)v27 < 0) {
    operator delete(__p[0]);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BCD26A28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned long long &>::formatOptionsAtIndex<unsigned long long &>(uint64_t a1)
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  uint64_t v3 = exception;
  if (a1) {
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else {
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v3, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD26AC8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::~__func()
{
}

__n128 std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F171DB40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

__n128 std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171DB40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::operator()(uint64_t a1, uint64_t **a2, long long *a3)
{
  BOOL v4 = *a2;
  long long v64 = *a3;
  uint64_t v65 = *((void *)a3 + 2);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(uint64_t **)(v5 + 272);
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = (uint64_t **)v6;
        unint64_t v8 = v6[4];
        if (v8 <= (unint64_t)v4) {
          break;
        }
        uint64_t v6 = *v7;
        char v9 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= (unint64_t)v4) {
        break;
      }
      uint64_t v6 = v7[1];
      if (!v6)
      {
        char v9 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    char v9 = (uint64_t **)(v5 + 272);
    unsigned int v7 = (uint64_t **)(v5 + 272);
LABEL_9:
    unsigned int v10 = (uint64_t *)v7;
    unsigned int v7 = (uint64_t **)operator new(0x40uLL);
    void v7[4] = v4;
    void v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    *unsigned int v7 = 0;
    v7[1] = 0;
    void v7[2] = v10;
    void *v9 = (uint64_t *)v7;
    uint64_t v11 = **(void **)(v5 + 264);
    unsigned int v12 = (uint64_t *)v7;
    if (v11)
    {
      *(void *)(v5 + 264) = v11;
      unsigned int v12 = *v9;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v5 + 272), v12);
    ++*(void *)(v5 + 280);
  }
  unint64_t v14 = (char *)v7[5];
  unint64_t v13 = (char *)v7[6];
  if (v14 == v13)
  {
LABEL_17:
    unint64_t v18 = (unint64_t)v7[7];
    if ((unint64_t)v13 >= v18)
    {
      unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v14) >> 3);
      unint64_t v22 = v21 + 1;
      if (v21 + 1 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_75;
      }
      unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v18 - (void)v14) >> 3);
      if (2 * v23 > v22) {
        unint64_t v22 = 2 * v23;
      }
      if (v23 >= 0x555555555555555) {
        unint64_t v24 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24) {
        unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(v24);
      }
      else {
        uint64_t v25 = 0;
      }
      unint64_t v35 = v24 + 24 * v21;
      unint64_t v36 = v24 + 24 * v25;
      long long v37 = v64;
      *(void *)(v35 + 16) = v65;
      *(_OWORD *)unint64_t v35 = v37;
      uint64_t v20 = (uint64_t *)(v35 + 24);
      uint64_t v39 = v7[5];
      unsigned __int8 v38 = (char *)v7[6];
      if (v38 != (char *)v39)
      {
        do
        {
          long long v40 = *(_OWORD *)(v38 - 24);
          *(void *)(v35 - _Block_object_dispose(&a9, 8) = *((void *)v38 - 1);
          *(_OWORD *)(v35 - 24) = v40;
          v35 -= 24;
          v38 -= 24;
        }
        while (v38 != (char *)v39);
        unsigned __int8 v38 = (char *)v7[5];
      }
      void v7[5] = (uint64_t *)v35;
      v7[6] = v20;
      v7[7] = (uint64_t *)v36;
      if (v38) {
        operator delete(v38);
      }
    }
    else
    {
      long long v19 = v64;
      *((void *)v13 + 2) = v65;
      *(_OWORD *)unint64_t v13 = v19;
      uint64_t v20 = (uint64_t *)(v13 + 24);
    }
    v7[6] = v20;
    return;
  }
  uint64_t v15 = 0;
  unint64_t v16 = **(void **)(a1 + 16);
  while (1)
  {
    unint64_t v17 = *(void *)&v14[v15];
    if (v17 == v16)
    {
      uint8x8_t v26 = &v14[v15];
      long long v27 = v64;
      *((void *)v26 + 2) = v65;
      *(_OWORD *)uint8x8_t v26 = v27;
      return;
    }
    if (v17 > v16) {
      break;
    }
    v15 += 24;
    if (&v14[v15] == v13) {
      goto LABEL_17;
    }
  }
  uint64_t v28 = v15 / 24;
  unint64_t v29 = &v14[24 * (v15 / 24)];
  unint64_t v30 = (unint64_t)v7[7];
  if ((unint64_t)v13 < v30)
  {
    if (v29 == v13)
    {
      long long v48 = v64;
      *((void *)v13 + 2) = v65;
      *(_OWORD *)unint64_t v13 = v48;
      v7[6] = (uint64_t *)(v13 + 24);
    }
    else
    {
      unint64_t v31 = v29 + 24;
      unint64_t v32 = v13 - 24;
      char v33 = v7[6];
      while (v32 < v13)
      {
        long long v34 = *(_OWORD *)v32;
        void v33[2] = *((void *)v32 + 2);
        *(_OWORD *)char v33 = v34;
        v33 += 3;
        v32 += 24;
      }
      v7[6] = v33;
      if (v13 != v31) {
        memmove(v29 + 24, v29, v13 - v31);
      }
      long long v46 = (char *)&v64;
      if (v29 <= (char *)&v64) {
        long long v46 = (char *)&v64 + 24 * (v7[6] > (uint64_t *)&v64);
      }
      long long v47 = *(_OWORD *)v46;
      *((void *)v29 + 2) = *((void *)v46 + 2);
      *(_OWORD *)unint64_t v29 = v47;
    }
    return;
  }
  unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v14) >> 3) + 1;
  if (v41 > 0xAAAAAAAAAAAAAAALL) {
LABEL_75:
  }
    std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
  unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - (void)v14) >> 3);
  if (2 * v42 > v41) {
    unint64_t v41 = 2 * v42;
  }
  if (v42 >= 0x555555555555555) {
    unint64_t v43 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v43 = v41;
  }
  if (v43)
  {
    int v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(v43);
  }
  else
  {
    int v45 = 0;
    uint64_t v44 = 0;
  }
  unint64_t v49 = &v45[24 * v28];
  uint64_t v50 = &v45[24 * v44];
  if (v28 == v44)
  {
    if (v15 < 1)
    {
      if (v15) {
        unint64_t v52 = 2 * v28;
      }
      else {
        unint64_t v52 = 1;
      }
      char v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(v52);
      unint64_t v49 = &v53[24 * (v52 >> 2)];
      uint64_t v50 = &v53[24 * v54];
      if (v45) {
        operator delete(v45);
      }
    }
    else
    {
      uint64_t v51 = v28 + 2;
      if (v28 >= -1) {
        uint64_t v51 = v28 + 1;
      }
      v49 -= 24 * (v51 >> 1);
    }
  }
  long long v55 = v64;
  *((void *)v49 + 2) = v65;
  *(_OWORD *)unint64_t v49 = v55;
  uint64_t v56 = (char *)v7[5];
  unsigned __int8 v57 = v49;
  if (v56 != v29)
  {
    uint64_t v58 = v29;
    unsigned __int8 v59 = v49;
    do
    {
      long long v60 = *(_OWORD *)(v58 - 24);
      unsigned __int8 v57 = v59 - 24;
      *((void *)v59 - 1) = *((void *)v58 - 1);
      *(_OWORD *)(v59 - 24) = v60;
      v58 -= 24;
      v59 -= 24;
    }
    while (v58 != v56);
  }
  uint64_t v61 = (char *)v7[6];
  int64_t v62 = v61 - v29;
  if (v61 != v29) {
    memmove(v49 + 24, v29, v61 - v29);
  }
  unint64_t v63 = v7[5];
  void v7[5] = (uint64_t *)v57;
  v7[6] = (uint64_t *)&v49[v62 + 24];
  v7[7] = (uint64_t *)v50;
  if (v63)
  {
    operator delete(v63);
  }
}

void sub_1BCD26FEC(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0,std::allocator<health::WriteAheadLog::_walLock_commitTransaction(unsigned long long)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::target_type()
{
}

void *std::__function::__value_func<void ()(long long,health::WriteAheadLog::PageEntry)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t **std::__tree<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unsigned int v7 = a1 + 1;
LABEL_9:
    char v9 = (uint64_t *)v7;
    unsigned int v7 = (uint64_t **)operator new(0x40uLL);
    void v7[4] = *a3;
    void v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    *unsigned int v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    unsigned int v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::~__func()
{
}

void *std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F171DBD0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F171DBD0;
  a2[1] = v2;
  return result;
}

__n128 std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::operator()(uint64_t a1, uint64_t **a2, __n128 *a3)
{
  BOOL v4 = (uint64_t **)(*(void *)(a1 + 8) + 32);
  unint64_t v8 = *a2;
  uint64_t v5 = std::__tree<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::WriteAheadLog::PageEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v4, (unint64_t)v8, &v8);
  uint64_t v6 = (uint64_t *)a3[1].n128_u64[0];
  __n128 result = *a3;
  *(__n128 *)(v5 + 5) = *a3;
  v5[7] = v6;
  return result;
}

uint64_t std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0,std::allocator<health::WriteAheadLog::Transaction::commitAndMerge(health::WriteAheadLog::Transaction&)::$_0>,void ()(long long,health::WriteAheadLog::PageEntry)>::target_type()
{
}

void health::FormatImplementation<std::string,unsigned long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (std::string::size_type i = (char *)a1; ; ++i)
  {
    unint64_t v30 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    unint64_t v30 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    unint64_t v30 = i + 2;
    int v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v21 = 0;
      unint64_t v22 = i + 3;
      do
      {
        unint64_t v30 = v22;
        uint64_t v21 = (v20 - 48) + 10 * v21;
        int v23 = *v22++;
        int v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      unint64_t v30 = v22;
      if (*(v22 - 1) == 125) {
        health::FormatterParameters<0ul,std::string,unsigned long long &>::formatOptionsAtIndex<std::string,unsigned long long &>(v21);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_47;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v25, (const char **)&v30);
  unsigned int v12 = v30;
  if (v26)
  {
    if (v26 == 1)
    {
      health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)&v25);
      unint64_t v13 = HIBYTE(v32);
      if (v32 < 0) {
        unint64_t v13 = v32;
      }
      unint64_t v14 = *((void *)&v27 + 1);
      if (*((void *)&v27 + 1) <= v13) {
        unint64_t v14 = v13;
      }
      if ((_BYTE)v27) {
        unint64_t v13 = v14;
      }
      health::FormatImplementation<std::string,unsigned long long &>(v12, a2, v13 + a3 - v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = (char *)a2;
      }
      else {
        uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v25, &v15[a3 - v8], (const void **)&__p);
      if (SHIBYTE(v32) < 0) {
        operator delete(__p);
      }
      goto LABEL_37;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_47:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  uint64_t v16 = a4[1];
  std::string __p = (void *)v16;
  long long v32 = v25;
  long long v33 = v27;
  long long v34 = v28;
  uint64_t v35 = v29;
  if (*(char *)(v16 + 23) < 0) {
    unint64_t v17 = *(void *)(v16 + 8);
  }
  else {
    unint64_t v17 = *(unsigned __int8 *)(v16 + 23);
  }
  unint64_t v18 = *((void *)&v27 + 1);
  if (*((void *)&v27 + 1) <= v17) {
    unint64_t v18 = v17;
  }
  if ((_BYTE)v27) {
    unint64_t v17 = v18;
  }
  health::FormatImplementation<std::string,unsigned long long &>(v30, a2, v17 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v19 = (char *)a2;
  }
  else {
    long long v19 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v25, &v19[a3 - v8], (uint64_t)&__p);
LABEL_37:
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BCD275D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string,unsigned long long &>::formatOptionsAtIndex<std::string,unsigned long long &>(uint64_t a1)
{
  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v1 = exception;
    if (a1 == 1) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCD2769C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_DWORD *health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(_DWORD *result, char *__dst, uint64_t a3)
{
  BOOL v4 = result;
  uint64_t v5 = *(void **)a3;
  int v6 = *(char *)(*(void *)a3 + 23);
  size_t v7 = *(unsigned __int8 *)(*(void *)a3 + 23);
  if (v6 < 0) {
    unint64_t v8 = v5[1];
  }
  else {
    unint64_t v8 = *(unsigned __int8 *)(*(void *)a3 + 23);
  }
  if (!*((unsigned char *)result + 16) || (unint64_t v9 = *((void *)result + 3), v10 = v9 - v8, v9 <= v8))
  {
    if (v6 < 0)
    {
      uint64_t v5 = (void *)*v5;
      size_t v7 = *(void *)(*(void *)a3 + 8);
      if (!v7) {
        return result;
      }
    }
    else if (!*(unsigned char *)(*(void *)a3 + 23))
    {
      return result;
    }
    unint64_t v13 = __dst;
    size_t v12 = v7;
LABEL_20:
    return memmove(v13, v5, v12);
  }
  int v11 = *result;
  if (*result)
  {
    if (v11 != 1)
    {
      if (v11 != 2) {
        return result;
      }
      if (v9 != v8)
      {
        do
        {
          *__dst++ = *((unsigned char *)result + 52);
          --v10;
        }
        while (v10);
        uint64_t v5 = *(void **)a3;
        LOBYTE(v6) = *(unsigned char *)(*(void *)a3 + 23);
      }
      if ((v6 & 0x80) != 0)
      {
        int v23 = v5;
        uint64_t v5 = (void *)*v5;
        size_t v12 = v23[1];
        if (!v12) {
          return result;
        }
      }
      else
      {
        size_t v12 = v6;
        if (!(_BYTE)v6) {
          return result;
        }
      }
      unint64_t v13 = __dst;
      goto LABEL_20;
    }
    unint64_t v15 = v10 >> 1;
    if (v10 >= 2)
    {
      if (v15 <= 1) {
        uint64_t v16 = 1;
      }
      else {
        uint64_t v16 = v10 >> 1;
      }
      do
      {
        *__dst++ = *((unsigned char *)result + 52);
        --v16;
      }
      while (v16);
      uint64_t v5 = *(void **)a3;
      LOBYTE(v6) = *(unsigned char *)(*(void *)a3 + 23);
    }
    if ((v6 & 0x80) != 0)
    {
      unint64_t v22 = v5;
      uint64_t v5 = (void *)*v5;
      size_t v17 = v22[1];
      if (!v17)
      {
LABEL_40:
        if (v10 != v15)
        {
          unint64_t v18 = v10 - (v10 >> 1);
          long long v19 = &__dst[v8];
          if (v18 <= 1) {
            unint64_t v18 = 1;
          }
          uint64_t v20 = -(uint64_t)v18;
          do
            *v19++ = v4[52];
          while (!__CFADD__(v20++, 1));
        }
        return result;
      }
    }
    else
    {
      size_t v17 = v6;
      if (!(_BYTE)v6) {
        goto LABEL_40;
      }
    }
    __n128 result = memmove(__dst, v5, v17);
    goto LABEL_40;
  }
  if (v6 < 0)
  {
    uint64_t v5 = (void *)*v5;
    size_t v7 = *(void *)(*(void *)a3 + 8);
  }
  if (v7) {
    __n128 result = memmove(__dst, v5, v7);
  }
  if (v9 != v8)
  {
    unint64_t v14 = &__dst[v8];
    do
    {
      *v14++ = v4[52];
      --v10;
    }
    while (v10);
  }
  return result;
}

void sub_1BCD2846C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__56(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__56(uint64_t a1)
{
}

uint64_t HDCloudSyncCodableProfileIdentifierReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  BOOL v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    size_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        char v19 = 0;
        unsigned int v20 = 0;
        uint64_t v21 = 0;
        *(unsigned char *)(a1 + 24) |= 1u;
        while (1)
        {
          uint64_t v22 = *v3;
          unint64_t v23 = *(void *)(a2 + v22);
          if (v23 == -1 || v23 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v24 = *(unsigned char *)(*(void *)(a2 + *v7) + v23);
          *(void *)(a2 + v22) = v23 + 1;
          v21 |= (unint64_t)(v24 & 0x7F) << v19;
          if ((v24 & 0x80) == 0) {
            goto LABEL_31;
          }
          v19 += 7;
          BOOL v14 = v20++ >= 9;
          if (v14)
          {
            uint64_t v21 = 0;
            goto LABEL_33;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_31:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_33:
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = v21;
      }
      else if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadData();
        unint64_t v18 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v17;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCD293CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD298EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t __Block_byref_object_copy__57(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__57(uint64_t a1)
{
}

uint64_t HDCodableScoredAssessmentReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  BOOL v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    size_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = objc_alloc_init(HDCodableSample);
          objc_storeStrong((id *)(a1 + 32), v17);
          if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v17, a2))
          {
            PBReaderRecallMark();

            continue;
          }

          return 0;
        case 2u:
          char v19 = 0;
          unsigned int v20 = 0;
          uint64_t v21 = 0;
          *(unsigned char *)(a1 + 40) |= 2u;
          while (1)
          {
            uint64_t v22 = *v3;
            unint64_t v23 = *(void *)(a2 + v22);
            if (v23 == -1 || v23 >= *(void *)(a2 + *v4)) {
              break;
            }
            char v24 = *(unsigned char *)(*(void *)(a2 + *v7) + v23);
            *(void *)(a2 + v22) = v23 + 1;
            v21 |= (unint64_t)(v24 & 0x7F) << v19;
            if ((v24 & 0x80) == 0) {
              goto LABEL_40;
            }
            v19 += 7;
            BOOL v14 = v20++ >= 9;
            if (v14)
            {
              uint64_t v21 = 0;
              goto LABEL_42;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_40:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v21 = 0;
          }
LABEL_42:
          uint64_t v32 = 16;
          goto LABEL_47;
        case 3u:
          uint64_t v25 = PBReaderReadData();
          uint64_t v26 = *(void **)(a1 + 24);
          *(void *)(a1 + 24) = v25;

          continue;
        case 4u:
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v21 = 0;
          *(unsigned char *)(a1 + 40) |= 1u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v29 = *v3;
        unint64_t v30 = *(void *)(a2 + v29);
        if (v30 == -1 || v30 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v31 = *(unsigned char *)(*(void *)(a2 + *v7) + v30);
        *(void *)(a2 + v29) = v30 + 1;
        v21 |= (unint64_t)(v31 & 0x7F) << v27;
        if ((v31 & 0x80) == 0) {
          goto LABEL_44;
        }
        v27 += 7;
        BOOL v14 = v28++ >= 9;
        if (v14)
        {
          uint64_t v21 = 0;
          goto LABEL_46;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_44:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v21 = 0;
      }
LABEL_46:
      uint64_t v32 = 8;
LABEL_47:
      *(void *)(a1 + v32) = v21;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t SleepLibraryCore()
{
  if (!SleepLibraryCore_frameworkLibrary) {
    SleepLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  return SleepLibraryCore_frameworkLibrary;
}

uint64_t getgetSleepFeatureAvailabilityProvidingSymbolLoc()
{
  uint64_t v3 = 0;
  BOOL v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getgetSleepFeatureAvailabilityProvidingSymbolLoc_ptr;
  uint64_t v6 = getgetSleepFeatureAvailabilityProvidingSymbolLoc_ptr;
  if (!getgetSleepFeatureAvailabilityProvidingSymbolLoc_ptr)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    void v2[2] = __getgetSleepFeatureAvailabilityProvidingSymbolLoc_block_invoke;
    v2[3] = &unk_1E62F6B28;
    void v2[4] = &v3;
    __getgetSleepFeatureAvailabilityProvidingSymbolLoc_block_invoke(v2);
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1BCD2AD90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __SleepLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  SleepLibraryCore_frameworkLibrary = result;
  return result;
}

void *__getgetSleepFeatureAvailabilityProvidingSymbolLoc_block_invoke(void *a1)
{
  uint64_t v2 = SleepLibraryCore();
  if (v2)
  {
    uint64_t v3 = (void *)v2;
  }
  else
  {
    a1 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v3 = [NSString stringWithUTF8String:"void *SleepLibrary(void)"];
    objc_msgSend(a1, "handleFailureInFunction:file:lineNumber:description:", v3, @"HDProfile+HKFeatureAvailabilityHealthDataSource.m", 25, @"%s", 0);

    __break(1u);
    free(v5);
  }
  uint64_t result = dlsym(v3, "getSleepFeatureAvailabilityProviding");
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  getgetSleepFeatureAvailabilityProvidingSymbolLoc_ptr = *(void *)(*(void *)(a1[4] + 8) + 24);
  return result;
}

BOOL HDCloudSyncCodableSharedSummaryAuthorizationRecordReadFrom(void *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  BOOL v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    size_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        unint64_t v18 = (void *)a1[2];
        a1[2] = v17;
LABEL_23:

        goto LABEL_25;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_25:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    unint64_t v18 = PBReaderReadString();
    if (v18) {
      [a1 addAuthorizationCategories:v18];
    }
    goto LABEL_23;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCD2BA88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__58(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__58(uint64_t a1)
{
}

void sub_1BCD2BC80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD2C020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL HDCodableWorkoutSessionConfigurationReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  BOOL v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    size_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = objc_alloc_init(HDCodableWorkoutConfiguration);
        objc_storeStrong((id *)(a1 + 16), v17);
        if (!PBReaderPlaceMark() || (HDCodableWorkoutConfigurationReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
        goto LABEL_24;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_26:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v18 = PBReaderReadString();
    uint64_t v17 = *(HDCodableWorkoutConfiguration **)(a1 + 8);
    *(void *)(a1 + _Block_object_dispose(&a9, 8) = v18;
LABEL_24:

    goto LABEL_26;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCD2DDA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Block_object_dispose((const void *)(v28 - 240), 8);
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__59(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__59(uint64_t a1)
{
}

__CFString *HDBKSApplicationStateString(unsigned int a1)
{
  if (a1 > 8) {
    return 0;
  }
  else {
    return off_1E62FB1E0[a1];
  }
}

BOOL HDBKSApplicationStateIsForeground(int a1)
{
  return a1 == 8;
}

BOOL HDBKSApplicationStateIsBackgroundRunning(int a1)
{
  return a1 == 4;
}

BOOL HDBKSApplicationStateIsSuspended(int a1)
{
  return a1 == 2;
}

BOOL HDBKSApplicationStateIsTerminated(unsigned int a1)
{
  return a1 < 2;
}

void sub_1BCD3237C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t HDCodableOriginalSignedClinicalDataRecordReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  BOOL v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  size_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v18 = objc_alloc_init(HDCodableMessageVersion);
        objc_storeStrong((id *)(a1 + 72), v18);
        if (PBReaderPlaceMark() && HDCodableMessageVersionReadFrom((uint64_t)v18, a2)) {
          goto LABEL_70;
        }
        goto LABEL_94;
      case 2u:
        uint64_t v20 = PBReaderReadData();
        uint64_t v21 = 112;
        goto LABEL_50;
      case 3u:
        uint64_t v20 = PBReaderReadString();
        uint64_t v21 = 56;
        goto LABEL_50;
      case 4u:
        uint64_t v20 = PBReaderReadString();
        uint64_t v21 = 64;
        goto LABEL_50;
      case 5u:
        uint64_t v20 = PBReaderReadString();
        uint64_t v21 = 104;
        goto LABEL_50;
      case 6u:
        uint64_t v20 = PBReaderReadData();
        uint64_t v21 = 88;
        goto LABEL_50;
      case 7u:
        PBReaderReadString();
        uint64_t v18 = (HDCodableMessageVersion *)objc_claimAutoreleasedReturnValue();
        if (v18) {
          [(id)a1 addType:v18];
        }
        goto LABEL_71;
      case 8u:
        uint64_t v18 = objc_alloc_init(HDCodableMetadataDictionary);
        objc_storeStrong((id *)(a1 + 80), v18);
        if (!PBReaderPlaceMark() || (HDCodableMetadataDictionaryReadFrom(v18, a2) & 1) == 0) {
          goto LABEL_94;
        }
        goto LABEL_70;
      case 9u:
        *(unsigned char *)(a1 + 148) |= 4u;
        uint64_t v22 = *v3;
        unint64_t v23 = *(void *)(a2 + v22);
        if (v23 <= 0xFFFFFFFFFFFFFFF7 && v23 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v24 = *(void *)(*(void *)(a2 + *v7) + v23);
          *(void *)(a2 + v22) = v23 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v24 = 0;
        }
        uint64_t v51 = 24;
        goto LABEL_91;
      case 0xAu:
        uint64_t v20 = PBReaderReadString();
        uint64_t v21 = 96;
        goto LABEL_50;
      case 0xBu:
        *(unsigned char *)(a1 + 148) |= 1u;
        uint64_t v25 = *v3;
        unint64_t v26 = *(void *)(a2 + v25);
        if (v26 <= 0xFFFFFFFFFFFFFFF7 && v26 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v24 = *(void *)(*(void *)(a2 + *v7) + v26);
          *(void *)(a2 + v25) = v26 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v24 = 0;
        }
        uint64_t v51 = 8;
        goto LABEL_91;
      case 0xCu:
        uint64_t v20 = PBReaderReadString();
        uint64_t v21 = 48;
        goto LABEL_50;
      case 0xDu:
        char v27 = 0;
        unsigned int v28 = 0;
        uint64_t v29 = 0;
        *(unsigned char *)(a1 + 148) |= 8u;
        while (2)
        {
          uint64_t v30 = *v3;
          uint64_t v31 = *(void *)(a2 + v30);
          unint64_t v32 = v31 + 1;
          if (v31 == -1 || v32 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v33 = *(unsigned char *)(*(void *)(a2 + *v7) + v31);
            *(void *)(a2 + v30) = v32;
            v29 |= (unint64_t)(v33 & 0x7F) << v27;
            if (v33 < 0)
            {
              v27 += 7;
              BOOL v15 = v28++ >= 9;
              if (v15)
              {
                uint64_t v29 = 0;
                goto LABEL_75;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v29 = 0;
        }
LABEL_75:
        uint64_t v50 = 32;
        goto LABEL_84;
      case 0xEu:
        uint64_t v20 = PBReaderReadData();
        uint64_t v21 = 136;
LABEL_50:
        long long v34 = *(void **)(a1 + v21);
        *(void *)(a1 + v21) = v20;

        goto LABEL_92;
      case 0xFu:
        *(unsigned char *)(a1 + 148) |= 2u;
        uint64_t v35 = *v3;
        unint64_t v36 = *(void *)(a2 + v35);
        if (v36 <= 0xFFFFFFFFFFFFFFF7 && v36 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v24 = *(void *)(*(void *)(a2 + *v7) + v36);
          *(void *)(a2 + v35) = v36 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v24 = 0;
        }
        uint64_t v51 = 16;
LABEL_91:
        *(void *)(a1 + v51) = v24;
        goto LABEL_92;
      case 0x10u:
        char v37 = 0;
        unsigned int v38 = 0;
        uint64_t v39 = 0;
        *(unsigned char *)(a1 + 148) |= 0x20u;
        while (2)
        {
          uint64_t v40 = *v3;
          uint64_t v41 = *(void *)(a2 + v40);
          unint64_t v42 = v41 + 1;
          if (v41 == -1 || v42 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v43 = *(unsigned char *)(*(void *)(a2 + *v7) + v41);
            *(void *)(a2 + v40) = v42;
            v39 |= (unint64_t)(v43 & 0x7F) << v37;
            if (v43 < 0)
            {
              v37 += 7;
              BOOL v15 = v38++ >= 9;
              if (v15)
              {
                uint64_t v39 = 0;
                goto LABEL_79;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v39 = 0;
        }
LABEL_79:
        *(unsigned char *)(a1 + 144) = v39 != 0;
        goto LABEL_92;
      case 0x11u:
        char v44 = 0;
        unsigned int v45 = 0;
        uint64_t v29 = 0;
        *(unsigned char *)(a1 + 148) |= 0x10u;
        while (2)
        {
          uint64_t v46 = *v3;
          uint64_t v47 = *(void *)(a2 + v46);
          unint64_t v48 = v47 + 1;
          if (v47 == -1 || v48 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v49 = *(unsigned char *)(*(void *)(a2 + *v7) + v47);
            *(void *)(a2 + v46) = v48;
            v29 |= (unint64_t)(v49 & 0x7F) << v44;
            if (v49 < 0)
            {
              v44 += 7;
              BOOL v15 = v45++ >= 9;
              if (v15)
              {
                uint64_t v29 = 0;
                goto LABEL_83;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v29 = 0;
        }
LABEL_83:
        uint64_t v50 = 40;
LABEL_84:
        *(void *)(a1 + v50) = v29;
        goto LABEL_92;
      case 0x12u:
        uint64_t v18 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 120), v18);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v18, a2))
        {
LABEL_70:
          PBReaderRecallMark();
LABEL_71:

LABEL_92:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_94:

        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_92;
    }
  }
}

void sub_1BCD38C0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,id location)
{
  objc_destroyWeak(v39);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__60(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__60(uint64_t a1)
{
}

id HDSampleEntityOrderingTermsForRecentness()
{
  void v5[3] = *MEMORY[0x1E4F143B8];
  uint64_t v0 = [MEMORY[0x1E4F65D50] orderingTermWithProperty:@"start_date" entityClass:objc_opt_class() ascending:0];
  uint64_t v1 = objc_msgSend(MEMORY[0x1E4F65D50], "orderingTermWithProperty:entityClass:ascending:", @"end_date", objc_opt_class(), 0, v0);
  v5[1] = v1;
  uint64_t v2 = [MEMORY[0x1E4F65D50] orderingTermWithProperty:@"creation_date" entityClass:objc_opt_class() ascending:0];
  v5[2] = v2;
  uint64_t v3 = [MEMORY[0x1E4F1C978] arrayWithObjects:v5 count:3];

  return v3;
}

id HDSampleEntityOrderingTermsForOldness()
{
  v3[1] = *MEMORY[0x1E4F143B8];
  uint64_t v0 = [MEMORY[0x1E4F65D50] orderingTermWithProperty:@"creation_date" entityClass:objc_opt_class() ascending:1];
  v3[0] = v0;
  uint64_t v1 = [MEMORY[0x1E4F1C978] arrayWithObjects:v3 count:1];

  return v1;
}

void sub_1BCD3D0C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  _Block_object_dispose(&a32, 8);
  _Block_object_dispose(&a38, 8);
  _Block_object_dispose((const void *)(v38 - 184), 8);
  _Block_object_dispose((const void *)(v38 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1BCD3D2E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDSampleEntityPredicateForDateInterval(void *a1, void *a2)
{
  void v16[2] = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [v4 endDate];
  uint64_t v6 = HDSampleEntityPredicateForStartDate(3);

  size_t v7 = [v4 startDate];
  char v8 = HDSampleEntityPredicateForEndDate(6);

  v16[0] = v6;
  v16[1] = v8;
  unsigned int v9 = [MEMORY[0x1E4F1C978] arrayWithObjects:v16 count:2];
  unint64_t v10 = [v4 startDate];

  uint64_t v11 = [v3 _earliestAllowedStartDateForSampleOverlappingDate:v10];

  if (v11)
  {
    uint64_t v12 = HDSampleEntityPredicateForStartDate(6);
    uint64_t v13 = [v9 arrayByAddingObject:v12];

    unsigned int v9 = (void *)v13;
  }
  char v14 = [MEMORY[0x1E4F65D08] predicateMatchingAllPredicates:v9];

  return v14;
}

void sub_1BCD4091C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD40B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD41D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_1BCD4248C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD42B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v6 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1BCD43098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 136), 8);
  _Unwind_Resume(a1);
}

void _HDSQLiteNewSourceUUIDWithBundleIdentifierAndProductType(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2 == 2)
  {
    if (sqlite3_value_type(*a3) != 5 && sqlite3_value_type(a3[1]) != 5)
    {
      uint64_t v5 = [NSString stringWithUTF8String:sqlite3_value_text(*a3)];
      uint64_t v6 = [NSString stringWithUTF8String:sqlite3_value_text(a3[1])];
      if (qword_1EBA18BA8 != -1) {
        dispatch_once(&qword_1EBA18BA8, &__block_literal_global_682);
      }
      if ([(id)_MergedGlobals_202 containsObject:v6]
        && [v5 hasPrefix:@"com.apple.health."])
      {
        size_t v7 = [v5 stringByReplacingOccurrencesOfString:@"com.apple.health." withString:&stru_1F1728D60];
        if ([v7 length])
        {
          uint64_t v8 = (void *)[objc_alloc(MEMORY[0x1E4F29128]) initWithUUIDString:v7];
        }
        else
        {
          _HKInitializeLogging();
          unsigned int v9 = *MEMORY[0x1E4F29F18];
          if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F18], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v5;
            _os_log_error_impl(&dword_1BCB7D000, v9, OS_LOG_TYPE_ERROR, "Failed to generate UUID from bundle identifier %{public}@", buf, 0xCu);
          }
          uint64_t v8 = 0;
        }

        if (v8) {
          goto LABEL_12;
        }
      }
      else
      {
      }
    }
    uint64_t v8 = [MEMORY[0x1E4F29128] UUID];
LABEL_12:
    *(_OWORD *)long long buf = 0uLL;
    [v8 getUUIDBytes:buf];
    sqlite3_result_blob(a1, buf, 16, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);

    return;
  }
  uint64_t v10 = [MEMORY[0x1E4F28B00] currentHandler];
  uint64_t v11 = objc_msgSend(NSString, "stringWithUTF8String:", "void _HDSQLiteNewSourceUUIDWithBundleIdentifierAndProductType(sqlite3_context *, int, sqlite3_value **)");
  [v10 handleFailureInFunction:v11, @"HDDatabaseMigrator+Monarch.m", 895, @"Invalid parameter not satisfying: %@", @"argc == 2" file lineNumber description];

  sqlite3_result_error(a1, "Improper number of arguments.", 1);
}

void sub_1BCD43754(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__61(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__61(uint64_t a1)
{
}

void sub_1BCD43DEC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1BCD444D4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1BCD45A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getIMServiceImplClass_block_invoke(uint64_t a1)
{
  IMCoreLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("IMServiceImpl");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getIMServiceImplClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
    id v3 = [NSString stringWithUTF8String:"Class getIMServiceImplClass(void)_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"HDContributorManager.m", 32, @"Unable to find class %s", "IMServiceImpl");

    __break(1u);
  }
}

void *IMCoreLibrary()
{
  uint64_t v0 = IMCoreLibraryCore();
  if (v0) {
    return (void *)v0;
  }
  uint64_t v1 = [MEMORY[0x1E4F28B00] currentHandler];
  id v3 = [NSString stringWithUTF8String:"void *IMCoreLibrary(void)"];
  objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v3, @"HDContributorManager.m", 31, @"%s", 0);

  __break(1u);
  free(v4);
  return v1;
}

uint64_t IMCoreLibraryCore()
{
  if (!IMCoreLibraryCore_frameworkLibrary) {
    IMCoreLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  return IMCoreLibraryCore_frameworkLibrary;
}

uint64_t __IMCoreLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  IMCoreLibraryCore_frameworkLibrary = result;
  return result;
}

uint64_t getIMPreferredAccountForServiceSymbolLoc()
{
  uint64_t v3 = 0;
  id v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getIMPreferredAccountForServiceSymbolLoc_ptr;
  uint64_t v6 = getIMPreferredAccountForServiceSymbolLoc_ptr;
  if (!getIMPreferredAccountForServiceSymbolLoc_ptr)
  {
    uint64_t v1 = IMCoreLibrary();
    v4[3] = (uint64_t)dlsym(v1, "IMPreferredAccountForService");
    getIMPreferredAccountForServiceSymbolLoc_ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1BCD45DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__getIMPreferredAccountForServiceSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = IMCoreLibrary();
  uint64_t result = dlsym(v2, "IMPreferredAccountForService");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getIMPreferredAccountForServiceSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __Block_byref_object_copy__62(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__62(uint64_t a1)
{
}

void sub_1BCD473AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableAuthorizationReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  size_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 64) |= 0x20u;
        while (1)
        {
          uint64_t v21 = *v3;
          uint64_t v22 = *(void *)(a2 + v21);
          unint64_t v23 = v22 + 1;
          if (v22 == -1 || v23 > *(void *)(a2 + *v4)) {
            break;
          }
          char v24 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v23;
          v20 |= (unint64_t)(v24 & 0x7F) << v18;
          if ((v24 & 0x80) == 0) {
            goto LABEL_63;
          }
          v18 += 7;
          BOOL v15 = v19++ >= 9;
          if (v15)
          {
            uint64_t v20 = 0;
            goto LABEL_65;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_63:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_65:
        uint64_t v54 = 48;
        goto LABEL_82;
      case 2u:
        char v26 = 0;
        unsigned int v27 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 64) |= 4u;
        while (2)
        {
          uint64_t v28 = *v3;
          uint64_t v29 = *(void *)(a2 + v28);
          unint64_t v30 = v29 + 1;
          if (v29 == -1 || v30 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v31 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
            *(void *)(a2 + v2_Block_object_dispose(&a9, 8) = v30;
            v20 |= (unint64_t)(v31 & 0x7F) << v26;
            if (v31 < 0)
            {
              v26 += 7;
              BOOL v15 = v27++ >= 9;
              if (v15)
              {
                uint64_t v20 = 0;
                goto LABEL_69;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_69:
        uint64_t v54 = 24;
        goto LABEL_82;
      case 3u:
        char v32 = 0;
        unsigned int v33 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 64) |= 2u;
        while (2)
        {
          uint64_t v34 = *v3;
          uint64_t v35 = *(void *)(a2 + v34);
          unint64_t v36 = v35 + 1;
          if (v35 == -1 || v36 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v37 = *(unsigned char *)(*(void *)(a2 + *v7) + v35);
            *(void *)(a2 + v34) = v36;
            v20 |= (unint64_t)(v37 & 0x7F) << v32;
            if (v37 < 0)
            {
              v32 += 7;
              BOOL v15 = v33++ >= 9;
              if (v15)
              {
                uint64_t v20 = 0;
                goto LABEL_73;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_73:
        uint64_t v54 = 16;
        goto LABEL_82;
      case 4u:
        *(unsigned char *)(a1 + 64) |= 8u;
        uint64_t v38 = *v3;
        unint64_t v39 = *(void *)(a2 + v38);
        if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v40 = *(void *)(*(void *)(a2 + *v7) + v39);
          *(void *)(a2 + v3_Block_object_dispose(&a9, 8) = v39 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v40 = 0;
        }
        *(void *)(a1 + 32) = v40;
        goto LABEL_83;
      case 5u:
        char v41 = 0;
        unsigned int v42 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 64) |= 0x10u;
        while (2)
        {
          uint64_t v43 = *v3;
          uint64_t v44 = *(void *)(a2 + v43);
          unint64_t v45 = v44 + 1;
          if (v44 == -1 || v45 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v46 = *(unsigned char *)(*(void *)(a2 + *v7) + v44);
            *(void *)(a2 + v43) = v45;
            v20 |= (unint64_t)(v46 & 0x7F) << v41;
            if (v46 < 0)
            {
              v41 += 7;
              BOOL v15 = v42++ >= 9;
              if (v15)
              {
                uint64_t v20 = 0;
                goto LABEL_77;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_77:
        uint64_t v54 = 40;
        goto LABEL_82;
      case 6u:
        char v47 = 0;
        unsigned int v48 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 64) |= 1u;
        while (2)
        {
          uint64_t v49 = *v3;
          uint64_t v50 = *(void *)(a2 + v49);
          unint64_t v51 = v50 + 1;
          if (v50 == -1 || v51 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v52 = *(unsigned char *)(*(void *)(a2 + *v7) + v50);
            *(void *)(a2 + v49) = v51;
            v20 |= (unint64_t)(v52 & 0x7F) << v47;
            if (v52 < 0)
            {
              v47 += 7;
              BOOL v15 = v48++ >= 9;
              if (v15)
              {
                uint64_t v20 = 0;
                goto LABEL_81;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_81:
        uint64_t v54 = 8;
LABEL_82:
        *(void *)(a1 + v54) = v20;
        goto LABEL_83;
      case 7u:
        char v53 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 56), v53);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v53, a2))
        {
          PBReaderRecallMark();

LABEL_83:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }

        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_83;
    }
  }
}

uint64_t HDCodableFHIRResourceReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  size_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 2u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 80;
        goto LABEL_72;
      case 3u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 120;
        goto LABEL_72;
      case 4u:
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 104;
        goto LABEL_72;
      case 5u:
        *(unsigned char *)(a1 + 160) |= 0x20u;
        uint64_t v20 = *v3;
        unint64_t v21 = *(void *)(a2 + v20);
        if (v21 <= 0xFFFFFFFFFFFFFFF7 && v21 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v22 = 0;
        }
        uint64_t v54 = 48;
        goto LABEL_94;
      case 6u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 128;
        goto LABEL_72;
      case 7u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 64;
        goto LABEL_72;
      case 9u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 112;
        goto LABEL_72;
      case 0xAu:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 136;
        goto LABEL_72;
      case 0xBu:
        char v24 = 0;
        unsigned int v25 = 0;
        uint64_t v26 = 0;
        *(unsigned char *)(a1 + 160) |= 1u;
        while (2)
        {
          uint64_t v27 = *v3;
          uint64_t v28 = *(void *)(a2 + v27);
          unint64_t v29 = v28 + 1;
          if (v28 == -1 || v29 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v28);
            *(void *)(a2 + v27) = v29;
            v26 |= (unint64_t)(v30 & 0x7F) << v24;
            if (v30 < 0)
            {
              v24 += 7;
              BOOL v15 = v25++ >= 9;
              if (v15)
              {
                uint64_t v26 = 0;
                goto LABEL_76;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v26 = 0;
        }
LABEL_76:
        uint64_t v53 = 8;
        goto LABEL_89;
      case 0xCu:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 56;
        goto LABEL_72;
      case 0xDu:
        char v31 = 0;
        unsigned int v32 = 0;
        uint64_t v26 = 0;
        *(unsigned char *)(a1 + 160) |= 4u;
        while (2)
        {
          uint64_t v33 = *v3;
          uint64_t v34 = *(void *)(a2 + v33);
          unint64_t v35 = v34 + 1;
          if (v34 == -1 || v35 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v36 = *(unsigned char *)(*(void *)(a2 + *v7) + v34);
            *(void *)(a2 + v33) = v35;
            v26 |= (unint64_t)(v36 & 0x7F) << v31;
            if (v36 < 0)
            {
              v31 += 7;
              BOOL v15 = v32++ >= 9;
              if (v15)
              {
                uint64_t v26 = 0;
                goto LABEL_80;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v26 = 0;
        }
LABEL_80:
        uint64_t v53 = 24;
        goto LABEL_89;
      case 0xEu:
        char v37 = 0;
        unsigned int v38 = 0;
        uint64_t v26 = 0;
        *(unsigned char *)(a1 + 160) |= 8u;
        while (2)
        {
          uint64_t v39 = *v3;
          uint64_t v40 = *(void *)(a2 + v39);
          unint64_t v41 = v40 + 1;
          if (v40 == -1 || v41 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v42 = *(unsigned char *)(*(void *)(a2 + *v7) + v40);
            *(void *)(a2 + v39) = v41;
            v26 |= (unint64_t)(v42 & 0x7F) << v37;
            if (v42 < 0)
            {
              v37 += 7;
              BOOL v15 = v38++ >= 9;
              if (v15)
              {
                uint64_t v26 = 0;
                goto LABEL_84;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v26 = 0;
        }
LABEL_84:
        uint64_t v53 = 32;
        goto LABEL_89;
      case 0xFu:
        char v43 = 0;
        unsigned int v44 = 0;
        uint64_t v26 = 0;
        *(unsigned char *)(a1 + 160) |= 0x10u;
        while (2)
        {
          uint64_t v45 = *v3;
          uint64_t v46 = *(void *)(a2 + v45);
          unint64_t v47 = v46 + 1;
          if (v46 == -1 || v47 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v48 = *(unsigned char *)(*(void *)(a2 + *v7) + v46);
            *(void *)(a2 + v45) = v47;
            v26 |= (unint64_t)(v48 & 0x7F) << v43;
            if (v48 < 0)
            {
              v43 += 7;
              BOOL v15 = v44++ >= 9;
              if (v15)
              {
                uint64_t v26 = 0;
                goto LABEL_88;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v26 = 0;
        }
LABEL_88:
        uint64_t v53 = 40;
LABEL_89:
        *(void *)(a1 + v53) = v26;
        goto LABEL_95;
      case 0x10u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 96;
        goto LABEL_72;
      case 0x11u:
        uint64_t v49 = objc_alloc_init(HDCodableMessageVersion);
        objc_storeStrong((id *)(a1 + 88), v49);
        if (!PBReaderPlaceMark() || !HDCodableMessageVersionReadFrom((uint64_t)v49, a2)) {
          goto LABEL_97;
        }
        goto LABEL_70;
      case 0x12u:
        *(unsigned char *)(a1 + 160) |= 2u;
        uint64_t v50 = *v3;
        unint64_t v51 = *(void *)(a2 + v50);
        if (v51 <= 0xFFFFFFFFFFFFFFF7 && v51 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v22 = *(void *)(*(void *)(a2 + *v7) + v51);
          *(void *)(a2 + v50) = v51 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v22 = 0;
        }
        uint64_t v54 = 16;
LABEL_94:
        *(void *)(a1 + v54) = v22;
        goto LABEL_95;
      case 0x13u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 72;
        goto LABEL_72;
      case 0x14u:
        uint64_t v49 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 144), v49);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v49, a2))
        {
LABEL_70:
          PBReaderRecallMark();

LABEL_95:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_97:

        return 0;
      case 0x15u:
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 152;
LABEL_72:
        char v52 = *(void **)(a1 + v19);
        *(void *)(a1 + v19) = v18;

        goto LABEL_95;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_95;
    }
  }
}

void sub_1BCD53AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__63(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__63(uint64_t a1)
{
}

void sub_1BCD53CCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD557D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD5D0E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__64(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__64(uint64_t a1)
{
}

id _HDRatingOfExertionSamplesForWorkoutPID(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  void v24[2] = *MEMORY[0x1E4F143B8];
  unsigned int v9 = (void *)MEMORY[0x1E4F2B3B8];
  uint64_t v10 = *MEMORY[0x1E4F2A800];
  id v11 = a4;
  id v12 = a2;
  unint64_t v13 = [v9 quantityTypeForIdentifier:v10];
  v24[0] = v13;
  char v14 = [MEMORY[0x1E4F2B3B8] quantityTypeForIdentifier:*MEMORY[0x1E4F2A950]];
  v24[1] = v14;
  BOOL v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v24 count:2];

  int v16 = HDReferenceForAssociatableObject(v12);

  id v23 = 0;
  uint64_t v17 = +[HDAssociationEntity objectsAssociatedWithObjectPID:a1 subObjectReference:v16 dataTypes:v15 associationType:1 limit:a3 sortDescending:a3 == 1 profile:v11 error:&v23];

  id v18 = v23;
  if (v17)
  {
    id v19 = v17;
  }
  else
  {
    id v20 = v18;
    unint64_t v21 = v20;
    if (v20)
    {
      if (a5) {
        *a5 = v20;
      }
      else {
        _HKLogDroppedError();
      }
    }
  }

  return v17;
}

void sub_1BCD5E180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__65(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__65(uint64_t a1)
{
}

void sub_1BCD5E6B4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Unwind_Resume(a1);
}

void sub_1BCD5F104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableMenstrualCyclesExperienceModelReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    size_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        char v19 = 0;
        unsigned int v20 = 0;
        uint64_t v21 = 0;
        *(unsigned char *)(a1 + 24) |= 1u;
        while (1)
        {
          uint64_t v22 = *v3;
          unint64_t v23 = *(void *)(a2 + v22);
          if (v23 == -1 || v23 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v24 = *(unsigned char *)(*(void *)(a2 + *v7) + v23);
          *(void *)(a2 + v22) = v23 + 1;
          v21 |= (unint64_t)(v24 & 0x7F) << v19;
          if ((v24 & 0x80) == 0) {
            goto LABEL_31;
          }
          v19 += 7;
          BOOL v14 = v20++ >= 9;
          if (v14)
          {
            uint64_t v21 = 0;
            goto LABEL_33;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_31:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v21 = 0;
        }
LABEL_33:
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = v21;
      }
      else if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadData();
        id v18 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v17;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCD61D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__66(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__66(uint64_t a1)
{
}

void sub_1BCD621C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD63390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__67(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__67(uint64_t a1)
{
}

id HDConceptIndexEntityPredicateForConceptIdentifier(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if ([v4 count])
  {
    uint64_t v5 = (void *)MEMORY[0x1E4F65D00];
    uint64_t v6 = [v3 numberRepresentation];
    size_t v7 = [v5 predicateWithProperty:@"concept_identifier" equalToValue:v6];

    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    void v12[2] = __HDConceptIndexEntityPredicateForConceptIdentifier_block_invoke;
    void v12[3] = &unk_1E62F2F90;
    id v13 = v7;
    id v8 = v7;
    unsigned int v9 = objc_msgSend(v4, "hk_map:", v12);
    unint64_t v10 = [MEMORY[0x1E4F65D08] predicateMatchingAnyPredicates:v9];
  }
  else
  {
    unint64_t v10 = [MEMORY[0x1E4F65D58] falsePredicate];
  }

  return v10;
}

id __HDConceptIndexEntityPredicateForConceptIdentifier_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)MEMORY[0x1E4F65D08];
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"key_path" equalToValue:a2];
  uint64_t v5 = [v2 compoundPredicateWithPredicate:v3 otherPredicate:v4];

  return v5;
}

id HDConceptIndexEntityPredicateForConceptIdentifiers(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v6 = v3;
  uint64_t v7 = [v6 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v17 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = objc_msgSend(*(id *)(*((void *)&v16 + 1) + 8 * i), "numberRepresentation", (void)v16);
        [v5 addObject:v11];
      }
      uint64_t v8 = [v6 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v8);
  }

  unint64_t v12 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"concept_identifier" values:v5];
  id v13 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"key_path" equalToValue:v4];
  BOOL v14 = [MEMORY[0x1E4F65D08] compoundPredicateWithPredicate:v13 otherPredicate:v12];

  return v14;
}

void sub_1BCD64F80(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1BCD65450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCD65D30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak((id *)(v18 - 72));
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCD661E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD67408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  _Unwind_Resume(a1);
}

void sub_1BCD675B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD676A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6770C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  unint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)HDDatabase;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1BCD67B30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD67DE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD67F38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD68040(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD680D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD68188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6826C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD68408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__CFString *HDStringFromHDDatabaseType(uint64_t a1)
{
  if (a1 == 1)
  {
    uint64_t v2 = @"Protected Database";
  }
  else if (a1)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown Database Type (%ld)", a1);
    uint64_t v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v2 = @"Unprotected Database";
  }
  return v2;
}

void sub_1BCD687D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD699DC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a2)
  {

    objc_begin_catch(a1);
    if (!v17) {
      JUMPOUT(0x1BCD69578);
    }
    JUMPOUT(0x1BCD69428);
  }
  _Unwind_Resume(a1);
}

void sub_1BCD69E44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD69EC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6A0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,void *a28)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6A2E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6A3CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6A4E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6A584(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6A704(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__68(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__68(uint64_t a1)
{
}

void sub_1BCD6A870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6AAB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6ACCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6AECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

__CFString *HDStringFromDatabaseComponentIdentifier(unint64_t a1)
{
  if (a1 >= 4)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown database component (%ld)", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E62FCA38[a1];
  }

  return v1;
}

void sub_1BCD6B498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6B650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6B714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6B7A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6B838(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6B898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6BBB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6C130(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1BCD6BF04);
  }
  _Unwind_Resume(exception_object);
}

void sub_1BCD6C4F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6C840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6CA4C(_Unwind_Exception *a1)
{
  uint64_t v7 = v4;

  _Unwind_Resume(a1);
}

id HDDatabaseIdentifierDefaultKeyForProfileIdentifier(void *a1)
{
  uint64_t v1 = NSString;
  uint64_t v2 = [a1 identifier];
  id v3 = [v2 UUIDString];
  id v4 = [v1 stringWithFormat:@"DatabaseIdentifier-%@", v3];

  return v4;
}

void sub_1BCD6CB38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6CBF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  BOOL v14 = v13;

  _Unwind_Resume(a1);
}

void sub_1BCD6CE38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6D708(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6DDCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, uint64_t a19, void *a20,void *a21)
{
  if (!v23)
  {

    unint64_t v23 = 0;
  }

  _Unwind_Resume(a1);
}

void sub_1BCD6E04C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6E120(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6E3D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6E620(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1BCD6E9D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6EBA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6ED64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6EEE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  unint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1BCD6EFD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6F0A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6F14C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6F804(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6F9D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6FBA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD6FF18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a27, 8);

  _Block_object_dispose((const void *)(v34 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1BCD7010C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD703D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  _Block_object_dispose(&a17, 8);
  _Block_object_dispose(&a23, 8);

  _Unwind_Resume(a1);
}

void sub_1BCD70548(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD706D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD70744(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD707C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD70844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD70C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1BCD70DE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD70EF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v11 = v10;

  _Unwind_Resume(a1);
}

void sub_1BCD71000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v11 = v10;

  _Unwind_Resume(a1);
}

void sub_1BCD710A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD71190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1BCD714A8(_Unwind_Exception *a1)
{
  if (!v3)
  {

    id v3 = 0;
  }

  _Unwind_Resume(a1);
}

void sub_1BCD716C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD71918(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD71DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1BCD71FC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  id v13 = v12;

  _Unwind_Resume(a1);
}

void sub_1BCD72080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  unint64_t v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1BCD72194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1BCD72234(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD724B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD72A90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1BCD72D50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Unwind_Resume(a1);
}

void sub_1BCD72DF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD72E68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD73008(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD730FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id HDDatabaseUserDefaultsKeyForProfileIdentifier(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = NSString;
  id v5 = [a2 identifier];
  id v6 = [v5 UUIDString];
  uint64_t v7 = [v4 stringWithFormat:@"%@-%@", v3, v6];

  return v7;
}

void sub_1BCD733EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD76B74(_Unwind_Exception *a1)
{
}

uint64_t HDCodableCompanionUserNotificationResponseReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        unsigned int v20 = objc_alloc_init(HDCodableError);
        objc_storeStrong((id *)(a1 + 8), v20);
        if (!PBReaderPlaceMark() || (HDCodableErrorReadFrom((uint64_t)v20, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else if (v17 == 2)
      {
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v23 = 0;
        *(unsigned char *)(a1 + 28) |= 1u;
        while (1)
        {
          uint64_t v24 = *v3;
          unint64_t v25 = *(void *)(a2 + v24);
          if (v25 == -1 || v25 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v26 = *(unsigned char *)(*(void *)(a2 + *v7) + v25);
          *(void *)(a2 + v24) = v25 + 1;
          v23 |= (unint64_t)(v26 & 0x7F) << v21;
          if ((v26 & 0x80) == 0) {
            goto LABEL_35;
          }
          v21 += 7;
          BOOL v14 = v22++ >= 9;
          if (v14)
          {
            uint64_t v23 = 0;
            goto LABEL_37;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_35:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v23 = 0;
        }
LABEL_37:
        *(unsigned char *)(a1 + 24) = v23 != 0;
      }
      else if (v17 == 1)
      {
        uint64_t v18 = PBReaderReadString();
        long long v19 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v18;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCD7A260(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1BCD7A35C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7A48C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7A69C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7A770(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7AD50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7B050(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7B1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__69(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__69(uint64_t a1)
{
}

void sub_1BCD7B2C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7B450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD7B518(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7B63C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7B9AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  *(void *)(v35 - 24_Block_object_dispose(&a9, 8) = v33;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100]((void ***)(v35 - 248));

  _Block_object_dispose(&a33, 8);
  *(void *)(v35 - 24_Block_object_dispose(&a9, 8) = a10;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100]((void ***)(v35 - 248));

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__292(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__293(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void *std::vector<_HDWrappedSource>::reserve(void *result, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[2] - *result) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v2 = (char **)result;
    uint64_t v3 = result[1] - *result;
    long long v16 = result + 2;
    id v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(a2);
    uint64_t v7 = *v2;
    unint64_t v6 = (unint64_t)v2[1];
    if ((char *)v6 == *v2)
    {
      int64x2_t v11 = vdupq_n_s64(v6);
      char v8 = &v4[v3];
    }
    else
    {
      char v8 = &v4[v3];
      do
      {
        uint64_t v9 = *(void *)(v6 - 24);
        v6 -= 24;
        *(void *)unint64_t v6 = 0;
        *((void *)v8 - 3) = v9;
        v8 -= 24;
        uint64_t v10 = *(void *)(v6 + 8);
        unsigned char v8[16] = *(unsigned char *)(v6 + 16);
        *((void *)v8 + 1) = v10;
      }
      while ((char *)v6 != v7);
      int64x2_t v11 = *(int64x2_t *)v2;
    }
    void *v2 = v8;
    v2[1] = &v4[v3];
    int64x2_t v14 = v11;
    unint64_t v12 = v2[2];
    void v2[2] = &v4[24 * v5];
    int v15 = v12;
    uint64_t v13 = v11.i64[0];
    return (void *)std::__split_buffer<_HDWrappedSource>::~__split_buffer((uint64_t)&v13);
  }
  return result;
}

void sub_1BCD7BD88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7BF84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7C204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7C49C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7C91C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,id a57,id a58,id a59)
{
  _Block_object_dispose(&a44, 8);
  *(void *)(v59 - 24_Block_object_dispose(&a9, 8) = a10;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100]((void ***)(v59 - 248));

  _Unwind_Resume(a1);
}

void sub_1BCD7CB44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7CD94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7CE7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7D968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, id *a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void **a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,char a38)
{
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a25);
  a17 = (void **)&a35;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a17);
  a17 = (void **)&a38;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a17);
  a17 = (void **)(v38 - 224);
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a17);

  std::pair<_HDCachedSourceOrder * {__strong},HDConcreteSyncIdentity * {__strong}>::~pair(a13);
  _Unwind_Resume(a1);
}

void sub_1BCD7E2A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *std::pair<_HDCachedSourceOrder * {__strong},HDConcreteSyncIdentity * {__strong}>::~pair(id *a1)
{
  return a1;
}

void sub_1BCD7E414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7E4FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7E704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  unint64_t v17 = v15;

  a13 = (void **)&a10;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a13);

  _Unwind_Resume(a1);
}

void sub_1BCD7EF68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, void **a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void **a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  *(void *)(v72 - 256) = v71;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100]((void ***)(v72 - 256));
  _Block_object_dispose(&a71, 8);
  *(void *)(v72 - 256) = a9;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100]((void ***)(v72 - 256));

  _Block_object_dispose(&a28, 8);
  _Block_object_dispose(&a32, 8);
  std::__hash_table<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,std::__unordered_map_hasher<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectHash,HDNSObjectEqual,true>,std::__unordered_map_equal<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectEqual,HDNSObjectHash,true>,std::allocator<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>>>::~__hash_table(a13);
  _Block_object_dispose(&a43, 8);
  a32 = a14;
  std::vector<HKSource * {__strong}>::__destroy_vector::operator()[abi:ne180100](&a32);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__310(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__311(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<HKSource * {__strong}>::__destroy_vector::operator()[abi:ne180100](&v1);
}

uint64_t __Block_byref_object_copy__313(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 4_Block_object_dispose(&a9, 8) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    void *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__314(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,std::__unordered_map_hasher<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectHash,HDNSObjectEqual,true>,std::__unordered_map_equal<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectEqual,HDNSObjectHash,true>,std::allocator<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>>>::~__hash_table(a1 + 48);
}

void sub_1BCD7F330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7F564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t _HDDefaultSourceOrderCompare(HKSource *a1, HKSource *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = a2;
  uint64_t v5 = ___ZL28_HDDefaultSourceOrderCompareP8HKSourceS0__block_invoke(v3);
  uint64_t v6 = ___ZL28_HDDefaultSourceOrderCompareP8HKSourceS0__block_invoke(v4);
  uint64_t v7 = [v5 compare:v6];

  if (!v7)
  {
    if ([(HKSource *)v3 _isAppleDevice]
      && [(HKSource *)v4 _isAppleDevice])
    {
      unint64_t v8 = [(HKSource *)v3 bundleIdentifier];
      uint64_t v9 = [(HKSource *)v4 bundleIdentifier];
      uint64_t v7 = [v8 compare:v9];
    }
    else
    {
      uint64_t v7 = 0;
    }
  }

  return v7;
}

void sub_1BCD7F670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7F860(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD7F994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1BCD80618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void **a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  std::__split_buffer<_HDWrappedSource>::~__split_buffer((uint64_t)&a50);

  a42 = (void **)&a45;
  std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](&a42);

  _Unwind_Resume(a1);
}

void sub_1BCD80844(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD8097C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD80A80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD80B48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCD80BC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<_HDWrappedSource>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 3);
        v4 -= 24;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__split_buffer<_HDWrappedSource>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *std::vector<_HDWrappedSource>::__init_with_size[abi:ne180100]<_HDWrappedSource*,_HDWrappedSource*>(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<_HDWrappedSource>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      __n128 result = (char *)*(id *)a2;
      *(void *)uint64_t v7 = result;
      char v8 = *(unsigned char *)(a2 + 16);
      *(void *)(v7 + _Block_object_dispose(&a9, 8) = *(void *)(a2 + 8);
      *(unsigned char *)(v7 + 16) = v8;
      v7 += 24;
      a2 += 24;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1BCD80D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<_HDWrappedSource>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawDistanceSample>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void std::vector<HKSource * {__strong}>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 1);
        v4 -= 8;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<_HDWrappedSource>::__vdeallocate(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = (void *)*((void *)v3 - 3);
        v3 -= 24;
      }
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,_HDWrappedSource *,_HDWrappedSource *,_HDWrappedSource *,0>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      uint64_t v6 = *v5;
      *uint64_t v5 = 0;
      uint64_t v7 = *(void **)a3;
      *(void *)a3 = v6;

      uint64_t v8 = v5[1];
      *(unsigned char *)(a3 + 16) = *((unsigned char *)v5 + 16);
      *(void *)(a3 + _Block_object_dispose(&a9, 8) = v8;
      a3 += 24;
      v5 += 3;
    }
    while (v5 != a2);
  }
  return a3;
}

id *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<_HDWrappedSource *,_HDWrappedSource *,_HDWrappedSource *>(uint64_t a1, uint64_t a2, id *location)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      objc_storeStrong(location, *(id *)v5);
      uint64_t v6 = *(void **)(v5 + 8);
      *((unsigned char *)location + 16) = *(unsigned char *)(v5 + 16);
      location[1] = v6;
      location += 3;
      v5 += 24;
    }
    while (v5 != a2);
  }
  return location;
}

void *___ZL28_HDDefaultSourceOrderCompareP8HKSourceS0__block_invoke(void *a1)
{
  id v1 = a1;
  if ([v1 _isPreferredSource])
  {
    uint64_t v2 = [v1 bundleIdentifier];
    char v3 = [v2 isEqualToString:*MEMORY[0x1E4F2BDC0]];

    if (v3)
    {
      uint64_t v4 = &unk_1F17EB610;
    }
    else if ([v1 _isConnectedGymSource])
    {
      uint64_t v4 = &unk_1F17EB628;
    }
    else if ([v1 _isAppleWatch])
    {
      uint64_t v4 = &unk_1F17EB640;
    }
    else if ([v1 _isAppleDevice])
    {
      uint64_t v4 = &unk_1F17EB658;
    }
    else if ([v1 _isApplication])
    {
      uint64_t v4 = &unk_1F17EB670;
    }
    else
    {
      uint64_t v4 = &unk_1F17EB688;
    }
  }
  else
  {
    uint64_t v4 = &unk_1F17EB6A0;
  }

  return v4;
}

void sub_1BCD81080(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,std::__unordered_map_hasher<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectHash,HDNSObjectEqual,true>,std::__unordered_map_equal<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectEqual,HDNSObjectHash,true>,std::allocator<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      char v3 = (id *)*v2;

      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,std::__unordered_map_hasher<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectHash,HDNSObjectEqual,true>,std::__unordered_map_equal<HKSource * {__strong},std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,HDNSObjectEqual,HDNSObjectHash,true>,std::allocator<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>>>::__emplace_unique_key_args<HKSource * {__strong},std::piecewise_construct_t const&,std::tuple<HKSource * const {__strong}&>,std::tuple<>>(uint64_t *a1, id *a2, id **a3)
{
  unint64_t v7 = [*a2 hash];
  unint64_t v8 = v7;
  unint64_t v9 = a1[1];
  if (v9)
  {
    char v43 = a3;
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    unint64_t v12 = *(void ***)(*a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(void **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v8)
        {
          id v15 = *a2;
          id v16 = *((id *)i + 2);
          id v17 = v15;
          if (v16 == v17)
          {

            return i;
          }
          uint64_t v18 = v17;
          if (v17)
          {
            char v19 = [v16 isEqual:v17];

            if (v19) {
              return i;
            }
          }
          else
          {
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
    a3 = v43;
  }
  unsigned int v20 = a1 + 2;
  uint64_t i = operator new(0x30uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v8;
  *((void *)i + 2) = **a3;
  *((void *)i + 3) = 0;
  *((void *)i + 4) = 0;
  *((void *)i + 5) = 0;
  float v21 = (float)(unint64_t)(a1[3] + 1);
  float v22 = *((float *)a1 + 8);
  if (!v9 || (float)(v22 * (float)v9) < v21)
  {
    BOOL v23 = 1;
    if (v9 >= 3) {
      BOOL v23 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v9);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    else {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v9 = a1[1];
    if (*(void *)&prime > v9) {
      goto LABEL_35;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v33 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v9 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        unint64_t v33 = std::__next_prime(v33);
      }
      else
      {
        uint64_t v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2) {
          unint64_t v33 = v35;
        }
      }
      if (*(void *)&prime <= v33) {
        int8x8_t prime = (int8x8_t)v33;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_35:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v27 = operator new(8 * *(void *)&prime);
          uint64_t v28 = (void *)*a1;
          *a1 = (uint64_t)v27;
          if (v28) {
            operator delete(v28);
          }
          uint64_t v29 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v29++) = 0;
          while (*(void *)&prime != v29);
          char v30 = (void *)*v20;
          if (*v20)
          {
            unint64_t v31 = v30[1];
            uint8x8_t v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(void *)&prime) {
                v31 %= *(void *)&prime;
              }
            }
            else
            {
              v31 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v31) = v20;
            char v36 = (void *)*v30;
            if (*v30)
            {
              do
              {
                unint64_t v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(void *)&prime) {
                    v37 %= *(void *)&prime;
                  }
                }
                else
                {
                  v37 &= *(void *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*(void *)(*a1 + 8 * v37))
                  {
                    *(void *)(*a1 + 8 * v37) = v30;
                    goto LABEL_60;
                  }
                  *char v30 = *v36;
                  *char v36 = **(void **)(*a1 + 8 * v37);
                  **(void **)(*a1 + 8 * v37) = v36;
                  char v36 = v30;
                }
                unint64_t v37 = v31;
LABEL_60:
                char v30 = v36;
                char v36 = (void *)*v36;
                unint64_t v31 = v37;
              }
              while (v36);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_64;
        }
        char v42 = (void *)*a1;
        *a1 = 0;
        if (v42) {
          operator delete(v42);
        }
        unint64_t v9 = 0;
        a1[1] = 0;
      }
    }
LABEL_64:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v38 = *a1;
  uint64_t v39 = *(void **)(*a1 + 8 * v3);
  if (v39)
  {
    *(void *)uint64_t i = *v39;
LABEL_77:
    void *v39 = i;
    goto LABEL_78;
  }
  *(void *)uint64_t i = *v20;
  *unsigned int v20 = i;
  *(void *)(v38 + 8 * v3) = v20;
  if (*(void *)i)
  {
    unint64_t v40 = *(void *)(*(void *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v40 >= v9) {
        v40 %= v9;
      }
    }
    else
    {
      v40 &= v9 - 1;
    }
    uint64_t v39 = (void *)(*a1 + 8 * v40);
    goto LABEL_77;
  }
LABEL_78:
  ++a1[3];
  return i;
}

void sub_1BCD81560(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<HKSource * {__strong},_HDWrappedSource>,void *>>>::operator()[abi:ne180100](char a1, id *a2)
{
  if (a1)
  {
  }
  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void sub_1BCD81978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCD81CAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCD83010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
}

void sub_1BCD85854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD85C6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD86C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__70(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__70(uint64_t a1)
{
}

void sub_1BCD87500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD87A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD87D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD8881C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD89EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  _Block_object_dispose(&a51, 8);
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a59, 8);
  _Block_object_dispose(&a63, 8);
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&a71, 8);
  _Block_object_dispose(&STACK[0x210], 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableTimestampedKeyValuePairReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v15 = v9++ >= 9;
        if (v15)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v18 = PBReaderReadString();
          uint64_t v19 = 40;
          goto LABEL_37;
        case 2u:
          *(unsigned char *)(a1 + 56) |= 4u;
          uint64_t v21 = *v3;
          unint64_t v22 = *(void *)(a2 + v21);
          if (v22 <= 0xFFFFFFFFFFFFFFF7 && v22 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v23 = *(void *)(*(void *)(a2 + *v7) + v22);
            *(void *)(a2 + v21) = v22 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v23 = 0;
          }
          uint64_t v34 = 24;
          goto LABEL_46;
        case 3u:
          char v24 = 0;
          unsigned int v25 = 0;
          uint64_t v26 = 0;
          *(unsigned char *)(a1 + 56) |= 2u;
          break;
        case 4u:
          *(unsigned char *)(a1 + 56) |= 1u;
          uint64_t v31 = *v3;
          unint64_t v32 = *(void *)(a2 + v31);
          if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v23 = *(void *)(*(void *)(a2 + *v7) + v32);
            *(void *)(a2 + v31) = v32 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v23 = 0;
          }
          uint64_t v34 = 8;
LABEL_46:
          *(void *)(a1 + v34) = v23;
          continue;
        case 5u:
          uint64_t v18 = PBReaderReadString();
          uint64_t v19 = 48;
          goto LABEL_37;
        case 6u:
          uint64_t v18 = PBReaderReadData();
          uint64_t v19 = 32;
LABEL_37:
          unint64_t v33 = *(void **)(a1 + v19);
          *(void *)(a1 + v19) = v18;

          continue;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v27 = *v3;
        uint64_t v28 = *(void *)(a2 + v27);
        unint64_t v29 = v28 + 1;
        if (v28 == -1 || v29 > *(void *)(a2 + *v4)) {
          break;
        }
        char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v28);
        *(void *)(a2 + v27) = v29;
        v26 |= (unint64_t)(v30 & 0x7F) << v24;
        if ((v30 & 0x80) == 0) {
          goto LABEL_39;
        }
        v24 += 7;
        BOOL v15 = v25++ >= 9;
        if (v15)
        {
          uint64_t v26 = 0;
          goto LABEL_41;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_39:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v26 = 0;
      }
LABEL_41:
      *(void *)(a1 + 16) = v26;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCD8D004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__71(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__71(uint64_t a1)
{
}

void sub_1BCD8D1A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD8DC34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

id getSOSUtilitiesClass_0()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getSOSUtilitiesClass_softClass;
  uint64_t v7 = getSOSUtilitiesClass_softClass;
  if (!getSOSUtilitiesClass_softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    void v3[2] = __getSOSUtilitiesClass_block_invoke_0;
    void v3[3] = &unk_1E62F6B28;
    v3[4] = &v4;
    __getSOSUtilitiesClass_block_invoke_0((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_1BCD8E9C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCD8EADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getSOSUtilitiesClass_block_invoke_0(uint64_t a1)
{
  SOSLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("SOSUtilities");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getSOSUtilitiesClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
    unint64_t v3 = [NSString stringWithUTF8String:"Class getSOSUtilitiesClass(void)_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"HDMedicalIDDataManager+EmergencyContactConsolidation.m", 25, @"Unable to find class %s", "SOSUtilities");

    __break(1u);
  }
}

void SOSLibrary()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!SOSLibraryCore_frameworkLibrary)
  {
    v3[1] = (void *)MEMORY[0x1E4F143A8];
    void v3[2] = (void *)3221225472;
    void v3[3] = __SOSLibraryCore_block_invoke_0;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E62FD2F0;
    uint64_t v5 = 0;
    SOSLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  if (!SOSLibraryCore_frameworkLibrary)
  {
    id v1 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v2 = [NSString stringWithUTF8String:"void *SOSLibrary(void)"];
    objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v2, @"HDMedicalIDDataManager+EmergencyContactConsolidation.m", 24, @"%s", v3[0]);

    __break(1u);
    goto LABEL_7;
  }
  uint64_t v0 = v3[0];
  if (v3[0]) {
LABEL_7:
  }
    free(v0);
}

uint64_t __SOSLibraryCore_block_invoke_0()
{
  uint64_t result = _sl_dlopen();
  SOSLibraryCore_frameworkLibrary = result;
  return result;
}

void __getSOSContactsManagerClass_block_invoke(uint64_t a1)
{
  SOSLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("SOSContactsManager");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getSOSContactsManagerClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
    unint64_t v3 = [NSString stringWithUTF8String:"Class getSOSContactsManagerClass(void)_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"HDMedicalIDDataManager+EmergencyContactConsolidation.m", 27, @"Unable to find class %s", "SOSContactsManager");

    __break(1u);
  }
}

void sub_1BCD91F84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

uint64_t __Block_byref_object_copy__72(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__72(uint64_t a1)
{
}

void sub_1BCD9292C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableMedicationDoseEventReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  long long v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = off_1E62EF000;
    char v8 = &OBJC_IVAR___HDDemoDataBaseSampleGenerator__profile;
    unsigned int v9 = &OBJC_IVAR___HDDemoDataBaseSampleGenerator__profile;
    unint64_t v10 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v11 = 0;
      unsigned int v12 = 0;
      unint64_t v13 = 0;
      while (1)
      {
        uint64_t v14 = *v3;
        uint64_t v15 = *(void *)(a2 + v14);
        unint64_t v16 = v15 + 1;
        if (v15 == -1 || v16 > *(void *)(a2 + *v4)) {
          break;
        }
        char v17 = *(unsigned char *)(*(void *)(a2 + *v10) + v15);
        *(void *)(a2 + v14) = v16;
        v13 |= (unint64_t)(v17 & 0x7F) << v11;
        if ((v17 & 0x80) == 0) {
          goto LABEL_12;
        }
        v11 += 7;
        BOOL v18 = v12++ >= 9;
        if (v18)
        {
          unint64_t v13 = 0;
          int v19 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v19 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v13 = 0;
      }
LABEL_14:
      if (v19 || (v13 & 7) == 4) {
        break;
      }
      switch((v13 >> 3))
      {
        case 1u:
          uint64_t v21 = v8;
          unint64_t v22 = v9;
          uint64_t v23 = v7;
          id v24 = objc_alloc_init(v7[287]);
          objc_storeStrong((id *)(a1 + 64), v24);
          if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v24, a2))
          {
            PBReaderRecallMark();

            uint64_t v7 = v23;
            unsigned int v9 = v22;
            char v8 = v21;
            continue;
          }

          return 0;
        case 2u:
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          *(unsigned char *)(a1 + v8[536]) |= 2u;
          while (1)
          {
            uint64_t v29 = *v3;
            uint64_t v30 = *(void *)(a2 + v29);
            unint64_t v31 = v30 + 1;
            if (v30 == -1 || v31 > *(void *)(a2 + *v4)) {
              break;
            }
            char v32 = *(unsigned char *)(*(void *)(a2 + *v10) + v30);
            *(void *)(a2 + v29) = v31;
            v28 |= (unint64_t)(v32 & 0x7F) << v26;
            if ((v32 & 0x80) == 0) {
              goto LABEL_52;
            }
            v26 += 7;
            BOOL v18 = v27++ >= 9;
            if (v18)
            {
              uint64_t v28 = 0;
              goto LABEL_54;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_52:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v28 = 0;
          }
LABEL_54:
          uint64_t v49 = v9[537];
          goto LABEL_59;
        case 3u:
          uint64_t v33 = PBReaderReadString();
          uint64_t v34 = 72;
          goto LABEL_50;
        case 4u:
          uint64_t v33 = PBReaderReadString();
          uint64_t v34 = 48;
          goto LABEL_50;
        case 5u:
          *(unsigned char *)(a1 + v8[536]) |= 8u;
          uint64_t v35 = *v3;
          unint64_t v36 = *(void *)(a2 + v35);
          if (v36 <= 0xFFFFFFFFFFFFFFF7 && v36 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v36);
            *(void *)(a2 + v35) = v36 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v37 = 0;
          }
          uint64_t v50 = 32;
          goto LABEL_66;
        case 6u:
          *(unsigned char *)(a1 + v8[536]) |= 1u;
          uint64_t v38 = *v3;
          unint64_t v39 = *(void *)(a2 + v38);
          if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v39);
            *(void *)(a2 + v3_Block_object_dispose(&a9, 8) = v39 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v37 = 0;
          }
          uint64_t v50 = 8;
          goto LABEL_66;
        case 7u:
          *(unsigned char *)(a1 + v8[536]) |= 4u;
          uint64_t v40 = *v3;
          unint64_t v41 = *(void *)(a2 + v40);
          if (v41 <= 0xFFFFFFFFFFFFFFF7 && v41 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v41);
            *(void *)(a2 + v40) = v41 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v37 = 0;
          }
          uint64_t v50 = 24;
LABEL_66:
          *(void *)(a1 + v50) = v37;
          continue;
        case 8u:
          char v42 = 0;
          unsigned int v43 = 0;
          uint64_t v28 = 0;
          *(unsigned char *)(a1 + v8[536]) |= 0x10u;
          break;
        case 9u:
          uint64_t v33 = PBReaderReadData();
          uint64_t v34 = 56;
LABEL_50:
          char v48 = *(void **)(a1 + v34);
          *(void *)(a1 + v34) = v33;

          continue;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v44 = *v3;
        uint64_t v45 = *(void *)(a2 + v44);
        unint64_t v46 = v45 + 1;
        if (v45 == -1 || v46 > *(void *)(a2 + *v4)) {
          break;
        }
        char v47 = *(unsigned char *)(*(void *)(a2 + *v10) + v45);
        *(void *)(a2 + v44) = v46;
        v28 |= (unint64_t)(v47 & 0x7F) << v42;
        if ((v47 & 0x80) == 0) {
          goto LABEL_56;
        }
        v42 += 7;
        BOOL v18 = v43++ >= 9;
        if (v18)
        {
          uint64_t v28 = 0;
          goto LABEL_58;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_56:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v28 = 0;
      }
LABEL_58:
      uint64_t v49 = 40;
LABEL_59:
      *(void *)(a1 + v49) = v28;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableMedicalCodingListReadFrom(void *a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  long long v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        char v17 = objc_alloc_init(HDCodableMedicalCoding);
        [a1 addItems:v17];
        if (!PBReaderPlaceMark() || !HDCodableMedicalCodingReadFrom((uint64_t)v17, a2))
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

BOOL HDCloudSyncCodableSharedSummaryRecordReadFrom(char *a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  long long v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 56;
          goto LABEL_31;
        case 2u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 40;
          goto LABEL_31;
        case 3u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 24;
          goto LABEL_31;
        case 4u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 64;
          goto LABEL_31;
        case 5u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 16;
          goto LABEL_31;
        case 6u:
          int v19 = PBReaderReadString();
          if (v19) {
            [a1 addObjectTypeIdentifiers:v19];
          }
          goto LABEL_32;
        case 7u:
          int v19 = PBReaderReadString();
          if (v19) {
            [a1 addAuthorizationCategories:v19];
          }
          goto LABEL_32;
        case 8u:
          uint64_t v17 = PBReaderReadData();
          uint64_t v18 = 48;
LABEL_31:
          int v19 = *(void **)&a1[v18];
          *(void *)&a1[v18] = v17;
LABEL_32:

          goto LABEL_33;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0;
          }
LABEL_33:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          break;
      }
    }
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableListUserDomainConceptReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  long long v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        uint64_t v23 = PBReaderReadString();
        id v24 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v23;
      }
      else if ((v10 >> 3) == 1)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 24) |= 1u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_31;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            uint64_t v19 = 0;
            goto LABEL_33;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_31:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v19 = 0;
        }
LABEL_33:
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = v19;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

BOOL HDCodableCompanionUserNotificationRequestReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  long long v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        unsigned int v18 = *(HDCodableCompanionUserNotificationConfiguration **)(a1 + 16);
        *(void *)(a1 + 16) = v17;
LABEL_24:

        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_26:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    unsigned int v18 = objc_alloc_init(HDCodableCompanionUserNotificationConfiguration);
    objc_storeStrong((id *)(a1 + 8), v18);
    if (!PBReaderPlaceMark()
      || (HDCodableCompanionUserNotificationConfigurationReadFrom((uint64_t)v18, a2) & 1) == 0)
    {

      return 0;
    }
    PBReaderRecallMark();
    goto LABEL_24;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

double combineNoiseLevelDatums(double a1, double a2, double a3, double a4)
{
  char v8 = [[HDQuantitySampleOverlapProcessor alloc] initWithOverlapFunction:1];
  double v9 = __exp10(a1 / 10.0);
  double v10 = __exp10(a3 / 10.0);
  double v11 = 0.0;
  if (a2 + a4 > 0.0)
  {
    double v12 = a2 * v9 + a4 * v10;
    if (v12 > 0.0) {
      double v11 = log10(v12 / (a2 + a4)) * 10.0;
    }
  }

  return v11;
}

void sub_1BCDA0A00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HDStatisticsNoiseLevel::addSampleValue(HDStatisticsNoiseLevel *this, double a2, double a3, int a4)
{
  double v8 = __exp10(a2 / 10.0) * a3;
  uint64_t v9 = *((void *)this + 4);
  if (!v9)
  {
    *(double *)this = v8;
    *((double *)this + 1) = a3;
    uint64_t v13 = 1;
    *((double *)this + 2) = a2;
    *((double *)this + 3) = a2;
    goto LABEL_9;
  }
  double v11 = *((double *)this + 2);
  double v10 = *((double *)this + 3);
  if (v10 >= a2) {
    double v10 = a2;
  }
  if (v11 <= a2) {
    double v11 = a2;
  }
  *((double *)this + 2) = v11;
  *((double *)this + 3) = v10;
  double v12 = *((double *)this + 1) + a3;
  *(double *)this = v8 + *(double *)this;
  *((double *)this + 1) = v12;
  if (a4)
  {
    uint64_t v13 = v9 + 1;
LABEL_9:
    *((void *)this + 4) = v13;
  }
}

long double HDStatisticsNoiseLevel::mean(HDStatisticsNoiseLevel *this)
{
  double v1 = *((double *)this + 1);
  long double result = 0.0;
  if (v1 > 0.0 && *(double *)this > 0.0) {
    return log10(*(double *)this / v1) * 10.0;
  }
  return result;
}

uint64_t *HDStatisticsNoiseLevel::splitSampleAtTime@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  double v3 = *((double *)result + 1);
  double v4 = *((double *)result + 2);
  uint64_t v5 = result[3];
  char v6 = *((unsigned char *)result + 32);
  double v7 = 0.0;
  char v8 = *((unsigned char *)result + 33);
  if (v6)
  {
    if (v3 > a3)
    {
      BOOL v9 = 0;
      char v6 = v4 > v3;
      a3 = *((double *)result + 2);
      char v10 = *((unsigned char *)result + 33);
      double v7 = *(double *)result;
      double v11 = *((double *)result + 1);
LABEL_9:
      uint64_t v12 = result[3];
      goto LABEL_10;
    }
    if (v4 >= a3)
    {
      BOOL v9 = v3 < a3;
      char v6 = v4 > a3;
      char v10 = *((unsigned char *)result + 33);
      double v7 = *(double *)result;
      double v11 = a3;
      goto LABEL_9;
    }
    char v10 = 0;
    uint64_t v12 = 0;
    char v6 = 0;
    BOOL v9 = v4 > v3;
    a3 = *((double *)result + 2);
    double v11 = 0.0;
  }
  else
  {
    BOOL v9 = 0;
    char v10 = 0;
    uint64_t v12 = 0;
    double v11 = 0.0;
    a3 = *((double *)result + 2);
  }
  double v4 = 0.0;
LABEL_10:
  *(void *)a2 = *result;
  *(double *)(a2 + _Block_object_dispose(&a9, 8) = v3;
  *(double *)(a2 + 16) = a3;
  *(void *)(a2 + 24) = v5;
  *(unsigned char *)(a2 + 32) = v9;
  *(unsigned char *)(a2 + 33) = v8;
  *(_DWORD *)(a2 + 34) = *(_DWORD *)((char *)result + 34);
  *(_WORD *)(a2 + 3_Block_object_dispose(&a9, 8) = *((_WORD *)result + 19);
  *(double *)(a2 + 40) = v7;
  *(double *)(a2 + 4_Block_object_dispose(&a9, 8) = v11;
  *(double *)(a2 + 56) = v4;
  *(void *)(a2 + 64) = v12;
  *(unsigned char *)(a2 + 72) = v6;
  *(unsigned char *)(a2 + 73) = v10;
  return result;
}

long long *HDStatisticsNoiseLevel::splitSampleAtTime(long long *result, uint64_t a2, double a3)
{
  if (!*((unsigned char *)result + 32)) {
    goto LABEL_6;
  }
  double v3 = *((double *)result + 1);
  if (v3 > a3)
  {
    __int16 v4 = *((_WORD *)result + 16);
    long long v5 = result[1];
    *(_OWORD *)a2 = *result;
    *(_OWORD *)(a2 + 16) = v5;
    *(_WORD *)(a2 + 32) = v4;
    *(unsigned char *)(a2 + 32) = *(double *)(a2 + 16) > *(double *)(a2 + 8);
    *((unsigned char *)result + 32) = 0;
    return result;
  }
  double v6 = *((double *)result + 2);
  if (v6 < a3)
  {
    *((unsigned char *)result + 32) = v6 > v3;
LABEL_6:
    *(unsigned char *)(a2 + 32) = 0;
    return result;
  }
  long long v7 = *result;
  long long v8 = result[1];
  *(_WORD *)(a2 + 32) = *((_WORD *)result + 16);
  *(_OWORD *)a2 = v7;
  *(_OWORD *)(a2 + 16) = v8;
  *((double *)result + 2) = a3;
  *(double *)(a2 + _Block_object_dispose(&a9, 8) = a3;
  *((unsigned char *)result + 32) = *((double *)result + 1) < a3;
  *(unsigned char *)(a2 + 32) = *(double *)(a2 + 16) > a3;
  return result;
}

uint64_t HDStatisticsNoiseLevel::applyMaskToSample(uint64_t result, void *a2)
{
  uint64_t v2 = (double *)a2[1];
  if (v2 != (double *)*a2)
  {
    double v3 = *(double *)(result + 16);
    double v4 = *(double *)(result + 8);
    if (v3 - v4 <= 0.0) {
      goto LABEL_19;
    }
    long long v5 = (double *)(*a2 + 8);
    double v6 = 0.0;
    double v7 = *(double *)(result + 8);
    do
    {
      long long v8 = v5 - 1;
      if (*v5 > v7)
      {
        double v9 = *v8;
        if (*v8 >= v3) {
          break;
        }
        if (v9 > v7)
        {
          if (v3 < v9) {
            long long v8 = (double *)(result + 16);
          }
          double v6 = v6 + *v8 - v7;
        }
        if (*v5 >= v3) {
          char v10 = (double *)(result + 16);
        }
        else {
          char v10 = v5;
        }
        double v7 = *v10;
      }
      double v11 = v5 + 1;
      v5 += 2;
    }
    while (v11 != v2);
    double v12 = v3 - v7;
    BOOL v13 = v7 < v3;
    double v14 = -0.0;
    if (v13) {
      double v14 = v12;
    }
    double v15 = v6 + v14;
    if (v15 <= 0.0) {
LABEL_19:
    }
      *(unsigned char *)(result + 32) = 0;
    else {
      *(double *)(result + 16) = v4 + v15;
    }
  }
  return result;
}

void HDStatisticsNoiseLevel::configure(id *this, HDStatisticsNoiseLevelConfiguration *a2)
{
  double v3 = a2;
  if (v3)
  {
    int v4 = *((unsigned __int8 *)this + 89);
    double v7 = v3;
    char v5 = [(HDStatisticsNoiseLevelConfiguration *)v3 enableOverlapProcessing];
    if (v4) {
      char v6 = v5;
    }
    else {
      char v6 = 1;
    }
    if ((v6 & 1) == 0)
    {
      HDStatisticsNoiseLevel::finalizeSamples((HDStatisticsNoiseLevel *)this);
      *((unsigned char *)this + 8_Block_object_dispose(&a9, 8) = 1;
      [this[10] resetAnchorTime:0.0];
    }
    *((unsigned char *)this + 89) = [(HDStatisticsNoiseLevelConfiguration *)v7 enableOverlapProcessing];
    double v3 = v7;
  }
}

void sub_1BCDA0D98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HDStatisticsNoiseLevel::finalizeSamples(HDStatisticsNoiseLevel *this)
{
  uint64_t v1 = MEMORY[0x1F4188790](this);
  if (*(unsigned char *)(v1 + 89))
  {
    uint64_t v2 = v1;
    memset(v8, 0, 512);
    double v3 = *(void **)(v1 + 80);
    if (v3) {
      [v3 exportCurrentState];
    }
    else {
      bzero(v8, 0x1420uLL);
    }
    int v4 = [HDQuantitySampleOverlapProcessor alloc];
    memcpy(__dst, v8, sizeof(__dst));
    char v5 = [(HDQuantitySampleOverlapProcessor *)v4 initWithState:__dst];
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    void v6[2] = ___ZN22HDStatisticsNoiseLevel15finalizeSamplesEv_block_invoke;
    uint64_t v6[3] = &__block_descriptor_40_e24_B32__0q8____dddBq_16__24l;
    void v6[4] = v2;
    [(HDQuantitySampleOverlapProcessor *)v5 fetchFinalOverlapSamplesWithErrorOut:0 handler:v6];
  }
}

void sub_1BCDA0F00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HDStatisticsNoiseLevel::addSample(HDStatisticsNoiseLevel *this, const HDRawQuantitySample *a2, char a3)
{
  if (*((unsigned char *)this + 89))
  {
    memset(v14, 0, sizeof(v14));
    double var0 = a2->var0;
    int64_t var3 = a2->var3;
    char v6 = (void *)*((void *)this + 10);
    long long v11 = *(_OWORD *)&a2->var1;
    double v12 = var0;
    char v13 = a3;
    int64_t v15 = var3;
    uint64_t v7 = *((unsigned __int8 *)this + 88);
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    std::locale v10[2] = ___ZN22HDStatisticsNoiseLevel9addSampleERK19HDRawQuantitySampleb_block_invoke;
    void v10[3] = &__block_descriptor_40_e24_B32__0q8____dddBq_16__24l;
    v10[4] = this;
    [v6 fetchOverlapProcessSamplesFrom:&v11 setAnchorTime:v7 errorOut:0 handler:v10];
    if (*((unsigned char *)this + 88)) {
      *((unsigned char *)this + 8_Block_object_dispose(&a9, 8) = 0;
    }
  }
  else
  {
    double v8 = a2->var0;
    double v9 = a2->var2 - a2->var1;
    HDStatisticsNoiseLevel::addSampleValue(this, v8, v9, a3);
  }
}

uint64_t ___ZN22HDStatisticsNoiseLevel9addSampleERK19HDRawQuantitySampleb_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return 1;
}

void HDStatisticsNoiseLevel::addProcessedOverlapSampleValues(HDStatisticsNoiseLevel *this, uint64_t a2, uint64_t a3)
{
  if (a2 >= 1)
  {
    uint64_t v3 = a2;
    uint64_t v5 = a3 + 16;
    do
    {
      double v6 = *(double *)(v5 - 16);
      double v7 = *(double *)(v5 - 8);
      double v8 = *(double *)v5;
      uint64_t v9 = *(void *)(v5 + 16);
      HDStatisticsNoiseLevel::addSampleValue(this, *(double *)v5, v7 - v6, *(unsigned char *)(v5 + 8) & 1);
      if (v3 == 1 && (!*((unsigned char *)this + 72) || *((double *)this + 6) <= v6))
      {
        *((double *)this + 5) = v8;
        *((double *)this + 6) = v6;
        *((double *)this + 7) = v7;
        *((void *)this + _Block_object_dispose(&a9, 8) = v9;
        *((_WORD *)this + 36) = 1;
      }
      v5 += 40;
      --v3;
    }
    while (v3);
  }
}

uint64_t ___ZN22HDStatisticsNoiseLevel15finalizeSamplesEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return 1;
}

__n128 HDStatisticsNoiseLevel::updateMostRecentSample(HDStatisticsNoiseLevel *this, const HDRawQuantitySample *a2)
{
  if (!*((unsigned char *)this + 72) || (result.n128_u64[0] = *((void *)this + 6), result.n128_f64[0] <= a2->var1))
  {
    __n128 result = *(__n128 *)&a2->var0;
    long long v3 = *(_OWORD *)&a2->var2;
    *((_WORD *)this + 36) = *(_WORD *)&a2->var4;
    *(__n128 *)((char *)this + 40) = result;
    *(_OWORD *)((char *)this + 56) = v3;
  }
  return result;
}

void HDStatisticsNoiseLevel::unarchive(HDStatisticsNoiseLevel *this, const statistics::Statistics *a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](this);
  int v4 = v3;
  *(_OWORD *)((char *)v3 + 5_Block_object_dispose(&a9, 8) = 0u;
  void v3[2] = 0u;
  void v3[3] = 0u;
  _OWORD *v3 = 0u;
  v3[1] = 0u;
  uint64_t v5 = [[HDQuantitySampleOverlapProcessor alloc] initWithOverlapFunction:1];
  *((void *)v4 + 10) = v5;
  *((unsigned char *)v4 + 89) = 1;
  *((void *)v4 + 4) = *(void *)(v2 + 24);
  uint64_t v6 = *(void *)(v2 + 88);
  _OWORD *v4 = vextq_s8(*(int8x16_t *)(v2 + 184), *(int8x16_t *)(v2 + 184), 8uLL);
  uint64_t v7 = *(void *)(v2 + 104);
  *((void *)v4 + 2) = v6;
  *((void *)v4 + 3) = v7;
  *((unsigned char *)v4 + 8_Block_object_dispose(&a9, 8) = *(unsigned char *)(v2 + 201);
  uint64_t v8 = *(void *)(v2 + 112);
  if (v8)
  {
    uint64_t v9 = *(void *)(v8 + 8);
    uint64_t v10 = *(void *)(v8 + 16);
    *(int8x16_t *)((char *)v4 + 40) = vextq_s8(*(int8x16_t *)(v8 + 24), *(int8x16_t *)(v8 + 24), 8uLL);
    *((void *)v4 + 7) = v9;
    *((void *)v4 + _Block_object_dispose(&a9, 8) = v10;
    *((_WORD *)v4 + 36) = 1;
  }
  *((unsigned char *)v4 + 89) = *(unsigned char *)(v2 + 200);
  long long v11 = *(HDStatisticsNoiseLevel **)(v2 + 120);
  if (v11)
  {
    memset(v14, 0, 512);
    HDStatisticsNoiseLevel::unarchiveOverlapProcessor(v11, v14);
    double v12 = [HDQuantitySampleOverlapProcessor alloc];
    memcpy(v13, v14, sizeof(v13));
    *((void *)v4 + 10) = [(HDQuantitySampleOverlapProcessor *)v12 initWithState:v13];
  }
}

void sub_1BCDA12D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HDStatisticsNoiseLevel::unarchiveOverlapProcessor(HDStatisticsNoiseLevel *this@<X0>, void *a2@<X8>)
{
  bzero(a2 + 3, 0x1408uLL);
  *a2 = *((void *)this + 1);
  uint64_t v5 = *((void *)this + 3);
  a2[1] = *((void *)this + 2);
  a2[2] = v5;
  *((unsigned char *)a2 + 24) = (*((unsigned char *)this + 56) != 0) & (*((unsigned char *)this + 60) >> 3);
  if (v5 >= 1)
  {
    uint64_t v6 = 0;
    if (v5 >= 128) {
      uint64_t v7 = 128;
    }
    else {
      uint64_t v7 = v5;
    }
    uint64_t v8 = a2 + 8;
    do
    {
      statistics::QuantitySampleAttenuationEngineSample::QuantitySampleAttenuationEngineSample((uint64_t)v11, *(const statistics::QuantitySampleAttenuationEngineSample **)(*((void *)this + 4) + 8 * v6));
      char v9 = v14;
      uint64_t v10 = v12;
      *(v8 - 4) = v13;
      *(_OWORD *)(v8 - 3) = *(_OWORD *)&v11[8];
      *((unsigned char *)v8 - _Block_object_dispose(&a9, 8) = v9;
      void *v8 = v10;
      v8 += 5;
      PB::Base::~Base((PB::Base *)v11);
      ++v6;
    }
    while (v7 != v6);
  }
}

void HDStatisticsNoiseLevel::archive(HDStatisticsNoiseLevel *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *((void *)this + 3);
  *(void *)(a2 + 8_Block_object_dispose(&a9, 8) = *((void *)this + 2);
  *(int8x16_t *)(a2 + 184) = vextq_s8(*(int8x16_t *)this, *(int8x16_t *)this, 8uLL);
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 160) = 0;
  *(void *)a2 = &unk_1F171B978;
  *(void *)(a2 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 12_Block_object_dispose(&a9, 8) = 0;
  *(void *)(a2 + 112) = 0;
  uint64_t v5 = *((void *)this + 4);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = v5;
  *(void *)(a2 + 104) = v4;
  LOBYTE(v5) = *((unsigned char *)this + 88);
  *(_DWORD *)(a2 + 204) = 90273;
  *(unsigned char *)(a2 + 201) = v5;
  statistics::Statistics::makeMostRecentDatum(a2);
  v7[0] = &unk_1F17206F8;
  int v11 = 127;
  int8x16_t v8 = vextq_s8(*(int8x16_t *)((char *)this + 40), *(int8x16_t *)((char *)this + 40), 8uLL);
  v7[1] = *((void *)this + 7);
  void v7[2] = *((void *)this + 8);
  __int16 v9 = 0;
  char v10 = 0;
  statistics::RawQuantitySample::operator=(*(void *)(a2 + 112), (uint64_t)v7);
  PB::Base::~Base((PB::Base *)v7);
  char v6 = *((unsigned char *)this + 89);
  *(_DWORD *)(a2 + 204) |= 0x8000u;
  *(unsigned char *)(a2 + 200) = v6;
  statistics::Statistics::makeOverlapProcessorState(a2);
  HDStatisticsNoiseLevel::archiveOverlapProcessor(this);
  statistics::QuantityOverlapProcessorState::operator=(*(void *)(a2 + 120), (uint64_t)v7);
  v7[0] = &unk_1F1721AC8;
  uint64_t v12 = (void **)&v8.i64[1];
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v12);
  PB::Base::~Base((PB::Base *)v7);
}

void sub_1BCDA151C(_Unwind_Exception *a1)
{
  statistics::Statistics::~Statistics(v1);
  _Unwind_Resume(a1);
}

void HDStatisticsNoiseLevel::archiveOverlapProcessor(HDStatisticsNoiseLevel *this)
{
  uint64_t v1 = MEMORY[0x1F4188790](this);
  uint64_t v3 = v2;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v4 = *(void **)(v1 + 80);
  if (v4)
  {
    [v4 exportCurrentState];
    uint64_t v6 = *((void *)&v9 + 1);
    uint64_t v7 = v9;
    uint64_t v5 = v10;
    char v8 = BYTE8(v10);
  }
  else
  {
    bzero(&v9, 0x1420uLL);
    char v8 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
  }
  *(void *)uint64_t v3 = &unk_1F1721AC8;
  *(void *)(v3 + 32) = 0;
  *(void *)(v3 + 40) = 0;
  *(void *)(v3 + 4_Block_object_dispose(&a9, 8) = 0;
  *(_DWORD *)(v3 + 60) = 15;
  *(void *)(v3 + _Block_object_dispose(&a9, 8) = v7;
  *(void *)(v3 + 16) = v6;
  *(void *)(v3 + 24) = v5;
  *(unsigned char *)(v3 + 56) = v8;
  if (v5 >= 1) {
    operator new();
  }
}

void sub_1BCDA17A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  PB::Base::~Base((PB::Base *)&a9);
  statistics::QuantityOverlapProcessorState::~QuantityOverlapProcessorState(v9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>>,std::reverse_iterator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>*>,std::reverse_iterator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>*>,std::reverse_iterator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>>,std::reverse_iterator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>*>,std::reverse_iterator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>*>,std::reverse_iterator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  void v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    long long v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>>,std::reverse_iterator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>>,std::reverse_iterator<std::unique_ptr<statistics::QuantitySampleAttenuationEngineSample>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<statistics::Interval>>,std::reverse_iterator<std::unique_ptr<statistics::Interval>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

void sub_1BCDA3178(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDA36C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDA5334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

uint64_t __Block_byref_object_copy__73(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__73(uint64_t a1)
{
}

void sub_1BCDA5C0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose((const void *)(v41 - 256), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDA6FEC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 184), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDA79C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDA7BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDA7E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDA8354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDDataEntityPredicateForSyncProvenance(uint64_t a1, char a2)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v4 = [NSNumber numberWithLongLong:a1];
  if (a2) {
    [v3 predicateWithProperty:@"data_provenances.sync_provenance" equalToValue:v4];
  }
  else {
  uint64_t v5 = [v3 predicateWithProperty:@"data_provenances.sync_provenance" notEqualToValue:v4];
  }

  return v5;
}

id HDDataEntityPredicateForDataUUIDs(void *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v3 = v1;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = _HDSQLiteValueForUUID();
        objc_msgSend(v2, "addObject:", v8, v11);
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v5);
  }

  long long v9 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"uuid" values:v2];

  return v9;
}

uint64_t HDDataEntityPredicateForObjectsAfterAnchor(uint64_t a1)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"data_id" greaterThanValue:a1];
}

uint64_t HDDataEntityPredicateForRowIDs(uint64_t a1)
{
  return [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"data_id" values:a1];
}

id HDDataEntityPredicateForObjectsFromAppleWatchSources(int a1)
{
  v6[1] = *MEMORY[0x1E4F143B8];
  id v1 = (void *)[[NSString alloc] initWithFormat:@"((%@ & %lld) != %d)", @"data_provenances.derived_flags", 1, a1 ^ 1u, 0];
  id v2 = (void *)MEMORY[0x1E4F65D78];
  v6[0] = @"data_provenances.derived_flags";
  id v3 = [MEMORY[0x1E4F1C978] arrayWithObjects:v6 count:1];
  uint64_t v4 = [v2 predicateWithSQL:v1 overProperties:v3 values:MEMORY[0x1E4F1CBF0]];

  return v4;
}

id HDDataEntityPredicateForSourceRevisionsSet(uint64_t a1, void *a2, int a3)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  uint64_t v7 = v6;
  if ((unint64_t)(a1 - 1) >= 2)
  {
    if (a1 != 7)
    {
      long long v23 = 0;
      goto LABEL_45;
    }
    a1 = 1;
  }
  id v47 = v5;
  if (!a3)
  {
    uint64_t v49 = v6;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __HDDataEntityPredicateForSourceRevisionsSet_block_invoke;
    aBlock[3] = &__block_descriptor_40_e40_v32__0__NSMutableArray_8__NSString_16_24l;
    aBlock[4] = a1;
    long long v24 = (void (**)(void *, void *, __CFString *, void *))_Block_copy(aBlock);
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    id v48 = v5;
    uint64_t v55 = [v48 countByEnumeratingWithState:&v56 objects:v65 count:16];
    if (!v55) {
      goto LABEL_42;
    }
    id obja = *(id *)v57;
    uint64_t v51 = *MEMORY[0x1E4F2AA30];
    uint64_t v50 = *MEMORY[0x1E4F2AA28];
    while (1)
    {
      for (uint64_t i = 0; i != v55; ++i)
      {
        if (*(id *)v57 != obja) {
          objc_enumerationMutation(v48);
        }
        long long v26 = *(void **)(*((void *)&v56 + 1) + 8 * i);
        uint64_t v27 = objc_msgSend(v26, "version", v47);
        long long v28 = (void *)v27;
        long long v29 = &stru_1F1728D60;
        if (v27) {
          long long v29 = (__CFString *)v27;
        }
        long long v30 = v29;

        uint64_t v31 = [v26 productType];
        long long v32 = (void *)v31;
        long long v33 = @"UnknownDevice";
        if (v31) {
          long long v33 = (__CFString *)v31;
        }
        long long v34 = v33;

        if (v26) {
          [v26 operatingSystemVersion];
        }
        long long v35 = [MEMORY[0x1E4F1CA48] array];
        long long v36 = NSNumber;
        long long v37 = [v26 sourceEntity];
        long long v38 = objc_msgSend(v36, "numberWithLongLong:", objc_msgSend(v37, "persistentID"));
        v24[2](v24, v35, @"data_provenances.source_id", v38);

        if (([(__CFString *)v30 isEqualToString:v51] & 1) == 0) {
          v24[2](v24, v35, @"data_provenances.source_version", v30);
        }
        long long v39 = [v26 productType];
        char v40 = [v39 isEqualToString:v50];

        if ((v40 & 1) == 0) {
          v24[2](v24, v35, @"data_provenances.origin_product_type", v34);
        }
        if ((HKNSOperatingSystemVersionsEqual() & 1) == 0)
        {
          uint64_t v41 = [NSNumber numberWithInteger:0];
          v24[2](v24, v35, @"data_provenances.origin_major_version", v41);

          char v42 = [NSNumber numberWithInteger:0];
          v24[2](v24, v35, @"data_provenances.origin_minor_version", v42);

          unsigned int v43 = [NSNumber numberWithInteger:0];
          v24[2](v24, v35, @"data_provenances.origin_patch_version", v43);
        }
        if (a1 != 7)
        {
          if (a1 == 2)
          {
            uint64_t v44 = [MEMORY[0x1E4F65D08] predicateMatchingAnyPredicates:v35];
            goto LABEL_39;
          }
          if (a1 != 1) {
            goto LABEL_40;
          }
        }
        uint64_t v44 = [MEMORY[0x1E4F65D08] predicateMatchingAllPredicates:v35];
LABEL_39:
        uint64_t v45 = (void *)v44;
        [v49 addObject:v44];

LABEL_40:
      }
      uint64_t v55 = [v48 countByEnumeratingWithState:&v56 objects:v65 count:16];
      if (!v55)
      {
LABEL_42:

        uint64_t v7 = v49;
        long long v23 = [MEMORY[0x1E4F65D08] predicateMatchingAnyPredicates:v49];

        goto LABEL_43;
      }
    }
  }
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  obuint64_t j = v5;
  uint64_t v8 = [obj countByEnumeratingWithState:&v61 objects:v67 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v54 = *(void *)v62;
    do
    {
      for (uint64_t j = 0; j != v9; ++j)
      {
        if (*(void *)v62 != v54) {
          objc_enumerationMutation(obj);
        }
        long long v11 = *(void **)(*((void *)&v61 + 1) + 8 * j);
        long long v12 = (void *)MEMORY[0x1E4F65D00];
        long long v13 = NSNumber;
        long long v14 = objc_msgSend(v11, "sourceEntity", v47);
        long long v15 = objc_msgSend(v13, "numberWithLongLong:", objc_msgSend(v14, "persistentID"));
        uint64_t v16 = [v12 predicateWithProperty:@"data_provenances.source_id" value:v15 comparisonType:a1];
        v66[0] = v16;
        long long v17 = (void *)MEMORY[0x1E4F65D00];
        long long v18 = [v11 version];
        long long v19 = [v17 predicateWithProperty:@"data_provenances.source_version" value:v18 comparisonType:a1];
        v66[1] = v19;
        long long v20 = [MEMORY[0x1E4F1C978] arrayWithObjects:v66 count:2];

        if (a1 == 7 || a1 == 1)
        {
          uint64_t v21 = [MEMORY[0x1E4F65D08] predicateMatchingAllPredicates:v20];
        }
        else
        {
          uint64_t v21 = [MEMORY[0x1E4F65D08] predicateMatchingAnyPredicates:v20];
        }
        long long v22 = (void *)v21;
        [v7 addObject:v21];
      }
      uint64_t v9 = [obj countByEnumeratingWithState:&v61 objects:v67 count:16];
    }
    while (v9);
  }

  long long v23 = [MEMORY[0x1E4F65D08] predicateMatchingAnyPredicates:v7];
LABEL_43:
  id v5 = v47;
LABEL_45:

  return v23;
}

void __HDDataEntityPredicateForSourceRevisionsSet_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v7 = *(void *)(a1 + 32);
  id v8 = a2;
  id v9 = [v6 predicateWithProperty:a3 value:a4 comparisonType:v7];
  [v8 addObject:v9];
}

id HDDataEntityPredicateForOriginBuildInRange(void *a1, void *a2)
{
  v25[1] = *MEMORY[0x1E4F143B8];
  unint64_t v3 = a1;
  unint64_t v4 = a2;
  if (v3 | v4)
  {
    id v5 = objc_opt_new();
    id v6 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"data_provenances.origin_build" notEqualToValue:@"UnknownBuild"];
    [v5 addObject:v6];

    uint64_t v7 = (void *)MEMORY[0x1E4F65C80];
    if (v3)
    {
      id v8 = (void *)MEMORY[0x1E4F65D78];
      id v9 = [NSString stringWithFormat:@"%@(%@, ?) >= 0", *MEMORY[0x1E4F65C80], @"data_provenances.origin_build"];
      v25[0] = @"data_provenances.origin_build";
      uint64_t v10 = [MEMORY[0x1E4F1C978] arrayWithObjects:v25 count:1];
      unint64_t v24 = v3;
      long long v11 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v24 count:1];
      long long v12 = [v8 predicateWithSQL:v9 overProperties:v10 values:v11];
      [v5 addObject:v12];

      uint64_t v7 = (void *)MEMORY[0x1E4F65C80];
    }
    if (v4)
    {
      long long v13 = (void *)MEMORY[0x1E4F65D78];
      long long v14 = [NSString stringWithFormat:@"%@(%@, ?) < 0", *v7, @"data_provenances.origin_build"];
      long long v23 = @"data_provenances.origin_build";
      long long v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v23 count:1];
      unint64_t v22 = v4;
      uint64_t v16 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v22 count:1];
      long long v17 = [v13 predicateWithSQL:v14 overProperties:v15 values:v16];
      [v5 addObject:v17];
    }
    long long v18 = [MEMORY[0x1E4F65D08] predicateMatchingAllPredicates:v5];
  }
  else
  {
    long long v20 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v21 = objc_msgSend(NSString, "stringWithUTF8String:", "HDSQLitePredicate * _Nonnull HDDataEntityPredicateForOriginBuildInRange(NSString * _Nullable __strong, NSString * _Nullable __strong)");
    [v20 handleFailureInFunction:v21 file:@"HDDataEntity.m" lineNumber:2312 description:@"Must specify at least one of minBuild and maxBuild."];

    long long v18 = 0;
  }

  return v18;
}

__CFString *HDDataEntityPredicateForOriginBuild(uint64_t a1, void *a2)
{
  v11[1] = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  unint64_t v4 = 0;
  switch(a1)
  {
    case 0:
    case 7:
    case 8:
      goto LABEL_9;
    case 1:
      unint64_t v4 = @"== 0";
      goto LABEL_8;
    case 2:
      unint64_t v4 = @"!= 0";
      goto LABEL_8;
    case 3:
      unint64_t v4 = @"< 0";
      goto LABEL_8;
    case 4:
      unint64_t v4 = @"<= 0";
      goto LABEL_8;
    case 5:
      unint64_t v4 = @"> 0";
      goto LABEL_8;
    case 6:
      unint64_t v4 = @">= 0";
      goto LABEL_8;
    default:
LABEL_8:
      id v5 = (void *)MEMORY[0x1E4F65D78];
      id v6 = [NSString stringWithFormat:@"%@(%@, ?) %@", *MEMORY[0x1E4F65C80], @"data_provenances.origin_build", v4];
      v11[0] = @"data_provenances.origin_build";
      uint64_t v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:v11 count:1];
      id v10 = v3;
      id v8 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v10 count:1];
      unint64_t v4 = [v5 predicateWithSQL:v6 overProperties:v7 values:v8];

LABEL_9:
      return v4;
  }
}

id HDDataEntityPredicateForDeviceIdentifierSet(uint64_t a1, void *a2)
{
  id v3 = a2;
  switch(a1)
  {
    case 7:
      goto LABEL_4;
    case 2:
      uint64_t v4 = [MEMORY[0x1E4F65D10] doesNotContainPredicateWithProperty:@"data_provenances.device_id" values:v3];
      goto LABEL_6;
    case 1:
LABEL_4:
      uint64_t v4 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"data_provenances.device_id" values:v3];
LABEL_6:
      id v5 = (void *)v4;
      goto LABEL_8;
  }
  id v5 = 0;
LABEL_8:

  return v5;
}

id HDDataEntityPredicateForCreationDate(uint64_t a1)
{
  id v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = _HDSQLiteValueForDate();
  uint64_t v4 = [v2 predicateWithProperty:@"creation_date" value:v3 comparisonType:a1];

  return v4;
}

uint64_t HDDataEntityPredicateForContributorIdentifier(uint64_t a1)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"data_provenances.contributor_id" equalToValue:a1];
}

BOOL HDCodableTinkerOptInRequestReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = 16;
LABEL_22:
        long long v19 = *(void **)(a1 + v18);
        *(void *)(a1 + v1_Block_object_dispose(&a9, 8) = v17;

        goto LABEL_24;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_24:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v17 = PBReaderReadString();
    uint64_t v18 = 8;
    goto LABEL_22;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCDACE2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCDAE6B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  _Block_object_dispose(&a34, 8);
  _Block_object_dispose((const void *)(v34 - 216), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__74(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__74(uint64_t a1)
{
}

BOOL HDCodableStateSyncCollectionReadFrom(void *a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2)
      {
        uint64_t v17 = objc_alloc_init(HDCodableObjectCollection);
        [a1 addDeletedSampleCollections:v17];
      }
      else
      {
        if ((v10 >> 3) != 1)
        {
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0;
          }
          continue;
        }
        uint64_t v17 = objc_alloc_init(HDCodableObjectCollection);
        [a1 addSampleCollections:v17];
      }
      if (!PBReaderPlaceMark() || !HDCodableObjectCollectionReadFrom((uint64_t)v17, a2))
      {

        return 0;
      }
      PBReaderRecallMark();
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCDB1074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose((const void *)(v31 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__75(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__75(uint64_t a1)
{
}

uint64_t HDCodableCompanionUserNotificationConfigurationReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 12) |= 1u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_29;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_31;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_29:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v19) = 0;
        }
LABEL_31:
        *(_DWORD *)(a1 + _Block_object_dispose(&a9, 8) = v19;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCDB6D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__76(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__76(uint64_t a1)
{
}

uint64_t HDCodableSummarySharingEntryReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 144;
        goto LABEL_63;
      case 2u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 104;
        goto LABEL_63;
      case 3u:
        PBReaderReadString();
        uint64_t v20 = (HDCodableSharingSetupMetadata *)objc_claimAutoreleasedReturnValue();
        if (v20) {
          [(id)a1 addAllContactIdentifiers:v20];
        }
        goto LABEL_76;
      case 4u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 64;
        goto LABEL_63;
      case 5u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 80;
        goto LABEL_63;
      case 6u:
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v23 = 0;
        *(unsigned char *)(a1 + 152) |= 0x40u;
        while (2)
        {
          uint64_t v24 = *v3;
          uint64_t v25 = *(void *)(a2 + v24);
          unint64_t v26 = v25 + 1;
          if (v25 == -1 || v26 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v27 = *(unsigned char *)(*(void *)(a2 + *v7) + v25);
            *(void *)(a2 + v24) = v26;
            v23 |= (unint64_t)(v27 & 0x7F) << v21;
            if (v27 < 0)
            {
              v21 += 7;
              BOOL v15 = v22++ >= 9;
              if (v15)
              {
                LODWORD(v23) = 0;
                goto LABEL_87;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v23) = 0;
        }
LABEL_87:
        uint64_t v61 = 132;
        goto LABEL_104;
      case 7u:
        char v28 = 0;
        unsigned int v29 = 0;
        uint64_t v23 = 0;
        *(unsigned char *)(a1 + 152) |= 8u;
        while (2)
        {
          uint64_t v30 = *v3;
          uint64_t v31 = *(void *)(a2 + v30);
          unint64_t v32 = v31 + 1;
          if (v31 == -1 || v32 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v33 = *(unsigned char *)(*(void *)(a2 + *v7) + v31);
            *(void *)(a2 + v30) = v32;
            v23 |= (unint64_t)(v33 & 0x7F) << v28;
            if (v33 < 0)
            {
              v28 += 7;
              BOOL v15 = v29++ >= 9;
              if (v15)
              {
                LODWORD(v23) = 0;
                goto LABEL_91;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v23) = 0;
        }
LABEL_91:
        uint64_t v61 = 56;
        goto LABEL_104;
      case 8u:
        char v34 = 0;
        unsigned int v35 = 0;
        uint64_t v23 = 0;
        *(unsigned char *)(a1 + 152) |= 0x20u;
        while (2)
        {
          uint64_t v36 = *v3;
          uint64_t v37 = *(void *)(a2 + v36);
          unint64_t v38 = v37 + 1;
          if (v37 == -1 || v38 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v39 = *(unsigned char *)(*(void *)(a2 + *v7) + v37);
            *(void *)(a2 + v36) = v38;
            v23 |= (unint64_t)(v39 & 0x7F) << v34;
            if (v39 < 0)
            {
              v34 += 7;
              BOOL v15 = v35++ >= 9;
              if (v15)
              {
                LODWORD(v23) = 0;
                goto LABEL_95;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v23) = 0;
        }
LABEL_95:
        uint64_t v61 = 128;
        goto LABEL_104;
      case 9u:
        uint64_t v20 = objc_alloc_init(HDCodableSharingSetupMetadata);
        objc_storeStrong((id *)(a1 + 120), v20);
        if (!PBReaderPlaceMark() || !HDCodableSharingSetupMetadataReadFrom((char *)v20, a2)) {
          goto LABEL_114;
        }
        goto LABEL_75;
      case 0xAu:
        *(unsigned char *)(a1 + 152) |= 4u;
        uint64_t v40 = *v3;
        unint64_t v41 = *(void *)(a2 + v40);
        if (v41 <= 0xFFFFFFFFFFFFFFF7 && v41 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v42 = *(void *)(*(void *)(a2 + *v7) + v41);
          *(void *)(a2 + v40) = v41 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v42 = 0;
        }
        uint64_t v62 = 24;
        goto LABEL_111;
      case 0xBu:
        PBReaderReadString();
        uint64_t v20 = (HDCodableSharingSetupMetadata *)objc_claimAutoreleasedReturnValue();
        if (v20) {
          [(id)a1 addAuthorizationCategories:v20];
        }
        goto LABEL_76;
      case 0xCu:
        *(unsigned char *)(a1 + 152) |= 1u;
        uint64_t v43 = *v3;
        unint64_t v44 = *(void *)(a2 + v43);
        if (v44 <= 0xFFFFFFFFFFFFFFF7 && v44 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v42 = *(void *)(*(void *)(a2 + *v7) + v44);
          *(void *)(a2 + v43) = v44 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v42 = 0;
        }
        uint64_t v62 = 8;
        goto LABEL_111;
      case 0xDu:
        *(unsigned char *)(a1 + 152) |= 2u;
        uint64_t v45 = *v3;
        unint64_t v46 = *(void *)(a2 + v45);
        if (v46 <= 0xFFFFFFFFFFFFFFF7 && v46 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v42 = *(void *)(*(void *)(a2 + *v7) + v46);
          *(void *)(a2 + v45) = v46 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v42 = 0;
        }
        uint64_t v62 = 16;
LABEL_111:
        *(void *)(a1 + v62) = v42;
        goto LABEL_112;
      case 0xEu:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 72;
        goto LABEL_63;
      case 0xFu:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 48;
        goto LABEL_63;
      case 0x10u:
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 96;
LABEL_63:
        id v47 = *(void **)(a1 + v19);
        *(void *)(a1 + v19) = v18;

        goto LABEL_112;
      case 0x11u:
        char v48 = 0;
        unsigned int v49 = 0;
        uint64_t v23 = 0;
        *(unsigned char *)(a1 + 152) |= 0x10u;
        while (2)
        {
          uint64_t v50 = *v3;
          uint64_t v51 = *(void *)(a2 + v50);
          unint64_t v52 = v51 + 1;
          if (v51 == -1 || v52 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v53 = *(unsigned char *)(*(void *)(a2 + *v7) + v51);
            *(void *)(a2 + v50) = v52;
            v23 |= (unint64_t)(v53 & 0x7F) << v48;
            if (v53 < 0)
            {
              v48 += 7;
              BOOL v15 = v49++ >= 9;
              if (v15)
              {
                LODWORD(v23) = 0;
                goto LABEL_99;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v23) = 0;
        }
LABEL_99:
        uint64_t v61 = 88;
        goto LABEL_104;
      case 0x28u:
        uint64_t v20 = objc_alloc_init(HDCodableSharingAuthorization);
        [(id)a1 addSharingAuthorizations:v20];
        if (PBReaderPlaceMark() && HDCodableSharingAuthorizationReadFrom((uint64_t)v20, a2))
        {
LABEL_75:
          PBReaderRecallMark();
LABEL_76:

LABEL_112:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_114:

        return 0;
      case 0x29u:
        char v55 = 0;
        unsigned int v56 = 0;
        uint64_t v23 = 0;
        *(unsigned char *)(a1 + 152) |= 0x80u;
        while (2)
        {
          uint64_t v57 = *v3;
          uint64_t v58 = *(void *)(a2 + v57);
          unint64_t v59 = v58 + 1;
          if (v58 == -1 || v59 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v60 = *(unsigned char *)(*(void *)(a2 + *v7) + v58);
            *(void *)(a2 + v57) = v59;
            v23 |= (unint64_t)(v60 & 0x7F) << v55;
            if (v60 < 0)
            {
              v55 += 7;
              BOOL v15 = v56++ >= 9;
              if (v15)
              {
                LODWORD(v23) = 0;
                goto LABEL_103;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v23) = 0;
        }
LABEL_103:
        uint64_t v61 = 136;
LABEL_104:
        *(_DWORD *)(a1 + v61) = v23;
        goto LABEL_112;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_112;
    }
  }
}

uint64_t HDCodableWorkoutEventReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 48) |= 8u;
        while (1)
        {
          uint64_t v21 = *v3;
          uint64_t v22 = *(void *)(a2 + v21);
          unint64_t v23 = v22 + 1;
          if (v22 == -1 || v23 > *(void *)(a2 + *v4)) {
            break;
          }
          char v24 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v23;
          v20 |= (unint64_t)(v24 & 0x7F) << v18;
          if ((v24 & 0x80) == 0) {
            goto LABEL_45;
          }
          v18 += 7;
          BOOL v15 = v19++ >= 9;
          if (v15)
          {
            uint64_t v20 = 0;
            goto LABEL_47;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_45:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_47:
        uint64_t v38 = 32;
        goto LABEL_52;
      case 2u:
        *(unsigned char *)(a1 + 48) |= 1u;
        uint64_t v26 = *v3;
        unint64_t v27 = *(void *)(a2 + v26);
        if (v27 <= 0xFFFFFFFFFFFFFFF7 && v27 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v27);
          *(void *)(a2 + v26) = v27 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v39 = 8;
        goto LABEL_57;
      case 3u:
        char v29 = 0;
        unsigned int v30 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 48) |= 4u;
        while (2)
        {
          uint64_t v31 = *v3;
          uint64_t v32 = *(void *)(a2 + v31);
          unint64_t v33 = v32 + 1;
          if (v32 == -1 || v33 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v34 = *(unsigned char *)(*(void *)(a2 + *v7) + v32);
            *(void *)(a2 + v31) = v33;
            v20 |= (unint64_t)(v34 & 0x7F) << v29;
            if (v34 < 0)
            {
              v29 += 7;
              BOOL v15 = v30++ >= 9;
              if (v15)
              {
                uint64_t v20 = 0;
                goto LABEL_51;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_51:
        uint64_t v38 = 24;
LABEL_52:
        *(void *)(a1 + v3_Block_object_dispose(&a9, 8) = v20;
        goto LABEL_58;
      case 4u:
        unsigned int v35 = objc_alloc_init(HDCodableMetadataDictionary);
        objc_storeStrong((id *)(a1 + 40), v35);
        if PBReaderPlaceMark() && (HDCodableMetadataDictionaryReadFrom(v35, a2))
        {
          PBReaderRecallMark();

LABEL_58:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }

        return 0;
      case 5u:
        *(unsigned char *)(a1 + 48) |= 2u;
        uint64_t v36 = *v3;
        unint64_t v37 = *(void *)(a2 + v36);
        if (v37 <= 0xFFFFFFFFFFFFFFF7 && v37 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v37);
          *(void *)(a2 + v36) = v37 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v39 = 16;
LABEL_57:
        *(void *)(a1 + v39) = v28;
        goto LABEL_58;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_58;
    }
  }
}

id HDSummarySharingEntryPredicateForTypeStatusAndDirection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v17[3] = *MEMORY[0x1E4F143B8];
  id v5 = (void *)MEMORY[0x1E4F65D00];
  id v6 = [NSNumber numberWithInteger:a1];
  uint64_t v7 = [v5 predicateWithProperty:@"type" equalToValue:v6];

  char v8 = (void *)MEMORY[0x1E4F65D00];
  unsigned int v9 = [NSNumber numberWithInteger:a2];
  unint64_t v10 = [v8 predicateWithProperty:@"status" equalToValue:v9];

  uint64_t v11 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v12 = [NSNumber numberWithUnsignedInteger:a3];
  unint64_t v13 = [v11 predicateWithProperty:@"direction" equalToValue:v12];

  v17[0] = v7;
  v17[1] = v10;
  void v17[2] = v13;
  char v14 = [MEMORY[0x1E4F1C978] arrayWithObjects:v17 count:3];
  BOOL v15 = [MEMORY[0x1E4F65D08] predicateMatchingAllPredicates:v14];

  return v15;
}

id HDSummarySharingEntryPredicateForTypeAndStatus(uint64_t a1, uint64_t a2)
{
  void v12[2] = *MEMORY[0x1E4F143B8];
  id v3 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v4 = [NSNumber numberWithInteger:a1];
  id v5 = [v3 predicateWithProperty:@"type" equalToValue:v4];

  id v6 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v7 = [NSNumber numberWithInteger:a2];
  char v8 = [v6 predicateWithProperty:@"status" equalToValue:v7];

  v12[0] = v5;
  v12[1] = v8;
  unsigned int v9 = [MEMORY[0x1E4F1C978] arrayWithObjects:v12 count:2];
  unint64_t v10 = [MEMORY[0x1E4F65D08] predicateMatchingAllPredicates:v9];

  return v10;
}

id HDSummarySharingEntryPredicateForIdentifierTypeAndDirection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v15[3] = *MEMORY[0x1E4F143B8];
  id v5 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"primary_contact_identifier" equalToValue:a1];
  id v6 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v7 = [NSNumber numberWithInteger:a2];
  char v8 = [v6 predicateWithProperty:@"type" equalToValue:v7];

  unsigned int v9 = (void *)MEMORY[0x1E4F65D00];
  unint64_t v10 = [NSNumber numberWithUnsignedInteger:a3];
  uint64_t v11 = [v9 predicateWithProperty:@"direction" equalToValue:v10];

  v15[0] = v5;
  v15[1] = v8;
  void v15[2] = v11;
  uint64_t v12 = [MEMORY[0x1E4F1C978] arrayWithObjects:v15 count:3];
  unint64_t v13 = [MEMORY[0x1E4F65D08] predicateMatchingAllPredicates:v12];

  return v13;
}

uint64_t HDSummarySharingEntryPredicateForUUID(uint64_t a1)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"uuid" equalToValue:a1];
}

uint64_t HDSummarySharingEntryPredicateForInvitationUUID(uint64_t a1)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"invitation_uuid" equalToValue:a1];
}

id HDSummarySharingEntryPredicateForCloudKitIdentifierTypeStatusAndDirection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v20[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"cloudkit_identifier" equalToValue:a1];
  char v8 = (void *)MEMORY[0x1E4F65D00];
  unsigned int v9 = [NSNumber numberWithInteger:a2];
  unint64_t v10 = [v8 predicateWithProperty:@"type" equalToValue:v9];

  uint64_t v11 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v12 = [NSNumber numberWithInteger:a3];
  unint64_t v13 = [v11 predicateWithProperty:@"status" equalToValue:v12];

  char v14 = (void *)MEMORY[0x1E4F65D00];
  BOOL v15 = [NSNumber numberWithUnsignedInteger:a4];
  int v16 = [v14 predicateWithProperty:@"direction" equalToValue:v15];

  v20[0] = v7;
  v20[1] = v10;
  void v20[2] = v13;
  void v20[3] = v16;
  char v17 = [MEMORY[0x1E4F1C978] arrayWithObjects:v20 count:4];
  char v18 = [MEMORY[0x1E4F65D08] predicateMatchingAllPredicates:v17];

  return v18;
}

id HDUserDomainConceptEducationContentEntityPredicateForEducationContent(uint64_t a1)
{
  id v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = +[HDSQLiteSchemaEntity disambiguatedSQLForProperty:@"deleted"];
  uint64_t v4 = [NSNumber numberWithBool:a1];
  id v5 = [v2 predicateWithProperty:v3 equalToValue:v4];

  return v5;
}

void sub_1BCDC1F10(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDC2EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__77(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__77(uint64_t a1)
{
}

void sub_1BCDC3264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDC3A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDC4A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose((const void *)(v35 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDC540C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v37 - 224), 8);
  _Block_object_dispose((const void *)(v37 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDC5F9C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDC66E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__78(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__78(uint64_t a1)
{
}

void sub_1BCDC6EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDC9848(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 120));
  _Unwind_Resume(a1);
}

void sub_1BCDC9BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDC9F10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__79(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__79(uint64_t a1)
{
}

void sub_1BCDCA55C(_Unwind_Exception *a1)
{
}

void sub_1BCDCAFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a34, 8);
  _Block_object_dispose((const void *)(v34 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDCB250(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__80(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__80(uint64_t a1)
{
}

void sub_1BCDCD018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__81(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__81(uint64_t a1)
{
}

void sub_1BCDCF858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDCFD08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDD5F74(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a37, 8);
  if (a2 == 1)
  {
    id v41 = objc_begin_catch(a1);
    _HKInitializeLogging();
    uint64_t v42 = *MEMORY[0x1E4F29F30];
    if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F30], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)(v38 - 256) = 138412290;
      *(void *)(v38 - 252) = v41;
      _os_log_error_impl(&dword_1BCB7D000, v42, OS_LOG_TYPE_ERROR, "Exception creating demo workout: %@", (uint8_t *)(v38 - 256), 0xCu);
    }

    objc_end_catch();
    JUMPOUT(0x1BCDD5CBCLL);
  }
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__82(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__82(uint64_t a1)
{
}

id HDNotificationInstructionPredicateForIsValid(int a1)
{
  uint64_t v1 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v2 = [NSNumber numberWithInt:a1 ^ 1u];
  id v3 = [v1 predicateWithProperty:@"is_invalid" equalToValue:v2];

  return v3;
}

void sub_1BCDDEA60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDDEED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCDE105C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose((const void *)(v29 - 144), 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__83(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__83(uint64_t a1)
{
}

void sub_1BCDE153C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDE26A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCDE3718(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDE3974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDE3D80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDE4040(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDE5A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDE5E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

id HDOnboardingCompletionEntityAllProperties()
{
  v5[7] = *MEMORY[0x1E4F143B8];
  v5[0] = @"uuid";
  v5[1] = @"feature_identifier";
  v5[2] = @"version";
  void v5[3] = @"completion_date";
  void v5[4] = @"country_code";
  v5[5] = @"country_code_provenance";
  v5[6] = @"mod_date";
  uint64_t v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v5 count:7];
  v4[0] = @"deleted";
  v4[1] = @"sync_provenance";
  uint64_t v4[2] = @"sync_identity";
  uint64_t v1 = [MEMORY[0x1E4F1C978] arrayWithObjects:v4 count:3];
  uint64_t v2 = [v0 arrayByAddingObjectsFromArray:v1];

  return v2;
}

id _OnboardingCompletionFromRow(uint64_t a1, uint64_t a2)
{
  if (HDSQLiteColumnWithNameAsBoolean())
  {
    id v3 = 0;
  }
  else
  {
    uint64_t v4 = HDSQLiteColumnWithNameAsUUID();
    id v5 = HDSQLiteColumnWithNameAsString();
    uint64_t v6 = HDSQLiteColumnWithNameAsInt64();
    uint64_t v7 = HDSQLiteColumnWithNameAsDate();
    char v8 = HDSQLiteColumnWithNameAsString();
    uint64_t v9 = HDSQLiteColumnWithNameAsInt64();
    if (v4 && v5 && v7)
    {
      id v3 = (void *)[objc_alloc(MEMORY[0x1E4F2B2D8]) initWithFeatureIdentifier:v5 version:v6 completionDate:v7 countryCode:v8 countryCodeProvenance:v9 UUID:v4];
    }
    else
    {
      objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a2, 100, @"Unexpectedly found missing values: UUID(%@) featureIdentifier(%@) completionDate(%@)", v4, v5, v7);
      id v3 = 0;
    }
  }

  return v3;
}

void sub_1BCDE822C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__84(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__84(uint64_t a1)
{
}

void sub_1BCDE86EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDEA03C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1BCDEA690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__85(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__85(uint64_t a1)
{
}

id HDWorkoutEntityOrderingTermsForCondenserDate()
{
  v3[1] = *MEMORY[0x1E4F143B8];
  uint64_t v0 = [MEMORY[0x1E4F65D50] orderingTermWithProperty:@"condenser_date" entityClass:objc_opt_class() ascending:1];
  v3[0] = v0;
  uint64_t v1 = [MEMORY[0x1E4F1C978] arrayWithObjects:v3 count:1];

  return v1;
}

void sub_1BCDEB224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCDEB494(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1BCDEC6C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

id HDWorkoutEntityPredicateForDuration(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = objc_msgSend(NSNumber, "numberWithDouble:");
  uint64_t v4 = [v2 predicateWithProperty:@"activities.duration" value:v3 comparisonType:a1];

  return v4;
}

id HDWorkoutEntityPredicateForTotalDistance(uint64_t a1, void *a2)
{
  id v3 = (void *)MEMORY[0x1E4F65D00];
  id v4 = a2;
  id v5 = +[HDDataEntity disambiguatedSQLForProperty:@"total_distance"];
  uint64_t v6 = NSNumber;
  uint64_t v7 = _HKWorkoutCanonicalDistanceUnit();
  [v4 doubleValueForUnit:v7];
  double v9 = v8;

  uint64_t v10 = [v6 numberWithDouble:v9];
  uint64_t v11 = [v3 predicateWithProperty:v5 value:v10 comparisonType:a1];

  return v11;
}

id HDWorkoutEntityPredicateForTotalEnergyBurned(uint64_t a1, void *a2)
{
  id v3 = (void *)MEMORY[0x1E4F2B3B8];
  uint64_t v4 = *MEMORY[0x1E4F2A5C0];
  id v5 = a2;
  uint64_t v6 = [v3 quantityTypeForIdentifier:v4];
  uint64_t v7 = [v6 canonicalUnit];

  double v8 = (void *)MEMORY[0x1E4F65D00];
  double v9 = NSNumber;
  [v5 doubleValueForUnit:v7];
  double v11 = v10;

  uint64_t v12 = [v9 numberWithDouble:v11];
  uint64_t v13 = [v8 predicateWithProperty:@"active_energy.quantity" value:v12 comparisonType:a1];

  return v13;
}

id HDWorkoutEntityPredicateForTotalSwimmingStrokeCount(uint64_t a1, void *a2)
{
  id v3 = (void *)MEMORY[0x1E4F2B3B8];
  uint64_t v4 = *MEMORY[0x1E4F2A8F8];
  id v5 = a2;
  uint64_t v6 = [v3 quantityTypeForIdentifier:v4];
  uint64_t v7 = [v6 canonicalUnit];

  double v8 = (void *)MEMORY[0x1E4F65D00];
  double v9 = NSNumber;
  [v5 doubleValueForUnit:v7];
  double v11 = v10;

  uint64_t v12 = [v9 numberWithDouble:v11];
  uint64_t v13 = [v8 predicateWithProperty:@"swimming_strokes.quantity" value:v12 comparisonType:a1];

  return v13;
}

id HDWorkoutEntityPredicateForTotalFlightsClimbed(uint64_t a1, void *a2)
{
  id v3 = (void *)MEMORY[0x1E4F2B3B8];
  uint64_t v4 = *MEMORY[0x1E4F2A808];
  id v5 = a2;
  uint64_t v6 = [v3 quantityTypeForIdentifier:v4];
  uint64_t v7 = [v6 canonicalUnit];

  double v8 = (void *)MEMORY[0x1E4F65D00];
  double v9 = NSNumber;
  [v5 doubleValueForUnit:v7];
  double v11 = v10;

  uint64_t v12 = [v9 numberWithDouble:v11];
  uint64_t v13 = [v8 predicateWithProperty:@"flights_climbed.quantity" value:v12 comparisonType:a1];

  return v13;
}

id HDWorkoutEntityPredicateForWorkoutGoalType(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)MEMORY[0x1E4F65D00];
  id v5 = +[HDDataEntity disambiguatedSQLForProperty:@"goal_type"];
  uint64_t v6 = [NSNumber numberWithUnsignedInteger:a2];
  uint64_t v7 = [v4 predicateWithProperty:v5 value:v6 comparisonType:a1];

  return v7;
}

id HDWorkoutEntityPredicateForWorkoutGoal(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    uint64_t v6 = NSNumber;
    uint64_t v7 = _HKWorkoutCanonicalUnitForGoalType();
    [v5 doubleValueForUnit:v7];
    double v8 = objc_msgSend(v6, "numberWithDouble:");

    double v9 = (void *)MEMORY[0x1E4F65D00];
    double v10 = +[HDDataEntity disambiguatedSQLForProperty:@"goal"];
    double v11 = [v9 predicateWithProperty:v10 value:v8 comparisonType:a1];

    uint64_t v12 = HDWorkoutEntityPredicateForWorkoutGoalType(1, a2);
  }
  else
  {
    uint64_t v13 = (void *)MEMORY[0x1E4F65D48];
    uint64_t v14 = +[HDDataEntity disambiguatedSQLForProperty:@"goal"];
    if (a1 == 1) {
      [v13 isNullPredicateWithProperty:v14];
    }
    else {
    double v11 = [v13 isNotNullPredicateWithProperty:v14];
    }

    uint64_t v12 = 0;
    double v8 = 0;
  }
  uint64_t v15 = [MEMORY[0x1E4F65D58] compoundPredicateWithPredicate:v11 otherPredicate:v12];

  return v15;
}

id HDWorkoutEntityPredicateForWorkoutCondenserVersionLessThan(uint64_t a1)
{
  std::locale v10[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)MEMORY[0x1E4F65D08];
  id v3 = [MEMORY[0x1E4F65D48] isNullPredicateWithProperty:@"condenser_version"];
  v10[0] = v3;
  uint64_t v4 = (void *)MEMORY[0x1E4F65D00];
  id v5 = [NSNumber numberWithInteger:a1];
  uint64_t v6 = [v4 predicateWithProperty:@"condenser_version" lessThanValue:v5];
  v10[1] = v6;
  uint64_t v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:v10 count:2];
  double v8 = [v2 predicateMatchingAnyPredicates:v7];

  return v8;
}

id HDWorkoutEntityPredicateForWorkoutCondenserVersionEqualTo(uint64_t a1)
{
  uint64_t v1 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v2 = [NSNumber numberWithInteger:a1];
  id v3 = [v1 predicateWithProperty:@"condenser_version" equalToValue:v2];

  return v3;
}

BOOL HDCodableWorkoutSessionSyncTransactionReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      if (v9++ >= 9)
      {
        unint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 32;
        goto LABEL_29;
      case 2u:
        unsigned int v19 = objc_alloc_init(HDCodableWorkoutSessionConfiguration);
        objc_storeStrong((id *)(a1 + 16), v19);
        if (!PBReaderPlaceMark() || !HDCodableWorkoutSessionConfigurationReadFrom((uint64_t)v19, a2)) {
          goto LABEL_34;
        }
        goto LABEL_27;
      case 3u:
        unsigned int v19 = objc_alloc_init(HDCodableWorkoutSessionGlobalState);
        objc_storeStrong((id *)(a1 + 24), v19);
        if (PBReaderPlaceMark()
          && (HDCodableWorkoutSessionGlobalStateReadFrom((uint64_t)v19, a2) & 1) != 0)
        {
LABEL_27:
          PBReaderRecallMark();
LABEL_30:

LABEL_31:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_34:

        return 0;
      case 4u:
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 8;
LABEL_29:
        unsigned int v19 = *(HDCodableWorkoutSessionConfiguration **)(a1 + v18);
        *(void *)(a1 + v1_Block_object_dispose(&a9, 8) = v17;
        goto LABEL_30;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0) {
          return 0;
        }
        goto LABEL_31;
    }
  }
}

void sub_1BCDEEDFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *location, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id a25)
{
}

void sub_1BCDF2270(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t HDCodableTypedObjectAssociationReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 24;
        goto LABEL_44;
      case 2u:
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 32;
        goto LABEL_44;
      case 3u:
        uint64_t v21 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 48), v21);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v21, a2))
        {
          PBReaderRecallMark();

LABEL_55:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }

        return 0;
      case 4u:
        char v22 = 0;
        unsigned int v23 = 0;
        uint64_t v24 = 0;
        *(unsigned char *)(a1 + 60) |= 2u;
        while (2)
        {
          uint64_t v25 = *v3;
          uint64_t v26 = *(void *)(a2 + v25);
          unint64_t v27 = v26 + 1;
          if (v26 == -1 || v27 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v28 = *(unsigned char *)(*(void *)(a2 + *v7) + v26);
            *(void *)(a2 + v25) = v27;
            v24 |= (unint64_t)(v28 & 0x7F) << v22;
            if (v28 < 0)
            {
              v22 += 7;
              BOOL v15 = v23++ >= 9;
              if (v15)
              {
                uint64_t v24 = 0;
                goto LABEL_48;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v24 = 0;
        }
LABEL_48:
        *(void *)(a1 + 16) = v24;
        goto LABEL_55;
      case 5u:
        char v29 = 0;
        unsigned int v30 = 0;
        uint64_t v31 = 0;
        *(unsigned char *)(a1 + 60) |= 4u;
        while (2)
        {
          uint64_t v32 = *v3;
          uint64_t v33 = *(void *)(a2 + v32);
          unint64_t v34 = v33 + 1;
          if (v33 == -1 || v34 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v35 = *(unsigned char *)(*(void *)(a2 + *v7) + v33);
            *(void *)(a2 + v32) = v34;
            v31 |= (unint64_t)(v35 & 0x7F) << v29;
            if (v35 < 0)
            {
              v29 += 7;
              BOOL v15 = v30++ >= 9;
              if (v15)
              {
                uint64_t v31 = 0;
                goto LABEL_52;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v31 = 0;
        }
LABEL_52:
        *(unsigned char *)(a1 + 56) = v31 != 0;
        goto LABEL_55;
      case 6u:
        *(unsigned char *)(a1 + 60) |= 1u;
        uint64_t v36 = *v3;
        unint64_t v37 = *(void *)(a2 + v36);
        if (v37 <= 0xFFFFFFFFFFFFFFF7 && v37 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v38 = *(void *)(*(void *)(a2 + *v7) + v37);
          *(void *)(a2 + v36) = v37 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v38 = 0;
        }
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = v38;
        goto LABEL_55;
      case 7u:
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 40;
LABEL_44:
        uint64_t v39 = *(void **)(a1 + v19);
        *(void *)(a1 + v19) = v18;

        goto LABEL_55;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_55;
    }
  }
}

BOOL HDCodableBinarySampleReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = objc_alloc_init(HDCodableSample);
        objc_storeStrong((id *)(a1 + 16), v17);
        if (!PBReaderPlaceMark() || (HDCodableSampleReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
        goto LABEL_24;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_26:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v18 = PBReaderReadData();
    uint64_t v17 = *(HDCodableSample **)(a1 + 8);
    *(void *)(a1 + _Block_object_dispose(&a9, 8) = v18;
LABEL_24:

    goto LABEL_26;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCDFBDE8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__86(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__86(uint64_t a1)
{
}

id HDPredicateForMetadataValue(void *a1, uint64_t a2)
{
  void v15[4] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (!v3 && a2 == 2)
  {
    uint64_t v4 = [MEMORY[0x1E4F65D48] isNotNullPredicateWithProperty:@"numerical_value"];
    id v5 = [MEMORY[0x1E4F65D48] isNotNullPredicateWithProperty:@"date_value"];
    uint64_t v6 = [MEMORY[0x1E4F65D48] isNotNullPredicateWithProperty:@"string_value"];
    uint64_t v7 = [MEMORY[0x1E4F65D48] isNotNullPredicateWithProperty:@"data_value"];
    char v8 = (void *)MEMORY[0x1E4F65D08];
    v15[0] = v4;
    v15[1] = v5;
    void v15[2] = v6;
    v15[3] = v7;
    unsigned int v9 = [MEMORY[0x1E4F1C978] arrayWithObjects:v15 count:4];
    unint64_t v10 = [v8 predicateMatchingAnyPredicates:v9];

    goto LABEL_15;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v11 = (void *)MEMORY[0x1E4F65D00];
    unint64_t v12 = _HDSQLiteValueForString();
    char v13 = @"string_value";
LABEL_14:
    unint64_t v10 = [v11 predicateWithProperty:v13 value:v12 comparisonType:a2];

LABEL_15:
    if (v10) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v11 = (void *)MEMORY[0x1E4F65D00];
    unint64_t v12 = _HDSQLiteValueForNumber();
    char v13 = @"numerical_value";
    goto LABEL_14;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v11 = (void *)MEMORY[0x1E4F65D00];
    unint64_t v12 = _HDSQLiteValueForDate();
    char v13 = @"date_value";
    goto LABEL_14;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    unint64_t v10 = _HDMetadataQuantityComparisonPredicate(a2, v3);
    goto LABEL_15;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v11 = (void *)MEMORY[0x1E4F65D00];
    unint64_t v12 = _HDSQLiteValueForData();
    char v13 = @"data_value";
    goto LABEL_14;
  }
LABEL_16:
  unint64_t v10 = [MEMORY[0x1E4F65D58] falsePredicate];
LABEL_17:

  return v10;
}

id _HDMetadataQuantityComparisonPredicate(uint64_t a1, void *a2)
{
  void v33[2] = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = 0;
  char v5 = 0;
  char v6 = 1;
  uint64_t v7 = @"=  0";
  char v8 = @"= -1";
  switch(a1)
  {
    case 1:
      uint64_t v4 = 0;
      uint64_t v7 = 0;
      char v5 = 1;
      char v8 = @"=  0";
      break;
    case 2:
      char v6 = 0;
      char v5 = 0;
      uint64_t v7 = @"=  1";
      uint64_t v4 = @"=  2";
      break;
    case 3:
      uint64_t v4 = 0;
      uint64_t v7 = 0;
      goto LABEL_6;
    case 4:
      break;
    case 5:
      uint64_t v4 = 0;
      uint64_t v7 = 0;
      char v5 = 1;
      goto LABEL_9;
    case 6:
      uint64_t v4 = 0;
      char v5 = 0;
LABEL_9:
      char v8 = @"=  1";
      break;
    default:
      unsigned int v9 = [MEMORY[0x1E4F28B00] currentHandler];
      unint64_t v10 = objc_msgSend(NSString, "stringWithUTF8String:", "HDSQLitePredicate * _Nonnull _HDMetadataQuantityComparisonPredicate(HDSQLiteComparisonType, HKQuantity * _Nonnull __strong)");
      [v9 handleFailureInFunction:v10 file:@"HDMetadataValueEntity.m" lineNumber:668 description:@"Unsupported comparison type for HKQuantity metadata values!"];

      char v8 = 0;
      uint64_t v4 = 0;
      uint64_t v7 = 0;
      char v6 = 1;
LABEL_6:
      char v5 = 1;
      break;
  }
  uint64_t v11 = NSNumber;
  unint64_t v12 = [v3 _unit];
  [v3 doubleValueForUnit:v12];
  char v13 = objc_msgSend(v11, "numberWithDouble:");
  char v14 = _HDSQLiteValueForNumber();

  int v15 = [v3 _unit];
  int v16 = [v15 unitString];
  uint64_t v17 = _HDSQLiteValueForString();

  uint64_t v18 = (void *)MEMORY[0x1E4F65D78];
  uint64_t v19 = *MEMORY[0x1E4F65C88];
  if (v6)
  {
    if (v5)
    {
      uint64_t v20 = [NSString stringWithFormat:@"%@(%@, %@, ?, ?) %@", v19, @"numerical_value", @"string_value", v8];
      v29[0] = @"numerical_value";
      v29[1] = @"string_value";
      uint64_t v21 = [MEMORY[0x1E4F1C978] arrayWithObjects:v29 count:2];
      v28[0] = v14;
      v28[1] = v17;
      char v22 = (void *)MEMORY[0x1E4F1C978];
      unsigned int v23 = v28;
      uint64_t v24 = 2;
    }
    else
    {
      uint64_t v20 = [NSString stringWithFormat:@"%@(%@, %@, ?, ?) %@ OR %@(%@, %@, ?, ?) %@", v19, @"numerical_value", @"string_value", v8, v19, @"numerical_value", @"string_value", v7];
      v31[0] = @"numerical_value";
      v31[1] = @"string_value";
      uint64_t v21 = [MEMORY[0x1E4F1C978] arrayWithObjects:v31 count:2];
      v30[0] = v14;
      v30[1] = v17;
      _OWORD v30[2] = v14;
      v30[3] = v17;
      char v22 = (void *)MEMORY[0x1E4F1C978];
      unsigned int v23 = v30;
      uint64_t v24 = 4;
    }
  }
  else
  {
    uint64_t v20 = [NSString stringWithFormat:@"%@(%@, %@, ?, ?) %@ OR %@(%@, %@, ?, ?) %@ OR %@(%@, %@, ?, ?) %@", v19, @"numerical_value", @"string_value", v8, v19, @"numerical_value", @"string_value", v7, v19, @"numerical_value", @"string_value", v4];
    v33[0] = @"numerical_value";
    v33[1] = @"string_value";
    uint64_t v21 = [MEMORY[0x1E4F1C978] arrayWithObjects:v33 count:2];
    v32[0] = v14;
    v32[1] = v17;
    void v32[2] = v14;
    v32[3] = v17;
    uint64_t v32[4] = v14;
    v32[5] = v17;
    char v22 = (void *)MEMORY[0x1E4F1C978];
    unsigned int v23 = v32;
    uint64_t v24 = 6;
  }
  uint64_t v25 = [v22 arrayWithObjects:v23 count:v24];
  uint64_t v26 = [v18 predicateWithSQL:v20 overProperties:v21 values:v25];

  return v26;
}

uint64_t __Block_byref_object_copy__87(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__87(uint64_t a1)
{
}

void sub_1BCE0127C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t _significantTimeChange(uint64_t a1, void *a2)
{
  return [a2 _handleSignificantTimeChangeNotification:0];
}

void sub_1BCE027F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__88(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__88(uint64_t a1)
{
}

void sub_1BCE02DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE030D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE03968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE03A30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE04188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCE043DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,void *a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31)
{
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__89(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__89(uint64_t a1)
{
}

void sub_1BCE04850(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCE04A00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCE04C00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  id v19 = va_arg(va1, id);

  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);

  _Unwind_Resume(a1);
}

void sub_1BCE04D70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCE04E58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCE0514C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDSeriesSamplePredicateForSamplesToAutoFreezeExcludingSamples(void *a1)
{
  void v13[2] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"frozen" equalToValue:&unk_1F17ECBB8];
  id v3 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v4 = [NSNumber numberWithLongLong:+[HDSeriesSampleEntity _insertionEra]()];
  char v5 = [v3 predicateWithProperty:@"insertion_era" notEqualToValue:v4];

  id v6 = objc_alloc(MEMORY[0x1E4F1CA48]);
  v13[0] = v2;
  v13[1] = v5;
  uint64_t v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:v13 count:2];
  char v8 = (void *)[v6 initWithArray:v7];

  if ([v1 count])
  {
    unsigned int v9 = objc_msgSend(v1, "hk_map:", &__block_literal_global_479);
    unint64_t v10 = [MEMORY[0x1E4F65D10] doesNotContainPredicateWithProperty:@"uuid" values:v9];
    [v8 addObject:v10];
  }
  uint64_t v11 = [MEMORY[0x1E4F65D08] predicateMatchingAllPredicates:v8];

  return v11;
}

void sub_1BCE05368(_Unwind_Exception *a1)
{
  uint64_t v7 = v5;

  _Unwind_Resume(a1);
}

id __HDSeriesSamplePredicateForSamplesToAutoFreezeExcludingSamples_block_invoke()
{
  uint64_t v0 = _HDSQLiteValueForUUID();

  return v0;
}

id HDSeriesSamplePredicateForSeriesIdentifier(uint64_t a1)
{
  id v1 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v2 = [NSNumber numberWithLongLong:a1];
  id v3 = [v1 predicateWithProperty:@"hfd_key" equalToValue:v2];

  return v3;
}

void sub_1BCE0547C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __cxx_global_array_dtor_0()
{
  for (uint64_t i = 0; i != -18; i -= 3)
  {
  }
}

void _assertMetadataIsSame(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = [v1 firstObject];
  id v3 = [v2 metadata];

  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  id v4 = v1;
  uint64_t v5 = [v4 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v18;
    do
    {
      uint64_t v8 = 0;
      unsigned int v9 = v3;
      do
      {
        if (*(void *)v18 != v7) {
          objc_enumerationMutation(v4);
        }
        unint64_t v10 = *(void **)(*((void *)&v17 + 1) + 8 * v8);
        uint64_t v11 = objc_msgSend(v10, "metadata", (void)v17);
        unint64_t v12 = v9;
        if (v11 == v9) {
          goto LABEL_12;
        }
        uint64_t v13 = v11;
        if (!v9)
        {

LABEL_11:
          unint64_t v12 = [MEMORY[0x1E4F28B00] currentHandler];
          uint64_t v16 = [NSString stringWithUTF8String:"void _assertMetadataIsSame(NSArray<HDQuantityDatum *> * _Nonnull __strong)"];
          [v12 handleFailureInFunction:v16 file:@"HDQuantityDatum.m" lineNumber:262 description:@"Cannot merge an array of datums with different metadata"];

LABEL_12:
          goto LABEL_13;
        }
        char v14 = [v10 metadata];
        char v15 = [v14 isEqual:v9];

        if ((v15 & 1) == 0) {
          goto LABEL_11;
        }
LABEL_13:
        id v3 = [v10 metadata];

        ++v8;
        unsigned int v9 = v3;
      }
      while (v6 != v8);
      uint64_t v6 = [v4 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }
    while (v6);
  }
}

id _HDCombineQuantitySensorData(void *a1, void *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if ([v5 count])
  {
    _assertMetadataIsSame(v5);
    uint64_t v8 = [v5 firstObject];
    unsigned int v9 = [v8 dateInterval];
    unint64_t v10 = [v9 startDate];

    if (v10)
    {
      uint64_t v11 = [v5 lastObject];
      unint64_t v12 = [v11 dateInterval];
      uint64_t v13 = [v12 endDate];

      if (v13)
      {
        char v14 = _HDCombinedQuantityForData(v5, v6);
        char v15 = [v5 firstObject];
        id v16 = [v15 metadata];

        if (v16)
        {
          if (v7)
          {
            uint64_t v17 = objc_msgSend(v16, "hk_dictionaryByAddingEntriesFromDictionary:", v7);

            id v16 = (id)v17;
          }
        }
        else
        {
          id v16 = v7;
        }
        long long v18 = [MEMORY[0x1E4F2B388] _quantitySamplesEnforcingDurationWithType:v6 quantity:v14 startDate:v10 endDate:v13 device:0 metadata:v16];
      }
      else
      {
        _HKInitializeLogging();
        long long v20 = (void *)*MEMORY[0x1E4F29F10];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F10], OS_LOG_TYPE_FAULT))
        {
          uint64_t v24 = v20;
          uint64_t v25 = [v5 lastObject];
          int v26 = 138412290;
          unint64_t v27 = v25;
          _os_log_fault_impl(&dword_1BCB7D000, v24, OS_LOG_TYPE_FAULT, "Sensor datum missing end date: %@", (uint8_t *)&v26, 0xCu);
        }
        long long v18 = 0;
      }
    }
    else
    {
      _HKInitializeLogging();
      long long v19 = (void *)*MEMORY[0x1E4F29F10];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F10], OS_LOG_TYPE_FAULT))
      {
        uint64_t v22 = v19;
        unsigned int v23 = [v5 firstObject];
        int v26 = 138412290;
        unint64_t v27 = v23;
        _os_log_fault_impl(&dword_1BCB7D000, v22, OS_LOG_TYPE_FAULT, "Sensor datum missing start date: %@", (uint8_t *)&v26, 0xCu);
      }
      long long v18 = 0;
    }
  }
  else
  {
    long long v18 = 0;
  }

  return v18;
}

id _HDCombinedQuantityForData(void *a1, void *a2)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = [v4 canonicalUnit];
  uint64_t v6 = [v4 aggregationStyle];
  if ((unint64_t)(v6 - 2) < 2)
  {
    id v48 = v4;
    uint64_t v51 = +[HDStatisticsCollectionCalculator calculatorForQuantityType:v4 intervalCollection:0 options:2 mergeStrategy:1];
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    id v47 = v3;
    obuint64_t j = v3;
    uint64_t v15 = [obj countByEnumeratingWithState:&v53 objects:v69 count:16];
    if (v15)
    {
      uint64_t v16 = v15;
      uint64_t v50 = *(void *)v54;
      do
      {
        for (uint64_t i = 0; i != v16; ++i)
        {
          if (*(void *)v54 != v50) {
            objc_enumerationMutation(obj);
          }
          long long v18 = *(void **)(*((void *)&v53 + 1) + 8 * i);
          long long v19 = [v18 quantity];
          long long v20 = v5;
          [v19 doubleValueForUnit:v5];
          double v22 = v21;
          unsigned int v23 = [v18 dateInterval];
          uint64_t v24 = [v23 startDate];
          [v24 timeIntervalSinceReferenceDate];
          double v26 = v25;
          unint64_t v27 = [v18 dateInterval];
          uint64_t v28 = [v27 endDate];
          [v28 timeIntervalSinceReferenceDate];
          id v52 = 0;
          char v30 = [v51 addSampleValue:0 startTime:&v52 endTime:v22 sourceID:v26 error:v29];
          id v31 = v52;

          if ((v30 & 1) == 0)
          {
            _HKInitializeLogging();
            uint64_t v32 = *MEMORY[0x1E4F29F10];
            if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F10], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138543618;
              id v66 = v48;
              __int16 v67 = 2114;
              id v68 = v31;
              _os_log_error_impl(&dword_1BCB7D000, v32, OS_LOG_TYPE_ERROR, "Failed to add datum to calculator during merge calculation for type %{public}@: %{public}@", buf, 0x16u);
            }
          }

          id v5 = v20;
        }
        uint64_t v16 = [obj countByEnumeratingWithState:&v53 objects:v69 count:16];
      }
      while (v16);
    }

    uint64_t v33 = [v51 currentStatistics];
    a2 = [v33 averageQuantity];

    id v3 = v47;
    id v4 = v48;
  }
  else
  {
    if (v6 == 1)
    {
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      id v34 = v3;
      uint64_t v35 = [v34 countByEnumeratingWithState:&v57 objects:v70 count:16];
      if (v35)
      {
        uint64_t v36 = v35;
        uint64_t v37 = *(void *)v58;
        double v38 = 0.0;
        do
        {
          for (uint64_t j = 0; j != v36; ++j)
          {
            if (*(void *)v58 != v37) {
              objc_enumerationMutation(v34);
            }
            uint64_t v40 = [*(id *)(*((void *)&v57 + 1) + 8 * j) quantity];
            [v40 doubleValueForUnit:v5];
            double v38 = v38 + v41;
          }
          uint64_t v36 = [v34 countByEnumeratingWithState:&v57 objects:v70 count:16];
        }
        while (v36);
      }
      else
      {
        double v38 = 0.0;
      }

      uint64_t v45 = (void *)MEMORY[0x1E4F2B370];
      double v44 = v38 / (double)(unint64_t)[v34 count];
      uint64_t v42 = v45;
      uint64_t v43 = v5;
    }
    else
    {
      if (v6) {
        goto LABEL_36;
      }
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      id v7 = v3;
      uint64_t v8 = [v7 countByEnumeratingWithState:&v61 objects:v71 count:16];
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = *(void *)v62;
        double v11 = 0.0;
        do
        {
          for (uint64_t k = 0; k != v9; ++k)
          {
            if (*(void *)v62 != v10) {
              objc_enumerationMutation(v7);
            }
            uint64_t v13 = [*(id *)(*((void *)&v61 + 1) + 8 * k) quantity];
            [v13 doubleValueForUnit:v5];
            double v11 = v11 + v14;
          }
          uint64_t v9 = [v7 countByEnumeratingWithState:&v61 objects:v71 count:16];
        }
        while (v9);
      }
      else
      {
        double v11 = 0.0;
      }

      uint64_t v42 = (void *)MEMORY[0x1E4F2B370];
      uint64_t v43 = v5;
      double v44 = v11;
    }
    a2 = [v42 quantityWithUnit:v43 doubleValue:v44];
  }
LABEL_36:

  return a2;
}

HDQuantityDatum *HDMergedQuantitySensorData(void *a1, void *a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if ([v3 count])
  {
    _assertMetadataIsSame(v3);
    id v5 = [v3 firstObject];
    uint64_t v6 = [v5 dateInterval];
    id v7 = [v6 startDate];

    if (v7)
    {
      uint64_t v8 = [v3 lastObject];
      uint64_t v9 = [v8 dateInterval];
      uint64_t v10 = [v9 endDate];

      if (v10)
      {
        uint64_t v40 = v10;
        double v41 = v7;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        id v11 = v3;
        uint64_t v12 = [v11 countByEnumeratingWithState:&v44 objects:v48 count:16];
        if (v12)
        {
          uint64_t v13 = v12;
          id v14 = 0;
          uint64_t v15 = *(void *)v45;
          do
          {
            for (uint64_t i = 0; i != v13; ++i)
            {
              if (*(void *)v45 != v15) {
                objc_enumerationMutation(v11);
              }
              uint64_t v17 = *(void **)(*((void *)&v44 + 1) + 8 * i);
              long long v18 = [v17 saveCompletion];

              if (v18)
              {
                if (!v14) {
                  id v14 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
                }
                long long v19 = [v17 saveCompletion];
                long long v20 = _Block_copy(v19);
                [v14 addObject:v20];
              }
            }
            uint64_t v13 = [v11 countByEnumeratingWithState:&v44 objects:v48 count:16];
          }
          while (v13);
        }
        else
        {
          id v14 = 0;
        }

        id v39 = v4;
        uint64_t v24 = _HDCombinedQuantityForData(v11, v4);
        double v38 = [HDQuantityDatum alloc];
        uint64_t v37 = [v11 lastObject];
        double v25 = [v37 datumIdentifier];
        double v26 = (void *)[objc_alloc(MEMORY[0x1E4F28C18]) initWithStartDate:v7 endDate:v40];
        unint64_t v27 = [v11 lastObject];
        uint64_t v28 = [v27 metadata];
        double v29 = [v11 lastObject];
        char v30 = [v29 resumeContextProvider];
        double v21 = [(HDQuantityDatum *)v38 initWithIdentifier:v25 dateInterval:v26 quantity:v24 metadata:v28 resumeContextProvider:v30];

        if (v14)
        {
          aBlock[0] = MEMORY[0x1E4F143A8];
          aBlock[1] = 3221225472;
          aBlock[2] = __HDMergedQuantitySensorData_block_invoke;
          aBlock[3] = &unk_1E62F2978;
          id v43 = v14;
          id v31 = _Block_copy(aBlock);
          [(HDQuantityDatum *)v21 setSaveCompletion:v31];
        }
        id v4 = v39;
        uint64_t v10 = v40;
        id v7 = v41;
      }
      else
      {
        _HKInitializeLogging();
        unsigned int v23 = (void *)*MEMORY[0x1E4F29F10];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F10], OS_LOG_TYPE_FAULT))
        {
          uint64_t v35 = v23;
          uint64_t v36 = [v3 lastObject];
          *(_DWORD *)long long buf = 138412290;
          uint64_t v50 = v36;
          _os_log_fault_impl(&dword_1BCB7D000, v35, OS_LOG_TYPE_FAULT, "Sensor datum missing end date: %@", buf, 0xCu);
        }
        double v21 = 0;
      }
    }
    else
    {
      _HKInitializeLogging();
      double v22 = (void *)*MEMORY[0x1E4F29F10];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F10], OS_LOG_TYPE_FAULT))
      {
        uint64_t v33 = v22;
        id v34 = [v3 firstObject];
        *(_DWORD *)long long buf = 138412290;
        uint64_t v50 = v34;
        _os_log_fault_impl(&dword_1BCB7D000, v33, OS_LOG_TYPE_FAULT, "Sensor datum missing start date: %@", buf, 0xCu);
      }
      double v21 = 0;
    }
  }
  else
  {
    double v21 = 0;
  }

  return v21;
}

void __HDMergedQuantitySensorData_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v11;
    do
    {
      uint64_t v9 = 0;
      do
      {
        if (*(void *)v11 != v8) {
          objc_enumerationMutation(v5);
        }
        (*(void (**)(void))(*(void *)(*((void *)&v10 + 1) + 8 * v9) + 16))(*(void *)(*((void *)&v10 + 1) + 8 * v9));
        ++v9;
      }
      while (v7 != v9);
      uint64_t v7 = [v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v7);
  }
}

id HDAggregateQuantitySensorData(void *a1, void *a2, void *a3, void *a4, double a5)
{
  uint64_t v9 = (void *)MEMORY[0x1E4F1C9C8];
  id v10 = a4;
  id v11 = a3;
  id v12 = a2;
  id v13 = a1;
  id v14 = [v9 distantPast];
  uint64_t v15 = HDAggregateQuantitySensorDataThroughDate(v13, v12, v11, v14, 0, v10, a5);

  return v15;
}

HDQuantityAggregationResult *HDAggregateQuantitySensorDataThroughDate(void *a1, void *a2, void *a3, void *a4, int a5, void *a6, double a7)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  id v12 = a1;
  id v99 = a2;
  id v13 = a3;
  id v14 = a4;
  id v95 = a6;
  uint64_t v15 = [v12 count];
  if (!v15)
  {
    double v25 = 0;
    goto LABEL_69;
  }
  unint64_t v16 = v15;
  id v91 = v14;
  uint64_t v92 = v13;
  uint64_t v17 = [v12 firstObject];
  uint64_t v18 = [v17 metadata];

  long long v19 = [v12 firstObject];
  long long v20 = [v19 dateInterval];
  uint64_t v21 = [v20 startDate];

  uint64_t v94 = (void *)v21;
  uint64_t v22 = [MEMORY[0x1E4F1C9C8] dateWithTimeInterval:v21 sinceDate:a7];
  char v100 = v12;
  unint64_t v102 = v16;
  if (v16 == 1)
  {
    unint64_t v101 = 0;
    id v97 = 0;
    uint64_t v98 = 0;
    unsigned int v23 = (void *)v18;
    uint64_t v24 = (void *)v22;
  }
  else
  {
    id v97 = 0;
    uint64_t v98 = 0;
    unint64_t v101 = 0;
    uint64_t v26 = 1;
    unsigned int v23 = (void *)v18;
    uint64_t v24 = (void *)v22;
    do
    {
      unint64_t v27 = [v12 objectAtIndexedSubscript:v26];
      uint64_t v28 = [v27 dateInterval];
      double v29 = [v28 endDate];

      char v30 = [v27 metadata];
      if (v23 == v30)
      {
        unsigned int v33 = 1;
      }
      else
      {
        id v31 = [v27 metadata];
        if (v31)
        {
          uint64_t v32 = [v27 metadata];
          unsigned int v33 = [v23 isEqual:v32];
        }
        else
        {
          unsigned int v33 = 0;
        }
      }
      if (!objc_msgSend(v29, "hk_isBeforeDate:", v24) || (v33 & 1) == 0)
      {
        id v34 = [v27 dateInterval];
        uint64_t v35 = [v34 startDate];
        uint64_t v36 = v12;
        uint64_t v37 = v24;
        [v24 timeIntervalSinceDate:v35];
        double v39 = v38;

        uint64_t v40 = [v27 dateInterval];
        [v40 duration];
        double v42 = v41;

        if (v39 + v39 >= v42) {
          uint64_t v43 = v33;
        }
        else {
          uint64_t v43 = 0;
        }
        uint64_t v44 = v43 - 1;
        long long v45 = [v36 subarrayWithRange:v39 + v39];
        long long v46 = _HDCombineQuantitySensorData(v45, v99, v95);
        if (!v46) {
          goto LABEL_26;
        }
        long long v47 = v23;
        _HKInitializeLogging();
        id v48 = (void *)*MEMORY[0x1E4F29F10];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F10], OS_LOG_TYPE_INFO))
        {
          unsigned int v49 = v48;
          uint64_t v50 = [v45 count];
          *(_DWORD *)long long buf = 138543874;
          id v104 = v99;
          __int16 v105 = 2048;
          uint64_t v106 = v50;
          __int16 v107 = 2112;
          uint64_t v108 = v46;
          _os_log_impl(&dword_1BCB7D000, v49, OS_LOG_TYPE_INFO, "%{public}@: Aggregating %ld sensor datums produced %@", buf, 0x20u);
        }
        id v51 = v97;
        if (!v97) {
          id v51 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
        }
        id v97 = v51;
        [v51 addObjectsFromArray:v46];
        unsigned int v23 = v47;
        id v52 = v98;
        if (!v98) {
          id v52 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
        }
        uint64_t v98 = v52;
        [v52 addObjectsFromArray:v45];
        unint64_t v53 = v26 + v44 + 1;
        unint64_t v101 = v53;
        if (v53 < [v100 count])
        {
          long long v54 = [v100 objectAtIndexedSubscript:v53];
          uint64_t v55 = [v54 metadata];

          long long v56 = [v54 dateInterval];
          uint64_t v57 = [v56 startDate];

          uint64_t v24 = [MEMORY[0x1E4F1C9C8] dateWithTimeInterval:v57 sinceDate:a7];

          uint64_t v94 = (void *)v57;
          unsigned int v23 = (void *)v55;
        }
        else
        {
LABEL_26:
          uint64_t v24 = v37;
        }

        id v12 = v100;
      }

      ++v26;
      unint64_t v16 = v102;
    }
    while (v102 != v26);
  }
  unint64_t v93 = v24;
  unint64_t v58 = v101;
  uint64_t v90 = v23;
  if (v16 <= v101)
  {
    id v14 = v91;
    id v13 = v92;
  }
  else
  {
    id v13 = v92;
    [v92 timeIntervalSinceDate:v94];
    id v14 = v91;
    if (v59 >= a7)
    {
      long long v60 = objc_msgSend(v12, "subarrayWithRange:", v101, v16 - v101);
      long long v61 = _HDCombineQuantitySensorData(v60, v99, v95);
      if (v61)
      {
        _HKInitializeLogging();
        long long v62 = (void *)*MEMORY[0x1E4F29F10];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F10], OS_LOG_TYPE_INFO))
        {
          long long v63 = v62;
          uint64_t v64 = [v60 count];
          *(_DWORD *)long long buf = 138543874;
          id v104 = v99;
          __int16 v105 = 2048;
          uint64_t v106 = v64;
          __int16 v107 = 2112;
          uint64_t v108 = v61;
          _os_log_impl(&dword_1BCB7D000, v63, OS_LOG_TYPE_INFO, "%{public}@: Aggregating %ld sensor datums produced %@", buf, 0x20u);
        }
        id v65 = v97;
        if (!v97) {
          id v65 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
        }
        id v97 = v65;
        [v65 addObjectsFromArray:v61];
        id v66 = v98;
        if (!v98) {
          id v66 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
        }
        uint64_t v98 = v66;
        [v66 addObjectsFromArray:v60];
        unint64_t v58 = v16;
      }
      unint64_t v101 = v58;
    }
  }
  unint64_t v67 = v16;
  while (1)
  {
    unint64_t v68 = v67 - 1;
    uint64_t v69 = [v12 objectAtIndexedSubscript:v67 - 1];
    unint64_t v70 = [v69 dateInterval];
    uint64_t v71 = [v70 startDate];

    uint64_t v72 = [v69 dateInterval];
    uint64_t v73 = [v72 endDate];

    if ((objc_msgSend(v71, "hk_isAfterDate:", v14) & 1) == 0
      && (!objc_msgSend(v73, "hk_isAfterOrEqualToDate:", v14) || a5))
    {
      break;
    }

    --v67;
    if (!v68)
    {
      unint64_t v74 = v93;
      id v75 = v97;
      unint64_t v76 = v101;
      goto LABEL_60;
    }
  }
  unint64_t v76 = v101;
  if (v68 >= v101)
  {
    uint64_t v77 = objc_msgSend(v12, "subarrayWithRange:", v101, v67 - v101);
    unint64_t v78 = _HDCombineQuantitySensorData(v77, v99, v95);
    if (v78)
    {
      _HKInitializeLogging();
      char v79 = (void *)*MEMORY[0x1E4F29F10];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F10], OS_LOG_TYPE_INFO))
      {
        unsigned int v80 = v79;
        uint64_t v81 = [v77 count];
        *(_DWORD *)long long buf = 138543874;
        id v104 = v99;
        __int16 v105 = 2048;
        uint64_t v106 = v81;
        __int16 v107 = 2112;
        uint64_t v108 = v78;
        _os_log_impl(&dword_1BCB7D000, v80, OS_LOG_TYPE_INFO, "%{public}@: Aggregating %ld sensor datums produced %@", buf, 0x20u);
      }
      id v75 = v97;
      if (!v97) {
        id v75 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      }
      [v75 addObjectsFromArray:v78];
      id v82 = v98;
      if (!v98) {
        id v82 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      }
      uint64_t v98 = v82;
      [v82 addObjectsFromArray:v77];
      unint64_t v76 = v67;
      unint64_t v74 = v93;
    }
    else
    {
      unint64_t v74 = v93;
      id v75 = v97;
    }

    id v14 = v91;
    id v13 = v92;
  }
  else
  {
    unint64_t v74 = v93;
    id v75 = v97;
  }

LABEL_60:
  if (v75)
  {
    id v83 = v75;
    if (v102 <= v76)
    {
      id v84 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    }
    else
    {
      objc_msgSend(v100, "hk_mutableSubarrayWithRange:", v76, v102 - v76);
      id v84 = (id)objc_claimAutoreleasedReturnValue();
    }
    char v85 = v84;
    double v25 = [[HDQuantityAggregationResult alloc] initWithAggregatedSamples:v83 consumedData:v98 remainingData:v84];
  }
  else
  {
    if ((unint64_t)[v100 count] < 2)
    {
      double v25 = 0;
      uint64_t v88 = v90;
      goto LABEL_68;
    }
    id v83 = 0;
    char v85 = HDMergedQuantitySensorData(v100, v99);
    uint64_t v86 = [HDQuantityAggregationResult alloc];
    unint64_t v87 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithObjects:", v85, 0);
    double v25 = [(HDQuantityAggregationResult *)v86 initWithAggregatedSamples:0 consumedData:0 remainingData:v87];

    unint64_t v74 = v93;
  }

  uint64_t v88 = v90;
  id v75 = v83;
LABEL_68:

  id v12 = v100;
LABEL_69:

  return v25;
}

void sub_1BCE090FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t HDCodableRoutePointDatumReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v15 = v9++ >= 9;
        if (v15)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          *(unsigned char *)(a1 + 52) |= 0x10u;
          uint64_t v18 = *v3;
          unint64_t v19 = *(void *)(a2 + v18);
          if (v19 <= 0xFFFFFFFFFFFFFFF7 && v19 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v20 = *(void *)(*(void *)(a2 + *v7) + v19);
            *(void *)(a2 + v1_Block_object_dispose(&a9, 8) = v19 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v20 = 0;
          }
          uint64_t v37 = 40;
          goto LABEL_57;
        case 2u:
          *(unsigned char *)(a1 + 52) |= 2u;
          uint64_t v22 = *v3;
          unint64_t v23 = *(void *)(a2 + v22);
          if (v23 <= 0xFFFFFFFFFFFFFFF7 && v23 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v20 = *(void *)(*(void *)(a2 + *v7) + v23);
            *(void *)(a2 + v22) = v23 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v20 = 0;
          }
          uint64_t v37 = 16;
          goto LABEL_57;
        case 3u:
          *(unsigned char *)(a1 + 52) |= 4u;
          uint64_t v24 = *v3;
          unint64_t v25 = *(void *)(a2 + v24);
          if (v25 <= 0xFFFFFFFFFFFFFFF7 && v25 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v20 = *(void *)(*(void *)(a2 + *v7) + v25);
            *(void *)(a2 + v24) = v25 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v20 = 0;
          }
          uint64_t v37 = 24;
          goto LABEL_57;
        case 4u:
          *(unsigned char *)(a1 + 52) |= 1u;
          uint64_t v26 = *v3;
          unint64_t v27 = *(void *)(a2 + v26);
          if (v27 <= 0xFFFFFFFFFFFFFFF7 && v27 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v20 = *(void *)(*(void *)(a2 + *v7) + v27);
            *(void *)(a2 + v26) = v27 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v20 = 0;
          }
          uint64_t v37 = 8;
          goto LABEL_57;
        case 5u:
          *(unsigned char *)(a1 + 52) |= 8u;
          uint64_t v28 = *v3;
          unint64_t v29 = *(void *)(a2 + v28);
          if (v29 <= 0xFFFFFFFFFFFFFFF7 && v29 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v20 = *(void *)(*(void *)(a2 + *v7) + v29);
            *(void *)(a2 + v2_Block_object_dispose(&a9, 8) = v29 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v20 = 0;
          }
          uint64_t v37 = 32;
LABEL_57:
          *(void *)(a1 + v37) = v20;
          continue;
        case 6u:
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v32 = 0;
          *(unsigned char *)(a1 + 52) |= 0x20u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v33 = *v3;
        uint64_t v34 = *(void *)(a2 + v33);
        unint64_t v35 = v34 + 1;
        if (v34 == -1 || v35 > *(void *)(a2 + *v4)) {
          break;
        }
        char v36 = *(unsigned char *)(*(void *)(a2 + *v7) + v34);
        *(void *)(a2 + v33) = v35;
        v32 |= (unint64_t)(v36 & 0x7F) << v30;
        if ((v36 & 0x80) == 0) {
          goto LABEL_44;
        }
        v30 += 7;
        BOOL v15 = v31++ >= 9;
        if (v15)
        {
          LODWORD(v32) = 0;
          goto LABEL_46;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_44:
      if (*(unsigned char *)(a2 + *v5)) {
        LODWORD(v32) = 0;
      }
LABEL_46:
      *(_DWORD *)(a1 + 4_Block_object_dispose(&a9, 8) = v32;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t __Block_byref_object_copy__90(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__90(uint64_t a1)
{
}

void sub_1BCE0B978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE0BFA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE0C5CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE0D9C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE0DDDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE0E870(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1BCE0FC40(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void *health::DataStoreInspector::DataStoreInspector(void *this, DataStore *a2)
{
  *this = a2;
  return this;
}

{
  *this = a2;
  return this;
}

void health::DataStoreInspector::enumerateStoreForPrinting(uint64_t *a1, uint64_t a2, int a3, long long **a4)
{
  void v20[4] = *MEMORY[0x1E4F143B8];
  int v16 = a3;
  if (a3 == 1)
  {
    uint64_t v7 = *a1;
    v20[0] = &unk_1F171E5D0;
    v20[1] = a1;
    void v20[2] = a2;
    void v20[3] = v20;
    health::DataStore::checkIntegrityForInspecting(v7, (uint64_t)v20);
    std::__function::__value_func<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::~__value_func[abi:ne180100](v20);
  }
  unint64_t v13 = 0;
  char v14 = 0;
  uint64_t v15 = 0;
  int v12 = 0;
  uint64_t v8 = *a1;
  unsigned int v9 = operator new(0x30uLL);
  void *v9 = &unk_1F171EBA0;
  v9[1] = &v12;
  void v9[2] = a1;
  v9[3] = &v16;
  void v9[4] = a2;
  void v9[5] = &v13;
  v19[3] = v9;
  health::DataStore::enumerateObjectTreeForInspecting(v8, (uint64_t)v19);
  std::__function::__value_func<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::~__value_func[abi:ne180100](v19);
  if (v16)
  {
    if (a4 && v16 == 1)
    {
      std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v18, a2);
      health::DataStoreInspector::_crossReferenceWithSQLiteEntries((uint64_t)a1, (long long **)&v13, a4, (uint64_t)v18);
      std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v18);
    }
  }
  else
  {
    uint64_t v17 = &v12;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<int &>((std::string *)"\nTotal # of objects = {0}", &__p, 0, (uint64_t *)&v17);
    uint64_t v10 = *(void *)(a2 + 24);
    if (!v10) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v10 + 48))(v10, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  if (v13)
  {
    char v14 = v13;
    operator delete(v13);
  }
}

void sub_1BCE109D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void health::DataStoreInspector::_crossReferenceWithSQLiteEntries(uint64_t a1, long long **a2, long long **a3, uint64_t a4)
{
  v53[4] = *MEMORY[0x1E4F143B8];
  v51[0] = 0;
  v51[1] = 0;
  v49[1] = 0;
  uint64_t v50 = (uint64_t *)v51;
  id v48 = v49;
  v49[0] = 0;
  v47[0] = 0;
  v47[1] = 0;
  v45[1] = 0;
  long long v46 = (uint64_t *)v47;
  uint64_t v44 = v45;
  v45[0] = 0;
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  if (*a2 != v8)
  {
    do
    {
      long long v42 = *v7;
      BOOL v9 = (void)v42 == 3 || (void)v42 == 0;
      unint64_t v10 = *((void *)&v42 + 1);
      if (v9)
      {
        uint64_t v11 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(&v50, *((unint64_t *)&v42 + 1), (void *)&v42 + 1);
        int v12 = (uint64_t *)&v48;
      }
      else
      {
        uint64_t v11 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(&v46, *((unint64_t *)&v42 + 1), (void *)&v42 + 1);
        int v12 = (uint64_t *)&v44;
      }
      long long v13 = *v7;
      long long v14 = v7[1];
      long long v15 = v7[2];
      v11[11] = (uint64_t *)*((void *)v7 + 6);
      *(_OWORD *)(v11 + 9) = v15;
      *(_OWORD *)(v11 + 7) = v14;
      *(_OWORD *)(v11 + 5) = v13;
      std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(v12, v10, v10);
      uint64_t v7 = (long long *)((char *)v7 + 56);
    }
    while (v7 != v8);
    uint64_t v7 = *a2;
  }
  a2[1] = v7;
  *((void *)&v42 + 1) = 0;
  uint64_t v43 = 0;
  *(void *)&long long v42 = (char *)&v42 + 8;
  v41[0] = 0;
  v41[1] = 0;
  v39[1] = 0;
  uint64_t v40 = v41;
  double v38 = (uint64_t *)v39;
  v39[0] = 0;
  v37[0] = 0;
  v37[1] = 0;
  char v36 = v37;
  int v16 = *a3;
  uint64_t v17 = a3[1];
  if (*a3 != v17)
  {
    do
    {
      long long v35 = *v16;
      BOOL v18 = (void)v35 == 3 || (void)v35 == 0;
      unint64_t v19 = *((void *)&v35 + 1);
      if (v18)
      {
        uint64_t v20 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)&v42, *((unint64_t *)&v35 + 1), (void *)&v35 + 1);
        uint64_t v21 = (uint64_t *)&v40;
      }
      else
      {
        uint64_t v20 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(&v38, *((unint64_t *)&v35 + 1), (void *)&v35 + 1);
        uint64_t v21 = (uint64_t *)&v36;
      }
      long long v22 = *v16;
      long long v23 = v16[1];
      long long v24 = v16[2];
      v20[11] = (uint64_t *)*((void *)v16 + 6);
      *(_OWORD *)(v20 + 9) = v24;
      *(_OWORD *)(v20 + 7) = v23;
      *(_OWORD *)(v20 + 5) = v22;
      std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(v21, v19, v19);
      int v16 = (long long *)((char *)v16 + 56);
    }
    while (v16 != v17);
    int v16 = *a3;
  }
  a3[1] = v16;
  std::map<unsigned long long,health::DataStoreInspector::DataSeriesEntry>::map[abi:ne180100]((uint64_t)v34, &v50);
  std::set<unsigned long long>::set[abi:ne180100]((uint64_t)v33, &v48);
  std::map<unsigned long long,health::DataStoreInspector::DataSeriesEntry>::map[abi:ne180100]((uint64_t)v32, &v42);
  std::set<unsigned long long>::set[abi:ne180100]((uint64_t)v31, &v40);
  uint64_t v25 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v53, a4);
  health::DataStoreInspector::_crossReferenceWithSQLiteKeys(v25, v34, v33, v32, v31, (uint64_t)v53);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v53);
  std::__tree<long>::destroy((void *)v31[1]);
  std::__tree<long>::destroy(v32[1]);
  std::__tree<long>::destroy((void *)v33[1]);
  std::__tree<long>::destroy(v34[1]);
  std::map<unsigned long long,health::DataStoreInspector::DataSeriesEntry>::map[abi:ne180100]((uint64_t)v30, &v46);
  std::set<unsigned long long>::set[abi:ne180100]((uint64_t)v29, &v44);
  std::map<unsigned long long,health::DataStoreInspector::DataSeriesEntry>::map[abi:ne180100]((uint64_t)v28, &v38);
  std::set<unsigned long long>::set[abi:ne180100]((uint64_t)v27, &v36);
  uint64_t v26 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v52, a4);
  health::DataStoreInspector::_crossReferenceWithSQLiteKeys(v26, v30, v29, v28, v27, (uint64_t)v52);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v52);
  std::__tree<long>::destroy((void *)v27[1]);
  std::__tree<long>::destroy(v28[1]);
  std::__tree<long>::destroy((void *)v29[1]);
  std::__tree<long>::destroy(v30[1]);
  std::__tree<long>::destroy(v37[0]);
  std::__tree<long>::destroy(v39[0]);
  std::__tree<long>::destroy(v41[0]);
  std::__tree<long>::destroy(*((void **)&v42 + 1));
  std::__tree<long>::destroy(v45[0]);
  std::__tree<long>::destroy(v47[0]);
  std::__tree<long>::destroy(v49[0]);
  std::__tree<long>::destroy(v51[0]);
}

void sub_1BCE10DA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,void *a43)
{
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100]((void *)(v43 - 136));
  std::__tree<long>::destroy(a10);
  std::__tree<long>::destroy(a13);
  std::__tree<long>::destroy(a16);
  std::__tree<long>::destroy(a19);
  std::__tree<long>::destroy(a37);
  std::__tree<long>::destroy(a40);
  std::__tree<long>::destroy(a43);
  std::__tree<long>::destroy(*(void **)(v43 - 248));
  std::__tree<long>::destroy(*(void **)(v43 - 224));
  std::__tree<long>::destroy(*(void **)(v43 - 200));
  std::__tree<long>::destroy(*(void **)(v43 - 176));
  std::__tree<long>::destroy(*(void **)(v43 - 152));
  _Unwind_Resume(a1);
}

void *health::DataStoreInspector::enumerateSampleHistoryForPrinting(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, char a6)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  switch(a2)
  {
    case 0:
      std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v18, a4);
      health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>((uint64_t)v14, a1, a2, a3, (uint64_t)v18, a5, a6);
      uint64_t v11 = v18;
      break;
    case 1:
      std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v16, a4);
      health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>((uint64_t)v14, a1, a2, a3, (uint64_t)v16, a5, a6);
      uint64_t v11 = v16;
      break;
    case 2:
      std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v15, a4);
      health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>((uint64_t)v14, a1, a2, a3, (uint64_t)v15, a5, a6);
      uint64_t v11 = v15;
      break;
    case 3:
      std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v17, a4);
      health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>((uint64_t)v14, a1, a2, a3, (uint64_t)v17, a5, a6);
      uint64_t v11 = v17;
      break;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Unexpected object type");
      __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  return std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v11);
}

void sub_1BCE1104C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a2 == 1)
  {
    unint64_t v27 = __cxa_begin_catch(exception_object);
    uint64_t v28 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)&a16, v26);
    health::DataStoreInspector::_unknownBehaviorHandler(v28, v25, v24, (uint64_t)v27, (uint64_t)&a16);
    std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](&a16);
    __cxa_end_catch();
    JUMPOUT(0x1BCE10FD8);
  }
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7)
{
  void v25[4] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v24 = a3;
  *((void *)&v24 + 1) = a4;
  int v23 = a6;
  char v22 = a7;
  *(_OWORD *)a1 = v24;
  *(_OWORD *)(a1 + 16) = xmmword_1BD325E90;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 32) = _Q0;
  *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0xBFF0000000000000;
  uint64_t v21 = 0;
  uint64_t v15 = *a2;
  int v16 = operator new(0x40uLL);
  void *v16 = &unk_1F171E6E0;
  v16[1] = a1;
  void v16[2] = &v23;
  void v16[3] = &v24;
  void v16[4] = a2;
  v16[5] = a5;
  v16[6] = &v22;
  v16[7] = &v21;
  v25[3] = v16;
  char v17 = health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(v15, (uint64_t)&v24, (uint64_t)v25);
  std::__function::__value_func<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::~__value_func[abi:ne180100](v25);
  if (v23 == 1) {
    char v18 = 1;
  }
  else {
    char v18 = v17;
  }
  if ((v18 & 1) == 0)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&__p, (std::string *)"Sample history [ID: {0}] does not exist.", (uint64_t)&v24);
    uint64_t v19 = *(void *)(a5 + 24);
    if (!v19) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    goto LABEL_10;
  }
  if (!v23 && v21 >= 1)
  {
    health::FormatString<long long &>(&__p, (uint64_t)&v21);
    uint64_t v19 = *(void *)(a5 + 24);
    if (!v19) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
LABEL_10:
    (*(void (**)(uint64_t, std::string *))(*(void *)v19 + 48))(v19, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1BCE11308(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7)
{
  void v25[4] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v24 = a3;
  *((void *)&v24 + 1) = a4;
  int v23 = a6;
  char v22 = a7;
  *(_OWORD *)a1 = v24;
  *(_OWORD *)(a1 + 16) = xmmword_1BD325E90;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 32) = _Q0;
  *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0xBFF0000000000000;
  uint64_t v21 = 0;
  uint64_t v15 = *a2;
  int v16 = operator new(0x40uLL);
  void *v16 = &unk_1F171E880;
  v16[1] = a1;
  void v16[2] = &v23;
  void v16[3] = &v24;
  void v16[4] = a2;
  v16[5] = a5;
  v16[6] = &v22;
  v16[7] = &v21;
  v25[3] = v16;
  char v17 = health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(v15, (uint64_t)&v24, (uint64_t)v25);
  std::__function::__value_func<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::~__value_func[abi:ne180100](v25);
  if (v23 == 1) {
    char v18 = 1;
  }
  else {
    char v18 = v17;
  }
  if ((v18 & 1) == 0)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&__p, (std::string *)"Sample history [ID: {0}] does not exist.", (uint64_t)&v24);
    uint64_t v19 = *(void *)(a5 + 24);
    if (!v19) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    goto LABEL_10;
  }
  if (!v23 && v21 >= 1)
  {
    health::FormatString<long long &>(&__p, (uint64_t)&v21);
    uint64_t v19 = *(void *)(a5 + 24);
    if (!v19) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
LABEL_10:
    (*(void (**)(uint64_t, std::string *))(*(void *)v19 + 48))(v19, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1BCE114FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7)
{
  void v25[4] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v24 = a3;
  *((void *)&v24 + 1) = a4;
  int v23 = a6;
  char v22 = a7;
  *(_OWORD *)a1 = v24;
  *(_OWORD *)(a1 + 16) = xmmword_1BD325E90;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 32) = _Q0;
  *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0xBFF0000000000000;
  uint64_t v21 = 0;
  uint64_t v15 = *a2;
  int v16 = operator new(0x40uLL);
  void *v16 = &unk_1F171E9A0;
  v16[1] = a1;
  void v16[2] = &v23;
  void v16[3] = &v24;
  void v16[4] = a2;
  v16[5] = a5;
  v16[6] = &v22;
  v16[7] = &v21;
  v25[3] = v16;
  char v17 = health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(v15, (uint64_t)&v24, (uint64_t)v25);
  std::__function::__value_func<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::~__value_func[abi:ne180100](v25);
  if (v23 == 1) {
    char v18 = 1;
  }
  else {
    char v18 = v17;
  }
  if ((v18 & 1) == 0)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&__p, (std::string *)"Sample history [ID: {0}] does not exist.", (uint64_t)&v24);
    uint64_t v19 = *(void *)(a5 + 24);
    if (!v19) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    goto LABEL_10;
  }
  if (!v23 && v21 >= 1)
  {
    health::FormatString<long long &>(&__p, (uint64_t)&v21);
    uint64_t v19 = *(void *)(a5 + 24);
    if (!v19) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
LABEL_10:
    (*(void (**)(uint64_t, std::string *))(*(void *)v19 + 48))(v19, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1BCE116F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7)
{
  void v25[4] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v24 = a3;
  *((void *)&v24 + 1) = a4;
  int v23 = a6;
  char v22 = a7;
  *(_OWORD *)a1 = v24;
  *(_OWORD *)(a1 + 16) = xmmword_1BD325E90;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 32) = _Q0;
  *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0xBFF0000000000000;
  uint64_t v21 = 0;
  uint64_t v15 = *a2;
  int v16 = operator new(0x40uLL);
  void *v16 = &unk_1F171EAA0;
  v16[1] = a1;
  void v16[2] = &v23;
  void v16[3] = &v24;
  void v16[4] = a2;
  v16[5] = a5;
  v16[6] = &v22;
  v16[7] = &v21;
  v25[3] = v16;
  char v17 = health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(v15, (uint64_t)&v24, (uint64_t)v25);
  std::__function::__value_func<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::~__value_func[abi:ne180100](v25);
  if (v23 == 1) {
    char v18 = 1;
  }
  else {
    char v18 = v17;
  }
  if ((v18 & 1) == 0)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &>(&__p, (std::string *)"Sample history [ID: {0}] does not exist.", (uint64_t)&v24);
    uint64_t v19 = *(void *)(a5 + 24);
    if (!v19) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    goto LABEL_10;
  }
  if (!v23 && v21 >= 1)
  {
    health::FormatString<long long &>(&__p, (uint64_t)&v21);
    uint64_t v19 = *(void *)(a5 + 24);
    if (!v19) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
LABEL_10:
    (*(void (**)(uint64_t, std::string *))(*(void *)v19 + 48))(v19, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1BCE118E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_unknownBehaviorHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v11[4] = *MEMORY[0x1E4F143B8];
  v9[0] = a2;
  v9[1] = a3;
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 16))(a4);
  memset(&__p, 0, sizeof(__p));
  v10[0] = (char **)&v7;
  v10[1] = (char **)v9;
  health::FormatImplementation<health::DataStore::ObjectIdentifier &,char const*>((std::string *)"HFD sample history [ID: {0}] has unknown behavior - {1}", &__p, 0, v10);
  uint64_t v6 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v11, a5);
  health::DataStoreInspector::_errorHandler(v6, 2, 0, 0, (std::string::size_type)&__p, (uint64_t)v11);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1BCE11A04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100]((void *)(v16 - 56));
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL health::DataStoreInspector::_isLocationSeriesKey(health::DataStoreInspector *this, ObjectIdentifier a2)
{
  return !a2.objectType || a2.objectType == 3;
}

void health::DataStoreInspector::_crossReferenceWithSQLiteKeys(uint64_t a1, uint64_t **a2, std::string::size_type *a3, uint64_t **a4, std::string::size_type *a5, uint64_t a6)
{
  v74[4] = *MEMORY[0x1E4F143B8];
  v69[0] = 0;
  v69[1] = 0;
  unint64_t v68 = v69;
  uint64_t v11 = a5 + 1;
  unint64_t v10 = (std::string::size_type *)*a5;
  std::string::size_type v12 = (std::string::size_type)(a3 + 1);
  long long v13 = (void *)*a3;
  *(void *)&long long v60 = &v68;
  *((void *)&v60 + 1) = v69;
  BOOL v14 = v10 == a5 + 1 || v13 == (void *)v12;
  if (v14)
  {
    uint64_t v15 = a5;
  }
  else
  {
    do
    {
      unint64_t v17 = v10[4];
      unint64_t v18 = v13[4];
      if (v17 >= v18)
      {
        if (v18 >= v17)
        {
          std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100]((uint64_t)&v60, v17);
          char v22 = (std::string::size_type *)v10[1];
          if (v22)
          {
            do
            {
              uint64_t v21 = v22;
              char v22 = (std::string::size_type *)*v22;
            }
            while (v22);
          }
          else
          {
            do
            {
              uint64_t v21 = (std::string::size_type *)v10[2];
              BOOL v14 = *v21 == (void)v10;
              unint64_t v10 = v21;
            }
            while (!v14);
          }
        }
        else
        {
          uint64_t v21 = v10;
        }
        int v23 = (void *)v13[1];
        if (v23)
        {
          do
          {
            long long v13 = v23;
            int v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            long long v24 = v13;
            long long v13 = (void *)v13[2];
          }
          while ((void *)*v13 != v24);
        }
        unint64_t v10 = v21;
      }
      else
      {
        uint64_t v19 = (std::string::size_type *)v10[1];
        if (v19)
        {
          do
          {
            unint64_t v10 = v19;
            uint64_t v19 = (std::string::size_type *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            uint64_t v20 = v10;
            unint64_t v10 = (std::string::size_type *)v10[2];
          }
          while ((std::string::size_type *)*v10 != v20);
        }
      }
    }
    while (v10 != v11 && v13 != (void *)v12);
    long long v13 = (void *)*a3;
    uint64_t v15 = a5;
    unint64_t v10 = (std::string::size_type *)*a5;
  }
  v67[0] = 0;
  v67[1] = 0;
  id v66 = v67;
  uint64_t v64 = (void **)v13;
  __p.__r_.__value_.__r.__words[0] = v12;
  v53[0] = v10;
  v52.__r_.__value_.__r.__words[0] = (std::string::size_type)v11;
  *(void *)&long long v56 = &v66;
  *((void *)&v56 + 1) = v67;
  std::__set_difference[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::insert_iterator<std::set<unsigned long long>> &>((uint64_t)&v60, (uint64_t)&v64, &__p, (uint64_t)v53, &v52, &v56);
  v65[0] = 0;
  v65[1] = 0;
  uint64_t v64 = v65;
  std::string::size_type v25 = *a3;
  __p.__r_.__value_.__r.__words[0] = *v15;
  v53[0] = v11;
  v52.__r_.__value_.__r.__words[0] = v25;
  v51.__r_.__value_.__r.__words[0] = v12;
  *(void *)&long long v56 = &v64;
  *((void *)&v56 + 1) = v65;
  std::__set_difference[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::insert_iterator<std::set<unsigned long long>> &>((uint64_t)&v60, (uint64_t)&__p, v53, (uint64_t)&v52, &v51, &v56);
  uint64_t v26 = v68;
  if (v68 != v69)
  {
    do
    {
      unint64_t v27 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a2, v26[4], v26 + 4);
      long long v28 = *(_OWORD *)(v27 + 7);
      long long v60 = *(_OWORD *)(v27 + 5);
      long long v61 = v28;
      long long v62 = *(_OWORD *)(v27 + 9);
      long long v63 = v27[11];
      unint64_t v29 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a4, v26[4], v26 + 4);
      long long v30 = *(_OWORD *)(v29 + 7);
      long long v56 = *(_OWORD *)(v29 + 5);
      long long v57 = v30;
      long long v58 = *(_OWORD *)(v29 + 9);
      double v59 = v29[11];
      if ((void)v30)
      {
        if (*((void *)&v57 + 1) != *((void *)&v61 + 1))
        {
          health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(&__p, (std::string *)"HFD sample history [ID: {0}] has an actual sample count ({1}) that does not match its SQLite row ({2})", (uint64_t)&v60, (uint64_t)&v61 + 8, (uint64_t)&v57 + 8);
          uint64_t v31 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v74, a6);
          health::DataStoreInspector::_errorHandler(v31, 4, 0, 0, (std::string::size_type)&__p, (uint64_t)v74);
          std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v74);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
      }
      if (vabdd_f64(*((double *)&v58 + 1), *((double *)&v62 + 1)) > 1800.0)
      {
        health::timestampToDate(*((double *)&v62 + 1), &__p);
        health::timestampToDate(*((double *)&v58 + 1), v53);
        health::FormatString<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(&v52, (std::string *)"HFD sample history [ID: {0}] has an actual start date ({1}) that does not match its SQLite row ({2})", (uint64_t)&v60, (uint64_t)&__p, (uint64_t)v53);
        uint64_t v32 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v73, a6);
        health::DataStoreInspector::_errorHandler(v32, 4, 0, 0, (std::string::size_type)&v52, (uint64_t)v73);
        std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v73);
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v52.__r_.__value_.__l.__data_);
        }
        if (v54 < 0) {
          operator delete(v53[0]);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      if (vabdd_f64(*(double *)&v59, *(double *)&v63) > 1800.0)
      {
        health::timestampToDate(*(double *)&v63, &__p);
        health::timestampToDate(*(double *)&v59, v53);
        health::FormatString<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(&v52, (std::string *)"HFD sample history [ID: {0}] has an actual end date ({1}) that does not match its SQLite row ({2})", (uint64_t)&v60, (uint64_t)&__p, (uint64_t)v53);
        uint64_t v33 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v72, a6);
        health::DataStoreInspector::_errorHandler(v33, 4, 0, 0, (std::string::size_type)&v52, (uint64_t)v72);
        std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v72);
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v52.__r_.__value_.__l.__data_);
        }
        if (v54 < 0) {
          operator delete(v53[0]);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      uint64_t v34 = (void *)v26[1];
      if (v34)
      {
        do
        {
          long long v35 = (void **)v34;
          uint64_t v34 = (void *)*v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          long long v35 = (void **)v26[2];
          BOOL v14 = *v35 == v26;
          uint64_t v26 = v35;
        }
        while (!v14);
      }
      uint64_t v26 = v35;
    }
    while (v35 != v69);
  }
  char v36 = v66;
  if (v66 != v67)
  {
    do
    {
      uint64_t v37 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a2, v36[4], v36 + 4);
      long long v38 = *(_OWORD *)(v37 + 9);
      long long v39 = *(_OWORD *)(v37 + 7);
      long long v60 = *(_OWORD *)(v37 + 5);
      long long v61 = v39;
      long long v62 = v38;
      long long v63 = v37[11];
      health::timestampToDate(*((double *)&v38 + 1), &__p);
      health::timestampToDate(*(double *)&v63, v53);
      *(void *)&long long v56 = v53;
      *((void *)&v56 + 1) = &__p;
      *(void *)&long long v57 = (char *)&v61 + 8;
      *((void *)&v57 + 1) = &v60;
      memset(&v52, 0, sizeof(v52));
      health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>((std::string *)"[ID: {0} | Count: {1} | {2} to {3}]", &v52, 0, (uint64_t *)&v56);
      uint64_t v40 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v71, a6);
      health::DataStoreInspector::_errorHandler(v40, 5, 0, 0, (std::string::size_type)&v52, (uint64_t)v71);
      std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v71);
      if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v52.__r_.__value_.__l.__data_);
      }
      if (v54 < 0) {
        operator delete(v53[0]);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      double v41 = (void *)v36[1];
      if (v41)
      {
        do
        {
          long long v42 = (void **)v41;
          double v41 = (void *)*v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          long long v42 = (void **)v36[2];
          BOOL v14 = *v42 == v36;
          char v36 = v42;
        }
        while (!v14);
      }
      char v36 = v42;
    }
    while (v42 != v67);
  }
  uint64_t v43 = v64;
  if (v64 != v65)
  {
    do
    {
      uint64_t v44 = std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a4, v43[4], v43 + 4);
      long long v45 = *(_OWORD *)(v44 + 9);
      long long v46 = *(_OWORD *)(v44 + 7);
      long long v60 = *(_OWORD *)(v44 + 5);
      long long v61 = v46;
      long long v62 = v45;
      long long v63 = v44[11];
      health::timestampToDate(*((double *)&v45 + 1), &__p);
      health::timestampToDate(*(double *)&v63, v53);
      health::timestampToDate(*(double *)&v62, &v52);
      *(void *)&long long v56 = &v61;
      *((void *)&v56 + 1) = &v52;
      *(void *)&long long v57 = v53;
      *((void *)&v57 + 1) = &__p;
      *(void *)&long long v58 = (char *)&v61 + 8;
      *((void *)&v58 + 1) = &v60;
      memset(&v51, 0, sizeof(v51));
      health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>((std::string *)"[ID: {0} | Count: {1} | {2} to {3} | Insertion Era: {4} | Frozen: {5}]", &v51, 0, (uint64_t *)&v56);
      uint64_t v47 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v70, a6);
      health::DataStoreInspector::_errorHandler(v47, 6, 0, 0, (std::string::size_type)&v51, (uint64_t)v70);
      std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v70);
      if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v51.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v52.__r_.__value_.__l.__data_);
      }
      if (v54 < 0) {
        operator delete(v53[0]);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      id v48 = (void *)v43[1];
      if (v48)
      {
        do
        {
          unsigned int v49 = (void **)v48;
          id v48 = (void *)*v48;
        }
        while (v48);
      }
      else
      {
        do
        {
          unsigned int v49 = (void **)v43[2];
          BOOL v14 = *v49 == v43;
          uint64_t v43 = v49;
        }
        while (!v14);
      }
      uint64_t v43 = v49;
    }
    while (v49 != v65);
  }
  std::__tree<long>::destroy(v65[0]);
  std::__tree<long>::destroy(v67[0]);
  std::__tree<long>::destroy(v69[0]);
}

void sub_1BCE1215C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,char a59)
{
}

void health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(std::string *a1, std::string *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5[0] = a5;
  v5[1] = a4;
  v5[2] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,long long &>(a2, a1, 0, v5);
}

void sub_1BCE122D0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::DataStoreInspector::_errorHandler(uint64_t a1, int a2, uint64_t a3, uint64_t a4, std::string::size_type a5, uint64_t a6)
{
  v22[0] = a3;
  v22[1] = a4;
  std::string::basic_string[abi:ne180100]<0>(&v21, "Unknown Error");
  uint64_t v11 = "Unable to Traverse History";
  std::string::size_type v12 = 26;
  switch(a2)
  {
    case 0:
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
      {
        v21.__r_.__value_.__l.__size_ = 15;
        BOOL v14 = (std::string *)v21.__r_.__value_.__r.__words[0];
        long long v13 = (std::string::value_type *)(v21.__r_.__value_.__r.__words[0] + 15);
      }
      else
      {
        long long v13 = &v21.__r_.__value_.__s.__data_[15];
        *((unsigned char *)&v21.__r_.__value_.__s + 23) = 15;
        BOOL v14 = &v21;
      }
      qmemcpy(v14, "File Corruption", 15);
      goto LABEL_18;
    case 1:
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
      {
        v21.__r_.__value_.__l.__size_ = 22;
        uint64_t v16 = (std::string *)v21.__r_.__value_.__r.__words[0];
        long long v13 = (std::string::value_type *)(v21.__r_.__value_.__r.__words[0] + 22);
      }
      else
      {
        long long v13 = &v21.__r_.__value_.__s.__data_[22];
        *((unsigned char *)&v21.__r_.__value_.__s + 23) = 22;
        uint64_t v16 = &v21;
      }
      qmemcpy(v16, "Unexpected Object Type", 22);
      goto LABEL_18;
    case 2:
      goto LABEL_11;
    case 3:
      uint64_t v11 = "Sample History Root Mismatch";
      std::string::size_type v12 = 28;
      goto LABEL_11;
    case 4:
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
      {
        v21.__r_.__value_.__l.__size_ = 19;
        uint64_t v15 = (std::string *)v21.__r_.__value_.__r.__words[0];
        long long v13 = (std::string::value_type *)(v21.__r_.__value_.__r.__words[0] + 19);
      }
      else
      {
        long long v13 = &v21.__r_.__value_.__s.__data_[19];
        *((unsigned char *)&v21.__r_.__value_.__s + 23) = 19;
        uint64_t v15 = &v21;
      }
      *(_DWORD *)((char *)&v15->__r_.__value_.__r.__words[1] + 7) = 1751348321;
      *(_OWORD *)&v15->__r_.__value_.__l.__data_ = *(_OWORD *)"SQLite Row Mismatch";
LABEL_18:
      *long long v13 = 0;
      break;
    case 5:
      uint64_t v11 = "Orphaned HFD Object (no reference in SQLite)";
      std::string::size_type v12 = 44;
      goto LABEL_11;
    case 6:
      uint64_t v11 = "Orphaned SQLite Row (no matching object in HFD)";
      std::string::size_type v12 = 47;
LABEL_11:
      std::string::__assign_external(&v21, v11, v12);
      break;
    default:
      break;
  }
  if (a3 | a4)
  {
    v23.__r_.__value_.__r.__words[0] = a5;
    v23.__r_.__value_.__l.__size_ = (std::string::size_type)v22;
    v23.__r_.__value_.__r.__words[2] = (std::string::size_type)&v21;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<std::string &,health::BlockPointer &,std::string const&>((std::string *)"{0}: [{1}] {2}", &__p, 0, (uint64_t *)&v23);
    uint64_t v19 = *(void *)(a6 + 24);
    if (!v19) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v19 + 48))(v19, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      unint64_t v18 = (void *)__p.__r_.__value_.__r.__words[0];
      goto LABEL_26;
    }
  }
  else
  {
    __p.__r_.__value_.__r.__words[0] = a5;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)&v21;
    memset(&v23, 0, sizeof(v23));
    health::FormatImplementation<std::string &,std::string const&>((std::string *)"{0}: {1}", &v23, 0, (uint64_t *)&__p);
    uint64_t v17 = *(void *)(a6 + 24);
    if (!v17) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v17 + 48))(v17, &v23);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    {
      unint64_t v18 = (void *)v23.__r_.__value_.__r.__words[0];
LABEL_26:
      operator delete(v18);
    }
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
}

void sub_1BCE12598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void health::timestampToDate(double a1@<D0>, void *a2@<X8>)
{
  if (a1 <= 0.0)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = objc_msgSend(MEMORY[0x1E4F1C9C8], "dateWithTimeIntervalSinceReferenceDate:");
  }
  id v6 = (id)v4;
  HKDiagnosticStringFromDate();
  id v5 = objc_claimAutoreleasedReturnValue();
  std::string::basic_string[abi:ne180100]<0>(a2, (char *)[v5 UTF8String]);
}

void sub_1BCE12688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void health::FormatString<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(std::string *a1, std::string *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5[0] = a5;
  v5[1] = a4;
  v5[2] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(a2, a1, 0, v5);
}

void sub_1BCE126F4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::doubleToString@<X0>(health *this@<X0>, void *a2@<X8>)
{
  int v3 = (int)this;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v6);
  *(void *)((char *)&v7[1] + *(void *)(v6 - 24)) = v3;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v7, a2);
  uint64_t v6 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v7[-1] + *(void *)(v6 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v7[0] = MEMORY[0x1E4FBA470] + 16;
  if (v8 < 0) {
    operator delete((void *)v7[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1C187B850](&v9);
}

void sub_1BCE12874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100](uint64_t a1, unint64_t a2)
{
  int v3 = std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>(*(uint64_t ***)a1, *(uint64_t **)(a1 + 8), a2, a2);
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = v3;
  uint64_t v4 = (uint64_t *)v3[1];
  if (v4)
  {
    do
    {
      id v5 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  else
  {
    do
    {
      id v5 = (uint64_t *)v3[2];
      BOOL v6 = *v5 == (void)v3;
      int v3 = v5;
    }
    while (!v6);
  }
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = v5;
  return a1;
}

uint64_t *std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t **a1, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  id v5 = a2;
  uint64_t v7 = a1 + 1;
  if (a1 + 1 != (uint64_t **)a2)
  {
    unint64_t v8 = a2[4];
    if (v8 <= a3)
    {
      if (v8 < a3)
      {
        long long v13 = (uint64_t **)(a2 + 1);
        std::string::size_type v12 = (uint64_t *)a2[1];
        if (v12)
        {
          do
          {
            long long v13 = (uint64_t **)v12;
            std::string::size_type v12 = (uint64_t *)*v12;
            id v5 = (uint64_t *)v13;
            BOOL v14 = v13;
          }
          while (v12);
        }
        else
        {
          BOOL v14 = (uint64_t **)a2;
          do
          {
            uint64_t v20 = v14;
            BOOL v14 = (uint64_t **)v14[2];
          }
          while (*v14 != (uint64_t *)v20);
        }
        if (v14 == v7) {
          goto LABEL_42;
        }
        if ((unint64_t)v14[4] > a3) {
          goto LABEL_42;
        }
        std::string v21 = *v7;
        long long v13 = a1 + 1;
        id v5 = (uint64_t *)(a1 + 1);
        if (!*v7) {
          goto LABEL_42;
        }
        while (1)
        {
          while (1)
          {
            id v5 = v21;
            unint64_t v22 = v21[4];
            if (v22 <= a3) {
              break;
            }
            std::string v21 = (uint64_t *)*v21;
            long long v13 = (uint64_t **)v5;
            if (!*v5) {
              goto LABEL_42;
            }
          }
          if (v22 >= a3) {
            break;
          }
          std::string v21 = (uint64_t *)v21[1];
          if (!v21)
          {
LABEL_30:
            long long v13 = (uint64_t **)(v5 + 1);
            goto LABEL_42;
          }
        }
      }
      return v5;
    }
  }
  uint64_t v9 = *a2;
  if (*a1 == a2)
  {
    uint64_t v11 = a2;
  }
  else
  {
    if (v9)
    {
      unint64_t v10 = (uint64_t *)*a2;
      do
      {
        uint64_t v11 = v10;
        unint64_t v10 = (uint64_t *)v10[1];
      }
      while (v10);
    }
    else
    {
      uint64_t v15 = a2;
      do
      {
        uint64_t v11 = (uint64_t *)v15[2];
        BOOL v16 = *v11 == (void)v15;
        uint64_t v15 = v11;
      }
      while (v16);
    }
    if (v11[4] >= a3)
    {
      unint64_t v18 = *v7;
      long long v13 = a1 + 1;
      id v5 = (uint64_t *)(a1 + 1);
      if (!*v7) {
        goto LABEL_42;
      }
      while (1)
      {
        while (1)
        {
          id v5 = v18;
          unint64_t v19 = v18[4];
          if (v19 <= a3) {
            break;
          }
          unint64_t v18 = (uint64_t *)*v18;
          long long v13 = (uint64_t **)v5;
          if (!*v5) {
            goto LABEL_42;
          }
        }
        if (v19 >= a3) {
          return v5;
        }
        unint64_t v18 = (uint64_t *)v18[1];
        if (!v18) {
          goto LABEL_30;
        }
      }
    }
  }
  if (v9) {
    uint64_t v17 = v11;
  }
  else {
    uint64_t v17 = a2;
  }
  if (v9) {
    long long v13 = (uint64_t **)(v11 + 1);
  }
  else {
    long long v13 = (uint64_t **)a2;
  }
  id v5 = *v13;
  if (!*v13)
  {
    id v5 = v17;
LABEL_42:
    std::string v23 = (uint64_t *)operator new(0x28uLL);
    v23[4] = a4;
    std::__tree<unsigned long long>::__insert_node_at(a1, (uint64_t)v5, v13, v23);
    return v23;
  }
  return v5;
}

uint64_t *std::__tree<unsigned long long>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  id v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t std::__set_difference[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long> &,std::insert_iterator<std::set<unsigned long long>> &>(uint64_t result, uint64_t a2, void *a3, uint64_t a4, void *a5, long long *a6)
{
  uint64_t v7 = result;
  unint64_t v8 = *(void **)a2;
  uint64_t v9 = (void *)*a3;
  if (*(void *)a2 == *a3)
  {
LABEL_38:
    long long v27 = *a6;
    uint64_t v9 = v8;
    goto LABEL_39;
  }
  for (uint64_t i = *(void **)a4; *(void *)a4 != *a5; uint64_t i = *(void **)a4)
  {
    unint64_t v15 = v8[4];
    unint64_t v16 = i[4];
    if (v15 >= v16)
    {
      if (v16 >= v15)
      {
        std::string v23 = (void *)v8[1];
        if (v23)
        {
          do
          {
            long long v24 = v23;
            std::string v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            long long v24 = (void *)v8[2];
            BOOL v20 = *v24 == (void)v8;
            unint64_t v8 = v24;
          }
          while (!v20);
        }
        *(void *)a2 = v24;
        std::string::size_type v25 = *(void **)a4;
        uint64_t v26 = *(void **)(*(void *)a4 + 8);
        if (v26)
        {
          do
          {
            unint64_t v22 = v26;
            uint64_t v26 = (void *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            unint64_t v22 = (void *)v25[2];
            BOOL v20 = *v22 == (void)v25;
            std::string::size_type v25 = v22;
          }
          while (!v20);
        }
      }
      else
      {
        std::string v21 = (void *)i[1];
        if (v21)
        {
          do
          {
            unint64_t v22 = v21;
            std::string v21 = (void *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            unint64_t v22 = (void *)i[2];
            BOOL v20 = *v22 == (void)i;
            uint64_t i = v22;
          }
          while (!v20);
        }
      }
      *(void *)a4 = v22;
    }
    else
    {
      uint64_t result = std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100]((uint64_t)a6, v15);
      uint64_t v17 = *(void **)a2;
      unint64_t v18 = *(void **)(*(void *)a2 + 8);
      if (v18)
      {
        do
        {
          unint64_t v19 = v18;
          unint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          unint64_t v19 = (void *)v17[2];
          BOOL v20 = *v19 == (void)v17;
          uint64_t v17 = v19;
        }
        while (!v20);
      }
      *(void *)a2 = v19;
    }
    unint64_t v8 = *(void **)a2;
    uint64_t v9 = (void *)*a3;
    if (*(void *)a2 == *a3) {
      goto LABEL_38;
    }
  }
  long long v27 = *a6;
  long long v30 = *a6;
  if (v8 != v9)
  {
    do
    {
      uint64_t result = std::insert_iterator<std::set<unsigned long long>>::operator=[abi:ne180100]((uint64_t)&v30, v8[4]);
      long long v28 = (void *)v8[1];
      if (v28)
      {
        do
        {
          unint64_t v29 = v28;
          long long v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          unint64_t v29 = (void *)v8[2];
          BOOL v20 = *v29 == (void)v8;
          unint64_t v8 = v29;
        }
        while (!v20);
      }
      unint64_t v8 = v29;
    }
    while (v29 != v9);
    long long v27 = v30;
  }
LABEL_39:
  *(void *)uint64_t v7 = v9;
  *(_OWORD *)(v7 + _Block_object_dispose(&a9, 8) = v27;
  return result;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v7 = 22;
LABEL_5:
    std::string::__grow_by_and_replace(this, v7, __n - v7, size, 0, size, __n, __s);
    return this;
  }
  std::string::size_type v7 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v7 < __n)
  {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
    goto LABEL_5;
  }
  std::string::size_type v9 = this->__r_.__value_.__r.__words[0];
  memmove(this->__r_.__value_.__l.__data_, __s, __n);
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
    this->__r_.__value_.__l.__size_ = __n;
  }
  else {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  }
  *(unsigned char *)(v9 + __n) = 0;
  return this;
}

uint64_t std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::~__func()
{
}

__n128 std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F171E5D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171E5D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3, std::string::size_type a4)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  uint64_t v7 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v9, *(void *)(a1 + 16));
  health::DataStoreInspector::_errorHandler(v7, 0, v5, v6, a4, (uint64_t)v9);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v9);
  return 1;
}

void sub_1BCE12FF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_0>,BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::target_type()
{
}

void *std::__function::__value_func<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v8 = 0;
  uint64_t v6 = operator new(0x20uLL);
  *uint64_t v6 = &unk_1F171E660;
  v6[1] = a2;
  void v6[2] = a3;
  uint64_t v6[3] = &v8;
  v9[3] = v6;
  health::DataStore::performReadTransactionWithLambda(a1, (uint64_t)v9);
  std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100](v9);
  return v8;
}

void sub_1BCE1318C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void health::FormatString<health::DataStore::ObjectIdentifier &>(std::string *a1, std::string *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<health::DataStore::ObjectIdentifier &>(a2, a1, 0, &v3);
}

void sub_1BCE131E8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatString<long long &>(std::string *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<long long &>((std::string *)"\nTotal # of samples = {0}", a1, 0, &v2);
}

void sub_1BCE13250(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::~__func()
{
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F171E660;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171E660;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(a1 + 8, a2);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target_type()
{
}

uint64_t std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(uint64_t a1, uint64_t a2)
{
  memset(&v5[16], 0, 32);
  memset(&v5[56], 0, 32);
  uint64_t v6 = a2;
  uint64_t result = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)a1);
  if (result)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 24);
    if (!v4) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v4 + 48))(v4, v5);
    **(unsigned char **)(a1 + 16) = 1;
  }
  return result;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::~__func()
{
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1F171E6E0;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171E6E0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a2[4];
  uint64_t v5 = a2[5];
  uint64_t v6 = a2[6];
  uint64_t v23 = v6;
  if (v6 < 1)
  {
    int v7 = **(_DWORD **)(a1 + 16);
    if (v6) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = v7 == 1;
    }
    if (v8)
    {
      health::FormatString<health::DataStore::ObjectIdentifier &>(&v26, (std::string *)"HFD sample history root [ID: {0}] reports an empty sample count.", *(void *)(a1 + 24));
      uint64_t v14 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v28, *(void *)(a1 + 40));
      health::DataStoreInspector::_errorHandler(v14, 2, v4, v5, (std::string::size_type)&v26, (uint64_t)v28);
      std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v28);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
      {
        long long v13 = (void *)v26.__r_.__value_.__r.__words[0];
        goto LABEL_23;
      }
      goto LABEL_24;
    }
  }
  else
  {
    *(double *)(*(void *)(a1 + 8) + 40) = health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::firstSampleKey(a2);
    *(double *)(*(void *)(a1 + 8) + 4_Block_object_dispose(&a9, 8) = health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::lastSampleKey(a2);
    int v7 = **(_DWORD **)(a1 + 16);
  }
  if (v7 == 2)
  {
    if (!**(unsigned char **)(a1 + 48)) {
      goto LABEL_24;
    }
    uint64_t v11 = *(void *)(a1 + 40);
    std::string::basic_string[abi:ne180100]<0>(v28, "object_id \t sample_number \t timestamp \t data");
    uint64_t v12 = *(void *)(v11 + 24);
    if (!v12) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, void *))(*(void *)v12 + 48))(v12, v28);
  }
  else
  {
    if (v7) {
      goto LABEL_24;
    }
    _HDSampleHistoryDescriptionForObjectType(**(void **)(a1 + 24), v28);
    health::timestampToDate(*(double *)(*(void *)(a1 + 8) + 40), &v26);
    health::timestampToDate(*(double *)(*(void *)(a1 + 8) + 48), v24);
    uint64_t v9 = *(void *)(a1 + 40);
    health::FormatString<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(&__p, (uint64_t)v28, *(void *)(a1 + 24), (uint64_t)&v23, (uint64_t)&v26, (uint64_t)v24);
    uint64_t v10 = *(void *)(v9 + 24);
    if (!v10) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v10 + 48))(v10, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v25 < 0) {
      operator delete(v24[0]);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
  }
  if (v29 < 0)
  {
    long long v13 = (void *)v28[0];
LABEL_23:
    operator delete(v13);
  }
LABEL_24:
  uint64_t v15 = *(void *)(a1 + 56);
  uint64_t v16 = *(void *)(a1 + 40);
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  unint64_t v19 = operator new(0x28uLL);
  void *v19 = &unk_1F171E760;
  v19[1] = v15;
  void v19[2] = v18;
  v19[3] = v16;
  void v19[4] = v17;
  long long v27 = v19;
  health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(a2, (uint64_t)&v26);
  std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>::~__value_func[abi:ne180100](&v26);
  BOOL v20 = *(void **)(a1 + 56);
  *(void *)(*(void *)(a1 + 8) + 24) = *v20;
  if (**(_DWORD **)(a1 + 16) == 1 && *v20 != v23)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(&__p, (std::string *)"HFD sample history [ID: {0}] has an actual sample count ({1}) that does not match its reported count ({2}).", *(void *)(a1 + 24), (uint64_t)v20, (uint64_t)&v23);
    uint64_t v21 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v24, *(void *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v21, 3, v4, v5, (std::string::size_type)&__p, (uint64_t)v24);
    std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1BCE137D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::target_type()
{
}

double health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::firstSampleKey(void *a1)
{
  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_6;
  }
  uint64_t v1 = *(uint64_t **)(a1[11] + 24);
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[3];
  memset(v6, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v2, v3, (uint64_t)v6);
  if (!WORD4(v6[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_6:
    __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
  }
  return *(double *)v6;
}

void sub_1BCE139D8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::lastSampleKey(void *a1)
{
  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_11;
  }
  uint64_t v1 = *(uint64_t **)(a1[11] + 24);
  v11[0] = 0;
  v11[1] = 0;
  uint64_t v12 = v1;
  uint64_t v2 = a1[3];
  v9[0] = a1[2];
  v9[1] = v2;
  uint64_t v10 = v11;
  memset(__dst, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v9[0], v2, (uint64_t)__dst);
  unsigned int v3 = __dst[204];
  if (!__dst[204])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
    goto LABEL_11;
  }
  if (!LOBYTE(__dst[205]))
  {
    int v5 = 0;
    while (__dst[204])
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)v9, v5, (uint64_t)__dst, (unsigned __int16)(__dst[204] - 1), (uint64_t)__src);
      memcpy(__dst, __src, 0x19BuLL);
      ++v5;
      if (LOBYTE(__dst[205]))
      {
        unsigned int v3 = __dst[204];
        uint64_t v4 = (uint64_t **)(v10 + 2);
        goto LABEL_9;
      }
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_11:
    __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
  }
  uint64_t v4 = &v12;
LABEL_9:
  uint64_t v6 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)__dst, v3 - 1);
  bzero(__src, 0x332uLL);
  long long v15 = 0u;
  long long v16 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*v4, *(void *)(v6 + 8), *(void *)(v6 + 16), (uint64_t)__src);
  return *(double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)__src, v14 - 1);
}

void sub_1BCE13BC0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatString<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(std::string *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v6[0] = a6;
  v6[1] = a5;
  void v6[2] = a4;
  uint64_t v6[3] = a3;
  void v6[4] = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>((std::string *)"'{0}' [ID: {1} | Count: {2} | {3} to {4}]\n", a1, 0, v6);
}

void sub_1BCE13C30(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(void *result, uint64_t a2)
{
  void v6[4] = *MEMORY[0x1E4F143B8];
  if (result[6])
  {
    uint64_t v2 = *(void *)(result[11] + 24);
    v5[0] = 0;
    v5[1] = 0;
    v5[2] = v2;
    long long v3 = *((_OWORD *)result + 1);
    uint64_t v4 = v5;
    std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>((uint64_t *)&v3, (uint64_t)v6, 0);
    return std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>::~__value_func[abi:ne180100](v6);
  }
  return result;
}

void sub_1BCE13CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    uint64_t v33 = i;
    if (*i != 123) {
      break;
    }
    int v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)v29, (const char **)&v33);
        uint64_t v12 = v33;
        switch(v30)
        {
          case 0:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[4], (uint64_t)v29);
            unint64_t v13 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v13 = v35;
            }
            unint64_t v14 = v32;
            if (v32 <= v13) {
              unint64_t v14 = v13;
            }
            if (v31) {
              unint64_t v13 = v14;
            }
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v15 = (char *)a2;
            }
            else {
              long long v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_59;
          case 1:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v29);
            unint64_t v16 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v16 = v35;
            }
            unint64_t v17 = v32;
            if (v32 <= v16) {
              unint64_t v17 = v16;
            }
            if (v31) {
              unint64_t v16 = v17;
            }
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v16 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v15 = (char *)a2;
            }
            else {
              long long v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_59;
          case 2:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v29);
            unint64_t v18 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v18 = v35;
            }
            unint64_t v19 = v32;
            if (v32 <= v18) {
              unint64_t v19 = v18;
            }
            if (v31) {
              unint64_t v18 = v19;
            }
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v15 = (char *)a2;
            }
            else {
              long long v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_59;
          case 3:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v29);
            unint64_t v20 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v20 = v35;
            }
            unint64_t v21 = v32;
            if (v32 <= v20) {
              unint64_t v21 = v20;
            }
            if (v31) {
              unint64_t v20 = v21;
            }
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v15 = (char *)a2;
            }
            else {
              long long v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_59;
          case 4:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v29);
            unint64_t v22 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v22 = v35;
            }
            unint64_t v23 = v32;
            if (v32 <= v22) {
              unint64_t v23 = v22;
            }
            if (v31) {
              unint64_t v22 = v23;
            }
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v22 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v15 = (char *)a2;
            }
            else {
              long long v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
LABEL_59:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v29, &v15[a3 + v8], (const void **)&__p);
            if ((char)v36 < 0) {
              operator delete(__p);
            }
            if (v8) {
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            }
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_71;
        }
      }
      uint64_t v33 = i + 2;
      int v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        uint64_t v25 = 0;
        std::string v26 = i + 3;
        do
        {
          uint64_t v33 = v26;
          uint64_t v25 = (v24 - 48) + 10 * v25;
          int v27 = *v26++;
          int v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        uint64_t v33 = v26;
        if (*(v26 - 1) == 125) {
          health::FormatterParameters<0ul,std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>::formatOptionsAtIndex<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v25);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_71:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    uint64_t v33 = i + 1;
    char v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
  {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE14174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>::formatOptionsAtIndex<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(uint64_t a1)
{
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
      break;
    default:
      long long v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      exception = v3;
      if (a1 == 4) {
        std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
      }
      else {
        std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
      }
      break;
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE142E4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  uint64_t v5 = v12;
  if (*(unsigned char *)(a3 + 16)) {
    *(void *)((char *)&v13[2] + *(void *)(v12 - 24)) = *(void *)(a3 + 24);
  }
  if (*(unsigned char *)(a3 + 32)) {
    *(void *)((char *)&v13[1] + *(void *)(v5 - 24)) = *(void *)(a3 + 40);
  }
  uint64_t v6 = (const std::ios_base *)((char *)&v13[-1] + *(void *)(v5 - 24));
  std::ios_base::fmtflags v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    std::string::size_type v8 = std::locale::use_facet(v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  health::operator<<(&v12);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(void *)(a1 + 16) = v11;
  uint64_t v12 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v13[-1] + *(void *)(v12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v13[0] = MEMORY[0x1E4FBA470] + 16;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v15);
  return a1;
}

void sub_1BCE14564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0) {
    operator delete(*(void **)v13);
  }
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<std::string &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v16);
  uint64_t v6 = v16;
  if (*(unsigned char *)(a3 + 16)) {
    *(void *)((char *)&v17[2] + *(void *)(v16 - 24)) = *(void *)(a3 + 24);
  }
  if (*(unsigned char *)(a3 + 32)) {
    *(void *)((char *)&v17[1] + *(void *)(v6 - 24)) = *(void *)(a3 + 40);
  }
  std::ios_base::fmtflags v7 = (const std::ios_base *)((char *)&v17[-1] + *(void *)(v6 - 24));
  std::ios_base::fmtflags v8 = *(char *)(a3 + 52);
  if (v7[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v7);
    char v9 = std::locale::use_facet(v14, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 32);
    std::locale::~locale(v14);
  }
  v7[1].__fmtflags_ = v8;
  int v10 = *(char *)(a2 + 23);
  if (v10 >= 0) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = *(void *)a2;
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v12 = *(void *)(a2 + 8);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v16, v11, v12);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v17, v14);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = *(_OWORD *)&v14[0].__locale_;
  *(void *)(a1 + 16) = v15;
  uint64_t v16 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v17[-1] + *(void *)(v16 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v17[0] = MEMORY[0x1E4FBA470] + 16;
  if (v18 < 0) {
    operator delete((void *)v17[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v19);
  return a1;
}

void sub_1BCE14800(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0) {
    operator delete(*(void **)v13);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[2];
  memset(v8, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 16), *a1, a1[1], (uint64_t)v8);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>((uint64_t)a1, 0, (uint64_t)v8, a2, a3);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_WORD *)(a3 + 408))
  {
    uint64_t v7 = result;
    unsigned __int16 v8 = *(_WORD *)(a3 + 408) - 1;
    if (!a5) {
      unsigned __int16 v8 = 0;
    }
    if (*(unsigned char *)(a3 + 410))
    {
      uint64_t v9 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v8);
      uint64_t v10 = *(void *)(v9 + 8);
      uint64_t v11 = *(void *)(v9 + 16);
      uint64_t v12 = *(void *)(v7 + 16);
      bzero(v14, 0x332uLL);
      *(_OWORD *)&v14[824] = 0u;
      long long v15 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v12 + 16), v10, v11, (uint64_t)v14);
      uint64_t v16 = a4;
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17> const&,health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(v7, (uint64_t)v14, (uint64_t)&v16, a5);
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex(result, a2, a3, v8, (uint64_t)v14);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(v7, (a2 + 1), v14, a4, a5);
    }
  }
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV1>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17> const&,health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawLocationDatumV1 const&)#1}>(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v43 = result;
  if (a4 == 1)
  {
    if (*(_WORD *)(a2 + 816))
    {
      unint64_t v14 = *(unsigned __int16 *)(a2 + 816) - 1;
      unint64_t v15 = 1;
      double v16 = 0.0;
      while (1)
      {
        unint64_t v17 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        uint64_t v18 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        if (v15 >= 2)
        {
          v19.n128_u64[0] = *v17;
          if (*(double *)v17 >= v16)
          {
            unint64_t v20 = (void *)*MEMORY[0x1E4F29F18];
            std::string::basic_string[abi:ne180100]<0>(v55, "key < lastKey");
            std::string::basic_string[abi:ne180100]<0>(v54, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v53, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &__p);
            health::_HDAssertImplementation<health::btree_access_error>(v20, (uint64_t)v55, (uint64_t)v54, (uint64_t)v53, 412, (uint64_t)&__p);
          }
        }
        uint64_t v21 = *(void *)(*(void *)a3 + 24);
        if (!v21) {
          break;
        }
        double v16 = *(double *)v17;
        __n128 result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(void *)v21 + 48))(v21, v17, v18 + 8, v19);
        if ((result & 1) == 0) {
          return result;
        }
        ++v15;
        if (--v14 == -1) {
          goto LABEL_35;
        }
      }
LABEL_48:
      std::__throw_bad_function_call[abi:ne180100]();
    }
    double v16 = 0.0;
LABEL_35:
    uint64_t v32 = *(void *)(a2 + 824);
    uint64_t v33 = (void **)MEMORY[0x1E4F29F18];
    uint64_t v34 = *(void *)(a2 + 832);
    while (1)
    {
      uint64_t v35 = *(void *)(v43 + 16);
      if (v32 == *(void *)v35 && v34 == *(void *)(v35 + 8)) {
        break;
      }
      bzero(v64, 0x332uLL);
      long long v66 = 0u;
      long long v67 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v35 + 16), v32, v34, (uint64_t)v64);
      if (!v65)
      {
        unsigned __int8 v36 = *v33;
        std::string::basic_string[abi:ne180100]<0>(v51, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v50, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v48);
        health::_HDAssertImplementation<health::btree_access_error>(v36, (uint64_t)v51, (uint64_t)v50, (uint64_t)v49, 422, (uint64_t)&v48);
      }
      unint64_t v37 = v65 - 1;
      do
      {
        long long v38 = (double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, v37);
        uint64_t v39 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, v37);
        if (*v38 >= v16)
        {
          double v41 = *v33;
          std::string::basic_string[abi:ne180100]<0>(v47, "key < lastKey");
          std::string::basic_string[abi:ne180100]<0>(v46, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v45, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v44);
          health::_HDAssertImplementation<health::btree_access_error>(v41, (uint64_t)v47, (uint64_t)v46, (uint64_t)v45, 427, (uint64_t)&v44);
        }
        uint64_t v42 = *(void *)(*(void *)a3 + 24);
        if (!v42) {
          goto LABEL_48;
        }
        double v16 = *v38;
        v40.n128_f64[0] = *v38;
        __n128 result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(void *)v42 + 48))(v42, v38, v39 + 8, v40);
        if ((result & 1) == 0) {
          return result;
        }
        --v37;
      }
      while (v37 != -1);
      uint64_t v34 = *((void *)&v66 + 1);
      uint64_t v32 = v66;
    }
  }
  else if (!a4)
  {
    uint64_t v6 = (void **)MEMORY[0x1E4F29F18];
    if (*(_WORD *)(a2 + 816))
    {
      unint64_t v7 = 0;
      double v8 = 0.0;
      while (1)
      {
        uint64_t v9 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        uint64_t v10 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        if (v7)
        {
          v11.n128_u64[0] = *v9;
          if (*(double *)v9 <= v8)
          {
            uint64_t v12 = *v6;
            std::string::basic_string[abi:ne180100]<0>(v71, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v70, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v69, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v68);
            health::_HDAssertImplementation<health::btree_access_error>(v12, (uint64_t)v71, (uint64_t)v70, (uint64_t)v69, 382, (uint64_t)&v68);
          }
        }
        uint64_t v13 = *(void *)(*(void *)a3 + 24);
        if (!v13) {
          goto LABEL_48;
        }
        double v8 = *(double *)v9;
        __n128 result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(void *)v13 + 48))(v13, v9, v10 + 8, v11);
        if ((result & 1) == 0) {
          return result;
        }
        if (++v7 >= *(unsigned __int16 *)(a2 + 816)) {
          goto LABEL_22;
        }
      }
    }
    double v8 = 0.0;
LABEL_22:
    uint64_t v22 = *(void *)(a2 + 840);
    uint64_t v23 = *(void *)(a2 + 848);
    while (1)
    {
      uint64_t v24 = *(void *)(v43 + 16);
      if (v22 == *(void *)v24 && v23 == *(void *)(v24 + 8)) {
        break;
      }
      bzero(v64, 0x332uLL);
      long long v66 = 0u;
      long long v67 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>>(*(uint64_t **)(v24 + 16), v22, v23, (uint64_t)v64);
      if (!v65)
      {
        uint64_t v25 = *v6;
        std::string::basic_string[abi:ne180100]<0>(v63, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v62, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v61, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v60);
        health::_HDAssertImplementation<health::btree_access_error>(v25, (uint64_t)v63, (uint64_t)v62, (uint64_t)v61, 392, (uint64_t)&v60);
      }
      for (unint64_t i = 0; i < v65; ++i)
      {
        int v27 = (double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, i);
        uint64_t v28 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV1,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, i);
        if (*v27 <= v8)
        {
          uint64_t v30 = *v6;
          std::string::basic_string[abi:ne180100]<0>(v59, "key > lastKey");
          std::string::basic_string[abi:ne180100]<0>(v58, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v57, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v56);
          health::_HDAssertImplementation<health::btree_access_error>(v30, (uint64_t)v59, (uint64_t)v58, (uint64_t)v57, 396, (uint64_t)&v56);
        }
        uint64_t v31 = *(void *)(*(void *)a3 + 24);
        if (!v31) {
          goto LABEL_48;
        }
        double v8 = *v27;
        v29.n128_f64[0] = *v27;
        __n128 result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(void *)v31 + 48))(v31, v27, v28 + 8, v29);
        if ((result & 1) == 0) {
          return result;
        }
      }
      uint64_t v23 = *((void *)&v67 + 1);
      uint64_t v22 = v67;
    }
  }
  return result;
}

void sub_1BCE15170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a46 < 0) {
    operator delete(a41);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EE7__cloneEv(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F171E760;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EE7__cloneEPNS0_6__baseIS11_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171E760;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EEclESX_S10_(uint64_t a1, double *a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a3 + 16);
  v12[0] = *(_OWORD *)a3;
  v12[1] = v3;
  uint64_t v13 = *(void *)(a3 + 32);
  double v4 = *a2;
  uint64_t v5 = *(void **)(a1 + 8);
  ++*v5;
  int v6 = **(_DWORD **)(a1 + 16);
  if (v6 == 2)
  {
    uint64_t v9 = *(void *)(a1 + 24);
    uint64_t v10 = *(void *)(a1 + 32);
    health::doubleToString((health *)9, v14);
    unint64_t v17 = v12;
    uint64_t v18 = v14;
    __n128 v19 = v5;
    uint64_t v20 = v10;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>((std::string *)"{0} \t Sample #{1} \t {2} \t {3}", &__p, 0, (uint64_t *)&v17);
    uint64_t v8 = *(void *)(v9 + 24);
    if (!v8) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  else
  {
    if (v6) {
      return 1;
    }
    uint64_t v7 = *(void *)(a1 + 24);
    health::timestampToDate(v4, v14);
    unint64_t v17 = v12;
    uint64_t v18 = v14;
    __n128 v19 = v5;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV1 &>((std::string *)"Sample #{0} | Timestamp: {1} | Data: {2}", &__p, 0, (uint64_t *)&v17);
    uint64_t v8 = *(void *)(v7 + 24);
    if (!v8) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v8 + 48))(v8, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v15 < 0) {
    operator delete(v14[0]);
  }
  return 1;
}

void sub_1BCE15658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV1EE11target_typeEv()
{
  return &_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV1EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_;
}

void health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV1 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    uint64_t v31 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    uint64_t v31 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    uint64_t v31 = i + 2;
    int v22 = i[2];
    if ((v22 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v23 = 0;
      uint64_t v24 = i + 3;
      do
      {
        uint64_t v31 = v24;
        uint64_t v23 = (v22 - 48) + 10 * v23;
        int v25 = *v24++;
        int v22 = v25;
      }
      while ((v25 - 58) >= 0xFFFFFFF6);
      uint64_t v31 = v24;
      if (*(v24 - 1) == 125) {
        health::FormatterParameters<0ul,long long &,std::string,_HDRawLocationDatumV1 &>::formatOptionsAtIndex<long long &,std::string,_HDRawLocationDatumV1 &>(v23);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_58;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v27, (const char **)&v31);
  uint64_t v12 = v31;
  if (!*((void *)&v27 + 1))
  {
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v27);
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    std::string::size_type v17 = *((void *)&v28 + 1);
    if (*((void *)&v28 + 1) <= size) {
      std::string::size_type v17 = size;
    }
    if ((_BYTE)v28) {
      std::string::size_type size = v17;
    }
    health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV1 &>(v12, a2, size + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v15 = (char *)a2;
    }
    else {
      char v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
LABEL_34:
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v27, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (!v8) {
      return;
    }
LABEL_37:
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
    return;
  }
  if (*((void *)&v27 + 1) != 1)
  {
    if (*((void *)&v27 + 1) == 2)
    {
      health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(&__p, *a4, *a4 + 8, *a4 + 16, *a4 + 20, *a4 + 24, *a4 + 28, *a4 + 32);
      std::string::size_type v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v13 = __p.__r_.__value_.__l.__size_;
      }
      std::string::size_type v14 = *((void *)&v28 + 1);
      if (*((void *)&v28 + 1) <= v13) {
        std::string::size_type v14 = v13;
      }
      if ((_BYTE)v28) {
        std::string::size_type v13 = v14;
      }
      health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV1 &>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        char v15 = (char *)a2;
      }
      else {
        char v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_34;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_58:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  std::string::size_type v18 = a4[1];
  __p.__r_.__value_.__r.__words[0] = v18;
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v27;
  long long v33 = v28;
  long long v34 = v29;
  uint64_t v35 = v30;
  if (*(char *)(v18 + 23) < 0) {
    unint64_t v19 = *(void *)(v18 + 8);
  }
  else {
    unint64_t v19 = *(unsigned __int8 *)(v18 + 23);
  }
  unint64_t v20 = *((void *)&v28 + 1);
  if (*((void *)&v28 + 1) <= v19) {
    unint64_t v20 = v19;
  }
  if ((_BYTE)v28) {
    unint64_t v19 = v20;
  }
  health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV1 &>(v31, a2, v19 + a3 + v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v21 = (char *)a2;
  }
  else {
    uint64_t v21 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v27, &v21[a3 + v8], (uint64_t)&__p);
  if (v8) {
    goto LABEL_37;
  }
}

void sub_1BCE15A78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,std::string,_HDRawLocationDatumV1 &>::formatOptionsAtIndex<long long &,std::string,_HDRawLocationDatumV1 &>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE15B60(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(std::string *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v8[0] = a8;
  v8[1] = a7;
  void v8[2] = a6;
  void v8[3] = a5;
  v8[4] = a4;
  void v8[5] = a3;
  v8[6] = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&>((std::string *)"(Lat: {0}, Lon: {1}, Alt: {2}, Speed: {3}, Course: {4}, HAcc: {5}, VAcc: {6})", a1, 0, v8);
}

void sub_1BCE15BD8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    long long v33 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v33 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v33 = i + 2;
    int v24 = i[2];
    if ((v24 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v25 = 0;
      std::string v26 = i + 3;
      do
      {
        long long v33 = v26;
        uint64_t v25 = (v24 - 48) + 10 * v25;
        int v27 = *v26++;
        int v24 = v27;
      }
      while ((v27 - 58) >= 0xFFFFFFF6);
      long long v33 = v26;
      if (*(v26 - 1) == 125) {
        health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&>::formatOptionsAtIndex<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(v25);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v29, (const char **)&v33);
  uint64_t v12 = v33;
  switch(v30)
  {
    case 0:
      health::TypeFormatter<double const&,void>::TypeFormatter((uint64_t)&__p, a4[6], (uint64_t)v29);
      unint64_t v13 = v36;
      if ((v36 & 0x80u) != 0) {
        unint64_t v13 = v35;
      }
      unint64_t v14 = v32;
      if (v32 <= v13) {
        unint64_t v14 = v13;
      }
      if (v31) {
        unint64_t v13 = v14;
      }
      goto LABEL_27;
    case 1:
      health::TypeFormatter<double const&,void>::TypeFormatter((uint64_t)&__p, a4[5], (uint64_t)v29);
      unint64_t v13 = v36;
      if ((v36 & 0x80u) != 0) {
        unint64_t v13 = v35;
      }
      unint64_t v15 = v32;
      if (v32 <= v13) {
        unint64_t v15 = v13;
      }
      if (v31) {
        unint64_t v13 = v15;
      }
LABEL_27:
      std::string::size_type v16 = a3 + v8;
      health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v17 = (char *)a2;
      }
      else {
        std::string::size_type v17 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_67;
    case 2:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, a4[4], (uint64_t)v29);
      unint64_t v18 = v36;
      if ((v36 & 0x80u) != 0) {
        unint64_t v18 = v35;
      }
      unint64_t v19 = v32;
      if (v32 <= v18) {
        unint64_t v19 = v18;
      }
      if (v31) {
        unint64_t v18 = v19;
      }
      goto LABEL_64;
    case 3:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v29);
      unint64_t v18 = v36;
      if ((v36 & 0x80u) != 0) {
        unint64_t v18 = v35;
      }
      unint64_t v20 = v32;
      if (v32 <= v18) {
        unint64_t v20 = v18;
      }
      if (v31) {
        unint64_t v18 = v20;
      }
      goto LABEL_64;
    case 4:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v29);
      unint64_t v18 = v36;
      if ((v36 & 0x80u) != 0) {
        unint64_t v18 = v35;
      }
      unint64_t v21 = v32;
      if (v32 <= v18) {
        unint64_t v21 = v18;
      }
      if (v31) {
        unint64_t v18 = v21;
      }
      goto LABEL_64;
    case 5:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v29);
      unint64_t v18 = v36;
      if ((v36 & 0x80u) != 0) {
        unint64_t v18 = v35;
      }
      unint64_t v22 = v32;
      if (v32 <= v18) {
        unint64_t v22 = v18;
      }
      if (v31) {
        unint64_t v18 = v22;
      }
      goto LABEL_64;
    case 6:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v29);
      unint64_t v18 = v36;
      if ((v36 & 0x80u) != 0) {
        unint64_t v18 = v35;
      }
      unint64_t v23 = v32;
      if (v32 <= v18) {
        unint64_t v23 = v18;
      }
      if (v31) {
        unint64_t v18 = v23;
      }
LABEL_64:
      std::string::size_type v16 = a3 + v8;
      health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(v12, a2, v18 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v17 = (char *)a2;
      }
      else {
        std::string::size_type v17 = (char *)a2->__r_.__value_.__r.__words[0];
      }
LABEL_67:
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v29, &v17[v16], (const void **)&__p);
      if ((char)v36 < 0) {
        operator delete(__p);
      }
      if (v8) {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      break;
    default:
      health::FormatterParameters<7ul>::formatParameterAtIndex<health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&>>();
  }
}

void sub_1BCE160A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&>::formatOptionsAtIndex<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(uint64_t a1)
{
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
      break;
    default:
      long long v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      exception = v3;
      if (a1 == 6) {
        std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
      }
      else {
        std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
      }
      break;
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE16244(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<7ul>::formatParameterAtIndex<health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&>>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE162D4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<float const&,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  uint64_t v5 = v12;
  if (*(unsigned char *)(a3 + 16)) {
    *(void *)((char *)&v13[2] + *(void *)(v12 - 24)) = *(void *)(a3 + 24);
  }
  if (*(unsigned char *)(a3 + 32)) {
    *(void *)((char *)&v13[1] + *(void *)(v5 - 24)) = *(void *)(a3 + 40);
  }
  int v6 = (const std::ios_base *)((char *)&v13[-1] + *(void *)(v5 - 24));
  std::ios_base::fmtflags v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    std::string::size_type v8 = std::locale::use_facet(v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(void *)(a1 + 16) = v11;
  uint64_t v12 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v13[-1] + *(void *)(v12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v13[0] = MEMORY[0x1E4FBA470] + 16;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v15);
  return a1;
}

void sub_1BCE16530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0) {
    operator delete(*(void **)v13);
  }
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<double const&,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  uint64_t v5 = v12;
  if (*(unsigned char *)(a3 + 16)) {
    *(void *)((char *)&v13[2] + *(void *)(v12 - 24)) = *(void *)(a3 + 24);
  }
  if (*(unsigned char *)(a3 + 32)) {
    *(void *)((char *)&v13[1] + *(void *)(v5 - 24)) = *(void *)(a3 + 40);
  }
  int v6 = (const std::ios_base *)((char *)&v13[-1] + *(void *)(v5 - 24));
  std::ios_base::fmtflags v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    std::string::size_type v8 = std::locale::use_facet(v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(void *)(a1 + 16) = v11;
  uint64_t v12 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v13[-1] + *(void *)(v12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v13[0] = MEMORY[0x1E4FBA470] + 16;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v15);
  return a1;
}

void sub_1BCE167B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0) {
    operator delete(*(void **)v13);
  }
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    long long v33 = i;
    if (*i != 123) {
      break;
    }
    int v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)&v29, (const char **)&v33);
        uint64_t v12 = v33;
        switch(*((void *)&v29 + 1))
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)&v29);
            std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type size = __p.__r_.__value_.__l.__size_;
            }
            std::string::size_type v14 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= size) {
              std::string::size_type v14 = size;
            }
            if ((_BYTE)v30) {
              std::string::size_type size = v14;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(v12, a2, size + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_43;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v29);
            std::string::size_type v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
            }
            std::string::size_type v19 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v18) {
              std::string::size_type v19 = v18;
            }
            if ((_BYTE)v30) {
              std::string::size_type v18 = v19;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_43;
          case 2:
            std::string::size_type v16 = a4[1];
            __p.__r_.__value_.__r.__words[0] = v16;
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v29;
            long long v35 = v30;
            long long v36 = v31;
            uint64_t v37 = v32;
            if (*(char *)(v16 + 23) < 0) {
              unint64_t v17 = *(void *)(v16 + 8);
            }
            else {
              unint64_t v17 = *(unsigned __int8 *)(v16 + 23);
            }
            unint64_t v22 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v17) {
              unint64_t v22 = v17;
            }
            if ((_BYTE)v30) {
              unint64_t v17 = v22;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(v33, a2, v17 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v23 = (char *)a2;
            }
            else {
              unint64_t v23 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v29, &v23[a3 + v8], (uint64_t)&__p);
            if (!v8) {
              return;
            }
            goto LABEL_46;
          case 3:
            health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&>(&__p, *a4, *a4 + 8, *a4 + 16, *a4 + 20, *a4 + 24, *a4 + 28, *a4 + 32);
            std::string::size_type v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v20 = __p.__r_.__value_.__l.__size_;
            }
            std::string::size_type v21 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v20) {
              std::string::size_type v21 = v20;
            }
            if ((_BYTE)v30) {
              std::string::size_type v20 = v21;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
LABEL_43:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v29, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            if (v8) {
LABEL_46:
            }
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_65;
        }
      }
      long long v33 = i + 2;
      int v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        uint64_t v25 = 0;
        std::string v26 = i + 3;
        do
        {
          long long v33 = v26;
          uint64_t v25 = (v24 - 48) + 10 * v25;
          int v27 = *v26++;
          int v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        long long v33 = v26;
        if (*(v26 - 1) == 125) {
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(v25);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_65:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    long long v33 = i + 1;
    char v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
  {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE16C20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV1 &>(uint64_t a1)
{
  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    long long v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3) {
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
    }
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE16D3C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV1 const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    uint64_t v25 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    uint64_t v25 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    uint64_t v25 = i + 2;
    int v16 = i[2];
    if ((v16 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v17 = 0;
      std::string::size_type v18 = i + 3;
      do
      {
        uint64_t v25 = v18;
        uint64_t v17 = (v16 - 48) + 10 * v17;
        int v19 = *v18++;
        int v16 = v19;
      }
      while ((v19 - 58) >= 0xFFFFFFF6);
      uint64_t v25 = v18;
      if (*(v18 - 1) == 125) {
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &>(v17);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_35:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v21, (const char **)&v25);
  if (v22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    goto LABEL_35;
  }
  uint64_t v12 = v25;
  health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)__p, *a4, (uint64_t)v21);
  unint64_t v13 = v27;
  if ((v27 & 0x80u) != 0) {
    unint64_t v13 = (unint64_t)__p[1];
  }
  unint64_t v14 = v24;
  if (v24 <= v13) {
    unint64_t v14 = v13;
  }
  if (v23) {
    unint64_t v13 = v14;
  }
  health::FormatImplementation<health::DataStore::ObjectIdentifier &>(v12, a2, v13 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = (char *)a2;
  }
  else {
    uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v21, &v15[a3 - v8], (const void **)__p);
  if ((char)v27 < 0) {
    operator delete(__p[0]);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BCE170DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &>(uint64_t a1)
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  long long v3 = exception;
  if (a1) {
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else {
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v3, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE17178(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    uint64_t v25 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    uint64_t v25 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    uint64_t v25 = i + 2;
    int v16 = i[2];
    if ((v16 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v17 = 0;
      std::string::size_type v18 = i + 3;
      do
      {
        uint64_t v25 = v18;
        uint64_t v17 = (v16 - 48) + 10 * v17;
        int v19 = *v18++;
        int v16 = v19;
      }
      while ((v19 - 58) >= 0xFFFFFFF6);
      uint64_t v25 = v18;
      if (*(v18 - 1) == 125) {
        health::FormatterParameters<0ul,long long &>::formatOptionsAtIndex<long long &>(v17);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_35:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v21, (const char **)&v25);
  if (v22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    goto LABEL_35;
  }
  uint64_t v12 = v25;
  health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)__p, *a4, (uint64_t)v21);
  unint64_t v13 = v27;
  if ((v27 & 0x80u) != 0) {
    unint64_t v13 = (unint64_t)__p[1];
  }
  unint64_t v14 = v24;
  if (v24 <= v13) {
    unint64_t v14 = v13;
  }
  if (v23) {
    unint64_t v13 = v14;
  }
  health::FormatImplementation<long long &>(v12, a2, v13 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = (char *)a2;
  }
  else {
    uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v21, &v15[a3 - v8], (const void **)__p);
  if ((char)v27 < 0) {
    operator delete(__p[0]);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BCE17404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &>::formatOptionsAtIndex<long long &>(uint64_t a1)
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  long long v3 = exception;
  if (a1) {
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else {
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v3, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE174A4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v8 = 0;
  int v6 = operator new(0x20uLL);
  *int v6 = &unk_1F171E800;
  v6[1] = a2;
  void v6[2] = a3;
  uint64_t v6[3] = &v8;
  v9[3] = v6;
  health::DataStore::performReadTransactionWithLambda(a1, (uint64_t)v9);
  std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100](v9);
  return v8;
}

void sub_1BCE1756C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(health::DataStore::ReadTransaction const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::~__func()
{
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F171E800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171E800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(a1 + 8, a2);
}

uint64_t std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1},std::allocator<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1}>,void ()(health::DataStore::ReadTransaction const&)>::target_type()
{
}

uint64_t std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<BOOL health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier const&,std::function<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>)::{lambda(health::DataStore::ReadTransaction const&)#1} &,health::DataStore::ReadTransaction const&>(uint64_t a1, uint64_t a2)
{
  memset(&v5[16], 0, 32);
  memset(&v5[56], 0, 32);
  uint64_t v6 = a2;
  uint64_t result = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::loadHistoryRoot((uint64_t)v5, *(ObjectIdentifier **)a1);
  if (result)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 24);
    if (!v4) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v4 + 48))(v4, v5);
    **(unsigned char **)(a1 + 16) = 1;
  }
  return result;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::~__func()
{
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1F171E880;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171E880;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a2[4];
  uint64_t v5 = a2[5];
  uint64_t v6 = a2[6];
  uint64_t v23 = v6;
  if (v6 < 1)
  {
    int v7 = **(_DWORD **)(a1 + 16);
    if (v6) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = v7 == 1;
    }
    if (v8)
    {
      health::FormatString<health::DataStore::ObjectIdentifier &>(&v26, (std::string *)"HFD sample history root [ID: {0}] reports an empty sample count.", *(void *)(a1 + 24));
      uint64_t v14 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v28, *(void *)(a1 + 40));
      health::DataStoreInspector::_errorHandler(v14, 2, v4, v5, (std::string::size_type)&v26, (uint64_t)v28);
      std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v28);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
      {
        unint64_t v13 = (void *)v26.__r_.__value_.__r.__words[0];
        goto LABEL_23;
      }
      goto LABEL_24;
    }
  }
  else
  {
    *(double *)(*(void *)(a1 + 8) + 40) = health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::firstSampleKey(a2);
    *(double *)(*(void *)(a1 + 8) + 4_Block_object_dispose(&a9, 8) = health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::lastSampleKey(a2);
    int v7 = **(_DWORD **)(a1 + 16);
  }
  if (v7 == 2)
  {
    if (!**(unsigned char **)(a1 + 48)) {
      goto LABEL_24;
    }
    uint64_t v11 = *(void *)(a1 + 40);
    std::string::basic_string[abi:ne180100]<0>(v28, "object_id \t sample_number \t timestamp \t data");
    uint64_t v12 = *(void *)(v11 + 24);
    if (!v12) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, void *))(*(void *)v12 + 48))(v12, v28);
  }
  else
  {
    if (v7) {
      goto LABEL_24;
    }
    _HDSampleHistoryDescriptionForObjectType(**(void **)(a1 + 24), v28);
    health::timestampToDate(*(double *)(*(void *)(a1 + 8) + 40), &v26);
    health::timestampToDate(*(double *)(*(void *)(a1 + 8) + 48), v24);
    uint64_t v9 = *(void *)(a1 + 40);
    health::FormatString<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(&__p, (uint64_t)v28, *(void *)(a1 + 24), (uint64_t)&v23, (uint64_t)&v26, (uint64_t)v24);
    uint64_t v10 = *(void *)(v9 + 24);
    if (!v10) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v10 + 48))(v10, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v25 < 0) {
      operator delete(v24[0]);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
  }
  if (v29 < 0)
  {
    unint64_t v13 = (void *)v28[0];
LABEL_23:
    operator delete(v13);
  }
LABEL_24:
  uint64_t v15 = *(void *)(a1 + 56);
  uint64_t v16 = *(void *)(a1 + 40);
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  int v19 = operator new(0x28uLL);
  void *v19 = &unk_1F171E900;
  v19[1] = v15;
  void v19[2] = v18;
  v19[3] = v16;
  void v19[4] = v17;
  unsigned __int8 v27 = v19;
  health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(a2, (uint64_t)&v26);
  std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>::~__value_func[abi:ne180100](&v26);
  std::string::size_type v20 = *(void **)(a1 + 56);
  *(void *)(*(void *)(a1 + 8) + 24) = *v20;
  if (**(_DWORD **)(a1 + 16) == 1 && *v20 != v23)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(&__p, (std::string *)"HFD sample history [ID: {0}] has an actual sample count ({1}) that does not match its reported count ({2}).", *(void *)(a1 + 24), (uint64_t)v20, (uint64_t)&v23);
    uint64_t v21 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v24, *(void *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v21, 3, v4, v5, (std::string::size_type)&__p, (uint64_t)v24);
    std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1BCE17AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::target_type()
{
}

double health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::firstSampleKey(void *a1)
{
  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_6;
  }
  uint64_t v1 = *(uint64_t **)(a1[11] + 24);
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[3];
  memset(v6, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v2, v3, (uint64_t)v6);
  if (!WORD4(v6[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_6:
    __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
  }
  return *(double *)v6;
}

void sub_1BCE17CEC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::lastSampleKey(void *a1)
{
  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_11;
  }
  uint64_t v1 = *(uint64_t **)(a1[11] + 24);
  v11[0] = 0;
  v11[1] = 0;
  uint64_t v12 = v1;
  uint64_t v2 = a1[3];
  v9[0] = a1[2];
  v9[1] = v2;
  uint64_t v10 = v11;
  memset(__dst, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v9[0], v2, (uint64_t)__dst);
  unsigned int v3 = WORD4(__dst[25]);
  if (!WORD4(__dst[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
    goto LABEL_11;
  }
  if (!BYTE10(__dst[25]))
  {
    int v5 = 0;
    while (WORD4(__dst[25]))
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)v9, v5, (uint64_t)__dst, (unsigned __int16)(WORD4(__dst[25]) - 1), (uint64_t)__src);
      memcpy(__dst, __src, 0x19BuLL);
      ++v5;
      if (BYTE10(__dst[25]))
      {
        unsigned int v3 = WORD4(__dst[25]);
        uint64_t v4 = (uint64_t **)(v10 + 2);
        goto LABEL_9;
      }
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_11:
    __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
  }
  uint64_t v4 = &v12;
LABEL_9:
  uint64_t v6 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)__dst, v3 - 1);
  bzero(__src, 0x3BAuLL);
  long long v15 = 0u;
  long long v16 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>>(*v4, *(void *)(v6 + 8), *(void *)(v6 + 16), (uint64_t)__src);
  return *(double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)__src, v14 - 1);
}

void sub_1BCE17EFC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(void *result, uint64_t a2)
{
  void v6[4] = *MEMORY[0x1E4F143B8];
  if (result[6])
  {
    uint64_t v2 = *(void *)(result[11] + 24);
    v5[0] = 0;
    v5[1] = 0;
    v5[2] = v2;
    long long v3 = *((_OWORD *)result + 1);
    uint64_t v4 = v5;
    std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>((uint64_t *)&v3, (uint64_t)v6, 0);
    return std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>::~__value_func[abi:ne180100](v6);
  }
  return result;
}

void sub_1BCE17FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x11)
  {
    uint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 43, (uint64_t)&__p);
  }
  return a1 + 56 * a2;
}

{
  void *v2;
  std::string __p;
  void *v5[2];
  void *v6[2];
  void v7[2];

  if (a2 >= 0x11)
  {
    uint64_t v2 = (void *)*MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v7, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(v6, "operator[]");
    std::string::basic_string[abi:ne180100]<0>(v5, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &__p);
    health::_HDAssertImplementation<std::out_of_range>(v2, (uint64_t)v7, (uint64_t)v6, (uint64_t)v5, 50, (uint64_t)&__p);
  }
  return a1 + 56 * a2;
}

void sub_1BCE180B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v13 = 0;
  unint64_t v14 = 935;
  health::RawBuffer::RawBuffer(v11, v12, 935);
  health::BlockAccessFile::ReadTransaction::retrieveBlock(a1, a2, a3, (uint64_t)v11);
  BOOL v8 = v12;
  if (v14 > 0x3FF) {
    BOOL v8 = v13;
  }
  v10[0] = v8;
  v10[1] = v8;
  std::locale v10[2] = 935;
  health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::deserialize(a4, (uint64_t)v10);
  uint64_t result = (uint64_t)v13;
  unint64_t v13 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BCE18208(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void sub_1BCE18324(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::deserialize(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 17; ++i)
  {
    uint64_t v5 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a1, i);
    health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry::deserialize(v5, a2);
  }
  __int16 v7 = 0;
  health::DeserializationBuffer::extractRaw<unsigned short>(a2, &v7);
  *(_WORD *)(a1 + 952) = v7;
  health::BlockPointer::deserialize((void *)(a1 + 960), a2);
  return health::BlockPointer::deserialize((void *)(a1 + 976), a2);
}

uint64_t health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry::deserialize(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)(a1 + 8);
  uint64_t v6 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a2, &v6);
  *(void *)a1 = v6;
  return health::DeserializeValues<double,double,float,float,float,float,float,float,float,unsigned char>(a2, v4, (void *)(a1 + 16), (_DWORD *)(a1 + 24), (_DWORD *)(a1 + 28), (_DWORD *)(a1 + 32), (_DWORD *)(a1 + 36), (_DWORD *)(a1 + 40), (_DWORD *)(a1 + 44), (_DWORD *)(a1 + 48), (unsigned char *)(a1 + 52));
}

uint64_t health::DeserializeValues<double,double,float,float,float,float,float,float,float,unsigned char>(uint64_t a1, void *a2, void *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10, unsigned char *a11)
{
  uint64_t v20 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a1, &v20);
  *a2 = v20;
  uint64_t v20 = 0;
  health::DeserializationBuffer::extractRaw<long long>(a1, &v20);
  *a3 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a4 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a5 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a6 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a7 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a8 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a9 = v20;
  LODWORD(v20) = 0;
  health::DeserializationBuffer::extractRaw<int>(a1, &v20);
  *a10 = v20;
  return health::DeserializationBuffer::extractRaw<unsigned char>(a1, a11);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[2];
  memset(v8, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(*(uint64_t **)(v6 + 16), *a1, a1[1], (uint64_t)v8);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>((uint64_t)a1, 0, (uint64_t)v8, a2, a3);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_WORD *)(a3 + 408))
  {
    uint64_t v7 = result;
    unsigned __int16 v8 = *(_WORD *)(a3 + 408) - 1;
    if (!a5) {
      unsigned __int16 v8 = 0;
    }
    if (*(unsigned char *)(a3 + 410))
    {
      uint64_t v9 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v8);
      uint64_t v10 = *(void *)(v9 + 8);
      uint64_t v11 = *(void *)(v9 + 16);
      uint64_t v12 = *(void *)(v7 + 16);
      bzero(v14, 0x3BAuLL);
      long long v16 = 0u;
      long long v15 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>>(*(uint64_t **)(v12 + 16), v10, v11, (uint64_t)v14);
      uint64_t v17 = a4;
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17> const&,health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(v7, (uint64_t)v14, (uint64_t)&v17, a5);
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex(result, a2, a3, v8, (uint64_t)v14);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(v7, (a2 + 1), v14, a4, a5);
    }
  }
  return result;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateLeaves<void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,_HDRawLocationDatumV2>>::_enumerateAllValues<health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(int,health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17> const&,health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::enumerateSamples(std::function<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1} const&,health::bplustree::EnumerationDirection)::{lambda(double const&,_HDRawLocationDatumV2 const&)#1}>(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v43 = result;
  if (a4 == 1)
  {
    if (*(_WORD *)(a2 + 952))
    {
      unint64_t v14 = *(unsigned __int16 *)(a2 + 952) - 1;
      unint64_t v15 = 1;
      double v16 = 0.0;
      while (1)
      {
        uint64_t v17 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        uint64_t v18 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v14);
        if (v15 >= 2)
        {
          v19.n128_u64[0] = *v17;
          if (*(double *)v17 >= v16)
          {
            uint64_t v20 = (void *)*MEMORY[0x1E4F29F18];
            std::string::basic_string[abi:ne180100]<0>(v55, "key < lastKey");
            std::string::basic_string[abi:ne180100]<0>(v54, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v53, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &__p);
            health::_HDAssertImplementation<health::btree_access_error>(v20, (uint64_t)v55, (uint64_t)v54, (uint64_t)v53, 412, (uint64_t)&__p);
          }
        }
        uint64_t v21 = *(void *)(*(void *)a3 + 24);
        if (!v21) {
          break;
        }
        double v16 = *(double *)v17;
        uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(void *)v21 + 48))(v21, v17, v18 + 8, v19);
        if ((result & 1) == 0) {
          return result;
        }
        ++v15;
        if (--v14 == -1) {
          goto LABEL_35;
        }
      }
LABEL_48:
      std::__throw_bad_function_call[abi:ne180100]();
    }
    double v16 = 0.0;
LABEL_35:
    uint64_t v32 = *(void *)(a2 + 960);
    long long v33 = (void **)MEMORY[0x1E4F29F18];
    uint64_t v34 = *(void *)(a2 + 968);
    while (1)
    {
      uint64_t v35 = *(void *)(v43 + 16);
      if (v32 == *(void *)v35 && v34 == *(void *)(v35 + 8)) {
        break;
      }
      bzero(v64, 0x3BAuLL);
      long long v66 = 0u;
      long long v67 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>>(*(uint64_t **)(v35 + 16), v32, v34, (uint64_t)v64);
      if (!v65)
      {
        long long v36 = *v33;
        std::string::basic_string[abi:ne180100]<0>(v51, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v50, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v49, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v48);
        health::_HDAssertImplementation<health::btree_access_error>(v36, (uint64_t)v51, (uint64_t)v50, (uint64_t)v49, 422, (uint64_t)&v48);
      }
      unint64_t v37 = v65 - 1;
      do
      {
        long long v38 = (double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, v37);
        uint64_t v39 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, v37);
        if (*v38 >= v16)
        {
          double v41 = *v33;
          std::string::basic_string[abi:ne180100]<0>(v47, "key < lastKey");
          std::string::basic_string[abi:ne180100]<0>(v46, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v45, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v44);
          health::_HDAssertImplementation<health::btree_access_error>(v41, (uint64_t)v47, (uint64_t)v46, (uint64_t)v45, 427, (uint64_t)&v44);
        }
        uint64_t v42 = *(void *)(*(void *)a3 + 24);
        if (!v42) {
          goto LABEL_48;
        }
        double v16 = *v38;
        v40.n128_f64[0] = *v38;
        uint64_t result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(void *)v42 + 48))(v42, v38, v39 + 8, v40);
        if ((result & 1) == 0) {
          return result;
        }
        --v37;
      }
      while (v37 != -1);
      uint64_t v34 = *((void *)&v66 + 1);
      uint64_t v32 = v66;
    }
  }
  else if (!a4)
  {
    uint64_t v6 = (void **)MEMORY[0x1E4F29F18];
    if (*(_WORD *)(a2 + 952))
    {
      unint64_t v7 = 0;
      double v8 = 0.0;
      while (1)
      {
        uint64_t v9 = (unint64_t *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        uint64_t v10 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[](a2, v7);
        if (v7)
        {
          v11.n128_u64[0] = *v9;
          if (*(double *)v9 <= v8)
          {
            uint64_t v12 = *v6;
            std::string::basic_string[abi:ne180100]<0>(v71, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v70, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v69, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v68);
            health::_HDAssertImplementation<health::btree_access_error>(v12, (uint64_t)v71, (uint64_t)v70, (uint64_t)v69, 382, (uint64_t)&v68);
          }
        }
        uint64_t v13 = *(void *)(*(void *)a3 + 24);
        if (!v13) {
          goto LABEL_48;
        }
        double v8 = *(double *)v9;
        uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, __n128))(*(void *)v13 + 48))(v13, v9, v10 + 8, v11);
        if ((result & 1) == 0) {
          return result;
        }
        if (++v7 >= *(unsigned __int16 *)(a2 + 952)) {
          goto LABEL_22;
        }
      }
    }
    double v8 = 0.0;
LABEL_22:
    uint64_t v22 = *(void *)(a2 + 976);
    uint64_t v23 = *(void *)(a2 + 984);
    while (1)
    {
      uint64_t v24 = *(void *)(v43 + 16);
      if (v22 == *(void *)v24 && v23 == *(void *)(v24 + 8)) {
        break;
      }
      bzero(v64, 0x3BAuLL);
      long long v66 = 0u;
      long long v67 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>>(*(uint64_t **)(v24 + 16), v22, v23, (uint64_t)v64);
      if (!v65)
      {
        char v25 = *v6;
        std::string::basic_string[abi:ne180100]<0>(v63, "leaf.valueCount > 0");
        std::string::basic_string[abi:ne180100]<0>(v62, "_enumerateLeaves");
        std::string::basic_string[abi:ne180100]<0>(v61, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v60);
        health::_HDAssertImplementation<health::btree_access_error>(v25, (uint64_t)v63, (uint64_t)v62, (uint64_t)v61, 392, (uint64_t)&v60);
      }
      for (unint64_t i = 0; i < v65; ++i)
      {
        unsigned __int8 v27 = (double *)health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, i);
        uint64_t v28 = health::StaticArray<health::bplustree::LeafNode<double,_HDRawLocationDatumV2,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)v64, i);
        if (*v27 <= v8)
        {
          uint64_t v30 = *v6;
          std::string::basic_string[abi:ne180100]<0>(v59, "key > lastKey");
          std::string::basic_string[abi:ne180100]<0>(v58, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(v57, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v56);
          health::_HDAssertImplementation<health::btree_access_error>(v30, (uint64_t)v59, (uint64_t)v58, (uint64_t)v57, 396, (uint64_t)&v56);
        }
        uint64_t v31 = *(void *)(*(void *)a3 + 24);
        if (!v31) {
          goto LABEL_48;
        }
        double v8 = *v27;
        v29.n128_f64[0] = *v27;
        uint64_t result = (*(uint64_t (**)(uint64_t, double *, uint64_t, __n128))(*(void *)v31 + 48))(v31, v27, v28 + 8, v29);
        if ((result & 1) == 0) {
          return result;
        }
      }
      uint64_t v23 = *((void *)&v67 + 1);
      uint64_t v22 = v67;
    }
  }
  return result;
}

void sub_1BCE18F24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EE7__cloneEv(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v2 = &unk_1F171E900;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EE7__cloneEPNS0_6__baseIS11_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171E900;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EEclESX_S10_(uint64_t a1, double *a2, _OWORD *a3)
{
  long long v3 = a3[1];
  v12[0] = *a3;
  v12[1] = v3;
  _OWORD v12[2] = a3[2];
  double v4 = *a2;
  uint64_t v5 = *(void **)(a1 + 8);
  ++*v5;
  int v6 = **(_DWORD **)(a1 + 16);
  if (v6 == 2)
  {
    uint64_t v9 = *(void *)(a1 + 24);
    uint64_t v10 = *(void *)(a1 + 32);
    health::doubleToString((health *)9, v13);
    double v16 = v12;
    uint64_t v17 = v13;
    uint64_t v18 = v5;
    uint64_t v19 = v10;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>((std::string *)"{0} \t Sample #{1} \t {2} \t {3}", &__p, 0, (uint64_t *)&v16);
    uint64_t v8 = *(void *)(v9 + 24);
    if (!v8) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  else
  {
    if (v6) {
      return 1;
    }
    uint64_t v7 = *(void *)(a1 + 24);
    health::timestampToDate(v4, v13);
    double v16 = v12;
    uint64_t v17 = v13;
    uint64_t v18 = v5;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV2 &>((std::string *)"Sample #{0} | Timestamp: {1} | Data: {2}", &__p, 0, (uint64_t *)&v16);
    uint64_t v8 = *(void *)(v7 + 24);
    if (!v8) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v8 + 48))(v8, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v14 < 0) {
    operator delete(v13[0]);
  }
  return 1;
}

void sub_1BCE1940C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK21_HDRawLocationDatumV2EE11target_typeEv()
{
  return &_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI25LocationHistoryBehaviorV2EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_;
}

void health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV2 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    uint64_t v31 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    uint64_t v31 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    uint64_t v31 = i + 2;
    int v22 = i[2];
    if ((v22 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v23 = 0;
      uint64_t v24 = i + 3;
      do
      {
        uint64_t v31 = v24;
        uint64_t v23 = (v22 - 48) + 10 * v23;
        int v25 = *v24++;
        int v22 = v25;
      }
      while ((v25 - 58) >= 0xFFFFFFF6);
      uint64_t v31 = v24;
      if (*(v24 - 1) == 125) {
        health::FormatterParameters<0ul,long long &,std::string,_HDRawLocationDatumV2 &>::formatOptionsAtIndex<long long &,std::string,_HDRawLocationDatumV2 &>(v23);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_58;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v27, (const char **)&v31);
  uint64_t v12 = v31;
  if (!*((void *)&v27 + 1))
  {
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v27);
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    std::string::size_type v17 = *((void *)&v28 + 1);
    if (*((void *)&v28 + 1) <= size) {
      std::string::size_type v17 = size;
    }
    if ((_BYTE)v28) {
      std::string::size_type size = v17;
    }
    health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV2 &>(v12, a2, size + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v15 = (char *)a2;
    }
    else {
      unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
LABEL_34:
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v27, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (!v8) {
      return;
    }
LABEL_37:
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
    return;
  }
  if (*((void *)&v27 + 1) != 1)
  {
    if (*((void *)&v27 + 1) == 2)
    {
      health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(&__p, *a4, *a4 + 8, *a4 + 16, *a4 + 20, *a4 + 24, *a4 + 28, *a4 + 32, *a4 + 36, *a4 + 40, *a4 + 44);
      std::string::size_type v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v13 = __p.__r_.__value_.__l.__size_;
      }
      std::string::size_type v14 = *((void *)&v28 + 1);
      if (*((void *)&v28 + 1) <= v13) {
        std::string::size_type v14 = v13;
      }
      if ((_BYTE)v28) {
        std::string::size_type v13 = v14;
      }
      health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV2 &>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v15 = (char *)a2;
      }
      else {
        unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_34;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_58:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  std::string::size_type v18 = a4[1];
  __p.__r_.__value_.__r.__words[0] = v18;
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v27;
  long long v33 = v28;
  long long v34 = v29;
  uint64_t v35 = v30;
  if (*(char *)(v18 + 23) < 0) {
    unint64_t v19 = *(void *)(v18 + 8);
  }
  else {
    unint64_t v19 = *(unsigned __int8 *)(v18 + 23);
  }
  unint64_t v20 = *((void *)&v28 + 1);
  if (*((void *)&v28 + 1) <= v19) {
    unint64_t v20 = v19;
  }
  if ((_BYTE)v28) {
    unint64_t v19 = v20;
  }
  health::FormatImplementation<long long &,std::string,_HDRawLocationDatumV2 &>(v31, a2, v19 + a3 + v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v21 = (char *)a2;
  }
  else {
    uint64_t v21 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v27, &v21[a3 + v8], (uint64_t)&__p);
  if (v8) {
    goto LABEL_37;
  }
}

void sub_1BCE19840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  __cxa_free_exception(v26);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,std::string,_HDRawLocationDatumV2 &>::formatOptionsAtIndex<long long &,std::string,_HDRawLocationDatumV2 &>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    unint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    unint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE19928(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(std::string *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v11[0] = a11;
  v11[1] = a10;
  void v11[2] = a9;
  void v11[3] = a8;
  void v11[4] = a7;
  void v11[5] = a6;
  v11[6] = a5;
  v11[7] = a4;
  v11[8] = a3;
  v11[9] = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>((std::string *)"(Lat: {0}, Lon: {1}, Alt: {2}, Speed: {3}, Course: {4}, HAcc: {5}, VAcc: {6}, SAcc: {7}, CAcc:{8}, Signal: {9})", a1, 0, (uint64_t)v11);
}

void sub_1BCE199AC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    long long v62 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v62 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v62 = i + 2;
    int v49 = i[2];
    if ((v49 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v50 = 0;
      std::string v51 = i + 3;
      do
      {
        long long v62 = v51;
        uint64_t v50 = (v49 - 48) + 10 * v50;
        int v52 = *v51++;
        int v49 = v52;
      }
      while ((v52 - 58) >= 0xFFFFFFF6);
      long long v62 = v51;
      if (*(v51 - 1) == 125) {
        health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>::formatOptionsAtIndex<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(v50);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_153:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)&v55, (const char **)&v62);
  uint64_t v12 = v62;
  switch(v56)
  {
    case 0:
      health::TypeFormatter<double const&,void>::TypeFormatter((uint64_t)&v67, *(void *)(a4 + 72), (uint64_t)&v55);
      size_t v13 = v69;
      if ((v69 & 0x80u) != 0) {
        size_t v13 = *(void *)v68;
      }
      size_t v14 = v58;
      if (v58 <= v13) {
        size_t v14 = v13;
      }
      if (v57) {
        size_t v13 = v14;
      }
      goto LABEL_67;
    case 1:
      health::TypeFormatter<double const&,void>::TypeFormatter((uint64_t)&v67, *(void *)(a4 + 64), (uint64_t)&v55);
      size_t v13 = v69;
      if ((v69 & 0x80u) != 0) {
        size_t v13 = *(void *)v68;
      }
      size_t v31 = v58;
      if (v58 <= v13) {
        size_t v31 = v13;
      }
      if (v57) {
        size_t v13 = v31;
      }
LABEL_67:
      std::string::size_type v32 = a3 + v8;
      health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v33 = (char *)a2;
      }
      else {
        long long v33 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_114;
    case 2:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(void *)(a4 + 56), (uint64_t)&v55);
      size_t v15 = v69;
      if ((v69 & 0x80u) != 0) {
        size_t v15 = *(void *)v68;
      }
      size_t v34 = v58;
      if (v58 <= v15) {
        size_t v34 = v15;
      }
      if (v57) {
        size_t v15 = v34;
      }
      goto LABEL_111;
    case 3:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(void *)(a4 + 48), (uint64_t)&v55);
      size_t v15 = v69;
      if ((v69 & 0x80u) != 0) {
        size_t v15 = *(void *)v68;
      }
      size_t v35 = v58;
      if (v58 <= v15) {
        size_t v35 = v15;
      }
      if (v57) {
        size_t v15 = v35;
      }
      goto LABEL_111;
    case 4:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(void *)(a4 + 40), (uint64_t)&v55);
      size_t v15 = v69;
      if ((v69 & 0x80u) != 0) {
        size_t v15 = *(void *)v68;
      }
      size_t v16 = v58;
      if (v58 <= v15) {
        size_t v16 = v15;
      }
      if (v57) {
        size_t v15 = v16;
      }
      goto LABEL_111;
    case 5:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(void *)(a4 + 32), (uint64_t)&v55);
      size_t v15 = v69;
      if ((v69 & 0x80u) != 0) {
        size_t v15 = *(void *)v68;
      }
      size_t v36 = v58;
      if (v58 <= v15) {
        size_t v36 = v15;
      }
      if (v57) {
        size_t v15 = v36;
      }
      goto LABEL_111;
    case 6:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(void *)(a4 + 24), (uint64_t)&v55);
      size_t v15 = v69;
      if ((v69 & 0x80u) != 0) {
        size_t v15 = *(void *)v68;
      }
      size_t v37 = v58;
      if (v58 <= v15) {
        size_t v37 = v15;
      }
      if (v57) {
        size_t v15 = v37;
      }
      goto LABEL_111;
    case 7:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(void *)(a4 + 16), (uint64_t)&v55);
      size_t v15 = v69;
      if ((v69 & 0x80u) != 0) {
        size_t v15 = *(void *)v68;
      }
      size_t v38 = v58;
      if (v58 <= v15) {
        size_t v38 = v15;
      }
      if (v57) {
        size_t v15 = v38;
      }
      goto LABEL_111;
    case 8:
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&v67, *(void *)(a4 + 8), (uint64_t)&v55);
      size_t v15 = v69;
      if ((v69 & 0x80u) != 0) {
        size_t v15 = *(void *)v68;
      }
      size_t v39 = v58;
      if (v58 <= v15) {
        size_t v39 = v15;
      }
      if (v57) {
        size_t v15 = v39;
      }
LABEL_111:
      std::string::size_type v32 = a3 + v8;
      health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(v12, a2, v15 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v33 = (char *)a2;
      }
      else {
        long long v33 = (char *)a2->__r_.__value_.__r.__words[0];
      }
LABEL_114:
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v55, &v33[v32], (const void **)&v67);
      if (((char)v69 & 0x80000000) == 0) {
        goto LABEL_117;
      }
      uint64_t v30 = v67;
      goto LABEL_116;
    case 9:
      std::string::size_type v17 = *(unsigned char **)a4;
      uint64_t v64 = 0;
      long long v63 = 0uLL;
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v67);
      std::string::size_type v18 = v67;
      if (v57) {
        *(void *)&v70[*((void *)v67 - 3)] = v58;
      }
      if (v59) {
        *(void *)&v68[*(v18 - 3) + 8] = v60;
      }
      unint64_t v19 = (const std::ios_base *)&v68[*(v18 - 3) - 8];
      std::ios_base::fmtflags v20 = v61;
      if (v19[1].__fmtflags_ == -1)
      {
        std::ios_base::getloc(v19);
        uint64_t v21 = std::locale::use_facet(v65, MEMORY[0x1E4FBA258]);
        ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 32);
        std::locale::~locale(v65);
      }
      v19[1].__fmtflags_ = v20;
      LOBYTE(v65[0].__locale_) = *v17;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v67, (uint64_t)v65, 1);
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v68, v65);
      long long v63 = *(_OWORD *)&v65[0].__locale_;
      uint64_t v64 = v66;
      long long v67 = (void *)*MEMORY[0x1E4FBA418];
      *(void *)&v68[*((void *)v67 - 3) - 8] = *(void *)(MEMORY[0x1E4FBA418] + 24);
      *(void *)std::string v68 = MEMORY[0x1E4FBA470] + 16;
      if (v72 < 0) {
        operator delete(__p);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x1C187B850](&v73);
      int v54 = SHIBYTE(v64);
      if (v64 >= 0) {
        size_t v22 = HIBYTE(v64);
      }
      else {
        size_t v22 = *((void *)&v63 + 1);
      }
      size_t v23 = v58;
      if (v58 <= v22) {
        size_t v23 = v22;
      }
      if (v57) {
        size_t v24 = v23;
      }
      else {
        size_t v24 = v22;
      }
      health::FormatImplementation<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(v12, a2, v24 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v25 = a2;
      }
      else {
        int v25 = (std::string *)a2->__r_.__value_.__r.__words[0];
      }
      uint64_t v26 = (char *)v25 + a3 + v8;
      if (!v57) {
        goto LABEL_54;
      }
      size_t v27 = v58;
      unint64_t v28 = v58 - v22;
      if (v58 <= v22) {
        goto LABEL_54;
      }
      if (v55)
      {
        if (v55 == 1)
        {
          unint64_t v42 = v28 >> 1;
          if (v28 >= 2)
          {
            if (v42 <= 1) {
              uint64_t v43 = 1;
            }
            else {
              uint64_t v43 = v28 >> 1;
            }
            do
            {
              *v26++ = v61;
              --v43;
            }
            while (v43);
          }
          if (v22)
          {
            if (v54 >= 0) {
              std::string v44 = &v63;
            }
            else {
              std::string v44 = (long long *)v63;
            }
            memmove(v26, v44, v22);
          }
          if (v28 != v42)
          {
            unint64_t v45 = v28 - (v28 >> 1);
            long long v46 = &v26[v22];
            if (v45 <= 1) {
              unint64_t v45 = 1;
            }
            uint64_t v47 = -(uint64_t)v45;
            do
              *v46++ = v61;
            while (!__CFADD__(v47++, 1));
          }
        }
        else if (v55 == 2)
        {
          if (v58 != v22)
          {
            do
            {
              *v26++ = v61;
              --v28;
            }
            while (v28);
          }
LABEL_54:
          if (v22)
          {
            if (v54 >= 0) {
              long long v29 = &v63;
            }
            else {
              long long v29 = (long long *)v63;
            }
            memmove(v26, v29, v22);
          }
        }
      }
      else
      {
        if (v22)
        {
          if (v54 >= 0) {
            __n128 v40 = &v63;
          }
          else {
            __n128 v40 = (long long *)v63;
          }
          memmove((char *)v25 + a3 + v8, v40, v22);
        }
        if (v27 != v22)
        {
          size_t v41 = (size_t)v25 + v22;
          do
          {
            *(unsigned char *)(v41 + a3 + v_Block_object_dispose(&a9, 8) = v61;
            ++v41;
            --v28;
          }
          while (v28);
        }
      }
      if ((SHIBYTE(v64) & 0x80000000) == 0) {
        goto LABEL_117;
      }
      uint64_t v30 = (void *)v63;
LABEL_116:
      operator delete(v30);
LABEL_117:
      if (v8) {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      break;
    default:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
      goto LABEL_153;
  }
}

void sub_1BCE1A2E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,std::locale a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  __cxa_free_exception(v32);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>::formatOptionsAtIndex<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(uint64_t a1)
{
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
      break;
    default:
      long long v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      exception = v3;
      if (a1 == 9) {
        std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
      }
      else {
        std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
      }
      break;
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1A534(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    long long v33 = i;
    if (*i != 123) {
      break;
    }
    int v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)&v29, (const char **)&v33);
        uint64_t v12 = v33;
        switch(*((void *)&v29 + 1))
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)&v29);
            std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type size = __p.__r_.__value_.__l.__size_;
            }
            std::string::size_type v14 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= size) {
              std::string::size_type v14 = size;
            }
            if ((_BYTE)v30) {
              std::string::size_type size = v14;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(v12, a2, size + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t v15 = (char *)a2;
            }
            else {
              size_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_43;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v29);
            std::string::size_type v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
            }
            std::string::size_type v19 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v18) {
              std::string::size_type v19 = v18;
            }
            if ((_BYTE)v30) {
              std::string::size_type v18 = v19;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t v15 = (char *)a2;
            }
            else {
              size_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_43;
          case 2:
            std::string::size_type v16 = a4[1];
            __p.__r_.__value_.__r.__words[0] = v16;
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v29;
            long long v35 = v30;
            long long v36 = v31;
            uint64_t v37 = v32;
            if (*(char *)(v16 + 23) < 0) {
              unint64_t v17 = *(void *)(v16 + 8);
            }
            else {
              unint64_t v17 = *(unsigned __int8 *)(v16 + 23);
            }
            unint64_t v22 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v17) {
              unint64_t v22 = v17;
            }
            if ((_BYTE)v30) {
              unint64_t v17 = v22;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(v33, a2, v17 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t v23 = (char *)a2;
            }
            else {
              size_t v23 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v29, &v23[a3 + v8], (uint64_t)&__p);
            if (!v8) {
              return;
            }
            goto LABEL_46;
          case 3:
            health::FormatString<double const&,double const&,float const&,float const&,float const&,float const&,float const&,float const&,float const&,unsigned char const&>(&__p, *a4, *a4 + 8, *a4 + 16, *a4 + 20, *a4 + 24, *a4 + 28, *a4 + 32, *a4 + 36, *a4 + 40, *a4 + 44);
            std::string::size_type v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v20 = __p.__r_.__value_.__l.__size_;
            }
            std::string::size_type v21 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v20) {
              std::string::size_type v21 = v20;
            }
            if ((_BYTE)v30) {
              std::string::size_type v20 = v21;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t v15 = (char *)a2;
            }
            else {
              size_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
LABEL_43:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v29, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            if (v8) {
LABEL_46:
            }
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_65;
        }
      }
      long long v33 = i + 2;
      int v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        uint64_t v25 = 0;
        uint64_t v26 = i + 3;
        do
        {
          long long v33 = v26;
          uint64_t v25 = (v24 - 48) + 10 * v25;
          int v27 = *v26++;
          int v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        long long v33 = v26;
        if (*(v26 - 1) == 125) {
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(v25);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_65:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    long long v33 = i + 1;
    char v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
  {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE1A9D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  __cxa_free_exception(v26);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawLocationDatumV2 &>(uint64_t a1)
{
  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    long long v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3) {
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
    }
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1AAEC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<BOOL ()(double const&,_HDRawLocationDatumV2 const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::~__func()
{
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)unint64_t v2 = &unk_1F171E9A0;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171E9A0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a2[4];
  uint64_t v5 = a2[5];
  uint64_t v6 = a2[6];
  uint64_t v23 = v6;
  if (v6 < 1)
  {
    int v7 = **(_DWORD **)(a1 + 16);
    if (v6) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = v7 == 1;
    }
    if (v8)
    {
      health::FormatString<health::DataStore::ObjectIdentifier &>(&v26, (std::string *)"HFD sample history root [ID: {0}] reports an empty sample count.", *(void *)(a1 + 24));
      uint64_t v14 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v28, *(void *)(a1 + 40));
      health::DataStoreInspector::_errorHandler(v14, 2, v4, v5, (std::string::size_type)&v26, (uint64_t)v28);
      std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v28);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
      {
        size_t v13 = (void *)v26.__r_.__value_.__r.__words[0];
        goto LABEL_23;
      }
      goto LABEL_24;
    }
  }
  else
  {
    *(double *)(*(void *)(a1 + 8) + 40) = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::firstSampleKey(a2);
    *(double *)(*(void *)(a1 + 8) + 4_Block_object_dispose(&a9, 8) = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::lastSampleKey(a2);
    int v7 = **(_DWORD **)(a1 + 16);
  }
  if (v7 == 2)
  {
    if (!**(unsigned char **)(a1 + 48)) {
      goto LABEL_24;
    }
    uint64_t v11 = *(void *)(a1 + 40);
    std::string::basic_string[abi:ne180100]<0>(v28, "object_id \t sample_number \t timestamp \t data");
    uint64_t v12 = *(void *)(v11 + 24);
    if (!v12) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, void *))(*(void *)v12 + 48))(v12, v28);
  }
  else
  {
    if (v7) {
      goto LABEL_24;
    }
    _HDSampleHistoryDescriptionForObjectType(**(void **)(a1 + 24), v28);
    health::timestampToDate(*(double *)(*(void *)(a1 + 8) + 40), &v26);
    health::timestampToDate(*(double *)(*(void *)(a1 + 8) + 48), v24);
    uint64_t v9 = *(void *)(a1 + 40);
    health::FormatString<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(&__p, (uint64_t)v28, *(void *)(a1 + 24), (uint64_t)&v23, (uint64_t)&v26, (uint64_t)v24);
    uint64_t v10 = *(void *)(v9 + 24);
    if (!v10) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v10 + 48))(v10, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v25 < 0) {
      operator delete(v24[0]);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
  }
  if (v29 < 0)
  {
    size_t v13 = (void *)v28[0];
LABEL_23:
    operator delete(v13);
  }
LABEL_24:
  uint64_t v15 = *(void *)(a1 + 56);
  uint64_t v16 = *(void *)(a1 + 40);
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  std::string::size_type v19 = operator new(0x28uLL);
  void *v19 = &unk_1F171EA10;
  v19[1] = v15;
  void v19[2] = v18;
  v19[3] = v16;
  void v19[4] = v17;
  int v27 = v19;
  health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::enumerateSamples(a2, (uint64_t)&v26);
  std::__function::__value_func<BOOL ()(double const&,double const&)>::~__value_func[abi:ne180100](&v26);
  std::string::size_type v20 = *(void **)(a1 + 56);
  *(void *)(*(void *)(a1 + 8) + 24) = *v20;
  if (**(_DWORD **)(a1 + 16) == 1 && *v20 != v23)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(&__p, (std::string *)"HFD sample history [ID: {0}] has an actual sample count ({1}) that does not match its reported count ({2}).", *(void *)(a1 + 24), (uint64_t)v20, (uint64_t)&v23);
    uint64_t v21 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v24, *(void *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v21, 3, v4, v5, (std::string::size_type)&__p, (uint64_t)v24);
    std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1BCE1AFF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::target_type()
{
}

double health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::firstSampleKey(void *a1)
{
  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_6;
  }
  uint64_t v1 = *(uint64_t **)(a1[11] + 24);
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[3];
  memset(v6, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v2, v3, (uint64_t)v6);
  if (!WORD4(v6[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_6:
    __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
  }
  return *(double *)v6;
}

void sub_1BCE1B1FC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::lastSampleKey(void *a1)
{
  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_11;
  }
  uint64_t v1 = *(uint64_t **)(a1[11] + 24);
  v11[0] = 0;
  v11[1] = 0;
  uint64_t v12 = v1;
  uint64_t v2 = a1[3];
  v9[0] = a1[2];
  v9[1] = v2;
  uint64_t v10 = v11;
  memset(__dst, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v9[0], v2, (uint64_t)__dst);
  unsigned int v3 = WORD4(__dst[25]);
  if (!WORD4(__dst[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
    goto LABEL_11;
  }
  if (!BYTE10(__dst[25]))
  {
    int v5 = 0;
    while (WORD4(__dst[25]))
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)v9, v5, (uint64_t)__dst, (unsigned __int16)(WORD4(__dst[25]) - 1), (uint64_t)__src);
      memcpy(__dst, __src, 0x19BuLL);
      ++v5;
      if (BYTE10(__dst[25]))
      {
        unsigned int v3 = WORD4(__dst[25]);
        uint64_t v4 = (uint64_t **)(v10 + 2);
        goto LABEL_9;
      }
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_11:
    __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
  }
  uint64_t v4 = &v12;
LABEL_9:
  uint64_t v6 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)__dst, v3 - 1);
  memset(__src, 0, 274);
  *(_OWORD *)((char *)&__src[17] + _Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)((char *)&__src[18] + _Block_object_dispose(&a9, 8) = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,double,health::BlockPointer,17>>(*v4, *(void *)(v6 + 8), *(void *)(v6 + 16), (uint64_t)__src);
  return *(double *)health::StaticArray<health::bplustree::LeafNode<double,double,health::BlockPointer,17>::ValueEntry,17ul>::operator[]((uint64_t)__src, LOWORD(__src[17]) - 1);
}

void sub_1BCE1B400(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EE7__cloneEv(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F171EA10;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EE7__cloneEPNS0_6__baseISY_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171EA10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EEclESX_SX_(uint64_t a1, double *a2, uint64_t *a3)
{
  double v3 = *a2;
  uint64_t v14 = *a3;
  uint64_t v4 = *(void **)(a1 + 8);
  ++*v4;
  int v5 = **(_DWORD **)(a1 + 16);
  if (v5 == 2)
  {
    uint64_t v8 = *(void *)(a1 + 24);
    uint64_t v9 = *(void *)(a1 + 32);
    health::doubleToString((health *)9, v11);
    uint64_t v15 = &v14;
    uint64_t v16 = v11;
    uint64_t v17 = v4;
    uint64_t v18 = v9;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>((std::string *)"{0} \t Sample #{1} \t {2} \t {3}", &__p, 0, (uint64_t *)&v15);
    uint64_t v7 = *(void *)(v8 + 24);
    if (!v7) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  else
  {
    if (v5) {
      return 1;
    }
    uint64_t v6 = *(void *)(a1 + 24);
    health::timestampToDate(v3, v11);
    uint64_t v15 = &v14;
    uint64_t v16 = v11;
    uint64_t v17 = v4;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<long long &,std::string,double &>((std::string *)"Sample #{0} | Timestamp: {1} | Data: {2}", &__p, 0, (uint64_t *)&v15);
    uint64_t v7 = *(void *)(v6 + 24);
    if (!v7) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v7 + 48))(v7, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v12 < 0) {
    operator delete(v11[0]);
  }
  return 1;
}

void sub_1BCE1B630(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdSX_EE11target_typeEv()
{
  return &_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV0EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_;
}

void health::FormatImplementation<long long &,std::string,double &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    long long v31 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v31 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v31 = i + 2;
    int v22 = i[2];
    if ((v22 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v23 = 0;
      int v24 = i + 3;
      do
      {
        long long v31 = v24;
        uint64_t v23 = (v22 - 48) + 10 * v23;
        int v25 = *v24++;
        int v22 = v25;
      }
      while ((v25 - 58) >= 0xFFFFFFF6);
      long long v31 = v24;
      if (*(v24 - 1) == 125) {
        health::FormatterParameters<0ul,long long &,std::string,double &>::formatOptionsAtIndex<long long &,std::string,double &>(v23);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_58;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v27, (const char **)&v31);
  char v12 = v31;
  if (!*((void *)&v27 + 1))
  {
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v27);
    unint64_t v16 = HIBYTE(v33);
    if (v33 < 0) {
      unint64_t v16 = v33;
    }
    unint64_t v17 = *((void *)&v28 + 1);
    if (*((void *)&v28 + 1) <= v16) {
      unint64_t v17 = v16;
    }
    if ((_BYTE)v28) {
      unint64_t v16 = v17;
    }
    health::FormatImplementation<long long &,std::string,double &>(v12, a2, v16 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v15 = (char *)a2;
    }
    else {
      uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
LABEL_34:
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v27, &v15[a3 + v8], (const void **)&__p);
    if (SHIBYTE(v33) < 0) {
      operator delete(__p);
    }
    if (!v8) {
      return;
    }
LABEL_37:
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
    return;
  }
  if (*((void *)&v27 + 1) != 1)
  {
    if (*((void *)&v27 + 1) == 2)
    {
      health::TypeFormatter<double &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)&v27);
      unint64_t v13 = HIBYTE(v33);
      if (v33 < 0) {
        unint64_t v13 = v33;
      }
      unint64_t v14 = *((void *)&v28 + 1);
      if (*((void *)&v28 + 1) <= v13) {
        unint64_t v14 = v13;
      }
      if ((_BYTE)v28) {
        unint64_t v13 = v14;
      }
      health::FormatImplementation<long long &,std::string,double &>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = (char *)a2;
      }
      else {
        uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_34;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_58:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  uint64_t v18 = a4[1];
  std::string __p = (void *)v18;
  long long v33 = v27;
  long long v34 = v28;
  long long v35 = v29;
  uint64_t v36 = v30;
  if (*(char *)(v18 + 23) < 0) {
    unint64_t v19 = *(void *)(v18 + 8);
  }
  else {
    unint64_t v19 = *(unsigned __int8 *)(v18 + 23);
  }
  unint64_t v20 = *((void *)&v28 + 1);
  if (*((void *)&v28 + 1) <= v19) {
    unint64_t v20 = v19;
  }
  if ((_BYTE)v28) {
    unint64_t v19 = v20;
  }
  health::FormatImplementation<long long &,std::string,double &>(v31, a2, v19 + a3 + v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v21 = (char *)a2;
  }
  else {
    uint64_t v21 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v27, &v21[a3 + v8], (uint64_t)&__p);
  if (v8) {
    goto LABEL_37;
  }
}

void sub_1BCE1BA3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,std::string,double &>::formatOptionsAtIndex<long long &,std::string,double &>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1BB24(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<double &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  uint64_t v5 = v12;
  if (*(unsigned char *)(a3 + 16)) {
    *(void *)((char *)&v13[2] + *(void *)(v12 - 24)) = *(void *)(a3 + 24);
  }
  if (*(unsigned char *)(a3 + 32)) {
    *(void *)((char *)&v13[1] + *(void *)(v5 - 24)) = *(void *)(a3 + 40);
  }
  uint64_t v6 = (const std::ios_base *)((char *)&v13[-1] + *(void *)(v5 - 24));
  std::ios_base::fmtflags v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    std::string::size_type v8 = std::locale::use_facet(v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(void *)(a1 + 16) = v11;
  uint64_t v12 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v13[-1] + *(void *)(v12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v13[0] = MEMORY[0x1E4FBA470] + 16;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v15);
  return a1;
}

void sub_1BCE1BD8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0) {
    operator delete(*(void **)v13);
  }
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    long long v33 = i;
    if (*i != 123) {
      break;
    }
    int v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)&v29, (const char **)&v33);
        uint64_t v12 = v33;
        switch(*((void *)&v29 + 1))
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)&v29);
            unint64_t v13 = HIBYTE(v35);
            if (v35 < 0) {
              unint64_t v13 = v35;
            }
            unint64_t v14 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v13) {
              unint64_t v14 = v13;
            }
            if ((_BYTE)v30) {
              unint64_t v13 = v14;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_43;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v29);
            unint64_t v18 = HIBYTE(v35);
            if (v35 < 0) {
              unint64_t v18 = v35;
            }
            unint64_t v19 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v18) {
              unint64_t v19 = v18;
            }
            if ((_BYTE)v30) {
              unint64_t v18 = v19;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_43;
          case 2:
            uint64_t v16 = a4[1];
            std::string __p = (void *)v16;
            long long v35 = v29;
            long long v36 = v30;
            long long v37 = v31;
            uint64_t v38 = v32;
            if (*(char *)(v16 + 23) < 0) {
              unint64_t v17 = *(void *)(v16 + 8);
            }
            else {
              unint64_t v17 = *(unsigned __int8 *)(v16 + 23);
            }
            unint64_t v22 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v17) {
              unint64_t v22 = v17;
            }
            if ((_BYTE)v30) {
              unint64_t v17 = v22;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(v33, a2, v17 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v23 = (char *)a2;
            }
            else {
              uint64_t v23 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v29, &v23[a3 + v8], (uint64_t)&__p);
            if (!v8) {
              return;
            }
            goto LABEL_46;
          case 3:
            health::TypeFormatter<double &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)&v29);
            unint64_t v20 = HIBYTE(v35);
            if (v35 < 0) {
              unint64_t v20 = v35;
            }
            unint64_t v21 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v20) {
              unint64_t v21 = v20;
            }
            if ((_BYTE)v30) {
              unint64_t v20 = v21;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
LABEL_43:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v29, &v15[a3 + v8], (const void **)&__p);
            if (SHIBYTE(v35) < 0) {
              operator delete(__p);
            }
            if (v8) {
LABEL_46:
            }
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_65;
        }
      }
      long long v33 = i + 2;
      int v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        uint64_t v25 = 0;
        std::string v26 = i + 3;
        do
        {
          long long v33 = v26;
          uint64_t v25 = (v24 - 48) + 10 * v25;
          int v27 = *v26++;
          int v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        long long v33 = v26;
        if (*(v26 - 1) == 125) {
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,double &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(v25);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_65:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    long long v33 = i + 1;
    char v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
  {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE1C1E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,double &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,double &>(uint64_t a1)
{
  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    double v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3) {
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
    }
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1C2FC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::~__func()
{
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1F171EAA0;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171EAA0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a2[4];
  uint64_t v5 = a2[5];
  uint64_t v6 = a2[6];
  uint64_t v23 = v6;
  if (v6 < 1)
  {
    int v7 = **(_DWORD **)(a1 + 16);
    if (v6) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = v7 == 1;
    }
    if (v8)
    {
      health::FormatString<health::DataStore::ObjectIdentifier &>(&v26, (std::string *)"HFD sample history root [ID: {0}] reports an empty sample count.", *(void *)(a1 + 24));
      uint64_t v14 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v28, *(void *)(a1 + 40));
      health::DataStoreInspector::_errorHandler(v14, 2, v4, v5, (std::string::size_type)&v26, (uint64_t)v28);
      std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v28);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
      {
        unint64_t v13 = (void *)v26.__r_.__value_.__r.__words[0];
        goto LABEL_23;
      }
      goto LABEL_24;
    }
  }
  else
  {
    *(double *)(*(void *)(a1 + 8) + 40) = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::firstSampleKey(a2);
    *(double *)(*(void *)(a1 + 8) + 4_Block_object_dispose(&a9, 8) = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::lastSampleKey(a2);
    int v7 = **(_DWORD **)(a1 + 16);
  }
  if (v7 == 2)
  {
    if (!**(unsigned char **)(a1 + 48)) {
      goto LABEL_24;
    }
    uint64_t v11 = *(void *)(a1 + 40);
    std::string::basic_string[abi:ne180100]<0>(v28, "object_id \t sample_number \t timestamp \t data");
    uint64_t v12 = *(void *)(v11 + 24);
    if (!v12) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, void *))(*(void *)v12 + 48))(v12, v28);
  }
  else
  {
    if (v7) {
      goto LABEL_24;
    }
    _HDSampleHistoryDescriptionForObjectType(**(void **)(a1 + 24), v28);
    health::timestampToDate(*(double *)(*(void *)(a1 + 8) + 40), &v26);
    health::timestampToDate(*(double *)(*(void *)(a1 + 8) + 48), v24);
    uint64_t v9 = *(void *)(a1 + 40);
    health::FormatString<std::string &,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(&__p, (uint64_t)v28, *(void *)(a1 + 24), (uint64_t)&v23, (uint64_t)&v26, (uint64_t)v24);
    uint64_t v10 = *(void *)(v9 + 24);
    if (!v10) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v10 + 48))(v10, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v25 < 0) {
      operator delete(v24[0]);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
  }
  if (v29 < 0)
  {
    unint64_t v13 = (void *)v28[0];
LABEL_23:
    operator delete(v13);
  }
LABEL_24:
  uint64_t v15 = *(void *)(a1 + 56);
  uint64_t v16 = *(void *)(a1 + 40);
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  unint64_t v19 = operator new(0x28uLL);
  void *v19 = &unk_1F171EB10;
  v19[1] = v15;
  void v19[2] = v18;
  v19[3] = v16;
  void v19[4] = v17;
  int v27 = v19;
  health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::enumerateSamples(a2, (uint64_t)&v26);
  std::__function::__value_func<BOOL ()(double const&,_HDRawQuantitySampleValueV1 const&)>::~__value_func[abi:ne180100](&v26);
  unint64_t v20 = *(void **)(a1 + 56);
  *(void *)(*(void *)(a1 + 8) + 24) = *v20;
  if (**(_DWORD **)(a1 + 16) == 1 && *v20 != v23)
  {
    health::FormatString<health::DataStore::ObjectIdentifier &,long long &,long long &>(&__p, (std::string *)"HFD sample history [ID: {0}] has an actual sample count ({1}) that does not match its reported count ({2}).", *(void *)(a1 + 24), (uint64_t)v20, (uint64_t)&v23);
    uint64_t v21 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v24, *(void *)(a1 + 40));
    health::DataStoreInspector::_errorHandler(v21, 3, v4, v5, (std::string::size_type)&__p, (uint64_t)v24);
    std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1BCE1C700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<health::DataStoreInspector::DataSeriesEntry health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,BOOL)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::target_type()
{
}

double health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::firstSampleKey(void *a1)
{
  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_6;
  }
  uint64_t v1 = *(uint64_t **)(a1[11] + 24);
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[3];
  memset(v6, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v2, v3, (uint64_t)v6);
  if (!WORD4(v6[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_6:
    __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
  }
  return *(double *)v6;
}

void sub_1BCE1C904(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::lastSampleKey(void *a1)
{
  if (!a1[6])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "History contains no samples.");
    goto LABEL_11;
  }
  uint64_t v1 = *(uint64_t **)(a1[11] + 24);
  v11[0] = 0;
  v11[1] = 0;
  uint64_t v12 = v1;
  uint64_t v2 = a1[3];
  v9[0] = a1[2];
  v9[1] = v2;
  uint64_t v10 = v11;
  memset(__dst, 0, 411);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<double,health::BlockPointer,17>>(v1, v9[0], v2, (uint64_t)__dst);
  unsigned int v3 = WORD4(__dst[25]);
  if (!WORD4(__dst[25]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
    goto LABEL_11;
  }
  if (!BYTE10(__dst[25]))
  {
    int v5 = 0;
    while (WORD4(__dst[25]))
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<double,double>>::_interiorChildAtIndex((uint64_t)v9, v5, (uint64_t)__dst, (unsigned __int16)(WORD4(__dst[25]) - 1), (uint64_t)__src);
      memcpy(__dst, __src, 0x19BuLL);
      ++v5;
      if (BYTE10(__dst[25]))
      {
        unsigned int v3 = WORD4(__dst[25]);
        uint64_t v4 = (uint64_t **)(v10 + 2);
        goto LABEL_9;
      }
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Tree contains no values.");
LABEL_11:
    __cxa_throw(exception, (struct type_info *)off_1E62F22B8, MEMORY[0x1E4FBA1D0]);
  }
  uint64_t v4 = &v12;
LABEL_9:
  uint64_t v6 = health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)__dst, v3 - 1);
  memset(__src, 0, 410);
  memset(&__src[26], 0, 32);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<double,_HDRawQuantitySampleValueV1,health::BlockPointer,17>>(*v4, *(void *)(v6 + 8), *(void *)(v6 + 16), (uint64_t)__src);
  return *(double *)health::StaticArray<health::bplustree::InteriorNode<double,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)__src, WORD4(__src[25]) - 1);
}

void sub_1BCE1CB18(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EE7__cloneEv(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F171EB10;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EE7__cloneEPNS0_6__baseIS11_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171EB10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EEclESX_S10_(uint64_t a1, double *a2, long long *a3)
{
  double v3 = *a2;
  long long v14 = *a3;
  uint64_t v4 = *(void **)(a1 + 8);
  ++*v4;
  int v5 = **(_DWORD **)(a1 + 16);
  if (v5 == 2)
  {
    uint64_t v8 = *(void *)(a1 + 24);
    uint64_t v9 = *(void *)(a1 + 32);
    health::doubleToString((health *)9, v11);
    uint64_t v15 = &v14;
    uint64_t v16 = v11;
    uint64_t v17 = v4;
    uint64_t v18 = v9;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>((std::string *)"{0} \t Sample #{1} \t {2} \t {3}", &__p, 0, (uint64_t *)&v15);
    uint64_t v7 = *(void *)(v8 + 24);
    if (!v7) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  else
  {
    if (v5) {
      return 1;
    }
    uint64_t v6 = *(void *)(a1 + 24);
    health::timestampToDate(v3, v11);
    uint64_t v15 = &v14;
    uint64_t v16 = v11;
    uint64_t v17 = v4;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<long long &,std::string,_HDRawQuantitySampleValueV1 &>((std::string *)"Sample #{0} | Timestamp: {1} | Data: {2}", &__p, 0, (uint64_t *)&v15);
    uint64_t v7 = *(void *)(v6 + 24);
    if (!v7) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v7 + 48))(v7, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v12 < 0) {
    operator delete(v11[0]);
  }
  return 1;
}

void sub_1BCE1CD48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS3_15DataSeriesEntryENS2_9DataStore16ObjectIdentifierENS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEENS3_12OutputFormatEbENKUlRKNS7_13SampleHistoryIS5_EEE_clESO_EUlRKT_T0_E_NSD_ISU_EEFbRKdRK27_HDRawQuantitySampleValueV1EE11target_typeEv()
{
  return &_ZTIZZN6health18DataStoreInspector23_enumerateSampleHistoryI29QuantitySampleValueBehaviorV1EENS0_15DataSeriesEntryENS_9DataStore16ObjectIdentifierENSt3__18functionIFvRKNS6_12basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEENS0_12OutputFormatEbENKUlRKNS4_13SampleHistoryIS2_EEE_clESM_EUlRKT_T0_E_;
}

void health::FormatImplementation<long long &,std::string,_HDRawQuantitySampleValueV1 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    long long v31 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v31 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v31 = i + 2;
    int v22 = i[2];
    if ((v22 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v23 = 0;
      int v24 = i + 3;
      do
      {
        long long v31 = v24;
        uint64_t v23 = (v22 - 48) + 10 * v23;
        int v25 = *v24++;
        int v22 = v25;
      }
      while ((v25 - 58) >= 0xFFFFFFF6);
      long long v31 = v24;
      if (*(v24 - 1) == 125) {
        health::FormatterParameters<0ul,long long &,std::string,_HDRawQuantitySampleValueV1 &>::formatOptionsAtIndex<long long &,std::string,_HDRawQuantitySampleValueV1 &>(v23);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_58;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v27, (const char **)&v31);
  char v12 = v31;
  if (!*((void *)&v27 + 1))
  {
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v27);
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    std::string::size_type v17 = *((void *)&v28 + 1);
    if (*((void *)&v28 + 1) <= size) {
      std::string::size_type v17 = size;
    }
    if ((_BYTE)v28) {
      std::string::size_type size = v17;
    }
    health::FormatImplementation<long long &,std::string,_HDRawQuantitySampleValueV1 &>(v12, a2, size + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v15 = (char *)a2;
    }
    else {
      uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
LABEL_34:
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v27, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (!v8) {
      return;
    }
LABEL_37:
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
    return;
  }
  if (*((void *)&v27 + 1) != 1)
  {
    if (*((void *)&v27 + 1) == 2)
    {
      health::FormatString<double const&,float const&>(&__p, *a4, *a4 + 8);
      std::string::size_type v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v13 = __p.__r_.__value_.__l.__size_;
      }
      std::string::size_type v14 = *((void *)&v28 + 1);
      if (*((void *)&v28 + 1) <= v13) {
        std::string::size_type v14 = v13;
      }
      if ((_BYTE)v28) {
        std::string::size_type v13 = v14;
      }
      health::FormatImplementation<long long &,std::string,_HDRawQuantitySampleValueV1 &>(v12, a2, v13 + a3 + v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = (char *)a2;
      }
      else {
        uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_34;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_58:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  std::string::size_type v18 = a4[1];
  __p.__r_.__value_.__r.__words[0] = v18;
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v27;
  long long v33 = v28;
  long long v34 = v29;
  uint64_t v35 = v30;
  if (*(char *)(v18 + 23) < 0) {
    unint64_t v19 = *(void *)(v18 + 8);
  }
  else {
    unint64_t v19 = *(unsigned __int8 *)(v18 + 23);
  }
  unint64_t v20 = *((void *)&v28 + 1);
  if (*((void *)&v28 + 1) <= v19) {
    unint64_t v20 = v19;
  }
  if ((_BYTE)v28) {
    unint64_t v19 = v20;
  }
  health::FormatImplementation<long long &,std::string,_HDRawQuantitySampleValueV1 &>(v31, a2, v19 + a3 + v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v21 = (char *)a2;
  }
  else {
    uint64_t v21 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v27, &v21[a3 + v8], (uint64_t)&__p);
  if (v8) {
    goto LABEL_37;
  }
}

void sub_1BCE1D154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,std::string,_HDRawQuantitySampleValueV1 &>::formatOptionsAtIndex<long long &,std::string,_HDRawQuantitySampleValueV1 &>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1D23C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatString<double const&,float const&>(std::string *a1, uint64_t a2, uint64_t a3)
{
  v3[0] = a3;
  v3[1] = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<double const&,float const&>((std::string *)"(Value: {0}, Duration: {1})", a1, 0, v3);
}

void sub_1BCE1D2A8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<double const&,float const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    long long v27 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v27 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v27 = i + 2;
    int v18 = i[2];
    if ((v18 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v19 = 0;
      unint64_t v20 = i + 3;
      do
      {
        long long v27 = v20;
        uint64_t v19 = (v18 - 48) + 10 * v19;
        int v21 = *v20++;
        int v18 = v21;
      }
      while ((v21 - 58) >= 0xFFFFFFF6);
      long long v27 = v20;
      if (*(v20 - 1) == 125) {
        health::FormatterParameters<0ul,double const&,float const&>::formatOptionsAtIndex<double const&,float const&>(v19);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_45;
  }
  health::FormatOptions::FormatOptions((uint64_t)v23, (const char **)&v27);
  char v12 = v27;
  if (v24)
  {
    if (v24 == 1)
    {
      health::TypeFormatter<float const&,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v23);
      unint64_t v13 = v30;
      if ((v30 & 0x80u) != 0) {
        unint64_t v13 = v29;
      }
      unint64_t v14 = v26;
      if (v26 <= v13) {
        unint64_t v14 = v13;
      }
      if (v25) {
        unint64_t v13 = v14;
      }
      health::FormatImplementation<double const&,float const&>(v12, a2, v13 + a3 - v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = (char *)a2;
      }
      else {
        uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_33;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_45:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::TypeFormatter<double const&,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v23);
  unint64_t v16 = v30;
  if ((v30 & 0x80u) != 0) {
    unint64_t v16 = v29;
  }
  unint64_t v17 = v26;
  if (v26 <= v16) {
    unint64_t v17 = v16;
  }
  if (v25) {
    unint64_t v16 = v17;
  }
  health::FormatImplementation<double const&,float const&>(v12, a2, v16 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = (char *)a2;
  }
  else {
    uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
LABEL_33:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v23, &v15[a3 - v8], (const void **)&__p);
  if ((char)v30 < 0) {
    operator delete(__p);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BCE1D5BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,double const&,float const&>::formatOptionsAtIndex<double const&,float const&>(uint64_t a1)
{
  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v1 = exception;
    if (a1 == 1) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1D680(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    long long v33 = i;
    if (*i != 123) {
      break;
    }
    int v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)&v29, (const char **)&v33);
        char v12 = v33;
        switch(*((void *)&v29 + 1))
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)&v29);
            std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type size = __p.__r_.__value_.__l.__size_;
            }
            std::string::size_type v14 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= size) {
              std::string::size_type v14 = size;
            }
            if ((_BYTE)v30) {
              std::string::size_type size = v14;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(v12, a2, size + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_43;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)&v29);
            std::string::size_type v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
            }
            std::string::size_type v19 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v18) {
              std::string::size_type v19 = v18;
            }
            if ((_BYTE)v30) {
              std::string::size_type v18 = v19;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_43;
          case 2:
            std::string::size_type v16 = a4[1];
            __p.__r_.__value_.__r.__words[0] = v16;
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = v29;
            long long v35 = v30;
            long long v36 = v31;
            uint64_t v37 = v32;
            if (*(char *)(v16 + 23) < 0) {
              unint64_t v17 = *(void *)(v16 + 8);
            }
            else {
              unint64_t v17 = *(unsigned __int8 *)(v16 + 23);
            }
            unint64_t v22 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v17) {
              unint64_t v22 = v17;
            }
            if ((_BYTE)v30) {
              unint64_t v17 = v22;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(v33, a2, v17 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v23 = (char *)a2;
            }
            else {
              uint64_t v23 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,std::string>(&v29, &v23[a3 + v8], (uint64_t)&__p);
            if (!v8) {
              return;
            }
            goto LABEL_46;
          case 3:
            health::FormatString<double const&,float const&>(&__p, *a4, *a4 + 8);
            std::string::size_type v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v20 = __p.__r_.__value_.__l.__size_;
            }
            std::string::size_type v21 = *((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= v20) {
              std::string::size_type v21 = v20;
            }
            if ((_BYTE)v30) {
              std::string::size_type v20 = v21;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
LABEL_43:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v29, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            if (v8) {
LABEL_46:
            }
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_65;
        }
      }
      long long v33 = i + 2;
      int v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        uint64_t v25 = 0;
        unint64_t v26 = i + 3;
        do
        {
          long long v33 = v26;
          uint64_t v25 = (v24 - 48) + 10 * v25;
          int v27 = *v26++;
          int v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        long long v33 = v26;
        if (*(v26 - 1) == 125) {
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(v25);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_65:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    long long v33 = i + 1;
    char v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
  {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE1DAB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  __cxa_free_exception(v22);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string,_HDRawQuantitySampleValueV1 &>(uint64_t a1)
{
  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    double v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3) {
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
    }
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1DBCC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::~__func()
{
}

__n128 std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1F171EBA0;
  *(_OWORD *)(v2 + _Block_object_dispose(&a9, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171EBA0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a2;
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *a3;
  uint64_t v9 = a3[1];
  uint64_t v10 = *(uint64_t **)(a1 + 16);
  ++**(_DWORD **)(a1 + 8);
  double v53 = -1.0;
  double v54 = -1.0;
  uint64_t v52 = -1;
  switch(*a2)
  {
    case 0:
      uint64_t v11 = a2[1];
      uint64_t v12 = *v10;
      uint64_t v55 = 0;
      uint64_t v56 = v11;
      unint64_t v13 = operator new(0x20uLL);
      *unint64_t v13 = &unk_1F171EC20;
      v13[1] = &v52;
      void v13[2] = &v54;
      void v13[3] = &v53;
      long long v67 = v13;
      health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV1>(v12, (uint64_t)&v55, (uint64_t)v66);
      std::__function::__value_func<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::~__value_func[abi:ne180100](v66);
      break;
    case 1:
      uint64_t v20 = a2[1];
      uint64_t v21 = *v10;
      uint64_t v55 = 1;
      uint64_t v56 = v20;
      unint64_t v22 = operator new(0x20uLL);
      void *v22 = &unk_1F171ED20;
      v22[1] = &v52;
      void v22[2] = &v54;
      v22[3] = &v53;
      long long v67 = v22;
      health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV0>(v21, (uint64_t)&v55, (uint64_t)v66);
      std::__function::__value_func<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::~__value_func[abi:ne180100](v66);
      break;
    case 2:
      uint64_t v14 = a2[1];
      uint64_t v15 = *v10;
      uint64_t v55 = 2;
      uint64_t v56 = v14;
      std::string::size_type v16 = operator new(0x20uLL);
      void *v16 = &unk_1F171EDA0;
      v16[1] = &v52;
      void v16[2] = &v54;
      void v16[3] = &v53;
      long long v67 = v16;
      health::DataStore::accessSampleHistoryWithIdentifierForReading<QuantitySampleValueBehaviorV1>(v15, (uint64_t)&v55, (uint64_t)v66);
      std::__function::__value_func<void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::~__value_func[abi:ne180100](v66);
      break;
    case 3:
      uint64_t v17 = a2[1];
      uint64_t v18 = *v10;
      uint64_t v55 = 3;
      uint64_t v56 = v17;
      std::string::size_type v19 = operator new(0x20uLL);
      void *v19 = &unk_1F171ECA0;
      v19[1] = &v52;
      void v19[2] = &v54;
      v19[3] = &v53;
      long long v67 = v19;
      health::DataStore::accessSampleHistoryWithIdentifierForReading<LocationHistoryBehaviorV2>(v18, (uint64_t)&v55, (uint64_t)v66);
      std::__function::__value_func<void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::~__value_func[abi:ne180100](v66);
      break;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Unexpected object type");
      __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  int v23 = **(_DWORD **)(a1 + 24);
  if (v23)
  {
    if (v23 == 2)
    {
      char v27 = **(_DWORD **)(a1 + 8) == 1;
      uint64_t v29 = *v6;
      uint64_t v28 = v6[1];
      std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)&__p, *(void *)(a1 + 32));
      health::DataStoreInspector::enumerateSampleHistoryForPrinting(v10, v29, v28, (uint64_t)&__p, **(_DWORD **)(a1 + 24), v27);
      std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](&__p);
    }
    else if (v23 == 1)
    {
      uint64_t v24 = *v6;
      if ((unint64_t)*v6 >= 4)
      {
        health::FormatString<health::DataStore::ObjectIdentifier const&>((std::string *)"HFD object [ID: {0}] type is not expected", (uint64_t)v6, &__p);
        uint64_t v25 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v64, *(void *)(a1 + 32));
        health::DataStoreInspector::_errorHandler(v25, 1, v8, v9, (std::string::size_type)&__p, (uint64_t)v64);
        std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v64);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        uint64_t v24 = *v6;
      }
      *(_OWORD *)&v51.__r_.__value_.__l.__data_ = 0uLL;
      switch(v24)
      {
        case 0:
          uint64_t v26 = v6[1];
          std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v57, *(void *)(a1 + 32));
          health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV1>((uint64_t)&__p, v10, 0, v26, (uint64_t)v57, **(_DWORD **)(a1 + 24), 1);
          goto LABEL_28;
        case 1:
          uint64_t v34 = v6[1];
          std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v57, *(void *)(a1 + 32));
          health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV0>((uint64_t)&__p, v10, 1, v34, (uint64_t)v57, **(_DWORD **)(a1 + 24), 1);
          goto LABEL_28;
        case 2:
          uint64_t v32 = v6[1];
          std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v57, *(void *)(a1 + 32));
          health::DataStoreInspector::_enumerateSampleHistory<QuantitySampleValueBehaviorV1>((uint64_t)&__p, v10, 2, v32, (uint64_t)v57, **(_DWORD **)(a1 + 24), 1);
          goto LABEL_28;
        case 3:
          uint64_t v33 = v6[1];
          std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v57, *(void *)(a1 + 32));
          health::DataStoreInspector::_enumerateSampleHistory<LocationHistoryBehaviorV2>((uint64_t)&__p, v10, 3, v33, (uint64_t)v57, **(_DWORD **)(a1 + 24), 1);
LABEL_28:
          std::string v51 = __p;
          uint64_t v6 = v60;
          int v5 = v61;
          std::string::size_type v3 = v62;
          std::string::size_type v4 = v63;
          std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v57);
          break;
        default:
          break;
      }
      long long v35 = *(std::string ***)(a1 + 40);
      uint64_t v37 = v35[1];
      unint64_t v36 = (unint64_t)v35[2];
      if ((unint64_t)v37 >= v36)
      {
        size_t v39 = *v35;
        uint64_t v40 = 0x6DB6DB6DB6DB6DB7 * (((char *)v37 - (char *)*v35) >> 3);
        unint64_t v41 = v40 + 1;
        if ((unint64_t)(v40 + 1) > 0x492492492492492) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v42 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v36 - (void)v39) >> 3);
        if (2 * v42 > v41) {
          unint64_t v41 = 2 * v42;
        }
        if (v42 >= 0x249249249249249) {
          unint64_t v43 = 0x492492492492492;
        }
        else {
          unint64_t v43 = v41;
        }
        if (v43)
        {
          if (v43 > 0x492492492492492) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          std::string v44 = (char *)operator new(56 * v43);
        }
        else
        {
          std::string v44 = 0;
        }
        unint64_t v45 = (std::string *)&v44[56 * v40];
        *unint64_t v45 = v51;
        v45[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v6;
        v45[1].__r_.__value_.__l.__size_ = (std::string::size_type)v5;
        v45[1].__r_.__value_.__r.__words[2] = v3;
        v45[2].__r_.__value_.__r.__words[0] = v4;
        uint64_t v38 = (std::string *)((char *)v45 + 56);
        if (v37 != v39)
        {
          do
          {
            long long v46 = *(_OWORD *)&v37[-3].__r_.__value_.__r.__words[2];
            long long v47 = *(_OWORD *)&v37[-2].__r_.__value_.__r.__words[1];
            long long v48 = *(_OWORD *)&v37[-1].__r_.__value_.__l.__data_;
            v45[-1].__r_.__value_.__r.__words[2] = v37[-1].__r_.__value_.__r.__words[2];
            *(_OWORD *)&v45[-1].__r_.__value_.__l.__data_ = v48;
            *(_OWORD *)&v45[-2].__r_.__value_.__r.__words[1] = v47;
            *(_OWORD *)&v45[-3].__r_.__value_.__r.__words[2] = v46;
            unint64_t v45 = (std::string *)((char *)v45 - 56);
            uint64_t v37 = (std::string *)((char *)v37 - 56);
          }
          while (v37 != v39);
          uint64_t v37 = *v35;
        }
        *long long v35 = v45;
        v35[1] = v38;
        void v35[2] = (std::string *)&v44[56 * v43];
        if (v37) {
          operator delete(v37);
        }
      }
      else
      {
        *uint64_t v37 = v51;
        v37[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v6;
        v37[1].__r_.__value_.__l.__size_ = (std::string::size_type)v5;
        v37[1].__r_.__value_.__r.__words[2] = v3;
        v37[2].__r_.__value_.__r.__words[0] = v4;
        uint64_t v38 = (std::string *)((char *)v37 + 56);
      }
      v35[1] = v38;
    }
  }
  else
  {
    _HDSampleHistoryDescriptionForObjectType(*v6, v64);
    health::timestampToDate(v54, v57);
    health::timestampToDate(v53, &v51);
    uint64_t v30 = *(void *)(a1 + 32);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)v57;
    __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v52;
    uint64_t v60 = v6;
    char v61 = v64;
    memset(&v50, 0, sizeof(v50));
    health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>((std::string *)"'{0}' [ID: {1} | Count: {2} | {3} to {4}]", &v50, 0, (uint64_t *)&__p);
    uint64_t v31 = *(void *)(v30 + 24);
    if (!v31) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v31 + 48))(v31, &v50);
    if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v50.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v51.__r_.__value_.__l.__data_);
    }
    if (v58 < 0) {
      operator delete(v57[0]);
    }
    if (v65 < 0) {
      operator delete(v64[0]);
    }
  }
}

void sub_1BCE1E358(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](&a27);
  if (a2 == 2)
  {
    unint64_t v43 = __cxa_begin_catch(a1);
    uint64_t v44 = *v40;
    uint64_t v45 = v40[1];
    uint64_t v46 = std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)&__p, *(void *)(v39 + 32));
    health::DataStoreInspector::_unknownBehaviorHandler(v46, v44, v45, (uint64_t)v43, (uint64_t)&__p);
    std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](&__p);
    __cxa_end_catch();
    JUMPOUT(0x1BCE1E188);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1,std::allocator<health::DataStoreInspector::enumerateStoreForPrinting(std::function<void ()(std::string const&)>,health::DataStoreInspector::OutputFormat,std::vector<health::DataStoreInspector::DataSeriesEntry> *)::$_1>,void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::target_type()
{
}

void health::FormatString<health::DataStore::ObjectIdentifier const&>(std::string *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v3 = a2;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<health::DataStore::ObjectIdentifier const&>(a1, a3, 0, &v3);
}

void sub_1BCE1E5D8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::~__func()
{
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F171EC20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171EC20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v3 = a2[6];
  **(void **)(a1 + _Block_object_dispose(&a9, 8) = v3;
  if (v3 <= 0)
  {
    **(void **)(a1 + 16) = 0;
    goto LABEL_5;
  }
  double SampleKey = health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::firstSampleKey(a2);
  uint64_t v6 = **(void **)(a1 + 8);
  **(double **)(a1 + 16) = SampleKey;
  if (v6 < 1)
  {
LABEL_5:
    double v7 = 0.0;
    goto LABEL_6;
  }
  double v7 = health::DataStore::SampleHistory<LocationHistoryBehaviorV1>::lastSampleKey(a2);
LABEL_6:
  **(double **)(a1 + 24) = v7;
}

uint64_t std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV1> const&)>::target_type()
{
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::~__func()
{
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F171ECA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171ECA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v3 = a2[6];
  **(void **)(a1 + _Block_object_dispose(&a9, 8) = v3;
  if (v3 <= 0)
  {
    **(void **)(a1 + 16) = 0;
    goto LABEL_5;
  }
  double SampleKey = health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::firstSampleKey(a2);
  uint64_t v6 = **(void **)(a1 + 8);
  **(double **)(a1 + 16) = SampleKey;
  if (v6 < 1)
  {
LABEL_5:
    double v7 = 0.0;
    goto LABEL_6;
  }
  double v7 = health::DataStore::SampleHistory<LocationHistoryBehaviorV2>::lastSampleKey(a2);
LABEL_6:
  **(double **)(a1 + 24) = v7;
}

uint64_t std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<LocationHistoryBehaviorV2>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)#1}>,void ()(health::DataStore::SampleHistory<LocationHistoryBehaviorV2> const&)>::target_type()
{
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::~__func()
{
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F171ED20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171ED20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v3 = a2[6];
  **(void **)(a1 + _Block_object_dispose(&a9, 8) = v3;
  if (v3 <= 0)
  {
    **(void **)(a1 + 16) = 0;
    goto LABEL_5;
  }
  double SampleKey = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::firstSampleKey(a2);
  uint64_t v6 = **(void **)(a1 + 8);
  **(double **)(a1 + 16) = SampleKey;
  if (v6 < 1)
  {
LABEL_5:
    double v7 = 0.0;
    goto LABEL_6;
  }
  double v7 = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0>::lastSampleKey(a2);
LABEL_6:
  **(double **)(a1 + 24) = v7;
}

uint64_t std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV0>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV0> const&)>::target_type()
{
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::~__func()
{
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F171EDA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(&a9, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F171EDA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(&a9, 8) = result;
  return result;
}

void std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v3 = a2[6];
  **(void **)(a1 + _Block_object_dispose(&a9, 8) = v3;
  if (v3 <= 0)
  {
    **(void **)(a1 + 16) = 0;
    goto LABEL_5;
  }
  double SampleKey = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::firstSampleKey(a2);
  uint64_t v6 = **(void **)(a1 + 8);
  **(double **)(a1 + 16) = SampleKey;
  if (v6 < 1)
  {
LABEL_5:
    double v7 = 0.0;
    goto LABEL_6;
  }
  double v7 = health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1>::lastSampleKey(a2);
LABEL_6:
  **(double **)(a1 + 24) = v7;
}

uint64_t std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1},std::allocator<void health::DataStoreInspector::_getSampleHistoryStats<QuantitySampleValueBehaviorV1>(health::DataStore::ObjectIdentifier,double &,double &,long long &)::{lambda(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)#1}>,void ()(health::DataStore::SampleHistory<QuantitySampleValueBehaviorV1> const&)>::target_type()
{
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier const&>(std::string *a1, std::string *this, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    std::string::size_type v19 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(this, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    std::string::size_type v19 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    std::string::size_type v19 = i + 2;
    int v12 = i[2];
    if ((v12 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v13 = 0;
      uint64_t v14 = i + 3;
      do
      {
        std::string::size_type v19 = v14;
        uint64_t v13 = (v12 - 48) + 10 * v13;
        int v15 = *v14++;
        int v12 = v15;
      }
      while ((v15 - 58) >= 0xFFFFFFF6);
      std::string::size_type v19 = v14;
      if (*(v14 - 1) == 125) {
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&>((uint64_t)a4, (uint64_t)a4, v13);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v17, (const char **)&v19);
  health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>::formatParameterAtIndex<health::DataStore::ObjectIdentifier const&>(a4, (uint64_t)a4, v18, v17, this, a3 - v8, (int)v19);
  if (v8) {
    health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
  }
}

void sub_1BCE1ED94(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    health::FormatterParameters<1ul>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&>();
  }
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1EE14(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>::formatParameterAtIndex<health::DataStore::ObjectIdentifier const&>(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned char *a4, std::string *a5, uint64_t a6, int a7)
{
  if (a3)
  {
    health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>>();
  }
  health::TypeFormatter<health::DataStore::ObjectIdentifier const&,void>::TypeFormatter((uint64_t)&__p, *a1, (uint64_t)a4);
  health::FormatImplementation<health::DataStore::ObjectIdentifier const&>(a7, a5);
  if ((a5->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v11 = (char *)a5;
  }
  else {
    int v11 = (char *)a5->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(a4, &v11[a6], (const void **)&__p);
  if (v13 < 0) {
    operator delete(__p);
  }
}

void sub_1BCE1EF30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatterParameters<1ul>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1EF98(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<1ul>::formatParameterAtIndex<health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&>>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1EFF4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<health::DataStore::ObjectIdentifier const&,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  uint64_t v5 = v12;
  if (*(unsigned char *)(a3 + 16)) {
    *(void *)((char *)&v13[2] + *(void *)(v12 - 24)) = *(void *)(a3 + 24);
  }
  if (*(unsigned char *)(a3 + 32)) {
    *(void *)((char *)&v13[1] + *(void *)(v5 - 24)) = *(void *)(a3 + 40);
  }
  uint64_t v6 = (const std::ios_base *)((char *)&v13[-1] + *(void *)(v5 - 24));
  std::ios_base::fmtflags v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    uint64_t v8 = std::locale::use_facet(v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  health::operator<<(&v12);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(void *)(a1 + 16) = v11;
  uint64_t v12 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v13[-1] + *(void *)(v12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v13[0] = MEMORY[0x1E4FBA470] + 16;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v15);
  return a1;
}

void sub_1BCE1F250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0) {
    operator delete(*(void **)v13);
  }
  _Unwind_Resume(a1);
}

void health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    uint64_t v33 = i;
    if (*i != 123) {
      break;
    }
    int v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)v29, (const char **)&v33);
        uint64_t v12 = v33;
        switch(v30)
        {
          case 0:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[4], (uint64_t)v29);
            unint64_t v13 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v13 = v35;
            }
            unint64_t v14 = v32;
            if (v32 <= v13) {
              unint64_t v14 = v13;
            }
            if (v31) {
              unint64_t v13 = v14;
            }
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_59;
          case 1:
            health::TypeFormatter<health::DataStore::ObjectIdentifier const&,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v29);
            unint64_t v16 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v16 = v35;
            }
            unint64_t v17 = v32;
            if (v32 <= v16) {
              unint64_t v17 = v16;
            }
            if (v31) {
              unint64_t v16 = v17;
            }
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v12, a2, v16 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_59;
          case 2:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v29);
            unint64_t v18 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v18 = v35;
            }
            unint64_t v19 = v32;
            if (v32 <= v18) {
              unint64_t v19 = v18;
            }
            if (v31) {
              unint64_t v18 = v19;
            }
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_59;
          case 3:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v29);
            unint64_t v20 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v20 = v35;
            }
            unint64_t v21 = v32;
            if (v32 <= v20) {
              unint64_t v21 = v20;
            }
            if (v31) {
              unint64_t v20 = v21;
            }
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_59;
          case 4:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v29);
            unint64_t v22 = v36;
            if ((v36 & 0x80u) != 0) {
              unint64_t v22 = v35;
            }
            unint64_t v23 = v32;
            if (v32 <= v22) {
              unint64_t v23 = v22;
            }
            if (v31) {
              unint64_t v22 = v23;
            }
            health::FormatImplementation<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v12, a2, v22 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v15 = (char *)a2;
            }
            else {
              uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
LABEL_59:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v29, &v15[a3 + v8], (const void **)&__p);
            if ((char)v36 < 0) {
              operator delete(__p);
            }
            if (v8) {
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            }
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_71;
        }
      }
      uint64_t v33 = i + 2;
      int v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        uint64_t v25 = 0;
        uint64_t v26 = i + 3;
        do
        {
          uint64_t v33 = v26;
          uint64_t v25 = (v24 - 48) + 10 * v25;
          int v27 = *v26++;
          int v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        uint64_t v33 = v26;
        if (*(v26 - 1) == 125) {
          health::FormatterParameters<0ul,std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>::formatOptionsAtIndex<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(v25);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_71:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    uint64_t v33 = i + 1;
    char v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
  {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE1F704(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>::formatOptionsAtIndex<std::string &,health::DataStore::ObjectIdentifier const&,long long &,std::string &,std::string &>(uint64_t a1)
{
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
      break;
    default:
      uint64_t v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      exception = v3;
      if (a1 == 4) {
        std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
      }
      else {
        std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
      }
      break;
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1F878(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void health::FormatImplementation<int &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    uint64_t v25 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    uint64_t v25 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    uint64_t v25 = i + 2;
    int v16 = i[2];
    if ((v16 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v17 = 0;
      unint64_t v18 = i + 3;
      do
      {
        uint64_t v25 = v18;
        uint64_t v17 = (v16 - 48) + 10 * v17;
        int v19 = *v18++;
        int v16 = v19;
      }
      while ((v19 - 58) >= 0xFFFFFFF6);
      uint64_t v25 = v18;
      if (*(v18 - 1) == 125) {
        health::FormatterParameters<0ul,int &>::formatOptionsAtIndex<int &>(v17);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_35:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v21, (const char **)&v25);
  if (v22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    goto LABEL_35;
  }
  uint64_t v12 = v25;
  health::TypeFormatter<int &,void>::TypeFormatter((uint64_t)__p, *a4, (uint64_t)v21);
  unint64_t v13 = v27;
  if ((v27 & 0x80u) != 0) {
    unint64_t v13 = (unint64_t)__p[1];
  }
  unint64_t v14 = v24;
  if (v24 <= v13) {
    unint64_t v14 = v13;
  }
  if (v23) {
    unint64_t v13 = v14;
  }
  health::FormatImplementation<int &>(v12, a2, v13 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = (char *)a2;
  }
  else {
    uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v21, &v15[a3 - v8], (const void **)__p);
  if ((char)v27 < 0) {
    operator delete(__p[0]);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BCE1FBA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,int &>::formatOptionsAtIndex<int &>(uint64_t a1)
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  uint64_t v3 = exception;
  if (a1) {
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else {
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v3, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE1FC48(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<int &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  uint64_t v5 = v12;
  if (*(unsigned char *)(a3 + 16)) {
    *(void *)((char *)&v13[2] + *(void *)(v12 - 24)) = *(void *)(a3 + 24);
  }
  if (*(unsigned char *)(a3 + 32)) {
    *(void *)((char *)&v13[1] + *(void *)(v5 - 24)) = *(void *)(a3 + 40);
  }
  uint64_t v6 = (const std::ios_base *)((char *)&v13[-1] + *(void *)(v5 - 24));
  std::ios_base::fmtflags v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    uint64_t v8 = std::locale::use_facet(v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(void *)(a1 + 16) = v11;
  uint64_t v12 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v13[-1] + *(void *)(v12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v13[0] = MEMORY[0x1E4FBA470] + 16;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v15);
  return a1;
}

void sub_1BCE1FEA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0) {
    operator delete(*(void **)v13);
  }
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,health::DataStoreInspector::DataSeriesEntry>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t **a1, unint64_t a2, void *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        std::ios_base::fmtflags v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    std::ios_base::fmtflags v7 = a1 + 1;
LABEL_9:
    char v9 = (char *)operator new(0x60uLL);
    *((void *)v9 + 4) = *a3;
    *(_OWORD *)(v9 + 40) = 0u;
    *(_OWORD *)(v9 + 56) = 0u;
    *(_OWORD *)(v9 + 72) = 0u;
    *((void *)v9 + 11) = 0;
    std::__tree<unsigned long long>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t *std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t *result, unint64_t a2, uint64_t a3)
{
  std::string::size_type v4 = (uint64_t **)result;
  uint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        std::ios_base::fmtflags v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    std::ios_base::fmtflags v7 = (uint64_t **)(result + 1);
LABEL_9:
    char v9 = (uint64_t *)operator new(0x28uLL);
    void v9[4] = a3;
    return std::__tree<unsigned long long>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

uint64_t std::map<unsigned long long,health::DataStoreInspector::DataSeriesEntry>::map[abi:ne180100](uint64_t a1, void *a2)
{
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  uint64_t v3 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  std::string::size_type v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      unint64_t v6 = v5[4];
      uint64_t v7 = *(void *)(a1 + 8);
      unint64_t v8 = v3;
      if (*(void **)a1 == v3) {
        goto LABEL_8;
      }
      char v9 = *(void **)(a1 + 8);
      uint64_t v10 = v3;
      if (v7)
      {
        do
        {
          unint64_t v8 = v9;
          char v9 = (void *)v9[1];
        }
        while (v9);
      }
      else
      {
        do
        {
          unint64_t v8 = (void *)v10[2];
          BOOL v11 = *v8 == (void)v10;
          uint64_t v10 = v8;
        }
        while (v11);
      }
      if (v8[4] < v6)
      {
LABEL_8:
        if (v7) {
          uint64_t v12 = (uint64_t **)v8;
        }
        else {
          uint64_t v12 = (uint64_t **)v3;
        }
        if (v7) {
          uint64_t v13 = (uint64_t **)(v8 + 1);
        }
        else {
          uint64_t v13 = (uint64_t **)v3;
        }
        if (*v13) {
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v13 = (uint64_t **)v3;
        uint64_t v12 = (uint64_t **)v3;
        if (v7)
        {
          char v14 = *(uint64_t **)(a1 + 8);
          while (1)
          {
            while (1)
            {
              uint64_t v12 = (uint64_t **)v14;
              unint64_t v15 = v14[4];
              if (v15 <= v6) {
                break;
              }
              char v14 = *v12;
              uint64_t v13 = v12;
              if (!*v12) {
                goto LABEL_24;
              }
            }
            if (v15 >= v6) {
              goto LABEL_25;
            }
            char v14 = v12[1];
            if (!v14)
            {
              uint64_t v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_24:
      int v16 = (uint64_t *)operator new(0x60uLL);
      long long v17 = *((_OWORD *)v5 + 2);
      long long v18 = *((_OWORD *)v5 + 3);
      long long v19 = *((_OWORD *)v5 + 5);
      *((_OWORD *)v16 + 4) = *((_OWORD *)v5 + 4);
      *((_OWORD *)v16 + 5) = v19;
      *((_OWORD *)v16 + 2) = v17;
      *((_OWORD *)v16 + 3) = v18;
      std::__tree<unsigned long long>::__insert_node_at((uint64_t **)a1, (uint64_t)v12, v13, v16);
LABEL_25:
      unint64_t v20 = (void *)v5[1];
      if (v20)
      {
        do
        {
          unint64_t v21 = v20;
          unint64_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          unint64_t v21 = (void *)v5[2];
          BOOL v11 = *v21 == (void)v5;
          uint64_t v5 = v21;
        }
        while (!v11);
      }
      uint64_t v5 = v21;
    }
    while (v21 != v4);
  }
  return a1;
}

void sub_1BCE201CC(_Unwind_Exception *a1)
{
  std::__tree<long>::destroy(v1);
  _Unwind_Resume(a1);
}

uint64_t std::set<unsigned long long>::set[abi:ne180100](uint64_t a1, void *a2)
{
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  uint64_t v3 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  std::string::size_type v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t **)a1, v3, v5[4], v5[4]);
      unint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          unint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
    }
    while (v7 != v4);
  }
  return a1;
}

void sub_1BCE20278(_Unwind_Exception *a1)
{
  std::__tree<long>::destroy(*v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    uint64_t v29 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    uint64_t v29 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    uint64_t v29 = i + 2;
    int v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v21 = 0;
      uint64_t v22 = i + 3;
      do
      {
        uint64_t v29 = v22;
        uint64_t v21 = (v20 - 48) + 10 * v21;
        int v23 = *v22++;
        int v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      uint64_t v29 = v22;
      if (*(v22 - 1) == 125) {
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,long long &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,long long &>(v21);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_55;
  }
  health::FormatOptions::FormatOptions((uint64_t)v25, (const char **)&v29);
  uint64_t v12 = v29;
  if (v26)
  {
    if (v26 != 1)
    {
      if (v26 == 2)
      {
        health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v25);
        unint64_t v13 = v32;
        if ((v32 & 0x80u) != 0) {
          unint64_t v13 = v31;
        }
        unint64_t v14 = v28;
        if (v28 <= v13) {
          unint64_t v14 = v13;
        }
        if (v27) {
          unint64_t v13 = v14;
        }
        health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,long long &>(v12, a2, v13 + a3 + v8, a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v15 = (char *)a2;
        }
        else {
          unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
        }
        goto LABEL_43;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_55:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v25);
    unint64_t v18 = v32;
    if ((v32 & 0x80u) != 0) {
      unint64_t v18 = v31;
    }
    unint64_t v19 = v28;
    if (v28 <= v18) {
      unint64_t v19 = v18;
    }
    if (v27) {
      unint64_t v18 = v19;
    }
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,long long &>(v12, a2, v18 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v15 = (char *)a2;
    }
    else {
      unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
  else
  {
    health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v25);
    unint64_t v16 = v32;
    if ((v32 & 0x80u) != 0) {
      unint64_t v16 = v31;
    }
    unint64_t v17 = v28;
    if (v28 <= v16) {
      unint64_t v17 = v16;
    }
    if (v27) {
      unint64_t v16 = v17;
    }
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,long long &>(v12, a2, v16 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v15 = (char *)a2;
    }
    else {
      unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
LABEL_43:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v25, &v15[a3 + v8], (const void **)&__p);
  if ((char)v32 < 0) {
    operator delete(__p);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE205FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,long long &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,long long &>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE206EC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    uint64_t v29 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    uint64_t v29 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    uint64_t v29 = i + 2;
    int v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v21 = 0;
      uint64_t v22 = i + 3;
      do
      {
        uint64_t v29 = v22;
        uint64_t v21 = (v20 - 48) + 10 * v21;
        int v23 = *v22++;
        int v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      uint64_t v29 = v22;
      if (*(v22 - 1) == 125) {
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,std::string &,std::string &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(v21);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_55;
  }
  health::FormatOptions::FormatOptions((uint64_t)v25, (const char **)&v29);
  uint64_t v12 = v29;
  if (v26)
  {
    if (v26 != 1)
    {
      if (v26 == 2)
      {
        health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v25);
        unint64_t v13 = v32;
        if ((v32 & 0x80u) != 0) {
          unint64_t v13 = v31;
        }
        unint64_t v14 = v28;
        if (v28 <= v13) {
          unint64_t v14 = v13;
        }
        if (v27) {
          unint64_t v13 = v14;
        }
        health::FormatImplementation<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(v12, a2, v13 + a3 + v8, a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v15 = (char *)a2;
        }
        else {
          unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
        }
        goto LABEL_43;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_55:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v25);
    unint64_t v18 = v32;
    if ((v32 & 0x80u) != 0) {
      unint64_t v18 = v31;
    }
    unint64_t v19 = v28;
    if (v28 <= v18) {
      unint64_t v19 = v18;
    }
    if (v27) {
      unint64_t v18 = v19;
    }
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(v12, a2, v18 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v15 = (char *)a2;
    }
    else {
      unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
  else
  {
    health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v25);
    unint64_t v16 = v32;
    if ((v32 & 0x80u) != 0) {
      unint64_t v16 = v31;
    }
    unint64_t v17 = v28;
    if (v28 <= v16) {
      unint64_t v17 = v16;
    }
    if (v27) {
      unint64_t v16 = v17;
    }
    health::FormatImplementation<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(v12, a2, v16 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v15 = (char *)a2;
    }
    else {
      unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
LABEL_43:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v25, &v15[a3 + v8], (const void **)&__p);
  if ((char)v32 < 0) {
    operator delete(__p);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE20A7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,std::string &,std::string &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,std::string &,std::string &>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE20B6C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    unint64_t v31 = i;
    if (*i != 123) {
      break;
    }
    int v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)v27, (const char **)&v31);
        uint64_t v12 = v31;
        switch(v28)
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v27);
            unint64_t v13 = v34;
            if ((v34 & 0x80u) != 0) {
              unint64_t v13 = v33;
            }
            unint64_t v14 = v30;
            if (v30 <= v13) {
              unint64_t v14 = v13;
            }
            if (v29) {
              unint64_t v13 = v14;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v15 = (char *)a2;
            }
            else {
              unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_50;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v27);
            unint64_t v18 = v34;
            if ((v34 & 0x80u) != 0) {
              unint64_t v18 = v33;
            }
            unint64_t v19 = v30;
            if (v30 <= v18) {
              unint64_t v19 = v18;
            }
            if (v29) {
              unint64_t v18 = v19;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v15 = (char *)a2;
            }
            else {
              unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_50;
          case 2:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v27);
            unint64_t v16 = v34;
            if ((v34 & 0x80u) != 0) {
              unint64_t v16 = v33;
            }
            unint64_t v17 = v30;
            if (v30 <= v16) {
              unint64_t v17 = v16;
            }
            if (v29) {
              unint64_t v16 = v17;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v16 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v15 = (char *)a2;
            }
            else {
              unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_50;
          case 3:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v27);
            unint64_t v20 = v34;
            if ((v34 & 0x80u) != 0) {
              unint64_t v20 = v33;
            }
            unint64_t v21 = v30;
            if (v30 <= v20) {
              unint64_t v21 = v20;
            }
            if (v29) {
              unint64_t v20 = v21;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v15 = (char *)a2;
            }
            else {
              unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
LABEL_50:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v27, &v15[a3 + v8], (const void **)&__p);
            if ((char)v34 < 0) {
              operator delete(__p);
            }
            if (v8) {
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            }
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_62;
        }
      }
      unint64_t v31 = i + 2;
      int v22 = i[2];
      if ((v22 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        uint64_t v23 = 0;
        unint64_t v24 = i + 3;
        do
        {
          unint64_t v31 = v24;
          uint64_t v23 = (v22 - 48) + 10 * v23;
          int v25 = *v24++;
          int v22 = v25;
        }
        while ((v25 - 58) >= 0xFFFFFFF6);
        unint64_t v31 = v24;
        if (*(v24 - 1) == 125) {
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(v23);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_62:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    unint64_t v31 = i + 1;
    char v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
  {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE20F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &>(uint64_t a1)
{
  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    uint64_t v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3) {
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
    }
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE210B0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    unint64_t v35 = i;
    if (*i != 123) {
      break;
    }
    int v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)v31, (const char **)&v35);
        uint64_t v12 = v35;
        switch(v32)
        {
          case 0:
            health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, a4[5], (uint64_t)v31);
            unint64_t v13 = v38;
            if ((v38 & 0x80u) != 0) {
              unint64_t v13 = v37;
            }
            unint64_t v14 = v34;
            if (v34 <= v13) {
              unint64_t v14 = v13;
            }
            if (v33) {
              unint64_t v13 = v14;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v15 = (char *)a2;
            }
            else {
              unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_68;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[4], (uint64_t)v31);
            unint64_t v16 = v38;
            if ((v38 & 0x80u) != 0) {
              unint64_t v16 = v37;
            }
            unint64_t v17 = v34;
            if (v34 <= v16) {
              unint64_t v17 = v16;
            }
            if (v33) {
              unint64_t v16 = v17;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v16 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v15 = (char *)a2;
            }
            else {
              unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_68;
          case 2:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v31);
            unint64_t v18 = v38;
            if ((v38 & 0x80u) != 0) {
              unint64_t v18 = v37;
            }
            unint64_t v19 = v34;
            if (v34 <= v18) {
              unint64_t v19 = v18;
            }
            if (v33) {
              unint64_t v18 = v19;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v15 = (char *)a2;
            }
            else {
              unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_68;
          case 3:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v31);
            unint64_t v20 = v38;
            if ((v38 & 0x80u) != 0) {
              unint64_t v20 = v37;
            }
            unint64_t v21 = v34;
            if (v34 <= v20) {
              unint64_t v21 = v20;
            }
            if (v33) {
              unint64_t v20 = v21;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v15 = (char *)a2;
            }
            else {
              unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_68;
          case 4:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v31);
            unint64_t v22 = v38;
            if ((v38 & 0x80u) != 0) {
              unint64_t v22 = v37;
            }
            unint64_t v23 = v34;
            if (v34 <= v22) {
              unint64_t v23 = v22;
            }
            if (v33) {
              unint64_t v22 = v23;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v22 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v15 = (char *)a2;
            }
            else {
              unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_68;
          case 5:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v31);
            unint64_t v24 = v38;
            if ((v38 & 0x80u) != 0) {
              unint64_t v24 = v37;
            }
            unint64_t v25 = v34;
            if (v34 <= v24) {
              unint64_t v25 = v24;
            }
            if (v33) {
              unint64_t v24 = v25;
            }
            health::FormatImplementation<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v12, a2, v24 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v15 = (char *)a2;
            }
            else {
              unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
LABEL_68:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v31, &v15[a3 + v8], (const void **)&__p);
            if ((char)v38 < 0) {
              operator delete(__p);
            }
            if (v8) {
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            }
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_80;
        }
      }
      unint64_t v35 = i + 2;
      int v26 = i[2];
      if ((v26 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        uint64_t v27 = 0;
        uint64_t v28 = i + 3;
        do
        {
          unint64_t v35 = v28;
          uint64_t v27 = (v26 - 48) + 10 * v27;
          int v29 = *v28++;
          int v26 = v29;
        }
        while ((v29 - 58) >= 0xFFFFFFF6);
        unint64_t v35 = v28;
        if (*(v28 - 1) == 125) {
          health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(v27);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_80:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    unint64_t v35 = i + 1;
    char v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
  {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE215C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,long long &,std::string &,std::string &,std::string &,long long &>(uint64_t a1)
{
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
      break;
    default:
      uint64_t v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      exception = v3;
      if (a1 == 5) {
        std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
      }
      else {
        std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
      }
      break;
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE21758(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier &,char const*>(std::string *a1, std::string *a2, std::string::size_type a3, char ***a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    int v29 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    int v29 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    int v29 = i + 2;
    int v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v21 = 0;
      unint64_t v22 = i + 3;
      do
      {
        int v29 = v22;
        uint64_t v21 = (v20 - 48) + 10 * v21;
        int v23 = *v22++;
        int v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      int v29 = v22;
      if (*(v22 - 1) == 125) {
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,char const*>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,char const*>(v21);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_47;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v25, (const char **)&v29);
  uint64_t v12 = v29;
  if (*((void *)&v25 + 1))
  {
    if (*((void *)&v25 + 1) == 1)
    {
      unint64_t v13 = **a4;
      std::string __p = v13;
      if (v13) {
        unint64_t v13 = (char *)strlen(v13);
      }
      unint64_t v31 = v13;
      long long v32 = v25;
      long long v33 = v26;
      long long v34 = v27;
      uint64_t v35 = v28;
      unint64_t v14 = (char *)*((void *)&v26 + 1);
      if (*((void *)&v26 + 1) <= (unint64_t)v13) {
        unint64_t v14 = v13;
      }
      if ((_BYTE)v26) {
        unint64_t v15 = v14;
      }
      else {
        unint64_t v15 = v13;
      }
      health::FormatImplementation<health::DataStore::ObjectIdentifier &,char const*>(v29, a2, &v15[a3 - v8], a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v16 = a2;
      }
      else {
        unint64_t v16 = (std::string *)a2->__r_.__value_.__r.__words[0];
      }
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(&v25, (unsigned char *)v16 + a3 - v8, (uint64_t)&__p);
      goto LABEL_37;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_47:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::TypeFormatter<health::DataStore::ObjectIdentifier &,void>::TypeFormatter((uint64_t)&__p, (uint64_t)a4[1], (uint64_t)&v25);
  unint64_t v17 = (char *)BYTE7(v32);
  if (SBYTE7(v32) < 0) {
    unint64_t v17 = v31;
  }
  unint64_t v18 = (char *)*((void *)&v26 + 1);
  if (*((void *)&v26 + 1) <= (unint64_t)v17) {
    unint64_t v18 = v17;
  }
  if ((_BYTE)v26) {
    unint64_t v17 = v18;
  }
  health::FormatImplementation<health::DataStore::ObjectIdentifier &,char const*>(v12, a2, &v17[a3 - v8], a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v19 = (char *)a2;
  }
  else {
    unint64_t v19 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v25, &v19[a3 - v8], (const void **)&__p);
  if (SBYTE7(v32) < 0) {
    operator delete(__p);
  }
LABEL_37:
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BCE21AA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier &,char const*>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier &,char const*>(uint64_t a1)
{
  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v1 = exception;
    if (a1 == 1) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE21B64(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<std::string &,std::string const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    long long v27 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v27 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v27 = i + 2;
    int v18 = i[2];
    if ((v18 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v19 = 0;
      int v20 = i + 3;
      do
      {
        long long v27 = v20;
        uint64_t v19 = (v18 - 48) + 10 * v19;
        int v21 = *v20++;
        int v18 = v21;
      }
      while ((v21 - 58) >= 0xFFFFFFF6);
      long long v27 = v20;
      if (*(v20 - 1) == 125) {
        health::FormatterParameters<0ul,std::string &,std::string const&>::formatOptionsAtIndex<std::string &,std::string const&>(v19);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_45;
  }
  health::FormatOptions::FormatOptions((uint64_t)v23, (const char **)&v27);
  uint64_t v12 = v27;
  if (v24)
  {
    if (v24 == 1)
    {
      health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v23);
      unint64_t v13 = v30;
      if ((v30 & 0x80u) != 0) {
        unint64_t v13 = v29;
      }
      unint64_t v14 = v26;
      if (v26 <= v13) {
        unint64_t v14 = v13;
      }
      if (v25) {
        unint64_t v13 = v14;
      }
      health::FormatImplementation<std::string &,std::string const&>(v12, a2, v13 + a3 - v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v15 = (char *)a2;
      }
      else {
        unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_33;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_45:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v23);
  unint64_t v16 = v30;
  if ((v30 & 0x80u) != 0) {
    unint64_t v16 = v29;
  }
  unint64_t v17 = v26;
  if (v26 <= v16) {
    unint64_t v17 = v16;
  }
  if (v25) {
    unint64_t v16 = v17;
  }
  health::FormatImplementation<std::string &,std::string const&>(v12, a2, v16 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v15 = (char *)a2;
  }
  else {
    unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
LABEL_33:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v23, &v15[a3 - v8], (const void **)&__p);
  if ((char)v30 < 0) {
    operator delete(__p);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BCE21E78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &,std::string const&>::formatOptionsAtIndex<std::string &,std::string const&>(uint64_t a1)
{
  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v1 = exception;
    if (a1 == 1) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE21F44(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<std::string &,health::BlockPointer &,std::string const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    unint64_t v29 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    unint64_t v29 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    unint64_t v29 = i + 2;
    int v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v21 = 0;
      unint64_t v22 = i + 3;
      do
      {
        unint64_t v29 = v22;
        uint64_t v21 = (v20 - 48) + 10 * v21;
        int v23 = *v22++;
        int v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      unint64_t v29 = v22;
      if (*(v22 - 1) == 125) {
        health::FormatterParameters<0ul,std::string &,health::BlockPointer &,std::string const&>::formatOptionsAtIndex<std::string &,health::BlockPointer &,std::string const&>(v21);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_55;
  }
  health::FormatOptions::FormatOptions((uint64_t)v25, (const char **)&v29);
  uint64_t v12 = v29;
  if (v26)
  {
    if (v26 != 1)
    {
      if (v26 == 2)
      {
        health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v25);
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
        }
        std::string::size_type v14 = v28;
        if (v28 <= size) {
          std::string::size_type v14 = size;
        }
        if (v27) {
          std::string::size_type size = v14;
        }
        health::FormatImplementation<std::string &,health::BlockPointer &,std::string const&>(v12, a2, size + a3 + v8, a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v15 = (char *)a2;
        }
        else {
          unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
        }
        goto LABEL_43;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_55:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    health::FormatString<unsigned long long const&,unsigned long long const&>((std::string *)"({0}: {1})", a4[1], a4[1] + 8, &__p);
    std::string::size_type v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
    }
    std::string::size_type v19 = v28;
    if (v28 <= v18) {
      std::string::size_type v19 = v18;
    }
    if (v27) {
      std::string::size_type v18 = v19;
    }
    health::FormatImplementation<std::string &,health::BlockPointer &,std::string const&>(v12, a2, v18 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v15 = (char *)a2;
    }
    else {
      unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
  else
  {
    health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v25);
    std::string::size_type v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v16 = __p.__r_.__value_.__l.__size_;
    }
    std::string::size_type v17 = v28;
    if (v28 <= v16) {
      std::string::size_type v17 = v16;
    }
    if (v27) {
      std::string::size_type v16 = v17;
    }
    health::FormatImplementation<std::string &,health::BlockPointer &,std::string const&>(v12, a2, v16 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v15 = (char *)a2;
    }
    else {
      unint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
LABEL_43:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v25, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BCE222D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &,health::BlockPointer &,std::string const&>::formatOptionsAtIndex<std::string &,health::BlockPointer &,std::string const&>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE223CC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatString<unsigned long long const&,unsigned long long const&>(std::string *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  v4[0] = a3;
  v4[1] = a2;
  a4->__r_.__value_.__l.__size_ = 0;
  a4->__r_.__value_.__r.__words[2] = 0;
  a4->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<unsigned long long const&,unsigned long long const&>(a1, a4, 0, v4);
}

void sub_1BCE22430(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<unsigned long long const&,unsigned long long const&>(std::string *a1, std::string *this, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (unint64_t i = (char *)a1; ; ++i)
  {
    std::string::size_type v19 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(this, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    std::string::size_type v19 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    std::string::size_type v19 = i + 2;
    int v12 = i[2];
    if ((v12 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v13 = 0;
      std::string::size_type v14 = i + 3;
      do
      {
        std::string::size_type v19 = v14;
        uint64_t v13 = (v12 - 48) + 10 * v13;
        int v15 = *v14++;
        int v12 = v15;
      }
      while ((v15 - 58) >= 0xFFFFFFF6);
      std::string::size_type v19 = v14;
      if (*(v14 - 1) == 125) {
        health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>((uint64_t)a4, (uint64_t)a4, v13);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v17, (const char **)&v19);
  health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>::formatParameterAtIndex<unsigned long long const&,unsigned long long const&>(a4, (uint64_t)a4, v18, v17, this, a3 - v8, (int)v19);
  if (v8) {
    health::CopyFormatSectionToResult(a1, this, a3, -v8, v9 & 1);
  }
}

void sub_1BCE2265C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    health::FormatterParameters<1ul,unsigned long long const&>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>(a1, a2, a3);
  }
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE226DC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>::formatParameterAtIndex<unsigned long long const&,unsigned long long const&>(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned char *a4, std::string *a5, uint64_t a6, int a7)
{
  if (a3)
  {
    health::FormatterParameters<1ul,unsigned long long const&>::formatParameterAtIndex<unsigned long long const&,unsigned long long const&>(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)&__p, a1[1], (uint64_t)a4);
    health::FormatImplementation<unsigned long long const&,unsigned long long const&>(a7, a5);
    if ((a5->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v11 = (char *)a5;
    }
    else {
      int v11 = (char *)a5->__r_.__value_.__r.__words[0];
    }
    health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(a4, &v11[a6], (const void **)&__p);
    if (v13 < 0) {
      operator delete(__p);
    }
  }
}

void sub_1BCE227F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatterParameters<1ul,unsigned long long const&>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 1)
  {
    health::FormatterParameters<2ul>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>();
  }
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE22884(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<2ul>::formatOptionsAtIndex<unsigned long long const&,unsigned long long const&>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE228E0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<1ul,unsigned long long const&>::formatParameterAtIndex<unsigned long long const&,unsigned long long const&>(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned char *a4, std::string *a5, uint64_t a6, int a7)
{
  if (a3 != 1)
  {
    health::FormatterParameters<2ul>::formatParameterAtIndex<health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>>();
  }
  health::TypeFormatter<unsigned long long &,void>::TypeFormatter((uint64_t)&__p, *a1, (uint64_t)a4);
  health::FormatImplementation<unsigned long long const&,unsigned long long const&>(a7, a5);
  if ((a5->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v11 = (char *)a5;
  }
  else {
    int v11 = (char *)a5->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(a4, &v11[a6], (const void **)&__p);
  if (v13 < 0) {
    operator delete(__p);
  }
}

void sub_1BCE22A00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatterParameters<2ul>::formatParameterAtIndex<health::FormatterParameters<0ul,unsigned long long const&,unsigned long long const&>>()
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BCE22A68(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t HDCodableUserDomainConceptLocalizedStringPropertyReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  std::string::size_type v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v15 = v9++ >= 9;
        if (v15)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          char v18 = 0;
          unsigned int v19 = 0;
          uint64_t v20 = 0;
          *(unsigned char *)(a1 + 52) |= 2u;
          while (1)
          {
            uint64_t v21 = *v3;
            uint64_t v22 = *(void *)(a2 + v21);
            unint64_t v23 = v22 + 1;
            if (v22 == -1 || v23 > *(void *)(a2 + *v4)) {
              break;
            }
            char v24 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
            *(void *)(a2 + v21) = v23;
            v20 |= (unint64_t)(v24 & 0x7F) << v18;
            if ((v24 & 0x80) == 0) {
              goto LABEL_49;
            }
            v18 += 7;
            BOOL v15 = v19++ >= 9;
            if (v15)
            {
              uint64_t v20 = 0;
              goto LABEL_51;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_49:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v20 = 0;
          }
LABEL_51:
          uint64_t v45 = 16;
          goto LABEL_56;
        case 2u:
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v20 = 0;
          *(unsigned char *)(a1 + 52) |= 4u;
          while (2)
          {
            uint64_t v27 = *v3;
            uint64_t v28 = *(void *)(a2 + v27);
            unint64_t v29 = v28 + 1;
            if (v28 == -1 || v29 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v28);
              *(void *)(a2 + v27) = v29;
              v20 |= (unint64_t)(v30 & 0x7F) << v25;
              if (v30 < 0)
              {
                v25 += 7;
                BOOL v15 = v26++ >= 9;
                if (v15)
                {
                  uint64_t v20 = 0;
                  goto LABEL_55;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v20 = 0;
          }
LABEL_55:
          uint64_t v45 = 24;
LABEL_56:
          *(void *)(a1 + v45) = v20;
          continue;
        case 3u:
          *(unsigned char *)(a1 + 52) |= 1u;
          uint64_t v31 = *v3;
          unint64_t v32 = *(void *)(a2 + v31);
          if (v32 <= 0xFFFFFFFFFFFFFFF7 && v32 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v33 = *(void *)(*(void *)(a2 + *v7) + v32);
            *(void *)(a2 + v31) = v32 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v33 = 0;
          }
          *(void *)(a1 + _Block_object_dispose(&a9, 8) = v33;
          continue;
        case 5u:
          uint64_t v35 = PBReaderReadString();
          uint64_t v36 = 40;
          goto LABEL_40;
        case 6u:
          uint64_t v35 = PBReaderReadString();
          uint64_t v36 = 32;
LABEL_40:
          unint64_t v37 = *(void **)(a1 + v36);
          *(void *)(a1 + v36) = v35;

          continue;
        case 7u:
          char v38 = 0;
          unsigned int v39 = 0;
          uint64_t v40 = 0;
          *(unsigned char *)(a1 + 52) |= 8u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v41 = *v3;
        uint64_t v42 = *(void *)(a2 + v41);
        unint64_t v43 = v42 + 1;
        if (v42 == -1 || v43 > *(void *)(a2 + *v4)) {
          break;
        }
        char v44 = *(unsigned char *)(*(void *)(a2 + *v7) + v42);
        *(void *)(a2 + v41) = v43;
        v40 |= (unint64_t)(v44 & 0x7F) << v38;
        if ((v44 & 0x80) == 0) {
          goto LABEL_58;
        }
        v38 += 7;
        BOOL v15 = v39++ >= 9;
        if (v15)
        {
          uint64_t v40 = 0;
          goto LABEL_60;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_58:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v40 = 0;
      }
LABEL_60:
      *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = v40 != 0;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCloudSyncCodableSequenceReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  std::string::size_type v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      unint64_t v12 = *(void *)(a2 + v11);
      if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
        break;
      }
      char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v14 = v9++ >= 9;
      if (v14)
      {
        unint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v15 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 100) |= 0x10u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_79;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_81;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_79:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v19) = 0;
        }
LABEL_81:
        *(_DWORD *)(a1 + 80) = v19;
        goto LABEL_103;
      case 2u:
        char v23 = 0;
        unsigned int v24 = 0;
        uint64_t v25 = 0;
        *(unsigned char *)(a1 + 100) |= 0x20u;
        while (2)
        {
          uint64_t v26 = *v3;
          unint64_t v27 = *(void *)(a2 + v26);
          if (v27 == -1 || v27 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v28 = *(unsigned char *)(*(void *)(a2 + *v7) + v27);
            *(void *)(a2 + v26) = v27 + 1;
            v25 |= (unint64_t)(v28 & 0x7F) << v23;
            if (v28 < 0)
            {
              v23 += 7;
              BOOL v14 = v24++ >= 9;
              if (v14)
              {
                uint64_t v25 = 0;
                goto LABEL_85;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v25 = 0;
        }
LABEL_85:
        *(unsigned char *)(a1 + 96) = v25 != 0;
        goto LABEL_103;
      case 3u:
        char v29 = 0;
        unsigned int v30 = 0;
        uint64_t v31 = 0;
        *(unsigned char *)(a1 + 100) |= 4u;
        while (2)
        {
          uint64_t v32 = *v3;
          unint64_t v33 = *(void *)(a2 + v32);
          if (v33 == -1 || v33 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v34 = *(unsigned char *)(*(void *)(a2 + *v7) + v33);
            *(void *)(a2 + v32) = v33 + 1;
            v31 |= (unint64_t)(v34 & 0x7F) << v29;
            if (v34 < 0)
            {
              v29 += 7;
              BOOL v14 = v30++ >= 9;
              if (v14)
              {
                uint64_t v31 = 0;
                goto LABEL_89;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v31 = 0;
        }
LABEL_89:
        uint64_t v53 = 24;
        goto LABEL_102;
      case 4u:
        PBReaderReadData();
        uint64_t v35 = (HDCodableSyncIdentity *)objc_claimAutoreleasedReturnValue();
        if (v35) {
          [(id)a1 addIncludedStoreIdentifiers:v35];
        }
        goto LABEL_61;
      case 5u:
        uint64_t v35 = objc_alloc_init(HDCodableSyncIdentity);
        [(id)a1 addIncludedSyncIdentities:v35];
        goto LABEL_44;
      case 6u:
        uint64_t v35 = objc_alloc_init(HDCodableSyncIdentity);
        [(id)a1 addIncludedChildSyncIdentities:v35];
LABEL_44:
        if (!PBReaderPlaceMark() || !HDCodableSyncIdentityReadFrom((uint64_t)v35, a2)) {
          goto LABEL_105;
        }
        goto LABEL_60;
      case 0xAu:
        char v37 = 0;
        unsigned int v38 = 0;
        uint64_t v31 = 0;
        *(unsigned char *)(a1 + 100) |= 8u;
        while (2)
        {
          uint64_t v39 = *v3;
          unint64_t v40 = *(void *)(a2 + v39);
          if (v40 == -1 || v40 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v41 = *(unsigned char *)(*(void *)(a2 + *v7) + v40);
            *(void *)(a2 + v39) = v40 + 1;
            v31 |= (unint64_t)(v41 & 0x7F) << v37;
            if (v41 < 0)
            {
              v37 += 7;
              BOOL v14 = v38++ >= 9;
              if (v14)
              {
                uint64_t v31 = 0;
                goto LABEL_93;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v31 = 0;
        }
LABEL_93:
        uint64_t v53 = 32;
        goto LABEL_102;
      case 0xBu:
        uint64_t v35 = objc_alloc_init(HDCodableSyncAnchorRangeMap);
        uint64_t v42 = 40;
        goto LABEL_58;
      case 0xCu:
        uint64_t v35 = objc_alloc_init(HDCodableSyncAnchorRangeMap);
        uint64_t v42 = 48;
LABEL_58:
        objc_storeStrong((id *)(a1 + v42), v35);
        if (PBReaderPlaceMark() && -[HDCodableSyncIdentity readFrom:](v35, "readFrom:", a2, 0, 0))
        {
LABEL_60:
          PBReaderRecallMark();
LABEL_61:

LABEL_103:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_105:

        return 0;
      case 0x14u:
        char v43 = 0;
        unsigned int v44 = 0;
        uint64_t v31 = 0;
        *(unsigned char *)(a1 + 100) |= 1u;
        while (2)
        {
          uint64_t v45 = *v3;
          unint64_t v46 = *(void *)(a2 + v45);
          if (v46 == -1 || v46 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v47 = *(unsigned char *)(*(void *)(a2 + *v7) + v46);
            *(void *)(a2 + v45) = v46 + 1;
            v31 |= (unint64_t)(v47 & 0x7F) << v43;
            if (v47 < 0)
            {
              v43 += 7;
              BOOL v14 = v44++ >= 9;
              if (v14)
              {
                uint64_t v31 = 0;
                goto LABEL_97;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v31 = 0;
        }
LABEL_97:
        uint64_t v53 = 8;
        goto LABEL_102;
      case 0x15u:
        char v48 = 0;
        unsigned int v49 = 0;
        uint64_t v31 = 0;
        *(unsigned char *)(a1 + 100) |= 2u;
        while (2)
        {
          uint64_t v50 = *v3;
          unint64_t v51 = *(void *)(a2 + v50);
          if (v51 == -1 || v51 >= *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v52 = *(unsigned char *)(*(void *)(a2 + *v7) + v51);
            *(void *)(a2 + v50) = v51 + 1;
            v31 |= (unint64_t)(v52 & 0x7F) << v48;
            if (v52 < 0)
            {
              v48 += 7;
              BOOL v14 = v49++ >= 9;
              if (v14)
              {
                uint64_t v31 = 0;
                goto LABEL_101;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v31 = 0;
        }
LABEL_101:
        uint64_t v53 = 16;
LABEL_102:
        *(void *)(a1 + v53) = v31;
        goto LABEL_103;
      case 0x1Eu:
        PBReaderReadString();
        uint64_t v35 = (HDCodableSyncIdentity *)objc_claimAutoreleasedReturnValue();
        if (v35) {
          [(id)a1 addUnfrozenChangeRecordNames:v35];
        }
        goto LABEL_61;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_103;
    }
  }
}

id HDHeartDailyAnalyticsProcessingIntervalForCurrentDateAndCalendar(uint64_t a1, void *a2)
{
  id v3 = a2;
  std::string::size_type v4 = [v3 startOfDayForDate:a1];
  uint64_t v5 = [v3 dateByAddingUnit:16 value:-1 toDate:v4 options:0];
  unint64_t v6 = [v3 dateByAddingUnit:16 value:-1 toDate:v5 options:0];

  uint64_t v7 = (void *)[objc_alloc(MEMORY[0x1E4F28C18]) initWithStartDate:v6 endDate:v5];

  return v7;
}

void sub_1BCE2E65C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__91(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__91(uint64_t a1)
{
}

void sub_1BCE2E84C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE2EA24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE2EBFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE2EDA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE2F658(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1BCE30E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__92(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__92(uint64_t a1)
{
}

void sub_1BCE320FC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 128));
  _Unwind_Resume(a1);
}

void sub_1BCE33614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t __Block_byref_object_copy__93(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__93(uint64_t a1)
{
}

__CFString *NSStringFromHKBiologicalSex(unint64_t a1)
{
  if (a1 < 4) {
    return off_1E63003D0[a1];
  }
  uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
  uint64_t v3 = [NSString stringWithUTF8String:"NSString *NSStringFromHKBiologicalSex(HKBiologicalSex)"];
  [v2 handleFailureInFunction:v3 file:@"HDDemoDataDefines.m" lineNumber:26 description:@"Invalid biological sex"];

  return 0;
}

__CFString *NSStringFromHDDemoDataFoodType(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) < 6) {
    return off_1E63003F0[a1 - 1];
  }
  uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
  uint64_t v3 = [NSString stringWithUTF8String:"NSString *NSStringFromHDDemoDataFoodType(HDDemoDataFoodType)"];
  [v2 handleFailureInFunction:v3 file:@"HDDemoDataDefines.m" lineNumber:46 description:@"Invalid demo data food type"];

  return 0;
}

__CFString *NSStringFromHDDemoDataGenerationPeriod(uint64_t a1)
{
  if (a1 > 59)
  {
    if (a1 > 179)
    {
      if (a1 == 180) {
        return @"6 Months";
      }
      if (a1 == 365) {
        return @"1 Year";
      }
    }
    else
    {
      if (a1 == 60) {
        return @"2 Months";
      }
      if (a1 == 90) {
        return @"3 Months";
      }
    }
  }
  else if (a1 > 6)
  {
    if (a1 == 7) {
      return @"1 Week";
    }
    if (a1 == 30) {
      return @"1 Month";
    }
  }
  else
  {
    if (a1 == -1) {
      return @"Year to Date";
    }
    if (a1 == 1) {
      return @"1 Day";
    }
  }
  unint64_t v6 = objc_msgSend(MEMORY[0x1E4F28B00], "currentHandler", v2, v1, v3, v4);
  uint64_t v7 = [NSString stringWithUTF8String:"NSString *NSStringFromHDDemoDataGenerationPeriod(HDDemoDataGenerationPeriod)"];
  [v6 handleFailureInFunction:v7 file:@"HDDemoDataDefines.m" lineNumber:70 description:@"Invalid demo data generation period"];

  return 0;
}

uint64_t HDDemoDataIsValidGenerationPeriod(uint64_t a1)
{
  uint64_t result = 1;
  if (a1 <= 89)
  {
    unint64_t v7 = a1 + 1;
    if (v7 <= 0x3D && ((1 << v7) & 0x2000000080000105) != 0) {
      return result;
    }
LABEL_8:
    char v8 = objc_msgSend(MEMORY[0x1E4F28B00], "currentHandler", v2, v1, v3, v4);
    uint64_t v9 = [NSString stringWithUTF8String:"BOOL HDDemoDataIsValidGenerationPeriod(HDDemoDataGenerationPeriod)"];
    [v8 handleFailureInFunction:v9 file:@"HDDemoDataDefines.m" lineNumber:87 description:@"Invalid demo data initial generation period"];

    return 0;
  }
  if (a1 != 90 && a1 != 180 && a1 != 365) {
    goto LABEL_8;
  }
  return result;
}

__CFString *DisplayNameForHDDemoDataProfileType(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) < 4) {
    return off_1E6300420[a1 - 1];
  }
  uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
  uint64_t v3 = [NSString stringWithUTF8String:"NSString *DisplayNameForHDDemoDataProfileType(HDDemoDataProfileType)"];
  [v2 handleFailureInFunction:v3 file:@"HDDemoDataDefines.m" lineNumber:103 description:@"Invalid demo data profile type"];

  return 0;
}

__CFString *DirectoryPathForHDDemoDataProfileType(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) < 4) {
    return off_1E6300440[a1 - 1];
  }
  uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
  uint64_t v3 = [NSString stringWithUTF8String:"NSString *DirectoryPathForHDDemoDataProfileType(HDDemoDataProfileType)"];
  [v2 handleFailureInFunction:v3 file:@"HDDemoDataDefines.m" lineNumber:119 description:@"Invalid demo data profile type"];

  return 0;
}

__CFString *NSStringFromHDDemoDataSampleTrackingType(uint64_t a1)
{
  if (a1 == 1) {
    return @"Typical";
  }
  if (a1 == 2) {
    return @"Inclusive";
  }
  uint64_t v2 = [MEMORY[0x1E4F28B00] currentHandler];
  uint64_t v3 = [NSString stringWithUTF8String:"NSString *NSStringFromHDDemoDataSampleTrackingType(HDDemoDataSampleTrackingType)"];
  [v2 handleFailureInFunction:v3 file:@"HDDemoDataDefines.m" lineNumber:131 description:@"Invalid demo data sample tracking type"];

  return 0;
}

void sub_1BCE36278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__94(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__94(uint64_t a1)
{
}

void sub_1BCE36EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE3A830(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 240), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__95(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__95(uint64_t a1)
{
}

BOOL HDCodableAuthorizationCompleteMessageReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    unint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 10) {
        break;
      }
      if (v17 == 2)
      {
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 24;
        goto LABEL_24;
      }
      if (v17 == 1)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 8;
LABEL_24:
        uint64_t v20 = *(void **)(a1 + v19);
        *(void *)(a1 + v19) = v18;

        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_26:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v18 = PBReaderReadString();
    uint64_t v19 = 16;
    goto LABEL_24;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCE3DF28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  objc_destroyWeak(v39);
  objc_destroyWeak((id *)(v40 - 192));
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__96(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__96(uint64_t a1)
{
}

void sub_1BCE41BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__97(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__97(uint64_t a1)
{
}

void sub_1BCE41DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE41F5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDAttachmentPredicateForAttachmentIdentifier(uint64_t a1)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"identifier" equalToValue:a1];
}

void sub_1BCE42E64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__98(uint64_t a1, uint64_t a2)
{
  uint64_t result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__98(uint64_t a1)
{
}

void sub_1BCE43424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE44620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va2, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__315(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__316(uint64_t a1)
{
}

void sub_1BCE45344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1BCE4554C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, long long buf)
{
  if (a2 == 1)
  {
    id v12 = objc_begin_catch(a1);
    _HKInitializeLogging();
    uint64_t v13 = (id)*MEMORY[0x1E4F29FA8];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      uint64_t v16 = *(void *)(v11 + 40);
      unint64_t v17 = [v12 reason];
      LODWORD(buf) = 138543618;
      *(void *)((char *)&buf + 4) = v16;
      WORD6(buf) = 2114;
      *(void *)((char *)&buf + 14) = v17;
      _os_log_fault_impl(&dword_1BCB7D000, v13, OS_LOG_TYPE_FAULT, "%{public}@: Error unarchiving change objects: %{public}@", (uint8_t *)&buf, 0x16u);
    }
    uint64_t v14 = *(void *)(*(void *)(v11 + 56) + 8);
    uint64_t v15 = *(void **)(v14 + 40);
    *(void *)(v14 + 40) = 0;

    objc_end_catch();
    JUMPOUT(0x1BCE45488);
  }
  _Unwind_Resume(a1);
}

void sub_1BCE46968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, id *a10, id *a11, id *a12, id *a13, id *a14, id *a15, id *a16, id *a17, id *a18, id *location)
{
}

void sub_1BCE4B480(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
}

void sub_1BCE4C620(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCE4C974(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t _HDAddWorkoutBuilderTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9738 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddWorkoutSessionControllerTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"CREATE TABLE IF NOT EXISTS workout_session_controllers (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, workout_session_id INTEGER NOT NULL REFERENCES workout_sessions(ROWID) ON DELETE CASCADE, recovery_identifier TEXT NOT NULL, archived_state BLOB)", a4 error] ^ 1;

  return v6;
}

uint64_t _HDAddClientBundleIdentifierToWorkoutSession(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = [a2 unprotectedDatabase];
  v8[0] = @"ALTER TABLE workout_sessions ADD COLUMN client_bundle_id TEXT;";
  uint64_t v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1];
  LODWORD(a4) = [v5 executeSQLStatements:v6 error:a4];

  return a4 ^ 1;
}

uint64_t _HDAddAuthorizationMode(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9750 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddClientApplicationIdentifierToWorkoutSession(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = [a2 unprotectedDatabase];
  v8[0] = @"ALTER TABLE workout_sessions ADD COLUMN client_application_id TEXT;";
  uint64_t v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1];
  LODWORD(a4) = [v5 executeSQLStatements:v6 error:a4];

  return a4 ^ 1;
}

uint64_t _HDRemoveExistingWorkoutBuildersAndSessions(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9768 error:a4] ^ 1;

  return v6;
}

uint64_t _HDSplitAuthorizationAnchors(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9780 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddSyncProtocolVersionToCloudSyncStore(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9798 error:a4] ^ 1;

  return v6;
}

uint64_t _HDMakeStatisticsColumnNullable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E97B0 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddRequestedTargetStateToWorkoutSession(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = [a2 unprotectedDatabase];
  v8[0] = @"ALTER TABLE workout_sessions ADD COLUMN requested_target_state INTEGER NOT NULL DEFAULT 1;";
  uint64_t v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1];
  LODWORD(a4) = [v5 executeSQLStatements:v6 error:a4];

  return a4 ^ 1;
}

uint64_t _HDAddHasFailedToWorkoutSession(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = [a2 unprotectedDatabase];
  v8[0] = @"ALTER TABLE workout_sessions ADD COLUMN has_failed INTEGER NOT NULL DEFAULT 0;";
  uint64_t v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1];
  LODWORD(a4) = [v5 executeSQLStatements:v6 error:a4];

  return a4 ^ 1;
}

uint64_t _HDAddWorkoutEventForeignKey(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E97C8 error:a4] ^ 1;

  return v6;
}

uint64_t _CreateQuantitySampleSeriesEntityTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"CREATE TABLE IF NOT EXISTS quantity_sample_series (data_id INTEGER PRIMARY KEY REFERENCES samples (data_id) ON DELETE CASCADE, count INTEGER NOT NULL DEFAULT 0, insertion_era INTEGER, hfd_key INTEGER NOT NULL, min REAL, max REAL, most_recent REAL, most_recent_date REAL)", a4 error] ^ 1;

  return v6;
}

uint64_t _AddCondenserVersionToWorkoutEntityTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"ALTER TABLE workouts ADD condenser_version INTEGER" error:a4] ^ 1;

  return v6;
}

uint64_t _AddTemplateUniqueNameToFitnessFriendAchievements(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void v8[2] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = [a2 protectedDatabase];
  v8[0] = @"DROP TABLE fitness_friend_achievements";
  v8[1] = @"CREATE TABLE fitness_friend_achievements (data_id INTEGER PRIMARY KEY, friend_uuid BLOB, template_unique_name TEXT, completed_date REAL, value)";
  uint64_t v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:2];
  LODWORD(a4) = [v5 executeSQLStatements:v6 error:a4];

  return a4 ^ 1;
}

uint64_t _AddiOSVersionToFHIRResources(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v8[6] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = [a2 protectedDatabase];
  v8[0] = @"CREATE TABLE original_fhir_resources (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, type TEXT NOT NULL, account_id INTEGER NOT NULL REFERENCES clinical_accounts (ROWID) ON DELETE CASCADE, id TEXT NOT NULL, sync_provenance INTEGER NOT NULL, raw_content BLOB NOT NULL, received_date REAL NOT NULL, received_date_timezone TEXT NOT NULL, fhir_version TEXT NOT NULL, source_url TEXT, extraction_hints INTEGER, origin_major_version INTEGER NOT NULL, origin_minor_version INTEGER NOT NULL, origin_patch_version INTEGER NOT NULL, origin_build TEXT NOT NULL, UNIQUE(type, account_id, id))";
  v8[1] = @"CREATE TABLE IF NOT EXISTS original_fhir_resources_last_seen (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, resource_id INTEGER NOT NULL REFERENCES original_fhir_resources(ROWID) ON DELETE CASCADE, last_seen_date REAL NOT NULL)";
  void v8[2] = @"INSERT INTO original_fhir_resources (rowid, type, account_id, id, sync_provenance, raw_content, received_date, received_date_timezone, fhir_version, source_url, extraction_hints, origin_major_version, origin_minor_version, origin_patch_version, origin_build) SELECT rowid, type, account_id, id, sync_provenance, raw_content, received_date, received_date_timezone, fhir_version, source_url, extraction_hints, 11, 3, 0, '15E216' FROM fhir_resources";
  void v8[3] = @"INSERT INTO original_fhir_resources_last_seen (rowid, resource_id, last_seen_date) SELECT rowid, resource_id, last_seen_date FROM fhir_resources_last_seen";
  v8[4] = @"DROP TABLE fhir_resources";
  void v8[5] = @"DROP TABLE fhir_resources_last_seen";
  uint64_t v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:6];
  LODWORD(a4) = [v5 executeSQLStatements:v6 error:a4];

  return a4 ^ 1;
}

uint64_t _AddCondenserDateToWorkoutEntityTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"ALTER TABLE workouts ADD condenser_date REAL" error:a4] ^ 1;

  return v6;
}

uint64_t _AddHFDKeyToSeriesSampleEntityTable(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v5 = a2;
  uint64_t v6 = [v5 protectedDatabase];
  id v14 = 0;
  char v7 = [v6 table:@"data_series" hasColumnWithName:@"count" error:&v14];
  id v8 = v14;

  if (v7) {
    goto LABEL_2;
  }
  if (v8)
  {
    if (a4) {
      *a4 = v8;
    }
    else {
      _HKLogDroppedError();
    }
    goto LABEL_9;
  }
  uint64_t v11 = [v5 protectedDatabase];
  int v12 = [v11 executeUncachedSQL:@"ALTER TABLE data_series ADD COLUMN count INTEGER NOT NULL DEFAULT 0" error:a4];

  if (!v12)
  {
LABEL_9:
    uint64_t v10 = 1;
    goto LABEL_10;
  }
LABEL_2:
  uint64_t v9 = [v5 protectedDatabase];
  uint64_t v10 = [v9 executeSQLStatements:&unk_1F17E97E0 error:a4] ^ 1;

LABEL_10:
  return v10;
}

uint64_t _CreateClinicalRecordEntityTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"CREATE TABLE IF NOT EXISTS clinical_record_samples (data_id INTEGER PRIMARY KEY, display_name TEXT NOT NULL, fhir_resource_resource_type TEXT, fhir_resource_identifier TEXT, fhir_resource_data BLOB, fhir_resource_source_url TEXT, fhir_resource_last_updated_date REAL)", a4 error] ^ 1;

  return v6;
}

uint64_t _MakeQuantitySampleSeriesEntityHFDKeyUnique(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E97F8 error:a4] ^ 1;

  return v6;
}

uint64_t _CreateQuantitySampleSeriesUnfrozenIndex(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9810 error:a4] ^ 1;

  return v6;
}

uint64_t _RemoveLegacyAchievements(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9828 error:a4] ^ 1;

  return v6;
}

uint64_t _HDMigrateClinicalSources(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v6 = a1;
  id v7 = a2;
  id v8 = [v7 unprotectedDatabase];
  int v9 = [v8 executeSQLStatements:&unk_1F17E9840 error:a4];

  if (v9)
  {
    uint64_t v10 = [v7 unprotectedDatabase];
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 3221225472;
    void v35[2] = ___HDMigrateClinicalSources_block_invoke;
    v35[3] = &unk_1E62F3D38;
    id v11 = v7;
    id v36 = v11;
    int v12 = [v10 executeUncachedSQL:@"SELECT account_id FROM public_clinical_sources" error:a4 bindingHandler:0 enumerationHandler:v35];

    if (!v12) {
      goto LABEL_22;
    }
    uint64_t v13 = [v6 fetchLegacySyncIdentity:v11 error:a4];
    if (v13 == -1) {
      goto LABEL_22;
    }
    uint64_t v14 = v13;
    uint64_t v15 = [v11 unprotectedDatabase];
    int v16 = [v15 executeSQLStatements:&unk_1F17E9858 error:a4];

    if (!v16) {
      goto LABEL_22;
    }
    unint64_t v17 = [v11 unprotectedDatabase];
    v34[0] = MEMORY[0x1E4F143A8];
    v34[1] = 3221225472;
    void v34[2] = ___HDMigrateClinicalSources_block_invoke_5;
    v34[3] = &__block_descriptor_40_e23_v16__0__sqlite3_stmt__8l;
    v34[4] = v14;
    int v18 = [v17 executeSQL:@"INSERT INTO sources (uuid, logical_source_id, name, source_options, local_device, product_type, mod_date, provenance, sync_anchor, deleted, sync_identity)                                             SELECT RANDOMBLOB(16), l.ROWID, name, source_options, local_device, product_type, mod_date, 0, COALESCE((SELECT MAX(sync_anchor) + 1 FROM sources), 1) + p.ROWID, 0, ?                                             FROM public_clinical_sources p JOIN logical_sources l WHERE p.stable_bundle_id = l.bundle_id", a4, v34, 0 error bindingHandler enumerationHandler];

    if (!v18) {
      goto LABEL_22;
    }
    uint64_t v19 = [v11 unprotectedDatabase];
    int v20 = [v19 executeSQLStatements:&unk_1F17E9870 error:a4];

    if (v20)
    {
      id v33 = [v11 protectedDatabase];
      unint64_t v21 = [v33 dumpSchemaWithError:a4];
      if (v21)
      {
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        uint64_t v22 = [&unk_1F17E9888 countByEnumeratingWithState:&v37 objects:v43 count:16];
        if (v22)
        {
          uint64_t v24 = v22;
          uint64_t v25 = *(void *)v38;
          *(void *)&long long v23 = 138412290;
          long long v32 = v23;
          do
          {
            for (uint64_t i = 0; i != v24; ++i)
            {
              if (*(void *)v38 != v25) {
                objc_enumerationMutation(&unk_1F17E9888);
              }
              uint64_t v27 = *(void *)(*((void *)&v37 + 1) + 8 * i);
              if (objc_msgSend(MEMORY[0x1E4F65D18], "databaseSchemas:containTable:", v21, v27, v32))
              {
                if (![v33 deleteRowsFromDataEntitySubclassTable:v27 intermediateTables:&unk_1F17E98A0 error:a4])goto LABEL_25; {
              }
                }
              else
              {
                _HKInitializeLogging();
                char v28 = *MEMORY[0x1E4F29F18];
                if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F18], OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)long long buf = v32;
                  uint64_t v42 = v27;
                  _os_log_impl(&dword_1BCB7D000, v28, OS_LOG_TYPE_INFO, "Skipping deletion from nonexistent table \"%@\"", buf, 0xCu);
                }
              }
            }
            uint64_t v24 = [&unk_1F17E9888 countByEnumeratingWithState:&v37 objects:v43 count:16];
          }
          while (v24);
        }

        char v29 = v33;
        uint64_t v30 = 0;
      }
      else
      {
LABEL_25:

        char v29 = v33;
        uint64_t v30 = 1;
      }
    }
    else
    {
LABEL_22:
      uint64_t v30 = 1;
    }
  }
  else
  {
    uint64_t v30 = 1;
  }

  return v30;
}

uint64_t _MakeSeriesSampleEntityHFDKeyUnique(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E98B8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddHealthRecordsAccountCount(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = a1;
  id v7 = a2;
  v18[0] = 0;
  v18[1] = v18;
  void v18[2] = 0x2020000000;
  v18[3] = 0;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = ___HDAddHealthRecordsAccountCount_block_invoke;
  aBlock[3] = &unk_1E62F3640;
  void aBlock[4] = v18;
  id v8 = _Block_copy(aBlock);
  int v9 = [v7 protectedDatabase];
  char v10 = [v9 executeSQL:@"SELECT COUNT(*) FROM clinical_accounts" error:a4 bindingHandler:0 enumerationHandler:v8];

  if ((v10 & 1) == 0 || (uint64_t v11 = [v6 fetchLegacySyncIdentity:v7 error:a4], v11 == -1))
  {
    uint64_t v14 = 1;
  }
  else
  {
    int v12 = [v7 unprotectedDatabase];
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    void v16[2] = ___HDAddHealthRecordsAccountCount_block_invoke_2;
    void v16[3] = &unk_1E62FB758;
    void v16[4] = v18;
    v16[5] = v11;
    int v13 = objc_msgSend(v12, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", @"INSERT OR REPLACE INTO key_value (domain, key, value, mod_date, category, provenance, sync_identity) VALUES (?, ?, ?, ?, ?, ?, ?);",
            a4,
            v16,
            0);

    uint64_t v14 = v13 ^ 1u;
  }

  _Block_object_dispose(v18, 8);
  return v14;
}

void sub_1BCE4E180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL HDCloudSyncCodableRegisteredStoreReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    id v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3) {
        break;
      }
      if (v17 == 2)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 16;
LABEL_26:
        int v20 = *(HDCodableSyncIdentity **)(a1 + v19);
        *(void *)(a1 + v19) = v18;
LABEL_27:

        goto LABEL_29;
      }
      if (v17 == 1)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 8;
        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_29:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    int v20 = objc_alloc_init(HDCodableSyncIdentity);
    objc_storeStrong((id *)(a1 + 24), v20);
    if (!PBReaderPlaceMark() || !HDCodableSyncIdentityReadFrom((uint64_t)v20, a2))
    {

      return 0;
    }
    PBReaderRecallMark();
    goto LABEL_27;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCE571E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1BCE58084(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1BCE583B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE59208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE59A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

__CFString *HDStringFromJournalProcessingResult(unsigned int a1)
{
  if (a1 >= 5)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%ld)", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E6300F58[a1];
  }

  return v1;
}

BOOL HDJournalProcessingSuccessIndicatedWithResult(int a1)
{
  return (a1 - 3) < 2;
}

void sub_1BCE5B398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCE5B778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
}

uint64_t HDCodableActivityGoalScheduleReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    id v7 = off_1E62EF000;
    char v8 = &OBJC_IVAR___HDEntityEncoder__authorizationFilter;
    unsigned int v9 = &OBJC_IVAR___HDEntityEncoder__authorizationFilter;
    unint64_t v10 = (int *)MEMORY[0x1E4F940B8];
    while (2)
    {
      if (!*(unsigned char *)(a2 + *v5))
      {
        char v11 = 0;
        unsigned int v12 = 0;
        unint64_t v13 = 0;
        while (1)
        {
          uint64_t v14 = *v3;
          uint64_t v15 = *(void *)(a2 + v14);
          unint64_t v16 = v15 + 1;
          if (v15 == -1 || v16 > *(void *)(a2 + *v4)) {
            break;
          }
          char v17 = *(unsigned char *)(*(void *)(a2 + *v10) + v15);
          *(void *)(a2 + v14) = v16;
          v13 |= (unint64_t)(v17 & 0x7F) << v11;
          if ((v17 & 0x80) == 0) {
            goto LABEL_12;
          }
          v11 += 7;
          BOOL v18 = v12++ >= 9;
          if (v18)
          {
            unint64_t v13 = 0;
            int v19 = *(unsigned __int8 *)(a2 + *v5);
            goto LABEL_14;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
        int v19 = *(unsigned __int8 *)(a2 + *v5);
        if (*(unsigned char *)(a2 + *v5)) {
          unint64_t v13 = 0;
        }
LABEL_14:
        if (v19) {
          BOOL v20 = 1;
        }
        else {
          BOOL v20 = (v13 & 7) == 4;
        }
        if (!v20)
        {
          switch((v13 >> 3))
          {
            case 1u:
              unint64_t v21 = v8;
              uint64_t v22 = v9;
              long long v23 = v7;
              id v24 = objc_alloc_init(v7[287]);
              objc_storeStrong((id *)(a1 + 72), v24);
              if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v24, a2))
              {
                PBReaderRecallMark();

                id v7 = v23;
                unsigned int v9 = v22;
                char v8 = v21;
                goto LABEL_72;
              }

              return 0;
            case 2u:
              char v26 = 0;
              unsigned int v27 = 0;
              uint64_t v28 = 0;
              *(unsigned char *)(a1 + v8[262]) |= 2u;
              break;
            case 3u:
              uint64_t v33 = PBReaderReadString();
              char v34 = *(void **)(a1 + 80);
              *(void *)(a1 + 80) = v33;

              goto LABEL_72;
            case 4u:
              *(unsigned char *)(a1 + v8[262]) |= 4u;
              uint64_t v35 = *v3;
              unint64_t v36 = *(void *)(a2 + v35);
              if (v36 <= 0xFFFFFFFFFFFFFFF7 && v36 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v36);
                *(void *)(a2 + v35) = v36 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v37 = 0;
              }
              uint64_t v50 = 24;
              goto LABEL_71;
            case 5u:
              *(unsigned char *)(a1 + v8[262]) |= 0x40u;
              uint64_t v38 = *v3;
              unint64_t v39 = *(void *)(a2 + v38);
              if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v39);
                *(void *)(a2 + v3_Block_object_dispose(&a9, 8) = v39 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v37 = 0;
              }
              uint64_t v50 = 56;
              goto LABEL_71;
            case 6u:
              *(unsigned char *)(a1 + v8[262]) |= 0x80u;
              uint64_t v40 = *v3;
              unint64_t v41 = *(void *)(a2 + v40);
              if (v41 <= 0xFFFFFFFFFFFFFFF7 && v41 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v41);
                *(void *)(a2 + v40) = v41 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v37 = 0;
              }
              uint64_t v50 = 64;
              goto LABEL_71;
            case 7u:
              *(unsigned char *)(a1 + v8[262]) |= 0x20u;
              uint64_t v42 = *v3;
              unint64_t v43 = *(void *)(a2 + v42);
              if (v43 <= 0xFFFFFFFFFFFFFFF7 && v43 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v43);
                *(void *)(a2 + v42) = v43 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v37 = 0;
              }
              uint64_t v50 = 48;
              goto LABEL_71;
            case 8u:
              *(unsigned char *)(a1 + v8[262]) |= 1u;
              uint64_t v44 = *v3;
              unint64_t v45 = *(void *)(a2 + v44);
              if (v45 <= 0xFFFFFFFFFFFFFFF7 && v45 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v45);
                *(void *)(a2 + v44) = v45 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v37 = 0;
              }
              uint64_t v50 = 8;
              goto LABEL_71;
            case 9u:
              *(unsigned char *)(a1 + v8[262]) |= 8u;
              uint64_t v46 = *v3;
              unint64_t v47 = *(void *)(a2 + v46);
              if (v47 <= 0xFFFFFFFFFFFFFFF7 && v47 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v47);
                *(void *)(a2 + v46) = v47 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v37 = 0;
              }
              uint64_t v50 = 32;
              goto LABEL_71;
            case 0xAu:
              *(unsigned char *)(a1 + v8[262]) |= 0x10u;
              uint64_t v48 = *v3;
              unint64_t v49 = *(void *)(a2 + v48);
              if (v49 <= 0xFFFFFFFFFFFFFFF7 && v49 + 8 <= *(void *)(a2 + *v4))
              {
                uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v49);
                *(void *)(a2 + v4_Block_object_dispose(&a9, 8) = v49 + 8;
              }
              else
              {
                *(unsigned char *)(a2 + *v5) = 1;
                uint64_t v37 = 0;
              }
              uint64_t v50 = 40;
LABEL_71:
              *(void *)(a1 + v50) = v37;
              goto LABEL_72;
            default:
              uint64_t result = PBReaderSkipValueWithTag();
              if (!result) {
                return result;
              }
LABEL_72:
              if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
                return *(unsigned char *)(a2 + *v5) == 0;
              }
              continue;
          }
          while (1)
          {
            uint64_t v29 = *v3;
            uint64_t v30 = *(void *)(a2 + v29);
            unint64_t v31 = v30 + 1;
            if (v30 == -1 || v31 > *(void *)(a2 + *v4)) {
              break;
            }
            char v32 = *(unsigned char *)(*(void *)(a2 + *v10) + v30);
            *(void *)(a2 + v29) = v31;
            v28 |= (unint64_t)(v32 & 0x7F) << v26;
            if ((v32 & 0x80) == 0) {
              goto LABEL_54;
            }
            v26 += 7;
            BOOL v18 = v27++ >= 9;
            if (v18)
            {
              uint64_t v28 = 0;
              goto LABEL_56;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_54:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v28 = 0;
          }
LABEL_56:
          *(void *)(a1 + v9[263]) = v28;
          goto LABEL_72;
        }
      }
      break;
    }
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCheckAutomaticAppUpdatesAllowed()
{
  uint64_t v0 = [MEMORY[0x1E4F74230] sharedConnection];
  uint64_t v1 = [v0 isAutomaticAppUpdatesAllowed];

  return v1;
}

uint64_t _HDUpdateClientSideDataCollectionLastCollectedDatum(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9900 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddShouldCollectEventsColumnToWorkoutBuildersTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9918 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddOnboardingCompletionTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"CREATE TABLE IF NOT EXISTS onboarding_completions (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, uuid BLOB NOT NULL UNIQUE, feature_identifier TEXT NOT NULL, version INTEGER NOT NULL, completion_date REAL NOT NULL, country_code TEXT, mod_date REAL NOT NULL, deleted INTEGER NOT NULL DEFAULT 0, sync_provenance INTEGER NOT NULL)", a4 error] ^ 1;

  return v6;
}

uint64_t _HDResetAnchorsForCloudSyncStoresWithGaps(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"DELETE FROM sync_anchors WHERE store IN (SELECT ROWID FROM sync_stores INNER JOIN cloud_sync_stores on (sync_stores.ROWID=cloud_sync_stores.sync_store) WHERE has_gap)" error:a4] ^ 1;

  return v6;
}

uint64_t _HDResetReceivedNanoSyncAnchorsForCategoryAndQuantitySamples(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = a2;
  id v7 = [a1 behavior];
  int v8 = [v7 isAppleWatch];

  if (v8)
  {
    unsigned int v9 = [v6 unprotectedDatabase];
    uint64_t v10 = [v9 executeSQLStatements:&unk_1F17E9930 error:a4] ^ 1;
  }
  else
  {
    uint64_t v10 = 0;
  }

  return v10;
}

uint64_t _HDAddSleepScheduleTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = (objc_class *)MEMORY[0x1E4F1CA48];
  id v6 = a2;
  id v7 = objc_alloc_init(v5);
  [v7 addObject:@"CREATE TABLE IF NOT EXISTS sleep_schedule_samples (data_id INTEGER PRIMARY KEY, monday INTEGER NOT NULL, tuesday INTEGER NOT NULL, wednesday INTEGER NOT NULL, thursday INTEGER NOT NULL, friday INTEGER NOT NULL, saturday INTEGER NOT NULL, sunday INTEGER NOT NULL, wake_hour INTEGER, wake_minute INTEGER, bed_hour INTEGER, bed_minute INTEGER, wind_down_seconds REAL)"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_monday ON sleep_schedule_samples (monday) WHERE monday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_tuesday ON sleep_schedule_samples (tuesday) WHERE tuesday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_wednesday ON sleep_schedule_samples (wednesday) WHERE wednesday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_thursday ON sleep_schedule_samples (thursday) WHERE thursday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_friday ON sleep_schedule_samples (friday) WHERE friday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_saturday ON sleep_schedule_samples (saturday) WHERE saturday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_sunday ON sleep_schedule_samples (sunday) WHERE sunday = 1;"];
  int v8 = [v6 protectedDatabase];

  uint64_t v9 = [v8 executeSQLStatements:v7 error:a4] ^ 1;
  return v9;
}

uint64_t _HDAddECGSampleTable()
{
  return 0;
}

uint64_t _HDAddContributorsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  id v5 = [a2 protectedDatabase];
  v8[0] = @"CREATE TABLE IF NOT EXISTS contributors (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, uuid BLOB UNIQUE NOT NULL, payload BLOB, deleted INTEGER NOT NULL, placeholder INTEGER NOT NULL, mod_date REAL NOT NULL, sync_anchor INTEGER UNIQUE NOT NULL)";
  id v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v8 count:1];
  LODWORD(a4) = [v5 executeSQLStatements:v6 error:a4];

  return a4 ^ 1;
}

uint64_t _HDAddDeviceRecordSamplesTable()
{
  return 0;
}

uint64_t _HDAddProtectedOnboardingCompletionTable()
{
  return 0;
}

uint64_t _HDAddFHIRVersionToClinicalRecordSamplesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9948 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddContributorsColumnToProvenance(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v12[5] = *MEMORY[0x1E4F143B8];
  id v5 = (objc_class *)NSString;
  id v6 = a2;
  id v7 = [v5 alloc];
  int v8 = (void *)[v7 initWithFormat:@"INSERT INTO contributors (ROWID, uuid, payload, deleted, placeholder, mod_date, sync_anchor) VALUES (1, %@('00000000-0000-0000-0000-000000000000'), NULL, 0, 0, %lf, 0)", *MEMORY[0x1E4F65C98], CFAbsoluteTimeGetCurrent()];
  v12[0] = v8;
  v12[1] = @"CREATE TABLE IF NOT EXISTS data_provenances_new (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, sync_provenance INTEGER NOT NULL, origin_product_type TEXT NOT NULL, origin_build TEXT NOT NULL, local_product_type TEXT NOT NULL, local_build TEXT NOT NULL, source_id INTEGER NOT NULL, device_id INTEGER NOT NULL, contributor_id INTEGER NOT NULL, source_version TEXT NOT NULL, tz_name TEXT NOT NULL, origin_major_version INTEGER NOT NULL, origin_minor_version INTEGER NOT NULL, origin_patch_version INTEGER NOT NULL, derived_flags INTEGER NOT NULL, UNIQUE(sync_provenance, origin_product_type, origin_build, local_product_type, local_build, source_id, device_id, contributor_id, source_version, tz_name, origin_major_version, origin_minor_version, origin_patch_version))";
  _OWORD v12[2] = @"INSERT INTO data_provenances_new (ROWID, sync_provenance, origin_product_type, origin_build, local_product_type, local_build, source_id, device_id, contributor_id, source_version, tz_name, origin_major_version, origin_minor_version, origin_patch_version, derived_flags) SELECT ROWID, sync_provenance, origin_product_type, origin_build, local_product_type, local_build, source_id, device_id, 1, source_version, tz_name, origin_major_version, origin_minor_version, origin_patch_version, derived_flags FROM data_provenances";
  _OWORD v12[3] = @"DROP TABLE IF EXISTS data_provenances";
  void v12[4] = @"ALTER TABLE data_provenances_new RENAME TO data_provenances";
  uint64_t v9 = [MEMORY[0x1E4F1C978] arrayWithObjects:v12 count:5];
  uint64_t v10 = [v6 protectedDatabase];

  LODWORD(a4) = [v10 executeSQLStatements:v9 error:a4];
  return a4 ^ 1;
}

uint64_t _HDCreatePartialIndexForDeletedObjects(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9960 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddAppleIDAndCallerIDToContributorsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9978 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddECGSymptomsColumnToECGSamplesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9990 error:a4] ^ 1;

  return v6;
}

uint64_t _HDMigrateECGClassificationAverageHRAndPayload(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = a2;
  uint64_t v6 = [v5 protectedDatabase];
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  uint64_t v9[2] = ___HDMigrateECGClassificationAverageHRAndPayload_block_invoke;
  v9[3] = &unk_1E6300FD8;
  id v10 = v5;
  char v11 = @"DELETE FROM binary_samples WHERE data_id=?";
  unsigned int v12 = @"INSERT INTO ecg_samples (data_id, voltage_payload, private_classification, average_heart_rate, symptoms_status) VALUES (?, ?, ?, ?, ?)";
  unint64_t v13 = @"DELETE FROM metadata_values WHERE key_id IN (SELECT rowid FROM metadata_keys WHERE key LIKE '_HKPrivateMetadataKeyClassification' OR key LIKE '_HKPrivateMetadataKeyElectrocardiogramHeartRate') AND object_id=?";
  id v7 = v5;
  LODWORD(a4) = [v6 executeUncachedSQL:@"SELECT samples.data_id, uuid, creation_date, provenance, start_date, end_date, binary_samples.payload, a.numerical_value, b.numerical_value, c.numerical_value                                     FROM objects                                     INNER JOIN samples USING (data_id)                                     INNER JOIN binary_samples USING (data_id)                                     LEFT JOIN metadata_values a ON ((a.object_id = samples.data_id) AND (a.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateMetadataKeyClassification')))                                     LEFT JOIN metadata_values b ON ((b.object_id = samples.data_id) AND (b.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateMetadataKeyElectrocardiogramHeartRate')))                                     LEFT JOIN metadata_values c ON ((c.object_id = samples.data_id) AND (c.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateMetadataKeyElectrocardiogramSymptoms')))                                     WHERE data_os_log_type_t type = 144", a4, 0, v9 error bindingHandler enumerationHandler];

  return a4 ^ 1;
}

uint64_t _HDRemovePlaceholderAndAddSyncProvenanceToContributorsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E99C0 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddFirstSeenDateToOriginalFHIRResourcesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E99F0 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddCoverageRecordSamplesTable()
{
  return 0;
}

uint64_t _HDAddSCWIColumnToFriendWorkoutTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9A08 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddRequestedScopeToClinicalCredentialsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E99D8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDFixInvalidContributorInDataProvenancesTable(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  v43[1] = *MEMORY[0x1E4F143B8];
  id v29 = a1;
  id v6 = a2;
  uint64_t v38 = 0;
  unint64_t v39 = &v38;
  uint64_t v40 = 0x2020000000;
  uint64_t v41 = -1;
  id v7 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  id v8 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  uint64_t v9 = [NSString stringWithFormat:@"SELECT * FROM data_provenances WHERE contributor_id NOT IN (%@)", @"SELECT ROWID from contributors"];
  id v10 = [v6 protectedDatabase];
  uint64_t v30 = MEMORY[0x1E4F143A8];
  uint64_t v31 = 3221225472;
  char v32 = ___HDFixInvalidContributorInDataProvenancesTable_block_invoke;
  uint64_t v33 = &unk_1E6301028;
  uint64_t v37 = &v38;
  id v11 = v6;
  id v34 = v11;
  id v12 = v7;
  id v35 = v12;
  id v13 = v8;
  id v36 = v13;
  char v14 = [v10 executeUncachedSQL:v9 error:a4 bindingHandler:0 enumerationHandler:&v30];

  if ((v14 & 1) == 0) {
    goto LABEL_7;
  }
  if ([v13 count])
  {
    uint64_t v15 = NSString;
    uint64_t v16 = v39[3];
    char v17 = [v13 componentsJoinedByString:@","];
    BOOL v18 = [v15 stringWithFormat:@"UPDATE data_provenances SET contributor_id = %lld WHERE ROWID IN (%@)", v16, v17, v29, v30, v31, v32, v33, v34, v35];

    int v19 = [v11 protectedDatabase];
    v43[0] = v18;
    BOOL v20 = [MEMORY[0x1E4F1C978] arrayWithObjects:v43 count:1];
    LOBYTE(v16) = [v19 executeSQLStatements:v20 error:a4];

    if ((v16 & 1) == 0) {
      goto LABEL_7;
    }
  }
  if (![v12 count]) {
    goto LABEL_6;
  }
  unint64_t v21 = NSString;
  uint64_t v22 = [v12 componentsJoinedByString:@","];
  long long v23 = [v21 stringWithFormat:@"DELETE FROM data_provenances WHERE ROWID IN (%@)", v22];

  id v24 = [v11 protectedDatabase];
  uint64_t v42 = v23;
  uint64_t v25 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v42 count:1];
  char v26 = [v24 executeSQLStatements:v25 error:a4];

  if (v26) {
LABEL_6:
  }
    uint64_t v27 = 0;
  else {
LABEL_7:
  }
    uint64_t v27 = 1;

  _Block_object_dispose(&v38, 8);
  return v27;
}

void sub_1BCE5EFD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _HDAddOverrideDayIndexRemoveWindDownFromSleepScheduleTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = (objc_class *)MEMORY[0x1E4F1CA48];
  id v6 = a2;
  id v7 = objc_alloc_init(v5);
  [v7 addObject:@"ALTER TABLE sleep_schedule_samples RENAME TO sleep_schedule_samples_old;"];
  [v7 addObject:@"CREATE TABLE IF NOT EXISTS sleep_schedule_samples (data_id INTEGER PRIMARY KEY, monday INTEGER NOT NULL, tuesday INTEGER NOT NULL, wednesday INTEGER NOT NULL, thursday INTEGER NOT NULL, friday INTEGER NOT NULL, saturday INTEGER NOT NULL, sunday INTEGER NOT NULL, wake_hour INTEGER, wake_minute INTEGER, bed_hour INTEGER, bed_minute INTEGER, override_day_index INTEGER)"];
  [v7 addObject:@"INSERT INTO sleep_schedule_samples (data_id, monday, tuesday, wednesday, thursday, friday, saturday, sunday, wake_hour, wake_minute, bed_hour, bed_minute) SELECT data_id, monday, tuesday, wednesday, thursday, friday, saturday, sunday, wake_hour, wake_minute, bed_hour, bed_minute FROM sleep_schedule_samples_old;"];
  [v7 addObject:@"DROP TABLE sleep_schedule_samples_old;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_monday ON sleep_schedule_samples (monday) WHERE monday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_tuesday ON sleep_schedule_samples (tuesday) WHERE tuesday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_wednesday ON sleep_schedule_samples (wednesday) WHERE wednesday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_thursday ON sleep_schedule_samples (thursday) WHERE thursday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_friday ON sleep_schedule_samples (friday) WHERE friday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_saturday ON sleep_schedule_samples (saturday) WHERE saturday = 1;"];
  [v7 addObject:@"CREATE INDEX IF NOT EXISTS sleep_schedule_samples_sunday ON sleep_schedule_samples (sunday) WHERE sunday = 1;"];
  id v8 = [v6 protectedDatabase];

  uint64_t v9 = [v8 executeSQLStatements:v7 error:a4] ^ 1;
  return v9;
}

uint64_t _HDUpdateMedicalRecordsCoverageDiagnosticreportProcedureTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = a2;
  id v6 = [v5 protectedDatabase];
  int v7 = [v6 deleteDataEntitySubclassTablesIfExist:&unk_1F17E9A20 intermediateTables:&unk_1F17E9A38 error:a4];

  if (v7)
  {
    id v8 = [v5 protectedDatabase];
    uint64_t v9 = [v8 executeSQLStatements:&unk_1F17E9A50 error:a4] ^ 1;
  }
  else
  {
    uint64_t v9 = 1;
  }

  return v9;
}

uint64_t _HDRepairECGSymptomsStatus(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = a2;
  id v6 = [v5 protectedDatabase];
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  uint64_t v9[2] = ___HDRepairECGSymptomsStatus_block_invoke;
  v9[3] = &unk_1E62F3D60;
  id v10 = v5;
  id v11 = @"UPDATE ecg_samples SET symptoms_status = ? WHERE data_id = ?;";
  id v7 = v5;
  LODWORD(a4) = objc_msgSend(v6, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", @"SELECT objects.data_id, a.numerical_value                                     FROM objects                                     INNER JOIN ecg_samples USING (data_id)                                     LEFT JOIN metadata_values a ON ((a.object_id = objects.data_id) AND (a.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateMetadataKeyElectrocardiogramSymptoms')));",
                  a4,
                  0,
                  v9);

  return a4 ^ 1;
}

uint64_t _HDMigrateAndDeleteProtectedOnboardingCompletionTable(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = a1;
  id v7 = a2;
  id v8 = [v7 protectedDatabase];
  uint64_t v9 = [v8 dumpSchemaWithError:a4];

  if (!v9) {
    goto LABEL_7;
  }
  if (![MEMORY[0x1E4F65D18] databaseSchemas:v9 containTable:@"onboarding_completions"])
  {
    uint64_t v17 = 0;
    goto LABEL_11;
  }
  uint64_t v10 = [v6 fetchLegacySyncIdentity:v7 error:a4];
  if (v10 == -1)
  {
LABEL_7:
    uint64_t v17 = 1;
  }
  else
  {
    uint64_t v11 = v10;
    id v12 = [v7 protectedDatabase];
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 3221225472;
    void v19[2] = ___HDMigrateAndDeleteProtectedOnboardingCompletionTable_block_invoke;
    v19[3] = &unk_1E62F9D90;
    id v13 = v7;
    id v20 = v13;
    unint64_t v21 = @"INSERT OR REPLACE INTO onboarding_completions (uuid, feature_identifier, version, completion_date, country_code, mod_date, deleted, sync_provenance, sync_identity) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
    uint64_t v22 = v11;
    LODWORD(v11) = [v12 executeUncachedSQL:@"SELECT uuid, feature_identifier, version, completion_date, country_code, mod_date, deleted, sync_provenance FROM onboarding_completions", a4, 0, v19 error bindingHandler enumerationHandler];

    if (v11
      && ([v13 unprotectedDatabase],
          char v14 = objc_claimAutoreleasedReturnValue(),
          int v15 = [v14 executeUncachedSQL:@"DELETE FROM sync_anchors WHERE schema='main' and type=?" error:a4 bindingHandler:&__block_literal_global_107 enumerationHandler:0], v14, v15))
    {
      uint64_t v16 = [v13 protectedDatabase];
      uint64_t v17 = [v16 executeUncachedSQL:@"DROP TABLE IF EXISTS onboarding_completions" error:a4] ^ 1;
    }
    else
    {
      uint64_t v17 = 1;
    }
  }
LABEL_11:

  return v17;
}

uint64_t _HDRecreateCHRConditionsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = [v5 protectedDatabase];
  int v7 = [v6 deleteDataEntitySubclassTablesIfExist:&unk_1F17E9A68 intermediateTables:&unk_1F17E9A80 error:a4];

  if (v7)
  {
    id v8 = [v5 protectedDatabase];
    v12[0] = @"CREATE TABLE condition_record_samples (data_id INTEGER PRIMARY KEY, condition_coding_collection BLOB NOT NULL, categories_coding_collections BLOB NOT NULL, asserter TEXT, abatement BLOB, onset BLOB, recorded_date BLOB, clinical_status_coding BLOB, verification_status_coding BLOB, severity_coding_collection BLOB, body_sites_coding_collections BLOB)";
    uint64_t v9 = [MEMORY[0x1E4F1C978] arrayWithObjects:v12 count:1];
    uint64_t v10 = [v8 executeSQLStatements:v9 error:a4] ^ 1;
  }
  else
  {
    uint64_t v10 = 1;
  }

  return v10;
}

uint64_t _HDUpdateSleepAndAppetiteChangesCategoryValues(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = NSString;
  uint64_t v6 = *MEMORY[0x1E4F65C80];
  id v7 = a2;
  objc_msgSend(v5, "stringWithFormat:", @"UPDATE category_samples SET value = 0 WHERE data_id IN (SELECT objects.data_id FROM objects INNER JOIN samples USING (data_id) INNER JOIN data_provenances ON (objects.provenance = data_provenances.rowid) WHERE (data_type=164 OR data_type=169 OR data_type=170) AND NOT (%@(origin_build, '17G41') > 0 AND %@(origin_build, '18A1') < 0));",
    v6,
  id v8 = v6);
  uint64_t v9 = [v7 protectedDatabase];

  uint64_t v10 = [v9 executeUncachedSQL:v8 error:a4] ^ 1;
  return v10;
}

uint64_t _HDRepairECGSymptomsStatusForNilSymptomsMetadata(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = a2;
  uint64_t v6 = [v5 protectedDatabase];
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  uint64_t v9[2] = ___HDRepairECGSymptomsStatusForNilSymptomsMetadata_block_invoke;
  v9[3] = &unk_1E62F3D60;
  id v10 = v5;
  uint64_t v11 = @"UPDATE ecg_samples SET symptoms_status = ? WHERE data_id = ?;";
  id v7 = v5;
  LODWORD(a4) = objc_msgSend(v6, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", @"SELECT objects.data_id, a.numerical_value                                     FROM objects                                     INNER JOIN ecg_samples USING (data_id)                                     LEFT JOIN metadata_values a ON ((a.object_id = objects.data_id) AND (a.key_id=(SELECT rowid FROM metadata_keys WHERE key='_HKPrivateMetadataKeyElectrocardiogramSymptoms')));",
                  a4,
                  0,
                  v9);

  return a4 ^ 1;
}

uint64_t _HDUpdateNullTypeValesInObjectsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"UPDATE objects SET type=1 WHERE type IS NULL" error:a4] ^ 1;

  return v6;
}

uint64_t _HDRenameSCWIAndAddSeymourMediaTypeColumnToFriendWorkoutTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9A98 error:a4] ^ 1;

  return v6;
}

uint64_t _HDUpdateCoverageAddIdentifierColumnsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9AB0 error:a4] ^ 1;

  return v6;
}

void sub_1BCE603B8(_Unwind_Exception *a1)
{
}

void sub_1BCE60A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDSyncAnchorRangeDescription(uint64_t a1, uint64_t a2)
{
  return [NSString stringWithFormat:@"(%lld, %lld)", a1, a2];
}

uint64_t HDSyncVersionRangeToString(unint64_t a1)
{
  return [NSString stringWithFormat:@"[%d, %d]", a1, HIDWORD(a1)];
}

void sub_1BCE61C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__99(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__99(uint64_t a1)
{
}

void sub_1BCE6206C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1BCE623B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1BCE62F28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t __Block_byref_object_copy__100(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__100(uint64_t a1)
{
}

void sub_1BCE63EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_1BCE64A78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_1BCE65C3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE67430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE690B4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Block_object_dispose((const void *)(v1 - 224), 8);
  _Unwind_Resume(a1);
}

void sub_1BCE6D004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__101(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__101(uint64_t a1)
{
}

void sub_1BCE6FBEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE70304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a47, 8);
  _Block_object_dispose(&a51, 8);
  _Block_object_dispose((const void *)(v51 - 256), 8);
  _Block_object_dispose((const void *)(v51 - 224), 8);
  _Block_object_dispose((const void *)(v51 - 192), 8);
  _Block_object_dispose((const void *)(v51 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1BCE707F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BCE73A90(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Unwind_Resume(a1);
}

void sub_1BCE748C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose((const void *)(v39 - 240), 8);
  _Unwind_Resume(a1);
}

void sub_1BCE779A4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1BCE7A3A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getUIHealthAuthorizationActionClass_block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  v6[0] = 0;
  if (!qword_1EBA18C18)
  {
    v6[1] = (void *)MEMORY[0x1E4F143A8];
    void v6[2] = (void *)3221225472;
    uint64_t v6[3] = __UIKitLibraryCore_block_invoke;
    void v6[4] = &__block_descriptor_40_e5_v8__0l;
    void v6[5] = v6;
    long long v7 = xmmword_1E63016E0;
    uint64_t v8 = 0;
    qword_1EBA18C18 = _sl_dlopen();
  }
  if (!qword_1EBA18C18)
  {
    uint64_t v3 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v4 = [NSString stringWithUTF8String:"void *UIKitLibrary(void)"];
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, @"HDAuthorizationManager.m", 59, @"%s", v6[0]);

    goto LABEL_10;
  }
  if (v6[0]) {
    free(v6[0]);
  }
  Class result = objc_getClass("UIHealthAuthorizationAction");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    uint64_t v3 = [MEMORY[0x1E4F28B00] currentHandler];
    id v5 = [NSString stringWithUTF8String:"Class getUIHealthAuthorizationActionClass(void)_block_invoke"];
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v5, @"HDAuthorizationManager.m", 60, @"Unable to find class %s", "UIHealthAuthorizationAction");

LABEL_10:
    __break(1u);
  }
  _MergedGlobals_206 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __UIKitLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  qword_1EBA18C18 = result;
  return result;
}

uint64_t HDCodableUserDomainConceptNamedQuantityReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v15 = v9++ >= 9;
        if (v15)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v18 = PBReaderReadString();
          uint64_t v19 = 40;
          goto LABEL_26;
        case 2u:
          *(unsigned char *)(a1 + 60) |= 4u;
          uint64_t v21 = *v3;
          unint64_t v22 = *(void *)(a2 + v21);
          if (v22 <= 0xFFFFFFFFFFFFFFF7 && v22 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v23 = *(void *)(*(void *)(a2 + *v7) + v22);
            *(void *)(a2 + v21) = v22 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v23 = 0;
          }
          uint64_t v48 = 24;
          goto LABEL_68;
        case 3u:
          uint64_t v18 = PBReaderReadString();
          uint64_t v19 = 48;
LABEL_26:
          id v24 = *(void **)(a1 + v19);
          *(void *)(a1 + v19) = v18;

          continue;
        case 4u:
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          *(unsigned char *)(a1 + 60) |= 2u;
          while (2)
          {
            uint64_t v28 = *v3;
            uint64_t v29 = *(void *)(a2 + v28);
            unint64_t v30 = v29 + 1;
            if (v29 == -1 || v30 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v31 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
              *(void *)(a2 + v2_Block_object_dispose(&STACK[0x258], 8) = v30;
              v27 |= (unint64_t)(v31 & 0x7F) << v25;
              if (v31 < 0)
              {
                v25 += 7;
                BOOL v15 = v26++ >= 9;
                if (v15)
                {
                  uint64_t v27 = 0;
                  goto LABEL_54;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v27 = 0;
          }
LABEL_54:
          uint64_t v47 = 16;
          goto LABEL_59;
        case 5u:
          char v32 = 0;
          unsigned int v33 = 0;
          uint64_t v27 = 0;
          *(unsigned char *)(a1 + 60) |= 8u;
          while (2)
          {
            uint64_t v34 = *v3;
            uint64_t v35 = *(void *)(a2 + v34);
            unint64_t v36 = v35 + 1;
            if (v35 == -1 || v36 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v37 = *(unsigned char *)(*(void *)(a2 + *v7) + v35);
              *(void *)(a2 + v34) = v36;
              v27 |= (unint64_t)(v37 & 0x7F) << v32;
              if (v37 < 0)
              {
                v32 += 7;
                BOOL v15 = v33++ >= 9;
                if (v15)
                {
                  uint64_t v27 = 0;
                  goto LABEL_58;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v27 = 0;
          }
LABEL_58:
          uint64_t v47 = 32;
LABEL_59:
          *(void *)(a1 + v47) = v27;
          continue;
        case 6u:
          *(unsigned char *)(a1 + 60) |= 1u;
          uint64_t v38 = *v3;
          unint64_t v39 = *(void *)(a2 + v38);
          if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v23 = *(void *)(*(void *)(a2 + *v7) + v39);
            *(void *)(a2 + v3_Block_object_dispose(&STACK[0x258], 8) = v39 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v23 = 0;
          }
          uint64_t v48 = 8;
LABEL_68:
          *(void *)(a1 + v4_Block_object_dispose(&STACK[0x258], 8) = v23;
          continue;
        case 7u:
          char v40 = 0;
          unsigned int v41 = 0;
          uint64_t v42 = 0;
          *(unsigned char *)(a1 + 60) |= 0x10u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v43 = *v3;
        uint64_t v44 = *(void *)(a2 + v43);
        unint64_t v45 = v44 + 1;
        if (v44 == -1 || v45 > *(void *)(a2 + *v4)) {
          break;
        }
        char v46 = *(unsigned char *)(*(void *)(a2 + *v7) + v44);
        *(void *)(a2 + v43) = v45;
        v42 |= (unint64_t)(v46 & 0x7F) << v40;
        if ((v46 & 0x80) == 0) {
          goto LABEL_61;
        }
        v40 += 7;
        BOOL v15 = v41++ >= 9;
        if (v15)
        {
          uint64_t v42 = 0;
          goto LABEL_63;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_61:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v42 = 0;
      }
LABEL_63:
      *(unsigned char *)(a1 + 56) = v42 != 0;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCE81E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__102(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__102(uint64_t a1)
{
}

void sub_1BCE82C28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&STACK[0x298], 8);
  _Block_object_dispose(&STACK[0x2B8], 8);
  _Block_object_dispose(&STACK[0x2D8], 8);
  _Block_object_dispose(&STACK[0x2F8], 8);
  _Block_object_dispose(&a65, 8);
  _Unwind_Resume(a1);
}

BOOL HDCodableSharingSetupInvitationTokenReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = 8;
LABEL_22:
        uint64_t v19 = *(void **)(a1 + v18);
        *(void *)(a1 + v1_Block_object_dispose(&STACK[0x258], 8) = v17;

        goto LABEL_24;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_24:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v17 = PBReaderReadData();
    uint64_t v18 = 16;
    goto LABEL_22;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BCE880C0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

HDAssociatableObjectReference *HDReferenceForAssociatableObject(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v2 = [HDAssociatableObjectReference alloc];
    uint64_t v3 = [v1 UUID];
    uint64_t v4 = [(HDAssociatableObjectReference *)v2 initWithUUID:v3 objectClass:objc_opt_class()];
  }
  else
  {
    uint64_t v4 = 0;
  }

  return v4;
}

HDAssociatableObjectReference *HDReferenceForUnknownAssociatableObjectWithUUID(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    uint64_t v2 = [[HDAssociatableObjectReference alloc] initWithUUID:v1 objectClass:objc_opt_class()];
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

HDAssociatableObjectReference *HDReferenceForUnknownAssociatableObjectWithPersistentID(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = [(HDSQLiteEntity *)[HDWorkoutActivityEntity alloc] initWithPersistentID:a1];
  long long v7 = v6;
  if (v6)
  {
    id v8 = [(HDWorkoutActivityEntity *)v6 UUIDInTransaction:v5 error:a3];
    unsigned int v9 = [[HDAssociatableObjectReference alloc] initWithUUID:v8 objectClass:objc_opt_class()];
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_error:format:", 3, @"No entity found for persistentID");
    id v8 = (id)objc_claimAutoreleasedReturnValue();
    if (v8)
    {
      if (a3) {
        *a3 = v8;
      }
      else {
        _HKLogDroppedError();
      }
    }

    unsigned int v9 = 0;
  }

  return v9;
}

void sub_1BCE8F550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCE8F6B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCE8F7D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCE8F948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);

  _Block_object_dispose(va, 8);
  std::unique_ptr<health::DataStore>::reset[abi:ne180100](v11, 0);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__103(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 4_Block_object_dispose(&STACK[0x258], 8) = 0;
  *(void *)(result + 4_Block_object_dispose(&STACK[0x258], 8) = v2;
  return result;
}

health::TransactionalFile *__Block_byref_object_dispose__103(uint64_t a1)
{
  return std::unique_ptr<health::DataStore>::reset[abi:ne180100]((health::TransactionalFile **)(a1 + 48), 0);
}

void sub_1BCE8FA84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  MEMORY[0x1C187B8A0](v17, 0x10B2C40074D0DA0);
  _Unwind_Resume(a1);
}

void sub_1BCE8FC80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BCE8FE4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

health::TransactionalFile *std::unique_ptr<health::DataStore>::reset[abi:ne180100](health::TransactionalFile **a1, health::TransactionalFile *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    health::TransactionalFile::~TransactionalFile(result);
    JUMPOUT(0x1C187B8A0);
  }
  return result;
}

void sub_1BCE90050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BCE909E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__104(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__104(uint64_t a1)
{
}

uint64_t HDIsValidTinkerEventIdentifier(void *a1)
{
  id v1 = (void *)MEMORY[0x1E4F1CAD0];
  id v2 = a1;
  uint64_t v3 = objc_msgSend(v1, "setWithObjects:", @"TinkerPrivacyAlertEventSharingSetUp", @"TinkerPrivacyAlertEventBirthday", @"TinkerPrivacyAlertEventTesting", 0);
  uint64_t v4 = [v3 containsObject:v2];

  return v4;
}

void sub_1BCE90D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1BCE915BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1BCE917B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableStaticSyncChangeSetReadFrom(void *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = objc_alloc_init(HDCodableNanoSyncChange);
        [a1 addChanges:v17];
        if (!PBReaderPlaceMark() || (HDCodableNanoSyncChangeReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t __Block_byref_object_copy__105(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__105(uint64_t a1)
{
}

uint64_t _HDAddCloudSyncStoreShardColumns(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9BD0 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddCKRecordCacheTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9BE8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddOnboardingCompletionsCountryCodeProvenanceColumn(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9C00 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddAppSDKVersionFlagColumn(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9C18 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddNeedsFetchColumnToCachedCKRecordZoneEntity(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9C30 error:a4] ^ 1;

  return v6;
}

uint64_t _HDResetUnprotectedCKRecordCache(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9C48 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddZoneStateColumnToCachedCKRecordZoneEntity(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9C60 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddUserRecordIDToCKDatabaseCache(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9C78 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddEpochManagementForCloudCache(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9C90 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddWorkoutBuilderActivitiesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9CA8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDFixWorkoutBuilderActivitiesForeignKey(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9CC0 error:a4] ^ 1;

  return v6;
}

uint64_t _HDMakeWorkoutBuilderActivityEndDateNullable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9CD8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDResetUnprotectedInconsistentCloudCache(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9CF0 error:a4] ^ 1;

  return v6;
}

uint64_t _HDRemoveOtherCardioFitnessMedications(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = a1;
  id v7 = a2;
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x2020000000;
  uint64_t v25 = 0;
  char v8 = [v7 protectedDatabase];
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3221225472;
  void v21[2] = ___HDRemoveOtherCardioFitnessMedications_block_invoke;
  void v21[3] = &unk_1E62F3640;
  void v21[4] = &v22;
  char v9 = objc_msgSend(v8, "executeUncachedSQL:error:bindingHandler:enumerationHandler:", @"SELECT value FROM key_value_secure WHERE key = 'cardio_fitness_medications_use' AND category = 101;",
         a4,
         0,
         v21);

  if (v9)
  {
    v23[3] &= ~4uLL;
    unint64_t v10 = [v7 protectedDatabase];
    char v11 = objc_msgSend(v10, "executeSQL:error:bindingHandler:enumerationHandler:", @"DELETE FROM key_value_secure WHERE key = 'cardio_fitness_medications_use';",
            a4,
            0,
            0);

    if (v11)
    {
      unint64_t v12 = [MEMORY[0x1E4F1C9C8] date];
      char v13 = [v7 protectedDatabase];
      v18[0] = MEMORY[0x1E4F143A8];
      v18[1] = 3221225472;
      void v18[2] = ___HDRemoveOtherCardioFitnessMedications_block_invoke_2;
      v18[3] = &unk_1E6301B98;
      id v20 = &v22;
      id v14 = v12;
      id v19 = v14;
      int v15 = objc_msgSend(v13, "executeSQL:error:bindingHandler:enumerationHandler:", @"INSERT INTO key_value_secure (category, domain, key, value, provenance, mod_date) values (101, '', 'cardio_fitness_medications_use', ?, 0, ?);",
              a4,
              v18,
              0);

      uint64_t v16 = v15 ^ 1u;
    }
    else
    {
      uint64_t v16 = 1;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  _Block_object_dispose(&v22, 8);

  return v16;
}

void sub_1BCE95CAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _HDAddAdHocConceptTable(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = a1;
  id v7 = a2;
  char v8 = [v7 protectedDatabase];
  int v9 = [v8 executeSQLStatements:&unk_1F17E9D08 error:a4];

  if (v9)
  {
    uint64_t v32 = 0;
    unsigned int v33 = &v32;
    uint64_t v34 = 0x3032000000;
    uint64_t v35 = __Block_byref_object_copy__106;
    unint64_t v36 = __Block_byref_object_dispose__106;
    id v37 = 0;
    unint64_t v10 = [v7 unprotectedDatabase];
    v29[0] = MEMORY[0x1E4F143A8];
    v29[1] = 3221225472;
    void v29[2] = ___HDAddAdHocConceptTable_block_invoke;
    std::string::size_type v29[3] = &unk_1E62F2900;
    unint64_t v30 = @"com.apple.health.records";
    char v31 = @"Indexer-State";
    v28[0] = MEMORY[0x1E4F143A8];
    v28[1] = 3221225472;
    void v28[2] = ___HDAddAdHocConceptTable_block_invoke_2;
    v28[3] = &unk_1E62F3640;
    uint64_t v28[4] = &v32;
    char v11 = [v10 executeUncachedSQL:@"SELECT value FROM key_value WHERE ((category = ?) AND (domain = ?) AND (key = ?))" error:a4 bindingHandler:v29 enumerationHandler:v28];

    if ((v11 & 1) == 0)
    {
      uint64_t v17 = 1;
LABEL_16:

      _Block_object_dispose(&v32, 8);
      goto LABEL_17;
    }
    if (v33[5])
    {
      id v12 = objc_alloc(MEMORY[0x1E4F28DC0]);
      char v13 = (HDConceptIndexState *)[v12 initForReadingFromData:v33[5] error:a4];
      [(HDConceptIndexState *)v13 setClass:objc_opt_class() forClassName:@"HDConceptIndexManagerState"];
      id v14 = [(HDConceptIndexState *)v13 decodeObjectOfClass:objc_opt_class() forKey:*MEMORY[0x1E4F284E8]];
      int v15 = v14;
      if (!v14)
      {
        uint64_t v17 = 1;
LABEL_15:

        goto LABEL_16;
      }
      uint64_t v16 = +[HDConceptIndexState stateWithGeneration:](HDConceptIndexState, "stateWithGeneration:", [v14 generation] + 1);

      char v13 = (HDConceptIndexState *)v16;
    }
    else
    {
      char v13 = objc_alloc_init(HDConceptIndexState);
    }
    uint64_t v18 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v13 requiringSecureCoding:1 error:a4];
    if (!v18 || (uint64_t v19 = [v6 fetchLegacySyncIdentity:v7 error:a4], v19 == -1))
    {
      uint64_t v17 = 1;
    }
    else
    {
      id v20 = [v7 unprotectedDatabase];
      v23[0] = MEMORY[0x1E4F143A8];
      v23[1] = 3221225472;
      void v23[2] = ___HDAddAdHocConceptTable_block_invoke_3;
      v23[3] = &unk_1E62F4098;
      id v24 = v18;
      uint64_t v25 = @"Indexer-State";
      unsigned int v26 = @"com.apple.health.records";
      uint64_t v27 = v19;
      int v21 = [v20 executeUncachedSQL:@"INSERT OR REPLACE INTO key_value (value, key, domain, category, provenance, mod_date, sync_identity) VALUES (?, ?, ?, ?, ?, ?, ?)", a4, v23, 0 error bindingHandler enumerationHandler];

      uint64_t v17 = v21 ^ 1u;
    }

    goto LABEL_15;
  }
  uint64_t v17 = 1;
LABEL_17:

  return v17;
}

void sub_1BCE9604C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t _HDAddSecureCKRecordCacheTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"CREATE TABLE IF NOT EXISTS ck_record_cache_secure (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, record_id INTEGER UNIQUE NOT NULL, record_data BLOB)", a4 error] ^ 1;

  return v6;
}

uint64_t _HDUpdateMedicalRecordsDiagnosticResultTableAddReferenceRangeStatus(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  uint64_t v6 = [v5 protectedDatabase];
  int v7 = [v6 deleteDataEntitySubclassTablesIfExist:&unk_1F17E9D20 intermediateTables:&unk_1F17E9D38 error:a4];

  if (v7
    && ([v5 protectedDatabase],
        char v8 = objc_claimAutoreleasedReturnValue(),
        int v9 = [v8 executeUncachedSQL:@"UPDATE clinical_accounts SET last_extracted_rowid = NULL" error:a4], v8, v9))
  {
    unint64_t v10 = [v5 protectedDatabase];
    v14[0] = @"CREATE TABLE IF NOT EXISTS diagnostic_test_result_samples (data_id INTEGER PRIMARY KEY, diagnostic_test_coding_collection BLOB NOT NULL, value BLOB, reference_ranges BLOB, effective_start_date BLOB, category TEXT NOT NULL, categories_coding_collections BLOB NOT NULL, issue_date BLOB, effective_end_date BLOB, status_coding BLOB NOT NULL, interpretation_coding_collections BLOB, comments TEXT, body_site_coding_collection BLOB, method_coding_collection BLOB, performers BLOB, reference_range_status INTEGER NOT NULL);";
    char v11 = [MEMORY[0x1E4F1C978] arrayWithObjects:v14 count:1];
    uint64_t v12 = [v10 executeSQLStatements:v11 error:a4] ^ 1;
  }
  else
  {
    uint64_t v12 = 1;
  }

  return v12;
}

uint64_t _HDRecreateCHRMedicationTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = a2;
  uint64_t v6 = [v5 protectedDatabase];
  int v7 = [v6 deleteDataEntitySubclassTablesIfExist:&unk_1F17E9D50 intermediateTables:&unk_1F17E9D68 error:a4];

  if (v7)
  {
    char v8 = [v5 protectedDatabase];
    uint64_t v9 = [v8 executeSQLStatements:&unk_1F17E9D80 error:a4] ^ 1;
  }
  else
  {
    uint64_t v9 = 1;
  }

  return v9;
}

uint64_t _HDAddSampleAggregateCacheEntitiesTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9D98 error:a4] ^ 1;

  return v6;
}

uint64_t _HDUpdateAllergyRecordSamplesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  uint64_t v6 = [v5 protectedDatabase];
  int v7 = [v6 deleteDataEntitySubclassTablesIfExist:&unk_1F17E9DB0 intermediateTables:&unk_1F17E9DC8 error:a4];

  if (v7)
  {
    char v8 = [v5 protectedDatabase];
    v12[0] = @"CREATE TABLE allergy_record_samples (data_id INTEGER PRIMARY KEY, allergy_coding_collection BLOB NOT NULL, onset_date BLOB, asserter TEXT, reactions BLOB, criticality_coding BLOB, last_occurrence_date BLOB, recorded_date BLOB, verification_status_coding BLOB, clinical_status_coding BLOB, allergy_type_coding BLOB, category_coding BLOB)";
    uint64_t v9 = [MEMORY[0x1E4F1C978] arrayWithObjects:v12 count:1];
    uint64_t v10 = [v8 executeSQLStatements:v9 error:a4] ^ 1;
  }
  else
  {
    uint64_t v10 = 1;
  }

  return v10;
}

uint64_t _HDAddUserDomainConceptEntities(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  uint64_t v6 = [v5 protectedDatabase];
  int v7 = [v6 executeSQLStatements:&unk_1F17E9DE0 error:a4];

  if (v7)
  {
    char v8 = [v5 protectedDatabase];
    int v9 = [v8 executeUncachedSQL:@"UPDATE clinical_accounts SET last_extracted_rowid = NULL" error:a4];

    if (v9)
    {
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      uint64_t v10 = [&unk_1F17E9E10 countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (!v10)
      {
        uint64_t v16 = 0;
        goto LABEL_13;
      }
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)v19;
LABEL_5:
      uint64_t v13 = 0;
      while (1)
      {
        if (*(void *)v19 != v12) {
          objc_enumerationMutation(&unk_1F17E9E10);
        }
        uint64_t v14 = *(void *)(*((void *)&v18 + 1) + 8 * v13);
        int v15 = [v5 protectedDatabase];
        LODWORD(v14) = [v15 deleteRowsFromDataEntitySubclassTable:v14 intermediateTables:&unk_1F17E9DF8 error:a4];

        if (!v14) {
          break;
        }
        if (v11 == ++v13)
        {
          uint64_t v11 = [&unk_1F17E9E10 countByEnumeratingWithState:&v18 objects:v22 count:16];
          uint64_t v16 = 0;
          if (v11) {
            goto LABEL_5;
          }
          goto LABEL_13;
        }
      }
    }
  }
  uint64_t v16 = 1;
LABEL_13:

  return v16;
}

uint64_t _HDAddSharingAuthorizationAndRelationshipTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9E28 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddAnchorDateToCachedQueriesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9E40 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddSummarySharingTables(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9E58 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddQuantitySeriesDataTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9E70 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddLocationSeriesDataTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9E88 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddSignedClinicalDataIssuerEntitiesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9EA0 error:a4] ^ 1;

  return v6;
}

uint64_t _HDUpdateClinicalAccountsTableForIssuerBackingAndOsloStatus(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9EB8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddOriginalSignedClinicalDataRecordEntitiesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9ED0 error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddSignedClinicalDataRecordEntitiesTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9EE8 error:a4] ^ 1;

  return v6;
}

uint64_t _HDUpdateMedicalRecordEntitiesTableForSCD(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  LODWORD(a4) = [v5 executeSQLStatements:&unk_1F17E9F00 error:a4];

  return a4 ^ 1;
}

uint64_t _HDAddSessionColumnToObjectAuthorizationsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"ALTER TABLE object_authorizations ADD COLUMN session BLOB" error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddDateAcceptedToSummarySharingEntryTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9F18 error:a4] ^ 1;

  return v6;
}

uint64_t _HDPurgeDeletedUserDomainConcepts(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"DELETE FROM user_domain_concepts WHERE deleted" error:a4] ^ 1;

  return v6;
}

uint64_t _HDAddClinicalAccountColumnsForFetchFailureTracking(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  LODWORD(a4) = [v5 executeSQLStatements:&unk_1F17E9F30 error:a4];

  return a4 ^ 1;
}

uint64_t _HDRemoveDeletedAndSyncedColumnFromSharedSummaryTransactionsTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v5 = [a2 protectedDatabase];
  uint64_t v6 = [v5 executeSQLStatements:&unk_1F17E9F48 error:a4] ^ 1;

  return v6;
}