@interface SASampleStore
+ (BOOL)canOpenFileAsKTraceFile:(const char *)a3 errorOut:(id *)a4;
+ (BOOL)supportsSecureCoding;
+ (id)sampleStoreForBinaryFormat:(id)a3;
+ (id)sampleStoreForSpindumpFile:(const char *)a3;
- (BOOL)appleInternalIsKnown;
- (BOOL)cacheLoadInfoForProcess:(int)a3;
- (BOOL)findCpuSignalHandlerStackLeafKernelFrame;
- (BOOL)hardwareKeyboard;
- (BOOL)hasEnterprisePersona;
- (BOOL)hasHardwareKeyboardInfo;
- (BOOL)hasInternalCarryDeviceDistinction;
- (BOOL)haveCPUClusterInfo;
- (BOOL)haveKPerfSched;
- (BOOL)isAppleInternal;
- (BOOL)isECoreForCPUNum:(unsigned int)a3;
- (BOOL)isEmpty;
- (BOOL)isInternalCarryDevice;
- (BOOL)isPCoreForCPUNum:(unsigned int)a3;
- (BOOL)isRootInstalled;
- (BOOL)kPerfPETParsePastLastStackshot;
- (BOOL)keepMicrostackshotsWithoutLoadInfo;
- (BOOL)keepStateBetweenSampleIndexes;
- (BOOL)omitSensitiveStrings;
- (BOOL)parseKTraceFile:(const char *)a3 warningsOut:(id)a4 errorOut:(id *)a5;
- (BOOL)parseStackshotsFromKTraceFile:(const char *)a3 warningsOut:(id)a4 errorOut:(id *)a5;
- (BOOL)sampleOnlyMainThreads;
- (BOOL)sanitizePaths;
- (BOOL)saveBinaryFormatToStream:(__sFILE *)a3;
- (BOOL)setTargetProcessWithHint:(id)a3;
- (BOOL)shouldGatherKextStat;
- (BOOL)stackshotsOnlyIncludeSpecificProcesses;
- (NSArray)exclaves;
- (NSArray)hidEvents;
- (NSArray)installedRootNames;
- (NSArray)ioEvents;
- (NSArray)kernelCaches;
- (NSArray)keyboardLanguages;
- (NSArray)kperfTriggers;
- (NSArray)memoryPressureEvents;
- (NSArray)models;
- (NSArray)powerModeTransitions;
- (NSArray)preferredLanguages;
- (NSArray)sampleTimestamps;
- (NSArray)sharedCaches;
- (NSDictionary)activeTrials;
- (NSDictionary)homeVolumeSpace;
- (NSDictionary)nonDefaultFeatureFlags;
- (NSDictionary)systemAdvisoryLevels;
- (NSDictionary)tasksByPid;
- (NSDictionary)tasksByUniquePid;
- (NSError)wrError;
- (NSObject)_taskForPid:(uint64_t)a3 uniquePid:(unsigned char *)a4 name:(uint64_t)a5 pidStartTime:(NSObject *)a6 loadInfos:(unsigned int)a7 numLoadInfos:(char)a8 loadInfosIsPartial:(NSObject *)a9 textExecLoadInfos:(unsigned int)a10 numTextExecLoadInfos:(char)a11 textExecLoadInfosIsPartial:(uint64_t)a12 architecture:(void *)a13 timestamp:(void *)a14 sharedCache:(char)a15 needAOTInfo:;
- (NSString)actionTaken;
- (NSString)automatedDeviceGroup;
- (NSString)bootArgs;
- (NSString)countryCode;
- (NSString)customOutput;
- (NSString)durationNote;
- (NSString)event;
- (NSString)eventNote;
- (NSString)hardwareModel;
- (NSString)kernelVersion;
- (NSString)kextStat;
- (NSString)machineArchitecture;
- (NSString)osBuildVersion;
- (NSString)osProductName;
- (NSString)osProductVersion;
- (NSString)osProductVersionExtra;
- (NSString)reason;
- (NSString)signature;
- (NSString)stepsNote;
- (NSString)targetProcessAbsolutePath;
- (NSString)targetProcessBundleBuildVersion;
- (NSString)targetProcessBundleId;
- (NSString)targetProcessBundleName;
- (NSString)targetProcessBundleProductBuildVersion;
- (NSString)targetProcessBundleProjectName;
- (NSString)targetProcessBundleShortVersion;
- (NSString)targetProcessBundleSourceVersion;
- (NSString)targetProcessBundleVersion;
- (NSString)targetProcessCommerceAppID;
- (NSString)targetProcessCommerceExternalID;
- (NSString)targetProcessName;
- (NSString)targetProcessVendorID;
- (NSString)wrDiagnosticName;
- (NSString)wrSignpostCategory;
- (NSString)wrSignpostName;
- (NSString)wrSignpostSubsystem;
- (NSString)wrTriggeringSignpostCategory;
- (NSString)wrTriggeringSignpostName;
- (NSString)wrTriggeringSignpostSubsystem;
- (NSString)wrWorkflowName;
- (SAFrame)cpuSignalHandlerStackLeafKernelFrame;
- (SAMountStatusTracker)mountStatusTracker;
- (SASampleStore)init;
- (SASampleStore)initWithCoder:(id)a3;
- (SATask)targetProcess;
- (SATimeRange)eventTimeRange;
- (SATimestamp)endTime;
- (SATimestamp)startTime;
- (SATimestamp)timeWhenTransitionedToSamplingAllProcesses;
- (SATimestamp)timeWhenTransitionedToSamplingAllThreads;
- (SATimestamp)timestampOfLastStackshot;
- (double)_getLastWakeTime;
- (double)attemptedSamplingInterval;
- (double)cpuDuration;
- (double)cpuLimit;
- (double)cpuLimitDuration;
- (double)cpuUsed;
- (double)extraDuration;
- (double)kPerfPETSampleIntervalLimit;
- (double)lastWakeTime;
- (double)reportTimeThreshold;
- (double)wakeupsDuration;
- (double)wakeupsLimitDuration;
- (double)wrSignpostDurationSingle;
- (double)wrSignpostDurationSingleThreshold;
- (double)wrSignpostDurationSum;
- (double)wrSignpostDurationSumThreshold;
- (double)wrSignpostDurationUnion;
- (double)wrSignpostDurationUnionThreshold;
- (double)wrWorkflowDuration;
- (double)wrWorkflowDurationOmittingNetworkBoundIntervals;
- (double)wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold;
- (double)wrWorkflowDurationThreshold;
- (double)wrWorkflowTimeoutDuration;
- (double)writeDuration;
- (double)writeLimitDuration;
- (id)_firstTaskOnOrAfterTimestamp:(void *)a1 inTasks:(void *)a2;
- (id)_lastTaskOnOrBeforeTimestamp:(void *)a3 inTasks:;
- (id)addPowerModeTransition:(id *)a1;
- (id)addressTranslationsForPid:(uint64_t)a1;
- (id)applySharedCacheToTask:(uint64_t)a3 uuid:(uint64_t)a4 slide:(uint64_t)a5 slidBaseAddress:;
- (id)binaryFormat;
- (id)callTreeForDispatchQueue:(id)a3 andThread:(id)a4 inTask:(id)a5 options:(id)a6;
- (id)callTreeForDispatchQueue:(id)a3 swiftTask:(id)a4 thread:(id)a5 inTask:(id)a6 options:(id)a7;
- (id)callTreeForExecutable:(id)a3 options:(id)a4;
- (id)callTreeForSwiftTask:(id)a3 thread:(id)a4 inTask:(id)a5 options:(id)a6;
- (id)callTreeForTask:(id)a3 options:(id)a4;
- (id)callTreeForThread:(id)a3 inTask:(id)a4 options:(id)a5;
- (id)callTreesForThreadsInTask:(id)a3 options:(id)a4;
- (id)fanSpeedClosestToTimestamp:(id)a3;
- (id)fixupAllFrames;
- (id)idleThreadSet;
- (id)initForFileParsing;
- (id)initForLiveSampling;
- (id)lastTaskWithPid:(uint64_t)a3 orTid:;
- (id)loadInfosForKTSymbolOwners:(int)a3 isKernelSpace:(uint64_t)a4 excludeRange:(unint64_t)a5;
- (id)sharedCacheWithUUID:(uint64_t)a3 slide:(uint64_t)a4 slidBaseAddress:;
- (id)taskForKCDataDeltaTask:(NSObject *)a3 loadInfos:(unsigned int)a4 numLoadInfos:(char)a5 loadInfosIsPartial:(NSObject *)a6 textExecLoadInfos:(unsigned int)a7 numTextExecLoadInfos:(char)a8 textExecLoadInfosIsPartial:(void *)a9 timestamp:(void *)a10 sharedCache:(char)a11 needAOTInfo:;
- (id)taskForKCDataTask:(NSObject *)a3 loadInfos:(unsigned int)a4 numLoadInfos:(char)a5 loadInfosIsPartial:(NSObject *)a6 textExecLoadInfos:(unsigned int)a7 numTextExecLoadInfos:(char)a8 textExecLoadInfosIsPartial:(uint64_t)a9 architecture:(void *)a10 timestamp:(void *)a11 sharedCache:(char)a12 needAOTInfo:;
- (id)taskForKCDataTransitioningTask:(void *)a1 loadInfos:(uint64_t)a2 numLoadInfos:(NSObject *)a3 loadInfosIsPartial:(unsigned int)a4 textExecLoadInfos:(char)a5 numTextExecLoadInfos:(NSObject *)a6 textExecLoadInfosIsPartial:(unsigned int)a7 architecture:(char)a8 timestamp:(void *)a9 sharedCache:(void *)a10 needAOTInfo:(char)a11;
- (id)taskForMicrostackshotTask:(char *)a3 taskName:(NSObject *)a4 loadInfos:(unsigned int)a5 numLoadInfos:(void *)a6 sharedCache:(int)a7 loadInfosIsPartial:(void *)a8 timestamp:(uint64_t)a9 architecture:(char)a10 needAOTInfo:(char)a11 isFromCurrentBoot:;
- (id)taskForPid:(void *)a3 andName:(void *)a4 didExecAtTimestamp:;
- (id)taskWithPid:(uint64_t)a3 orTid:(void *)a4 atTimestamp:;
- (id)taskWithPid:(void *)a3 atTimestamp:;
- (id)tidToPidDict;
- (id)tidsForPid:(int)a3;
- (int)addMicrostackshotsFromFile:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8;
- (int)addMicrostackshotsFromFile:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8 statistics:(id)a9;
- (int)gatherHWPageSize;
- (int)gatherVMPageSize;
- (int)targetProcessId;
- (int64_t)addMicrostackshotsFromData:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8;
- (int64_t)addMicrostackshotsFromData:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8 statistics:(id)a9;
- (int64_t)numOSCryptexFileExtents;
- (mach_timebase_info)machTimebase;
- (uint64_t)_addKCDataStackshot:(void *)a3 timestamp:(unint64_t)a4 sampleIndex:(unsigned char *)a5 shouldSkipSampleOut:(unsigned int)a6 primaryDataIsKPerf:(char)a7 addStaticInfoOnly:;
- (uint64_t)_parseKCDataSharedCacheContainer:(void *)a3 sharedCaches:;
- (uint64_t)_parseKCDataTaskContainer:(void *)a3 timestampOfSample:(unint64_t)a4 sampleIndex:(void *)a5 sharedCaches:(void *)a6 frameIterator:(uint64_t)a7 primaryDataIsKPerf:(char)a8 addStaticInfoOnly:(void *)a9 taskUniquePidsInThisSample:(_OWORD *)a10 taskPidsInThisSample:(void *)a11 importanceDonations:(void *)a12 rPidForJetsamCoalitionId:(NSObject *)a13 port_label_info_array:(unsigned __int16 *)a14 exclaveInfo:(void *)a15;
- (uint64_t)_parseKCDataThreadContainer:(void *)a3 timestampOfSample:(unint64_t)a4 sampleIndex:(void *)a5 task:(void *)a6 kernelTask:(void *)a7 frameIterator:(NSObject *)a8 mainThreadID:(char)a9 primaryDataIsKPerf:(char)a10 addStaticInfoOnly:(void *)a11 threadIDsInThisTaskThisSample:(NSObject *)a12 dispatchQueueIDsInThisTaskThisSample:(char)a13 taskIsSuspended:(uint64_t)a14 waitInfos:(unsigned int)a15 numWaitInfos:(uint64_t)a16 turnstileInfos:(unsigned int)a17 numTurnstileInfos:(int)a18 port_label_info_array:(unsigned int)a19 exclaveInfo:(unsigned __int16 *)a20;
- (uint64_t)_parseKTraceFile:(int)a3 stackshotsOnly:(void *)a4 warningsOut:(void *)a5 errorOut:;
- (uint64_t)addKCDataThreadV4:(uint64_t)a3 threadV2:(uint64_t)a4 deltaThreadV3:(uint64_t)a5 deltaThreadV2:(void *)a6 timestamp:(unint64_t)a7 sampleIndex:(void *)a8 stack:(void *)a9 threadExclavesInfo:(char *)a10 threadName:(id *)a11 dispatchQueueLabel:(uint64_t)a12 waitInfo:(void *)a13 waitInfoPortLabelInfo:(uint64_t)a14 turnstileInfo:(void *)a15 turnstileInfoPortLabelInfo:(uint64_t *)a16 instructionCycles:(void *)a17 task:(void *)a18 kernelTask:(char)a19 taskIsSuspended:;
- (uint64_t)checkDyldInfoCompletion:(uint64_t)a1;
- (uint64_t)parseKCDataExclavesContainer:(void *)a3 exclaveInfo:(uint64_t)a4 primaryDataIsKPerf:;
- (unint64_t)_addMicrostackshotFromData:(int)a3 ofTypes:(int)a4 inTimeRangeStart:(uint64_t)a5 end:(void *)a6 onlyPid:(double)a7 onlyTid:(double)a8 statistics:;
- (unint64_t)addKCDataStackshot:(id)a3;
- (unint64_t)addKCDataStackshot:(id)a3 returningTimestamp:(id *)a4;
- (unint64_t)addKCDataStackshots:(id)a3 createSeparateSamplePerStackshot:(BOOL)a4;
- (unint64_t)bytesWritten;
- (unint64_t)bytesWrittenLimit;
- (unint64_t)dataGatheringOptions;
- (unint64_t)dataSource;
- (unint64_t)dataStyle;
- (unint64_t)gpuRestartCount;
- (unint64_t)gpuRestartLastMachAbs;
- (unint64_t)indexOfFirstSampleOnOrAfterTimestamp:(id)a3;
- (unint64_t)indexOfLastSampleOnOrBeforeTimestamp:(id)a3;
- (unint64_t)numSamples;
- (unint64_t)numWakeups;
- (unint64_t)numWakeupsLimit;
- (unint64_t)targetDispatchQueueId;
- (unint64_t)targetHIDEventEndMachAbs;
- (unint64_t)targetHIDEventMachAbs;
- (unint64_t)targetThreadId;
- (unint64_t)wrSignpostCount;
- (unint64_t)wrSignpostCountThreshold;
- (unsigned)additionalCSSymbolicatorFlags;
- (unsigned)hwPageSize;
- (unsigned)numActiveCPUs;
- (unsigned)vmPageSize;
- (unsigned)workQueueHardThreadLimit;
- (unsigned)workQueueSoftThreadLimit;
- (void)_addKPerfDataFromKTraceSession:(uint64_t)a3 beforeMachAbsTime:(int)a4 petTimerID:;
- (void)_backfillPidStartTimestamp:(void *)a1 toPreviousTasksEnumerator:(void *)a2 execTimestampOfNextTask:(void *)a3;
- (void)_populateFromKtraceMachineInfo:(int)a3 is64bit:;
- (void)addAddressTranslations:(uint64_t)a1;
- (void)addAuxiliaryData:(id)a3;
- (void)addIOEvent:(uint64_t)a1;
- (void)addNewImageInfos:(unsigned int)a3 numLoadInfos:(const char *)a4 name:(void *)a5 sharedCache:(uint64_t)a6 architecture:(void *)a7 toTask:;
- (void)addProcessInfoFromTailspin:(id)a3;
- (void)addSharedCache:(uint64_t)a1;
- (void)addTask:(uint64_t)a1;
- (void)addUserCallstack:(unint64_t *)a3 numUserFrames:(unsigned int)a4 swiftAsyncCallstack:(unint64_t *)a5 numSwiftAsyncFrames:(unsigned int)a6 swiftAsyncStartIndex:(unsigned int)a7 kernelCallstack:(unint64_t *)a8 numKernelFrames:(unsigned int)a9 loadInfos:(const dyld_uuid_info_64 *)a10 numLoadInfos:(unsigned int)a11 textExecLoadInfos:(const dyld_uuid_info_64 *)a12 numTextExecLoadInfos:(unsigned int)a13 uniquePid:(unint64_t)a14 pid:(int)a15 processName:(id)a16 tid:(unint64_t)a17 timestamp:(id)a18 sharedCache:(id)a19;
- (void)addUserCallstack:(unint64_t *)a3 numUserFrames:(unsigned int)a4 swiftAsyncCallstack:(unint64_t *)a5 numSwiftAsyncFrames:(unsigned int)a6 swiftAsyncStartIndex:(unsigned int)a7 kernelCallstack:(unint64_t *)a8 numKernelFrames:(unsigned int)a9 uniquePid:(unint64_t)a10 pid:(int)a11 tid:(unint64_t)a12 timestamp:(id)a13;
- (void)backfillTask:(unint64_t)a3 lastSampleIndex:(void *)a4 timestamp:(char)a5 haveSnap:(uint64_t)a6 terminatedThreadsUserTimeInNs:(uint64_t)a7 terminatedThreadsSystemTimeInNs:(uint64_t)a8 terminatedThreadsCycles:(uint64_t)a9 terminatedThreadsInstructions:(int)a10 suspendCount:(int)a11 pageins:(char)a12 isDarwinBG:(char)a13 isForeground:(char)a14 isBoosted:(char)a15 isDirty:(char)a16 haveWQFlags:(char)a17 wqExceededTotalThreadLimit:(char)a18 wqExceededConstrainedThreadLimit:(char)a19 haveMem:(uint64_t)a20 taskSizeInBytes:(char)a21 haveLatencyQos:(int)a22 latencyQos:;
- (void)backfillThread:(void *)a3 inTask:(unint64_t)a4 lastSampleIndex:(void *)a5 timestamp:(char)a6 haveName:(unsigned char *)a7 name:(int)a8 haveDispatchQueueId:(uint64_t)a9 dispatchQueueId:(void *)a10 dispatchQueueLabel:(void *)a11 leafKernelFrame:(unsigned __int8)a12 hasExclaveInKernelStack:(char)a13 haveUserStack:(void *)a14 leafUserFrame:(uint64_t)a15 swiftTaskId:(void *)a16 leafOfCRootFramesReplacedBySwiftAsync:(void *)a17 threadExclavesInfo:(char)a18 haveSched:(uint64_t)a19 systemCpuTimeNs:(uint64_t)a20 userCpuTimeNs:(int)a21 basePriority:(int)a22 scheduledPriority:(int)a23 state:(char)a24 threadQos:(char)a25 threadRequestedQos:(char)a26 threadRequestedQosOverride:(char)a27 threadQosPromote:(char)a28 haveCycIns:(uint64_t)a29 instructions:(uint64_t)a30 cycles:(char)a31 haveSnap:(char)a32 ioTier:(char)a33 isIOPassive:(char)a34 isDarwinBG:(char)a35 isSuspended:(char)a36 isGlobalForcedIdle:(char)a37 isIdleWorkQueue:(void *)a38 lastMadeRunnableTime:(char)a39 isOnCore:(unsigned __int8)a40 isOnCoreForLastSampleIndex:(unsigned int)a41 cpuNum:;
- (void)clusterFlagsForCPUNum:(void *)result;
- (void)dealloc;
- (void)encodeWithCoder:(id)a3;
- (void)enumerateTasks:(id)a3;
- (void)enumerateTasksWithLiveness:(uint64_t)a1;
- (void)exclaveWithIdentifier:(uint64_t)a1;
- (void)existingTaskForEvent:(uint64_t)a3 inSession:(_DWORD *)a4 returningPid:;
- (void)findTargetProcessInTimeRange:(uint64_t)a1;
- (void)firstTaskWithPid:(void *)a1;
- (void)firstTaskWithPid:(void *)a3 onOrAfterTimestamp:;
- (void)firstTaskWithUniquePid:(void *)a3 onOrAfterTimestamp:;
- (void)forwardFillFromLastStackshot:(void *)a1;
- (void)gatherBootArgs;
- (void)gatherMachineArchitecture;
- (void)iterateAllTimestamps:(uint64_t)a1;
- (void)kperfRecord:(void *)a3 state:(void *)a4 frameIterator:;
- (void)lastTaskWithPid:(void *)a1;
- (void)lastTaskWithPid:(void *)a3 onOrBeforeTimestamp:;
- (void)lastTaskWithUniquePid:(void *)a1;
- (void)lastTaskWithUniquePid:(void *)a3 onOrBeforeTimestamp:;
- (void)postprocess;
- (void)removeAllData;
- (void)resampleTruncatedBacktraces;
- (void)setActionTaken:(id)a3;
- (void)setAdditionalCSSymbolicatorFlags:(unsigned int)a3;
- (void)setAttemptedSamplingInterval:(double)a3;
- (void)setBootArgs:(id)a3;
- (void)setBytesWritten:(unint64_t)a3;
- (void)setBytesWrittenLimit:(unint64_t)a3;
- (void)setCpuDuration:(double)a3;
- (void)setCpuLimit:(double)a3;
- (void)setCpuLimitDuration:(double)a3;
- (void)setCpuUsed:(double)a3;
- (void)setCustomOutput:(id)a3;
- (void)setDataGatheringOptions:(unint64_t)a3;
- (void)setDurationNote:(id)a3;
- (void)setEndTime:(uint64_t)a1;
- (void)setEvent:(id)a3;
- (void)setEventNote:(id)a3;
- (void)setEventTimeRange:(id)a3;
- (void)setExtraDuration:(double)a3;
- (void)setHardwareModel:(id)a3;
- (void)setHaveKPerfSched:(BOOL)a3;
- (void)setHwPageSize:(unsigned int)a3;
- (void)setKPerfPETParsePastLastStackshot:(BOOL)a3;
- (void)setKPerfPETSampleIntervalLimit:(double)a3;
- (void)setKeepMicrostackshotsWithoutLoadInfo:(BOOL)a3;
- (void)setKeepStateBetweenSampleIndexes:(BOOL)a3;
- (void)setKperfTriggers:(id)a3;
- (void)setMachTimebase:(mach_timebase_info)a3;
- (void)setMachineArchitecture:(id)a3;
- (void)setNumActiveCPUs:(unsigned int)a3;
- (void)setNumWakeups:(unint64_t)a3;
- (void)setNumWakeupsLimit:(unint64_t)a3;
- (void)setOmitSensitiveStrings:(BOOL)a3;
- (void)setOsBuildVersion:(id)a3;
- (void)setOsProductName:(id)a3;
- (void)setOsProductVersion:(id)a3;
- (void)setOsProductVersionExtra:(id)a3;
- (void)setReason:(id)a3;
- (void)setReportTimeThreshold:(double)a3;
- (void)setSampleOnlyMainThreads:(BOOL)a3;
- (void)setSanitizePaths:(BOOL)a3;
- (void)setShouldGatherKextStat:(BOOL)a3;
- (void)setSignature:(id)a3;
- (void)setStackshotsOnlyIncludeSpecificProcesses:(BOOL)a3;
- (void)setStartTime:(uint64_t)a1;
- (void)setStepsNote:(id)a3;
- (void)setTargetDispatchQueueId:(unint64_t)a3;
- (void)setTargetHIDEventEndMachAbs:(unint64_t)a3;
- (void)setTargetHIDEventMachAbs:(unint64_t)a3;
- (void)setTargetProcess:(id)a3;
- (void)setTargetProcessId:(int)a3;
- (void)setTargetThreadId:(unint64_t)a3;
- (void)setVmPageSize:(unsigned int)a3;
- (void)setWakeupsDuration:(double)a3;
- (void)setWakeupsLimitDuration:(double)a3;
- (void)setWrDiagnosticName:(id)a3;
- (void)setWrError:(id)a3;
- (void)setWrSignpostCategory:(id)a3;
- (void)setWrSignpostCount:(unint64_t)a3;
- (void)setWrSignpostCountThreshold:(unint64_t)a3;
- (void)setWrSignpostDurationSingle:(double)a3;
- (void)setWrSignpostDurationSingleThreshold:(double)a3;
- (void)setWrSignpostDurationSum:(double)a3;
- (void)setWrSignpostDurationSumThreshold:(double)a3;
- (void)setWrSignpostDurationUnion:(double)a3;
- (void)setWrSignpostDurationUnionThreshold:(double)a3;
- (void)setWrSignpostName:(id)a3;
- (void)setWrSignpostSubsystem:(id)a3;
- (void)setWrTriggeringSignpostCategory:(id)a3;
- (void)setWrTriggeringSignpostName:(id)a3;
- (void)setWrTriggeringSignpostSubsystem:(id)a3;
- (void)setWrWorkflowDuration:(double)a3;
- (void)setWrWorkflowDurationOmittingNetworkBoundIntervals:(double)a3;
- (void)setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold:(double)a3;
- (void)setWrWorkflowDurationThreshold:(double)a3;
- (void)setWrWorkflowName:(id)a3;
- (void)setWrWorkflowTimeoutDuration:(double)a3;
- (void)setWriteDuration:(double)a3;
- (void)setWriteLimitDuration:(double)a3;
- (void)startingSamplingLiveSystem;
- (void)symbolicate;
- (void)task:(void *)a3 exitedAtTimestamp:;
- (void)taskWithUniquePid:(void *)a3 atTimestamp:;
- (void)useDsymForUUIDFor:(id)a3;
@end

@implementation SASampleStore

- (int64_t)addMicrostackshotsFromData:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8
{
  return [(SASampleStore *)self addMicrostackshotsFromData:a3 ofTypes:*(void *)&a4 inTimeRangeStart:*(void *)&a7 end:a8 onlyPid:0 onlyTid:a5 statistics:a6];
}

- (SAFrame)cpuSignalHandlerStackLeafKernelFrame
{
  return (SAFrame *)objc_getProperty(self, a2, 416, 1);
}

- (id)sharedCacheWithUUID:(uint64_t)a3 slide:(uint64_t)a4 slidBaseAddress:
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    v8 = objc_msgSend(*(id *)(a1 + 112), "reverseObjectEnumerator", 0);
    uint64_t v9 = [v8 countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)v18;
      while (2)
      {
        for (uint64_t i = 0; i != v10; ++i)
        {
          if (*(void *)v18 != v11) {
            objc_enumerationMutation(v8);
          }
          v13 = *(void **)(*((void *)&v17 + 1) + 8 * i);
          if ([v13 matchesUUID:a2 slide:a3 slidBaseAddress:a4])
          {
            id v15 = v13;

            goto LABEL_12;
          }
        }
        uint64_t v10 = [v8 countByEnumeratingWithState:&v17 objects:v21 count:16];
        if (v10) {
          continue;
        }
        break;
      }
    }

    v14 = uuidForBytes(a2);
    id v15 = +[SASharedCache sharedCacheWithUUID:v14 slide:a3 slidBaseAddress:a4];

    [*(id *)(a1 + 112) addObject:v15];
  }
  else
  {
    id v15 = 0;
  }
LABEL_12:
  return v15;
}

- (NSArray)sharedCaches
{
  return (NSArray *)objc_getProperty(self, a2, 112, 1);
}

- (SATimestamp)startTime
{
  startTime = [(NSMutableArray *)self->_sampleTimestamps firstObject];
  v4 = startTime;
  if (!startTime) {
    startTime = self->_startTime;
  }
  v5 = startTime;

  return v5;
}

- (id)addPowerModeTransition:(id *)a1
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (a1)
  {
    if (!a1[10])
    {
      uint64_t v4 = [objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:1];
      id v5 = a1[10];
      a1[10] = (id)v4;
    }
    v6 = [v3 timestamp];
    [v6 wallTime];
    double v8 = v7;

    id v9 = a1[10];
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 3221225472;
    v22[2] = __40__SASampleStore_addPowerModeTransition___block_invoke;
    v22[3] = &__block_descriptor_40_e31_q16__0__SAPowerModeTransition_8l;
    *(double *)&v22[4] = v8;
    unint64_t v10 = SABinarySearchArray(v9, 1280, (uint64_t)v22);
    if (v10 >= [a1[10] count]) {
      goto LABEL_9;
    }
    uint64_t v11 = [a1[10] objectAtIndexedSubscript:v10];
    v12 = [v11 timestamp];
    [v12 wallTime];
    double v14 = v13;

    if (v14 == v8)
    {
      int v15 = *__error();
      v16 = _sa_logt();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        long long v19 = [a1[10] objectAtIndexedSubscript:v10];
        long long v20 = [v19 timestamp];
        v21 = [v20 debugDescription];
        *(_DWORD *)buf = 138543362;
        v24 = v21;
        _os_log_debug_impl(&dword_1BF22B000, v16, OS_LOG_TYPE_DEBUG, "Already have a power mode transition at %{public}@", buf, 0xCu);
      }
      *__error() = v15;
      long long v17 = [a1[10] objectAtIndexedSubscript:v10];
    }
    else
    {
LABEL_9:
      [a1[10] insertObject:v3 atIndex:v10];
      long long v17 = (id *)v3;
    }
    a1 = v17;
  }

  return a1;
}

- (SATask)targetProcess
{
  return self->_targetProcess;
}

- (void)setTargetProcessId:(int)a3
{
  if (self->_targetProcessId != a3)
  {
    self->_targetProcessId = a3;
    self->_targetThreadId = 0;
    -[SASampleStore findTargetProcessInTimeRange:]((uint64_t)self, 0);
  }
}

- (SASampleStore)init
{
  v32.receiver = self;
  v32.super_class = (Class)SASampleStore;
  v2 = [(SASampleStore *)&v32 init];
  if (v2)
  {
    id v3 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E4F1CA60]);
    tasksByPid = v2->_tasksByPid;
    v2->_tasksByPid = v3;

    id v5 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E4F1CA60]);
    tasksByUniquePid = v2->_tasksByUniquePid;
    v2->_tasksByUniquePid = v5;

    v2->_targetProcessId = -1;
    targetProcess = v2->_targetProcess;
    v2->_targetProcess = 0;

    double v8 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
    sampleTimestamps = v2->_sampleTimestamps;
    v2->_sampleTimestamps = v8;

    unint64_t v10 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
    hidEvents = v2->_hidEvents;
    v2->_hidEvents = v10;

    v12 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
    gestures = v2->_gestures;
    v2->_gestures = v12;

    double v14 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
    ioEvents = v2->_ioEvents;
    v2->_ioEvents = v14;

    v16 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E4F1CA60]);
    ioEventsByTid = v2->_ioEventsByTid;
    v2->_ioEventsByTid = v16;

    long long v18 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
    memoryPressureEvents = v2->_memoryPressureEvents;
    v2->_memoryPressureEvents = v18;

    uint64_t v20 = [objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:1];
    kernelCaches = v2->_kernelCaches;
    v2->_kernelCaches = (NSMutableArray *)v20;

    uint64_t v22 = [objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:1];
    sharedCaches = v2->_sharedCaches;
    v2->_sharedCaches = (NSMutableArray *)v22;

    v24 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
    fanSpeeds = v2->_fanSpeeds;
    v2->_fanSpeeds = v24;

    v26 = objc_alloc_init(SAMountStatusTracker);
    mountStatusTracker = v2->_mountStatusTracker;
    v2->_mountStatusTracker = v26;

    wsDataStore = v2->_wsDataStore;
    v2->_wsDataStore = 0;

    v29 = +[SABinaryLocator sharedBinaryLocator];
    binaryLocator = v2->_binaryLocator;
    v2->_binaryLocator = v29;

    v2->_additionalCSSymbolicatorFlags = 0;
    v2->_sampleOnlyMainThreads = 0;
    v2->_stackshotsOnlyIncludeSpecificProcesses = 0;
  }
  return v2;
}

- (id)initForLiveSampling
{
  id result = [(SASampleStore *)self init];
  if (result)
  {
    *((unsigned char *)result + 317) = 1;
    *((void *)result + 51) = 1415;
  }
  return result;
}

- (SATimestamp)endTime
{
  endTime = [(NSMutableArray *)self->_sampleTimestamps lastObject];
  uint64_t v4 = endTime;
  if (!endTime) {
    endTime = self->_endTime;
  }
  id v5 = endTime;

  return v5;
}

- (void)gatherBootArgs
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1 && !*(void *)(a1 + 496))
  {
    size_t v2 = *MEMORY[0x1E4F14B00];
    id v3 = (char *)&v11 - ((*MEMORY[0x1E4F14B00] + 15) & 0xFFFFFFFFFFFFFFF0);
    *id v3 = 0;
    size_t v12 = v2;
    if (sysctlbyname("kern.bootargs", v3, &v12, 0, 0))
    {
      int v4 = *__error();
      id v5 = _sa_logt();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        int v8 = *__error();
        id v9 = __error();
        unint64_t v10 = strerror(*v9);
        *(_DWORD *)buf = 67109378;
        int v14 = v8;
        __int16 v15 = 2080;
        v16 = v10;
        _os_log_error_impl(&dword_1BF22B000, v5, OS_LOG_TYPE_ERROR, "Unable to get kern.bootargs: %d %s", buf, 0x12u);
      }

      *__error() = v4;
    }
    else
    {
      uint64_t v6 = SANSStringForCString(v3);
      double v7 = *(void **)(a1 + 496);
      *(void *)(a1 + 496) = v6;
    }
  }
}

- (unint64_t)dataGatheringOptions
{
  return self->_dataGatheringOptions;
}

- (void)setDataGatheringOptions:(unint64_t)a3
{
  self->_dataGatheringOptions = a3;
}

- (void)findTargetProcessInTimeRange:(uint64_t)a1
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (!a1) {
    goto LABEL_15;
  }
  int v4 = *(void **)(a1 + 160);
  *(void *)(a1 + 160) = 0;

  uint64_t v5 = *(void *)(a1 + 168);
  if (v5)
  {
    if (v3)
    {
      uint64_t v6 = [v3 endTime];
      double v7 = -[SASampleStore taskWithPid:orTid:atTimestamp:]((id)a1, 0xFFFFFFFFLL, v5, v6);
      int v8 = v7;
      if (v7)
      {
        id v9 = v7;
        unint64_t v10 = *(void **)(a1 + 160);
        *(void *)(a1 + 160) = v9;
      }
      else
      {
        uint64_t v18 = *(void *)(a1 + 168);
        unint64_t v10 = [v3 startTime];
        uint64_t v19 = -[SASampleStore taskWithPid:orTid:atTimestamp:]((id)a1, 0xFFFFFFFFLL, v18, v10);
        uint64_t v20 = *(void **)(a1 + 160);
        *(void *)(a1 + 160) = v19;
      }
      double v13 = *(void **)(a1 + 160);
      if (v13) {
        goto LABEL_11;
      }
      int v14 = *__error();
      __int16 v15 = _sa_logt();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_13;
      }
      uint64_t v36 = *(void *)(a1 + 168);
      int v38 = 134217984;
      uint64_t v39 = v36;
      uint64_t v17 = "No task with thread 0x%llx in event time range, clearing target thread";
    }
    else
    {
      uint64_t v11 = -[SASampleStore lastTaskWithPid:orTid:]((void *)a1, 0xFFFFFFFFLL, *(void *)(a1 + 168));
      size_t v12 = *(void **)(a1 + 160);
      *(void *)(a1 + 160) = v11;

      double v13 = *(void **)(a1 + 160);
      if (v13)
      {
LABEL_11:
        *(_DWORD *)(a1 + 152) = [v13 pid];
        goto LABEL_14;
      }
      int v14 = *__error();
      __int16 v15 = _sa_logt();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
LABEL_13:

        *__error() = v14;
        *(void *)(a1 + 168) = 0;
        goto LABEL_14;
      }
      uint64_t v16 = *(void *)(a1 + 168);
      int v38 = 134217984;
      uint64_t v39 = v16;
      uint64_t v17 = "No task with thread 0x%llx, clearing target thread";
    }
    _os_log_error_impl(&dword_1BF22B000, v15, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v38, 0xCu);
    goto LABEL_13;
  }
LABEL_14:
  if (!*(void *)(a1 + 160))
  {
    uint64_t v21 = *(unsigned int *)(a1 + 152);
    if ((v21 & 0x80000000) == 0)
    {
      if (v3)
      {
        uint64_t v22 = [v3 endTime];
        v23 = -[SASampleStore taskWithPid:atTimestamp:](a1, v21, v22);
        v24 = v23;
        if (v23)
        {
          id v25 = v23;
          v26 = *(void **)(a1 + 160);
          *(void *)(a1 + 160) = v25;
        }
        else
        {
          uint64_t v33 = *(unsigned int *)(a1 + 152);
          v26 = [v3 startTime];
          uint64_t v34 = -[SASampleStore taskWithPid:atTimestamp:](a1, v33, v26);
          v35 = *(void **)(a1 + 160);
          *(void *)(a1 + 160) = v34;
        }
        if (!*(void *)(a1 + 160))
        {
          int v29 = *__error();
          v30 = _sa_logt();
          if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            goto LABEL_26;
          }
          int v37 = *(_DWORD *)(a1 + 152);
          int v38 = 67109120;
          LODWORD(v39) = v37;
          objc_super v32 = "no task with pid %d in event time range, clearing target process";
          goto LABEL_30;
        }
      }
      else
      {
        uint64_t v27 = -[SASampleStore lastTaskWithPid:]((void *)a1, *(unsigned int *)(a1 + 152));
        v28 = *(void **)(a1 + 160);
        *(void *)(a1 + 160) = v27;

        if (!*(void *)(a1 + 160))
        {
          int v29 = *__error();
          v30 = _sa_logt();
          if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
LABEL_26:

            *__error() = v29;
            *(_DWORD *)(a1 + 152) = -1;
            goto LABEL_15;
          }
          int v31 = *(_DWORD *)(a1 + 152);
          int v38 = 67109120;
          LODWORD(v39) = v31;
          objc_super v32 = "no task with pid %d, clearing target process";
LABEL_30:
          _os_log_error_impl(&dword_1BF22B000, v30, OS_LOG_TYPE_ERROR, v32, (uint8_t *)&v38, 8u);
          goto LABEL_26;
        }
      }
    }
  }
LABEL_15:
}

- (NSString)kextStat
{
  return (NSString *)objc_getProperty(self, a2, 440, 1);
}

- (NSString)eventNote
{
  return (NSString *)objc_getProperty(self, a2, 728, 1);
}

- (void)postprocess
{
  uint64_t v327 = *MEMORY[0x1E4F143B8];
  if (self->_numMicrostackshotsSkippedDueToMissingLoadInfos)
  {
    int v3 = *__error();
    int v4 = _sa_logt();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      unint64_t numMicrostackshotsSkippedDueToMissingLoadInfos = self->_numMicrostackshotsSkippedDueToMissingLoadInfos;
      buf.uint64_t f_bsize = 134217984;
      *(void *)&buf.f_iosize = numMicrostackshotsSkippedDueToMissingLoadInfos;
      _os_log_error_impl(&dword_1BF22B000, v4, OS_LOG_TYPE_ERROR, "%llu microstackshots were skipped due to having no load infos", (uint8_t *)&buf, 0xCu);
    }

    *__error() = v3;
  }
  if (self->_nextSampleIsFirstSamplingAllThreads)
  {
    int v5 = *__error();
    uint64_t v6 = _sa_logt();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_impl(&dword_1BF22B000, v6, OS_LOG_TYPE_DEFAULT, "WARNING: No stackshot provided after sampleOnlyMainThreads set to NO", (uint8_t *)&buf, 2u);
    }

    *__error() = v5;
    *(_WORD *)&self->_sampleOnlyMainThreads = 1;
  }
  if (self->_nextSampleIsFirstSamplingAllProcesses)
  {
    int v7 = *__error();
    int v8 = _sa_logt();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_impl(&dword_1BF22B000, v8, OS_LOG_TYPE_DEFAULT, "WARNING: No stackshot provided after stackshotsOnlyIncludeSpecificProcesses set to NO", (uint8_t *)&buf, 2u);
    }

    *__error() = v7;
    *(_WORD *)&self->_stackshotsOnlyIncludeSpecificProcesses = 1;
  }
  if (self->_mostRecentNativeSharedCache || (~LODWORD(self->_dataGatheringOptions) & 3) != 0)
  {
    uint64_t v10 = 0;
    id v9 = 0;
  }
  else
  {
    id v9 = +[SASharedCache currentSharedCache];
    if (v9)
    {
      uint64_t v10 = MEMORY[0x1C18A5C00]();
      -[SASampleStore addSharedCache:]((uint64_t)self, v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
  }
  if ((~LODWORD(self->_dataGatheringOptions) & 0x502) == 0) {
    -[SASampleStore resampleTruncatedBacktraces]((uint64_t)self);
  }
  v305[0] = MEMORY[0x1E4F143A8];
  v305[1] = 3221225472;
  v305[2] = __28__SASampleStore_postprocess__block_invoke;
  v305[3] = &unk_1E63F72F0;
  v305[4] = self;
  uint64_t v307 = v10;
  id v257 = v9;
  id v306 = v257;
  -[SASampleStore enumerateTasksWithLiveness:]((uint64_t)self, v305);
  uint64_t v301 = 0;
  v302 = &v301;
  uint64_t v303 = 0x2020000000;
  char v304 = 0;
  uint64_t v297 = 0;
  v298 = &v297;
  uint64_t v299 = 0x2020000000;
  char v300 = 0;
  uint64_t v293 = 0;
  v294 = &v293;
  uint64_t v295 = 0x2020000000;
  char v296 = 0;
  uint64_t v289 = 0;
  v290 = &v289;
  uint64_t v291 = 0x2020000000;
  char v292 = 0;
  v288[0] = MEMORY[0x1E4F143A8];
  v288[1] = 3221225472;
  v288[2] = __28__SASampleStore_postprocess__block_invoke_2;
  v288[3] = &unk_1E63F7340;
  v288[4] = &v293;
  v288[5] = &v301;
  v288[6] = &v289;
  v288[7] = &v297;
  [(SASampleStore *)self enumerateTasks:v288];
  if (*((unsigned char *)v294 + 24)) {
    int32_t v11 = *((unsigned char *)v302 + 24) == 0;
  }
  else {
    int32_t v11 = 0;
  }
  if (*((unsigned char *)v290 + 24))
  {
    BOOL v12 = *((unsigned char *)v298 + 24) == 0;
    if (v11) {
      goto LABEL_28;
    }
LABEL_27:
    if (!v12) {
      goto LABEL_31;
    }
    goto LABEL_28;
  }
  BOOL v12 = 0;
  if ((v11 & 1) == 0) {
    goto LABEL_27;
  }
LABEL_28:
  int v13 = *__error();
  int v14 = _sa_logt();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    buf.uint64_t f_bsize = 67109376;
    buf.f_iosize = v11;
    LOWORD(buf.f_blocks) = 1024;
    *(_DWORD *)((char *)&buf.f_blocks + 2) = v12;
    _os_log_debug_impl(&dword_1BF22B000, v14, OS_LOG_TYPE_DEBUG, "No valid originPid:%d or proximatePid:%d, clearing it all out", (uint8_t *)&buf, 0xEu);
  }

  *__error() = v13;
  v285[0] = MEMORY[0x1E4F143A8];
  v285[1] = 3221225472;
  v285[2] = __28__SASampleStore_postprocess__block_invoke_168;
  v285[3] = &__block_descriptor_34_e20_v24__0__SATask_8_B16l;
  char v286 = v11;
  BOOL v287 = v12;
  [(SASampleStore *)self enumerateTasks:v285];
LABEL_31:
  unint64_t dataGatheringOptions = self->_dataGatheringOptions;
  if ((dataGatheringOptions & 1) == 0) {
    goto LABEL_329;
  }
  if ((dataGatheringOptions & 2) == 0)
  {
    -[SASampleStore lastTaskWithPid:](self, 0);
    long long v279 = 0u;
    long long v280 = 0u;
    long long v277 = 0u;
    long long v278 = 0u;
    id v256 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v16 = [v256 binaryLoadInfos];
    uint64_t v17 = [v16 countByEnumeratingWithState:&v277 objects:v315 count:16];
    if (!v17)
    {
LABEL_45:

      long long v275 = 0u;
      long long v276 = 0u;
      long long v273 = 0u;
      long long v274 = 0u;
      obuint64_t j = self->_exclaves;
      id v260 = (id)[(NSMutableArray *)obj countByEnumeratingWithState:&v273 objects:v314 count:16];
      if (v260)
      {
        uint64_t v259 = *(void *)v274;
        do
        {
          for (uint64_t i = 0; i != v260; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v274 != v259) {
              objc_enumerationMutation(obj);
            }
            uint64_t v27 = *(void **)(*((void *)&v273 + 1) + 8 * i);
            long long v269 = 0u;
            long long v270 = 0u;
            long long v271 = 0u;
            long long v272 = 0u;
            v28 = [v27 loadInfos];
            uint64_t v29 = [v28 countByEnumeratingWithState:&v269 objects:v313 count:16];
            if (v29)
            {
              uint64_t v30 = *(void *)v270;
              do
              {
                for (uint64_t j = 0; j != v29; ++j)
                {
                  if (*(void *)v270 != v30) {
                    objc_enumerationMutation(v28);
                  }
                  objc_super v32 = *(void **)(*((void *)&v269 + 1) + 8 * j);
                  uint64_t v33 = [v32 binary];
                  uint64_t v34 = [v33 path];
                  BOOL v35 = v34 == 0;

                  if (v35)
                  {
                    uint64_t v36 = [v32 binary];
                    int v37 = [v36 uuid];
                    uint64_t SymbolOwnerForExclaveUUID = CreateSymbolOwnerForExclaveUUID(v37);
                    uint64_t v40 = v39;

                    if ((CSIsNull() & 1) == 0)
                    {
                      uint64_t v41 = [v32 binary];
                      v42 = (void *)v41;
                      if (v41) {
                        [(SABinary *)v41 addInfoFromSymbolOwner:v40 fromDisk:0 includeExpensiveInfo:0];
                      }

                      CSRelease();
                      v43 = [v32 binary];
                      [v43 gatherInfoWithDataGatheringOptions:self->_dataGatheringOptions pid:0xFFFFFFFFLL];
                    }
                  }
                }
                uint64_t v29 = [v28 countByEnumeratingWithState:&v269 objects:v313 count:16];
              }
              while (v29);
            }
          }
          id v260 = (id)[(NSMutableArray *)obj countByEnumeratingWithState:&v273 objects:v314 count:16];
        }
        while (v260);
      }
LABEL_281:

      goto LABEL_282;
    }
    char v18 = 0;
    uint64_t v19 = *(void *)v278;
LABEL_35:
    uint64_t v20 = 0;
    while (1)
    {
      if (*(void *)v278 != v19) {
        objc_enumerationMutation(v16);
      }
      uint64_t v21 = *(void **)(*((void *)&v277 + 1) + 8 * v20);
      if (v18) {
        goto LABEL_42;
      }
      uint64_t v22 = [*(id *)(*((void *)&v277 + 1) + 8 * v20) binary];
      v23 = [v22 path];
      BOOL v24 = v23 == 0;

      if (v24) {
        break;
      }
      char v18 = 0;
LABEL_43:
      v26 = [v21 binary];
      [v26 gatherInfoWithDataGatheringOptions:self->_dataGatheringOptions | 2 pid:0];

      if (v17 == ++v20)
      {
        uint64_t v17 = [v16 countByEnumeratingWithState:&v277 objects:v315 count:16];
        if (!v17) {
          goto LABEL_45;
        }
        goto LABEL_35;
      }
    }
    id v25 = +[SABinaryLoadInfo binaryLoadInfoForLiveProcessWithPid:0 dataGatheringOptions:self->_dataGatheringOptions | 2 additionalCSSymbolicatorFlags:self->_additionalCSSymbolicatorFlags];
LABEL_42:
    char v18 = 1;
    goto LABEL_43;
  }
  if (self->_lastWakeTime == 0.0) {
    self->_lastWakeTime = -[SASampleStore _getLastWakeTime]((uint64_t)self);
  }
  if (self->_shouldGatherKextStat && !self->_kextStat)
  {
    if (qword_1EB698E98 != -1) {
      dispatch_once(&qword_1EB698E98, &__block_literal_global_387);
    }
    objc_storeStrong((id *)&self->_kextStat, (id)qword_1EB698E90);
  }
  -[SASampleStore gatherBootArgs]((uint64_t)self);
  if (!self->_systemAdvisoryLevels)
  {
    id v44 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    CFDictionaryRef AdvisoryDetailed = IOCopySystemLoadAdvisoryDetailed();
    CFDictionaryRef v46 = AdvisoryDetailed;
    if (AdvisoryDetailed)
    {
      v47 = [(__CFDictionary *)AdvisoryDetailed objectForKeyedSubscript:@"UserLevel"];
      v48 = [(__CFDictionary *)v46 objectForKeyedSubscript:@"BatteryLevel"];
      v49 = [(__CFDictionary *)v46 objectForKeyedSubscript:@"CombinedLevel"];
      if (v47)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v50 = (void *)[v47 copy];
          [v44 setObject:v50 forKeyedSubscript:0x1F1A808F8];
        }
      }
      if (v48)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v51 = (void *)[v48 copy];
          [v44 setObject:v51 forKeyedSubscript:0x1F1A80918];
        }
      }
      if (v49)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v52 = (void *)[v49 copy];
          [v44 setObject:v52 forKeyedSubscript:0x1F1A80938];
        }
      }
    }
    LODWORD(out_token) = 0;
    if (!notify_register_check((const char *)*MEMORY[0x1E4F14918], (int *)&out_token))
    {
      *(void *)&buf.uint64_t f_bsize = 0;
      uint32_t state = notify_get_state(out_token, (uint64_t *)&buf.f_bsize);
      uint64_t v54 = *(void *)&buf.f_bsize;
      notify_cancel(out_token);
      if (!state)
      {
        v55 = [NSNumber numberWithUnsignedInt:v54];
        [v44 setObject:v55 forKeyedSubscript:0x1F1A80958];
      }
    }
    if ([v44 count])
    {
      v56 = (void *)[v44 copy];
      objc_setProperty_atomic(self, v57, v56, 504);
    }
  }
  if (!self->_homeVolumeSpace)
  {
    v58 = SAGetHomeDirectoryURL();
    v59 = v58;
    if (v58)
    {
      memset(&buf, 0, 512);
      id v60 = v58;
      if (!statfs((const char *)[v60 fileSystemRepresentation], &buf))
      {
        uint64_t f_bsize = buf.f_bsize;
        uint64_t f_blocks = buf.f_blocks;
        uint64_t f_bavail = buf.f_bavail;
        v64 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:3];
        v65 = [NSNumber numberWithUnsignedLongLong:f_blocks * f_bsize];
        [v64 setObject:v65 forKeyedSubscript:0x1F1A80998];

        v66 = [NSNumber numberWithUnsignedLongLong:f_bavail * f_bsize];
        [v64 setObject:v66 forKeyedSubscript:0x1F1A809B8];

        *(_DWORD *)&v325[8] = 0;
        *(void *)v325 = 0;
        *(void *)&long long v318 = 0;
        *(void *)&long long out_token = 5;
        *((void *)&out_token + 1) = 32;
        id v67 = v60;
        if (!getattrlist((const char *)[v67 fileSystemRepresentation], &out_token, v325, 0xCuLL, 1u)
          && *(uint64_t *)&v325[4] >= 1)
        {
          v310[0] = 0;
          if (!fsctl((const char *)[v67 fileSystemRepresentation], 0x4004681BuLL, v310, 0))
          {
            if (v310[0])
            {
              v68 = [NSNumber numberWithUnsignedLongLong:*(void *)&v325[4] * v310[0]];
              [v64 setObject:v68 forKeyedSubscript:0x1F1A809D8];
            }
          }
        }
        v69 = (NSDictionary *)[v64 copy];
        homeVolumeSpace = self->_homeVolumeSpace;
        self->_homeVolumeSpace = v69;
      }
    }
  }
  if (!self->_nonDefaultFeatureFlags)
  {
    if (qword_1EB698EB8 != -1) {
      dispatch_once(&qword_1EB698EB8, &__block_literal_global_415);
    }
    objc_storeStrong((id *)&self->_nonDefaultFeatureFlags, (id)qword_1EB698EC0);
  }
  if ([(NSMutableArray *)self->_powerModeTransitions count]) {
    goto LABEL_117;
  }
  v71 = (void *)[objc_alloc(MEMORY[0x1E4F1CB18]) initWithSuiteName:@"com.apple.powerd.lowpowermode.state"];
  v72 = v71;
  if (!v71
    || ([v71 objectForKey:@"state"],
        v73 = objc_claimAutoreleasedReturnValue(),
        BOOL v74 = v73 == 0,
        v73,
        v74))
  {
    int v80 = *__error();
    v81 = _sa_logt();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_debug_impl(&dword_1BF22B000, v81, OS_LOG_TYPE_DEBUG, "Unable to get low power mode defaults", (uint8_t *)&buf, 2u);
    }

    v82 = __error();
    char v75 = 0;
    goto LABEL_115;
  }
  char v75 = [v72 BOOLForKey:@"state"];
  v76 = [v72 objectForKey:@"stateChangeDate"];
  if (!v76)
  {
    int v80 = *__error();
    v142 = _sa_logt();
    if (os_log_type_enabled(v142, OS_LOG_TYPE_FAULT))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_fault_impl(&dword_1BF22B000, v142, OS_LOG_TYPE_FAULT, "No stateChangeDate for low power mode", (uint8_t *)&buf, 2u);
    }

    v82 = __error();
LABEL_115:
    v76 = 0;
    v79 = 0;
    int *v82 = v80;
    goto LABEL_116;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    int v143 = *__error();
    v144 = _sa_logt();
    if (os_log_type_enabled(v144, OS_LOG_TYPE_FAULT))
    {
      v250 = [(id)objc_opt_class() debugDescription];
      buf.uint64_t f_bsize = 138412290;
      *(void *)&buf.f_iosize = v250;
      _os_log_fault_impl(&dword_1BF22B000, v144, OS_LOG_TYPE_FAULT, "low power mode stateChangeDate is not an NSDate: %@", (uint8_t *)&buf, 0xCu);
    }
    *__error() = v143;

    v76 = 0;
    goto LABEL_212;
  }
  [v76 timeIntervalSinceReferenceDate];
  if (v77 == 0.0)
  {
LABEL_212:
    v79 = 0;
    goto LABEL_116;
  }
  [v76 timeIntervalSinceReferenceDate];
  v79 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:v78];
LABEL_116:
  v83 = -[SAPowerModeTransition initWithLowPowerMode:timestamp:]((id *)[SAPowerModeTransition alloc], v75, v79);
  id v84 = -[SASampleStore addPowerModeTransition:]((id *)&self->super.isa, v83);

LABEL_117:
  if (!self->_installedRootNames && DarwinupLibraryCore())
  {
    *(void *)&long long out_token = 0;
    *((void *)&out_token + 1) = &out_token;
    *(void *)&long long v318 = 0x2050000000;
    v89 = (void *)qword_1EB698EF0;
    *((void *)&v318 + 1) = qword_1EB698EF0;
    if (!qword_1EB698EF0)
    {
      *(void *)&buf.uint64_t f_bsize = MEMORY[0x1E4F143A8];
      buf.uint64_t f_blocks = 3221225472;
      buf.f_bfree = (uint64_t)__getDUSessionClass_block_invoke;
      buf.uint64_t f_bavail = (uint64_t)&unk_1E63F7CE0;
      buf.f_files = (uint64_t)&out_token;
      __getDUSessionClass_block_invoke((uint64_t)&buf);
      v89 = *(void **)(*((void *)&out_token + 1) + 24);
    }
    id v90 = v89;
    _Block_object_dispose(&out_token, 8);
    *(void *)&long long out_token = 0;
    *((void *)&out_token + 1) = &out_token;
    *(void *)&long long v318 = 0x2050000000;
    v91 = (void *)qword_1EB698EF8;
    *((void *)&v318 + 1) = qword_1EB698EF8;
    if (!qword_1EB698EF8)
    {
      *(void *)&buf.uint64_t f_bsize = MEMORY[0x1E4F143A8];
      buf.uint64_t f_blocks = 3221225472;
      buf.f_bfree = (uint64_t)__getDURootClass_block_invoke;
      buf.uint64_t f_bavail = (uint64_t)&unk_1E63F7CE0;
      buf.f_files = (uint64_t)&out_token;
      __getDURootClass_block_invoke((uint64_t)&buf);
      v91 = *(void **)(*((void *)&out_token + 1) + 24);
    }
    id v92 = v91;
    _Block_object_dispose(&out_token, 8);
    if (objc_opt_class() && objc_opt_class())
    {
      dispatch_semaphore_t v93 = dispatch_semaphore_create(0);
      v94 = dispatch_get_global_queue(0, 0);
      *(void *)&buf.uint64_t f_bsize = MEMORY[0x1E4F143A8];
      buf.uint64_t f_blocks = 3221225472;
      buf.f_bfree = (uint64_t)__40__SASampleStore_gatherRootInstalledInfo__block_invoke;
      buf.uint64_t f_bavail = (uint64_t)&unk_1E63F7A30;
      buf.f_fsid = (fsid_t)v90;
      buf.f_files = (uint64_t)self;
      v95 = v93;
      buf.f_ffree = (uint64_t)v95;
      dispatch_async(v94, &buf);

      dispatch_time_t v96 = dispatch_time(0, 1000000000);
      if (dispatch_semaphore_wait(v95, v96))
      {
        int v97 = *__error();
        v98 = _sa_logt();
        if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
        {
          LOWORD(out_token) = 0;
          _os_log_error_impl(&dword_1BF22B000, v98, OS_LOG_TYPE_ERROR, "Timed out waiting for darwinup", (uint8_t *)&out_token, 2u);
        }

        *__error() = v97;
      }
    }
  }
  if (!self->_isRootInstalled)
  {
    *(void *)v325 = 0;
    v310[0] = 8;
    int v85 = sysctlbyname("kern.roots_installed", v325, v310, 0, 0);
    int v86 = *__error();
    v87 = _sa_logt();
    v88 = v87;
    if (v85)
    {
      if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
      {
        int v208 = *__error();
        LODWORD(out_token) = 67109120;
        DWORD1(out_token) = v208;
        _os_log_error_impl(&dword_1BF22B000, v88, OS_LOG_TYPE_ERROR, "Unable to get installed root info kern.roots_installed: %{errno}d", (uint8_t *)&out_token, 8u);
      }

      *__error() = v86;
    }
    else
    {
      if (os_log_type_enabled(v87, OS_LOG_TYPE_INFO))
      {
        LODWORD(out_token) = 134217984;
        *(void *)((char *)&out_token + 4) = *(void *)v325;
        _os_log_impl(&dword_1BF22B000, v88, OS_LOG_TYPE_INFO, "Installed root info kern.roots_installed: %llu", (uint8_t *)&out_token, 0xCu);
      }

      *__error() = v86;
      if (*(void *)v325) {
        self->_isRootInstalled = 1;
      }
    }
  }
  if (!self->_keyboardLanguages)
  {
    id v263 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    id v261 = (id)CFPreferencesCopyValue(@"KeyboardsCurrentAndNext", @"com.apple.keyboard.preferences", @"mobile", (CFStringRef)*MEMORY[0x1E4F1D3C8]);
    if (v261)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        long long v319 = 0u;
        long long v320 = 0u;
        long long out_token = 0u;
        long long v318 = 0u;
        id v100 = v261;
        uint64_t v101 = [v100 countByEnumeratingWithState:&out_token objects:&buf count:16];
        if (v101)
        {
          uint64_t v102 = *(void *)v318;
          do
          {
            for (uint64_t k = 0; k != v101; ++k)
            {
              if (*(void *)v318 != v102) {
                objc_enumerationMutation(v100);
              }
              v104 = *(void **)(*((void *)&out_token + 1) + 8 * k);
              if (v104)
              {
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  v105 = [v104 stringByReplacingOccurrencesOfString:@"@sw=" withString:@" "];
                  v106 = [v105 stringByReplacingOccurrencesOfString:@"@hw=" withString:@" "];

                  v107 = [v106 stringByReplacingOccurrencesOfString:@"hw=" withString:&stru_1F1A80538];;

                  v108 = [v107 stringByReplacingOccurrencesOfString:@"sw=" withString:&stru_1F1A80538];;

                  v109 = [v108 stringByReplacingOccurrencesOfString:@"Automatic" withString:&stru_1F1A80538];

                  int v110 = *__error();
                  v111 = _sa_logt();
                  if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)v325 = 138412546;
                    *(void *)&v325[4] = v104;
                    *(_WORD *)&v325[12] = 2112;
                    *(void *)&v325[14] = v109;
                    _os_log_debug_impl(&dword_1BF22B000, v111, OS_LOG_TYPE_DEBUG, "keyboard %@ -> %@", v325, 0x16u);
                  }

                  *__error() = v110;
                  if (([v263 containsObject:v109] & 1) == 0) {
                    [v263 addObject:v109];
                  }
                }
                else
                {
                  int v112 = *__error();
                  v113 = _sa_logt();
                  if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT))
                  {
                    ClassName = object_getClassName(v104);
                    *(_DWORD *)v325 = 136315138;
                    *(void *)&v325[4] = ClassName;
                    _os_log_fault_impl(&dword_1BF22B000, v113, OS_LOG_TYPE_FAULT, "keyboard not a string! %s", v325, 0xCu);
                  }

                  *__error() = v112;
                }
              }
            }
            uint64_t v101 = [v100 countByEnumeratingWithState:&out_token objects:&buf count:16];
          }
          while (v101);
        }

        v115 = (NSArray *)[v263 copy];
        keyboardLanguages = self->_keyboardLanguages;
        self->_keyboardLanguages = v115;
      }
      else
      {
        int v117 = *__error();
        v118 = _sa_logt();
        if (os_log_type_enabled(v118, OS_LOG_TYPE_FAULT))
        {
          v248 = object_getClassName(v261);
          buf.uint64_t f_bsize = 136315138;
          *(void *)&buf.f_iosize = v248;
          _os_log_fault_impl(&dword_1BF22B000, v118, OS_LOG_TYPE_FAULT, "keyboards not an array! %s", (uint8_t *)&buf, 0xCu);
        }

        *__error() = v117;
      }
    }
  }
  if (!self->_preferredLanguages)
  {
    v119 = getPreferredLanguages();
    v120 = v119;
    if (v119 && [v119 count])
    {
      int v121 = *__error();
      v122 = _sa_logt();
      if (os_log_type_enabled(v122, OS_LOG_TYPE_DEBUG))
      {
        buf.uint64_t f_bsize = 138412290;
        *(void *)&buf.f_iosize = v120;
        _os_log_debug_impl(&dword_1BF22B000, v122, OS_LOG_TYPE_DEBUG, "Preferred languages found: %@", (uint8_t *)&buf, 0xCu);
      }

      *__error() = v121;
      if ((unint64_t)[v120 count] < 2)
      {
        v123 = (NSArray *)[v120 copy];
      }
      else
      {
        objc_msgSend(v120, "subarrayWithRange:", 0, 2);
        v123 = (NSArray *)objc_claimAutoreleasedReturnValue();
      }
      preferredLanguages = self->_preferredLanguages;
      self->_preferredLanguages = v123;
    }
    else
    {
      int v125 = *__error();
      v126 = _sa_logt();
      if (os_log_type_enabled(v126, OS_LOG_TYPE_FAULT))
      {
        LOWORD(buf.f_bsize) = 0;
        _os_log_fault_impl(&dword_1BF22B000, v126, OS_LOG_TYPE_FAULT, "Preferred languages are not found!", (uint8_t *)&buf, 2u);
      }

      *__error() = v125;
    }
  }
  if (!self->_countryCode)
  {
    v127 = getPreferredLanguages();
    v128 = (void *)MEMORY[0x1E4F1CA20];
    v129 = [v127 firstObject];
    v130 = [v128 localeWithLocaleIdentifier:v129];
    v131 = [v130 objectForKey:*MEMORY[0x1E4F1C400]];

    if (v131 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      int v132 = *__error();
      v133 = _sa_logt();
      if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
      {
        buf.uint64_t f_bsize = 138412290;
        *(void *)&buf.f_iosize = v131;
        _os_log_debug_impl(&dword_1BF22B000, v133, OS_LOG_TYPE_DEBUG, "Country code found: %@", (uint8_t *)&buf, 0xCu);
      }

      *__error() = v132;
      objc_storeStrong((id *)&self->_countryCode, v131);
    }
    else
    {
      int v134 = *__error();
      v135 = _sa_logt();
      if (os_log_type_enabled(v135, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buf.f_bsize) = 0;
        _os_log_debug_impl(&dword_1BF22B000, v135, OS_LOG_TYPE_DEBUG, "Country code not found!", (uint8_t *)&buf, 2u);
      }

      *__error() = v134;
    }
  }
  if (!self->_hasHardwareKeyboardInfo)
  {
    p_hasHardwareKeyboardInfo = &self->_hasHardwareKeyboardInfo;
    self->_hasHardwareKeyboardInfo = 1;
    CFBooleanRef v137 = (const __CFBoolean *)CFPreferencesCopyValue(@"HardwareKeyboardLastSeen", @"com.apple.keyboard.preferences", @"mobile", (CFStringRef)*MEMORY[0x1E4F1D3C8]);
    CFBooleanRef v138 = v137;
    if (!v137)
    {
      p_hasHardwareKeyboardInfo = &self->_hardwareKeyboard;
      goto LABEL_192;
    }
    CFTypeID v139 = CFGetTypeID(v137);
    if (v139 != CFBooleanGetTypeID())
    {
      LODWORD(v174) = *__error();
      v168 = _sa_logt();
      if (os_log_type_enabled(v168, OS_LOG_TYPE_FAULT)) {
        goto LABEL_359;
      }
      goto LABEL_357;
    }
    self->_hardwareKeyboard = CFBooleanGetValue(v138) != 0;
    CFRelease(v138);
  }
  while (1)
  {
    if (self->_numVnodesHardLimit) {
      goto LABEL_217;
    }
    *(void *)&long long out_token = 0;
    *(void *)v325 = 0;
    v310[0] = 0;
    *(void *)&buf.uint64_t f_bsize = 8;
    if (sysctlbyname("kern.num_vnodes", &out_token, (size_t *)&buf.f_bsize, 0, 0))
    {
      int v140 = *__error();
      v141 = _sa_logt();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
      {
        int v209 = *__error();
        *(_DWORD *)v321 = 67109120;
        *(_DWORD *)&v321[4] = v209;
        _os_log_error_impl(&dword_1BF22B000, v141, OS_LOG_TYPE_ERROR, "Unable to get kern.num_vnodes: %{errno}d", v321, 8u);
      }
LABEL_216:

      *__error() = v140;
      goto LABEL_217;
    }
    *(void *)&buf.uint64_t f_bsize = 8;
    if (sysctlbyname("kern.free_vnodes", v325, (size_t *)&buf.f_bsize, 0, 0))
    {
      int v140 = *__error();
      v141 = _sa_logt();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
      {
        int v249 = *__error();
        *(_DWORD *)v321 = 67109120;
        *(_DWORD *)&v321[4] = v249;
        _os_log_error_impl(&dword_1BF22B000, v141, OS_LOG_TYPE_ERROR, "Unable to get kern.free_vnodes: %{errno}d", v321, 8u);
      }
      goto LABEL_216;
    }
    *(void *)&buf.uint64_t f_bsize = 8;
    if (sysctlbyname("kern.maxvnodes", v310, (size_t *)&buf.f_bsize, 0, 0))
    {
      int v140 = *__error();
      v141 = _sa_logt();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
      {
        int v251 = *__error();
        *(_DWORD *)v321 = 67109120;
        *(_DWORD *)&v321[4] = v251;
        _os_log_error_impl(&dword_1BF22B000, v141, OS_LOG_TYPE_ERROR, "Unable to get kern.maxvnodes: %{errno}d", v321, 8u);
      }
      goto LABEL_216;
    }
    LODWORD(cf) = 0;
    *(void *)&buf.uint64_t f_bsize = 4;
    if (sysctlbyname("vfs.vnstats.vn_dealloc_level", &cf, (size_t *)&buf.f_bsize, 0, 0))
    {
      int v140 = *__error();
      v141 = _sa_logt();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
      {
        int v252 = *__error();
        *(_DWORD *)v321 = 67109120;
        *(_DWORD *)&v321[4] = v252;
        _os_log_error_impl(&dword_1BF22B000, v141, OS_LOG_TYPE_ERROR, "Unable to get vfs.vnstats.vn_dealloc_level: %{errno}d", v321, 8u);
      }
      goto LABEL_216;
    }
    unint64_t v246 = v310[0];
    unint64_t v247 = v310[0] << (cf != 0);
    self->_numVnodesAllocated = out_token;
    self->_numVnodesFree = *(void *)v325;
    self->_numVnodesSoftLimit = v246;
    self->_numVnodesHardLimit = v247;
LABEL_217:
    if (!self->_processNameForUnknownPids)
    {
      *(void *)&buf.uint64_t f_bsize = 0;
      buf.uint64_t f_blocks = (uint64_t)&buf;
      buf.f_bfree = 0x3032000000;
      buf.uint64_t f_bavail = (uint64_t)__Block_byref_object_copy__0;
      buf.f_files = (uint64_t)__Block_byref_object_dispose__0;
      buf.f_ffree = (uint64_t)objc_alloc_init(MEMORY[0x1E4F1CA60]);
      *(void *)&long long out_token = MEMORY[0x1E4F143A8];
      *((void *)&out_token + 1) = 3221225472;
      *(void *)&long long v318 = __42__SASampleStore_gatherUnknownProcessNames__block_invoke;
      *((void *)&v318 + 1) = &unk_1E63F79E0;
      *(void *)&long long v319 = self;
      *((void *)&v319 + 1) = &buf;
      [(SASampleStore *)self enumerateTasks:&out_token];
      v145 = (NSDictionary *)[(NSDictionary *)self->_processNameForUnknownPids copy];
      processNameForUnknownPids = self->_processNameForUnknownPids;
      self->_processNameForUnknownPids = v145;

      _Block_object_dispose(&buf, 8);
    }
    id v147 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    *(void *)&buf.uint64_t f_bsize = MEMORY[0x1E4F143A8];
    buf.uint64_t f_blocks = 3221225472;
    buf.f_bfree = (uint64_t)__52__SASampleStore_gatherUnknownResourceCoalitionNames__block_invoke;
    buf.uint64_t f_bavail = (uint64_t)&unk_1E63F7A08;
    buf.f_files = (uint64_t)v147;
    id v148 = v147;
    [(SASampleStore *)self enumerateTasks:&buf];

    if (!self->_activeTrials && TrialLibraryCore())
    {
      dispatch_semaphore_t v149 = dispatch_semaphore_create(0);
      v150 = dispatch_get_global_queue(0, 0);
      *(void *)&buf.uint64_t f_bsize = MEMORY[0x1E4F143A8];
      buf.uint64_t f_blocks = 3221225472;
      buf.f_bfree = (uint64_t)__29__SASampleStore_gatherTrials__block_invoke;
      buf.uint64_t f_bavail = (uint64_t)&unk_1E63F7920;
      buf.f_files = (uint64_t)self;
      v151 = v149;
      buf.f_ffree = (uint64_t)v151;
      dispatch_async(v150, &buf);

      dispatch_time_t v152 = dispatch_time(0, 5000000000);
      if (dispatch_semaphore_wait(v151, v152))
      {
        int v153 = *__error();
        v154 = _sa_logt();
        if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
        {
          LOWORD(out_token) = 0;
          _os_log_error_impl(&dword_1BF22B000, v154, OS_LOG_TYPE_ERROR, "Timed out waiting for trial info", (uint8_t *)&out_token, 2u);
        }

        *__error() = v153;
      }
    }
    if (!self->_gpuRestartCount)
    {
      *(void *)&long long out_token = 0;
      *((void *)&out_token + 1) = &out_token;
      long long v318 = 0x2020000000uLL;
      *(void *)v325 = 0;
      *(void *)&v325[8] = v325;
      *(void *)&v325[16] = 0x2020000000;
      v326 = 0;
      v310[0] = 0;
      v310[1] = (size_t)v310;
      v310[2] = 0x2020000000;
      char v311 = 0;
      *(void *)v321 = 0;
      v322 = v321;
      uint64_t v323 = 0x2020000000;
      char v324 = 0;
      self->_gpuRestartCount = 0;
      self->_gpuRestartLastMachAbs = 0;
      CFTypeRef cf = 0;
      CFTypeRef v308 = 0;
      CFMutableDictionaryRef v155 = IOServiceMatching("AGXAccelerator");
      v156 = (const void *)IOReportCopyChannelsForDrivers();
      CFRelease(v155);
      if (!v156)
      {
        int v159 = *__error();
        v160 = _sa_logt();
        if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
        {
          buf.uint64_t f_bsize = 138412290;
          *(void *)&buf.f_iosize = cf;
          _os_log_error_impl(&dword_1BF22B000, v160, OS_LOG_TYPE_ERROR, "Failed to get IOReport channels: %@", (uint8_t *)&buf, 0xCu);
        }

        *__error() = v159;
        goto LABEL_255;
      }
      if (IOReportGetChannelCount())
      {
        Subscription = (const void *)IOReportCreateSubscription();
        if (Subscription && v308)
        {
          Samples = (const void *)IOReportCreateSamples();
          if (Samples)
          {
            *(void *)&buf.uint64_t f_bsize = MEMORY[0x1E4F143A8];
            buf.uint64_t f_blocks = 3221225472;
            buf.f_bfree = (uint64_t)__30__SASampleStore_gatherGPUInfo__block_invoke;
            buf.uint64_t f_bavail = (uint64_t)&unk_1E63F7968;
            buf.f_files = (uint64_t)&out_token;
            buf.f_ffree = (uint64_t)v310;
            buf.f_fsid = (fsid_t)v325;
            *(void *)&buf.f_owner = v321;
            IOReportIterate();
            self->_gpuRestartCount = *(void *)(*((void *)&out_token + 1) + 24);
            self->_gpuRestartLastMachAbs = *(void *)(*(void *)&v325[8] + 24);
LABEL_246:
            if (cf) {
              CFRelease(cf);
            }
            if (Samples) {
              CFRelease(Samples);
            }
            if (v308) {
              CFRelease(v308);
            }
            if (Subscription) {
              CFRelease(Subscription);
            }
            CFRelease(v156);
LABEL_255:
            _Block_object_dispose(v321, 8);
            _Block_object_dispose(v310, 8);
            _Block_object_dispose(v325, 8);
            _Block_object_dispose(&out_token, 8);
            goto LABEL_256;
          }
          int v161 = *__error();
          v164 = _sa_logt();
          if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
          {
            buf.uint64_t f_bsize = 138412290;
            *(void *)&buf.f_iosize = cf;
            _os_log_error_impl(&dword_1BF22B000, v164, OS_LOG_TYPE_ERROR, "Failed to create IOReport samples: %@", (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
          int v161 = *__error();
          v164 = _sa_logt();
          if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
          {
            buf.uint64_t f_bsize = 138412290;
            *(void *)&buf.f_iosize = cf;
            _os_log_error_impl(&dword_1BF22B000, v164, OS_LOG_TYPE_ERROR, "Failed to subscribe to IOReport channels: %@", (uint8_t *)&buf, 0xCu);
          }
        }

        v163 = __error();
        Samples = 0;
      }
      else
      {
        int v161 = *__error();
        v162 = _sa_logt();
        if (os_log_type_enabled(v162, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf.f_bsize) = 0;
          _os_log_debug_impl(&dword_1BF22B000, v162, OS_LOG_TYPE_DEBUG, "No IOReport channels found", (uint8_t *)&buf, 2u);
        }

        v163 = __error();
        Samples = 0;
        Subscription = 0;
      }
      int *v163 = v161;
      goto LABEL_246;
    }
LABEL_256:
    if (self->_attemptedToGatherModelInfo) {
      goto LABEL_276;
    }
    v165 = [(SASampleStore *)self models];
    BOOL v166 = v165 == 0;

    if (!v166) {
      goto LABEL_276;
    }
    self->_attemptedToGatherModelInfo = 1;
    if (!SAHelperLibraryCore()) {
      break;
    }
    v167 = [(SASampleStore *)self startTime];
    v168 = [v167 copyDate];

    v169 = [(SASampleStore *)self endTime];
    v170 = (void *)[v169 copyDate];

    if (!v168 || !v170)
    {
      int v182 = *__error();
      v183 = _sa_logt();
      if (os_log_type_enabled(v183, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.f_bsize) = 0;
        _os_log_error_impl(&dword_1BF22B000, v183, OS_LOG_TYPE_ERROR, "No wall time for event, cannot gather model info", (uint8_t *)&buf, 2u);
      }

      *__error() = v182;
      goto LABEL_275;
    }
    v171 = [v168 dateByAddingTimeInterval:-60.0];
    v172 = [v170 dateByAddingTimeInterval:60.0];
    dispatch_semaphore_t v173 = dispatch_semaphore_create(0);
    *(void *)&buf.uint64_t f_bsize = MEMORY[0x1E4F143A8];
    buf.uint64_t f_blocks = 3221225472;
    buf.f_bfree = (uint64_t)__32__SASampleStore_gatherModelInfo__block_invoke;
    buf.uint64_t f_bavail = (uint64_t)&unk_1E63F7A58;
    buf.f_files = (uint64_t)self;
    p_hasHardwareKeyboardInfo = v173;
    buf.f_ffree = (uint64_t)p_hasHardwareKeyboardInfo;
    CFBooleanRef v138 = v171;
    id v174 = v172;
    v175 = &buf;
    *(void *)v325 = 0;
    *(void *)&v325[8] = v325;
    *(void *)&v325[16] = 0x2020000000;
    v176 = (void (*)(const __CFBoolean *, id, statfs *))off_1EB698F10;
    v326 = off_1EB698F10;
    if (!off_1EB698F10)
    {
      *(void *)&long long out_token = MEMORY[0x1E4F143A8];
      *((void *)&out_token + 1) = 3221225472;
      *(void *)&long long v318 = __getSAModelGatherInfoSymbolLoc_block_invoke;
      *((void *)&v318 + 1) = &unk_1E63F7CE0;
      *(void *)&long long v319 = v325;
      __getSAModelGatherInfoSymbolLoc_block_invoke((uint64_t)&out_token);
      v176 = *(void (**)(const __CFBoolean *, id, statfs *))(*(void *)&v325[8] + 24);
    }
    _Block_object_dispose(v325, 8);
    if (v176)
    {
      v176(v138, v174, v175);

      dispatch_time_t v177 = dispatch_time(0, 10000000000);
      if (dispatch_semaphore_wait((dispatch_semaphore_t)p_hasHardwareKeyboardInfo, v177))
      {
        int v178 = *__error();
        v179 = _sa_logt();
        if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
        {
          LOWORD(out_token) = 0;
          _os_log_error_impl(&dword_1BF22B000, v179, OS_LOG_TYPE_ERROR, "Timed out waiting for model info", (uint8_t *)&out_token, 2u);
        }

        *__error() = v178;
      }

LABEL_275:
      goto LABEL_276;
    }
    v255 = dlerror();
    abort_report_np();
    __break(1u);
LABEL_359:
    CFTypeID v253 = CFGetTypeID(v138);
    v254 = (__CFString *)CFCopyTypeIDDescription(v253);
    buf.uint64_t f_bsize = 138412290;
    *(void *)&buf.f_iosize = v254;
    _os_log_fault_impl(&dword_1BF22B000, v168, OS_LOG_TYPE_FAULT, "HardwareKeyboardLastSeen not a BOOLean: %@", (uint8_t *)&buf, 0xCu);

LABEL_357:
    *__error() = (int)v174;
    CFRelease(v138);
LABEL_192:
    BOOL *p_hasHardwareKeyboardInfo = 0;
  }
  int v180 = *__error();
  v181 = _sa_logt();
  if (os_log_type_enabled(v181, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.f_bsize) = 0;
    _os_log_error_impl(&dword_1BF22B000, v181, OS_LOG_TYPE_ERROR, "SAModel not available", (uint8_t *)&buf, 2u);
  }

  *__error() = v180;
LABEL_276:
  v184 = objc_msgSend(MEMORY[0x1E4FB3710], "personaAttributesForPersonaType:", 2, v255);
  v185 = [v184 userPersonaUniqueString];
  self->_hasEnterprisePersona = v185 != 0;

  v186 = +[SATimestamp timestamp];
  [v186 wallTime];
  double v188 = v187;
  [v186 machContTimeSeconds];
  double v190 = v189;
  id v256 = v186;
  double LastWake = -[SASampleStore _getLastWakeTime]((uint64_t)self);
  if (LastWake != 0.0)
  {
    if (LastWake <= 0.0)
    {
      v192 = 0;
    }
    else
    {
      v192 = [[SATimestamp alloc] initWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:LastWake];
      [(SATimestamp *)v192 guessMissingTimesBasedOnTimestamp:v256];
    }
    v281[0] = MEMORY[0x1E4F143A8];
    v281[1] = 3221225472;
    v281[2] = __28__SASampleStore_postprocess__block_invoke_3_172;
    v281[3] = &unk_1E63F73A8;
    double v284 = v188 - v190;
    obuint64_t j = v192;
    v282 = obj;
    id v256 = v256;
    id v283 = v256;
    -[SASampleStore iterateAllTimestamps:]((uint64_t)self, v281);

    goto LABEL_281;
  }
LABEL_282:

  if (self)
  {
    if (!self->_kernelVersion)
    {
      memset(&buf, 0, 512);
      buf.f_mntonname[680] = 0;
      if (uname((utsname *)&buf))
      {
        int v193 = *__error();
        v194 = _sa_logt();
        if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
        {
          int v195 = *__error();
          LODWORD(out_token) = 67109120;
          DWORD1(out_token) = v195;
          _os_log_impl(&dword_1BF22B000, v194, OS_LOG_TYPE_DEFAULT, "WARNING: unable to get kernel strings: %d", (uint8_t *)&out_token, 8u);
        }

        *__error() = v193;
      }
      else if (buf.f_mntonname[680])
      {
        SANSStringForCString(&buf.f_mntonname[680]);
        v196 = (NSString *)objc_claimAutoreleasedReturnValue();
        kernelVersion = self->_kernelVersion;
        self->_kernelVersion = v196;
      }
    }
    if (!self->_osProductName && !self->_osProductVersion && !self->_osProductVersionExtra && !self->_osBuildVersion)
    {
      CFDictionaryRef v198 = (const __CFDictionary *)_CFCopySupplementalVersionDictionary();
      CFDictionaryRef v199 = v198;
      if (v198)
      {
        CFDictionaryGetValue(v198, (const void *)*MEMORY[0x1E4F1CD18]);
        v200 = (NSString *)objc_claimAutoreleasedReturnValue();
        osProductName = self->_osProductName;
        self->_osProductName = v200;

        CFDictionaryGetValue(v199, (const void *)*MEMORY[0x1E4F1CD30]);
        v202 = (NSString *)objc_claimAutoreleasedReturnValue();
        osProductVersion = self->_osProductVersion;
        self->_osProductVersion = v202;

        CFDictionaryGetValue(v199, (const void *)*MEMORY[0x1E4F1CD28]);
        v204 = (NSString *)objc_claimAutoreleasedReturnValue();
        osProductVersionExtra = self->_osProductVersionExtra;
        self->_osProductVersionExtra = v204;

        CFDictionaryGetValue(v199, (const void *)*MEMORY[0x1E4F1CD10]);
        v206 = (NSString *)objc_claimAutoreleasedReturnValue();
        osBuildVersion = self->_osBuildVersion;
        self->_osBuildVersion = v206;

        CFRelease(v199);
      }
      else
      {
        int v210 = *__error();
        v211 = _sa_logt();
        if (os_log_type_enabled(v211, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.f_bsize) = 0;
          _os_log_error_impl(&dword_1BF22B000, v211, OS_LOG_TYPE_ERROR, "unable to get system versions dictionary", (uint8_t *)&buf, 2u);
        }

        *__error() = v210;
      }
    }
  }
  [(SASampleStore *)self gatherMachineArchitecture];
  if (self)
  {
    if (!self->_workQueueSoftThreadLimit)
    {
      *(void *)&long long out_token = 4;
      if (sysctlbyname("kern.wq_max_constrained_threads", &self->_workQueueSoftThreadLimit, (size_t *)&out_token, 0, 0))
      {
        int v212 = *__error();
        v213 = _sa_logt();
        if (os_log_type_enabled(v213, OS_LOG_TYPE_ERROR))
        {
          int32_t v237 = *__error();
          v238 = __error();
          v239 = strerror(*v238);
          buf.uint64_t f_bsize = 67109378;
          buf.f_iosize = v237;
          LOWORD(buf.f_blocks) = 2080;
          *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v239;
          _os_log_error_impl(&dword_1BF22B000, v213, OS_LOG_TYPE_ERROR, "Unable to get kern.wq_max_constrained_threads: %d %s", (uint8_t *)&buf, 0x12u);
        }

        *__error() = v212;
      }
    }
    if (!self->_workQueueHardThreadLimit)
    {
      *(void *)&long long out_token = 4;
      if (sysctlbyname("kern.wq_max_threads", &self->_workQueueHardThreadLimit, (size_t *)&out_token, 0, 0))
      {
        int v214 = *__error();
        v215 = _sa_logt();
        if (os_log_type_enabled(v215, OS_LOG_TYPE_ERROR))
        {
          int32_t v240 = *__error();
          v241 = __error();
          v242 = strerror(*v241);
          buf.uint64_t f_bsize = 67109378;
          buf.f_iosize = v240;
          LOWORD(buf.f_blocks) = 2080;
          *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v242;
          _os_log_error_impl(&dword_1BF22B000, v215, OS_LOG_TYPE_ERROR, "Unable to get kern.wq_max_threads: %d %s", (uint8_t *)&buf, 0x12u);
        }

        *__error() = v214;
      }
    }
    if (qword_1EB698EB0 != -1) {
      dispatch_once(&qword_1EB698EB0, &__block_literal_global_397);
    }
    objc_storeStrong((id *)&self->_hardwareModel, (id)qword_1EB698EA8);
    if (!self->_numActiveCPUs)
    {
      *(void *)&long long out_token = 4;
      if (sysctlbyname("hw.activecpu", &self->_numActiveCPUs, (size_t *)&out_token, 0, 0))
      {
        int v217 = *__error();
        v218 = _sa_logt();
        if (os_log_type_enabled(v218, OS_LOG_TYPE_ERROR))
        {
          int32_t v243 = *__error();
          v244 = __error();
          v245 = strerror(*v244);
          buf.uint64_t f_bsize = 67109378;
          buf.f_iosize = v243;
          LOWORD(buf.f_blocks) = 2080;
          *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v245;
          _os_log_error_impl(&dword_1BF22B000, v218, OS_LOG_TYPE_ERROR, "Unable to get hw.activecpu: %d %s", (uint8_t *)&buf, 0x12u);
        }

        *__error() = v217;
      }
      if (!objc_getProperty(self, v216, 1032, 1))
      {
        uint64_t current = ktrace_machine_create_current();
        if (current)
        {
          MEMORY[0x1C18A5C00]();
          int v220 = CSArchitectureIs64Bit();
          -[SASampleStore _populateFromKtraceMachineInfo:is64bit:]((uint64_t)self, current, v220);
          ktrace_machine_destroy();
        }
        else
        {
          int v221 = *__error();
          v222 = _sa_logt();
          if (os_log_type_enabled(v222, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf.f_bsize) = 0;
            _os_log_error_impl(&dword_1BF22B000, v222, OS_LOG_TYPE_ERROR, "Unable to get ktrace machine - cannot determine P vs E cores", (uint8_t *)&buf, 2u);
          }

          *__error() = v221;
        }
      }
    }
  }
  -[SASampleStore gatherHWPageSize]((int *)self);
  -[SASampleStore gatherVMPageSize]((int *)self);
  if (self)
  {
    if (!self->_appleInternalIsKnown)
    {
      self->_appleInternalIsKnown = 1;
      self->_isAppleInternal = is_apple_internal_setting();
      if (qword_1EB698F08 != -1) {
        dispatch_once(&qword_1EB698F08, &__block_literal_global_1708);
      }
      objc_storeStrong((id *)&self->_automatedDeviceGroup, (id)qword_1EB698F00);
      if (self->_isAppleInternal)
      {
        self->_hasInternalCarryDeviceDistinction = 1;
        if (!self->_automatedDeviceGroup)
        {
          v234 = (void *)CFPreferencesCopyValue(@"ExperimentGroup", @"com.apple.da", @"mobile", (CFStringRef)*MEMORY[0x1E4F1D3C8]);
          v235 = [v234 lowercaseString];

          if ([v235 containsString:@"carry"]) {
            char v236 = 1;
          }
          else {
            char v236 = [v235 containsString:@"walkabout"];
          }

          self->_isInternalCarryDevice = v236;
        }
      }
    }
    if (self->_numOSCryptexFileExtents <= 0)
    {
      if (qword_1EB698ED0 != -1) {
        dispatch_once(&qword_1EB698ED0, &__block_literal_global_450);
      }
      self->_numOSCryptexFileExtents = qword_1EB698ED8;
    }
  }
LABEL_329:
  long long v267 = 0u;
  long long v268 = 0u;
  long long v265 = 0u;
  long long v266 = 0u;
  v223 = (void *)[(NSMutableArray *)self->_sharedCaches copy];
  uint64_t v224 = [v223 countByEnumeratingWithState:&v265 objects:v312 count:16];
  if (v224)
  {
    uint64_t v225 = *(void *)v266;
    do
    {
      for (uint64_t m = 0; m != v224; ++m)
      {
        if (*(void *)v266 != v225) {
          objc_enumerationMutation(v223);
        }
        v227 = *(unsigned char **)(*((void *)&v265 + 1) + 8 * m);
        if (v227 && (v227[24] & 1) != 0)
        {
          v228 = [*(id *)(*((void *)&v265 + 1) + 8 * m) uuid];
          v229 = +[SASharedCache sharedCacheWithUUID:slide:slidBaseAddress:](SASharedCache, "sharedCacheWithUUID:slide:slidBaseAddress:", v228, [v227 slide], objc_msgSend(v227, "slidBaseAddress"));

          v230 = [v229 binaryLoadInfos];
          if ([v230 count])
          {

            goto LABEL_338;
          }
          v231 = [v227 binaryLoadInfos];
          BOOL v232 = [v231 count] == 0;

          if (v232)
          {
LABEL_338:
            [(NSMutableArray *)self->_sharedCaches removeObject:v227];
            -[SASampleStore addSharedCache:]((uint64_t)self, v229);
          }

          continue;
        }
      }
      uint64_t v224 = [v223 countByEnumeratingWithState:&v265 objects:v312 count:16];
    }
    while (v224);
  }

  [(NSMutableArray *)self->_ioEvents sortUsingComparator:&__block_literal_global_177];
  [(NSMutableDictionary *)self->_ioEventsByTid enumerateKeysAndObjectsUsingBlock:&__block_literal_global_179];
  id v233 = -[SASampleStore fixupAllFrames]((id *)&self->super.isa);
  if (self->_machTimebase.denom && self->_machTimebase.numer)
  {
    v264[0] = MEMORY[0x1E4F143A8];
    v264[1] = 3221225472;
    v264[2] = __28__SASampleStore_postprocess__block_invoke_7;
    v264[3] = &unk_1E63F7410;
    v264[4] = self;
    -[SASampleStore iterateAllTimestamps:]((uint64_t)self, v264);
  }
  _Block_object_dispose(&v289, 8);
  _Block_object_dispose(&v293, 8);
  _Block_object_dispose(&v297, 8);
  _Block_object_dispose(&v301, 8);
}

void __36__SASampleStore_gatherHardwareModel__block_invoke()
{
  dispatch_semaphore_t v0 = dispatch_semaphore_create(0);
  v1 = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __36__SASampleStore_gatherHardwareModel__block_invoke_2;
  block[3] = &unk_1E63F74F8;
  size_t v2 = v0;
  int v8 = v2;
  dispatch_async(v1, block);

  dispatch_time_t v3 = dispatch_time(0, 1000000000);
  if (dispatch_semaphore_wait(v2, v3))
  {
    int v4 = *__error();
    int v5 = _sa_logt();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_error_impl(&dword_1BF22B000, v5, OS_LOG_TYPE_ERROR, "Timed out waiting for MobileGestalt", v6, 2u);
    }

    *__error() = v4;
  }
}

- (void)lastTaskWithPid:(void *)a1
{
  if (a1)
  {
    a1 = -[SASampleStore lastTaskWithPid:onOrBeforeTimestamp:](a1, a2, 0);
    uint64_t v2 = vars8;
  }
  return a1;
}

void __32__SASampleStore_enumerateTasks___block_invoke(uint64_t a1, uint64_t a2, void *a3, unsigned char *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v6 = a3;
  uint64_t v7 = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v12;
LABEL_3:
    uint64_t v10 = 0;
    while (1)
    {
      if (*(void *)v12 != v9) {
        objc_enumerationMutation(v6);
      }
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
      if (*a4) {
        break;
      }
      if (v8 == ++v10)
      {
        uint64_t v8 = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
        if (v8) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
}

- (void)addTask:(uint64_t)a1
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (a1)
  {
    id v26 = v3;
    uint64_t v4 = [v3 uniquePid];
    int v5 = *(void **)(a1 + 8);
    if (v4 == -1)
    {
      if ([*(id *)(a1 + 8) count])
      {
        int v15 = *__error();
        uint64_t v16 = _sa_logt();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          id v17 = [v26 debugDescription];
          *(_DWORD *)statfs buf = 136315138;
          uint64_t v28 = [v17 UTF8String];
          _os_log_error_impl(&dword_1BF22B000, v16, OS_LOG_TYPE_ERROR, "%s has no uniquePid", buf, 0xCu);
        }
        *__error() = v15;
        id v18 = [v26 debugDescription];
        char v19 = [v18 UTF8String];
        _SASetCrashLogMessage(488, "%s has no uniquePid", v20, v21, v22, v23, v24, v25, v19);

        _os_crash();
        __break(1u);
      }
    }
    else
    {
      id v6 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v26, "uniquePid"));
      id v7 = [v5 objectForKeyedSubscript:v6];

      if (!v7)
      {
        id v7 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
        uint64_t v8 = *(void **)(a1 + 8);
        uint64_t v9 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v26, "uniquePid"));
        [v8 setObject:v7 forKeyedSubscript:v9];
      }
      [v7 addObject:v26];
    }
    uint64_t v10 = *(void **)(a1 + 16);
    long long v11 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend(v26, "pid"));
    id v12 = [v10 objectForKeyedSubscript:v11];

    if (!v12)
    {
      id v12 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      long long v13 = *(void **)(a1 + 16);
      long long v14 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend(v26, "pid"));
      [v13 setObject:v12 forKeyedSubscript:v14];
    }
    [v12 addObject:v26];

    id v3 = v26;
  }
}

- (NSDictionary)tasksByUniquePid
{
  return (NSDictionary *)objc_getProperty(self, a2, 8, 1);
}

- (unint64_t)targetHIDEventMachAbs
{
  return self->_targetHIDEventMachAbs;
}

- (void)setTargetHIDEventMachAbs:(unint64_t)a3
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  self->_targetHIDEventMachAbs = a3;
  if (a3 && !self->_eventTimeRange)
  {
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    obuint64_t j = self->_hidEvents;
    uint64_t v4 = [(NSMutableArray *)obj countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(void *)v22;
      while (2)
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          if (*(void *)v22 != v6) {
            objc_enumerationMutation(obj);
          }
          uint64_t v8 = *(void **)(*((void *)&v21 + 1) + 8 * i);
          uint64_t v9 = [v8 hidEventTimestamp];
          if ([v9 machAbsTime] == self->_targetHIDEventMachAbs)
          {
            if (self->_targetProcessId < 0)
            {

LABEL_17:
              long long v14 = [v8 hidEventTimestamp];
              int v15 = [v8 steps];
              uint64_t v16 = [v15 lastObject];
              id v17 = [v16 timestamp];
              id v18 = +[SATimeRange timeRangeStart:v14 end:v17];
              eventTimeRange = self->_eventTimeRange;
              self->_eventTimeRange = v18;

              goto LABEL_18;
            }
            uint64_t v10 = [v8 steps];
            long long v11 = [v10 lastObject];
            int v12 = [v11 pid];
            int targetProcessId = self->_targetProcessId;

            if (v12 == targetProcessId) {
              goto LABEL_17;
            }
          }
          else
          {
          }
        }
        uint64_t v5 = [(NSMutableArray *)obj countByEnumeratingWithState:&v21 objects:v25 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }
LABEL_18:
  }
}

- (BOOL)haveKPerfSched
{
  return self->_haveKPerfSched;
}

- (void)setHaveKPerfSched:(BOOL)a3
{
  self->_haveKPerfSched = a3;
}

- (NSArray)kperfTriggers
{
  return self->_kperfTriggers;
}

- (void)setKperfTriggers:(id)a3
{
  uint64_t v4 = (NSArray *)[a3 copy];
  kperfTriggers = self->_kperfTriggers;
  self->_kperfTriggers = v4;
}

- (double)kPerfPETSampleIntervalLimit
{
  return self->_sampleIntervalLimit;
}

- (void)setKPerfPETSampleIntervalLimit:(double)a3
{
  self->_sampleIntervalLimit = a3;
}

- (BOOL)kPerfPETParsePastLastStackshot
{
  return self->_kPerfPETParsePastLastStackshot;
}

- (void)setKPerfPETParsePastLastStackshot:(BOOL)a3
{
  self->_kPerfPETParsePastLastStackshot = a3;
}

- (void)addSharedCache:(uint64_t)a1
{
  id v3 = a2;
  if (a1)
  {
    id v5 = v3;
    char v4 = [*(id *)(a1 + 112) containsObject:v3];
    id v3 = v5;
    if ((v4 & 1) == 0)
    {
      [*(id *)(a1 + 112) addObject:v5];
      id v3 = v5;
    }
  }
}

- (unint64_t)numSamples
{
  unint64_t result = [(NSMutableArray *)self->_sampleTimestamps count];
  if (!result) {
    return self->_numSamples;
  }
  return result;
}

- (void)setStartTime:(uint64_t)a1
{
  id v4 = a2;
  if (a1) {
    objc_storeStrong((id *)(a1 + 40), a2);
  }
}

- (void)setEndTime:(uint64_t)a1
{
  id v4 = a2;
  if (a1) {
    objc_storeStrong((id *)(a1 + 48), a2);
  }
}

- (void)addIOEvent:(uint64_t)a1
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v10 = v3;
    [*(id *)(a1 + 88) addObject:v3];
    id v4 = *(void **)(a1 + 968);
    id v5 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v10, "threadID"));
    uint64_t v6 = [v4 objectForKeyedSubscript:v5];

    if (v6)
    {
      [v6 addObject:v10];
    }
    else
    {
      id v7 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithObjects:", v10, 0);
      uint64_t v8 = *(void **)(a1 + 968);
      uint64_t v9 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v10, "threadID"));
      [v8 setObject:v7 forKeyedSubscript:v9];
    }
    id v3 = v10;
  }
}

- (void)removeAllData
{
  if (a1)
  {
    id v2 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    id v3 = (void *)a1[3];
    a1[3] = v2;

    id v4 = (void *)a1[5];
    a1[4] = 0;
    a1[5] = 0;

    id v5 = (void *)a1[6];
    a1[6] = 0;

    id v6 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    id v7 = (void *)a1[2];
    a1[2] = v6;

    id v8 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    uint64_t v9 = (void *)a1[1];
    a1[1] = v8;

    id v10 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    long long v11 = (void *)a1[7];
    a1[7] = v10;

    id v12 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    long long v13 = (void *)a1[8];
    a1[8] = v12;

    id v14 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    int v15 = (void *)a1[11];
    a1[11] = v14;

    id v16 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    id v17 = (void *)a1[121];
    a1[121] = v16;

    id v18 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    char v19 = (void *)a1[12];
    a1[12] = v18;

    id v20 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    long long v21 = (void *)a1[9];
    a1[9] = v20;
  }
}

- (BOOL)isEmpty
{
  return [(SASampleStore *)self numSamples] == 0;
}

- (void)enumerateTasks:(id)a3
{
  id v4 = a3;
  uint64_t v5 = [(NSMutableDictionary *)self->_tasksByUniquePid count];
  uint64_t v6 = 8;
  if (!v5) {
    uint64_t v6 = 16;
  }
  id v7 = *(Class *)((char *)&self->super.isa + v6);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = __32__SASampleStore_enumerateTasks___block_invoke;
  v9[3] = &unk_1E63F7258;
  id v10 = v4;
  id v8 = v4;
  [v7 enumerateKeysAndObjectsUsingBlock:v9];
}

- (void)useDsymForUUIDFor:(id)a3
{
  id v16 = a3;
  id v4 = (const char *)[v16 UTF8String];
  if (v4 && (__endptr = 0, unint64_t v5 = strtoull(v4, &__endptr, 0), __endptr) && !*__endptr)
  {
    unint64_t v10 = v5;
    uint64_t v6 = self;
    objc_sync_enter(v6);
    idsToUseDsymForUUID = v6->_idsToUseDsymForUUID;
    if (idsToUseDsymForUUID)
    {
      id v12 = [NSNumber numberWithUnsignedLongLong:v10];
      [(NSMutableArray *)idsToUseDsymForUUID addObject:v12];
    }
    else
    {
      id v13 = objc_alloc(MEMORY[0x1E4F1CA48]);
      id v12 = [NSNumber numberWithUnsignedLongLong:v10];
      uint64_t v14 = objc_msgSend(v13, "initWithObjects:", v12, 0);
      int v15 = v6->_idsToUseDsymForUUID;
      v6->_idsToUseDsymForUUID = (NSMutableArray *)v14;
    }
  }
  else
  {
    uint64_t v6 = self;
    objc_sync_enter(v6);
    namesToUseDsymForUUID = v6->_namesToUseDsymForUUID;
    if (namesToUseDsymForUUID)
    {
      [(NSMutableArray *)namesToUseDsymForUUID addObject:v16];
    }
    else
    {
      uint64_t v8 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithObjects:", v16, 0);
      uint64_t v9 = v6->_namesToUseDsymForUUID;
      v6->_namesToUseDsymForUUID = (NSMutableArray *)v8;
    }
  }
  objc_sync_exit(v6);
}

- (id)fanSpeedClosestToTimestamp:(id)a3
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  unint64_t v5 = self->_fanSpeeds;
  uint64_t v6 = [(NSMutableArray *)v5 countByEnumeratingWithState:&v26 objects:v30 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)v27;
LABEL_3:
    uint64_t v10 = 0;
    while (1)
    {
      if (*(void *)v27 != v9) {
        objc_enumerationMutation(v5);
      }
      long long v11 = *(void **)(*((void *)&v26 + 1) + 8 * v10);
      if (!v8) {
        goto LABEL_8;
      }
      id v12 = objc_msgSend(v8, "timestamp", (void)v26);
      [v12 machAbsTimeSeconds];
      double v14 = v13;
      [v4 machAbsTimeSeconds];
      double v16 = vabdd_f64(v14, v15);
      id v17 = [v11 timestamp];
      [v17 machAbsTimeSeconds];
      double v19 = v18;
      [v4 machAbsTimeSeconds];
      double v21 = vabdd_f64(v19, v20);

      if (v16 > v21)
      {
LABEL_8:
        id v22 = v11;

        uint64_t v8 = v22;
      }
      long long v23 = objc_msgSend(v8, "timestamp", (void)v26);
      char v24 = [v23 ge:v4];

      if (v24) {
        break;
      }
      if (v7 == ++v10)
      {
        uint64_t v7 = [(NSMutableArray *)v5 countByEnumeratingWithState:&v26 objects:v30 count:16];
        if (v7) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
  }

  return v8;
}

- (BOOL)haveCPUClusterInfo
{
  if (self) {
    self = (SASampleStore *)objc_getProperty(self, a2, 1032, 1);
  }
  return self != 0;
}

- (BOOL)isECoreForCPUNum:(unsigned int)a3
{
  return -[SASampleStore clusterFlagsForCPUNum:](self, *(const char **)&a3) & 1;
}

- (void)clusterFlagsForCPUNum:(void *)result
{
  if (result)
  {
    id Property = objc_getProperty(result, a2, 1032, 1);
    id v4 = NSNumber;
    id v5 = Property;
    uint64_t v6 = [v4 numberWithUnsignedInt:a2];
    uint64_t v7 = [v5 objectForKeyedSubscript:v6];

    uint64_t v8 = [v7 unsignedLongLongValue];
    return (void *)v8;
  }
  return result;
}

- (BOOL)isPCoreForCPUNum:(unsigned int)a3
{
  return ((unint64_t)-[SASampleStore clusterFlagsForCPUNum:](self, *(const char **)&a3) >> 1) & 1;
}

- (BOOL)setTargetProcessWithHint:(id)a3
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = v4;
  if (!v4 || ![v4 length])
  {
    self->_int targetProcessId = -1;
    self->_targetThreadId = 0;
    -[SASampleStore findTargetProcessInTimeRange:]((uint64_t)self, 0);
    BOOL v11 = 1;
    goto LABEL_75;
  }
  id v68 = objc_alloc_init(MEMORY[0x1E4F28EE0]);
  CFNumberRef v6 = [v68 numberFromString:v5];
  int v80 = self;
  CFNumberRef v69 = v6;
  if (!v6) {
    goto LABEL_5;
  }
  CFNumberRef v7 = v6;
  if (CFNumberIsFloatType(v6)) {
    goto LABEL_5;
  }
  CFDictionaryRef v46 = self->_eventTimeRange;
  uint64_t v47 = [(__CFNumber *)v7 intValue];
  if (v46)
  {
    v48 = [(SATimeRange *)v46 endTime];
    uint64_t v49 = -[SASampleStore lastTaskWithPid:onOrBeforeTimestamp:](self, v47, v48);
    if (v49)
    {
      uint64_t v40 = (SATask *)v49;

LABEL_64:
      CFNumberRef v50 = v69;
      goto LABEL_65;
    }
    uint64_t v51 = [(__CFNumber *)v69 intValue];
    v52 = [(SATimeRange *)v46 endTime];
    -[SASampleStore firstTaskWithPid:onOrAfterTimestamp:](self, v51, v52);
    uint64_t v40 = (SATask *)objc_claimAutoreleasedReturnValue();

    if (v40) {
      goto LABEL_64;
    }
    uint64_t v61 = [(__CFNumber *)v69 unsignedLongLongValue];
    v62 = [(SATimeRange *)v46 endTime];
    v63 = -[SASampleStore lastTaskWithUniquePid:onOrBeforeTimestamp:](self, v61, v62);
    v64 = v63;
    if (v63)
    {
      uint64_t v40 = v63;
    }
    else
    {
      uint64_t v65 = [(__CFNumber *)v69 unsignedLongLongValue];
      [(SATimeRange *)v46 endTime];
      id v67 = v66 = v5;
      -[SASampleStore firstTaskWithUniquePid:onOrAfterTimestamp:](v80, v65, v67);
      uint64_t v40 = (SATask *)objc_claimAutoreleasedReturnValue();

      id v5 = v66;
    }
  }
  else
  {
    -[SASampleStore lastTaskWithPid:](self, v47);
    uint64_t v40 = (SATask *)objc_claimAutoreleasedReturnValue();
    if (v40) {
      goto LABEL_64;
    }
    -[SASampleStore lastTaskWithUniquePid:](self, [(__CFNumber *)v69 unsignedLongLongValue]);
    uint64_t v40 = (SATask *)objc_claimAutoreleasedReturnValue();
  }

  self = v80;
  CFNumberRef v50 = v69;
  if (v40) {
    goto LABEL_65;
  }
LABEL_5:
  if ([(NSMutableDictionary *)self->_tasksByUniquePid count])
  {
    uint64_t v8 = [(NSMutableDictionary *)self->_tasksByUniquePid allValues];
    uint64_t v9 = v8;
    uint64_t v10 = &__block_literal_global_1;
  }
  else
  {
    uint64_t v8 = [(NSMutableDictionary *)self->_tasksByPid allValues];
    uint64_t v9 = v8;
    uint64_t v10 = &__block_literal_global_157;
  }
  id v12 = [v8 sortedArrayUsingComparator:v10];

  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  id v13 = v12;
  uint64_t v72 = [v13 countByEnumeratingWithState:&v88 objects:v93 count:16];
  if (!v72)
  {

    uint64_t v41 = 0;
    v43 = 0;
    id v44 = 0;
    v45 = 0;
    v42 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    goto LABEL_57;
  }
  id v77 = 0;
  double v78 = 0;
  BOOL v74 = 0;
  char v75 = 0;
  v79 = 0;
  v76 = 0;
  obuint64_t j = v13;
  uint64_t v71 = *(void *)v89;
  double v14 = v80;
  do
  {
    uint64_t v15 = 0;
    do
    {
      if (*(void *)v89 != v71) {
        objc_enumerationMutation(obj);
      }
      uint64_t v73 = v15;
      double v16 = *(void **)(*((void *)&v88 + 1) + 8 * v15);
      long long v84 = 0u;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      id v81 = v16;
      uint64_t v83 = [v81 countByEnumeratingWithState:&v84 objects:v92 count:16];
      if (v83)
      {
        uint64_t v82 = *(void *)v85;
        do
        {
          for (uint64_t i = 0; i != v83; ++i)
          {
            if (*(void *)v85 != v82) {
              objc_enumerationMutation(v81);
            }
            double v18 = *(void **)(*((void *)&v84 + 1) + 8 * i);
            double v19 = [v18 name];
            if (v19)
            {
              double v20 = v14->_eventTimeRange;
              if (v20)
              {
                double v21 = [v18 startTimestamp];
                id v22 = [(SATimeRange *)v20 endTime];
                if ([v21 gt:v22])
                {

LABEL_42:
                  goto LABEL_43;
                }
                [v18 endTimestamp];
                char v24 = v23 = v5;
                uint64_t v25 = [(SATimeRange *)v20 startTime];
                char v26 = [v24 lt:v25];

                id v5 = v23;
                double v14 = v80;

                if (v26) {
                  goto LABEL_42;
                }
              }
              long long v27 = [v18 name];
              uint64_t v28 = [v27 rangeOfString:v5];
              uint64_t v30 = v29;

              if (v28 == 0x7FFFFFFFFFFFFFFFLL)
              {
                uint64_t v33 = [v18 name];
                uint64_t v34 = [v33 rangeOfString:v5 options:1];
                uint64_t v36 = v35;

                if (v34 != 0x7FFFFFFFFFFFFFFFLL)
                {
                  if (v34)
                  {
                    if (!v76) {
                      v76 = v18;
                    }
                  }
                  else
                  {
                    int v37 = [v18 name];
                    uint64_t v38 = [v37 length];

                    if (v36 == v38)
                    {
                      if (!v75) {
                        char v75 = v18;
                      }
                    }
                    else if (!v74)
                    {
                      BOOL v74 = v18;
                    }
                  }
                }
              }
              else if (v28)
              {
                if (!v79) {
                  v79 = v18;
                }
              }
              else
              {
                uint64_t v31 = [v18 name];
                uint64_t v32 = [v31 length];

                if (v30 == v32)
                {
                  if (!v77) {
                    id v77 = v18;
                  }
                }
                else if (!v78)
                {
                  double v78 = v18;
                }
              }
              goto LABEL_42;
            }
LABEL_43:
          }
          uint64_t v83 = [v81 countByEnumeratingWithState:&v84 objects:v92 count:16];
        }
        while (v83);
      }

      uint64_t v15 = v73 + 1;
    }
    while (v73 + 1 != v72);
    uint64_t v72 = [obj countByEnumeratingWithState:&v88 objects:v93 count:16];
  }
  while (v72);
  id v13 = obj;

  if (v77)
  {
    uint64_t v39 = (SATask *)v77;
    uint64_t v40 = v39;
    v42 = v75;
    uint64_t v41 = v76;
    goto LABEL_55;
  }
  if (v75)
  {
    v42 = v75;
    uint64_t v39 = 0;
    uint64_t v40 = v42;
    uint64_t v41 = v76;
LABEL_55:
    v45 = v78;
    v43 = v79;
LABEL_56:
    id v44 = v74;
  }
  else
  {
    if (v78)
    {
      v45 = v78;
      v42 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = v45;
      uint64_t v41 = v76;
      v43 = v79;
      goto LABEL_56;
    }
    if (v74)
    {
      id v44 = v74;
      v45 = 0;
      v42 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = v44;
      uint64_t v41 = v76;
      v43 = v79;
    }
    else if (v79)
    {
      v43 = v79;
      id v44 = 0;
      v45 = 0;
      v42 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = v43;
      uint64_t v41 = v76;
    }
    else
    {
      if (v76)
      {
        uint64_t v41 = v76;
        v43 = 0;
        id v44 = 0;
        v45 = 0;
        v42 = 0;
        uint64_t v39 = 0;
        uint64_t v40 = v41;
      }
      else
      {
        uint64_t v41 = 0;
        v43 = 0;
        id v44 = 0;
        v45 = 0;
        v42 = 0;
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      id v13 = obj;
    }
  }
LABEL_57:

  self = v80;
  CFNumberRef v50 = v69;
  if (!v40)
  {
    BOOL v11 = 0;
    goto LABEL_74;
  }
LABEL_65:
  if (self->_targetProcess == v40)
  {
    BOOL v11 = 1;
  }
  else
  {
    objc_storeStrong((id *)&self->_targetProcess, v40);
    self->_int targetProcessId = [(SATask *)v40 pid];
    v53 = self;
    if (self->_targetThreadId)
    {
      uint64_t v54 = [(SATask *)self->_targetProcess threads];
      v55 = [NSNumber numberWithUnsignedLongLong:v53->_targetThreadId];
      v56 = [v54 objectForKeyedSubscript:v55];

      if (!v56) {
        v53->_targetThreadId = 0;
      }
    }
    if (v53->_targetDispatchQueueId)
    {
      SEL v57 = [(SATask *)v53->_targetProcess dispatchQueues];
      v58 = [NSNumber numberWithUnsignedLongLong:v53->_targetDispatchQueueId];
      v59 = [v57 objectForKeyedSubscript:v58];

      if (!v59) {
        v53->_targetDispatchQueueId = 0;
      }
    }
    BOOL v11 = 1;
    CFNumberRef v50 = v69;
  }
LABEL_74:

LABEL_75:
  return v11;
}

- (void)lastTaskWithPid:(void *)a3 onOrBeforeTimestamp:
{
  id v5 = a3;
  if (a1)
  {
    CFNumberRef v6 = (void *)a1[2];
    CFNumberRef v7 = [NSNumber numberWithInt:a2];
    uint64_t v8 = [v6 objectForKeyedSubscript:v7];

    if (v8)
    {
      if (v5) {
        -[SASampleStore _lastTaskOnOrBeforeTimestamp:inTasks:]((uint64_t)a1, v5, v8);
      }
      else {
      a1 = [v8 lastObject];
      }
    }
    else
    {
      a1 = 0;
    }
  }
  return a1;
}

- (void)firstTaskWithPid:(void *)a3 onOrAfterTimestamp:
{
  id v5 = a3;
  if (a1)
  {
    CFNumberRef v6 = (void *)a1[2];
    CFNumberRef v7 = [NSNumber numberWithInt:a2];
    uint64_t v8 = [v6 objectForKeyedSubscript:v7];

    if (v8)
    {
      if (v5) {
        -[SASampleStore _firstTaskOnOrAfterTimestamp:inTasks:](v5, v8);
      }
      else {
      a1 = [v8 firstObject];
      }
    }
    else
    {
      a1 = 0;
    }
  }
  return a1;
}

- (void)lastTaskWithUniquePid:(void *)a3 onOrBeforeTimestamp:
{
  id v5 = a3;
  if (a1)
  {
    CFNumberRef v6 = (void *)a1[1];
    CFNumberRef v7 = [NSNumber numberWithUnsignedLongLong:a2];
    uint64_t v8 = [v6 objectForKeyedSubscript:v7];

    if (v5) {
      -[SASampleStore _lastTaskOnOrBeforeTimestamp:inTasks:]((uint64_t)a1, v5, v8);
    }
    else {
    a1 = [v8 lastObject];
    }
  }
  return a1;
}

- (void)firstTaskWithUniquePid:(void *)a3 onOrAfterTimestamp:
{
  id v5 = a3;
  if (a1)
  {
    CFNumberRef v6 = (void *)a1[1];
    CFNumberRef v7 = [NSNumber numberWithUnsignedLongLong:a2];
    uint64_t v8 = [v6 objectForKeyedSubscript:v7];

    if (v5) {
      -[SASampleStore _firstTaskOnOrAfterTimestamp:inTasks:](v5, v8);
    }
    else {
    a1 = [v8 firstObject];
    }
  }
  return a1;
}

- (void)lastTaskWithUniquePid:(void *)a1
{
  if (a1)
  {
    a1 = -[SASampleStore lastTaskWithUniquePid:onOrBeforeTimestamp:](a1, a2, 0);
    uint64_t v2 = vars8;
  }
  return a1;
}

uint64_t __42__SASampleStore_setTargetProcessWithHint___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  CFNumberRef v6 = [v4 lastObject];
  unint64_t v7 = [v6 uniquePid];
  uint64_t v8 = [v5 lastObject];
  unint64_t v9 = [v8 uniquePid];

  if (v7 <= v9)
  {
    BOOL v11 = [v4 lastObject];
    unint64_t v12 = [v11 uniquePid];
    id v13 = [v5 lastObject];
    uint64_t v10 = v12 < [v13 uniquePid];
  }
  else
  {
    uint64_t v10 = -1;
  }

  return v10;
}

uint64_t __42__SASampleStore_setTargetProcessWithHint___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = [a3 lastObject];
  int v6 = [v5 pid];
  unint64_t v7 = [v4 lastObject];

  uint64_t v8 = (int)(v6 - [v7 pid]);
  return v8;
}

- (unint64_t)targetThreadId
{
  return self->_targetThreadId;
}

- (void)setTargetThreadId:(unint64_t)a3
{
  if (self->_targetThreadId != a3)
  {
    self->_targetThreadId = a3;
    -[SASampleStore findTargetProcessInTimeRange:]((uint64_t)self, 0);
  }
}

- (unint64_t)targetDispatchQueueId
{
  return self->_targetDispatchQueueId;
}

- (void)setTargetDispatchQueueId:(unint64_t)a3
{
  if (self->_targetDispatchQueueId != a3)
  {
    unint64_t v3 = a3;
    if (a3)
    {
      targetProcess = self->_targetProcess;
      if (targetProcess)
      {
        int v6 = [(SATask *)targetProcess dispatchQueues];
        unint64_t v7 = [NSNumber numberWithUnsignedLongLong:v3];
        uint64_t v8 = [v6 objectForKeyedSubscript:v7];

        if (!v8) {
          unint64_t v3 = 0;
        }
      }
    }
    self->_targetDispatchQueueId = v3;
  }
}

- (int)targetProcessId
{
  return self->_targetProcessId;
}

- (void)setTargetProcess:(id)a3
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v5 = (SATask *)a3;
  targetProcess = self->_targetProcess;
  if (targetProcess != v5)
  {
    uint64_t v28 = v5;
    if (v5)
    {
      tasksByPid = self->_tasksByPid;
      uint64_t v8 = objc_msgSend(NSNumber, "numberWithInt:", -[SATask pid](v5, "pid"));
      unint64_t v9 = [(NSMutableDictionary *)tasksByPid objectForKeyedSubscript:v8];
      uint64_t v10 = [v9 indexOfObjectIdenticalTo:v28];

      if (v10 == 0x7FFFFFFFFFFFFFFFLL)
      {
        int v17 = *__error();
        double v18 = _sa_logt();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          id v19 = [(SATask *)v28 debugDescription];
          *(_DWORD *)statfs buf = 136315138;
          uint64_t v30 = [v19 UTF8String];
          _os_log_error_impl(&dword_1BF22B000, v18, OS_LOG_TYPE_ERROR, "Setting target process %s which isn't in this SASampleStore", buf, 0xCu);
        }
        *__error() = v17;
        id v20 = [(SATask *)v28 debugDescription];
        char v21 = [v20 UTF8String];
        _SASetCrashLogMessage(859, "Setting target process %s which isn't in this SASampleStore", v22, v23, v24, v25, v26, v27, v21);

        _os_crash();
        __break(1u);
      }
      objc_storeStrong((id *)&self->_targetProcess, a3);
      self->_int targetProcessId = [(SATask *)v28 pid];
      if (self->_targetThreadId)
      {
        BOOL v11 = [(SATask *)v28 threads];
        unint64_t v12 = [NSNumber numberWithUnsignedLongLong:self->_targetThreadId];
        id v13 = [v11 objectForKeyedSubscript:v12];

        if (!v13) {
          self->_targetThreadId = 0;
        }
      }
      id v5 = v28;
      if (self->_targetDispatchQueueId)
      {
        double v14 = [(SATask *)v28 dispatchQueues];
        uint64_t v15 = [NSNumber numberWithUnsignedLongLong:self->_targetDispatchQueueId];
        double v16 = [v14 objectForKeyedSubscript:v15];

        id v5 = v28;
        if (!v16) {
          self->_targetDispatchQueueId = 0;
        }
      }
    }
    else
    {
      self->_targetProcess = 0;

      id v5 = 0;
      self->_int targetProcessId = -1;
      self->_targetThreadId = 0;
      self->_targetDispatchQueueId = 0;
    }
  }
}

- (id)taskWithPid:(uint64_t)a3 orTid:(void *)a4 atTimestamp:
{
  id v7 = a4;
  if (!a1)
  {
LABEL_14:

    return a1;
  }
  if (a2 != -1 || a3)
  {
    uint64_t v8 = [a1 startTime];
    if (v8 && [v7 lt:v8])
    {
      id v9 = v7;
      id v7 = v8;
    }
    else
    {
      id v9 = [a1 endTime];
      if (v9 && [v7 gt:v9])
      {
        id v9 = v9;

        id v7 = v9;
      }
    }

    if (a2 == -1)
    {
      *(void *)statfs buf = 0;
      uint64_t v25 = buf;
      uint64_t v26 = 0x3032000000;
      uint64_t v27 = __Block_byref_object_copy__0;
      uint64_t v28 = __Block_byref_object_dispose__0;
      id v29 = 0;
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 3221225472;
      v20[2] = __47__SASampleStore_taskWithPid_orTid_atTimestamp___block_invoke;
      v20[3] = &unk_1E63F7438;
      uint64_t v23 = a3;
      id v21 = v7;
      uint64_t v22 = buf;
      [a1 enumerateTasks:v20];
      a1 = *((id *)v25 + 5);

      _Block_object_dispose(buf, 8);
    }
    else
    {
      -[SASampleStore taskWithPid:atTimestamp:]((uint64_t)a1, a2, v7);
      a1 = (id)objc_claimAutoreleasedReturnValue();
    }

    goto LABEL_14;
  }
  int v11 = *__error();
  unint64_t v12 = _sa_logt();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)statfs buf = 0;
    _os_log_error_impl(&dword_1BF22B000, v12, OS_LOG_TYPE_ERROR, "neither pid nor tid provided", buf, 2u);
  }

  *__error() = v11;
  _SASetCrashLogMessage(1870, "neither pid nor tid provided", v13, v14, v15, v16, v17, v18, v19);
  id result = (id)_os_crash();
  __break(1u);
  return result;
}

- (id)lastTaskWithPid:(uint64_t)a3 orTid:
{
  if (!a1)
  {
LABEL_13:
    id v3 = 0;
    goto LABEL_7;
  }
  if (a2 == -1 && !a3)
  {
    int v5 = *__error();
    int v6 = _sa_logt();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v6, OS_LOG_TYPE_ERROR, "neither pid nor tid provided", buf, 2u);
    }

    *__error() = v5;
    _SASetCrashLogMessage(1901, "neither pid nor tid provided", v7, v8, v9, v10, v11, v12, v13[0]);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (a2 == -1)
  {
    *(void *)statfs buf = 0;
    uint64_t v15 = buf;
    uint64_t v16 = 0x3032000000;
    uint64_t v17 = __Block_byref_object_copy__0;
    uint64_t v18 = __Block_byref_object_dispose__0;
    id v19 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __39__SASampleStore_lastTaskWithPid_orTid___block_invoke;
    v13[3] = &unk_1E63F7460;
    v13[4] = buf;
    v13[5] = a3;
    [a1 enumerateTasks:v13];
    id v3 = *((id *)v15 + 5);
    _Block_object_dispose(buf, 8);
  }
  else
  {
    -[SASampleStore lastTaskWithPid:](a1, a2);
    id v3 = (id)objc_claimAutoreleasedReturnValue();
  }
LABEL_7:
  return v3;
}

- (id)taskWithPid:(void *)a3 atTimestamp:
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  int v6 = *(void **)(a1 + 16);
  uint64_t v7 = [NSNumber numberWithInt:a2];
  uint64_t v8 = [v6 objectForKeyedSubscript:v7];

  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v9 = v8;
  id v10 = (id)[v9 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v10)
  {
    uint64_t v11 = *(void *)v16;
    while (2)
    {
      for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v11) {
          objc_enumerationMutation(v9);
        }
        uint64_t v13 = *(void **)(*((void *)&v15 + 1) + 8 * i);
        if (-[SATask isAliveAtTimestamp:](v13, v5))
        {
          id v10 = v13;
          goto LABEL_11;
        }
      }
      id v10 = (id)[v9 countByEnumeratingWithState:&v15 objects:v19 count:16];
      if (v10) {
        continue;
      }
      break;
    }
  }
LABEL_11:

  return v10;
}

- (NSString)targetProcessName
{
  return [(SATask *)self->_targetProcess name];
}

- (NSString)targetProcessAbsolutePath
{
  uint64_t v2 = [(SATask *)self->_targetProcess mainBinaryPath];
  if ([v2 isAbsolutePath]) {
    id v3 = v2;
  }
  else {
    id v3 = 0;
  }

  return (NSString *)v3;
}

- (NSString)targetProcessBundleName
{
  return [(SATask *)self->_targetProcess bundleName];
}

- (NSString)targetProcessBundleVersion
{
  return [(SATask *)self->_targetProcess bundleVersion];
}

- (NSString)targetProcessBundleShortVersion
{
  return [(SATask *)self->_targetProcess bundleShortVersion];
}

- (NSString)targetProcessBundleBuildVersion
{
  return [(SATask *)self->_targetProcess bundleBuildVersion];
}

- (NSString)targetProcessBundleProjectName
{
  return [(SATask *)self->_targetProcess bundleProjectName];
}

- (NSString)targetProcessBundleSourceVersion
{
  return [(SATask *)self->_targetProcess bundleSourceVersion];
}

- (NSString)targetProcessBundleProductBuildVersion
{
  return [(SATask *)self->_targetProcess bundleProductBuildVersion];
}

- (NSString)targetProcessBundleId
{
  return [(SATask *)self->_targetProcess bundleIdentifier];
}

- (NSString)targetProcessCommerceAppID
{
  return (NSString *)objc_msgSend(NSString, "stringWithFormat:", @"%llu", -[SATask adamID](self->_targetProcess, "adamID"));
}

- (NSString)targetProcessCommerceExternalID
{
  return [(SATask *)self->_targetProcess installerVersionID];
}

- (NSString)targetProcessVendorID
{
  return [(SATask *)self->_targetProcess vendorID];
}

- (BOOL)cacheLoadInfoForProcess:(int)a3
{
  id v4 = -[SASampleStore lastTaskWithPid:](self, *(uint64_t *)&a3);
  id v5 = v4;
  if (v4 && (unint64_t dataGatheringOptions = self->_dataGatheringOptions, (dataGatheringOptions & 2) != 0))
  {
    char v8 = -[SATask gatherLoadInfoFromLiveProcessWithDataGatheringOptions:additionalCSSymbolicatorFlags:]((uint64_t)v4, dataGatheringOptions, self->_additionalCSSymbolicatorFlags);
  }
  else
  {
    uint64_t v7 = [v4 binaryLoadInfos];
    char v8 = [v7 count] != 0;
  }
  return v8;
}

- (void)addAuxiliaryData:(id)a3
{
  id v4 = a3;
  selfa = v4;
  if (v4)
  {
    id v7 = objc_getProperty(v4, v5, 8, 1);
    if (v7) {
      [(NSMutableArray *)self->_fanSpeeds addObject:v7];
    }
    char v8 = (void *)selfa[2];
    if (v8)
    {
      mountStatusTracker = self->_mountStatusTracker;
      id Property = objc_getProperty(selfa, v6, 24, 1);
      -[SAMountStatusTracker addMountStatus:forTimestamp:]((uint64_t)mountStatusTracker, v8, Property);
    }
  }
  else
  {
    id v7 = 0;
  }
}

- (void)startingSamplingLiveSystem
{
  if (self)
  {
    if (self->_lastWakeTime == 0.0) {
      self->_lastWakeTime = -[SASampleStore _getLastWakeTime]((uint64_t)self);
    }
  }
}

- (void)enumerateTasksWithLiveness:(uint64_t)a1
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    id v5 = *(void **)(a1 + 16);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = __44__SASampleStore_enumerateTasksWithLiveness___block_invoke;
    v6[3] = &unk_1E63F72A0;
    v6[4] = a1;
    id v7 = v3;
    [v5 enumerateKeysAndObjectsUsingBlock:v6];
  }
}

void __44__SASampleStore_enumerateTasksWithLiveness___block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(void *)(*(void *)(a1 + 32) + 408);
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v5 = objc_msgSend(a3, "reverseObjectEnumerator", 0);
  uint64_t v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v6)
  {
    uint64_t v8 = v6;
    uint64_t v9 = *(void *)v13;
    uint64_t v10 = (v4 >> 1) & 1;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v13 != v9) {
          objc_enumerationMutation(v5);
        }
        if ((v10 & 1) != 0 && (*(unsigned char *)(*(void *)(a1 + 32) + 352) & 4) != 0) {
          [(SATask *)*(id *)(*((void *)&v12 + 1) + 8 * i) isFromCurrentBootCycle];
        }
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
        LOBYTE(v10) = 0;
      }
      uint64_t v8 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
      LOBYTE(v10) = 0;
    }
    while (v8);
  }
}

- (id)fixupAllFrames
{
  v1 = a1;
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    id v19 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
    uint64_t v27 = 0;
    uint64_t v28 = &v27;
    uint64_t v29 = 0x2020000000;
    char v30 = 0;
    uint64_t v2 = mach_absolute_time();
    double v3 = SASecondsFromMachTimeUsingLiveTimebase(v2);
    int v4 = 0;
    uint64_t v5 = MEMORY[0x1E4F143A8];
    uint64_t v6 = v28;
    do
    {
      int v7 = v4;
      *((unsigned char *)v6 + 24) = 0;
      v24[0] = v5;
      v24[1] = 3221225472;
      v24[2] = __31__SASampleStore_fixupAllFrames__block_invoke;
      v24[3] = &unk_1E63F72C8;
      v24[4] = v1;
      id v8 = v19;
      id v25 = v8;
      uint64_t v26 = &v27;
      -[SASampleStore enumerateTasksWithLiveness:]((uint64_t)v1, v24);
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      id v9 = v1[15];
      uint64_t v10 = [v9 countByEnumeratingWithState:&v20 objects:v35 count:16];
      if (v10)
      {
        uint64_t v11 = *(void *)v21;
        do
        {
          for (uint64_t i = 0; i != v10; ++i)
          {
            if (*(void *)v21 != v11) {
              objc_enumerationMutation(v9);
            }
            uint64_t v13 = *(void *)(*((void *)&v20 + 1) + 8 * i);
            buf[0] = 0;
            -[SAExclave fixupFrameInstructionsWithNewInstructions:foundNewBinaryInfo:](v13, v8, buf);
            if (buf[0]) {
              *((unsigned char *)v28 + 24) = 1;
            }
          }
          uint64_t v10 = [v9 countByEnumeratingWithState:&v20 objects:v35 count:16];
        }
        while (v10);
      }

      int v4 = v7 + 1;
      uint64_t v6 = v28;
    }
    while (*((unsigned char *)v28 + 24));
    if (v7)
    {
      int v14 = *__error();
      long long v15 = _sa_logt();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v17 = mach_absolute_time();
        double v18 = SASecondsFromMachTimeUsingLiveTimebase(v17);
        *(_DWORD *)statfs buf = 67109376;
        int v32 = v7 + 1;
        __int16 v33 = 2048;
        double v34 = v18 - v3;
        _os_log_debug_impl(&dword_1BF22B000, v15, OS_LOG_TYPE_DEBUG, "Iterated frame fixup %d times (in %.3fs)", buf, 0x12u);
      }

      *__error() = v14;
    }
    v1 = (id *)[v8 copy];
    _Block_object_dispose(&v27, 8);
  }
  return v1;
}

void __31__SASampleStore_fixupAllFrames__block_invoke(uint64_t a1, id *a2, int a3)
{
  char v4 = 0;
  -[SATask fixupFrameInstructionsWithDataGatheringOptions:mightBeAlive:foundNewBinaryInfo:uuidsWithNewInstructions:additionalCSSymbolicatorFlags:](a2, *(void *)(*(void *)(a1 + 32) + 408), a3, &v4, *(void **)(a1 + 40), *(_DWORD *)(*(void *)(a1 + 32) + 328));
  if (v4) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
}

- (void)resampleTruncatedBacktraces
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (a1 && (~*(_DWORD *)(a1 + 408) & 0x402) == 0 && !*(unsigned char *)(a1 + 312))
  {
    *(unsigned char *)(a1 + 312) = 1;
    uint64_t v2 = mach_absolute_time();
    double v3 = SASecondsFromMachTimeUsingLiveTimebase(v2);
    uint64_t v22 = 0;
    long long v23 = &v22;
    uint64_t v24 = 0x2020000000;
    int v25 = 0;
    uint64_t v18 = 0;
    id v19 = &v18;
    uint64_t v20 = 0x2020000000;
    int v21 = 0;
    char v4 = objc_alloc_init(SAFrameIterator);
    [(SAFrameIterator *)v4 setBacktracer:3];
    uint64_t v5 = [(id)a1 tasksByPid];
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __44__SASampleStore_resampleTruncatedBacktraces__block_invoke;
    v13[3] = &unk_1E63F7708;
    uint64_t v6 = v4;
    int v14 = v6;
    uint64_t v15 = a1;
    long long v16 = &v18;
    uint64_t v17 = &v22;
    [v5 enumerateKeysAndObjectsUsingBlock:v13];

    uint64_t v7 = mach_absolute_time();
    double v8 = SASecondsFromMachTimeUsingLiveTimebase(v7);
    int v9 = *__error();
    uint64_t v10 = _sa_logt();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      int v11 = *((_DWORD *)v23 + 6);
      int v12 = *((_DWORD *)v19 + 6);
      *(_DWORD *)statfs buf = 67109632;
      int v27 = v11;
      __int16 v28 = 1024;
      int v29 = v12;
      __int16 v30 = 2048;
      double v31 = v8 - v3;
      _os_log_debug_impl(&dword_1BF22B000, v10, OS_LOG_TYPE_DEBUG, "Resampling %d tasks (%d threads) took %.3fs", buf, 0x18u);
    }

    *__error() = v9;
    _Block_object_dispose(&v18, 8);
    _Block_object_dispose(&v22, 8);
  }
}

void __28__SASampleStore_postprocess__block_invoke(uint64_t a1, uint64_t a2, int a3)
{
}

void __28__SASampleStore_postprocess__block_invoke_2(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = [a2 threads];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = __28__SASampleStore_postprocess__block_invoke_3;
  v7[3] = &unk_1E63F7318;
  long long v6 = *(_OWORD *)(a1 + 48);
  long long v8 = *(_OWORD *)(a1 + 32);
  long long v9 = v6;
  uint64_t v10 = a3;
  [v5 enumerateKeysAndObjectsUsingBlock:v7];
}

void __28__SASampleStore_postprocess__block_invoke_3(uint64_t a1, uint64_t a2, void *a3, unsigned char *a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v6 = objc_msgSend(a3, "threadStates", 0);
  uint64_t v7 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v13;
    while (2)
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v13 != v9) {
          objc_enumerationMutation(v6);
        }
        int v11 = *(void **)(*((void *)&v12 + 1) + 8 * i);
        if ([v11 originPid] != -1)
        {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
          if ((int)[v11 originPid] >= 1) {
            *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
          }
        }
        if ([v11 proximatePid] != -1)
        {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
          if ((int)[v11 proximatePid] >= 1) {
            *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
          }
        }
        if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)
          && *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24))
        {
          *a4 = 1;
          **(unsigned char **)(a1 + 64) = 1;
          goto LABEL_18;
        }
      }
      uint64_t v8 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v8) {
        continue;
      }
      break;
    }
  }
LABEL_18:
}

void __28__SASampleStore_postprocess__block_invoke_168(uint64_t a1, void *a2)
{
  double v3 = [a2 threads];
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __28__SASampleStore_postprocess__block_invoke_2_169;
  v4[3] = &__block_descriptor_34_e35_v32__0__NSNumber_8__SAThread_16_B24l;
  __int16 v5 = *(_WORD *)(a1 + 32);
  [v3 enumerateKeysAndObjectsUsingBlock:v4];
}

void __28__SASampleStore_postprocess__block_invoke_2_169(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  char v4 = objc_msgSend(a3, "threadStates", 0);
  uint64_t v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v12;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v11 + 1) + 8 * v8);
        if (*(unsigned char *)(a1 + 32))
        {
          if (!v9) {
            goto LABEL_14;
          }
          *(_DWORD *)(v9 + 28) = -1;
        }
        if (*(unsigned char *)(a1 + 33)) {
          BOOL v10 = v9 == 0;
        }
        else {
          BOOL v10 = 1;
        }
        if (!v10) {
          *(_DWORD *)(v9 + 32) = -1;
        }
LABEL_14:
        ++v8;
      }
      while (v6 != v8);
      uint64_t v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v6);
  }
}

- (double)_getLastWakeTime
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int WakeTime = IOPMGetLastWakeTime();
    if (WakeTime == -536870184) {
      return -1.0;
    }
    int v2 = WakeTime;
    if (!WakeTime) {
      return 0.0;
    }
    int v4 = *__error();
    uint64_t v5 = _sa_logt();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 67109120;
      int v7 = v2;
      _os_log_error_impl(&dword_1BF22B000, v5, OS_LOG_TYPE_ERROR, "Unable to get last wake time: %d", buf, 8u);
    }

    *__error() = v4;
  }
  return 0.0;
}

void __28__SASampleStore_postprocess__block_invoke_3_172(uint64_t a1, void *a2)
{
  id v6 = a2;
  [v6 wallTime];
  if (v3 == 0.0 || ([v6 wallTime], v4 >= *(double *)(a1 + 48)))
  {
    uint64_t v5 = *(void **)(a1 + 32);
    if (!v5 || [v5 le:v6]) {
      [v6 guessMissingTimesBasedOnTimestamp:*(void *)(a1 + 40)];
    }
  }
}

- (void)iterateAllTimestamps:(uint64_t)a1
{
  uint64_t v179 = *MEMORY[0x1E4F143B8];
  double v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (*(void *)(a1 + 40)) {
      v3[2](v3);
    }
    if (*(void *)(a1 + 48)) {
      v4[2](v4);
    }
    uint64_t v5 = *(void **)(a1 + 736);
    if (v5)
    {
      id v6 = [v5 startTime];
      ((void (*)(void (**)(void), void *))v4[2])(v4, v6);

      int v7 = [*(id *)(a1 + 736) endTime];
      ((void (*)(void (**)(void), void *))v4[2])(v4, v7);
    }
    long long v164 = 0u;
    long long v165 = 0u;
    long long v162 = 0u;
    long long v163 = 0u;
    uint64_t v101 = a1;
    id v8 = *(id *)(a1 + 24);
    uint64_t v9 = [v8 countByEnumeratingWithState:&v162 objects:v178 count:16];
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)v163;
      do
      {
        for (uint64_t i = 0; i != v10; ++i)
        {
          if (*(void *)v163 != v11) {
            objc_enumerationMutation(v8);
          }
          ((void (*)(void (**)(void), void))v4[2])(v4, *(void *)(*((void *)&v162 + 1) + 8 * i));
        }
        uint64_t v10 = [v8 countByEnumeratingWithState:&v162 objects:v178 count:16];
      }
      while (v10);
    }

    long long v160 = 0u;
    long long v161 = 0u;
    long long v158 = 0u;
    long long v159 = 0u;
    obuint64_t j = *(id *)(v101 + 56);
    uint64_t v13 = [obj countByEnumeratingWithState:&v158 objects:v177 count:16];
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)v159;
      do
      {
        for (uint64_t j = 0; j != v14; ++j)
        {
          if (*(void *)v159 != v15) {
            objc_enumerationMutation(obj);
          }
          uint64_t v17 = *(void **)(*((void *)&v158 + 1) + 8 * j);
          uint64_t v18 = objc_msgSend(v17, "hidEventTimestamp", v101);
          ((void (*)(void (**)(void), void *))v4[2])(v4, v18);

          long long v156 = 0u;
          long long v157 = 0u;
          long long v154 = 0u;
          long long v155 = 0u;
          id v19 = [v17 steps];
          uint64_t v20 = [v19 countByEnumeratingWithState:&v154 objects:v176 count:16];
          if (v20)
          {
            uint64_t v21 = v20;
            uint64_t v22 = *(void *)v155;
            do
            {
              for (uint64_t k = 0; k != v21; ++k)
              {
                if (*(void *)v155 != v22) {
                  objc_enumerationMutation(v19);
                }
                uint64_t v24 = [*(id *)(*((void *)&v154 + 1) + 8 * k) timestamp];
                ((void (*)(void (**)(void), void *))v4[2])(v4, v24);
              }
              uint64_t v21 = [v19 countByEnumeratingWithState:&v154 objects:v176 count:16];
            }
            while (v21);
          }
        }
        uint64_t v14 = [obj countByEnumeratingWithState:&v158 objects:v177 count:16];
      }
      while (v14);
    }

    long long v152 = 0u;
    long long v153 = 0u;
    long long v150 = 0u;
    long long v151 = 0u;
    id v102 = *(id *)(v101 + 64);
    uint64_t v105 = [v102 countByEnumeratingWithState:&v150 objects:v175 count:16];
    if (v105)
    {
      id v103 = *(id *)v151;
      do
      {
        uint64_t v26 = 0;
        do
        {
          if (*(id *)v151 != v103) {
            objc_enumerationMutation(v102);
          }
          int v27 = *(void **)(*((void *)&v150 + 1) + 8 * v26);
          if (v27)
          {
            id v28 = objc_getProperty(*(id *)(*((void *)&v150 + 1) + 8 * v26), v25, 32, 1);
            int v29 = [v28 startTime];
            ((void (*)(void (**)(void), void *))v4[2])(v4, v29);

            id Property = objc_getProperty(v27, v30, 32, 1);
          }
          else
          {
            v48 = [0 startTime];
            ((void (*)(void (**)(void), void *))v4[2])(v4, v48);

            id Property = 0;
          }
          id v32 = Property;
          __int16 v33 = [v32 endTime];
          ((void (*)(void (**)(void), void *))v4[2])(v4, v33);

          long long v148 = 0u;
          long long v149 = 0u;
          long long v146 = 0u;
          long long v147 = 0u;
          uint64_t v107 = v26;
          if (v27) {
            id v35 = objc_getProperty(v27, v34, 8, 1);
          }
          else {
            id v35 = 0;
          }
          id obja = v35;
          uint64_t v36 = [obja countByEnumeratingWithState:&v146 objects:v174 count:16];
          if (v36)
          {
            uint64_t v37 = v36;
            uint64_t v38 = *(void *)v147;
            do
            {
              for (uint64_t m = 0; m != v37; ++m)
              {
                if (*(void *)v147 != v38) {
                  objc_enumerationMutation(obja);
                }
                uint64_t v40 = *(void **)(*((void *)&v146 + 1) + 8 * m);
                uint64_t v41 = objc_msgSend(v40, "hidEventTimestamp", v101);
                ((void (*)(void (**)(void), void *))v4[2])(v4, v41);

                long long v144 = 0u;
                long long v145 = 0u;
                long long v142 = 0u;
                long long v143 = 0u;
                v42 = [v40 steps];
                uint64_t v43 = [v42 countByEnumeratingWithState:&v142 objects:v173 count:16];
                if (v43)
                {
                  uint64_t v44 = v43;
                  uint64_t v45 = *(void *)v143;
                  do
                  {
                    for (uint64_t n = 0; n != v44; ++n)
                    {
                      if (*(void *)v143 != v45) {
                        objc_enumerationMutation(v42);
                      }
                      uint64_t v47 = [*(id *)(*((void *)&v142 + 1) + 8 * n) timestamp];
                      ((void (*)(void (**)(void), void *))v4[2])(v4, v47);
                    }
                    uint64_t v44 = [v42 countByEnumeratingWithState:&v142 objects:v173 count:16];
                  }
                  while (v44);
                }
              }
              uint64_t v37 = [obja countByEnumeratingWithState:&v146 objects:v174 count:16];
            }
            while (v37);
          }

          uint64_t v26 = v107 + 1;
        }
        while (v107 + 1 != v105);
        uint64_t v49 = [v102 countByEnumeratingWithState:&v150 objects:v175 count:16];
        uint64_t v105 = v49;
      }
      while (v49);
    }

    long long v140 = 0u;
    long long v141 = 0u;
    long long v138 = 0u;
    long long v139 = 0u;
    id v50 = *(id *)(v101 + 88);
    uint64_t v51 = [v50 countByEnumeratingWithState:&v138 objects:v172 count:16];
    if (v51)
    {
      uint64_t v52 = v51;
      uint64_t v53 = *(void *)v139;
      do
      {
        for (iuint64_t i = 0; ii != v52; ++ii)
        {
          if (*(void *)v139 != v53) {
            objc_enumerationMutation(v50);
          }
          v55 = *(void **)(*((void *)&v138 + 1) + 8 * ii);
          v56 = objc_msgSend(v55, "startTimestamp", v101);
          ((void (*)(void (**)(void), void *))v4[2])(v4, v56);

          SEL v57 = [v55 endTimestamp];
          ((void (*)(void (**)(void), void *))v4[2])(v4, v57);
        }
        uint64_t v52 = [v50 countByEnumeratingWithState:&v138 objects:v172 count:16];
      }
      while (v52);
    }

    long long v136 = 0u;
    long long v137 = 0u;
    long long v134 = 0u;
    long long v135 = 0u;
    id v58 = *(id *)(v101 + 96);
    uint64_t v59 = [v58 countByEnumeratingWithState:&v134 objects:v171 count:16];
    if (v59)
    {
      uint64_t v60 = v59;
      uint64_t v61 = *(void *)v135;
      do
      {
        for (juint64_t j = 0; jj != v60; ++jj)
        {
          if (*(void *)v135 != v61) {
            objc_enumerationMutation(v58);
          }
          v63 = objc_msgSend(*(id *)(*((void *)&v134 + 1) + 8 * jj), "timestamp", v101);
          ((void (*)(void (**)(void), void *))v4[2])(v4, v63);
        }
        uint64_t v60 = [v58 countByEnumeratingWithState:&v134 objects:v171 count:16];
      }
      while (v60);
    }

    -[SAMountStatusTracker iterateAllTimestamps:](*(void *)(v101 + 400), v4);
    long long v132 = 0u;
    long long v133 = 0u;
    long long v130 = 0u;
    long long v131 = 0u;
    id v64 = *(id *)(v101 + 72);
    uint64_t v65 = [v64 countByEnumeratingWithState:&v130 objects:v170 count:16];
    if (v65)
    {
      uint64_t v66 = v65;
      uint64_t v67 = *(void *)v131;
      do
      {
        for (kuint64_t k = 0; kk != v66; ++kk)
        {
          if (*(void *)v131 != v67) {
            objc_enumerationMutation(v64);
          }
          CFNumberRef v69 = objc_msgSend(*(id *)(*((void *)&v130 + 1) + 8 * kk), "timestamp", v101);
          ((void (*)(void (**)(void), void *))v4[2])(v4, v69);
        }
        uint64_t v66 = [v64 countByEnumeratingWithState:&v130 objects:v170 count:16];
      }
      while (v66);
    }

    long long v128 = 0u;
    long long v129 = 0u;
    long long v126 = 0u;
    long long v127 = 0u;
    id v70 = *(id *)(v101 + 80);
    uint64_t v71 = [v70 countByEnumeratingWithState:&v126 objects:v169 count:16];
    if (v71)
    {
      uint64_t v72 = v71;
      uint64_t v73 = *(void *)v127;
      do
      {
        for (muint64_t m = 0; mm != v72; ++mm)
        {
          if (*(void *)v127 != v73) {
            objc_enumerationMutation(v70);
          }
          char v75 = *(void **)(*((void *)&v126 + 1) + 8 * mm);
          v76 = objc_msgSend(v75, "timestamp", v101);

          if (v76)
          {
            id v77 = [v75 timestamp];
            ((void (*)(void (**)(void), void *))v4[2])(v4, v77);
          }
        }
        uint64_t v72 = [v70 countByEnumeratingWithState:&v126 objects:v169 count:16];
      }
      while (v72);
    }

    if (*(void *)(v101 + 424)) {
      v4[2](v4);
    }
    if (*(void *)(v101 + 432)) {
      v4[2](v4);
    }
    v124[0] = MEMORY[0x1E4F143A8];
    v124[1] = 3221225472;
    v124[2] = __38__SASampleStore_iterateAllTimestamps___block_invoke;
    v124[3] = &unk_1E63F7AA8;
    double v78 = v4;
    id v125 = v78;
    [(id)v101 enumerateTasks:v124];
    long long v122 = 0u;
    long long v123 = 0u;
    long long v120 = 0u;
    long long v121 = 0u;
    id v104 = [(id)v101 models];
    uint64_t v108 = [v104 countByEnumeratingWithState:&v120 objects:v168 count:16];
    if (v108)
    {
      uint64_t v106 = *(void *)v121;
      do
      {
        for (nuint64_t n = 0; nn != v108; ++nn)
        {
          if (*(void *)v121 != v106) {
            objc_enumerationMutation(v104);
          }
          int v80 = *(void **)(*((void *)&v120 + 1) + 8 * nn);
          long long v116 = 0u;
          long long v117 = 0u;
          long long v118 = 0u;
          long long v119 = 0u;
          id objb = v80;
          id v81 = objc_msgSend(v80, "loadedChanges", v101);
          uint64_t v82 = [v81 countByEnumeratingWithState:&v116 objects:v167 count:16];
          if (v82)
          {
            uint64_t v83 = v82;
            uint64_t v84 = *(void *)v117;
            do
            {
              for (uint64_t i1 = 0; i1 != v83; ++i1)
              {
                if (*(void *)v117 != v84) {
                  objc_enumerationMutation(v81);
                }
                long long v86 = *(void **)(*((void *)&v116 + 1) + 8 * i1);
                long long v87 = [v86 timestamp];

                if (v87)
                {
                  long long v88 = [v86 timestamp];
                  ((void (*)(void (**)(void), void *))v78[2])(v78, v88);
                }
                long long v89 = [v86 endTime];

                if (v89)
                {
                  long long v90 = [v86 endTime];
                  ((void (*)(void (**)(void), void *))v78[2])(v78, v90);
                }
              }
              uint64_t v83 = [v81 countByEnumeratingWithState:&v116 objects:v167 count:16];
            }
            while (v83);
          }

          long long v114 = 0u;
          long long v115 = 0u;
          long long v112 = 0u;
          long long v113 = 0u;
          long long v91 = [objb executions];
          uint64_t v92 = [v91 countByEnumeratingWithState:&v112 objects:v166 count:16];
          if (v92)
          {
            uint64_t v93 = v92;
            uint64_t v94 = *(void *)v113;
            do
            {
              for (uint64_t i2 = 0; i2 != v93; ++i2)
              {
                if (*(void *)v113 != v94) {
                  objc_enumerationMutation(v91);
                }
                dispatch_time_t v96 = *(void **)(*((void *)&v112 + 1) + 8 * i2);
                int v97 = [v96 startTime];

                if (v97)
                {
                  v98 = [v96 startTime];
                  ((void (*)(void (**)(void), void *))v78[2])(v78, v98);
                }
                v99 = [v96 endTime];

                if (v99)
                {
                  id v100 = [v96 endTime];
                  ((void (*)(void (**)(void), void *))v78[2])(v78, v100);
                }
              }
              uint64_t v93 = [v91 countByEnumeratingWithState:&v112 objects:v166 count:16];
            }
            while (v93);
          }
        }
        uint64_t v108 = [v104 countByEnumeratingWithState:&v120 objects:v168 count:16];
      }
      while (v108);
    }
  }
}

- (int)gatherHWPageSize
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    if (!result[86])
    {
      size_t v6 = 4;
      id result = (int *)sysctlbyname("hw.pagesize", result + 86, &v6, 0, 0);
      if (result)
      {
        int v1 = *__error();
        int v2 = _sa_logt();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        {
          int v3 = *__error();
          double v4 = __error();
          uint64_t v5 = strerror(*v4);
          *(_DWORD *)statfs buf = 67109378;
          int v8 = v3;
          __int16 v9 = 2080;
          uint64_t v10 = v5;
          _os_log_error_impl(&dword_1BF22B000, v2, OS_LOG_TYPE_ERROR, "Unable to get hw.pagesize: %d %s", buf, 0x12u);
        }

        id result = __error();
        *id result = v1;
      }
    }
  }
  return result;
}

- (int)gatherVMPageSize
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    if (!result[87])
    {
      size_t v6 = 4;
      id result = (int *)sysctlbyname("vm.pagesize", result + 87, &v6, 0, 0);
      if (result)
      {
        int v1 = *__error();
        int v2 = _sa_logt();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        {
          int v3 = *__error();
          double v4 = __error();
          uint64_t v5 = strerror(*v4);
          *(_DWORD *)statfs buf = 67109378;
          int v8 = v3;
          __int16 v9 = 2080;
          uint64_t v10 = v5;
          _os_log_error_impl(&dword_1BF22B000, v2, OS_LOG_TYPE_ERROR, "Unable to get vm.pagesize: %d %s", buf, 0x12u);
        }

        id result = __error();
        *id result = v1;
      }
    }
  }
  return result;
}

uint64_t __28__SASampleStore_postprocess__block_invoke_4(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = [a2 startTimestamp];
  size_t v6 = [v4 startTimestamp];

  uint64_t v7 = [v5 compare:v6];
  return v7;
}

uint64_t __28__SASampleStore_postprocess__block_invoke_5(uint64_t a1, uint64_t a2, void *a3)
{
  return [a3 sortUsingComparator:&__block_literal_global_181];
}

uint64_t __28__SASampleStore_postprocess__block_invoke_6(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = [a2 startTimestamp];
  size_t v6 = [v4 startTimestamp];

  uint64_t v7 = [v5 compare:v6];
  return v7;
}

uint64_t __28__SASampleStore_postprocess__block_invoke_7(uint64_t a1, uint64_t a2)
{
  return -[SATimestamp applyMachTimebase:](a2, *(void *)(*(void *)(a1 + 32) + 184));
}

- (void)task:(void *)a3 exitedAtTimestamp:
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    uint64_t v7 = [v5 exitTimestamp];

    if (v7)
    {
      int v10 = *__error();
      uint64_t v11 = _sa_logt();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        id v12 = [v5 debugDescription];
        uint64_t v13 = [v12 UTF8String];
        uint64_t v14 = [v5 exitTimestamp];
        id v15 = [v14 debugDescription];
        uint64_t v16 = [v15 UTF8String];
        id v17 = [v6 debugDescription];
        *(_DWORD *)statfs buf = 136315650;
        uint64_t v32 = v13;
        __int16 v33 = 2080;
        uint64_t v34 = v16;
        __int16 v35 = 2080;
        uint64_t v36 = [v17 UTF8String];
        _os_log_error_impl(&dword_1BF22B000, v11, OS_LOG_TYPE_ERROR, "%s exited at %s, updating to %s", buf, 0x20u);
      }
      *__error() = v10;
      id v18 = [v5 debugDescription];
      char v19 = [v18 UTF8String];
      uint64_t v20 = [v5 exitTimestamp];
      id v21 = [v20 debugDescription];
      [v21 UTF8String];
      id v22 = [v6 debugDescription];
      [v22 UTF8String];
      _SASetCrashLogMessage(1315, "%s exited at %s, updating to %s", v23, v24, v25, v26, v27, v28, v19);

      _os_crash();
      __break(1u);
    }
    if (v5) {
      objc_setProperty_atomic(v5, v8, v6, 232);
    }
    if (*(void *)(a1 + 360) >= 2uLL)
    {
      __int16 v9 = [v5 threads];
      v29[0] = MEMORY[0x1E4F143A8];
      v29[1] = 3221225472;
      v29[2] = __40__SASampleStore_task_exitedAtTimestamp___block_invoke;
      v29[3] = &unk_1E63F7DA8;
      id v30 = v6;
      [v9 enumerateKeysAndObjectsUsingBlock:v29];
    }
  }
}

void __40__SASampleStore_task_exitedAtTimestamp___block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  self = a3;
  id v4 = [self exitTimestamp];

  id v6 = self;
  if (self && !v4)
  {
    objc_setProperty_atomic(self, v5, *(id *)(a1 + 32), 40);
    id v6 = self;
  }
}

- (void)_backfillPidStartTimestamp:(void *)a1 toPreviousTasksEnumerator:(void *)a2 execTimestampOfNextTask:(void *)a3
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  id v8 = v6;
  uint64_t v9 = [v8 countByEnumeratingWithState:&v25 objects:v29 count:16];
  if (v9)
  {
    uint64_t v11 = v9;
    uint64_t v12 = *(void *)v26;
    do
    {
      uint64_t v13 = 0;
      uint64_t v14 = v7;
      do
      {
        if (*(void *)v26 != v12) {
          objc_enumerationMutation(v8);
        }
        id v15 = *(void **)(*((void *)&v25 + 1) + 8 * v13);
        if (v15) {
          id Property = objc_getProperty(*(id *)(*((void *)&v25 + 1) + 8 * v13), v10, 272, 1);
        }
        else {
          id Property = 0;
        }
        id v17 = Property;

        if (v17) {
          goto LABEL_19;
        }
        uint64_t v18 = objc_msgSend(v15, "exitTimestamp", (void)v25);
        if (!v18) {
          goto LABEL_19;
        }
        char v19 = (void *)v18;
        uint64_t v20 = [v15 exitTimestamp];
        char v21 = [v20 ne:v14];

        if (v21) {
          goto LABEL_19;
        }
        if (v15) {
          objc_setProperty_atomic(v15, v22, v5, 272);
        }
        uint64_t v23 = [v15 execTimestamp];

        if (!v23)
        {
LABEL_19:
          id v7 = v14;
          goto LABEL_20;
        }
        id v7 = [v15 execTimestamp];

        ++v13;
        uint64_t v14 = v7;
      }
      while (v11 != v13);
      uint64_t v24 = [v8 countByEnumeratingWithState:&v25 objects:v29 count:16];
      uint64_t v11 = v24;
    }
    while (v24);
  }
LABEL_20:
}

- (void)addNewImageInfos:(unsigned int)a3 numLoadInfos:(const char *)a4 name:(void *)a5 sharedCache:(uint64_t)a6 architecture:(void *)a7 toTask:
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v13 = a5;
  uint64_t v14 = a7;
  id v15 = [v14 sharedCache];

  if (v14 && v13 && !v15)
  {
    if (v14[72])
    {
      int v17 = *__error();
      uint64_t v18 = _sa_logt();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
      {
        uint64_t v23 = [v13 debugDescription];
        [v14 debugDescription];
        *(_DWORD *)dest = 138412546;
        *(void *)&dest[4] = v23;
        v26 = __int16 v25 = 2112;
        id v22 = (void *)v26;
        _os_log_fault_impl(&dword_1BF22B000, v18, OS_LOG_TYPE_FAULT, "shared cache %@, though task %@ has no shared cache", dest, 0x16u);
      }
      *__error() = v17;
    }
    else
    {
      objc_setProperty_atomic(v14, v16, v13, 256);
    }
  }
  char v19 = [v14 binaryLoadInfos];
  if ([v19 count] < (unint64_t)a3) {
    goto LABEL_10;
  }
  if (!a3) {
    goto LABEL_20;
  }
  if (!v14)
  {
LABEL_10:

LABEL_14:
    if ((*(unsigned char *)(a1 + 408) & 2) != 0)
    {
      char v19 = SAExecutablePath([v14 pid], a4);
    }
    else
    {
      char v19 = 0;
    }
    char v21 = _SABinaryCreateLoadInfoArrayFromDyldImageInfos(a2, a3, v19, 0, 0, 0);
    -[SATask addImageInfos:]((uint64_t)v14, v21);
    if (v14) {
      v14[73] = 1;
    }

LABEL_20:
    if (!v14) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }
  char v20 = v14[73];

  if ((v20 & 1) == 0) {
    goto LABEL_14;
  }
LABEL_21:
  objc_copyStruct(dest, v14 + 288, 8, 1, 0);
  if (!*(void *)dest)
  {
    *(void *)dest = a6;
    objc_copyStruct(v14 + 288, dest, 8, 1, 0);
  }
LABEL_23:
}

- (NSObject)_taskForPid:(uint64_t)a3 uniquePid:(unsigned char *)a4 name:(uint64_t)a5 pidStartTime:(NSObject *)a6 loadInfos:(unsigned int)a7 numLoadInfos:(char)a8 loadInfosIsPartial:(NSObject *)a9 textExecLoadInfos:(unsigned int)a10 numTextExecLoadInfos:(char)a11 textExecLoadInfosIsPartial:(uint64_t)a12 architecture:(void *)a13 timestamp:(void *)a14 sharedCache:(char)a15 needAOTInfo:
{
  char v20 = a9;
  uint64_t v192 = *MEMORY[0x1E4F143B8];
  id v21 = a13;
  id v174 = a14;
  if (a1)
  {
    id newValue = v21;
    if (a4)
    {
      if (*a4) {
        id v21 = a4;
      }
      else {
        id v21 = 0;
      }
    }
    else
    {
      id v21 = 0;
    }
    char v158 = a8;
    if (a3 == -1)
    {
      if (a2 == -1)
      {
        int v78 = *__error();
        uint64_t v26 = _sa_logt();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          if (a7)
          {
            uuidForBytes((uint64_t)&a6[1]);
            a1 = (id)objc_claimAutoreleasedReturnValue();
            char v20 = [a1 UUIDString];
            v79 = (const char *)[v20 UTF8String];
          }
          else
          {
            v79 = "no load info";
          }
          *(_DWORD *)statfs buf = 136315394;
          *(void *)dispatch_time_t v177 = v21;
          *(_WORD *)&v177[8] = 2080;
          *(void *)&v177[10] = v79;
          _os_log_error_impl(&dword_1BF22B000, v26, OS_LOG_TYPE_ERROR, "unknown uniquepid and pid for %s (%s)", buf, 0x16u);
          if (a7)
          {
          }
        }

        *__error() = v78;
        if (a7)
        {
          uint64_t v26 = uuidForBytes((uint64_t)&a6[1]);
          a1 = [v26 UUIDString];
          [a1 UTF8String];
          _SASetCrashLogMessage(1480, "unknown uniquepid and pid for %s (%s)", v86, v87, v88, v89, v90, v91, (char)v21);
        }
        else
        {
          _SASetCrashLogMessage(1480, "unknown uniquepid and pid for %s (%s)", v80, v81, v82, v83, v84, v85, (char)v21);
        }
        _os_crash();
        __break(1u);
        goto LABEL_86;
      }
      uint64_t v39 = (void *)*((void *)a1 + 2);
      uint64_t v40 = [NSNumber numberWithInt:a2];
      uint64_t v24 = [v39 objectForKeyedSubscript:v40];

      if (v24)
      {
        uint64_t v41 = [v24 lastObject];
        uint64_t v26 = v41;
        if (v41)
        {
          if (-[SATask correspondsToPid:name:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:](v41, a2, v21, a6, a7, a9, a10, a12, v174))goto LABEL_30; {
LABEL_24:
          }
          uint64_t v43 = [v26 exitTimestamp];
          if (v43)
          {
          }
          else if (*((void *)a1 + 45) >= 2uLL)
          {
            -[SASampleStore task:exitedAtTimestamp:]((uint64_t)a1, v26, newValue);
          }
          char v44 = 0;
LABEL_48:
          if ((*((unsigned char *)a1 + 408) & 2) != 0)
          {
            uint64_t v60 = SAExecutablePath(a2, (const char *)v21);
            uint64_t v58 = a2;
            uint64_t v59 = (void *)v60;
          }
          else
          {
            uint64_t v58 = a2;
            uint64_t v59 = 0;
          }
          uint64_t v61 = +[SATask taskWithPid:uniquePid:name:mainBinaryPath:pidStartTime:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:]((uint64_t)SATask, v58, a3, (uint64_t)v21, v59, a5, (uint64_t)a6, a7, (uint64_t)a9, a10, a12, v174);
          SEL v57 = v61;
          id v21 = newValue;
          if ((v44 & 1) == 0 && *((void *)a1 + 45) >= 2uLL)
          {
            if (v61)
            {
              objc_setProperty_atomic(v61, v62, newValue, 224);
              id v64 = objc_getProperty(v57, v63, 272, 1);
              if (v64)
              {
                uint64_t v66 = v64;
                id v67 = v26 ? objc_getProperty(v26, v65, 272, 1) : 0;
                id v68 = v67;

                if (!v68)
                {
                  id v70 = objc_getProperty(v57, v69, 272, 1);
                  id v71 = newValue;
                  id v72 = v70;
                  uint64_t v73 = [v24 reverseObjectEnumerator];
                  -[SASampleStore _backfillPidStartTimestamp:toPreviousTasksEnumerator:execTimestampOfNextTask:](v72, v73, v71);
                }
              }
            }
          }
          -[SASampleStore addTask:]((uint64_t)a1, v57);
          uint64_t v74 = *((void *)a1 + 51);
          if ((v74 & 2) == 0) {
            goto LABEL_71;
          }
          if (a15) {
            goto LABEL_69;
          }
          if ((v74 & 0x80) != 0)
          {
            char v75 = [v57 binaryLoadInfos];
            if (![v75 count]
              || (v158 & 1) != 0
              || (a11 & 1) != 0
              || ![v57 pid])
            {

LABEL_69:
              -[SATask gatherLoadInfoFromLiveProcessWithDataGatheringOptions:additionalCSSymbolicatorFlags:]((uint64_t)v57, *((void *)a1 + 51), *((_DWORD *)a1 + 82));
              goto LABEL_70;
            }
            uint64_t v76 = [v57 uniquePid];

            if (!v76) {
              goto LABEL_69;
            }
          }
LABEL_70:
          -[SATask _gatherDataFromLiveProcessIsLate:mainBinaryPath:]((uint64_t)v57, 0, v59);
LABEL_71:

LABEL_72:
          goto LABEL_73;
        }
      }
      else
      {
        uint64_t v26 = 0;
      }
    }
    else
    {
      long long v163 = (void *)a2;
      id v22 = (void *)*((void *)a1 + 1);
      uint64_t v23 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:");
      uint64_t v24 = [v22 objectForKeyedSubscript:v23];

      if (!v24)
      {
        uint64_t v26 = 0;
        char v44 = 1;
        goto LABEL_42;
      }
      __int16 v25 = [v24 lastObject];
      uint64_t v26 = v25;
      if (v163 != -1)
      {
        long long v156 = v24;
        uint64_t v27 = (void *)*((void *)a1 + 2);
        long long v28 = objc_msgSend(NSNumber, "numberWithInt:");
        int v29 = [v27 objectForKeyedSubscript:v28];
        uint64_t v30 = [v29 lastObject];

        if (v30 == v26)
        {
LABEL_18:
          if (v26)
          {
            uint64_t v24 = v156;
            a2 = (uint64_t)v163;
            goto LABEL_29;
          }
          char v44 = 1;
          uint64_t v24 = v156;
LABEL_42:
          a2 = (uint64_t)v163;
          goto LABEL_48;
        }
        if ([v26 pid] == -1)
        {
          if (v26) {
            HIDWORD(v26[9].isa) = v163;
          }
          double v31 = [*((id *)a1 + 2) objectForKeyedSubscript:&unk_1F1A9AEC0];
          char v32 = [v31 containsObject:v26];

          if (v32)
          {
            __int16 v33 = [*((id *)a1 + 2) objectForKeyedSubscript:&unk_1F1A9AEC0];
            [v33 removeObject:v26];

            uint64_t v34 = (void *)*((void *)a1 + 2);
            __int16 v35 = objc_msgSend(NSNumber, "numberWithInt:", -[NSObject pid](v26, "pid"));
            id v36 = [v34 objectForKeyedSubscript:v35];

            if (!v36)
            {
              id v36 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
              uint64_t v37 = (void *)*((void *)a1 + 2);
              uint64_t v38 = objc_msgSend(NSNumber, "numberWithInt:", -[NSObject pid](v26, "pid"));
              [v37 setObject:v36 forKeyedSubscript:v38];
            }
            [v36 addObject:v26];

            goto LABEL_18;
          }
          goto LABEL_89;
        }
LABEL_86:
        int v175 = *__error();
        uint64_t v92 = _sa_logt();
        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
        {
          log = v92;
          uint64_t v93 = (void *)*((void *)a1 + 2);
          v171 = [NSNumber numberWithInt:v163];
          v168 = [v93 objectForKeyedSubscript:v171];
          uint64_t v149 = [v168 count];
          uint64_t v94 = (void *)*((void *)a1 + 2);
          id newValuea = [NSNumber numberWithInt:v163];
          long long v161 = [v94 objectForKeyedSubscript:newValuea];
          long long v159 = [v161 lastObject];
          id v157 = [v159 debugDescription];
          uint64_t v142 = [v157 UTF8String];
          v95 = (void *)*((void *)a1 + 2);
          long long v152 = [NSNumber numberWithInt:v163];
          long long v150 = [v95 objectForKeyedSubscript:v152];
          long long v147 = [v150 lastObject];
          uint64_t v139 = [v147 uniquePid];
          dispatch_time_t v96 = (void *)*((void *)a1 + 2);
          long long v145 = [NSNumber numberWithInt:v163];
          long long v143 = [v96 objectForKeyedSubscript:v145];
          long long v141 = [v143 lastObject];
          long long v140 = [v141 mainBinaryLoadInfo];
          id v97 = [v140 debugDescription];
          uint64_t v138 = [v97 UTF8String];
          uint64_t v98 = [v156 count];
          id v99 = [v26 debugDescription];
          uint64_t v100 = [v99 UTF8String];
          uint64_t v101 = [v26 uniquePid];
          id v102 = [v26 mainBinaryLoadInfo];
          id v103 = [v102 debugDescription];
          uint64_t v104 = [v103 UTF8String];
          *(_DWORD *)statfs buf = 67111426;
          *(_DWORD *)dispatch_time_t v177 = v163;
          *(_WORD *)&v177[4] = 2048;
          *(void *)&v177[6] = v149;
          *(_WORD *)&v177[14] = 2080;
          *(void *)&v177[16] = v142;
          __int16 v178 = 2048;
          uint64_t v179 = v139;
          __int16 v180 = 2080;
          uint64_t v181 = v138;
          __int16 v182 = 2048;
          uint64_t v183 = a3;
          __int16 v184 = 2048;
          uint64_t v185 = v98;
          uint64_t v92 = log;
          __int16 v186 = 2080;
          uint64_t v187 = v100;
          __int16 v188 = 2048;
          uint64_t v189 = v101;
          __int16 v190 = 2080;
          uint64_t v191 = v104;
          _os_log_error_impl(&dword_1BF22B000, log, OS_LOG_TYPE_ERROR, "_tasksByPid[%d] (count %lu) .lastObject %s (unique pid %llu, main binary %s) != tasksWithUniquePid[%llu] (count %lu) .lastObject %s (unique pid %llu, main binary %s)", buf, 0x62u);
        }
        *__error() = v175;
        uint64_t v105 = (void *)*((void *)a1 + 2);
        id v21 = v163;
        os_log_t loga = [NSNumber numberWithInt:v163];
        id v174 = [v105 objectForKeyedSubscript:loga];
        [v174 count];
        uint64_t v106 = (void *)*((void *)a1 + 2);
        v172 = [NSNumber numberWithInt:v163];
        v169 = [v106 objectForKeyedSubscript:v172];
        id newValueb = [v169 lastObject];
        id v162 = [newValueb debugDescription];
        [v162 UTF8String];
        uint64_t v107 = (void *)*((void *)a1 + 2);
        long long v160 = [NSNumber numberWithInt:v163];
        long long v153 = [v107 objectForKeyedSubscript:v160];
        long long v151 = [v153 lastObject];
        [v151 uniquePid];
        uint64_t v108 = (void *)*((void *)a1 + 2);
        long long v148 = [NSNumber numberWithInt:v163];
        long long v146 = [v108 objectForKeyedSubscript:v148];
        long long v144 = [v146 lastObject];
        v109 = [v144 mainBinaryLoadInfo];
        id v110 = [v109 debugDescription];
        [v110 UTF8String];
        [v156 count];
        id v111 = [v26 debugDescription];
        a1 = (id)[v111 UTF8String];
        [v26 uniquePid];
        uint64_t v26 = [v26 mainBinaryLoadInfo];
        id v112 = [v26 debugDescription];
        [v112 UTF8String];
        _SASetCrashLogMessage(1447, "_tasksByPid[%d] (count %lu) .lastObject %s (unique pid %llu, main binary %s) != tasksWithUniquePid[%llu] (count %lu) .lastObject %s (unique pid %llu, main binary %s)", v113, v114, v115, v116, v117, v118, (char)v163);

        _os_crash();
        __break(1u);
LABEL_89:
        int v119 = *__error();
        long long v120 = _sa_logt();
        if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
        {
          long long v121 = (void *)*((void *)a1 + 2);
          long long v122 = [NSNumber numberWithInt:v163];
          long long v123 = [v121 objectForKeyedSubscript:v122];
          uint64_t v124 = [v123 count];
          id v125 = [v26 debugDescription];
          uint64_t v126 = [v125 UTF8String];
          *(_DWORD *)statfs buf = 134218242;
          *(void *)dispatch_time_t v177 = v124;
          *(_WORD *)&v177[8] = 2080;
          *(void *)&v177[10] = v126;
          _os_log_error_impl(&dword_1BF22B000, v120, OS_LOG_TYPE_ERROR, "_tasksByPid[-1] (count %lu) does not contain task %s that didn't have pid until now", buf, 0x16u);
        }
        *__error() = v119;
        long long v127 = (void *)*((void *)a1 + 2);
        long long v128 = [NSNumber numberWithInt:v163];
        long long v129 = [v127 objectForKeyedSubscript:v128];
        char v130 = [v129 count];
        id v131 = [v26 debugDescription];
        [v131 UTF8String];
        _SASetCrashLogMessage(1458, "_tasksByPid[-1] (count %lu) does not contain task %s that didn't have pid until now", v132, v133, v134, v135, v136, v137, v130);

        _os_crash();
        __break(1u);
        goto LABEL_92;
      }
      if (v25)
      {
        a2 = [v25 pid];
LABEL_29:
        if (-[SATask correspondsToUniquePid:name:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:]((uint64_t)v26, a3, v21, a6, a7, a9, a10, a12, v174))
        {
LABEL_30:
          if (a5)
          {
            unint64_t v45 = a5;
            id v46 = objc_getProperty(v26, v42, 272, 1);

            if (!v46)
            {
              id v47 = v24;
              v48 = [v47 reverseObjectEnumerator];
              uint64_t v49 = [v48 nextObject];
              if (v49)
              {
                id v50 = v24;
                uint64_t v51 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:(double)v45 - *MEMORY[0x1E4F1CF78]];
                objc_setProperty_atomic(v49, v52, v51, 272);
                uint64_t v53 = [v49 execTimestamp];

                if (v53)
                {
                  uint64_t v54 = [v49 execTimestamp];
                  -[SASampleStore _backfillPidStartTimestamp:toPreviousTasksEnumerator:execTimestampOfNextTask:](v51, v48, v54);
                }
                uint64_t v24 = v50;
              }
            }
          }
          -[SASampleStore addNewImageInfos:numLoadInfos:name:sharedCache:architecture:toTask:]((uint64_t)a1, (uint64_t)a6, a7, (const char *)v21, v174, a12, v26);
          v55 = [v26 exitTimestamp];

          id v21 = newValue;
          if (v55) {
            objc_setProperty_atomic(v26, v56, newValue, 232);
          }
          uint64_t v26 = v26;
          SEL v57 = v26;
          goto LABEL_72;
        }
        goto LABEL_24;
      }
      a2 = 0xFFFFFFFFLL;
    }
    char v44 = 1;
    goto LABEL_48;
  }
LABEL_92:
  SEL v57 = 0;
LABEL_73:

  return v57;
}

- (id)taskForKCDataTask:(NSObject *)a3 loadInfos:(unsigned int)a4 numLoadInfos:(char)a5 loadInfosIsPartial:(NSObject *)a6 textExecLoadInfos:(unsigned int)a7 numTextExecLoadInfos:(char)a8 textExecLoadInfosIsPartial:(uint64_t)a9 architecture:(void *)a10 timestamp:(void *)a11 sharedCache:(char)a12 needAOTInfo:
{
  uint64_t v12 = -[SASampleStore _taskForPid:uniquePid:name:pidStartTime:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:](a1, *(unsigned int *)(a2 + 84), *(void *)a2, (unsigned char *)(a2 + 88), *(void *)(a2 + 32), a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  return v12;
}

- (id)taskForKCDataDeltaTask:(NSObject *)a3 loadInfos:(unsigned int)a4 numLoadInfos:(char)a5 loadInfosIsPartial:(NSObject *)a6 textExecLoadInfos:(unsigned int)a7 numTextExecLoadInfos:(char)a8 textExecLoadInfosIsPartial:(void *)a9 timestamp:(void *)a10 sharedCache:(char)a11 needAOTInfo:
{
  uint64_t v11 = -[SASampleStore _taskForPid:uniquePid:name:pidStartTime:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:](a1, 0xFFFFFFFFLL, a2, 0, 0, a3, a4, a5, a6, a7, a8, 0, a9, a10, a11);
  return v11;
}

- (id)taskForKCDataTransitioningTask:(void *)a1 loadInfos:(uint64_t)a2 numLoadInfos:(NSObject *)a3 loadInfosIsPartial:(unsigned int)a4 textExecLoadInfos:(char)a5 numTextExecLoadInfos:(NSObject *)a6 textExecLoadInfosIsPartial:(unsigned int)a7 architecture:(char)a8 timestamp:(void *)a9 sharedCache:(void *)a10 needAOTInfo:(char)a11
{
  uint64_t v11 = -[SASampleStore _taskForPid:uniquePid:name:pidStartTime:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:](a1, *(unsigned int *)(a2 + 24), *(void *)a2, (unsigned char *)(a2 + 28), 0, a3, a4, a5, a6, a7, a8, 0, a9, a10, a11);
  return v11;
}

- (id)taskForMicrostackshotTask:(char *)a3 taskName:(NSObject *)a4 loadInfos:(unsigned int)a5 numLoadInfos:(void *)a6 sharedCache:(int)a7 loadInfosIsPartial:(void *)a8 timestamp:(uint64_t)a9 architecture:(char)a10 needAOTInfo:(char)a11 isFromCurrentBoot:
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  id v18 = a6;
  id v19 = a8;
  if (*(void *)(a2 + 8) == -1)
  {
    int v72 = a7;
    double v31 = a4;
    unsigned int v32 = a5;
    id v33 = v19;
    uint64_t v34 = *(void **)(a1 + 16);
    __int16 v35 = [NSNumber numberWithInt:*(unsigned int *)(a2 + 4)];
    id v22 = [v34 objectForKeyedSubscript:v35];

    if (v22)
    {
      uint64_t v36 = [v22 lastObject];
      id v24 = (id)v36;
      id v19 = v33;
      if (v36)
      {
        a5 = v32;
        if (-[SATask correspondsToPid:name:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:](v36, *(_DWORD *)(a2 + 4), a3, v31, v32, 0, 0, a9, v18))
        {
          -[SASampleStore addNewImageInfos:numLoadInfos:name:sharedCache:architecture:toTask:](a1, (uint64_t)v31, v32, a3, v18, a9, v24);
          id v24 = v24;
          uint64_t v30 = v24;
          goto LABEL_34;
        }
        uint64_t v37 = [v24 exitTimestamp];
        a4 = v31;
        a7 = v72;
        if (v37) {
          goto LABEL_19;
        }
LABEL_17:
        uint64_t v38 = *(void *)(a1 + 360);
        if (!v38) {
          goto LABEL_20;
        }
        if (v38 != 1)
        {
          -[SASampleStore task:exitedAtTimestamp:](a1, v24, v19);
LABEL_20:

          if ((*(unsigned char *)(a1 + 408) & 2) != 0)
          {
            id v22 = SAExecutablePath(*(_DWORD *)(a2 + 4), a3);
          }
          else
          {
            id v22 = 0;
          }
          uint64_t v30 = +[SATask taskWithPid:uniquePid:name:mainBinaryPath:pidStartTime:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:]((uint64_t)SATask, *(unsigned int *)(a2 + 4), *(void *)(a2 + 8), (uint64_t)a3, v22, 0, (uint64_t)a4, a5, 0, 0, a9, v18);
          -[SASampleStore addTask:](a1, v30);
          uint64_t v39 = *(void *)(a1 + 408);
          if ((v39 & 2) == 0 || !a11) {
            goto LABEL_34;
          }
          id v40 = v19;
          if (a10) {
            goto LABEL_32;
          }
          if ((v39 & 0x80) != 0)
          {
            uint64_t v41 = [v30 binaryLoadInfos];
            if (![v41 count] || a7)
            {

LABEL_32:
              -[SATask gatherLoadInfoFromLiveProcessWithDataGatheringOptions:additionalCSSymbolicatorFlags:]((uint64_t)v30, *(void *)(a1 + 408), *(_DWORD *)(a1 + 328));
              goto LABEL_33;
            }
            int v42 = [v30 pid];

            if (!v42) {
              goto LABEL_32;
            }
          }
LABEL_33:
          -[SATask _gatherDataFromLiveProcessIsLate:mainBinaryPath:]((uint64_t)v30, 0, v22);
          id v19 = v40;
          goto LABEL_34;
        }
LABEL_19:

        goto LABEL_20;
      }
    }
    else
    {
      id v24 = 0;
      id v19 = v33;
    }
    a5 = v32;
    a4 = v31;
    a7 = v72;
    goto LABEL_20;
  }
  char v20 = *(void **)(a1 + 8);
  id v21 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:");
  id v22 = [v20 objectForKeyedSubscript:v21];

  if (!v22)
  {
    id v24 = 0;
    goto LABEL_20;
  }
  uint64_t v23 = [v22 lastObject];
  id v24 = (id)v23;
  if (!v23) {
    goto LABEL_20;
  }
  if (!-[SATask correspondsToUniquePid:name:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:architecture:sharedCache:](v23, *(void *)(a2 + 8), a3, a4, a5, 0, 0, a9, v18))
  {
    uint64_t v37 = [v24 exitTimestamp];
    if (v37) {
      goto LABEL_19;
    }
    goto LABEL_17;
  }
  uint64_t v71 = (uint64_t)a4;
  unsigned int v74 = a5;
  id v76 = v19;
  __int16 v25 = *(void **)(a1 + 16);
  uint64_t v26 = [NSNumber numberWithInt:*(unsigned int *)(a2 + 4)];
  uint64_t v27 = [v25 objectForKeyedSubscript:v26];
  long long v28 = [v27 lastObject];
  int v29 = [v22 lastObject];

  if (v28 != v29)
  {
    int v77 = *__error();
    log = _sa_logt();
    if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
    {
      char v44 = *(void **)(a1 + 16);
      char v75 = [NSNumber numberWithInt:*(unsigned int *)(a2 + 4)];
      uint64_t v73 = [v44 objectForKeyedSubscript:v75];
      uint64_t v69 = [v73 count];
      unint64_t v45 = *(void **)(a1 + 16);
      id v70 = [NSNumber numberWithInt:*(unsigned int *)(a2 + 4)];
      id v46 = [v45 objectForKeyedSubscript:v70];
      id v47 = [v46 lastObject];
      id v48 = [v47 debugDescription];
      uint64_t v49 = [v48 UTF8String];
      uint64_t v50 = [v22 count];
      uint64_t v51 = [v22 lastObject];
      id v52 = [v51 debugDescription];
      *(_DWORD *)statfs buf = 134218754;
      uint64_t v81 = v69;
      __int16 v82 = 2080;
      uint64_t v83 = v49;
      __int16 v84 = 2048;
      uint64_t v85 = v50;
      __int16 v86 = 2080;
      uint64_t v87 = [v52 UTF8String];
      _os_log_error_impl(&dword_1BF22B000, log, OS_LOG_TYPE_ERROR, "_tasksByPid[@(task_snap->pid)] (count %lu) .lastObject %s != tasksWithUniquePid (count %lu) .lastObject %s", buf, 0x2Au);
    }
    *__error() = v77;
    uint64_t v53 = *(void **)(a1 + 16);
    os_log_t loga = [NSNumber numberWithInt:*(unsigned int *)(a2 + 4)];
    uint64_t v54 = [v53 objectForKeyedSubscript:loga];
    char v55 = [v54 count];
    v56 = *(void **)(a1 + 16);
    SEL v57 = [NSNumber numberWithInt:*(unsigned int *)(a2 + 4)];
    uint64_t v58 = [v56 objectForKeyedSubscript:v57];
    uint64_t v59 = [v58 lastObject];
    id v60 = [v59 debugDescription];
    [v60 UTF8String];
    [v22 count];
    uint64_t v61 = [v22 lastObject];
    id v62 = [v61 debugDescription];
    [v62 UTF8String];
    _SASetCrashLogMessage(1663, "_tasksByPid[@(task_snap->pid)] (count %lu) .lastObject %s != tasksWithUniquePid (count %lu) .lastObject %s", v63, v64, v65, v66, v67, v68, v55);

    _os_crash();
    __break(1u);
  }
  -[SASampleStore addNewImageInfos:numLoadInfos:name:sharedCache:architecture:toTask:](a1, v71, v74, a3, v18, a9, v24);
  id v24 = v24;
  uint64_t v30 = v24;
  id v19 = v76;
LABEL_34:

  return v30;
}

- (id)_lastTaskOnOrBeforeTimestamp:(void *)a3 inTasks:
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    id v8 = objc_msgSend(v6, "reverseObjectEnumerator", 0);
    id v9 = (id)[v8 countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v18;
      while (2)
      {
        for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v18 != v10) {
            objc_enumerationMutation(v8);
          }
          uint64_t v12 = *(void **)(*((void *)&v17 + 1) + 8 * i);
          id v13 = [v12 startTimestamp];
          uint64_t v14 = v13;
          if (v13)
          {
            if (![v13 gt:v5]) {
              goto LABEL_14;
            }
          }
          else
          {
            id v15 = [v7 firstObject];

            if (v12 == v15)
            {
LABEL_14:
              id v9 = v12;

              goto LABEL_15;
            }
          }
        }
        id v9 = (id)[v8 countByEnumeratingWithState:&v17 objects:v21 count:16];
        if (v9) {
          continue;
        }
        break;
      }
    }
LABEL_15:
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

- (void)firstTaskWithPid:(void *)a1
{
  if (a1)
  {
    a1 = -[SASampleStore firstTaskWithPid:onOrAfterTimestamp:](a1, a2, 0);
    uint64_t v2 = vars8;
  }
  return a1;
}

- (id)_firstTaskOnOrAfterTimestamp:(void *)a1 inTasks:(void *)a2
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v4 = a2;
  id v5 = (id)[v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v14;
    while (2)
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v6) {
          objc_enumerationMutation(v4);
        }
        id v8 = *(void **)(*((void *)&v13 + 1) + 8 * i);
        id v9 = objc_msgSend(v8, "endTimestamp", (void)v13);
        uint64_t v10 = v9;
        if (v9)
        {
          if (![v9 lt:v3]) {
            goto LABEL_13;
          }
        }
        else
        {
          uint64_t v11 = [v4 lastObject];

          if (v8 == v11)
          {
LABEL_13:
            id v5 = v8;

            goto LABEL_14;
          }
        }
      }
      id v5 = (id)[v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
LABEL_14:

  return v5;
}

- (void)taskWithUniquePid:(void *)a3 atTimestamp:
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  if (a1)
  {
    uint64_t v6 = (void *)a1[1];
    id v7 = [NSNumber numberWithUnsignedLongLong:a2];
    id v8 = [v6 objectForKeyedSubscript:v7];

    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    id v9 = v8;
    a1 = (void *)[v9 countByEnumeratingWithState:&v14 objects:v18 count:16];
    if (a1)
    {
      uint64_t v10 = *(void *)v15;
      while (2)
      {
        uint64_t v11 = 0;
        do
        {
          if (*(void *)v15 != v10) {
            objc_enumerationMutation(v9);
          }
          uint64_t v12 = *(void **)(*((void *)&v14 + 1) + 8 * (void)v11);
          if (-[SATask isAliveAtTimestamp:](v12, v5))
          {
            a1 = v12;
            goto LABEL_12;
          }
          uint64_t v11 = (void *)((char *)v11 + 1);
        }
        while (a1 != v11);
        a1 = (void *)[v9 countByEnumeratingWithState:&v14 objects:v18 count:16];
        if (a1) {
          continue;
        }
        break;
      }
    }
LABEL_12:
  }
  return a1;
}

void __47__SASampleStore_taskWithPid_orTid_atTimestamp___block_invoke(uint64_t a1, void *a2, unsigned char *a3)
{
  id v11 = a2;
  uint64_t v6 = [v11 threads];
  id v7 = [NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 48)];
  uint64_t v8 = [v6 objectForKeyedSubscript:v7];
  if (v8)
  {
    id v9 = (void *)v8;
    unsigned int v10 = -[SATask isAliveAtTimestamp:](v11, *(void **)(a1 + 32));

    if (v10)
    {
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
      *a3 = 1;
    }
  }
  else
  {
  }
}

void __39__SASampleStore_lastTaskWithPid_orTid___block_invoke(uint64_t a1, void *a2, unsigned char *a3)
{
  id v11 = a2;
  uint64_t v6 = [v11 threads];
  id v7 = [NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 40)];
  uint64_t v8 = [v6 objectForKeyedSubscript:v7];

  id v9 = (id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  if (v8)
  {
    objc_storeStrong(v9, a2);
  }
  else if (*v9)
  {
    int v10 = [v11 pid];
    if (v10 != [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) pid]) {
      *a3 = 1;
    }
  }
}

- (id)initForFileParsing
{
  id result = [(SASampleStore *)self init];
  if (result)
  {
    *((unsigned char *)result + 317) = 0;
    *((void *)result + 51) = 1652;
  }
  return result;
}

- (void)setSampleOnlyMainThreads:(BOOL)a3
{
  if (self->_sampleOnlyMainThreads == a3) {
    return;
  }
  BOOL v3 = a3;
  if (![(NSMutableArray *)self->_sampleTimestamps count])
  {
LABEL_8:
    self->_sampleOnlyMainThreads = v3;
    return;
  }
  if (!v3)
  {
    self->_nextSampleIsFirstSamplingAllThreads = 1;
    goto LABEL_8;
  }
  int v5 = *__error();
  uint64_t v6 = _sa_logt();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)id v7 = 0;
    _os_log_error_impl(&dword_1BF22B000, v6, OS_LOG_TYPE_ERROR, "Cannot set sampleOnlyMainThreads to YES after parsing any data", v7, 2u);
  }

  *__error() = v5;
}

- (BOOL)sampleOnlyMainThreads
{
  return self->_sampleOnlyMainThreads;
}

- (void)setStackshotsOnlyIncludeSpecificProcesses:(BOOL)a3
{
  if (self->_stackshotsOnlyIncludeSpecificProcesses == a3) {
    return;
  }
  BOOL v3 = a3;
  if (![(NSMutableArray *)self->_sampleTimestamps count])
  {
LABEL_8:
    self->_stackshotsOnlyIncludeSpecificProcesses = v3;
    return;
  }
  if (!v3)
  {
    self->_nextSampleIsFirstSamplingAllProcesses = 1;
    goto LABEL_8;
  }
  int v5 = *__error();
  uint64_t v6 = _sa_logt();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)id v7 = 0;
    _os_log_error_impl(&dword_1BF22B000, v6, OS_LOG_TYPE_ERROR, "Cannot set stackshotsOnlyIncludeSpecificProcesses to YES after parsing any data", v7, 2u);
  }

  *__error() = v5;
}

- (BOOL)stackshotsOnlyIncludeSpecificProcesses
{
  return self->_stackshotsOnlyIncludeSpecificProcesses;
}

- (void)dealloc
{
  [(SABinaryLocator *)self->_binaryLocator done];
  v3.receiver = self;
  v3.super_class = (Class)SASampleStore;
  [(SASampleStore *)&v3 dealloc];
}

- (unint64_t)indexOfFirstSampleOnOrAfterTimestamp:(id)a3
{
  id v4 = a3;
  unint64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
  if ([(NSMutableArray *)self->_sampleTimestamps count])
  {
    unint64_t v6 = -[NSMutableArray indexOfObject:inSortedRange:options:usingComparator:](self->_sampleTimestamps, "indexOfObject:inSortedRange:options:usingComparator:", v4, 0, [(NSMutableArray *)self->_sampleTimestamps count], 1280, &__block_literal_global_204);
    if (v6 < [(NSMutableArray *)self->_sampleTimestamps count]) {
      unint64_t v5 = v6;
    }
  }

  return v5;
}

uint64_t __54__SASampleStore_indexOfFirstSampleOnOrAfterTimestamp___block_invoke(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "compare:");
}

- (unint64_t)indexOfLastSampleOnOrBeforeTimestamp:(id)a3
{
  id v4 = a3;
  unint64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
  if ([(NSMutableArray *)self->_sampleTimestamps count])
  {
    uint64_t v6 = -[NSMutableArray indexOfObject:inSortedRange:options:usingComparator:](self->_sampleTimestamps, "indexOfObject:inSortedRange:options:usingComparator:", v4, 0, [(NSMutableArray *)self->_sampleTimestamps count], 1536, &__block_literal_global_206);
    if (v6) {
      unint64_t v5 = v6 - 1;
    }
  }

  return v5;
}

uint64_t __54__SASampleStore_indexOfLastSampleOnOrBeforeTimestamp___block_invoke(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "compare:");
}

- (void)exclaveWithIdentifier:(uint64_t)a1
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    id v4 = *(id *)(a1 + 120);
    uint64_t v5 = [v4 countByEnumeratingWithState:&v15 objects:v19 count:16];
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)v16;
      while (2)
      {
        for (uint64_t i = 0; i != v6; ++i)
        {
          if (*(void *)v16 != v7) {
            objc_enumerationMutation(v4);
          }
          id v9 = *(void **)(*((void *)&v15 + 1) + 8 * i);
          if (objc_msgSend(v9, "identifier", (void)v15) == a2)
          {
            int v10 = v9;

            goto LABEL_14;
          }
        }
        uint64_t v6 = [v4 countByEnumeratingWithState:&v15 objects:v19 count:16];
        if (v6) {
          continue;
        }
        break;
      }
    }

    int v10 = -[SAExclave initWithIdentifier:]([SAExclave alloc], a2);
    id v11 = *(void **)(a1 + 120);
    if (!v11)
    {
      id v12 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      long long v13 = *(void **)(a1 + 120);
      *(void *)(a1 + 120) = v12;

      id v11 = *(void **)(a1 + 120);
    }
    objc_msgSend(v11, "addObject:", v10, (void)v15);
  }
  else
  {
    int v10 = 0;
  }
LABEL_14:
  return v10;
}

- (uint64_t)parseKCDataExclavesContainer:(void *)a3 exclaveInfo:(uint64_t)a4 primaryDataIsKPerf:
{
  uint64_t v346 = *MEMORY[0x1E4F143B8];
  id v293 = a3;
  int cache = (int)a2->isa->cache;
  if (cache != 2377)
  {
    int v242 = *__error();
    int32_t v243 = _sa_logt();
    if (os_log_type_enabled(v243, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = cache;
      _os_log_error_impl(&dword_1BF22B000, v243, OS_LOG_TYPE_ERROR, "bad container type %u", buf, 8u);
    }

    *__error() = v242;
    _SASetCrashLogMessage(5782, "bad container type %u", v244, v245, v246, v247, v248, v249, cache);
    _os_crash();
    __break(1u);
LABEL_431:
    int v250 = *__error();
    int v251 = _sa_logt();
    if (os_log_type_enabled(v251, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = v314;
      *(_DWORD *)&uint8_t buf[4] = cache;
      _os_log_error_impl(&dword_1BF22B000, v251, OS_LOG_TYPE_ERROR, "bad container type %u", buf, 8u);
    }

    *__error() = v250;
    _SASetCrashLogMessage(6224, "bad container type %u", v252, v253, v254, v255, v256, v257, cache);
    _os_crash();
    __break(1u);
    goto LABEL_434;
  }
  uint64_t v299 = a1;
  superclass = a2->isa->superclass;
  unint64_t v8 = 0x1E4F1C000uLL;
  id v300 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  id v298 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  id v9 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  id v10 = v9;
  id v11 = a2->superclass;
  id v12 = (char *)a2->isa + HIDWORD(a2->isa->isa);
  long long v13 = (__objc2_class *)(v12 + 16);
  long long v14 = v12 + 32;
  a2->isa = v13;
  long long v15 = &OBJC_INSTANCE_METHODS_SATimeRangeOfSamples;
  id v297 = v9;
  if (v14 > (char *)v11) {
    goto LABEL_3;
  }
LABEL_89:
  int v314 = 67109120;
  __objc2_meth_list v85 = v15[204];
  while (2)
  {
    if (&v14[HIDWORD(v13->isa)] > (char *)v11 || LODWORD(v13->isa) == -242132755)
    {
LABEL_3:
      id v315 = objc_alloc_init(*(Class *)(v8 + 2656));
      long long v333 = 0u;
      long long v334 = 0u;
      long long v335 = 0u;
      long long v336 = 0u;
      obuint64_t j = [v10 allValues];
      uint64_t v289 = [obj countByEnumeratingWithState:&v333 objects:v339 count:16];
      if (!v289) {
        goto LABEL_85;
      }
      uint64_t v17 = *(void *)v334;
      superclass = (__objc2_class *)v323;
      uint64_t v287 = a4 << 63 >> 63;
      __objc2_meth_list v18 = v15[204];
      uint64_t v285 = *(void *)v334;
LABEL_5:
      uint64_t v19 = 0;
      unint64_t v20 = 0x1E4F28000uLL;
LABEL_6:
      if (*(void *)v334 != v17)
      {
        uint64_t v21 = v19;
        objc_enumerationMutation(obj);
        uint64_t v19 = v21;
      }
      uint64_t v291 = v19;
      id Property = *(void ***)(*((void *)&v333 + 1) + 8 * v19);
      long long v329 = 0u;
      long long v330 = 0u;
      long long v331 = 0u;
      long long v332 = 0u;
      id v283 = Property;
      if (Property) {
        id Property = (void **)objc_getProperty(Property, v16, 16, 1);
      }
      uint64_t v23 = Property;
      uint64_t v313 = [v23 countByEnumeratingWithState:&v329 objects:v338 count:16];
      if (!v313)
      {
LABEL_82:

        goto LABEL_83;
      }
      context = 0;
      uint64_t v301 = v23;
      uint64_t v303 = *(void *)v330;
LABEL_12:
      uint64_t v24 = 0;
LABEL_13:
      if (*(void *)v330 != v303) {
        objc_enumerationMutation(v23);
      }
      a2 = *(__objc2_class **)(*((void *)&v329 + 1) + 8 * v24);
      isa = a2->superclass->isa;
      uint64_t v26 = [*(id *)(v20 + 3792) numberWithUnsignedLongLong:isa];
      id v10 = [v315 objectForKeyedSubscript:v26];

      if (!v10)
      {
        uint64_t v27 = [*(id *)(v20 + 3792) numberWithUnsignedLongLong:isa];
        long long v28 = [v300 objectForKeyedSubscript:v27];

        if (v28)
        {
          v316 = a2;
          uint64_t v29 = v24;
          uint64_t v30 = [*(id *)(v20 + 3792) numberWithUnsignedLongLong:v28[1][2]];
          double v31 = [v298 objectForKeyedSubscript:v30];

          unsigned int v32 = v28;
          id v33 = v31;
          memset(v343, 0, sizeof(v343));
          long long v344 = 0u;
          long long v345 = 0u;
          id v34 = *(id *)(v299 + 120);
          uint64_t v35 = [v34 countByEnumeratingWithState:v343 objects:buf count:16];
          if (!v35) {
            goto LABEL_25;
          }
          uint64_t v36 = v35;
          uint64_t v37 = **(void **)&v343[16];
          do
          {
            for (uint64_t i = 0; i != v36; ++i)
            {
              if (**(void **)&v343[16] != v37) {
                objc_enumerationMutation(v34);
              }
              uint64_t v39 = *(void **)(*(void *)&v343[8] + 8 * i);
              if ([v39 identifier] == *v28[1])
              {
                -[SAExclave fillInName:textLayout:]((uint64_t)v39, v32[2], v33);
                id v10 = v39;
                goto LABEL_30;
              }
            }
            uint64_t v36 = [v34 countByEnumeratingWithState:v343 objects:buf count:16];
          }
          while (v36);
LABEL_25:

          id v10 = -[SAExclave initWithKCData:name:textLayout:]([SAExclave alloc], v28[1], v32[2], v33);
          id v40 = *(void **)(v299 + 120);
          if (!v40)
          {
            id v41 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
            int v42 = *(void **)(v299 + 120);
            *(void *)(v299 + 120) = v41;

            id v40 = *(void **)(v299 + 120);
          }
          [v40 addObject:v10];
          uint64_t v43 = -[SASampleStore lastTaskWithPid:]((void *)v299, 0);
          if (v43)
          {
            id v34 = (id)v43;
          }
          else
          {
            +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, 0, v287, 0, 0);
            id v34 = (id)objc_claimAutoreleasedReturnValue();
            -[SASampleStore addTask:](v299, v34);
          }
LABEL_30:

          uint64_t v23 = v301;
          uint64_t v24 = v29;
          unint64_t v20 = 0x1E4F28000;
          a2 = v316;
        }
        else
        {
          id v10 = [MEMORY[0x1E4F1CA98] null];
          int v44 = *__error();
          unint64_t v45 = _sa_logt();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)statfs buf = 134217984;
            *(void *)&uint8_t buf[4] = isa;
            _os_log_error_impl(&dword_1BF22B000, v45, OS_LOG_TYPE_ERROR, "No exclave address space %llu in stackshot", buf, 0xCu);
          }

          *__error() = v44;
        }
        id v46 = [*(id *)(v20 + 3792) numberWithUnsignedLongLong:isa];
        [v315 setObject:v10 forKeyedSubscript:v46];

        if (!v10) {
          goto LABEL_74;
        }
      }
      id v47 = [MEMORY[0x1E4F1CA98] null];

      if (v10 == v47) {
        goto LABEL_74;
      }
      uint64_t v306 = v24;
      long long v327 = 0u;
      long long v328 = 0u;
      long long v325 = 0u;
      long long v326 = 0u;
      v317 = a2;
      id v49 = objc_getProperty(a2, v48, 16, 1);
      uint64_t v50 = [v49 countByEnumeratingWithState:&v325 objects:v337 count:16];
      if (!v50)
      {
        id v52 = 0;
        goto LABEL_68;
      }
      uint64_t v51 = v50;
      id v52 = 0;
      unint64_t v8 = *(void *)v326;
LABEL_38:
      uint64_t v53 = 0;
      while (1)
      {
        a4 = (uint64_t)v52;
        if (*(void *)v326 != v8) {
          objc_enumerationMutation(v49);
        }
        long long v15 = (__objc2_meth_list *)[*(id *)(*((void *)&v325 + 1) + 8 * v53) unsignedLongLongValue];
        if (!v52) {
          break;
        }
        char v55 = v52[1].isa;
        if (!v55) {
          goto LABEL_53;
        }
        v56 = v55;
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          v324[0] = MEMORY[0x1E4F143A8];
          v324[1] = v18;
          v324[2] = __77__SASampleStore_parseKCDataExclavesContainer_exclaveInfo_primaryDataIsKPerf___block_invoke;
          v324[3] = &__block_descriptor_40_e21_B24__0__SAFrame_8_B16l;
          v324[4] = v15;
          SEL v57 = v324;
          uint64_t v58 = v56;
LABEL_46:
          a2 = [(__objc2_class *)v58 objectsPassingTest:v57];
          id v52 = [(__objc2_class *)a2 anyObject];
          goto LABEL_52;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          int v75 = *__error();
          id v76 = _sa_logt();
          if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
          {
            ClassName = object_getClassName(v56);
            *(_DWORD *)statfs buf = 136315138;
            *(void *)&uint8_t buf[4] = ClassName;
            _os_log_error_impl(&dword_1BF22B000, v76, OS_LOG_TYPE_ERROR, "child is %s", buf, 0xCu);
          }

          *__error() = v75;
          char v78 = object_getClassName(v56);
          _SASetCrashLogMessage(5929, "child is %s", v79, v80, v81, v82, v83, v84, v78);
          id v9 = (id)_os_crash();
          __break(1u);
          goto LABEL_89;
        }
        a2 = v56;
        if (v15 == (__objc2_meth_list *)[(__objc2_class *)a2 address]) {
          id v52 = a2;
        }
        else {
          id v52 = 0;
        }
        v56 = a2;
LABEL_52:

        if (!v52)
        {
LABEL_53:
          uint64_t v59 = (__objc2_class *)-[SAExclaveFrame initWithExclave:]([SAExclaveFrame alloc], v10);
          id v52 = v59;
          if (v59) {
            v59->int cache = v15;
          }
          id v60 = [v10 loadInfos];

          if (v60)
          {
            a2 = SABinaryLoadInfo;
            id v62 = [v10 loadInfos];
            uint64_t v63 = +[SABinaryLoadInfo binaryLoadInfoForAddress:v15 inBinaryLoadInfos:v62];
            if (v52) {
              objc_storeWeak(&v52->vtable, v63);
            }
          }
          if (v52) {
            v52->info = (__objc2_class_ro *)a4;
          }
          if (a4)
          {
            -[SAFrame _addChildFrame:](a4, v52);
          }
          else
          {
            id v64 = objc_getProperty(v10, v61, 40, 1);
            [v64 addObject:v52];
          }
        }

        if (v51 == ++v53)
        {
          uint64_t v51 = [v49 countByEnumeratingWithState:&v325 objects:v337 count:16];
          if (v51) {
            goto LABEL_38;
          }
LABEL_68:

          uint64_t v65 = [SAExclaveCallstack alloc];
          if (v65)
          {
            uint64_t v66 = v317->superclass;
            uint64_t v67 = -[SAExclaveCallstack initWithExclave:leafFrame:]((id *)&v65->super.isa, v10, v52);
            uint64_t v68 = v67;
            uint64_t v23 = v301;
            uint64_t v24 = v306;
            if (v67)
            {
              v67[4] = v66->cache;
              v67[3] = v66->superclass;
            }
            id v69 = context;
            if (!context) {
LABEL_72:
            }
              id v69 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
          }
          else
          {
            uint64_t v68 = 0;
            uint64_t v24 = v306;
            id v69 = context;
            uint64_t v23 = v301;
            if (!context) {
              goto LABEL_72;
            }
          }
          context = v69;
          [v69 insertObject:v68 atIndex:0];

          unint64_t v20 = 0x1E4F28000uLL;
LABEL_74:

          if (++v24 != v313) {
            goto LABEL_13;
          }
          uint64_t v70 = [v23 countByEnumeratingWithState:&v329 objects:v338 count:16];
          uint64_t v313 = v70;
          if (v70) {
            goto LABEL_12;
          }

          id v10 = v297;
          if (context)
          {
            uint64_t v71 = (void *)[context copy];
            int v72 = [*(id *)(v20 + 3792) numberWithUnsignedLongLong:*v283[1]];
            [v293 setObject:v71 forKeyedSubscript:v72];

            uint64_t v23 = (void **)context;
            goto LABEL_82;
          }
LABEL_83:
          uint64_t v19 = v291 + 1;
          uint64_t v17 = v285;
          if (v291 + 1 == v289)
          {
            uint64_t v73 = [obj countByEnumeratingWithState:&v333 objects:v339 count:16];
            uint64_t v17 = v285;
            uint64_t v289 = v73;
            if (!v73)
            {
LABEL_85:

              uint64_t v74 = 0;
              goto LABEL_422;
            }
            goto LABEL_5;
          }
          goto LABEL_6;
        }
      }
      uint64_t v58 = (__objc2_class *)objc_getProperty(v10, v54, 40, 1);
      v56 = v58;
      v322[0] = MEMORY[0x1E4F143A8];
      v322[1] = v18;
      v323[0] = __77__SASampleStore_parseKCDataExclavesContainer_exclaveInfo_primaryDataIsKPerf___block_invoke_335;
      v323[1] = &__block_descriptor_40_e21_B24__0__SAFrame_8_B16l;
      v323[2] = v15;
      SEL v57 = v322;
      goto LABEL_46;
    }
    __int16 v86 = (void *)MEMORY[0x1C18A6A20](v9);
    uint64_t v87 = v86;
    uint64_t v88 = a2->isa;
    int v89 = (int)a2->isa->isa;
    if ((v89 & 0xFFFFFFF0) == 0x20) {
      int v90 = 17;
    }
    else {
      int v90 = (int)a2->isa->isa;
    }
    if ((v90 - 1) < 6) {
      goto LABEL_98;
    }
    if (v90 != 19)
    {
      if (v90 != 20)
      {
LABEL_98:
        goto LABEL_403;
      }
      v241 = v88->superclass;
      if (superclass == v241)
      {
        unint64_t v8 = 0x1E4F1C000;
        goto LABEL_3;
      }
      int v238 = *__error();
      v239 = _sa_logt();
      if (os_log_type_enabled(v239, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)statfs buf = 134218240;
        *(void *)&uint8_t buf[4] = superclass;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v241;
        _os_log_error_impl(&dword_1BF22B000, v239, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
      }
      uint64_t v74 = 7;
LABEL_421:

      *__error() = v238;
      break;
    }
    unint64_t v91 = (unint64_t)a2->superclass;
    if ((unint64_t)&v88->cache > v91
      || (uint64_t isa_high = HIDWORD(v88->isa), (unint64_t)&v88->cache + isa_high > v91)
      || ((v89 & 0xFFFFFFF0) != 0x20 ? (BOOL v93 = v89 == 19) : (BOOL v93 = 0),
          v93 ? (BOOL v94 = isa_high > 3) : (BOOL v94 = 0),
          !v94))
    {
      int v238 = *__error();
      v239 = _sa_logt();
      if (os_log_type_enabled(v239, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)statfs buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 2377;
        _os_log_error_impl(&dword_1BF22B000, v239, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
      }
      uint64_t v74 = 1;
      goto LABEL_421;
    }
    int v95 = (int)v88->cache;
    if (v95 == 2378)
    {
      id v307 = v10;
      int cache = (int)a2->isa->cache;
      if (cache == 2378)
      {
        long long v128 = a2->isa->superclass;
        id v319 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
        long long v129 = a2->superclass;
        char v130 = (char *)a2->isa + HIDWORD(a2->isa->isa);
        id v131 = v130 + 16;
        a2->isa = (__objc2_class *)(v130 + 16);
        uint64_t v132 = v130 + 32;
        if (v132 > (char *)v129) {
          goto LABEL_390;
        }
        v288 = v128;
        p_int cache = 0;
        while (2)
        {
          if (&v132[v131[1]] > (char *)v129 || *v131 == -242132755)
          {
LABEL_385:
            if (p_cache)
            {
              v227 = [SAKCDataExclaveSCResult alloc];
              if ([v319 count]) {
                v228 = v319;
              }
              else {
                v228 = 0;
              }
              v229 = -[SAKCDataExclaveSCResult initWithInfo:callstacks:](v227, (uint64_t)p_cache, v228);
              v230 = [NSNumber numberWithUnsignedLongLong:*p_cache];
              [v307 setObject:v229 forKeyedSubscript:v230];

              uint64_t v74 = 0;
              goto LABEL_393;
            }
LABEL_390:
            int v231 = *__error();
            BOOL v232 = _sa_logt();
            if (os_log_type_enabled(v232, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)statfs buf = 0;
              _os_log_error_impl(&dword_1BF22B000, v232, OS_LOG_TYPE_ERROR, "No exclave_scresult_info in scresult container", buf, 2u);
            }

            *__error() = v231;
            uint64_t v74 = 1;
            goto LABEL_393;
          }
          uint64_t v133 = (void *)MEMORY[0x1C18A6A20]();
          uint64_t v134 = a2->isa;
          int v135 = (int)a2->isa->isa;
          if ((v135 & 0xFFFFFFF0) == 0x20) {
            int v136 = 17;
          }
          else {
            int v136 = (int)a2->isa->isa;
          }
          if (v136 != 19)
          {
            if (v136 == 2379)
            {
              p_int cache = &v134->cache;
            }
            else if (v136 == 20)
            {
              v226 = v134->superclass;
              if (v288 == v226)
              {
                goto LABEL_385;
              }
              contextb = v133;
              int v221 = *__error();
              v222 = _sa_logt();
              if (os_log_type_enabled(v222, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)statfs buf = 134218240;
                *(void *)&uint8_t buf[4] = v288;
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v226;
                _os_log_error_impl(&dword_1BF22B000, v222, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
              }
              uint64_t v74 = 7;
LABEL_374:

              *__error() = v221;
              unint64_t v8 = 0x1E4F1C000;
LABEL_393:

              v223 = v307;
              goto LABEL_394;
            }
            goto LABEL_278;
          }
          unint64_t v137 = (unint64_t)a2->superclass;
          contextb = v133;
          if ((unint64_t)&v134->cache > v137
            || (uint64_t v138 = HIDWORD(v134->isa), (unint64_t)&v134->cache + v138 > v137)
            || ((v135 & 0xFFFFFFF0) != 0x20 ? (BOOL v139 = v135 == 19) : (BOOL v139 = 0),
                v139 ? (BOOL v140 = v138 > 3) : (BOOL v140 = 0),
                !v140))
          {
            int v221 = *__error();
            v222 = _sa_logt();
            if (os_log_type_enabled(v222, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)statfs buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = 2378;
              _os_log_error_impl(&dword_1BF22B000, v222, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
            }
            uint64_t v74 = 1;
            goto LABEL_374;
          }
          if (LODWORD(v134->cache) != 2380)
          {
            uint64_t v74 = SkipToContainerEnd((int **)a2, 1);
            goto LABEL_277;
          }
          id v141 = v319;
          uint64_t v142 = a2->isa;
          int cache = (int)a2->isa->cache;
          if (cache != 2380) {
            goto LABEL_440;
          }
          long long v143 = v141;
          long long v144 = v142->superclass;
          long long v145 = a2->superclass;
          long long v146 = (char *)v142 + HIDWORD(v142->isa);
          long long v147 = v146 + 16;
          a2->isa = (__objc2_class *)(v146 + 16);
          long long v148 = v146 + 32;
          if (v148 > (char *)v145)
          {
            v302 = 0;
            goto LABEL_192;
          }
          double v284 = v144;
          uint64_t v292 = 0;
          v302 = 0;
LABEL_199:
          if (&v148[v147[1]] > (char *)v145 || *v147 == -242132755) {
            goto LABEL_267;
          }
          long long v151 = (void *)MEMORY[0x1C18A6A20]();
          long long v152 = v151;
          long long v153 = a2->isa;
          int v154 = (int)a2->isa->isa;
          unsigned int v155 = v154 & 0xFFFFFFF0;
          if ((v154 & 0xFFFFFFF0) == 0x20) {
            int v156 = 17;
          }
          else {
            int v156 = (int)a2->isa->isa;
          }
          uint64_t p_superclass = (uint64_t)&v153[1].superclass;
          if ((v156 - 1) >= 6) {
            uint64_t p_superclass = (uint64_t)&a2->isa->cache;
          }
          if (v156 > 19)
          {
            if (v156 == 2381)
            {
              uint64_t v292 = p_superclass;
            }
            else if (v156 == 20)
            {
              uint64_t v181 = v153->superclass;
              if (v284 == v181)
              {
                unint64_t v8 = 0x1E4F1C000;
LABEL_267:
                if (v292)
                {
                  dispatch_time_t v177 = -[SAKCDataExclaveCallstack initWithInfo:addresses:]([SAKCDataExclaveCallstack alloc], v292, v302);
                  [v143 addObject:v177];

                  uint64_t v74 = 0;
                  goto LABEL_276;
                }
LABEL_192:
                int v149 = *__error();
                long long v150 = _sa_logt();
                if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v343 = 0;
                  _os_log_error_impl(&dword_1BF22B000, v150, OS_LOG_TYPE_ERROR, "No exclave_ipcstackentry_info in ipcstackentry container", v343, 2u);
                }

                *__error() = v149;
                uint64_t v74 = 1;
              }
              else
              {
                int v178 = *__error();
                uint64_t v179 = _sa_logt();
                if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v343 = 134218240;
                  *(void *)&v343[4] = v284;
                  *(_WORD *)&v343[12] = 2048;
                  *(void *)&v343[14] = v181;
                  _os_log_error_impl(&dword_1BF22B000, v179, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", v343, 0x16u);
                }
                uint64_t v74 = 7;
LABEL_275:

                *__error() = v178;
                unint64_t v8 = 0x1E4F1C000;
              }
LABEL_276:

              id v10 = v297;
LABEL_277:
              if (v74) {
                goto LABEL_393;
              }
LABEL_278:
              long long v129 = a2->superclass;
              __int16 v180 = (char *)a2->isa + HIDWORD(a2->isa->isa);
              id v131 = v180 + 16;
              a2->isa = (__objc2_class *)(v180 + 16);
              uint64_t v132 = v180 + 32;
              if (v132 > (char *)v129) {
                goto LABEL_385;
              }
              continue;
            }
            goto LABEL_233;
          }
          break;
        }
        unint64_t v158 = (unint64_t)a2->superclass;
        if (v156 != 17)
        {
          if (v156 == 19)
          {
            long long v159 = &v153->cache;
            unint64_t v8 = 0x1E4F1C000;
            if ((unint64_t)&v153->cache > v158
              || (uint64_t v160 = HIDWORD(v153->isa), (unint64_t)v159 + v160 > v158)
              || (v155 != 32 ? (BOOL v161 = v154 == 19) : (BOOL v161 = 0),
                  v161 ? (BOOL v162 = v160 > 3) : (BOOL v162 = 0),
                  !v162))
            {
              int v178 = *__error();
              uint64_t v179 = _sa_logt();
              if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v343 = 67109120;
                *(_DWORD *)&v343[4] = 2380;
                _os_log_error_impl(&dword_1BF22B000, v179, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", v343, 8u);
              }
              uint64_t v74 = 1;
              goto LABEL_275;
            }
            uint64_t v74 = SkipToContainerEnd((int **)a2, 1);
            if (v74) {
              goto LABEL_276;
            }
            goto LABEL_266;
          }
LABEL_233:
          unint64_t v8 = 0x1E4F1C000;
LABEL_265:
LABEL_266:
          long long v145 = a2->superclass;
          v176 = (char *)a2->isa + HIDWORD(a2->isa->isa);
          long long v147 = v176 + 16;
          a2->isa = (__objc2_class *)(v176 + 16);
          long long v148 = v176 + 32;
          if (v148 > (char *)v145) {
            goto LABEL_267;
          }
          goto LABEL_199;
        }
        v290 = v151;
        uint64_t v163 = a4;
        if ((unint64_t)&v153->cache > v158) {
          goto LABEL_269;
        }
        uint64_t v164 = HIDWORD(v153->isa);
        if ((unint64_t)&v153->cache + v164 > v158 || v154 != 17 && v155 != 32) {
          goto LABEL_269;
        }
        long long v165 = v153->superclass;
        if (!v165)
        {
          if (v164) {
            goto LABEL_269;
          }
          unint64_t v166 = (unint64_t)v165 >> 32;
          if (v154 == 17) {
            goto LABEL_252;
          }
          goto LABEL_256;
        }
        if (v154 == 17)
        {
          unint64_t v166 = (unint64_t)v165 >> 32;
          if (SHIDWORD(v165) <= 2310)
          {
            switch(HIDWORD(v165))
            {
              case 0x30:
                unsigned int v167 = 20;
                break;
              case 0x31:
                unsigned int v167 = 24;
                break;
              case 0x81A:
LABEL_244:
                unsigned int v167 = 8;
                break;
              default:
                goto LABEL_269;
            }
          }
          else
          {
            switch(HIDWORD(v165))
            {
              case 0x907:
                unsigned int v167 = 4;
                break;
              case 0x908:
              case 0x909:
                goto LABEL_269;
              case 0x90A:
              case 0x90C:
                goto LABEL_244;
              case 0x90B:
              case 0x90D:
                unsigned int v167 = 16;
                break;
              default:
                if (HIDWORD(v165) != 2369) {
                  goto LABEL_269;
                }
                unsigned int v167 = 48;
                break;
            }
          }
          if (v164 / v167 < v165 || v164 % v165 >= 0x10)
          {
LABEL_269:
            int v178 = *__error();
            uint64_t v179 = _sa_logt();
            if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)v343 = 0;
              uint64_t v74 = 2;
              _os_log_error_impl(&dword_1BF22B000, v179, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: array is invalid", v343, 2u);
            }
            else
            {
              uint64_t v74 = 2;
            }
            long long v15 = &OBJC_INSTANCE_METHODS_SATimeRangeOfSamples;
            long long v152 = v290;
            goto LABEL_275;
          }
LABEL_252:
          if (((v166 - 2311) > 0x3A || ((1 << (v166 - 7)) & 0x400000000000079) == 0)
            && (v166 - 48) >= 2
            && v166 != 2074)
          {
LABEL_256:
            unsigned int v169 = 0;
LABEL_257:
            if (v166 == 2382)
            {
              char v286 = v87;
              uint64_t v170 = p_superclass;
              id v171 = objc_alloc_init(MEMORY[0x1E4F1CA48]);

              if (v165)
              {
                v282 = v143;
                unsigned int v172 = 0;
                uint64_t v173 = MEMORY[0x1E4F143A8];
                long long v165 = (__objc2_class *)v165;
                do
                {
                  *(void *)statfs buf = v173;
                  *(__objc2_meth_list *)&uint8_t buf[8] = v85;
                  *(void *)&buf[16] = __65__SASampleStore_parseKCDataExclavesIPCStackContainer_callstacks___block_invoke;
                  v341 = &unk_1E63F7690;
                  id v174 = v171;
                  id v342 = v174;
                  __65__SASampleStore_parseKCDataExclavesIPCStackContainer_callstacks___block_invoke((uint64_t)buf, v175, (void *)(v170 + v172));

                  v172 += v169;
                  long long v165 = (__objc2_class *)((char *)v165 - 1);
                }
                while (v165);
                a4 = v163;
                long long v15 = &OBJC_INSTANCE_METHODS_SATimeRangeOfSamples;
                unint64_t v8 = 0x1E4F1C000;
                v302 = v174;
                long long v143 = v282;
              }
              else
              {
                v302 = v171;
                long long v15 = &OBJC_INSTANCE_METHODS_SATimeRangeOfSamples;
                unint64_t v8 = 0x1E4F1C000;
              }
              long long v152 = v290;
              uint64_t v87 = v286;
              goto LABEL_265;
            }
          }
          long long v15 = &OBJC_INSTANCE_METHODS_SATimeRangeOfSamples;
          unint64_t v8 = 0x1E4F1C000;
          long long v152 = v151;
          goto LABEL_265;
        }
        unsigned int v168 = v164 - ((uint64_t)a2->isa->isa & 0xF);
        if (v164 < (unint64_t)((uint64_t)a2->isa->isa & 0xF)) {
          goto LABEL_269;
        }
        if (v168 < v165) {
          goto LABEL_269;
        }
        unsigned int v169 = v168 / v165;
        if (v168 % v165) {
          goto LABEL_269;
        }
        unint64_t v166 = (unint64_t)v165 >> 32;
        goto LABEL_257;
      }
LABEL_434:
      int v258 = *__error();
      uint64_t v259 = _sa_logt();
      if (os_log_type_enabled(v259, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)statfs buf = v314;
        *(_DWORD *)&uint8_t buf[4] = cache;
        _os_log_error_impl(&dword_1BF22B000, v259, OS_LOG_TYPE_ERROR, "bad container type %u", buf, 8u);
      }

      *__error() = v258;
      _SASetCrashLogMessage(5984, "bad container type %u", v260, v261, v262, v263, v264, v265, cache);
      _os_crash();
      __break(1u);
      goto LABEL_437;
    }
    if (v95 == 2386)
    {
      id v320 = v298;
      __int16 v182 = a2->isa;
      int cache = (int)a2->isa->cache;
      if (cache == 2386)
      {
        uint64_t v183 = v182->superclass;
        __int16 v184 = a2->superclass;
        uint64_t v185 = (char *)v182 + HIDWORD(v182->isa);
        __int16 v186 = v185 + 16;
        a2->isa = (__objc2_class *)(v185 + 16);
        uint64_t v187 = v185 + 32;
        if (v187 > (char *)v184)
        {
          __int16 v188 = 0;
          goto LABEL_289;
        }
        CFTypeRef v308 = v183;
        contextc = 0;
        id v191 = 0;
        while (1)
        {
          if (&v187[v186[1]] > (char *)v184 || *v186 == -242132755) {
            goto LABEL_364;
          }
          uint64_t v192 = (void *)MEMORY[0x1C18A6A20]();
          int v193 = v192;
          v194 = a2->isa;
          int v195 = (int)a2->isa->isa;
          unsigned int v196 = v195 & 0xFFFFFFF0;
          if ((v195 & 0xFFFFFFF0) == 0x20) {
            int v197 = 17;
          }
          else {
            int v197 = (int)a2->isa->isa;
          }
          if ((v197 - 1) >= 6) {
            uint64_t v198 = (uint64_t)&a2->isa->cache;
          }
          else {
            uint64_t v198 = (uint64_t)&v194[1].superclass;
          }
          if (v197 > 19)
          {
            if (v197 == 2387)
            {
              contextc = (void *)v198;
            }
            else if (v197 == 20)
            {
              int32_t v237 = v194->superclass;
              id v10 = v297;
              if (v308 != v237)
              {
                v218 = v192;
                id obja = (id)a4;
                int v219 = *__error();
                int v220 = _sa_logt();
                __int16 v188 = v191;
                if (os_log_type_enabled(v220, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v343 = 134218240;
                  *(void *)&v343[4] = v308;
                  *(_WORD *)&v343[12] = 2048;
                  *(void *)&v343[14] = v237;
                  _os_log_error_impl(&dword_1BF22B000, v220, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", v343, 0x16u);
                }
                uint64_t v74 = 7;
LABEL_378:

                *__error() = v219;
                a4 = (uint64_t)obja;
                long long v15 = &OBJC_INSTANCE_METHODS_SATimeRangeOfSamples;
                unint64_t v8 = 0x1E4F1C000;
                goto LABEL_379;
              }
LABEL_364:
              if (contextc)
              {
                __int16 v188 = v191;
                v216 = -[SAKCDataExclaveTextLayout initWithInfo:textSegments:]([SAKCDataExclaveTextLayout alloc], (uint64_t)contextc, v191);
                int v217 = [NSNumber numberWithUnsignedLongLong:*contextc];
                [v320 setObject:v216 forKeyedSubscript:v217];

                uint64_t v74 = 0;
LABEL_366:
                long long v15 = &OBJC_INSTANCE_METHODS_SATimeRangeOfSamples;
LABEL_379:

                v223 = v320;
LABEL_394:

                goto LABEL_402;
              }
              __int16 v188 = v191;
              long long v15 = &OBJC_INSTANCE_METHODS_SATimeRangeOfSamples;
LABEL_289:
              int v189 = *__error();
              __int16 v190 = _sa_logt();
              if (os_log_type_enabled(v190, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)v343 = 0;
                _os_log_error_impl(&dword_1BF22B000, v190, OS_LOG_TYPE_ERROR, "No exclave_textlayout_info in textlayout container", v343, 2u);
              }

              *__error() = v189;
              uint64_t v74 = 1;
              goto LABEL_379;
            }
            goto LABEL_329;
          }
          unint64_t v199 = (unint64_t)a2->superclass;
          if (v197 == 17) {
            break;
          }
          id v10 = v297;
          if (v197 != 19) {
            goto LABEL_362;
          }
          v200 = &v194->cache;
          if ((unint64_t)&v194->cache > v199
            || (uint64_t v201 = HIDWORD(v194->isa), (unint64_t)v200 + v201 > v199)
            || (v196 != 32 ? (BOOL v202 = v195 == 19) : (BOOL v202 = 0), v202 ? (v203 = v201 > 3) : (v203 = 0), !v203))
          {
            v218 = v192;
            id obja = (id)a4;
            int v219 = *__error();
            int v220 = _sa_logt();
            __int16 v188 = v191;
            if (os_log_type_enabled(v220, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v343 = 67109120;
              *(_DWORD *)&v343[4] = 2386;
              _os_log_error_impl(&dword_1BF22B000, v220, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", v343, 8u);
            }
            uint64_t v74 = 1;
            goto LABEL_378;
          }
          uint64_t v74 = SkipToContainerEnd((int **)a2, 1);
          if (v74)
          {
            __int16 v188 = v191;
            goto LABEL_366;
          }
LABEL_363:
          __int16 v184 = a2->superclass;
          v215 = (char *)a2->isa + HIDWORD(a2->isa->isa);
          __int16 v186 = v215 + 16;
          a2->isa = (__objc2_class *)(v215 + 16);
          uint64_t v187 = v215 + 32;
          if (v187 > (char *)v184) {
            goto LABEL_364;
          }
        }
        if ((unint64_t)&v194->cache > v199) {
          goto LABEL_368;
        }
        uint64_t v204 = HIDWORD(v194->isa);
        if ((unint64_t)&v194->cache + v204 > v199 || v195 != 17 && v196 != 32) {
          goto LABEL_368;
        }
        v205 = v194->superclass;
        if (v205)
        {
          if (v195 == 17)
          {
            unint64_t v206 = (unint64_t)v205 >> 32;
            if (SHIDWORD(v205) <= 2310)
            {
              switch(HIDWORD(v205))
              {
                case 0x30:
                  unsigned int v207 = 20;
                  break;
                case 0x31:
                  unsigned int v207 = 24;
                  break;
                case 0x81A:
LABEL_340:
                  unsigned int v207 = 8;
                  break;
                default:
                  goto LABEL_368;
              }
            }
            else
            {
              switch(HIDWORD(v205))
              {
                case 0x907:
                  unsigned int v207 = 4;
                  break;
                case 0x908:
                case 0x909:
                  goto LABEL_368;
                case 0x90A:
                case 0x90C:
                  goto LABEL_340;
                case 0x90B:
                case 0x90D:
                  unsigned int v207 = 16;
                  break;
                default:
                  if (HIDWORD(v205) != 2369) {
                    goto LABEL_368;
                  }
                  unsigned int v207 = 48;
                  break;
              }
            }
            if (v204 / v207 < v205 || v204 % v205 >= 0x10)
            {
LABEL_368:
              v218 = v192;
              id obja = (id)a4;
              int v219 = *__error();
              int v220 = _sa_logt();
              __int16 v188 = v191;
              if (os_log_type_enabled(v220, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)v343 = 0;
                uint64_t v74 = 2;
                _os_log_error_impl(&dword_1BF22B000, v220, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: array is invalid", v343, 2u);
              }
              else
              {
                uint64_t v74 = 2;
              }
              id v10 = v297;
              goto LABEL_378;
            }
LABEL_348:
            if ((v206 - 2311) > 0x3A || ((1 << (v206 - 7)) & 0x400000000000079) == 0)
            {
              if ((v206 - 48) >= 2 && v206 != 2074) {
                goto LABEL_352;
              }
LABEL_329:
              id v10 = v297;
LABEL_362:
              goto LABEL_363;
            }
LABEL_361:
            id v10 = v297;
            goto LABEL_362;
          }
          unsigned int v208 = v204 - ((uint64_t)a2->isa->isa & 0xF);
          if (v204 < (unint64_t)((uint64_t)a2->isa->isa & 0xF)) {
            goto LABEL_368;
          }
          if (v208 < v205) {
            goto LABEL_368;
          }
          unsigned int v209 = v208 / v205;
          if (v208 % v205) {
            goto LABEL_368;
          }
          unint64_t v206 = (unint64_t)v205 >> 32;
        }
        else
        {
          if (v204) {
            goto LABEL_368;
          }
          unint64_t v206 = (unint64_t)v205 >> 32;
          if (v195 == 17) {
            goto LABEL_348;
          }
LABEL_352:
          unsigned int v209 = 0;
        }
        if (v206 == 2388)
        {
          v305 = v192;
          if (!v191) {
            id v191 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
          }
          if (v205)
          {
            unsigned int v210 = 0;
            uint64_t v211 = MEMORY[0x1E4F143A8];
            uint64_t v212 = v205;
            do
            {
              *(void *)statfs buf = v211;
              *(__objc2_meth_list *)&uint8_t buf[8] = v85;
              *(void *)&buf[16] = __68__SASampleStore_parseKCDataExclavesTextLayoutContainer_textLayouts___block_invoke;
              v341 = &unk_1E63F76B8;
              id v213 = v191;
              id v342 = v213;
              __68__SASampleStore_parseKCDataExclavesTextLayoutContainer_textLayouts___block_invoke((uint64_t)buf, v214, v198 + v210);

              v210 += v209;
              --v212;
            }
            while (v212);
            id v191 = v213;
          }
          id v10 = v297;
          unint64_t v8 = 0x1E4F1C000;
          int v193 = v305;
          goto LABEL_362;
        }
        goto LABEL_361;
      }
LABEL_437:
      int v266 = *__error();
      long long v267 = _sa_logt();
      if (os_log_type_enabled(v267, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v343 = v314;
        *(_DWORD *)&v343[4] = cache;
        _os_log_error_impl(&dword_1BF22B000, v267, OS_LOG_TYPE_ERROR, "bad container type %u", v343, 8u);
      }

      *__error() = v266;
      _SASetCrashLogMessage(6330, "bad container type %u", v268, v269, v270, v271, v272, v273, cache);
      _os_crash();
      __break(1u);
LABEL_440:
      int v274 = *__error();
      long long v275 = _sa_logt();
      if (os_log_type_enabled(v275, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v343 = v314;
        *(_DWORD *)&v343[4] = cache;
        _os_log_error_impl(&dword_1BF22B000, v275, OS_LOG_TYPE_ERROR, "bad container type %u", v343, 8u);
      }

      *__error() = v274;
      _SASetCrashLogMessage(6090, "bad container type %u", v276, v277, v278, v279, v280, v281, cache);
      _os_crash();
      __break(1u);
    }
    if (v95 != 2383)
    {
      uint64_t v74 = SkipToContainerEnd((int **)a2, 1);
      goto LABEL_402;
    }
    id v96 = v300;
    id v97 = a2->isa;
    int cache = (int)a2->isa->cache;
    if (cache != 2383) {
      goto LABEL_431;
    }
    uint64_t v98 = v96;
    id v99 = v97->superclass;
    uint64_t v100 = a2->superclass;
    uint64_t v101 = (char *)v97 + HIDWORD(v97->isa);
    id v102 = v101 + 16;
    a2->isa = (__objc2_class *)(v101 + 16);
    id v103 = v101 + 32;
    if (v103 > (char *)v100)
    {
LABEL_397:
      int v234 = *__error();
      v235 = _sa_logt();
      if (os_log_type_enabled(v235, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_error_impl(&dword_1BF22B000, v235, OS_LOG_TYPE_ERROR, "No exclave_addressspace_info in addressspace container", buf, 2u);
      }

      *__error() = v234;
      uint64_t v74 = 1;
LABEL_400:
      id v10 = v297;
      goto LABEL_401;
    }
    contexta = v99;
    uint64_t v104 = 0;
    uint64_t v318 = 0;
    while (1)
    {
      if (&v103[v102[1]] > (char *)v100 || *v102 == -242132755)
      {
LABEL_164:
        if (!v104) {
          goto LABEL_397;
        }
        goto LABEL_165;
      }
      uint64_t v105 = (void *)MEMORY[0x1C18A6A20]();
      uint64_t v106 = v105;
      uint64_t v107 = a2->isa;
      int v108 = (int)a2->isa->isa;
      if ((v108 & 0xFFFFFFF0) == 0x20) {
        int v109 = 17;
      }
      else {
        int v109 = (int)a2->isa->isa;
      }
      if ((v109 - 1) > 5)
      {
        if (v109 <= 2309)
        {
          if (v109 != 17 && v109 != 19) {
            goto LABEL_139;
          }
          unsigned int v111 = HIDWORD(v107->isa);
          int v115 = v111;
LABEL_142:
          id v110 = &v107->cache;
          goto LABEL_143;
        }
        if (v109 == 2310)
        {
          unsigned int v111 = HIDWORD(v107->isa);
          if (v111 == 112 && ((uint64_t)v107->superclass & 0x8F) == 0)
          {
            int v115 = 104;
            goto LABEL_142;
          }
        }
        else
        {
          if (v109 != 2312)
          {
LABEL_139:
            unsigned int v111 = HIDWORD(v107->isa);
            goto LABEL_140;
          }
          unsigned int v111 = HIDWORD(v107->isa);
          if (v111 == 32 && ((uint64_t)v107->superclass & 0x8F) == 0)
          {
            int v115 = 24;
            goto LABEL_142;
          }
        }
LABEL_140:
        unsigned int v117 = (uint64_t)v107->superclass & 0xF;
        BOOL v113 = v111 >= v117;
        int v115 = v111 - v117;
        if (!v113) {
          int v115 = 0;
        }
        goto LABEL_142;
      }
      id v110 = &v107[1].superclass;
      unsigned int v111 = HIDWORD(v107->isa);
      unsigned int v112 = (uint64_t)v107->superclass & 0xF;
      BOOL v113 = v111 >= v112;
      unsigned int v114 = v111 - v112;
      if (!v113) {
        unsigned int v114 = 0;
      }
      int v115 = v114 - 32;
LABEL_143:
      if (v109 > 2383)
      {
        if (v109 == 2385)
        {
          if (*((unsigned char *)v110 + (v115 - 1)))
          {
            long long v120 = v98;
            long long v121 = v104;
            uint64_t v122 = a4;
            int v123 = *__error();
            uint64_t v124 = _sa_logt();
            if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)statfs buf = 0;
              _os_log_impl(&dword_1BF22B000, v124, OS_LOG_TYPE_DEFAULT, "WARNING: exclave address space name non NULL-terminated", buf, 2u);
            }

            *__error() = v123;
            a4 = v122;
            uint64_t v104 = v121;
            uint64_t v98 = v120;
          }
          else
          {
            uint64_t v318 = (uint64_t)v110;
          }
        }
        else if (v109 == 2384)
        {
          uint64_t v104 = v110;
        }
        goto LABEL_162;
      }
      if (v109 != 19) {
        break;
      }
      uint64_t v118 = a2->superclass;
      int v119 = (__objc2_class *)&v107->cache;
      if (v119 > v118
        || (__objc2_class *)((char *)v119 + v111) > v118
        || (v108 & 0xFFFFFFF0) == 0x20
        || v108 != 19
        || v111 <= 3)
      {
        int v224 = *__error();
        uint64_t v225 = _sa_logt();
        if (os_log_type_enabled(v225, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)statfs buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = 2383;
          _os_log_error_impl(&dword_1BF22B000, v225, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
        }
        uint64_t v74 = 1;
        id v10 = v297;
        goto LABEL_413;
      }
      uint64_t v74 = SkipToContainerEnd((int **)a2, 1);
      if (v74) {
        goto LABEL_400;
      }
LABEL_163:
      uint64_t v100 = a2->superclass;
      id v125 = (char *)a2->isa + HIDWORD(a2->isa->isa);
      id v102 = v125 + 16;
      a2->isa = (__objc2_class *)(v125 + 16);
      id v103 = v125 + 32;
      if (v103 > (char *)v100) {
        goto LABEL_164;
      }
    }
    if (v109 != 20)
    {
LABEL_162:
      goto LABEL_163;
    }
    id objb = (id)a4;
    id v233 = v107->superclass;
    if (contexta == v233)
    {
      a4 = (uint64_t)objb;
      if (!v104) {
        goto LABEL_397;
      }
LABEL_165:
      uint64_t v126 = -[SAKCDataExclaveAddressSpace initWithInfo:name:]([SAKCDataExclaveAddressSpace alloc], (uint64_t)v104, v318);
      long long v127 = [NSNumber numberWithUnsignedLongLong:*v104];
      [v98 setObject:v126 forKeyedSubscript:v127];

      uint64_t v74 = 0;
      goto LABEL_400;
    }
    int v224 = *__error();
    uint64_t v225 = _sa_logt();
    if (os_log_type_enabled(v225, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 134218240;
      *(void *)&uint8_t buf[4] = contexta;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v233;
      _os_log_error_impl(&dword_1BF22B000, v225, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
    }
    uint64_t v74 = 7;
    a4 = (uint64_t)objb;
    id v10 = v297;
LABEL_413:

    *__error() = v224;
LABEL_401:

    unint64_t v8 = 0x1E4F1C000;
LABEL_402:
    if (!v74)
    {
LABEL_403:
      id v11 = a2->superclass;
      char v236 = (char *)a2->isa + HIDWORD(a2->isa->isa);
      long long v13 = (__objc2_class *)(v236 + 16);
      a2->isa = (__objc2_class *)(v236 + 16);
      long long v14 = v236 + 32;
      if (v14 > (char *)v11) {
        goto LABEL_3;
      }
      continue;
    }
    break;
  }
LABEL_422:

  return v74;
}

- (uint64_t)addKCDataThreadV4:(uint64_t)a3 threadV2:(uint64_t)a4 deltaThreadV3:(uint64_t)a5 deltaThreadV2:(void *)a6 timestamp:(unint64_t)a7 sampleIndex:(void *)a8 stack:(void *)a9 threadExclavesInfo:(char *)a10 threadName:(id *)a11 dispatchQueueLabel:(uint64_t)a12 waitInfo:(void *)a13 waitInfoPortLabelInfo:(uint64_t)a14 turnstileInfo:(void *)a15 turnstileInfoPortLabelInfo:(uint64_t *)a16 instructionCycles:(void *)a17 task:(void *)a18 kernelTask:(char)a19 taskIsSuspended:
{
  uint64_t v196 = *MEMORY[0x1E4F143B8];
  id v190 = a6;
  id v189 = a8;
  id v192 = a9;
  id v25 = a17;
  id v188 = a18;
  id v191 = v25;
  if (!a1)
  {
LABEL_258:
    uint64_t v46 = 0;
    uint64_t v51 = v189;
    goto LABEL_251;
  }
  if (a2) {
    uint64_t v26 = a2;
  }
  else {
    uint64_t v26 = a3;
  }
  if (a4) {
    uint64_t v27 = a4;
  }
  else {
    uint64_t v27 = a5;
  }
  if (!a4 && !a2 && !a3 && !a5)
  {
    int v147 = *__error();
    long long v148 = _sa_logt();
    if (os_log_type_enabled(v148, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v148, OS_LOG_TYPE_ERROR, "no thread snap", buf, 2u);
    }

    *__error() = v147;
    _SASetCrashLogMessage(3067, "no thread snap", v149, v150, v151, v152, v153, v154, v171);
    _os_crash();
    __break(1u);
LABEL_255:
    int v155 = *__error();
    int v156 = _sa_logt();
    if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 136315138;
      uint64_t v195 = (uint64_t)a1;
      _os_log_error_impl(&dword_1BF22B000, v156, OS_LOG_TYPE_ERROR, "dispatchQueueId 0, but dispatchQueueLabel %s", buf, 0xCu);
    }

    *__error() = v155;
    _SASetCrashLogMessage(3347, "dispatchQueueId 0, but dispatchQueueLabel %s", v157, v158, v159, v160, v161, v162, (char)a1);
    _os_crash();
    __break(1u);
    goto LABEL_258;
  }
  uint64_t v183 = a3;
  uint64_t v179 = a5;
  if (v26) {
    long long v28 = (uint64_t *)v26;
  }
  else {
    long long v28 = (uint64_t *)v27;
  }
  uint64_t v29 = [NSNumber numberWithUnsignedLongLong:*v28];
  uint64_t v30 = [v25 threads];
  uint64_t v187 = (void *)v29;
  double v31 = [v30 objectForKeyedSubscript:v29];

  __int16 v184 = a1;
  if (!v31)
  {
    +[SAThread threadWithId:]((uint64_t)SAThread, *v28);
    unsigned int v32 = (unsigned char *)objc_claimAutoreleasedReturnValue();
    id v33 = v32;
    if (v26) {
      uint64_t v34 = v26 + 64;
    }
    else {
      uint64_t v34 = v27 + 16;
    }
    if (v32) {
      v32[16] = *(unsigned char *)(v34 + 1) & 1;
    }
    -[SATask addThread:]((uint64_t)v25, v32);
    if ((*(unsigned char *)(v34 + 1) & 0x20) != 0)
    {
      uint64_t v35 = [v25 mainThread];

      if (!v35)
      {
        if (v33) {
          v33[17] = 1;
        }
        if (v25) {
          objc_setProperty_atomic(v25, v36, v33, 264);
        }
      }
    }
    if (![a1[3] count]) {
      goto LABEL_41;
    }
    if (*((unsigned char *)a1 + 223))
    {
      uint64_t v38 = [v25 taskStates];
      if ((unint64_t)[v38 count] < 2)
      {
        uint64_t v39 = [v25 taskStates];
        id v40 = [v39 firstObject];
        id v41 = [v40 startTimestamp];
        int v42 = [v41 lt:v190];

        a1 = v184;
        if (!v42) {
          goto LABEL_41;
        }
      }
      else
      {
      }
    }
    if (*((unsigned char *)a1 + 221))
    {
      int v43 = [v33 isMainThread];
      if (v43) {
        double v31 = 0;
      }
      else {
        double v31 = (id *)v33;
      }
      if (!v33 || (v43 & 1) == 0) {
        goto LABEL_42;
      }
    }
    else if (!v33)
    {
      double v31 = 0;
      goto LABEL_42;
    }
    objc_setProperty_atomic(v33, v37, v190, 32);
LABEL_41:
    double v31 = (id *)v33;
  }
LABEL_42:
  int v44 = [v31 threadStates];
  uint64_t v45 = [v44 lastObject];
  uint64_t v46 = v26 | v45;

  BOOL v47 = v45 != 0;
  if (!(v26 | v45))
  {
    uint64_t v51 = v189;
    uint64_t v50 = v187;
LABEL_250:

LABEL_251:
    return v46;
  }
  if (v45 && [(id)v45 endSampleIndex] == a7)
  {
    int v48 = *__error();
    id v49 = _sa_logt();
    uint64_t v50 = v187;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)statfs buf = 134217984;
      uint64_t v195 = [v31 threadId];
      _os_log_error_impl(&dword_1BF22B000, v49, OS_LOG_TYPE_ERROR, "Already saw thread 0x%llx in this stackshot, ignoring second instance", buf, 0xCu);
    }

    uint64_t v46 = 0;
    *__error() = v48;
    goto LABEL_249;
  }
  id v52 = a13;
  if (a19)
  {
    int v53 = 1;
  }
  else
  {
    uint64_t v54 = (unsigned __int8 *)(v26 + 64);
    if (!v26) {
      uint64_t v54 = (unsigned __int8 *)(v27 + 16);
    }
    int v53 = (*v54 >> 6) & 1;
  }
  int v172 = v53;
  if (v26)
  {
    if (v45)
    {
      uint64_t v55 = [(id)v45 name];

      BOOL v47 = ((unint64_t)a10 | v55) == 0;
      if (a10)
      {
        if (v55)
        {
          id v56 = [(id)v45 name];
          BOOL v47 = strcmp(a10, (const char *)[v56 UTF8String]) == 0;
        }
      }
    }
  }
  if (a13)
  {
    SEL v57 = (void *)a13[1];
    if (!v57)
    {
      id v52 = 0;
      if (v45) {
        goto LABEL_63;
      }
LABEL_68:
      int v175 = 0;
      goto LABEL_71;
    }
    id v52 = SANSStringForCString(v57);
  }
  if (!v45) {
    goto LABEL_68;
  }
LABEL_63:
  uint64_t v58 = [(id)v45 waitInfo];

  int v175 = (a12 | v58) == 0;
  if (a12 && v58)
  {
    uint64_t v59 = [(id)v45 waitInfo];
    id v60 = (void *)v59;
    if (a13)
    {
      uint64_t v61 = *(unsigned __int16 *)(*a13 + 2);
      uint64_t v62 = *(unsigned __int8 *)(*a13 + 4);
    }
    else
    {
      uint64_t v61 = 0;
      uint64_t v62 = 0;
    }
    int v175 = -[SAWaitInfo matchesKCDataWaitInfo:portName:flags:domain:](v59, a12, v52, v61, v62);
  }
LABEL_71:
  uint64_t v173 = v52;
  if (a15 && (uint64_t v63 = (void *)a15[1]) != 0)
  {
    dispatch_time_t v177 = SANSStringForCString(v63);
  }
  else
  {
    dispatch_time_t v177 = 0;
  }
  if (v45)
  {
    uint64_t v64 = [(id)v45 turnstileInfo];

    int v174 = (a14 | v64) == 0;
    if (a14 && v64)
    {
      uint64_t v65 = [(id)v45 turnstileInfo];
      uint64_t v66 = (void *)v65;
      if (a15)
      {
        uint64_t v67 = *(unsigned __int16 *)(*a15 + 2);
        uint64_t v68 = *(unsigned __int8 *)(*a15 + 4);
      }
      else
      {
        uint64_t v67 = 0;
        uint64_t v68 = 0;
      }
      int v174 = -[SATurnstileInfo matchesKCDataTurnstileInfo:portName:flags:domain:](v65, a14, v177, v67, v68);
    }
    if (!v26) {
      goto LABEL_100;
    }
    uint64_t v70 = [(id)v45 userTimeInNs];
    id v71 = v184[23];
    if (!v71 || !HIDWORD(v71)) {
      goto LABEL_99;
    }
    unint64_t v72 = v70;
    unint64_t v73 = *(void *)(v26 + 48);
    if (v71 != HIDWORD(v71)) {
      unint64_t v73 = __udivti3();
    }
    if (v72 >= v73)
    {
LABEL_99:
      uint64_t v74 = [(id)v45 systemTimeInNs];
      id v75 = v184[23];
      if (!v75 || !HIDWORD(v75)) {
        goto LABEL_269;
      }
      unint64_t v76 = v74;
      unint64_t v77 = *(void *)(v26 + 56);
      if (v75 != HIDWORD(v75)) {
        unint64_t v77 = __udivti3();
      }
      if (v76 >= v77)
      {
LABEL_269:
        if (!a16
          || (uint64_t v78 = a16[1], v78 == [(id)v45 cycles])
          && (uint64_t v79 = *a16, v79 == [(id)v45 instructions]))
        {
          if ((*(unsigned char *)(v26 + 65) & 8) == 0)
          {
LABEL_100:
            int v69 = *(_DWORD *)(v45 + 40);
LABEL_101:
            uint64_t v80 = (_DWORD *)(v26 + 88);
            if (!v26) {
              uint64_t v80 = (_DWORD *)(v27 + 32);
            }
            if (v69 == *v80)
            {
              int v81 = [(id)v45 basePriority];
              uint64_t v82 = (__int16 *)(v26 + 96);
              if (!v26) {
                uint64_t v82 = (__int16 *)(v27 + 40);
              }
              if (v81 == *v82)
              {
                int v83 = [(id)v45 scheduledPriority];
                uint64_t v84 = (__int16 *)(v26 + 98);
                if (!v26) {
                  uint64_t v84 = (__int16 *)(v27 + 42);
                }
                if (v83 == *v84)
                {
                  int v85 = [(id)v45 schedulerFlags];
                  __int16 v86 = (_DWORD *)(v26 + 92);
                  if (!v26) {
                    __int16 v86 = (_DWORD *)(v27 + 36);
                  }
                  if (v85 == *v86)
                  {
                    uint64_t v87 = [(id)v45 voucherIdentifier];
                    uint64_t v88 = (void *)(v26 + 32);
                    if (!v26) {
                      uint64_t v88 = (void *)(v27 + 8);
                    }
                    if (v87 == *v88)
                    {
                      int v89 = [(id)v45 threadQos];
                      int v90 = (unsigned __int8 *)(v26 + 100);
                      if (!v26) {
                        int v90 = (unsigned __int8 *)(v27 + 44);
                      }
                      if (v89 == *v90)
                      {
                        int v91 = [(id)v45 threadRequestedQos];
                        uint64_t v92 = (unsigned __int8 *)(v26 + 101);
                        if (!v26) {
                          uint64_t v92 = (unsigned __int8 *)(v27 + 45);
                        }
                        if (v91 == *v92)
                        {
                          int v93 = [(id)v45 threadRequestedQosOverride];
                          BOOL v94 = (unsigned __int8 *)(v26 + 102);
                          if (!v26) {
                            BOOL v94 = (unsigned __int8 *)(v27 + 46);
                          }
                          if (v93 == *v94)
                          {
                            int v95 = [(id)v45 ioTier];
                            id v96 = (unsigned __int8 *)(v26 + 103);
                            if (!v26) {
                              id v96 = (unsigned __int8 *)(v27 + 47);
                            }
                            if (v95 == *v96)
                            {
                              int v97 = [(id)v45 isDarwinBG];
                              uint64_t v98 = (unsigned char *)(v26 ? v26 + 64 : v27 + 16);
                              if (v97 != ((*v98 & 0x10) == 0)
                                && [(id)v45 isIOPassive] != ((*v98 & 0x20) == 0)
                                && [(id)v45 isIdleWorkQueue] != ((v98[1] & 0x10) == 0)
                                && [(id)v45 isRunning] != ((v98[1] & 8) == 0)
                                && v172 == [(id)v45 isSuspended]
                                && v47
                                && ((v175 ^ 1) & 1) == 0
                                && ((v174 ^ 1) & 1) == 0)
                              {
                                if (v45) {
                                  objc_setProperty_atomic((id)v45, v99, v190, 56);
                                }
                                -[SAThreadState setEndSampleIndex:](v45, a7);
                                uint64_t v100 = [(id)v45 dispatchQueue];
                                uint64_t v46 = [v100 identifier];

                                uint64_t v50 = v187;
                                goto LABEL_248;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            uint64_t v181 = [(id)v45 leafUserFrame];
            id v176 = [(id)v45 leafOfCRootFramesReplacedBySwiftAsync];
            __int16 v180 = [(id)v45 leafKernelFrame];
            if (v45) {
              id Property = objc_getProperty((id)v45, v101, 176, 1);
            }
            else {
              id Property = 0;
            }
            id v103 = Property;

            id v192 = v103;
            uint64_t v104 = (uint64_t)a16;
            if (!v47) {
              goto LABEL_145;
            }
LABEL_157:
            uint64_t v105 = [(id)v45 name];
            goto LABEL_158;
          }
        }
      }
    }
  }
  else
  {
    if (!v26)
    {
      int v174 = 0;
      int v69 = 0;
      goto LABEL_101;
    }
    int v174 = 0;
  }
  [v189 setContinuation:*(void *)(v26 + 16)];
  BOOL v106 = (*(_WORD *)(v26 + 64) & 0x8080) != 0
      || [v191 pid] && !objc_msgSend(v189, "hasUserStack");
  [v189 setIsUserStackTruncated:v106];
  [v189 setIsSwiftAsyncStackTruncated:(*(void *)(v26 + 64) >> 16) & 1];
  [v189 setIsKernelStackTruncated:(*(void *)(v26 + 64) >> 14) & 1];
  if ([v191 pid])
  {
    id v193 = 0;
    uint64_t v181 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v191, v189, &v193);
    id v176 = v193;
  }
  else
  {
    uint64_t v181 = 0;
    id v176 = 0;
  }
  uint64_t v104 = (uint64_t)a16;
  __int16 v180 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v188, v189, 0);
  if (v47) {
    goto LABEL_157;
  }
LABEL_145:
  if (!a10)
  {
    __int16 v182 = 0;
    goto LABEL_159;
  }
  uint64_t v105 = SANSStringForCString(a10);
LABEL_158:
  __int16 v182 = (void *)v105;
LABEL_159:
  uint64_t v107 = v184;
  int v108 = v176;
  if (v175)
  {
    uint64_t v109 = [(id)v45 waitInfo];
  }
  else
  {
    if (!a12)
    {
      unsigned int v112 = 0;
      goto LABEL_168;
    }
    if (a13)
    {
      unint64_t v110 = *(unsigned __int16 *)(*a13 + 2);
      unint64_t v111 = *(unsigned __int8 *)(*a13 + 4);
    }
    else
    {
      unint64_t v110 = 0;
      unint64_t v111 = 0;
    }
    uint64_t v109 = +[SAWaitInfo waitInfoWithKCDataWaitInfo:portName:flags:domain:]((uint64_t)SAWaitInfo, a12, v52, v110, v111);
  }
  unsigned int v112 = (void *)v109;
LABEL_168:
  if (v174)
  {
    uint64_t v113 = [(id)v45 turnstileInfo];
  }
  else
  {
    if (!a14)
    {
      uint64_t v116 = 0;
      goto LABEL_177;
    }
    if (a15)
    {
      unint64_t v114 = *(unsigned __int16 *)(*a15 + 2);
      unint64_t v115 = *(unsigned __int8 *)(*a15 + 4);
    }
    else
    {
      unint64_t v114 = 0;
      unint64_t v115 = 0;
    }
    uint64_t v113 = +[SATurnstileInfo turnstileInfoWithKCDataTurnstileInfo:portName:flags:domain:]((uint64_t)SATurnstileInfo, a14, v177, v114, v115);
  }
  uint64_t v116 = (void *)v113;
LABEL_177:
  uint64_t v185 = v116;
  if (a2)
  {
    unsigned int v117 = +[SAThreadState stateWithKCDataThreadV4:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:name:leafUserFrame:leafOfCRootFramesReplacedBySwiftAsync:leafKernelFrame:machTimebase:waitInfo:turnstileInfo:threadPolicyVersion:threadInstructionCycles:]((uint64_t)SAThreadState, a2, v190, v190, a7, a7, v182, v181, v176, v180, (uint64_t)v107[23], v112, v116, *((_DWORD *)v107 + 50), v104);
    goto LABEL_185;
  }
  if (v183)
  {
    unsigned int v117 = +[SAThreadState stateWithKCDataThreadV2:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:name:leafUserFrame:leafOfCRootFramesReplacedBySwiftAsync:leafKernelFrame:machTimebase:waitInfo:turnstileInfo:]((uint64_t)SAThreadState, v183, v190, v190, a7, a7, v182, v181, v176, v180, (uint64_t)v107[23], v112, v116);
    goto LABEL_185;
  }
  if (a4)
  {
    unsigned int v117 = +[SAThreadState stateWithKCDataDeltaThreadV3:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:name:leafUserFrame:leafOfCRootFramesReplacedBySwiftAsync:leafKernelFrame:oldThreadState:waitInfo:turnstileInfo:threadPolicyVersion:]((uint64_t)SAThreadState, a4, v190, v190, a7, a7, v182, v181, v176, v180, (void *)v45, v112, v116, *((_DWORD *)v107 + 50));
    goto LABEL_185;
  }
  if (v179)
  {
    unsigned int v117 = +[SAThreadState stateWithKCDataDeltaThreadV2:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:name:leafUserFrame:leafOfCRootFramesReplacedBySwiftAsync:leafKernelFrame:oldThreadState:waitInfo:turnstileInfo:]((uint64_t)SAThreadState, v179, v190, v190, a7, a7, v182, v181, v176, v180, (void *)v45, v112, v116);
LABEL_185:
    int v119 = v117;
    if (v117)
    {
      objc_setProperty_atomic(v117, v118, v192, 176);
      if (v172) {
        *((unsigned char *)v119 + 11) |= 0x40u;
      }
    }
    if (v45)
    {
      unint64_t v120 = [(id)v45 userTimeInNs];
      if (v120 > [v119 userTimeInNs])
      {
        uint64_t v121 = [(id)v45 userTimeInNs];
        if (v119) {
          *((void *)v119 + 17) = v121;
        }
      }
      unint64_t v122 = [(id)v45 systemTimeInNs];
      if (v122 > [v119 systemTimeInNs])
      {
        uint64_t v123 = [(id)v45 systemTimeInNs];
        if (v119) {
          *((void *)v119 + 18) = v123;
        }
      }
      unint64_t v124 = [(id)v45 cycles];
      if (v124 > [v119 cycles])
      {
        uint64_t v125 = [(id)v45 cycles];
        if (v119) {
          *((void *)v119 + 20) = v125;
        }
      }
      unint64_t v126 = [(id)v45 instructions];
      if (v126 > [v119 instructions])
      {
        uint64_t v127 = [(id)v45 instructions];
        if (v119) {
          *((void *)v119 + 19) = v127;
        }
      }
    }
    if (v31)
    {
      [v31[1] addObject:v119];
      uint64_t v128 = [v31[1] count] - 1;
    }
    else
    {
      uint64_t v128 = 0;
    }
    int v178 = v112;
    if (!v26)
    {
      unint64_t v137 = [(id)v45 dispatchQueue];
      uint64_t v138 = v137;
      if (v137)
      {
        uint64_t v46 = [v137 identifier];
        if (v119) {
          objc_storeWeak((id *)v119 + 14, v138);
        }
        BOOL v139 = +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SADispatchQueueState, v31, v128);
        if (v138[24]) {
          BOOL v140 = 0;
        }
        else {
          BOOL v140 = v138 + 24;
        }
        -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v138, v139, v140);
      }
      else
      {
        uint64_t v46 = 0;
      }

      id v141 = [(id)v45 swiftTask];
      if (v141)
      {
        if (v119) {
          objc_storeWeak((id *)v119 + 15, v141);
        }
        long long v145 = +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SASwiftTaskState, v31, v128);
        -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v141, v145, 0);
      }
      goto LABEL_246;
    }
    a1 = a11;
    uint64_t v46 = *(void *)(v26 + 40);
    if (v46)
    {
      long long v129 = [NSNumber numberWithUnsignedLongLong:v46];
      char v130 = [v191 dispatchQueues];
      id v131 = [v130 objectForKeyedSubscript:v129];

      if (!v131)
      {
        +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SADispatchQueue, v46);
        id v131 = (unsigned char *)objc_claimAutoreleasedReturnValue();
        -[SATask addDispatchQueue:]((uint64_t)v191, v131);
      }
      if (a11)
      {
        uint64_t v132 = [v131 dispatchQueueLabel];

        if (!v132)
        {
          uint64_t v134 = SANSStringForCString(a11);
          if (v134 && v131) {
            objc_setProperty_atomic_copy(v131, v133, v134, 32);
          }
        }
      }
      if (v119) {
        objc_storeWeak((id *)v119 + 14, v131);
      }
      int v135 = +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SADispatchQueueState, v31, v128);
      int v108 = v176;
      if (v131)
      {
        if (v131[24]) {
          int v136 = 0;
        }
        else {
          int v136 = v131 + 24;
        }
        -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v131, v135, v136);
      }

      if (!v176)
      {
        if (!v119) {
          goto LABEL_247;
        }
        goto LABEL_240;
      }
LABEL_233:
      id v141 = [NSNumber numberWithUnsignedLongLong:-1];
      uint64_t v142 = [v191 swiftTasks];
      long long v143 = [v142 objectForKeyedSubscript:v141];

      if (!v143)
      {
        long long v143 = +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SASwiftTask, -1);
        -[SATask addSwiftTask:]((uint64_t)v191, v143);
      }
      if (v119) {
        objc_storeWeak((id *)v119 + 15, v143);
      }
      long long v144 = +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SASwiftTaskState, v31, v128);
      if (v143) {
        -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v143, v144, 0);
      }

LABEL_246:
      goto LABEL_247;
    }
    if (!a11)
    {
      if (v119)
      {
        objc_storeWeak((id *)v119 + 14, 0);
        int v108 = v176;
        if (!v176)
        {
LABEL_240:
          objc_storeWeak((id *)v119 + 15, 0);
LABEL_247:
          uint64_t v50 = v187;

LABEL_248:
LABEL_249:
          uint64_t v51 = v189;
          goto LABEL_250;
        }
      }
      else
      {
        int v108 = v176;
        if (!v176)
        {
          uint64_t v46 = 0;
          goto LABEL_247;
        }
      }
      goto LABEL_233;
    }
    goto LABEL_255;
  }
  int v163 = *__error();
  uint64_t v164 = _sa_logt();
  if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)statfs buf = 0;
    _os_log_error_impl(&dword_1BF22B000, v164, OS_LOG_TYPE_ERROR, "no thread snap later", buf, 2u);
  }

  *__error() = v163;
  _SASetCrashLogMessage(3293, "no thread snap later", v165, v166, v167, v168, v169, v170, v171);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

- (void)addProcessInfoFromTailspin:(id)a3
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v26 = [v4 objectForKeyedSubscript:0x1F1A80EF8];
  -[SASampleStore lastTaskWithPid:](self, [v26 intValue]);
  uint64_t v5 = (unsigned char *)objc_claimAutoreleasedReturnValue();
  if (v5)
  {
    uint64_t v6 = [v4 objectForKeyedSubscript:0x1F1A80F18];
    if (v6)
    {
      id v23 = v4;
      if ([v5 pid]) {
        LOBYTE(v7) = 1;
      }
      else {
        int v7 = CSArchitectureIsArm64() ^ 1;
      }
      char v24 = v7;
      id v25 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithCapacity:", objc_msgSend(v6, "count"));
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      uint64_t v22 = v6;
      id v8 = v6;
      uint64_t v9 = [v8 countByEnumeratingWithState:&v27 objects:v31 count:16];
      if (v9)
      {
        uint64_t v10 = v9;
        uint64_t v11 = *(void *)v28;
        do
        {
          uint64_t v12 = 0;
          do
          {
            if (*(void *)v28 != v11) {
              objc_enumerationMutation(v8);
            }
            long long v13 = *(void **)(*((void *)&v27 + 1) + 8 * v12);
            long long v14 = objc_msgSend(v8, "objectForKeyedSubscript:", v13, v22);
            long long v15 = uuidForString(v13);
            if (v15)
            {
              long long v16 = +[SABinary binaryWithUUID:v15 absolutePath:0];
              uint64_t v17 = -[SABinary segmentWithCleanName:](v16, @"__TEXT_EXEC");
              char v18 = v24;
              if (v17) {
                char v18 = 1;
              }
              if ((v18 & 1) == 0)
              {
                if (addProcessInfoFromTailspin__onceToken != -1) {
                  dispatch_once(&addProcessInfoFromTailspin__onceToken, &__block_literal_global_227);
                }
                uint64_t v17 = +[SASegment segmentWithBinary:name:length:]((uint64_t)SASegment, v16, @"__TEXT_EXEC", 0);
                -[SABinary addSegment:](v16, v17);
              }
              uint64_t v19 = [v14 unsignedLongLongValue];
              BOOL v20 = [v26 intValue] == 0;
              if (v17) {
                +[SABinaryLoadInfo binaryLoadInfoWithSegment:loadAddress:isInKernelAddressSpace:exclave:](SABinaryLoadInfo, v17, v19, v20, 0);
              }
              else {
              uint64_t v21 = +[SABinaryLoadInfo binaryLoadInfoWithBinary:loadAddress:isInKernelAddressSpace:exclave:]((uint64_t)SABinaryLoadInfo, v16, v19, v20, 0);
              }
              [v25 addObject:v21];
            }
            ++v12;
          }
          while (v10 != v12);
          uint64_t v10 = [v8 countByEnumeratingWithState:&v27 objects:v31 count:16];
        }
        while (v10);
      }

      -[SATask addImageInfos:]((uint64_t)v5, v25);
      v5[73] = 1;

      id v4 = v23;
      uint64_t v6 = v22;
    }
  }
}

size_t __44__SASampleStore_addProcessInfoFromTailspin___block_invoke()
{
  return fwrite("Assuming 64-bit arm kernel binaries all have TEXT_EXEC segments...\n", 0x43uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
}

- (unint64_t)addKCDataStackshots:(id)a3 createSeparateSamplePerStackshot:(BOOL)a4
{
  BOOL v4 = a4;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  int v7 = 0;
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  locatiouint64_t n = (id *)&self->_startTime;
  p_endTime = (id *)&self->_endTime;
  p_timeWhenTransitionedToSamplingAllThreads = (id *)&self->_timeWhenTransitionedToSamplingAllThreads;
  p_timeWhenTransitionedToSamplingAllProcesses = (id *)&self->_timeWhenTransitionedToSamplingAllProcesses;
  unint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)&long long v11 = 134218242;
  long long v23 = v11;
  long long v28 = self;
  do
  {
    if (v8 >= objc_msgSend(v6, "length", v23)) {
      break;
    }
    if (v4 || !v7)
    {
      uint64_t v12 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:0.0];

      if ([(SASampleStore *)self dataStyle] == 1) {
        unint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v10 = [(NSMutableArray *)self->_sampleTimestamps count];
      }
      int v7 = (void *)v12;
    }
    char v30 = 0;
    id v13 = objc_alloc(MEMORY[0x1E4F1C9B8]);
    id v14 = v6;
    long long v15 = objc_msgSend(v13, "initWithBytesNoCopy:length:freeWhenDone:", objc_msgSend(v14, "bytes") + v8, objc_msgSend(v14, "length") - v8, 0);
    uint64_t v16 = -[SASampleStore _addKCDataStackshot:timestamp:sampleIndex:shouldSkipSampleOut:primaryDataIsKPerf:addStaticInfoOnly:]((uint64_t)self, v15, v7, v10, &v30, 0, 0);
    if (!v16 || v30)
    {
      unint64_t v29 = v10;
      int v18 = *__error();
      uint64_t v19 = _sa_logt();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        BOOL v20 = ", and should skip";
        if (!v30) {
          BOOL v20 = "";
        }
        *(_DWORD *)statfs buf = v23;
        uint64_t v32 = v16;
        __int16 v33 = 2080;
        uint64_t v34 = v20;
        _os_log_debug_impl(&dword_1BF22B000, v19, OS_LOG_TYPE_DEBUG, "KCData stackshot parsed %ld bytes%s", buf, 0x16u);
      }

      *__error() = v18;
      self = v28;
      unint64_t v10 = v29;
    }
    else
    {
      ++v9;
      if (v4)
      {
        if ([(SASampleStore *)self dataStyle] == 1)
        {
          startTime = self->_startTime;
          ++self->_numSamples;
          if (!startTime) {
            objc_storeStrong(location, v7);
          }
          objc_storeStrong(p_endTime, v7);
        }
        else
        {
          [(NSMutableArray *)self->_sampleTimestamps addObject:v7];
        }
        if (self->_nextSampleIsFirstSamplingAllThreads)
        {
          objc_storeStrong(p_timeWhenTransitionedToSamplingAllThreads, v7);
          self->_nextSampleIsFirstSamplingAllThreads = 0;
        }
        if (self->_nextSampleIsFirstSamplingAllProcesses)
        {
          objc_storeStrong(p_timeWhenTransitionedToSamplingAllProcesses, v7);
          self->_nextSampleIsFirstSamplingAllProcesses = 0;
        }
      }
    }
    v8 += v16;
  }
  while (v16);
  if (!v4 && v9)
  {
    if ([(SASampleStore *)self dataStyle] != 1)
    {
      [(NSMutableArray *)self->_sampleTimestamps addObject:v7];
      uint64_t v21 = self->_startTime;
      ++self->_numSamples;
      if (!v21) {
        objc_storeStrong(location, v7);
      }
      objc_storeStrong(p_endTime, v7);
    }
    if (self->_nextSampleIsFirstSamplingAllThreads)
    {
      objc_storeStrong(p_timeWhenTransitionedToSamplingAllThreads, v7);
      self->_nextSampleIsFirstSamplingAllThreads = 0;
    }
    if (self->_nextSampleIsFirstSamplingAllProcesses)
    {
      objc_storeStrong(p_timeWhenTransitionedToSamplingAllProcesses, v7);
      self->_nextSampleIsFirstSamplingAllProcesses = 0;
    }
  }

  return v9;
}

- (uint64_t)_addKCDataStackshot:(void *)a3 timestamp:(unint64_t)a4 sampleIndex:(unsigned char *)a5 shouldSkipSampleOut:(unsigned int)a6 primaryDataIsKPerf:(char)a7 addStaticInfoOnly:
{
  uint64_t v350 = *MEMORY[0x1E4F143B8];
  id v12 = a2;
  id v13 = a3;
  id v315 = v12;
  if (!a1)
  {
    id v25 = 0;
    goto LABEL_19;
  }
  v316 = v13;
  if (!v12 || (unint64_t)[v12 length] <= 0xF)
  {
    int v14 = *__error();
    long long v15 = _sa_logt();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.isa) = 0;
      _os_log_impl(&dword_1BF22B000, v15, OS_LOG_TYPE_DEFAULT, "WARNING: No buffer", (uint8_t *)&buf, 2u);
    }
LABEL_15:

    *__error() = v14;
    goto LABEL_16;
  }
  unsigned int v312 = a6;
  id v16 = v12;
  uint64_t v17 = [v16 bytes];
  uint64_t v18 = [v16 length];
  char v304 = (__objc2_class *)v18;
  uint64_t v19 = (__objc2_class *)(v18 + v17);
  BOOL v20 = (int *)(v17 + 16);
  if (v17 + 16 > (unint64_t)(v18 + v17) || (uint64_t v21 = *(unsigned int *)(v17 + 4), (char *)v20 + v21 > (char *)v19))
  {
LABEL_13:
    int v14 = *__error();
    long long v15 = _sa_logt();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.isa) = 134217984;
      *(__objc2_class **)((char *)&buf.isa + 4) = v304;
      _os_log_error_impl(&dword_1BF22B000, v15, OS_LOG_TYPE_ERROR, "Overran kcdata buffer (length %lu)", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_15;
  }
  uint64_t v22 = (_DWORD *)v17;
  while (*v22 != -242132755)
  {
    long long v23 = (char *)v22 + v21;
    char v24 = v23 + 32;
    if (v23 + 32 <= (char *)v19)
    {
      uint64_t v22 = v23 + 16;
      uint64_t v21 = *((unsigned int *)v23 + 5);
      if (&v24[v21] <= (char *)v19) {
        continue;
      }
    }
    goto LABEL_13;
  }
  char v297 = a7;
  obuint64_t j = a3;
  unint64_t v269 = a4;
  uint64_t v281 = (int *)v17;
  v340 = (int *)v17;
  unint64_t v341 = v18 + v17;
  if ((v312 & 1) == 0)
  {
    uint64_t v27 = *(void *)(a1 + 360);
    *(void *)(a1 + 352) |= 1uLL;
    if (!v27) {
      *(void *)(a1 + 360) = 2;
    }
  }
  long long v28 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA60]), "initWithCapacity:", objc_msgSend(*(id *)(a1 + 112), "count"));
  long long v336 = 0u;
  long long v337 = 0u;
  long long v338 = 0u;
  long long v339 = 0u;
  uint64_t v313 = a1;
  id v29 = *(id *)(a1 + 112);
  uint64_t v30 = [v29 countByEnumeratingWithState:&v336 objects:v347 count:16];
  if (v30)
  {
    uint64_t v31 = *(void *)v337;
    do
    {
      for (uint64_t i = 0; i != v30; ++i)
      {
        if (*(void *)v337 != v31) {
          objc_enumerationMutation(v29);
        }
        uint64_t v33 = *(void *)(*((void *)&v336 + 1) + 8 * i);
        if (v33 && *(_DWORD *)(v33 + 32))
        {
          uint64_t v34 = objc_msgSend(NSNumber, "numberWithUnsignedInt:");
          [v28 setObject:v33 forKeyedSubscript:v34];
        }
      }
      uint64_t v30 = [v29 countByEnumeratingWithState:&v336 objects:v347 count:16];
    }
    while (v30);
  }

  id v290 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  uint64_t v280 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  if (v312)
  {
    v282 = 0;
    uint64_t v35 = v281;
    goto LABEL_125;
  }
  id v36 = 0;
  char v37 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  unsigned int v40 = 0;
  LOBYTE(v41) = 0;
  int v42 = 0;
  p_int cache = &buf.cache;
  uint64_t v305 = -1;
  int v44 = v281;
  while (1)
  {
    uint64_t v45 = v44[1];
    if ((char *)v20 + v45 > (char *)v19 || (int v46 = *v44, *v44 == -242132755))
    {
LABEL_123:
      id v36 = v36;
      v282 = v36;
      goto LABEL_124;
    }
    if ((v46 & 0xFFFFFFF0) == 0x20) {
      int v47 = 17;
    }
    else {
      int v47 = *v44;
    }
    if ((v47 - 1) >= 6) {
      int v48 = (uint64_t *)(v44 + 4);
    }
    else {
      int v48 = (uint64_t *)(v44 + 12);
    }
    if (v41)
    {
      LOBYTE(v41) = v47 != 20 || v42 != *((void **)v44 + 1);
      goto LABEL_122;
    }
    LOBYTE(v41) = 0;
    if (v47 > 2308)
    {
      if (v47 != 2309 && v47 != 2352 && v47 != 2368) {
        goto LABEL_122;
      }
      LOBYTE(v41) = 0;
      uint64_t v55 = *v48;
LABEL_67:
      uint64_t v305 = v55;
      goto LABEL_122;
    }
    if (v47 == 17) {
      break;
    }
    if (v47 == 19)
    {
      if (v45 < 4 || v46 != 19) {
        goto LABEL_511;
      }
      int v59 = v44[4];
      if ((v59 == 2353 || v59 == 2307) && (v37 & 1) == 0)
      {
        LOBYTE(v41) = 0;
        char v37 = 1;
        uint64_t v38 = *((void *)v44 + 1);
      }
      else
      {
        if (v37) {
          int v42 = (void *)*((void *)v44 + 1);
        }
        LOBYTE(v41) = v37;
      }
    }
    else if (v47 == 20)
    {
      if (*((void *)v44 + 1) != v38)
      {
        LOBYTE(v41) = 0;
        goto LABEL_122;
      }
      if (v40 && v39 && v305 != -1)
      {
        uint64_t v291 = p_cache;
        __ptr = v42;
        id context = v36;
        if (!v36)
        {
          id v49 = v39;
          id context = objc_alloc_init(MEMORY[0x1E4F1CA60]);
          uint64_t v39 = v49;
        }
        uint64_t v50 = v40;
        double v284 = v39;
        p_flags = &v39->flags;
        do
        {
          id v52 = [NSNumber numberWithInt:*p_flags];
          id v53 = [context objectForKey:v52];
          if (!v53)
          {
            id v53 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
            [context setObject:v53 forKey:v52];
          }
          uint64_t v54 = [NSNumber numberWithUnsignedLongLong:v305];
          [v53 addObject:v54];

          ++p_flags;
          --v50;
        }
        while (v50);
        id v36 = context;
        uint64_t v39 = v284;
        goto LABEL_106;
      }
      if (v39)
      {
        uint64_t v291 = p_cache;
        __ptr = v42;
LABEL_106:
        free(v39);
        LOBYTE(v41) = 0;
        unsigned int v40 = 0;
        uint64_t v39 = 0;
        uint64_t v38 = 0;
        char v37 = 0;
        uint64_t v305 = -1;
        p_int cache = v291;
        int v42 = __ptr;
        goto LABEL_122;
      }
      LOBYTE(v41) = 0;
      unsigned int v40 = 0;
      uint64_t v38 = 0;
      char v37 = 0;
      uint64_t v55 = -1;
      goto LABEL_67;
    }
LABEL_122:
    int v44 = (int *)((char *)v20 + v44[1]);
    BOOL v20 = v44 + 4;
    if (v44 + 4 > (int *)v19) {
      goto LABEL_123;
    }
  }
  if (v46 != 17 && (v46 & 0xFFFFFFF0) != 0x20) {
    goto LABEL_511;
  }
  unint64_t v56 = *((void *)v44 + 1);
  if (!v56)
  {
    if (v45) {
      goto LABEL_511;
    }
    unint64_t v57 = HIDWORD(v56);
    if (v46 == 17)
    {
LABEL_114:
      LOBYTE(v41) = 0;
      if ((int)v57 <= 2313)
      {
        if ((v57 - 48) < 2 || v57 == 2074) {
          goto LABEL_122;
        }
        if (v57 == 2311)
        {
          unsigned int v60 = 4;
LABEL_92:
          if (((v57 == 2311) & v37) == 1)
          {
            uint64_t v283 = *((void *)v44 + 1);
            uint64_t v285 = v38;
            uint64_t v292 = p_cache;
            __ptra = v42;
            contexta = v36;
            BOOL v62 = v56 == 0;
            uint64_t v39 = (__objc2_class_ro *)malloc_type_calloc(v283, 4uLL, 0x100004052888210uLL);
            unsigned int v41 = 0;
            if (v62)
            {
              unsigned int v40 = 0;
              char v37 = 1;
              id v36 = contexta;
              p_int cache = v292;
              int v42 = __ptra;
              uint64_t v38 = v285;
            }
            else
            {
              uint64_t v63 = 0;
              uint64_t v64 = (__objc2_class *)MEMORY[0x1E4F143A8];
              p_int cache = v292;
              int v42 = __ptra;
              uint64_t v38 = v285;
              do
              {
                buf.isa = v64;
                buf.superclass = (__objc2_class *)3221225472;
                buf.int cache = __SAKCDataReadAheadDonatingUniquePids_block_invoke;
                buf.vtable = &__block_descriptor_40_e13_v20__0I8r_i12l;
                *(uint32_t *)((char *)&v39->flags + v63) = *(_DWORD *)((char *)v48 + v41);
                v63 += 4;
                v41 += v60;
              }
              while (4 * v283 != v63);
              LOBYTE(v41) = 0;
              buf.info = v39;
              char v37 = 1;
              unsigned int v40 = v283;
              id v36 = contexta;
            }
          }
          else
          {
            LOBYTE(v41) = 0;
          }
          goto LABEL_122;
        }
      }
      else if ((v57 - 2314) < 4 || v57 == 2369)
      {
        goto LABEL_122;
      }
    }
    unsigned int v60 = 0;
    goto LABEL_92;
  }
  if (v46 != 17)
  {
    unsigned int v61 = v45 - (*v44 & 0xF);
    if (v45 < (*v44 & 0xFu)) {
      goto LABEL_511;
    }
    if (v61 < v56) {
      goto LABEL_511;
    }
    unsigned int v60 = v61 / v56;
    if (v61 % v56) {
      goto LABEL_511;
    }
    unint64_t v57 = HIDWORD(v56);
    goto LABEL_92;
  }
  v282 = 0;
  unint64_t v57 = HIDWORD(v56);
  if (SHIDWORD(v56) <= 2310)
  {
    switch(HIDWORD(v56))
    {
      case 0x30:
        unsigned int v58 = 20;
        break;
      case 0x31:
        unsigned int v58 = 24;
        break;
      case 0x81A:
LABEL_104:
        unsigned int v58 = 8;
        break;
      default:
        goto LABEL_124;
    }
  }
  else
  {
    switch(HIDWORD(v56))
    {
      case 0x907:
        unsigned int v58 = 4;
        break;
      case 0x908:
      case 0x909:
        goto LABEL_124;
      case 0x90A:
      case 0x90C:
        goto LABEL_104;
      case 0x90B:
      case 0x90D:
        unsigned int v58 = 16;
        break;
      default:
        if (HIDWORD(v56) != 2369) {
          goto LABEL_124;
        }
        unsigned int v58 = 48;
        break;
    }
  }
  if (v45 / v58 >= v56 && v45 % v56 <= 0xF) {
    goto LABEL_114;
  }
LABEL_511:
  v282 = 0;
LABEL_124:

  uint64_t v35 = v340;
  uint64_t v19 = (__objc2_class *)v341;
  BOOL v20 = v340 + 4;
LABEL_125:
  id v293 = objc_alloc_init(SAFrameIterator);
  [(SAFrameIterator *)v293 setBacktracer:2];
  if (v20 <= (int *)v19)
  {
    unsigned int v66 = 0;
    __ptrb = 0;
    int v67 = 0;
    uint64_t v68 = 0;
    int v69 = 0;
    uint64_t v70 = 0;
    BOOL v71 = 0;
    uint64_t v72 = 0;
    unint64_t v73 = v20;
    uint64_t v74 = v35;
    while (1)
    {
      uint64_t v75 = v74[1];
      if ((char *)v73 + v75 > (char *)v19 || (int v76 = *v74, *v74 == -242132755))
      {
LABEL_201:
        uint64_t v65 = 0;
        buf.isa = (__objc2_class *)v35;
        buf.superclass = v19;
        int v108 = v20;
        superclass = v19;
        isa = (__objc2_class *)v35;
        long long v267 = v66;
        while (1)
        {
          uint64_t isa_high = HIDWORD(isa->isa);
          if ((char *)v108 + isa_high > (char *)superclass || LODWORD(isa->isa) == -242132755)
          {
LABEL_211:
            uint64_t v270 = __ptrb;
            goto LABEL_212;
          }
          if (LODWORD(isa->isa) == 19 && LODWORD(isa->cache) == 2377)
          {
            if (!v65) {
              uint64_t v65 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:1];
            }
            if (-[SASampleStore parseKCDataExclavesContainer:exclaveInfo:primaryDataIsKPerf:](a1, &buf, v65, v312))
            {
              uint64_t v270 = __ptrb;
              uint64_t v279 = 0;
              goto LABEL_213;
            }
            isa = buf.isa;
            superclass = buf.superclass;
            uint64_t isa_high = HIDWORD(buf.isa->isa);
          }
          unsigned int v112 = (char *)isa + isa_high;
          isa = (__objc2_class *)(v112 + 16);
          buf.isa = (__objc2_class *)(v112 + 16);
          buf.superclass = superclass;
          int v108 = (int *)(v112 + 32);
          if (v112 + 32 > (char *)superclass) {
            goto LABEL_211;
          }
        }
      }
      int v77 = (v76 & 0xFFFFFFF0) == 0x20 ? 17 : *v74;
      if ((v77 - 1) > 5) {
        break;
      }
      uint64_t v78 = (__objc2_class *)(v74 + 12);
      unsigned int v79 = v74[2] & 0xF;
      BOOL v80 = v75 >= v79;
      int v81 = v75 - v79;
      if (!v80) {
        int v81 = 0;
      }
      int v82 = v81 - 32;
      if (v71)
      {
LABEL_180:
        BOOL v71 = v77 != 20 || v72 != *((void *)v74 + 1);
        goto LABEL_183;
      }
LABEL_137:
      BOOL v71 = 0;
      if (v77 > 2356)
      {
        if (v77 == 2357)
        {
          if (v67)
          {
            BOOL v71 = 0;
            int v67 = 1;
            int v69 = v78;
          }
          else
          {
            contextd = v70;
            uint64_t v287 = v68;
            unsigned int v307 = v66;
            uint64_t v272 = v72;
            int v94 = *__error();
            int v95 = _sa_logt();
            if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
            {
              int isa_low = SLOWORD(v78->isa);
              LODWORD(buf.isa) = 67109120;
              HIDWORD(buf.isa) = isa_low;
              _os_log_error_impl(&dword_1BF22B000, v95, OS_LOG_TYPE_ERROR, "Port label info %d not in port label container", (uint8_t *)&buf, 8u);
            }

            id v96 = __error();
            BOOL v71 = 0;
            int v67 = 0;
            *id v96 = v94;
            int v69 = v78;
            uint64_t v72 = v272;
            unsigned int v66 = v307;
            uint64_t v68 = v287;
            uint64_t v70 = contextd;
          }
        }
        else if (v77 == 2358)
        {
          if (*((unsigned char *)&v78->isa + (v82 - 1)))
          {
            int v271 = v67;
            uint64_t v277 = v69;
            contextc = v70;
            uint64_t v286 = v68;
            unsigned int v306 = v66;
            uint64_t v88 = v72;
            int v89 = *__error();
            int v90 = _sa_logt();
            if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.isa) = 0;
              _os_log_impl(&dword_1BF22B000, v90, OS_LOG_TYPE_DEFAULT, "WARNING: port name non NULL-terminated", (uint8_t *)&buf, 2u);
            }

            int v91 = __error();
            BOOL v71 = 0;
            int *v91 = v89;
            uint64_t v72 = v88;
            unsigned int v66 = v306;
            uint64_t v68 = v286;
            uint64_t v70 = contextc;
            int v69 = v277;
            int v67 = v271;
          }
          else if (v67)
          {
            BOOL v71 = 0;
            int v67 = 1;
            uint64_t v70 = v78;
          }
          else
          {
            uint64_t v274 = v72;
            uint64_t v278 = v69;
            uint64_t v288 = v68;
            unsigned int v309 = v66;
            int v101 = *__error();
            id v102 = _sa_logt();
            if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf.isa) = 136315138;
              *(__objc2_class **)((char *)&buf.isa + 4) = v78;
              _os_log_error_impl(&dword_1BF22B000, v102, OS_LOG_TYPE_ERROR, "Port name %s not in port label container", (uint8_t *)&buf, 0xCu);
            }

            id v103 = __error();
            BOOL v71 = 0;
            int v67 = 0;
            *id v103 = v101;
            uint64_t v70 = v78;
            uint64_t v72 = v274;
            int v69 = v278;
            unsigned int v66 = v309;
            uint64_t v68 = v288;
          }
        }
      }
      else if (v77 == 19)
      {
        if (v75 < 4 || v76 != 19) {
          goto LABEL_201;
        }
        if (v67) {
          uint64_t v92 = *((void *)v74 + 1);
        }
        else {
          uint64_t v92 = v72;
        }
        if ((v74[4] != 2356) | v67 & 1)
        {
          uint64_t v72 = v92;
          BOOL v71 = v67;
        }
        else
        {
          BOOL v71 = 0;
        }
        if (!((v74[4] != 2356) | v67 & 1))
        {
          uint64_t v70 = 0;
          int v69 = 0;
          uint64_t v68 = *((void *)v74 + 1);
          int v67 = 1;
        }
      }
      else if (v77 == 20)
      {
        if ((v67 & (*((void *)v74 + 1) == v68)) == 1)
        {
          uint64_t v276 = v69;
          if (v69 && v70)
          {
            contextb = v70;
            unsigned int v83 = v66;
            unsigned int v84 = v66 + 1;
            int v85 = (char *)reallocf(__ptrb, 16 * (v66 + 1));
            if (v85)
            {
              BOOL v71 = 0;
              uint64_t v68 = 0;
              int v67 = 0;
              __ptrb = v85;
              __int16 v86 = &v85[16 * v83];
              *(void *)__int16 v86 = v276;
              *((void *)v86 + 1) = contextb;
              unsigned int v66 = v84;
              uint64_t v70 = 0;
              int v69 = 0;
            }
            else
            {
              uint64_t v275 = v72;
              int v104 = *__error();
              uint64_t v105 = _sa_logt();
              if (os_log_type_enabled(v105, OS_LOG_TYPE_FAULT))
              {
                LODWORD(buf.isa) = 67109120;
                HIDWORD(buf.isa) = v84;
                _os_log_fault_impl(&dword_1BF22B000, v105, OS_LOG_TYPE_FAULT, "unable to realloc %u port label infos", (uint8_t *)&buf, 8u);
              }

              BOOL v106 = __error();
              BOOL v71 = 0;
              uint64_t v70 = 0;
              int v69 = 0;
              uint64_t v68 = 0;
              int v67 = 0;
              __ptrb = 0;
              unsigned int v66 = 0;
              int *v106 = v104;
              uint64_t v72 = v275;
            }
          }
          else
          {
            int v97 = v70;
            unsigned int v308 = v66;
            uint64_t v273 = v72;
            int v98 = *__error();
            id v99 = _sa_logt();
            if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf.isa) = 67109378;
              HIDWORD(buf.isa) = v276 != 0;
              LOWORD(buf.superclass) = 2080;
              *(__objc2_class **)((char *)&buf.superclass + 2) = v97;
              _os_log_error_impl(&dword_1BF22B000, v99, OS_LOG_TYPE_ERROR, "Port label without both info (%d) and name (%s)", (uint8_t *)&buf, 0x12u);
            }

            uint64_t v100 = __error();
            BOOL v71 = 0;
            uint64_t v70 = 0;
            int v69 = 0;
            uint64_t v68 = 0;
            int v67 = 0;
            *uint64_t v100 = v98;
            uint64_t v72 = v273;
            unsigned int v66 = v308;
          }
        }
        else
        {
          BOOL v71 = 0;
        }
      }
LABEL_183:
      uint64_t v74 = (int *)((char *)v73 + v74[1]);
      unint64_t v73 = v74 + 4;
      if (v74 + 4 > (int *)v19) {
        goto LABEL_201;
      }
    }
    if (v77 > 2309)
    {
      if (v77 == 2312)
      {
        if (v75 == 32 && (v74[2] & 0x8F) == 0)
        {
          int v82 = 24;
          goto LABEL_179;
        }
      }
      else if (v77 == 2310 && v75 == 112 && (v74[2] & 0x8F) == 0)
      {
        int v82 = 104;
        goto LABEL_179;
      }
    }
    else
    {
      BOOL v87 = v77 == 17 || v77 == 19;
      int v82 = v74[1];
      if (v87) {
        goto LABEL_179;
      }
    }
    unsigned int v93 = v74[2] & 0xF;
    BOOL v80 = v75 >= v93;
    int v82 = v75 - v93;
    if (!v80) {
      int v82 = 0;
    }
LABEL_179:
    uint64_t v78 = (__objc2_class *)(v74 + 4);
    if (v71) {
      goto LABEL_180;
    }
    goto LABEL_137;
  }
  long long v267 = 0;
  __ptrb = 0;
  uint64_t v270 = 0;
  uint64_t v65 = 0;
  buf.isa = (__objc2_class *)v35;
  buf.superclass = v19;
LABEL_212:
  uint64_t v279 = (void *)[v65 copy];
LABEL_213:

  if (qword_1EB698EE0 != -1) {
    dispatch_once(&qword_1EB698EE0, &__block_literal_global_1668);
  }
  if (byte_1EB698E81 == 1)
  {
    int v113 = *__error();
    fwrite("\n\nNEXT STACKSHOT\n\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143D8]);
    *__error() = v113;
  }
  char v114 = v297;
  if (v20 > (int *)v19)
  {
    uint64_t v289 = 0;
    char v310 = 0;
    goto LABEL_219;
  }
  char v310 = 0;
  uint64_t v266 = 0;
  uint64_t v289 = 0;
  double v130 = *MEMORY[0x1E4F1CF78];
  while (2)
  {
    if ((char *)v20 + v35[1] > (char *)v19 || *v35 == -242132755) {
      goto LABEL_219;
    }
    contexte = (void *)MEMORY[0x1C18A6A20]();
    if (v310)
    {
      char v310 = 1;
      goto LABEL_504;
    }
    KCLogIter((unsigned int *)v35, (unint64_t)v19, 0);
    int v131 = *v35;
    unsigned int v132 = *v35 & 0xFFFFFFF0;
    if (v132 == 32) {
      int v133 = 17;
    }
    else {
      int v133 = *v35;
    }
    if ((v133 - 1) > 5)
    {
      char v139 = v297;
      uint64_t v140 = v312;
      id v141 = (unsigned __int16 **)__ptrb;
      if (v133 <= 2309)
      {
        if (v133 == 17 || v133 == 19)
        {
          unsigned int v135 = v35[1];
          unsigned int v138 = v135;
LABEL_269:
          uint64_t v134 = v35 + 4;
          goto LABEL_270;
        }
        goto LABEL_266;
      }
      if (v133 == 2310)
      {
        unsigned int v135 = v35[1];
        if (v135 == 112 && (v35[2] & 0x8F) == 0)
        {
          unsigned int v138 = 104;
          goto LABEL_269;
        }
      }
      else
      {
        if (v133 != 2312)
        {
LABEL_266:
          unsigned int v135 = v35[1];
          goto LABEL_267;
        }
        unsigned int v135 = v35[1];
        if (v135 == 32 && (v35[2] & 0x8F) == 0)
        {
          unsigned int v138 = 24;
          goto LABEL_269;
        }
      }
LABEL_267:
      unsigned int v142 = v35[2] & 0xF;
      BOOL v80 = v135 >= v142;
      unsigned int v138 = v135 - v142;
      if (!v80) {
        unsigned int v138 = 0;
      }
      goto LABEL_269;
    }
    uint64_t v134 = v35 + 12;
    unsigned int v135 = v35[1];
    unsigned int v136 = v35[2] & 0xF;
    BOOL v80 = v135 >= v136;
    unsigned int v137 = v135 - v136;
    if (!v80) {
      unsigned int v137 = 0;
    }
    unsigned int v138 = v137 - 32;
    char v139 = v297;
    uint64_t v140 = v312;
    id v141 = (unsigned __int16 **)__ptrb;
LABEL_270:
    char v310 = 0;
    if (v133 > 2311)
    {
      if (v133 <= 2331)
      {
        if (v133 == 2312)
        {
          if (v138 < 0x28) {
            goto LABEL_550;
          }
          if (qword_1EB698EE8 != -1) {
            dispatch_once(&qword_1EB698EE8, &__block_literal_global_1673);
          }
          if (byte_1EB698E82)
          {
LABEL_550:
            if (!uuid_is_null((const unsigned __int8 *)v134 + 8))
            {
              uint64_t v186 = -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, (uint64_t)(v134 + 1), *v134, -1);
              uint64_t v187 = *(void **)(a1 + 1024);
              *(void *)(a1 + 1024) = v186;
            }
          }
          else if (![v28 count] && !uuid_is_null((const unsigned __int8 *)v134 + 8))
          {
            uint64_t v219 = -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, (uint64_t)(v134 + 1), *v134, v134[4]);
            int v220 = *(void **)(a1 + 1024);
            *(void *)(a1 + 1024) = v219;
          }
          goto LABEL_502;
        }
        if (v133 == 2318)
        {
          if (!*(void *)(a1 + 496))
          {
            uint64_t v188 = SANSStringForCString(v134);
            id v189 = *(void **)(a1 + 496);
            *(void *)(a1 + 496) = v188;
          }
          goto LABEL_502;
        }
        if (v133 != 2319) {
          goto LABEL_503;
        }
        uint64_t v145 = a1;
        if (!*(void *)(a1 + 448))
        {
          uint64_t v146 = SANSStringForCString(v134);
          int v147 = *(void **)(a1 + 448);
          *(void *)(a1 + 448) = v146;

          uint64_t v145 = a1;
        }
        if (*(void *)(v145 + 192)) {
          goto LABEL_502;
        }
        if ([*(id *)(v145 + 448) rangeOfString:@"X86_64" options:1] == 0x7FFFFFFFFFFFFFFFLL)
        {
          if ([*(id *)(a1 + 448) rangeOfString:@"ARM64" options:1] == 0x7FFFFFFFFFFFFFFFLL)
          {
            if ([*(id *)(a1 + 448) rangeOfString:@"ARM" options:1] == 0x7FFFFFFFFFFFFFFFLL)
            {
              block[0] = MEMORY[0x1E4F143A8];
              block[1] = 3221225472;
              block[2] = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_250;
              block[3] = &unk_1E63F74F8;
              void block[4] = a1;
              if (qword_1EB698E88 != -1) {
                dispatch_once(&qword_1EB698E88, block);
              }
              goto LABEL_502;
            }
            char v310 = 0;
            uint64_t v223 = a1;
            uint64_t v224 = 12;
          }
          else
          {
            char v310 = 0;
            uint64_t v223 = a1;
            uint64_t v224 = 16777228;
          }
        }
        else
        {
          char v310 = 0;
          uint64_t v223 = a1;
          uint64_t v224 = 0x301000007;
        }
        *(void *)(v223 + 192) = v224;
        goto LABEL_503;
      }
      if (v133 <= 2374)
      {
        if (v133 != 2332)
        {
          if (v133 == 2338)
          {
            char v310 = 0;
            *(_DWORD *)(a1 + 200) = *(_DWORD *)v134;
          }
          goto LABEL_503;
        }
        if (!uuid_is_null((const unsigned __int8 *)v134 + 8))
        {
          long long v334 = 0u;
          long long v335 = 0u;
          long long v332 = 0u;
          long long v333 = 0u;
          id v205 = *(id *)(a1 + 104);
          uint64_t v206 = [v205 countByEnumeratingWithState:&v332 objects:v346 count:16];
          if (v206)
          {
            uint64_t v207 = *(void *)v333;
LABEL_441:
            uint64_t v208 = 0;
            while (1)
            {
              if (*(void *)v333 != v207) {
                objc_enumerationMutation(v205);
              }
              unsigned int v209 = *(void **)(*((void *)&v332 + 1) + 8 * v208);
              if ([v209 matchesUUID:v134 + 1 loadAddress:*v134]) {
                break;
              }
              if (v206 == ++v208)
              {
                uint64_t v206 = [v205 countByEnumeratingWithState:&v332 objects:v346 count:16];
                if (v206) {
                  goto LABEL_441;
                }
                goto LABEL_447;
              }
            }
            id v221 = v209;

            if (v221) {
              goto LABEL_472;
            }
          }
          else
          {
LABEL_447:
          }
          v222 = uuidForBytes((uint64_t)(v134 + 1));
          id v221 = +[SAKernelCache kernelCacheWithUUID:v222 loadAddress:*v134];

          [*(id *)(a1 + 104) addObject:v221];
LABEL_472:

          goto LABEL_502;
        }
        int v181 = *__error();
        __int16 v182 = _sa_logt();
        if (os_log_type_enabled(v182, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.isa) = 0;
          _os_log_error_impl(&dword_1BF22B000, v182, OS_LOG_TYPE_ERROR, "Kernel cache UUID is all zeros", (uint8_t *)&buf, 2u);
        }
LABEL_435:

        char v310 = 0;
        *__error() = v181;
        goto LABEL_503;
      }
      if (v133 == 2375)
      {
        if (!*(void *)(a1 + 480))
        {
          uint64_t v203 = SANSStringForCString(v134);
          uint64_t v204 = *(void **)(a1 + 480);
          *(void *)(a1 + 480) = v203;
        }
        goto LABEL_502;
      }
      if (v133 != 1503811591) {
        goto LABEL_503;
      }
      uint64_t v265 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:1000];
      long long v148 = v35 + 4;
      if (v35 + 4 > (int *)v19)
      {
LABEL_431:
        id v167 = 0;
        goto LABEL_432;
      }
      char v311 = 0;
      uint64_t v149 = 0;
      uint64_t v262 = 0;
      BOOL v150 = 0;
      uint64_t v151 = 0;
LABEL_310:
      uint64_t v152 = v35[1];
      if ((char *)v148 + v152 > (char *)v19 || (int v153 = *v35, *v35 == -242132755))
      {
LABEL_382:
        if (!v311) {
          goto LABEL_431;
        }
        int v178 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA60]), "initWithCapacity:", objc_msgSend(v311, "count"));
        buf.isa = (__objc2_class *)MEMORY[0x1E4F143A8];
        buf.superclass = (__objc2_class *)3221225472;
        buf.int cache = __SAKCDataReadAheadJetsamCoalitionInfo_block_invoke_2;
        buf.vtable = &unk_1E63F7BE0;
        buf.info = (__objc2_class_ro *)v265;
        id v179 = v178;
        id v349 = v179;
        [v311 enumerateKeysAndObjectsUsingBlock:&buf];
        id v180 = v349;
        id v167 = v179;

LABEL_384:
LABEL_432:

        char v310 = 0;
        uint64_t v289 = v167;
LABEL_503:
        uint64_t v35 = v340;
        uint64_t v19 = (__objc2_class *)v341;
LABEL_504:
        v227 = (char *)v35 + v35[1];
        uint64_t v35 = (int *)(v227 + 16);
        v340 = (int *)(v227 + 16);
        unint64_t v341 = (unint64_t)v19;
        BOOL v20 = (int *)(v227 + 32);
        char v114 = v297;
        if (v227 + 32 > (char *)v19)
        {
LABEL_219:
          int v115 = 1;
          goto LABEL_220;
        }
        continue;
      }
      if ((v153 & 0xFFFFFFF0) == 0x20) {
        int v154 = 17;
      }
      else {
        int v154 = *v35;
      }
      if ((v154 - 1) >= 6) {
        int v155 = v35 + 4;
      }
      else {
        int v155 = v35 + 12;
      }
      if (v150)
      {
        BOOL v150 = v154 != 20 || v151 != *((void *)v35 + 1);
        goto LABEL_381;
      }
      BOOL v150 = 0;
      if (v154 > 19)
      {
        if (v154 == 20)
        {
          BOOL v150 = 0;
          uint64_t v161 = *((void *)v35 + 1);
          uint64_t v162 = v262;
          BOOL v87 = v161 == v262;
          BOOL v163 = v161 != v262;
          if (v87) {
            uint64_t v162 = 0;
          }
          uint64_t v262 = v162;
          uint64_t v149 = v163 & v149;
        }
        else
        {
          if (v154 == 2309)
          {
            uint64_t v156 = v151;
            uint64_t v157 = v149;
            uint64_t v164 = [NSNumber numberWithInt:*((unsigned int *)v155 + 21)];
            uint64_t v165 = [NSNumber numberWithUnsignedLongLong:*v155];
            [v265 setObject:v164 forKeyedSubscript:v165];
          }
          else
          {
            if (v154 != 2352) {
              goto LABEL_381;
            }
            uint64_t v156 = v151;
            uint64_t v157 = v149;
            uint64_t v158 = [NSNumber numberWithInt:*((unsigned int *)v155 + 6)];
            uint64_t v159 = [NSNumber numberWithUnsignedLongLong:*v155];
            [v265 setObject:v158 forKeyedSubscript:v159];
          }
          BOOL v150 = 0;
          uint64_t v149 = v157;
          uint64_t v151 = v156;
        }
LABEL_381:
        uint64_t v35 = (int *)((char *)v148 + v35[1]);
        long long v148 = v35 + 4;
        if (v35 + 4 > (int *)v19) {
          goto LABEL_382;
        }
        goto LABEL_310;
      }
      if (v154 != 17)
      {
        if (v154 == 19)
        {
          if (v152 < 4 || v153 != 19) {
            goto LABEL_490;
          }
          int v160 = v35[4];
          if ((v160 == 2353 || v160 == 2307) && (v149 & 1) == 0)
          {
            BOOL v150 = 0;
            uint64_t v149 = 1;
            uint64_t v262 = *((void *)v35 + 1);
          }
          else
          {
            if (v149) {
              uint64_t v151 = *((void *)v35 + 1);
            }
            BOOL v150 = v149;
          }
        }
        goto LABEL_381;
      }
      if (v153 != 17 && (v153 & 0xFFFFFFF0) != 0x20) {
        goto LABEL_490;
      }
      unint64_t v166 = *((void *)v35 + 1);
      if (v166)
      {
        if (v153 == 17)
        {
          id v167 = 0;
          unint64_t v168 = HIDWORD(v166);
          if (SHIDWORD(v166) <= 2310)
          {
            switch(HIDWORD(v166))
            {
              case 0x30:
                unsigned int v169 = 20;
                break;
              case 0x31:
                unsigned int v169 = 24;
                break;
              case 0x81A:
LABEL_368:
                unsigned int v169 = 8;
                break;
              default:
                goto LABEL_384;
            }
          }
          else
          {
            switch(HIDWORD(v166))
            {
              case 0x907:
                unsigned int v169 = 4;
                break;
              case 0x908:
              case 0x909:
                goto LABEL_384;
              case 0x90A:
              case 0x90C:
                goto LABEL_368;
              case 0x90B:
              case 0x90D:
                unsigned int v169 = 16;
                break;
              default:
                if (HIDWORD(v166) != 2369) {
                  goto LABEL_384;
                }
                unsigned int v169 = 48;
                break;
            }
          }
          if (v152 / v169 < v166 || v152 % v166 > 0xF)
          {
LABEL_490:
            id v167 = 0;
            goto LABEL_384;
          }
LABEL_376:
          if ((v168 - 2311) <= 0x3A && ((1 << (v168 - 7)) & 0x400000000000079) != 0
            || (v168 - 48) < 2
            || (unsigned int v264 = 0, v168 == 2074))
          {
LABEL_380:
            BOOL v150 = 0;
            goto LABEL_381;
          }
        }
        else
        {
          unsigned int v170 = v152 - (*v35 & 0xF);
          if (v152 < (*v35 & 0xFu)) {
            goto LABEL_490;
          }
          if (v170 < v166) {
            goto LABEL_490;
          }
          unsigned int v264 = v170 / v166;
          if (v170 % v166) {
            goto LABEL_490;
          }
          unint64_t v168 = HIDWORD(v166);
        }
      }
      else
      {
        if (v152) {
          goto LABEL_490;
        }
        unint64_t v168 = HIDWORD(v166);
        if (v153 == 17) {
          goto LABEL_376;
        }
        unsigned int v264 = 0;
      }
      if (v168 == 2336)
      {
        if (!v311)
        {
          int v171 = *((void *)v35 + 1);
          uint64_t v172 = v151;
          uint64_t v173 = v149;
          char v311 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:v166];
          uint64_t v149 = v173;
          uint64_t v151 = v172;
          LODWORD(v166) = v171;
        }
        if (v166)
        {
          uint64_t v260 = v151;
          unsigned int v261 = v149;
          unsigned int v174 = 0;
          uint64_t v263 = MEMORY[0x1E4F143A8];
          uint64_t v175 = v166;
          do
          {
            v342[0] = v263;
            v342[1] = 3221225472;
            v342[2] = __SAKCDataReadAheadJetsamCoalitionInfo_block_invoke;
            v342[3] = &unk_1E63F7BB8;
            id v176 = v311;
            id v343 = v176;
            __SAKCDataReadAheadJetsamCoalitionInfo_block_invoke((uint64_t)v342, v177, (void *)((char *)v155 + v174));

            v174 += v264;
            --v175;
          }
          while (v175);
          BOOL v150 = 0;
          char v311 = v176;
          uint64_t v149 = v261;
          uint64_t v151 = v260;
          goto LABEL_381;
        }
      }
      goto LABEL_380;
    }
    break;
  }
  if (v133 > 49)
  {
    switch(v133)
    {
      case '2':
        int v190 = *((_DWORD *)v134 + 1);
        if (!v190 || !*(_DWORD *)v134)
        {
          int v181 = *__error();
          __int16 v182 = _sa_logt();
          if (os_log_type_enabled(v182, OS_LOG_TYPE_DEBUG))
          {
            int v225 = *(_DWORD *)v134;
            int v226 = *((_DWORD *)v134 + 1);
            LODWORD(buf.isa) = 67109376;
            HIDWORD(buf.isa) = v225;
            LOWORD(buf.superclass) = 1024;
            *(_DWORD *)((char *)&buf.superclass + 2) = v226;
            _os_log_debug_impl(&dword_1BF22B000, v182, OS_LOG_TYPE_DEBUG, "Bad timebase: %d/%d", (uint8_t *)&buf, 0xEu);
          }
          goto LABEL_435;
        }
        int v191 = *(_DWORD *)(a1 + 188);
        if (v191 && v190 != v191 || (int v192 = *(_DWORD *)(a1 + 184)) != 0 && *(_DWORD *)v134 != v192)
        {
          int v193 = *__error();
          v194 = _sa_logt();
          if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
          {
            int v195 = *(_DWORD *)(a1 + 188);
            int v196 = *(_DWORD *)v134;
            int v197 = *((_DWORD *)v134 + 1);
            buf.isa = (__objc2_class *)__PAIR64__(*(_DWORD *)(a1 + 184), 67109888);
            LOWORD(buf.superclass) = 1024;
            *(_DWORD *)((char *)&buf.superclass + 2) = v195;
            HIWORD(buf.superclass) = 1024;
            LODWORD(buf.cache) = v196;
            WORD2(buf.cache) = 1024;
            *(_DWORD *)((char *)&buf.cache + 6) = v197;
            _os_log_impl(&dword_1BF22B000, v194, OS_LOG_TYPE_DEFAULT, "WARNING: Changing mach timebase! %u/%u -> %u/%u", (uint8_t *)&buf, 0x1Au);
          }

          *__error() = v193;
        }
        *(void *)(a1 + 184) = *v134;
        if (!v266)
        {
          char v310 = 0;
          uint64_t v266 = 0;
          goto LABEL_503;
        }
        uint64_t v198 = v316;
        if (v316) {
          v316->superclass = (__objc2_class *)v266;
        }
        break;
      case '3':
        uint64_t v198 = v316;
        uint64_t v266 = *v134;
        if (!*(_DWORD *)(a1 + 188) || !*(_DWORD *)(a1 + 184)) {
          goto LABEL_502;
        }
        if (v316) {
          v316->superclass = (__objc2_class *)*v134;
        }
        break;
      case '5':
        if (v316)
        {
          char v310 = 0;
          *(double *)&v316[1].isa = (double)(unint64_t)*v134 / 1000000.0 - v130;
          goto LABEL_503;
        }
        goto LABEL_502;
      default:
        goto LABEL_503;
    }
    uint64_t v199 = [(__objc2_class *)v198 machAbsTime];
    uint64_t v200 = 0;
    uint64_t v201 = *(void *)(a1 + 184);
    if (v201)
    {
      BOOL v202 = v316;
      if (HIDWORD(v201))
      {
        uint64_t v200 = v199;
        if (v201 != HIDWORD(v201)) {
          uint64_t v200 = __udivti3();
        }
      }
    }
    else
    {
      BOOL v202 = v316;
    }
    if (v202)
    {
      char v310 = 0;
      *(double *)&v202->int cache = (double)(unint64_t)v200 / 1000000000.0;
      goto LABEL_503;
    }
    goto LABEL_502;
  }
  if (v133 == -568875622)
  {
    if ([*(id *)(a1 + 24) count])
    {
      char v310 = 0;
      *(void *)(a1 + 360) = 4;
    }
    else
    {
      int v210 = *__error();
      uint64_t v211 = _sa_logt();
      if (os_log_type_enabled(v211, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buf.isa) = 0;
        _os_log_debug_impl(&dword_1BF22B000, v211, OS_LOG_TYPE_DEBUG, "Delta before full, ignoring", (uint8_t *)&buf, 2u);
      }

      *__error() = v210;
      char v310 = 1;
    }
    goto LABEL_503;
  }
  if (v133 == 17)
  {
    if (v35 + 4 > (int *)v19 || (char *)v35 + v135 + 16 > (char *)v19 || v131 != 17 && v132 != 32) {
      goto LABEL_534;
    }
    unint64_t v183 = *((void *)v35 + 1);
    if (v183)
    {
      if (v131 == 17)
      {
        unint64_t v184 = HIDWORD(v183);
        if (SHIDWORD(v183) <= 2310)
        {
          switch(HIDWORD(v183))
          {
            case 0x30:
              unsigned int v185 = 20;
              break;
            case 0x31:
              unsigned int v185 = 24;
              break;
            case 0x81A:
LABEL_486:
              unsigned int v185 = 8;
              break;
            default:
              goto LABEL_534;
          }
        }
        else
        {
          switch(HIDWORD(v183))
          {
            case 0x907:
              unsigned int v185 = 4;
              break;
            case 0x908:
            case 0x909:
              goto LABEL_534;
            case 0x90A:
            case 0x90C:
              goto LABEL_486;
            case 0x90B:
            case 0x90D:
              unsigned int v185 = 16;
              break;
            default:
              if (HIDWORD(v183) != 2369) {
                goto LABEL_534;
              }
              unsigned int v185 = 48;
              break;
          }
        }
        if (v135 / v185 >= v183 && v135 % v183 < 0x10)
        {
LABEL_498:
          if ((v184 - 2311) <= 0x3A && ((1 << (v184 - 7)) & 0x400000000000079) != 0) {
            goto LABEL_502;
          }
          if ((v184 - 48) < 2) {
            goto LABEL_502;
          }
          unsigned int v212 = 0;
          if (v184 == 2074) {
            goto LABEL_502;
          }
LABEL_459:
          char v310 = 0;
          if v184 != 2328 || (v139) {
            goto LABEL_503;
          }
          if (*(void *)(a1 + 360) == 1)
          {
            int v243 = *__error();
            uint64_t v244 = _sa_logt();
            if (os_log_type_enabled(v244, OS_LOG_TYPE_ERROR))
            {
              uint64_t v245 = *(__objc2_class **)(v313 + 360);
              LODWORD(buf.isa) = 67109376;
              HIDWORD(buf.isa) = v183;
              LOWORD(buf.superclass) = 2048;
              *(__objc2_class **)((char *)&buf.superclass + 2) = v245;
              _os_log_error_impl(&dword_1BF22B000, v244, OS_LOG_TYPE_ERROR, "%d nonrunnable tasks, but _dataStyle %llu", (uint8_t *)&buf, 0x12u);
            }

            *__error() = v243;
            _SASetCrashLogMessage(3923, "%d nonrunnable tasks, but _dataStyle %llu", v246, v247, v248, v249, v250, v251, v183);
            _os_crash();
            __break(1u);
          }
          else if ((v140 & 1) == 0)
          {
            if (v183)
            {
              unsigned int v215 = 0;
              uint64_t v216 = MEMORY[0x1E4F143A8];
              uint64_t v217 = *((void *)v35 + 1);
              do
              {
                v328[0] = v216;
                v328[1] = 3221225472;
                v328[2] = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke;
                v328[3] = &unk_1E63F74D0;
                v328[4] = a1;
                long long v329 = v316;
                unint64_t v331 = v269;
                id v330 = v290;
                __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke((uint64_t)v328, v218, (void *)((char *)v134 + v215));

                v215 += v212;
                --v217;
              }
              while (v217);
            }
            goto LABEL_502;
          }
          int v252 = *__error();
          uint64_t v253 = _sa_logt();
          if (os_log_type_enabled(v253, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf.isa) = 67109120;
            HIDWORD(buf.isa) = v183;
            _os_log_error_impl(&dword_1BF22B000, v253, OS_LOG_TYPE_ERROR, "%d nonrunnable tasks when parsing stackshot in kperf", (uint8_t *)&buf, 8u);
          }

          *__error() = v252;
          _SASetCrashLogMessage(3924, "%d nonrunnable tasks when parsing stackshot in kperf", v254, v255, v256, v257, v258, v259, v183);
          uint64_t result = _os_crash();
          __break(1u);
          return result;
        }
      }
      else
      {
        unsigned int v213 = *v35 & 0xF;
        BOOL v80 = v135 >= v213;
        unsigned int v214 = v135 - v213;
        if (v80 && v214 >= v183)
        {
          unsigned int v212 = v214 / v183;
          if (!(v214 % v183))
          {
            unint64_t v184 = HIDWORD(v183);
            goto LABEL_459;
          }
        }
      }
    }
    else if (!v135)
    {
      unint64_t v184 = HIDWORD(v183);
      if (v131 != 17)
      {
        unsigned int v212 = 0;
        goto LABEL_459;
      }
      goto LABEL_498;
    }
LABEL_534:
    int v240 = *__error();
    v241 = _sa_logt();
    if (!os_log_type_enabled(v241, OS_LOG_TYPE_ERROR))
    {
LABEL_537:

      *__error() = v240;
      goto LABEL_538;
    }
    LODWORD(buf.isa) = 134218240;
    *(__objc2_class **)((char *)&buf.isa + 4) = v304;
    WORD2(buf.superclass) = 2048;
    *(__objc2_class **)((char *)&buf.superclass + 6) = (__objc2_class *)((char *)v35 - (char *)v281);
    int v242 = "Error parsing kcdata buffer at byte %ld of %lu: array is invalid";
LABEL_540:
    _os_log_error_impl(&dword_1BF22B000, v241, OS_LOG_TYPE_ERROR, v242, (uint8_t *)&buf, 0x16u);
    goto LABEL_537;
  }
  if (v133 != 19) {
    goto LABEL_503;
  }
  if (v35 + 4 > (int *)v19 || (char *)v35 + v135 + 16 > (char *)v19 || v132 == 32 || v131 != 19 || v135 <= 3)
  {
    int v240 = *__error();
    v241 = _sa_logt();
    if (!os_log_type_enabled(v241, OS_LOG_TYPE_ERROR)) {
      goto LABEL_537;
    }
    LODWORD(buf.isa) = 134218240;
    *(__objc2_class **)((char *)&buf.isa + 4) = v304;
    WORD2(buf.superclass) = 2048;
    *(__objc2_class **)((char *)&buf.superclass + 6) = (__objc2_class *)((char *)v35 - (char *)v281);
    int v242 = "Error parsing kcdata buffer at byte %ld of %lu: container is invalid";
    goto LABEL_540;
  }
  int v143 = v35[4];
  if (v143 <= 2355)
  {
    if (v143 != 2307 && v143 != 2353) {
      goto LABEL_479;
    }
    int v144 = [(SASampleStore *)a1 _parseKCDataTaskContainer:v316 timestampOfSample:v269 sampleIndex:v28 sharedCaches:v293 frameIterator:v140 primaryDataIsKPerf:v139 addStaticInfoOnly:v290 taskUniquePidsInThisSample:v280 taskPidsInThisSample:v282 importanceDonations:v289 rPidForJetsamCoalitionId:v267 port_label_info_array:v141 exclaveInfo:v279];
  }
  else
  {
    switch(v143)
    {
      case 2356:
LABEL_289:
        int v144 = SkipToContainerEnd(&v340, 0);
        break;
      case 2370:
        int v144 = -[SASampleStore _parseKCDataSharedCacheContainer:sharedCaches:](a1, (unsigned int **)&v340, v28);
        break;
      case 2377:
        goto LABEL_289;
      default:
LABEL_479:
        int v144 = SkipToContainerEnd(&v340, 1);
        break;
    }
  }
  if (!v144)
  {
LABEL_502:
    char v310 = 0;
    goto LABEL_503;
  }
LABEL_538:
  char v310 = 0;
  int v115 = 0;
  char v114 = v297;
LABEL_220:
  if (v270) {
    free(__ptrb);
  }
  if (!v115) {
    goto LABEL_510;
  }
  if ((unint64_t)(v340 + 4) > v341
    || (unint64_t)v340 + v340[1] + 16 > v341
    || *v340 != -242132755)
  {
    int v228 = *__error();
    v229 = _sa_logt();
    if (os_log_type_enabled(v229, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.isa) = 134217984;
      *(__objc2_class **)((char *)&buf.isa + 4) = v304;
      _os_log_error_impl(&dword_1BF22B000, v229, OS_LOG_TYPE_ERROR, "Overran kcdata buffer (length %lu)", (uint8_t *)&buf, 0xCu);
    }

    *__error() = v228;
LABEL_510:

LABEL_16:
    id v25 = 0;
    if (a5) {
      *a5 = 1;
    }
    goto LABEL_18;
  }
  if (!v312)
  {
    if ((~*(_DWORD *)(v313 + 408) & 0x582) == 0) {
      -[SASampleStore resampleTruncatedBacktraces](v313);
    }
    id v230 = objc_alloc(MEMORY[0x1E4F1CA80]);
    int v231 = [*(id *)(v313 + 8) allKeys];
    BOOL v232 = (void *)[v230 initWithArray:v231];

    [v232 minusSet:v290];
    long long v319 = 0u;
    long long v320 = 0u;
    long long v317 = 0u;
    long long v318 = 0u;
    id v119 = v232;
    uint64_t v233 = [v119 countByEnumeratingWithState:&v317 objects:v344 count:16];
    if (!v233)
    {
LABEL_528:

      goto LABEL_529;
    }
    uint64_t v234 = *(void *)v318;
LABEL_517:
    uint64_t v235 = 0;
    while (1)
    {
      if (*(void *)v318 != v234) {
        objc_enumerationMutation(v119);
      }
      char v236 = -[SASampleStore lastTaskWithUniquePid:]((void *)v313, [*(id *)(*((void *)&v317 + 1) + 8 * v235) unsignedLongLongValue]);
      int32_t v237 = [v236 exitTimestamp];
      if (!v237)
      {
        uint64_t v238 = *(void *)(v313 + 360);
        if (!v238) {
          goto LABEL_522;
        }
        if (v238 != 1)
        {
          -[SASampleStore task:exitedAtTimestamp:](v313, v236, v316);
          goto LABEL_522;
        }
      }

LABEL_522:
      if (v233 == ++v235)
      {
        uint64_t v239 = [v119 countByEnumeratingWithState:&v317 objects:v344 count:16];
        uint64_t v233 = v239;
        if (!v239) {
          goto LABEL_528;
        }
        goto LABEL_517;
      }
    }
  }
  if ((v114 & 1) == 0 && *(void *)(v313 + 360) == 3)
  {
    v326[0] = MEMORY[0x1E4F143A8];
    v326[1] = 3221225472;
    v326[2] = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_252;
    v326[3] = &__block_descriptor_40_e20_v24__0__SATask_8_B16l;
    v326[4] = v269;
    [(id)v313 enumerateTasks:v326];
    id v116 = objc_alloc(MEMORY[0x1E4F1CA80]);
    unsigned int v117 = [*(id *)(v313 + 16) allKeys];
    uint64_t v118 = (void *)[v116 initWithArray:v117];

    [v118 minusSet:v280];
    long long v324 = 0u;
    long long v325 = 0u;
    long long v322 = 0u;
    long long v323 = 0u;
    id v119 = v118;
    uint64_t v120 = [v119 countByEnumeratingWithState:&v322 objects:v345 count:16];
    if (v120)
    {
      uint64_t v121 = *(void *)v323;
      do
      {
        for (uint64_t j = 0; j != v120; ++j)
        {
          if (*(void *)v323 != v121) {
            objc_enumerationMutation(v119);
          }
          uint64_t v123 = -[SASampleStore lastTaskWithPid:]((void *)v313, [*(id *)(*((void *)&v322 + 1) + 8 * j) intValue]);
          unint64_t v124 = [v123 exitTimestamp];
          BOOL v125 = v124 == 0;

          if (v125)
          {
            buf.isa = 0;
            buf.superclass = &buf;
            buf.int cache = (void *)0x3032000000;
            buf.vtable = __Block_byref_object_copy__0;
            buf.info = (__objc2_class_ro *)__Block_byref_object_dispose__0;
            unint64_t v126 = [v123 taskStates];
            uint64_t v127 = [v126 lastObject];
            id v349 = [v127 endTimestamp];

            uint64_t v128 = [v123 threads];
            v321[0] = MEMORY[0x1E4F143A8];
            v321[1] = 3221225472;
            v321[2] = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_3;
            v321[3] = &unk_1E63F7D80;
            v321[4] = &buf;
            [v128 enumerateKeysAndObjectsUsingBlock:v321];

            if (buf.superclass[1].isa) {
              long long v129 = buf.superclass[1].isa;
            }
            else {
              long long v129 = v316;
            }
            -[SASampleStore task:exitedAtTimestamp:](v313, v123, v129);
            _Block_object_dispose(&buf, 8);
          }
        }
        uint64_t v120 = [v119 countByEnumeratingWithState:&v322 objects:v345 count:16];
      }
      while (v120);
    }
    goto LABEL_528;
  }
LABEL_529:

  if (a5) {
    *a5 = v310 & 1;
  }
  if ((v310 & 1) == 0) {
    objc_storeStrong((id *)(v313 + 376), obj);
  }
  id v25 = (char *)((char *)v340 - (char *)v281 + v340[1] + 16);
LABEL_18:
  id v13 = v316;
LABEL_19:

  return (uint64_t)v25;
}

- (unint64_t)addKCDataStackshot:(id)a3 returningTimestamp:(id *)a4
{
  id v6 = a3;
  int v7 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:0.0];
  if ([(SASampleStore *)self dataStyle] == 1) {
    unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = [(NSMutableArray *)self->_sampleTimestamps count];
  }
  char v13 = 0;
  unint64_t v9 = -[SASampleStore _addKCDataStackshot:timestamp:sampleIndex:shouldSkipSampleOut:primaryDataIsKPerf:addStaticInfoOnly:]((uint64_t)self, v6, v7, v8, &v13, 0, 0);
  if (v9) {
    BOOL v10 = v13 == 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    if ([(SASampleStore *)self dataStyle] == 1)
    {
      startTime = self->_startTime;
      ++self->_numSamples;
      if (!startTime) {
        objc_storeStrong((id *)&self->_startTime, v7);
      }
      objc_storeStrong((id *)&self->_endTime, v7);
    }
    else
    {
      [(NSMutableArray *)self->_sampleTimestamps addObject:v7];
    }
    if (self->_nextSampleIsFirstSamplingAllThreads)
    {
      objc_storeStrong((id *)&self->_timeWhenTransitionedToSamplingAllThreads, v7);
      self->_nextSampleIsFirstSamplingAllThreads = 0;
    }
    if (self->_nextSampleIsFirstSamplingAllProcesses)
    {
      objc_storeStrong((id *)&self->_timeWhenTransitionedToSamplingAllProcesses, v7);
      self->_nextSampleIsFirstSamplingAllProcesses = 0;
    }
  }
  if (a4) {
    *a4 = v7;
  }

  return v9;
}

- (unint64_t)addKCDataStackshot:(id)a3
{
  return [(SASampleStore *)self addKCDataStackshot:a3 returningTimestamp:0];
}

- (uint64_t)_parseKCDataTaskContainer:(void *)a3 timestampOfSample:(unint64_t)a4 sampleIndex:(void *)a5 sharedCaches:(void *)a6 frameIterator:(uint64_t)a7 primaryDataIsKPerf:(char)a8 addStaticInfoOnly:(void *)a9 taskUniquePidsInThisSample:(_OWORD *)a10 taskPidsInThisSample:(void *)a11 importanceDonations:(void *)a12 rPidForJetsamCoalitionId:(NSObject *)a13 port_label_info_array:(unsigned __int16 *)a14 exclaveInfo:(void *)a15
{
  LODWORD(v20) = a15;
  LOBYTE(v21) = (_BYTE)a12;
  uint64_t v22 = a10;
  uint64_t v571 = *MEMORY[0x1E4F143B8];
  long long v23 = a3;
  id v489 = a5;
  id v24 = a6;
  id v492 = a9;
  v504 = a10;
  id v25 = a11;
  id v491 = a12;
  id v487 = a15;
  uint64_t v26 = (*a2)[4];
  uint64_t v27 = *((void *)*a2 + 1);
  if (v26 != 2307 && v26 != 2353) {
    goto LABEL_637;
  }
  memset(v567, 0, 40);
  long long v566 = 0u;
  long long v565 = 0u;
  long long v564 = 0u;
  long long v563 = 0u;
  *(_OWORD *)v562 = 0u;
  memset(__dst, 0, 60);
  id v497 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  v498 = objc_alloc_init(MEMORY[0x1E4F28BD0]);
  long long v28 = *a2;
  BOOL v20 = (const unsigned __int8 *)a2[1];
  uint64_t v545 = 0;
  v546[0] = 0;
  long long v558 = 0u;
  long long v559 = 0u;
  uint64_t v560 = 0;
  id v29 = v28 + 2;
  id newValue = v23;
  id v488 = v24;
  v503 = v25;
  int v471 = v26;
  uint64_t v472 = v27;
  if (v28 + 2 > (void *)v20
    || (v30 = *((unsigned int *)v28 + 1), uint64_t v21 = (uint64_t)v29 + v30, (const unsigned __int8 *)((char *)v29 + v30) > v20))
  {
    int v31 = *__error();
    uint64_t v32 = _sa_logt();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
LABEL_6:
      v483 = 0;
      v495 = 0;
      v496 = 0;
      uint64_t v478 = 0;
      v479 = 0;
      v499 = 0;
      uint64_t context = 0;
      uint64_t v33 = 0;
      long long v23 = 0;
      v493 = 0;
      LODWORD(v477) = 0;
      id v25 = 0;
      LODWORD(__nel) = 0;
      self = 0;
LABEL_7:

      *__error() = v31;
      goto LABEL_8;
    }
    *(_WORD *)__objc2_class buf = 0;
    int v43 = "Bad kcdataiter";
LABEL_36:
    _os_log_error_impl(&dword_1BF22B000, v32, OS_LOG_TYPE_ERROR, v43, buf, 2u);
    goto LABEL_6;
  }
  if (*(_DWORD *)v28 != 19)
  {
    int v31 = *__error();
    uint64_t v32 = _sa_logt();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_6;
    }
    *(_WORD *)__objc2_class buf = 0;
    int v43 = "Not a container";
    goto LABEL_36;
  }
  if (v30 <= 3)
  {
    int v31 = *__error();
    uint64_t v32 = _sa_logt();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_6;
    }
    *(_WORD *)__objc2_class buf = 0;
    int v43 = "invalid container";
    goto LABEL_36;
  }
  int v44 = *((_DWORD *)v28 + 4);
  if (v44 != 2307 && v44 != 2353)
  {
    int v31 = *__error();
    uint64_t v32 = _sa_logt();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_6;
    }
    *(_WORD *)__objc2_class buf = 0;
    int v43 = "Not a task container";
    goto LABEL_36;
  }
  uint64_t v26 = v21 + 16;
  if (v21 + 16 > (unint64_t)v20)
  {
    uint64_t v45 = 0;
    v495 = 0;
    v496 = 0;
    uint64_t v478 = 0;
    int v46 = 0;
    uint64_t context = 0;
    uint64_t v33 = 0;
    long long v23 = 0;
    v493 = 0;
    LODWORD(v477) = 0;
    int v47 = 0;
    int v48 = 0;
    LODWORD(__nel) = 0;
    self = 0;
LABEL_32:
    v479 = v47;
    v483 = v45;
    id v25 = v48;
    v499 = v46;
    int v31 = *__error();
    uint64_t v32 = _sa_logt();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    *(_WORD *)__objc2_class buf = 0;
    id v49 = "Hit end of kcdata before end of container";
LABEL_34:
    _os_log_error_impl(&dword_1BF22B000, v32, OS_LOG_TYPE_ERROR, v49, buf, 2u);
    goto LABEL_7;
  }
  uint64_t v45 = 0;
  v495 = 0;
  v496 = 0;
  uint64_t v478 = 0;
  int v46 = 0;
  uint64_t context = 0;
  uint64_t v33 = 0;
  long long v23 = 0;
  v493 = 0;
  LODWORD(v477) = 0;
  int v47 = 0;
  int v48 = 0;
  LODWORD(__nel) = 0;
  self = 0;
  uint64_t v34 = 0;
  BOOL v50 = 0;
  v459 = v551;
  uint64_t v458 = v28[1];
  uint64_t v16 = 3221225472;
  id v25 = (char *)&v558 + 8;
  uint64_t v35 = (char *)&v559 + 8;
  uint64_t __src = (uint64_t)v553;
  unint64_t v461 = (unint64_t)v552;
  uint64_t v36 = 17;
  uint64_t p_superclass = SAMicrostackshotStatistics.superclass;
  id v52 = SAMicrostackshotStatistics.superclass;
  while (1)
  {
    uint64_t v53 = *(unsigned int *)(v21 + 4);
    if (v26 + v53 > (unint64_t)v20) {
      goto LABEL_32;
    }
    int v54 = *(_DWORD *)v21;
    if (*(_DWORD *)v21 == -242132755) {
      goto LABEL_32;
    }
    int v55 = (v54 & 0xFFFFFFF0) == 0x20 ? 17 : *(_DWORD *)v21;
    if ((v55 - 1) <= 5) {
      break;
    }
    if (v55 > 2309)
    {
      if (v55 == 2312)
      {
        if (v53 == 32 && (*(unsigned char *)(v21 + 8) & 0x8F) == 0)
        {
          unsigned int v60 = 24;
          goto LABEL_90;
        }
      }
      else if (v55 == 2310 && v53 == 112 && (*(unsigned char *)(v21 + 8) & 0x8F) == 0)
      {
        unsigned int v60 = 104;
        goto LABEL_90;
      }
    }
    else
    {
      BOOL v61 = v55 == 17 || v55 == 19;
      unsigned int v60 = *(_DWORD *)(v21 + 4);
      if (v61) {
        goto LABEL_90;
      }
    }
    unsigned int v64 = *(_DWORD *)(v21 + 8) & 0xF;
    BOOL v58 = v53 >= v64;
    unsigned int v60 = v53 - v64;
    if (!v58) {
      unsigned int v60 = 0;
    }
LABEL_90:
    unint64_t v56 = (void (*)(uint64_t, unsigned int, unsigned __int8 *))(v21 + 16);
    if (!v50) {
      goto LABEL_49;
    }
LABEL_91:
    if (v55 == 2310)
    {
      if ((*((unsigned char *)v56 + 65) & 0x20) != 0) {
        v546[0] = *(NSObject **)v56;
      }
LABEL_96:
      BOOL v50 = 1;
      goto LABEL_97;
    }
    if (v55 != 20) {
      goto LABEL_96;
    }
    BOOL v50 = v34 != *(void *)(v21 + 8);
LABEL_97:
    uint64_t v21 = v26 + *(unsigned int *)(v21 + 4);
    uint64_t v26 = v21 + 16;
    if (v21 + 16 > (unint64_t)v20) {
      goto LABEL_32;
    }
  }
  unint64_t v56 = (void (*)(uint64_t, unsigned int, unsigned __int8 *))(v21 + 48);
  unsigned int v57 = *(_DWORD *)(v21 + 8) & 0xF;
  BOOL v58 = v53 >= v57;
  int v59 = v53 - v57;
  if (!v58) {
    int v59 = 0;
  }
  unsigned int v60 = v59 - 32;
  if (v50) {
    goto LABEL_91;
  }
LABEL_49:
  if (v55 > 2338)
  {
    if (v55 <= 2351)
    {
      if (a7) {
        BOOL v62 = v45;
      }
      else {
        BOOL v62 = v56;
      }
      if (v55 == 2346) {
        uint64_t v63 = v56;
      }
      else {
        uint64_t v63 = (void (*)(uint64_t, unsigned int, unsigned __int8 *))v47;
      }
      if (v55 == 2339) {
        uint64_t v45 = v62;
      }
      else {
        int v47 = (unsigned int *)v63;
      }
      BOOL v50 = 0;
      goto LABEL_97;
    }
    switch(v55)
    {
      case 2352:
        BOOL v50 = 0;
        long long v23 = (uint64_t *)v56;
        break;
      case 2368:
        BOOL v50 = 0;
        uint64_t v33 = (uint64_t *)v56;
        break;
      case 2373:
        BOOL v50 = 0;
        LODWORD(v477) = *(_DWORD *)v56;
        break;
      default:
        goto LABEL_124;
    }
    goto LABEL_97;
  }
  if (v55 > 2308)
  {
    switch(v55)
    {
      case 2309:
        BOOL v50 = 0;
        uint64_t context = (uint64_t)v56;
        break;
      case 2312:
        if (v60 < 0x28) {
          goto LABEL_104;
        }
        if (p_superclass[477] != (__objc2_class *)-1)
        {
          v502 = v46;
          v483 = v45;
          unsigned int v132 = v25;
          int v133 = v48;
          uint64_t v22 = v47;
          __s1a = v35;
          uint64_t v470 = v34;
          v464 = v56;
          dispatch_once(&qword_1EB698EE8, &__block_literal_global_1673);
          unint64_t v56 = v464;
          uint64_t v35 = __s1a;
          id v52 = (__objc2_class **)(SAMicrostackshotStatistics + 8);
          uint64_t p_superclass = (__objc2_class **)(SAMicrostackshotStatistics + 8);
          uint64_t v36 = 17;
          uint64_t v134 = v132;
          uint64_t v34 = v470;
          int v47 = (unsigned int *)v22;
          uint64_t v45 = v483;
          int v48 = v133;
          id v25 = v134;
          int v46 = v502;
        }
        if (*((unsigned char *)v52 + 3714))
        {
LABEL_104:
          __s1b = v35;
          uint64_t v469 = v34;
          v483 = v45;
          v500 = v46;
          *(void *)&long long v558 = *(void *)v56;
          uint64_t v65 = (unsigned __int8 *)v25;
          unsigned int v66 = v25;
          int v67 = v48;
          uint64_t v22 = v47;
          uuid_copy(v65, (const unsigned __int8 *)v56 + 8);
          id v52 = (__objc2_class **)(SAMicrostackshotStatistics + 8);
          uint64_t p_superclass = (__objc2_class **)(SAMicrostackshotStatistics + 8);
          uint64_t v36 = 17;
          uint64_t v35 = __s1b;
          uint64_t v34 = v469;
          uint64_t v68 = v66;
          int v47 = (unsigned int *)v22;
          uint64_t v45 = v483;
          int v48 = v67;
          id v25 = v68;
          int v46 = v500;
          BOOL v50 = 0;
          *(void *)__s1b = -1;
          *((void *)__s1b + 1) = -1;
        }
        else
        {
          BOOL v50 = 0;
          long long v75 = *(_OWORD *)v56;
          long long v76 = *((_OWORD *)v56 + 1);
          uint64_t v560 = *((void *)v56 + 4);
          long long v559 = v76;
          long long v558 = v75;
        }
        goto LABEL_97;
      case 2337:
        BOOL v50 = 0;
        self = *(NSObject **)v56;
        break;
      default:
        goto LABEL_124;
    }
    goto LABEL_97;
  }
  if (v55 != 17)
  {
    if (v55 == 19)
    {
      if (v53 < 4 || v54 != 19) {
        goto LABEL_207;
      }
      uint64_t v34 = *(void *)(v21 + 8);
      goto LABEL_96;
    }
    if (v55 != 20)
    {
LABEL_124:
      BOOL v50 = 0;
      goto LABEL_97;
    }
    v499 = v46;
    if (*(void *)(v21 + 8) != v458)
    {
      v479 = v47;
      v483 = v45;
      id v25 = v48;
      int v31 = *__error();
      uint64_t v32 = _sa_logt();
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      *(_WORD *)__objc2_class buf = 0;
      id v49 = "Unmatched end container";
      goto LABEL_34;
    }
    id v25 = v48;
    LODWORD(v21) = v33 == 0;
    BOOL v37 = v23 == 0;
    if (!context && !v33 && !v23)
    {
      int v135 = *__error();
      unsigned int v136 = _sa_logt();
      if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v568 = 134217984;
        *(void *)&v568[4] = v472;
        unsigned int v137 = "No task struct for task container %llu, treating as an unknown container";
        unsigned int v138 = v136;
        uint32_t v139 = 12;
        goto LABEL_349;
      }
      goto LABEL_293;
    }
    v479 = v47;
    v483 = v45;
    if (!context)
    {
      int v38 = 1;
      goto LABEL_222;
    }
    int v140 = 0;
    uint64_t v141 = *(unsigned int *)(context + 84);
    if (*(unsigned char *)(context + 88)) {
      unsigned int v142 = (char *)(context + 88);
    }
    else {
      unsigned int v142 = 0;
    }
    uint64_t v144 = *(void *)context;
    int v143 = *(void (**)(uint64_t, unsigned int, unsigned __int8 *))(context + 8);
LABEL_245:
    LODWORD(v468) = v141;
    if ((int)v141 < -1 || v144 <= -2)
    {
      uint64_t v158 = v142;
      int v135 = *__error();
      unsigned int v136 = _sa_logt();
      if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v568 = 136315650;
        *(void *)&v568[4] = v158;
        *(_WORD *)&v568[12] = 1024;
        *(_DWORD *)&v568[14] = v468;
        *(_WORD *)&v568[18] = 2048;
        *(void *)&v568[20] = v144;
        _os_log_debug_impl(&dword_1BF22B000, v136, OS_LOG_TYPE_DEBUG, "Ignoring task with negative pid %s [%d] unique pid %llu", v568, 0x1Cu);
      }
      goto LABEL_293;
    }
    uint64_t v463 = (uint64_t)v33;
    v464 = v143;
    __s1 = v142;
    if (v23 && v144 == -1)
    {
      int v462 = v140;
      if (v141 == -1)
      {
        uint64_t v144 = --_parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo__next_fake_unique_pid;
        int v159 = *__error();
        int v160 = _sa_logt();
        if (os_log_type_enabled(v160, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v568 = 136315394;
          *(void *)&v568[4] = __s1;
          *(_WORD *)&v568[12] = 2048;
          *(void *)&v568[14] = v144;
          _os_log_impl(&dword_1BF22B000, v160, OS_LOG_TYPE_DEFAULT, "WARNING: transitioning task %s with no uniquepid and no pid, faking uniquepid:%llu", v568, 0x16u);
        }

        *__error() = v159;
      }
      else
      {
        BOOL v150 = objc_msgSend((id)a1, "tasksByPid", v34, v35, v36);
        uint64_t v151 = [NSNumber numberWithInt:v141];
        uint64_t v152 = [v150 objectForKeyedSubscript:v151];

        int v153 = v152;
        int v154 = [v152 lastObject];
        uint64_t v22 = v154;
        if (v154)
        {
          uint64_t v144 = [v154 uniquePid];
          int v155 = *__error();
          uint64_t v156 = _sa_logt();
          if (os_log_type_enabled(v156, OS_LOG_TYPE_INFO))
          {
            uint64_t v157 = [v22 debugDescription];
            *(_DWORD *)v568 = 136315650;
            *(void *)&v568[4] = __s1;
            *(_WORD *)&v568[12] = 2112;
            *(void *)&v568[14] = v157;
            *(_WORD *)&v568[22] = 2048;
            *(void *)&v568[24] = v144;
            _os_log_impl(&dword_1BF22B000, v156, OS_LOG_TYPE_INFO, "transitioning task %s with no uniquepid, assuming it's the predecessor with matching pid %@: using uniquepid %llu", v568, 0x20u);
          }
        }
        else
        {
          uint64_t v144 = v141 + 10000000000;
          int v155 = *__error();
          uint64_t v156 = _sa_logt();
          if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v568 = 136315394;
            *(void *)&v568[4] = __s1;
            *(_WORD *)&v568[12] = 2048;
            *(void *)&v568[14] = v144;
            _os_log_impl(&dword_1BF22B000, v156, OS_LOG_TYPE_DEFAULT, "WARNING: transitioning task %s with no uniquepid and no predecessor task, faking uniquepid %llu", v568, 0x16u);
          }
        }

        *__error() = v155;
      }
      uint64_t v141 = v468;
      int v140 = v462;
      if (__dst != (_OWORD *)v23) {
        memmove(__dst, v23, 0x3CuLL);
      }
      *(void *)&__dst[0] = v144;
      long long v23 = (uint64_t *)__dst;
    }
    if ((a7 & 1) == 0 && v144 == -1)
    {
      int v135 = *__error();
      unsigned int v136 = _sa_logt();
      BOOL v161 = os_log_type_enabled(v136, OS_LOG_TYPE_ERROR);
      if (v140)
      {
        long long v23 = newValue;
        uint64_t v39 = v488;
        if (v21)
        {
          if (!v161) {
            goto LABEL_294;
          }
          *(_DWORD *)v568 = 136315650;
          *(void *)&v568[4] = __s1;
          *(_WORD *)&v568[12] = 1024;
          *(_DWORD *)&v568[14] = v468;
          *(_WORD *)&v568[18] = 2048;
          *(void *)&v568[20] = v472;
          int v147 = "No uniquepid for transitioning task %s [%d] in task container %llu";
LABEL_289:
          long long v148 = v136;
          uint32_t v149 = 28;
        }
        else
        {
          if (!v161) {
            goto LABEL_294;
          }
          *(_DWORD *)v568 = 134217984;
          *(void *)&v568[4] = v472;
          int v147 = "No uniquepid for delta task in task container %llu";
LABEL_243:
          long long v148 = v136;
          uint32_t v149 = 12;
        }
        _os_log_error_impl(&dword_1BF22B000, v148, OS_LOG_TYPE_ERROR, v147, v568, v149);
        goto LABEL_294;
      }
      long long v23 = newValue;
      uint64_t v39 = v488;
      if (!v161) {
        goto LABEL_294;
      }
      *(_DWORD *)v568 = 136315650;
      *(void *)&v568[4] = __s1;
      *(_WORD *)&v568[12] = 1024;
      *(_DWORD *)&v568[14] = v468;
      *(_WORD *)&v568[18] = 2048;
      *(void *)&v568[20] = v472;
      int v147 = "No uniquepid for task %s [%d] in task container %llu";
      goto LABEL_289;
    }
    uint64_t __src = (uint64_t)v23;
    if (a7)
    {
      LODWORD(v23) = v140;
      uint64_t v162 = objc_msgSend(NSNumber, "numberWithInt:", v141, v35, v36);
      char v163 = [v504 containsObject:v162];

      if ((v163 & 1) == 0)
      {
        if (v468) {
          BOOL v164 = v144 == 0;
        }
        else {
          BOOL v164 = 1;
        }
        LODWORD(v15) = v164;
        uint64_t v165 = objc_msgSend(NSNumber, "numberWithInt:");
        [v504 addObject:v165];

        if (v23) {
          goto LABEL_607;
        }
        if (v562 != (uint8_t *)context) {
          memmove(v562, (const void *)context, 0x78uLL);
        }
        *(void *)v562 = -1;
        unint64_t v461 = *(void *)&v562[8] & 0x1FFCFF0C40;
        *(void *)&v562[8] &= 0x1FFCFF0C40uLL;
        HIDWORD(v565) = 0;
        DWORD1(v566) = 0;
        if (v483)
        {
LABEL_610:
          int v330 = *__error();
          unint64_t v331 = _sa_logt();
          if (os_log_type_enabled(v331, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v568 = 0;
            _os_log_error_impl(&dword_1BF22B000, v331, OS_LOG_TYPE_ERROR, "taskTerminatedThreadsInstructionCycles non-NULL when primary data is kperf", v568, 2u);
          }

          *__error() = v330;
          _SASetCrashLogMessage(4352, "taskTerminatedThreadsInstructionCycles non-NULL when primary data is kperf", v332, v333, v334, v335, v336, v337, v442);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v26 = v477;
          if (!v503)
          {
            unint64_t v166 = [(id)a1 osProductName];
            int v167 = [v166 isEqualToString:@"Mac OS X"];

            if (v167)
            {
              unint64_t v168 = [(id)a1 osBuildVersion];
              unsigned int v169 = v168;
              unsigned int v170 = @"18A230";
LABEL_310:
              uint64_t v182 = [v168 compare:v170 options:65];

              if (v182 == -1)
              {
                *(void *)&long long v565 = 0;
                *((void *)&v564 + 1) = 0;
              }
            }
            else
            {
              id v176 = [(id)a1 osProductName];
              int v177 = [v176 isEqualToString:@"iPhone OS"];

              if (v177)
              {
                unint64_t v168 = [(id)a1 osBuildVersion];
                unsigned int v169 = v168;
                unsigned int v170 = @"16A230";
                goto LABEL_310;
              }
              int v178 = [(id)a1 osProductName];
              int v179 = [v178 isEqualToString:@"Watch OS"];

              if (v179)
              {
                unint64_t v168 = [(id)a1 osBuildVersion];
                unsigned int v169 = v168;
                unsigned int v170 = @"16R230";
                goto LABEL_310;
              }
              id v180 = [(id)a1 osProductName];
              int v181 = [v180 isEqualToString:@"Apple TVOS"];

              if (v181)
              {
                unint64_t v168 = [(id)a1 osBuildVersion];
                unsigned int v169 = v168;
                unsigned int v170 = @"16J230";
                goto LABEL_310;
              }
            }
            uint64_t v173 = (uint64_t)v562;
LABEL_313:
            if (!__s1)
            {
              __s1 = 0;
              goto LABEL_320;
            }
            if (strcmp(__s1, "unknown")) {
              goto LABEL_320;
            }
            if (v173)
            {
              if (v562 != (uint8_t *)v173) {
                memmove(v562, (const void *)v173, 0x78uLL);
              }
              __s1 = 0;
              memset((char *)v567 + 8, 0, 32);
              uint64_t v173 = (uint64_t)v562;
              goto LABEL_320;
            }
            if (__src)
            {
              if (__dst != (_OWORD *)__src) {
                memmove(__dst, (const void *)__src, 0x3CuLL);
              }
              uint64_t v173 = 0;
              __s1 = 0;
              memset((char *)&__dst[1] + 12, 0, 32);
              uint64_t __src = (uint64_t)__dst;
LABEL_320:
              v543[0] = MEMORY[0x1E4F143A8];
              uint64_t v16 = 3221225472;
              v543[1] = 3221225472;
              v543[2] = __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke;
              v543[3] = &__block_descriptor_33_e38_B24__0__dyld_uuid_info_64_Q_16C__8_I16l;
              LODWORD(context) = v15;
              char v544 = v15;
              long long v23 = (uint64_t *)MEMORY[0x1C18A6C80](v543);
              LOBYTE(v183) = ((uint64_t (*)(uint64_t *, NSObject *, char *))v23[2])(v23, v493, (char *)&v545 + 4);
              v459 = v23;
              LOBYTE(v23) = ((uint64_t (*)(uint64_t *, NSObject *, uint64_t *))v23[2])(v23, v495, &v545);
              int v184 = (int)__nel;
              if (__nel)
              {
                if (v25)
                {
                  mergesort_b(v25, __nel, 0x38uLL, &__block_literal_global_301);
                  goto LABEL_323;
                }
LABEL_604:
                int v314 = *__error();
                id v315 = _sa_logt();
                if (os_log_type_enabled(v315, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v568 = 67109120;
                  *(_DWORD *)&v568[4] = __nel;
                  _os_log_error_impl(&dword_1BF22B000, v315, OS_LOG_TYPE_ERROR, "%d aot infos, but NULL array", v568, 8u);
                }

                *__error() = v314;
                _SASetCrashLogMessage(4457, "%d aot infos, but NULL array", v316, v317, v318, v319, v320, v321, (char)__nel);
                _os_crash();
                __break(1u);
LABEL_607:
                int v322 = *__error();
                long long v323 = _sa_logt();
                if (os_log_type_enabled(v323, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v568 = 0;
                  _os_log_error_impl(&dword_1BF22B000, v323, OS_LOG_TYPE_ERROR, "no task_struct when backfilling kperf", v568, 2u);
                }

                *__error() = v322;
                _SASetCrashLogMessage(4337, "no task_struct when backfilling kperf", v324, v325, v326, v327, v328, v329, v442);
                _os_crash();
                __break(1u);
                goto LABEL_610;
              }
LABEL_323:
              if (!*(void *)(a1 + 192))
              {
                int v306 = *__error();
                unsigned int v307 = _sa_logt();
                if (os_log_type_enabled(v307, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v568 = 0;
                  _os_log_error_impl(&dword_1BF22B000, v307, OS_LOG_TYPE_ERROR, "Unknown system architecture when parsing task", v568, 2u);
                }

                *__error() = v306;
                _SASetCrashLogMessage(4473, "Unknown system architecture when parsing task", v308, v309, v310, v311, v312, v313, v442);
                _os_crash();
                __break(1u);
                goto LABEL_604;
              }
              if (v26)
              {
                unsigned int v185 = [NSNumber numberWithUnsignedInt:v26];
                id v186 = [v489 objectForKeyedSubscript:v185];

                if (!v186)
                {
                  LODWORD(v20) = *__error();
                  uint64_t v26 = _sa_logt();
                  if (!os_log_type_enabled((os_log_t)v26, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_327;
                  }
                  goto LABEL_652;
                }
LABEL_339:
                BOOL v188 = 0;
LABEL_340:
                uint64_t v187 = v479;
LABEL_341:
                if (v187) {
                  goto LABEL_342;
                }
LABEL_354:
                uint64_t v191 = 0;
                int v192 = self;
                goto LABEL_355;
              }
LABEL_328:
              if (uuid_is_null((const unsigned __int8 *)&v558 + 8))
              {
                if ((v461 & 0x40000000) == 0)
                {
                  if ((v461 & 0x80000000) != 0)
                  {
                    int v193 = *__error();
                    v194 = _sa_logt();
                    if (os_log_type_enabled(v194, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)v568 = 136315394;
                      *(void *)&v568[4] = __s1;
                      *(_WORD *)&v568[12] = 1024;
                      *(_DWORD *)&v568[14] = v468;
                      _os_log_error_impl(&dword_1BF22B000, v194, OS_LOG_TYPE_ERROR, "Task %s [%d] is using non-system shared cache, but stackshot has no shared cache info", v568, 0x12u);
                    }

                    id v186 = 0;
                    BOOL v188 = 0;
                    *__error() = v193;
                    goto LABEL_340;
                  }
                  uint64_t v187 = v479;
                  if ((v461 & 0x20000000) != 0)
                  {
                    id v186 = 0;
                    BOOL v188 = (v464 & 8 | (unint64_t)__src) == 0;
                    if (v479) {
                      goto LABEL_342;
                    }
                    goto LABEL_354;
                  }
                  BOOL v188 = 0;
                  id v186 = 0;
                  if (!v173 || (context & 1) != 0) {
                    goto LABEL_341;
                  }
                  id v189 = *(id *)(a1 + 1024);
                  uint64_t v187 = v479;
                  id v186 = v189;
                  BOOL v188 = 0;
                  if (!v479) {
                    goto LABEL_354;
                  }
LABEL_342:
                  uint64_t v191 = *v187 | ((unint64_t)(v187[1] & 0xFFFFFF) << 32);
                  int v192 = self;
                  if ((v461 & 0x10000000) != 0) {
                    uint64_t v191 = SAArchitectureForTranslatedTask(v191);
                  }
LABEL_355:
                  v477 = v186;
                  if (v173)
                  {
                    BOOL v61 = v184 == 0;
                    char v195 = v461;
                    uint64_t v196 = (v461 >> 28) & 1;
                    if (!v61) {
                      LOBYTE(v196) = 0;
                    }
                    int v197 = -[SASampleStore taskForKCDataTask:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:]((void *)a1, v173, v493, HIDWORD(v545), v183, v495, v545, (char)v23, v191, newValue, v186, v196);
                    goto LABEL_367;
                  }
                  if (v21)
                  {
                    if (__src)
                    {
                      BOOL v61 = v184 == 0;
                      char v195 = v461;
                      uint64_t v198 = (v461 >> 28) & 1;
                      if (!v61) {
                        LOBYTE(v198) = 0;
                      }
                      int v197 = -[SASampleStore taskForKCDataTransitioningTask:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:]((void *)a1, __src, v493, HIDWORD(v545), v183, v495, v545, (char)v23, newValue, v186, v198);
                      goto LABEL_367;
                    }
LABEL_619:
                    int v354 = *__error();
                    v355 = _sa_logt();
                    if (os_log_type_enabled(v355, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)v568 = 0;
                      _os_log_error_impl(&dword_1BF22B000, v355, OS_LOG_TYPE_ERROR, "no task_struct, task_delta_struct, nor task_transitioning_struct", v568, 2u);
                    }

                    *__error() = v354;
                    _SASetCrashLogMessage(4531, "no task_struct, task_delta_struct, nor task_transitioning_struct", v356, v357, v358, v359, v360, v361, v442);
                    _os_crash();
                    __break(1u);
                  }
                  BOOL v61 = v184 == 0;
                  char v195 = v461;
                  uint64_t v199 = (v461 >> 28) & 1;
                  if (!v61) {
                    LOBYTE(v199) = 0;
                  }
                  int v197 = -[SASampleStore taskForKCDataDeltaTask:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:timestamp:sharedCache:needAOTInfo:]((void *)a1, *(void *)v463, v493, HIDWORD(v545), v183, v495, v545, (char)v23, newValue, v186, v199);
LABEL_367:
                  uint64_t v26 = (uint64_t)v197;
                  if (v188)
                  {
                    uint64_t v200 = [v197 sharedCache];

                    if (v200)
                    {
                      int v201 = *__error();
                      BOOL v202 = _sa_logt();
                      if (os_log_type_enabled(v202, OS_LOG_TYPE_FAULT))
                      {
                        v479 = [(id)v26 sharedCache];
                        selfb = [v479 debugDescription];
                        uint64_t v304 = [(id)v26 debugDescription];
                        *(_DWORD *)v568 = 138412546;
                        *(void *)&v568[4] = selfb;
                        *(_WORD *)&v568[12] = 2112;
                        *(void *)&v568[14] = v304;
                        uint64_t v305 = (void *)v304;
                        _os_log_fault_impl(&dword_1BF22B000, v202, OS_LOG_TYPE_FAULT, "shared cache previously %@, though task %@ now has no shared cache", v568, 0x16u);
                      }
                      *__error() = v201;
                      if (v26)
                      {
                        objc_setProperty_atomic((id)v26, v203, 0, 256);
                        goto LABEL_374;
                      }
                    }
                    else if (v26)
                    {
LABEL_374:
                      *(unsigned char *)(v26 + 72) = 1;
                    }
                  }
                  if (v491 && v192)
                  {
                    uint64_t v204 = [NSNumber numberWithUnsignedLongLong:v192];
                    id v205 = [v491 objectForKeyedSubscript:v204];

                    if (v205)
                    {
                      int v206 = [v205 intValue];
                      if (v206 != -1 && v26) {
                        *(_DWORD *)(v26 + 84) = v206;
                      }
                    }
                    else
                    {
                      int v207 = *__error();
                      uint64_t v208 = _sa_logt();
                      if (os_log_type_enabled(v208, OS_LOG_TYPE_DEFAULT))
                      {
                        [(id)v26 debugDescription];
                        unsigned int v209 = v480 = v207;
                        *(_DWORD *)v568 = 138412546;
                        *(void *)&v568[4] = v209;
                        *(_WORD *)&v568[12] = 2048;
                        *(void *)&v568[14] = v192;
                        _os_log_impl(&dword_1BF22B000, v208, OS_LOG_TYPE_DEFAULT, "WARNING: Task %@ has jetsam coalition id %llu, but stackshot has no info for that coalition", v568, 0x16u);

                        int v207 = v480;
                      }

                      *__error() = v207;
                    }
                  }
                  if (![*(id *)(a1 + 24) count]) {
                    goto LABEL_390;
                  }
                  int v210 = [(id)v26 taskStates];
                  if (![v210 count])
                  {
                    uint64_t v211 = [(id)v26 execTimestamp];
                    if (v211) {
                      goto LABEL_388;
                    }
                    if (a7)
                    {
                      v481 = *(void **)(a1 + 16);
                      uint64_t v217 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend((id)v26, "pid"));
                      uint64_t v218 = [v481 objectForKeyedSubscript:v217];
                      v479 = (unsigned int *)[v218 count];

                      if ((unint64_t)v479 >= 2 && v26) {
LABEL_412:
                      }
                        objc_setProperty_atomic((id)v26, v219, newValue, 224);
LABEL_390:
                      unsigned int v212 = v495;
                      LODWORD(v479) = (v195 & 0x10) != 0
                                   || v173 && *(_DWORD *)(v173 + 56)
                                   || (v21 & 1) == 0 && *(_DWORD *)(v463 + 48);
                      if (a8)
                      {
                        v483 = 0;
                        long long v23 = newValue;
                        uint64_t v39 = v488;
                        unsigned int v40 = v504;
                        goto LABEL_449;
                      }
                      if (a7)
                      {
                        if (v173)
                        {
                          if (a4)
                          {
                            uint64_t v213 = 0;
                            if (a4 == 0x7FFFFFFFFFFFFFFFLL) {
                              unint64_t v214 = 0x7FFFFFFFFFFFFFFFLL;
                            }
                            else {
                              unint64_t v214 = a4 - 1;
                            }
                            uint64_t v215 = *(void *)(a1 + 184);
                            if (v215)
                            {
                              uint64_t v216 = 0;
                              if (HIDWORD(v215))
                              {
                                uint64_t v213 = *(void *)(v173 + 16);
                                if (v215 == HIDWORD(v215))
                                {
                                  uint64_t v216 = *(void *)(v173 + 24);
                                }
                                else
                                {
                                  uint64_t v213 = __udivti3();
                                  uint64_t v216 = __udivti3();
                                }
                              }
                            }
                            else
                            {
                              uint64_t v216 = 0;
                            }
                            int v220 = *(_DWORD *)(v173 + 8);
                            -[SASampleStore backfillTask:lastSampleIndex:timestamp:haveSnap:terminatedThreadsUserTimeInNs:terminatedThreadsSystemTimeInNs:terminatedThreadsCycles:terminatedThreadsInstructions:suspendCount:pageins:isDarwinBG:isForeground:isBoosted:isDirty:haveWQFlags:wqExceededTotalThreadLimit:wqExceededConstrainedThreadLimit:haveMem:taskSizeInBytes:haveLatencyQos:latencyQos:]((void *)a1, (void *)v26, v214, newValue, 1, v213, v216, 0, 0, *(_DWORD *)(v173 + 56), *(_DWORD *)(v173 + 64), (v220 & 0x40) != 0, (v220 & 0x400) != 0, (v220 & 0x800) != 0, BYTE2(v220) & 1, (v220 & 0x80000) != 0, (v220 & 0x40000) != 0, (v220 & 0x20000) != 0, *(void *)(v173 + 40) != 0,
                              *(void *)(v173 + 40),
                              1,
                              *(_DWORD *)(v173 + 80));
                          }
                          goto LABEL_420;
                        }
LABEL_616:
                        int v346 = *__error();
                        v347 = _sa_logt();
                        if (os_log_type_enabled(v347, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)v568 = 0;
                          _os_log_error_impl(&dword_1BF22B000, v347, OS_LOG_TYPE_ERROR, "no task_struct when backfilling kperf", v568, 2u);
                        }

                        *__error() = v346;
                        _SASetCrashLogMessage(4579, "no task_struct when backfilling kperf", v348, v349, v350, v351, v352, v353, v443);
                        _os_crash();
                        __break(1u);
                        goto LABEL_619;
                      }
LABEL_420:
                      id v221 = [(id)v26 taskStates];
                      uint64_t v222 = [v221 lastObject];

                      selfa = (void *)v222;
                      if (v222)
                      {
                        uint64_t v223 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend((id)v26, "pid"));
                        uint64_t v224 = [v503 objectForKeyedSubscript:v223];
                        uint64_t v225 = *(void *)(a1 + 184);
                        if (v173)
                        {
                          char v226 = -[SATaskState correspondsToKCDataTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:](v222, v173, v483, v225, v224);

                          if (v226) {
                            goto LABEL_432;
                          }
LABEL_425:
                          int v228 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend((id)v26, "pid"));
                          v229 = [v503 objectForKeyedSubscript:v228];
                          long long v23 = newValue;
                          uint64_t v230 = +[SATaskState stateWithKCDataTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:]((uint64_t)SATaskState, v173, v483, *(void *)(a1 + 184), v229, newValue, newValue, a4, a4);
LABEL_434:
                          uint64_t v234 = (void *)v230;

                          uint64_t v39 = v488;
                          uint64_t v233 = selfa;
                          if (v26)
                          {
                            [*(id *)(v26 + 8) addObject:v234];
                            [*(id *)(v26 + 8) count];
                          }

LABEL_437:
                          if (context)
                          {
                            v483 = (void (*)(uint64_t, unsigned int, unsigned __int8 *))(id)v26;
                            uint64_t v235 = [v483 binaryLoadInfos];
                            [v39 setKernelBinaryLoadInfos:v235];
                          }
                          else
                          {
                            char v236 = [(id)v26 binaryLoadInfos];
                            [v39 setUserBinaryLoadInfos:v236];

                            if (v26) {
                              uint64_t v237 = *(unsigned char *)(v26 + 73) & 1;
                            }
                            else {
                              uint64_t v237 = 0;
                            }
                            [v39 setAssumeUserBinaryLoadInfosContainMainBinary:v237];
                            uint64_t v238 = [(id)v26 sharedCache];
                            [v39 setSharedCache:v238];

                            if ((v461 & 0x10000000) != 0)
                            {
                              uint64_t v239 = -[SASampleStore addressTranslationsForPid:](a1, [(id)v26 pid]);
                              [v39 setAddressTranslations:v239];
                            }
                            -[SASampleStore lastTaskWithPid:]((void *)a1, 0);
                            v483 = (void (*)(uint64_t, unsigned int, unsigned __int8 *))objc_claimAutoreleasedReturnValue();
                            if (!v483)
                            {
                              +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, 0, a7 << 63 >> 63, 0, 0);
                              v483 = (void (*)(uint64_t, unsigned int, unsigned __int8 *))objc_claimAutoreleasedReturnValue();
                              -[SASampleStore addTask:](a1, v483);
                            }
                          }
                          if (*(unsigned char *)(a1 + 220) && !v546[0])
                          {
                            int v240 = [(id)v26 mainThread];
                            v546[0] = [v240 threadId];
                          }
                          unsigned int v40 = v504;
                          unsigned int v212 = v495;
LABEL_449:
                          if (v493)
                          {
                            free(v493);
                            unsigned int v212 = v495;
                          }
                          HIDWORD(v545) = 0;
                          if (v212) {
                            free(v212);
                          }
                          LODWORD(v545) = 0;
                          if (v25) {
                            free(v25);
                          }
                          v241 = a2[1];
                          int v242 = (char *)*a2 + (*a2)[1];
                          int v243 = v242 + 16;
                          *a2 = (unsigned int *)(v242 + 16);
                          uint64_t v244 = v242 + 32;
                          id v25 = v503;
                          if (v244 > (char *)v241)
                          {
LABEL_456:
                            uint64_t v41 = 0;
LABEL_562:
                            if (!v41 && (a8 & 1) == 0)
                            {
                              if ((a7 & 1) == 0)
                              {
                                id v280 = objc_alloc(MEMORY[0x1E4F1CA80]);
                                uint64_t v281 = [(id)v26 threads];
                                v282 = [v281 allKeys];
                                uint64_t v283 = (void *)[v280 initWithArray:v282];

                                [v283 minusSet:v497];
                                long long v512 = 0u;
                                long long v513 = 0u;
                                long long v510 = 0u;
                                long long v511 = 0u;
                                id v284 = v283;
                                uint64_t v285 = [v284 countByEnumeratingWithState:&v510 objects:v556 count:16];
                                if (v285)
                                {
                                  uint64_t v286 = v285;
                                  uint64_t v287 = *(void *)v511;
                                  do
                                  {
                                    for (uint64_t i = 0; i != v286; ++i)
                                    {
                                      if (*(void *)v511 != v287) {
                                        objc_enumerationMutation(v284);
                                      }
                                      uint64_t v289 = *(void *)(*((void *)&v510 + 1) + 8 * i);
                                      id v290 = [(id)v26 threads];
                                      uint64_t v291 = [v290 objectForKeyedSubscript:v289];

                                      uint64_t v292 = [v291 exitTimestamp];

                                      if (v292) {
                                        BOOL v294 = 1;
                                      }
                                      else {
                                        BOOL v294 = v291 == 0;
                                      }
                                      if (!v294) {
                                        objc_setProperty_atomic(v291, v293, v23, 40);
                                      }
                                    }
                                    uint64_t v286 = [v284 countByEnumeratingWithState:&v510 objects:v556 count:16];
                                  }
                                  while (v286);
                                }
                              }
                              long long v508 = 0u;
                              long long v509 = 0u;
                              long long v506 = 0u;
                              long long v507 = 0u;
                              uint64_t v295 = v498;
                              uint64_t v296 = [v295 countByEnumeratingWithState:&v506 objects:v555 count:16];
                              if (v296)
                              {
                                uint64_t v297 = v296;
                                uint64_t v298 = *(void *)v507;
                                do
                                {
                                  for (uint64_t j = 0; j != v297; ++j)
                                  {
                                    if (*(void *)v507 != v298) {
                                      objc_enumerationMutation(v295);
                                    }
                                    uint64_t v300 = *(void *)(*((void *)&v506 + 1) + 8 * j);
                                    if ((unint64_t)[v295 countForObject:v300] >= 2)
                                    {
                                      uint64_t v301 = [(id)v26 dispatchQueues];
                                      v302 = [v301 objectForKeyedSubscript:v300];
                                      if (v302) {
                                        v302[24] = 1;
                                      }
                                    }
                                  }
                                  uint64_t v297 = [v295 countByEnumeratingWithState:&v506 objects:v555 count:16];
                                }
                                while (v297);
                              }

                              uint64_t v41 = 0;
                              uint64_t v39 = v488;
                              id v25 = v503;
                              unsigned int v40 = v504;
                            }
LABEL_590:
                            if (v496) {
                              free(v496);
                            }
                            if (v499) {
                              free(v499);
                            }
                            [v39 clearTaskData];

                            goto LABEL_21;
                          }
                          v495 = a14;
                          v493 = a13;
                          __nel = v515;
                          self = v523;
                          while (2)
                          {
                            if (&v244[v243[1]] > (char *)v241 || *v243 == -242132755) {
                              goto LABEL_456;
                            }
                            uint64_t v21 = (uint64_t)v39;
                            uint64_t context = MEMORY[0x1C18A6A20]();
                            KCLogIter(*a2, (unint64_t)a2[1], 0);
                            uint64_t v245 = *a2;
                            unsigned int v246 = **a2;
                            unsigned int v247 = v246 & 0xFFFFFFF0;
                            if ((v246 & 0xFFFFFFF0) == 0x20) {
                              int v248 = 17;
                            }
                            else {
                              int v248 = **a2;
                            }
                            uint64_t v249 = v245 + 4;
                            if ((v248 - 1) >= 6) {
                              BOOL v20 = (const unsigned __int8 *)(v245 + 4);
                            }
                            else {
                              BOOL v20 = (const unsigned __int8 *)(*a2 + 12);
                            }
                            if (v248 > 19)
                            {
                              if (v248 == 2332)
                              {
                                if (uuid_is_null(v20 + 8))
                                {
                                  int v255 = *__error();
                                  uint64_t v256 = _sa_logt();
                                  if (os_log_type_enabled(v256, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_WORD *)v568 = 0;
                                    _os_log_error_impl(&dword_1BF22B000, v256, OS_LOG_TYPE_ERROR, "Kernel cache UUID is all zeros", v568, 2u);
                                  }

                                  *__error() = v255;
                                }
                                else
                                {
                                  long long v541 = 0u;
                                  long long v542 = 0u;
                                  long long v539 = 0u;
                                  long long v540 = 0u;
                                  id v260 = *(id *)(a1 + 104);
                                  uint64_t v261 = [v260 countByEnumeratingWithState:&v539 objects:v557 count:16];
                                  if (v261)
                                  {
                                    uint64_t v262 = v261;
                                    uint64_t v263 = *(void *)v540;
LABEL_495:
                                    uint64_t v264 = 0;
                                    while (1)
                                    {
                                      if (*(void *)v540 != v263) {
                                        objc_enumerationMutation(v260);
                                      }
                                      uint64_t v265 = *(void **)(*((void *)&v539 + 1) + 8 * v264);
                                      if ([v265 matchesUUID:v20 + 8 loadAddress:*(void *)v20]) {
                                        break;
                                      }
                                      if (v262 == ++v264)
                                      {
                                        uint64_t v262 = [v260 countByEnumeratingWithState:&v539 objects:v557 count:16];
                                        if (v262) {
                                          goto LABEL_495;
                                        }
                                        goto LABEL_501;
                                      }
                                    }
                                    id v268 = v265;

                                    if (v268) {
                                      goto LABEL_516;
                                    }
                                  }
                                  else
                                  {
LABEL_501:
                                  }
                                  unint64_t v269 = uuidForBytes((uint64_t)(v20 + 8));
                                  id v268 = +[SAKernelCache kernelCacheWithUUID:v269 loadAddress:*(void *)v20];

                                  [*(id *)(a1 + 104) addObject:v268];
LABEL_516:

                                  long long v23 = newValue;
                                }
                              }
                              else if (v248 == 20)
                              {
                                uint64_t v303 = *((void *)v245 + 1);
                                if (v472 == v303)
                                {
                                  uint64_t v41 = 0;
                                  id v25 = v503;
                                  unsigned int v40 = v504;
                                  uint64_t v279 = (void *)context;
                                }
                                else
                                {
                                  int v277 = *__error();
                                  uint64_t v278 = _sa_logt();
                                  if (os_log_type_enabled(v278, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_DWORD *)v568 = 134218240;
                                    *(void *)&v568[4] = v472;
                                    *(_WORD *)&v568[12] = 2048;
                                    *(void *)&v568[14] = v303;
                                    _os_log_error_impl(&dword_1BF22B000, v278, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", v568, 0x16u);
                                  }
                                  uint64_t v41 = 7;
LABEL_556:
                                  uint64_t v39 = (void *)v21;
LABEL_560:
                                  id v25 = v503;
                                  unsigned int v40 = v504;
                                  uint64_t v279 = (void *)context;

                                  *__error() = v277;
                                }
                                goto LABEL_562;
                              }
                              goto LABEL_549;
                            }
                            uint64_t v22 = __dst;
                            unint64_t v250 = (unint64_t)a2[1];
                            if (v248 != 17)
                            {
                              if (v248 == 19)
                              {
                                uint64_t v251 = v245 + 4;
                                if ((unint64_t)(v245 + 4) > v250
                                  || (uint64_t v252 = v245[1], (unint64_t)v251 + v252 > v250)
                                  || v247 == 32
                                  || v246 != 19
                                  || v252 <= 3)
                                {
                                  int v277 = *__error();
                                  uint64_t v278 = _sa_logt();
                                  if (os_log_type_enabled(v278, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_DWORD *)v568 = 67109120;
                                    *(_DWORD *)&v568[4] = v471;
                                    _os_log_error_impl(&dword_1BF22B000, v278, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", v568, 8u);
                                  }
                                  uint64_t v41 = 1;
                                  goto LABEL_560;
                                }
                                if (*v249 == 2356)
                                {
                                  uint64_t v41 = SkipToContainerEnd((int **)a2, 0);
                                  id v25 = v503;
                                  unsigned int v40 = v504;
                                  uint64_t v253 = (void *)context;
                                }
                                else
                                {
                                  id v25 = v503;
                                  unsigned int v40 = v504;
                                  uint64_t v253 = (void *)context;
                                  if (*v249 == 2308) {
                                    uint64_t v254 = -[SASampleStore _parseKCDataThreadContainer:timestampOfSample:sampleIndex:task:kernelTask:frameIterator:mainThreadID:primaryDataIsKPerf:addStaticInfoOnly:threadIDsInThisTaskThisSample:dispatchQueueIDsInThisTaskThisSample:taskIsSuspended:waitInfos:numWaitInfos:turnstileInfos:numTurnstileInfos:port_label_info_array:exclaveInfo:](a1, (int **)a2, v23, a4, (void *)v26, v483, v39, v546[0], a7, a8, v497, v498, (char)v479, (uint64_t)v496, HIDWORD(v478), (uint64_t)v499, v478, v444, a13,
                                  }
                                             a14,
                                             v487);
                                  else {
                                    uint64_t v254 = SkipToContainerEnd((int **)a2, 1);
                                  }
                                  uint64_t v41 = v254;
                                }
                                if (v41) {
                                  goto LABEL_590;
                                }
                                goto LABEL_550;
                              }
                              goto LABEL_549;
                            }
                            if ((unint64_t)(v245 + 4) > v250) {
                              goto LABEL_554;
                            }
                            uint64_t v257 = v245[1];
                            if ((unint64_t)v245 + v257 + 16 > v250 || v246 != 17 && v247 != 32) {
                              goto LABEL_554;
                            }
                            size_t v15 = *((void *)v245 + 1);
                            if (v15)
                            {
                              if (v246 == 17)
                              {
                                size_t v258 = HIDWORD(v15);
                                if (SHIDWORD(v15) <= 2310)
                                {
                                  switch(HIDWORD(v15))
                                  {
                                    case 0x30:
                                      unsigned int v259 = 20;
                                      break;
                                    case 0x31:
                                      unsigned int v259 = 24;
                                      break;
                                    case 0x81A:
LABEL_520:
                                      unsigned int v259 = 8;
                                      break;
                                    default:
                                      goto LABEL_554;
                                  }
                                }
                                else
                                {
                                  switch(HIDWORD(v15))
                                  {
                                    case 0x907:
                                      unsigned int v259 = 4;
                                      break;
                                    case 0x908:
                                    case 0x909:
                                      goto LABEL_554;
                                    case 0x90A:
                                    case 0x90C:
                                      goto LABEL_520;
                                    case 0x90B:
                                    case 0x90D:
                                      unsigned int v259 = 16;
                                      break;
                                    default:
                                      if (HIDWORD(v15) != 2369) {
                                        goto LABEL_554;
                                      }
                                      unsigned int v259 = 48;
                                      break;
                                  }
                                }
                                if (v257 / v259 < v15
                                  || v257 % v15 >= 0x10)
                                {
LABEL_554:
                                  int v277 = *__error();
                                  uint64_t v278 = _sa_logt();
                                  if (os_log_type_enabled(v278, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_WORD *)v568 = 0;
                                    uint64_t v41 = 2;
                                    _os_log_error_impl(&dword_1BF22B000, v278, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: array is invalid", v568, 2u);
                                  }
                                  else
                                  {
                                    uint64_t v41 = 2;
                                  }
                                  goto LABEL_556;
                                }
LABEL_528:
                                if ((int)v258 > 2310)
                                {
                                  unsigned int v266 = 8;
                                  switch((int)v258)
                                  {
                                    case 2311:
                                      goto LABEL_549;
                                    case 2312:
                                    case 2313:
                                      goto LABEL_504;
                                    case 2314:
                                    case 2316:
                                      goto LABEL_531;
                                    case 2315:
                                    case 2317:
                                      unsigned int v266 = 16;
                                      goto LABEL_531;
                                    default:
                                      if (v258 != 2369) {
                                        goto LABEL_504;
                                      }
                                      unsigned int v266 = 48;
                                      break;
                                  }
                                  goto LABEL_533;
                                }
                                if ((v258 - 48) < 2 || v258 == 2074) {
                                  goto LABEL_549;
                                }
LABEL_504:
                                unsigned int v266 = 0;
                              }
                              else
                              {
                                unsigned int v267 = v257 - (**a2 & 0xF);
                                if (v257 < (**a2 & 0xF)) {
                                  goto LABEL_554;
                                }
                                if (v267 < v15) {
                                  goto LABEL_554;
                                }
                                unsigned int v266 = v267 / v15;
                                if (v267 % v15) {
                                  goto LABEL_554;
                                }
                                size_t v258 = HIDWORD(v15);
                              }
LABEL_531:
                              if (v258 == 2327)
                              {
                                if ((a8 & 1) == 0)
                                {
                                  if (a7) {
                                    goto LABEL_640;
                                  }
                                  if (*(void *)(a1 + 360) == 1) {
                                    goto LABEL_643;
                                  }
                                  if (v15)
                                  {
                                    int v273 = 0;
                                    uint64_t v274 = MEMORY[0x1E4F143A8];
                                    size_t v15 = v15;
                                    do
                                    {
                                      v514[0] = v274;
                                      v514[1] = v16;
                                      v515[0] = __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_313;
                                      v515[1] = &unk_1E63F75C8;
                                      v515[2] = a1;
                                      v520 = v546[0];
                                      id v516 = v497;
                                      id v517 = (id)v26;
                                      v518 = v23;
                                      unint64_t v521 = a4;
                                      v519 = v498;
                                      __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_313((uint64_t)v514, v275, (uint64_t *)&v20[v273]);

                                      v273 += v266;
                                      --v15;
                                    }
                                    while (v15);
                                  }
                                }
                                goto LABEL_549;
                              }
                              if (v258 != 2369)
                              {
LABEL_549:
                                uint64_t v39 = (void *)v21;
                                id v25 = v503;
                                unsigned int v40 = v504;
LABEL_550:
                                v241 = a2[1];
                                uint64_t v276 = (char *)*a2 + (*a2)[1];
                                int v243 = v276 + 16;
                                *a2 = (unsigned int *)(v276 + 16);
                                uint64_t v244 = v276 + 32;
                                if (v244 > (char *)v241) {
                                  goto LABEL_456;
                                }
                                continue;
                              }
LABEL_533:
                              if ((a8 & 1) == 0)
                              {
                                if (a7) {
                                  goto LABEL_628;
                                }
                                if (*(void *)(a1 + 360) == 1) {
                                  goto LABEL_631;
                                }
                                if (v15)
                                {
                                  int v270 = 0;
                                  uint64_t v271 = MEMORY[0x1E4F143A8];
                                  size_t v15 = v15;
                                  do
                                  {
                                    v522[0] = v271;
                                    v522[1] = v16;
                                    v523[0] = __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_309;
                                    v523[1] = &unk_1E63F75A0;
                                    v523[2] = a1;
                                    v529 = v546[0];
                                    unsigned int v535 = v266;
                                    int v536 = HIDWORD(v478);
                                    v530 = v496;
                                    v531 = a13;
                                    int v537 = v478;
                                    v532 = a14;
                                    v533 = v499;
                                    id v524 = v497;
                                    v525 = v23;
                                    unint64_t v534 = a4;
                                    id v526 = (id)v26;
                                    v527 = v483;
                                    char v538 = (char)v479;
                                    v528 = v498;
                                    __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_309((uint64_t)v522, v272, (uint64_t *)&v20[v270]);

                                    v270 += v266;
                                    --v15;
                                  }
                                  while (v15);
                                }
                              }
                              goto LABEL_549;
                            }
                            break;
                          }
                          if (v257) {
                            goto LABEL_554;
                          }
                          size_t v258 = HIDWORD(v15);
                          if (v246 == 17) {
                            goto LABEL_528;
                          }
                          goto LABEL_504;
                        }
                        if (v21)
                        {
                          int v231 = -[SATaskState correspondsToKCDataTransitioningTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:](v222, __src, v483, v225, v224);

                          if (v231)
                          {
LABEL_432:
                            uint64_t v233 = selfa;
                            long long v23 = newValue;
                            objc_setProperty_atomic(selfa, v227, newValue, 40);
                            selfa[7] = a4;
                            uint64_t v39 = v488;
                            goto LABEL_437;
                          }
LABEL_430:
                          int v228 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend((id)v26, "pid"));
                          v229 = [v503 objectForKeyedSubscript:v228];
                          long long v23 = newValue;
                          uint64_t v230 = +[SATaskState stateWithKCDataTransitioningTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:]((uint64_t)SATaskState, __src, (uint64_t)v483, *(void *)(a1 + 184), v229, newValue, newValue, a4, a4);
                          goto LABEL_434;
                        }
                        char v232 = -[SATaskState correspondsToKCDataDeltaTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:](v222, v463, v483, v225, v224);

                        if (v232) {
                          goto LABEL_432;
                        }
                      }
                      else
                      {
                        if (v173) {
                          goto LABEL_425;
                        }
                        if (v21) {
                          goto LABEL_430;
                        }
                      }
                      int v228 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend((id)v26, "pid"));
                      v229 = [v503 objectForKeyedSubscript:v228];
                      long long v23 = newValue;
                      uint64_t v230 = +[SATaskState stateWithKCDataDeltaTask:terminatedThreadsInstructionCycles:machTimebase:donatingUniquePids:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:]((uint64_t)SATaskState, v463, v483, *(void *)(a1 + 184), v229, newValue, newValue, a4, a4);
                      goto LABEL_434;
                    }
                    if (!*(unsigned char *)(a1 + 222) && !*(unsigned char *)(a1 + 223))
                    {

                      if (v26) {
                        goto LABEL_412;
                      }
                      goto LABEL_390;
                    }
LABEL_388:
                  }
                  goto LABEL_390;
                }
                id v190 = *(id *)(a1 + 1024);
              }
              else
              {
                -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, (uint64_t)&v558 + 8, v558, v560);
                id v190 = (id)objc_claimAutoreleasedReturnValue();
              }
              id v186 = v190;
              goto LABEL_339;
            }
LABEL_634:
            BOOL v20 = (const unsigned __int8 *)__dst;
            int v395 = *__error();
            v396 = _sa_logt();
            if (os_log_type_enabled(v396, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v568 = 136315138;
              *(void *)&v568[4] = __s1;
              _os_log_error_impl(&dword_1BF22B000, v396, OS_LOG_TYPE_ERROR, "no task nor transitioning task, but have p_comm %s", v568, 0xCu);
            }

            *__error() = v395;
            _SASetCrashLogMessage(4394, "no task nor transitioning task, but have p_comm %s", v397, v398, v399, v400, v401, v402, (char)__s1);
            _os_crash();
            __break(1u);
LABEL_637:
            int v403 = *__error();
            v404 = _sa_logt();
            if (os_log_type_enabled(v404, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v562 = 67109120;
              *(_DWORD *)&v562[4] = v26;
              _os_log_error_impl(&dword_1BF22B000, v404, OS_LOG_TYPE_ERROR, "bad container type %u", v562, 8u);
            }

            *__error() = v403;
            _SASetCrashLogMessage(4175, "bad container type %u", v405, v406, v407, v408, v409, v410, v26);
            _os_crash();
            __break(1u);
LABEL_640:
            int v411 = *__error();
            v412 = _sa_logt();
            if (os_log_type_enabled(v412, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v568 = 67109120;
              *(_DWORD *)&v568[4] = v15;
              _os_log_error_impl(&dword_1BF22B000, v412, OS_LOG_TYPE_ERROR, "%d nonrunnable tids when parsing stackshot in kperf", v568, 8u);
            }

            *__error() = v411;
            _SASetCrashLogMessage(4863, "%d nonrunnable tids when parsing stackshot in kperf", v413, v414, v415, v416, v417, v418, v15);
            _os_crash();
            __break(1u);
LABEL_643:
            int v419 = *__error();
            v420 = _sa_logt();
            if (os_log_type_enabled(v420, OS_LOG_TYPE_ERROR))
            {
              uint64_t v421 = *(void *)(a1 + 360);
              *(_DWORD *)v568 = 67109376;
              *(_DWORD *)&v568[4] = v15;
              *(_WORD *)&v568[8] = 2048;
              *(void *)((char *)v22 + 202) = v421;
              _os_log_error_impl(&dword_1BF22B000, v420, OS_LOG_TYPE_ERROR, "%d nonrunnable tids when dataStyle %llu", v568, 0x12u);
            }

            *__error() = v419;
            _SASetCrashLogMessage(4864, "%d nonrunnable tids when dataStyle %llu", v422, v423, v424, v425, v426, v427, v15);
            _os_crash();
            __break(1u);
LABEL_646:
            int v428 = *__error();
            v429 = _sa_logt();
            if (os_log_type_enabled(v429, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)__objc2_class buf = 0;
              _os_log_error_impl(&dword_1BF22B000, v429, OS_LOG_TYPE_ERROR, "multiple aot_info arrays for task", buf, 2u);
            }

            *__error() = v428;
            _SASetCrashLogMessage(2504, "multiple aot_info arrays for task", v430, v431, v432, v433, v434, v435, v442);
            _os_crash();
            __break(1u);
LABEL_649:
            int v183 = *__error();
            uint64_t v173 = _sa_logt();
            if (os_log_type_enabled((os_log_t)v173, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)__objc2_class buf = 0;
              _os_log_error_impl(&dword_1BF22B000, (os_log_t)v173, OS_LOG_TYPE_ERROR, "multiple text_exec_load_info arrays for task", buf, 2u);
            }

            *__error() = v183;
            _SASetCrashLogMessage(2487, "multiple text_exec_load_info arrays for task", v436, v437, v438, v439, v440, v441, v442);
            _os_crash();
            __break(1u);
LABEL_652:
            *(_DWORD *)v568 = 67109120;
            *(_DWORD *)&v568[4] = v477;
            _os_log_fault_impl(&dword_1BF22B000, (os_log_t)v26, OS_LOG_TYPE_FAULT, "No shared cache with id %u", v568, 8u);
LABEL_327:

            *__error() = (int)v20;
            int v184 = (int)__nel;
            goto LABEL_328;
          }
        }
        int v338 = *__error();
        long long v339 = _sa_logt();
        if (os_log_type_enabled(v339, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v568 = 0;
          _os_log_error_impl(&dword_1BF22B000, v339, OS_LOG_TYPE_ERROR, "importanceDonations non-NULL when primary data is kperf", v568, 2u);
        }

        *__error() = v338;
        _SASetCrashLogMessage(4353, "importanceDonations non-NULL when primary data is kperf", v340, v341, v342, v343, v344, v345, v442);
        _os_crash();
        __break(1u);
        goto LABEL_616;
      }
    }
    else
    {
      int v171 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", v144, v35, v36);
      int v172 = [v492 containsObject:v171];

      uint64_t v173 = context;
      if (!v172)
      {
        if (v468) {
          BOOL v174 = v144 == 0;
        }
        else {
          BOOL v174 = 1;
        }
        LODWORD(v15) = v174;
        uint64_t v175 = [NSNumber numberWithUnsignedLongLong:v144];
        [v492 addObject:v175];

        unint64_t v461 = (unint64_t)v464;
        uint64_t v26 = v477;
        goto LABEL_313;
      }
    }
    int v135 = *__error();
    unsigned int v136 = _sa_logt();
    if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v568 = 136315394;
      *(void *)&v568[4] = __s1;
      *(_WORD *)&v568[12] = 2048;
      *(void *)&v568[14] = v144;
      unsigned int v137 = "Already saw task %s unique pid %llu in this stackshot, ignoring second container";
      unsigned int v138 = v136;
      uint32_t v139 = 22;
LABEL_349:
      _os_log_error_impl(&dword_1BF22B000, v138, OS_LOG_TYPE_ERROR, v137, v568, v139);
    }
LABEL_293:
    long long v23 = newValue;
    uint64_t v39 = v488;
    goto LABEL_294;
  }
  if (v54 != 17 && (v54 & 0xFFFFFFF0) != 0x20) {
    goto LABEL_207;
  }
  unint64_t v69 = *(void *)(v21 + 8);
  if (!v69)
  {
    if (v53) {
      goto LABEL_207;
    }
    unint64_t v70 = HIDWORD(v69);
    if (v54 == 17) {
      goto LABEL_137;
    }
    uint64_t v22 = v56;
LABEL_118:
    uint64_t v73 = 0;
    goto LABEL_140;
  }
  if (v54 != 17)
  {
    unsigned int v74 = v53 - (*(_DWORD *)v21 & 0xF);
    if (v53 < (*(_DWORD *)v21 & 0xFu)) {
      goto LABEL_207;
    }
    if (v74 < v69) {
      goto LABEL_207;
    }
    uint64_t v73 = v74 / v69;
    if (v74 % v69) {
      goto LABEL_207;
    }
    uint64_t v22 = v56;
    unint64_t v70 = HIDWORD(v69);
LABEL_140:
    BOOL v50 = 0;
    if ((int)v70 <= 2332)
    {
      switch(v70)
      {
        case '0':
          goto LABEL_188;
        case '1':
          unint64_t v56 = (void (*)(uint64_t, unsigned int, unsigned __int8 *))v22;
          goto LABEL_194;
        case '9':
          int v449 = v73;
          __s1 = v35;
          uint64_t v468 = v34;
          v456 = v25;
          v479 = v47;
          v499 = v46;
          if (v48) {
            goto LABEL_646;
          }
          size_t v15 = *(void *)(v21 + 8);
          uint64_t v85 = *(void *)(v21 + 8);
          __int16 v86 = (char *)malloc_type_calloc(v15, 0x38uLL, 0x100004021716A34uLL);
          int v87 = v85;
          int v48 = v86;
          if (v85)
          {
            unsigned int v88 = 0;
            uint64_t v89 = 0;
            v551[3] = MEMORY[0x1E4F143A8];
            v551[4] = 3221225472;
            v551[5] = __ReadAheadTaskLevelInfo_block_invoke_1688;
            v551[6] = &__block_descriptor_40_e43_v20__0I8r__user64_dyld_aot_info_QQQ_32C__12l;
            v551[7] = v86;
            int v46 = v499;
            int v47 = v479;
            uint64_t v35 = __s1;
            uint64_t v34 = v468;
            id v25 = v456;
            uint64_t v36 = 17;
            uint64_t p_superclass = (__objc2_class **)(SAMicrostackshotStatistics + 8);
            id v52 = (__objc2_class **)(SAMicrostackshotStatistics + 8);
            do
            {
              int v90 = (char *)v22 + v88;
              int v91 = &v48[v89];
              long long v92 = *(_OWORD *)v90;
              long long v93 = *((_OWORD *)v90 + 1);
              long long v94 = *((_OWORD *)v90 + 2);
              *((void *)v91 + 6) = *((void *)v90 + 6);
              *((_OWORD *)v91 + 1) = v93;
              *((_OWORD *)v91 + 2) = v94;
              *(_OWORD *)int v91 = v92;
              v89 += 56;
              v88 += v449;
            }
            while (56 * v15 != v89);
            BOOL v50 = 0;
            LODWORD(__nel) = v87;
            goto LABEL_97;
          }
          LODWORD(__nel) = 0;
          BOOL v50 = 0;
          int v46 = v499;
          goto LABEL_206;
      }
      goto LABEL_97;
    }
    if ((int)v70 > 2349)
    {
      if (v70 != 2350)
      {
        if (v70 != 2369) {
          goto LABEL_97;
        }
        goto LABEL_181;
      }
      int v451 = v73;
      __s1 = v35;
      uint64_t v468 = v34;
      v456 = v25;
      v479 = v47;
      v483 = v45;
      v499 = v46;
      if (v495) {
        goto LABEL_649;
      }
      int v104 = v48;
      size_t v15 = *(void *)(v21 + 8);
      int v105 = *(void *)(v21 + 8);
      BOOL v106 = malloc_type_calloc(v15, 0x18uLL, 0x1000040504FFAC1uLL);
      if (v105)
      {
        unsigned int v107 = 0;
        uint64_t v108 = 0;
        uint64_t v109 = MEMORY[0x1E4F143A8];
        do
        {
          v551[8] = v109;
          v551[9] = 3221225472;
          v551[10] = __ReadAheadTaskLevelInfo_block_invoke_1685;
          v551[11] = &__block_descriptor_40_e38_v20__0I8r__dyld_uuid_info_64_Q_16C__12l;
          v551[12] = v106;
          unint64_t v110 = (char *)v22 + v107;
          unint64_t v111 = &v106[v108];
          long long v112 = *(_OWORD *)v110;
          v111[2].isa = *(Class *)(v110 + 16);
          *(_OWORD *)&v111->isa = v112;
          v108 += 3;
          v107 += v451;
        }
        while (3 * v15 != v108);
      }
      v495 = v106;
      BOOL v50 = 0;
      LODWORD(v545) = v105;
      int v46 = v499;
      int v48 = v104;
      goto LABEL_199;
    }
    __s1 = v35;
    uint64_t v468 = v34;
    v453 = v48;
    v456 = v25;
    v479 = v47;
    if (v70 == 2333)
    {
      unsigned int v450 = v73;
      v501 = v46;
      size_t v15 = *(void *)(v21 + 8);
      int v95 = *(void *)(v21 + 8);
      id v96 = (char *)malloc_type_calloc(v15, 0x1FuLL, 0x1000040B50B66BDuLL);
      BOOL v50 = v95;
      v496 = v96;
      if (v95)
      {
        unsigned int v97 = 0;
        uint64_t v98 = 0;
        uint64_t v99 = MEMORY[0x1E4F143A8];
        int v46 = v501;
        uint64_t v35 = __s1;
        uint64_t v34 = v468;
        uint64_t v36 = 17;
        uint64_t p_superclass = (__objc2_class **)(SAMicrostackshotStatistics + 8);
        id v52 = (__objc2_class **)(SAMicrostackshotStatistics + 8);
        do
        {
          *(void *)v568 = v99;
          *(void *)&v568[8] = 3221225472;
          *(void *)&v568[16] = __ReadAheadTaskLevelInfo_block_invoke_3;
          *(void *)&v568[24] = &__block_descriptor_44_e49_v20__0I8r__stackshot_thread_waitinfo_v2_QQQCsI_12l;
          unsigned int v570 = v450;
          uint64_t v100 = (_OWORD *)((char *)v22 + v97);
          int v101 = &v496[v98];
          v569 = v496;
          long long v102 = *v100;
          if (v450 < 0x1F)
          {
            *(_OWORD *)(v101 + 9) = *(long long *)((char *)v100 + 9);
            *(_OWORD *)int v101 = v102;
            id v103 = &v569[v98];
            *(_WORD *)(v103 + 25) = 0;
            *(_DWORD *)(v103 + 27) = 0;
          }
          else
          {
            *(_OWORD *)(v101 + 15) = *(long long *)((char *)v100 + 15);
            *(_OWORD *)int v101 = v102;
          }
          v98 += 31;
          v97 += v450;
        }
        while (31 * v15 != v98);
        BOOL v50 = 0;
        HIDWORD(v478) = v95;
        int v48 = v453;
        id v25 = v456;
        int v47 = v479;
        goto LABEL_97;
      }
      HIDWORD(v478) = 0;
      int v46 = v501;
    }
    else if (v70 == 2345)
    {
      unsigned int v448 = v73;
      size_t v77 = *(void *)(v21 + 8);
      uint64_t v446 = *(void *)(v21 + 8);
      int v46 = (char *)malloc_type_calloc(v77, 0x1CuLL, 0x100004027586B93uLL);
      BOOL v50 = v446;
      if (v446)
      {
        unsigned int v78 = 0;
        uint64_t v79 = 0;
        BOOL v80 = MEMORY[0x1E4F143A8];
        uint64_t v81 = 28 * v77;
        int v48 = v453;
        id v25 = v456;
        int v47 = v479;
        uint64_t v35 = __s1;
        uint64_t v34 = v468;
        uint64_t v36 = 17;
        uint64_t p_superclass = (__objc2_class **)(SAMicrostackshotStatistics + 8);
        id v52 = (__objc2_class **)(SAMicrostackshotStatistics + 8);
        do
        {
          v546[1] = v80;
          v546[2] = 3221225472;
          v546[3] = __ReadAheadTaskLevelInfo_block_invoke_4;
          v546[4] = &__block_descriptor_44_e54_v20__0I8r__stackshot_thread_turnstileinfo_v2_QQCCQs_12l;
          unsigned int v548 = v448;
          int v82 = (_OWORD *)((char *)v22 + v78);
          unsigned int v83 = &v46[v79];
          v547 = v46;
          long long v84 = *v82;
          if (v448 < 0x1C)
          {
            *(_OWORD *)(v83 + 10) = *(long long *)((char *)v82 + 10);
            *(_OWORD *)unsigned int v83 = v84;
            *(_WORD *)&v547[v79 + 26] = 0;
          }
          else
          {
            *(_OWORD *)(v83 + 12) = *(long long *)((char *)v82 + 12);
            *(_OWORD *)unsigned int v83 = v84;
          }
          v79 += 28;
          v78 += v448;
        }
        while (v81 != v79);
        BOOL v50 = 0;
        LODWORD(v478) = v446;
        goto LABEL_97;
      }
      LODWORD(v478) = 0;
    }
    int v48 = v453;
LABEL_206:
    int v47 = v479;
    uint64_t v35 = __s1;
    uint64_t v34 = v468;
    id v25 = v456;
    uint64_t v36 = 17;
    uint64_t p_superclass = (__objc2_class **)(SAMicrostackshotStatistics + 8);
    id v52 = (__objc2_class **)(SAMicrostackshotStatistics + 8);
    goto LABEL_97;
  }
  unint64_t v70 = HIDWORD(v69);
  if (SHIDWORD(v69) <= 2310)
  {
    switch(HIDWORD(v69))
    {
      case 0x30:
        unsigned int v72 = 20;
        break;
      case 0x31:
        unsigned int v72 = 24;
        break;
      case 0x81A:
        unsigned int v72 = 8;
        break;
      default:
        goto LABEL_207;
    }
  }
  else
  {
    BOOL v71 = v25;
    v479 = v47;
    v483 = v45;
    id v25 = v48;
    v499 = v46;
    switch(HIDWORD(v69))
    {
      case 0x907:
        unsigned int v72 = 4;
        goto LABEL_134;
      case 0x908:
      case 0x909:
        goto LABEL_8;
      case 0x90A:
      case 0x90C:
        unsigned int v72 = 8;
        goto LABEL_134;
      case 0x90B:
      case 0x90D:
        unsigned int v72 = 16;
LABEL_134:
        id v25 = v71;
        break;
      default:
        if (HIDWORD(v69) != 2369) {
          goto LABEL_207;
        }
        unsigned int v72 = 48;
        break;
    }
  }
  if (v53 / v72 >= v69 && v53 % v69 <= 0xF)
  {
LABEL_137:
    BOOL v50 = 0;
    if ((int)v70 > 2310)
    {
      uint64_t v22 = v56;
      uint64_t v73 = 8;
      switch((int)v70)
      {
        case 2311:
          goto LABEL_97;
        case 2312:
        case 2313:
          goto LABEL_118;
        case 2314:
        case 2316:
          goto LABEL_140;
        case 2315:
        case 2317:
          uint64_t v73 = 16;
          goto LABEL_140;
        default:
          if (v70 != 2369) {
            goto LABEL_118;
          }
          LODWORD(v73) = 48;
          break;
      }
LABEL_181:
      if (v69)
      {
        unsigned int v113 = 0;
        uint64_t v114 = *(void *)(v21 + 8);
        do
        {
          uint64_t v549 = MEMORY[0x1E4F143A8];
          uint64_t v550 = 3221225472;
          v551[0] = __ReadAheadTaskLevelInfo_block_invoke_2;
          v551[1] = &__block_descriptor_40_e51_v20__0I8r__thread_delta_snapshot_v2_QQQQIIssCCCC_12l;
          int v115 = (NSObject **)((char *)v22 + v113);
          if ((*((unsigned char *)v115 + 17) & 0x20) != 0) {
            v546[0] = *v115;
          }
          v113 += v73;
          --v114;
        }
        while (v114);
        BOOL v50 = 0;
        v551[2] = v546;
        goto LABEL_97;
      }
      goto LABEL_124;
    }
    if (v70 == 48)
    {
      uint64_t v22 = v56;
      LODWORD(v73) = 20;
LABEL_188:
      uint64_t v445 = v26;
      int v452 = v73;
      __s1 = v35;
      uint64_t v468 = v34;
      v454 = v48;
      v457 = v25;
      v479 = v47;
      v483 = v45;
      v499 = v46;
      if (!v493)
      {
        size_t v116 = *(void *)(v21 + 8);
        uint64_t v117 = *(void *)(v21 + 8);
        uint64_t v118 = malloc_type_calloc(v116, 0x18uLL, 0x1000040504FFAC1uLL);
        id v119 = &__block_descriptor_40_e38_v20__0I8r__dyld_uuid_info_32_I_16C__12l;
        int v447 = v117;
        if (v117)
        {
          size_t v15 = (size_t)v22;
          unsigned int v120 = 0;
          uint64_t v22 = 0;
          v494 = (void *)MEMORY[0x1E4F143A8];
          uint64_t v463 = 24 * v116;
          v464 = __ReadAheadTaskLevelInfo_block_invoke;
          do
          {
            v552[3] = v494;
            v552[4] = 3221225472;
            v553[0] = __ReadAheadTaskLevelInfo_block_invoke;
            v553[1] = v119;
            v553[2] = v118;
            uint64_t v121 = (const unsigned __int8 *)(v15 + v120);
            *(void *)((char *)v22 + (void)v118) = *(unsigned int *)v121;
            unint64_t v122 = v119;
            uuid_copy((unsigned __int8 *)v22 + (void)v118 + 8, v121 + 4);
            id v119 = v122;
            uint64_t v22 = (_OWORD *)((char *)v22 + 24);
            v120 += v452;
          }
          while ((_OWORD *)v463 != v22);
        }
        v493 = v118;
        BOOL v50 = 0;
        uint64_t v26 = v445;
        HIDWORD(v545) = v447;
        int v46 = v499;
        int v48 = v454;
        id v25 = v457;
        uint64_t v45 = v483;
        int v47 = v479;
        uint64_t v35 = __s1;
        uint64_t v34 = v468;
        uint64_t v36 = 17;
        uint64_t p_superclass = (__objc2_class **)(SAMicrostackshotStatistics + 8);
        id v52 = (__objc2_class **)(SAMicrostackshotStatistics + 8);
        goto LABEL_97;
      }
      int v362 = *__error();
      v363 = _sa_logt();
      if (os_log_type_enabled(v363, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__objc2_class buf = 0;
        _os_log_error_impl(&dword_1BF22B000, v363, OS_LOG_TYPE_ERROR, "multiple load_info arrays for task", buf, 2u);
      }

      *__error() = v362;
      _SASetCrashLogMessage(2448, "multiple load_info arrays for task", v364, v365, v366, v367, v368, v369, v442);
      _os_crash();
      __break(1u);
LABEL_625:
      int v370 = *__error();
      v371 = _sa_logt();
      if (os_log_type_enabled(v371, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__objc2_class buf = 0;
        _os_log_error_impl(&dword_1BF22B000, v371, OS_LOG_TYPE_ERROR, "multiple load_info arrays for task", buf, 2u);
      }

      *__error() = v370;
      _SASetCrashLogMessage(2466, "multiple load_info arrays for task", v372, v373, v374, v375, v376, v377, v442);
      _os_crash();
      __break(1u);
LABEL_628:
      int v378 = *__error();
      v379 = _sa_logt();
      if (os_log_type_enabled(v379, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v568 = 67109120;
        *(_DWORD *)&v568[4] = v15;
        _os_log_error_impl(&dword_1BF22B000, v379, OS_LOG_TYPE_ERROR, "%d delta threads when parsing stackshot in kperf", v568, 8u);
      }

      *__error() = v378;
      _SASetCrashLogMessage(4773, "%d delta threads when parsing stackshot in kperf", v380, v381, v382, v383, v384, v385, v15);
      _os_crash();
      __break(1u);
LABEL_631:
      int v386 = *__error();
      v387 = _sa_logt();
      if (os_log_type_enabled(v387, OS_LOG_TYPE_ERROR))
      {
        uint64_t v388 = *(void *)(a1 + 360);
        *(_DWORD *)v568 = 67109376;
        *(_DWORD *)&v568[4] = v15;
        *(_WORD *)&v568[8] = 2048;
        *(void *)((char *)v22 + 202) = v388;
        _os_log_error_impl(&dword_1BF22B000, v387, OS_LOG_TYPE_ERROR, "%d delta threads when dataStyle %llu", v568, 0x12u);
      }

      *__error() = v386;
      _SASetCrashLogMessage(4774, "%d delta threads when dataStyle %llu", v389, v390, v391, v392, v393, v394, v15);
      _os_crash();
      __break(1u);
      goto LABEL_634;
    }
    if (v70 != 49)
    {
      uint64_t v22 = v56;
      if (v70 == 2074) {
        goto LABEL_97;
      }
      goto LABEL_118;
    }
    uint64_t v73 = 24;
LABEL_194:
    v455 = v48;
    v456 = v25;
    v483 = v45;
    v479 = v47;
    __s1 = v35;
    uint64_t v468 = v34;
    v499 = v46;
    if (v493) {
      goto LABEL_625;
    }
    uint64_t v22 = (_OWORD *)v73;
    uint64_t v123 = v56;
    size_t v15 = *(void *)(v21 + 8);
    int v124 = *(void *)(v21 + 8);
    BOOL v125 = malloc_type_calloc(v15, 0x18uLL, 0x1000040504FFAC1uLL);
    if (v124)
    {
      unsigned int v126 = 0;
      uint64_t v127 = 0;
      uint64_t v128 = MEMORY[0x1E4F143A8];
      do
      {
        v551[13] = v128;
        v551[14] = 3221225472;
        v552[0] = __ReadAheadTaskLevelInfo_block_invoke_1680;
        v552[1] = &__block_descriptor_40_e38_v20__0I8r__dyld_uuid_info_64_Q_16C__12l;
        v552[2] = v125;
        long long v129 = (long long *)((char *)v123 + v126);
        double v130 = &v125[v127];
        long long v131 = *v129;
        v130[2].isa = (Class)v129[1];
        *(_OWORD *)&v130->isa = v131;
        v127 += 3;
        v126 += v22;
      }
      while (3 * v15 != v127);
    }
    v493 = v125;
    BOOL v50 = 0;
    HIDWORD(v545) = v124;
    int v46 = v499;
    int v48 = v455;
LABEL_199:
    uint64_t v45 = v483;
    goto LABEL_206;
  }
LABEL_207:
  v479 = v47;
  v483 = v45;
  id v25 = v48;
  v499 = v46;
LABEL_8:
  LODWORD(v21) = v33 == 0;
  BOOL v37 = v23 == 0;
  int v38 = context;
  if (context)
  {
LABEL_9:
    long long v23 = newValue;
    uint64_t v39 = v488;
    unsigned int v40 = v504;
    goto LABEL_10;
  }
LABEL_222:
  if (v21)
  {
    if (v37)
    {
      if (!v38) {
        goto LABEL_9;
      }
      int v143 = 0;
      unsigned int v142 = 0;
      uint64_t v141 = 0xFFFFFFFFLL;
      int v145 = 1;
      uint64_t v144 = -1;
    }
    else
    {
      if (*((unsigned char *)v23 + 28)) {
        unsigned int v142 = (char *)v23 + 28;
      }
      else {
        unsigned int v142 = 0;
      }
      if ((v38 & 1) == 0) {
        goto LABEL_9;
      }
      int v145 = 0;
      uint64_t v141 = *((unsigned int *)v23 + 6);
      uint64_t v144 = *v23;
      int v143 = (void (*)(uint64_t, unsigned int, unsigned __int8 *))v23[1];
    }
  }
  else
  {
    uint64_t v144 = *v33;
    if (v37)
    {
      if ((v38 & 1) == 0) {
        goto LABEL_9;
      }
      unsigned int v142 = 0;
      int v143 = (void (*)(uint64_t, unsigned int, unsigned __int8 *))v33[1];
      uint64_t v141 = 0xFFFFFFFFLL;
      int v145 = 1;
    }
    else
    {
      if (*((unsigned char *)v23 + 28)) {
        unsigned int v142 = (char *)v23 + 28;
      }
      else {
        unsigned int v142 = 0;
      }
      if ((v38 & 1) == 0) {
        goto LABEL_9;
      }
      int v145 = 0;
      uint64_t v141 = *((unsigned int *)v23 + 6);
      int v143 = (void (*)(uint64_t, unsigned int, unsigned __int8 *))v33[1];
    }
  }
  if (!a7)
  {
    uint64_t context = 0;
    int v140 = 1;
    goto LABEL_245;
  }
  int v135 = *__error();
  uint64_t v146 = _sa_logt();
  unsigned int v136 = v146;
  if (v145)
  {
    long long v23 = newValue;
    uint64_t v39 = v488;
    if (os_log_type_enabled(v146, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v568 = 134217984;
      *(void *)&v568[4] = v472;
      int v147 = "no task_struct for task container %llu when primary data is kperf";
      goto LABEL_243;
    }
  }
  else
  {
    long long v23 = newValue;
    uint64_t v39 = v488;
    if (os_log_type_enabled(v146, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v568 = 134217984;
      *(void *)&v568[4] = v472;
      _os_log_debug_impl(&dword_1BF22B000, v136, OS_LOG_TYPE_DEBUG, "Only transitioning task task container %llu when primary data is kperf", v568, 0xCu);
    }
  }
LABEL_294:
  unsigned int v40 = v504;

  *__error() = v135;
LABEL_10:
  if (v496) {
    free(v496);
  }
  if (v499) {
    free(v499);
  }
  if (v493) {
    free(v493);
  }
  if (v495) {
    free(v495);
  }
  if (v25) {
    free(v25);
  }
  [v39 clearTaskData];
  uint64_t v41 = SkipToContainerEnd((int **)a2, 1);
  id v25 = v503;
LABEL_21:

  return v41;
}

- (uint64_t)_parseKCDataSharedCacheContainer:(void *)a3 sharedCaches:
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  int v7 = a3;
  unint64_t v8 = *a2;
  uint64_t v9 = (*a2)[4];
  if (v9 == 2370)
  {
    BOOL v10 = v7;
    long long v11 = a2[1];
    uint64_t v12 = *((void *)v8 + 1);
    char v13 = (char *)v8 + v8[1];
    int v14 = v13 + 16;
    *a2 = (unsigned int *)(v13 + 16);
    size_t v15 = v13 + 32;
    if (v15 > (char *)v11) {
      goto LABEL_45;
    }
    objc_super v3 = 0;
    while (1)
    {
      if (&v15[v14[1]] > (char *)v11 || *v14 == -242132755)
      {
LABEL_28:
        if (!v3) {
          goto LABEL_45;
        }
        goto LABEL_29;
      }
      uint64_t v16 = (void *)MEMORY[0x1C18A6A20]();
      KCLogIter(*a2, (unint64_t)a2[1], 0);
      uint64_t v17 = *a2;
      unsigned int v18 = **a2;
      if ((v18 & 0xFFFFFFF0) == 0x20) {
        int v19 = 17;
      }
      else {
        int v19 = **a2;
      }
      switch(v19)
      {
        case 19:
          unint64_t v20 = (unint64_t)a2[1];
          uint64_t v21 = v17 + 4;
          if ((unint64_t)(v17 + 4) > v20
            || (uint64_t v22 = v17[1], (unint64_t)v21 + v22 > v20)
            || ((v18 & 0xFFFFFFF0) != 0x20 ? (BOOL v23 = v18 == 19) : (BOOL v23 = 0),
                v23 ? (BOOL v24 = v22 > 3) : (BOOL v24 = 0),
                !v24))
          {
            int v29 = *__error();
            uint64_t v30 = _sa_logt();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__objc2_class buf = 67109120;
              *(_DWORD *)id v49 = 2370;
              _os_log_error_impl(&dword_1BF22B000, v30, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
            }
            uint64_t v25 = 1;
            goto LABEL_36;
          }
          uint64_t v25 = SkipToContainerEnd((int **)a2, 1);
          if (v25) {
            goto LABEL_48;
          }
          break;
        case 2371:
          objc_super v3 = v17 + 4;
          break;
        case 20:
          uint64_t v33 = *((void *)v17 + 1);
          if (v12 != v33)
          {
            int v29 = *__error();
            uint64_t v30 = _sa_logt();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__objc2_class buf = 134218240;
              *(void *)id v49 = v12;
              *(_WORD *)&v49[8] = 2048;
              *(void *)BOOL v50 = v33;
              _os_log_error_impl(&dword_1BF22B000, v30, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
            }
            uint64_t v25 = 7;
LABEL_36:

            *__error() = v29;
            goto LABEL_48;
          }
          if (!v3)
          {
LABEL_45:
            int v34 = *__error();
            uint64_t v35 = _sa_logt();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)__objc2_class buf = 0;
              _os_log_error_impl(&dword_1BF22B000, v35, OS_LOG_TYPE_ERROR, "no shared cache info at shared cache container end", buf, 2u);
            }

            uint64_t v25 = 0;
            *__error() = v34;
            goto LABEL_48;
          }
LABEL_29:
          uint64_t v27 = [NSNumber numberWithUnsignedInt:v3[10]];
          uint64_t v9 = [v10 objectForKeyedSubscript:v27];

          a2 = (unsigned int **)(v3 + 2);
          if (v9)
          {
            if (([(id)v9 matchesUUID:v3 + 2 slide:*(void *)v3 slidBaseAddress:*((void *)v3 + 4)] & 1) == 0)
            {
              int v4 = *__error();
              uint64_t v28 = _sa_logt();
              if (os_log_type_enabled((os_log_t)v28, OS_LOG_TYPE_FAULT)) {
                goto LABEL_55;
              }
              goto LABEL_32;
            }
          }
          else
          {
            uint64_t v31 = -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, (uint64_t)(v3 + 2), *(void *)v3, *((void *)v3 + 4));
            uint64_t v9 = v31;
            if (v31)
            {
              *(_DWORD *)(v31 + 28) = v3[11];
              *(_DWORD *)(v31 + 32) = v3[10];
            }
            uint64_t v32 = [NSNumber numberWithUnsignedInt:v3[10]];
            [v10 setObject:v9 forKeyedSubscript:v32];
          }
          if (v3[11]) {
            objc_storeStrong((id *)(a1 + 1024), (id)v9);
          }
          goto LABEL_42;
        default:
          break;
      }
      long long v11 = a2[1];
      uint64_t v26 = (char *)*a2 + (*a2)[1];
      int v14 = v26 + 16;
      *a2 = (unsigned int *)(v26 + 16);
      size_t v15 = v26 + 32;
      if (v15 > (char *)v11) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v28 = *__error();
  BOOL v10 = _sa_logt();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__objc2_class buf = 67109120;
    *(_DWORD *)id v49 = v9;
    _os_log_error_impl(&dword_1BF22B000, v10, OS_LOG_TYPE_ERROR, "bad container type %u", buf, 8u);
  }

  *__error() = v28;
  _SASetCrashLogMessage(5645, "bad container type %u", v37, v38, v39, v40, v41, v42, v9);
  _os_crash();
  __break(1u);
LABEL_55:
  uint64_t v43 = *((void *)v3 + 4);
  uint64_t v44 = *(void *)v3;
  unsigned int v46 = v3[10];
  unsigned int v45 = v3[11];
  int v47 = [(id)v9 debugDescription];
  *(_DWORD *)__objc2_class buf = 67110658;
  *(_DWORD *)id v49 = v46;
  *(_WORD *)&v49[4] = 1040;
  *(_DWORD *)&v49[6] = 16;
  *(_WORD *)BOOL v50 = 2096;
  *(void *)&v50[2] = a2;
  __int16 v51 = 2048;
  uint64_t v52 = v43;
  __int16 v53 = 2048;
  uint64_t v54 = v44;
  __int16 v55 = 1024;
  unsigned int v56 = v45;
  __int16 v57 = 2114;
  BOOL v58 = v47;
  _os_log_fault_impl(&dword_1BF22B000, (os_log_t)v28, OS_LOG_TYPE_FAULT, "Shared cache info id %d: %{uuid_t}.16P slid base address 0x%llx, slide 0x%llx, flags 0x%x doesn't match existing %{public}@", buf, 0x3Cu);

LABEL_32:
  *__error() = v4;
LABEL_42:

  uint64_t v25 = 0;
LABEL_48:

  return v25;
}

void __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = -[SASampleStore lastTaskWithUniquePid:](*(void **)(a1 + 32), *a3);
  id v6 = v5;
  if (v5)
  {
    int v7 = [v5 taskStates];
    unint64_t v8 = [v7 lastObject];

    if (v8)
    {
      objc_setProperty_atomic(v8, v9, *(id *)(a1 + 40), 40);
      v8[7] = *(void *)(a1 + 56);
    }
    BOOL v10 = [v6 threads];
    uint64_t v18 = MEMORY[0x1E4F143A8];
    uint64_t v19 = 3221225472;
    unint64_t v20 = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_2;
    uint64_t v21 = &unk_1E63F74A8;
    id v11 = *(id *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 56);
    id v22 = v11;
    uint64_t v23 = v12;
    [v10 enumerateKeysAndObjectsUsingBlock:&v18];
  }
  else
  {
    int v13 = *__error();
    int v14 = _sa_logt();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = *a3;
      *(_DWORD *)__objc2_class buf = 134217984;
      uint64_t v25 = v17;
      _os_log_error_impl(&dword_1BF22B000, v14, OS_LOG_TYPE_ERROR, "Non-runnable task %llu from stackshot before any regular task struct", buf, 0xCu);
    }

    *__error() = v13;
  }
  size_t v15 = *(void **)(a1 + 48);
  uint64_t v16 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", *a3, v18, v19, v20, v21);
  [v15 addObject:v16];
}

void __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v9 = a3;
  int v4 = [v9 exitTimestamp];

  uint64_t v5 = v9;
  if (!v4)
  {
    id v6 = [v9 threadStates];
    int v7 = [v6 lastObject];

    if (v7)
    {
      objc_setProperty_atomic(v7, v8, *(id *)(a1 + 32), 56);
      -[SAThreadState setEndSampleIndex:]((uint64_t)v7, *(void *)(a1 + 40));
    }

    uint64_t v5 = v9;
  }
}

uint64_t __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_250(uint64_t a1)
{
  return fprintf((FILE *)*MEMORY[0x1E4F143C8], "Warning: Unable to infer machine architecture from kernel version %s\n", (const char *)[*(id *)(*(void *)(a1 + 32) + 448) UTF8String]);
}

void __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_252(uint64_t a1, void *a2)
{
  objc_super v3 = [a2 threads];
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_2_253;
  v4[3] = &__block_descriptor_40_e35_v32__0__NSNumber_8__SAThread_16_B24l;
  void v4[4] = *(void *)(a1 + 32);
  [v3 enumerateKeysAndObjectsUsingBlock:v4];
}

void __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_2_253(uint64_t a1, uint64_t a2, void *a3)
{
  self = a3;
  int v4 = [self exitTimestamp];

  uint64_t v5 = self;
  if (!v4)
  {
    id v6 = [self threadStates];
    int v7 = [v6 lastObject];

    if (v7 && (unint64_t)[v7 endSampleIndex] < *(void *)(a1 + 32))
    {
      id v9 = [v7 endTimestamp];
      if (self) {
        objc_setProperty_atomic(self, v8, v9, 40);
      }
    }
    uint64_t v5 = self;
  }
}

void __116__SASampleStore__addKCDataStackshot_timestamp_sampleIndex_shouldSkipSampleOut_primaryDataIsKPerf_addStaticInfoOnly___block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  id v9 = a3;
  int v4 = [v9 exitTimestamp];
  if (v4) {
    goto LABEL_3;
  }
  uint64_t v5 = [v9 threadStates];
  id v6 = [v5 lastObject];
  int v4 = [v6 endTimestamp];

  if (v4)
  {
LABEL_3:
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    unint64_t v8 = *(void **)(v7 + 40);
    if (v8)
    {
      if (![v8 lt:v4]) {
        goto LABEL_7;
      }
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    }
    objc_storeStrong((id *)(v7 + 40), v4);
  }
LABEL_7:
}

BOOL __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke(uint64_t a1, unsigned __int8 *__base, unsigned int *a3)
{
  unsigned int v3 = *a3;
  if (!*a3) {
    return 0;
  }
  unint64_t v7 = 0;
  unsigned int v8 = 0;
  id v9 = __base + 8;
  do
  {
    uint64_t v10 = *((void *)v9 - 1);
    if (v10)
    {
      if (v7 != v8)
      {
        id v11 = &__base[24 * v8];
        *(void *)id v11 = v10;
        uuid_copy(v11 + 8, v9);
        unsigned int v3 = *a3;
      }
      ++v8;
    }
    ++v7;
    v9 += 24;
  }
  while (v7 < v3);
  if (v3 == v8)
  {
    BOOL v12 = 0;
    if (!v8) {
      return v12;
    }
  }
  else
  {
    BOOL v12 = v8 != 0;
    *a3 = v8;
    if (!v8) {
      return v12;
    }
  }
  if (!*(unsigned char *)(a1 + 32)) {
    mergesort_b(__base, v8, 0x18uLL, &__block_literal_global_294);
  }
  return v12;
}

uint64_t __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  if (*a3 <= *a2) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = -1;
  }
  if (*a3 < *a2) {
    return 1;
  }
  else {
    return v3;
  }
}

uint64_t __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_299(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 8);
  unint64_t v4 = *(void *)(a2 + 8);
  BOOL v5 = v3 >= v4;
  if (v3 <= v4) {
    unsigned int v6 = 0;
  }
  else {
    unsigned int v6 = -1;
  }
  if (v5) {
    return v6;
  }
  else {
    return 1;
  }
}

- (id)addressTranslationsForPid:(uint64_t)a1
{
  if (a1)
  {
    unint64_t v4 = *(void **)(a1 + 304);
    BOOL v5 = [NSNumber numberWithInt:a2];
    unsigned int v6 = [v4 objectForKeyedSubscript:v5];

    if (!v6)
    {
      if (!*(void *)(a1 + 304))
      {
        uint64_t v7 = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:1];
        unsigned int v8 = *(void **)(a1 + 304);
        *(void *)(a1 + 304) = v7;
      }
      unsigned int v6 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:8];
      id v9 = *(void **)(a1 + 304);
      uint64_t v10 = [NSNumber numberWithInt:a2];
      [v9 setObject:v6 forKeyedSubscript:v10];
    }
  }
  else
  {
    unsigned int v6 = 0;
  }
  return v6;
}

void __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_309(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(_DWORD *)(a1 + 128) <= 0x3Fu) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = (uint64_t)a3;
  }
  uint64_t v6 = *a3;
  if (*(unsigned char *)(*(void *)(a1 + 32) + 220) && v6 != *(void *)(a1 + 80)) {
    return;
  }
  uint64_t v7 = *(unsigned int *)(a1 + 132);
  if (!v7)
  {
LABEL_10:
    uint64_t v8 = 0;
LABEL_11:
    id v9 = 0;
    goto LABEL_12;
  }
  uint64_t v8 = *(void *)(a1 + 88);
  while (*(void *)(v8 + 8) != v6)
  {
    v8 += 31;
    if (!--v7) {
      goto LABEL_10;
    }
  }
  if (!*(_WORD *)(v8 + 25)) {
    goto LABEL_11;
  }
  uint64_t v17 = *(unsigned int *)(a1 + 96);
  if (!v17) {
    goto LABEL_11;
  }
  id v9 = *(void **)(a1 + 104);
  while (*(unsigned __int16 *)*v9 != *(unsigned __int16 *)(v8 + 25))
  {
    v9 += 2;
    if (!--v17) {
      goto LABEL_11;
    }
  }
LABEL_12:
  uint64_t v10 = *(unsigned int *)(a1 + 136);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 112);
    while (*(void *)v11 != v6)
    {
      v11 += 28;
      if (!--v10) {
        goto LABEL_16;
      }
    }
    if (*(_WORD *)(v11 + 26))
    {
      uint64_t v18 = *(unsigned int *)(a1 + 96);
      if (v18)
      {
        BOOL v12 = *(void **)(a1 + 104);
        while (*(unsigned __int16 *)*v12 != *(unsigned __int16 *)(v11 + 26))
        {
          v12 += 2;
          if (!--v18) {
            goto LABEL_17;
          }
        }
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_16:
    uint64_t v11 = 0;
  }
LABEL_17:
  BOOL v12 = 0;
LABEL_18:
  int v13 = *(void **)(a1 + 40);
  int v14 = [NSNumber numberWithUnsignedLongLong:v6];
  [v13 addObject:v14];

  uint64_t v15 = -[SASampleStore addKCDataThreadV4:threadV2:deltaThreadV3:deltaThreadV2:timestamp:sampleIndex:stack:threadExclavesInfo:threadName:dispatchQueueLabel:waitInfo:waitInfoPortLabelInfo:turnstileInfo:turnstileInfoPortLabelInfo:instructionCycles:task:kernelTask:taskIsSuspended:](*(id **)(a1 + 32), 0, 0, v5, (uint64_t)a3, *(void **)(a1 + 48), *(void *)(a1 + 120), 0, 0, 0, 0, v8, v9, v11, v12, 0, *(void **)(a1 + 56), *(void **)(a1 + 64), *(unsigned char *)(a1 + 140));
  if (v15)
  {
    uint64_t v16 = *(void **)(a1 + 72);
    id v19 = [NSNumber numberWithUnsignedLongLong:v15];
    [v16 addObject:v19];
  }
}

void __264__SASampleStore__parseKCDataTaskContainer_timestampOfSample_sampleIndex_sharedCaches_frameIterator_primaryDataIsKPerf_addStaticInfoOnly_taskUniquePidsInThisSample_taskPidsInThisSample_importanceDonations_rPidForJetsamCoalitionId_port_label_info_array_exclaveInfo___block_invoke_313(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  if (!*(unsigned char *)(*(void *)(a1 + 32) + 220) || v5 == *(void *)(a1 + 72))
  {
    uint64_t v6 = *(void **)(a1 + 40);
    uint64_t v7 = [NSNumber numberWithUnsignedLongLong:v5];
    [v6 addObject:v7];

    uint64_t v8 = [*(id *)(a1 + 48) threads];
    id v9 = [NSNumber numberWithUnsignedLongLong:*a3];
    id v18 = [v8 objectForKeyedSubscript:v9];

    uint64_t v10 = v18;
    if (v18)
    {
      uint64_t v11 = [v18 threadStates];
      BOOL v12 = [v11 lastObject];

      if (v12)
      {
        objc_setProperty_atomic(v12, v13, *(id *)(a1 + 56), 56);
        -[SAThreadState setEndSampleIndex:]((uint64_t)v12, *(void *)(a1 + 80));
        int v14 = [v12 dispatchQueue];
        uint64_t v15 = [v14 identifier];

        if (v15)
        {
          uint64_t v16 = *(void **)(a1 + 64);
          uint64_t v17 = [NSNumber numberWithUnsignedLongLong:v15];
          [v16 addObject:v17];
        }
      }

      uint64_t v10 = v18;
    }
  }
}

- (uint64_t)_parseKCDataThreadContainer:(void *)a3 timestampOfSample:(unint64_t)a4 sampleIndex:(void *)a5 task:(void *)a6 kernelTask:(void *)a7 frameIterator:(NSObject *)a8 mainThreadID:(char)a9 primaryDataIsKPerf:(char)a10 addStaticInfoOnly:(void *)a11 threadIDsInThisTaskThisSample:(NSObject *)a12 dispatchQueueIDsInThisTaskThisSample:(char)a13 taskIsSuspended:(uint64_t)a14 waitInfos:(unsigned int)a15 numWaitInfos:(uint64_t)a16 turnstileInfos:(unsigned int)a17 numTurnstileInfos:(int)a18 port_label_info_array:(unsigned int)a19 exclaveInfo:(unsigned __int16 *)a20
{
  uint64_t v27 = a21;
  uint64_t v28 = a12;
  uint64_t v257 = *MEMORY[0x1E4F143B8];
  id v29 = a3;
  id v243 = a5;
  v241 = a6;
  id v30 = a7;
  id v242 = a11;
  uint64_t v31 = a12;
  id v32 = a21;
  uint64_t v33 = *a2;
  int v34 = (*a2)[4];
  if (v34 != 2308)
  {
    uint64_t v156 = *__error();
    int v155 = _sa_logt();
    if (os_log_type_enabled(v155, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__dst) = 67109120;
      DWORD1(__dst) = v34;
      _os_log_error_impl(&dword_1BF22B000, v155, OS_LOG_TYPE_ERROR, "bad container type %u", (uint8_t *)&__dst, 8u);
    }

    *__error() = (int)v156;
    _SASetCrashLogMessage(5056, "bad container type %u", v195, v196, v197, v198, v199, v200, v34);
    _os_crash();
    __break(1u);
    goto LABEL_327;
  }
  uint64_t v35 = v32;
  uint64_t v36 = a2[1];
  uint64_t v37 = *((void *)v33 + 1);
  if (*(unsigned char *)(a1 + 220) && v37 != a8)
  {
    uint64_t v38 = SkipToContainerEnd(a2, 1);
    uint64_t v39 = v243;
    a2 = v241;
    goto LABEL_320;
  }
  uint64_t v233 = v32;
  uint64_t v234 = v29;
  uint64_t v226 = a1;
  uint64_t v230 = v31;
  long long v255 = 0u;
  long long v256 = 0u;
  long long v253 = 0u;
  long long v254 = 0u;
  long long v251 = 0u;
  long long v252 = 0u;
  long long __dst = 0u;
  long long v250 = 0u;
  uint64_t v40 = (char *)v33 + v33[1];
  uint64_t v41 = v40 + 16;
  *a2 = (int *)(v40 + 16);
  uint64_t v42 = v40 + 32;
  if (v42 > (char *)v36)
  {
    uint64_t v43 = 0;
    uint64_t v236 = 0;
    uint64_t v239 = 0;
    uint64_t v240 = 0;
    char v225 = 0;
    v227 = 0;
    int v228 = 0;
    v229 = 0;
    int v231 = 0;
LABEL_7:
    uint64_t v44 = v29;
    uint64_t p_dst = v43;
    uint64_t v46 = v236;
    unint64_t v47 = v236 | v43;
    BOOL v48 = (v236 | v43) != 0;
    uint64_t v39 = v243;
    if (!v47 && !v240 && !v239)
    {
      int v49 = *__error();
      BOOL v50 = _sa_logt();
      a2 = v241;
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__objc2_class buf = 0;
        _os_log_error_impl(&dword_1BF22B000, v50, OS_LOG_TYPE_ERROR, "no thread_snap at thread container end", buf, 2u);
      }

      *__error() = v49;
      [v30 clearThreadData];
      uint64_t v38 = 2;
      uint64_t v31 = v230;
      uint64_t v35 = v233;
      id v29 = v234;
      goto LABEL_320;
    }
    uint64_t v121 = (uint64_t *)v239;
    if (v240) {
      uint64_t v121 = (uint64_t *)v240;
    }
    if (p_dst) {
      uint64_t v121 = (uint64_t *)p_dst;
    }
    if (v236) {
      uint64_t v121 = (uint64_t *)v236;
    }
    uint64_t v122 = *v121;
    unint64_t v123 = 0x1E4F28000uLL;
    if (v231)
    {
      int v124 = [NSNumber numberWithUnsignedLongLong:*(void *)v231];
      BOOL v125 = [v233 objectForKeyedSubscript:v124];

      unsigned int v126 = [SAThreadExclavesInfo alloc];
      if (v126 && (uint64_t v127 = -[SAThreadExclavesInfo initWithCallstacks:](v126, v125)) != 0)
      {
        unsigned int v128 = v231[3];
        char v232 = v127;
        *((_DWORD *)v127 + 2) = v128;
      }
      else
      {
        char v232 = 0;
      }
    }
    else
    {
      char v232 = 0;
    }
    int v129 = [v30 exclaveInsertionIndex];
    if (v129 == [v30 numKernelFrames]) {
      [v30 setExclaveInsertionIndex:0];
    }
    if (!a9) {
      goto LABEL_284;
    }
    if (v48)
    {
      if (!v236 || &__dst == (long long *)v236)
      {
        if (p_dst && &__dst != (long long *)p_dst)
        {
          long long v255 = 0u;
          long long v256 = 0u;
          long long v253 = 0u;
          long long v254 = 0u;
          long long v251 = 0u;
          long long v252 = 0u;
          long long __dst = 0u;
          long long v250 = 0u;
          memmove(&__dst, (const void *)p_dst, 0x68uLL);
          uint64_t p_dst = (uint64_t)&__dst;
        }
      }
      else
      {
        memmove(&__dst, (const void *)v236, 0x80uLL);
        uint64_t v46 = (uint64_t)&__dst;
      }
      v256 &= 0xE000000u;
      *(void *)&long long v251 = 0;
      *(void *)&long long v253 = v253 & 0x1EFFC;
      *((void *)&v254 + 1) = DWORD2(v254) & 0xFFFFFFFB;
      if (v46 | p_dst)
      {
        if (v46) {
          uint64_t v130 = v46;
        }
        else {
          uint64_t v130 = p_dst;
        }
        uint64_t v131 = *(void *)(v130 + 40);
        if (v228)
        {
          unsigned int v132 = [v243 dispatchQueues];
          int v133 = [NSNumber numberWithUnsignedLongLong:v131];
          uint64_t v134 = [v132 objectForKeyedSubscript:v133];

          if (v134)
          {
            int v135 = [v134 dispatchQueueLabel];

            if (!v135)
            {
              unsigned int v137 = SANSStringForCString(v228);
              if (v137) {
                objc_setProperty_atomic_copy(v134, v136, v137, 32);
              }
            }
          }

          uint64_t v39 = v243;
        }
        uint64_t v237 = v131;
        unsigned int v138 = [v39 threads];
        uint32_t v139 = [NSNumber numberWithUnsignedLongLong:v122];
        int v140 = [v138 objectForKeyedSubscript:v139];

        if (v140)
        {
          uint64_t v39 = v243;
        }
        else
        {
          uint64_t v39 = v243;
          if ((a10 & 1) == 0)
          {
            +[SAThread threadWithId:]((uint64_t)SAThread, v122);
            int v140 = (unsigned char *)objc_claimAutoreleasedReturnValue();
            uint64_t v141 = [v243 execTimestamp];

            if (v141)
            {
              int v143 = [v243 execTimestamp];
              if (v140) {
                objc_setProperty_atomic(v140, v142, v143, 32);
              }
            }
            -[SATask addThread:]((uint64_t)v243, v140);
          }
        }
        if (v46) {
          uint64_t v144 = v46;
        }
        else {
          uint64_t v144 = p_dst;
        }
        uint64_t v224 = v144;
        unint64_t v145 = *(void *)(v144 + 64);
        if (v140)
        {
          if ((v145 & 0x2000) != 0)
          {
            uint64_t v146 = [v39 mainThread];

            if (!v146)
            {
              v140[17] = 1;
              if (v39) {
                objc_setProperty_atomic(v39, v147, v140, 264);
              }
            }
          }
        }
        if (a10)
        {
          [v30 clearThreadData];

          a2 = v241;
          uint64_t v35 = v233;
          id v29 = v234;
          uint64_t v31 = v230;
          long long v148 = v232;
LABEL_319:

          uint64_t v38 = 0;
          goto LABEL_320;
        }
        if (v46) {
          uint64_t v149 = v46;
        }
        else {
          uint64_t v149 = p_dst;
        }
        [v30 setContinuation:*(void *)(v149 + 16)];
        BOOL v150 = (v145 & 0x8080) != 0
            || [v39 pid] && !objc_msgSend(v30, "hasUserStack");
        [v30 setIsUserStackTruncated:v150];
        [v30 setIsSwiftAsyncStackTruncated:(v145 >> 16) & 1];
        [v30 setIsKernelStackTruncated:(v145 >> 14) & 1];
        if ([v39 pid])
        {
          v244[0] = 0;
          uint64_t v151 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v39, v30, v244);
          id v152 = v244[0];
        }
        else
        {
          uint64_t v151 = 0;
          id v152 = 0;
        }
        unint64_t v123 = 0x1E4F28000;
        uint64_t v223 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v241, v30, 0);
        if (v46)
        {
          int v153 = *(_DWORD *)(v226 + 200);
          LOBYTE(v154) = 125;
          switch(v153)
          {
            case 0:
              break;
            case 4:
            case 5:
            case 6:
            case 7:
              int v154 = (*(_DWORD *)(v46 + 112) >> 25) & 7;
              break;
            default:
              SAComplainAboutUnknownThreadPolicyVersion(v153);
              goto LABEL_253;
          }
        }
        else
        {
LABEL_253:
          LOBYTE(v154) = 125;
        }
        if (v152) {
          uint64_t v157 = -1;
        }
        else {
          uint64_t v157 = 0;
        }
        if (a4)
        {
          uint64_t v221 = v157;
          uint64_t v222 = v151;
          uint64_t v158 = 0;
          if (a4 == 0x7FFFFFFFFFFFFFFFLL) {
            unint64_t v159 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v159 = a4 - 1;
          }
          if (v46) {
            uint64_t v160 = v46;
          }
          else {
            uint64_t v160 = p_dst;
          }
          uint64_t v161 = *(void *)(v226 + 184);
          if (v161)
          {
            uint64_t v162 = 0;
            if (HIDWORD(v161))
            {
              uint64_t v158 = *(void *)(v160 + 56);
              if (v161 == HIDWORD(v161))
              {
                if (v46) {
                  uint64_t v163 = v46;
                }
                else {
                  uint64_t v163 = p_dst;
                }
                uint64_t v162 = *(void *)(v163 + 48);
              }
              else
              {
                uint64_t v158 = __udivti3();
                unint64_t v123 = 0x1E4F28000uLL;
                uint64_t v44 = v234;
                uint64_t v162 = __udivti3();
              }
            }
          }
          else
          {
            uint64_t v162 = 0;
          }
          if (v46) {
            uint64_t v164 = v46;
          }
          else {
            uint64_t v164 = p_dst;
          }
          int v165 = *(__int16 *)(v164 + 96);
          int v166 = *(__int16 *)(v164 + 98);
          int v167 = *(_DWORD *)(v164 + 88);
          char v168 = *(unsigned char *)(v164 + 100);
          char v169 = *(unsigned char *)(v164 + 101);
          char v170 = *(unsigned char *)(v164 + 102);
          if (v229)
          {
            uint64_t v171 = *v229;
            uint64_t v172 = v229[1];
          }
          else
          {
            uint64_t v171 = 0;
            uint64_t v172 = 0;
          }
          if (v46) {
            uint64_t v173 = v46;
          }
          else {
            uint64_t v173 = p_dst;
          }
          uint64_t v219 = v158;
          uint64_t v151 = v222;
          -[SASampleStore backfillThread:inTask:lastSampleIndex:timestamp:haveName:name:haveDispatchQueueId:dispatchQueueId:dispatchQueueLabel:leafKernelFrame:hasExclaveInKernelStack:haveUserStack:leafUserFrame:swiftTaskId:leafOfCRootFramesReplacedBySwiftAsync:threadExclavesInfo:haveSched:systemCpuTimeNs:userCpuTimeNs:basePriority:scheduledPriority:state:threadQos:threadRequestedQos:threadRequestedQosOverride:threadQosPromote:haveCycIns:instructions:cycles:haveSnap:ioTier:isIOPassive:isDarwinBG:isSuspended:isGlobalForcedIdle:isIdleWorkQueue:lastMadeRunnableTime:isOnCore:isOnCoreForLastSampleIndex:cpuNum:]((void *)v226, v140, v243, v159, v44, v225 & 1, v227, 1, v237, v228, v223, v232 != 0, 1, v222, v221, v152, v232, 1, v219,
            v162,
            v165,
            v166,
            v167,
            v168,
            v169,
            v170,
            v154,
            v229 != 0,
            v171,
            v172,
            1,
            *(unsigned char *)(v173 + 103),
            (*(_DWORD *)(v224 + 64) & 0x20) != 0,
            (*(_DWORD *)(v224 + 64) & 0x10) != 0,
            a13 | ((*(_DWORD *)(v224 + 64) & 0x40u) >> 6),
            BYTE1(*(_DWORD *)(v224 + 64)) & 1,
            0,
            0,
            0,
            0,
            0xFFFFFFFF);
        }

LABEL_284:
        uint64_t v174 = 0;
        unsigned int v176 = a19;
        uint64_t v175 = a20;
        if (a14)
        {
          uint64_t v177 = a15;
          int v178 = 0;
          if (a15)
          {
            uint64_t v174 = a14;
            while (*(void *)(v174 + 8) != v122)
            {
              v174 += 31;
              if (!--v177)
              {
                uint64_t v174 = 0;
LABEL_298:
                int v178 = 0;
                goto LABEL_300;
              }
            }
            int v179 = *(__int16 *)(v174 + 25);
            if (!*(_WORD *)(v174 + 25)) {
              goto LABEL_298;
            }
            if (a19)
            {
              uint64_t v180 = a19;
              int v178 = a20;
              while (**v178 != (unsigned __int16)v179)
              {
                v178 += 2;
                if (!--v180) {
                  goto LABEL_295;
                }
              }
            }
            else
            {
LABEL_295:
              int v181 = *__error();
              uint64_t v182 = _sa_logt();
              if (os_log_type_enabled(v182, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__objc2_class buf = 67109120;
                LODWORD(v246) = v179;
                _os_log_error_impl(&dword_1BF22B000, v182, OS_LOG_TYPE_ERROR, "No port label info for id %d", buf, 8u);
              }

              int v178 = 0;
              *__error() = v181;
              unint64_t v123 = 0x1E4F28000;
              uint64_t v175 = a20;
              unsigned int v176 = a19;
            }
          }
        }
        else
        {
          int v178 = 0;
        }
LABEL_300:
        unint64_t v183 = v123;
        uint64_t v184 = 0;
        if (a16)
        {
          uint64_t v185 = a17;
          id v186 = 0;
          if (a17)
          {
            uint64_t v184 = a16;
            while (*(void *)v184 != v122)
            {
              v184 += 28;
              if (!--v185)
              {
                uint64_t v184 = 0;
LABEL_314:
                id v186 = 0;
                goto LABEL_316;
              }
            }
            int v187 = *(__int16 *)(v184 + 26);
            if (!*(_WORD *)(v184 + 26)) {
              goto LABEL_314;
            }
            if (v176)
            {
              uint64_t v188 = v176;
              id v186 = v175;
              while (**v186 != (unsigned __int16)v187)
              {
                v186 += 2;
                if (!--v188) {
                  goto LABEL_311;
                }
              }
            }
            else
            {
LABEL_311:
              int v238 = *__error();
              id v189 = _sa_logt();
              if (os_log_type_enabled(v189, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__objc2_class buf = 67109120;
                LODWORD(v246) = v187;
                _os_log_error_impl(&dword_1BF22B000, v189, OS_LOG_TYPE_ERROR, "No port label info for id %d", buf, 8u);
              }

              id v186 = 0;
              *__error() = v238;
            }
          }
        }
        else
        {
          id v186 = 0;
        }
LABEL_316:
        id v190 = [*(id *)(v183 + 3792) numberWithUnsignedLongLong:v122];
        [v242 addObject:v190];

        a2 = v241;
        uint64_t v218 = v186;
        long long v148 = v232;
        uint64_t v191 = p_dst;
        id v29 = v234;
        uint64_t v192 = -[SASampleStore addKCDataThreadV4:threadV2:deltaThreadV3:deltaThreadV2:timestamp:sampleIndex:stack:threadExclavesInfo:threadName:dispatchQueueLabel:waitInfo:waitInfoPortLabelInfo:turnstileInfo:turnstileInfoPortLabelInfo:instructionCycles:task:kernelTask:taskIsSuspended:]((id *)v226, v46, v191, v240, v239, v234, a4, v30, v232, (char *)v227, (id *)v228, v174, v178, v184, v218, v229, v243, v241, a13);
        uint64_t v31 = v230;
        if (v192)
        {
          int v193 = [*(id *)(v183 + 3792) numberWithUnsignedLongLong:v192];
          [v230 addObject:v193];
        }
        [v30 clearThreadData];
        uint64_t v39 = v243;
        uint64_t v35 = v233;
        goto LABEL_319;
      }
    }
    else
    {
      int v201 = *__error();
      BOOL v202 = _sa_logt();
      if (os_log_type_enabled(v202, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__objc2_class buf = 0;
        _os_log_error_impl(&dword_1BF22B000, v202, OS_LOG_TYPE_ERROR, "no thread_snap when primary data is kperf", buf, 2u);
      }

      *__error() = v201;
      _SASetCrashLogMessage(5373, "no thread_snap when primary data is kperf", v203, v204, v205, v206, v207, v208, v217);
      _os_crash();
      __break(1u);
    }
    int v209 = *__error();
    int v210 = _sa_logt();
    if (os_log_type_enabled(v210, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__objc2_class buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v210, OS_LOG_TYPE_ERROR, "no thread_snap when backfilling kperf", buf, 2u);
    }

    *__error() = v209;
    _SASetCrashLogMessage(5392, "no thread_snap when backfilling kperf", v211, v212, v213, v214, v215, v216, v217);
    _os_crash();
    __break(1u);
  }
  int v220 = v37;
  uint64_t v43 = 0;
  uint64_t v236 = 0;
  uint64_t v239 = 0;
  uint64_t v240 = 0;
  char v225 = 0;
  v227 = 0;
  int v228 = 0;
  v229 = 0;
  int v231 = 0;
  while (1)
  {
    if (&v42[v41[1]] > (char *)v36 || *v41 == -242132755) {
      goto LABEL_7;
    }
    uint64_t v27 = (void *)MEMORY[0x1C18A6A20]();
    KCLogIter((unsigned int *)*a2, (unint64_t)a2[1], 0);
    __int16 v51 = *a2;
    int v52 = **a2;
    unsigned int v53 = v52 & 0xFFFFFFF0;
    if ((v52 & 0xFFFFFFF0) == 0x20) {
      int v54 = 17;
    }
    else {
      int v54 = **a2;
    }
    if ((v54 - 1) > 5)
    {
      if (v54 <= 2309)
      {
        if (v54 != 17 && v54 != 19) {
          goto LABEL_38;
        }
        unsigned int v56 = v51[1];
        unsigned int v60 = v56;
LABEL_41:
        __int16 v55 = (unsigned int *)(v51 + 4);
        goto LABEL_42;
      }
      if (v54 == 2310)
      {
        unsigned int v56 = v51[1];
        if (v56 == 112 && (v51[2] & 0x8F) == 0)
        {
          unsigned int v60 = 104;
          goto LABEL_41;
        }
      }
      else
      {
        if (v54 != 2312)
        {
LABEL_38:
          unsigned int v56 = v51[1];
          goto LABEL_39;
        }
        unsigned int v56 = v51[1];
        if (v56 == 32 && (v51[2] & 0x8F) == 0)
        {
          unsigned int v60 = 24;
          goto LABEL_41;
        }
      }
LABEL_39:
      unsigned int v62 = v51[2] & 0xF;
      BOOL v58 = v56 >= v62;
      unsigned int v60 = v56 - v62;
      if (!v58) {
        unsigned int v60 = 0;
      }
      goto LABEL_41;
    }
    __int16 v55 = (unsigned int *)(v51 + 12);
    unsigned int v56 = v51[1];
    unsigned int v57 = v51[2] & 0xF;
    BOOL v58 = v56 >= v57;
    unsigned int v59 = v56 - v57;
    if (!v58) {
      unsigned int v59 = 0;
    }
    unsigned int v60 = v59 - 32;
LABEL_42:
    if (v54 > 2338)
    {
      if (v54 > 2353)
      {
        switch(v54)
        {
          case 2354:
            [v30 setSwiftAsyncStitchIndex:*v55];
            break;
          case 2369:
            if (v60 <= 0x3F) {
              uint64_t v73 = v240;
            }
            else {
              uint64_t v73 = (uint64_t)v55;
            }
            uint64_t v74 = v239;
            if (v60 <= 0x3F) {
              uint64_t v74 = (uint64_t)v55;
            }
            uint64_t v239 = v74;
            uint64_t v240 = v73;
            break;
          case 2376:
            [v30 setExclaveInsertionIndex:v55[2]];
            int v231 = v55;
            break;
        }
        goto LABEL_99;
      }
      if (v54 == 2339)
      {
        v229 = (uint64_t *)v55;
      }
      else if (v54 == 2344)
      {
        if (v60)
        {
          if (!*((unsigned char *)v55 + v60 - 1))
          {
            if (*(unsigned char *)v55)
            {
              int v228 = v55;
              goto LABEL_99;
            }
            uint64_t v63 = (unsigned int *)v43;
            int v66 = *__error();
            int v67 = _sa_logt();
            if (!os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_97;
            }
            *(_WORD *)__objc2_class buf = 0;
            uint64_t v68 = v67;
            unint64_t v69 = "WARNING: Empty dispatch queue label";
            goto LABEL_61;
          }
          uint64_t v63 = (unsigned int *)v43;
          int v66 = *__error();
          int v67 = _sa_logt();
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__objc2_class buf = 0;
            uint64_t v68 = v67;
            unint64_t v69 = "WARNING: dispatch queue label non NULL-terminated";
LABEL_61:
            uint32_t v70 = 2;
LABEL_96:
            _os_log_impl(&dword_1BF22B000, v68, OS_LOG_TYPE_DEFAULT, v69, buf, v70);
          }
        }
        else
        {
          uint64_t v63 = (unsigned int *)v43;
          int v66 = *__error();
          int v67 = _sa_logt();
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__objc2_class buf = 67109120;
            LODWORD(v246) = 0;
            uint64_t v68 = v67;
            unint64_t v69 = "WARNING: invalid dispatch queue label (size %d)";
            uint32_t v70 = 8;
            goto LABEL_96;
          }
        }
LABEL_97:

        *__error() = v66;
LABEL_98:
        uint64_t v43 = (uint64_t)v63;
      }
LABEL_99:
      goto LABEL_100;
    }
    if (v54 > 19)
    {
      if (v54 == 2310)
      {
        long long v75 = (unsigned int *)v236;
        if (v60 > 0x7F) {
          long long v75 = v55;
        }
        uint64_t v236 = (uint64_t)v75;
        if (v60 <= 0x7F) {
          uint64_t v43 = (uint64_t)v55;
        }
        goto LABEL_99;
      }
      if (v54 == 2313)
      {
        if (*((unsigned char *)v55 + v60 - 1))
        {
          uint64_t v63 = (unsigned int *)v43;
          int v64 = *__error();
          uint64_t v65 = _sa_logt();
          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__objc2_class buf = 0;
            _os_log_impl(&dword_1BF22B000, v65, OS_LOG_TYPE_DEFAULT, "WARNING: thread name non NULL-terminated", buf, 2u);
          }

          *__error() = v64;
          char v225 = 1;
          goto LABEL_98;
        }
        char v225 = 1;
        v227 = v55;
        goto LABEL_99;
      }
      if (v54 != 20) {
        goto LABEL_99;
      }
      int v155 = *((void *)v51 + 1);
      uint64_t v156 = v220;
      if (v220 == v155)
      {
        goto LABEL_7;
      }
      int v34 = *__error();
      uint64_t v28 = _sa_logt();
      a2 = v241;
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
LABEL_322:
        uint64_t v38 = 7;
        uint64_t v39 = v243;
        goto LABEL_248;
      }
LABEL_327:
      *(_DWORD *)__objc2_class buf = 134218240;
      unsigned int v246 = v156;
      __int16 v247 = 2048;
      int v248 = v155;
      _os_log_error_impl(&dword_1BF22B000, v28, OS_LOG_TYPE_ERROR, "Container end with wrong ID (%llu != %llu)", buf, 0x16u);
      goto LABEL_322;
    }
    unint64_t v71 = (unint64_t)a2[1];
    if (v54 == 17)
    {
      if ((unint64_t)(v51 + 4) > v71 || (unint64_t)v51 + v56 + 16 > v71 || v52 != 17 && v53 != 32) {
        goto LABEL_233;
      }
      unint64_t v76 = *((void *)v51 + 1);
      if (v76)
      {
        if (v52 == 17)
        {
          unint64_t v77 = HIDWORD(v76);
          if (SHIDWORD(v76) <= 2310)
          {
            switch(HIDWORD(v76))
            {
              case 0x30:
                unsigned int v78 = 20;
                break;
              case 0x31:
                unsigned int v78 = 24;
                break;
              case 0x81A:
LABEL_117:
                unsigned int v78 = 8;
                break;
              default:
                goto LABEL_233;
            }
          }
          else
          {
            switch(HIDWORD(v76))
            {
              case 0x907:
                unsigned int v78 = 4;
                break;
              case 0x908:
              case 0x909:
                goto LABEL_233;
              case 0x90A:
              case 0x90C:
                goto LABEL_117;
              case 0x90B:
              case 0x90D:
                unsigned int v78 = 16;
                break;
              default:
                if (HIDWORD(v76) != 2369) {
                  goto LABEL_233;
                }
                unsigned int v78 = 48;
                break;
            }
          }
          if (v56 / v78 < v76 || v56 % v76 >= 0x10)
          {
LABEL_233:
            int v34 = *__error();
            uint64_t v28 = _sa_logt();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)__objc2_class buf = 0;
              uint64_t v38 = 2;
              _os_log_error_impl(&dword_1BF22B000, v28, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: array is invalid", buf, 2u);
            }
            else
            {
              uint64_t v38 = 2;
            }
            goto LABEL_247;
          }
          goto LABEL_127;
        }
        unsigned int v81 = **a2 & 0xF;
        BOOL v58 = v56 >= v81;
        unsigned int v82 = v56 - v81;
        if (!v58) {
          goto LABEL_233;
        }
        if (v82 < v76) {
          goto LABEL_233;
        }
        unsigned int v80 = v82 / v76;
        if (v82 % v76) {
          goto LABEL_233;
        }
        unint64_t v77 = HIDWORD(v76);
      }
      else
      {
        if (v56) {
          goto LABEL_233;
        }
        unint64_t v77 = HIDWORD(v76);
        if (v52 == 17)
        {
LABEL_127:
          if ((int)v77 > 2310)
          {
            unsigned int v80 = 8;
            switch((int)v77)
            {
              case 2311:
                goto LABEL_99;
              case 2312:
              case 2313:
                goto LABEL_104;
              case 2314:
              case 2316:
                goto LABEL_130;
              case 2315:
              case 2317:
                unsigned int v80 = 16;
                goto LABEL_130;
              default:
                if (v77 != 2369) {
                  goto LABEL_104;
                }
                break;
            }
            goto LABEL_99;
          }
          if ((v77 - 48) < 2 || v77 == 2074) {
            goto LABEL_99;
          }
        }
LABEL_104:
        unsigned int v80 = 0;
      }
LABEL_130:
      switch((int)v77)
      {
        case 2314:
          unsigned int v83 = (char *)malloc_type_calloc(v76, 8uLL, 0x100004000313F17uLL);
          long long v84 = v83;
          if (v76)
          {
            unsigned int v85 = 0;
            uint64_t v86 = 0;
            int v87 = (void *)MEMORY[0x1E4F143A8];
            do
            {
              v244[41] = v87;
              v244[42] = (id)3221225472;
              v244[43] = __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke;
              v244[44] = &__block_descriptor_40_e39_v20__0I8r__stack_snapshot_frame32_II_12l;
              *(void *)&v83[v86] = *(unsigned int *)((char *)v55 + v85);
              v86 += 8;
              v85 += v80;
            }
            while (8 * v76 != v86);
            v244[45] = v83;
          }
          goto LABEL_164;
        case 2315:
          long long v92 = (char *)malloc_type_calloc(v76, 8uLL, 0x100004000313F17uLL);
          long long v84 = v92;
          if (v76)
          {
            unsigned int v93 = 0;
            uint64_t v94 = 0;
            int v95 = (void *)MEMORY[0x1E4F143A8];
            do
            {
              v244[31] = v95;
              v244[32] = (id)3221225472;
              v244[33] = __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_3;
              v244[34] = &__block_descriptor_40_e39_v20__0I8r__stack_snapshot_frame64_QQ_12l;
              *(void *)&v92[v94] = *(void *)((char *)v55 + v93);
              v94 += 8;
              v93 += v80;
            }
            while (8 * v76 != v94);
            v244[35] = v92;
          }
          goto LABEL_164;
        case 2316:
          id v96 = (char *)malloc_type_calloc(v76, 8uLL, 0x100004000313F17uLL);
          unsigned int v97 = v96;
          if (v76)
          {
            unsigned int v98 = 0;
            uint64_t v99 = 0;
            uint64_t v100 = (void *)MEMORY[0x1E4F143A8];
            do
            {
              v244[21] = v100;
              v244[22] = (id)3221225472;
              v244[23] = __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_5;
              v244[24] = &__block_descriptor_40_e39_v20__0I8r__stack_snapshot_frame32_II_12l;
              *(void *)&v96[v99] = *(unsigned int *)((char *)v55 + v98);
              v99 += 8;
              v98 += v80;
            }
            while (8 * v76 != v99);
            v244[25] = v96;
          }
          goto LABEL_173;
        case 2317:
          int v101 = (char *)malloc_type_calloc(v76, 8uLL, 0x100004000313F17uLL);
          unsigned int v97 = v101;
          if (v76)
          {
            unsigned int v102 = 0;
            uint64_t v103 = 0;
            int v104 = (void *)MEMORY[0x1E4F143A8];
            do
            {
              v244[11] = v104;
              v244[12] = (id)3221225472;
              v244[13] = __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_7;
              v244[14] = &__block_descriptor_40_e39_v20__0I8r__stack_snapshot_frame64_QQ_12l;
              *(void *)&v101[v103] = *(void *)((char *)v55 + v102);
              v103 += 8;
              v102 += v80;
            }
            while (8 * v76 != v103);
            v244[15] = v101;
          }
          goto LABEL_173;
        case 2318:
        case 2319:
        case 2320:
        case 2321:
        case 2322:
          goto LABEL_99;
        case 2323:
          int v105 = (char *)malloc_type_calloc(v76, 8uLL, 0x100004000313F17uLL);
          long long v84 = v105;
          if (v76)
          {
            unsigned int v106 = 0;
            uint64_t v107 = 0;
            uint64_t v108 = (void *)MEMORY[0x1E4F143A8];
            do
            {
              v244[36] = v108;
              v244[37] = (id)3221225472;
              v244[38] = __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_2;
              v244[39] = &__block_descriptor_40_e13_v20__0I8r_I12l;
              *(void *)&v105[v107] = *(unsigned int *)((char *)v55 + v106);
              v107 += 8;
              v106 += v80;
            }
            while (8 * v76 != v107);
            v244[40] = v105;
          }
          goto LABEL_164;
        case 2324:
          uint64_t v109 = (char *)malloc_type_calloc(v76, 8uLL, 0x100004000313F17uLL);
          long long v84 = v109;
          if (v76)
          {
            unsigned int v110 = 0;
            uint64_t v111 = 0;
            long long v112 = (void *)MEMORY[0x1E4F143A8];
            do
            {
              v244[26] = v112;
              v244[27] = (id)3221225472;
              v244[28] = __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_4;
              v244[29] = &__block_descriptor_40_e13_v20__0I8r_Q12l;
              *(void *)&v109[v111] = *(void *)((char *)v55 + v110);
              v111 += 8;
              v110 += v80;
            }
            while (8 * v76 != v111);
            v244[30] = v109;
          }
LABEL_164:
          [v30 setKernelFrames:v84];
          [v30 setNumKernelFrames:v76];
          goto LABEL_99;
        case 2325:
          unsigned int v113 = (char *)malloc_type_calloc(v76, 8uLL, 0x100004000313F17uLL);
          unsigned int v97 = v113;
          if (v76)
          {
            unsigned int v114 = 0;
            uint64_t v115 = 0;
            size_t v116 = (void *)MEMORY[0x1E4F143A8];
            do
            {
              v244[16] = v116;
              v244[17] = (id)3221225472;
              v244[18] = __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_6;
              v244[19] = &__block_descriptor_40_e13_v20__0I8r_I12l;
              *(void *)&v113[v115] = *(unsigned int *)((char *)v55 + v114);
              v115 += 8;
              v114 += v80;
            }
            while (8 * v76 != v115);
            v244[20] = v113;
          }
          goto LABEL_173;
        case 2326:
          uint64_t v117 = (char *)malloc_type_calloc(v76, 8uLL, 0x100004000313F17uLL);
          unsigned int v97 = v117;
          if (v76)
          {
            unsigned int v118 = 0;
            uint64_t v119 = 0;
            unsigned int v120 = (void *)MEMORY[0x1E4F143A8];
            do
            {
              v244[6] = v120;
              v244[7] = (id)3221225472;
              v244[8] = __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_8;
              v244[9] = &__block_descriptor_40_e13_v20__0I8r_Q12l;
              *(void *)&v117[v119] = *(void *)((char *)v55 + v118);
              v119 += 8;
              v118 += v80;
            }
            while (8 * v76 != v119);
            v244[10] = v117;
          }
LABEL_173:
          [v30 setUserFrames:v97];
          [v30 setNumUserFrames:v76];
          break;
        default:
          if (v77 == 2355)
          {
            unsigned int v88 = (char *)malloc_type_calloc(v76, 8uLL, 0x100004000313F17uLL);
            if (v76)
            {
              unsigned int v89 = 0;
              uint64_t v90 = 0;
              int v91 = (void *)MEMORY[0x1E4F143A8];
              do
              {
                v244[1] = v91;
                v244[2] = (id)3221225472;
                v244[3] = __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_9;
                v244[4] = &__block_descriptor_40_e13_v20__0I8r_Q12l;
                *(void *)&v88[v90] = *(void *)((char *)v55 + v89);
                v90 += 8;
                v89 += v80;
              }
              while (8 * v76 != v90);
              v244[5] = v88;
            }
            [v30 setSwiftAsyncFrames:v88];
            [v30 setNumSwiftAsyncFrames:v76];
          }
          break;
      }
      goto LABEL_99;
    }
    if (v54 != 19) {
      goto LABEL_99;
    }
    unsigned int v72 = v51 + 4;
    if ((unint64_t)v72 > v71 || (unint64_t)v72 + v56 > v71 || v53 == 32 || v52 != 19 || v56 <= 3) {
      break;
    }
    uint64_t v38 = SkipToContainerEnd(a2, 1);
    if (v38)
    {
      uint64_t v39 = v243;
      a2 = v241;
      goto LABEL_249;
    }
LABEL_100:
    uint64_t v36 = a2[1];
    uint64_t v79 = (char *)*a2 + (*a2)[1];
    uint64_t v41 = v79 + 16;
    *a2 = (int *)(v79 + 16);
    uint64_t v42 = v79 + 32;
    if (v42 > (char *)v36) {
      goto LABEL_7;
    }
  }
  int v34 = *__error();
  uint64_t v28 = _sa_logt();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__objc2_class buf = 67109120;
    LODWORD(v246) = 2308;
    _os_log_error_impl(&dword_1BF22B000, v28, OS_LOG_TYPE_ERROR, "Error parsing kcdata buffer: subcontainer of container type %u is invalid", buf, 8u);
  }
  uint64_t v38 = 1;
LABEL_247:
  uint64_t v39 = v243;
  a2 = v241;
LABEL_248:
  id v29 = v234;

  *__error() = v34;
LABEL_249:
  [v30 clearThreadData];
  uint64_t v31 = v230;
  uint64_t v35 = v233;
LABEL_320:

  return v38;
}

uint64_t __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke(uint64_t result, unsigned int a2, unsigned int *a3)
{
  *(void *)(*(void *)(result + 32) + 8 * a2) = *a3;
  return result;
}

uint64_t __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_2(uint64_t result, unsigned int a2, unsigned int *a3)
{
  *(void *)(*(void *)(result + 32) + 8 * a2) = *a3;
  return result;
}

uint64_t __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_3(uint64_t result, unsigned int a2, void *a3)
{
  *(void *)(*(void *)(result + 32) + 8 * a2) = *a3;
  return result;
}

uint64_t __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_4(uint64_t result, unsigned int a2, void *a3)
{
  *(void *)(*(void *)(result + 32) + 8 * a2) = *a3;
  return result;
}

uint64_t __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_5(uint64_t result, unsigned int a2, unsigned int *a3)
{
  *(void *)(*(void *)(result + 32) + 8 * a2) = *a3;
  return result;
}

uint64_t __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_6(uint64_t result, unsigned int a2, unsigned int *a3)
{
  *(void *)(*(void *)(result + 32) + 8 * a2) = *a3;
  return result;
}

uint64_t __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_7(uint64_t result, unsigned int a2, void *a3)
{
  *(void *)(*(void *)(result + 32) + 8 * a2) = *a3;
  return result;
}

uint64_t __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_8(uint64_t result, unsigned int a2, void *a3)
{
  *(void *)(*(void *)(result + 32) + 8 * a2) = *a3;
  return result;
}

uint64_t __328__SASampleStore__parseKCDataThreadContainer_timestampOfSample_sampleIndex_task_kernelTask_frameIterator_mainThreadID_primaryDataIsKPerf_addStaticInfoOnly_threadIDsInThisTaskThisSample_dispatchQueueIDsInThisTaskThisSample_taskIsSuspended_waitInfos_numWaitInfos_turnstileInfos_numTurnstileInfos_port_label_info_array_exclaveInfo___block_invoke_9(uint64_t result, unsigned int a2, void *a3)
{
  *(void *)(*(void *)(result + 32) + 8 * a2) = *a3;
  return result;
}

BOOL __77__SASampleStore_parseKCDataExclavesContainer_exclaveInfo_primaryDataIsKPerf___block_invoke(uint64_t a1, void *a2, unsigned char *a3)
{
  uint64_t v5 = [a2 address];
  uint64_t v6 = *(void *)(a1 + 32);
  if (v5 == v6) {
    *a3 = 1;
  }
  return v5 == v6;
}

BOOL __77__SASampleStore_parseKCDataExclavesContainer_exclaveInfo_primaryDataIsKPerf___block_invoke_335(uint64_t a1, void *a2, unsigned char *a3)
{
  uint64_t v5 = [a2 address];
  uint64_t v6 = *(void *)(a1 + 32);
  if (v5 == v6) {
    *a3 = 1;
  }
  return v5 == v6;
}

void __65__SASampleStore_parseKCDataExclavesIPCStackContainer_callstacks___block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3)
  {
    unint64_t v3 = *(void **)(a1 + 32);
    objc_msgSend(NSNumber, "numberWithUnsignedLongLong:");
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    [v3 insertObject:v6 atIndex:0];
  }
  else
  {
    int v4 = *__error();
    uint64_t v5 = _sa_logt();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__objc2_class buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v5, OS_LOG_TYPE_ERROR, "0 frame in exclave stack, ignoring", buf, 2u);
    }

    *__error() = v4;
  }
}

void __68__SASampleStore_parseKCDataExclavesTextLayoutContainer_textLayouts___block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void **)(a1 + 32);
  int v4 = -[SAKCDataExclaveTextLayoutSegment initWithInfo:]([SAKCDataExclaveTextLayoutSegment alloc], a3);
  [v3 addObject:v4];
}

void __44__SASampleStore_resampleTruncatedBacktraces__block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [v6 lastObject];
  if ([v7 pid] != -1 && objc_msgSend(v7, "pid"))
  {
    uint64_t v8 = [v7 exitTimestamp];
    if (v8 || (pid_t v9 = getpid(), v9 == [v7 pid]))
    {

      goto LABEL_6;
    }
    if (_AvoidSuspendingPid([v7 pid])) {
      goto LABEL_6;
    }
    uint64_t v31 = 0;
    id v32 = &v31;
    uint64_t v33 = 0x3032000000;
    int v34 = __Block_byref_object_copy__0;
    uint64_t v35 = __Block_byref_object_dispose__0;
    id v36 = 0;
    uint64_t v10 = [v7 threads];
    v30[0] = MEMORY[0x1E4F143A8];
    v30[1] = 3221225472;
    v30[2] = __44__SASampleStore_resampleTruncatedBacktraces__block_invoke_2;
    v30[3] = &unk_1E63F7D80;
    v30[4] = &v31;
    [v10 enumerateKeysAndObjectsUsingBlock:v30];

    if (!v32[5])
    {
LABEL_20:
      _Block_object_dispose(&v31, 8);

      goto LABEL_6;
    }
    uint64_t v11 = [v7 binaryLoadInfos];
    [*(id *)(a1 + 32) setUserBinaryLoadInfos:v11];

    if (v7) {
      uint64_t v12 = v7[73] & 1;
    }
    else {
      uint64_t v12 = 0;
    }
    [*(id *)(a1 + 32) setAssumeUserBinaryLoadInfosContainMainBinary:v12];
    int v13 = [v7 sharedCache];
    [*(id *)(a1 + 32) setSharedCache:v13];

    uint64_t v14 = *(void *)(a1 + 40);
    if (v14)
    {
      uint64_t v15 = *(void *)(v14 + 192);
      if (v7)
      {
LABEL_13:
        objc_copyStruct(&dest, v7 + 288, 8, 1, 0);
        if (v15)
        {
          if (dest)
          {
            CSArchitectureGetFamily();
            CSArchitectureGetFamily();
            if ((CSArchitectureMatchesArchitecture() & 1) == 0)
            {
              uint64_t v16 = -[SASampleStore addressTranslationsForPid:](*(void *)(a1 + 40), [v7 pid]);
              [*(id *)(a1 + 32) setAddressTranslations:v16];
            }
          }
        }
      }
    }
    else
    {
      uint64_t v15 = 0;
      if (v7) {
        goto LABEL_13;
      }
    }
    pid_t v17 = [v7 pid];
    id v18 = [(id)v32[5] allKeys];
    uint64_t v22 = MEMORY[0x1E4F143A8];
    uint64_t v23 = 3221225472;
    BOOL v24 = __44__SASampleStore_resampleTruncatedBacktraces__block_invoke_3;
    uint64_t v25 = &unk_1E63F76E0;
    uint64_t v28 = &v31;
    id v26 = *(id *)(a1 + 32);
    id v19 = v7;
    uint64_t v20 = *(void *)(a1 + 48);
    id v27 = v19;
    uint64_t v29 = v20;
    int v21 = SAResampleThreads(v17, v18, &v22);

    if (!v21) {
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
    }
    objc_msgSend(*(id *)(a1 + 32), "clearTaskData", v22, v23, v24, v25);

    goto LABEL_20;
  }
LABEL_6:
}

void __44__SASampleStore_resampleTruncatedBacktraces__block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v28 = a2;
  id v5 = a3;
  uint64_t v7 = v5;
  if (v5)
  {
    pid_t v9 = objc_getProperty(v5, v6, 48, 1);
    if (v9)
    {
LABEL_3:

      goto LABEL_6;
    }
    id Property = objc_getProperty(v7, v8, 56, 1);
  }
  else
  {
    id Property = 0;
  }
  id v11 = Property;

  if (!v11)
  {
    uint64_t v12 = [v7 threadStates];
    int v13 = [v12 lastObject];
    pid_t v9 = [v13 leafUserFrame];

    if (v9)
    {
LABEL_10:
      for (uint64_t i = (void *)v9[4]; ; uint64_t i = 0)
      {
        id v15 = i;

        if (!v15) {
          break;
        }
        if (v9) {
          uint64_t v16 = (void *)v9[4];
        }
        else {
          uint64_t v16 = 0;
        }
        pid_t v17 = v16;

        pid_t v9 = v17;
        if (v17) {
          goto LABEL_10;
        }
      }
      if ([v9 isTruncatedBacktraceFrame]) {
        goto LABEL_28;
      }
    }
    id v18 = [v7 threadStates];
    id v19 = [v18 lastObject];
    uint64_t v20 = [v19 leafOfCRootFramesReplacedBySwiftAsync];

    if (!v20)
    {
      pid_t v9 = 0;
      goto LABEL_3;
    }
    while (1)
    {
      pid_t v9 = v20;
      int v21 = v20 ? (void *)v20[4] : 0;
      id v22 = v21;

      if (!v22) {
        break;
      }
      if (v9) {
        uint64_t v23 = (void *)v9[4];
      }
      else {
        uint64_t v23 = 0;
      }
      uint64_t v20 = v23;
    }
    if (![v9 isTruncatedBacktraceFrame]) {
      goto LABEL_3;
    }
LABEL_28:
    BOOL v24 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
    if (!v24)
    {
      uint64_t v25 = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:8];
      uint64_t v26 = *(void *)(*(void *)(a1 + 32) + 8);
      id v27 = *(void **)(v26 + 40);
      *(void *)(v26 + 40) = v25;

      BOOL v24 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
    }
    [v24 setObject:v7 forKeyedSubscript:v28];
    goto LABEL_3;
  }
LABEL_6:
}

void __44__SASampleStore_resampleTruncatedBacktraces__block_invoke_3(uint64_t a1, void *a2, const void *a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  pid_t v9 = [NSNumber numberWithUnsignedLongLong:a2];
  uint64_t v10 = [v8 objectForKeyedSubscript:v9];

  if (!v10)
  {
    int v22 = *__error();
    uint64_t v23 = _sa_logt();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__objc2_class buf = 134217984;
      id v32 = a2;
      _os_log_error_impl(&dword_1BF22B000, v23, OS_LOG_TYPE_ERROR, "bad tid 0x%llx", buf, 0xCu);
    }

    *__error() = v22;
    _SASetCrashLogMessage(6692, "bad tid 0x%llx", v24, v25, v26, v27, v28, v29, (char)a2);
    _os_crash();
    __break(1u);
  }
  objc_msgSend(*(id *)(a1 + 32), "setUserFrames:", malloc_type_calloc(a4, 8uLL, 0x100004000313F17uLL));
  memcpy((void *)[*(id *)(a1 + 32) userFrames], a3, 8 * a4);
  [*(id *)(a1 + 32) setNumUserFrames:a4];
  uint64_t v12 = *(void **)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  id v30 = 0;
  int v13 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:](v11, v12, &v30);
  id v15 = v30;
  if (v13)
  {
    objc_setProperty_atomic(v10, v14, v13, 48);
    objc_setProperty_atomic(v10, v16, v15, 56);
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
  }
  else
  {
    int v17 = *__error();
    id v18 = _sa_logt();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      id v19 = [*(id *)(a1 + 40) debugDescription];
      uint64_t v20 = [v10 debugDescription];
      unsigned int v21 = [*(id *)(a1 + 32) numUserFrames];
      *(_DWORD *)__objc2_class buf = 138412802;
      id v32 = v19;
      __int16 v33 = 2112;
      int v34 = v20;
      __int16 v35 = 2048;
      uint64_t v36 = v21;
      _os_log_error_impl(&dword_1BF22B000, v18, OS_LOG_TYPE_ERROR, "%@ %@ unable to add resampled stack with %lu frames", buf, 0x20u);
    }
    *__error() = v17;
  }
  [*(id *)(a1 + 32) clearThreadData];
}

- (int)addMicrostackshotsFromFile:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8
{
  return [(SASampleStore *)self addMicrostackshotsFromFile:a3 ofTypes:*(void *)&a4 inTimeRangeStart:*(void *)&a7 end:a8 onlyPid:0 onlyTid:a5 statistics:a6];
}

- (int)addMicrostackshotsFromFile:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8 statistics:(id)a9
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  id v16 = a3;
  id v75 = a9;
  id v17 = v16;
  id v18 = (const char *)[v17 UTF8String];
  if (!v18)
  {
    *__error() = 22;
    int v32 = *__error();
    __int16 v33 = _sa_logt();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__objc2_class buf = 0;
      int v34 = "Unable to convert microstackshots path to C string";
LABEL_31:
      uint64_t v36 = v33;
      uint32_t v37 = 2;
      goto LABEL_32;
    }
LABEL_33:

    *__error() = v32;
    int v25 = -1;
    goto LABEL_48;
  }
  int v19 = open(v18, 0);
  if (v19 == -1)
  {
    int v32 = *__error();
    __int16 v33 = _sa_logt();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      int v35 = *__error();
      *(_DWORD *)__objc2_class buf = 67109120;
      *(_DWORD *)unsigned int v78 = v35;
      int v34 = "Unable to open microstackshots file: %{errno}d";
      uint64_t v36 = v33;
      uint32_t v37 = 8;
LABEL_32:
      _os_log_error_impl(&dword_1BF22B000, v36, OS_LOG_TYPE_ERROR, v34, buf, v37);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  gzFile v20 = gzdopen(v19, "r");
  if (!v20)
  {
    int v32 = *__error();
    __int16 v33 = _sa_logt();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__objc2_class buf = 0;
      int v34 = "Unable to gzdopen microstackshots file";
      goto LABEL_31;
    }
    goto LABEL_33;
  }
  unsigned int v21 = v20;
  id v71 = v17;
  int v22 = (char *)malloc_type_calloc(1uLL, 0x20000uLL, 0x6D7D62E3uLL);
  if (!v22) {
    goto LABEL_57;
  }
  uint64_t v23 = v22;
  int v24 = gzread(v21, v22, 0x20000u);
  if (v24 < 1)
  {
    int v25 = 0;
    goto LABEL_39;
  }
  int v25 = 0;
  size_t v26 = 0;
  uint64_t v27 = 0x20000;
  uint64_t v73 = v21;
  while (1)
  {
    size_t v28 = v26 + v24;
    if (v28) {
      break;
    }
    size_t v26 = 0;
LABEL_22:
    int v24 = gzread(v21, &v23[v26], v27 - v26);
    if (v24 <= 0)
    {
      if (v26) {
        goto LABEL_38;
      }
      goto LABEL_39;
    }
  }
  int v72 = v24;
  size_t __size = v27;
  unint64_t v29 = 0;
  while (1)
  {
    size_t v26 = v28 - v29;
    unsigned int v21 = (gzFile_s *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytesNoCopy:&v23[v29] length:v28 - v29 freeWhenDone:0];
    int64_t v30 = -[SASampleStore _addMicrostackshotFromData:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:]((uint64_t)self, v21, a4, a7, a8, v75, a5, a6);
    if (v30 <= 0) {
      break;
    }
    v29 += v30;
    if (v28 < v29)
    {
      int v25 = *__error();
      uint64_t v41 = _sa_logt();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__objc2_class buf = 134218240;
        *(void *)unsigned int v78 = v29;
        *(_WORD *)&v78[8] = 2048;
        *(void *)&v78[10] = v28;
        _os_log_error_impl(&dword_1BF22B000, v41, OS_LOG_TYPE_ERROR, "parsed beyond end of microstackshots buffer: %lu > %lu", buf, 0x16u);
      }

      *__error() = v25;
      _SASetCrashLogMessage(6786, "parsed beyond end of microstackshots buffer: %lu > %lu", v48, v49, v50, v51, v52, v53, v29);
      _os_crash();
      __break(1u);
LABEL_52:
      int v54 = *__error();
      *(_DWORD *)__objc2_class buf = 67109120;
      *(_DWORD *)unsigned int v78 = v54;
      uint64_t v44 = "Error while reading microstackshots file: %{errno}d";
      unsigned int v45 = v41;
      uint32_t v46 = 8;
LABEL_53:
      _os_log_error_impl(&dword_1BF22B000, v45, OS_LOG_TYPE_ERROR, v44, buf, v46);
      goto LABEL_46;
    }
    ++v25;

    size_t v26 = v28 - v29;
    if (v28 <= v29) {
      goto LABEL_16;
    }
  }
  if ((v30 & 0x8000000000000000) == 0)
  {

LABEL_16:
    unsigned int v21 = v73;
    if (!v26) {
      goto LABEL_19;
    }
    if (v29)
    {
      memmove(v23, &v23[v29], v26);
LABEL_19:
      uint64_t v27 = __size;
      goto LABEL_22;
    }
    uint64_t v27 = 2 * __size;
    uint64_t v31 = (char *)reallocf(v23, 2 * __size);
    if (v31)
    {
      uint64_t v23 = v31;
      goto LABEL_22;
    }
    int v55 = *__error();
    unsigned int v56 = _sa_logt();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__objc2_class buf = 134217984;
      *(void *)unsigned int v78 = 2 * __size;
      _os_log_error_impl(&dword_1BF22B000, v56, OS_LOG_TYPE_ERROR, "realloc of size %lu failed", buf, 0xCu);
    }

    *__error() = v55;
    _SASetCrashLogMessage(6799, "realloc of size %lu failed", v57, v58, v59, v60, v61, v62, 2 * __size);
    _os_crash();
    __break(1u);
LABEL_57:
    int v63 = *__error();
    int v64 = _sa_logt();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__objc2_class buf = 67109120;
      *(_DWORD *)unsigned int v78 = 0x20000;
      _os_log_error_impl(&dword_1BF22B000, v64, OS_LOG_TYPE_ERROR, "calloc of %d failed", buf, 8u);
    }

    *__error() = v63;
    _SASetCrashLogMessage(6752, "calloc of %d failed", v65, v66, v67, v68, v69, v70, 0);
    _os_crash();
    __break(1u);
  }
  if (!v25) {
    int v25 = -1;
  }

  size_t v26 = v28;
  unsigned int v21 = v73;
  int v24 = v72;
LABEL_38:
  int v38 = v24;
  objc_msgSend(v75, "setBytes_not_microstackshots:", objc_msgSend(v75, "bytes_not_microstackshots") + v26);
  int v24 = v38;
LABEL_39:
  if (v24 == -1)
  {
    errnuuint64_t m = 0;
    uint64_t v39 = gzerror(v21, &errnum);
    int v40 = errnum;
    LODWORD(v29) = *__error();
    uint64_t v41 = _sa_logt();
    BOOL v42 = os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
    if (v40 == -1)
    {
      if (v42) {
        goto LABEL_52;
      }
    }
    else if (v42)
    {
      uint64_t v43 = "";
      if (v39) {
        uint64_t v43 = v39;
      }
      *(_DWORD *)__objc2_class buf = 67109378;
      *(_DWORD *)unsigned int v78 = errnum;
      *(_WORD *)&v78[4] = 2080;
      *(void *)&v78[6] = v43;
      uint64_t v44 = "Error while reading microstackshots file: %d %s";
      unsigned int v45 = v41;
      uint32_t v46 = 18;
      goto LABEL_53;
    }
LABEL_46:

    *__error() = v29;
  }
  free(v23);
  gzclose(v21);
  id v17 = v71;
LABEL_48:

  return v25;
}

- (unint64_t)_addMicrostackshotFromData:(int)a3 ofTypes:(int)a4 inTimeRangeStart:(uint64_t)a5 end:(void *)a6 onlyPid:(double)a7 onlyTid:(double)a8 statistics:
{
  uint64_t v180 = *MEMORY[0x1E4F143B8];
  id v15 = a2;
  id v16 = a6;
  if (!a1)
  {
    unint64_t v22 = 0;
    goto LABEL_7;
  }
  uint64_t context = (void *)MEMORY[0x1C18A6A20]();
  id v17 = v15;
  uint64_t v18 = [v17 bytes];
  uint64_t v19 = [v17 length];
  unint64_t v20 = v19;
  if (!*(void *)(a1 + 360)) {
    *(void *)(a1 + 360) = 1;
  }
  *(void *)(a1 + 352) |= 4uLL;
  unint64_t v21 = v18 + v19;
  if (v18 + v19 < (unint64_t)(v18 + 27)) {
    goto LABEL_5;
  }
  if (*(_DWORD *)v18 != 835010577)
  {
    int v28 = *__error();
    unint64_t v29 = _sa_logt();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__objc2_class buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v29, OS_LOG_TYPE_ERROR, "Microstackshot buffer doesn't start with micro_snapshot", buf, 2u);
    }

    *__error() = v28;
    unint64_t v30 = v20 - 1;
    if (v20 - 1 >= 5)
    {
      unint64_t v31 = 0;
      while (*(_DWORD *)(v18 + 1 + v31) != 835010577)
      {
        if (v20 - 5 == ++v31) {
          goto LABEL_22;
        }
      }
      unint64_t v30 = v31;
    }
LABEL_22:
    unint64_t v22 = v30 + 1;
    int v32 = *__error();
    __int16 v33 = _sa_logt();
    int v34 = v33;
    if (v22 < v20)
    {
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
LABEL_26:

        *__error() = v32;
        objc_msgSend(v16, "setBytes_not_microstackshots:", objc_msgSend(v16, "bytes_not_microstackshots") + v22);
        goto LABEL_6;
      }
      *(_DWORD *)__objc2_class buf = 134217984;
      unint64_t v179 = v22;
LABEL_25:
      _os_log_impl(&dword_1BF22B000, v34, OS_LOG_TYPE_INFO, "Skipping %lu bytes until next microstackshot in the buffer", buf, 0xCu);
      goto LABEL_26;
    }
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__objc2_class buf = 134217984;
    unint64_t v179 = v20;
LABEL_72:
    _os_log_error_impl(&dword_1BF22B000, v34, OS_LOG_TYPE_ERROR, "Remaining %lu bytes do not contain any microstackshots", buf, 0xCu);
    goto LABEL_28;
  }
  uint64_t v24 = v18 + 320;
  if (v21 < v18 + 320) {
    goto LABEL_5;
  }
  if (*(_DWORD *)(v18 + 27) != -557122643)
  {
    int v35 = *__error();
    uint64_t v36 = _sa_logt();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__objc2_class buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v36, OS_LOG_TYPE_ERROR, "Microstackshot buffer doesn't contain task_snapshot after micro_snapshot", buf, 2u);
    }

    *__error() = v35;
    unint64_t v37 = v20 - 1;
    if (v20 - 1 >= 5)
    {
      unint64_t v38 = 0;
      while (*(_DWORD *)(v18 + 1 + v38) != 835010577)
      {
        if (v20 - 5 == ++v38) {
          goto LABEL_59;
        }
      }
      unint64_t v37 = v38;
    }
LABEL_59:
    unint64_t v22 = v37 + 1;
    int v32 = *__error();
    uint64_t v48 = _sa_logt();
    int v34 = v48;
    if (v22 < v20)
    {
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_INFO)) {
        goto LABEL_26;
      }
      *(_DWORD *)__objc2_class buf = 134217984;
      unint64_t v179 = v22;
      goto LABEL_25;
    }
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_DWORD *)__objc2_class buf = 134217984;
    unint64_t v179 = v20;
    goto LABEL_72;
  }
  int v25 = *(_DWORD *)(v18 + 107);
  if (!*(_DWORD *)(v18 + 31))
  {
    if ((v25 & 2) == 0) {
      goto LABEL_13;
    }
LABEL_37:
    char v26 = 1;
    unsigned int v27 = 24;
    goto LABEL_38;
  }
  if (v25) {
    goto LABEL_37;
  }
LABEL_13:
  char v26 = 0;
  unsigned int v27 = 20;
LABEL_38:
  unsigned int v39 = *(_DWORD *)(v18 + 83);
  unint64_t v40 = v24 + v27 * (unint64_t)v39;
  if (v21 >= v40 && v21 >= v40 + 316)
  {
    if (*(_DWORD *)v40 == -17958194)
    {
      unint64_t v22 = 0;
      if ((*(unsigned char *)(v40 + 68) & 4) != 0) {
        uint64_t v41 = (uint64_t *)(v40 + 316);
      }
      else {
        uint64_t v41 = 0;
      }
      if ((*(unsigned char *)(v40 + 68) & 4) != 0) {
        BOOL v42 = (char *)(v40 + 324);
      }
      else {
        BOOL v42 = (char *)(v40 + 316);
      }
      char v43 = 2;
      if ((*(unsigned char *)(v40 + 68) & 2) != 0) {
        char v44 = 3;
      }
      else {
        char v44 = 2;
      }
      unint64_t v45 = (unint64_t)*(unsigned int *)(v40 + 4) << v44;
      if (*(unsigned char *)(v40 + 68)) {
        char v43 = 3;
      }
      unint64_t v46 = (unint64_t)&v42[v45 + ((unint64_t)*(unsigned int *)(v40 + 8) << v43)];
      if (v21 < v46) {
        goto LABEL_6;
      }
      unsigned int v151 = v27;
      char v153 = v26;
      uint64_t v163 = v24 + v27 * (unint64_t)v39;
      size_t count = *(unsigned int *)(v18 + 83);
      uint64_t v157 = v41;
      uint64_t __src = (v18 + 320);
      int v160 = *(_DWORD *)(v18 + 107);
      int v155 = v42;
      uint64_t v156 = &v42[v45];
      if (__strlcpy_chk() == 16) {
        __strlcpy_chk();
      }
      double v47 = (double)*(unint64_t *)(v18 + 8)
          - *MEMORY[0x1E4F1CF78]
          + (double)*(unint64_t *)(v18 + 16) / 1000000.0;
      if (a8 != 0.0 && v47 > a8)
      {
        unint64_t v22 = -2;
        goto LABEL_6;
      }
      unint64_t v22 = v46 - v18;
      if (a7 != 0.0 && v47 < a7
        || (a3 & 0xFFFFFFFB) != 0 && (a3 & 0xFB & *(unsigned char *)(v18 + 24)) == 0
        || (a4 & 0x80000000) == 0 && *(_DWORD *)(v18 + 31) != a4
        || a5 && *(void *)(v163 + 28) != a5)
      {
        objc_msgSend(v16, "setNum_microstackshots_filtered_out:", objc_msgSend(v16, "num_microstackshots_filtered_out") + 1);
        objc_msgSend(v16, "setBytes_microstackshots_filtered_out:", objc_msgSend(v16, "bytes_microstackshots_filtered_out") + v22);
        goto LABEL_6;
      }
      BOOL v54 = (*(unsigned char *)(a1 + 408) & 1) != 0 && v47 > SATimeOfBootForLiveMachine();
      int v55 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:v47];
      uint64_t v57 = (id *)(a1 + 48);
      unsigned int v56 = *(void **)(a1 + 48);
      if (v56 && [v56 ge:v55])
      {
        BOOL v142 = v54;
        __base = -[SASampleStore taskWithPid:atTimestamp:](a1, *(unsigned int *)(v18 + 31), v55);
        uint64_t v58 = [__base threads];
        uint64_t v59 = [NSNumber numberWithUnsignedLongLong:*(void *)(v163 + 28)];
        uint64_t v60 = [v58 objectForKeyedSubscript:v59];

        uint64_t v61 = [v60 firstThreadStateOnOrAfterTime:v55 sampleIndex:0x7FFFFFFFFFFFFFFFLL];
        uint64_t v62 = [v61 endTimestamp];
        obuint64_t j = v55;
        char v63 = [v62 eq:v55];

        if (v63)
        {
          uint64_t v64 = 2;
        }
        else
        {
          int v65 = *__error();
          uint64_t v66 = _sa_logt();
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
          {
            int v139 = *(_DWORD *)(v18 + 31);
            uint64_t v141 = _CopyStringForTime(3, v47);
            uint64_t v138 = [(__CFString *)v141 UTF8String];
            [*(id *)(a1 + 48) wallTime];
            *(_DWORD *)char v170 = 136315906;
            uint64_t v171 = buf;
            __int16 v172 = 1024;
            int v173 = v139;
            __int16 v174 = 2080;
            uint64_t v175 = v138;
            __int16 v176 = 2048;
            double v177 = v137 - v47;
            _os_log_error_impl(&dword_1BF22B000, v66, OS_LOG_TYPE_ERROR, "Not including microstackshot for %s [%d] at %s due being out of order (before previous by %fs)", v170, 0x26u);
          }
          *__error() = v65;
          uint64_t v64 = 4;
        }

        int v55 = obj;
        BOOL v54 = v142;
        uint64_t v57 = (id *)(a1 + 48);
      }
      else
      {
        uint64_t v64 = 0;
      }
      if count || ([(id)a1 keepMicrostackshotsWithoutLoadInfo])
      {
        if (!v64)
        {
          locatiouint64_t n = v57;
          char v143 = v54;
          id obja = v55;
          -[SAMicrostackshotStatistics addMicro:task:thread:size:errors:](v16, v18, v18 + 27, v163, v22, 0);
          int v140 = 0;
          if (!uuid_is_null((const unsigned __int8 *)(v18 + 59)))
          {
            int v140 = -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, v18 + 59, *(void *)(v18 + 75), -1);
          }
          if (count)
          {
            size_t v67 = count;
            uint64_t v68 = (unsigned __int8 *)malloc_type_calloc(count, 0x18uLL, 0x1000040504FFAC1uLL);
            __basea = v68;
            if (v153)
            {
              memmove(v68, __src, v151 * (unint64_t)count);
            }
            else
            {
              uint64_t v70 = (const unsigned __int8 *)(v18 + 324);
              id v71 = v68 + 8;
              do
              {
                *((void *)v71 - 1) = *((unsigned int *)v70 - 1);
                uuid_copy(v71, v70);
                v70 += 20;
                v71 += 24;
                --v67;
              }
              while (v67);
            }
            uint64_t v72 = 0;
            unsigned int v69 = 0;
            if (count <= 1) {
              uint64_t v73 = 1;
            }
            else {
              uint64_t v73 = count;
            }
            uint64_t v74 = __basea + 8;
            do
            {
              if (!uuid_is_null(v74))
              {
                uint64_t v75 = *((void *)v74 - 1);
                if (v75)
                {
                  if (v72 != v69)
                  {
                    unint64_t v76 = &__basea[24 * v69];
                    *(void *)unint64_t v76 = v75;
                    uuid_copy(v76 + 8, v74);
                  }
                  ++v69;
                }
              }
              ++v72;
              v74 += 24;
            }
            while (v73 != v72);
            BOOL v78 = count != v69 && v69 != 0;
            int counta = v78;
            if (v69 && *(_DWORD *)(v18 + 31))
            {
              mergesort_b(__basea, v69, 0x18uLL, &__block_literal_global_358);
              uint64_t __src = __basea;
            }
            else
            {
              uint64_t __src = __basea;
            }
          }
          else
          {
            unsigned int v69 = 0;
            __basea = 0;
            int counta = 0;
          }
          if (*(unsigned char *)(a1 + 408))
          {
            if (!*(void *)(a1 + 192)) {
              [(id)a1 gatherMachineArchitecture];
            }
            if (!*(_DWORD *)(a1 + 184) || !*(_DWORD *)(a1 + 188)) {
              mach_timebase_info((mach_timebase_info_t)(a1 + 184));
            }
            if (!*(_DWORD *)(a1 + 344) || !*(_DWORD *)(a1 + 348))
            {
              -[SASampleStore gatherHWPageSize]((int *)a1);
              -[SASampleStore gatherVMPageSize]((int *)a1);
            }
          }
          else if (!*(unsigned char *)(a1 + 288))
          {
            uint64_t v79 = (FILE **)MEMORY[0x1E4F143C8];
            if (!*(void *)(a1 + 192))
            {
              int v80 = *__error();
              unsigned int v81 = _sa_logt();
              if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)char v170 = 0;
                _os_log_impl(&dword_1BF22B000, v81, OS_LOG_TYPE_DEFAULT, "WARNING: Machine architecture unknown for microstackshots, task architectures will be unknown", v170, 2u);
              }

              *__error() = v80;
              fwrite("Machine architecture unknown for microstackshots, task architectures will be unknown\n", 0x55uLL, 1uLL, *v79);
              *(unsigned char *)(a1 + 288) = 1;
            }
            if (!*(_DWORD *)(a1 + 184) || !*(_DWORD *)(a1 + 188))
            {
              int v82 = *__error();
              unsigned int v83 = _sa_logt();
              if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)char v170 = 0;
                _os_log_impl(&dword_1BF22B000, v83, OS_LOG_TYPE_DEFAULT, "WARNING: Mach timebase unknown for microstackshots, cpu times will be unknown", v170, 2u);
              }

              *__error() = v82;
              fwrite("Mach timebase unknown for microstackshots, cpu times will be unknown\n", 0x45uLL, 1uLL, *v79);
              *(unsigned char *)(a1 + 288) = 1;
            }
            if (!*(_DWORD *)(a1 + 344) || !*(_DWORD *)(a1 + 348))
            {
              int v84 = *__error();
              unsigned int v85 = _sa_logt();
              if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)char v170 = 0;
                _os_log_impl(&dword_1BF22B000, v85, OS_LOG_TYPE_DEFAULT, "WARNING: Page sizes unknown for microstackshots, task footprints will be unknown", v170, 2u);
              }

              *__error() = v84;
              fwrite("Page sizes unknown for microstackshots, task footprints will be unknown\n", 0x48uLL, 1uLL, *v79);
              *(unsigned char *)(a1 + 288) = 1;
            }
          }
          if ((v160 & 0x10000000) != 0 && (uint64_t v86 = *(void *)(a1 + 192)) != 0) {
            uint64_t v87 = SAArchitectureForTranslatedTask(v86);
          }
          else {
            uint64_t v87 = 0;
          }
          if (!*(void *)(a1 + 40)) {
            objc_storeStrong((id *)(a1 + 40), obja);
          }
          objc_storeStrong(location, obja);
          ++*(void *)(a1 + 32);
          uint64_t v88 = -[SASampleStore taskForMicrostackshotTask:taskName:loadInfos:numLoadInfos:sharedCache:loadInfosIsPartial:timestamp:architecture:needAOTInfo:isFromCurrentBoot:](a1, v18 + 27, (char *)buf, __src, v69, v140, counta, obja, v87, (v160 & 0x10000000) != 0, v143);
          uint64_t v89 = v88;
          uint64_t v90 = *(void *)(v18 + 111);
          int v154 = *(_DWORD *)(v18 + 119);
          int locationa = *(_DWORD *)(v18 + 123);
          if (v90 && v88) {
            *(void *)(v88 + 144) = v90;
          }
          uint64_t v91 = +[SATaskState stateWithStackshotTaskV1:machTimebase:hwPageSize:startTimestamp:endTimestamp:startSampleIndex:endSampleIndex:]((uint64_t)SATaskState, v18 + 27, *(void *)(a1 + 184), *(_DWORD *)(a1 + 344), obja, obja, 0x7FFFFFFFFFFFFFFFLL, 0x7FFFFFFFFFFFFFFFLL);
          if (v89)
          {
            [*(id *)(v89 + 8) addObject:v91];
            [*(id *)(v89 + 8) count];
          }
          id v152 = (void *)v91;
          long long v92 = [(id)v89 threads];
          unsigned int v93 = [NSNumber numberWithUnsignedLongLong:*(void *)(v163 + 28)];
          uint64_t v94 = [v92 objectForKeyedSubscript:v93];

          if (!v94)
          {
            uint64_t v94 = +[SAThread threadWithId:]((uint64_t)SAThread, *(void *)(v163 + 28));
            -[SATask addThread:](v89, v94);
          }
          __srca = (id *)v94;
          int v95 = objc_alloc_init(SAFrameIterator);
          [(SAFrameIterator *)v95 setBacktracer:2];
          int v96 = *(_DWORD *)(v18 + 31);
          unsigned int v97 = [(id)v89 binaryLoadInfos];
          countb = v95;
          if (v96)
          {
            [(SAFrameIterator *)v95 setUserBinaryLoadInfos:v97];

            if (v89) {
              uint64_t v98 = *(unsigned char *)(v89 + 73) & 1;
            }
            else {
              uint64_t v98 = 0;
            }
            [(SAFrameIterator *)v95 setAssumeUserBinaryLoadInfosContainMainBinary:v98];
            uint64_t v99 = [(id)v89 sharedCache];
            [(SAFrameIterator *)v95 setSharedCache:v99];

            if ((v160 & 0x10000000) == 0)
            {
LABEL_178:
              unsigned int v100 = *(_DWORD *)(v163 + 8);
              if (v100)
              {
                uint64_t v101 = *(unsigned __int16 *)(v163 + 74);
                uint64_t v144 = (uint64_t)((unint64_t)(((v101 - 1) < 0xFFFE) & (v100 > v101)) << 63) >> 63;
                if ((v101 - 1) < 0xFFFE && v100 > v101) {
                  size_t v102 = *(unsigned __int16 *)(v163 + 74);
                }
                else {
                  size_t v102 = v100;
                }
                if ((v101 - 1) < 0xFFFE && v100 > v101) {
                  size_t v103 = v100 - v101;
                }
                else {
                  size_t v103 = 0;
                }
                size_t v161 = v103;
                int v104 = malloc_type_calloc(v102, 8uLL, 0x100004000313F17uLL);
                int v105 = v104;
                if (*(unsigned char *)(v163 + 68))
                {
                  memcpy(v104, v156, 8 * v102);
                }
                else if (v102)
                {
                  unsigned int v106 = (unsigned int *)v156;
                  uint64_t v107 = v104;
                  size_t v108 = v102;
                  do
                  {
                    unsigned int v109 = *v106++;
                    *v107++ = v109;
                    --v108;
                  }
                  while (v108);
                }
                [(SAFrameIterator *)v95 setUserFrames:v105];
                [(SAFrameIterator *)v95 setNumUserFrames:v102];
                if (v161)
                {
                  unsigned int v110 = malloc_type_calloc(v161, 8uLL, 0x100004000313F17uLL);
                  uint64_t v111 = v110;
                  if (*(unsigned char *)(v163 + 68))
                  {
                    memcpy(v110, &v156[8 * v101], 8 * v161);
                  }
                  else
                  {
                    long long v112 = &v156[4 * v101];
                    unsigned int v113 = v110;
                    size_t v114 = v161;
                    do
                    {
                      unsigned int v115 = *(_DWORD *)v112;
                      v112 += 4;
                      *v113++ = v115;
                      --v114;
                    }
                    while (v114);
                  }
                  [(SAFrameIterator *)v95 setSwiftAsyncFrames:v111];
                  [(SAFrameIterator *)v95 setNumSwiftAsyncFrames:v161];
                  [(SAFrameIterator *)v95 setSwiftAsyncStitchIndex:v102];
                }
              }
              else
              {
                uint64_t v144 = 0;
              }
              uint64_t v116 = v163;
              size_t v117 = *(unsigned int *)(v163 + 4);
              if (v117)
              {
                unsigned int v118 = malloc_type_calloc(v117, 8uLL, 0x100004000313F17uLL);
                uint64_t v119 = v118;
                uint64_t v120 = *(unsigned int *)(v163 + 4);
                if ((*(unsigned char *)(v163 + 68) & 2) != 0)
                {
                  memcpy(v118, v155, 8 * v120);
                }
                else
                {
                  uint64_t v121 = (unsigned int *)v155;
                  if (v120)
                  {
                    uint64_t v122 = v118;
                    do
                    {
                      unsigned int v123 = *v121++;
                      *v122++ = v123;
                      --v120;
                    }
                    while (v120);
                  }
                }
                [(SAFrameIterator *)v95 setKernelFrames:v119];
                uint64_t v116 = v163;
                [(SAFrameIterator *)v95 setNumKernelFrames:*(unsigned int *)(v163 + 4)];
              }
              id v169 = 0;
              uint64_t v124 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:](v89, v95, &v169);
              id v162 = v169;
              uint64_t v164 = (void *)v124;
              uint64_t v125 = +[SAThreadStateMicrostackshot stateWithMicrostackshot:v18 thread:v116 startTimestamp:obja endTimestamp:obja startSampleIndex:0x7FFFFFFFFFFFFFFFLL endSampleIndex:0x7FFFFFFFFFFFFFFFLL leafUserFrame:v124 leafOfCRootFramesReplacedBySwiftAsync:v162 leafKernelFrame:0 machTimebase:*(void *)(a1 + 184)];
              unsigned int v126 = (id *)v125;
              if (v154 != -1)
              {
                if (!v125)
                {
LABEL_214:
                  uint64_t v127 = (uint64_t)__srca;
                  if (__srca)
                  {
                    [__srca[1] addObject:v125];
                    uint64_t v127 = [__srca[1] count] - 1;
                  }
                  if (v157)
                  {
                    unsigned int v128 = [(id)v89 dispatchQueues];
                    int v129 = [NSNumber numberWithUnsignedLongLong:*v157];
                    uint64_t v130 = [v128 objectForKeyedSubscript:v129];

                    if (!v130)
                    {
                      +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SADispatchQueue, *v157);
                      uint64_t v130 = (unsigned char *)objc_claimAutoreleasedReturnValue();
                      -[SATask addDispatchQueue:](v89, v130);
                    }
                    uint64_t v131 = +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SADispatchQueueState, __srca, v127);
                    if (v130)
                    {
                      if (v130[24]) {
                        unsigned int v132 = 0;
                      }
                      else {
                        unsigned int v132 = v130 + 24;
                      }
                      -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v130, v131, v132);
                    }
                  }
                  if (v144)
                  {
                    int v133 = [NSNumber numberWithUnsignedLongLong:-1];
                    uint64_t v134 = [(id)v89 swiftTasks];
                    int v135 = [v134 objectForKeyedSubscript:v133];

                    if (!v135)
                    {
                      int v135 = +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SASwiftTask, -1);
                      -[SATask addSwiftTask:](v89, v135);
                    }
                    if (v126) {
                      objc_storeWeak(v126 + 15, v135);
                    }
                    unsigned int v136 = +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SASwiftTaskState, __srca, v127);
                    if (v135) {
                      -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v135, v136, 0);
                    }
                  }
                  else if (v126)
                  {
                    objc_storeWeak(v126 + 15, 0);
                  }
                  if (__basea) {
                    free(__basea);
                  }

                  int v55 = obja;
                  goto LABEL_238;
                }
                *(_DWORD *)(v125 + 28) = v154;
              }
              if (locationa != -1 && v125) {
                *(_DWORD *)(v125 + 32) = locationa;
              }
              goto LABEL_214;
            }
            unsigned int v97 = -[SASampleStore addressTranslationsForPid:](a1, [(id)v89 pid]);
            [(SAFrameIterator *)v95 setAddressTranslations:v97];
          }
          else
          {
            [(SAFrameIterator *)v95 setKernelBinaryLoadInfos:v97];
          }

          goto LABEL_178;
        }
      }
      else
      {
        ++*(void *)(a1 + 280);
        v64 |= 8uLL;
      }
      -[SAMicrostackshotStatistics addMicro:task:thread:size:errors:](v16, v18, v18 + 27, v163, v22, v64);
LABEL_238:

      goto LABEL_6;
    }
    int v49 = *__error();
    uint64_t v50 = _sa_logt();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__objc2_class buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v50, OS_LOG_TYPE_ERROR, "Microstackshot buffer doesn't contain thread_snapshot after task_snapshot", buf, 2u);
    }

    *__error() = v49;
    unint64_t v51 = v20 - 1;
    if (v20 - 1 >= 5)
    {
      unint64_t v52 = 0;
      while (*(_DWORD *)(v18 + 1 + v52) != 835010577)
      {
        if (v20 - 5 == ++v52) {
          goto LABEL_74;
        }
      }
      unint64_t v51 = v52;
    }
LABEL_74:
    unint64_t v22 = v51 + 1;
    int v32 = *__error();
    uint64_t v53 = _sa_logt();
    int v34 = v53;
    if (v22 < v20)
    {
      if (!os_log_type_enabled(v53, OS_LOG_TYPE_INFO)) {
        goto LABEL_26;
      }
      *(_DWORD *)__objc2_class buf = 134217984;
      unint64_t v179 = v22;
      goto LABEL_25;
    }
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__objc2_class buf = 134217984;
      unint64_t v179 = v20;
      goto LABEL_72;
    }
LABEL_28:

    *__error() = v32;
    objc_msgSend(v16, "setBytes_not_microstackshots:", objc_msgSend(v16, "bytes_not_microstackshots") + v20);
    unint64_t v22 = -1;
    goto LABEL_6;
  }
LABEL_5:
  unint64_t v22 = 0;
LABEL_6:
LABEL_7:

  return v22;
}

- (int64_t)addMicrostackshotsFromData:(id)a3 ofTypes:(unsigned int)a4 inTimeRangeStart:(double)a5 end:(double)a6 onlyPid:(int)a7 onlyTid:(unint64_t)a8 statistics:(id)a9
{
  id v16 = a3;
  id v17 = a9;
  unint64_t v18 = 0;
  if ([v16 length])
  {
    while (1)
    {
      id v19 = objc_alloc(MEMORY[0x1E4F1C9B8]);
      id v20 = v16;
      unint64_t v21 = objc_msgSend(v19, "initWithBytesNoCopy:length:freeWhenDone:", objc_msgSend(v20, "bytes") + v18, objc_msgSend(v20, "length") - v18, 0);
      int64_t v22 = -[SASampleStore _addMicrostackshotFromData:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:]((uint64_t)self, v21, a4, a7, a8, v17, a5, a6);
      unint64_t v23 = v22;
      if (v22 <= 0) {
        break;
      }
      v18 += v22;

      if (v18 >= [v20 length]) {
        goto LABEL_10;
      }
    }

    if (v23) {
      BOOL v24 = v18 == 0;
    }
    else {
      BOOL v24 = 0;
    }
    if (v24) {
      unint64_t v18 = v23;
    }
  }
LABEL_10:

  return v18;
}

uint64_t __100__SASampleStore__addMicrostackshotFromData_ofTypes_inTimeRangeStart_end_onlyPid_onlyTid_statistics___block_invoke(uint64_t a1, void *a2, void *a3)
{
  if (*a3 <= *a2) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = -1;
  }
  if (*a3 < *a2) {
    return 1;
  }
  else {
    return v3;
  }
}

- (void)addUserCallstack:(unint64_t *)a3 numUserFrames:(unsigned int)a4 swiftAsyncCallstack:(unint64_t *)a5 numSwiftAsyncFrames:(unsigned int)a6 swiftAsyncStartIndex:(unsigned int)a7 kernelCallstack:(unint64_t *)a8 numKernelFrames:(unsigned int)a9 uniquePid:(unint64_t)a10 pid:(int)a11 tid:(unint64_t)a12 timestamp:(id)a13
{
  LODWORD(v16) = a11;
  LODWORD(v15) = 0;
  LODWORD(v14) = 0;
  LODWORD(v13) = a9;
  -[SASampleStore addUserCallstack:numUserFrames:swiftAsyncCallstack:numSwiftAsyncFrames:swiftAsyncStartIndex:kernelCallstack:numKernelFrames:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:uniquePid:pid:processName:tid:timestamp:sharedCache:](self, "addUserCallstack:numUserFrames:swiftAsyncCallstack:numSwiftAsyncFrames:swiftAsyncStartIndex:kernelCallstack:numKernelFrames:loadInfos:numLoadInfos:textExecLoadInfos:numTextExecLoadInfos:uniquePid:pid:processName:tid:timestamp:sharedCache:", a3, *(void *)&a4, a5, *(void *)&a6, *(void *)&a7, a8, v13, 0, v14, 0, v15, a10, v16, 0, a12, a13,
    0);
}

- (void)addUserCallstack:(unint64_t *)a3 numUserFrames:(unsigned int)a4 swiftAsyncCallstack:(unint64_t *)a5 numSwiftAsyncFrames:(unsigned int)a6 swiftAsyncStartIndex:(unsigned int)a7 kernelCallstack:(unint64_t *)a8 numKernelFrames:(unsigned int)a9 loadInfos:(const dyld_uuid_info_64 *)a10 numLoadInfos:(unsigned int)a11 textExecLoadInfos:(const dyld_uuid_info_64 *)a12 numTextExecLoadInfos:(unsigned int)a13 uniquePid:(unint64_t)a14 pid:(int)a15 processName:(id)a16 tid:(unint64_t)a17 timestamp:(id)a18 sharedCache:(id)a19
{
  uint64_t v19 = *(void *)&a6;
  uint64_t v20 = *(void *)&a4;
  id v22 = a16;
  id v67 = a18;
  id v66 = a19;
  uint64_t v23 = MEMORY[0x1C18A6A20]();
  self->_dataSource |= 0x10uLL;
  int v65 = (void *)v23;
  if (self->_dataGatheringOptions)
  {
    if (!*(void *)&self->_arch) {
      [(SASampleStore *)self gatherMachineArchitecture];
    }
    if (!self->_machTimebase.numer || !self->_machTimebase.denom) {
      mach_timebase_info(&self->_machTimebase);
    }
    if (!self->_hwPageSize || !self->_vmPageSize)
    {
      -[SASampleStore gatherHWPageSize]((int *)self);
      -[SASampleStore gatherVMPageSize]((int *)self);
    }
  }
  else if (!self->_reportedMissingMachineInfoForCustomCallstacks)
  {
    BOOL v24 = (FILE **)MEMORY[0x1E4F143C8];
    if (!*(void *)&self->_arch)
    {
      int v25 = *__error();
      char v26 = _sa_logt();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__objc2_class buf = 0;
        _os_log_impl(&dword_1BF22B000, v26, OS_LOG_TYPE_DEFAULT, "WARNING: Machine architecture unknown, task architectures will be unknown", buf, 2u);
      }

      *__error() = v25;
      fwrite("Machine architecture unknown, task architectures will be unknown\n", 0x41uLL, 1uLL, *v24);
      self->_reportedMissingMachineInfoForCustomCallstacks = 1;
    }
    if (!self->_machTimebase.numer || !self->_machTimebase.denom)
    {
      int v27 = *__error();
      int v28 = _sa_logt();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v70 = 0;
        _os_log_impl(&dword_1BF22B000, v28, OS_LOG_TYPE_DEFAULT, "WARNING: Mach timebase unknown, cpu times will be unknown", v70, 2u);
      }

      *__error() = v27;
      fwrite("Mach timebase unknown, cpu times will be unknown\n", 0x31uLL, 1uLL, *v24);
      self->_reportedMissingMachineInfoForCustomCallstacks = 1;
    }
    if (!self->_hwPageSize || !self->_vmPageSize)
    {
      int v29 = *__error();
      unint64_t v30 = _sa_logt();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unsigned int v69 = 0;
        _os_log_impl(&dword_1BF22B000, v30, OS_LOG_TYPE_DEFAULT, "WARNING: Page sizes unknown, task footprints will be unknown", v69, 2u);
      }

      *__error() = v29;
      fwrite("Page sizes unknown, task footprints will be unknown\n", 0x34uLL, 1uLL, *v24);
      self->_reportedMissingMachineInfoForCustomCallstacks = 1;
    }
  }
  if (!self->_startTime) {
    objc_storeStrong((id *)&self->_startTime, a18);
  }
  objc_storeStrong((id *)&self->_endTime, a18);
  ++self->_numSamples;
  id v64 = v22;
  -[SASampleStore _taskForPid:uniquePid:name:pidStartTime:loadInfos:numLoadInfos:loadInfosIsPartial:textExecLoadInfos:numTextExecLoadInfos:textExecLoadInfosIsPartial:architecture:timestamp:sharedCache:needAOTInfo:](self, a15, a14, (unsigned char *)[v64 UTF8String], 0, a10, a11, 0, a12, a13, 0, 0, v67, v66, 0);
  unint64_t v31 = (unsigned char *)objc_claimAutoreleasedReturnValue();
  int v32 = [v31 threads];
  __int16 v33 = [NSNumber numberWithUnsignedLongLong:a17];
  int v34 = [v32 objectForKeyedSubscript:v33];

  if (!v34)
  {
    +[SAThread threadWithId:]((uint64_t)SAThread, a17);
    int v34 = (id *)objc_claimAutoreleasedReturnValue();
    -[SATask addThread:]((uint64_t)v31, v34);
  }
  int v35 = objc_alloc_init(SAFrameIterator);
  [(SAFrameIterator *)v35 setBacktracer:0];
  uint64_t v36 = [v31 binaryLoadInfos];
  if (a15)
  {
    [(SAFrameIterator *)v35 setUserBinaryLoadInfos:v36];

    if (v31) {
      uint64_t v37 = v31[73] & 1;
    }
    else {
      uint64_t v37 = 0;
    }
    [(SAFrameIterator *)v35 setAssumeUserBinaryLoadInfosContainMainBinary:v37];
    unint64_t v38 = [v31 sharedCache];
    [(SAFrameIterator *)v35 setSharedCache:v38];

    unsigned int v39 = -[SASampleStore lastTaskWithPid:](self, 0);
    if (!v39)
    {
      if (a14 == -1) {
        uint64_t v40 = -1;
      }
      else {
        uint64_t v40 = 0;
      }
      unsigned int v39 = +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, 0, v40, 0, 0);
      -[SASampleStore addTask:]((uint64_t)self, v39);
    }
  }
  else
  {
    [(SAFrameIterator *)v35 setKernelBinaryLoadInfos:v36];

    unsigned int v39 = 0;
  }
  if (v20)
  {
    [(SAFrameIterator *)v35 setUserFrames:malloc_type_malloc(8 * v20, 0x100004000313F17uLL)];
    memmove([(SAFrameIterator *)v35 userFrames], a3, 8 * v20);
    [(SAFrameIterator *)v35 setNumUserFrames:v20];
  }
  if (v19)
  {
    [(SAFrameIterator *)v35 setSwiftAsyncFrames:malloc_type_malloc(8 * v19, 0x100004000313F17uLL)];
    memmove([(SAFrameIterator *)v35 swiftAsyncFrames], a5, 8 * v19);
    [(SAFrameIterator *)v35 setNumSwiftAsyncFrames:v19];
    [(SAFrameIterator *)v35 setSwiftAsyncStitchIndex:a7];
  }
  if (a9)
  {
    [(SAFrameIterator *)v35 setKernelFrames:malloc_type_malloc(8 * a9, 0x100004000313F17uLL)];
    memmove([(SAFrameIterator *)v35 kernelFrames], a8, 8 * a9);
    [(SAFrameIterator *)v35 setNumKernelFrames:a9];
  }
  if (a15)
  {
    id v68 = 0;
    uint64_t v41 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v31, v35, &v68);
    id v42 = v68;
  }
  else
  {
    id v42 = 0;
    uint64_t v41 = 0;
  }
  char v43 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v39, v35, 0);
  if (v19) {
    uint64_t v44 = -1;
  }
  else {
    uint64_t v44 = 0;
  }
  unint64_t v45 = +[SAThreadState stateWithStartTimestamp:v67 endTimestamp:v67 startSampleIndex:0x7FFFFFFFFFFFFFFFLL endSampleIndex:0x7FFFFFFFFFFFFFFFLL];
  double v47 = v45;
  if (v45)
  {
    objc_setProperty_atomic(v45, v46, v41, 64);
    objc_setProperty_atomic(v47, v48, v42, 72);
    objc_setProperty_atomic(v47, v49, v43, 80);
  }
  char v63 = v39;
  if (v34)
  {
    [v34[1] addObject:v47];
    uint64_t v50 = [v34[1] count] - 1;
    if (v19)
    {
LABEL_54:
      uint64_t v61 = v42;
      uint64_t v62 = v41;
      unint64_t v51 = [NSNumber numberWithUnsignedLongLong:v44];
      unint64_t v52 = [v31 swiftTasks];
      uint64_t v53 = [v52 objectForKeyedSubscript:v51];

      if (!v53)
      {
        uint64_t v53 = +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SASwiftTask, v44);
        -[SATask addSwiftTask:]((uint64_t)v31, v53);
      }
      if (v47) {
        objc_storeWeak(v47 + 15, v53);
      }
      BOOL v54 = +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SASwiftTaskState, v34, v50);
      id v42 = v61;
      if (v53) {
        -[SARecipe addState:hasConcurrentExecution:]((uint64_t)v53, v54, 0);
      }

      unsigned int v56 = v64;
      int v55 = v65;
      uint64_t v41 = v62;
      goto LABEL_64;
    }
  }
  else
  {
    uint64_t v50 = 0;
    if (v19) {
      goto LABEL_54;
    }
  }
  unsigned int v56 = v64;
  int v55 = v65;
  if (v47) {
    objc_storeWeak(v47 + 15, 0);
  }
LABEL_64:
}

- (BOOL)findCpuSignalHandlerStackLeafKernelFrame
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!self->_cpuSignalHandlerStackLeafKernelFrame)
  {
    uint64_t v4 = -[SASampleStore lastTaskWithPid:](self, 0);
    id v5 = (void *)v4;
    if (v4)
    {
      uint64_t v29 = 0;
      unint64_t v30 = &v29;
      uint64_t v31 = 0x3032000000;
      int v32 = __Block_byref_object_copy__0;
      __int16 v33 = __Block_byref_object_dispose__0;
      id v34 = 0;
      v28[0] = MEMORY[0x1E4F143A8];
      v28[1] = 3221225472;
      v28[2] = __57__SASampleStore_findCpuSignalHandlerStackLeafKernelFrame__block_invoke;
      v28[3] = &unk_1E63F7D58;
      v28[4] = &v29;
      -[SATask enumerateFrames:](v4, v28);
      id v6 = (void *)v30[5];
      if (v6)
      {
        p_cpuSignalHandlerStackLeafKernelFrame = &self->_cpuSignalHandlerStackLeafKernelFrame;
LABEL_6:
        id v6 = (void *)v6[5];
        while (1)
        {
          uint64_t v8 = v6;
          BOOL v9 = v8 == 0;

          uint64_t v10 = (void *)v30[5];
          if (v9) {
            break;
          }
          if (v10) {
            uint64_t v11 = (void *)v10[5];
          }
          else {
            uint64_t v11 = 0;
          }
          id v12 = v11;
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            id v13 = v12;
            uint64_t v14 = [v13 anyObject];
            uint64_t v15 = (void *)v30[5];
            void v30[5] = v14;
          }
          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              int v18 = *__error();
              uint64_t v19 = _sa_logt();
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
              {
                ClassName = object_getClassName(v12);
                *(_DWORD *)__objc2_class buf = 136315138;
                uint64_t v36 = ClassName;
                _os_log_error_impl(&dword_1BF22B000, v19, OS_LOG_TYPE_ERROR, "child is %s", buf, 0xCu);
              }

              *__error() = v18;
              char v21 = object_getClassName(v12);
              _SASetCrashLogMessage(7598, "child is %s", v22, v23, v24, v25, v26, v27, v21);
              _os_crash();
              __break(1u);
            }
            id v16 = v12;
            id v13 = (id)v30[5];
            void v30[5] = (uint64_t)v16;
          }

          id v6 = (void *)v30[5];
          if (v6) {
            goto LABEL_6;
          }
        }
        objc_storeStrong((id *)p_cpuSignalHandlerStackLeafKernelFrame, v10);
        _Block_object_dispose(&v29, 8);

        BOOL v2 = 1;
        goto LABEL_20;
      }
      _Block_object_dispose(&v29, 8);
    }
    BOOL v2 = 0;
LABEL_20:

    return v2;
  }
  return 1;
}

void __57__SASampleStore_findCpuSignalHandlerStackLeafKernelFrame__block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v6 = a2;
  uint64_t v7 = [v6 instruction];
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = __57__SASampleStore_findCpuSignalHandlerStackLeafKernelFrame__block_invoke_2;
  v10[3] = &unk_1E63F7730;
  uint64_t v8 = *(void *)(a1 + 32);
  id v11 = v6;
  uint64_t v12 = v8;
  uint64_t v13 = a4;
  id v9 = v6;
  [v7 enumerateSymbols:v10];
}

void __57__SASampleStore_findCpuSignalHandlerStackLeafKernelFrame__block_invoke_2(uint64_t a1, void *a2)
{
  unsigned int v3 = [a2 name];
  uint64_t v4 = v3;
  if (v3)
  {
    id v6 = v3;
    if (([v3 isEqualToString:@"cpu_signal_handler"] & 1) != 0
      || (v5 = [v6 isEqualToString:@"sync_iss_to_iks"], uint64_t v4 = v6, v5))
    {
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), *(id *)(a1 + 32));
      uint64_t v4 = v6;
      **(unsigned char **)(a1 + 48) = 1;
    }
  }
}

- (void)symbolicate
{
  BOOL v2 = self;
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  if ((self->_dataGatheringOptions & 0x78) == 0 && !self->_idsToUseDsymForUUID && !self->_namesToUseDsymForUUID) {
    return;
  }
  uint64_t v3 = mach_absolute_time();
  double v4 = SASecondsFromMachTimeUsingLiveTimebase(v3);
  int v5 = *__error();
  id v6 = _sa_logt();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__objc2_class buf = 0;
    _os_log_impl(&dword_1BF22B000, v6, OS_LOG_TYPE_INFO, "Symbolication starting", buf, 2u);
  }

  uint64_t v7 = 0;
  unsigned int v8 = 0;
  *__error() = v5;
  uint64_t v67 = v2->_dataGatheringOptions & 8;
  id v9 = (void *)((v2->_dataGatheringOptions >> 3) & 1);
  uint64_t v60 = v76;
  uint64_t v61 = v91;
  uint64_t v59 = v74;
  char v10 = 1;
  *(void *)&long long v11 = 134218498;
  long long v58 = v11;
  int v65 = v2;
  char v66 = (char)v9;
  do
  {
    unsigned int v63 = v8;
    if ((v10 & 1) == 0) {
      break;
    }
    id v64 = v7;
    uint64_t v12 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:2000];
    v90[0] = MEMORY[0x1E4F143A8];
    v90[1] = 3221225472;
    v91[0] = __28__SASampleStore_symbolicate__block_invoke;
    v91[1] = &unk_1E63F7758;
    id v62 = v12;
    id v92 = v62;
    unsigned int v93 = v2;
    id v71 = (void *)MEMORY[0x1C18A6C80](v90);
    long long v86 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v89 = 0u;
    obuint64_t j = v2->_exclaves;
    uint64_t v13 = v67;
    uint64_t v72 = [(NSMutableArray *)obj countByEnumeratingWithState:&v86 objects:v101 count:16];
    if (!v72) {
      goto LABEL_42;
    }
    uint64_t v70 = *(void *)v87;
    do
    {
      uint64_t v15 = 0;
      do
      {
        if (*(void *)v87 != v70) {
          objc_enumerationMutation(obj);
        }
        id v16 = *(void **)(*((void *)&v86 + 1) + 8 * v15);
        if (v13)
        {
LABEL_18:
          char v18 = 1;
          goto LABEL_19;
        }
        idsToUseDsymForUUID = v2->_idsToUseDsymForUUID;
        if (!idsToUseDsymForUUID && !v2->_namesToUseDsymForUUID) {
          goto LABEL_35;
        }
        if (-[NSMutableArray containsObject:](idsToUseDsymForUUID, "containsObject:", &unk_1F1A9AED8, v58, v59, v60, v61) & 1) != 0|| ([(NSMutableArray *)v2->_namesToUseDsymForUUID containsObject:@"exclaves"])
        {
          goto LABEL_18;
        }
        if (v2->_namesToUseDsymForUUID)
        {
          uint64_t v22 = -[SASampleStore lastTaskWithPid:](v2, 0);
          char v18 = (char)v9;
          if (v22)
          {
            long long v84 = 0u;
            long long v85 = 0u;
            long long v82 = 0u;
            long long v83 = 0u;
            unsigned int v69 = v2->_namesToUseDsymForUUID;
            uint64_t v23 = [(NSMutableArray *)v69 countByEnumeratingWithState:&v82 objects:v100 count:16];
            char v18 = (char)v9;
            if (v23)
            {
              uint64_t v24 = v23;
              uint64_t v25 = *(void *)v83;
              while (2)
              {
                for (uint64_t i = 0; i != v24; ++i)
                {
                  if (*(void *)v83 != v25) {
                    objc_enumerationMutation(v69);
                  }
                  uint64_t v27 = *(void *)(*((void *)&v82 + 1) + 8 * i);
                  uint64_t v28 = [v22 name];
                  if (v28)
                  {
                    uint64_t v29 = (void *)v28;
                    unint64_t v30 = [v22 name];
                    char v18 = 1;
                    uint64_t v31 = [v30 rangeOfString:v27 options:1];

                    if (v31 != 0x7FFFFFFFFFFFFFFFLL)
                    {
                      BOOL v2 = v65;
                      LOBYTE(v9) = v66;
                      goto LABEL_37;
                    }
                  }
                }
                uint64_t v24 = [(NSMutableArray *)v69 countByEnumeratingWithState:&v82 objects:v100 count:16];
                if (v24) {
                  continue;
                }
                break;
              }
              BOOL v2 = v65;
              LOBYTE(v9) = v66;
              char v18 = v66;
LABEL_37:
              uint64_t v13 = v67;
            }
          }
        }
        else
        {
LABEL_35:
          char v18 = 0;
        }
LABEL_19:
        if (v16) {
          id Property = objc_getProperty(v16, v14, 40, 1);
        }
        else {
          id Property = 0;
        }
        id v20 = Property;
        v79[0] = MEMORY[0x1E4F143A8];
        v79[1] = 3221225472;
        v79[2] = __28__SASampleStore_symbolicate__block_invoke_380;
        v79[3] = &unk_1E63F7780;
        id v21 = v71;
        v79[4] = v2;
        id v80 = v21;
        char v81 = v18;
        +[SAFrame enumerateFrameTree:block:]((uint64_t)SAFrame, v20, v79);

        ++v15;
      }
      while (v15 != v72);
      uint64_t v32 = [(NSMutableArray *)obj countByEnumeratingWithState:&v86 objects:v101 count:16];
      uint64_t v72 = v32;
    }
    while (v32);
LABEL_42:
    unsigned int v8 = v63 + 1;

    v75[0] = MEMORY[0x1E4F143A8];
    v75[1] = 3221225472;
    v76[0] = __28__SASampleStore_symbolicate__block_invoke_2;
    v76[1] = &unk_1E63F77F8;
    v76[2] = v2;
    char v78 = (char)v9;
    id v33 = v71;
    id v77 = v33;
    [(SASampleStore *)v2 enumerateTasks:v75];
    v73[0] = MEMORY[0x1E4F143A8];
    v73[1] = 3221225472;
    v74[0] = __28__SASampleStore_symbolicate__block_invoke_5;
    v74[1] = &unk_1E63F7820;
    v74[2] = v2;
    id v34 = v62;
    [v62 enumerateKeysAndObjectsUsingBlock:v73];
    id v9 = -[SASampleStore fixupAllFrames]((id *)&v2->super.isa);
    if ([v9 count])
    {
      if (v64 && [v64 isEqualToSet:v9])
      {
        int v35 = *__error();
        uint64_t v36 = _sa_logt();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
        {
          double v50 = COERCE_DOUBLE([v9 count]);
          unint64_t v51 = [v9 anyObject];
          unint64_t v52 = +[SABinary binaryWithUUID:v51 absolutePath:0];
          uint64_t v53 = [v52 debugDescription];
          *(_DWORD *)__objc2_class buf = v58;
          double v95 = v50;
          __int16 v96 = 1024;
          unsigned int v97 = v63 + 1;
          __int16 v98 = 2112;
          uint64_t v99 = v53;
          _os_log_fault_impl(&dword_1BF22B000, v36, OS_LOG_TYPE_FAULT, "Symbolication loop has same set of UUIDs to symbolicate! %lu binaries need more symbolication after iteration %d (including %@)", buf, 0x1Cu);

          BOOL v2 = v65;
          id v34 = v62;
        }
        char v37 = 0;
        char v10 = 0;
        *__error() = v35;
      }
      else
      {
        int v38 = *__error();
        unsigned int v39 = _sa_logt();
        uint64_t v40 = v39;
        if (v63 < 0x63)
        {
          if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
          {
            double v41 = COERCE_DOUBLE([v9 count]);
            id v42 = [v9 anyObject];
            char v43 = +[SABinary binaryWithUUID:v42 absolutePath:0];
            uint64_t v44 = [v43 debugDescription];
            *(_DWORD *)__objc2_class buf = v58;
            double v95 = v41;
            __int16 v96 = 1024;
            unsigned int v97 = v63 + 1;
            __int16 v98 = 2112;
            uint64_t v99 = v44;
            _os_log_impl(&dword_1BF22B000, v40, OS_LOG_TYPE_INFO, "%lu binaries need more symbolication after iteration %d (including %@)", buf, 0x1Cu);

            BOOL v2 = v65;
          }

          *__error() = v38;
          id v45 = v9;

          char v37 = 1;
          id v64 = v45;
          char v10 = 1;
        }
        else
        {
          if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
          {
            double v46 = COERCE_DOUBLE([v9 count]);
            double v47 = [v9 anyObject];
            SEL v48 = +[SABinary binaryWithUUID:v47 absolutePath:0];
            SEL v49 = [v48 debugDescription];
            *(_DWORD *)__objc2_class buf = v58;
            double v95 = v46;
            __int16 v96 = 1024;
            unsigned int v97 = v63 + 1;
            __int16 v98 = 2112;
            uint64_t v99 = v49;
            _os_log_fault_impl(&dword_1BF22B000, v40, OS_LOG_TYPE_FAULT, "Hit symbolication loop count limit! %lu binaries need more symbolication after iteration %d (including %@)", buf, 0x1Cu);

            BOOL v2 = v65;
          }

          char v37 = 0;
          char v10 = 0;
          *__error() = v38;
        }
        id v34 = v62;
      }
    }
    else
    {
      char v10 = 0;
      char v37 = 1;
    }

    uint64_t v7 = v64;
    LOBYTE(v9) = v66;
  }
  while ((v37 & 1) != 0);
  int v54 = *__error();
  int v55 = _sa_logt();
  if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
  {
    uint64_t v56 = mach_absolute_time();
    double v57 = SASecondsFromMachTimeUsingLiveTimebase(v56);
    *(_DWORD *)__objc2_class buf = 134218240;
    double v95 = v57 - v4;
    __int16 v96 = 1024;
    unsigned int v97 = v8;
    _os_log_impl(&dword_1BF22B000, v55, OS_LOG_TYPE_INFO, "Symbolication done (took %.3f seconds, %d iterations)", buf, 0x12u);
  }

  *__error() = v54;
}

void __28__SASampleStore_symbolicate__block_invoke(uint64_t a1, void *a2, int a3, BOOL a4, int a5)
{
  id v9 = a2;
  id v16 = [v9 uuid];
  uint64_t v10 = objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:");
  if (!v10)
  {
    id v13 = v9;
    self;
    long long v11 = objc_alloc_init(SAUUIDToSymbolicate);
    uint64_t v14 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithObjects:", v13, 0);

    binaries = v11->_binaries;
    v11->_binaries = (NSMutableArray *)v14;

    v11->_livePid = -1;
    v11->_unint64_t dataGatheringOptions = *(void *)(*(void *)(a1 + 40) + 408);
    v11->_livePid = a3;
    v11->_isInExclave = a4;
    [*(id *)(a1 + 32) setObject:v11 forKeyedSubscript:v16];
    goto LABEL_11;
  }
  long long v11 = (SAUUIDToSymbolicate *)v10;
  id v12 = v9;
  if (([(NSMutableArray *)v11->_binaries containsObject:v12] & 1) == 0) {
    [(NSMutableArray *)v11->_binaries addObject:v12];
  }

  if (a3 != -1 && v11->_livePid == -1)
  {
    v11->_livePid = a3;
    if (!a4) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (a4) {
LABEL_10:
  }
    v11->_isInExclave = 1;
LABEL_11:
  if (a5) {
    v11->_dataGatheringOptions |= 0x48uLL;
  }
}

void __28__SASampleStore_symbolicate__block_invoke_380(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 instruction];
  id v5 = [v3 binary];

  double v4 = v5;
  if (v5)
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    double v4 = v5;
  }
}

void __28__SASampleStore_symbolicate__block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  id v4 = a2;
  id v5 = v4;
  if ((~*(_DWORD *)(*(void *)(a1 + 32) + 408) & 0x402) != 0 || kill([v4 pid], 0)) {
    int v6 = -1;
  }
  else {
    int v6 = [v5 pid];
  }
  if (*(unsigned char *)(a1 + 48)) {
    goto LABEL_5;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  if (*(void *)(v11 + 264))
  {
    int v12 = [v5 pid];
    if (v12 == -1)
    {
      if ([v5 uniquePid] == -1) {
        goto LABEL_25;
      }
    }
    else
    {
      id v13 = *(void **)(*(void *)(a1 + 32) + 264);
      BOOL v2 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend(v5, "pid"));
      if ([v13 containsObject:v2])
      {

LABEL_5:
        int v7 = 1;
        goto LABEL_6;
      }
      if ([v5 uniquePid] == -1)
      {

        goto LABEL_25;
      }
    }
    uint64_t v14 = *(void **)(*(void *)(a1 + 32) + 264);
    uint64_t v15 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v5, "uniquePid"));
    char v16 = [v14 containsObject:v15];

    if (v12 != -1) {
    if (v16)
    }
      goto LABEL_5;
  }
  else if (!*(void *)(v11 + 256))
  {
    goto LABEL_37;
  }
LABEL_25:
  id v17 = *(void **)(*(void *)(a1 + 32) + 256);
  if (!v17)
  {
LABEL_37:
    int v7 = 0;
    goto LABEL_6;
  }
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  id v18 = v17;
  uint64_t v19 = [v18 countByEnumeratingWithState:&v36 objects:v40 count:16];
  if (v19)
  {
    uint64_t v20 = v19;
    int v28 = v6;
    uint64_t v21 = *(void *)v37;
LABEL_28:
    uint64_t v22 = 0;
    while (1)
    {
      if (*(void *)v37 != v21) {
        objc_enumerationMutation(v18);
      }
      uint64_t v23 = *(void *)(*((void *)&v36 + 1) + 8 * v22);
      uint64_t v24 = [v5 name];
      if (v24)
      {
        uint64_t v25 = (void *)v24;
        uint64_t v26 = [v5 name];
        int v7 = 1;
        uint64_t v27 = [v26 rangeOfString:v23 options:1];

        if (v27 != 0x7FFFFFFFFFFFFFFFLL) {
          break;
        }
      }
      if (v20 == ++v22)
      {
        uint64_t v20 = [v18 countByEnumeratingWithState:&v36 objects:v40 count:16];
        if (v20) {
          goto LABEL_28;
        }
        int v7 = 0;
        break;
      }
    }
    int v6 = v28;
  }
  else
  {
    int v7 = 0;
  }

LABEL_6:
  v32[0] = MEMORY[0x1E4F143A8];
  v32[1] = 3221225472;
  v32[2] = __28__SASampleStore_symbolicate__block_invoke_3;
  v32[3] = &unk_1E63F77A8;
  id v33 = *(id *)(a1 + 40);
  int v34 = v6;
  char v35 = v7;
  -[SATask enumerateFrames:]((uint64_t)v5, v32);
  int v8 = [v5 pid];
  if (v7 && v8)
  {
    id v9 = [v5 threads];
    v29[0] = MEMORY[0x1E4F143A8];
    v29[1] = 3221225472;
    v29[2] = __28__SASampleStore_symbolicate__block_invoke_4;
    v29[3] = &unk_1E63F77D0;
    id v10 = *(id *)(a1 + 40);
    void v29[4] = *(void *)(a1 + 32);
    id v30 = v10;
    char v31 = 1;
    [v9 enumerateKeysAndObjectsUsingBlock:v29];
  }
}

void __28__SASampleStore_symbolicate__block_invoke_3(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 instruction];
  id v5 = [v3 binary];

  id v4 = v5;
  if (v5)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    id v4 = v5;
  }
}

void __28__SASampleStore_symbolicate__block_invoke_4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  obuint64_t j = [a3 threadStates];
  uint64_t v4 = [obj countByEnumeratingWithState:&v37 objects:v42 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v32 = *(void *)v38;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v38 != v32) {
          objc_enumerationMutation(obj);
        }
        int v7 = *(void **)(*((void *)&v37 + 1) + 8 * v6);
        id v9 = [v7 leafKernelFrame];
        if (v9)
        {
          do
          {
            id v10 = [v9 instruction];
            uint64_t v11 = [v10 binary];

            if (v11) {
              (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
            }

            int v12 = (void *)v9[4];
            id v13 = v12;

            id v9 = v13;
          }
          while (v12);
        }
        long long v35 = 0u;
        long long v36 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        if (v7)
        {
          id Property = objc_getProperty(v7, v8, 176, 1);
          char v16 = Property;
          if (Property) {
            id Property = objc_getProperty(Property, v15, 16, 1);
          }
        }
        else
        {
          char v16 = 0;
          id Property = 0;
        }
        id v17 = Property;

        uint64_t v18 = [v17 countByEnumeratingWithState:&v33 objects:v41 count:16];
        if (v18)
        {
          uint64_t v20 = v18;
          uint64_t v21 = *(void *)v34;
          do
          {
            uint64_t v22 = 0;
            do
            {
              if (*(void *)v34 != v21) {
                objc_enumerationMutation(v17);
              }
              uint64_t v23 = *(void **)(*((void *)&v33 + 1) + 8 * v22);
              if (v23)
              {
                uint64_t v24 = objc_getProperty(v23, v19, 16, 1);
                if (v24)
                {
                  do
                  {
                    uint64_t v25 = [v24 instruction];
                    uint64_t v26 = [v25 binary];

                    if (v26) {
                      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
                    }

                    uint64_t v27 = (void *)v24[4];
                    int v28 = v27;

                    uint64_t v24 = v28;
                  }
                  while (v27);
                }
              }
              ++v22;
            }
            while (v22 != v20);
            uint64_t v29 = [v17 countByEnumeratingWithState:&v33 objects:v41 count:16];
            uint64_t v20 = v29;
          }
          while (v29);
        }

        ++v6;
      }
      while (v6 != v5);
      uint64_t v30 = [obj countByEnumeratingWithState:&v37 objects:v42 count:16];
      uint64_t v5 = v30;
    }
    while (v30);
  }
}

void __28__SASampleStore_symbolicate__block_invoke_5(uint64_t a1, void *a2, void *a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id Property = a3;
  id v8 = Property;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  if (Property) {
    id Property = objc_getProperty(Property, v7, 16, 1);
  }
  id v9 = Property;
  uint64_t v10 = [v9 countByEnumeratingWithState:&v30 objects:v35 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)v31;
    do
    {
      uint64_t v13 = 0;
      do
      {
        if (*(void *)v31 != v12) {
          objc_enumerationMutation(v9);
        }
        if (v8)
        {
          unint64_t v14 = *((void *)v8 + 3);
          int v15 = *((_DWORD *)v8 + 3);
          int v16 = *((unsigned char *)v8 + 8) & 1;
        }
        else
        {
          int v15 = 0;
          unint64_t v14 = 0;
          int v16 = 0;
        }
        -[SABinary symbolicateAllInstructionsWithOptions:pid:checkExclave:onlyDsym:additionalCSSymbolicatorFlags:](*(void **)(*((void *)&v30 + 1) + 8 * v13++), v14, v15, v16, 0, *(_DWORD *)(*(void *)(a1 + 32) + 328));
      }
      while (v11 != v13);
      uint64_t v17 = [v9 countByEnumeratingWithState:&v30 objects:v35 count:16];
      uint64_t v11 = v17;
    }
    while (v17);
  }

  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  if (v8) {
    id v19 = objc_getProperty(v8, v18, 16, 1);
  }
  else {
    id v19 = 0;
  }
  id v20 = v19;
  uint64_t v21 = [v20 countByEnumeratingWithState:&v26 objects:v34 count:16];
  if (v21)
  {
    uint64_t v22 = v21;
    uint64_t v23 = *(void *)v27;
    do
    {
      for (uint64_t i = 0; i != v22; ++i)
      {
        if (*(void *)v27 != v23) {
          objc_enumerationMutation(v20);
        }
        objc_msgSend(*(id *)(*((void *)&v26 + 1) + 8 * i), "clearCoreSymbolicationCache", (void)v26);
      }
      uint64_t v22 = [v20 countByEnumeratingWithState:&v26 objects:v34 count:16];
    }
    while (v22);
  }

  uint64_t v25 = +[SABinary dataFillingQueue]();
  dispatch_sync(v25, &__block_literal_global_382);
}

- (void)addAddressTranslations:(uint64_t)a1
{
  id v3 = a2;
  if (a1)
  {
    if (!*(void *)(a1 + 304))
    {
      uint64_t v4 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA60]), "initWithCapacity:", objc_msgSend(v3, "count"));
      id v5 = *(void **)(a1 + 304);
      *(void *)(a1 + 304) = v4;
    }
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = __40__SASampleStore_addAddressTranslations___block_invoke;
    v6[3] = &unk_1E63F7870;
    v6[4] = a1;
    [v3 enumerateKeysAndObjectsUsingBlock:v6];
  }
}

void __40__SASampleStore_addAddressTranslations___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = a3;
  id v8 = -[SASampleStore addressTranslationsForPid:](v6, [v5 intValue]);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  v12[2] = __40__SASampleStore_addAddressTranslations___block_invoke_2;
  v12[3] = &unk_1E63F7848;
  uint64_t v9 = *(void *)(a1 + 32);
  id v13 = v8;
  uint64_t v14 = v9;
  id v15 = v5;
  id v10 = v5;
  id v11 = v8;
  [v7 enumerateKeysAndObjectsUsingBlock:v12];
}

void __40__SASampleStore_addAddressTranslations___block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (![v6 unsignedLongLongValue]) {
    goto LABEL_10;
  }
  uint64_t v7 = [*(id *)(a1 + 32) objectForKeyedSubscript:v5];
  if (!v7) {
    goto LABEL_9;
  }
  id v8 = (void *)v7;
  uint64_t v9 = [*(id *)(a1 + 32) objectForKeyedSubscript:v5];
  if (![v9 unsignedLongLongValue])
  {

    goto LABEL_9;
  }
  id v10 = [*(id *)(a1 + 32) objectForKeyedSubscript:v5];
  char v11 = [v10 isEqual:v6];

  if (v11)
  {
LABEL_9:
    [*(id *)(a1 + 32) setObject:v6 forKeyedSubscript:v5];
    goto LABEL_10;
  }
  int v12 = *__error();
  id v13 = _sa_logt();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
  {
    uint64_t v14 = -[SASampleStore lastTaskWithPid:](*(void **)(a1 + 40), [*(id *)(a1 + 48) intValue]);
    id v15 = [v14 debugDescription];
    uint64_t v16 = [v5 unsignedLongLongValue];
    uint64_t v17 = [v6 unsignedLongLongValue];
    uint64_t v18 = [*(id *)(a1 + 32) objectForKeyedSubscript:v5];
    int v19 = 138413058;
    id v20 = v15;
    __int16 v21 = 2048;
    uint64_t v22 = v16;
    __int16 v23 = 2048;
    uint64_t v24 = v17;
    __int16 v25 = 2048;
    uint64_t v26 = [v18 unsignedLongLongValue];
    _os_log_fault_impl(&dword_1BF22B000, v13, OS_LOG_TYPE_FAULT, "%@: libktrace translation 0x%llx -> 0x%llx mismatch with existing translation -> 0x%llx", (uint8_t *)&v19, 0x2Au);
  }
  *__error() = v12;
LABEL_10:
}

void __31__SASampleStore_gatherKextStat__block_invoke()
{
  dispatch_block_t v0 = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, &__block_literal_global_389);
  qos_class_t v1 = qos_class_self();
  BOOL v2 = dispatch_get_global_queue(v1, 0);
  dispatch_async(v2, v0);

  dispatch_time_t v3 = dispatch_time(0, 2000000000);
  if (dispatch_block_wait(v0, v3))
  {
    int v4 = *__error();
    id v5 = _sa_logt();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v6 = 0;
      _os_log_impl(&dword_1BF22B000, v5, OS_LOG_TYPE_DEFAULT, "WARNING: Timed out waiting for kextstat", v6, 2u);
    }

    *__error() = v4;
  }
}

void __31__SASampleStore_gatherKextStat__block_invoke_2()
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v15 = -1;
  long long v20 = xmmword_1E63F7890;
  int v0 = SASpawnPlatformBinaryWithSigningIdentifier("/usr/sbin/kextstat", "com.apple.kextstat", (char *const *)&v20, 0, 0, 0, &v15, 0, 0, 0, 0);
  if (v0 < 1)
  {
    int v9 = *__error();
    id v10 = _sa_logt();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      int v11 = *__error();
      int v12 = __error();
      id v13 = strerror(*v12);
      *(_DWORD *)__objc2_class buf = 67109378;
      int v17 = v11;
      __int16 v18 = 2080;
      int v19 = v13;
      _os_log_debug_impl(&dword_1BF22B000, v10, OS_LOG_TYPE_DEBUG, "Unable to run kextstat: %d %s", buf, 0x12u);
    }

    *__error() = v9;
  }
  else
  {
    pid_t v1 = v0;
    id v2 = objc_alloc_init(MEMORY[0x1E4F28E78]);
    dispatch_time_t v3 = malloc_type_calloc(0x40uLL, 0x400uLL, 0x671501A4uLL);
    int v4 = (void *)MEMORY[0x1E4F14B00];
    ssize_t v5 = read(v15, v3, *MEMORY[0x1E4F14B00] - 1);
    if (v5 >= 1)
    {
      do
      {
        *((unsigned char *)v3 + v5) = 0;
        id v6 = SANSStringForCString(v3);
        if (v6)
        {
          [v2 appendString:v6];
        }
        else
        {
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 3221225472;
          block[2] = __31__SASampleStore_gatherKextStat__block_invoke_3;
          block[3] = &__block_descriptor_40_e5_v8__0l;
          void block[4] = v3;
          if (qword_1EB698EA0 != -1) {
            dispatch_once(&qword_1EB698EA0, block);
          }
        }

        ssize_t v5 = read(v15, v3, *v4 - 1);
      }
      while (v5 > 0);
    }
    waitpid(v1, 0, 0);
    free(v3);
    if ([v2 length])
    {
      uint64_t v7 = [v2 copy];
      id v8 = (void *)qword_1EB698E90;
      qword_1EB698E90 = v7;
    }
  }
}

int *__31__SASampleStore_gatherKextStat__block_invoke_3(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v2 = *__error();
  dispatch_time_t v3 = _sa_logt();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 136315138;
    uint64_t v7 = v5;
    _os_log_error_impl(&dword_1BF22B000, v3, OS_LOG_TYPE_ERROR, "Unable to convert kextstat output to NSString: %s", (uint8_t *)&v6, 0xCu);
  }

  uint64_t result = __error();
  *uint64_t result = v2;
  return result;
}

- (NSString)machineArchitecture
{
  arch = (void *)self->_arch;
  if (arch)
  {
    arch = (void *)CSArchitectureGetFamilyName();
    if (arch)
    {
      arch = SANSStringForCString(arch);
    }
  }
  return (NSString *)arch;
}

- (void)setMachineArchitecture:(id)a3
{
  id v5 = a3;
  uint64_t ArchitectureForName = [v5 UTF8String];
  if (ArchitectureForName)
  {
    [v5 UTF8String];
    uint64_t ArchitectureForName = CSArchitectureGetArchitectureForName();
  }
  self->_arch = (_CSArchitecture)ArchitectureForName;
}

- (void)gatherMachineArchitecture
{
  self->_arch = (_CSArchitecture)MEMORY[0x1C18A5C00](self, a2);
}

- (mach_timebase_info)machTimebase
{
  return self->_machTimebase;
}

- (void)setMachTimebase:(mach_timebase_info)a3
{
  self->_machTimebase = a3;
}

intptr_t __36__SASampleStore_gatherHardwareModel__block_invoke_2(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v2 = (const void *)MGCopyAnswerWithError();
  if (v2)
  {
    dispatch_time_t v3 = v2;
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 == CFStringGetTypeID())
    {
      id v5 = (void *)qword_1EB698EA8;
      qword_1EB698EA8 = (uint64_t)v3;
    }
    else
    {
      int v8 = *__error();
      int v9 = _sa_logt();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        CFTypeID v11 = CFGetTypeID(v3);
        int v12 = (__CFString *)CFCopyTypeIDDescription(v11);
        *(_DWORD *)__objc2_class buf = 138412290;
        uint64_t v14 = v12;
        _os_log_fault_impl(&dword_1BF22B000, v9, OS_LOG_TYPE_FAULT, "Product type not a string (%@)", buf, 0xCu);
      }
      *__error() = v8;
      CFRelease(v3);
    }
  }
  else
  {
    int v6 = *__error();
    uint64_t v7 = _sa_logt();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__objc2_class buf = 67109120;
      LODWORD(v14) = 0;
      _os_log_fault_impl(&dword_1BF22B000, v7, OS_LOG_TYPE_FAULT, "Unable to get product type: %d", buf, 8u);
    }

    *__error() = v6;
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

- (void)_populateFromKtraceMachineInfo:(int)a3 is64bit:
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    id v5 = [(id)a1 hardwareModel];

    if (!v5)
    {
      int v6 = (void *)ktrace_machine_model();
      if (v6)
      {
        uint64_t v7 = SANSStringForCString(v6);
        [(id)a1 setHardwareModel:v7];
      }
    }
    if (![(id)a1 numActiveCPUs])
    {
      uint64_t active = ktrace_machine_active_cpus();
      if (active) {
        [(id)a1 setNumActiveCPUs:active];
      }
    }
    if (![(id)a1 hwPageSize])
    {
      uint64_t v9 = ktrace_machine_hw_page_size();
      if (v9) {
        [(id)a1 setHwPageSize:v9];
      }
    }
    if (![(id)a1 vmPageSize])
    {
      uint64_t v10 = ktrace_machine_vm_page_size();
      if (v10) {
        [(id)a1 setVmPageSize:v10];
      }
    }
    CFTypeID v11 = [(id)a1 osProductName];

    if (!v11)
    {
      int v12 = (void *)ktrace_machine_os_name();
      if (v12)
      {
        id v13 = SANSStringForCString(v12);
        [(id)a1 setOsProductName:v13];
      }
    }
    uint64_t v14 = [(id)a1 osProductVersion];

    if (!v14)
    {
      uint64_t v15 = (void *)ktrace_machine_os_version();
      if (v15)
      {
        uint64_t v16 = SANSStringForCString(v15);
        [(id)a1 setOsProductVersion:v16];
      }
    }
    int v17 = [(id)a1 osProductVersionExtra];

    if (!v17)
    {
      __int16 v18 = (void *)ktrace_machine_os_version_extra();
      if (v18)
      {
        int v19 = SANSStringForCString(v18);
        [(id)a1 setOsProductVersionExtra:v19];
      }
    }
    long long v20 = [(id)a1 osBuildVersion];

    if (!v20)
    {
      uint64_t v22 = (void *)ktrace_machine_os_build();
      if (v22)
      {
        __int16 v23 = SANSStringForCString(v22);
        [(id)a1 setOsBuildVersion:v23];
      }
    }
    if (!*(void *)(a1 + 192))
    {
      int v24 = ktrace_machine_cpu_type();
      uint64_t v25 = ktrace_machine_cpu_subtype();
      uint64_t v26 = v24 & 0xFEFFFFFF;
      if (a3) {
        v26 |= 0x1000000uLL;
      }
      *(void *)(a1 + 192) = v26 | ((unint64_t)(v25 & 0xFFFFFF) << 32);
    }
    if (!objc_getProperty((id)a1, v21, 1032, 1))
    {
      uint64_t v27 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:*(unsigned int *)(a1 + 340)];
      if (*(_DWORD *)(a1 + 340))
      {
        uint64_t v29 = 0;
        *(void *)&long long v28 = 67109376;
        long long v41 = v28;
        do
        {
          int v30 = ktrace_machine_cpu_cluster();
          if (v30)
          {
            int v31 = v30;
            int v32 = *__error();
            long long v33 = _sa_logt();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__objc2_class buf = v41;
              int v43 = v29;
              __int16 v44 = 1024;
              int v45 = v31;
              long long v34 = v33;
              long long v35 = "Unable to determine cluster for cpu %u: %{errno}d";
LABEL_43:
              _os_log_error_impl(&dword_1BF22B000, v34, OS_LOG_TYPE_ERROR, v35, buf, 0xEu);
            }
          }
          else
          {
            int v36 = ktrace_machine_cluster_flags();
            if (!v36)
            {
              long long v38 = [NSNumber numberWithUnsignedLongLong:0];
              long long v39 = [NSNumber numberWithUnsignedInt:v29];
              [v27 setObject:v38 forKeyedSubscript:v39];

              goto LABEL_39;
            }
            int v37 = v36;
            int v32 = *__error();
            long long v33 = _sa_logt();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__objc2_class buf = v41;
              int v43 = 0;
              __int16 v44 = 1024;
              int v45 = v37;
              long long v34 = v33;
              long long v35 = "Unable to determine flags for cluster %u: %{errno}d";
              goto LABEL_43;
            }
          }

          *__error() = v32;
LABEL_39:
          uint64_t v29 = (v29 + 1);
        }
        while (v29 < *(_DWORD *)(a1 + 340));
      }
      if (objc_msgSend(v27, "count", v41)) {
        objc_setProperty_atomic_copy((id)a1, v40, v27, 1032);
      }
    }
  }
}

void __45__SASampleStore_gatherNonDefaultFeatureFlags__block_invoke()
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (objc_opt_class())
  {
    id v0 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    pid_t v1 = (void *)qword_1EB698EC0;
    qword_1EB698EC0 = (uint64_t)v0;

    int v2 = [MEMORY[0x1E4F61898] shared];
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    obuint64_t j = [v2 domains];
    uint64_t v26 = [obj countByEnumeratingWithState:&v35 objects:v40 count:16];
    if (v26)
    {
      uint64_t v25 = *(void *)v36;
      do
      {
        uint64_t v3 = 0;
        do
        {
          if (*(void *)v36 != v25) {
            objc_enumerationMutation(obj);
          }
          uint64_t v28 = v3;
          uint64_t v4 = *(void *)(*((void *)&v35 + 1) + 8 * v3);
          uint64_t context = (void *)MEMORY[0x1C18A6A20]();
          id v5 = [v2 featuresForDomain:v4];
          long long v31 = 0u;
          long long v32 = 0u;
          long long v33 = 0u;
          long long v34 = 0u;
          id v29 = v5;
          uint64_t v6 = [v5 countByEnumeratingWithState:&v31 objects:v39 count:16];
          if (v6)
          {
            uint64_t v7 = v6;
            uint64_t v8 = *(void *)v32;
            do
            {
              for (uint64_t i = 0; i != v7; ++i)
              {
                if (*(void *)v32 != v8) {
                  objc_enumerationMutation(v29);
                }
                uint64_t v10 = *(void *)(*((void *)&v31 + 1) + 8 * i);
                CFTypeID v11 = [v2 stateForFeature:v10 domain:v4 level:4];
                if (v11)
                {
                  int v12 = [v2 defaultStateForFeature:v10 domain:v4];
                  id v13 = v12;
                  if (!v12 || (uint64_t v14 = [v12 value], v14 != objc_msgSend(v11, "value")))
                  {
                    uint64_t v15 = [v11 value];
                    uint64_t v16 = MEMORY[0x1E4F1CC28];
                    if (v15 == 1) {
                      uint64_t v16 = MEMORY[0x1E4F1CC38];
                    }
                    uint64_t v30 = v16;
                    uint64_t v17 = v7;
                    uint64_t v18 = v8;
                    int v19 = v2;
                    uint64_t v20 = qword_1EB698EC0;
                    uint64_t v21 = (void *)[[NSString alloc] initWithFormat:@"%@.%@", v4, v10];
                    uint64_t v22 = (void *)v20;
                    int v2 = v19;
                    uint64_t v8 = v18;
                    uint64_t v7 = v17;
                    [v22 setObject:v30 forKeyedSubscript:v21];
                  }
                }
              }
              uint64_t v7 = [v29 countByEnumeratingWithState:&v31 objects:v39 count:16];
            }
            while (v7);
          }

          uint64_t v3 = v28 + 1;
        }
        while (v28 + 1 != v26);
        uint64_t v26 = [obj countByEnumeratingWithState:&v35 objects:v40 count:16];
      }
      while (v26);
    }

    [v2 invalidateCache];
    if (![(id)qword_1EB698EC0 count])
    {
      __int16 v23 = (void *)qword_1EB698EC0;
      qword_1EB698EC0 = 0;
    }
  }
}

intptr_t __29__SASampleStore_gatherTrials__block_invoke(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v35 = 0;
  long long v36 = &v35;
  uint64_t v37 = 0x2050000000;
  int v2 = (void *)getTRIAllocationStatusClass_softClass;
  uint64_t v38 = getTRIAllocationStatusClass_softClass;
  if (!getTRIAllocationStatusClass_softClass)
  {
    *(void *)&long long buf = MEMORY[0x1E4F143A8];
    *((void *)&buf + 1) = 3221225472;
    long long v40 = __getTRIAllocationStatusClass_block_invoke;
    uint64_t v41 = &unk_1E63F7CE0;
    id v42 = &v35;
    __getTRIAllocationStatusClass_block_invoke((uint64_t)&buf);
    int v2 = (void *)v36[3];
  }
  id v3 = v2;
  _Block_object_dispose(&v35, 8);
  if (objc_opt_class())
  {
    uint64_t v4 = [v3 defaultProvider];
    id v5 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    id v34 = 0;
    v32[0] = MEMORY[0x1E4F143A8];
    v32[1] = 3221225472;
    v32[2] = __29__SASampleStore_gatherTrials__block_invoke_2;
    v32[3] = &unk_1E63F78A8;
    id v6 = v5;
    id v33 = v6;
    char v7 = [v4 enumerateActiveExperimentsForEnvironment:0 error:&v34 block:v32];
    id v8 = v34;
    int v9 = *__error();
    uint64_t v10 = _sa_logt();
    CFTypeID v11 = v10;
    if (v7)
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = [v6 count];
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v12;
        _os_log_debug_impl(&dword_1BF22B000, v11, OS_LOG_TYPE_DEBUG, "Found %lu active trial experiments", (uint8_t *)&buf, 0xCu);
      }
    }
    else if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v8;
      _os_log_error_impl(&dword_1BF22B000, v11, OS_LOG_TYPE_ERROR, "Unable to determine active trial experiments: %@", (uint8_t *)&buf, 0xCu);
    }

    *__error() = v9;
    id v13 = objc_alloc_init(MEMORY[0x1E4F1CA48]);

    id v31 = 0;
    uint64_t v26 = MEMORY[0x1E4F143A8];
    uint64_t v27 = 3221225472;
    uint64_t v28 = __29__SASampleStore_gatherTrials__block_invoke_421;
    id v29 = &unk_1E63F78F8;
    id v14 = v13;
    id v30 = v14;
    char v15 = [v4 enumerateActiveRolloutsWithError:&v31 block:&v26];
    id v16 = v31;
    int v17 = *__error();
    uint64_t v18 = _sa_logt();
    int v19 = v18;
    if (v15)
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v20 = objc_msgSend(v14, "count", v26, v27, v28, v29);
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v20;
        _os_log_debug_impl(&dword_1BF22B000, v19, OS_LOG_TYPE_DEBUG, "Found %lu active trial rollouts", (uint8_t *)&buf, 0xCu);
      }
    }
    else if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v16;
      _os_log_error_impl(&dword_1BF22B000, v19, OS_LOG_TYPE_ERROR, "Unable to determine active trial rollouts: %@", (uint8_t *)&buf, 0xCu);
    }

    *__error() = v17;
    uint64_t v21 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:2];
    [v21 setObject:v6 forKeyedSubscript:0x1F1A82E58];
    [v21 setObject:v14 forKeyedSubscript:0x1F1A82E78];
    __int16 v23 = (void *)[v21 copy];
    int v24 = *(void **)(a1 + 32);
    if (v24) {
      objc_setProperty_atomic(v24, v22, v23, 528);
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void __29__SASampleStore_gatherTrials__block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v2 = a2;
  id v3 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  uint64_t v4 = [v2 experimentId];
  id v5 = (void *)[v4 copy];
  [v3 setObject:v5 forKeyedSubscript:0x1F1A82E98];

  id v6 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend(v2, "deploymentId"));
  [v3 setObject:v6 forKeyedSubscript:0x1F1A82EB8];

  char v7 = [v2 treatmentId];
  id v8 = (void *)[v7 copy];
  [v3 setObject:v8 forKeyedSubscript:0x1F1A82EF8];

  id v9 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v10 = [v2 namespaces];
  uint64_t v11 = [v10 countByEnumeratingWithState:&v22 objects:v26 count:16];
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v13 = *(void *)v23;
    do
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        if (*(void *)v23 != v13) {
          objc_enumerationMutation(v10);
        }
        char v15 = *(void **)(*((void *)&v22 + 1) + 8 * i);
        id v16 = objc_msgSend(NSNumber, "numberWithUnsignedInt:", objc_msgSend(v15, "compatibilityVersion"));
        int v17 = [v15 name];
        [v9 setObject:v16 forKeyedSubscript:v17];
      }
      uint64_t v12 = [v10 countByEnumeratingWithState:&v22 objects:v26 count:16];
    }
    while (v12);
  }

  uint64_t v18 = (void *)[v9 copy];
  [v3 setObject:v18 forKeyedSubscript:0x1F1A82ED8];

  int v19 = *(void **)(a1 + 32);
  uint64_t v20 = (void *)[v3 copy];
  [v19 addObject:v20];
}

void __29__SASampleStore_gatherTrials__block_invoke_421(uint64_t a1, void *a2)
{
  id v3 = (objc_class *)MEMORY[0x1E4F1CA60];
  id v4 = a2;
  id v5 = objc_alloc_init(v3);
  id v6 = [v4 rolloutId];
  char v7 = (void *)[v6 copy];
  [v5 setObject:v7 forKeyedSubscript:0x1F1A82F18];

  id v8 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend(v4, "deploymentId"));
  [v5 setObject:v8 forKeyedSubscript:0x1F1A82EB8];

  id v9 = [v4 rampId];
  uint64_t v10 = (void *)[v9 copy];
  [v5 setObject:v10 forKeyedSubscript:0x1F1A82F38];

  id v11 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  uint64_t v12 = [v4 factorPackIds];

  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3221225472;
  v17[2] = __29__SASampleStore_gatherTrials__block_invoke_2_422;
  v17[3] = &unk_1E63F78D0;
  id v18 = v11;
  id v13 = v11;
  [v12 enumerateKeysAndObjectsUsingBlock:v17];

  id v14 = (void *)[v13 copy];
  [v5 setObject:v14 forKeyedSubscript:0x1F1A82F58];

  char v15 = *(void **)(a1 + 32);
  id v16 = (void *)[v5 copy];
  [v15 addObject:v16];
}

uint64_t __29__SASampleStore_gatherTrials__block_invoke_2_422(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) setObject:a3 forKeyedSubscript:a2];
}

uint64_t __40__SASampleStore_addPowerModeTransition___block_invoke(uint64_t a1, void *a2)
{
  id v3 = [a2 timestamp];
  [v3 wallTime];
  double v5 = v4;

  double v6 = *(double *)(a1 + 32);
  if (v5 <= v6) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = -1;
  }
  if (v5 < v6) {
    return 1;
  }
  else {
    return v7;
  }
}

uint64_t __30__SASampleStore_gatherGPUInfo__block_invoke(void *a1)
{
  CFStringRef Group = (const __CFString *)IOReportChannelGetGroup();
  if (IOReportChannelGetFormat() == 1
    && CFEqual(Group, @"Internal Statistics"))
  {
    ChannelName = (const void *)IOReportChannelGetChannelName();
    if (CFEqual(ChannelName, @"GPU Restart Count"))
    {
      *(void *)(*(void *)(a1[4] + 8) + 24) = IOReportSimpleGetIntegerValue();
      uint64_t v4 = a1[5];
LABEL_7:
      *(unsigned char *)(*(void *)(v4 + 8) + 24) = 1;
      goto LABEL_8;
    }
    if (CFEqual(ChannelName, @"Last GPU Restart"))
    {
      *(void *)(*(void *)(a1[6] + 8) + 24) = IOReportSimpleGetIntegerValue();
      uint64_t v4 = a1[7];
      goto LABEL_7;
    }
  }
LABEL_8:
  if (*(unsigned char *)(*(void *)(a1[5] + 8) + 24) && *(unsigned char *)(*(void *)(a1[7] + 8) + 24)) {
    return 273;
  }
  else {
    return 0;
  }
}

void __42__SASampleStore_gatherUnknownProcessNames__block_invoke(uint64_t a1, void *a2)
{
  id v3 = [a2 threads];
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __42__SASampleStore_gatherUnknownProcessNames__block_invoke_2;
  v4[3] = &unk_1E63F79B8;
  long long v5 = *(_OWORD *)(a1 + 32);
  [v3 enumerateKeysAndObjectsUsingBlock:v4];
}

void __42__SASampleStore_gatherUnknownProcessNames__block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  obuint64_t j = [a3 threadStates];
  uint64_t v4 = [obj countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v14;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v14 != v6) {
          objc_enumerationMutation(obj);
        }
        id v8 = *(void **)(*((void *)&v13 + 1) + 8 * v7);
        v11[0] = MEMORY[0x1E4F143A8];
        v11[1] = 3221225472;
        v11[2] = __42__SASampleStore_gatherUnknownProcessNames__block_invoke_3;
        v11[3] = &unk_1E63F7990;
        long long v12 = *(_OWORD *)(a1 + 32);
        id v9 = (void (**)(void, void))MEMORY[0x1C18A6C80](v11);
        v9[2](v9, [v8 originPid]);
        v9[2](v9, [v8 proximatePid]);

        ++v7;
      }
      while (v5 != v7);
      uint64_t v5 = [obj countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v5);
  }
}

void __42__SASampleStore_gatherUnknownProcessNames__block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2 != -1)
  {
    uint64_t v4 = [*(id *)(a1 + 32) tasksByPid];
    uint64_t v5 = [NSNumber numberWithInt:a2];
    uint64_t v6 = [v4 objectForKeyedSubscript:v5];
    uint64_t v7 = [v6 count];

    if (!v7)
    {
      char v12 = 0;
      memset(v11, 0, sizeof(v11));
      if (qword_1EB698EC8 != -1) {
        dispatch_once(&qword_1EB698EC8, &__block_literal_global_446);
      }
      if ((_MergedGlobals_3 & 1) == 0)
      {
        proc_name(a2, v11, 0x21u);
        if (LOBYTE(v11[0]))
        {
          id v8 = SANSStringForCString(v11);
          id v9 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
          uint64_t v10 = [NSNumber numberWithInt:a2];
          [v9 setObject:v8 forKeyedSubscript:v10];
        }
      }
    }
  }
}

void __52__SASampleStore_gatherUnknownResourceCoalitionNames__block_invoke(uint64_t a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = [v3 resourceCoalitionID];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = [v3 resourceCoalitionName];
    if (v6)
    {

      goto LABEL_26;
    }
    if (![(SATask *)v3 isFromCurrentBootCycle]) {
      goto LABEL_26;
    }
    id v8 = *(void **)(a1 + 32);
    id v9 = [NSNumber numberWithUnsignedLongLong:v5];
    uint64_t v10 = [v8 objectForKeyedSubscript:v9];

    if (v10)
    {
      if (v3) {
        objc_setProperty_atomic(v3, v11, v10, 152);
      }
      goto LABEL_25;
    }
    char v12 = (void *)xpc_coalition_copy_info();
    uint64_t v13 = v12;
    if (!v12)
    {
      int v19 = *__error();
      uint64_t v20 = _sa_logt();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v27 = [v3 name];
        *(_DWORD *)uint64_t v28 = 134218498;
        *(void *)&v28[4] = v5;
        *(_WORD *)&v28[12] = 2112;
        *(void *)&v28[14] = v27;
        *(_WORD *)&v28[22] = 1024;
        int v29 = [v3 pid];
        _os_log_debug_impl(&dword_1BF22B000, v20, OS_LOG_TYPE_DEBUG, "No info for rcid %llu (used by %@ [%d])", v28, 0x1Cu);
      }
      *__error() = v19;
      goto LABEL_24;
    }
    string = xpc_dictionary_get_string(v12, (const char *)*MEMORY[0x1E4F14378]);
    if (string)
    {
      long long v15 = (char *)string;
      int v16 = *__error();
      int v17 = _sa_logt();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_17;
      }
      *(_DWORD *)uint64_t v28 = 134218242;
      *(void *)&v28[4] = v5;
      *(_WORD *)&v28[12] = 2080;
      *(void *)&v28[14] = v15;
      uint64_t v18 = "RCID %llu has bundleid:%s";
    }
    else
    {
      long long v15 = (char *)xpc_dictionary_get_string(v13, (const char *)*MEMORY[0x1E4F14380]);
      int v16 = *__error();
      int v17 = _sa_logt();
      BOOL v21 = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
      if (!v15)
      {
        if (v21)
        {
          *(_DWORD *)uint64_t v28 = 134217984;
          *(void *)&v28[4] = v5;
          _os_log_debug_impl(&dword_1BF22B000, v17, OS_LOG_TYPE_DEBUG, "RCID %llu has no bundleid/name", v28, 0xCu);
        }

        *__error() = v16;
        goto LABEL_24;
      }
      if (!v21)
      {
LABEL_17:

        *__error() = v16;
        long long v22 = SANSStringForCString(v15);
        if (v22)
        {
          long long v24 = v22;
          if (v3) {
            objc_setProperty_atomic(v3, v23, v22, 152);
          }
          long long v25 = *(void **)(a1 + 32);
          uint64_t v26 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", v5, *(_OWORD *)v28, *(void *)&v28[16]);
          [v25 setObject:v24 forKeyedSubscript:v26];
        }
LABEL_24:

LABEL_25:
        goto LABEL_26;
      }
      *(_DWORD *)uint64_t v28 = 134218242;
      *(void *)&v28[4] = v5;
      *(_WORD *)&v28[12] = 2080;
      *(void *)&v28[14] = v15;
      uint64_t v18 = "RCID %llu has name:%s";
    }
    _os_log_debug_impl(&dword_1BF22B000, v17, OS_LOG_TYPE_DEBUG, v18, v28, 0x16u);
    goto LABEL_17;
  }
LABEL_26:
}

void __43__SASampleStore_gatherOSCryptexFileExtents__block_invoke()
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (objc_opt_class())
  {
    id v0 = [MEMORY[0x1E4F73A28] sharedDataAccessor];
    id v32 = 0;
    pid_t v1 = (void *)[v0 copyPathForPersonalizedData:11 error:&v32];
    id v2 = v32;

    if (v1)
    {
      id v3 = v1;
      uint64_t v4 = (const char *)[v3 fileSystemRepresentation];
      if (!v4)
      {
        int v14 = *__error();
        long long v15 = _sa_logt();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          v40.st_dev = 138412290;
          *(void *)&v40.st_mode = v3;
          _os_log_error_impl(&dword_1BF22B000, v15, OS_LOG_TYPE_ERROR, "Unable to get fileSystemRepresentation for cryptex path %@", (uint8_t *)&v40, 0xCu);
        }

        *__error() = v14;
        goto LABEL_23;
      }
      __darwin_ino64_t v5 = (__darwin_ino64_t)v4;
      int v6 = open(v4, 0, 0);
      if (v6 < 0)
      {
        int v16 = *__error();
        int v17 = _sa_logt();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          int v31 = *__error();
          v40.st_dev = 136315394;
          *(void *)&v40.st_mode = v5;
          WORD2(v40.st_ino) = 1024;
          *(_DWORD *)((char *)&v40.st_ino + 6) = v31;
          _os_log_error_impl(&dword_1BF22B000, v17, OS_LOG_TYPE_ERROR, "FileExtent: error opening \"%s\": %{errno}d", (uint8_t *)&v40, 0x12u);
        }

        int v11 = 0;
        *__error() = v16;
        goto LABEL_20;
      }
      int v7 = v6;
      memset(&v40, 0, sizeof(v40));
      if (fstat(v6, &v40))
      {
        int v8 = *__error();
        id v9 = _sa_logt();
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          goto LABEL_7;
        }
        int v30 = *__error();
        *(_DWORD *)long long buf = 136315394;
        __darwin_ino64_t v37 = v5;
        __int16 v38 = 1024;
        LODWORD(v39) = v30;
        long long v22 = "FileExtent: failed to get file size for \"%s\": %{errno}d";
        long long v23 = v9;
        uint32_t v24 = 18;
      }
      else
      {
        off_t st_size = v40.st_size;
        if (v40.st_size)
        {
          if (v40.st_size < 1)
          {
            int v11 = 0;
            goto LABEL_9;
          }
          off_t v21 = 0;
          int v11 = 0;
          while (1)
          {
            int v33 = 0;
            off_t v34 = st_size - v21;
            off_t v35 = v21;
            if (fcntl(v7, 65, &v33))
            {
              int v8 = *__error();
              long long v25 = _sa_logt();
              if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
                goto LABEL_38;
              }
              int v26 = *__error();
              *(_DWORD *)long long buf = 67109120;
              LODWORD(v37) = v26;
              uint64_t v27 = "FileExtent: error in fcntl(): %{errno}d";
              uint64_t v28 = v25;
              uint32_t v29 = 8;
              goto LABEL_42;
            }
            if (!v34) {
              break;
            }
            v21 += v34;
            ++v11;
            if (v21 >= st_size) {
              goto LABEL_9;
            }
          }
          int v8 = *__error();
          long long v25 = _sa_logt();
          if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
            goto LABEL_38;
          }
          *(_DWORD *)long long buf = 134218240;
          __darwin_ino64_t v37 = v21;
          __int16 v38 = 2048;
          off_t v39 = st_size;
          uint64_t v27 = "FileExtent: 0 contigbytes fcntl() at offset %lld out of %lld";
          uint64_t v28 = v25;
          uint32_t v29 = 22;
LABEL_42:
          _os_log_error_impl(&dword_1BF22B000, v28, OS_LOG_TYPE_ERROR, v27, buf, v29);
LABEL_38:

          uint64_t v10 = __error();
LABEL_8:
          *uint64_t v10 = v8;
LABEL_9:
          close(v7);
LABEL_20:
          qword_1EB698ED8 = v11;
          int v18 = *__error();
          int v19 = _sa_logt();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
          {
            v40.st_dev = 67109378;
            *(_DWORD *)&v40.st_mode = qword_1EB698ED8;
            LOWORD(v40.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v40.st_ino + 2) = v5;
            _os_log_impl(&dword_1BF22B000, v19, OS_LOG_TYPE_INFO, "Shared cache fragmentation OS Cryptex File Extents count is %d for file: (\"%s\")", (uint8_t *)&v40, 0x12u);
          }

          *__error() = v18;
LABEL_23:

          goto LABEL_24;
        }
        int v8 = *__error();
        id v9 = _sa_logt();
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
LABEL_7:

          uint64_t v10 = __error();
          int v11 = 0;
          goto LABEL_8;
        }
        *(_DWORD *)long long buf = 136315138;
        __darwin_ino64_t v37 = v5;
        long long v22 = "FileExtent: no extents for \"%s\" (empty file)\n";
        long long v23 = v9;
        uint32_t v24 = 12;
      }
      _os_log_error_impl(&dword_1BF22B000, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
      goto LABEL_7;
    }
  }
  else
  {
    id v2 = 0;
  }
  int v12 = *__error();
  uint64_t v13 = _sa_logt();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    v40.st_dev = 138412290;
    *(void *)&v40.st_mode = v2;
    _os_log_impl(&dword_1BF22B000, v13, OS_LOG_TYPE_INFO, "Unable to get path for MSUDA_CRYPTEX1_OS_CRYPTEX: (%@)", (uint8_t *)&v40, 0xCu);
  }

  *__error() = v12;
LABEL_24:
}

void __40__SASampleStore_gatherRootInstalledInfo__block_invoke(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v2 = objc_alloc_init(*(Class *)(a1 + 48));
  id v26 = 0;
  int v3 = [v2 openAndReturnError:&v26];
  id v4 = v26;
  __darwin_ino64_t v5 = v4;
  if (v3)
  {
    id v25 = v4;
    int v6 = [v2 allInstalledRootsAndReturnError:&v25];
    id v7 = v25;

    id v8 = objc_alloc_init(MEMORY[0x1E4F1CA70]);
    if (v6)
    {
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      id v9 = v6;
      uint64_t v10 = [v9 countByEnumeratingWithState:&v21 objects:v29 count:16];
      if (v10)
      {
        uint64_t v11 = v10;
        uint64_t v12 = *(void *)v22;
        do
        {
          uint64_t v13 = 0;
          do
          {
            if (*(void *)v22 != v12) {
              objc_enumerationMutation(v9);
            }
            int v14 = objc_msgSend(*(id *)(*((void *)&v21 + 1) + 8 * v13), "name", (void)v21);
            [v8 addObject:v14];

            ++v13;
          }
          while (v11 != v13);
          uint64_t v11 = [v9 countByEnumeratingWithState:&v21 objects:v29 count:16];
        }
        while (v11);
      }
    }
    id v15 = (id)objc_msgSend(v2, "closeAndReturnError:", 0, (void)v21);
    uint64_t v16 = [v8 array];
    uint64_t v17 = *(void *)(a1 + 32);
    int v18 = *(void **)(v17 + 552);
    *(void *)(v17 + 552) = v16;

    if ([*(id *)(*(void *)(a1 + 32) + 552) count]) {
      *(unsigned char *)(*(void *)(a1 + 32) + 318) = 1;
    }

    __darwin_ino64_t v5 = v7;
  }
  else
  {
    int v19 = *__error();
    uint64_t v20 = _sa_logt();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v28 = v5;
      _os_log_error_impl(&dword_1BF22B000, v20, OS_LOG_TYPE_ERROR, "Error opening Darwinup session: %@", buf, 0xCu);
    }

    *__error() = v19;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void __32__SASampleStore_gatherModelInfo__block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  int v7 = *__error();
  id v8 = _sa_logt();
  id v9 = v8;
  if (v5)
  {
    id v34 = v6;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v54 = [v5 count];
      _os_log_impl(&dword_1BF22B000, v9, OS_LOG_TYPE_INFO, "Got information on %lu models", buf, 0xCu);
    }

    *__error() = v7;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    id v35 = v5;
    obuint64_t j = v5;
    uint64_t v10 = [obj countByEnumeratingWithState:&v46 objects:v52 count:16];
    if (v10)
    {
      uint64_t v11 = v10;
      uint64_t v37 = *(void *)v47;
      do
      {
        for (uint64_t i = 0; i != v11; ++i)
        {
          if (*(void *)v47 != v37) {
            objc_enumerationMutation(obj);
          }
          uint64_t v13 = *(void **)(*((void *)&v46 + 1) + 8 * i);
          long long v42 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v45 = 0u;
          int v14 = objc_msgSend(v13, "loadedChanges", v34);
          uint64_t v15 = [v14 countByEnumeratingWithState:&v42 objects:v51 count:16];
          if (v15)
          {
            uint64_t v16 = v15;
            uint64_t v17 = *(void *)v43;
            do
            {
              for (uint64_t j = 0; j != v16; ++j)
              {
                if (*(void *)v43 != v17) {
                  objc_enumerationMutation(v14);
                }
                int v19 = *(void **)(*((void *)&v42 + 1) + 8 * j);
                uint64_t v20 = [v19 timestamp];
                -[SATimestamp applyMachTimebase:]((uint64_t)v20, [*(id *)(a1 + 32) machTimebase]);

                long long v21 = [v19 endTime];
                -[SATimestamp applyMachTimebase:]((uint64_t)v21, [*(id *)(a1 + 32) machTimebase]);
              }
              uint64_t v16 = [v14 countByEnumeratingWithState:&v42 objects:v51 count:16];
            }
            while (v16);
          }

          long long v40 = 0u;
          long long v41 = 0u;
          long long v38 = 0u;
          long long v39 = 0u;
          long long v22 = [v13 executions];
          uint64_t v23 = [v22 countByEnumeratingWithState:&v38 objects:v50 count:16];
          if (v23)
          {
            uint64_t v24 = v23;
            uint64_t v25 = *(void *)v39;
            do
            {
              for (uint64_t k = 0; k != v24; ++k)
              {
                if (*(void *)v39 != v25) {
                  objc_enumerationMutation(v22);
                }
                uint64_t v27 = *(void **)(*((void *)&v38 + 1) + 8 * k);
                uint64_t v28 = [v27 startTime];
                -[SATimestamp applyMachTimebase:]((uint64_t)v28, [*(id *)(a1 + 32) machTimebase]);

                uint32_t v29 = [v27 endTime];
                -[SATimestamp applyMachTimebase:]((uint64_t)v29, [*(id *)(a1 + 32) machTimebase]);
              }
              uint64_t v24 = [v22 countByEnumeratingWithState:&v38 objects:v50 count:16];
            }
            while (v24);
          }
        }
        uint64_t v11 = [obj countByEnumeratingWithState:&v46 objects:v52 count:16];
      }
      while (v11);
    }

    uint64_t v30 = [obj copy];
    uint64_t v31 = *(void *)(a1 + 32);
    id v32 = *(void **)(v31 + 536);
    *(void *)(v31 + 536) = v30;

    id v6 = v34;
    id v5 = v35;
  }
  else
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v33 = [v6 debugDescription];
      *(_DWORD *)long long buf = 138412290;
      uint64_t v54 = (uint64_t)v33;
      _os_log_error_impl(&dword_1BF22B000, v9, OS_LOG_TYPE_ERROR, "Unable to get model information: %@", buf, 0xCu);
    }
    *__error() = v7;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void __38__SASampleStore_iterateAllTimestamps___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = [v3 execTimestamp];

  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = [v3 execTimestamp];
    (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);
  }
  int v7 = [v3 exitTimestamp];

  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    id v9 = [v3 exitTimestamp];
    (*(void (**)(uint64_t, void *))(v8 + 16))(v8, v9);
  }
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v10 = [v3 taskStates];
  uint64_t v11 = [v10 countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v13 = *(void *)v24;
    do
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        if (*(void *)v24 != v13) {
          objc_enumerationMutation(v10);
        }
        uint64_t v15 = *(void **)(*((void *)&v23 + 1) + 8 * i);
        uint64_t v16 = *(void *)(a1 + 32);
        uint64_t v17 = [v15 startTimestamp];
        (*(void (**)(uint64_t, void *))(v16 + 16))(v16, v17);

        uint64_t v18 = *(void *)(a1 + 32);
        int v19 = [v15 endTimestamp];
        (*(void (**)(uint64_t, void *))(v18 + 16))(v18, v19);
      }
      uint64_t v12 = [v10 countByEnumeratingWithState:&v23 objects:v27 count:16];
    }
    while (v12);
  }

  uint64_t v20 = [v3 threads];
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 3221225472;
  v21[2] = __38__SASampleStore_iterateAllTimestamps___block_invoke_2;
  v21[3] = &unk_1E63F7A80;
  id v22 = *(id *)(a1 + 32);
  [v20 enumerateKeysAndObjectsUsingBlock:v21];
}

void __38__SASampleStore_iterateAllTimestamps___block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = [v4 creationTimestamp];

  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v7 = [v4 creationTimestamp];
    (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v7);
  }
  uint64_t v8 = [v4 exitTimestamp];

  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = [v4 exitTimestamp];
    (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);
  }
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v11 = objc_msgSend(v4, "threadStates", 0);
  uint64_t v12 = [v11 countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (v12)
  {
    uint64_t v13 = v12;
    uint64_t v14 = *(void *)v25;
    do
    {
      for (uint64_t i = 0; i != v13; ++i)
      {
        if (*(void *)v25 != v14) {
          objc_enumerationMutation(v11);
        }
        uint64_t v16 = *(void **)(*((void *)&v24 + 1) + 8 * i);
        uint64_t v17 = *(void *)(a1 + 32);
        uint64_t v18 = [v16 startTimestamp];
        (*(void (**)(uint64_t, void *))(v17 + 16))(v17, v18);

        uint64_t v19 = *(void *)(a1 + 32);
        uint64_t v20 = [v16 endTimestamp];
        (*(void (**)(uint64_t, void *))(v19 + 16))(v19, v20);

        long long v21 = [v16 timestampLastMadeRunnable];

        if (v21)
        {
          uint64_t v22 = *(void *)(a1 + 32);
          long long v23 = [v16 timestampLastMadeRunnable];
          (*(void (**)(uint64_t, void *))(v22 + 16))(v22, v23);
        }
      }
      uint64_t v13 = [v11 countByEnumeratingWithState:&v24 objects:v28 count:16];
    }
    while (v13);
  }
}

- (id)callTreeForTask:(id)a3 options:(id)a4
{
  id v6 = a4;
  id v7 = a3;
  uint64_t v8 = [[SASamplePrinter alloc] initWithSampleStore:self];
  [(SASamplePrinter *)v8 setOptions:v6];

  uint64_t v9 = [(SASamplePrinter *)v8 callTreeForTask:v7];

  return v9;
}

- (id)callTreesForThreadsInTask:(id)a3 options:(id)a4
{
  id v6 = a4;
  id v7 = a3;
  uint64_t v8 = [[SASamplePrinter alloc] initWithSampleStore:self];
  [(SASamplePrinter *)v8 setOptions:v6];

  uint64_t v9 = [(SASamplePrinter *)v8 callTreesForThreadsInTask:v7];

  return v9;
}

- (id)callTreeForThread:(id)a3 inTask:(id)a4 options:(id)a5
{
  id v8 = a5;
  id v9 = a4;
  id v10 = a3;
  uint64_t v11 = [[SASamplePrinter alloc] initWithSampleStore:self];
  [(SASamplePrinter *)v11 setOptions:v8];

  uint64_t v12 = [(SASamplePrinter *)v11 callTreeForThread:v10 inTask:v9];

  return v12;
}

- (id)callTreeForDispatchQueue:(id)a3 andThread:(id)a4 inTask:(id)a5 options:(id)a6
{
  id v10 = a6;
  id v11 = a5;
  id v12 = a4;
  id v13 = a3;
  uint64_t v14 = [[SASamplePrinter alloc] initWithSampleStore:self];
  [(SASamplePrinter *)v14 setOptions:v10];

  uint64_t v15 = [(SASamplePrinter *)v14 callTreeForDispatchQueue:v13 andThread:v12 inTask:v11];

  return v15;
}

- (id)callTreeForSwiftTask:(id)a3 thread:(id)a4 inTask:(id)a5 options:(id)a6
{
  id v10 = a6;
  id v11 = a5;
  id v12 = a4;
  id v13 = a3;
  uint64_t v14 = [[SASamplePrinter alloc] initWithSampleStore:self];
  [(SASamplePrinter *)v14 setOptions:v10];

  uint64_t v15 = [(SASamplePrinter *)v14 callTreeForSwiftTask:v13 thread:v12 inTask:v11];

  return v15;
}

- (id)callTreeForDispatchQueue:(id)a3 swiftTask:(id)a4 thread:(id)a5 inTask:(id)a6 options:(id)a7
{
  id v12 = a7;
  id v13 = a6;
  id v14 = a5;
  id v15 = a4;
  id v16 = a3;
  uint64_t v17 = [[SASamplePrinter alloc] initWithSampleStore:self];
  [(SASamplePrinter *)v17 setOptions:v12];

  uint64_t v18 = [(SASamplePrinter *)v17 callTreeForDispatchQueue:v16 swiftTask:v15 thread:v14 inTask:v13];

  return v18;
}

- (id)callTreeForExecutable:(id)a3 options:(id)a4
{
  id v6 = a4;
  id v7 = a3;
  id v8 = [[SASamplePrinter alloc] initWithSampleStore:self];
  [(SASamplePrinter *)v8 setOptions:v6];

  id v9 = [(SASamplePrinter *)v8 callTreeForExecutable:v7];

  return v9;
}

- (NSDictionary)tasksByPid
{
  return (NSDictionary *)objc_getProperty(self, a2, 16, 1);
}

- (NSArray)sampleTimestamps
{
  return (NSArray *)objc_getProperty(self, a2, 24, 1);
}

- (NSArray)hidEvents
{
  return (NSArray *)objc_getProperty(self, a2, 56, 1);
}

- (NSArray)ioEvents
{
  return (NSArray *)objc_getProperty(self, a2, 88, 1);
}

- (NSArray)memoryPressureEvents
{
  return (NSArray *)objc_getProperty(self, a2, 96, 1);
}

- (NSArray)kernelCaches
{
  return (NSArray *)objc_getProperty(self, a2, 104, 1);
}

- (NSArray)exclaves
{
  return (NSArray *)objc_getProperty(self, a2, 120, 1);
}

- (NSArray)powerModeTransitions
{
  return (NSArray *)objc_getProperty(self, a2, 80, 1);
}

- (unint64_t)dataSource
{
  return self->_dataSource;
}

- (unint64_t)dataStyle
{
  return self->_dataStyle;
}

- (double)attemptedSamplingInterval
{
  return self->_attemptedSamplingInterval;
}

- (void)setAttemptedSamplingInterval:(double)a3
{
  self->_attemptedSamplingInterval = a3;
}

- (SATimestamp)timestampOfLastStackshot
{
  return (SATimestamp *)objc_getProperty(self, a2, 376, 1);
}

- (NSString)reason
{
  return (NSString *)objc_getProperty(self, a2, 384, 1);
}

- (void)setReason:(id)a3
{
}

- (double)lastWakeTime
{
  return self->_lastWakeTime;
}

- (SAMountStatusTracker)mountStatusTracker
{
  return (SAMountStatusTracker *)objc_getProperty(self, a2, 400, 1);
}

- (BOOL)keepMicrostackshotsWithoutLoadInfo
{
  return self->_keepMicrostackshotsWithoutLoadInfo;
}

- (void)setKeepMicrostackshotsWithoutLoadInfo:(BOOL)a3
{
  self->_keepMicrostackshotsWithoutLoadInfo = a3;
}

- (unsigned)additionalCSSymbolicatorFlags
{
  return self->_additionalCSSymbolicatorFlags;
}

- (void)setAdditionalCSSymbolicatorFlags:(unsigned int)a3
{
  self->_additionalCSSymbolicatorFlags = a3;
}

- (SATimestamp)timeWhenTransitionedToSamplingAllThreads
{
  return (SATimestamp *)objc_getProperty(self, a2, 424, 1);
}

- (SATimestamp)timeWhenTransitionedToSamplingAllProcesses
{
  return (SATimestamp *)objc_getProperty(self, a2, 432, 1);
}

- (BOOL)sanitizePaths
{
  return self->_sanitizePaths;
}

- (void)setSanitizePaths:(BOOL)a3
{
  self->_sanitizePaths = a3;
}

- (BOOL)omitSensitiveStrings
{
  return self->_omitSensitiveStrings;
}

- (void)setOmitSensitiveStrings:(BOOL)a3
{
  self->_omitSensitiveStrings = a3;
}

- (BOOL)shouldGatherKextStat
{
  return self->_shouldGatherKextStat;
}

- (void)setShouldGatherKextStat:(BOOL)a3
{
  self->_shouldGatherKextStat = a3;
}

- (NSString)kernelVersion
{
  return (NSString *)objc_getProperty(self, a2, 448, 1);
}

- (NSString)osProductName
{
  return (NSString *)objc_getProperty(self, a2, 456, 1);
}

- (void)setOsProductName:(id)a3
{
}

- (NSString)osProductVersion
{
  return (NSString *)objc_getProperty(self, a2, 464, 1);
}

- (void)setOsProductVersion:(id)a3
{
}

- (NSString)osProductVersionExtra
{
  return (NSString *)objc_getProperty(self, a2, 472, 1);
}

- (void)setOsProductVersionExtra:(id)a3
{
}

- (NSString)osBuildVersion
{
  return (NSString *)objc_getProperty(self, a2, 480, 1);
}

- (void)setOsBuildVersion:(id)a3
{
}

- (unsigned)workQueueSoftThreadLimit
{
  return self->_workQueueSoftThreadLimit;
}

- (unsigned)workQueueHardThreadLimit
{
  return self->_workQueueHardThreadLimit;
}

- (NSString)hardwareModel
{
  return (NSString *)objc_getProperty(self, a2, 488, 1);
}

- (void)setHardwareModel:(id)a3
{
}

- (unsigned)numActiveCPUs
{
  return self->_numActiveCPUs;
}

- (void)setNumActiveCPUs:(unsigned int)a3
{
  self->_numActiveCPUs = a3;
}

- (unsigned)hwPageSize
{
  return self->_hwPageSize;
}

- (void)setHwPageSize:(unsigned int)a3
{
  self->_hwPageSize = a3;
}

- (unsigned)vmPageSize
{
  return self->_vmPageSize;
}

- (void)setVmPageSize:(unsigned int)a3
{
  self->_vmPageSize = a3;
}

- (NSString)bootArgs
{
  return (NSString *)objc_getProperty(self, a2, 496, 1);
}

- (void)setBootArgs:(id)a3
{
}

- (NSDictionary)systemAdvisoryLevels
{
  return (NSDictionary *)objc_getProperty(self, a2, 504, 1);
}

- (NSDictionary)homeVolumeSpace
{
  return (NSDictionary *)objc_getProperty(self, a2, 512, 1);
}

- (NSDictionary)nonDefaultFeatureFlags
{
  return (NSDictionary *)objc_getProperty(self, a2, 520, 1);
}

- (NSDictionary)activeTrials
{
  return (NSDictionary *)objc_getProperty(self, a2, 528, 1);
}

- (NSArray)models
{
  return (NSArray *)objc_getProperty(self, a2, 536, 1);
}

- (int64_t)numOSCryptexFileExtents
{
  return self->_numOSCryptexFileExtents;
}

- (BOOL)isRootInstalled
{
  return self->_isRootInstalled;
}

- (NSArray)installedRootNames
{
  return (NSArray *)objc_getProperty(self, a2, 552, 1);
}

- (BOOL)isAppleInternal
{
  return self->_isAppleInternal;
}

- (BOOL)appleInternalIsKnown
{
  return self->_appleInternalIsKnown;
}

- (BOOL)isInternalCarryDevice
{
  return self->_isInternalCarryDevice;
}

- (BOOL)hasInternalCarryDeviceDistinction
{
  return self->_hasInternalCarryDeviceDistinction;
}

- (NSString)automatedDeviceGroup
{
  return (NSString *)objc_getProperty(self, a2, 560, 1);
}

- (NSArray)keyboardLanguages
{
  return (NSArray *)objc_getProperty(self, a2, 568, 1);
}

- (NSArray)preferredLanguages
{
  return (NSArray *)objc_getProperty(self, a2, 576, 1);
}

- (NSString)countryCode
{
  return (NSString *)objc_getProperty(self, a2, 584, 1);
}

- (BOOL)hasHardwareKeyboardInfo
{
  return self->_hasHardwareKeyboardInfo;
}

- (BOOL)hardwareKeyboard
{
  return self->_hardwareKeyboard;
}

- (unint64_t)gpuRestartCount
{
  return self->_gpuRestartCount;
}

- (unint64_t)gpuRestartLastMachAbs
{
  return self->_gpuRestartLastMachAbs;
}

- (BOOL)hasEnterprisePersona
{
  return self->_hasEnterprisePersona;
}

- (unint64_t)targetHIDEventEndMachAbs
{
  return self->_targetHIDEventEndMachAbs;
}

- (void)setTargetHIDEventEndMachAbs:(unint64_t)a3
{
  self->_targetHIDEventEndMachAbs = a3;
}

- (NSString)customOutput
{
  return (NSString *)objc_getProperty(self, a2, 616, 1);
}

- (void)setCustomOutput:(id)a3
{
}

- (double)cpuUsed
{
  return self->_cpuUsed;
}

- (void)setCpuUsed:(double)a3
{
  self->_cpuUsed = a3;
}

- (double)cpuDuration
{
  return self->_cpuDuration;
}

- (void)setCpuDuration:(double)a3
{
  self->_cpuDuratiouint64_t n = a3;
}

- (double)cpuLimit
{
  return self->_cpuLimit;
}

- (void)setCpuLimit:(double)a3
{
  self->_cpuLimit = a3;
}

- (double)cpuLimitDuration
{
  return self->_cpuLimitDuration;
}

- (void)setCpuLimitDuration:(double)a3
{
  self->_cpuLimitDuratiouint64_t n = a3;
}

- (unint64_t)numWakeups
{
  return self->_numWakeups;
}

- (void)setNumWakeups:(unint64_t)a3
{
  self->_numWakeups = a3;
}

- (double)wakeupsDuration
{
  return self->_wakeupsDuration;
}

- (void)setWakeupsDuration:(double)a3
{
  self->_wakeupsDuratiouint64_t n = a3;
}

- (unint64_t)numWakeupsLimit
{
  return self->_numWakeupsLimit;
}

- (void)setNumWakeupsLimit:(unint64_t)a3
{
  self->_numWakeupsLimit = a3;
}

- (double)wakeupsLimitDuration
{
  return self->_wakeupsLimitDuration;
}

- (void)setWakeupsLimitDuration:(double)a3
{
  self->_wakeupsLimitDuratiouint64_t n = a3;
}

- (unint64_t)bytesWritten
{
  return self->_bytesWritten;
}

- (void)setBytesWritten:(unint64_t)a3
{
  self->_bytesWritteuint64_t n = a3;
}

- (double)writeDuration
{
  return self->_writeDuration;
}

- (void)setWriteDuration:(double)a3
{
  self->_writeDuratiouint64_t n = a3;
}

- (unint64_t)bytesWrittenLimit
{
  return self->_bytesWrittenLimit;
}

- (void)setBytesWrittenLimit:(unint64_t)a3
{
  self->_bytesWrittenLimit = a3;
}

- (double)writeLimitDuration
{
  return self->_writeLimitDuration;
}

- (void)setWriteLimitDuration:(double)a3
{
  self->_writeLimitDuratiouint64_t n = a3;
}

- (NSString)event
{
  return (NSString *)objc_getProperty(self, a2, 720, 1);
}

- (void)setEvent:(id)a3
{
}

- (void)setEventNote:(id)a3
{
}

- (SATimeRange)eventTimeRange
{
  return (SATimeRange *)objc_getProperty(self, a2, 736, 1);
}

- (void)setEventTimeRange:(id)a3
{
}

- (NSString)signature
{
  return (NSString *)objc_getProperty(self, a2, 744, 1);
}

- (void)setSignature:(id)a3
{
}

- (NSString)actionTaken
{
  return (NSString *)objc_getProperty(self, a2, 752, 1);
}

- (void)setActionTaken:(id)a3
{
}

- (double)extraDuration
{
  return self->_extraDuration;
}

- (void)setExtraDuration:(double)a3
{
  self->_extraDuratiouint64_t n = a3;
}

- (NSString)durationNote
{
  return (NSString *)objc_getProperty(self, a2, 768, 1);
}

- (void)setDurationNote:(id)a3
{
}

- (NSString)stepsNote
{
  return (NSString *)objc_getProperty(self, a2, 776, 1);
}

- (void)setStepsNote:(id)a3
{
}

- (double)reportTimeThreshold
{
  return self->_reportTimeThreshold;
}

- (void)setReportTimeThreshold:(double)a3
{
  self->_reportTimeThreshold = a3;
}

- (NSString)wrWorkflowName
{
  return (NSString *)objc_getProperty(self, a2, 792, 1);
}

- (void)setWrWorkflowName:(id)a3
{
}

- (NSError)wrError
{
  return (NSError *)objc_getProperty(self, a2, 800, 1);
}

- (void)setWrError:(id)a3
{
}

- (NSString)wrDiagnosticName
{
  return (NSString *)objc_getProperty(self, a2, 808, 1);
}

- (void)setWrDiagnosticName:(id)a3
{
}

- (double)wrWorkflowTimeoutDuration
{
  return self->_wrWorkflowTimeoutDuration;
}

- (void)setWrWorkflowTimeoutDuration:(double)a3
{
  self->_wrWorkflowTimeoutDuratiouint64_t n = a3;
}

- (double)wrWorkflowDurationThreshold
{
  return self->_wrWorkflowDurationThreshold;
}

- (void)setWrWorkflowDurationThreshold:(double)a3
{
  self->_wrWorkflowDurationThreshold = a3;
}

- (double)wrWorkflowDuration
{
  return self->_wrWorkflowDuration;
}

- (void)setWrWorkflowDuration:(double)a3
{
  self->_wrWorkflowDuratiouint64_t n = a3;
}

- (double)wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold
{
  return self->_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold;
}

- (void)setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold:(double)a3
{
  self->_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold = a3;
}

- (double)wrWorkflowDurationOmittingNetworkBoundIntervals
{
  return self->_wrWorkflowDurationOmittingNetworkBoundIntervals;
}

- (void)setWrWorkflowDurationOmittingNetworkBoundIntervals:(double)a3
{
  self->_wrWorkflowDurationOmittingNetworkBoundIntervals = a3;
}

- (NSString)wrSignpostName
{
  return (NSString *)objc_getProperty(self, a2, 856, 1);
}

- (void)setWrSignpostName:(id)a3
{
}

- (NSString)wrSignpostSubsystem
{
  return (NSString *)objc_getProperty(self, a2, 864, 1);
}

- (void)setWrSignpostSubsystem:(id)a3
{
}

- (NSString)wrSignpostCategory
{
  return (NSString *)objc_getProperty(self, a2, 872, 1);
}

- (void)setWrSignpostCategory:(id)a3
{
}

- (NSString)wrTriggeringSignpostName
{
  return (NSString *)objc_getProperty(self, a2, 880, 1);
}

- (void)setWrTriggeringSignpostName:(id)a3
{
}

- (NSString)wrTriggeringSignpostSubsystem
{
  return (NSString *)objc_getProperty(self, a2, 888, 1);
}

- (void)setWrTriggeringSignpostSubsystem:(id)a3
{
}

- (NSString)wrTriggeringSignpostCategory
{
  return (NSString *)objc_getProperty(self, a2, 896, 1);
}

- (void)setWrTriggeringSignpostCategory:(id)a3
{
}

- (unint64_t)wrSignpostCountThreshold
{
  return self->_wrSignpostCountThreshold;
}

- (void)setWrSignpostCountThreshold:(unint64_t)a3
{
  self->_wrSignpostCountThreshold = a3;
}

- (unint64_t)wrSignpostCount
{
  return self->_wrSignpostCount;
}

- (void)setWrSignpostCount:(unint64_t)a3
{
  self->_wrSignpostCount = a3;
}

- (double)wrSignpostDurationUnionThreshold
{
  return self->_wrSignpostDurationUnionThreshold;
}

- (void)setWrSignpostDurationUnionThreshold:(double)a3
{
  self->_wrSignpostDurationUnionThreshold = a3;
}

- (double)wrSignpostDurationUnion
{
  return self->_wrSignpostDurationUnion;
}

- (void)setWrSignpostDurationUnion:(double)a3
{
  self->_wrSignpostDurationUniouint64_t n = a3;
}

- (double)wrSignpostDurationSumThreshold
{
  return self->_wrSignpostDurationSumThreshold;
}

- (void)setWrSignpostDurationSumThreshold:(double)a3
{
  self->_wrSignpostDurationSumThreshold = a3;
}

- (double)wrSignpostDurationSum
{
  return self->_wrSignpostDurationSum;
}

- (void)setWrSignpostDurationSum:(double)a3
{
  self->_wrSignpostDurationSuuint64_t m = a3;
}

- (double)wrSignpostDurationSingleThreshold
{
  return self->_wrSignpostDurationSingleThreshold;
}

- (void)setWrSignpostDurationSingleThreshold:(double)a3
{
  self->_wrSignpostDurationSingleThreshold = a3;
}

- (double)wrSignpostDurationSingle
{
  return self->_wrSignpostDurationSingle;
}

- (void)setWrSignpostDurationSingle:(double)a3
{
  self->_wrSignpostDurationSingle = a3;
}

- (void).cxx_destruct
{
  objc_storeStrong((id *)&self->_clusterFlagsForCPUNumMapping, 0);
  objc_storeStrong((id *)&self->_mostRecentNativeSharedCache, 0);
  objc_storeStrong((id *)&self->_previousSAVersions, 0);
  objc_storeStrong((id *)&self->_processNameForUnknownPids, 0);
  objc_storeStrong((id *)&self->_ioEventsByTid, 0);
  objc_storeStrong((id *)&self->_wrTriggeringSignpostCategory, 0);
  objc_storeStrong((id *)&self->_wrTriggeringSignpostSubsystem, 0);
  objc_storeStrong((id *)&self->_wrTriggeringSignpostName, 0);
  objc_storeStrong((id *)&self->_wrSignpostCategory, 0);
  objc_storeStrong((id *)&self->_wrSignpostSubsystem, 0);
  objc_storeStrong((id *)&self->_wrSignpostName, 0);
  objc_storeStrong((id *)&self->_wrDiagnosticName, 0);
  objc_storeStrong((id *)&self->_wrError, 0);
  objc_storeStrong((id *)&self->_wrWorkflowName, 0);
  objc_storeStrong((id *)&self->_stepsNote, 0);
  objc_storeStrong((id *)&self->_durationNote, 0);
  objc_storeStrong((id *)&self->_actionTaken, 0);
  objc_storeStrong((id *)&self->_signature, 0);
  objc_storeStrong((id *)&self->_eventTimeRange, 0);
  objc_storeStrong((id *)&self->_eventNote, 0);
  objc_storeStrong((id *)&self->_event, 0);
  objc_storeStrong((id *)&self->_customOutput, 0);
  objc_storeStrong((id *)&self->_countryCode, 0);
  objc_storeStrong((id *)&self->_preferredLanguages, 0);
  objc_storeStrong((id *)&self->_keyboardLanguages, 0);
  objc_storeStrong((id *)&self->_automatedDeviceGroup, 0);
  objc_storeStrong((id *)&self->_installedRootNames, 0);
  objc_storeStrong((id *)&self->_models, 0);
  objc_storeStrong((id *)&self->_activeTrials, 0);
  objc_storeStrong((id *)&self->_nonDefaultFeatureFlags, 0);
  objc_storeStrong((id *)&self->_homeVolumeSpace, 0);
  objc_storeStrong((id *)&self->_systemAdvisoryLevels, 0);
  objc_storeStrong((id *)&self->_bootArgs, 0);
  objc_storeStrong((id *)&self->_hardwareModel, 0);
  objc_storeStrong((id *)&self->_osBuildVersion, 0);
  objc_storeStrong((id *)&self->_osProductVersionExtra, 0);
  objc_storeStrong((id *)&self->_osProductVersion, 0);
  objc_storeStrong((id *)&self->_osProductName, 0);
  objc_storeStrong((id *)&self->_kernelVersion, 0);
  objc_storeStrong((id *)&self->_kextStat, 0);
  objc_storeStrong((id *)&self->_timeWhenTransitionedToSamplingAllProcesses, 0);
  objc_storeStrong((id *)&self->_timeWhenTransitionedToSamplingAllThreads, 0);
  objc_storeStrong((id *)&self->_cpuSignalHandlerStackLeafKernelFrame, 0);
  objc_storeStrong((id *)&self->_mountStatusTracker, 0);
  objc_storeStrong((id *)&self->_reason, 0);
  objc_storeStrong((id *)&self->_timestampOfLastStackshot, 0);
  objc_storeStrong((id *)&self->_processAddressTranslations, 0);
  objc_storeStrong((id *)&self->_idsToUseDsymForUUID, 0);
  objc_storeStrong((id *)&self->_namesToUseDsymForUUID, 0);
  objc_storeStrong((id *)&self->_kperfTriggers, 0);
  objc_storeStrong((id *)&self->_targetProcess, 0);
  objc_storeStrong((id *)&self->_pidsToTrack, 0);
  objc_storeStrong((id *)&self->_binaryLocator, 0);
  objc_storeStrong((id *)&self->_wsDataStore, 0);
  objc_storeStrong((id *)&self->_exclaves, 0);
  objc_storeStrong((id *)&self->_sharedCaches, 0);
  objc_storeStrong((id *)&self->_kernelCaches, 0);
  objc_storeStrong((id *)&self->_memoryPressureEvents, 0);
  objc_storeStrong((id *)&self->_ioEvents, 0);
  objc_storeStrong((id *)&self->_powerModeTransitions, 0);
  objc_storeStrong((id *)&self->_fanSpeeds, 0);
  objc_storeStrong((id *)&self->_gestures, 0);
  objc_storeStrong((id *)&self->_hidEvents, 0);
  objc_storeStrong((id *)&self->_endTime, 0);
  objc_storeStrong((id *)&self->_startTime, 0);
  objc_storeStrong((id *)&self->_sampleTimestamps, 0);
  objc_storeStrong((id *)&self->_tasksByPid, 0);
  objc_storeStrong((id *)&self->_tasksByUniquePid, 0);
}

+ (BOOL)supportsSecureCoding
{
  return 1;
}

- (void)encodeWithCoder:(id)a3
{
  uint64_t v219 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if (v4)
  {
    uint64_t v5 = (void *)MEMORY[0x1C18A6A20]();
    [(SASampleStore *)self symbolicate];
    id v6 = (void *)MEMORY[0x1C18A6A20]();
    [v4 encodeInteger:36 forKey:@"_PASampleTimeSeriesDataStore_Serialized_Version"];
    [v4 encodeInteger:36 forKey:@"_SASampleStore_Serialized_Version"];
    id v7 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    *(void *)long long buf = 0;
    uint64_t v203 = buf;
    uint64_t v204 = 0x2020000000;
    uint64_t v205 = 0;
    v201[0] = MEMORY[0x1E4F143A8];
    v201[1] = 3221225472;
    v201[2] = __56__SASampleStore_SASampleStoreNSCoding__encodeWithCoder___block_invoke;
    v201[3] = &unk_1E63F7AD0;
    v201[4] = buf;
    [(SASampleStore *)self enumerateTasks:v201];
    uint64_t v8 = *((void *)v203 + 3);
    if (v8)
    {
      uint64_t v9 = 8 * v8;
      id v10 = malloc_type_malloc(8 * v8, 0x2773E731uLL);
      v200[0] = 0;
      v200[1] = v200;
      v200[2] = 0x2020000000;
      v200[3] = 0;
      v196[0] = MEMORY[0x1E4F143A8];
      v196[1] = 3221225472;
      v196[2] = __56__SASampleStore_SASampleStoreNSCoding__encodeWithCoder___block_invoke_2;
      v196[3] = &unk_1E63F7438;
      uint64_t v199 = v10;
      id v197 = v7;
      uint64_t v198 = v200;
      [(SASampleStore *)self enumerateTasks:v196];
      [v4 encodeBytes:v10 length:v9 forKey:@"_tasks"];
      free(v10);

      _Block_object_dispose(v200, 8);
    }
    id v11 = -[SASampleStore lastTaskWithPid:](self, 0);
    id v13 = v11;
    if (v11) {
      id Property = objc_getProperty(v11, v12, 280, 1);
    }
    else {
      id Property = 0;
    }
    id v15 = Property;

    if (v15)
    {
      unint64_t v16 = [v15 count];
      if (v16)
      {
        long long v194 = 0u;
        long long v195 = 0u;
        long long v192 = 0u;
        long long v193 = 0u;
        id v17 = v15;
        uint64_t v18 = [v17 countByEnumeratingWithState:&v192 objects:v218 count:16];
        if (v18)
        {
          uint64_t v19 = *(void *)v193;
          do
          {
            for (uint64_t i = 0; i != v18; ++i)
            {
              if (*(void *)v193 != v19) {
                objc_enumerationMutation(v17);
              }
              [*(id *)(*((void *)&v192 + 1) + 8 * i) addSelfToSerializationDictionary:v7];
            }
            uint64_t v18 = [v17 countByEnumeratingWithState:&v192 objects:v218 count:16];
          }
          while (v18);
        }

        long long v21 = malloc_type_malloc(8 * v16, 0x7288A8B1uLL);
        SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v21, v16, v17, v7);
        [v4 encodeBytes:v21 length:8 * v16 forKey:@"_rootKernelFrames"];
        free(v21);
      }
    }
    fanSpeeds = self->_fanSpeeds;
    if (fanSpeeds)
    {
      unint64_t v23 = [(NSMutableArray *)fanSpeeds count];
      long long v190 = 0u;
      long long v191 = 0u;
      long long v188 = 0u;
      long long v189 = 0u;
      long long v24 = self->_fanSpeeds;
      uint64_t v25 = [(NSMutableArray *)v24 countByEnumeratingWithState:&v188 objects:v217 count:16];
      if (v25)
      {
        uint64_t v26 = *(void *)v189;
        do
        {
          for (uint64_t j = 0; j != v25; ++j)
          {
            if (*(void *)v189 != v26) {
              objc_enumerationMutation(v24);
            }
            [*(id *)(*((void *)&v188 + 1) + 8 * j) addSelfToSerializationDictionary:v7];
          }
          uint64_t v25 = [(NSMutableArray *)v24 countByEnumeratingWithState:&v188 objects:v217 count:16];
        }
        while (v25);
      }

      uint64_t v28 = malloc_type_malloc(8 * v23, 0xC9174A17uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v28, v23, self->_fanSpeeds, v7);
      [v4 encodeBytes:v28 length:8 * v23 forKey:@"_fanSpeeds"];
      free(v28);
    }
    powerModeTransitions = self->_powerModeTransitions;
    if (powerModeTransitions)
    {
      unint64_t v30 = [(NSMutableArray *)powerModeTransitions count];
      long long v186 = 0u;
      long long v187 = 0u;
      long long v184 = 0u;
      long long v185 = 0u;
      uint64_t v31 = self->_powerModeTransitions;
      uint64_t v32 = [(NSMutableArray *)v31 countByEnumeratingWithState:&v184 objects:v216 count:16];
      if (v32)
      {
        uint64_t v33 = *(void *)v185;
        do
        {
          for (uint64_t k = 0; k != v32; ++k)
          {
            if (*(void *)v185 != v33) {
              objc_enumerationMutation(v31);
            }
            [*(id *)(*((void *)&v184 + 1) + 8 * k) addSelfToSerializationDictionary:v7];
          }
          uint64_t v32 = [(NSMutableArray *)v31 countByEnumeratingWithState:&v184 objects:v216 count:16];
        }
        while (v32);
      }

      id v35 = malloc_type_malloc(8 * v30, 0xBB38B55EuLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v35, v30, self->_powerModeTransitions, v7);
      [v4 encodeBytes:v35 length:8 * v30 forKey:@"_powerModeTransitions"];
      free(v35);
    }
    hidEvents = self->_hidEvents;
    if (hidEvents)
    {
      unint64_t v37 = [(NSMutableArray *)hidEvents count];
      long long v182 = 0u;
      long long v183 = 0u;
      long long v180 = 0u;
      long long v181 = 0u;
      long long v38 = self->_hidEvents;
      uint64_t v39 = [(NSMutableArray *)v38 countByEnumeratingWithState:&v180 objects:v215 count:16];
      if (v39)
      {
        uint64_t v40 = *(void *)v181;
        do
        {
          for (uint64_t m = 0; m != v39; ++m)
          {
            if (*(void *)v181 != v40) {
              objc_enumerationMutation(v38);
            }
            [*(id *)(*((void *)&v180 + 1) + 8 * m) addSelfToSerializationDictionary:v7];
          }
          uint64_t v39 = [(NSMutableArray *)v38 countByEnumeratingWithState:&v180 objects:v215 count:16];
        }
        while (v39);
      }

      long long v42 = malloc_type_malloc(8 * v37, 0x658287B9uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v42, v37, self->_hidEvents, v7);
      [v4 encodeBytes:v42 length:8 * v37 forKey:@"_hidEvents"];
      free(v42);
    }
    gestures = self->_gestures;
    if (gestures)
    {
      unint64_t v44 = [(NSMutableArray *)gestures count];
      long long v178 = 0u;
      long long v179 = 0u;
      long long v176 = 0u;
      long long v177 = 0u;
      long long v45 = self->_gestures;
      uint64_t v46 = [(NSMutableArray *)v45 countByEnumeratingWithState:&v176 objects:v214 count:16];
      if (v46)
      {
        uint64_t v47 = *(void *)v177;
        do
        {
          for (uint64_t n = 0; n != v46; ++n)
          {
            if (*(void *)v177 != v47) {
              objc_enumerationMutation(v45);
            }
            [*(id *)(*((void *)&v176 + 1) + 8 * n) addSelfToSerializationDictionary:v7];
          }
          uint64_t v46 = [(NSMutableArray *)v45 countByEnumeratingWithState:&v176 objects:v214 count:16];
        }
        while (v46);
      }

      long long v49 = malloc_type_malloc(8 * v44, 0x1DC8E228uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v49, v44, self->_gestures, v7);
      [v4 encodeBytes:v49 length:8 * v44 forKey:@"_gestures"];
      free(v49);
    }
    ioEvents = self->_ioEvents;
    if (ioEvents)
    {
      unint64_t v51 = [(NSMutableArray *)ioEvents count];
      long long v174 = 0u;
      long long v175 = 0u;
      long long v172 = 0u;
      long long v173 = 0u;
      unint64_t v52 = self->_ioEvents;
      uint64_t v53 = [(NSMutableArray *)v52 countByEnumeratingWithState:&v172 objects:v213 count:16];
      if (v53)
      {
        uint64_t v54 = *(void *)v173;
        do
        {
          for (iuint64_t i = 0; ii != v53; ++ii)
          {
            if (*(void *)v173 != v54) {
              objc_enumerationMutation(v52);
            }
            [*(id *)(*((void *)&v172 + 1) + 8 * ii) addSelfToSerializationDictionary:v7];
          }
          uint64_t v53 = [(NSMutableArray *)v52 countByEnumeratingWithState:&v172 objects:v213 count:16];
        }
        while (v53);
      }

      uint64_t v56 = malloc_type_malloc(8 * v51, 0x4EDBD29BuLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v56, v51, self->_ioEvents, v7);
      [v4 encodeBytes:v56 length:8 * v51 forKey:@"_ioEvents"];
      free(v56);
    }
    memoryPressureEvents = self->_memoryPressureEvents;
    if (memoryPressureEvents)
    {
      unint64_t v58 = [(NSMutableArray *)memoryPressureEvents count];
      long long v170 = 0u;
      long long v171 = 0u;
      long long v168 = 0u;
      long long v169 = 0u;
      uint64_t v59 = self->_memoryPressureEvents;
      uint64_t v60 = [(NSMutableArray *)v59 countByEnumeratingWithState:&v168 objects:v212 count:16];
      if (v60)
      {
        uint64_t v61 = *(void *)v169;
        do
        {
          for (juint64_t j = 0; jj != v60; ++jj)
          {
            if (*(void *)v169 != v61) {
              objc_enumerationMutation(v59);
            }
            [*(id *)(*((void *)&v168 + 1) + 8 * jj) addSelfToSerializationDictionary:v7];
          }
          uint64_t v60 = [(NSMutableArray *)v59 countByEnumeratingWithState:&v168 objects:v212 count:16];
        }
        while (v60);
      }

      unsigned int v63 = malloc_type_malloc(8 * v58, 0x4FA82583uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v63, v58, self->_memoryPressureEvents, v7);
      [v4 encodeBytes:v63 length:8 * v58 forKey:@"_memoryPressureEvents"];
      free(v63);
    }
    sharedCaches = self->_sharedCaches;
    if (sharedCaches)
    {
      unint64_t v65 = [(NSMutableArray *)sharedCaches count];
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      char v66 = self->_sharedCaches;
      uint64_t v67 = [(NSMutableArray *)v66 countByEnumeratingWithState:&v164 objects:v211 count:16];
      if (v67)
      {
        uint64_t v68 = *(void *)v165;
        do
        {
          for (kuint64_t k = 0; kk != v67; ++kk)
          {
            if (*(void *)v165 != v68) {
              objc_enumerationMutation(v66);
            }
            [*(id *)(*((void *)&v164 + 1) + 8 * kk) addSelfToSerializationDictionary:v7];
          }
          uint64_t v67 = [(NSMutableArray *)v66 countByEnumeratingWithState:&v164 objects:v211 count:16];
        }
        while (v67);
      }

      uint64_t v70 = malloc_type_malloc(8 * v65, 0x5865EE10uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v70, v65, self->_sharedCaches, v7);
      [v4 encodeBytes:v70 length:8 * v65 forKey:@"_sharedCaches"];
      free(v70);
    }
    kernelCaches = self->_kernelCaches;
    if (kernelCaches)
    {
      unint64_t v72 = [(NSMutableArray *)kernelCaches count];
      long long v162 = 0u;
      long long v163 = 0u;
      long long v160 = 0u;
      long long v161 = 0u;
      uint64_t v73 = self->_kernelCaches;
      uint64_t v74 = [(NSMutableArray *)v73 countByEnumeratingWithState:&v160 objects:v210 count:16];
      if (v74)
      {
        uint64_t v75 = *(void *)v161;
        do
        {
          for (muint64_t m = 0; mm != v74; ++mm)
          {
            if (*(void *)v161 != v75) {
              objc_enumerationMutation(v73);
            }
            [*(id *)(*((void *)&v160 + 1) + 8 * mm) addSelfToSerializationDictionary:v7];
          }
          uint64_t v74 = [(NSMutableArray *)v73 countByEnumeratingWithState:&v160 objects:v210 count:16];
        }
        while (v74);
      }

      id v77 = malloc_type_malloc(8 * v72, 0x3A9CC605uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v77, v72, self->_kernelCaches, v7);
      [v4 encodeBytes:v77 length:8 * v72 forKey:@"_kernelCaches"];
      free(v77);
    }
    exclaves = self->_exclaves;
    if (exclaves)
    {
      unint64_t v79 = [(NSMutableArray *)exclaves count];
      long long v158 = 0u;
      long long v159 = 0u;
      long long v156 = 0u;
      long long v157 = 0u;
      id v80 = self->_exclaves;
      uint64_t v81 = [(NSMutableArray *)v80 countByEnumeratingWithState:&v156 objects:v209 count:16];
      if (v81)
      {
        uint64_t v82 = *(void *)v157;
        do
        {
          for (nuint64_t n = 0; nn != v81; ++nn)
          {
            if (*(void *)v157 != v82) {
              objc_enumerationMutation(v80);
            }
            [*(id *)(*((void *)&v156 + 1) + 8 * nn) addSelfToSerializationDictionary:v7];
          }
          uint64_t v81 = [(NSMutableArray *)v80 countByEnumeratingWithState:&v156 objects:v209 count:16];
        }
        while (v81);
      }

      long long v84 = malloc_type_malloc(8 * v79, 0xCE96E6BAuLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v84, v79, self->_exclaves, v7);
      [v4 encodeBytes:v84 length:8 * v79 forKey:@"_exclaves"];
      free(v84);
    }
    kperfTriggers = self->_kperfTriggers;
    if (kperfTriggers)
    {
      unint64_t v86 = [(NSArray *)kperfTriggers count];
      long long v154 = 0u;
      long long v155 = 0u;
      long long v152 = 0u;
      long long v153 = 0u;
      long long v87 = self->_kperfTriggers;
      uint64_t v88 = [(NSArray *)v87 countByEnumeratingWithState:&v152 objects:v208 count:16];
      if (v88)
      {
        uint64_t v89 = *(void *)v153;
        do
        {
          for (uint64_t i1 = 0; i1 != v88; ++i1)
          {
            if (*(void *)v153 != v89) {
              objc_enumerationMutation(v87);
            }
            [*(id *)(*((void *)&v152 + 1) + 8 * i1) addSelfToSerializationDictionary:v7];
          }
          uint64_t v88 = [(NSArray *)v87 countByEnumeratingWithState:&v152 objects:v208 count:16];
        }
        while (v88);
      }

      uint64_t v91 = malloc_type_malloc(8 * v86, 0x26144497uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v91, v86, self->_kperfTriggers, v7);
      [v4 encodeBytes:v91 length:8 * v86 forKey:@"_kperfTriggers"];
      free(v91);
    }
    models = self->_models;
    if (models)
    {
      unint64_t v93 = [(NSArray *)models count];
      long long v150 = 0u;
      long long v151 = 0u;
      long long v148 = 0u;
      long long v149 = 0u;
      uint64_t v94 = self->_models;
      uint64_t v95 = [(NSArray *)v94 countByEnumeratingWithState:&v148 objects:v207 count:16];
      if (v95)
      {
        uint64_t v96 = *(void *)v149;
        do
        {
          for (uint64_t i2 = 0; i2 != v95; ++i2)
          {
            if (*(void *)v149 != v96) {
              objc_enumerationMutation(v94);
            }
            [*(id *)(*((void *)&v148 + 1) + 8 * i2) addSelfToSerializationDictionary:v7];
          }
          uint64_t v95 = [(NSArray *)v94 countByEnumeratingWithState:&v148 objects:v207 count:16];
        }
        while (v95);
      }

      __int16 v98 = malloc_type_malloc(8 * v93, 0xC21F6E74uLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v98, v93, self->_models, v7);
      [v4 encodeBytes:v98 length:8 * v93 forKey:@"_models"];
      free(v98);
    }
    uint64_t v99 = self->_mountStatusTracker;
    unsigned int v100 = v99;
    if (v99)
    {
      [(SAMountStatusTracker *)v99 addSelfToSerializationDictionary:v7];
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v100, v7), @"_mountStatusTracker");
    }

    uint64_t v101 = self->_wsDataStore;
    uint64_t v102 = v101;
    if (v101)
    {
      [(SAWSUpdateDataStore *)v101 addSelfToSerializationDictionary:v7];
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v102, v7), @"_wsDataStore");
    }

    size_t v103 = self->_timeWhenTransitionedToSamplingAllProcesses;
    int v104 = v103;
    if (v103)
    {
      [(SATimestamp *)v103 addSelfToSerializationDictionary:v7];
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v104, v7), @"_timeWhenTransitionedToSamplingAllProcesses");
    }

    int v105 = self->_timeWhenTransitionedToSamplingAllThreads;
    unsigned int v106 = v105;
    if (v105)
    {
      [(SATimestamp *)v105 addSelfToSerializationDictionary:v7];
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v106, v7), @"_timeWhenTransitionedToSamplingAllThreads");
    }

    uint64_t v107 = self->_cpuSignalHandlerStackLeafKernelFrame;
    size_t v108 = v107;
    if (v107)
    {
      [(SAFrame *)v107 addSelfToSerializationDictionary:v7];
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v108, v7), @"_cpuSignalHandlerStackLeafKernelFrame");
    }

    unsigned int v109 = self->_eventTimeRange;
    unsigned int v110 = v109;
    if (v109)
    {
      [(SATimeRange *)v109 addSelfToSerializationDictionary:v7];
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v110, v7), @"_eventTimeRange");
    }

    uint64_t v111 = self->_timestampOfLastStackshot;
    long long v112 = v111;
    if (v111)
    {
      [(SATimestamp *)v111 addSelfToSerializationDictionary:v7];
      objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v112, v7), @"_timestampOfLastStackshot");
    }

    sampleTimestamps = self->_sampleTimestamps;
    if (sampleTimestamps)
    {
      unint64_t v114 = [(NSMutableArray *)sampleTimestamps count];
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      unsigned int v115 = self->_sampleTimestamps;
      uint64_t v116 = [(NSMutableArray *)v115 countByEnumeratingWithState:&v144 objects:v206 count:16];
      if (v116)
      {
        uint64_t v117 = *(void *)v145;
        do
        {
          for (uint64_t i3 = 0; i3 != v116; ++i3)
          {
            if (*(void *)v145 != v117) {
              objc_enumerationMutation(v115);
            }
            [*(id *)(*((void *)&v144 + 1) + 8 * i3) addSelfToSerializationDictionary:v7];
          }
          uint64_t v116 = [(NSMutableArray *)v115 countByEnumeratingWithState:&v144 objects:v206 count:16];
        }
        while (v116);
      }

      uint64_t v119 = malloc_type_malloc(8 * v114, 0x2ACE00AEuLL);
      SASerializableFillSerializedIndicesWithCollectionOfSerializableInstances(v119, v114, self->_sampleTimestamps, v7);
      [v4 encodeBytes:v119 length:8 * v114 forKey:@"_sampleTimestamps"];
      free(v119);
      sampleTimestamps = self->_sampleTimestamps;
    }
    if (![(NSMutableArray *)sampleTimestamps count])
    {
      [v4 encodeInt64:self->_numSamples forKey:@"_numSamples"];
      uint64_t v120 = self->_startTime;
      uint64_t v121 = v120;
      if (v120)
      {
        [(SATimestamp *)v120 addSelfToSerializationDictionary:v7];
        objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v121, v7), @"_startTime");
      }

      uint64_t v122 = self->_endTime;
      unsigned int v123 = v122;
      if (v122)
      {
        [(SATimestamp *)v122 addSelfToSerializationDictionary:v7];
        objc_msgSend(v4, "encodeInt64:forKey:", SASerializableIndexForPointerFromSerializationDictionary(v123, v7), @"_endTime");
      }
    }
    uint64_t v124 = SASerializableNewDataBufferDictionaryFromSerializationDictionary(v7);

    [v4 encodeObject:v124 forKey:@"SerializedDataDictionary"];
    [v4 encodeDouble:@"_lastWakeTime" forKey:self->_lastWakeTime];
    [v4 encodeDouble:@"_attemptedSamplingInterval" forKey:self->_attemptedSamplingInterval];
    [v4 encodeObject:self->_kextStat forKey:@"_kextStat"];
    [v4 encodeObject:self->_customOutput forKey:@"_customOutput"];
    [v4 encodeObject:self->_kernelVersion forKey:@"_kernelVersion"];
    [v4 encodeObject:self->_osProductName forKey:@"_osProductName"];
    [v4 encodeObject:self->_osProductVersion forKey:@"_osProductVersion"];
    [v4 encodeObject:self->_osProductVersionExtra forKey:@"_osProductVersionExtra"];
    [v4 encodeObject:self->_osBuildVersion forKey:@"_osBuildVersion"];
    [v4 encodeInt32:self->_arch.cpu_type forKey:@"cpu_type"];
    [v4 encodeInt32:self->_arch.cpu_subtype forKey:@"cpu_subtype"];
    [v4 encodeInt32:self->_machTimebase.numer forKey:@"_machTimebase_numer"];
    [v4 encodeInt32:self->_machTimebase.denom forKey:@"_machTimebase_denom"];
    [v4 encodeInt32:self->_workQueueSoftThreadLimit forKey:@"_workQueueSoftThreadLimit"];
    [v4 encodeInt32:self->_workQueueHardThreadLimit forKey:@"_workQueueHardThreadLimit"];
    [v4 encodeObject:self->_hardwareModel forKey:@"_hardwareModel"];
    [v4 encodeInt32:self->_numActiveCPUs forKey:@"_numActiveCPUs"];
    id v126 = objc_getProperty(self, v125, 1032, 1);
    [v4 encodeObject:v126 forKey:@"_clusterFlagsForCPUNumMapping"];

    [v4 encodeInt32:self->_hwPageSize forKey:@"_hwPageSize"];
    [v4 encodeInt32:self->_vmPageSize forKey:@"_vmPageSize"];
    [v4 encodeObject:self->_bootArgs forKey:@"_bootArgs"];
    [v4 encodeObject:self->_systemAdvisoryLevels forKey:@"_systemAdvisoryLevels"];
    [v4 encodeObject:self->_homeVolumeSpace forKey:@"_homeVolumeSpace"];
    [v4 encodeObject:self->_nonDefaultFeatureFlags forKey:@"_nonDefaultFeatureFlags"];
    [v4 encodeInt32:LODWORD(self->_numOSCryptexFileExtents) forKey:@"_numOSCryptexFileExtents"];
    [v4 encodeBool:self->_isRootInstalled forKey:@"_isRootInstalled"];
    [v4 encodeObject:self->_installedRootNames forKey:@"_installedRootNames"];
    if (self->_appleInternalIsKnown)
    {
      [v4 encodeBool:self->_isAppleInternal forKey:@"_isAppleInternal"];
      if (self->_hasInternalCarryDeviceDistinction) {
        [v4 encodeBool:self->_isInternalCarryDevice forKey:@"_isInternalCarryDevice"];
      }
    }
    [v4 encodeObject:self->_automatedDeviceGroup forKey:@"_automatedDeviceGroup"];
    [v4 encodeObject:self->_keyboardLanguages forKey:@"_keyboardLanguages"];
    [v4 encodeObject:self->_preferredLanguages forKey:@"_preferredLanguages"];
    [v4 encodeObject:self->_countryCode forKey:@"_countryCode"];
    if (self->_hasHardwareKeyboardInfo) {
      [v4 encodeBool:self->_hardwareKeyboard forKey:@"_hardwareKeyboard"];
    }
    [v4 encodeInt64:self->_numVnodesAllocated forKey:@"_numVnodesAllocated"];
    [v4 encodeInt64:self->_numVnodesFree forKey:@"_numVnodesFree"];
    [v4 encodeInt64:self->_numVnodesSoftLimit forKey:@"_numVnodesSoftLimit"];
    [v4 encodeInt64:self->_numVnodesHardLimit forKey:@"_numVnodesHardLimit"];
    [v4 encodeObject:self->_activeTrials forKey:@"_activeTrials"];
    [v4 encodeObject:self->_event forKey:@"_event"];
    [v4 encodeObject:self->_eventNote forKey:@"_eventNote"];
    [v4 encodeObject:self->_signature forKey:@"_signature"];
    [v4 encodeObject:self->_actionTaken forKey:@"_actionTaken"];
    [v4 encodeDouble:@"_extraDuration" forKey:self->_extraDuration];
    [v4 encodeObject:self->_durationNote forKey:@"_durationNote"];
    [v4 encodeObject:self->_stepsNote forKey:@"_stepsNote"];
    [v4 encodeInt64:self->_targetThreadId forKey:@"_targetThreadId"];
    [v4 encodeInt64:self->_targetDispatchQueueId forKey:@"_targetDispatchQueueId"];
    [v4 encodeDouble:@"_cpuUsed" forKey:self->_cpuUsed];
    [v4 encodeDouble:@"_cpuDuration" forKey:self->_cpuDuration];
    [v4 encodeDouble:@"_cpuLimit" forKey:self->_cpuLimit];
    [v4 encodeDouble:@"_cpuLimitDuration" forKey:self->_cpuLimitDuration];
    [v4 encodeInt64:self->_numWakeups forKey:@"_numWakeups"];
    [v4 encodeDouble:@"_wakeupsDuration" forKey:self->_wakeupsDuration];
    [v4 encodeInt64:self->_numWakeupsLimit forKey:@"_numWakeupsLimit"];
    [v4 encodeDouble:@"_wakeupsLimitDuration" forKey:self->_wakeupsLimitDuration];
    [v4 encodeDouble:@"_reportTimeThreshold" forKey:self->_reportTimeThreshold];
    wrWorkflowName = self->_wrWorkflowName;
    if (wrWorkflowName)
    {
      [v4 encodeObject:wrWorkflowName forKey:@"_wrWorkflowName"];
      [v4 encodeObject:self->_wrError forKey:@"_wrError"];
      [v4 encodeObject:self->_wrDiagnosticName forKey:@"_wrDiagnosticName"];
      [v4 encodeDouble:@"_wrWorkflowTimeoutDuration" forKey:self->_wrWorkflowTimeoutDuration];
      [v4 encodeDouble:@"_wrWorkflowDurationThreshold" forKey:self->_wrWorkflowDurationThreshold];
      [v4 encodeDouble:@"_wrWorkflowDuration" forKey:self->_wrWorkflowDuration];
      [v4 encodeDouble:@"_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold" forKey:self->_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold];
      [v4 encodeDouble:@"_wrWorkflowDurationOmittingNetworkBoundIntervals" forKey:self->_wrWorkflowDurationOmittingNetworkBoundIntervals];
      [v4 encodeObject:self->_wrSignpostName forKey:@"_wrSignpostName"];
      [v4 encodeObject:self->_wrSignpostSubsystem forKey:@"_wrSignpostSubsystem"];
      [v4 encodeObject:self->_wrSignpostCategory forKey:@"_wrSignpostCategory"];
      [v4 encodeObject:self->_wrTriggeringSignpostName forKey:@"_wrTriggeringSignpostName"];
      [v4 encodeObject:self->_wrTriggeringSignpostSubsystem forKey:@"_wrTriggeringSignpostSubsystem"];
      [v4 encodeObject:self->_wrTriggeringSignpostCategory forKey:@"_wrTriggeringSignpostCategory"];
      [v4 encodeInt64:self->_wrSignpostCountThreshold forKey:@"_wrSignpostCountThreshold"];
      [v4 encodeInt64:self->_wrSignpostCount forKey:@"_wrSignpostCount"];
      [v4 encodeDouble:@"_wrSignpostDurationUnionThreshold" forKey:self->_wrSignpostDurationUnionThreshold];
      [v4 encodeDouble:@"_wrSignpostDurationUnion" forKey:self->_wrSignpostDurationUnion];
      [v4 encodeDouble:@"_wrSignpostDurationSumThreshold" forKey:self->_wrSignpostDurationSumThreshold];
      [v4 encodeDouble:@"_wrSignpostDurationSum" forKey:self->_wrSignpostDurationSum];
      [v4 encodeDouble:@"_wrSignpostDurationSingleThreshold" forKey:self->_wrSignpostDurationSingleThreshold];
      [v4 encodeDouble:@"_wrSignpostDurationSingle" forKey:self->_wrSignpostDurationSingle];
    }
    [v4 encodeInt32:self->_targetProcessId forKey:@"_targetProcessId"];
    [v4 encodeInt64:self->_targetHIDEventMachAbs forKey:@"_targetHIDEventMachAbs"];
    [v4 encodeInt64:self->_targetHIDEventEndMachAbs forKey:@"_targetHIDEventEndMachAbs"];
    [v4 encodeInt64:self->_dataSource forKey:@"_dataSource"];
    [v4 encodeInt64:self->_dataStyle forKey:@"_dataStyle"];
    [v4 encodeObject:self->_reason forKey:@"_reason"];
    [v4 encodeBool:self->_hidEventsHaveHighFidelityTimelines forKey:@"_hidEventsHaveHighFidelityTimelines"];
    previousSAVersions = self->_previousSAVersions;
    if (previousSAVersions)
    {
      uint64_t v129 = [(NSArray *)previousSAVersions mutableCopy];
    }
    else
    {
      uint64_t v129 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:1];
    }
    unsigned int v132 = (void *)v129;
    int v133 = [NSNumber numberWithDouble:382.0];
    [v132 addObject:v133];

    [v4 encodeObject:v132 forKey:@"_previousSAVersions"];
    [v4 encodeInt64:self->_gpuRestartCount forKey:@"_gpuRestartCount"];
    [v4 encodeInt64:self->_gpuRestartLastMachAbs forKey:@"_gpuRestartLastMachAbs"];
    [v4 encodeBool:self->_hasEnterprisePersona forKey:@"_hasEnterprisePersona"];
    uint64_t v134 = [(SATask *)self->_targetProcess bundleBuildVersion];
    [v4 encodeObject:v134 forKey:@"_targetProcessBundleVersion"];

    int v135 = [(SATask *)self->_targetProcess bundleShortVersion];
    [v4 encodeObject:v135 forKey:@"_targetProcessBundleShortVersion"];

    unsigned int v136 = [(SATask *)self->_targetProcess bundleBuildVersion];
    [v4 encodeObject:v136 forKey:@"_targetProcessBundleBuildVersion"];

    double v137 = [(SATask *)self->_targetProcess bundleProjectName];
    [v4 encodeObject:v137 forKey:@"_targetProcessBundleProjectName"];

    uint64_t v138 = [(SATask *)self->_targetProcess bundleSourceVersion];
    [v4 encodeObject:v138 forKey:@"_targetProcessBundleSourceVersion"];

    int v139 = [(SATask *)self->_targetProcess bundleProductBuildVersion];
    [v4 encodeObject:v139 forKey:@"_targetProcessBundleProductBuildVersion"];

    int v140 = [(SATask *)self->_targetProcess bundleIdentifier];
    [v4 encodeObject:v140 forKey:@"_targetProcessBundleId"];

    uint64_t v141 = objc_msgSend(NSString, "stringWithFormat:", @"%llu", -[SATask adamID](self->_targetProcess, "adamID"));
    [v4 encodeObject:v141 forKey:@"_targetProcessCommerceAppID"];

    BOOL v142 = [(SATask *)self->_targetProcess installerVersionID];
    [v4 encodeObject:v142 forKey:@"_targetProcessCommerceExternalID"];

    char v143 = [(SATask *)self->_targetProcess vendorID];
    [v4 encodeObject:v143 forKey:@"_targetProcessVendorID"];

    _Block_object_dispose(buf, 8);
  }
  else
  {
    int v130 = *__error();
    uint64_t v131 = _sa_logt();
    if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v131, OS_LOG_TYPE_ERROR, "Invalid encoder", buf, 2u);
    }

    *__error() = v130;
  }
}

uint64_t __56__SASampleStore_SASampleStoreNSCoding__encodeWithCoder___block_invoke(uint64_t result)
{
  return result;
}

void __56__SASampleStore_SASampleStoreNSCoding__encodeWithCoder___block_invoke_2(uint64_t *a1, void *a2)
{
  uint64_t v3 = a1[4];
  id v4 = a2;
  [v4 addSelfToSerializationDictionary:v3];
  uint64_t v5 = SASerializableIndexForPointerFromSerializationDictionary(v4, (void *)a1[4]);

  *(void *)(a1[6] + 8 * (*(void *)(*(void *)(a1[5] + 8) + 24))++) = v5;
}

- (SASampleStore)initWithCoder:(id)a3
{
  uint64_t v623 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  long long v558 = (void *)MEMORY[0x1C18A6A20]();
  id v563 = v4;
  if (!v4)
  {
    long long v565 = self;
    int v106 = *__error();
    uint64_t v107 = _sa_logt();
    if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v107, OS_LOG_TYPE_ERROR, "Invalid decoder", buf, 2u);
    }

    size_t v108 = 0;
    *__error() = v106;
    goto LABEL_193;
  }
  v580.receiver = self;
  v580.super_class = (Class)SASampleStore;
  long long v564 = [(SASampleStore *)&v580 init];

  if (!v564)
  {
    gSASerializationEncodedVersionBeingDecoded();
    IsEmbedded = (unsigned char *)gSASerializationEncodedDataIsEmbedded();
    uint64_t v111 = v558;
LABEL_300:
    *unsigned int v110 = 0;
    unsigned char *IsEmbedded = 0;
    size_t v108 = v564;
    long long v565 = v108;
    goto LABEL_301;
  }
  v564->_unint64_t dataGatheringOptions = 0;
  uint64_t v5 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_osProductVersion"];
  osProductVersiouint64_t n = v564->_osProductVersion;
  v564->_osProductVersiouint64_t n = (NSString *)v5;

  uint64_t v7 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_osProductVersionExtra"];
  osProductVersionExtra = v564->_osProductVersionExtra;
  v564->_osProductVersionExtra = (NSString *)v7;

  uint64_t v9 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_osBuildVersion"];
  osBuildVersiouint64_t n = v564->_osBuildVersion;
  v564->_osBuildVersiouint64_t n = (NSString *)v9;

  if ([v4 containsValueForKey:@"_SASampleStore_Serialized_Version"])
  {
    uint64_t v556 = [v4 decodeIntegerForKey:@"_SASampleStore_Serialized_Version"];
    v554 = (uint64_t *)gSASerializationEncodedVersionBeingDecoded();
    uint64_t *v554 = v556;
    v564->_dataSource = [v4 decodeInt64ForKey:@"_dataSource"];
    v564->_dataStyle = [v4 decodeInt64ForKey:@"_dataStyle"];
    id v11 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v12 = objc_opt_class();
    id v13 = objc_msgSend(v11, "setWithObjects:", v12, objc_opt_class(), 0);
    uint64_t v14 = [v4 decodeArrayOfObjectsOfClasses:v13 forKey:@"_previousSAVersions"];
    previousSAVersions = v564->_previousSAVersions;
    v564->_previousSAVersions = (NSArray *)v14;

    if (!v564->_previousSAVersions)
    {
      unint64_t v16 = (void *)MEMORY[0x1E4F1C978];
      id v17 = [MEMORY[0x1E4F1CA98] null];
      uint64_t v18 = [v16 arrayWithObject:v17];
      uint64_t v19 = v564->_previousSAVersions;
      v564->_previousSAVersions = (NSArray *)v18;
    }
    uint64_t v20 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_osProductName"];
    osProductName = v564->_osProductName;
    v564->_osProductName = (NSString *)v20;

    SAIsEmbeddedPlatform(v564->_osProductName);
    uint64_t v550 = (unsigned char *)gSASerializationEncodedDataIsEmbedded();
    *uint64_t v550 = v22;
    uint64_t v23 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_reason"];
    reasouint64_t n = v564->_reason;
    v564->_reasouint64_t n = (NSString *)v23;

    [v4 decodeDoubleForKey:@"_lastWakeTime"];
    v564->_lastint WakeTime = v25;
    [v4 decodeDoubleForKey:@"_attemptedSamplingInterval"];
    v564->_attemptedSamplingInterval = v26;
    uint64_t v27 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_kextStat"];
    kextStat = v564->_kextStat;
    v564->_kextStat = (NSString *)v27;

    uint64_t v29 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_customOutput"];
    customOutput = v564->_customOutput;
    v564->_customOutput = (NSString *)v29;

    uint64_t v31 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_kernelVersion"];
    kernelVersiouint64_t n = v564->_kernelVersion;
    v564->_kernelVersiouint64_t n = (NSString *)v31;

    v564->_arch.cpu_type = [v4 decodeInt32ForKey:@"cpu_type"];
    v564->_arch.cpu_subtype = [v4 decodeInt32ForKey:@"cpu_subtype"];
    v564->_machTimebase.numer = [v4 decodeInt32ForKey:@"_machTimebase_numer"];
    v564->_machTimebase.denouint64_t m = [v4 decodeInt32ForKey:@"_machTimebase_denom"];
    v564->_workQueueSoftThreadLimit = [v4 decodeInt32ForKey:@"_workQueueSoftThreadLimit"];
    v564->_workQueueHardThreadLimit = [v4 decodeInt32ForKey:@"_workQueueHardThreadLimit"];
    uint64_t v33 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_hardwareModel"];
    hardwareModel = v564->_hardwareModel;
    v564->_hardwareModel = (NSString *)v33;

    v564->_numActiveCPUs = [v4 decodeInt32ForKey:@"_numActiveCPUs"];
    id v35 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v36 = objc_opt_class();
    unint64_t v37 = objc_msgSend(v35, "setWithObjects:", v36, objc_opt_class(), 0);
    uint64_t v38 = [v4 decodeObjectOfClasses:v37 forKey:@"_clusterFlagsForCPUNumMapping"];
    clusterFlagsForCPUNumMapping = v564->_clusterFlagsForCPUNumMapping;
    v564->_clusterFlagsForCPUNumMapping = (NSDictionary *)v38;

    v564->_hwPageSize = [v4 decodeInt32ForKey:@"_hwPageSize"];
    v564->_vmPageSize = [v4 decodeInt32ForKey:@"_vmPageSize"];
    uint64_t v40 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_bootArgs"];
    bootArgs = v564->_bootArgs;
    v564->_bootArgs = (NSString *)v40;

    long long v42 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v43 = objc_opt_class();
    uint64_t v44 = objc_opt_class();
    long long v45 = objc_msgSend(v42, "setWithObjects:", v43, v44, objc_opt_class(), 0);
    uint64_t v46 = [v4 decodeObjectOfClasses:v45 forKey:@"_systemAdvisoryLevels"];
    systemAdvisoryLevels = v564->_systemAdvisoryLevels;
    v564->_systemAdvisoryLevels = (NSDictionary *)v46;

    long long v48 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v49 = objc_opt_class();
    uint64_t v50 = objc_opt_class();
    unint64_t v51 = objc_msgSend(v48, "setWithObjects:", v49, v50, objc_opt_class(), 0);
    uint64_t v52 = [v4 decodeObjectOfClasses:v51 forKey:@"_homeVolumeSpace"];
    homeVolumeSpace = v564->_homeVolumeSpace;
    v564->_homeVolumeSpace = (NSDictionary *)v52;

    uint64_t v54 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v55 = objc_opt_class();
    uint64_t v56 = objc_opt_class();
    double v57 = objc_msgSend(v54, "setWithObjects:", v55, v56, objc_opt_class(), 0);
    uint64_t v58 = [v4 decodeObjectOfClasses:v57 forKey:@"_nonDefaultFeatureFlags"];
    nonDefaultFeatureFlags = v564->_nonDefaultFeatureFlags;
    v564->_nonDefaultFeatureFlags = (NSDictionary *)v58;

    v564->_numOSCryptexFileExtents = (int)[v4 decodeInt32ForKey:@"_numOSCryptexFileExtents"];
    uint64_t v60 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v61 = objc_opt_class();
    id v62 = objc_msgSend(v60, "setWithObjects:", v61, objc_opt_class(), 0);
    uint64_t v63 = [v4 decodeObjectOfClasses:v62 forKey:@"_keyboardLanguages"];
    keyboardLanguages = v564->_keyboardLanguages;
    v564->_keyboardLanguages = (NSArray *)v63;

    unint64_t v65 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v66 = objc_opt_class();
    uint64_t v67 = objc_msgSend(v65, "setWithObjects:", v66, objc_opt_class(), 0);
    uint64_t v68 = [v4 decodeObjectOfClasses:v67 forKey:@"_preferredLanguages"];
    preferredLanguages = v564->_preferredLanguages;
    v564->_preferredLanguages = (NSArray *)v68;

    uint64_t v70 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_countryCode"];
    countryCode = v564->_countryCode;
    v564->_countryCode = (NSString *)v70;

    v564->_isRootInstalled = [v4 decodeBoolForKey:@"_isRootInstalled"];
    unint64_t v72 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v73 = objc_opt_class();
    uint64_t v74 = objc_msgSend(v72, "setWithObjects:", v73, objc_opt_class(), 0);
    uint64_t v75 = [v4 decodeObjectOfClasses:v74 forKey:@"_installedRootNames"];
    installedRootNames = v564->_installedRootNames;
    v564->_installedRootNames = (NSArray *)v75;

    if ([(NSArray *)v564->_installedRootNames count]) {
      v564->_isRootInstalled = 1;
    }
    id v77 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v78 = objc_opt_class();
    uint64_t v79 = objc_opt_class();
    uint64_t v80 = objc_opt_class();
    uint64_t v81 = objc_msgSend(v77, "setWithObjects:", v78, v79, v80, objc_opt_class(), 0);
    uint64_t v82 = [v4 decodeObjectOfClasses:v81 forKey:@"_activeTrials"];
    activeTrials = v564->_activeTrials;
    v564->_activeTrials = (NSDictionary *)v82;

    if ([v4 containsValueForKey:@"_isAppleInternal"])
    {
      v564->_appleInternalIsKnowuint64_t n = 1;
      v564->_isAppleInternal = [v4 decodeBoolForKey:@"_isAppleInternal"];
      if ([v4 containsValueForKey:@"_isInternalCarryDevice"])
      {
        v564->_hasInternalCarryDeviceDistinctiouint64_t n = 1;
        v564->_isInternalCarryDevice = [v4 decodeBoolForKey:@"_isInternalCarryDevice"];
      }
    }
    uint64_t v84 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_automatedDeviceGroup"];
    automatedDeviceCFStringRef Group = v564->_automatedDeviceGroup;
    v564->_automatedDeviceCFStringRef Group = (NSString *)v84;

    if ([v4 containsValueForKey:@"_hardwareKeyboard"])
    {
      v564->_hardwareKeyboard = [v4 decodeBoolForKey:@"_hardwareKeyboard"];
      v564->_hasHardwareKeyboardInfo = 1;
    }
    v564->_numVnodesAllocated = [v4 decodeInt64ForKey:@"_numVnodesAllocated"];
    v564->_numVnodesFree = [v4 decodeInt64ForKey:@"_numVnodesFree"];
    v564->_numVnodesSoftLimit = [v4 decodeInt64ForKey:@"_numVnodesSoftLimit"];
    v564->_numVnodesHardLimit = [v4 decodeInt64ForKey:@"_numVnodesHardLimit"];
    [v4 decodeDoubleForKey:@"_cpuUsed"];
    v564->_cpuUsed = v86;
    [v4 decodeDoubleForKey:@"_cpuDuration"];
    v564->_cpuDuratiouint64_t n = v87;
    [v4 decodeDoubleForKey:@"_cpuLimit"];
    v564->_cpuLimit = v88;
    [v4 decodeDoubleForKey:@"_cpuLimitDuration"];
    v564->_cpuLimitDuratiouint64_t n = v89;
    v564->_numWakeups = [v4 decodeInt64ForKey:@"_numWakeups"];
    [v4 decodeDoubleForKey:@"_wakeupsDuration"];
    v564->_wakeupsDuratiouint64_t n = v90;
    v564->_numWakeupsLimit = [v4 decodeInt64ForKey:@"_numWakeupsLimit"];
    [v4 decodeDoubleForKey:@"_wakeupsLimitDuration"];
    v564->_wakeupsLimitDuratiouint64_t n = v91;
    [v4 decodeDoubleForKey:@"_reportTimeThreshold"];
    v564->_reportTimeThreshold = v92;
    uint64_t v93 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_event"];
    event = v564->_event;
    v564->_event = (NSString *)v93;

    uint64_t v95 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_eventNote"];
    eventNote = v564->_eventNote;
    v564->_eventNote = (NSString *)v95;

    uint64_t v97 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_signature"];
    signature = v564->_signature;
    v564->_signature = (NSString *)v97;

    uint64_t v99 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_actionTaken"];
    actionTakeuint64_t n = v564->_actionTaken;
    v564->_actionTakeuint64_t n = (NSString *)v99;

    [v4 decodeDoubleForKey:@"_extraDuration"];
    v564->_extraDuratiouint64_t n = v101;
    uint64_t v102 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_durationNote"];
    durationNote = v564->_durationNote;
    v564->_durationNote = (NSString *)v102;

    uint64_t v104 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_stepsNote"];
    stepsNote = v564->_stepsNote;
    v564->_stepsNote = (NSString *)v104;

    v564->_int targetProcessId = [v4 decodeInt32ForKey:@"_targetProcessId"];
    v564->_targetHIDEventMachAbs = [v4 decodeInt64ForKey:@"_targetHIDEventMachAbs"];
    v564->_targetHIDEventEndMachAbs = [v4 decodeInt64ForKey:@"_targetHIDEventEndMachAbs"];
    v564->_targetThreadId = [v4 decodeInt64ForKey:@"_targetThreadId"];
    v564->_targetDispatchQueueId = [v4 decodeInt64ForKey:@"_targetDispatchQueueId"];
    if ([v4 containsValueForKey:@"_hidEventsHaveHighFidelityTimelines"])
    {
      v564->_hidEventsHaveHighFidelityTimelines = [v4 decodeBoolForKey:@"_hidEventsHaveHighFidelityTimelines"];
    }
    else
    {
      unsigned int v115 = [(SASampleStore *)v564 osProductName];
      int v116 = SAIsEmbeddedPlatform(v115);

      if (v116) {
        v564->_hidEventsHaveHighFidelityTimelines = 0;
      }
      else {
        v564->_hidEventsHaveHighFidelityTimelines = 1;
      }
    }
    if ([v4 containsValueForKey:@"_wrWorkflowName"])
    {
      uint64_t v228 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_wrWorkflowName"];
      wrWorkflowName = v564->_wrWorkflowName;
      v564->_wrWorkflowName = (NSString *)v228;

      uint64_t v230 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_wrError"];
      wrError = v564->_wrError;
      v564->_wrError = (NSError *)v230;

      uint64_t v232 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_wrDiagnosticName"];
      wrDiagnosticName = v564->_wrDiagnosticName;
      v564->_wrDiagnosticName = (NSString *)v232;

      [v4 decodeDoubleForKey:@"_wrWorkflowTimeoutDuration"];
      v564->_wrWorkflowTimeoutDuratiouint64_t n = v234;
      [v4 decodeDoubleForKey:@"_wrWorkflowDurationThreshold"];
      v564->_wrWorkflowDurationThreshold = v235;
      [v4 decodeDoubleForKey:@"_wrWorkflowDuration"];
      v564->_wrWorkflowDuratiouint64_t n = v236;
      [v4 decodeDoubleForKey:@"_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold"];
      v564->_wrWorkflowDurationOmittingNetworkBoundIntervalsThreshold = v237;
      [v4 decodeDoubleForKey:@"_wrWorkflowDurationOmittingNetworkBoundIntervals"];
      v564->_wrWorkflowDurationOmittingNetworkBoundIntervals = v238;
      uint64_t v239 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_wrSignpostName"];
      wrSignpostName = v564->_wrSignpostName;
      v564->_wrSignpostName = (NSString *)v239;

      uint64_t v241 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_wrSignpostSubsystem"];
      wrSignpostSubsysteuint64_t m = v564->_wrSignpostSubsystem;
      v564->_wrSignpostSubsysteuint64_t m = (NSString *)v241;

      uint64_t v243 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_wrSignpostCategory"];
      wrSignpostCategory = v564->_wrSignpostCategory;
      v564->_wrSignpostCategory = (NSString *)v243;

      uint64_t v245 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_wrTriggeringSignpostName"];
      wrTriggeringSignpostName = v564->_wrTriggeringSignpostName;
      v564->_wrTriggeringSignpostName = (NSString *)v245;

      uint64_t v247 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_wrTriggeringSignpostSubsystem"];
      wrTriggeringSignpostSubsysteuint64_t m = v564->_wrTriggeringSignpostSubsystem;
      v564->_wrTriggeringSignpostSubsysteuint64_t m = (NSString *)v247;

      uint64_t v249 = [v4 decodeObjectOfClass:objc_opt_class() forKey:@"_wrTriggeringSignpostCategory"];
      wrTriggeringSignpostCategory = v564->_wrTriggeringSignpostCategory;
      v564->_wrTriggeringSignpostCategory = (NSString *)v249;

      v564->_wrSignpostCountThreshold = [v4 decodeInt64ForKey:@"_wrSignpostCountThreshold"];
      v564->_wrSignpostCount = [v4 decodeInt64ForKey:@"_wrSignpostCount"];
      [v4 decodeDoubleForKey:@"_wrSignpostDurationUnionThreshold"];
      v564->_wrSignpostDurationUnionThreshold = v251;
      [v4 decodeDoubleForKey:@"_wrSignpostDurationUnion"];
      v564->_wrSignpostDurationUniouint64_t n = v252;
      [v4 decodeDoubleForKey:@"_wrSignpostDurationSumThreshold"];
      v564->_wrSignpostDurationSumThreshold = v253;
      [v4 decodeDoubleForKey:@"_wrSignpostDurationSum"];
      v564->_wrSignpostDurationSuuint64_t m = v254;
      [v4 decodeDoubleForKey:@"_wrSignpostDurationSingleThreshold"];
      v564->_wrSignpostDurationSingleThreshold = v255;
      [v4 decodeDoubleForKey:@"_wrSignpostDurationSingle"];
      v564->_wrSignpostDurationSingle = v256;
    }
    v564->_gpuRestartCount = [v4 decodeInt64ForKey:@"_gpuRestartCount"];
    v564->_gpuRestartLastMachAbs = [v4 decodeInt64ForKey:@"_gpuRestartLastMachAbs"];
    v564->_hasEnterprisePersona = [v4 decodeBoolForKey:@"_hasEnterprisePersona"];
    uint64_t v257 = (void *)MEMORY[0x1E4F1CAD0];
    uint64_t v258 = objc_opt_class();
    uint64_t v259 = objc_opt_class();
    id v260 = objc_msgSend(v257, "setWithObjects:", v258, v259, objc_opt_class(), 0);
    v562 = [v4 decodeObjectOfClasses:v260 forKey:@"SerializedDataDictionary"];

    if (!v562)
    {
      id v542 = +[SAException exceptionWithName:@"Decoding failure" reason:@"nil dataDictionary" userInfo:0];
      objc_exception_throw(v542);
    }
    id v560 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    *(void *)long long buf = 0;
    id v261 = v4;
    uint64_t v262 = [v261 decodeBytesForKey:@"_tasks" returnedLength:buf];
    if (v262)
    {
      unint64_t v263 = *(void *)buf;
      uint64_t v264 = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:*(void *)buf >> 3];
      tasksByPid = v564->_tasksByPid;
      v564->_tasksByPid = (NSMutableDictionary *)v264;

      uint64_t v266 = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:v263 >> 3];
      tasksByUniquePid = v564->_tasksByUniquePid;
      v564->_tasksByUniquePid = (NSMutableDictionary *)v266;

      id v268 = objc_opt_class();
      SASerializableNewMutableArrayFromIndexList(v262, v263 >> 3, v560, v562, v268);
      long long v578 = 0u;
      long long v579 = 0u;
      long long v576 = 0u;
      long long v577 = 0u;
      unint64_t v269 = (NSMutableDictionary *)(id)objc_claimAutoreleasedReturnValue();
      uint64_t v270 = [(NSMutableDictionary *)v269 countByEnumeratingWithState:&v576 objects:v612 count:16];
      if (v270)
      {
        uint64_t v271 = *(void *)v577;
        do
        {
          for (uint64_t i = 0; i != v270; ++i)
          {
            if (*(void *)v577 != v271) {
              objc_enumerationMutation(v269);
            }
            int v273 = *(void **)(*((void *)&v576 + 1) + 8 * i);
            -[SASampleStore addTask:]((uint64_t)v564, v273);
            -[SATask fixupFrameInstructionsWithDataGatheringOptions:mightBeAlive:foundNewBinaryInfo:uuidsWithNewInstructions:additionalCSSymbolicatorFlags:]((id *)v273, v564->_dataGatheringOptions, 0, 0, 0, v564->_additionalCSSymbolicatorFlags);
          }
          uint64_t v270 = [(NSMutableDictionary *)v269 countByEnumeratingWithState:&v576 objects:v612 count:16];
        }
        while (v270);
      }
    }
    else
    {
      uint64_t v274 = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:0];
      uint64_t v275 = v564->_tasksByPid;
      v564->_tasksByPid = (NSMutableDictionary *)v274;

      uint64_t v276 = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:0];
      unint64_t v269 = v564->_tasksByUniquePid;
      v564->_tasksByUniquePid = (NSMutableDictionary *)v276;
    }

    -[SASampleStore findTargetProcessInTimeRange:]((uint64_t)v564, 0);
    int v277 = -[SASampleStore lastTaskWithPid:](v564, 0);
    uint64_t v279 = v277;
    if (v277) {
      id Property = objc_getProperty(v277, v278, 280, 1);
    }
    else {
      id Property = 0;
    }
    id v281 = Property;
    BOOL v282 = [v281 count] == 0;

    if (v282)
    {
      *(void *)long long buf = 0;
      uint64_t v283 = [v261 decodeBytesForKey:@"_rootKernelFrames" returnedLength:buf];
      if (v283)
      {
        unint64_t v284 = *(void *)buf;
        uint64_t v285 = objc_opt_class();
        uint64_t v287 = SASerializableNewMutableSetFromIndexList(v283, v284 >> 3, v560, v562, v285);
        if (v279
          || ([(NSMutableDictionary *)v564->_tasksByUniquePid count] ? (uint64_t v288 = 0) : (uint64_t v288 = -1),
              +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, 0, v288, 0, 0),
              uint64_t v279 = objc_claimAutoreleasedReturnValue(),
              -[SASampleStore addTask:]((uint64_t)v564, v279),
              v279))
        {
          objc_setProperty_atomic(v279, v286, v287, 280);
        }
        -[SATask fixupFrameInstructionsWithDataGatheringOptions:mightBeAlive:foundNewBinaryInfo:uuidsWithNewInstructions:additionalCSSymbolicatorFlags:]((id *)v279, v564->_dataGatheringOptions, 0, 0, 0, v564->_additionalCSSymbolicatorFlags);
      }
    }

    if (v556 <= 19 && v564->_targetProcess)
    {
      uint64_t v289 = [v261 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleVersion"];
      id v290 = [(SATask *)v564->_targetProcess mainBinary];
      uint64_t v292 = v290;
      if (v290) {
        objc_setProperty_atomic_copy(v290, v291, v289, 96);
      }

      id v293 = [v261 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleShortVersion"];
      BOOL v294 = [(SATask *)v564->_targetProcess mainBinary];
      uint64_t v296 = v294;
      if (v294) {
        objc_setProperty_atomic_copy(v294, v295, v293, 104);
      }

      uint64_t v298 = [v261 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleBuildVersion"];
      targetProcess = v564->_targetProcess;
      if (targetProcess) {
        objc_setProperty_atomic_copy(targetProcess, v297, v298, 112);
      }

      uint64_t v301 = [v261 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleProjectName"];
      v302 = v564->_targetProcess;
      if (v302) {
        objc_setProperty_atomic_copy(v302, v300, v301, 120);
      }

      uint64_t v304 = [v261 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleSourceVersion"];
      uint64_t v305 = v564->_targetProcess;
      if (v305) {
        objc_setProperty_atomic_copy(v305, v303, v304, 128);
      }

      unsigned int v307 = [v261 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleProductBuildVersion"];
      uint64_t v308 = v564->_targetProcess;
      if (v308) {
        objc_setProperty_atomic_copy(v308, v306, v307, 136);
      }

      uint64_t v309 = [v261 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleId"];
      uint64_t v310 = [(SATask *)v564->_targetProcess mainBinary];
      uint64_t v312 = v310;
      if (v310) {
        objc_setProperty_atomic_copy(v310, v311, v309, 88);
      }

      uint64_t v313 = [v261 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessCommerceAppID"];
      if (v313)
      {
        id v314 = objc_alloc_init(MEMORY[0x1E4F28EE0]);
        id v315 = [v314 numberFromString:v313];
        uint64_t v316 = v315;
        if (v315)
        {
          uint64_t v317 = [v315 unsignedLongLongValue];
          uint64_t v318 = v564->_targetProcess;
          if (v318) {
            v318->_adamID = v317;
          }
        }
        else
        {
          int v392 = *__error();
          uint64_t v393 = _sa_logt();
          if (os_log_type_enabled(v393, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v313;
            _os_log_fault_impl(&dword_1BF22B000, v393, OS_LOG_TYPE_FAULT, "Unable to parse commerceAppID %@", buf, 0xCu);
          }

          *__error() = v392;
        }
      }
      int v395 = [v261 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessCommerceExternalID"];
      v396 = v564->_targetProcess;
      if (v396) {
        objc_setProperty_atomic_copy(v396, v394, v395, 168);
      }

      uint64_t v398 = [v261 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessVendorID"];
      uint64_t v399 = v564->_targetProcess;
      if (v399) {
        objc_setProperty_atomic_copy(v399, v397, v398, 176);
      }
    }
    *(void *)long long buf = 0;
    id v400 = v261;
    uint64_t v401 = [v400 decodeBytesForKey:@"_fanSpeeds" returnedLength:buf];
    if (v401)
    {
      unint64_t v402 = *(void *)buf;
      int v403 = objc_opt_class();
      uint64_t v404 = SASerializableNewMutableArrayFromIndexList(v401, v402 >> 3, v560, v562, v403);
      fanSpeeds = v564->_fanSpeeds;
      v564->_fanSpeeds = (NSMutableArray *)v404;
    }
    else
    {
      fanSpeeds = v564->_fanSpeeds;
      v564->_fanSpeeds = 0;
    }

    *(void *)long long buf = 0;
    id v406 = v400;
    uint64_t v407 = [v406 decodeBytesForKey:@"_powerModeTransitions" returnedLength:buf];
    if (v407)
    {
      unint64_t v408 = *(void *)buf;
      uint64_t v409 = objc_opt_class();
      uint64_t v410 = SASerializableNewMutableArrayFromIndexList(v407, v408 >> 3, v560, v562, v409);
      powerModeTransitions = v564->_powerModeTransitions;
      v564->_powerModeTransitions = (NSMutableArray *)v410;
    }
    else
    {
      powerModeTransitions = v564->_powerModeTransitions;
      v564->_powerModeTransitions = 0;
    }

    if (*v554 <= 33 && *v550)
    {
      *(void *)long long buf = 0;
      uint64_t v412 = [v406 decodeBytesForKey:@"_hidEvents" returnedLength:buf];
      if (!v412)
      {
        hidEvents = v564->_hidEvents;
        v564->_hidEvents = 0;
        goto LABEL_216;
      }
    }
    else
    {
      *(void *)long long buf = 0;
      uint64_t v412 = [v406 decodeBytesForKey:@"_hidEvents" returnedLength:buf];
      if (!v412)
      {
        hidEvents = v564->_hidEvents;
        v564->_hidEvents = 0;
        goto LABEL_216;
      }
    }
    unint64_t v413 = *(void *)buf;
    uint64_t v414 = objc_opt_class();
    uint64_t v415 = SASerializableNewMutableArrayFromIndexList(v412, v413 >> 3, v560, v562, v414);
    hidEvents = v564->_hidEvents;
    v564->_hidEvents = (NSMutableArray *)v415;
LABEL_216:

    *(void *)long long buf = 0;
    id v417 = v406;
    uint64_t v418 = [v417 decodeBytesForKey:@"_gestures" returnedLength:buf];
    if (v418)
    {
      unint64_t v419 = *(void *)buf;
      v420 = objc_opt_class();
      uint64_t v421 = SASerializableNewMutableArrayFromIndexList(v418, v419 >> 3, v560, v562, v420);
      gestures = v564->_gestures;
      v564->_gestures = (NSMutableArray *)v421;
    }
    else
    {
      gestures = v564->_gestures;
      v564->_gestures = 0;
    }

    if (!v564->_gestures)
    {
      uint64_t v423 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
      uint64_t v424 = v564->_gestures;
      v564->_gestures = v423;
    }
    *(void *)long long buf = 0;
    id v553 = v417;
    uint64_t v425 = [v553 decodeBytesForKey:@"_ioEvents" returnedLength:buf];
    if (v425)
    {
      unint64_t v426 = *(void *)buf;
      uint64_t v427 = objc_opt_class();
      uint64_t v428 = SASerializableNewMutableArrayFromIndexList(v425, v426 >> 3, v560, v562, v427);
      ioEvents = v564->_ioEvents;
      v564->_ioEvents = (NSMutableArray *)v428;
    }
    else
    {
      ioEvents = v564->_ioEvents;
      v564->_ioEvents = 0;
    }

    uint64_t v430 = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x1E4F1CA60]);
    ioEventsByTid = v564->_ioEventsByTid;
    v564->_ioEventsByTid = v430;

    long long v574 = 0u;
    long long v575 = 0u;
    long long v572 = 0u;
    long long v573 = 0u;
    uint64_t v432 = v564->_ioEvents;
    uint64_t v433 = [(NSMutableArray *)v432 countByEnumeratingWithState:&v572 objects:v611 count:16];
    if (v433)
    {
      uint64_t v434 = *(void *)v573;
      do
      {
        for (uint64_t j = 0; j != v433; ++j)
        {
          if (*(void *)v573 != v434) {
            objc_enumerationMutation(v432);
          }
          uint64_t v436 = *(void **)(*((void *)&v572 + 1) + 8 * j);
          uint64_t v437 = v564->_ioEventsByTid;
          uint64_t v438 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v436, "threadID"));
          uint64_t v439 = [(NSMutableDictionary *)v437 objectForKeyedSubscript:v438];

          if (v439)
          {
            [v439 addObject:v436];
          }
          else
          {
            uint64_t v440 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithObjects:", v436, 0);
            uint64_t v441 = v564->_ioEventsByTid;
            char v442 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v436, "threadID"));
            [(NSMutableDictionary *)v441 setObject:v440 forKeyedSubscript:v442];
          }
        }
        uint64_t v433 = [(NSMutableArray *)v432 countByEnumeratingWithState:&v572 objects:v611 count:16];
      }
      while (v433);
    }

    *(void *)long long buf = 0;
    id v443 = v553;
    uint64_t v444 = [v443 decodeBytesForKey:@"_memoryPressureEvents" returnedLength:buf];
    if (v444)
    {
      unint64_t v445 = *(void *)buf;
      uint64_t v446 = objc_opt_class();
      uint64_t v447 = SASerializableNewMutableArrayFromIndexList(v444, v445 >> 3, v560, v562, v446);
      memoryPressureEvents = v564->_memoryPressureEvents;
      v564->_memoryPressureEvents = (NSMutableArray *)v447;
    }
    else
    {
      memoryPressureEvents = v564->_memoryPressureEvents;
      v564->_memoryPressureEvents = 0;
    }

    *(void *)long long buf = 0;
    id v449 = v443;
    uint64_t v450 = [v449 decodeBytesForKey:@"_sharedCaches" returnedLength:buf];
    if (v450)
    {
      unint64_t v451 = *(void *)buf;
      int v452 = objc_opt_class();
      uint64_t v453 = SASerializableNewMutableArrayFromIndexList(v450, v451 >> 3, v560, v562, v452);
      sharedCaches = v564->_sharedCaches;
      v564->_sharedCaches = (NSMutableArray *)v453;
    }
    else
    {
      sharedCaches = v564->_sharedCaches;
      v564->_sharedCaches = 0;
    }

    *(void *)long long buf = 0;
    id v455 = v449;
    uint64_t v456 = [v455 decodeBytesForKey:@"_kernelCaches" returnedLength:buf];
    if (v456)
    {
      unint64_t v457 = *(void *)buf;
      uint64_t v458 = objc_opt_class();
      uint64_t v459 = SASerializableNewMutableArrayFromIndexList(v456, v457 >> 3, v560, v562, v458);
      kernelCaches = v564->_kernelCaches;
      v564->_kernelCaches = (NSMutableArray *)v459;
    }
    else
    {
      kernelCaches = v564->_kernelCaches;
      v564->_kernelCaches = 0;
    }

    *(void *)long long buf = 0;
    id v461 = v455;
    uint64_t v462 = [v461 decodeBytesForKey:@"_exclaves" returnedLength:buf];
    if (v462)
    {
      unint64_t v463 = *(void *)buf;
      v464 = objc_opt_class();
      uint64_t v465 = SASerializableNewMutableArrayFromIndexList(v462, v463 >> 3, v560, v562, v464);
      exclaves = v564->_exclaves;
      v564->_exclaves = (NSMutableArray *)v465;
    }
    else
    {
      exclaves = v564->_exclaves;
      v564->_exclaves = 0;
    }

    v467 = v564->_exclaves;
    if (v467)
    {
      long long v570 = 0u;
      long long v571 = 0u;
      long long v568 = 0u;
      long long v569 = 0u;
      uint64_t v468 = v467;
      uint64_t v469 = [(NSMutableArray *)v468 countByEnumeratingWithState:&v568 objects:v610 count:16];
      if (v469)
      {
        uint64_t v470 = *(void *)v569;
        do
        {
          for (uint64_t k = 0; k != v469; ++k)
          {
            if (*(void *)v569 != v470) {
              objc_enumerationMutation(v468);
            }
            -[SAExclave fixupFrameInstructionsWithNewInstructions:foundNewBinaryInfo:](*(void *)(*((void *)&v568 + 1) + 8 * k), 0, 0);
          }
          uint64_t v469 = [(NSMutableArray *)v468 countByEnumeratingWithState:&v568 objects:v610 count:16];
        }
        while (v469);
      }
    }
    *(void *)long long buf = 0;
    id v472 = v461;
    uint64_t v473 = [v472 decodeBytesForKey:@"_kperfTriggers" returnedLength:buf];
    if (v473)
    {
      unint64_t v474 = *(void *)buf;
      v475 = objc_opt_class();
      uint64_t v476 = SASerializableNewMutableArrayFromIndexList(v473, v474 >> 3, v560, v562, v475);
      kperfTriggers = v564->_kperfTriggers;
      v564->_kperfTriggers = (NSArray *)v476;
    }
    else
    {
      kperfTriggers = v564->_kperfTriggers;
      v564->_kperfTriggers = 0;
    }

    uint64_t v478 = [(NSArray *)v564->_kperfTriggers copy];
    v479 = v564->_kperfTriggers;
    v564->_kperfTriggers = (NSArray *)v478;

    *(void *)long long buf = 0;
    id v480 = v472;
    uint64_t v481 = [v480 decodeBytesForKey:@"_models" returnedLength:buf];
    if (v481)
    {
      unint64_t v482 = *(void *)buf;
      v483 = objc_opt_class();
      uint64_t v484 = SASerializableNewMutableArrayFromIndexList(v481, v482 >> 3, v560, v562, v483);
      models = v564->_models;
      v564->_models = (NSArray *)v484;
    }
    else
    {
      models = v564->_models;
      v564->_models = 0;
    }

    uint64_t v486 = [(NSArray *)v564->_models copy];
    id v487 = v564->_models;
    v564->_models = (NSArray *)v486;

    if (![v480 containsValueForKey:@"_mountStatusTracker"]
      || (unint64_t v488 = [v480 decodeInt64ForKey:@"_mountStatusTracker"], v488 == -1))
    {
      v490 = objc_alloc_init(SAMountStatusTracker);
    }
    else
    {
      id v489 = objc_opt_class();
      SASerializableNonnullInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v488, v560, v562, v489);
      v490 = (SAMountStatusTracker *)objc_claimAutoreleasedReturnValue();
    }
    mountStatusTracker = v564->_mountStatusTracker;
    v564->_mountStatusTracker = v490;

    if ([v480 containsValueForKey:@"_wsDataStore"])
    {
      unint64_t v492 = [v480 decodeInt64ForKey:@"_wsDataStore"];
      v493 = objc_opt_class();
      uint64_t v494 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v492, v560, v562, v493, 0);
      wsDataStore = v564->_wsDataStore;
      v564->_wsDataStore = (SAWSUpdateDataStore *)v494;
    }
    else
    {
      wsDataStore = v564->_wsDataStore;
      v564->_wsDataStore = 0;
    }

    if ([v480 containsValueForKey:@"_timeWhenTransitionedToSamplingAllProcesses"])
    {
      unint64_t v496 = [v480 decodeInt64ForKey:@"_timeWhenTransitionedToSamplingAllProcesses"];
      id v497 = objc_opt_class();
      uint64_t v498 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v496, v560, v562, v497, 0);
      timeWhenTransitionedToSamplingAllProcesses = v564->_timeWhenTransitionedToSamplingAllProcesses;
      v564->_timeWhenTransitionedToSamplingAllProcesses = (SATimestamp *)v498;
    }
    else
    {
      timeWhenTransitionedToSamplingAllProcesses = v564->_timeWhenTransitionedToSamplingAllProcesses;
      v564->_timeWhenTransitionedToSamplingAllProcesses = 0;
    }

    if ([v480 containsValueForKey:@"_timeWhenTransitionedToSamplingAllThreads"])
    {
      unint64_t v500 = [v480 decodeInt64ForKey:@"_timeWhenTransitionedToSamplingAllThreads"];
      v501 = objc_opt_class();
      uint64_t v502 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v500, v560, v562, v501, 0);
      timeWhenTransitionedToSamplingAllThreads = v564->_timeWhenTransitionedToSamplingAllThreads;
      v564->_timeWhenTransitionedToSamplingAllThreads = (SATimestamp *)v502;
    }
    else
    {
      timeWhenTransitionedToSamplingAllThreads = v564->_timeWhenTransitionedToSamplingAllThreads;
      v564->_timeWhenTransitionedToSamplingAllThreads = 0;
    }

    if ([v480 containsValueForKey:@"_cpuSignalHandlerStackLeafKernelFrame"])
    {
      unint64_t v504 = [v480 decodeInt64ForKey:@"_cpuSignalHandlerStackLeafKernelFrame"];
      v505 = objc_opt_class();
      uint64_t v506 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v504, v560, v562, v505, 0);
      cpuSignalHandlerStackLeafKernelFrame = v564->_cpuSignalHandlerStackLeafKernelFrame;
      v564->_cpuSignalHandlerStackLeafKernelFrame = (SAFrame *)v506;
    }
    else
    {
      cpuSignalHandlerStackLeafKernelFrame = v564->_cpuSignalHandlerStackLeafKernelFrame;
      v564->_cpuSignalHandlerStackLeafKernelFrame = 0;
    }

    if ([v480 containsValueForKey:@"_eventTimeRange"])
    {
      unint64_t v508 = [v480 decodeInt64ForKey:@"_eventTimeRange"];
      long long v509 = objc_opt_class();
      uint64_t v510 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v508, v560, v562, v509, 0);
      eventTimeRange = v564->_eventTimeRange;
      v564->_eventTimeRange = (SATimeRange *)v510;
    }
    else
    {
      eventTimeRange = v564->_eventTimeRange;
      v564->_eventTimeRange = 0;
    }

    if ([v480 containsValueForKey:@"_timestampOfLastStackshot"])
    {
      unint64_t v512 = [v480 decodeInt64ForKey:@"_timestampOfLastStackshot"];
      long long v513 = objc_opt_class();
      uint64_t v514 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v512, v560, v562, v513, 0);
      timestampOfLastStackshot = v564->_timestampOfLastStackshot;
      v564->_timestampOfLastStackshot = (SATimestamp *)v514;
    }
    else
    {
      timestampOfLastStackshot = v564->_timestampOfLastStackshot;
      v564->_timestampOfLastStackshot = 0;
    }

    *(void *)long long buf = 0;
    id v516 = v480;
    uint64_t v517 = [v516 decodeBytesForKey:@"_sampleTimestamps" returnedLength:buf];
    if (v517)
    {
      unint64_t v518 = *(void *)buf;
      v519 = objc_opt_class();
      uint64_t v520 = SASerializableNewMutableArrayFromIndexList(v517, v518 >> 3, v560, v562, v519);
      sampleTimestamps = v564->_sampleTimestamps;
      v564->_sampleTimestamps = (NSMutableArray *)v520;
    }
    else
    {
      sampleTimestamps = v564->_sampleTimestamps;
      v564->_sampleTimestamps = 0;
    }

    if (![(NSMutableArray *)v564->_sampleTimestamps count])
    {
      if ([v516 containsValueForKey:@"_startTime"])
      {
        unint64_t v522 = [v516 decodeInt64ForKey:@"_startTime"];
        v523 = objc_opt_class();
        uint64_t v524 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v522, v560, v562, v523, 0);
        startTime = v564->_startTime;
        v564->_startTime = (SATimestamp *)v524;
      }
      else
      {
        startTime = v564->_startTime;
        v564->_startTime = 0;
      }

      if ([v516 containsValueForKey:@"_endTime"])
      {
        unint64_t v526 = [v516 decodeInt64ForKey:@"_endTime"];
        v527 = objc_opt_class();
        uint64_t v528 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v526, v560, v562, v527, 0);
        endTime = v564->_endTime;
        v564->_endTime = (SATimestamp *)v528;
      }
      else
      {
        endTime = v564->_endTime;
        v564->_endTime = 0;
      }

      v564->_numSamples = [v516 decodeInt64ForKey:@"_numSamples"];
    }
    v564->_sampleOnlyMainThreads = 0;
    v564->_shouldGatherKextStat = 0;
    v530 = +[SABinaryLocator sharedBinaryLocator];
    binaryLocator = v564->_binaryLocator;
    v564->_binaryLocator = v530;

    if (v564->_machTimebase.denom && v564->_machTimebase.numer)
    {
      v566[0] = MEMORY[0x1E4F143A8];
      v566[1] = 3221225472;
      v566[2] = __54__SASampleStore_SASampleStoreNSCoding__initWithCoder___block_invoke;
      v566[3] = &unk_1E63F7410;
      v567 = v564;
      -[SASampleStore iterateAllTimestamps:]((uint64_t)v567, v566);
    }
    [v560 enumerateKeysAndObjectsUsingBlock:&__block_literal_global_7];

    if (v556 >= 37) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "WARNING: Binary version %lu is newer than SASampleStore's decoder version %lu. Some data in the original report may not be available in the reparsed report\n", v556, 36);
    }
    uint64_t v111 = v558;
    unsigned int v110 = v554;
    IsEmbedded = v550;
    goto LABEL_300;
  }
  id v112 = v4;
  uint64_t context = (void *)MEMORY[0x1C18A6A20]();
  v564->_unint64_t dataGatheringOptions = 0;
  if (([v112 containsValueForKey:@"_PASampleTimeSeriesDataStore_Serialized_Version"] & 1) == 0)
  {
    *(void *)gSASerializationEncodedVersionBeingDecoded() = 1;
    goto LABEL_306;
  }
  uint64_t v559 = [v112 decodeIntegerForKey:@"_PASampleTimeSeriesDataStore_Serialized_Version"];
  if (v559 >= 16)
  {
    int v533 = *__error();
    unint64_t v534 = _sa_logt();
    if (os_log_type_enabled(v534, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v613) = 134217984;
      *(void *)((char *)&v613 + 4) = v559;
      _os_log_error_impl(&dword_1BF22B000, v534, OS_LOG_TYPE_ERROR, "encodedVersion %ld for PAStyleCoder", (uint8_t *)&v613, 0xCu);
    }

    *__error() = v533;
    _SASetCrashLogMessage(11314, "encodedVersion %ld for PAStyleCoder", v535, v536, v537, v538, v539, v540, v559);
    _os_crash();
    __break(1u);
  }
  unsigned int v548 = (uint64_t *)gSASerializationEncodedVersionBeingDecoded();
  *unsigned int v548 = v559;
  if (v559 <= 7)
  {
LABEL_306:
    id v541 = +[SAException exceptionWithName:@"Decoding failure" reason:@"Encoded version too old" userInfo:0];
    objc_exception_throw(v541);
  }
  if ([v112 containsValueForKey:@"_osProductName"])
  {
    uint64_t v113 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_osProductName"];
    unint64_t v114 = v564->_osProductName;
    v564->_osProductName = (NSString *)v113;
  }
  else
  {
    unint64_t v114 = v564->_osProductName;
    v564->_osProductName = (NSString *)@"Mac OS X";
  }

  SAIsEmbeddedPlatform(v564->_osProductName);
  v547 = (unsigned char *)gSASerializationEncodedDataIsEmbedded();
  unsigned char *v547 = v117;
  if (![v112 containsValueForKey:@"_dataSource"])
  {
    uint64_t v120 = 1;
    uint64_t v119 = v564;
    goto LABEL_33;
  }
  char v118 = [v112 decodeInt64ForKey:@"_dataSource"];
  if ((v118 & 2) != 0) {
    v564->_dataSource |= 1uLL;
  }
  uint64_t v119 = v564;
  if ((v118 & 4) != 0)
  {
    uint64_t v120 = v564->_dataSource | 2;
LABEL_33:
    v119->_dataSource = v120;
  }
  v119->_dataStyle = 2;
  uint64_t v121 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_reason"];
  uint64_t v122 = v564->_reason;
  v564->_reasouint64_t n = (NSString *)v121;

  double v123 = 0.0;
  if ((unint64_t)v559 >= 0xD) {
    objc_msgSend(v112, "decodeDoubleForKey:", @"_lastWakeTime", 0.0);
  }
  v564->_lastint WakeTime = v123;
  [v112 decodeDoubleForKey:@"_attemptedSamplingInterval"];
  v564->_attemptedSamplingInterval = v124;
  uint64_t v125 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_kextStat"];
  id v126 = v564->_kextStat;
  v564->_kextStat = (NSString *)v125;

  uint64_t v127 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_kernelVersion"];
  unsigned int v128 = v564->_kernelVersion;
  v564->_kernelVersiouint64_t n = (NSString *)v127;

  uint64_t v129 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_osProductVersion"];
  int v130 = v564->_osProductVersion;
  v564->_osProductVersiouint64_t n = (NSString *)v129;

  uint64_t v131 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_osProductVersionExtra"];
  unsigned int v132 = v564->_osProductVersionExtra;
  v564->_osProductVersionExtra = (NSString *)v131;

  uint64_t v133 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_osBuildVersion"];
  uint64_t v134 = v564->_osBuildVersion;
  v564->_osBuildVersiouint64_t n = (NSString *)v133;

  id v557 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_machineArchitecture"];
  [v557 UTF8String];
  v564->_arch = (_CSArchitecture)CSArchitectureGetArchitectureForName();
  v564->_workQueueSoftThreadLimit = [v112 decodeInt32ForKey:@"_workQueueSoftThreadLimit"];
  v564->_workQueueHardThreadLimit = [v112 decodeInt32ForKey:@"_workQueueHardThreadLimit"];
  uint64_t v135 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_hardwareModel"];
  unsigned int v136 = v564->_hardwareModel;
  v564->_hardwareModel = (NSString *)v135;

  v564->_numActiveCPUs = [v112 decodeInt32ForKey:@"_numActiveCPUs"];
  uint64_t v137 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_bootArgs"];
  uint64_t v138 = v564->_bootArgs;
  v564->_bootArgs = (NSString *)v137;

  v564->_targetThreadId = [v112 decodeInt64ForKey:@"_targetThreadId"];
  unsigned int v139 = [v112 decodeInt32ForKey:@"_cpuPercent"];
  int v140 = [v112 decodeInt32ForKey:@"_cpuDuration"];
  v564->_cpuDuratiouint64_t n = (double)v140;
  v564->_cpuUsed = (double)v139 * (double)v140 / 100.0;
  v564->_numWakeups = (int)[v112 decodeInt32ForKey:@"_wakeupsPerSec"];
  v564->_wakeupsDuratiouint64_t n = (double)(int)[v112 decodeInt32ForKey:@"_wakeupsDuration"];
  uint64_t v141 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_event"];
  BOOL v142 = v564->_event;
  v564->_event = (NSString *)v141;

  uint64_t v143 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_eventNote"];
  long long v144 = v564->_eventNote;
  v564->_eventNote = (NSString *)v143;

  long long v145 = v564->_eventTimeRange;
  v564->_eventTimeRange = 0;

  long long v146 = v564->_timestampOfLastStackshot;
  v564->_timestampOfLastStackshot = 0;

  uint64_t v147 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_signature"];
  long long v148 = v564->_signature;
  v564->_signature = (NSString *)v147;

  long long v149 = v564->_actionTaken;
  v564->_actionTakeuint64_t n = 0;

  [v112 decodeDoubleForKey:@"_extraDuration"];
  v564->_extraDuratiouint64_t n = v150;
  uint64_t v151 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_durationNote"];
  long long v152 = v564->_durationNote;
  v564->_durationNote = (NSString *)v151;

  uint64_t v153 = [v112 decodeObjectOfClass:objc_opt_class() forKey:@"_stepsNote"];
  long long v154 = v564->_stepsNote;
  v564->_stepsNote = (NSString *)v153;

  v564->_int targetProcessId = [v112 decodeInt32ForKey:@"_targetProcessId"];
  [v112 decodeDoubleForKey:@"_timeWhenTransitionedToSamplingAllProcesses"];
  if (v155 != 0.0)
  {
    uint64_t v156 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:v155 machContTimeSec:0.0 wallTime:0.0];
    long long v157 = v564->_timeWhenTransitionedToSamplingAllThreads;
    v564->_timeWhenTransitionedToSamplingAllThreads = (SATimestamp *)v156;
  }
  long long v158 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v159 = objc_opt_class();
  uint64_t v160 = objc_opt_class();
  long long v161 = objc_msgSend(v158, "setWithObjects:", v159, v160, objc_opt_class(), 0);
  v561 = [v112 decodeObjectOfClasses:v161 forKey:@"SerializedDataDictionary"];

  if (!v561)
  {
    id v543 = +[SAException exceptionWithName:@"Decoding failure" reason:@"nil dataDictionary" userInfo:0];
    objc_exception_throw(v543);
  }
  unint64_t v609 = 0;
  unint64_t v608 = 0;
  unint64_t v607 = 0;
  unint64_t v606 = 0;
  unint64_t v605 = 0;
  id v162 = v112;
  uint64_t v163 = [v162 decodeBytesForKey:@"TimeInsensitiveTaskIndices" returnedLength:&v609];
  if ([v162 containsValueForKey:@"RootKernelFrames"])
  {
    uint64_t v164 = [v162 decodeBytesForKey:@"RootKernelFrames" returnedLength:&v608];
  }
  else
  {
    uint64_t v164 = 0;
    unint64_t v608 = 0;
  }
  id v165 = v162;
  uint64_t v551 = [v165 decodeBytesForKey:@"SampleDataIndices" returnedLength:&v607];
  id v166 = v165;
  uint64_t v555 = [v166 decodeBytesForKey:@"FanSpeedIndices" returnedLength:&v606];
  id v167 = v166;
  id v552 = (id)[v167 decodeBytesForKey:@"HIDEventIndices" returnedLength:&v605];
  if ((v609 & 7) != 0)
  {
    char v544 = @"Unexpected task index array length";
    goto LABEL_313;
  }
  if ((v607 & 7) != 0)
  {
    char v544 = @"Unexpected sample index array length";
    goto LABEL_313;
  }
  if ((v606 & 7) != 0)
  {
    char v544 = @"Unexpected fan index array length";
    goto LABEL_313;
  }
  if ((v605 & 7) != 0)
  {
    char v544 = @"Unexpected hid event array length";
LABEL_313:
    id v545 = +[SAException exceptionWithName:@"Decoding failure" reason:v544 userInfo:0];
    objc_exception_throw(v545);
  }
  id v168 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  if (v163)
  {
    unint64_t v169 = v609;
    if (v609)
    {
      uint64_t v170 = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:v609 >> 3];
      long long v171 = v564->_tasksByPid;
      v564->_tasksByPid = (NSMutableDictionary *)v170;

      uint64_t v172 = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:v169 >> 3];
      long long v173 = v564->_tasksByUniquePid;
      v564->_tasksByUniquePid = (NSMutableDictionary *)v172;

      unint64_t v174 = v609;
      long long v175 = objc_opt_class();
      long long v176 = SASerializableNewMutableArrayFromIndexList(v163, v174 >> 3, v168, v561, v175);
      long long v603 = 0u;
      long long v604 = 0u;
      long long v601 = 0u;
      long long v602 = 0u;
      id v177 = v176;
      uint64_t v179 = [v177 countByEnumeratingWithState:&v601 objects:buf count:16];
      if (v179)
      {
        uint64_t v180 = *(void *)v602;
        do
        {
          for (uint64_t m = 0; m != v179; ++m)
          {
            if (*(void *)v602 != v180) {
              objc_enumerationMutation(v177);
            }
            id v182 = *(id *)(*((void *)&v601 + 1) + 8 * m);
            if (v182) {
              id v182 = objc_getProperty(v182, v178, 8, 1);
            }
            id v183 = v182;
            -[SASampleStore addTask:]((uint64_t)v564, v183);
          }
          uint64_t v179 = [v177 countByEnumeratingWithState:&v601 objects:buf count:16];
        }
        while (v179);
      }

      -[SASampleStore findTargetProcessInTimeRange:]((uint64_t)v564, 0);
    }
  }
  if (v164)
  {
    unint64_t v184 = v608;
    long long v185 = (void *)[objc_alloc(MEMORY[0x1E4F1CA80]) initWithCapacity:v608 >> 3];
    long long v186 = objc_opt_class();
    long long v187 = SASerializableNewMutableSetFromIndexList(v164, v184 >> 3, v168, v561, v186);
    long long v599 = 0u;
    long long v600 = 0u;
    long long v597 = 0u;
    long long v598 = 0u;
    id v188 = v187;
    uint64_t v190 = [v188 countByEnumeratingWithState:&v597 objects:v621 count:16];
    if (v190)
    {
      uint64_t v191 = *(void *)v598;
      do
      {
        for (uint64_t n = 0; n != v190; ++n)
        {
          if (*(void *)v598 != v191) {
            objc_enumerationMutation(v188);
          }
          id v193 = *(id *)(*((void *)&v597 + 1) + 8 * n);
          if (v193) {
            id v193 = objc_getProperty(v193, v189, 8, 1);
          }
          id v194 = v193;
          [v185 addObject:v194];
        }
        uint64_t v190 = [v188 countByEnumeratingWithState:&v597 objects:v621 count:16];
      }
      while (v190);
    }

    uint64_t v196 = -[SASampleStore lastTaskWithPid:](v564, 0);
    if (v196
      || ([(NSMutableDictionary *)v564->_tasksByUniquePid count] ? (uint64_t v197 = 0) : (uint64_t v197 = -1),
          +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, 0, v197, 0, 0),
          uint64_t v196 = objc_claimAutoreleasedReturnValue(),
          -[SASampleStore addTask:]((uint64_t)v564, v196),
          v196))
    {
      objc_setProperty_atomic(v196, v195, v185, 280);
    }
  }
  if (v564->_targetProcess)
  {
    uint64_t v198 = [v167 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleVersion"];
    uint64_t v199 = [(SATask *)v564->_targetProcess mainBinary];
    int v201 = v199;
    if (v199) {
      objc_setProperty_atomic_copy(v199, v200, v198, 96);
    }

    BOOL v202 = [v167 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleShortVersion"];
    uint64_t v203 = [(SATask *)v564->_targetProcess mainBinary];
    uint64_t v205 = v203;
    if (v203) {
      objc_setProperty_atomic_copy(v203, v204, v202, 104);
    }

    uint64_t v207 = [v167 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleBuildVersion"];
    uint64_t v208 = v564->_targetProcess;
    if (v208) {
      objc_setProperty_atomic_copy(v208, v206, v207, 112);
    }

    int v210 = [v167 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleProjectName"];
    uint64_t v211 = v564->_targetProcess;
    if (v211) {
      objc_setProperty_atomic_copy(v211, v209, v210, 120);
    }

    uint64_t v213 = [v167 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleSourceVersion"];
    uint64_t v214 = v564->_targetProcess;
    if (v214) {
      objc_setProperty_atomic_copy(v214, v212, v213, 128);
    }

    uint64_t v216 = [v167 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleProductBuildVersion"];
    char v217 = v564->_targetProcess;
    if (v217) {
      objc_setProperty_atomic_copy(v217, v215, v216, 136);
    }

    uint64_t v218 = [v167 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessBundleId"];
    uint64_t v219 = [(SATask *)v564->_targetProcess mainBinary];
    uint64_t v221 = v219;
    if (v219) {
      objc_setProperty_atomic_copy(v219, v220, v218, 88);
    }

    uint64_t v222 = [v167 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessCommerceAppID"];
    if (v222)
    {
      id v223 = objc_alloc_init(MEMORY[0x1E4F28EE0]);
      uint64_t v224 = [v223 numberFromString:v222];
      char v225 = v224;
      if (v224)
      {
        uint64_t v226 = [v224 unsignedLongLongValue];
        v227 = v564->_targetProcess;
        if (v227) {
          v227->_adamID = v226;
        }
      }
      else
      {
        int v319 = *__error();
        uint64_t v320 = _sa_logt();
        if (os_log_type_enabled(v320, OS_LOG_TYPE_FAULT))
        {
          LODWORD(v613) = 138412290;
          *(void *)((char *)&v613 + 4) = v222;
          _os_log_fault_impl(&dword_1BF22B000, v320, OS_LOG_TYPE_FAULT, "Unable to parse commerceAppID %@", (uint8_t *)&v613, 0xCu);
        }

        *__error() = v319;
      }
    }
    int v322 = [v167 decodeObjectOfClass:objc_opt_class() forKey:@"_targetProcessCommerceExternalID"];
    long long v323 = v564->_targetProcess;
    if (v323) {
      objc_setProperty_atomic_copy(v323, v321, v322, 168);
    }
  }
  if (v551)
  {
    unint64_t v324 = v607;
    if (v607)
    {
      uint64_t v325 = [objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:v607 >> 3];
      uint64_t v326 = v564->_sampleTimestamps;
      v564->_sampleTimestamps = (NSMutableArray *)v325;

      uint64_t v327 = objc_opt_class();
      uint64_t v328 = SASerializableNewMutableArrayFromIndexList(v551, v324 >> 3, v168, v561, v327);
      long long v595 = 0u;
      long long v596 = 0u;
      long long v593 = 0u;
      long long v594 = 0u;
      id v329 = v328;
      uint64_t v331 = [v329 countByEnumeratingWithState:&v593 objects:v620 count:16];
      if (v331)
      {
        uint64_t v332 = *(void *)v594;
        do
        {
          for (iuint64_t i = 0; ii != v331; ++ii)
          {
            if (*(void *)v594 != v332) {
              objc_enumerationMutation(v329);
            }
            id v334 = *(id *)(*((void *)&v593 + 1) + 8 * ii);
            uint64_t v335 = v564->_sampleTimestamps;
            if (v334) {
              id v334 = objc_getProperty(v334, v330, 8, 1);
            }
            id v336 = v334;
            [(NSMutableArray *)v335 addObject:v336];
          }
          uint64_t v331 = [v329 countByEnumeratingWithState:&v593 objects:v620 count:16];
        }
        while (v331);
      }
    }
  }
  if (v555)
  {
    unint64_t v337 = v606;
    uint64_t v338 = [objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:v606 >> 3];
    long long v339 = v564->_fanSpeeds;
    v564->_fanSpeeds = (NSMutableArray *)v338;

    uint64_t v340 = objc_opt_class();
    uint64_t v341 = SASerializableNewMutableArrayFromIndexList(v555, v337 >> 3, v168, v561, v340);
    long long v591 = 0u;
    long long v592 = 0u;
    long long v589 = 0u;
    long long v590 = 0u;
    id v342 = v341;
    uint64_t v344 = [v342 countByEnumeratingWithState:&v589 objects:v619 count:16];
    if (v344)
    {
      uint64_t v345 = *(void *)v590;
      do
      {
        for (juint64_t j = 0; jj != v344; ++jj)
        {
          if (*(void *)v590 != v345) {
            objc_enumerationMutation(v342);
          }
          id v347 = *(id *)(*((void *)&v589 + 1) + 8 * jj);
          uint64_t v348 = v564->_fanSpeeds;
          if (v347) {
            id v347 = objc_getProperty(v347, v343, 8, 1);
          }
          id v349 = v347;
          [(NSMutableArray *)v348 addObject:v349];
        }
        uint64_t v344 = [v342 countByEnumeratingWithState:&v589 objects:v619 count:16];
      }
      while (v344);
    }
  }
  if (v552)
  {
    uint64_t v350 = [objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:v605 >> 3];
    uint64_t v351 = v564->_hidEvents;
    v564->_hidEvents = (NSMutableArray *)v350;

    unint64_t v352 = v605;
    uint64_t v353 = objc_opt_class();
    int v354 = SASerializableNewMutableArrayFromIndexList((uint64_t)v552, v352 >> 3, v168, v561, v353);
    long long v587 = 0u;
    long long v588 = 0u;
    long long v585 = 0u;
    long long v586 = 0u;
    id v355 = v354;
    uint64_t v357 = [v355 countByEnumeratingWithState:&v585 objects:v618 count:16];
    if (v357)
    {
      uint64_t v358 = *(void *)v586;
      do
      {
        for (kuint64_t k = 0; kk != v357; ++kk)
        {
          if (*(void *)v586 != v358) {
            objc_enumerationMutation(v355);
          }
          id v360 = *(id *)(*((void *)&v585 + 1) + 8 * kk);
          uint64_t v361 = v564->_hidEvents;
          if (v360) {
            id v360 = objc_getProperty(v360, v356, 8, 1);
          }
          id v362 = v360;
          [(NSMutableArray *)v361 addObject:v362];
        }
        uint64_t v357 = [v355 countByEnumeratingWithState:&v585 objects:v618 count:16];
      }
      while (v357);
    }
  }
  v363 = (NSMutableArray *)objc_alloc_init(MEMORY[0x1E4F1CA48]);
  uint64_t v364 = v564->_gestures;
  v564->_gestures = v363;

  unint64_t v365 = [v167 decodeInt64ForKey:@"SymbolDataStoreIndex"];
  uint64_t v366 = objc_opt_class();
  uint64_t v367 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v365, v168, v561, v366, 0);
  unint64_t v368 = [v167 decodeInt64ForKey:@"MountStatusTrackerIndex"];
  uint64_t v369 = objc_opt_class();
  int v370 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v368, v168, v561, v369, 0);
  uint64_t v372 = v370;
  if (!v370)
  {
    id v546 = +[SAException exceptionWithName:@"Decoding failure" reason:@"Could not deserialize mount status" userInfo:0];
    objc_exception_throw(v546);
  }
  id v373 = objc_getProperty(v370, v371, 8, 1);
  objc_storeStrong((id *)&v564->_mountStatusTracker, v373);
  if ([v167 containsValueForKey:@"WSUpdateDataStoreIndex"])
  {
    unint64_t v374 = [v167 decodeInt64ForKey:@"WSUpdateDataStoreIndex"];
    uint64_t v375 = objc_opt_class();
    uint64_t v376 = _SASerializableInstanceForIndexUsingDeserializationDictionaryAndDataBufferDictionaryAndClass(v374, v168, v561, v375, 0);
    uint64_t v377 = v564->_wsDataStore;
    v564->_wsDataStore = (SAWSUpdateDataStore *)v376;
  }
  else
  {
    uint64_t v377 = v564->_wsDataStore;
    v564->_wsDataStore = 0;
  }

  v564->_sampleOnlyMainThreads = 0;
  v564->_shouldGatherKextStat = 0;
  int v378 = +[SABinaryLocator sharedBinaryLocator];
  v379 = v564->_binaryLocator;
  v564->_binaryLocator = v378;

  v564->_machTimebase = (mach_timebase_info)0x100000001;
  v584[0] = MEMORY[0x1E4F143A8];
  v584[1] = 3221225472;
  v584[2] = __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke;
  v584[3] = &unk_1E63F7410;
  v584[4] = v564;
  -[SASampleStore iterateAllTimestamps:]((uint64_t)v564, v584);
  if (v367) {
    id v381 = objc_getProperty(v367, v380, 24, 1);
  }
  else {
    id v381 = 0;
  }
  id v382 = v381;

  if (v382)
  {
    id v384 = objc_alloc(MEMORY[0x1E4F1CA48]);
    if (v367) {
      id v385 = objc_getProperty(v367, v383, 24, 1);
    }
    else {
      id v385 = 0;
    }
    id v386 = v385;
    uint64_t v387 = objc_msgSend(v384, "initWithObjects:", v386, 0);
    uint64_t v388 = v564->_kernelCaches;
    v564->_kernelCaches = (NSMutableArray *)v387;
  }
  *(void *)&long long v613 = 0;
  *((void *)&v613 + 1) = &v613;
  uint64_t v614 = 0x3032000000;
  v615 = __Block_byref_object_copy__0;
  v616 = __Block_byref_object_dispose__0;
  id v617 = 0;
  v581[0] = MEMORY[0x1E4F143A8];
  v581[1] = 3221225472;
  v581[2] = __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_2;
  v581[3] = &unk_1E63F7B70;
  v581[4] = v564;
  id v389 = v367;
  id v582 = v389;
  v583 = &v613;
  [(SASampleStore *)v564 enumerateTasks:v581];
  if (*(void *)(*((void *)&v613 + 1) + 40))
  {
    id v390 = objc_alloc(MEMORY[0x1E4F1CAD0]);
    uint64_t v391 = objc_msgSend(v390, "initWithObjects:", *(void *)(*((void *)&v613 + 1) + 40), 0);
    +[SAFrame enumerateFrameTree:block:]((uint64_t)SAFrame, v391, &__block_literal_global_1655);
  }
  [v168 enumerateKeysAndObjectsUsingBlock:&__block_literal_global_7];

  _Block_object_dispose(&v613, 8);
  *unsigned int v548 = 0;
  unsigned char *v547 = 0;

  size_t v108 = v564;
  long long v565 = v108;
LABEL_193:
  uint64_t v111 = v558;
LABEL_301:

  return v108;
}

uint64_t __54__SASampleStore_SASampleStoreNSCoding__initWithCoder___block_invoke(uint64_t a1, uint64_t a2)
{
  return -[SATimestamp applyMachTimebase:](a2, *(void *)(*(void *)(a1 + 32) + 184));
}

uint64_t __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke(uint64_t a1, uint64_t a2)
{
  return -[SATimestamp applyMachTimebase:](a2, *(void *)(*(void *)(a1 + 32) + 184));
}

void __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_2(void *a1, void *a2)
{
  uint64_t v3 = a2;
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x2020000000;
  v16[3] = 0;
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  v15[2] = __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_3;
  v15[3] = &unk_1E63F7AF8;
  v15[4] = a1[4];
  v15[5] = v16;
  [v3 enumerateTaskStatesBetweenStartTime:0 startSampleIndex:0x7FFFFFFFFFFFFFFFLL endTime:0 endSampleIndex:0x7FFFFFFFFFFFFFFFLL reverseOrder:0 block:v15];
  id v4 = [v3 threads];
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  v14[2] = __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_4;
  v14[3] = &unk_1E63F7B48;
  v14[4] = a1[4];
  v14[5] = v16;
  [v4 enumerateKeysAndObjectsUsingBlock:v14];

  if (v3 && (objc_copyStruct(&dest, v3 + 288, 8, 1, 0), dest)
    || (-[SATask guessArchitectureGivenMachineArchitecture:dataSource:]((uint64_t)v3, *(id *)(a1[4] + 192), *(void *)(a1[4] + 352)), v3))
  {
    objc_copyStruct(&dest, v3 + 288, 8, 1, 0);
  }
  char v6 = CSArchitectureIs32Bit();
  id Property = (id)a1[5];
  if (v6)
  {
    if (Property) {
      id Property = objc_getProperty(Property, v5, 16, 1);
    }
    id v9 = Property;
    if (v3) {
LABEL_13:
    }
      objc_setProperty_atomic(v3, v8, v9, 256);
  }
  else
  {
    if (Property) {
      id Property = objc_getProperty(Property, v5, 8, 1);
    }
    id v9 = Property;
    if (v3) {
      goto LABEL_13;
    }
  }

  id v10 = -[SATask removeStacksOutsideThisProcess]((uint64_t)v3);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1[6] + 8);
    uint64_t v13 = *(void *)(v11 + 40);
    uint64_t v12 = (id *)(v11 + 40);
    if (!v13) {
      objc_storeStrong(v12, v10);
    }
  }
  -[SATask fixupFrameInstructionsWithDataGatheringOptions:mightBeAlive:foundNewBinaryInfo:uuidsWithNewInstructions:additionalCSSymbolicatorFlags:]((id *)v3, *(void *)(a1[4] + 408), 0, 0, 0, *(_DWORD *)(a1[4] + 328));

  _Block_object_dispose(v16, 8);
}

void __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_3(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  for (uint64_t i = v3; ; v3 = i)
  {
    id v4 = [v3 startTimestamp];
    uint64_t v5 = [*(id *)(*(void *)(a1 + 32) + 24) objectAtIndexedSubscript:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)];

    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v7 = *(void *)(v6 + 24);
    if (v4 == v5) {
      break;
    }
    *(void *)(v6 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7 + 1;
  }
  uint64_t v8 = i;
  if (i) {
    i[6] = v7;
  }
  while (1)
  {
    id v9 = [v8 endTimestamp];
    id v10 = [*(id *)(*(void *)(a1 + 32) + 24) objectAtIndexedSubscript:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)];

    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v12 = *(void *)(v11 + 24);
    if (v9 == v10) {
      break;
    }
    *(void *)(v11 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v12 + 1;
    uint64_t v8 = i;
  }
  if (i) {
    i[7] = v12;
  }
}

uint64_t __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_4(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_5;
  v4[3] = &unk_1E63F7B20;
  long long v5 = *(_OWORD *)(a1 + 32);
  return [a3 enumerateThreadStatesBetweenStartTime:0 startSampleIndex:0x7FFFFFFFFFFFFFFFLL endTime:0 endSampleIndex:0x7FFFFFFFFFFFFFFFLL reverseOrder:0 block:v4];
}

void __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_5(uint64_t a1, void *a2)
{
  id v11 = a2;
  while (1)
  {
    uint64_t v3 = [v11 startTimestamp];
    id v4 = [*(id *)(*(void *)(a1 + 32) + 24) objectAtIndexedSubscript:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)];

    uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
    unint64_t v6 = *(void *)(v5 + 24);
    if (v3 == v4) {
      break;
    }
    *(void *)(v5 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v6 + 1;
  }
  -[SAThreadState setStartSampleIndex:]((uint64_t)v11, v6);
  while (1)
  {
    uint64_t v7 = [v11 endTimestamp];
    uint64_t v8 = [*(id *)(*(void *)(a1 + 32) + 24) objectAtIndexedSubscript:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)];

    uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
    unint64_t v10 = *(void *)(v9 + 24);
    if (v7 == v8) {
      break;
    }
    *(void *)(v9 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v10 + 1;
  }
  -[SAThreadState setEndSampleIndex:]((uint64_t)v11, v10);
}

void __61__SASampleStore_SASampleStoreNSCoding__initWithPAStyleCoder___block_invoke_6(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(void *)(a2 + 32) = 0;
  }
}

- (BOOL)keepStateBetweenSampleIndexes
{
  return 0;
}

- (void)setKeepStateBetweenSampleIndexes:(BOOL)a3
{
  if (a3)
  {
    int v3 = *__error();
    id v4 = _sa_logt();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_fault_impl(&dword_1BF22B000, v4, OS_LOG_TYPE_FAULT, "keepStateBetweenSampleIndexes is no longer supported", v5, 2u);
    }

    *__error() = v3;
  }
}

- (id)tidToPidDict
{
  id v3 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __36__SASampleStore_KPerf__tidToPidDict__block_invoke;
  v6[3] = &unk_1E63F7E18;
  id v4 = v3;
  id v7 = v4;
  [(SASampleStore *)self enumerateTasks:v6];

  return v4;
}

void __36__SASampleStore_KPerf__tidToPidDict__block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 threads];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __36__SASampleStore_KPerf__tidToPidDict__block_invoke_2;
  v6[3] = &unk_1E63F7DF0;
  id v7 = *(id *)(a1 + 32);
  id v5 = v3;
  id v8 = v5;
  [v4 enumerateKeysAndObjectsUsingBlock:v6];
}

void __36__SASampleStore_KPerf__tidToPidDict__block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v7 = a3;
  id v4 = objc_msgSend(NSNumber, "numberWithInt:", objc_msgSend(*(id *)(a1 + 40), "pid"));
  id v5 = *(void **)(a1 + 32);
  unint64_t v6 = objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v7, "threadId"));
  [v5 setObject:v4 forKeyedSubscript:v6];
}

- (id)tidsForPid:(int)a3
{
  uint64_t v3 = *(void *)&a3;
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v5 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  unint64_t v6 = [(SASampleStore *)self tasksByPid];
  id v7 = [NSNumber numberWithInt:v3];
  id v8 = [v6 objectForKeyedSubscript:v7];

  uint64_t v9 = [v8 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v9)
  {
    uint64_t v10 = *(void *)v16;
    do
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v16 != v10) {
          objc_enumerationMutation(v8);
        }
        uint64_t v12 = [*(id *)(*((void *)&v15 + 1) + 8 * i) threads];
        uint64_t v13 = [v12 allKeys];
        [v5 addObjectsFromArray:v13];
      }
      uint64_t v9 = [v8 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }
    while (v9);
  }

  return v5;
}

- (id)idleThreadSet
{
  id v3 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __37__SASampleStore_KPerf__idleThreadSet__block_invoke;
  v6[3] = &unk_1E63F7E18;
  id v4 = v3;
  id v7 = v4;
  [(SASampleStore *)self enumerateTasks:v6];

  return v4;
}

void __37__SASampleStore_KPerf__idleThreadSet__block_invoke(uint64_t a1, void *a2)
{
  id v3 = [a2 threads];
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __37__SASampleStore_KPerf__idleThreadSet__block_invoke_2;
  v4[3] = &unk_1E63F7E40;
  id v5 = *(id *)(a1 + 32);
  [v3 enumerateKeysAndObjectsUsingBlock:v4];
}

void __37__SASampleStore_KPerf__idleThreadSet__block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  unint64_t v6 = [v5 threadStates];
  uint64_t v7 = [v6 count];

  if (v7 == 1) {
    [*(id *)(a1 + 32) addObject:v8];
  }
}

- (void)existingTaskForEvent:(uint64_t)a3 inSession:(_DWORD *)a4 returningPid:
{
  id v4 = a1;
  if (a1)
  {
    uint64_t v7 = *(unsigned int *)(a2 + 88);
    if ((v7 & 0x80000000) != 0
      && ((int pid_for_thread = ktrace_get_pid_for_thread(), pid_for_thread < 0)
        ? (uint64_t v7 = 0xFFFFFFFFLL)
        : (uint64_t v7 = pid_for_thread),
          pid_for_thread < 0 && !*(void *)(a2 + 40)))
    {
      id v4 = 0;
      if (a4) {
LABEL_11:
      }
        *a4 = v7;
    }
    else
    {
      uint64_t v9 = -[SASampleStore lastTaskWithPid:orTid:](v4, v7, *(void *)(a2 + 40));
      id v4 = v9;
      if (v9) {
        LODWORD(v7) = [v9 pid];
      }
      if (a4) {
        goto LABEL_11;
      }
    }
  }
  return v4;
}

- (id)taskForPid:(void *)a3 andName:(void *)a4 didExecAtTimestamp:
{
  id v7 = a3;
  id v8 = a4;
  if (a1)
  {
    uint64_t v9 = -[SASampleStore lastTaskWithPid:](a1, a2);
    uint64_t v10 = v9;
    if (v9)
    {
      if (!v8)
      {
        if (v7)
        {
          if (!v9[7])
          {
            long long v17 = [v9 name];
            if (!v17
              || ([v10 name],
                  long long v18 = objc_claimAutoreleasedReturnValue(),
                  char v19 = [v18 hasPrefix:v7],
                  v18,
                  v17,
                  (v19 & 1) == 0))
            {
              -[SATask setName:]((uint64_t)v10, v7);
            }
          }
        }
        id v14 = v10;
        goto LABEL_22;
      }
      id v11 = [v9 exitTimestamp];

      if (!v11) {
        -[SASampleStore task:exitedAtTimestamp:]((uint64_t)a1, v10, v8);
      }
    }
    uint64_t v12 = +[SATask taskWithPid:uniquePid:name:sharedCache:]((uint64_t)SATask, a2, -1, v7, 0);
    id v14 = v12;
    if (v12) {
      objc_setProperty_atomic(v12, v13, v8, 224);
    }
    -[SASampleStore addTask:]((uint64_t)a1, v14);
    if (([a1 dataGatheringOptions] & 2) == 0)
    {
LABEL_22:

      goto LABEL_23;
    }
    if (([a1 dataGatheringOptions] & 0x80) != 0)
    {
      long long v15 = [v14 binaryLoadInfos];
      if (![v15 count])
      {

LABEL_20:
        -[SATask gatherLoadInfoFromLiveProcessWithDataGatheringOptions:additionalCSSymbolicatorFlags:]((uint64_t)v14, [a1 dataGatheringOptions], objc_msgSend(a1, "additionalCSSymbolicatorFlags"));
        goto LABEL_21;
      }
      int v16 = [v14 pid];

      if (!v16) {
        goto LABEL_20;
      }
    }
LABEL_21:
    -[SATask _gatherDataFromLiveProcessIsLate:mainBinaryPath:]((uint64_t)v14, 0, 0);
    goto LABEL_22;
  }
  id v14 = 0;
LABEL_23:

  return v14;
}

BOOL __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke(uint64_t a1, void *a2, unsigned char *a3)
{
  uint64_t v5 = [a2 address];
  uint64_t v6 = *(void *)(a1 + 32);
  if (v5 == v6) {
    *a3 = 1;
  }
  return v5 == v6;
}

BOOL __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke_78(uint64_t a1, void *a2, unsigned char *a3)
{
  uint64_t v5 = [a2 address];
  uint64_t v6 = *(void *)(a1 + 32);
  if (v5 == v6) {
    *a3 = 1;
  }
  return v5 == v6;
}

void __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke_83(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v45 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v7 = v45;
    if ([v7 needsExclave])
    {
      [v7 setNeedsExclave:0];
      if (v7) {
        objc_setProperty_atomic(v7, v8, *(id *)(a1 + 40), 176);
      }
      if (!a3 && qword_1EB698F20)
      {
        int v9 = *__error();
        uint64_t v10 = (FILE *)qword_1EB698F20;
        uint64_t v11 = *(void *)(*(void *)(a1 + 56) + 8);
        uint64_t v13 = [*(id *)(a1 + 32) threadId];
        id Property = *(id *)(a1 + 40);
        if (Property) {
          id Property = objc_getProperty(Property, v12, 16, 1);
        }
        id v43 = Property;
        uint64_t v16 = [v43 count];
        id v17 = *(id *)(a1 + 40);
        if (v17) {
          id v17 = objc_getProperty(v17, v15, 16, 1);
        }
        id v18 = v17;
        char v19 = [v18 lastObject];
        long long v21 = v19;
        if (v19)
        {
          id v22 = objc_getProperty(v19, v20, 16, 1);
          int v23 = v9;
        }
        else
        {
          int v23 = v9;
          id v22 = 0;
        }
        id v24 = v22;
        fprintf(v10, "%'llu Thread 0x%llx exclave info (%lu exclaves, leaf frame 0x%llx) backfilled to all (%d) thread states (indexes %lu-%lu)\n", v11, v13, v16, [v24 address], *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));

        *__error() = v23;
      }
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    }
    else
    {
      if (*(int *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) >= 1 && qword_1EB698F20 != 0)
      {
        int v27 = *__error();
        uint64_t v28 = (FILE *)qword_1EB698F20;
        uint64_t v29 = *(void *)(*(void *)(a1 + 56) + 8);
        uint64_t v31 = [*(id *)(a1 + 32) threadId];
        id v32 = *(id *)(a1 + 40);
        if (v32) {
          id v32 = objc_getProperty(v32, v30, 16, 1);
        }
        id v44 = v32;
        uint64_t v34 = [v44 count];
        id v35 = *(id *)(a1 + 40);
        if (v35) {
          id v35 = objc_getProperty(v35, v33, 16, 1);
        }
        id v42 = v35;
        uint64_t v36 = [v42 lastObject];
        uint64_t v38 = v36;
        int v41 = v27;
        if (v36) {
          id v39 = objc_getProperty(v36, v37, 16, 1);
        }
        else {
          id v39 = 0;
        }
        id v40 = v39;
        fprintf(v28, "%'llu Thread 0x%llx exclave info (%lu exclaves, leaf frame 0x%llx) backfilled to %d thread states (indexes %lu-%lu)\n", v29, v31, v34, [v40 address], *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), a3 + 1, *(int *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) + a3);

        *__error() = v41;
      }
      *a4 = 1;
    }
  }
  else
  {
    if (qword_1EB698F20)
    {
      int v25 = *__error();
      fprintf((FILE *)qword_1EB698F20, "%'llu Thread 0x%llx ran into non-kperf state at index %lu, stopping\n", *(void *)(*(void *)(a1 + 56) + 8), [*(id *)(a1 + 32) threadId], a3);
      *__error() = v25;
    }
    *a4 = 1;
  }
}

- (void)kperfRecord:(void *)a3 state:(void *)a4 frameIterator:
{
  uint64_t v328 = *MEMORY[0x1E4F143B8];
  self = a3;
  id v300 = a4;
  uint64_t v304 = a1;
  if (a1)
  {
    uint64_t context = (void *)MEMORY[0x1C18A6A20]();
    if ((*(void *)a2 & 0x200000000) == 0)
    {
      if ((~(unsigned __int16)*(void *)a2 & 0x2005) == 0)
      {
        uint64_t v6 = *(void *)(a2 + 16);
        if (!v6)
        {
          int v241 = *__error();
          id v242 = _sa_logt();
          if (os_log_type_enabled(v242, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl(&dword_1BF22B000, v242, OS_LOG_TYPE_ERROR, "0 tid", buf, 2u);
          }

          *__error() = v241;
          _SASetCrashLogMessage(773, "0 tid", v243, v244, v245, v246, v247, v248, v274);
          _os_crash();
          __break(1u);
          goto LABEL_269;
        }
        uint64_t v7 = [a1 dataSource];
        uint64_t v8 = *(void *)a2;
        if (v7 == 2)
        {
          if ((v8 & 0x20) == 0)
          {
            if (!qword_1EB698F20) {
              goto LABEL_264;
            }
            int v9 = __error();
            if ((*(unsigned char *)a2 & 2) != 0) {
              int v10 = *(_DWORD *)(a2 + 24);
            }
            else {
              int v10 = -1;
            }
            int v105 = *v9;
            fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Thread 0x%llx core %d ignoring record without thread info\n", *(void *)(a2 + 8), v6, v10);
            int v106 = __error();
LABEL_132:
            int *v106 = v105;
            goto LABEL_264;
          }
        }
        else if ((v8 & 0x1000000C0) == 0)
        {
          if (!qword_1EB698F20) {
            goto LABEL_264;
          }
          double v90 = __error();
          if ((*(unsigned char *)a2 & 2) != 0) {
            int v91 = *(_DWORD *)(a2 + 24);
          }
          else {
            int v91 = -1;
          }
          int v105 = *v90;
          fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Thread 0x%llx core %d ignoring record without a stack\n", *(void *)(a2 + 8), v6, v91);
          int v106 = __error();
          goto LABEL_132;
        }
        if (self
          && (uint64_t v61 = (void *)self[1],
              [NSNumber numberWithUnsignedLongLong:v6],
              id v62 = objc_claimAutoreleasedReturnValue(),
              LODWORD(v61) = [v61 containsObject:v62],
              v62,
              v61))
        {
          -[SAKPerfState nextSampleForThread:isOnCore:]((uint64_t)self, v6, 0);
          int v307 = 1;
        }
        else
        {
          int v307 = 0;
        }
        if ([v304 dataStyle] != 1)
        {
          if ([v304 dataStyle])
          {
            unsigned int v69 = [v304 sampleTimestamps];
            uint64_t v70 = [v69 count];

            if (!v70)
            {
              if (!qword_1EB698F20) {
                goto LABEL_264;
              }
              int v105 = *__error();
              fprintf((FILE *)qword_1EB698F20, "%'llu No sampling point before kperfdata\n", *(void *)(a2 + 8));
              int v106 = __error();
              goto LABEL_132;
            }
          }
        }
        if ((*(unsigned char *)a2 & 2) != 0) {
          LODWORD(v71) = *(_DWORD *)(a2 + 24);
        }
        else {
          LODWORD(v71) = -1;
        }
        unint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
        unint64_t v74 = absolute_from_timestamp;
        if (self)
        {
          unint64_t v75 = self[4];
          if (absolute_from_timestamp > v75)
          {
LABEL_89:
            unint64_t v75 = absolute_from_timestamp;
            goto LABEL_95;
          }
          if ((v307 & 1) == 0)
          {
            id v76 = objc_getProperty(self, v73, 40, 1);
            if (v76)
            {
              uint64_t v78 = v76;
              id v79 = objc_getProperty(self, v77, 40, 1);
              unint64_t v80 = [v79 machAbsTime];

              if (v74 <= v80)
              {
                if (qword_1EB698F20)
                {
                  int v117 = *__error();
                  char v118 = (FILE *)qword_1EB698F20;
                  uint64_t v119 = *(void *)(a2 + 8);
                  id v121 = objc_getProperty(self, v120, 40, 1);
                  fprintf(v118, "%'llu Adjusting forward record timestamp %lld to %lld, and making on-core for most recent timer %lld \n", v119, v74, v75, [v121 machAbsTime]);

                  *__error() = v117;
                  int v307 = 1;
LABEL_95:
                  if (qword_1EB698F20)
                  {
                    int v82 = *__error();
                    long long v83 = (FILE *)qword_1EB698F20;
                    uint64_t v85 = *(void *)a2;
                    uint64_t v84 = *(void *)(a2 + 8);
                    StringForKPDecodeContentBits((uint64_t *)a2);
                    double v86 = "off";
                    if (v307) {
                      double v86 = "on";
                    }
                    fprintf(v83, "%'llu Thread 0x%llx core %d parsing %s-core kperf with content 0x%llx: %s\n", v84, v6, v71, v86, v85, (const char *)&qword_1EB698F30);
                    *__error() = v82;
                  }
                  goto LABEL_99;
                }
                int v307 = 1;
LABEL_99:
                uint64_t pid_for_thread = ktrace_get_pid_for_thread();
                if ((pid_for_thread & 0x80000000) != 0)
                {
                  if ((*(unsigned char *)a2 & 0x20) == 0)
                  {
                    if (!qword_1EB698F20) {
                      goto LABEL_264;
                    }
                    double v88 = __error();
                    if ((*(unsigned char *)a2 & 2) != 0) {
                      int v89 = *(_DWORD *)(a2 + 24);
                    }
                    else {
                      int v89 = -1;
                    }
                    int v105 = *v88;
                    fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Thread 0x%llx core %d unable to determine pid for thread: %d\n", *(void *)(a2 + 8), v6, v89, pid_for_thread);
                    int v106 = __error();
                    goto LABEL_132;
                  }
                  uint64_t pid_for_thread = *(unsigned int *)(a2 + 88);
                  if ((pid_for_thread & 0x80000000) != 0)
                  {
LABEL_275:
                    int v265 = *__error();
                    uint64_t v266 = _sa_logt();
                    if (os_log_type_enabled(v266, OS_LOG_TYPE_ERROR))
                    {
                      int v267 = *(_DWORD *)(a2 + 88);
                      *(_DWORD *)long long buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v267;
                      _os_log_error_impl(&dword_1BF22B000, v266, OS_LOG_TYPE_ERROR, "rec->thread_info.pid is %d", buf, 8u);
                    }

                    *__error() = v265;
                    _SASetCrashLogMessage(838, "rec->thread_info.pid is %d", v268, v269, v270, v271, v272, v273, *(_DWORD *)(a2 + 88));
                    _os_crash();
                    __break(1u);
                  }
                }
                uint64_t v303 = [NSNumber numberWithUnsignedLongLong:v6];
                -[SASampleStore lastTaskWithPid:](v304, pid_for_thread);
                double v92 = (unsigned char *)objc_claimAutoreleasedReturnValue();
                if (!v92)
                {
                  execname_for_thread = (unsigned char *)ktrace_get_execname_for_thread();
                  if (execname_for_thread && *execname_for_thread)
                  {
                    uint64_t v94 = SANSStringForCString(execname_for_thread);
                  }
                  else
                  {
                    uint64_t v94 = 0;
                  }
                  uint64_t v95 = -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v304, pid_for_thread, v94, 0);

                  double v92 = (unsigned char *)v95;
                }
                uint64_t v311 = v92;
                uint64_t v96 = [v92 threads];
                uint64_t v97 = [v96 objectForKeyedSubscript:v303];

                uint64_t v309 = (unsigned char *)v97;
                if (v97)
                {
LABEL_140:
                  uint64_t v125 = [v311 binaryLoadInfos];
                  [v300 setUserBinaryLoadInfos:v125];

                  if (v311) {
                    uint64_t v126 = v311[73] & 1;
                  }
                  else {
                    uint64_t v126 = 0;
                  }
                  [v300 setAssumeUserBinaryLoadInfosContainMainBinary:v126];
                  uint64_t v127 = [v311 sharedCache];
                  [v300 setSharedCache:v127];

                  unsigned int v128 = [v304 sampleTimestamps];
                  if ([v128 count])
                  {
                    uint64_t v129 = [v304 sampleTimestamps];
                    unint64_t v291 = [v129 count] - 1;
                  }
                  else
                  {
                    unint64_t v291 = 0x7FFFFFFFFFFFFFFFLL;
                  }

                  if (!v307) {
                    goto LABEL_157;
                  }
                  id Property = self;
                  if (self) {
                    id Property = objc_getProperty(self, v130, 40, 1);
                  }
                  id v132 = Property;

                  if (!v132)
                  {
LABEL_157:
                    +[SATimestamp timestampWithMachAbsTime:fromKtraceSession:]((uint64_t)SATimestamp, v75);
                    id v306 = (id)objc_claimAutoreleasedReturnValue();
                    unsigned __int8 v142 = 0;
                    goto LABEL_189;
                  }
                  uint64_t v133 = [v304 sampleTimestamps];
                  id v134 = [v133 lastObject];

                  if (!v134) {
                    goto LABEL_153;
                  }
                  if (self)
                  {
                    id v136 = objc_getProperty(self, v135, 40, 1);
                    if (v134 == v136)
                    {

                      id v143 = v134;
                      id v145 = self;
                      goto LABEL_161;
                    }
                  }
                  else
                  {
                    id v136 = 0;
                  }
                  unint64_t v137 = [v134 machAbsTime];

                  if (v137 < v74)
                  {
LABEL_153:
                    id v138 = self;
                    if (self) {
                      id v138 = objc_getProperty(self, v135, 40, 1);
                    }
                    id v139 = v138;
                    if (qword_1EB698F20)
                    {
                      int v140 = *__error();
                      fprintf((FILE *)qword_1EB698F20, "%'llu Adjusting backward record timestamp %lld to %lld, to match the non-PET timer that triggered it\n", *(void *)(a2 + 8), v74, [v139 machAbsTime]);
                      int v141 = 0;
                      *__error() = v140;
                    }
                    else
                    {
                      int v141 = 0;
                    }
LABEL_171:
                    uint64_t v297 = v139;
                    uint64_t v156 = [v309 threadStates];
                    long long v157 = [v156 lastObject];
                    long long v158 = [v157 endTimestamp];
                    uint64_t v159 = v158;
                    if (v158)
                    {
                      id v160 = v158;
                    }
                    else
                    {
                      id v160 = [v309 creationTimestamp];
                    }
                    if (v160 && [v160 gt:v297])
                    {
                      if (v141)
                      {
                        long long v161 = [v309 threadStates];
                        if ([v161 count])
                        {
                          id v162 = [v309 threadStates];
                          uint64_t v163 = [v162 lastObject];
                          uint64_t v164 = [v163 endSampleIndex];

                          if (v164 != v291)
                          {
                            BOOL v294 = v134;
                            int v165 = *__error();
                            id v166 = _sa_logt();
                            if (os_log_type_enabled(v166, OS_LOG_TYPE_ERROR))
                            {
                              id v167 = [v309 debugDescription];
                              uint64_t v168 = [v167 UTF8String];
                              unint64_t v169 = [v309 threadStates];
                              uint64_t v170 = [v169 lastObject];
                              id v171 = [v170 debugDescription];
                              uint64_t v172 = [v171 UTF8String];
                              id v173 = [v294 debugDescription];
                              *(_DWORD *)long long buf = 136315906;
                              *(void *)&uint8_t buf[4] = v168;
                              *(_WORD *)&buf[12] = 2080;
                              *(void *)&buf[14] = v172;
                              *(_WORD *)&buf[22] = 2048;
                              unint64_t v324 = (void *)v291;
                              LOWORD(v325) = 2080;
                              *(void *)((char *)&v325 + 2) = [v173 UTF8String];
                              _os_log_error_impl(&dword_1BF22B000, v166, OS_LOG_TYPE_ERROR, "Thread %s state %s vs last sample index %lu timestamp %s", buf, 0x2Au);
                            }
                            *__error() = v165;
                            id v174 = [v309 debugDescription];
                            int v141 = [v174 UTF8String];
                            long long v175 = [v309 threadStates];
                            uint64_t pid_for_thread = [v175 lastObject];
                            id v71 = [(id)pid_for_thread debugDescription];
                            [v71 UTF8String];
                            id v176 = [v294 debugDescription];
                            [v176 UTF8String];
                            _SASetCrashLogMessage(914, "Thread %s state %s vs last sample index %lu timestamp %s", v177, v178, v179, v180, v181, v182, v141);

                            id v134 = v294;
                            _os_crash();
                            __break(1u);
                            goto LABEL_182;
                          }
                        }
                        else
                        {
                        }
                        int v141 = 0;
                      }
                      id v306 = v160;

                      if (qword_1EB698F20)
                      {
                        int v185 = *__error();
                        fprintf((FILE *)qword_1EB698F20, "%'llu Adjusting forward record timestamp %lld to %lld, to match the last thread state\n", *(void *)(a2 + 8), v74, [v306 machAbsTime]);
                        *__error() = v185;
                      }
                      goto LABEL_188;
                    }
LABEL_182:
                    id v306 = v297;
LABEL_188:

                    unsigned __int8 v142 = v141 != 0;
LABEL_189:
                    uint64_t v186 = *(void *)a2;
                    if ((*(void *)a2 & 0x200000) != 0)
                    {
                      uint64_t ns_from_timestamp = ktrace_get_ns_from_timestamp();
                      uint64_t v188 = ktrace_get_ns_from_timestamp();
                      int v189 = *(_DWORD *)(a2 + 6640);
                      unint64_t v190 = *(void *)(a2 + 6632);
                      uint64_t v191 = (v190 >> 1) & 1;
                      int v192 = *(_DWORD *)(a2 + 6644);
                      char v193 = v190 & 1;
                      uint64_t v194 = (v190 >> 2) & 1;
                      uint64_t v195 = (v190 >> 3) & 1;
                      if ((v190 & 0x10) != 0)
                      {
                        uint64_t v196 = (v190 >> 5) & 1;
                        uint64_t v197 = (v190 >> 6) & 1;
                        char v198 = 1;
                        goto LABEL_196;
                      }
                    }
                    else
                    {
                      if (v186 & 0x1000) == 0 || (*(unsigned char *)(a2 + 6560)) {
                        goto LABEL_205;
                      }
                      uint64_t ns_from_timestamp = 0;
                      uint64_t v188 = 0;
                      int v189 = 0;
                      int v192 = 0;
                      char v193 = 0;
                      LOBYTE(v191) = 0;
                      LOBYTE(v194) = 0;
                      LOBYTE(v195) = 0;
                    }
                    char v198 = 0;
                    LOBYTE(v196) = 0;
                    LOBYTE(v197) = 0;
LABEL_196:
                    uint64_t v199 = *(void *)a2;
                    if (*(void *)a2 & 0x1000) == 0 || (*(unsigned char *)(a2 + 6560))
                    {
                      char v201 = 0;
                      uint64_t v200 = 0;
                    }
                    else
                    {
                      uint64_t v200 = *(void *)(a2 + 6568);
                      char v201 = 1;
                    }
                    if ((v199 & 0x100000) != 0)
                    {
                      int v202 = (*(unsigned __int16 *)(a2 + 6624) >> 9) & 7;
                      if (v202) {
                        v202 |= 0xFF0000u;
                      }
                    }
                    else
                    {
                      int v202 = 0;
                    }
                    -[SASampleStore backfillTask:lastSampleIndex:timestamp:haveSnap:terminatedThreadsUserTimeInNs:terminatedThreadsSystemTimeInNs:terminatedThreadsCycles:terminatedThreadsInstructions:suspendCount:pageins:isDarwinBG:isForeground:isBoosted:isDirty:haveWQFlags:wqExceededTotalThreadLimit:wqExceededConstrainedThreadLimit:haveMem:taskSizeInBytes:haveLatencyQos:latencyQos:](v304, v311, v291, v306, (v186 & 0x200000) != 0, ns_from_timestamp, v188, 0, 0, v189, v192, v193, v191, v194, v195, v198, v196, v197, v201,
                      v200,
                      (v199 & 0x100000) != 0,
                      v202);
LABEL_205:
                    name_for_thread = (unsigned char *)ktrace_get_name_for_thread();
                    uint64_t v204 = name_for_thread;
                    if (name_for_thread) {
                      BOOL v205 = *name_for_thread != 0;
                    }
                    else {
                      BOOL v205 = 0;
                    }
                    uint64_t v206 = *(void *)a2;
                    if ((*(void *)a2 & 0x800000) != 0)
                    {
                      uint64_t v207 = *(void *)(a2 + 6688);
                      if ((v206 & 0x10000000) != 0)
                      {
                        if (*(unsigned char *)(a2 + 7088)) {
                          uint64_t v208 = (void *)(a2 + 7088);
                        }
                        else {
                          uint64_t v208 = 0;
                        }
                        uint64_t v206 = *(void *)a2;
                        goto LABEL_216;
                      }
                    }
                    else
                    {
                      uint64_t v207 = 0;
                    }
                    uint64_t v208 = 0;
LABEL_216:
                    unint64_t v290 = v206;
                    if ((v206 & 0x40) == 0)
                    {
                      uint64_t v298 = 0;
                      unsigned __int8 v289 = 0;
                      if ((v206 & 0x80) == 0)
                      {
LABEL_218:
                        uint64_t v292 = 0;
                        id v295 = 0;
                        uint64_t v209 = 0;
                        BOOL v210 = [v311 pid] == 0;
LABEL_249:
                        uint64_t v221 = *(void *)a2;
                        unsigned int v288 = v71;
                        if ((*(void *)a2 & 0x100000) != 0)
                        {
                          [v304 setHaveKPerfSched:1];
                          int v222 = v221;
                          uint64_t v221 = ktrace_get_ns_from_timestamp();
                          uint64_t v223 = ktrace_get_ns_from_timestamp();
                          uint64_t v224 = v221;
                          LODWORD(v221) = v222;
                          char v225 = v205;
                          unsigned int v226 = *(_DWORD *)(a2 + 6616) & 0xFFFFFFFB;
                          int v227 = *(__int16 *)(a2 + 6620);
                          int v281 = *(__int16 *)(a2 + 6622);
                          unsigned int v228 = *(unsigned __int16 *)(a2 + 6624);
                          BYTE4(v280) = v228 & 7;
                          int v279 = (v228 >> 6) & 7;
                          LODWORD(v280) = (v228 >> 3) & 7;
                          uint64_t v229 = *(void *)a2;
                          if ((*(void *)a2 & 0x8000000) != 0) {
                            char v230 = *(unsigned char *)(a2 + 7080) & 7;
                          }
                          else {
                            char v230 = 0;
                          }
                        }
                        else
                        {
                          char v225 = v205;
                          uint64_t v223 = 0;
                          uint64_t v224 = 0;
                          int v227 = 0;
                          int v281 = 0;
                          unsigned int v226 = 0;
                          uint64_t v280 = 0;
                          LOBYTE(v279) = 0;
                          char v230 = 0;
                          LODWORD(v229) = *(void *)a2;
                        }
                        char v287 = v225;
                        uint64_t v285 = v208;
                        uint64_t v286 = v207;
                        char v284 = v210;
                        int v282 = v227;
                        char v278 = v230;
                        if ((v229 & 0x4000000) != 0)
                        {
                          uint64_t v231 = *(void *)(a2 + 7064);
                          uint64_t v232 = *(void *)(a2 + 7072);
                        }
                        else
                        {
                          uint64_t v231 = 0;
                          uint64_t v232 = 0;
                        }
                        uint64_t v233 = v209;
                        uint64_t v283 = v204;
                        if ((v229 & 0x400000) != 0)
                        {
                          uint64_t v275 = v223;
                          uint64_t v276 = v224;
                          unsigned __int8 v277 = v142;
                          char v234 = *(unsigned char *)(a2 + 6682);
                          unint64_t v235 = *(void *)(a2 + 6664);
                          char v236 = *(__int16 *)(a2 + 6680) > 0;
                          if ((v235 & 4) != 0 && v309) {
                            v309[16] = 1;
                          }
                          uint64_t v237 = +[SATimestamp timestampWithMachAbsTime:fromKtraceSession:]((uint64_t)SATimestamp, *(void *)(a2 + 6672));
                          uint64_t v238 = (v235 >> 1) & 1;
                          char v239 = v235 & 1;
                          uint64_t v240 = (void *)v237;
                          unsigned __int8 v142 = v277;
                          uint64_t v223 = v275;
                          uint64_t v224 = v276;
                        }
                        else
                        {
                          char v234 = 0;
                          LOBYTE(v238) = 0;
                          char v239 = 0;
                          char v236 = 0;
                          uint64_t v240 = 0;
                        }
                        -[SASampleStore backfillThread:inTask:lastSampleIndex:timestamp:haveName:name:haveDispatchQueueId:dispatchQueueId:dispatchQueueLabel:leafKernelFrame:hasExclaveInKernelStack:haveUserStack:leafUserFrame:swiftTaskId:leafOfCRootFramesReplacedBySwiftAsync:threadExclavesInfo:haveSched:systemCpuTimeNs:userCpuTimeNs:basePriority:scheduledPriority:state:threadQos:threadRequestedQos:threadRequestedQosOverride:threadQosPromote:haveCycIns:instructions:cycles:haveSnap:ioTier:isIOPassive:isDarwinBG:isSuspended:isGlobalForcedIdle:isIdleWorkQueue:lastMadeRunnableTime:isOnCore:isOnCoreForLastSampleIndex:cpuNum:](v304, v309, v311, v291, v306, v287, v283, (v290 >> 23) & 1, v286, v285, v298, v289, v284, v292, v233, v295, 0, (v221 & 0x100000) != 0, v223,
                          v224,
                          v282,
                          v281,
                          v226,
                          SBYTE4(v280),
                          v280,
                          v279,
                          v278,
                          (v229 & 0x4000000) != 0,
                          v231,
                          v232,
                          (v229 & 0x400000) != 0,
                          v234,
                          v238,
                          v239,
                          v236,
                          0,
                          0,
                          v240,
                          v307,
                          v142,
                          v288);
                        [v300 clearThreadData];
                        [v300 clearTaskData];

                        goto LABEL_264;
                      }
                      goto LABEL_234;
                    }
                    size_t v211 = *(unsigned int *)(a2 + 2164);
                    if (v211)
                    {
                      objc_msgSend(v300, "setKernelFrames:", malloc_type_calloc(v211, 8uLL, 0x100004000313F17uLL));
                      memcpy((void *)[v300 kernelFrames], (const void *)(a2 + 2168), 8 * *(unsigned int *)(a2 + 2164));
                      [v300 setNumKernelFrames:*(unsigned int *)(a2 + 2164)];
                      unsigned int v212 = *(_DWORD *)(a2 + 7376);
                      unsigned __int8 v289 = v212 != 0;
                      if (v212)
                      {
                        if (v212 == *(_DWORD *)(a2 + 2164)) {
                          uint64_t v213 = 0;
                        }
                        else {
                          uint64_t v213 = v212;
                        }
                        [v300 setExclaveInsertionIndex:v213];
                      }
                      if ((*(unsigned char *)(a2 + 2160) & 0x10) != 0) {
                        [v300 setIsKernelStackTruncated:1];
                      }
                      uint64_t v214 = -[SASampleStore lastTaskWithPid:](v304, 0);
                      if (!v214)
                      {
                        execname_for_pid = (unsigned char *)ktrace_get_execname_for_pid();
                        if (execname_for_pid && *execname_for_pid)
                        {
                          uint64_t v216 = SANSStringForCString(execname_for_pid);
                        }
                        else
                        {
                          uint64_t v216 = 0;
                        }
                        uint64_t v214 = -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v304, 0, v216, 0);
                      }
                      char v217 = [v214 binaryLoadInfos];
                      [v300 setKernelBinaryLoadInfos:v217];

                      uint64_t v298 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v214, v300, 0);

                      if ((*(void *)a2 & 0x80) == 0) {
                        goto LABEL_218;
                      }
LABEL_234:
                      size_t v218 = *(unsigned int *)(a2 + 108);
                      if (v218)
                      {
                        objc_msgSend(v300, "setUserFrames:", malloc_type_calloc(v218, 8uLL, 0x100004000313F17uLL));
                        memcpy((void *)[v300 userFrames], (const void *)(a2 + 112), 8 * *(unsigned int *)(a2 + 108));
                        [v300 setNumUserFrames:*(unsigned int *)(a2 + 108)];
                        if ((*(unsigned char *)(a2 + 104) & 0x10) != 0)
                        {
                          if ((*(unsigned char *)(a2 + 4) & 1) == 0
                            || ([v300 setIsSwiftAsyncStackTruncated:1], !*(_DWORD *)(a2 + 7328)))
                          {
                            [v300 setIsUserStackTruncated:1];
                          }
                        }
                        int v219 = *(_DWORD *)(a2 + 104);
                        if ((v219 & 0x80) != 0)
                        {
                          int v220 = -[SASampleStore addressTranslationsForPid:]((uint64_t)v304, pid_for_thread);
                          [v300 setAddressTranslations:v220];

                          int v219 = *(_DWORD *)(a2 + 104);
                        }
                        if ((v219 & 0x100) != 0) {
                          [v300 setCheckLR:1];
                        }
                        if (*(unsigned char *)(a2 + 4))
                        {
                          objc_msgSend(v300, "setSwiftAsyncFrames:", malloc_type_calloc(*(unsigned int *)(a2 + 7328), 8uLL, 0x100004000313F17uLL));
                          memcpy((void *)[v300 swiftAsyncFrames], (const void *)(a2 + 112 + 8 * *(unsigned int *)(a2 + 7324)), 8 * *(unsigned int *)(a2 + 7328));
                          [v300 setNumSwiftAsyncFrames:*(unsigned int *)(a2 + 7328)];
                          [v300 setSwiftAsyncStitchIndex:*(unsigned int *)(a2 + 7320)];
                          if ([v300 numSwiftAsyncFrames]) {
                            uint64_t v209 = -1;
                          }
                          else {
                            uint64_t v209 = 0;
                          }
                        }
                        else
                        {
                          uint64_t v209 = 0;
                        }
                        id v312 = 0;
                        uint64_t v292 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:]((uint64_t)v311, v300, &v312);
                        id v295 = v312;
                        BOOL v210 = 1;
                        goto LABEL_249;
                      }
                      goto LABEL_272;
                    }
LABEL_269:
                    int v249 = *__error();
                    long long v250 = _sa_logt();
                    if (os_log_type_enabled(v250, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_error_impl(&dword_1BF22B000, v250, OS_LOG_TYPE_ERROR, "0 rec->kstack.nframes", buf, 2u);
                    }

                    *__error() = v249;
                    _SASetCrashLogMessage(1051, "0 rec->kstack.nframes", v251, v252, v253, v254, v255, v256, v274);
                    _os_crash();
                    __break(1u);
LABEL_272:
                    int v257 = *__error();
                    uint64_t v258 = _sa_logt();
                    if (os_log_type_enabled(v258, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_error_impl(&dword_1BF22B000, v258, OS_LOG_TYPE_ERROR, "0 rec->ustack.nframes", buf, 2u);
                    }

                    *__error() = v257;
                    _SASetCrashLogMessage(1091, "0 rec->ustack.nframes", v259, v260, v261, v262, v263, v264, v274);
                    _os_crash();
                    __break(1u);
                    goto LABEL_275;
                  }
                  id v146 = v134;
                  id v145 = self;
                  if (!self)
                  {
LABEL_162:
                    id v147 = v145;

                    if (v134 == v147)
                    {
                      if (qword_1EB698F20)
                      {
                        int v155 = *__error();
                        fprintf((FILE *)qword_1EB698F20, "%'llu Adjusting backward record timestamp %lld to %lld, to match the PET sample that triggered it\n", *(void *)(a2 + 8), v74, [v134 machAbsTime]);
                        *__error() = v155;
                      }
                    }
                    else if (qword_1EB698F20)
                    {
                      id v293 = v134;
                      int v148 = *__error();
                      long long v149 = (FILE *)qword_1EB698F20;
                      uint64_t v150 = *(void *)(a2 + 8);
                      uint64_t v152 = [v293 machAbsTime];
                      id v153 = self;
                      if (self) {
                        id v153 = objc_getProperty(self, v151, 40, 1);
                      }
                      id v154 = v153;
                      fprintf(v149, "%'llu Adjusting backward record timestamp %lld to %lld, to match the PET sample it straddles, even though the most recent on-cpu sample was at %lld\n", v150, v74, v152, [v154 machAbsTime]);

                      *__error() = v148;
                      int v141 = 1;
                      id v134 = v293;
                      goto LABEL_170;
                    }
                    int v141 = 1;
LABEL_170:
                    id v139 = v134;
                    goto LABEL_171;
                  }
LABEL_161:
                  id v145 = objc_getProperty(v145, v144, 40, 1);
                  goto LABEL_162;
                }
                __int16 v98 = [v304 tasksByPid];
                uint64_t v99 = [NSNumber numberWithInt:pid_for_thread];
                unsigned int v100 = [v98 objectForKeyedSubscript:v99];

                if ((unint64_t)[v100 count] >= 2)
                {
                  double v101 = objc_msgSend(v100, "objectAtIndexedSubscript:", objc_msgSend(v100, "count") - 2);
                  uint64_t v102 = [v101 threads];
                  uint64_t v103 = [v102 objectForKeyedSubscript:v303];

                  uint64_t v309 = (unsigned char *)v103;
                  if (v103)
                  {
                    id v104 = v101;

                    uint64_t v311 = v104;
LABEL_139:

                    goto LABEL_140;
                  }
                }
                +[SAThread threadWithId:]((uint64_t)SAThread, v6);
                uint64_t v309 = (unsigned char *)objc_claimAutoreleasedReturnValue();
                uint64_t v122 = [v311 execTimestamp];

                if (v122)
                {
                  double v124 = [v311 execTimestamp];
                  if (v309) {
                    objc_setProperty_atomic(v309, v123, v124, 32);
                  }
                }
                -[SATask addThread:]((uint64_t)v311, v309);
                goto LABEL_139;
              }
            }
          }
        }
        else
        {
          if (absolute_from_timestamp) {
            goto LABEL_89;
          }
          unint64_t v75 = 0;
        }
        if (qword_1EB698F20)
        {
          int v81 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu Adjusting forward record timestamp %lld to %lld\n", *(void *)(a2 + 8), v74, v75);
          *__error() = v81;
          goto LABEL_95;
        }
        goto LABEL_99;
      }
      if (!qword_1EB698F20) {
        goto LABEL_264;
      }
      uint64_t v53 = __error();
      uint64_t v54 = *(void *)a2;
      if ((*(void *)a2 & 4) != 0)
      {
        uint64_t v55 = *(void *)(a2 + 16);
        if ((v54 & 2) != 0)
        {
LABEL_60:
          int v56 = *(_DWORD *)(a2 + 24);
          if ((v54 & 0x10) != 0)
          {
LABEL_61:
            double v57 = (uint64_t *)a2;
            int v58 = *(_DWORD *)(a2 + 48);
LABEL_79:
            uint64_t v66 = (FILE *)qword_1EB698F20;
            int v67 = *v53;
            uint64_t v68 = v57[1];
            StringForKPDecodeContentBits(v57);
            fprintf(v66, "%'llu Thread 0x%llx core %d event 0x%x skipping kperf content 0x%llx: %s\n", v68, v55, v56, v58, v54, (const char *)&qword_1EB698F30);
            *__error() = v67;
            goto LABEL_264;
          }
LABEL_78:
          int v58 = 0;
          double v57 = (uint64_t *)a2;
          goto LABEL_79;
        }
      }
      else
      {
        uint64_t v55 = 0;
        if ((v54 & 2) != 0) {
          goto LABEL_60;
        }
      }
      int v56 = -1;
      if ((v54 & 0x10) != 0) {
        goto LABEL_61;
      }
      goto LABEL_78;
    }
    if ([a1 dataStyle] != 1)
    {
      if ([a1 dataStyle])
      {
        uint64_t v11 = [a1 sampleTimestamps];
        uint64_t v12 = [v11 count];

        if (!v12) {
          goto LABEL_264;
        }
      }
    }
    uint64_t v296 = self;
    uint64_t v13 = a2;
    v302 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:*(void *)(a2 + 7360)];
    if (*(void *)(a2 + 7360))
    {
      unint64_t v14 = 0;
      while (1)
      {
        uint64_t v16 = -[SASampleStore exclaveWithIdentifier:]((uint64_t)v304, *(void *)(*(void *)(v13 + 7368) + 2064 * v14));
        uint64_t v310 = *(void *)(v13 + 7368);
        uint64_t v17 = v310 + 2064 * v14;
        unsigned int v18 = *(_DWORD *)(v17 + 12);
        uint64_t v308 = (unsigned int *)(v17 + 12);
        if (v18) {
          break;
        }
        int v27 = 0;
LABEL_49:
        id v40 = -[SAExclaveCallstack initWithExclave:leafFrame:]((id *)[SAExclaveCallstack alloc], v16, v27);
        [v302 addObject:v40];

        ++v14;
        uint64_t v13 = a2;
        if (v14 >= *(void *)(a2 + 7360)) {
          goto LABEL_50;
        }
      }
      char v19 = 0;
      unsigned int v20 = 0;
      int v21 = -1;
      while (1)
      {
        uint64_t v22 = *(void *)(v310 + 2064 * v14 + 8 * (v18 + v21) + 16);
        if (v19)
        {
          int v23 = v19[5];
          if (!v23) {
            goto LABEL_31;
          }
          id v24 = v23;
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            int v25 = v24;
            v318[0] = MEMORY[0x1E4F143A8];
            v318[1] = 3221225472;
            v318[2] = __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke;
            v318[3] = &__block_descriptor_40_e21_B24__0__SAFrame_8_B16l;
            v318[4] = v22;
            double v26 = [v25 objectsPassingTest:v318];
            int v27 = [v26 anyObject];
          }
          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              int v107 = *__error();
              unint64_t v65 = _sa_logt();
              if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
              {
                ClassName = object_getClassName(v24);
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = ClassName;
                _os_log_error_impl(&dword_1BF22B000, v65, OS_LOG_TYPE_ERROR, "child is %s", buf, 0xCu);
              }

              *__error() = v107;
              char v109 = object_getClassName(v24);
              _SASetCrashLogMessage(647, "child is %s", v110, v111, v112, v113, v114, v115, v109);
              _os_crash();
              __break(1u);
LABEL_125:
              uint64_t v116 = *(void *)a2;
              *(_DWORD *)long long buf = 134217984;
              *(void *)&uint8_t buf[4] = v116;
              _os_log_fault_impl(&dword_1BF22B000, v24, OS_LOG_TYPE_FAULT, "Exclave callstack provided with other stack info: 0x%llx", buf, 0xCu);
LABEL_75:

              *__error() = (int)v65;
              goto LABEL_264;
            }
            unint64_t v30 = v24;
            if (v22 == [v30 address]) {
              int v27 = v30;
            }
            else {
              int v27 = 0;
            }
          }
          uint64_t v29 = v24;
        }
        else
        {
          if (v16) {
            id v28 = objc_getProperty(v16, v15, 40, 1);
          }
          else {
            id v28 = 0;
          }
          uint64_t v29 = v28;
          v317[0] = MEMORY[0x1E4F143A8];
          v317[1] = 3221225472;
          v317[2] = __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke_78;
          v317[3] = &__block_descriptor_40_e21_B24__0__SAFrame_8_B16l;
          v317[4] = v22;
          id v24 = [v29 objectsPassingTest:v317];
          int v27 = [v24 anyObject];
        }

        if (!v27)
        {
LABEL_31:
          uint64_t v31 = -[SAExclaveFrame initWithExclave:]([SAExclaveFrame alloc], v16);
          p_isa = (id *)&v31->isa;
          int v27 = v31;
          if (v31) {
            v31[2].isa = (Class)v22;
          }
          uint64_t v33 = [v16 loadInfos];
          BOOL v34 = v33 == 0;

          if (!v34)
          {
            uint64_t v36 = [v16 loadInfos];
            unint64_t v37 = +[SABinaryLoadInfo binaryLoadInfoForAddress:v22 inBinaryLoadInfos:v36];
            if (v27) {
              objc_storeWeak(p_isa + 3, v37);
            }
          }
          if (v27) {
            v27[4].isa = (Class)v19;
          }
          if (v19)
          {
            -[SAFrame _addChildFrame:]((uint64_t)v19, v27);
          }
          else
          {
            if (v16) {
              id v38 = objc_getProperty(v16, v35, 40, 1);
            }
            else {
              id v38 = 0;
            }
            id v39 = v38;
            [v39 addObject:v27];
          }
        }

        ++v20;
        unsigned int v18 = *v308;
        --v21;
        char v19 = (id *)&v27->isa;
        if (v20 >= *v308) {
          goto LABEL_49;
        }
      }
    }
LABEL_50:
    int v41 = -[SAThreadExclavesInfo initWithCallstacks:]([SAThreadExclavesInfo alloc], v302);
    uint64_t v42 = *(void *)(a2 + 7344);
    uint64_t v43 = ktrace_get_pid_for_thread();
    if ((v43 & 0x80000000) != 0)
    {
      int v59 = *__error();
      uint64_t v60 = _sa_logt();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v43;
        *(_WORD *)&uint8_t buf[8] = 2048;
        *(void *)&buf[10] = v42;
        _os_log_error_impl(&dword_1BF22B000, v60, OS_LOG_TYPE_ERROR, "Invalid pid [%d] for exclave info tid 0x%llu", buf, 0x12u);
      }

      *__error() = v59;
    }
    else
    {
      id v44 = -[SASampleStore lastTaskWithPid:](v304, v43);
      id v45 = v44;
      if (v44)
      {
        uint64_t v46 = [v44 threads];
        uint64_t v47 = [NSNumber numberWithUnsignedLongLong:v42];
        long long v48 = [v46 objectForKeyedSubscript:v47];

        uint64_t v313 = 0;
        id v314 = &v313;
        uint64_t v315 = 0x2020000000;
        int v316 = 0;
        *(void *)long long buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&uint8_t buf[16] = __55__SASampleStore_KPerf__backfillExclaveFromKPerf_state___block_invoke_83;
        unint64_t v324 = &unk_1E63F7E68;
        uint64_t v327 = a2;
        id v49 = v48;
        *(void *)&long long v325 = v49;
        uint64_t v50 = v41;
        *((void *)&v325 + 1) = v50;
        uint64_t v326 = &v313;
        [v49 enumerateThreadStatesBetweenStartTime:0 startSampleIndex:0x7FFFFFFFFFFFFFFFLL endTime:0 endSampleIndex:0x7FFFFFFFFFFFFFFFLL reverseOrder:1 block:buf];
        if (!*((_DWORD *)v314 + 6))
        {
          int v51 = *__error();
          uint64_t v52 = _sa_logt();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            id v183 = [v49 debugDescription];
            unint64_t v184 = [v50 debugDescription];
            *(_DWORD *)int v319 = 138412546;
            uint64_t v320 = v183;
            __int16 v321 = 2112;
            int v322 = v184;
            _os_log_error_impl(&dword_1BF22B000, v52, OS_LOG_TYPE_ERROR, "No thread states in %@ need exclave info %@", v319, 0x16u);
          }
          *__error() = v51;
        }

        _Block_object_dispose(&v313, 8);
      }
      else
      {
        int v63 = *__error();
        id v64 = _sa_logt();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v43;
          *(_WORD *)&uint8_t buf[8] = 2048;
          *(void *)&buf[10] = v42;
          _os_log_error_impl(&dword_1BF22B000, v64, OS_LOG_TYPE_ERROR, "No task with pid [%d] for exclave info tid 0x%llx", buf, 0x12u);
        }

        *__error() = v63;
      }
    }
    if ((*(void *)a2 & 0x1000000C0) != 0)
    {
      LODWORD(v65) = *__error();
      id v24 = _sa_logt();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT)) {
        goto LABEL_125;
      }
      goto LABEL_75;
    }
LABEL_264:
  }
}

- (void)backfillTask:(unint64_t)a3 lastSampleIndex:(void *)a4 timestamp:(char)a5 haveSnap:(uint64_t)a6 terminatedThreadsUserTimeInNs:(uint64_t)a7 terminatedThreadsSystemTimeInNs:(uint64_t)a8 terminatedThreadsCycles:(uint64_t)a9 terminatedThreadsInstructions:(int)a10 suspendCount:(int)a11 pageins:(char)a12 isDarwinBG:(char)a13 isForeground:(char)a14 isBoosted:(char)a15 isDirty:(char)a16 haveWQFlags:(char)a17 wqExceededTotalThreadLimit:(char)a18 wqExceededConstrainedThreadLimit:(char)a19 haveMem:(uint64_t)a20 taskSizeInBytes:(char)a21 haveLatencyQos:(int)a22 latencyQos:
{
  int v25 = a2;
  id v26 = a4;
  unint64_t v65 = a1;
  if (a1)
  {
    uint64_t v66 = v25;
    int v67 = v26;
    int v27 = [v25 exitTimestamp];

    if (v27)
    {
      id v28 = [v25 exitTimestamp];
      char v29 = [v28 lt:v26];

      char v31 = v29 ^ 1;
      if (!v25) {
        char v31 = 1;
      }
      if ((v31 & 1) == 0) {
        objc_setProperty_atomic(v25, v30, v26, 232);
      }
    }
    if (a3 == 0x7FFFFFFFFFFFFFFFLL)
    {
      id v32 = v26;
      unint64_t v33 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_25:
      uint64_t v43 = +[SATaskState stateWithStartTimestamp:v32 endTimestamp:v26 startSampleIndex:v33 endSampleIndex:a3];
      uint64_t v60 = v32;
      if (v25)
      {
        [v25[1] addObject:v43];
        uint64_t v44 = [v25[1] count] - 1;
      }
      else
      {
        uint64_t v44 = 0;
      }
      if (qword_1EB698F20)
      {
        int v59 = *__error();
        id v45 = (FILE *)qword_1EB698F20;
        uint64_t v46 = [v67 machAbsTime];
        int v47 = [v25 pid];
        uint64_t v48 = [v43 startSampleIndex];
        uint64_t v49 = [v43 endSampleIndex];
        uint64_t v50 = [v43 startTimestamp];
        uint64_t v51 = [v50 machAbsTime];
        uint64_t v52 = [v43 endTimestamp];
        fprintf(v45, "%'llu Created taskState (index %lu) for task [%d] (sample index %ld-%ld, machabs %llu-%llu)\n", v46, v44, v47, v48, v49, v51, [v52 machAbsTime]);

        *__error() = v59;
      }

LABEL_30:
      v97[0] = 0;
      v97[1] = v97;
      v97[2] = 0x2020000000;
      char v98 = a5;
      v95[0] = 0;
      v95[1] = v95;
      v95[2] = 0x2020000000;
      char v96 = a19;
      v93[0] = 0;
      v93[1] = v93;
      v93[2] = 0x2020000000;
      char v94 = a21;
      v91[0] = 0;
      v91[1] = v91;
      void v91[2] = 0x2020000000;
      int v92 = 0;
      v68[0] = MEMORY[0x1E4F143A8];
      v68[1] = 3221225472;
      v68[2] = __380__SASampleStore_KPerfPrivate__backfillTask_lastSampleIndex_timestamp_haveSnap_terminatedThreadsUserTimeInNs_terminatedThreadsSystemTimeInNs_terminatedThreadsCycles_terminatedThreadsInstructions_suspendCount_pageins_isDarwinBG_isForeground_isBoosted_isDirty_haveWQFlags_wqExceededTotalThreadLimit_wqExceededConstrainedThreadLimit_haveMem_taskSizeInBytes_haveLatencyQos_latencyQos___block_invoke;
      v68[3] = &unk_1E63F8308;
      id v69 = v67;
      uint64_t v76 = a6;
      uint64_t v77 = a7;
      uint64_t v78 = a8;
      uint64_t v79 = a9;
      int v81 = a10;
      int v82 = a11;
      char v84 = a12;
      char v85 = a13;
      char v86 = a14;
      char v87 = a15;
      char v88 = a16;
      char v89 = a17;
      char v90 = a18;
      unint64_t v72 = v97;
      uint64_t v73 = v91;
      uint64_t v80 = a20;
      unint64_t v74 = v95;
      unint64_t v75 = v93;
      int v83 = a22;
      uint64_t v70 = v66;
      id v71 = v65;
      [v70 enumerateTaskStatesBetweenStartTime:0 startSampleIndex:0x7FFFFFFFFFFFFFFFLL endTime:0 endSampleIndex:0x7FFFFFFFFFFFFFFFLL reverseOrder:1 block:v68];

      _Block_object_dispose(v91, 8);
      _Block_object_dispose(v93, 8);
      _Block_object_dispose(v95, 8);
      _Block_object_dispose(v97, 8);

      int v25 = v66;
      id v26 = v67;
      goto LABEL_31;
    }
    BOOL v34 = [v25 taskStates];
    id v35 = [v34 lastObject];

    if (v35)
    {
      if ([v35 endSampleIndex] == 0x7FFFFFFFFFFFFFFFLL)
      {
        unint64_t v33 = 0;
LABEL_18:
        id v38 = [v65 sampleTimestamps];
        id v32 = [v38 objectAtIndexedSubscript:v33];
        goto LABEL_21;
      }
      unint64_t v33 = [v35 endSampleIndex] + 1;
      if (v33 <= a3) {
        goto LABEL_18;
      }
      id v38 = v26;
    }
    else
    {
      uint64_t v36 = [v25 execTimestamp];
      if (!v36)
      {
        id v39 = [v65 sampleTimestamps];
        id v32 = [v39 objectAtIndexedSubscript:0];

        unint64_t v33 = 0;
        goto LABEL_25;
      }
      unint64_t v33 = [v65 indexOfFirstSampleOnOrAfterTimestamp:v36];
      id v37 = v36;
      id v38 = v37;
      if (v33 <= a3)
      {
        id v32 = v37;
LABEL_21:

        if (v33 != 0x7FFFFFFFFFFFFFFFLL) {
          goto LABEL_25;
        }
LABEL_22:
        id v40 = [v25 taskStates];
        uint64_t v41 = [v40 count];

        uint64_t v60 = v32;
        if (v41)
        {
          if (qword_1EB698F20)
          {
            int v42 = *__error();
            fprintf((FILE *)qword_1EB698F20, "%'llu Not creating taskState for task [%d] at machabs %llu due to already having a task state for sample index %lu\n", [v67 machAbsTime], objc_msgSend(v25, "pid"), objc_msgSend(v67, "machAbsTime"), a3);
            *__error() = v42;
          }
        }
        else if (qword_1EB698F20)
        {
          int v53 = *__error();
          uint64_t v54 = (FILE *)qword_1EB698F20;
          uint64_t v55 = [v26 machAbsTime];
          int v56 = [v25 pid];
          uint64_t v57 = [v26 machAbsTime];
          int v58 = [v25 execTimestamp];
          fprintf(v54, "%'llu Not creating taskState for task [%d] at machabs %llu due to the task being created after sample index %lu at machabs %llu\n", v55, v56, v57, a3, [v58 machAbsTime]);

          *__error() = v53;
        }
        goto LABEL_30;
      }

      id v35 = 0;
    }

    id v32 = v38;
    goto LABEL_22;
  }
LABEL_31:
}

- (void)backfillThread:(void *)a3 inTask:(unint64_t)a4 lastSampleIndex:(void *)a5 timestamp:(char)a6 haveName:(unsigned char *)a7 name:(int)a8 haveDispatchQueueId:(uint64_t)a9 dispatchQueueId:(void *)a10 dispatchQueueLabel:(void *)a11 leafKernelFrame:(unsigned __int8)a12 hasExclaveInKernelStack:(char)a13 haveUserStack:(void *)a14 leafUserFrame:(uint64_t)a15 swiftTaskId:(void *)a16 leafOfCRootFramesReplacedBySwiftAsync:(void *)a17 threadExclavesInfo:(char)a18 haveSched:(uint64_t)a19 systemCpuTimeNs:(uint64_t)a20 userCpuTimeNs:(int)a21 basePriority:(int)a22 scheduledPriority:(int)a23 state:(char)a24 threadQos:(char)a25 threadRequestedQos:(char)a26 threadRequestedQosOverride:(char)a27 threadQosPromote:(char)a28 haveCycIns:(uint64_t)a29 instructions:(uint64_t)a30 cycles:(char)a31 haveSnap:(char)a32 ioTier:(char)a33 isIOPassive:(char)a34 isDarwinBG:(char)a35 isSuspended:(char)a36 isGlobalForcedIdle:(char)a37 isIdleWorkQueue:(void *)a38 lastMadeRunnableTime:(char)a39 isOnCore:(unsigned __int8)a40 isOnCoreForLastSampleIndex:(unsigned int)a41 cpuNum:
{
  uint64_t v202 = *MEMORY[0x1E4F143B8];
  id v143 = a2;
  id v141 = a3;
  id v142 = a5;
  id newValue = a11;
  id v138 = a14;
  id v134 = a16;
  id v140 = a17;
  id v135 = a38;
  uint64_t v131 = a1;
  if (!a1) {
    goto LABEL_99;
  }
  id v45 = [v143 exitTimestamp];

  if (v143 && v45) {
    objc_setProperty_atomic(v143, v46, v142, 40);
  }
  int v47 = [v141 exitTimestamp];

  if (v47)
  {
    uint64_t v48 = [v141 exitTimestamp];
    char v49 = [v48 lt:v142];

    char v51 = v49 ^ 1;
    if (!v141) {
      char v51 = 1;
    }
    if ((v51 & 1) == 0) {
      objc_setProperty_atomic(v141, v50, v142, 232);
    }
  }
  if (a4 == 0x7FFFFFFFFFFFFFFFLL)
  {
    id v136 = v142;
    unint64_t v52 = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_48;
  }
  int v53 = [v143 threadStates];
  uint64_t v54 = [v53 lastObject];

  if (!v54)
  {
    uint64_t v55 = [v143 creationTimestamp];
    if (v55)
    {
      unint64_t v52 = [a1 indexOfFirstSampleOnOrAfterTimestamp:v55];
      if (v52 > a4)
      {
        id v136 = v142;

        uint64_t v54 = 0;
        goto LABEL_20;
      }
      int v56 = [v131 sampleTimestamps];
      id v136 = [v56 objectAtIndexedSubscript:v52];
    }
    else
    {
      int v56 = [a1 sampleTimestamps];
      id v136 = [v56 objectAtIndexedSubscript:0];
      uint64_t v55 = 0;
      unint64_t v52 = 0;
    }

    goto LABEL_25;
  }
  if ([v54 endSampleIndex] != 0x7FFFFFFFFFFFFFFFLL)
  {
    unint64_t v52 = [v54 endSampleIndex] + 1;
    if (v52 <= a4) {
      goto LABEL_21;
    }
    id v136 = v142;
LABEL_20:

    goto LABEL_45;
  }
  unint64_t v52 = 0;
LABEL_21:
  uint64_t v55 = [v131 sampleTimestamps];
  id v136 = [v55 objectAtIndexedSubscript:v52];
LABEL_25:

  if (!a39 || v52 == 0x7FFFFFFFFFFFFFFFLL)
  {
    id v57 = v136;
    goto LABEL_44;
  }
  if (v52 < a4 || (a40 & 1) == 0)
  {
    int v58 = +[SAThreadState stateWithStartTimestamp:v136 endTimestamp:v142 startSampleIndex:v52 endSampleIndex:a4 - a40];
    uint64_t v60 = v58;
    if (v58) {
      objc_setProperty_atomic(v58, v59, newValue, 80);
    }
    if (a12) {
      [v60 setNeedsExclave:1];
    }
    -[SAThreadState setCpuNum:]((uint64_t)v60, a41);
    if (v143)
    {
      [v143[1] addObject:v60];
      uint64_t v126 = [v143[1] count] - 1;
    }
    else
    {
      uint64_t v126 = 0;
    }
    if (a40) {
      unint64_t v52 = a4;
    }
    else {
      unint64_t v52 = 0x7FFFFFFFFFFFFFFFLL;
    }
    id v57 = v142;

    if (qword_1EB698F20)
    {
      int v120 = *__error();
      double v124 = (FILE *)qword_1EB698F20;
      uint64_t v122 = [v57 machAbsTime];
      uint64_t v119 = [v143 threadId];
      uint64_t v117 = [v60 startSampleIndex];
      uint64_t v116 = [v60 endSampleIndex];
      unint64_t v137 = [v60 startTimestamp];
      uint64_t v115 = [v137 machAbsTime];
      uint64_t v61 = [v60 endTimestamp];
      uint64_t v62 = [v61 machAbsTime];
      int v63 = [v60 leafKernelFrame];
      fprintf(v124, "%'llu Created off-core threadState (index %lu) for thread 0x%llx (sample index %ld-%ld, machabs %llu-%llu) with kernel stack (leaf frame 0x%llx) exclaves:%d due to on-core thread state applying to multiple sample indexes\n", v122, v126, v119, v117, v116, v115, v62, [v63 address], a12);

      *__error() = v120;
    }

LABEL_44:
    id v136 = v57;
    if (v52 != 0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_48;
    }
LABEL_45:
    id v64 = [v143 threadStates];
    uint64_t v65 = [v64 count];

    if (v65)
    {
      if (qword_1EB698F20)
      {
        int v66 = *__error();
        fprintf((FILE *)qword_1EB698F20, "%'llu Not creating threadState for thread 0x%llx at machabs %llu due to already having a thread state for sample index %lu (kernel leaf frame 0x%llx, user leaf frame 0x%llx)\n", [v142 machAbsTime], objc_msgSend(v143, "threadId"), objc_msgSend(v142, "machAbsTime"), a4, objc_msgSend(newValue, "address"), objc_msgSend(v138, "address"));
        *__error() = v66;
      }
    }
    else if (qword_1EB698F20)
    {
      int v94 = *__error();
      uint64_t v95 = (FILE *)qword_1EB698F20;
      uint64_t v96 = [v142 machAbsTime];
      uint64_t v97 = [v143 threadId];
      uint64_t v98 = [v142 machAbsTime];
      uint64_t v99 = [v143 creationTimestamp];
      fprintf(v95, "%'llu Not creating threadState for thread 0x%llx at machabs %llu due to the thread being created after sample index %lu at machabs %llu (kernel leaf frame 0x%llx, user leaf frame 0x%llx)\n", v96, v97, v98, a4, [v99 machAbsTime], objc_msgSend(newValue, "address"), objc_msgSend(v138, "address"));

      *__error() = v94;
    }
    goto LABEL_68;
  }
  if (![v136 eq:v142])
  {
    int v100 = *__error();
    double v101 = _sa_logt();
    if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
    {
      id v102 = [v136 debugDescription];
      uint64_t v103 = [v102 UTF8String];
      id v104 = [v142 debugDescription];
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v103;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = [v104 UTF8String];
      _os_log_error_impl(&dword_1BF22B000, v101, OS_LOG_TYPE_ERROR, "Start timestamp %s vs %s", buf, 0x16u);
    }
    *__error() = v100;
    id v105 = [v136 debugDescription];
    char v106 = [v105 UTF8String];
    id v107 = [v142 debugDescription];
    [v107 UTF8String];
    _SASetCrashLogMessage(3974, "Start timestamp %s vs %s", v108, v109, v110, v111, v112, v113, v106);

    _os_crash();
    __break(1u);
  }

LABEL_48:
  if (newValue || !v140 || a39)
  {
    uint64_t v68 = +[SAThreadState stateWithStartTimestamp:v136 endTimestamp:v142 startSampleIndex:v52 endSampleIndex:a4];
    -[SAThreadState setCpuNum:]((uint64_t)v68, a41);
    if (a39)
    {
      if (v68)
      {
        v68[19] |= 0x40u;
LABEL_57:
        objc_setProperty_atomic(v68, v69, newValue, 80);
      }
    }
    else if (v68)
    {
      goto LABEL_57;
    }
    if (a12) {
      [v68 setNeedsExclave:1];
    }
    if (v143)
    {
      [v143[1] addObject:v68];
      uint64_t v127 = [v143[1] count] - 1;
    }
    else
    {
      uint64_t v127 = 0;
    }
    if (qword_1EB698F20)
    {
      int v121 = *__error();
      uint64_t v125 = (FILE *)qword_1EB698F20;
      uint64_t v123 = [v142 machAbsTime];
      if ([v68 isRunning]) {
        uint64_t v70 = "on";
      }
      else {
        uint64_t v70 = "off";
      }
      uint64_t v71 = [v143 threadId];
      uint64_t v72 = [v68 startSampleIndex];
      uint64_t v73 = [v68 endSampleIndex];
      unint64_t v74 = [v68 startTimestamp];
      uint64_t v75 = [v74 machAbsTime];
      uint64_t v76 = [v68 endTimestamp];
      uint64_t v77 = [v76 machAbsTime];
      uint64_t v78 = [v68 leafKernelFrame];
      fprintf(v125, "%'llu Created %s-core threadState (index %lu) for thread 0x%llx (sample index %ld-%ld, machabs %llu-%llu) with kernel leaf frame 0x%llx) exclaves:%d\n", v123, v70, v127, v71, v72, v73, v75, v77, [v78 address], a12);

      *__error() = v121;
    }

    goto LABEL_68;
  }
  if (qword_1EB698F20)
  {
    int v67 = *__error();
    fprintf((FILE *)qword_1EB698F20, "%'llu Not creating threadState for thread 0x%llx at machabs %llu due to only have exclave info to backfill\n", [v142 machAbsTime], objc_msgSend(v143, "threadId"), objc_msgSend(v142, "machAbsTime"));
    *__error() = v67;
  }
LABEL_68:
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2020000000;
  char v201 = a6;
  if (a7 && *a7)
  {
    int v130 = SANSStringForCString(a7);
  }
  else
  {
    int v130 = 0;
  }
  uint64_t v79 = 0;
  v198[0] = 0;
  v198[1] = v198;
  v198[2] = 0x2020000000;
  char v199 = a8;
  if (a9)
  {
    id v133 = 0;
    if (a8)
    {
      uint64_t v80 = [v141 dispatchQueues];
      int v81 = [NSNumber numberWithUnsignedLongLong:a9];
      uint64_t v79 = [v80 objectForKeyedSubscript:v81];

      if (!v79)
      {
        uint64_t v79 = +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SADispatchQueue, a9);
        -[SATask addDispatchQueue:]((uint64_t)v141, v79);
      }
      if (a10)
      {
        int v82 = [v79 dispatchQueueLabel];
        BOOL v83 = v82 == 0;

        if (v83)
        {
          char v85 = SANSStringForCString(a10);
          if (v85 && v79) {
            objc_setProperty_atomic_copy(v79, v84, v85, 32);
          }
        }
      }
      id v133 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    }
  }
  else
  {
    id v133 = 0;
  }
  v196[0] = 0;
  v196[1] = v196;
  v196[2] = 0x2020000000;
  BOOL v197 = a15 != 0;
  if (a15)
  {
    char v86 = [v141 swiftTasks];
    char v87 = [NSNumber numberWithUnsignedLongLong:a15];
    char v88 = [v86 objectForKeyedSubscript:v87];

    if (!v88)
    {
      char v88 = +[SADispatchQueue dispatchQueueWithId:]((uint64_t)SASwiftTask, a15);
      -[SATask addSwiftTask:]((uint64_t)v141, v88);
    }
    id v118 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  }
  else
  {
    char v88 = 0;
    id v118 = 0;
  }
  v194[0] = 0;
  v194[1] = v194;
  v194[2] = 0x2020000000;
  char v195 = a13;
  v192[0] = 0;
  v192[1] = v192;
  v192[2] = 0x2020000000;
  char v193 = a18;
  v190[0] = 0;
  v190[1] = v190;
  v190[2] = 0x2020000000;
  char v191 = a28;
  v188[0] = 0;
  v188[1] = v188;
  v188[2] = 0x2020000000;
  char v189 = a31;
  v186[0] = 0;
  v186[1] = v186;
  v186[2] = 0x2020000000;
  BOOL v187 = v140 != 0;
  v184[0] = 0;
  v184[1] = v184;
  v184[2] = 0x2020000000;
  int v185 = 0;
  v144[0] = MEMORY[0x1E4F143A8];
  v144[1] = 3221225472;
  v144[2] = __616__SASampleStore_KPerfPrivate__backfillThread_inTask_lastSampleIndex_timestamp_haveName_name_haveDispatchQueueId_dispatchQueueId_dispatchQueueLabel_leafKernelFrame_hasExclaveInKernelStack_haveUserStack_leafUserFrame_swiftTaskId_leafOfCRootFramesReplacedBySwiftAsync_threadExclavesInfo_haveSched_systemCpuTimeNs_userCpuTimeNs_basePriority_scheduledPriority_state_threadQos_threadRequestedQos_threadRequestedQosOverride_threadQosPromote_haveCycIns_instructions_cycles_haveSnap_ioTier_isIOPassive_isDarwinBG_isSuspended_isGlobalForcedIdle_isIdleWorkQueue_lastMadeRunnableTime_isOnCore_isOnCoreForLastSampleIndex_cpuNum___block_invoke;
  v144[3] = &unk_1E63F82E0;
  id v145 = v142;
  id v146 = v143;
  long long v157 = buf;
  id v114 = v130;
  id v147 = v114;
  long long v158 = v184;
  uint64_t v159 = v198;
  char v89 = v79;
  id v148 = v89;
  id v90 = v133;
  id v149 = v90;
  id v160 = v194;
  id v150 = v138;
  id v151 = v134;
  long long v161 = v196;
  uint64_t v166 = a15;
  id v91 = v88;
  id v152 = v91;
  id v92 = v118;
  id v153 = v92;
  id v162 = v192;
  uint64_t v167 = a19;
  uint64_t v168 = a20;
  int v171 = a23;
  int v172 = a21;
  int v173 = a22;
  char v174 = a24;
  char v175 = a25;
  char v176 = a26;
  char v177 = a27;
  uint64_t v169 = a29;
  uint64_t v170 = a30;
  uint64_t v163 = v190;
  uint64_t v164 = v188;
  char v178 = a32;
  char v179 = a33;
  char v180 = a35;
  char v181 = a34;
  char v182 = a37;
  char v183 = a36;
  id v154 = v135;
  int v165 = v186;
  id v155 = v140;
  uint64_t v156 = v131;
  [v146 enumerateThreadStatesBetweenStartTime:0 startSampleIndex:0x7FFFFFFFFFFFFFFFLL endTime:0 endSampleIndex:0x7FFFFFFFFFFFFFFFLL reverseOrder:1 block:v144];
  if (v89 && [v90 count])
  {
    if (v89[24]) {
      uint64_t v93 = 0;
    }
    else {
      uint64_t v93 = v89 + 24;
    }
    -[SARecipe addStates:hasConcurrentExecution:]((uint64_t)v89, v90, v93);
  }
  if (v91 && [v92 count]) {
    -[SARecipe addStates:hasConcurrentExecution:]((uint64_t)v91, v92, 0);
  }

  _Block_object_dispose(v184, 8);
  _Block_object_dispose(v186, 8);
  _Block_object_dispose(v188, 8);
  _Block_object_dispose(v190, 8);
  _Block_object_dispose(v192, 8);
  _Block_object_dispose(v194, 8);

  _Block_object_dispose(v196, 8);
  _Block_object_dispose(v198, 8);

  _Block_object_dispose(buf, 8);
LABEL_99:
}

- (id)applySharedCacheToTask:(uint64_t)a3 uuid:(uint64_t)a4 slide:(uint64_t)a5 slidBaseAddress:
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  int v9 = a2;
  int v10 = v9;
  if (a1)
  {
    uint64_t v11 = [v9 sharedCache];
    uint64_t v12 = v11;
    if (!v11)
    {
      uint64_t v13 = -[SASampleStore sharedCacheWithUUID:slide:slidBaseAddress:](a1, a3, a4, a5);
      if (v10)
      {
        if (v10[72])
        {
          int v19 = *__error();
          unsigned int v20 = _sa_logt();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
          {
            id v26 = [v13 debugDescription];
            int v27 = [v10 debugDescription];
            int v32 = 138412546;
            *(void *)unint64_t v33 = v26;
            *(_WORD *)&v33[8] = 2112;
            *(void *)&v33[10] = v27;
            _os_log_fault_impl(&dword_1BF22B000, v20, OS_LOG_TYPE_FAULT, "shared cache %@, though task %@ has no shared cache", (uint8_t *)&v32, 0x16u);
          }
          int v21 = 0;
          *__error() = v19;
          goto LABEL_24;
        }
        objc_setProperty_atomic(v10, v14, v13, 256);
      }
      long long v15 = v13;
      uint64_t v13 = v15;
LABEL_23:
      int v21 = v15;
LABEL_24:

      goto LABEL_25;
    }
    if ([v11 matchesUUID:a3 slide:a4 slidBaseAddress:a5])
    {
      uint64_t v13 = 0;
LABEL_22:
      long long v15 = v12;
      goto LABEL_23;
    }
    uint64_t v13 = uuidForBytes(a3);
    uint64_t v16 = [v12 uuid];
    int v17 = [v16 isEqual:v13];

    if (v17)
    {
      uint64_t v18 = [v12 slidBaseAddress];
      if (a5 != -1 && v18 == -1)
      {
        -[SASharedCache setSlidBaseAddress:](v12, a5);
        goto LABEL_22;
      }
      uint64_t v22 = [v12 slide];
      if (a4 != -1 && v22 == -1)
      {
        -[SASharedCache setSlide:](v12, a4);
        goto LABEL_22;
      }
      int v23 = *__error();
      id v24 = _sa_logt();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      {
        id v28 = [v10 sharedCache];
        char v29 = [v28 debugDescription];
        int v32 = 68158722;
        *(_DWORD *)unint64_t v33 = 16;
        *(_WORD *)&v33[4] = 2096;
        *(void *)&v33[6] = a3;
        *(_WORD *)&v33[14] = 2048;
        *(void *)&v33[16] = a4;
        __int16 v34 = 2048;
        uint64_t v35 = a5;
        __int16 v36 = 2112;
        id v37 = v29;
        _os_log_fault_impl(&dword_1BF22B000, v24, OS_LOG_TYPE_FAULT, "Mismatching shared cache %{uuid_t}.16P slide 0x%llx slideBaseAddress 0x%llx, but task already has %@", (uint8_t *)&v32, 0x30u);
      }
    }
    else
    {
      int v23 = *__error();
      id v24 = _sa_logt();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      {
        unint64_t v30 = [v10 sharedCache];
        char v31 = [v30 debugDescription];
        int v32 = 68158722;
        *(_DWORD *)unint64_t v33 = 16;
        *(_WORD *)&v33[4] = 2096;
        *(void *)&v33[6] = a3;
        *(_WORD *)&v33[14] = 2048;
        *(void *)&v33[16] = a4;
        __int16 v34 = 2048;
        uint64_t v35 = a5;
        __int16 v36 = 2112;
        id v37 = v31;
        _os_log_fault_impl(&dword_1BF22B000, v24, OS_LOG_TYPE_FAULT, "Mismatching shared cache %{uuid_t}.16P slide 0x%llx slideBaseAddress 0x%llx, but task already has %@", (uint8_t *)&v32, 0x30u);
      }
    }

    *__error() = v23;
    goto LABEL_22;
  }
  int v21 = 0;
LABEL_25:

  return v21;
}

- (uint64_t)checkDyldInfoCompletion:(uint64_t)a1
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v5 = v3;
  uint64_t v6 = 0;
  if (a1 && v3)
  {
    if (*((unsigned char *)v3 + 9) && (*((unsigned char *)v3 + 10) || v3[5] + 1 < 2))
    {
      id v7 = objc_getProperty(v3, v4, 48, 1);
      if (v7 || v5[5] + 1 < 2)
      {
      }
      else
      {
        id v27 = objc_getProperty(v5, v8, 24, 1);
        if (v27)
        {
          unint64_t v28 = v5[4];

          if (v28)
          {
            int v29 = *__error();
            unint64_t v30 = _sa_logt();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              id v38 = [v5 debugDescription];
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = [v38 UTF8String];
              _os_log_error_impl(&dword_1BF22B000, v30, OS_LOG_TYPE_ERROR, "bad complete dyld info: %s", buf, 0xCu);
            }
            *__error() = v29;
            goto LABEL_37;
          }
        }
      }
      if (qword_1EB698F20)
      {
        int v10 = *__error();
        uint64_t v11 = (FILE *)qword_1EB698F20;
        id v12 = [v5 debugDescription];
        fprintf(v11, "%'llu %s\n\n", 0, (const char *)[v12 UTF8String]);

        *__error() = v10;
      }
      id v13 = objc_getProperty(v5, v9, 16, 1);
      unint64_t v14 = v5[4];
      id v16 = objc_getProperty(v5, v15, 24, 1);
      int v17 = v16;
      if (v5[1])
      {
        *(_OWORD *)long long buf = 0uLL;
        [v16 getUUIDBytes:buf];
        id v26 = -[SASampleStore applySharedCacheToTask:uuid:slide:slidBaseAddress:](a1, v13, (uint64_t)buf, -1, v14);
      }
      else
      {
        uint64_t v18 = [v13 sharedCache];
        unsigned int v20 = v18;
        if (!v18
          || [v18 startAddress] == -1
          || v14 < [v20 startAddress]
          || v14 >= [v20 endAddress])
        {
          id v22 = objc_getProperty(v5, v19, 48, 1);
          if (v22)
          {
            uint64_t v23 = objc_msgSend(objc_getProperty(v5, v21, 48, 1), "length");

            if (v23)
            {
              id Property = objc_getProperty(v5, v24, 48, 1);
              SACachedNSString(Property);
              id v22 = (id)objc_claimAutoreleasedReturnValue();
            }
            else
            {
              id v22 = 0;
            }
          }
          if ([v22 isAbsolutePath]) {
            id v31 = v22;
          }
          else {
            id v31 = 0;
          }
          int v32 = +[SABinary binaryWithUUID:v17 absolutePath:v31];
          unint64_t v33 = +[SABinaryLoadInfo binaryLoadInfoWithBinary:loadAddress:isInKernelAddressSpace:exclave:]((uint64_t)SABinaryLoadInfo, v32, v14, [v13 pid] == 0, 0);
          __int16 v34 = [v32 path];

          if (v22 && !v34 && v32) {
            objc_setProperty_atomic_copy(v32, v35, v22, 80);
          }
          __int16 v36 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1C978]), "initWithObjects:", v33, 0);
          -[SATask addImageInfos:]((uint64_t)v13, v36);
        }
      }

LABEL_37:
      uint64_t v6 = 1;
      goto LABEL_38;
    }
    uint64_t v6 = 0;
  }
LABEL_38:

  return v6;
}

- (void)_addKPerfDataFromKTraceSession:(uint64_t)a3 beforeMachAbsTime:(int)a4 petTimerID:
{
  uint64_t v8 = objc_alloc_init(SAFrameIterator);
  [(SAFrameIterator *)v8 setBacktracer:1];
  self;
  int v9 = [SAKPerfState alloc];
  if (v9)
  {
    v123.receiver = v9;
    v123.super_class = (Class)SAKPerfState;
    int v10 = objc_msgSendSuper2(&v123, sel_init);
    uint64_t v11 = v10;
    if (v10)
    {
      v10[3] = a2;
      *((_DWORD *)v10 + 5) = a4;
      id v12 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
      id v13 = (void *)v11[1];
      v11[1] = v12;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  id v14 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  v123.receiver = 0;
  v123.super_class = (Class)&v123;
  uint64_t v124 = 0x2020000000;
  uint64_t v125 = 0;
  objc_msgSend(a1, "kPerfPETSampleIntervalLimit", v14, v11);
  double v16 = v15;
  uint64_t v17 = [a1 machTimebase];
  uint64_t v18 = 0;
  if (v17)
  {
    if (HIDWORD(v17))
    {
      uint64_t v18 = (unint64_t)(v16 * 1000000000.0);
      if (HIDWORD(v17) != v17) {
        uint64_t v18 = __udivti3();
      }
    }
  }
  uint64_t v113 = MEMORY[0x1E4F143A8];
  uint64_t v114 = 3221225472;
  uint64_t v115 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke;
  uint64_t v116 = &unk_1E63F7E90;
  uint64_t v120 = a2;
  uint64_t v121 = a3;
  uint64_t v122 = v18;
  uint64_t v119 = &v123;
  uint64_t v117 = a1;
  id v118 = v11;
  ktrace_events_single();
  uint64_t v105 = MEMORY[0x1E4F143A8];
  uint64_t v106 = 3221225472;
  id v107 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_2;
  uint64_t v108 = &unk_1E63F7EB8;
  uint64_t v112 = a3;
  uint64_t v111 = a2;
  uint64_t v109 = a1;
  uint64_t v110 = v118;
  ktrace_events_single();
  uint64_t v97 = MEMORY[0x1E4F143A8];
  uint64_t v98 = 3221225472;
  uint64_t v99 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_3;
  int v100 = &unk_1E63F7EE0;
  id v101 = v14;
  id v102 = a1;
  uint64_t v103 = v110;
  uint64_t v104 = a2;
  ktrace_events_single();
  uint64_t v88 = MEMORY[0x1E4F143A8];
  uint64_t v89 = 3221225472;
  id v90 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_139;
  id v91 = &unk_1E63F7F08;
  uint64_t v96 = a3;
  uint64_t v95 = a2;
  id v92 = a1;
  uint64_t v93 = v103;
  int v94 = v8;
  ktrace_kperf();
  uint64_t v82 = MEMORY[0x1E4F143A8];
  uint64_t v83 = 3221225472;
  char v84 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_143;
  char v85 = &unk_1E63F7F30;
  char v86 = a1;
  char v87 = v93;
  ktrace_events_single();
  id v27 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:1];
  int v19 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:1];
  id v26 = v94;
  uint64_t v72 = MEMORY[0x1E4F143A8];
  uint64_t v73 = 3221225472;
  unint64_t v74 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_2_144;
  uint64_t v75 = &unk_1E63F7F58;
  uint64_t v81 = a3;
  uint64_t v80 = a2;
  uint64_t v76 = a1;
  id v77 = v19;
  id v78 = v27;
  uint64_t v79 = v87;
  ktrace_events_single();
  uint64_t v63 = MEMORY[0x1E4F143A8];
  uint64_t v64 = 3221225472;
  uint64_t v65 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_3_147;
  int v66 = &unk_1E63F7F80;
  uint64_t v70 = a2;
  uint64_t v71 = a3;
  id v20 = v78;
  id v67 = v20;
  uint64_t v68 = a1;
  id v69 = v79;
  ktrace_events_single();
  uint64_t v54 = MEMORY[0x1E4F143A8];
  uint64_t v55 = 3221225472;
  int v56 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_4;
  id v57 = &unk_1E63F7F80;
  uint64_t v61 = a2;
  uint64_t v62 = a3;
  id v58 = v77;
  int v59 = a1;
  uint64_t v60 = v69;
  ktrace_events_single();
  uint64_t v45 = MEMORY[0x1E4F143A8];
  uint64_t v46 = 3221225472;
  int v47 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_5;
  uint64_t v48 = &unk_1E63F7F80;
  uint64_t v52 = a2;
  uint64_t v53 = a3;
  id v21 = v58;
  id v49 = v21;
  uint64_t v50 = a1;
  char v51 = v60;
  ktrace_events_single();
  uint64_t v37 = MEMORY[0x1E4F143A8];
  uint64_t v38 = 3221225472;
  id v39 = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_6;
  uint64_t v40 = &unk_1E63F7EB8;
  uint64_t v43 = a2;
  uint64_t v44 = a3;
  uint64_t v41 = a1;
  id v42 = v51;
  ktrace_events_single();
  v32[5] = MEMORY[0x1E4F143A8];
  v32[6] = 3221225472;
  v32[7] = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_7;
  v32[8] = &unk_1E63F7F80;
  uint64_t v35 = a2;
  uint64_t v36 = a3;
  v32[9] = a1;
  id v22 = v42;
  id v33 = v22;
  id v23 = v101;
  id v34 = v23;
  ktrace_events_range();
  id v24 = [a1 osProductName];
  char v25 = SAIsEmbeddedPlatform(v24);

  if (a1) {
    a1[326] = v25 ^ 1;
  }
  v32[0] = MEMORY[0x1E4F143A8];
  v32[1] = 3221225472;
  v32[2] = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_8;
  v32[3] = &unk_1E63F7FA8;
  void v32[4] = a1;
  +[SAGesture parseKTrace:embedded:findingGestureAndHIDEvents:]((uint64_t)SAGesture, a2, v25, v32);
  v31[0] = MEMORY[0x1E4F143A8];
  v31[1] = 3221225472;
  v31[2] = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_9;
  v31[3] = &unk_1E63F7FD0;
  v31[4] = a1;
  +[SAIOEvent parseKTrace:findingIOEvents:]((uint64_t)SAIOEvent, a2, v31);
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_10;
  v30[3] = &unk_1E63F7FF8;
  v30[4] = a1;
  +[SAMemoryPressureEvent parseKTrace:findingMemoryPressureEvents:]((uint64_t)SAMemoryPressureEvent, a2, v30);
  id v28 = v22;
  id v29 = v23;
  ktrace_events_single();

  _Block_object_dispose(&v123, 8);
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke(uint64_t a1, uint64_t *a2)
{
  unint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(void *)(a1 + 64))
  {
    unint64_t v5 = absolute_from_timestamp;
    if (a2[2] && (uint64_t v6 = *(void *)(a1 + 72)) != 0)
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
      unint64_t v8 = *(void *)(v7 + 24);
      if (absolute_from_timestamp >= v8)
      {
        if (!v8)
        {
          *(void *)(v7 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = absolute_from_timestamp;
          uint64_t v6 = *(void *)(a1 + 72);
          uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
          unint64_t v8 = *(void *)(v7 + 24);
        }
        int v35 = 0;
        *(void *)(v7 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v6 + v8;
      }
      else
      {
        int v35 = 1;
      }
    }
    else
    {
      int v35 = 0;
    }
    uint64_t v9 = *(void *)(a1 + 32);
    int v10 = *(id *)(a1 + 40);
    uint64_t v11 = v10;
    if (!v9) {
      goto LABEL_47;
    }
    if (a2[2])
    {
      BOOL v12 = 1;
      if (!v10) {
        goto LABEL_20;
      }
    }
    else
    {
      if (!v10)
      {
        BOOL v12 = 1;
        goto LABEL_20;
      }
      uint64_t v13 = *((unsigned int *)v10 + 5);
      BOOL v12 = (v13 & 0x80000000) == 0 && a2[1] == v13;
    }
    v10[16] = v12;
    BOOL v12 = 0;
LABEL_20:
    double v15 = +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, (uint64_t)a2);
    if (!v12) {
      objc_setProperty_atomic(v11, v14, v15, 40);
    }

    if (v35) {
      goto LABEL_38;
    }
    if ([(id)v9 dataStyle] == 1 || !objc_msgSend((id)v9, "dataStyle"))
    {
      *(void *)(v9 + 32) = [(id)v9 numSamples] + 1;
      uint64_t v18 = [(id)v9 startTime];

      if (!v18)
      {
        if (v12) {
          id Property = 0;
        }
        else {
          id Property = objc_getProperty(v11, v19, 40, 1);
        }
        -[SASampleStore setStartTime:](v9, Property);
      }
      if (v12) {
        id v21 = 0;
      }
      else {
        id v21 = objc_getProperty(v11, v19, 40, 1);
      }
      -[SASampleStore setEndTime:](v9, v21);
      goto LABEL_38;
    }
    if (!v12 && (v11[16] & 1) != 0) {
      goto LABEL_29;
    }
    if ([(id)v9 dataSource] == 2) {
      goto LABEL_38;
    }
    if (v12) {
      id v17 = 0;
    }
    else {
LABEL_29:
    }
      id v17 = objc_getProperty(v11, v16, 40, 1);
    [*(id *)(v9 + 24) addObject:v17];
LABEL_38:
    if (qword_1EB698F20)
    {
      id v22 = __error();
      id v23 = "non-PET";
      if (!v12 && (v11[16] & 1) != 0) {
        id v23 = "PET";
      }
      id v24 = (FILE *)qword_1EB698F20;
      int v25 = *v22;
      uint64_t v26 = *a2;
      id v27 = [(id)v9 sampleTimestamps];
      uint64_t v29 = [v27 count];
      if (v12) {
        id v30 = 0;
      }
      else {
        id v30 = objc_getProperty(v11, v28, 40, 1);
      }
      id v31 = [v30 debugDescription];
      int v32 = (const char *)[v31 UTF8String];
      id v33 = "";
      if (v35) {
        id v33 = " (ignored)";
      }
      fprintf(v24, "%'llu \n\n%s Sample %ld at %s%s\n\n", v26, v23, v29 - 1, v32, v33);

      *__error() = v25;
    }
LABEL_47:

    uint64_t v34 = *(void *)(a1 + 40);
    if (v34) {
      *(void *)(v34 + 32) = v5;
    }
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_2(uint64_t a1, uint64_t a2)
{
  unint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(void *)(a1 + 56))
  {
    unint64_t v5 = absolute_from_timestamp;
    uint64_t v6 = *(void *)(a1 + 32);
    id v7 = *(id *)(a1 + 40);
    unint64_t v8 = v7;
    if (v6)
    {
      -[SAKPerfState nextSampleForThread:isOnCore:]((uint64_t)v7, *(void *)(a2 + 40), 1);
      if (qword_1EB698F20)
      {
        int v9 = *__error();
        fprintf((FILE *)qword_1EB698F20, "%'llu PERF_TMR_Handler on thread 0x%llx core %d\n", *(void *)a2, *(void *)(a2 + 40), *(_DWORD *)(a2 + 52));
        *__error() = v9;
      }
    }

    uint64_t v10 = *(void *)(a1 + 40);
    if (v10) {
      *(void *)(v10 + 32) = v5;
    }
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_3(void *a1, uint64_t a2)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  id v4 = (void *)a1[4];
  unint64_t v5 = [NSNumber numberWithUnsignedLongLong:*(void *)(a2 + 40)];
  uint64_t v6 = [v4 objectForKeyedSubscript:v5];

  int v8 = *(_DWORD *)(a2 + 48);
  if ((v8 & 1) == 0)
  {
    if (!v6) {
      goto LABEL_49;
    }
    if (objc_getProperty((id)v6, v7, 48, 1))
    {
      uint64_t v10 = KTraceStringFromArguments(a1[7], a2, 1u);
      if (v10)
      {
        objc_msgSend(objc_getProperty((id)v6, v9, 48, 1), "appendString:", v10);
      }
      else if (qword_1EB698F20)
      {
        int v15 = *__error();
        double v16 = (FILE *)qword_1EB698F20;
        uint64_t v17 = *(void *)a2;
        uint64_t v18 = *(void *)(a2 + 40);
        id v19 = [(id)v6 debugDescription];
        fprintf(v16, "%'llu WARNING: Continuation for dyld info is empty string on thread 0x%llx: %s\n", v17, v18, (const char *)[v19 UTF8String]);

        *__error() = v15;
      }
    }
    goto LABEL_45;
  }
  if ((!*(void *)(a2 + 8) || (*(void *)(a2 + 8) & 0xFFFF0000) == 0x1F050000)
    && ((v8 & 2) == 0 || *(void *)(a2 + 24)))
  {
    uint64_t v11 = *(void **)(a2 + 16);
    if (v6)
    {
      BOOL v12 = *(void **)(v6 + 40);
      if (v12) {
        BOOL v13 = v12 == v11;
      }
      else {
        BOOL v13 = 1;
      }
      if (v13)
      {
        id v14 = (id *)v6;
        goto LABEL_33;
      }
      id v20 = (void *)a1[4];
      id v21 = [NSNumber numberWithUnsignedLongLong:*(void *)(a2 + 40)];
      [v20 setObject:0 forKeyedSubscript:v21];
    }
    *(_DWORD *)long long buf = -1;
    uint64_t v22 = a1[6];
    if (v22) {
      uint64_t v23 = *(void *)(v22 + 24);
    }
    else {
      uint64_t v23 = 0;
    }
    uint64_t v24 = -[SASampleStore existingTaskForEvent:inSession:returningPid:]((void *)a1[5], a2, v23, buf);
    int v25 = (void *)v24;
    if ((*(_DWORD *)buf & 0x80000000) == 0)
    {
      if (!v24)
      {
        execname_for_thread = (unsigned char *)ktrace_get_execname_for_thread();
        if (execname_for_thread && *execname_for_thread)
        {
          id v27 = SANSStringForCString(execname_for_thread);
        }
        else
        {
          id v27 = 0;
        }
        int v25 = -[SASampleStore taskForPid:andName:didExecAtTimestamp:]((void *)a1[5], *(unsigned int *)buf, v27, 0);
      }
      id v14 = -[SADyldInfo initWithTask:]((id *)[SADyldInfo alloc], v25);
      uint64_t v29 = (void *)a1[4];
      id v30 = [NSNumber numberWithUnsignedLongLong:*(void *)(a2 + 40)];
      [v29 setObject:v14 forKeyedSubscript:v30];

      if (!v14)
      {
        uint64_t v6 = 0;
        char v31 = 1;
        goto LABEL_34;
      }
LABEL_33:
      char v31 = 0;
      v14[5] = v11;
      uint64_t v6 = (uint64_t)v14;
LABEL_34:
      KTraceStringFromArguments(a1[7], a2, 3u);
      id v33 = (id)objc_claimAutoreleasedReturnValue();
      if (!v33)
      {
        if (qword_1EB698F20)
        {
          int v34 = *__error();
          int v35 = (FILE *)qword_1EB698F20;
          uint64_t v36 = *(void *)a2;
          uint64_t v37 = *(void *)(a2 + 40);
          id v38 = [(id)v6 debugDescription];
          fprintf(v35, "%'llu WARNING: Start for dyld info is empty string on thread 0x%llx: %s\n", v36, v37, (const char *)[v38 UTF8String]);

          *__error() = v34;
        }
        id v33 = objc_alloc_init(MEMORY[0x1E4F28E78]);
      }
      if ((v31 & 1) == 0)
      {
        if (objc_getProperty((id)v6, v32, 48, 1))
        {
          int v40 = *__error();
          uint64_t v41 = _sa_logt();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
          {
            id Property = objc_getProperty((id)v6, v42, 48, 1);
            *(_DWORD *)long long buf = 138412546;
            id v47 = Property;
            __int16 v48 = 2112;
            id v49 = v33;
            _os_log_debug_impl(&dword_1BF22B000, v41, OS_LOG_TYPE_DEBUG, "Throwing out previous path %@ for new path %@", buf, 0x16u);
          }

          *__error() = v40;
        }
        objc_setProperty_atomic((id)v6, v39, v33, 48);
        *(unsigned char *)(v6 + 10) = 0;
      }

LABEL_45:
      if ((*(unsigned char *)(a2 + 48) & 2) != 0)
      {
        if (v6)
        {
          *(unsigned char *)(v6 + 10) = 1;
          if (-[SASampleStore checkDyldInfoCompletion:](a1[5], (void *)v6))
          {
            uint64_t v43 = (void *)a1[4];
            uint64_t v44 = [NSNumber numberWithUnsignedLongLong:*(void *)(a2 + 40)];
            [v43 setObject:0 forKeyedSubscript:v44];
          }
        }
      }
      goto LABEL_49;
    }
    if (qword_1EB698F20)
    {
      int v28 = *__error();
      fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Unable to determine pid for dyld string on thread 0x%llx: %d\n", *(void *)a2, *(void *)(a2 + 40), *(_DWORD *)buf);
      *__error() = v28;
    }

    uint64_t v6 = 0;
  }
LABEL_49:
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_139(uint64_t a1, unsigned char *a2)
{
  if (a2)
  {
    if (*a2)
    {
      unint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
      if (absolute_from_timestamp < *(void *)(a1 + 64))
      {
        unint64_t v5 = absolute_from_timestamp;
        -[SASampleStore kperfRecord:state:frameIterator:](*(void **)(a1 + 32), (uint64_t)a2, *(void **)(a1 + 40), *(void **)(a1 + 48));
        uint64_t v6 = *(void *)(a1 + 40);
        if (v6)
        {
          if (v5 > *(void *)(v6 + 32)) {
            *(void *)(v6 + 32) = v5;
          }
        }
      }
    }
  }
  else
  {
    int v7 = *__error();
    int v8 = _sa_logt();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v15 = 0;
      _os_log_error_impl(&dword_1BF22B000, v8, OS_LOG_TYPE_ERROR, "NULL rec", v15, 2u);
    }

    *__error() = v7;
    _SASetCrashLogMessage(1852, "NULL rec", v9, v10, v11, v12, v13, v14, v15[0]);
    _os_crash();
    __break(1u);
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_143(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 8) & 1) == 0)
  {
    id v3 = *(void **)(a1 + 32);
    id v4 = *(id *)(a1 + 40);
    if (v3)
    {
      uint64_t v17 = v4;
      if (v4) {
        uint64_t v5 = v4[3];
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = -[SASampleStore existingTaskForEvent:inSession:returningPid:](v3, a2, v5, 0);
      int v7 = v6;
      if (v6)
      {
        int v8 = [v6 threads];
        uint64_t v9 = [NSNumber numberWithUnsignedLongLong:*(void *)(a2 + 40)];
        uint64_t v10 = [v8 objectForKeyedSubscript:v9];

        if (v10)
        {
          uint64_t v11 = [v10 threadStates];
          uint64_t v12 = [v11 lastObject];

          if (v12)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0 && ([v12 filledUserStack] & 1) == 0)
            {
              if (qword_1EB698F20)
              {
                int v13 = *__error();
                uint64_t v14 = (FILE *)qword_1EB698F20;
                uint64_t v15 = *(void *)a2;
                id v16 = [v7 debugDescription];
                fprintf(v14, "%'llu WARNING: KPerf had an error getting user stack for task %s thread 0x%llx\n", v15, (const char *)[v16 UTF8String], *(void *)(a2 + 40));

                *__error() = v13;
              }
              [v12 setFilledUserStack:1];
            }
          }
        }
      }

      id v4 = v17;
    }
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_2_144(uint64_t a1, uint64_t a2)
{
  unint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(void *)(a1 + 72))
  {
    unint64_t v5 = absolute_from_timestamp;
    unsigned int v19 = -1;
    id v6 = -[SASampleStore existingTaskForEvent:inSession:returningPid:](*(void **)(a1 + 32), a2, *(void *)(a1 + 64), &v19);
    unsigned int v7 = v19;
    if ((v19 & 0x80000000) != 0)
    {
      if (qword_1EB698F20)
      {
        int v18 = *__error();
        fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Unable to determine old pid for TRACE_DATA_NEWTHREAD on thread 0x%llx: %d\n", *(void *)a2, *(void *)(a2 + 40), v19);
        *__error() = v18;
      }
    }
    else
    {
      unint64_t v8 = *(void *)(a2 + 8);
      int v9 = *(_DWORD *)(a2 + 16);
      if (v19 == v9 && *(void *)(a2 + 24))
      {
        uint64_t v10 = [NSNumber numberWithInt:v19];
        uint64_t v11 = *(void **)(a1 + 40);
        uint64_t v12 = [NSNumber numberWithUnsignedLongLong:v8];
        [v11 setObject:v10 forKeyedSubscript:v12];
      }
      else
      {
        uint64_t v10 = objc_alloc_init(SANewThreadInfo);
        int v13 = +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, a2);
        uint64_t v15 = v13;
        if (v10)
        {
          objc_setProperty_atomic(v10, v14, v13, 16);

          v10->_newTid = v8;
          v10->_oldPid = v7;
          v10->_newPid = v9;
        }
        else
        {
        }
        id v16 = *(void **)(a1 + 48);
        uint64_t v12 = [NSNumber numberWithUnsignedLongLong:*(void *)(a2 + 40)];
        [v16 setObject:v10 forKeyedSubscript:v12];
      }

      uint64_t v17 = *(void *)(a1 + 56);
      if (v17) {
        *(void *)(v17 + 32) = v5;
      }
    }
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_3_147(void *a1, uint64_t a2)
{
  unint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp >= a1[8]) {
    return;
  }
  unint64_t v5 = absolute_from_timestamp;
  id v6 = (void *)a1[4];
  unsigned int v7 = [NSNumber numberWithUnsignedLongLong:*(void *)(a2 + 40)];
  id v48 = [v6 objectForKeyedSubscript:v7];

  if (v48)
  {
    unint64_t v8 = KTraceStringFromArguments(a1[7], a2, 1u);
    int v9 = v8;
    if (v8)
    {
      uint64_t v10 = SACachedNSString(v8);
    }
    else
    {
      uint64_t v10 = 0;
    }
    uint64_t v11 = (void *)a1[5];
    uint64_t v12 = (uint64_t *)v48;
    id v14 = v10;
    if (!v11)
    {
LABEL_36:

      id v39 = (void *)a1[4];
      int v40 = [NSNumber numberWithUnsignedLongLong:*(void *)(a2 + 40)];
      [v39 setObject:0 forKeyedSubscript:v40];

      goto LABEL_37;
    }
    uint64_t v46 = v12[3];
    uint64_t v16 = *((unsigned int *)v12 + 2);
    uint64_t v15 = *((unsigned int *)v12 + 3);
    id newValue = objc_getProperty(v12, v13, 16, 1);
    if (v16 == v15)
    {
      uint64_t v17 = -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v11, v16, v14, 0);
      if (!qword_1EB698F20)
      {
        int v25 = (_DWORD *)v17;
LABEL_31:
        id v33 = [v25 threads];
        int v34 = [NSNumber numberWithUnsignedLongLong:v46];
        int v35 = [v33 objectForKeyedSubscript:v34];

        if (!v35)
        {
          uint64_t v36 = +[SAThread threadWithId:]((uint64_t)SAThread, v46);
          id v38 = v36;
          if (v36) {
            objc_setProperty_atomic(v36, v37, newValue, 32);
          }
          -[SATask addThread:]((uint64_t)v25, v38);
        }
        goto LABEL_36;
      }
      uint64_t v44 = (void *)v17;
      int v18 = *__error();
      unsigned int v19 = (FILE *)qword_1EB698F20;
      uint64_t v20 = [newValue machAbsTime];
      id v21 = [v44 debugDescription];
      fprintf(v19, "%'llu %s creating thread 0x%llx\n", v20, (const char *)[v21 UTF8String], v46);

      *__error() = v18;
LABEL_30:
      int v25 = v44;
      goto LABEL_31;
    }
    uint64_t v22 = -[SASampleStore lastTaskWithPid:](v11, v15);
    uint64_t v23 = (uint64_t)v22;
    if (v22)
    {
      uint64_t v24 = [v22 exitTimestamp];
      if (v24)
      {

        if (v15)
        {
          uint64_t v45 = (void *)v23;
          BOOL v43 = v16 == 0;
          goto LABEL_19;
        }
      }
    }
    else
    {
      if (v15)
      {
        uint64_t v45 = 0;
        if (!v16)
        {
          if (qword_1EB698F20)
          {
            int v42 = *__error();
            fprintf((FILE *)qword_1EB698F20, "%'llu kernel creating thread 0x%llx in process [%d]\n", [newValue machAbsTime], v46, v15);
            id v27 = 0;
            *__error() = v42;
          }
          else
          {
            id v27 = 0;
          }
          BOOL v43 = 1;
LABEL_22:
          -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v11, v15, v14, v27);
          int v25 = (_DWORD *)objc_claimAutoreleasedReturnValue();

          char v28 = v43;
          if (!v25) {
            char v28 = 1;
          }
          if ((v28 & 1) == 0) {
            v25[20] = v16;
          }

          goto LABEL_31;
        }
        BOOL v43 = 0;
LABEL_19:
        if (qword_1EB698F20)
        {
          int v26 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu [%d] creating thread 0x%llx in new process [%d]\n", [newValue machAbsTime], v16, v46, v15);
          *__error() = v26;
        }
        id v27 = newValue;
        goto LABEL_22;
      }
      uint64_t v23 = -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v11, 0, v14, 0);
    }
    if (!qword_1EB698F20)
    {
      int v25 = (_DWORD *)v23;
      goto LABEL_31;
    }
    uint64_t v44 = (void *)v23;
    int v29 = *__error();
    id v30 = (FILE *)qword_1EB698F20;
    uint64_t v31 = [newValue machAbsTime];
    id v32 = [v44 debugDescription];
    fprintf(v30, "%'llu Task [%d] creating thread 0x%llx in other process %s\n", v31, v16, v46, (const char *)[v32 UTF8String]);

    *__error() = v29;
    goto LABEL_30;
  }
LABEL_37:
  uint64_t v41 = a1[6];
  if (v41) {
    *(void *)(v41 + 32) = v5;
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_4(uint64_t a1, uint64_t *a2)
{
  unint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(void *)(a1 + 64))
  {
    unint64_t v5 = absolute_from_timestamp;
    id v6 = *(void **)(a1 + 32);
    unint64_t v7 = 0x1E4F28000uLL;
    unint64_t v8 = [NSNumber numberWithUnsignedLongLong:a2[5]];
    id v37 = [v6 objectForKeyedSubscript:v8];

    if (v37) {
      uint64_t v9 = [v37 intValue];
    }
    else {
      uint64_t v9 = 0xFFFFFFFFLL;
    }
    uint64_t v10 = *(void **)(a1 + 40);
    uint64_t v11 = *(id *)(a1 + 48);
    uint64_t v12 = v11;
    unsigned int v38 = v9;
    if (v10)
    {
      if (v9 == -1)
      {
        if (v11) {
          uint64_t v14 = v11[3];
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v13 = -[SASampleStore existingTaskForEvent:inSession:returningPid:](v10, (uint64_t)a2, v14, &v38);
      }
      else
      {
        uint64_t v13 = -[SASampleStore lastTaskWithPid:](v10, v9);
      }
      uint64_t v15 = (void *)v13;
      if ((v38 & 0x80000000) != 0)
      {
        if (qword_1EB698F20)
        {
          int v28 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Unable to determine pid for exec on thread 0x%llx: %d\n", *a2, a2[5], v38);
          *__error() = v28;
        }
      }
      else
      {
        if (v12) {
          uint64_t v16 = v12[3];
        }
        else {
          uint64_t v16 = 0;
        }
        uint64_t v17 = KTraceStringFromArguments(v16, (uint64_t)a2, 1u);
        +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, (uint64_t)a2);
        id newValue = (id)objc_claimAutoreleasedReturnValue();
        -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v10, v38, v17, newValue);
        int v18 = (_DWORD *)objc_claimAutoreleasedReturnValue();
        if (v15)
        {
          int v19 = [v15 ppid];
          if (v18) {
            v18[20] = v19;
          }
        }
        +[SAThread threadWithId:]((uint64_t)SAThread, a2[5]);
        uint64_t v20 = (unsigned char *)objc_claimAutoreleasedReturnValue();
        uint64_t v22 = v20;
        if (v20)
        {
          v20[17] = 1;
          objc_setProperty_atomic(v20, v21, newValue, 32);
        }
        -[SATask addThread:]((uint64_t)v18, v22);
        if (v18) {
          objc_setProperty_atomic(v18, v23, v22, 264);
        }
        if (qword_1EB698F20)
        {
          int v34 = v17;
          int v35 = v15;
          int v32 = *__error();
          id v33 = (FILE *)qword_1EB698F20;
          uint64_t v24 = *a2;
          id v25 = [v15 debugDescription];
          int v26 = (const char *)[v25 UTF8String];
          id v27 = [v18 debugDescription];
          fprintf(v33, "%'llu %s exec'ed %s\n", v24, v26, (const char *)[v27 UTF8String]);

          uint64_t v15 = v35;
          *__error() = v32;
          unint64_t v7 = 0x1E4F28000;
          uint64_t v17 = v34;
        }
      }
    }

    int v29 = *(void **)(a1 + 32);
    id v30 = [*(id *)(v7 + 3792) numberWithUnsignedLongLong:a2[5]];
    [v29 setObject:0 forKeyedSubscript:v30];

    uint64_t v31 = *(void *)(a1 + 48);
    if (v31) {
      *(void *)(v31 + 32) = v5;
    }
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_5(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  unint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(void *)(a1 + 64))
  {
    unint64_t v5 = absolute_from_timestamp;
    id v6 = *(void **)(a1 + 32);
    unint64_t v7 = [NSNumber numberWithUnsignedLongLong:*(void *)(a2 + 40)];
    unint64_t v8 = [v6 objectForKeyedSubscript:v7];

    if (v8)
    {
      uint64_t v9 = *(void **)(a1 + 32);
      uint64_t v10 = [NSNumber numberWithUnsignedLongLong:*(void *)(a2 + 40)];
      [v9 setObject:0 forKeyedSubscript:v10];

      goto LABEL_23;
    }
    uint64_t v11 = *(void **)(a1 + 40);
    uint64_t v12 = *(id *)(a1 + 48);
    if (!v11)
    {
LABEL_22:

LABEL_23:
      uint64_t v22 = *(void *)(a1 + 48);
      if (v22) {
        *(void *)(v22 + 32) = v5;
      }
      return;
    }
    uint64_t v13 = -[SASampleStore lastTaskWithPid:orTid:](v11, 0xFFFFFFFFLL, *(void *)(a2 + 40));
    if (!v13)
    {
      int v18 = *__error();
      int v19 = _sa_logt();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        if (v12) {
          uint64_t v23 = v12[3];
        }
        else {
          uint64_t v23 = 0;
        }
        uint64_t v24 = *(void *)(a2 + 40);
        id v25 = KTraceStringFromArguments(v23, a2, 1u);
        int v26 = 134218242;
        uint64_t v27 = v24;
        __int16 v28 = 2112;
        int v29 = v25;
        _os_log_debug_impl(&dword_1BF22B000, v19, OS_LOG_TYPE_DEBUG, "No task with thread 0x%llx at exit for name %@", (uint8_t *)&v26, 0x16u);
      }
      *__error() = v18;
      goto LABEL_21;
    }
    if (v12) {
      uint64_t v14 = v12[3];
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = KTraceStringFromArguments(v14, a2, 1u);
    uint64_t v16 = [v13 name];
    uint64_t v17 = (void *)v16;
    if (v15)
    {
      if (v13[7] && v16)
      {
        if (([v15 hasPrefix:v16] & 1) == 0) {
          goto LABEL_18;
        }
      }
      else if (!v16)
      {
LABEL_17:
        -[SATask setName:]((uint64_t)v13, v15);
        goto LABEL_18;
      }
      if (([v17 hasPrefix:v15] & 1) == 0) {
        goto LABEL_17;
      }
    }
LABEL_18:
    uint64_t v20 = [v13 exitTimestamp];

    if (!v20)
    {
      id v21 = +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, a2);
      -[SASampleStore task:exitedAtTimestamp:]((uint64_t)v11, v13, v21);
    }
LABEL_21:

    goto LABEL_22;
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_6(uint64_t a1, void *a2)
{
  unint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(void *)(a1 + 56))
  {
    unint64_t v5 = absolute_from_timestamp;
    id v6 = *(void **)(a1 + 32);
    id v7 = *(id *)(a1 + 40);
    if (v6)
    {
      uint64_t v8 = a2[1];
      uint64_t v9 = +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, (uint64_t)a2);
      uint64_t v10 = -[SASampleStore lastTaskWithPid:orTid:](v6, 0xFFFFFFFFLL, v8);
      uint64_t v11 = v10;
      if (v10)
      {
        uint64_t v12 = [v10 exitTimestamp];

        if (!v12)
        {
          uint64_t v13 = [v11 threads];
          uint64_t v14 = [NSNumber numberWithUnsignedLongLong:v8];
          uint64_t v15 = [v13 objectForKeyedSubscript:v14];

          if (v15) {
            objc_setProperty_atomic(v15, v16, v9, 40);
          }
        }
      }
      else if (qword_1EB698F20)
      {
        int v17 = *__error();
        fprintf((FILE *)qword_1EB698F20, "%'llu Thread 0x%llx exited, but we don't have a task with that thread!\n", *a2, v8);
        *__error() = v17;
      }
    }
    uint64_t v18 = *(void *)(a1 + 40);
    if (v18) {
      *(void *)(v18 + 32) = v5;
    }
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_7(uint64_t a1, __int32 *a2)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  unint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
  if (absolute_from_timestamp < *(void *)(a1 + 64))
  {
    id v5 = (id)absolute_from_timestamp;
    id v6 = *(void **)(a1 + 32);
    id v7 = *(void **)(a1 + 48);
    uint64_t v80 = *(id *)(a1 + 40);
    id v81 = v7;
    if (!v6) {
      goto LABEL_97;
    }
    uint64_t v8 = [NSNumber numberWithUnsignedLongLong:*((void *)a2 + 5)];
    uint64_t v9 = [v81 objectForKeyedSubscript:v8];

    char v11 = 0;
    int v12 = 0;
    LOBYTE(v13) = 0;
    int v14 = 0;
    int v15 = 0;
    switch((unsigned __int16)a2[12] >> 2)
    {
      case 0:
      case 5:
        goto LABEL_36;
      case 1:
      case 6:
        if (!v9) {
          goto LABEL_59;
        }
        goto LABEL_7;
      case 2:
      case 7:
        goto LABEL_23;
      case 3:
      case 8:
        goto LABEL_49;
      case 4:
      case 9:
        goto LABEL_14;
      case 10:
        char v11 = 1;
LABEL_36:
        int32x4_t uu = *(int32x4_t *)(a2 + 2);
        if (uuid_is_null((const unsigned __int8 *)&uu))
        {
          if (!qword_1EB698F20) {
            goto LABEL_96;
          }
          goto LABEL_25;
        }
        if (v9 && !objc_getProperty((id)v9, v33, 24, 1)) {
          goto LABEL_80;
        }
        *(_DWORD *)long long buf = -1;
        if (v80) {
          uint64_t v35 = v80[3];
        }
        else {
          uint64_t v35 = 0;
        }
        uint64_t v36 = -[SASampleStore existingTaskForEvent:inSession:returningPid:](v6, (uint64_t)a2, v35, buf);
        id v37 = (void *)v36;
        if ((*(_DWORD *)buf & 0x80000000) == 0)
        {
          if (!v36)
          {
            execname_for_thread = (unsigned char *)ktrace_get_execname_for_thread();
            if (execname_for_thread && *execname_for_thread)
            {
              id v39 = SANSStringForCString(execname_for_thread);
            }
            else
            {
              id v39 = 0;
            }
            id v37 = -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v6, *(unsigned int *)buf, v39, 0);
          }
          uint64_t v73 = -[SADyldInfo initWithTask:]((id *)[SADyldInfo alloc], v37);

          unint64_t v74 = [NSNumber numberWithUnsignedLongLong:*((void *)a2 + 5)];
          [v81 setObject:v73 forKeyedSubscript:v74];

          uint64_t v9 = (uint64_t)v73;
          goto LABEL_92;
        }
        if (qword_1EB698F20)
        {
          id v48 = (void *)v36;
          int v49 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Unable to determine pid for dyld on thread 0x%llx: %d\n", *(void *)a2, *((void *)a2 + 5), *(_DWORD *)buf);
          *__error() = v49;
          id v37 = v48;
        }

        goto LABEL_96;
      case 11:
        int v12 = 1;
        if (!v9) {
          goto LABEL_59;
        }
LABEL_7:
        id v16 = objc_getProperty((id)v9, v10, 24, 1);
        if (!v16) {
          goto LABEL_59;
        }
        char v17 = *(unsigned char *)(v9 + 8);

        if (v12)
        {
          if (v17)
          {
LABEL_10:
            uint64_t v19 = *((void *)a2 + 2);
            uint64_t v20 = *(void *)(v9 + 40);
            if (!v20 || v20 == v19) {
              goto LABEL_21;
            }
            goto LABEL_20;
          }
        }
        else if ((v17 & 1) == 0)
        {
          goto LABEL_10;
        }
LABEL_59:
        if (qword_1EB698F20)
        {
          int v43 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Missing first dyld tracepoint on thread 0x%llx\n", *(void *)a2, *((void *)a2 + 5));
          *__error() = v43;
        }
        goto LABEL_69;
      case 12:
        LOBYTE(v13) = 1;
LABEL_23:
        int32x4_t uu = vuzp1q_s32(*(int32x4_t *)(a2 + 2), *(int32x4_t *)(a2 + 6));
        if (uuid_is_null((const unsigned __int8 *)&uu))
        {
          if (qword_1EB698F20)
          {
LABEL_25:
            int v25 = *__error();
            fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: null UUID in dyld tracepoint on thread 0x%llx\n", *(void *)a2, *((void *)a2 + 5));
            int v26 = __error();
LABEL_57:
            int *v26 = v25;
          }
          goto LABEL_96;
        }
        if (v9 && !objc_getProperty((id)v9, v24, 24, 1))
        {
          if (objc_getProperty((id)v9, v27, 48, 1)) {
            goto LABEL_87;
          }
          int v50 = *__error();
          char v51 = _sa_logt();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            a2 = [(id)v9 debugDescription];
            *(_DWORD *)long long buf = 136315138;
            uint64_t v83 = [a2 UTF8String];
            _os_log_error_impl(&dword_1BF22B000, v51, OS_LOG_TYPE_ERROR, "No uuid and no path for dyld info %s", buf, 0xCu);
          }
          *__error() = v50;
          id v5 = [(id)v9 debugDescription];
          char v52 = [v5 UTF8String];
          _SASetCrashLogMessage(1549, "No uuid and no path for dyld info %s", v53, v54, v55, v56, v57, v58, v52);

          _os_crash();
          __break(1u);
LABEL_80:
          if (objc_getProperty((id)v9, v34, 48, 1))
          {
LABEL_92:
            uint64_t v70 = uuidForBytes((uint64_t)&uu);
            uint64_t v76 = v70;
            if (v9)
            {
              objc_setProperty_atomic((id)v9, v75, v70, 24);

              *(void *)(v9 + 32) = *((void *)a2 + 3);
              *(unsigned char *)(v9 + 8) = v11;
              goto LABEL_94;
            }
            goto LABEL_102;
          }
          int v13 = *__error();
          int v59 = _sa_logt();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
          {
            a2 = [(id)v9 debugDescription];
            uint64_t v60 = [a2 UTF8String];
            *(_DWORD *)long long buf = 136315138;
            uint64_t v83 = v60;
            _os_log_error_impl(&dword_1BF22B000, v59, OS_LOG_TYPE_ERROR, "No uuid and no path for dyld info %s", buf, 0xCu);
          }
          *__error() = v13;
          id v5 = [(id)v9 debugDescription];
          char v61 = [v5 UTF8String];
          _SASetCrashLogMessage(1474, "No uuid and no path for dyld info %s", v62, v63, v64, v65, v66, v67, v61);

          _os_crash();
          __break(1u);
        }
        else
        {
          *(_DWORD *)long long buf = -1;
          if (v80) {
            uint64_t v28 = v80[3];
          }
          else {
            uint64_t v28 = 0;
          }
          uint64_t v29 = -[SASampleStore existingTaskForEvent:inSession:returningPid:](v6, (uint64_t)a2, v28, buf);
          uint64_t v30 = (void *)v29;
          if ((*(_DWORD *)buf & 0x80000000) != 0)
          {
            if (qword_1EB698F20)
            {
              int v47 = *__error();
              fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Unable to determine pid for dyld on thread 0x%llx: %d\n", *(void *)a2, *((void *)a2 + 5), *(_DWORD *)buf);
              *__error() = v47;
            }

LABEL_96:
LABEL_97:

            uint64_t v78 = *(void *)(a1 + 40);
            if (v78) {
              *(void *)(v78 + 32) = v5;
            }
            return;
          }
          if (v29) {
            goto LABEL_86;
          }
          uint64_t v31 = (unsigned char *)ktrace_get_execname_for_thread();
          if (v31 && *v31)
          {
            int v32 = SANSStringForCString(v31);
LABEL_85:
            uint64_t v30 = -[SASampleStore taskForPid:andName:didExecAtTimestamp:](v6, *(unsigned int *)buf, v32, 0);

LABEL_86:
            uint64_t v68 = -[SADyldInfo initWithTask:]((id *)[SADyldInfo alloc], v30);

            id v69 = [NSNumber numberWithUnsignedLongLong:*((void *)a2 + 5)];
            [v81 setObject:v68 forKeyedSubscript:v69];

            uint64_t v9 = (uint64_t)v68;
LABEL_87:
            uint64_t v70 = uuidForBytes((uint64_t)&uu);
            uint64_t v72 = v70;
            if (v9)
            {
              objc_setProperty_atomic((id)v9, v71, v70, 24);

              *(unsigned char *)(v9 + 8) = v13;
              goto LABEL_94;
            }
LABEL_102:

            goto LABEL_94;
          }
        }
        int v32 = 0;
        goto LABEL_85;
      case 13:
        int v14 = 1;
LABEL_49:
        if (!v9) {
          goto LABEL_67;
        }
        id v40 = objc_getProperty((id)v9, v10, 24, 1);
        if (!v40) {
          goto LABEL_67;
        }
        char v41 = *(unsigned char *)(v9 + 8);

        if (v14)
        {
          if (v41)
          {
LABEL_53:
            *(void *)(v9 + 32) = *((void *)a2 + 1);
            goto LABEL_94;
          }
        }
        else if ((v41 & 1) == 0)
        {
          goto LABEL_53;
        }
LABEL_67:
        if (qword_1EB698F20)
        {
          int v45 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Missing first dyld tracepoint on thread 0x%llx\n", *(void *)a2, *((void *)a2 + 5));
          *__error() = v45;
        }
LABEL_69:
        uint64_t v46 = [NSNumber numberWithUnsignedLongLong:*((void *)a2 + 5)];
        [v81 setObject:0 forKeyedSubscript:v46];

        goto LABEL_96;
      case 14:
        int v15 = 1;
LABEL_14:
        if (!v9) {
          goto LABEL_63;
        }
        id v21 = objc_getProperty((id)v9, v10, 24, 1);
        if (!v21) {
          goto LABEL_63;
        }
        char v22 = *(unsigned char *)(v9 + 8);

        if (v15)
        {
          if (v22)
          {
LABEL_18:
            uint64_t v19 = *((void *)a2 + 2);
            uint64_t v23 = *(void *)(v9 + 40);
            if (!v23 || v23 == v19) {
              goto LABEL_21;
            }
LABEL_20:
            objc_setProperty_atomic((id)v9, v18, 0, 48);
            *(unsigned char *)(v9 + 10) = 0;
LABEL_21:
            *(void *)(v9 + 40) = v19;
            *(unsigned char *)(v9 + 9) = 1;
LABEL_94:
            if (-[SASampleStore checkDyldInfoCompletion:]((uint64_t)v6, (void *)v9))
            {
              id v77 = [NSNumber numberWithUnsignedLongLong:*((void *)a2 + 5)];
              [v81 setObject:0 forKeyedSubscript:v77];
            }
            goto LABEL_96;
          }
        }
        else if ((v22 & 1) == 0)
        {
          goto LABEL_18;
        }
LABEL_63:
        if (qword_1EB698F20)
        {
          int v44 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu WARNING: Missing first dyld tracepoint on thread 0x%llx\n", *(void *)a2, *((void *)a2 + 5));
          *__error() = v44;
        }
        goto LABEL_69;
      case 15:
      case 16:
        goto LABEL_94;
      default:
        int v25 = *__error();
        int v42 = _sa_logt();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT))
        {
          __int32 v79 = a2[12];
          uu.i32[0] = 67109120;
          uu.i32[1] = v79;
          _os_log_fault_impl(&dword_1BF22B000, v42, OS_LOG_TYPE_FAULT, "Unknown dyld tracepoint 0x%x", (uint8_t *)&uu, 8u);
        }

        int v26 = __error();
        goto LABEL_57;
    }
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_8(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  if (v8)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6) {
      [*(id *)(v6 + 64) addObject:v8];
    }
  }
  if (v5)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7) {
      [*(id *)(v7 + 56) addObject:v5];
    }
  }
}

void __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_9(uint64_t a1, void *a2)
{
}

uint64_t __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_10(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 32);
  if (v2) {
    return [*(id *)(v2 + 96) addObject:a2];
  }
  return result;
}

unint64_t __84__SASampleStore_KPerf___addKPerfDataFromKTraceSession_beforeMachAbsTime_petTimerID___block_invoke_11(uint64_t a1, uint64_t a2)
{
  unint64_t result = ktrace_get_absolute_from_timestamp();
  if (result < *(void *)(a1 + 64))
  {
    unint64_t v5 = result;
    uint64_t v6 = *(void **)(a1 + 32);
    id v7 = *(id *)(a1 + 40);
    if (v6)
    {
      id v8 = [v6 startTime];
      if (v8)
      {
        uint64_t v9 = +[SATimestamp timestampWithKTraceEvent:fromSession:]((uint64_t)SATimestamp, a2);
        [v9 wallTime];
        uint64_t v30 = _CopyStringForTime(3, v10);
        if ([v6 dataStyle] == 1 || !objc_msgSend(v6, "dataStyle"))
        {
          uint64_t v19 = (FILE *)*MEMORY[0x1E4F143C8];
          [v9 machAbsTimeSeconds];
          double v21 = v20;
          [v8 machAbsTimeSeconds];
          double v23 = v22;
          uint64_t v24 = (const char *)[(__CFString *)v30 UTF8String];
          uint64_t absolute_from_timestamp = ktrace_get_absolute_from_timestamp();
          uint64_t continuous_from_timestamp = ktrace_get_continuous_from_timestamp();
          fprintf(v19, "Warning: Lost trace events, dropping all samples (%.2fs) before %s (machabs %llu / machcont %llu)\n", v21 - v23, v24, absolute_from_timestamp, continuous_from_timestamp);
        }
        else
        {
          uint64_t v29 = (FILE *)*MEMORY[0x1E4F143C8];
          char v11 = [v6 sampleTimestamps];
          uint64_t v28 = [v11 count];
          [v9 machAbsTimeSeconds];
          double v13 = v12;
          [v8 machAbsTimeSeconds];
          double v15 = v14;
          id v16 = (const char *)[(__CFString *)v30 UTF8String];
          uint64_t v17 = ktrace_get_absolute_from_timestamp();
          uint64_t v18 = ktrace_get_continuous_from_timestamp();
          fprintf(v29, "Warning: Lost trace events, dropping first %lu samples (%.2fs) before %s (machabs %llu / machcont %llu)\n", v28, v13 - v15, v16, v17, v18);
        }
      }
      -[SASampleStore removeAllData](v6);
    }
    unint64_t result = [*(id *)(a1 + 48) removeAllObjects];
    uint64_t v27 = *(void *)(a1 + 40);
    if (v27) {
      *(void *)(v27 + 32) = v5;
    }
  }
  return result;
}

- (id)loadInfosForKTSymbolOwners:(int)a3 isKernelSpace:(uint64_t)a4 excludeRange:(unint64_t)a5
{
  uint64_t v211 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    unint64_t v5 = a2;
    uint64_t v196 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:*a2];
    id v7 = v5 + 1;
    uint64_t v6 = *v5;
    if (v6)
    {
      int v194 = 0;
      int v189 = 0;
      uint64_t v200 = &v7[v6];
      while (1)
      {
        uint64_t v8 = *v7;
        uint64_t v9 = (void *)MEMORY[0x1C18A6A20]();
        long double v10 = (int *)((char *)v7 + v8);
        char v11 = (unsigned __int16 *)((char *)v7 + v8 - *(int *)((char *)v7 + v8));
        unsigned int v12 = *v11;
        if (v12 < 5
          || !v11[2]
          || (v12 >= 7 ? (BOOL v13 = *((unsigned char *)v10 + v11[2]) == 1) : (BOOL v13 = 0), !v13 || (v14 = v11[3]) == 0))
        {
          if (_MergedGlobals_4[0] == 1)
          {
            int v20 = *__error();
            double v21 = _sa_logt();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              int v25 = (unsigned __int16 *)((char *)v10 - *v10);
              if (*v25 >= 0xBu && (uint64_t v26 = v25[5]) != 0) {
                uint64_t v27 = *(void *)((char *)v10 + v26);
              }
              else {
                uint64_t v27 = -1;
              }
              *(_DWORD *)int32x4_t uu = 134217984;
              *(void *)&uu[4] = v27;
              _os_log_debug_impl(&dword_1BF22B000, v21, OS_LOG_TYPE_DEBUG, "SAKTSYM No macho for symbol owner at 0x%llx", uu, 0xCu);
            }

            *__error() = v20;
          }
          goto LABEL_20;
        }
        BOOL v197 = (char *)v10 + v14 + *(unsigned int *)((char *)v10 + v14);
        double v15 = &v197[-*(int *)v197];
        if (*(unsigned __int16 *)v15 < 5u || (uint64_t v16 = *((unsigned __int16 *)v15 + 2)) == 0)
        {
          if (_MergedGlobals_4[0] == 1)
          {
            int v22 = *__error();
            double v23 = _sa_logt();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
            {
              int v49 = (unsigned __int16 *)((char *)v10 - *v10);
              if (*v49 >= 0xBu && (uint64_t v50 = v49[5]) != 0) {
                uint64_t v51 = *(void *)((char *)v10 + v50);
              }
              else {
                uint64_t v51 = -1;
              }
              *(_DWORD *)int32x4_t uu = 134217984;
              *(void *)&uu[4] = v51;
              _os_log_debug_impl(&dword_1BF22B000, v23, OS_LOG_TYPE_DEBUG, "SAKTSYM No UUID for symbol owner at 0x%llx", uu, 0xCu);
            }

            uint64_t v24 = 0;
            *__error() = v22;
          }
          else
          {
            uint64_t v24 = 0;
          }
          goto LABEL_242;
        }
        *(void *)int32x4_t uu = 0;
        *(void *)&uu[8] = 0;
        uuid_parse(&v197[v16 + 4 + *(unsigned int *)&v197[v16]], uu);
        uint64_t v17 = &v197[-*(int *)v197];
        if (*(unsigned __int16 *)v17 >= 7u && (uint64_t v18 = *((unsigned __int16 *)v17 + 3)) != 0)
        {
          uint64_t v19 = SANSStringForCString((void *)&v197[v18 + 4 + *(unsigned int *)&v197[v18]]);
        }
        else
        {
          uint64_t v19 = 0;
        }
        uint64_t v28 = uuidForBytes((uint64_t)uu);
        if ([v19 isAbsolutePath]) {
          uint64_t v29 = v19;
        }
        else {
          uint64_t v29 = 0;
        }
        +[SABinary binaryWithUUID:absolutePath:](SABinary, "binaryWithUUID:absolutePath:", v28, v29, log);
        self = (id)objc_claimAutoreleasedReturnValue();

        uint64_t v30 = [self path];
        if (v30) {
          BOOL v31 = 1;
        }
        else {
          BOOL v31 = v19 == 0;
        }
        int v32 = !v31;

        if (v32)
        {
          if (self) {
            objc_setProperty_atomic_copy(self, v33, v19, 80);
          }
          if (_MergedGlobals_4[0] == 1)
          {
            int v34 = *__error();
            uint64_t v35 = _sa_logt();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v36 = [self debugDescription];
              *(_DWORD *)long long buf = 138412290;
              BOOL v210 = v36;
              _os_log_impl(&dword_1BF22B000, v35, OS_LOG_TYPE_DEFAULT, "WARNING: SAKTSYM Used relative path for binary %@", buf, 0xCu);
            }
            *__error() = v34;
          }
        }

        uint64_t v24 = self;
        if (!self) {
          goto LABEL_242;
        }
        id v37 = &v197[-*(int *)v197];
        if (*(unsigned __int16 *)v37 >= 0x15u)
        {
          uint64_t v38 = *((unsigned __int16 *)v37 + 10);
          if (v38)
          {
            id v39 = (char *)&v197[v38 + 4 + *(unsigned int *)&v197[v38]];
            id v40 = SANSStringForCString(v39);
            if (v40)
            {
              char v41 = [self bundleIdentifier];
              BOOL v42 = v41 == 0;

              if (v42)
              {
                char v52 = SANSStringForCString(v39);
                objc_setProperty_atomic_copy(self, v53, v52, 88);
              }
              else
              {
                int v43 = [self bundleIdentifier];
                char v44 = [v43 isEqualToString:v40];

                if ((v44 & 1) == 0)
                {
                  int v45 = *__error();
                  uint64_t v46 = _sa_logt();
                  if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
                  {
                    uint64_t v169 = [self debugDescription];
                    *(_DWORD *)int32x4_t uu = 136315394;
                    *(void *)&uu[4] = v39;
                    *(_WORD *)&uu[12] = 2112;
                    *(void *)&uu[14] = v169;
                    _os_log_fault_impl(&dword_1BF22B000, v46, OS_LOG_TYPE_FAULT, "SAKTSYM Mismatched bundle id %s with existing binary %@", uu, 0x16u);
                  }
                  *__error() = v45;
                }
              }
            }
            else
            {
              int v47 = *__error();
              id v48 = _sa_logt();
              if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)int32x4_t uu = 136315138;
                *(void *)&uu[4] = v39;
                _os_log_fault_impl(&dword_1BF22B000, v48, OS_LOG_TYPE_FAULT, "SAKTSYM Unable to get string for bundle id %s", uu, 0xCu);
              }

              *__error() = v47;
            }

            uint64_t v24 = self;
          }
        }
        uint64_t v54 = (unsigned __int16 *)((char *)v10 - *v10);
        unsigned int v55 = *v54;
        if (v55 < 0xD)
        {
          char v181 = 1;
          if (v55 < 9) {
            break;
          }
          BOOL v56 = 0;
        }
        else
        {
          BOOL v56 = v54[6] && *((unsigned char *)v10 + v54[6]) != 0;
          char v181 = !v56;
        }
        uint64_t v57 = v54[4];
        if (!v57) {
          break;
        }
        if (!*(int *)((char *)v10 + v57 + *(unsigned int *)((char *)v10 + v57)))
        {
          if (_MergedGlobals_4[0] != 1)
          {
LABEL_218:
            uint64_t v190 = -1;
            uint64_t v193 = -1;
LABEL_223:
            if (v181) {
              goto LABEL_242;
            }
            goto LABEL_224;
          }
          int v148 = *__error();
          id v149 = _sa_logt();
          if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v168 = [self debugDescription];
            *(_DWORD *)int32x4_t uu = 138412290;
            *(void *)&uu[4] = v168;
            _os_log_debug_impl(&dword_1BF22B000, v149, OS_LOG_TYPE_DEBUG, "SAKTSYM symbol owner %@ not contiguous, but has zero segments", uu, 0xCu);
          }
          goto LABEL_216;
        }
        uint64_t v178 = [v196 count];
        BOOL v179 = v56;
        uint64_t v58 = *(unsigned __int16 *)((char *)v10 - *v10 + 8);
        uint64_t v59 = *(unsigned int *)((char *)v10 + v58);
        uint64_t v60 = *(unsigned int *)((char *)v10 + v58 + v59);
        if (v60)
        {
          uint64_t v61 = 0;
          int v188 = 0;
          uint64_t v195 = 4 * v60;
          char v198 = (char *)v5 + v58 + v8 + v59;
          uint64_t v193 = -1;
          uint64_t v190 = -1;
          while (1)
          {
            uint64_t v62 = *(unsigned int *)&v198[v61 + 8];
            uint64_t v63 = &v198[v61 + v62];
            uint64_t v64 = v62 - *((int *)v63 + 2);
            uint64_t v65 = &v198[v61 + v64];
            unsigned int v66 = *((unsigned __int16 *)v65 + 4);
            if (v66 >= 5 && (uint64_t v67 = *((unsigned __int16 *)v65 + 6)) != 0) {
              uint64_t v68 = &v198[v61 + 12 + v62 + v67 + *(unsigned int *)&v198[v61 + 8 + v62 + v67]];
            }
            else {
              uint64_t v68 = 0;
            }
            id v69 = (unsigned int *)((char *)v10 + *(unsigned __int16 *)((char *)v10 - *v10 + 8));
            if (*(unsigned int *)((char *)v69 + *v69) != 1) {
              goto LABEL_84;
            }
            if (v193 != -1) {
              break;
            }
            if (v66 >= 7 && (uint64_t v77 = *(unsigned __int16 *)&v198[v61 + 14 + v64]) != 0) {
              uint64_t v78 = *(void *)&v198[v61 + 8 + v62 + v77];
            }
            else {
              uint64_t v78 = -1;
            }
            uint64_t v193 = v78;
            if (v68) {
              goto LABEL_85;
            }
LABEL_99:
            if (!a3
              || !CSArchitectureIsArm64()
              || (__int32 v79 = (unsigned int *)((char *)v10 + *(unsigned __int16 *)((char *)v10 - *v10 + 8)),
                  *(unsigned int *)((char *)v79 + *v79) != 1))
            {
              if (_MergedGlobals_4[0] == 1)
              {
                int v82 = *__error();
                uint64_t v83 = _sa_logt();
                if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v125 = &v198[v61 + v62 - *((int *)v63 + 2)];
                  if (*((unsigned __int16 *)v125 + 4) >= 0xFu && (uint64_t v126 = *((unsigned __int16 *)v125 + 11)) != 0) {
                    uint64_t v127 = *(void *)&v198[v61 + 8 + v62 + v126];
                  }
                  else {
                    uint64_t v127 = -1;
                  }
                  id v133 = objc_msgSend(self, "debugDescription", log);
                  *(_DWORD *)int32x4_t uu = 134218242;
                  *(void *)&uu[4] = v127;
                  *(_WORD *)&uu[12] = 2112;
                  *(void *)&uu[14] = v133;
                  _os_log_debug_impl(&dword_1BF22B000, v83, OS_LOG_TYPE_DEBUG, "SAKTSYM No name for segment at offset 0x%llx into %@", uu, 0x16u);
                }
                *__error() = v82;
                goto LABEL_183;
              }
              goto LABEL_184;
            }
            if (qword_1EB698F28 != -1) {
              dispatch_once(&qword_1EB698F28, &__block_literal_global_2);
            }
            uint64_t v68 = "__TEXT_EXEC";
            if (_MergedGlobals_4[0] == 1)
            {
              int v80 = *__error();
              id v81 = _sa_logt();
              if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
              {
                id v135 = &v198[v61 + v62 - *((int *)v63 + 2)];
                if (*((unsigned __int16 *)v135 + 4) >= 0xFu && (uint64_t v136 = *((unsigned __int16 *)v135 + 11)) != 0) {
                  uint64_t v137 = *(void *)&v198[v61 + 8 + v62 + v136];
                }
                else {
                  uint64_t v137 = -1;
                }
                uint64_t v187 = v137;
                id v147 = objc_msgSend(self, "debugDescription", log);
                *(_DWORD *)int32x4_t uu = 134218242;
                *(void *)&uu[4] = v187;
                *(_WORD *)&uu[12] = 2112;
                *(void *)&uu[14] = v147;
                _os_log_debug_impl(&dword_1BF22B000, v81, OS_LOG_TYPE_DEBUG, "SAKTSYM No name for segment at offset 0x%llx into %@, assuming TEXT_EXEC", uu, 0x16u);
              }
              *__error() = v80;
              uint64_t v68 = "__TEXT_EXEC";
              uint64_t v24 = self;
            }
LABEL_85:
            if (!SAShouldIgnoreSegmentWithCName(v68))
            {
              if (strncmp(v68, "__TEXT", 6uLL)) {
                goto LABEL_88;
              }
              char v84 = &v198[v61 + v62 - *((int *)v63 + 2)];
              if (*((unsigned __int16 *)v84 + 4) < 7u
                || (uint64_t v85 = *((unsigned __int16 *)v84 + 7)) == 0
                || (uint64_t v184 = *(void *)&v198[v61 + 8 + v62 + v85], v184 == -1))
              {
                if (_MergedGlobals_4[0] == 1)
                {
                  int v86 = *__error();
                  char v87 = _sa_logt();
                  if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v130 = [self debugDescription];
                    *(_DWORD *)int32x4_t uu = 138412290;
                    *(void *)&uu[4] = v130;
                    uint64_t v186 = (void *)v130;
                    _os_log_debug_impl(&dword_1BF22B000, v87, OS_LOG_TYPE_DEBUG, "SAKTSYM TEXT segment has no address for %@", uu, 0xCu);
                  }
                  *__error() = v86;
                  uint64_t v184 = v190;
                  uint64_t v24 = self;
                }
                else
                {
LABEL_88:
                  uint64_t v184 = v190;
                }
              }
              uint64_t v72 = SANSStringForCString(v68);
              char v191 = v72;
              if (v72)
              {
                uint64_t v73 = -[SABinary segmentWithCleanName:](v24, v72);
                if (!v73)
                {
                  unint64_t v74 = &v198[v61 + v62 - *((int *)v63 + 2)];
                  if (*((unsigned __int16 *)v74 + 4) >= 9u && (uint64_t v75 = *((unsigned __int16 *)v74 + 8)) != 0) {
                    uint64_t v76 = *(void *)&v198[v61 + 8 + v62 + v75];
                  }
                  else {
                    uint64_t v76 = 0;
                  }
                  id v90 = +[SASegment segmentWithBinary:name:length:]((uint64_t)SASegment, self, v191, v76);
                  -[SABinary addSegment:](self, v90);
                  if (_MergedGlobals_4[0] == 1)
                  {
                    int v91 = *__error();
                    id v92 = _sa_logt();
                    if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v134 = [v90 debugDescription];
                      *(_DWORD *)int32x4_t uu = 138412290;
                      *(void *)&uu[4] = v134;
                      os_log_t log = (os_log_t)v134;
                      _os_log_debug_impl(&dword_1BF22B000, v92, OS_LOG_TYPE_DEBUG, "SAKTSYM new segment %@", uu, 0xCu);
                    }
                    *__error() = v91;
                  }
                  uint64_t v73 = v90;
                }
                uint64_t v93 = &v198[v61 + v62 - *((int *)v63 + 2)];
                char v180 = &v198[v61 + v62];
                if (*((unsigned __int16 *)v93 + 4) >= 9u)
                {
                  uint64_t v94 = *((unsigned __int16 *)v93 + 8);
                  if (v94)
                  {
                    if (*(void *)&v198[v61 + 8 + v62 + v94])
                    {
                      if ([v73 length])
                      {
                        uint64_t v95 = [v73 length];
                        uint64_t v96 = &v198[v61 + v62 - *((int *)v63 + 2)];
                        if (*((unsigned __int16 *)v96 + 4) < 9u)
                        {
                          uint64_t v97 = 0;
                        }
                        else
                        {
                          uint64_t v97 = *((unsigned __int16 *)v96 + 8);
                          if (v97) {
                            uint64_t v97 = *(void *)&v198[v61 + 8 + v62 + v97];
                          }
                        }
                        if (v95 != v97 && _MergedGlobals_4[0] == 1)
                        {
                          int v105 = *__error();
                          uint64_t v106 = _sa_logt();
                          if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
                          {
                            os_log_t log = v106;
                            uint64_t v140 = [v73 debugDescription];
                            id v141 = (void *)v140;
                            id v142 = &v198[v61 + v62 - *((int *)v180 + 2)];
                            if (*((unsigned __int16 *)v142 + 4) < 9u)
                            {
                              uint64_t v143 = 0;
                              long long v144 = log;
                            }
                            else
                            {
                              uint64_t v143 = *((unsigned __int16 *)v142 + 8);
                              long long v144 = log;
                              if (v143) {
                                uint64_t v143 = *(void *)&v198[v61 + 8 + v62 + v143];
                              }
                            }
                            *(_DWORD *)int32x4_t uu = 138412546;
                            *(void *)&uu[4] = v140;
                            *(_WORD *)&uu[12] = 2048;
                            *(void *)&uu[14] = v143;
                            _os_log_debug_impl(&dword_1BF22B000, v144, OS_LOG_TYPE_DEBUG, "SAKTSYM segment %@ length mismatch 0x%llx", uu, 0x16u);

                            uint64_t v106 = log;
                          }
                          goto LABEL_147;
                        }
                      }
                      else
                      {
                        id v102 = &v198[v61 + v62 - *((int *)v63 + 2)];
                        if (*((unsigned __int16 *)v102 + 4) >= 9u && (uint64_t v103 = *((unsigned __int16 *)v102 + 8)) != 0) {
                          unint64_t v104 = *(void *)&v198[v61 + 8 + v62 + v103];
                        }
                        else {
                          unint64_t v104 = 0;
                        }
                        -[SASegment setLength:](v73, v104);
                        if (_MergedGlobals_4[0] == 1)
                        {
                          int v105 = *__error();
                          uint64_t v106 = _sa_logt();
                          if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
                          {
                            os_log_t log = v106;
                            id v138 = [v73 debugDescription];
                            uint64_t v139 = [v73 length];
                            *(_DWORD *)int32x4_t uu = 138412546;
                            *(void *)&uu[4] = v138;
                            *(_WORD *)&uu[12] = 2048;
                            *(void *)&uu[14] = v139;
                            _os_log_debug_impl(&dword_1BF22B000, log, OS_LOG_TYPE_DEBUG, "SAKTSYM segment %@ added length 0x%llx", uu, 0x16u);

                            uint64_t v106 = log;
                          }
LABEL_147:

                          *__error() = v105;
                          uint64_t v63 = &v198[v61 + v62];
                        }
                      }
                    }
                  }
                }
                uint64_t v107 = v62 - *((int *)v63 + 2);
                unsigned int v108 = *(unsigned __int16 *)&v198[v61 + 8 + v107];
                if (v108 < 0xF
                  || !*(_WORD *)&v198[v61 + 22 + v107]
                  || (uint64_t v109 = *(void *)&v198[v61 + 8 + v62 + *(unsigned __int16 *)&v198[v61 + 22 + v107]], v109 == -1))
                {
                  uint64_t v112 = (unsigned __int16 *)((char *)v10 - *v10);
                  if (*v112 >= 0xDu)
                  {
                    uint64_t v113 = v112[6];
                    if (v113)
                    {
                      int v114 = *((unsigned __int8 *)v10 + v113);
                      if (v108 >= 7 && v114 != 0)
                      {
                        uint64_t v116 = *(unsigned __int16 *)&v198[v61 + 14 + v107];
                        if (v116)
                        {
                          uint64_t v117 = *(void *)&v198[v61 + 8 + v62 + v116];
                          if (v117 != -1 && v184 != -1)
                          {
                            uint64_t v109 = v117 - v184;
                            goto LABEL_151;
                          }
                        }
                      }
                    }
                  }
                }
                else
                {
LABEL_151:
                  if (v109 != 0x7FFFFFFFFFFFFFFFLL && ([v73 hasOffsetIntoBinary] & 1) == 0)
                  {
                    if (v73) {
                      v73[5] = v109;
                    }
                    if (_MergedGlobals_4[0] == 1)
                    {
                      int v110 = *__error();
                      uint64_t v111 = _sa_logt();
                      if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
                      {
                        id v145 = [v73 debugDescription];
                        uint64_t v146 = [v73 offsetIntoBinary];
                        *(_DWORD *)int32x4_t uu = 138412546;
                        *(void *)&uu[4] = v145;
                        *(_WORD *)&uu[12] = 2048;
                        *(void *)&uu[14] = v146;
                        _os_log_debug_impl(&dword_1BF22B000, v111, OS_LOG_TYPE_DEBUG, "SAKTSYM segment %@ added offsetIntoBinary 0x%llx", uu, 0x16u);
                      }
                      *__error() = v110;
                    }
                  }
                }
                if (!v179)
                {
                  uint64_t v119 = v62 - *((int *)v180 + 2);
                  if (*(unsigned __int16 *)&v198[v61 + 8 + v119] < 7u
                    || (uint64_t v120 = *(unsigned __int16 *)&v198[v61 + 14 + v119]) == 0
                    || (uint64_t v121 = *(void *)&v198[v61 + 8 + v62 + v120], v121 == -1))
                  {
                    if (_MergedGlobals_4[0] == 1)
                    {
                      int v122 = *__error();
                      objc_super v123 = _sa_logt();
                      if (os_log_type_enabled(v123, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v131 = [self debugDescription];
                        id v132 = [v73 debugDescription];
                        *(_DWORD *)int32x4_t uu = 138412546;
                        *(void *)&uu[4] = v131;
                        *(_WORD *)&uu[12] = 2112;
                        *(void *)&uu[14] = v132;
                        _os_log_debug_impl(&dword_1BF22B000, v123, OS_LOG_TYPE_DEBUG, "SAKTSYM symbol owner %@ not contiguous, but segment %@ has no load address", uu, 0x16u);
                      }
                      *__error() = v122;
                    }
                  }
                  else if (v121 - a4 >= a5)
                  {
                    uint64_t v124 = +[SABinaryLoadInfo binaryLoadInfoWithSegment:loadAddress:isInKernelAddressSpace:exclave:](SABinaryLoadInfo, v73, v121, a3, 0);
                    [v196 addObject:v124];
                  }
                  else
                  {
                    ++v194;
                  }
                }
              }
              else
              {
                int v88 = *__error();
                uint64_t v89 = _sa_logt();
                if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
                {
                  unsigned int v128 = &v197[-*(int *)v197];
                  if (*(unsigned __int16 *)v128 < 7u)
                  {
                    uint64_t v129 = 0;
                  }
                  else
                  {
                    uint64_t v129 = *((unsigned __int16 *)v128 + 3);
                    if (v129) {
                      v129 += (uint64_t)&v197[*(unsigned int *)&v197[v129]];
                    }
                  }
                  *(_DWORD *)int32x4_t uu = 136315138;
                  *(void *)&uu[4] = v129 + 4;
                  _os_log_fault_impl(&dword_1BF22B000, v89, OS_LOG_TYPE_FAULT, "SAKTSYM Unable to get string for symbol owner path %s", uu, 0xCu);
                }

                *__error() = v88;
              }

              uint64_t v190 = v184;
LABEL_183:
              uint64_t v24 = self;
              goto LABEL_184;
            }
            ++v188;
LABEL_184:
            v61 += 4;
            if (v195 == v61) {
              goto LABEL_220;
            }
          }
          int v70 = *__error();
          uint64_t v71 = _sa_logt();
          if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
          {
            uint64_t v98 = [self debugDescription];
            uint64_t v99 = &v198[v61 + v62 - *((int *)v63 + 2)];
            if (*((unsigned __int16 *)v99 + 4) >= 7u && (uint64_t v100 = *((unsigned __int16 *)v99 + 7)) != 0) {
              uint64_t v101 = *(void *)&v198[v61 + 8 + v62 + v100];
            }
            else {
              uint64_t v101 = -1;
            }
            *(_DWORD *)int32x4_t uu = 138413058;
            *(void *)&uu[4] = v98;
            *(_WORD *)&uu[12] = 2048;
            *(void *)&uu[14] = v193;
            *(_WORD *)&uu[22] = 2048;
            *(void *)uint64_t v207 = v101;
            *(_WORD *)&v207[8] = 2082;
            uint64_t v208 = v68;
            int v185 = (void *)v98;
            _os_log_fault_impl(&dword_1BF22B000, v71, OS_LOG_TYPE_FAULT, "SAKTSYM %@: ktrace claimed 1 segment, but after 0x%llx here's another: 0x%llx %{public}s", uu, 0x2Au);
          }
          *__error() = v70;
          uint64_t v24 = self;
LABEL_84:
          if (v68) {
            goto LABEL_85;
          }
          goto LABEL_99;
        }
        int v188 = 0;
        uint64_t v190 = -1;
        uint64_t v193 = -1;
LABEL_220:
        if (v179) {
          goto LABEL_223;
        }
        if (v178 != [v196 count]) {
          goto LABEL_223;
        }
        id v150 = (unsigned int *)((char *)v10 + *(unsigned __int16 *)((char *)v10 - *v10 + 8));
        if (*(unsigned int *)((char *)v150 + *v150) == v188) {
          goto LABEL_223;
        }
        if (_MergedGlobals_4[0] == 1)
        {
          int v164 = *__error();
          int v165 = _sa_logt();
          if (os_log_type_enabled(v165, OS_LOG_TYPE_DEBUG))
          {
            int v171 = [self debugDescription];
            int v172 = (unsigned int *)((char *)v10 + *(unsigned __int16 *)((char *)v10 - *v10 + 8));
            LODWORD(v172) = *(unsigned int *)((char *)v172 + *v172);
            *(_DWORD *)int32x4_t uu = 138412546;
            *(void *)&uu[4] = v171;
            *(_WORD *)&uu[12] = 1024;
            *(_DWORD *)&uu[14] = v172;
            _os_log_debug_impl(&dword_1BF22B000, v165, OS_LOG_TYPE_DEBUG, "SAKTSYM symbol owner %@ not contiguous, but no segments (of %d) have name/load addresses", uu, 0x12u);
          }
          *__error() = v164;
        }
LABEL_224:
        long long v203 = 0u;
        long long v204 = 0u;
        long long v201 = 0u;
        long long v202 = 0u;
        id v151 = v196;
        uint64_t v152 = [v151 countByEnumeratingWithState:&v201 objects:v205 count:16];
        if (v152)
        {
          uint64_t v153 = *(void *)v202;
          while (2)
          {
            for (uint64_t i = 0; i != v152; ++i)
            {
              if (*(void *)v202 != v153) {
                objc_enumerationMutation(v151);
              }
              id v155 = *(void **)(*((void *)&v201 + 1) + 8 * i);
              objc_msgSend(v155, "binary", log);
              id v156 = (id)objc_claimAutoreleasedReturnValue();
              BOOL v157 = v156 == self;

              if (v157)
              {
                int v159 = *__error();
                id v160 = _sa_logt();
                if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v166 = [v155 debugDescription];
                  *(_DWORD *)int32x4_t uu = 138412290;
                  *(void *)&uu[4] = v166;
                  _os_log_error_impl(&dword_1BF22B000, v160, OS_LOG_TYPE_ERROR, "SAKTSYM symbol owner contiguous, but already have binary in load infos: %@", uu, 0xCu);
                }
                *__error() = v159;

                goto LABEL_241;
              }
            }
            uint64_t v152 = [v151 countByEnumeratingWithState:&v201 objects:v205 count:16];
            if (v152) {
              continue;
            }
            break;
          }
        }

        if (v190 == -1) {
          uint64_t v158 = v193;
        }
        else {
          uint64_t v158 = v190;
        }
        if (v158 == -1)
        {
          uint64_t v24 = self;
          if (_MergedGlobals_4[0] != 1) {
            goto LABEL_242;
          }
          int v161 = *__error();
          id v162 = _sa_logt();
          if (os_log_type_enabled(v162, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v170 = [self debugDescription];
            *(_DWORD *)int32x4_t uu = 138412290;
            *(void *)&uu[4] = v170;
            _os_log_debug_impl(&dword_1BF22B000, v162, OS_LOG_TYPE_DEBUG, "SAKTSYM symbol owner %@ contiguous, but has no load address", uu, 0xCu);
          }
          *__error() = v161;
          goto LABEL_241;
        }
        uint64_t v24 = self;
        if (v158 - a4 >= a5)
        {
          uint64_t v163 = +[SABinaryLoadInfo binaryLoadInfoWithBinary:loadAddress:isInKernelAddressSpace:exclave:]((uint64_t)SABinaryLoadInfo, self, v158, a3, 0);
          [v151 addObject:v163];

LABEL_241:
          uint64_t v24 = self;
          goto LABEL_242;
        }
        ++v189;
LABEL_242:

LABEL_20:
        ++v7;
        ++v5;
        if (v7 == v200) {
          goto LABEL_255;
        }
      }
      if (_MergedGlobals_4[0] != 1) {
        goto LABEL_218;
      }
      int v148 = *__error();
      id v149 = _sa_logt();
      if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v167 = [self debugDescription];
        *(_DWORD *)int32x4_t uu = 138412290;
        *(void *)&uu[4] = v167;
        _os_log_debug_impl(&dword_1BF22B000, v149, OS_LOG_TYPE_DEBUG, "SAKTSYM symbol owner %@ not contiguous, but has no segments", uu, 0xCu);
      }
LABEL_216:

      *__error() = v148;
      if (v181) {
        goto LABEL_241;
      }
      uint64_t v193 = -1;
      uint64_t v190 = -1;
      goto LABEL_224;
    }
    int v189 = 0;
    int v194 = 0;
LABEL_255:
    if ((v194 > 0 || v189 > 0) && _MergedGlobals_4[0] == 1)
    {
      int v173 = *__error();
      char v174 = _sa_logt();
      if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int32x4_t uu = 67109888;
        *(_DWORD *)&uu[4] = v194;
        *(_WORD *)&uu[8] = 1024;
        *(_DWORD *)&uu[10] = v189;
        *(_WORD *)&uu[14] = 2048;
        *(void *)&uu[16] = a4;
        *(_WORD *)uint64_t v207 = 2048;
        *(void *)&v207[2] = a4 + a5;
        _os_log_debug_impl(&dword_1BF22B000, v174, OS_LOG_TYPE_DEBUG, "SAKTSYM %d segments and %d binaries excluded due to range 0x%llx-0x%llx", uu, 0x22u);
      }

      *__error() = v173;
    }
    +[SABinaryLoadInfo sortBinaryLoadInfos:]((uint64_t)SABinaryLoadInfo, v196);
    char v175 = (void *)[v196 copy];
  }
  else
  {
    char v175 = 0;
  }
  return v175;
}

size_t __78__SASampleStore_KPerf__loadInfosForKTSymbolOwners_isKernelSpace_excludeRange___block_invoke()
{
  return fwrite("Ktrace load info for 64-bit arm kernel binary segment has no name, assuming TEXT_EXEC segment...\n", 0x61uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
}

void __116__SASampleStore_KPerf__addLoadInfoFromKTrace_lastKTraceEventTimestamp_checkForNewLoadInfosEvenWithExistingLoadInfo___block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v516 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  -[SASampleStore _lastTaskOnOrBeforeTimestamp:inTasks:](*(void *)(a1 + 32), *(void **)(a1 + 40), v6);
  id v7 = (char *)objc_claimAutoreleasedReturnValue();
  uint64_t v8 = v7;
  if (!v7)
  {
    if (_MergedGlobals_4[0] == 1)
    {
      int v13 = *__error();
      uint64_t v14 = _sa_logt();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        int v370 = [v5 intValue];
        v371 = [*(id *)(a1 + 40) debugDescription];
        *(_DWORD *)long long buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v370;
        *(_WORD *)&uint8_t buf[8] = 2112;
        *(void *)&buf[10] = v371;
        _os_log_debug_impl(&dword_1BF22B000, v14, OS_LOG_TYPE_DEBUG, "SAKTSYM No tasks with pid %d before last ktrace timestamp %@", buf, 0x12u);
      }
      *__error() = v13;
    }
    goto LABEL_27;
  }
  if ([v7 pid])
  {
    uint64_t v9 = [v8 binaryLoadInfos];
    if ([v9 count])
    {
      int v10 = *(unsigned __int8 *)(a1 + 56);

      if (!v10)
      {
        if (_MergedGlobals_4[0] == 1)
        {
          int v11 = *__error();
          unsigned int v12 = _sa_logt();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            id v373 = [v8 name];
            *(_DWORD *)long long buf = 138412546;
            *(void *)&uint8_t buf[4] = v373;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = [v8 pid];
            _os_log_debug_impl(&dword_1BF22B000, v12, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Already have load info, not checking libktrace", buf, 0x12u);
          }
          *__error() = v11;
        }
LABEL_27:

        return;
      }
    }
    else
    {
    }
  }
  [v8 pid];
  double v15 = (void *)ktrace_dumpbuffer_address_space_pid();
  uint64_t v16 = v15;
  if (!v15)
  {
    if (_MergedGlobals_4[0] == 1)
    {
      int v21 = *__error();
      uint64_t v24 = _sa_logt();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v372 = [v8 name];
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v372;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = [v8 pid];
        _os_log_debug_impl(&dword_1BF22B000, v24, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] libktrace doesn't have load info", buf, 0x12u);
      }
      double v23 = __error();
      goto LABEL_25;
    }
LABEL_26:

    goto LABEL_27;
  }
  id v17 = v15;
  uint64_t v18 = (const char *)[v17 bytes];
  unint64_t v19 = [v17 length];
  unint64_t v20 = v19;
  v501 = (flatbuffers::Table *)v18;
  unint64_t v502 = v19;
  long long v503 = xmmword_1BF316770;
  uint64_t v504 = 0;
  char v505 = 1;
  if (v19 >= 0x7FFFFFFF) {
    __assert_rtn("Verifier", "flatbuffers.h", 2280, "size_ < FLATBUFFERS_MAX_BUFFER_SIZE");
  }
  if (v19 < 8) {
    goto LABEL_18;
  }
  if (strncmp(v18 + 4, "SYMB", 4uLL)) {
    goto LABEL_18;
  }
  unint64_t v25 = *(unsigned int *)v18;
  if ((int)v25 < 1) {
    goto LABEL_18;
  }
  if (v20 - 1 < v25) {
    goto LABEL_18;
  }
  uint64_t v26 = (const unsigned __int8 *)&v18[v25];
  if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)&v18[v25])
    || !flatbuffers::Table::VerifyOffset((flatbuffers::Table *)&v18[v25], (const flatbuffers::Verifier *)&v501, 4u))
  {
    goto LABEL_18;
  }
  uint64_t v27 = &v26[-*(int *)v26];
  if (*(unsigned __int16 *)v27 >= 5u)
  {
    uint64_t v28 = *((unsigned __int16 *)v27 + 2);
    if (v28)
    {
      if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, &v26[v28 + *(unsigned int *)&v26[v28]], 4uLL, 0))goto LABEL_18; {
      uint64_t v29 = &v26[-*(int *)v26];
      }
      if (*(unsigned __int16 *)v29 >= 5u)
      {
        uint64_t v30 = *((unsigned __int16 *)v29 + 2);
        if (v30)
        {
          uint64_t v31 = *(unsigned int *)&v26[v30];
          os_log_t log = (os_log_t)&v26[v30 + v31];
          if (LODWORD(log->isa))
          {
            uint64_t v32 = 0;
            id v33 = &v18[v25 + v31 + v30];
            int v34 = &v18[v25 + v30 + v31];
            int v471 = (char *)(v34 + 8);
            v475 = (char *)(v34 + 16);
            obuint64_t j = (id)(v33 + 8);
            uint64_t v478 = (char *)(v33 + 16);
            do
            {
              uint64_t v35 = (unsigned int *)&log->isa + v32 + 1;
              src = (const unsigned __int8 *)*v35;
              uint64_t v455 = v32;
              unint64_t v488 = (flatbuffers::Table *)&src[(void)v35];
              if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, &src[(void)v35])) {
                goto LABEL_18;
              }
              uint64_t v481 = (flatbuffers::Table *)((char *)v488 - *(int *)v488);
              unsigned int v36 = *(unsigned __int16 *)v481;
              if (v36 >= 5
                && *((_WORD *)v481 + 2)
                && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v488 + *((unsigned __int16 *)v481 + 2)) - v501))
              {
                goto LABEL_18;
              }
              if (!flatbuffers::Table::VerifyOffset(v488, (const flatbuffers::Verifier *)&v501, 6u)) {
                goto LABEL_18;
              }
              if (v36 < 7)
              {
                if (v36 < 5) {
                  goto LABEL_124;
                }
              }
              else if (*((_WORD *)v481 + 3))
              {
                id v37 = (flatbuffers::Table *)((char *)v488
                                           + *((unsigned __int16 *)v481 + 3)
                                           + *(unsigned int *)((char *)v488 + *((unsigned __int16 *)v481 + 3)));
                goto LABEL_50;
              }
              id v37 = 0;
LABEL_50:
              if (*((_WORD *)v481 + 2))
              {
                int v38 = *((unsigned __int8 *)v488 + *((unsigned __int16 *)v481 + 2));
                if (v38 == 3)
                {
                  if (v37 && !FlatbufferSymbols::DyldSharedCacheMetadata::Verify(v37, (flatbuffers::Verifier *)&v501)) {
                    goto LABEL_18;
                  }
                }
                else if (v38 == 2)
                {
                  if (v37 && !FlatbufferSymbols::MachoMetadata::Verify(v37, (flatbuffers::Verifier *)&v501)) {
                    goto LABEL_18;
                  }
                }
                else if (v38 == 1 && v37 != 0)
                {
                  if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v37)|| !flatbuffers::Table::VerifyOffset(v37, (const flatbuffers::Verifier *)&v501, 4u))
                  {
                    goto LABEL_18;
                  }
                  id v40 = (unsigned __int16 *)((char *)v37 - *(int *)v37);
                  if (*v40 >= 5u && (uint64_t v41 = v40[2]) != 0) {
                    BOOL v42 = (const unsigned __int8 *)v37 + v41 + *(unsigned int *)((char *)v37 + v41);
                  }
                  else {
                    BOOL v42 = 0;
                  }
                  if (!flatbuffers::Verifier::VerifyString((flatbuffers::Verifier *)&v501, v42)) {
                    goto LABEL_18;
                  }
                  uint64_t v441 = (unsigned __int16 *)((char *)v37 - *(int *)v37);
                  unsigned int v482 = *v441;
                  if (v482 >= 7
                    && (v441[3]
                     && (v502 < 9
                      || v502 - 8 < (FlatbufferSymbols::DyldSharedCacheMetadata *)((char *)v37 + v441[3]) - v501)
                     || v482 >= 9
                     && v441[4]
                     && (v502 < 9
                      || v502 - 8 < (FlatbufferSymbols::DyldSharedCacheMetadata *)((char *)v37 + v441[4]) - v501)))
                  {
                    goto LABEL_18;
                  }
                  if (!flatbuffers::Table::VerifyOffset(v37, (const flatbuffers::Verifier *)&v501, 0xAu)) {
                    goto LABEL_18;
                  }
                  int v43 = v482 >= 0xB && v441[5]
                      ? (const unsigned __int8 *)v37 + v441[5] + *(unsigned int *)((char *)v37 + v441[5])
                      : 0;
                  if (!flatbuffers::Verifier::VerifyString((flatbuffers::Verifier *)&v501, v43)
                    || !flatbuffers::Table::VerifyOffset(v37, (const flatbuffers::Verifier *)&v501, 0xCu))
                  {
                    goto LABEL_18;
                  }
                  char v44 = (unsigned __int16 *)((char *)v37 - *(int *)v37);
                  if (*v44 >= 0xDu)
                  {
                    uint64_t v45 = v44[6];
                    if (v45)
                    {
                      if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v37 + v45 + *(unsigned int *)((char *)v37 + v45), 4uLL, 0))goto LABEL_18; {
                      uint64_t v46 = (unsigned __int16 *)((char *)v37 - *(int *)v37);
                      }
                      if (*v46 >= 0xDu)
                      {
                        uint64_t v47 = v46[6];
                        if (v47)
                        {
                          unint64_t v413 = (char *)v37 + v47;
                          uint64_t v442 = *(unsigned int *)((char *)v37 + v47);
                          if (*(_DWORD *)((char *)v37 + v47 + v442))
                          {
                            uint64_t v417 = 0;
                            uint64_t v431 = v413 + 4;
                            v483 = (FlatbufferSymbols::DyldSharedCacheMetadata *)((char *)v37 + v47);
                            while (1)
                            {
                              uint64_t v434 = (char *)v483 + v442;
                              uint64_t v438 = *(unsigned int *)((char *)v483 + v442 + 4);
                              uint64_t v424 = (flatbuffers::Table *)((char *)v483 + v442 + v438 + 4);
                              if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v424))break; {
                              uint64_t v428 = v438 - *(int *)&v434[v438 + 4];
                              }
                              unsigned int v435 = *(unsigned __int16 *)&v434[v428 + 4];
                              if (v435 >= 5
                                && (*(_WORD *)((char *)v483 + v442 + v428 + 8)
                                 && (v502 < 9
                                  || v502 - 8 < (unint64_t)&v431[v442
                                                                      + v438
                                                                      + *(unsigned __int16 *)((char *)v483
                                                                                            + v442
                                                                                            + v428
                                                                                            + 8)
                                                                      - (void)v501])
                                 || v435 >= 7
                                 && (*(_WORD *)((char *)v483 + v442 + v428 + 10)
                                  && (v502 < 9
                                   || v502 - 8 < (unint64_t)&v431[v442
                                                                       + v438
                                                                       + *(unsigned __int16 *)((char *)v483
                                                                                             + v442
                                                                                             + v428
                                                                                             + 10)
                                                                       - (void)v501])
                                  || v435 >= 9
                                  && *(_WORD *)((char *)v483 + v442 + v428 + 12)
                                  && (v502 < 9
                                   || v502 - 8 < (unint64_t)&v431[v442
                                                                       + v438
                                                                       + *(unsigned __int16 *)((char *)v483
                                                                                             + v442
                                                                                             + v428
                                                                                             + 12)
                                                                       - (void)v501]))))
                              {
                                break;
                              }
                              if (!flatbuffers::Table::VerifyOffset(v424, (const flatbuffers::Verifier *)&v501, 0xAu)) {
                                break;
                              }
                              if (v435 >= 0xB)
                              {
                                if (*(_WORD *)((char *)v483 + v442 + v428 + 14))
                                {
                                  uint64_t v48 = *(unsigned __int16 *)((char *)v483 + v442 + v428 + 14);
                                  if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v483+ v442+ v438+ v48+ *(unsigned int *)((char *)v483 + v442 + v438 + v48 + 4)+ 4, 1uLL, 0))break; {
                                }
                                  }
                              }
                              LODWORD(v503) = v503 - 1;
                              v431 += 4;
                              v483 = (flatbuffers::Table *)((char *)v483 + 4);
                              if (++v417 >= (unint64_t)*(unsigned int *)&v413[v442]) {
                                goto LABEL_110;
                              }
                            }
LABEL_18:
                            int v21 = *__error();
                            int v22 = _sa_logt();
                            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                            {
                              unint64_t v368 = [v8 name];
                              int v369 = [v8 pid];
                              *(_DWORD *)long long buf = 138412546;
                              *(void *)&uint8_t buf[4] = v368;
                              *(_WORD *)&buf[12] = 1024;
                              *(_DWORD *)&buf[14] = v369;
                              _os_log_error_impl(&dword_1BF22B000, v22, OS_LOG_TYPE_ERROR, "SAKTSYM %@ [%d] libktrace load info failed verification", buf, 0x12u);
                            }
                            double v23 = __error();
LABEL_25:
                            int *v23 = v21;
                            goto LABEL_26;
                          }
                        }
                      }
                    }
                  }
LABEL_110:
                  if (!flatbuffers::Table::VerifyOffset(v37, (const flatbuffers::Verifier *)&v501, 0xEu)) {
                    goto LABEL_18;
                  }
                  int v49 = (unsigned __int16 *)((char *)v37 - *(int *)v37);
                  if (*v49 >= 0xFu)
                  {
                    uint64_t v50 = v49[7];
                    if (v50)
                    {
                      uint64_t v51 = (const unsigned __int8 *)v37 + v50 + *(unsigned int *)((char *)v37 + v50);
                      if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, v51)) {
                        goto LABEL_18;
                      }
                      char v52 = &v51[-*(int *)v51];
                      unsigned int v53 = *(unsigned __int16 *)v52;
                      if (v53 >= 5)
                      {
                        if (*((_WORD *)v52 + 2)
                          && (v502 < 9 || v502 - 8 < &v51[*((unsigned __int16 *)v52 + 2)]
                                                   - (const unsigned __int8 *)v501))
                        {
                          goto LABEL_18;
                        }
                        if (v53 >= 7)
                        {
                          uint64_t v54 = *((unsigned __int16 *)v52 + 3);
                          if (v54)
                          {
                            if (v502 < 9 || v502 - 8 < &v51[v54] - (const unsigned __int8 *)v501) {
                              goto LABEL_18;
                            }
                          }
                        }
                      }
                      LODWORD(v503) = v503 - 1;
                    }
                  }
                  LODWORD(v503) = v503 - 1;
                }
              }
LABEL_124:
              if (!flatbuffers::Table::VerifyOffset(v488, (const flatbuffers::Verifier *)&v501, 8u)) {
                goto LABEL_18;
              }
              unsigned int v55 = (unsigned __int16 *)((char *)v488 - *(int *)v488);
              if (*v55 >= 9u)
              {
                uint64_t v56 = v55[4];
                if (v56)
                {
                  if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v488 + v56 + *(unsigned int *)((char *)v488 + v56), 4uLL, 0))goto LABEL_18; {
                  uint64_t v57 = (unsigned __int16 *)((char *)v488 - *(int *)v488);
                  }
                  if (*v57 >= 9u)
                  {
                    uint64_t v58 = v57[4];
                    if (v58)
                    {
                      uint64_t v59 = *(unsigned int *)((char *)v488 + v58);
                      v429 = (_DWORD *)((char *)v488 + v58 + v59);
                      if (*v429)
                      {
                        uint64_t v60 = 0;
                        uint64_t v439 = &src[(void)v478 + v59 + v58];
                        uint64_t v436 = &src[(void)v475 + v58 + v59];
                        while (1)
                        {
                          uint64_t v432 = v60;
                          uint64_t v61 = (const unsigned __int8 *)&v429[v60 + 1];
                          uint64_t v418 = *(unsigned int *)v61;
                          uint64_t v484 = (flatbuffers::Table *)&v61[v418];
                          if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, &v61[v418])) {
                            goto LABEL_18;
                          }
                          id v443 = (unsigned __int16 *)((char *)v484 - *(int *)v484);
                          unsigned int v62 = *v443;
                          if (v62 >= 5
                            && v443[2]
                            && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v484 + v443[2]) - v501))
                          {
                            goto LABEL_18;
                          }
                          if (!flatbuffers::Table::VerifyOffset(v484, (const flatbuffers::Verifier *)&v501, 6u)) {
                            goto LABEL_18;
                          }
                          if (v62 < 7) {
                            break;
                          }
                          if (!v443[3]) {
                            goto LABEL_142;
                          }
                          uint64_t v63 = (flatbuffers::Table *)((char *)v484 + v443[3]
                                                                    + *(unsigned int *)((char *)v484 + v443[3]));
LABEL_143:
                          if (v443[2]
                            && v63
                            && *((unsigned char *)v484 + v443[2]) == 1
                            && !FlatbufferSymbols::MachoMetadata::Verify(v63, (flatbuffers::Verifier *)&v501))
                          {
                            goto LABEL_18;
                          }
LABEL_147:
                          if (!flatbuffers::Table::VerifyOffset(v484, (const flatbuffers::Verifier *)&v501, 8u)) {
                            goto LABEL_18;
                          }
                          uint64_t v64 = *(int *)v484;
                          unsigned int v65 = *(unsigned __int16 *)((char *)v484 - v64);
                          if (v65 < 9) {
                            goto LABEL_267;
                          }
                          if (!*(_WORD *)((char *)v484 - v64 + 8))
                          {
                            uint64_t v68 = -v64;
                            goto LABEL_251;
                          }
                          if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v484+ *(unsigned __int16 *)((char *)v484 - v64 + 8)+ *(unsigned int *)((char *)v484 + *(unsigned __int16 *)((char *)v484 - v64 + 8)), 4uLL, 0))goto LABEL_18; {
                          uint64_t v66 = *(int *)v484;
                          }
                          uint64_t v67 = (char *)v484 - v66;
                          unsigned int v65 = *(unsigned __int16 *)((char *)v484 - v66);
                          if (v65 < 9) {
                            goto LABEL_267;
                          }
                          uint64_t v68 = -v66;
                          uint64_t v69 = *((unsigned __int16 *)v67 + 4);
                          if (!v69) {
                            goto LABEL_251;
                          }
                          uint64_t v70 = *(unsigned int *)((char *)v484 + v69);
                          int v403 = (_DWORD *)((char *)v484 + v69 + v70);
                          if (!*v403) {
                            goto LABEL_251;
                          }
                          uint64_t v410 = (char *)&v439[v418 + v70 + v69];
                          unint64_t v414 = 0;
                          osos_log_t log = (os_log_t)&v436[v418 + v69 + v70];
                          do
                          {
                            uint64_t v71 = (const unsigned __int8 *)&v403[v414 + 1];
                            uint64_t v399 = *(unsigned int *)v71;
                            uint64_t v444 = (flatbuffers::Table *)&v71[v399];
                            if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, &v71[v399])
                              || !flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 4u))
                            {
                              goto LABEL_18;
                            }
                            uint64_t v72 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            if (*v72 >= 5u && (uint64_t v73 = v72[2]) != 0) {
                              unint64_t v74 = (const unsigned __int8 *)v444 + v73 + *(unsigned int *)((char *)v444 + v73);
                            }
                            else {
                              unint64_t v74 = 0;
                            }
                            if (!flatbuffers::Verifier::VerifyString((flatbuffers::Verifier *)&v501, v74)) {
                              goto LABEL_18;
                            }
                            unint64_t v419 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            unsigned int v75 = *v419;
                            if (v75 >= 7
                              && (v419[3]
                               && (v502 < 9 || v502 - 8 < (flatbuffers::Table *)((char *)v444 + v419[3]) - v501)
                               || v75 >= 9
                               && v419[4]
                               && (v502 < 9 || v502 - 8 < (flatbuffers::Table *)((char *)v444 + v419[4]) - v501)))
                            {
                              goto LABEL_18;
                            }
                            if (!flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 0xAu)) {
                              goto LABEL_18;
                            }
                            if (v75 >= 0xB && v419[5])
                            {
                              if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v444+ v419[5]+ *(unsigned int *)((char *)v444 + v419[5]), 4uLL, 0))goto LABEL_18; {
                              uint64_t v76 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                              }
                              if (*v76 >= 0xBu)
                              {
                                uint64_t v77 = v76[5];
                                if (v77)
                                {
                                  int v395 = (char *)v444 + v77;
                                  uint64_t v397 = (flatbuffers::Table *)*(unsigned int *)((char *)v444 + v77);
                                  if (*(_DWORD *)((char *)v397 + (void)v444 + v77))
                                  {
                                    uint64_t v420 = 0;
                                    uint64_t v78 = &v410[v399 + (void)v397 + v77];
                                    while ((FlatbufferSymbols::Symbol::Verify((FlatbufferSymbols::Symbol *)&v78[*(unsigned int *)v78], (flatbuffers::Verifier *)&v501) & 1) != 0)
                                    {
                                      v78 += 4;
                                      if (++v420 >= (unint64_t)*(unsigned int *)((char *)v397 + (void)v395)) {
                                        goto LABEL_180;
                                      }
                                    }
                                    goto LABEL_18;
                                  }
                                }
                              }
                            }
LABEL_180:
                            if (!flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 0xCu)) {
                              goto LABEL_18;
                            }
                            uint64_t v79 = *(int *)v444;
                            unsigned int v80 = *(unsigned __int16 *)((char *)v444 - v79);
                            if (v80 >= 0xD)
                            {
                              if (*(_WORD *)((char *)v444 - v79 + 12))
                              {
                                if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v444+ *(unsigned __int16 *)((char *)v444 - v79 + 12)+ *(unsigned int *)((char *)v444 + *(unsigned __int16 *)((char *)v444 - v79 + 12)), 1uLL, 0))goto LABEL_18; {
                                uint64_t v81 = *(int *)v444;
                                }
                                uint64_t v82 = -v81;
                                unsigned int v80 = *(unsigned __int16 *)((char *)v444 - v81);
                                LODWORD(v79) = *(_DWORD *)v444;
                              }
                              else
                              {
                                uint64_t v82 = -v79;
                              }
                              if (v80 >= 0xF)
                              {
                                uint64_t v83 = (unsigned __int16 *)((char *)v444 + v82);
                                if (v83[7])
                                {
                                  if (v502 < 9 || v502 - 8 < (flatbuffers::Table *)((char *)v444 + v83[7]) - v501) {
                                    goto LABEL_18;
                                  }
                                }
                                if (v80 >= 0x11
                                  && (v83[8]
                                   && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v444 + v83[8]) - v501)
                                   || v80 >= 0x13
                                   && (v83[9]
                                    && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v444 + v83[9]) - v501)
                                    || v80 >= 0x15
                                    && v83[10]
                                    && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v444 + v83[10]) - v501))))
                                {
                                  goto LABEL_18;
                                }
                              }
                            }
                            if (!flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 0x16u)) {
                              goto LABEL_18;
                            }
                            char v84 = (unsigned __int16 *)((char *)v444 - (int)v79);
                            if (*v84 >= 0x17u)
                            {
                              uint64_t v85 = v84[11];
                              if (v85)
                              {
                                if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v444 + v85 + *(unsigned int *)((char *)v444 + v85), 4uLL, 0))goto LABEL_18; {
                                int v86 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                                }
                                if (*v86 >= 0x17u)
                                {
                                  uint64_t v87 = v86[11];
                                  if (v87)
                                  {
                                    uint64_t v391 = (char *)v444 + v87;
                                    uint64_t v421 = *(unsigned int *)((char *)v444 + v87);
                                    if (*(_DWORD *)((char *)v444 + v87 + v421))
                                    {
                                      uint64_t v392 = 0;
                                      int v88 = &v410[v87 + v399];
                                      v396 = (char *)oslog + v399 + v87;
                                      do
                                      {
                                        uint64_t v398 = (flatbuffers::Table *)&v88[v421 + *(unsigned int *)&v88[v421]];
                                        uint64_t v400 = *(unsigned int *)&v88[v421];
                                        if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v398)|| !flatbuffers::Table::VerifyOffset(v398, (const flatbuffers::Verifier *)&v501, 4u))
                                        {
                                          goto LABEL_18;
                                        }
                                        uint64_t v89 = v400 - *(int *)&v88[v421 + v400];
                                        if (*(unsigned __int16 *)&v88[v421 + v89] >= 5u
                                          && (uint64_t v90 = *(unsigned __int16 *)&v88[v421 + 4 + v89]) != 0)
                                        {
                                          int v91 = (const unsigned __int8 *)&v88[v421
                                                                            + v400
                                                                            + v90
                                                                            + *(unsigned int *)&v88[v421 + v400 + v90]];
                                        }
                                        else
                                        {
                                          int v91 = 0;
                                        }
                                        if (!flatbuffers::Verifier::VerifyString((flatbuffers::Verifier *)&v501, v91)) {
                                          goto LABEL_18;
                                        }
                                        uint64_t v393 = v400 - *(int *)&v88[v421 + v400];
                                        unsigned int v394 = *(unsigned __int16 *)&v88[v421 + v393];
                                        if (v394 >= 7
                                          && (*(_WORD *)&v88[v421 + 6 + v393]
                                           && (v502 < 9
                                            || v502 - 8 < (unint64_t)&v396[v421
                                                                                + v400
                                                                                + *(unsigned __int16 *)&v88[v421 + 6 + v393]
                                                                                - (void)v501])
                                           || v394 >= 9
                                           && *(_WORD *)&v88[v421 + 8 + v393]
                                           && (v502 < 9
                                            || v502 - 8 < (unint64_t)&v396[v421
                                                                                + v400
                                                                                + *(unsigned __int16 *)&v88[v421 + 8 + v393]
                                                                                - (void)v501])))
                                        {
                                          goto LABEL_18;
                                        }
                                        if (!flatbuffers::Table::VerifyOffset(v398, (const flatbuffers::Verifier *)&v501, 0xAu))goto LABEL_18; {
                                        if (v394 >= 0xB)
                                        }
                                        {
                                          if (*(_WORD *)&v88[v421 + 10 + v393])
                                          {
                                            uint64_t v92 = *(unsigned __int16 *)&v88[v421 + 10 + v393];
                                            if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)&v88[v421+ v400+ v92+ *(unsigned int *)&v88[v421 + v400 + v92]], 1uLL, 0))goto LABEL_18; {
                                          }
                                            }
                                        }
                                        LODWORD(v503) = v503 - 1;
                                        v88 += 4;
                                        v396 += 4;
                                      }
                                      while (++v392 < (unint64_t)*(unsigned int *)&v391[v421]);
                                    }
                                  }
                                }
                              }
                            }
                            if (!flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 0x18u)) {
                              goto LABEL_18;
                            }
                            uint64_t v93 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            if (*v93 < 0x19u) {
                              goto LABEL_237;
                            }
                            uint64_t v94 = v93[12];
                            if (!v94) {
                              goto LABEL_237;
                            }
                            if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v444 + v94 + *(unsigned int *)((char *)v444 + v94), 4uLL, 0))goto LABEL_18; {
                            uint64_t v95 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            }
                            if (*v95 >= 0x19u && (uint64_t v96 = v95[12]) != 0) {
                              uint64_t v97 = (_DWORD *)((char *)v444 + v96 + *(unsigned int *)((char *)v444 + v96));
                            }
                            else {
LABEL_237:
                            }
                              uint64_t v97 = 0;
                            if (!flatbuffers::Verifier::VerifyVectorOfTables<FlatbufferSymbols::SymbolNameEntry>((flatbuffers::Verifier *)&v501, v97)|| !flatbuffers::Table::VerifyOffset(v444, (const flatbuffers::Verifier *)&v501, 0x1Au))
                            {
                              goto LABEL_18;
                            }
                            uint64_t v98 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            if (*v98 < 0x1Bu) {
                              goto LABEL_246;
                            }
                            uint64_t v99 = v98[13];
                            if (!v99) {
                              goto LABEL_246;
                            }
                            if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v444 + v99 + *(unsigned int *)((char *)v444 + v99), 4uLL, 0))goto LABEL_18; {
                            uint64_t v100 = (unsigned __int16 *)((char *)v444 - *(int *)v444);
                            }
                            if (*v100 >= 0x1Bu && (uint64_t v101 = v100[13]) != 0) {
                              id v102 = (_DWORD *)((char *)v444 + v101 + *(unsigned int *)((char *)v444 + v101));
                            }
                            else {
LABEL_246:
                            }
                              id v102 = 0;
                            if ((flatbuffers::Verifier::VerifyVectorOfTables<FlatbufferSymbols::SymbolNameEntry>((flatbuffers::Verifier *)&v501, v102) & 1) == 0)goto LABEL_18; {
                            LODWORD(v503) = v503 - 1;
                            }
                            osos_log_t log = (os_log_t)((char *)oslog + 4);
                            v410 += 4;
                            ++v414;
                          }
                          while (v414 < *v403);
                          uint64_t v103 = *(int *)v484;
                          uint64_t v68 = -v103;
                          unsigned int v65 = *(unsigned __int16 *)((char *)v484 - v103);
LABEL_251:
                          if (v65 >= 0xB)
                          {
                            unint64_t v104 = (unsigned __int16 *)((char *)v484 + v68);
                            if (v104[5])
                            {
                              if (v502 < 9 || v502 - 8 < (flatbuffers::Table *)((char *)v484 + v104[5]) - v501) {
                                goto LABEL_18;
                              }
                            }
                            if (v65 >= 0xD
                              && (v104[6]
                               && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v484 + v104[6]) - v501)
                               || v65 >= 0xF
                               && (v104[7]
                                && (v502 < 2 || v502 - 1 < (flatbuffers::Table *)((char *)v484 + v104[7]) - v501)
                                || v65 >= 0x11
                                && v104[8]
                                && (v502 < 5 || v502 - 4 < (flatbuffers::Table *)((char *)v484 + v104[8]) - v501))))
                            {
                              goto LABEL_18;
                            }
                          }
LABEL_267:
                          LODWORD(v503) = v503 - 1;
                          uint64_t v60 = v432 + 1;
                          v439 += 4;
                          v436 += 4;
                          if (v432 + 1 >= (unint64_t)*v429) {
                            goto LABEL_268;
                          }
                        }
                        if (v62 < 5) {
                          goto LABEL_147;
                        }
LABEL_142:
                        uint64_t v63 = 0;
                        goto LABEL_143;
                      }
                    }
                  }
                }
              }
LABEL_268:
              if (!flatbuffers::Table::VerifyOffset(v488, (const flatbuffers::Verifier *)&v501, 0xAu)) {
                goto LABEL_18;
              }
              int v105 = (unsigned __int16 *)((char *)v488 - *(int *)v488);
              if (*v105 >= 0xBu)
              {
                uint64_t v106 = v105[5];
                if (v106)
                {
                  if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, (const unsigned __int8 *)v488 + v106 + *(unsigned int *)((char *)v488 + v106), 4uLL, 0))goto LABEL_18; {
                  uint64_t v107 = (unsigned __int16 *)((char *)v488 - *(int *)v488);
                  }
                  if (*v107 >= 0xBu)
                  {
                    uint64_t v108 = v107[5];
                    if (v108)
                    {
                      uint64_t v109 = (flatbuffers::Table *)*(unsigned int *)((char *)v488 + v108);
                      uint64_t v415 = (char *)v488 + v108;
                      if (*(_DWORD *)((char *)v109 + (void)v488 + v108))
                      {
                        unint64_t v430 = 0;
                        uint64_t v440 = &src[(void)v471 + v108];
                        int v110 = &src[v108];
                        uint64_t v111 = (flatbuffers::Table *)&v110[(void)obj];
                        uint64_t v437 = (char *)&v110[(void)v478];
                        v485 = v109;
                        do
                        {
                          id v489 = v111;
                          uint64_t v112 = (char *)v109 + (void)v111;
                          srca = (unsigned char *)*(unsigned int *)((char *)v109 + (void)v111);
                          uint64_t v433 = (unsigned __int8 *)v109 + (void)v111 + (unint64_t)srca;
                          if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, v433)) {
                            goto LABEL_18;
                          }
                          uint64_t v425 = (flatbuffers::Table *)*(int *)((char *)v489 + (unint64_t)&srca[(void)v485]);
                          int64_t v445 = srca - (unsigned char *)v425;
                          unsigned int v113 = *(unsigned __int16 *)&v112[srca - (unsigned char *)v425];
                          if (v113 >= 5
                            && *(_WORD *)((char *)v485 + (void)v489 + v445 + 4)
                            && (v502 < 2
                             || (const unsigned __int8 *)(v502 - 1) < &v440[(void)v485
                                                                          + &srca[*(unsigned __int16 *)((char *)v485 + (void)v489 + v445 + 4)]
                                                                          - (unsigned char *)v501]))
                          {
                            goto LABEL_18;
                          }
                          if (!flatbuffers::Table::VerifyOffset((flatbuffers::Table *)v433, (const flatbuffers::Verifier *)&v501, 6u))goto LABEL_18; {
                          if (v113 < 7)
                          }
                          {
                            if (v113 < 5) {
                              goto LABEL_297;
                            }
                            uint64_t v117 = 0;
                            int v114 = v485;
                            uint64_t v115 = v489;
                          }
                          else
                          {
                            int v114 = v485;
                            uint64_t v115 = v489;
                            if (*(_WORD *)((char *)v485 + (void)v489 + v445 + 6))
                            {
                              uint64_t v116 = &srca[*(unsigned __int16 *)((char *)v485 + (void)v489 + v445 + 6)];
                              uint64_t v117 = (flatbuffers::Table *)((char *)v485
                                                          + (void)v489
                                                          + (unint64_t)&v116[*(unsigned int *)((char *)v489 + (unint64_t)&v116[(void)v485])]);
                            }
                            else
                            {
                              uint64_t v117 = 0;
                            }
                          }
                          uint64_t v118 = -(uint64_t)v425;
                          if (*(_WORD *)((char *)v114 + (void)v115 + v445 + 4)
                            && v117
                            && *((unsigned char *)v115
                               + (unint64_t)&srca[*(unsigned __int16 *)((char *)v114 + (void)v115 + v445 + 4)
                                                       + (void)v114]) == 1)
                          {
                            if (!FlatbufferSymbols::DyldSharedCacheMetadata::Verify(v117, (flatbuffers::Verifier *)&v501))goto LABEL_18; {
                            uint64_t v119 = *(int *)((char *)v489 + (unint64_t)&srca[(void)v485]);
                            }
                            uint64_t v118 = -v119;
                            unsigned int v113 = *(unsigned __int16 *)((char *)v489 + (unint64_t)&srca[(void)v485 - v119]);
                          }
                          if (v113 >= 9)
                          {
                            uint64_t v120 = *(unsigned __int16 *)&v437[(unint64_t)&srca[v118 + (void)v485]];
                            if (v120)
                            {
                              if (v502 < 9
                                || (const unsigned __int8 *)(v502 - 8) < &v440[(void)v485
                                                                             + &srca[v120]
                                                                             - (unsigned char *)v501])
                              {
                                goto LABEL_18;
                              }
                            }
                          }
LABEL_297:
                          LODWORD(v503) = v503 - 1;
                          uint64_t v109 = v485;
                          v440 += 4;
                          uint64_t v111 = (flatbuffers::Table *)((char *)v489 + 4);
                          v437 += 4;
                          ++v430;
                        }
                        while (v430 < *(unsigned int *)((char *)v485 + (void)v415));
                      }
                    }
                  }
                }
              }
              LODWORD(v503) = v503 - 1;
              uint64_t v32 = v455 + 1;
              v475 += 4;
              v478 += 4;
              obuint64_t j = (char *)obj + 4;
              v471 += 4;
            }
            while (v455 + 1 < (unint64_t)LODWORD(log->isa));
          }
        }
      }
    }
  }
  if (!flatbuffers::Table::VerifyOffset((flatbuffers::Table *)&v18[v25], (const flatbuffers::Verifier *)&v501, 6u)) {
    goto LABEL_18;
  }
  uint64_t v121 = &v26[-*(int *)v26];
  if (*(unsigned __int16 *)v121 >= 7u)
  {
    uint64_t v122 = *((unsigned __int16 *)v121 + 3);
    if (v122)
    {
      if (!flatbuffers::Verifier::VerifyVectorOrString((flatbuffers::Verifier *)&v501, &v26[v122 + *(unsigned int *)&v26[v122]], 4uLL, 0))goto LABEL_18; {
      objc_super v123 = &v26[-*(int *)v26];
      }
      if (*(unsigned __int16 *)v123 >= 7u)
      {
        uint64_t v124 = *((unsigned __int16 *)v123 + 3);
        if (v124)
        {
          unint64_t v125 = *(unsigned int *)&v26[v124];
          id v472 = &v26[v124];
          if (*(_DWORD *)&v26[v124 + v125])
          {
            unint64_t v479 = 0;
            uint64_t v486 = (flatbuffers::Table *)&v18[v25 + 4 + v124];
            uint64_t v126 = &v26[v124];
            v490 = (flatbuffers::Table *)*(unsigned int *)&v26[v124];
            do
            {
              uint64_t v127 = &v126[v125];
              uint64_t v128 = *(unsigned int *)&v126[v125 + 4];
              uint64_t v129 = (unsigned __int8 *)&v126[v125 + 4 + v128];
              if (!flatbuffers::Verifier::VerifyTableStart((flatbuffers::Verifier *)&v501, v129)) {
                goto LABEL_18;
              }
              uint64_t v476 = v128 - *(int *)&v127[v128 + 4];
              unsigned int v130 = *(unsigned __int16 *)&v127[v476 + 4];
              if (v130 >= 5
                && *(_WORD *)((char *)v490 + (void)v126 + v476 + 8)
                && (v502 < 5
                 || (flatbuffers::Table *)(v502 - 4) < (flatbuffers::Table *)((char *)v486
                                                                            + (void)v490
                                                                            + v128
                                                                            + *(unsigned __int16 *)((char *)v490
                                                                                                  + (void)v126
                                                                                                  + v476
                                                                                                  + 8)
                                                                            - (unint64_t)v501)))
              {
                goto LABEL_18;
              }
              if (!flatbuffers::Table::VerifyOffset((flatbuffers::Table *)v129, (const flatbuffers::Verifier *)&v501, 6u))goto LABEL_18; {
              if (v130 >= 7 && *(_WORD *)((char *)v490 + (void)v126 + v476 + 10))
              }
              {
                uint64_t v131 = v128 + *(unsigned __int16 *)((char *)v490 + (void)v126 + v476 + 10);
                id v132 = (const unsigned __int8 *)v490
                     + (void)v126
                     + v131
                     + *(unsigned int *)((char *)v490 + (void)v126 + v131 + 4)
                     + 4;
              }
              else
              {
                id v132 = 0;
              }
              if (!flatbuffers::Verifier::VerifyString((flatbuffers::Verifier *)&v501, v132)) {
                goto LABEL_18;
              }
              LODWORD(v503) = v503 - 1;
              unint64_t v125 = (unint64_t)v490;
              ++v479;
              uint64_t v486 = (flatbuffers::Table *)((char *)v486 + 4);
              v126 += 4;
            }
            while (v479 < *(unsigned int *)((char *)v490 + (void)v472));
          }
        }
      }
    }
  }
  LODWORD(v503) = v503 - 1;
  id v133 = (unsigned int *)[v17 bytes];
  uint64_t v134 = *v133;
  uint64_t v135 = *(unsigned __int16 *)((char *)v133 + v134 - *(int *)((char *)v133 + v134) + 4);
  uint64_t v136 = (unsigned int *)((char *)v133 + v134 + v135);
  uint64_t v137 = *v136;
  id v138 = (unsigned int *)((char *)v136 + v137);
  uint64_t v140 = v138 + 1;
  uint64_t v139 = *v138;
  if (!v139) {
    goto LABEL_26;
  }
  srcb = v8 + 288;
  id v487 = (flatbuffers::Table *)((char *)v133 + v135 + v134 + v137);
  v477 = &v140[v139];
  id v480 = v138 + 3;
  while (1)
  {
    uint64_t v141 = *v140;
    uint64_t v142 = *(int *)((char *)v140 + v141);
    uint64_t v143 = -v142;
    id v491 = (flatbuffers::Table *)((char *)v140 + v141);
    long long v144 = (unsigned __int16 *)((char *)v140 + v141 - v142);
    unsigned int v145 = *v144;
    if (v145 >= 5)
    {
      if (v144[2])
      {
        if (v145 >= 7 && *((unsigned char *)v491 + v144[2]) == 1)
        {
          uint64_t v147 = v144[3];
          if (v147) {
            break;
          }
        }
      }
    }
LABEL_498:
    uint64_t v270 = (unsigned __int16 *)((char *)v491 + v143);
    unsigned int v271 = *v270;
    if (v271 < 5 || !v270[2]) {
      goto LABEL_516;
    }
    if (v271 < 7 || *((unsigned char *)v491 + v270[2]) != 3) {
      goto LABEL_516;
    }
    uint64_t v273 = v270[3];
    if (!v273) {
      goto LABEL_516;
    }
    char v274 = (int *)((char *)v491 + v273 + *(unsigned int *)((char *)v491 + v273));
    uint64_t v275 = (unsigned __int16 *)((char *)v274 - *v274);
    if (*v275 >= 5u)
    {
      uint64_t v276 = v275[2];
      if (v276)
      {
        unsigned __int8 v277 = (char *)v274 + v276 + *(unsigned int *)((char *)v274 + v276);
        memset(uu, 0, sizeof(uu));
        uuid_parse(v277 + 4, uu);
        if (uuid_is_null(uu))
        {
          if (_MergedGlobals_4[0] == 1)
          {
            int v278 = *__error();
            int v279 = _sa_logt();
            if (os_log_type_enabled(v279, OS_LOG_TYPE_DEBUG))
            {
              int v316 = v274;
              uint64_t v317 = [v8 name];
              int v318 = [v8 pid];
              int v319 = (unsigned __int16 *)((char *)v316 - *v316);
              if (*v319 < 5u)
              {
                uint64_t v320 = 0;
              }
              else
              {
                uint64_t v320 = v319[2];
                if (v320) {
                  v320 += (uint64_t)v316 + *(unsigned int *)((char *)v316 + v320);
                }
              }
              *(_DWORD *)long long buf = 138412802;
              *(void *)&uint8_t buf[4] = v317;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v318;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = v320 + 4;
              _os_log_debug_impl(&dword_1BF22B000, v279, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache %{public}s with empty uuid", buf, 0x1Cu);
            }
LABEL_515:

            *__error() = v278;
            goto LABEL_516;
          }
          goto LABEL_516;
        }
        uint64_t v280 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
        if (*v280 < 9u || (uint64_t v281 = v280[4]) == 0)
        {
          if (_MergedGlobals_4[0] != 1) {
            goto LABEL_516;
          }
          int v278 = *__error();
          int v279 = _sa_logt();
          if (os_log_type_enabled(v279, OS_LOG_TYPE_DEBUG))
          {
            long long v323 = v274;
            unint64_t v324 = [v8 name];
            int v325 = [v8 pid];
            uint64_t v326 = (unsigned __int16 *)((char *)v323 - *v323);
            if (*v326 < 5u)
            {
              uint64_t v327 = 0;
            }
            else
            {
              uint64_t v327 = v326[2];
              if (v327) {
                v327 += (uint64_t)v323 + *(unsigned int *)((char *)v323 + v327);
              }
            }
            *(_DWORD *)long long buf = 138412802;
            *(void *)&uint8_t buf[4] = v324;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v325;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v327 + 4;
            _os_log_debug_impl(&dword_1BF22B000, v279, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache %{public}s with no symbol owners", buf, 0x1Cu);
          }
          goto LABEL_515;
        }
        if (!*(_DWORD *)((char *)v491 + v281 + *(unsigned int *)((char *)v491 + v281)))
        {
          if (_MergedGlobals_4[0] != 1) {
            goto LABEL_516;
          }
          BOOL v294 = v274;
          int v278 = *__error();
          int v279 = _sa_logt();
          if (os_log_type_enabled(v279, OS_LOG_TYPE_DEBUG))
          {
            id v342 = [v8 name];
            int v343 = [v8 pid];
            uint64_t v344 = (unsigned __int16 *)((char *)v294 - *v294);
            if (*v344 < 5u)
            {
              uint64_t v345 = 0;
            }
            else
            {
              uint64_t v345 = v344[2];
              if (v345) {
                v345 += (uint64_t)v294 + *(unsigned int *)((char *)v294 + v345);
              }
            }
            *(_DWORD *)long long buf = 138412802;
            *(void *)&uint8_t buf[4] = v342;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v343;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v345 + 4;
            _os_log_debug_impl(&dword_1BF22B000, v279, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache %{public}s with zero symbol owners", buf, 0x1Cu);
          }
          goto LABEL_515;
        }
        uint64_t v458 = v274;
        uint64_t v447 = v140;
        long long v495 = 0u;
        long long v496 = 0u;
        long long v493 = 0u;
        long long v494 = 0u;
        id objc = [*(id *)(a1 + 32) sharedCaches];
        uint64_t v282 = [objc countByEnumeratingWithState:&v493 objects:v506 count:16];
        if (v282)
        {
          unint64_t v474 = 0;
          uint64_t v283 = *(void *)v494;
          do
          {
            for (uint64_t i = 0; i != v282; ++i)
            {
              if (*(void *)v494 != v283) {
                objc_enumerationMutation(objc);
              }
              uint64_t v285 = *(void **)(*((void *)&v493 + 1) + 8 * i);
              *(void *)long long buf = 0;
              *(void *)&uint8_t buf[8] = 0;
              uint64_t v286 = [v285 uuid];
              [v286 getUUIDBytes:buf];

              if (!uuid_compare(buf, uu))
              {
                id v287 = v285;

                unint64_t v474 = v287;
              }
            }
            uint64_t v282 = [objc countByEnumeratingWithState:&v493 objects:v506 count:16];
          }
          while (v282);

          if (v474)
          {
            unsigned int v288 = [v474 binaryLoadInfos];
            BOOL v289 = [v288 count] == 0;

            if (!v289)
            {
              if (_MergedGlobals_4[0] == 1)
              {
                int v290 = *__error();
                unint64_t v291 = _sa_logt();
                if (os_log_type_enabled(v291, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v357 = [v8 name];
                  int v358 = [v8 pid];
                  uint64_t v359 = [v474 debugDescription];
                  *(_DWORD *)long long buf = 138412802;
                  *(void *)&uint8_t buf[4] = v357;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v358;
                  *(_WORD *)&buf[18] = 2112;
                  *(void *)&buf[20] = v359;
                  _os_log_debug_impl(&dword_1BF22B000, v291, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Already have load infos for %@", buf, 0x1Cu);
                }
                *__error() = v290;
              }
LABEL_570:

              uint64_t v140 = v447;
              goto LABEL_516;
            }
            char v295 = 0;
LABEL_544:
            uint64_t v296 = [v474 slide];
            if ((v295 & 1) != 0 || [v474 slidBaseAddress] == -1)
            {
              uint64_t v304 = (unsigned __int16 *)((char *)v458 - *v458);
              if (*v304 >= 0x15u && (uint64_t v305 = v304[10]) != 0)
              {
                uint64_t v306 = *(void *)((char *)v458 + v305);
                if (v306 == -1) {
                  uint64_t v297 = -1;
                }
                else {
                  uint64_t v297 = v306 + v296;
                }
              }
              else
              {
                uint64_t v297 = -1;
              }
            }
            else
            {
              uint64_t v297 = [v474 slidBaseAddress];
              uint64_t v298 = (unsigned __int16 *)((char *)v458 - *v458);
              if (*v298 >= 0x15u)
              {
                uint64_t v299 = v298[10];
                if (v299)
                {
                  uint64_t v300 = *(void *)((char *)v458 + v299);
                  if (v300 != -1)
                  {
                    uint64_t v301 = [v474 slidBaseAddress];
                    if (v300 != [v474 slide] + v301)
                    {
                      int v302 = *__error();
                      uint64_t v303 = _sa_logt();
                      if (os_log_type_enabled(v303, OS_LOG_TYPE_FAULT))
                      {
                        uint64_t v363 = [v474 debugDescription];
                        uint64_t v364 = (void *)v363;
                        unint64_t v365 = (unsigned __int16 *)((char *)v458 - *v458);
                        if (*v365 >= 0x15u && (uint64_t v366 = v365[10]) != 0) {
                          uint64_t v367 = *(void *)((char *)v458 + v366);
                        }
                        else {
                          uint64_t v367 = -1;
                        }
                        *(_DWORD *)long long buf = 138412546;
                        *(void *)&uint8_t buf[4] = v363;
                        *(_WORD *)&buf[12] = 2048;
                        *(void *)&buf[14] = v367;
                        _os_log_fault_impl(&dword_1BF22B000, v303, OS_LOG_TYPE_FAULT, "SAKTSYM kt says shared cache %@ has unslid base address 0x%llx", buf, 0x16u);
                      }
                      *__error() = v302;
                    }
                  }
                }
              }
            }
            int v307 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
            if (*v307 >= 9u && (uint64_t v308 = v307[4]) != 0) {
              uint64_t v309 = (unsigned int *)((char *)v491 + v308 + *(unsigned int *)((char *)v491 + v308));
            }
            else {
              uint64_t v309 = 0;
            }
            uint64_t v310 = [(SASampleStore *)*(void *)(a1 + 32) loadInfosForKTSymbolOwners:0 isKernelSpace:0 excludeRange:0];
            if ([v310 count])
            {
              uint64_t v311 = uuidForBytes((uint64_t)uu);
              +[SASharedCache applyBinaryLoadInfos:sharedCacheUUID:slide:slidBaseAddress:]((uint64_t)SASharedCache, v310, v311, [v474 slide], v297);

              if (_MergedGlobals_4[0] == 1)
              {
                int v312 = *__error();
                uint64_t v313 = _sa_logt();
                if (os_log_type_enabled(v313, OS_LOG_TYPE_DEBUG))
                {
                  id objd = [v8 name];
                  int v346 = [v8 pid];
                  id v347 = (unsigned __int16 *)((char *)v458 - *v458);
                  if (*v347 >= 5u && (uint64_t v348 = v347[2]) != 0) {
                    id v349 = (char *)v458 + v348 + *(unsigned int *)((char *)v458 + v348);
                  }
                  else {
                    id v349 = 0;
                  }
                  uint64_t v361 = [v310 count];
                  id v362 = (unsigned int *)((char *)v491 + *(unsigned __int16 *)((char *)v491 - *(int *)v491 + 8));
                  LODWORD(v362) = *(unsigned int *)((char *)v362 + *v362);
                  *(_DWORD *)long long buf = 138413314;
                  *(void *)&uint8_t buf[4] = objd;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v346;
                  *(_WORD *)&buf[18] = 2080;
                  *(void *)&buf[20] = v349 + 4;
                  __int16 v509 = 2048;
                  uint64_t v510 = v361;
                  __int16 v511 = 1024;
                  LODWORD(v512) = v362;
                  _os_log_debug_impl(&dword_1BF22B000, v313, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] shared cache %s: added %lu load infos from %d symbol owners", buf, 0x2Cu);
                }
                *__error() = v312;
              }
            }
            else if (_MergedGlobals_4[0] == 1)
            {
              int v314 = *__error();
              uint64_t v315 = _sa_logt();
              if (os_log_type_enabled(v315, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v353 = [v8 name];
                int v354 = [v8 pid];
                id v355 = (unsigned __int16 *)((char *)v458 - *v458);
                if (*v355 < 5u)
                {
                  uint64_t v356 = 0;
                }
                else
                {
                  uint64_t v356 = v355[2];
                  if (v356) {
                    v356 += (uint64_t)v458 + *(unsigned int *)((char *)v458 + v356);
                  }
                }
                id v360 = (unsigned int *)((char *)v491 + *(unsigned __int16 *)((char *)v491 - *(int *)v491 + 8));
                LODWORD(v360) = *(unsigned int *)((char *)v360 + *v360);
                *(_DWORD *)long long buf = 138413058;
                *(void *)&uint8_t buf[4] = v353;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v354;
                *(_WORD *)&buf[18] = 2080;
                *(void *)&buf[20] = v356 + 4;
                __int16 v509 = 1024;
                LODWORD(v510) = v360;
                _os_log_debug_impl(&dword_1BF22B000, v315, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] shared cache %s: no load infos from %d symbol owners", buf, 0x22u);
              }
              *__error() = v314;
            }

            goto LABEL_570;
          }
        }
        else
        {
        }
        unint64_t v474 = 0;
        char v295 = 1;
        goto LABEL_544;
      }
    }
    if (_MergedGlobals_4[0] == 1)
    {
      int v278 = *__error();
      int v279 = _sa_logt();
      if (os_log_type_enabled(v279, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v292 = [v8 name];
        int v293 = [v8 pid];
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v292;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v293;
        _os_log_debug_impl(&dword_1BF22B000, v279, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache with no UUID", buf, 0x12u);
      }
      goto LABEL_515;
    }
LABEL_516:
    ++v140;
    ++v480;
    id v487 = (flatbuffers::Table *)((char *)v487 + 4);
    if (v140 == v477) {
      goto LABEL_26;
    }
  }
  int v148 = (int *)((char *)v491 + v147 + *(unsigned int *)((char *)v491 + v147));
  id v149 = (unsigned __int16 *)((char *)v148 - *v148);
  if (*v149 < 7u || (uint64_t v150 = v149[3]) == 0 || (v151 = *(void *)((char *)v148 + v150), v151 == -1))
  {
    if (_MergedGlobals_4[0] == 1)
    {
      int v162 = *__error();
      uint64_t v163 = _sa_logt();
      if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v223 = [v8 name];
        int v224 = [v8 pid];
        char v225 = (unsigned __int16 *)((char *)v148 - *v148);
        if (*v225 < 5u)
        {
          uint64_t v226 = 0;
        }
        else
        {
          uint64_t v226 = v225[2];
          if (v226) {
            v226 += (uint64_t)v148 + *(unsigned int *)((char *)v148 + v226);
          }
        }
        *(_DWORD *)long long buf = 138412802;
        *(void *)&uint8_t buf[4] = v223;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v224;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = v226 + 4;
        _os_log_debug_impl(&dword_1BF22B000, v163, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] process %s missing pid", buf, 0x1Cu);
      }
      *__error() = v162;
    }
    goto LABEL_516;
  }
  if ([v8 pid] == v151)
  {
    uint64_t v152 = (unsigned __int16 *)((char *)v148 - *v148);
    if (*v152 >= 0xBu && (uint64_t v153 = v152[5]) != 0)
    {
      id v154 = (char *)v148 + v153 + *(unsigned int *)((char *)v148 + v153);
      memset(uu, 0, sizeof(uu));
      uuid_parse(v154 + 4, uu);
      uint64_t v473 = uuidForBytes((uint64_t)uu);
      id v155 = [v8 mainBinary];
      BOOL v156 = v155 == 0;

      if (!v156)
      {
        BOOL v157 = [v8 mainBinary];
        uint64_t v158 = [v157 uuid];
        char v159 = [v158 isEqual:v473];

        if ((v159 & 1) == 0)
        {
          int v160 = *__error();
          int v161 = _sa_logt();
          if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT))
          {
            unint64_t v492 = [v8 name];
            int v330 = [v8 pid];
            id obje = [v8 mainBinary];
            uint64_t v331 = [obje debugDescription];
            *(_DWORD *)long long buf = 138413058;
            *(void *)&uint8_t buf[4] = v492;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v330;
            *(_WORD *)&buf[18] = 2112;
            *(void *)&buf[20] = v473;
            __int16 v509 = 2112;
            uint64_t v510 = (uint64_t)v331;
            _os_log_fault_impl(&dword_1BF22B000, v161, OS_LOG_TYPE_FAULT, "SAKTSYM %@ [%d] Mismatched main binary %@ with existing %@", buf, 0x26u);
          }
          *__error() = v160;

          goto LABEL_516;
        }
      }
    }
    else
    {
      uint64_t v473 = 0;
    }
    uint64_t v446 = v140;
    int v164 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
    if (*v164 >= 0xBu && (uint64_t v165 = v164[5]) != 0)
    {
      uint64_t v166 = *(unsigned int *)((char *)v491 + v165);
      uint64_t v167 = *(unsigned int *)((char *)v491 + v165 + v166);
      if (v167)
      {
        uint64_t v168 = 0;
        id obja = (id)(4 * v167);
        uint64_t v169 = (char *)v487 + v141 + v166 + v165;
        uint64_t v416 = (char *)v480 + v141 + v165 + v166;
        char loga = 1;
        while (1)
        {
          uint64_t v170 = *(unsigned int *)((char *)v168 + (void)v169 + 8);
          int v171 = (char *)v168 + (void)v169 + v170;
          uint64_t v172 = v170 - *((int *)v171 + 2);
          int v173 = (char *)v168 + v172 + (void)v169;
          unsigned int v174 = *((unsigned __int16 *)v173 + 4);
          if (v174 >= 5)
          {
            uint64_t v175 = *((unsigned __int16 *)v173 + 6);
            if (v175)
            {
              int v176 = v169[v170 + 8 + v175 + (void)v168];
              BOOL v177 = v174 >= 7 && v176 == 1;
              if (v177 && *(_WORD *)((char *)v168 + v172 + (void)v169 + 14)) {
                break;
              }
            }
          }
          if (_MergedGlobals_4[0] == 1)
          {
            int v189 = *__error();
            uint64_t v190 = _sa_logt();
            if (os_log_type_enabled(v190, OS_LOG_TYPE_DEBUG))
            {
              int v192 = [v8 name];
              int v193 = [v8 pid];
              *(_DWORD *)long long buf = 138412546;
              *(void *)&uint8_t buf[4] = v192;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v193;
              _os_log_debug_impl(&dword_1BF22B000, v190, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] No shared cache metadata", buf, 0x12u);
            }
            goto LABEL_368;
          }
LABEL_370:
          uint64_t v168 = (char *)v168 + 4;
          if (obja == v168) {
            goto LABEL_406;
          }
        }
        uint64_t v456 = *(unsigned __int16 *)((char *)v168 + v172 + (void)v169 + 14);
        uint64_t v178 = *(unsigned int *)&v169[v170 + 8 + v456 + (void)v168];
        uint64_t v179 = v170 + v456 + v178;
        uint64_t v180 = *(int *)((char *)v168 + (void)v169 + v179 + 8);
        char v181 = (char *)v168 + (void)v169 + v179 - v180;
        unsigned int v182 = *((unsigned __int16 *)v181 + 4);
        if (v182 >= 5 && *((_WORD *)v181 + 6))
        {
          uint64_t v422 = *(unsigned int *)&v169[v170 + 8 + v456 + v178 + (void)v168 + *((unsigned __int16 *)v181 + 6)];
          unint64_t v426 = (flatbuffers::Table *)*((unsigned __int16 *)v181 + 6);
          if (v174 <= 8
            || (uint64_t v183 = *(unsigned __int16 *)((char *)v168 + v172 + (void)v169 + 16)) == 0
            || (uint64_t v184 = *(void *)&v169[v170 + 8 + v183 + (void)v168], v184 == -1))
          {
            if (_MergedGlobals_4[0] == 1)
            {
              uint64_t v194 = *(unsigned int *)&v169[v170 + 8 + v456 + (void)v168];
              int v195 = *__error();
              uint64_t v412 = _sa_logt();
              if (os_log_type_enabled(v412, OS_LOG_TYPE_DEBUG))
              {
                os_log_t oslogc = [v8 name];
                int v203 = [v8 pid];
                *(_DWORD *)long long buf = 138412802;
                *(void *)&uint8_t buf[4] = oslogc;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v203;
                *(_WORD *)&buf[18] = 2080;
                *(void *)&buf[20] = (char *)v168 + (void)v416 + (unint64_t)v426 + v170 + v456 + v194 + v422;
                _os_log_debug_impl(&dword_1BF22B000, v412, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache %s with no slide", buf, 0x1Cu);
              }
              *__error() = v195;
            }
            goto LABEL_370;
          }
          uint64_t v411 = *(unsigned int *)&v169[v170 + 8 + v456 + (void)v168];
          if (v182 < 0x15
            || (uint64_t v185 = v170 + v456 + v178,
                (uint64_t v186 = *(unsigned __int16 *)((char *)v168 + (void)v169 + v185 - v180 + 28)) == 0)
            || (uint64_t v187 = *(void *)&v169[v185 + 8 + (void)v168 + v186], v187 == -1))
          {
            if (_MergedGlobals_4[0] == 1)
            {
              int v196 = *__error();
              oschar loga = _sa_logt();
              if (os_log_type_enabled(osloga, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v405 = [v8 name];
                int v207 = [v8 pid];
                uint64_t v208 = &v169[v170 - *((int *)v171 + 2) + (void)v168];
                if (*((unsigned __int16 *)v208 + 4) >= 9u && (uint64_t v209 = *((unsigned __int16 *)v208 + 8)) != 0) {
                  uint64_t v210 = *(void *)&v169[v170 + 8 + v209 + (void)v168];
                }
                else {
                  uint64_t v210 = -1;
                }
                *(_DWORD *)long long buf = 138413058;
                *(void *)&uint8_t buf[4] = v405;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v207;
                *(_WORD *)&buf[18] = 2080;
                *(void *)&buf[20] = (char *)v168 + (void)v416 + (unint64_t)v426 + v170 + v456 + v411 + v422;
                __int16 v509 = 2048;
                uint64_t v510 = v210;
                _os_log_debug_impl(&dword_1BF22B000, osloga, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Shared cache %s with slide 0x%llx has no unslid base address", buf, 0x26u);
              }
              *__error() = v196;
            }
            uint64_t v188 = -1;
          }
          else
          {
            uint64_t v188 = v187 + v184;
          }
          os_log_t oslogb = (os_log_t)v188;
          if (loga)
          {
            *(void *)long long buf = 0;
            *(void *)&uint8_t buf[8] = 0;
            uuid_parse(&v169[(unint64_t)v426 + v170 + v456 + v411 + (void)v168 + 12 + v422], buf);
            BOOL v197 = &v169[v170 - *((int *)v171 + 2) + (void)v168];
            if (*((unsigned __int16 *)v197 + 4) >= 9u && (uint64_t v198 = *((unsigned __int16 *)v197 + 8)) != 0) {
              uint64_t v199 = *(void *)&v169[v170 + 8 + v198 + (void)v168];
            }
            else {
              uint64_t v199 = -1;
            }
            id v200 = -[SASampleStore applySharedCacheToTask:uuid:slide:slidBaseAddress:](*(void *)(a1 + 32), v8, (uint64_t)buf, v199, (uint64_t)oslogb);
            char loga = 0;
            goto LABEL_370;
          }
          int v189 = *__error();
          logb = _sa_logt();
          if (os_log_type_enabled(logb, OS_LOG_TYPE_FAULT))
          {
            uint64_t v404 = [v8 name];
            int v401 = [v8 pid];
            long long v204 = &v169[v170 - *((int *)v171 + 2) + (void)v168];
            if (*((unsigned __int16 *)v204 + 4) >= 9u && (uint64_t v205 = *((unsigned __int16 *)v204 + 8)) != 0) {
              uint64_t v206 = *(void *)&v169[v170 + 8 + v205 + (void)v168];
            }
            else {
              uint64_t v206 = -1;
            }
            unint64_t v402 = [v8 sharedCache];
            uint64_t v211 = [v402 debugDescription];
            *(_DWORD *)long long buf = 138413570;
            *(void *)&uint8_t buf[4] = v404;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v401;
            *(_WORD *)&buf[18] = 2080;
            *(void *)&buf[20] = (char *)v168 + (void)v416 + (unint64_t)v426 + v170 + v456 + v411 + v422;
            __int16 v509 = 2048;
            uint64_t v510 = v206;
            __int16 v511 = 2048;
            os_log_t v512 = oslogb;
            __int16 v513 = 2112;
            unsigned int v212 = (void *)v211;
            uint64_t v514 = v211;
            _os_log_fault_impl(&dword_1BF22B000, logb, OS_LOG_TYPE_FAULT, "SAKTSYM %@ [%d] Ignoring second shared cache %s slide 0x%llx slideBaseAddress 0x%llx (existing %@)", buf, 0x3Au);
          }
          char v191 = __error();
          char loga = 0;
        }
        else
        {
          if (_MergedGlobals_4[0] != 1) {
            goto LABEL_370;
          }
          int v189 = *__error();
          uint64_t v190 = _sa_logt();
          if (os_log_type_enabled(v190, OS_LOG_TYPE_DEBUG))
          {
            long long v201 = [v8 name];
            int v202 = [v8 pid];
            *(_DWORD *)long long buf = 138412546;
            *(void *)&uint8_t buf[4] = v201;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v202;
            _os_log_debug_impl(&dword_1BF22B000, v190, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] No shared cache UUID", buf, 0x12u);
          }
LABEL_368:

          char v191 = __error();
        }
        *char v191 = v189;
        goto LABEL_370;
      }
    }
    else if (_MergedGlobals_4[0] == 1)
    {
      int v213 = *__error();
      uint64_t v214 = _sa_logt();
      if (os_log_type_enabled(v214, OS_LOG_TYPE_DEBUG))
      {
        int v227 = [v8 name];
        int v228 = [v8 pid];
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v227;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v228;
        _os_log_debug_impl(&dword_1BF22B000, v214, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] No shared cache", buf, 0x12u);
      }
      *__error() = v213;
    }
LABEL_406:
    objc_copyStruct(buf, srcb, 8, 1, 0);
    if (!*(void *)buf)
    {
      uint64_t v215 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
      unsigned int v216 = *v215;
      if (v216 >= 5)
      {
        if (v215[2])
        {
          if (v216 >= 7 && *((unsigned char *)v491 + v215[2]) == 2)
          {
            uint64_t v218 = v215[3];
            if (v218)
            {
              int v219 = (int *)((char *)v491 + v218 + *(unsigned int *)((char *)v491 + v218));
              int v220 = (unsigned __int16 *)((char *)v219 - *v219);
              unsigned int v221 = *v220;
              if (v221 < 0xD)
              {
                int v222 = 0;
              }
              else
              {
                int v222 = (int *)v220[6];
                if (v220[6]) {
                  int v222 = (int *)((char *)v222 + (void)v219 + *(unsigned int *)((char *)v222 + (void)v219));
                }
              }
              uint64_t v229 = (unsigned __int16 *)((char *)v222 - *v222);
              if (*v229 >= 7u && (uint64_t v230 = v229[3]) != 0) {
                uint64_t v231 = *(unsigned int *)((char *)v222 + v230);
              }
              else {
                uint64_t v231 = 0;
              }
              if (v221 >= 0xD && (uint64_t v232 = v220[6]) != 0) {
                uint64_t v233 = (int *)((char *)v219 + v232 + *(unsigned int *)((char *)v219 + v232));
              }
              else {
                uint64_t v233 = 0;
              }
              char v234 = (unsigned __int16 *)((char *)v233 - *v233);
              if (*v234 >= 9u && (uint64_t v235 = v234[4]) != 0) {
                int v236 = *(int *)((char *)v233 + v235);
              }
              else {
                int v236 = 0;
              }
              *(void *)long long buf = v231 | ((unint64_t)(v236 & 0xFFFFFF) << 32);
              objc_copyStruct(srcb, buf, 8, 1, 0);
              if (_MergedGlobals_4[0] == 1)
              {
                int v237 = *__error();
                uint64_t v238 = _sa_logt();
                if (os_log_type_enabled(v238, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v350 = [v8 name];
                  int v351 = [v8 pid];
                  objc_copyStruct(uu, srcb, 8, 1, 0);
                  uint64_t FamilyName = CSArchitectureGetFamilyName();
                  *(_DWORD *)long long buf = 138412802;
                  *(void *)&uint8_t buf[4] = v350;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v351;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = FamilyName;
                  _os_log_debug_impl(&dword_1BF22B000, v238, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Applied architecture %{public}s", buf, 0x1Cu);
                }
                *__error() = v237;
              }
            }
          }
        }
      }
    }
    char v239 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
    if (*v239 < 9u || !v239[4])
    {
      if (_MergedGlobals_4[0] == 1)
      {
        int v245 = *__error();
        uint64_t v246 = _sa_logt();
        if (os_log_type_enabled(v246, OS_LOG_TYPE_DEBUG))
        {
          __int16 v321 = [v8 name];
          int v322 = [v8 pid];
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = v321;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v322;
          _os_log_debug_impl(&dword_1BF22B000, v246, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] No symbol owners", buf, 0x12u);
        }
        uint64_t v247 = 0;
        *__error() = v245;
      }
      else
      {
        uint64_t v247 = 0;
      }
      goto LABEL_479;
    }
    uint64_t v240 = [v8 sharedCache];
    int v241 = v240;
    uint64_t v423 = v240;
    if (!v240 || [v240 startAddress] == -1)
    {
      uint64_t v242 = 0;
      unint64_t v244 = 0;
    }
    else
    {
      uint64_t v242 = [v241 startAddress];
      uint64_t v243 = [v241 endAddress];
      unint64_t v244 = v243 - [v241 startAddress];
    }
    uint64_t v247 = v473;
    uint64_t v248 = (unsigned __int16 *)((char *)v491 - *(int *)v491);
    if (*v248 >= 9u && (uint64_t v249 = v248[4]) != 0) {
      long long v250 = (unsigned int *)((char *)v491 + v249 + *(unsigned int *)((char *)v491 + v249));
    }
    else {
      long long v250 = 0;
    }
    -[SASampleStore loadInfosForKTSymbolOwners:isKernelSpace:excludeRange:](*(void *)(a1 + 32), v250, [v8 pid] == 0, v242, v244);
    uint64_t v251 = (flatbuffers::Table *)objc_claimAutoreleasedReturnValue();
    uint64_t v427 = v251;
    if (-[SATask addImageInfos:]((uint64_t)v8, v251))
    {
      if (_MergedGlobals_4[0])
      {
        int v252 = *__error();
        uint64_t v253 = _sa_logt();
        if (os_log_type_enabled(v253, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v332 = [v8 name];
          int v333 = [v8 pid];
          uint64_t v334 = [(flatbuffers::Table *)v427 count];
          uint64_t v335 = (unsigned int *)((char *)v491 + *(unsigned __int16 *)((char *)v491 - *(int *)v491 + 8));
          LODWORD(v335) = *(unsigned int *)((char *)v335 + *v335);
          *(_DWORD *)long long buf = 138413058;
          *(void *)&uint8_t buf[4] = v332;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v333;
          *(_WORD *)&buf[18] = 2048;
          *(void *)&buf[20] = v334;
          __int16 v509 = 1024;
          LODWORD(v510) = v335;
          _os_log_debug_impl(&dword_1BF22B000, v253, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] added %lu load infos from %d symbol owners", buf, 0x22u);
        }
LABEL_463:

        *__error() = v252;
        uint64_t v247 = v473;
        uint64_t v251 = v427;
      }
    }
    else if (_MergedGlobals_4[0])
    {
      int v252 = *__error();
      uint64_t v253 = _sa_logt();
      if (os_log_type_enabled(v253, OS_LOG_TYPE_DEBUG))
      {
        id v336 = [v8 name];
        int v337 = [v8 pid];
        uint64_t v338 = [(flatbuffers::Table *)v427 count];
        long long v339 = (unsigned int *)((char *)v491 + *(unsigned __int16 *)((char *)v491 - *(int *)v491 + 8));
        LODWORD(v339) = *(unsigned int *)((char *)v339 + *v339);
        *(_DWORD *)long long buf = 138413058;
        *(void *)&uint8_t buf[4] = v336;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v337;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v338;
        __int16 v509 = 1024;
        LODWORD(v510) = v339;
        _os_log_debug_impl(&dword_1BF22B000, v253, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] %lu load infos from %d symbol owners (nothing new)", buf, 0x22u);
      }
      goto LABEL_463;
    }
    if (v247)
    {
      long long v499 = 0u;
      long long v500 = 0u;
      long long v497 = 0u;
      long long v498 = 0u;
      os_log_t logc = v251;
      uint64_t v254 = [logc countByEnumeratingWithState:&v497 objects:v507 count:16];
      if (v254)
      {
        id objb = *(id *)v498;
LABEL_467:
        uint64_t v457 = v254;
        uint64_t v255 = 0;
        while (1)
        {
          if (*(id *)v498 != objb) {
            objc_enumerationMutation(logc);
          }
          uint64_t v256 = *(void **)(*((void *)&v497 + 1) + 8 * v255);
          int v257 = [v256 binary];
          uint64_t v258 = [v257 uuid];
          int v259 = [v258 isEqual:v473];

          if (v259) {
            break;
          }
          if (v457 == ++v255)
          {
            uint64_t v254 = [logc countByEnumeratingWithState:&v497 objects:v507 count:16];
            if (v254) {
              goto LABEL_467;
            }
            goto LABEL_476;
          }
        }
        uint64_t v260 = [v256 binary];
        uint64_t v247 = [v260 path];

        if ([v247 isAbsolutePath]) {
          goto LABEL_477;
        }
      }
LABEL_476:
      uint64_t v247 = 0;
LABEL_477:

      uint64_t v251 = v427;
    }

LABEL_479:
    if (!v473)
    {
      if (_MergedGlobals_4[0] == 1)
      {
        int v268 = *__error();
        uint64_t v269 = _sa_logt();
        if (os_log_type_enabled(v269, OS_LOG_TYPE_DEBUG))
        {
          id objg = [v8 name];
          int v328 = [v8 pid];
          uint64_t v459 = [v8 mainBinaryLoadInfo];
          id v329 = [v459 debugDescription];
          *(_DWORD *)long long buf = 138412802;
          *(void *)&uint8_t buf[4] = objg;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v328;
          *(_WORD *)&buf[18] = 2112;
          *(void *)&buf[20] = v329;
          _os_log_debug_impl(&dword_1BF22B000, v269, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] No main binary (assuming %@)", buf, 0x1Cu);
        }
        *__error() = v268;
      }
      goto LABEL_497;
    }
    uint64_t v261 = +[SABinary binaryWithUUID:v473 absolutePath:v247];
    if ([v8 pid])
    {
      uint64_t v262 = [v8 mainBinary];
      BOOL v263 = v262 == 0;

      if (!v263)
      {
        uint64_t v264 = [v8 mainBinary];
        BOOL v265 = v264 == v261;

        if (v265) {
          goto LABEL_496;
        }
        -[SASampleStore setEndTime:]((uint64_t)v8, v261);
        if (_MergedGlobals_4[0] != 1) {
          goto LABEL_496;
        }
        int v266 = *__error();
        int v267 = _sa_logt();
        if (os_log_type_enabled(v267, OS_LOG_TYPE_DEBUG))
        {
          id objf = [v8 name];
          int v460 = [v8 pid];
          uint64_t v340 = [v261 debugDescription];
          *(_DWORD *)long long buf = 138412802;
          *(void *)&uint8_t buf[4] = objf;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v460;
          *(_WORD *)&buf[18] = 2112;
          *(void *)&buf[20] = v340;
          _os_log_debug_impl(&dword_1BF22B000, v267, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Main binary non-lowest %@", buf, 0x1Cu);
        }
        goto LABEL_495;
      }
      -[SASampleStore setEndTime:]((uint64_t)v8, v261);
      if (_MergedGlobals_4[0] == 1)
      {
        int v266 = *__error();
        int v267 = _sa_logt();
        if (os_log_type_enabled(v267, OS_LOG_TYPE_DEBUG))
        {
          id objh = [v8 name];
          int v461 = [v8 pid];
          uint64_t v341 = [v261 debugDescription];
          *(_DWORD *)long long buf = 138412802;
          *(void *)&uint8_t buf[4] = objh;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v461;
          *(_WORD *)&buf[18] = 2112;
          *(void *)&buf[20] = v341;
          _os_log_debug_impl(&dword_1BF22B000, v267, OS_LOG_TYPE_DEBUG, "SAKTSYM %@ [%d] Main binary %@", buf, 0x1Cu);
        }
LABEL_495:

        *__error() = v266;
      }
    }
    else
    {
      -[SASampleStore setEndTime:]((uint64_t)v8, v261);
    }
LABEL_496:

LABEL_497:
    uint64_t v143 = -(uint64_t)*(int *)v491;
    uint64_t v140 = v446;
    goto LABEL_498;
  }
  int v374 = *__error();
  uint64_t v375 = _sa_logt();
  if (os_log_type_enabled(v375, OS_LOG_TYPE_ERROR))
  {
    uint64_t v376 = (unsigned __int16 *)((char *)v148 - *v148);
    if (*v376 >= 7u && (uint64_t v377 = v376[3]) != 0) {
      int v378 = *(int *)((char *)v148 + v377);
    }
    else {
      int v378 = -1;
    }
    id v379 = [v8 debugDescription];
    uint64_t v380 = [v379 UTF8String];
    *(_DWORD *)long long buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v378;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = v380;
    _os_log_error_impl(&dword_1BF22B000, v375, OS_LOG_TYPE_ERROR, "ktrace flatbuffer returned data for pid %d when asking for %s", buf, 0x12u);
  }
  *__error() = v374;
  id v381 = (unsigned __int16 *)((char *)v148 - *v148);
  if (*v381 >= 7u && (uint64_t v382 = v381[3]) != 0) {
    int v383 = *(int *)((char *)v148 + v382);
  }
  else {
    LOBYTE(v383) = -1;
  }
  id v384 = [v8 debugDescription];
  [v384 UTF8String];
  _SASetCrashLogMessage(2328, "ktrace flatbuffer returned data for pid %d when asking for %s", v385, v386, v387, v388, v389, v390, v383);

  _os_crash();
  __break(1u);
}

+ (BOOL)canOpenFileAsKTraceFile:(const char *)a3 errorOut:(id *)a4
{
  if (!ktrace_session_create())
  {
    if (a4)
    {
      id v6 = @"Unable to allocate ktrace_session";
      goto LABEL_7;
    }
    return 0;
  }
  uint64_t v5 = ktrace_set_file();
  ktrace_session_destroy();
  if (v5)
  {
    if (a4)
    {
      id v6 = (__CFString *)(id)objc_msgSend([NSString alloc], "initWithFormat:", @"Unable set file as ktrace: %d", v5);
LABEL_7:
      BOOL result = 0;
      *a4 = v6;
      return result;
    }
    return 0;
  }
  return 1;
}

- (BOOL)parseStackshotsFromKTraceFile:(const char *)a3 warningsOut:(id)a4 errorOut:(id *)a5
{
  id v9 = 0;
  if (a5) {
    id v6 = &v9;
  }
  else {
    id v6 = 0;
  }
  char v7 = -[SASampleStore _parseKTraceFile:stackshotsOnly:warningsOut:errorOut:](self, (uint64_t)a3, 1, a4, v6);
  if (a5) {
    *a5 = v9;
  }

  return v7;
}

- (uint64_t)_parseKTraceFile:(int)a3 stackshotsOnly:(void *)a4 warningsOut:(void *)a5 errorOut:
{
  uint64_t v287 = *MEMORY[0x1E4F143B8];
  id v144 = a4;
  if (!a1)
  {
LABEL_168:
    uint64_t v12 = 0;
    goto LABEL_129;
  }
  uint64_t context = (void *)MEMORY[0x1C18A6A20]();
  if (-[SASampleStore(KPerf) _parseKTraceFile:stackshotsOnly:warningsOut:errorOut:]::onceToken != -1) {
    dispatch_once(&-[SASampleStore(KPerf) _parseKTraceFile:stackshotsOnly:warningsOut:errorOut:]::onceToken, &__block_literal_global_170);
  }
  id v143 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  uint64_t v271 = 0;
  uint64_t v272 = &v271;
  uint64_t v273 = 0x3032000000;
  char v274 = __Block_byref_object_copy__1;
  uint64_t v275 = __Block_byref_object_dispose__1;
  id v276 = (id)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:2];
  v269[0] = 0;
  v269[1] = v269;
  v269[2] = 0x3032000000;
  v269[3] = __Block_byref_object_copy__1;
  v269[4] = __Block_byref_object_dispose__1;
  id v270 = 0;
  uint64_t v265 = 0;
  int v266 = &v265;
  uint64_t v267 = 0x2020000000;
  char v268 = 0;
  uint64_t v261 = 0;
  uint64_t v262 = &v261;
  uint64_t v263 = 0x2020000000;
  char v264 = 0;
  uint64_t v257 = 0;
  uint64_t v258 = &v257;
  uint64_t v259 = 0x2020000000;
  char v260 = 0;
  uint64_t v253 = 0;
  uint64_t v254 = &v253;
  uint64_t v255 = 0x2020000000;
  int v256 = -1;
  uint64_t v247 = 0;
  uint64_t v248 = &v247;
  uint64_t v249 = 0x3032000000;
  long long v250 = __Block_byref_object_copy__1;
  uint64_t v251 = __Block_byref_object_dispose__1;
  id v252 = 0;
  uint64_t v8 = ktrace_session_create();
  if (!v8)
  {
    if (a5)
    {
      uint64_t v12 = 0;
      int v13 = *a5;
      *a5 = @"Unable to allocate ktrace_session";
      goto LABEL_127;
    }
LABEL_27:
    uint64_t v12 = 0;
LABEL_128:
    _Block_object_dispose(&v247, 8);

    _Block_object_dispose(&v253, 8);
    _Block_object_dispose(&v257, 8);
    _Block_object_dispose(&v261, 8);
    _Block_object_dispose(&v265, 8);
    _Block_object_dispose(v269, 8);

    _Block_object_dispose(&v271, 8);
LABEL_129:

    return v12;
  }
  ktrace_set_execnames_enabled();
  ktrace_session_set_event_names_enabled();
  ktrace_session_set_event_names_enabled();
  qos_class_self();
  ktrace_set_collection_qos();
  uint64_t v9 = ktrace_set_file();
  if (v9)
  {
    if (a5)
    {
      uint64_t v10 = objc_msgSend([NSString alloc], "initWithFormat:", @"Unable to set file as ktrace: %d", v9);
      int v11 = *a5;
      *a5 = (void *)v10;
    }
    ktrace_session_destroy();
    goto LABEL_27;
  }
  dispatch_semaphore_t v14 = dispatch_semaphore_create(0);
  uint64_t v240 = MEMORY[0x1E4F143A8];
  uint64_t v241 = 3221225472;
  uint64_t v242 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_184;
  uint64_t v243 = &unk_1E63F8048;
  uint64_t v246 = v8;
  unint64_t v244 = a1;
  double v15 = v14;
  int v245 = v15;
  ktrace_set_completion_handler();
  uint64_t v234 = MEMORY[0x1E4F143A8];
  uint64_t v235 = 3221225472;
  int v236 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2;
  int v237 = &unk_1E63F8070;
  char v239 = &v265;
  id v238 = v144;
  ktrace_chunks();
  uint64_t v224 = MEMORY[0x1E4F143A8];
  uint64_t v225 = 3221225472;
  uint64_t v226 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3;
  int v227 = &unk_1E63F8098;
  uint64_t v231 = &v261;
  uint64_t v232 = &v247;
  uint64_t v233 = &v257;
  uint64_t v230 = &v265;
  int v228 = a1;
  id v229 = v238;
  ktrace_chunks();
  uint64_t v218 = MEMORY[0x1E4F143A8];
  uint64_t v219 = 3221225472;
  int v220 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_196;
  unsigned int v221 = &unk_1E63F80C0;
  id v222 = v229;
  uint64_t v223 = a1;
  ktrace_chunks();
  uint64_t v211 = MEMORY[0x1E4F143A8];
  uint64_t v212 = 3221225472;
  int v213 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_222;
  uint64_t v214 = &unk_1E63F80E8;
  char v217 = &v265;
  id v16 = v222;
  id v215 = v16;
  id v138 = v143;
  id v216 = v138;
  ktrace_chunks();
  uint64_t v140 = a5;
  uint64_t v141 = a1;
  int v139 = a3;
  if ((a3 & 1) == 0)
  {
    uint64_t v204 = MEMORY[0x1E4F143A8];
    uint64_t v205 = 3221225472;
    uint64_t v206 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_233;
    int v207 = &unk_1E63F80E8;
    id v208 = v16;
    uint64_t v209 = a1;
    uint64_t v210 = &v253;
    ktrace_chunks();
  }
  v201[0] = MEMORY[0x1E4F143A8];
  v201[1] = 3221225472;
  v201[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_241;
  v201[3] = &unk_1E63F8070;
  int v203 = &v265;
  id v17 = v16;
  id v202 = v17;
  uint64_t v18 = (void *)MEMORY[0x1C18A6C80](v201);
  ktrace_chunks();
  ktrace_chunks();
  v197[0] = MEMORY[0x1E4F143A8];
  v197[1] = 3221225472;
  v197[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_248;
  v197[3] = &unk_1E63F8110;
  uint64_t v199 = &v265;
  id v19 = v17;
  id v198 = v19;
  id v200 = &v271;
  unint64_t v20 = (void *)MEMORY[0x1C18A6C80](v197);
  ktrace_chunks();
  ktrace_chunks();
  ktrace_chunks();
  uint64_t v191 = MEMORY[0x1E4F143A8];
  uint64_t v192 = 3221225472;
  int v193 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_255;
  uint64_t v194 = &unk_1E63F80C0;
  id v195 = v19;
  int v196 = a1;
  ktrace_chunks();
  uint64_t v184 = MEMORY[0x1E4F143A8];
  uint64_t v185 = 3221225472;
  uint64_t v186 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_259;
  uint64_t v187 = &unk_1E63F8110;
  int v189 = &v265;
  uint64_t v190 = v269;
  id v137 = v195;
  id v188 = v137;
  ktrace_chunks();
  qos_class_t v21 = qos_class_self();
  int v22 = dispatch_get_global_queue(v21, 0);
  int v23 = ktrace_start();

  if (v23)
  {
    if (a5)
    {
      char v134 = v23;
      uint64_t v24 = [[NSString alloc] initWithFormat:@"Unable to ktrace_start session: %d"];
      unint64_t v25 = *a5;
      *a5 = (void *)v24;
    }
    ktrace_session_destroy();
  }
  else
  {
    dispatch_semaphore_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
    ktrace_session_destroy();
    if (*((unsigned char *)v266 + 24) && !*((unsigned char *)v262 + 24)) {
      *((unsigned char *)v258 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    }
    if ((v139 & 1) == 0 && ![a1 dataStyle])
    {
      if (*((unsigned char *)v266 + 24))
      {
        uint64_t v26 = [a1 dataSource] | 2;
        uint64_t v27 = 3;
      }
      else
      {
        uint64_t v26 = [a1 dataSource] | 8;
        uint64_t v27 = 1;
      }
      a1[44] = v26;
      a1[45] = v27;
    }
  }

  if (v23) {
    goto LABEL_27;
  }
  uint64_t v28 = a1;
  uint64_t v29 = (NSObject **)v140;
  char v30 = v139;
  if (([a1 dataSource] & 2) != 0 && !*((unsigned char *)v258 + 24)) {
    int v135 = [a1 kPerfPETParsePastLastStackshot];
  }
  else {
    int v135 = 1;
  }
  if (([a1 dataSource] & 2) != 0 && !objc_msgSend((id)v272[5], "count"))
  {
    if (v140)
    {
      uint64_t v12 = 0;
      int v13 = *v140;
      *uint64_t v140 = @"No stackshot for PET data";
      goto LABEL_127;
    }
    goto LABEL_27;
  }
  id v31 = objc_alloc(MEMORY[0x1E4F1CA48]);
  uint64_t v136 = objc_msgSend(v31, "initWithCapacity:", objc_msgSend((id)v272[5], "count"));
  if (![(id)v272[5] count]) {
    goto LABEL_68;
  }
  id v32 = (id)v272[5];
  id v33 = v136;
  int v148 = v33;
  if (!v33)
  {
    int v105 = *__error();
    uint64_t v106 = _sa_logt();
    if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v284) = 0;
      _os_log_error_impl(&dword_1BF22B000, v106, OS_LOG_TYPE_ERROR, "nil stackshotMachAbsTimes_out", (uint8_t *)&v284, 2u);
    }

    *__error() = v105;
    _SASetCrashLogMessage(2024, "nil stackshotMachAbsTimes_out", v107, v108, v109, v110, v111, v112, v134);
    _os_crash();
    __break(1u);
    goto LABEL_165;
  }
  if ([v33 count])
  {
LABEL_165:
    int v113 = *__error();
    int v114 = _sa_logt();
    if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
    {
      uint64_t v115 = [v148 count];
      LODWORD(v284) = 134217984;
      *(void *)((char *)&v284 + 4) = v115;
      _os_log_error_impl(&dword_1BF22B000, v114, OS_LOG_TYPE_ERROR, "%lu stackshotMachAbsTimes_out.count", (uint8_t *)&v284, 0xCu);
    }

    *__error() = v113;
    char v116 = [v148 count];
    _SASetCrashLogMessage(2025, "%lu stackshotMachAbsTimes_out.count", v117, v118, v119, v120, v121, v122, v116);
    _os_crash();
    __break(1u);
    goto LABEL_168;
  }
  long long v280 = 0u;
  long long v279 = 0u;
  long long v278 = 0u;
  long long v277 = 0u;
  obuint64_t j = v32;
  uint64_t v34 = [obj countByEnumeratingWithState:&v277 objects:&v284 count:16];
  if (v34)
  {
    DWORD1(v146) = 0;
    *((void *)&v146 + 1) = 0;
    uint64_t v147 = *(void *)v278;
    do
    {
      for (uint64_t i = 0; i != v34; ++i)
      {
        if (*(void *)v278 != v147) {
          objc_enumerationMutation(obj);
        }
        id v36 = *(id *)(*((void *)&v277 + 1) + 8 * i);
        id v37 = (int *)[v36 bytes];
        unint64_t v38 = (unint64_t)v37 + [v36 length];
        while (1)
        {
          id v39 = v37 + 4;
          if ((unint64_t)(v37 + 4) > v38) {
            break;
          }
          if ((unint64_t)v39 + v37[1] > v38) {
            break;
          }
          int v40 = *v37;
          if (*v37 == -242132755) {
            break;
          }
          if ((v40 & 0xFFFFFFF0) == 0x20) {
            int v40 = 17;
          }
          if ((v40 - 1) >= 6) {
            uint64_t v41 = v37 + 4;
          }
          else {
            uint64_t v41 = v37 + 12;
          }
          if (v40 == 50)
          {
            if (v41[1] && *v41)
            {
              DWORD1(v146) = *v41;
              *((void *)&v146 + 1) = v41[1];
            }
            else
            {
              int v43 = *__error();
              char v44 = _sa_logt();
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
              {
                int v45 = *v41;
                int v46 = v41[1];
                *(_DWORD *)long long buf = 67109376;
                *(_DWORD *)&uint8_t buf[4] = v45;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v46;
                _os_log_error_impl(&dword_1BF22B000, v44, OS_LOG_TYPE_ERROR, "Bad mach timebase: %d/%d", buf, 0xEu);
              }

              *__error() = v43;
            }
          }
          else if (v40 == 51)
          {
            BOOL v42 = [NSNumber numberWithUnsignedLongLong:*(void *)v41];
            [v148 addObject:v42];
          }
          id v37 = (_DWORD *)((char *)v39 + v37[1]);
        }
      }
      uint64_t v34 = [obj countByEnumeratingWithState:&v277 objects:&v284 count:16];
    }
    while (v34);
  }
  else
  {
    *((void *)&v146 + 1) = 0;
    DWORD1(v146) = 0;
  }

  uint64_t v47 = [v148 lastObject];
  if (![v47 unsignedLongLongValue] || !DWORD2(v146))
  {

    goto LABEL_74;
  }

  if (!DWORD1(v146))
  {
LABEL_74:
    if (v140)
    {
      uint64_t v12 = 0;
      char v52 = *v140;
      *uint64_t v140 = @"No timestamp / timebase in stackshot";
      goto LABEL_125;
    }
    uint64_t v12 = 0;
    int v13 = v148;
LABEL_127:

    goto LABEL_128;
  }
  uint64_t v28 = v141;
  [v141 setMachTimebase:(unint64_t)(v146 >> 32)];
  uint64_t v29 = (NSObject **)v140;
  char v30 = v139;
LABEL_68:
  uint64_t v48 = ktrace_session_create();
  if (!v48)
  {
    if (!v29)
    {
LABEL_81:
      uint64_t v12 = 0;
LABEL_126:
      int v13 = v136;
      goto LABEL_127;
    }
    uint64_t v12 = 0;
    char v52 = *v29;
    const unsigned __int8 *v29 = @"Unable to allocate ktrace_session";
LABEL_125:

    goto LABEL_126;
  }
  ktrace_set_execnames_enabled();
  ktrace_session_set_event_names_enabled();
  ktrace_session_set_event_names_enabled();
  qos_class_self();
  ktrace_set_collection_qos();
  uint64_t v49 = ktrace_set_file();
  if (v49)
  {
    if (v29)
    {
      uint64_t v50 = objc_msgSend([NSString alloc], "initWithFormat:", @"Unable set file as ktrace: %d", v49);
      uint64_t v51 = *v29;
      const unsigned __int8 *v29 = v50;
    }
    ktrace_session_destroy();
    goto LABEL_81;
  }
  dispatch_semaphore_t v53 = dispatch_semaphore_create(0);
  *(void *)&long long v284 = 0;
  *((void *)&v284 + 1) = &v284;
  uint64_t v285 = 0x2020000000;
  uint64_t v286 = 0;
  uint64_t v178 = MEMORY[0x1E4F143A8];
  uint64_t v179 = 3221225472;
  uint64_t v180 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3_272;
  char v181 = &unk_1E63F8138;
  unsigned int v182 = &v284;
  uint64_t v183 = v48;
  ktrace_events_all();
  *(void *)&long long v277 = 0;
  *((void *)&v277 + 1) = &v277;
  long long v278 = 0x2020000000uLL;
  uint64_t v164 = MEMORY[0x1E4F143A8];
  uint64_t v165 = 3221225472;
  uint64_t v166 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_4;
  uint64_t v167 = &unk_1E63F8220;
  uint64_t v168 = v28;
  char v52 = v53;
  uint64_t v169 = v52;
  id v170 = v138;
  int v171 = v269;
  char v177 = v30;
  uint64_t v172 = &v277;
  int v173 = &v271;
  unsigned int v174 = &v284;
  uint64_t v175 = &v265;
  uint64_t v176 = v48;
  ktrace_set_completion_handler();
  if (v30)
  {
    ktrace_chunks();
    long long v151 = 0u;
    long long v152 = 0u;
    long long v149 = 0u;
    long long v150 = 0u;
    id v54 = (id)v272[5];
    uint64_t v55 = [v54 countByEnumeratingWithState:&v149 objects:v281 count:16];
    if (v55)
    {
      uint64_t v56 = *(void *)v150;
      do
      {
        for (uint64_t j = 0; j != v55; ++j)
        {
          if (*(void *)v150 != v56) {
            objc_enumerationMutation(v54);
          }
          [v28 addKCDataStackshot:*(void *)(*((void *)&v149 + 1) + 8 * j)];
        }
        uint64_t v55 = [v54 countByEnumeratingWithState:&v149 objects:v281 count:16];
      }
      while (v55);
    }
  }
  else
  {
    if ([(id)v272[5] count])
    {
      if (v135)
      {
        uint64_t v58 = -1;
      }
      else
      {
        uint64_t v59 = [v136 lastObject];
        uint64_t v58 = [v59 unsignedLongLongValue];
      }
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x2020000000;
      uint64_t v283 = 0;
      uint64_t v60 = [v136 objectAtIndexedSubscript:*(void *)(*((void *)&v277 + 1) + 24)];
      uint64_t v61 = [v60 unsignedLongLongValue];

      uint64_t v283 = v61;
      uint64_t v153 = MEMORY[0x1E4F143A8];
      uint64_t v154 = 3221225472;
      id v155 = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_283;
      BOOL v156 = &unk_1E63F8248;
      char v159 = buf;
      BOOL v157 = v141;
      int v160 = &v271;
      int v161 = &v277;
      uint64_t v162 = v48;
      id v158 = v136;
      char v163 = v135;
      ktrace_events_all();

      _Block_object_dispose(buf, 8);
      uint64_t v28 = v141;
    }
    else
    {
      uint64_t v58 = -1;
    }
    -[SASampleStore _addKPerfDataFromKTraceSession:beforeMachAbsTime:petTimerID:](v28, v48, v58, *((_DWORD *)v254 + 6));
  }
  qos_class_t v62 = qos_class_self();
  uint64_t v63 = dispatch_get_global_queue(v62, 0);
  uint64_t v64 = ktrace_start();

  if (v64)
  {
    if (v140)
    {
      uint64_t v65 = objc_msgSend([NSString alloc], "initWithFormat:", @"Unable to ktrace_start session: %d", v64);
      uint64_t v66 = *v140;
      *uint64_t v140 = (void *)v65;
    }
    ktrace_session_destroy();
    goto LABEL_103;
  }
  dispatch_semaphore_wait(v52, 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v67 = v140;
  uint64_t v68 = v141;
  if (v139) {
    goto LABEL_105;
  }
  char v75 = [v141 dataSource];
  if (!v137) {
    goto LABEL_105;
  }
  if ((v75 & 2) == 0) {
    goto LABEL_105;
  }
  uint64_t v76 = [v141 endTime];
  BOOL v77 = v76 == 0;

  uint64_t v67 = v140;
  uint64_t v68 = v141;
  if (v77) {
    goto LABEL_105;
  }
  uint64_t v78 = [v141 endTime];
  unint64_t v79 = [v78 machAbsTime];

  uint64_t v80 = *(void *)(*((void *)&v277 + 1) + 24);
  if (v80)
  {
    uint64_t v81 = [v136 objectAtIndexedSubscript:v80 - 1];
    unint64_t v82 = [v81 unsignedLongLongValue];

    uint64_t v67 = v140;
    uint64_t v68 = v141;
    if (v82 >= v79) {
      goto LABEL_105;
    }
    if (v82)
    {
      uint64_t v83 = *(void *)(*((void *)&v284 + 1) + 24);
      uint64_t v84 = [v141 machTimebase];
      uint64_t v85 = 0;
      if (v84)
      {
        if (HIDWORD(v84))
        {
          uint64_t v85 = v83 - v82;
          if (v84 != HIDWORD(v84)) {
            uint64_t v85 = __udivti3();
          }
        }
      }
      int v86 = +[SATimestamp timestampWithMachAbsTime:v82 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:0.0];
      uint64_t v87 = [v141 indexOfLastSampleOnOrBeforeTimestamp:v86];

      unint64_t v88 = *(void *)(*((void *)&v277 + 1) + 24);
      uint64_t v68 = v141;
      double v89 = (double)(unint64_t)v85 / 1000000000.0;
      if (v88 < [(id)v272[5] count])
      {
        uint64_t v90 = [v136 objectAtIndexedSubscript:*(void *)(*((void *)&v277 + 1) + 24)];
        uint64_t v91 = [v90 unsignedLongLongValue];
        uint64_t v92 = *(void *)(*((void *)&v284 + 1) + 24);
        uint64_t v93 = [v141 machTimebase];
        uint64_t v94 = 0;
        if (v93)
        {
          if (HIDWORD(v93))
          {
            uint64_t v94 = v91 - v92;
            if (v93 != HIDWORD(v93)) {
              uint64_t v94 = __udivti3();
            }
          }
        }

        id v95 = [NSString alloc];
        uint64_t v96 = [v141 sampleTimestamps];
        uint64_t v97 = objc_msgSend(v95, "initWithFormat:", @"KTrace data ended %.1fs before the next stackshot (%.1fs after the previous stackshot). Data for the last %lu samples will be missing for any threads/tasks after the point at which they stopped using any cpu time", (double)(unint64_t)v94 / 1000000000.0, *(void *)&v89, objc_msgSend(v96, "count") - v87);
        [v137 addObject:v97];
        goto LABEL_160;
      }
      uint64_t v67 = v140;
      if ((v135 & 1) == 0)
      {
        id v104 = [NSString alloc];
        uint64_t v96 = [v141 sampleTimestamps];
        uint64_t v97 = objc_msgSend(v104, "initWithFormat:", @"KTrace data ended %.1fs after the last stackshot. Data for the last %lu samples will be missing for any threads/tasks after the point at which they stopped using any cpu time", (double)(unint64_t)v85 / 1000000000.0, objc_msgSend(v96, "count") - v87);
        [v137 addObject:v97];
LABEL_160:

LABEL_161:
        uint64_t v67 = v140;
        uint64_t v68 = v141;
      }
LABEL_105:
      ktrace_session_destroy();
      if (v248[5] && [v68 targetProcessId] == -1) {
        objc_msgSend(v68, "setTargetProcessId:", objc_msgSend((id)v248[5], "intValue"));
      }
      if ([v68 dataStyle] == 1 || !objc_msgSend(v68, "dataStyle"))
      {
        if ([v68 isEmpty])
        {
          if (v67)
          {
            uint64_t v71 = @"No samples";
LABEL_118:
            uint64_t v72 = *v67;
            *uint64_t v67 = v71;
          }
LABEL_103:
          uint64_t v12 = 0;
LABEL_124:

          _Block_object_dispose(&v277, 8);
          _Block_object_dispose(&v284, 8);
          goto LABEL_125;
        }
      }
      else
      {
        uint64_t v69 = [v68 sampleTimestamps];
        BOOL v70 = [v69 count] == 0;

        uint64_t v67 = v140;
        uint64_t v68 = v141;
        if (v70)
        {
          if (v140)
          {
            uint64_t v71 = @"No PET samples";
            if (v139) {
              uint64_t v71 = @"No stackshots";
            }
            goto LABEL_118;
          }
          goto LABEL_103;
        }
      }
      if (([v68 dataSource] & 2) != 0 && v135 && objc_msgSend(v136, "count"))
      {
        uint64_t v73 = [v136 lastObject];
        -[SASampleStore forwardFillFromLastStackshot:](v68, [v73 unsignedLongLongValue]);

        uint64_t v68 = v141;
      }
      [v68 postprocess];
      uint64_t v12 = 1;
      goto LABEL_124;
    }
    unint64_t v98 = *(void *)(*((void *)&v277 + 1) + 24);
  }
  else
  {
    uint64_t v67 = v140;
    uint64_t v68 = v141;
    if (!v79) {
      goto LABEL_105;
    }
    unint64_t v98 = 0;
  }
  if (v98 < [(id)v272[5] count])
  {
    uint64_t v99 = [v136 objectAtIndexedSubscript:*(void *)(*((void *)&v277 + 1) + 24)];
    uint64_t v100 = [v99 unsignedLongLongValue];
    uint64_t v101 = *(void *)(*((void *)&v284 + 1) + 24);
    uint64_t v102 = [v141 machTimebase];
    uint64_t v103 = 0;
    if (v102)
    {
      if (HIDWORD(v102))
      {
        uint64_t v103 = v100 - v101;
        if (v102 != HIDWORD(v102)) {
          uint64_t v103 = __udivti3();
        }
      }
    }

    if ((double)(unint64_t)v103 / 1000000000.0 <= 0.001) {
      uint64_t v96 = objc_msgSend([NSString alloc], "initWithFormat:", @"KTrace data ended %fs before the stackshot. Data will be missing/incomplete for any threads/tasks after the point at which they stopped using any cpu time", (double)(unint64_t)v103 / 1000000000.0);
    }
    else {
      uint64_t v96 = objc_msgSend([NSString alloc], "initWithFormat:", @"KTrace data ended %.3fs before the stackshot. Data will be missing/incomplete for any threads/tasks after the point at which they stopped using any cpu time", (double)(unint64_t)v103 / 1000000000.0);
    }
    [v137 addObject:v96];
    goto LABEL_161;
  }
  int v123 = *__error();
  uint64_t v124 = _sa_logt();
  if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
  {
    uint64_t v125 = *(void *)(*((void *)&v277 + 1) + 24);
    uint64_t v126 = [v136 count];
    *(_DWORD *)long long buf = 134218240;
    *(void *)&uint8_t buf[4] = v125;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v126;
    _os_log_error_impl(&dword_1BF22B000, v124, OS_LOG_TYPE_ERROR, "nextStackshotIndex %lu, %lu stackshots", buf, 0x16u);
  }

  *__error() = v123;
  uint64_t v127 = *(void *)(*((void *)&v277 + 1) + 24);
  [v136 count];
  _SASetCrashLogMessage(3620, "nextStackshotIndex %lu, %lu stackshots", v128, v129, v130, v131, v132, v133, v127);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

- (BOOL)parseKTraceFile:(const char *)a3 warningsOut:(id)a4 errorOut:(id *)a5
{
  id v9 = 0;
  if (a5) {
    id v6 = &v9;
  }
  else {
    id v6 = 0;
  }
  char v7 = -[SASampleStore _parseKTraceFile:stackshotsOnly:warningsOut:errorOut:](self, (uint64_t)a3, 0, a4, v6);
  if (a5) {
    *a5 = v9;
  }

  return v7;
}

const char *__77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke()
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v0 = getenv("SA_PRINT_KPERF");
  if (v0 || (id v0 = getenv("SA_DEBUG_KPERF")) != 0)
  {
    if (strcmp(v0, "0"))
    {
      strcpy(__filename, "/var/tmp/SAKPerfLog.");
      time_t v9 = time(0);
      localtime_r(&v9, &v10);
      size_t v1 = strftime(&__filename[20], 0x3ECuLL, "%Y-%m-%d-%T", &v10);
      pid_t v2 = getpid();
      snprintf(&__filename[v1 + 20], 1004 - v1, ".%d.txt", v2);
      qword_1EB698F20 = (uint64_t)fopen(__filename, "w");
      if (qword_1EB698F20)
      {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Logging kperf parsing to %s\n", __filename);
        int v3 = *__error();
        id v4 = _sa_logt();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v12 = __filename;
          _os_log_impl(&dword_1BF22B000, v4, OS_LOG_TYPE_DEFAULT, "Logging kperf parsing to %{public}s", buf, 0xCu);
        }
      }
      else
      {
        int v3 = *__error();
        id v4 = _sa_logt();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          int v6 = *__error();
          char v7 = __error();
          uint64_t v8 = strerror(*v7);
          *(_DWORD *)long long buf = 136446722;
          uint64_t v12 = __filename;
          __int16 v13 = 1024;
          int v14 = v6;
          __int16 v15 = 2080;
          id v16 = v8;
          _os_log_error_impl(&dword_1BF22B000, v4, OS_LOG_TYPE_ERROR, "Unable to open %{public}s: %d %s", buf, 0x1Cu);
        }
      }

      *__error() = v3;
    }
  }
  uint64_t result = getenv("SA_LOG_KTSYM");
  if (result || (uint64_t result = getenv("SA_DEBUG_KTSYM")) != 0)
  {
    uint64_t result = (const char *)strcmp(result, "0");
    if (result) {
      _MergedGlobals_4[0] = 1;
    }
  }
  return result;
}

intptr_t __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_184(uint64_t a1)
{
  uint64_t machine = ktrace_get_machine();
  if (machine)
  {
    uint64_t v3 = machine;
    uint64_t v4 = *(void *)(a1 + 32);
    int is_kernel_64_bit = ktrace_is_kernel_64_bit();
    -[SASampleStore _populateFromKtraceMachineInfo:is64bit:](v4, v3, is_kernel_64_bit);
  }
  int v6 = *(NSObject **)(a1 + 40);
  return dispatch_semaphore_signal(v6);
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  uint64_t v2 = DictForChunkViaNSPropertyList();
  id v4 = (id)v2;
  if (v2)
  {
    +[SABinary addSymbolsFromTailspin:v2];
  }
  else
  {
    uint64_t v3 = *(void **)(a1 + 32);
    if (v3) {
      [v3 addObject:@"Unable to get dict for tailspin symbols chunk"];
    }
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3(void *a1)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(*(void *)(a1[6] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  *(unsigned char *)(*(void *)(a1[7] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  uint64_t v2 = DictForChunkViaNSPropertyList();
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t v4 = [v2 objectForKeyedSubscript:0x1F1A808B8];
    uint64_t v5 = *(void *)(a1[8] + 8);
    int v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;

    char v7 = DictGetNumber(v3, @"IsShutdownTrace");
    uint64_t v8 = v7;
    if (v7) {
      *(unsigned char *)(*(void *)(a1[9] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = [v7 BOOLValue];
    }
    uint64_t v9 = objc_opt_class();
    uint64_t v10 = objc_opt_class();
    uint64_t v12 = DictGetDictOfClasses(v3, @"SystemAdvisoryLevels", v9, v10);
    if (v12)
    {
      __int16 v13 = (void *)a1[4];
      if (v13) {
        objc_setProperty_atomic(v13, v11, v12, 504);
      }
    }
    uint64_t v14 = objc_opt_class();
    uint64_t v15 = objc_opt_class();
    id v16 = DictGetDictOfClasses(v3, @"HomeVolumeSpace", v14, v15);

    if (v16)
    {
      uint64_t v18 = (void *)a1[4];
      if (v18) {
        objc_setProperty_atomic(v18, v17, v16, 512);
      }
    }
    uint64_t v19 = objc_opt_class();
    uint64_t v20 = objc_opt_class();
    qos_class_t v21 = DictGetDictOfClasses(v3, @"NonDefaultFeatureFlags", v19, v20);

    if (v21)
    {
      int v23 = (void *)a1[4];
      if (v23) {
        objc_setProperty_atomic(v23, v22, v21, 520);
      }
    }
    uint64_t v24 = DictGetNumber(v3, @"IsRootInstalled");

    if (v24)
    {
      char v25 = [v24 BOOLValue];
      uint64_t v26 = a1[4];
      if (v26) {
        *(unsigned char *)(v26 + 318) = v25;
      }
    }
    objc_opt_class();
    uint64_t v28 = DictGetArrayOfClass(v3, @"InstalledRootNames");
    if (v28)
    {
      uint64_t v29 = (void *)a1[4];
      if (v29)
      {
        objc_setProperty_atomic(v29, v27, v28, 552);
        uint64_t v29 = (void *)a1[4];
      }
      char v30 = [v29 installedRootNames];
      uint64_t v31 = [v30 count];

      if (v31)
      {
        uint64_t v32 = a1[4];
        if (v32) {
          *(unsigned char *)(v32 + 318) = 1;
        }
      }
    }
    id v33 = DictGetNumber(v3, @"OSCryptexFileExtents");

    if (v33)
    {
      int v34 = [v33 intValue];
      uint64_t v35 = a1[4];
      if (v35) {
        *(void *)(v35 + 544) = v34;
      }
    }
    id v36 = DictGetNumber(v3, @"IsAppleInternal");

    if (v36)
    {
      char v37 = [v36 BOOLValue];
      uint64_t v38 = a1[4];
      if (v38)
      {
        *(unsigned char *)(v38 + 319) = v37;
        uint64_t v39 = a1[4];
        if (v39) {
          *(unsigned char *)(v39 + 320) = 1;
        }
      }
    }
    int v40 = DictGetNumber(v3, @"IsInternalCarryDevice");

    if (v40)
    {
      char v41 = [v40 BOOLValue];
      uint64_t v42 = a1[4];
      if (v42)
      {
        *(unsigned char *)(v42 + 321) = v41;
        uint64_t v43 = a1[4];
        if (v43) {
          *(unsigned char *)(v43 + 322) = 1;
        }
      }
    }
    int v45 = DictGetString(v3, @"AutomatedDeviceGroup");
    if (v45)
    {
      int v46 = (void *)a1[4];
      if (v46) {
        objc_setProperty_atomic(v46, v44, v45, 560);
      }
    }
    uint64_t v47 = DictGetDict(v3, @"MostRecentLowPowerModeTransition");

    if (v47)
    {
      id v104 = DictGetNumber(v47, @"LowPowerMode");
      uint64_t v48 = DictGetNumber(v47, @"PowerModeTransitionTimestamp");
      uint64_t v49 = v48;
      if (v104)
      {
        if (!v48 || ([v48 doubleValue], v50 == 0.0))
        {
          char v52 = 0;
        }
        else
        {
          [v49 doubleValue];
          char v52 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:v51];
        }
        id v54 = (id *)a1[4];
        uint64_t v55 = -[SAPowerModeTransition initWithLowPowerMode:timestamp:]((id *)[SAPowerModeTransition alloc], [v104 BOOLValue], v52);
        id v56 = -[SASampleStore addPowerModeTransition:](v54, v55);
      }
      else
      {
        int v57 = *__error();
        uint64_t v58 = _sa_logt();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
          uint64_t v103 = [0 debugDescription];
          [v49 debugDescription];
          *(_DWORD *)long long buf = 138412546;
          uint64_t v106 = v103;
          v108 = __int16 v107 = 2112;
          uint64_t v102 = (void *)v108;
          _os_log_error_impl(&dword_1BF22B000, v58, OS_LOG_TYPE_ERROR, "Invalid power mode transition from tailspin. lowPowerModeNum:%@ transitionTimeNum:%@", buf, 0x16u);
        }
        *__error() = v57;
      }
    }
    objc_opt_class();
    uint64_t v59 = DictGetArrayOfClass(v3, @"KeyboardLanguages");

    uint64_t v61 = v59;
    if (v59)
    {
      qos_class_t v62 = (void *)a1[4];
      if (v62) {
        objc_setProperty_atomic(v62, v60, v59, 568);
      }
    }
    objc_opt_class();
    uint64_t v63 = DictGetArrayOfClass(v3, @"PreferredLanguages");

    uint64_t v65 = v63;
    if (v63)
    {
      uint64_t v66 = (void *)a1[4];
      if (v66) {
        objc_setProperty_atomic(v66, v64, v63, 576);
      }
    }
    uint64_t v67 = DictGetString(v3, @"CountryCode");

    uint64_t v69 = v67;
    if (v67)
    {
      BOOL v70 = (void *)a1[4];
      if (v70) {
        objc_setProperty_atomic(v70, v68, v67, 584);
      }
    }
    uint64_t v71 = DictGetNumber(v3, @"HardwareKeyboard");

    uint64_t v72 = v71;
    if (v71)
    {
      char v73 = [v71 BOOLValue];
      uint64_t v74 = a1[4];
      if (v74)
      {
        *(unsigned char *)(v74 + 3++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v73;
        uint64_t v75 = a1[4];
        if (v75) {
          *(unsigned char *)(v75 + 323) = 1;
        }
      }
    }
    uint64_t v76 = DictGetDict(v3, @"VnodeInfo");

    BOOL v77 = v76;
    if (!v76) {
      goto LABEL_81;
    }
    uint64_t v78 = DictGetNumber(v76, @"NumVnodesAllocated");
    unint64_t v79 = DictGetNumber(v77, @"NumVnodesFree");
    uint64_t v80 = DictGetNumber(v77, @"NumVnodesMax");
    uint64_t v81 = DictGetNumber(v77, @"VnodeDeallocLevel");
    if (!v78 || !v79 || !v80) {
      goto LABEL_80;
    }
    uint64_t v82 = [v78 unsignedLongLongValue];
    uint64_t v83 = a1[4];
    if (v83) {
      *(void *)(v83 + 984) = v82;
    }
    uint64_t v84 = [v79 unsignedLongLongValue];
    uint64_t v85 = a1[4];
    if (v85) {
      *(void *)(v85 + 992) = v84;
    }
    uint64_t v86 = [v80 unsignedLongLongValue];
    uint64_t v87 = a1[4];
    if (v87) {
      *(void *)(v87 + 1000) = v86;
    }
    if (v81)
    {
      int v88 = [v81 unsignedIntValue];
      uint64_t v89 = a1[4];
      if (v88)
      {
        if (v89)
        {
          uint64_t v90 = 2 * *(void *)(v89 + 1000);
LABEL_79:
          *(void *)(v89 + 1008) = v90;
          goto LABEL_80;
        }
        goto LABEL_80;
      }
    }
    else
    {
      uint64_t v89 = a1[4];
    }
    if (v89)
    {
      uint64_t v90 = *(void *)(v89 + 1000);
      goto LABEL_79;
    }
LABEL_80:

LABEL_81:
    uint64_t v91 = DictGetNumber(v3, @"GPURestartCount");

    uint64_t v92 = v91;
    if (v91)
    {
      uint64_t v93 = [v91 unsignedLongLongValue];
      uint64_t v94 = a1[4];
      if (v94) {
        *(void *)(v94 + 592) = v93;
      }
    }
    id v95 = DictGetNumber(v3, @"GPURestartLastMachAbs");

    uint64_t v96 = v95;
    if (v95)
    {
      uint64_t v97 = [v95 unsignedLongLongValue];
      uint64_t v98 = a1[4];
      if (v98) {
        *(void *)(v98 + 600) = v97;
      }
    }
    uint64_t v99 = DictGetNumber(v3, @"HasEnterprisePersona");

    if (v99)
    {
      char v100 = [v99 BOOLValue];
      uint64_t v101 = a1[4];
      if (v101) {
        *(unsigned char *)(v101 + 325) = v100;
      }
    }

    goto LABEL_91;
  }
  dispatch_semaphore_t v53 = (void *)a1[5];
  if (v53) {
    [v53 addObject:@"Unable to get dict for tailspin metadata chunk"];
  }
LABEL_91:
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_196(uint64_t a1)
{
  uint64_t v108 = *MEMORY[0x1E4F143B8];
  DictForChunkViaNSPropertyList();
  id newValue = (id)objc_claimAutoreleasedReturnValue();
  if (!newValue)
  {
    int v32 = *__error();
    id v33 = _sa_logt();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v33, OS_LOG_TYPE_ERROR, "Unable to get dict for tailspin metadata chunk", buf, 2u);
    }

    *__error() = v32;
    int v34 = *(void **)(a1 + 32);
    if (v34) {
      [v34 addObject:@"Unable to get dict for tailspin metadata chunk"];
    }
    goto LABEL_116;
  }
  objc_opt_class();
  uint64_t v80 = DictGetArrayOfClass(newValue, @"experiments");
  if (v80)
  {
    long long v98 = 0u;
    long long v99 = 0u;
    long long v96 = 0u;
    long long v97 = 0u;
    obuint64_t j = v80;
    uint64_t v74 = [obj countByEnumeratingWithState:&v96 objects:v107 count:16];
    if (v74)
    {
      uint64_t v76 = *(void *)v97;
      do
      {
        for (uint64_t i = 0; i != v74; ++i)
        {
          if (*(void *)v97 != v76) {
            objc_enumerationMutation(obj);
          }
          size_t v1 = *(void **)(*((void *)&v96 + 1) + 8 * i);
          long long v92 = 0u;
          long long v93 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          id v2 = v1;
          uint64_t v3 = [v2 countByEnumeratingWithState:&v92 objects:v106 count:16];
          if (v3)
          {
            uint64_t v4 = *(void *)v93;
            do
            {
              uint64_t v5 = 0;
              do
              {
                if (*(void *)v93 != v4) {
                  objc_enumerationMutation(v2);
                }
                int v6 = *(char **)(*((void *)&v92 + 1) + 8 * v5);
                objc_opt_class();
                if (objc_opt_isKindOfClass())
                {
                  id v7 = [v2 objectForKeyedSubscript:v6];
                  if ([v6 isEqualToString:@"namespace_ids"])
                  {
                    uint64_t v8 = objc_opt_class();
                    uint64_t v9 = objc_opt_class();
                    uint64_t v10 = DictGetDictOfClasses(v2, @"namespace_ids", v8, v9);
                    LODWORD(v8) = v10 == 0;

                    if (v8)
                    {
                      int v35 = *__error();
                      id v36 = _sa_logt();
                      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_error_impl(&dword_1BF22B000, v36, OS_LOG_TYPE_ERROR, "Bad type in trial experiments dict: namespaces value is invalid", buf, 2u);
                      }

                      *__error() = v35;
                      uint64_t v38 = *(void **)(a1 + 32);
                      if (v38) {
                        [v38 addObject:@"Bad type in trial experiments dict: namespaces value is invalid"];
                      }
                      goto LABEL_114;
                    }
                  }
                  else if ([v6 isEqualToString:@"experiment_id"])
                  {
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) == 0)
                    {
                      int v43 = *__error();
                      char v44 = _sa_logt();
                      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                      {
                        ClassName = object_getClassName(v7);
                        *(_DWORD *)long long buf = 136315138;
                        uint64_t v103 = ClassName;
                        _os_log_error_impl(&dword_1BF22B000, v44, OS_LOG_TYPE_ERROR, "Bad type in trial experiments dict: experiment is %s", buf, 0xCu);
                      }

                      *__error() = v43;
                      int v46 = *(void **)(a1 + 32);
                      if (v46)
                      {
                        int v22 = objc_msgSend([NSString alloc], "initWithFormat:", @"Bad type in trial experiments dict: experiment is %s", object_getClassName(v7));
                        [v46 addObject:v22];
                        goto LABEL_113;
                      }
                      goto LABEL_114;
                    }
                  }
                  else if ([v6 isEqualToString:@"deployment_id"])
                  {
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) == 0)
                    {
                      int v52 = *__error();
                      dispatch_semaphore_t v53 = _sa_logt();
                      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                      {
                        BOOL v70 = object_getClassName(v7);
                        *(_DWORD *)long long buf = 136315138;
                        uint64_t v103 = v70;
                        _os_log_error_impl(&dword_1BF22B000, v53, OS_LOG_TYPE_ERROR, "Bad type in trial experiments dict: deployment is %s", buf, 0xCu);
                      }

                      *__error() = v52;
                      uint64_t v55 = *(void **)(a1 + 32);
                      if (v55)
                      {
                        int v22 = objc_msgSend([NSString alloc], "initWithFormat:", @"Bad type in trial experiments dict: deployment is %s", object_getClassName(v7));
                        [v55 addObject:v22];
                        goto LABEL_113;
                      }
                      goto LABEL_114;
                    }
                  }
                  else if ([v6 isEqualToString:@"treatment_id"])
                  {
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) == 0)
                    {
                      int v60 = *__error();
                      uint64_t v61 = _sa_logt();
                      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v72 = object_getClassName(v7);
                        *(_DWORD *)long long buf = 136315138;
                        uint64_t v103 = v72;
                        _os_log_error_impl(&dword_1BF22B000, v61, OS_LOG_TYPE_ERROR, "Bad type in trial experiments dict: treatment is %s", buf, 0xCu);
                      }

                      *__error() = v60;
                      uint64_t v63 = *(void **)(a1 + 32);
                      if (v63)
                      {
                        int v22 = objc_msgSend([NSString alloc], "initWithFormat:", @"Bad type in trial experiments dict: treatment is %s", object_getClassName(v7));
                        [v63 addObject:v22];
                        goto LABEL_113;
                      }
                      goto LABEL_114;
                    }
                  }
                  else
                  {
                    int v13 = *__error();
                    uint64_t v14 = _sa_logt();
                    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)long long buf = 138412290;
                      uint64_t v103 = v6;
                      _os_log_debug_impl(&dword_1BF22B000, v14, OS_LOG_TYPE_DEBUG, "Unknown key in experiments dict %@, ignoring", buf, 0xCu);
                    }

                    *__error() = v13;
                  }
                }
                else
                {
                  int v11 = *__error();
                  uint64_t v12 = _sa_logt();
                  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v15 = object_getClassName(v6);
                    *(_DWORD *)long long buf = 138412546;
                    uint64_t v103 = v6;
                    __int16 v104 = 2080;
                    int v105 = v15;
                    _os_log_debug_impl(&dword_1BF22B000, v12, OS_LOG_TYPE_DEBUG, "Unknown key in experiments dict %@ (%s), ignoring", buf, 0x16u);
                  }

                  *__error() = v11;
                }
                ++v5;
              }
              while (v3 != v5);
              uint64_t v3 = [v2 countByEnumeratingWithState:&v92 objects:v106 count:16];
            }
            while (v3);
          }
        }
        uint64_t v74 = [obj countByEnumeratingWithState:&v96 objects:v107 count:16];
      }
      while (v74);
    }
  }
  objc_opt_class();
  DictGetArrayOfClass(newValue, @"rollouts");
  obuint64_t j = (id)objc_claimAutoreleasedReturnValue();
  if (!obj)
  {
LABEL_74:
    uint64_t v31 = *(void **)(a1 + 40);
    if (v31) {
      objc_setProperty_atomic(v31, v16, newValue, 528);
    }
    goto LABEL_115;
  }
  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  id v2 = obj;
  uint64_t v75 = [v2 countByEnumeratingWithState:&v88 objects:v101 count:16];
  if (!v75) {
    goto LABEL_73;
  }
  uint64_t v77 = *(void *)v89;
LABEL_41:
  uint64_t v79 = 0;
LABEL_42:
  if (*(void *)v89 != v77) {
    objc_enumerationMutation(v2);
  }
  id v17 = *(void **)(*((void *)&v88 + 1) + 8 * v79);
  long long v84 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  id v7 = v17;
  uint64_t v18 = [v7 countByEnumeratingWithState:&v84 objects:v100 count:16];
  if (!v18) {
    goto LABEL_71;
  }
  uint64_t v19 = *(void *)v85;
LABEL_46:
  uint64_t v20 = 0;
  while (1)
  {
    if (*(void *)v85 != v19) {
      objc_enumerationMutation(v7);
    }
    qos_class_t v21 = *(void **)(*((void *)&v84 + 1) + 8 * v20);
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      int v26 = *__error();
      uint64_t v27 = _sa_logt();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        char v30 = object_getClassName(v21);
        *(_DWORD *)long long buf = 138412546;
        uint64_t v103 = (const char *)v21;
        __int16 v104 = 2080;
        int v105 = v30;
        _os_log_debug_impl(&dword_1BF22B000, v27, OS_LOG_TYPE_DEBUG, "Unknown key in rollouts dict %@ (%s), ignoring", buf, 0x16u);
      }

      *__error() = v26;
      goto LABEL_69;
    }
    int v22 = [v7 objectForKeyedSubscript:v21];
    if ([v21 isEqualToString:@"factor_pack_ids"])
    {
      uint64_t v23 = objc_opt_class();
      uint64_t v24 = objc_opt_class();
      char v25 = DictGetDictOfClasses(v7, @"factor_pack_ids", v23, v24);
      LODWORD(v23) = v25 == 0;

      if (v23)
      {
        int v39 = *__error();
        int v40 = _sa_logt();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl(&dword_1BF22B000, v40, OS_LOG_TYPE_ERROR, "Bad type in trial rollouts dict: trial factor packs value is invalid", buf, 2u);
        }

        *__error() = v39;
        uint64_t v42 = *(void **)(a1 + 32);
        if (v42) {
          [v42 addObject:@"Bad type in trial rollouts dict: trial factor packs value is invalid"];
        }
        goto LABEL_113;
      }
      goto LABEL_68;
    }
    if ([v21 isEqualToString:@"rollout_id"])
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        int v47 = *__error();
        uint64_t v48 = _sa_logt();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          uint64_t v69 = object_getClassName(v22);
          *(_DWORD *)long long buf = 136315138;
          uint64_t v103 = v69;
          _os_log_error_impl(&dword_1BF22B000, v48, OS_LOG_TYPE_ERROR, "Bad type in trial rollouts dict: rollout is %s", buf, 0xCu);
        }

        *__error() = v47;
        double v50 = *(void **)(a1 + 32);
        if (!v50) {
          goto LABEL_113;
        }
        double v51 = objc_msgSend([NSString alloc], "initWithFormat:", @"Bad type in trial rollouts dict: rollout is %s", object_getClassName(v22));
        [v50 addObject:v51];
        goto LABEL_112;
      }
      goto LABEL_68;
    }
    if ([v21 isEqualToString:@"deployment_id"])
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        int v56 = *__error();
        int v57 = _sa_logt();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
        {
          uint64_t v71 = object_getClassName(v22);
          *(_DWORD *)long long buf = 136315138;
          uint64_t v103 = v71;
          _os_log_error_impl(&dword_1BF22B000, v57, OS_LOG_TYPE_ERROR, "Bad type in trial rollouts dict: deployment is %s", buf, 0xCu);
        }

        *__error() = v56;
        uint64_t v59 = *(void **)(a1 + 32);
        if (!v59) {
          goto LABEL_113;
        }
        double v51 = objc_msgSend([NSString alloc], "initWithFormat:", @"Bad type in trial rollouts dict: deployment is %s", object_getClassName(v22));
        [v59 addObject:v51];
LABEL_112:

        goto LABEL_113;
      }
      goto LABEL_68;
    }
    if (![v21 isEqualToString:@"ramp_id"])
    {
      int v28 = *__error();
      uint64_t v29 = _sa_logt();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v103 = (const char *)v21;
        _os_log_debug_impl(&dword_1BF22B000, v29, OS_LOG_TYPE_DEBUG, "Unknown key in experiments dict %@, ignoring", buf, 0xCu);
      }

      *__error() = v28;
      goto LABEL_68;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      break;
    }
LABEL_68:

LABEL_69:
    if (v18 == ++v20)
    {
      uint64_t v18 = [v7 countByEnumeratingWithState:&v84 objects:v100 count:16];
      if (v18) {
        goto LABEL_46;
      }
LABEL_71:

      if (++v79 == v75)
      {
        uint64_t v75 = [v2 countByEnumeratingWithState:&v88 objects:v101 count:16];
        if (!v75)
        {
LABEL_73:

          goto LABEL_74;
        }
        goto LABEL_41;
      }
      goto LABEL_42;
    }
  }
  int v64 = *__error();
  uint64_t v65 = _sa_logt();
  if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
  {
    char v73 = object_getClassName(v22);
    *(_DWORD *)long long buf = 136315138;
    uint64_t v103 = v73;
    _os_log_error_impl(&dword_1BF22B000, v65, OS_LOG_TYPE_ERROR, "Bad type in trial rollouts dict: ramp is %s", buf, 0xCu);
  }

  *__error() = v64;
  uint64_t v67 = *(void **)(a1 + 32);
  if (v67)
  {
    double v51 = objc_msgSend([NSString alloc], "initWithFormat:", @"Bad type in trial rollouts dict: ramp is %s", object_getClassName(v22));
    [v67 addObject:v51];
    goto LABEL_112;
  }
LABEL_113:

LABEL_114:
LABEL_115:

LABEL_116:
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_222(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  ktrace_chunk_size();
  uint64_t v2 = ktrace_chunk_copy_cfdata();
  if (v2)
  {
    uint64_t v3 = (void *)v2;
    id v6 = [MEMORY[0x1E4F28F98] propertyListWithData:v2 options:0 format:0 error:0];

    if (v6)
    {
      objc_msgSend(*(id *)(a1 + 40), "addObject:");
    }
    else
    {
      uint64_t v5 = *(void **)(a1 + 32);
      if (v5) {
        [v5 addObject:@"Unable to deserialize dictionary from tailspin process info chunk"];
      }
    }
  }
  else
  {
    uint64_t v4 = *(void **)(a1 + 32);
    if (v4)
    {
      [v4 addObject:@"Unable to get data for tailspin process info chunk"];
    }
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_233(uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!ktrace_config_create())
  {
    uint64_t v8 = *(void **)(a1 + 32);
    if (v8)
    {
      [v8 addObject:@"Unable to parse ktrace config chunk"];
    }
    return;
  }
  reasouint64_t n = (unsigned char *)ktrace_config_get_reason();
  if (reason && *reason)
  {
    uint64_t v3 = SANSStringForCString(reason);
    [*(id *)(a1 + 40) setReason:v3];
  }
  id v45 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  int pet_mode = ktrace_config_kperf_get_pet_mode();
  if (pet_mode)
  {
    if (pet_mode == 2)
    {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = ktrace_config_kperf_get_pet_timer_id();
      if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) & 0x80000000) != 0)
      {
        int v5 = *__error();
        id v6 = _sa_logt();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v46.receiver) = 0;
          _os_log_error_impl(&dword_1BF22B000, v6, OS_LOG_TYPE_ERROR, "Unable to get lightweight PET timer, treating as non-PET", (uint8_t *)&v46, 2u);
        }

        *__error() = v5;
        id v7 = *(void **)(a1 + 32);
        if (v7) {
          [v7 addObject:@"Unable to get lightweight PET timer, treating ktrace data as non-PET"];
        }
      }
    }
    else
    {
      int v12 = *__error();
      int v13 = _sa_logt();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v46.receiver) = 0;
        _os_log_error_impl(&dword_1BF22B000, v13, OS_LOG_TYPE_ERROR, "Non-lightweight PET not supported, treating as non-PET", (uint8_t *)&v46, 2u);
      }

      *__error() = v12;
    }
  }
  else
  {
    uint64_t v9 = *(void **)(a1 + 40);
    uint64_t v10 = [v9 dataSource];
    if (v9) {
      v9[44] = v10 | 8;
    }
    uint64_t v11 = *(void *)(a1 + 40);
    if (v11) {
      *(void *)(v11 + 360) = 1;
    }
  }
  timer_size_t count = ktrace_config_kperf_get_timer_count();
  if (!timer_count) {
    goto LABEL_65;
  }
  unsigned int v16 = 0;
  id v17 = 0;
  *(void *)&long long v15 = 67109120;
  long long v44 = v15;
  do
  {
    unint64_t timer_period_ns = ktrace_config_kperf_get_timer_period_ns();
    if (!timer_period_ns)
    {
      int v28 = *__error();
      uint64_t v29 = _sa_logt();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        v46.receiver = (id)__PAIR64__(v16, v44);
        _os_log_error_impl(&dword_1BF22B000, v29, OS_LOG_TYPE_ERROR, "KPerf timer %d has 0 period, ignoring", (uint8_t *)&v46, 8u);
      }
      goto LABEL_39;
    }
    int timer_action_id = ktrace_config_kperf_get_timer_action_id();
    if (!timer_action_id)
    {
      int v28 = *__error();
      uint64_t v29 = _sa_logt();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        v46.receiver = (id)__PAIR64__(v16, v44);
        _os_log_error_impl(&dword_1BF22B000, v29, OS_LOG_TYPE_ERROR, "KPerf timer %d  has no action, ignoring", (uint8_t *)&v46, 8u);
      }
LABEL_39:

      char v30 = __error();
LABEL_46:
      int *v30 = v28;
      goto LABEL_47;
    }
    uint64_t action_samplers = ktrace_config_kperf_get_action_samplers();
    if ((action_samplers & 0xC) == 0)
    {
      int v28 = *__error();
      uint64_t v31 = _sa_logt();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        LODWORD(v46.receiver) = 67109632;
        HIDWORD(v46.receiver) = v16;
        LOWORD(v46.super_class) = 1024;
        *(_DWORD *)((char *)&v46.super_class + 2) = timer_action_id;
        HIWORD(v46.super_class) = 2048;
        uint64_t v47 = action_samplers;
        _os_log_impl(&dword_1BF22B000, v31, OS_LOG_TYPE_INFO, "KPerf timer %d (action %d) doesn't sample callstacks (0x%llx), ignoring", (uint8_t *)&v46, 0x18u);
      }

      char v30 = __error();
      goto LABEL_46;
    }
    int v21 = *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    if (v21 < 0 || v16 != v21)
    {
      int v32 = [SAKPerfTrigger alloc];
      if (v32)
      {
        v46.receiver = v32;
        v46.super_class = (Class)SAKPerfTrigger;
        id v33 = objc_msgSendSuper2(&v46, sel_init);
        int v34 = v33;
        if (v33)
        {
          v33[1] = 2;
          v33[2] = timer_period_ns;
          v33[3] = action_samplers;
        }
      }
      else
      {
        int v34 = 0;
      }
      objc_msgSend(v45, "addObject:", v34, v44);
    }
    else
    {
      [*(id *)(a1 + 40) kPerfPETSampleIntervalLimit];
      double v23 = v22 * 1000000000.0;
      if (timer_period_ns <= (unint64_t)v23) {
        unint64_t v24 = (unint64_t)v23;
      }
      else {
        unint64_t v24 = timer_period_ns;
      }
      char v25 = [SAKPerfTrigger alloc];
      if (v25)
      {
        v46.receiver = v25;
        v46.super_class = (Class)SAKPerfTrigger;
        int v26 = objc_msgSendSuper2(&v46, sel_init);
        uint64_t v27 = v26;
        if (v26)
        {
          v26[1] = 1;
          v26[2] = v24;
          v26[3] = action_samplers;
        }
      }
      else
      {
        uint64_t v27 = 0;
      }

      id v17 = v27;
      [v45 addObject:v27];
    }
LABEL_47:
    ++v16;
  }
  while (timer_count != v16);
  if (v17)
  {
    if ((unint64_t)[v45 count] >= 2)
    {
      int v35 = *__error();
      id v36 = _sa_logt();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v46.receiver) = 0;
        _os_log_error_impl(&dword_1BF22B000, v36, OS_LOG_TYPE_ERROR, "Parsing both PET and non-PET data is not supported, parsing only PET data", (uint8_t *)&v46, 2u);
      }

      *__error() = v35;
      [v45 removeAllObjects];
      [v45 addObject:v17];
    }
    char v37 = *(void **)(a1 + 40);
    uint64_t v38 = objc_msgSend(v37, "dataSource", v44);
    if (v37) {
      v37[44] = v38 | 2;
    }
    uint64_t v39 = *(void *)(a1 + 40);
    if (v39) {
      *(void *)(v39 + 360) = 3;
    }
    objc_msgSend(*(id *)(a1 + 40), "setAttemptedSamplingInterval:", (double)(unint64_t)objc_msgSend(v17, "timerPeriodNs") / 1000000000.0);
    goto LABEL_74;
  }
LABEL_65:
  int v40 = *(void **)(a1 + 40);
  uint64_t v41 = objc_msgSend(v40, "dataSource", v44);
  if (v40) {
    v40[44] = v41 | 8;
  }
  uint64_t v42 = *(void *)(a1 + 40);
  if (v42) {
    *(void *)(v42 + 360) = 1;
  }
  if ([v45 count] == 1)
  {
    int v43 = [v45 firstObject];
    if ([v43 type] == 2) {
      objc_msgSend(*(id *)(a1 + 40), "setAttemptedSamplingInterval:", (double)(unint64_t)objc_msgSend(v43, "timerPeriodNs") / 1000000000.0);
    }
  }
  id v17 = 0;
LABEL_74:
  [*(id *)(a1 + 40) setKperfTriggers:v45];
  ktrace_config_destroy();
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_241(uint64_t a1)
{
  if (ktrace_chunk_tag() == 36869) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  ktrace_chunk_size();
  uint64_t v2 = ktrace_chunk_copy_cfdata();
  if (v2)
  {
    id v4 = (id)v2;
    +[SASharedCache addDSCSymData:v2];
  }
  else
  {
    uint64_t v3 = *(void **)(a1 + 32);
    if (v3)
    {
      [v3 addObject:@"Unable to get data for dscsym chunk"];
    }
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_248(void *a1)
{
  if (ktrace_chunk_tag() == 36864) {
    *(unsigned char *)(*(void *)(a1[5] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  ktrace_chunk_size();
  uint64_t v2 = ktrace_chunk_copy_cfdata();
  if (v2)
  {
    uint64_t v3 = (void *)v2;
    if (ktrace_chunk_tag() == 36864)
    {
      uint64_t v4 = SAGetStackshotDataFromTailspinStackshotChunk(v3);

      uint64_t v3 = (void *)v4;
    }
    if ([v3 length])
    {
      [*(id *)(*(void *)(a1[6] + 8) + 40) addObject:v3];
    }
    else
    {
      int v6 = *__error();
      id v7 = _sa_logt();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v8 = 0;
        _os_log_error_impl(&dword_1BF22B000, v7, OS_LOG_TYPE_ERROR, "0-length stackshot chunk", v8, 2u);
      }

      *__error() = v6;
    }
  }
  else
  {
    int v5 = (void *)a1[4];
    if (v5)
    {
      [v5 addObject:@"Unable to get data for stackshot chunk"];
    }
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_255(uint64_t a1)
{
  uint64_t v2 = DictForChunkViaNSUnarchiver();
  id v4 = v2;
  if (v2)
  {
    -[SASampleStore addAddressTranslations:](*(void *)(a1 + 40), v2);
  }
  else
  {
    uint64_t v3 = *(void **)(a1 + 32);
    if (v3) {
      [v3 addObject:@"Unable to get data for address translation chunk"];
    }
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_259(void *a1)
{
  *(unsigned char *)(*(void *)(a1[5] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  uint64_t v2 = DictForChunkViaNSUnarchiver();
  uint64_t v3 = *(void *)(a1[6] + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  if (!*(void *)(*(void *)(a1[6] + 8) + 40))
  {
    int v5 = (void *)a1[4];
    if (v5)
    {
      [v5 addObject:@"Unable to get data for resampled stacks chunk"];
    }
  }
}

uint64_t __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3_272(uint64_t a1)
{
  uint64_t result = ktrace_get_absolute_from_timestamp();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = result;
  return result;
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_4(uint64_t a1)
{
  uint64_t v124 = *MEMORY[0x1E4F143B8];
  if ([*(id *)(a1 + 32) dataStyle] == 1 || !objc_msgSend(*(id *)(a1 + 32), "dataStyle"))
  {
    if (![*(id *)(a1 + 32) isEmpty]) {
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v2 = [*(id *)(a1 + 32) sampleTimestamps];
    uint64_t v3 = [v2 count];

    if (v3)
    {
LABEL_4:
      long long v112 = 0u;
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      id v4 = *(id *)(a1 + 48);
      uint64_t v5 = [v4 countByEnumeratingWithState:&v110 objects:v123 count:16];
      if (v5)
      {
        uint64_t v6 = *(void *)v111;
        do
        {
          for (uint64_t i = 0; i != v5; ++i)
          {
            if (*(void *)v111 != v6) {
              objc_enumerationMutation(v4);
            }
            [*(id *)(a1 + 32) addProcessInfoFromTailspin:*(void *)(*((void *)&v110 + 1) + 8 * i)];
          }
          uint64_t v5 = [v4 countByEnumeratingWithState:&v110 objects:v123 count:16];
        }
        while (v5);
      }

      if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
      {
        uint64_t v8 = objc_alloc_init(SAFrameIterator);
        [(SAFrameIterator *)v8 setBacktracer:3];
        uint64_t v9 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
        v108[0] = MEMORY[0x1E4F143A8];
        v108[1] = 3221225472;
        v108[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_5;
        v108[3] = &unk_1E63F8188;
        v108[4] = *(void *)(a1 + 32);
        uint64_t v10 = v8;
        uint64_t v109 = v10;
        [v9 enumerateKeysAndObjectsUsingBlock:v108];
      }
      if (!*(unsigned char *)(a1 + 104))
      {
        if ([*(id *)(a1 + 32) dataStyle] == 3 || objc_msgSend(*(id *)(a1 + 32), "dataStyle") == 4) {
          [*(id *)(a1 + 32) enumerateTasks:&__block_literal_global_276];
        }
        [*(id *)(a1 + 32) enumerateTasks:&__block_literal_global_279];
        unint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
        if (v11 < [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) count])
        {
          unint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
          unint64_t v13 = [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) count];
          while (v12 < v13)
          {
            uint64_t v14 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:0.0];
            if ([*(id *)(a1 + 32) dataStyle] != 3
              || ([*(id *)(a1 + 32) sampleTimestamps],
                  long long v15 = objc_claimAutoreleasedReturnValue(),
                  BOOL v16 = [v15 count] == 0,
                  v15,
                  v16))
            {
              unint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else
            {
              id v17 = [*(id *)(a1 + 32) sampleTimestamps];
              uint64_t v18 = [v17 count];

              unint64_t v19 = v18 - 1;
            }
            uint64_t v20 = *(void *)(a1 + 32);
            int v21 = [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) objectAtIndexedSubscript:v12];
            -[SASampleStore _addKCDataStackshot:timestamp:sampleIndex:shouldSkipSampleOut:primaryDataIsKPerf:addStaticInfoOnly:](v20, v21, v14, v19, 0, 1u, 1);

            double v22 = [*(id *)(a1 + 32) endTime];
            BOOL v23 = v22 == 0;

            if (!v23)
            {
              unint64_t v24 = [*(id *)(a1 + 32) endTime];
              [v14 guessMissingTimesBasedOnTimestamp:v24];
            }
            unint64_t v13 = [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) count];
            ++v12;
          }
        }
      }
      int v26 = +[SATimestamp timestampWithMachAbsTime:machContTime:wallTime:machTimebase:](SATimestamp, "timestampWithMachAbsTime:machContTime:wallTime:machTimebase:", *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24), 0, [*(id *)(a1 + 32) machTimebase], 0.0);
      uint64_t v27 = *(void **)(a1 + 32);
      uint64_t v28 = *(void *)(a1 + 96);
      char v29 = *(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24);
      id v78 = v26;
      if (v27)
      {
        char v30 = (void *)MEMORY[0x1C18A6A20]();
        uint64_t v31 = [v27 tasksByPid];
        v114[0] = MEMORY[0x1E4F143A8];
        v114[1] = 3221225472;
        v114[2] = __116__SASampleStore_KPerf__addLoadInfoFromKTrace_lastKTraceEventTimestamp_checkForNewLoadInfosEvenWithExistingLoadInfo___block_invoke;
        v114[3] = &unk_1E63F8020;
        v114[4] = v27;
        id v32 = v78;
        char v117 = v29 ^ 1;
        id v115 = v32;
        uint64_t v116 = v28;
        [v31 enumerateKeysAndObjectsUsingBlock:v114];
      }

      id v33 = [*(id *)(a1 + 32) sharedCaches];
      BOOL v34 = [v33 count] == 0;

      if (!v34)
      {
        int v35 = [*(id *)(a1 + 32) tasksByPid];
        v107[0] = MEMORY[0x1E4F143A8];
        v107[1] = 3221225472;
        v107[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_5_282;
        v107[3] = &unk_1E63F81F8;
        v107[4] = *(void *)(a1 + 32);
        [v35 enumerateKeysAndObjectsUsingBlock:v107];
      }
      long long v105 = 0u;
      long long v106 = 0u;
      long long v103 = 0u;
      long long v104 = 0u;
      id v36 = [*(id *)(a1 + 32) hidEvents];
      obuint64_t j = v36;
      uint64_t v37 = [v36 countByEnumeratingWithState:&v103 objects:v122 count:16];
      if (v37)
      {
        uint64_t v83 = *(void *)v104;
        do
        {
          uint64_t v85 = v37;
          for (uint64_t j = 0; j != v85; ++j)
          {
            if (*(void *)v104 != v83) {
              objc_enumerationMutation(obj);
            }
            uint64_t v39 = *(void **)(*((void *)&v103 + 1) + 8 * j);
            long long v99 = 0u;
            long long v100 = 0u;
            long long v101 = 0u;
            long long v102 = 0u;
            int v40 = [v39 steps];
            uint64_t v41 = [v40 countByEnumeratingWithState:&v99 objects:v121 count:16];
            if (v41)
            {
              uint64_t v42 = *(void *)v100;
              do
              {
                for (uint64_t k = 0; k != v41; ++k)
                {
                  if (*(void *)v100 != v42) {
                    objc_enumerationMutation(v40);
                  }
                  long long v44 = *(_DWORD **)(*((void *)&v99 + 1) + 8 * k);
                  if ([v44 pid] == -1 && objc_msgSend(v44, "tid"))
                  {
                    id v45 = *(void **)(a1 + 32);
                    uint64_t v46 = [v44 tid];
                    uint64_t v47 = [v44 timestamp];
                    uint64_t v48 = -[SASampleStore taskWithPid:orTid:atTimestamp:](v45, 0xFFFFFFFFLL, v46, v47);

                    if (v48)
                    {
                      int v49 = [v48 pid];
                      if (v44) {
                        v44[3] = v49;
                      }
                    }
                  }
                }
                uint64_t v41 = [v40 countByEnumeratingWithState:&v99 objects:v121 count:16];
              }
              while (v41);
            }
          }
          id v36 = obj;
          uint64_t v37 = [obj countByEnumeratingWithState:&v103 objects:v122 count:16];
        }
        while (v37);
      }

      long long v97 = 0u;
      long long v98 = 0u;
      long long v95 = 0u;
      long long v96 = 0u;
      id Property = *(id *)(a1 + 32);
      if (Property) {
        id Property = objc_getProperty(Property, v50, 64, 1);
      }
      id v76 = Property;
      uint64_t v74 = [v76 countByEnumeratingWithState:&v95 objects:v120 count:16];
      if (v74)
      {
        uint64_t v75 = *(void *)v96;
        do
        {
          uint64_t v77 = 0;
          do
          {
            if (*(void *)v96 != v75) {
              objc_enumerationMutation(v76);
            }
            dispatch_semaphore_t v53 = *(void **)(*((void *)&v95 + 1) + 8 * v77);
            long long v91 = 0u;
            long long v92 = 0u;
            long long v93 = 0u;
            long long v94 = 0u;
            if (v53) {
              id v54 = objc_getProperty(v53, v52, 8, 1);
            }
            else {
              id v54 = 0;
            }
            long long v86 = v53;
            id v79 = v54;
            uint64_t v55 = [v79 countByEnumeratingWithState:&v91 objects:v119 count:16];
            if (v55)
            {
              uint64_t v80 = *(void *)v92;
              do
              {
                id obja = (id)v55;
                for (uint64_t m = 0; m != obja; uint64_t m = (char *)m + 1)
                {
                  if (*(void *)v92 != v80) {
                    objc_enumerationMutation(v79);
                  }
                  int v57 = *(void **)(*((void *)&v91 + 1) + 8 * (void)m);
                  long long v87 = 0u;
                  long long v88 = 0u;
                  long long v89 = 0u;
                  long long v90 = 0u;
                  long long v84 = v57;
                  uint64_t v58 = objc_msgSend(v57, "steps", v74);
                  uint64_t v59 = [v58 countByEnumeratingWithState:&v87 objects:v118 count:16];
                  if (v59)
                  {
                    uint64_t v60 = *(void *)v88;
                    do
                    {
                      for (uint64_t n = 0; n != v59; ++n)
                      {
                        if (*(void *)v88 != v60) {
                          objc_enumerationMutation(v58);
                        }
                        qos_class_t v62 = *(_DWORD **)(*((void *)&v87 + 1) + 8 * n);
                        if ([v62 pid] == -1 && objc_msgSend(v62, "tid"))
                        {
                          uint64_t v63 = *(void **)(a1 + 32);
                          uint64_t v64 = [v62 tid];
                          uint64_t v65 = [v62 timestamp];
                          uint64_t v66 = -[SASampleStore taskWithPid:orTid:atTimestamp:](v63, 0xFFFFFFFFLL, v64, v65);

                          if (v66)
                          {
                            int v67 = [v66 pid];
                            if (v62) {
                              v62[3] = v67;
                            }
                          }
                        }
                      }
                      uint64_t v59 = [v58 countByEnumeratingWithState:&v87 objects:v118 count:16];
                    }
                    while (v59);
                  }

                  if (v86)
                  {
                    if (v86[4] == -1)
                    {
                      uint64_t v68 = [v84 steps];
                      uint64_t v69 = [v68 lastObject];
                      BOOL v70 = [v69 pid] == -1;

                      if (!v70)
                      {
                        uint64_t v71 = [v84 steps];
                        uint64_t v72 = [v71 lastObject];
                        v86[4] = [v72 pid];
                      }
                    }
                  }
                }
                uint64_t v55 = [v79 countByEnumeratingWithState:&v91 objects:v119 count:16];
              }
              while (v55);
            }

            ++v77;
          }
          while (v77 != v74);
          uint64_t v73 = [v76 countByEnumeratingWithState:&v95 objects:v120 count:16];
          uint64_t v74 = v73;
        }
        while (v73);
      }

      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
      return;
    }
  }
  char v25 = *(NSObject **)(a1 + 40);
  dispatch_semaphore_signal(v25);
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_5(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      -[SASampleStore lastTaskWithPid:](*(void **)(a1 + 32), [v5 intValue]);
      id v7 = (unsigned char *)objc_claimAutoreleasedReturnValue();
      uint64_t v8 = v7;
      if (v7)
      {
        uint64_t v9 = [v7 binaryLoadInfos];
        [*(id *)(a1 + 40) setUserBinaryLoadInfos:v9];

        [*(id *)(a1 + 40) setAssumeUserBinaryLoadInfosContainMainBinary:v8[73] & 1];
        uint64_t v10 = [v8 sharedCache];
        [*(id *)(a1 + 40) setSharedCache:v10];

        uint64_t v11 = *(void *)(a1 + 32);
        if (v11) {
          uint64_t v12 = *(void *)(v11 + 192);
        }
        else {
          uint64_t v12 = 0;
        }
        objc_copyStruct(&dest, v8 + 288, 8, 1, 0);
        if (v12)
        {
          if (dest)
          {
            CSArchitectureGetFamily();
            CSArchitectureGetFamily();
            if ((CSArchitectureMatchesArchitecture() & 1) == 0)
            {
              unint64_t v13 = -[SASampleStore addressTranslationsForPid:](*(void *)(a1 + 32), [v8 pid]);
              [*(id *)(a1 + 40) setAddressTranslations:v13];
            }
          }
        }
        v14[0] = MEMORY[0x1E4F143A8];
        v14[1] = 3221225472;
        v14[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_6;
        v14[3] = &unk_1E63F8160;
        long long v15 = v8;
        id v16 = *(id *)(a1 + 40);
        [v6 enumerateKeysAndObjectsUsingBlock:v14];
        [*(id *)(a1 + 40) clearTaskData];
      }
    }
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_6(uint64_t a1, void *a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v7 = [*(id *)(a1 + 32) threads];
      uint64_t v8 = [v7 objectForKeyedSubscript:v5];

      if (v8) {
        id Property = objc_getProperty(v8, v9, 48, 1);
      }
      else {
        id Property = 0;
      }
      id v11 = Property;

      if (!v11)
      {
        uint64_t v12 = malloc_type_calloc([v6 count], 8uLL, 0x100004000313F17uLL);
        for (unint64_t i = 0; i < [v6 count]; ++i)
        {
          uint64_t v14 = [v6 objectAtIndexedSubscript:i];
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0)
          {
            free(v12);

            goto LABEL_18;
          }
          *((void *)v12 + i) = [v14 unsignedLongLongValue];
        }
        [*(id *)(a1 + 40) setUserFrames:v12];
        objc_msgSend(*(id *)(a1 + 40), "setNumUserFrames:", objc_msgSend(v6, "count"));
        id v16 = -[SATask leafFrameAfterAddingStack:leafOfCRootFramesReplacedBySwiftAsync:](*(void *)(a1 + 32), *(void **)(a1 + 40), 0);
        if (v16)
        {
          if (v8) {
            objc_setProperty_atomic(v8, v15, v16, 48);
          }
        }
        else
        {
          int v17 = *__error();
          uint64_t v18 = _sa_logt();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            id v23 = [*(id *)(a1 + 32) debugDescription];
            uint64_t v19 = [v23 UTF8String];
            id v20 = [v8 debugDescription];
            uint64_t v21 = [v20 UTF8String];
            unsigned int v22 = [*(id *)(a1 + 40) numUserFrames];
            *(_DWORD *)long long buf = 136315650;
            uint64_t v25 = v19;
            __int16 v26 = 2080;
            uint64_t v27 = v21;
            __int16 v28 = 2048;
            uint64_t v29 = v22;
            _os_log_error_impl(&dword_1BF22B000, v18, OS_LOG_TYPE_ERROR, "%s %s unable to add resampled stack with %lu frames", buf, 0x20u);
          }
          *__error() = v17;
        }
        [*(id *)(a1 + 40) clearThreadData];
      }
LABEL_18:
    }
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_274(uint64_t a1, uint64_t a2)
{
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_2_277(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = [v2 threads];
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3_280;
  v5[3] = &unk_1E63F7E40;
  id v4 = v2;
  id v6 = v4;
  [v3 enumerateKeysAndObjectsUsingBlock:v5];
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_3_280(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if ([*(id *)(a1 + 32) pid])
  {
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x3032000000;
    v8[3] = __Block_byref_object_copy__1;
    v8[4] = __Block_byref_object_dispose__1;
    id v9 = 0;
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_4_281;
    v5[3] = &unk_1E63F81D0;
    id v7 = v8;
    id v6 = *(id *)(a1 + 32);
    [v4 enumerateThreadStatesBetweenStartTime:0 startSampleIndex:0x7FFFFFFFFFFFFFFFLL endTime:0 endSampleIndex:0x7FFFFFFFFFFFFFFFLL reverseOrder:1 block:v5];

    _Block_object_dispose(v8, 8);
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_4_281(uint64_t a1, void *a2)
{
  self = a2;
  uint64_t v3 = [self leafUserFrame];

  if (!v3)
  {
    id v5 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    if (!v5)
    {
      uint64_t v6 = -[SATask truncatedUserStackFrameSwiftAsync:](*(SAFrame **)(a1 + 32), 0);
      uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
      uint64_t v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;

      id v5 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    }
    if (self) {
      objc_setProperty_atomic(self, v4, v5, 64);
    }
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_5_282(uint64_t a1, void *a2, void *a3)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  id v4 = a2;
  id v49 = a3;
  double v50 = v4;
  if ([v4 intValue] && objc_msgSend(v4, "intValue") != -1)
  {
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    id v5 = [v49 reverseObjectEnumerator];
    uint64_t v6 = 0;
    uint64_t v7 = [v5 countByEnumeratingWithState:&v63 objects:v74 count:16];
    if (!v7) {
      goto LABEL_50;
    }
    char v55 = 0;
    uint64_t v8 = *(void *)v64;
    do
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v64 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v10 = *(unsigned char **)(*((void *)&v63 + 1) + 8 * i);
        if (!v10 || (v10[72] & 1) == 0)
        {
          id v11 = [*(id *)(*((void *)&v63 + 1) + 8 * i) sharedCache];
          BOOL v12 = v11 == 0;

          if (v12)
          {
            if (v6)
            {
              int v14 = *__error();
              long long v15 = _sa_logt();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              {
                double v51 = [v10 debugDescription];
                int v17 = [v6 uuid];
                uint64_t v18 = [v17 UUIDString];
                uint64_t v19 = [v6 slide];
                *(_DWORD *)long long buf = 138412802;
                uint64_t v69 = v51;
                __int16 v70 = 2112;
                uint64_t v71 = v18;
                __int16 v72 = 2048;
                uint64_t v73 = v19;
                _os_log_debug_impl(&dword_1BF22B000, v15, OS_LOG_TYPE_DEBUG, "%@: guessing shared cache based on later tasks with the same pid: UUID:%@ slide=0x%0llX", buf, 0x20u);
              }
              *__error() = v14;
              if (v10) {
                objc_setProperty_atomic(v10, v16, v6, 256);
              }
            }
            else
            {
              char v55 = 1;
            }
          }
          else
          {
            uint64_t v13 = [v10 sharedCache];

            uint64_t v6 = (void *)v13;
          }
        }
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v63 objects:v74 count:16];
    }
    while (v7);

    if (v55)
    {
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      id v5 = v49;
      uint64_t v20 = [v5 countByEnumeratingWithState:&v59 objects:v67 count:16];
      if (!v20) {
        goto LABEL_50;
      }
      uint64_t v21 = *(void *)v60;
      while (1)
      {
        for (uint64_t j = 0; j != v20; ++j)
        {
          if (*(void *)v60 != v21) {
            objc_enumerationMutation(v5);
          }
          id v23 = *(unsigned char **)(*((void *)&v59 + 1) + 8 * j);
          if (!v23 || (v23[72] & 1) == 0)
          {
            unint64_t v24 = [*(id *)(*((void *)&v59 + 1) + 8 * j) sharedCache];
            BOOL v25 = v24 == 0;

            if (v25)
            {
              if (!v6)
              {
                id Property = *(id *)(a1 + 32);
                if (Property) {
                  id Property = objc_getProperty(Property, v26, 1024, 1);
                }
                id v31 = Property;
                BOOL v32 = v31 == 0;

                id v34 = *(id *)(a1 + 32);
                if (v32)
                {
                  uint64_t v39 = [v34 sharedCaches];
                  id v35 = [v39 firstObject];

                  int v40 = *__error();
                  uint64_t v41 = _sa_logt();
                  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v58 = [v23 debugDescription];
                    dispatch_semaphore_t v53 = [v35 uuid];
                    uint64_t v47 = [v53 UUIDString];
                    uint64_t v48 = [v35 slide];
                    *(_DWORD *)long long buf = 138412802;
                    uint64_t v69 = v58;
                    __int16 v70 = 2112;
                    uint64_t v71 = v47;
                    __int16 v72 = 2048;
                    uint64_t v73 = v48;
                    _os_log_debug_impl(&dword_1BF22B000, v41, OS_LOG_TYPE_DEBUG, "%@: guessing first shared cache: UUID:%@ slide=0x%0llX", buf, 0x20u);
                  }
                  *__error() = v40;
                  if (v23) {
LABEL_46:
                  }
                    objc_setProperty_atomic(v23, v38, v35, 256);
                }
                else
                {
                  if (v34) {
                    id v34 = objc_getProperty(v34, v33, 1024, 1);
                  }
                  id v35 = v34;
                  int v36 = *__error();
                  uint64_t v37 = _sa_logt();
                  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
                  {
                    int v57 = [v23 debugDescription];
                    int v52 = [v35 uuid];
                    id v45 = [v52 UUIDString];
                    uint64_t v46 = [v35 slide];
                    *(_DWORD *)long long buf = 138412802;
                    uint64_t v69 = v57;
                    __int16 v70 = 2112;
                    uint64_t v71 = v45;
                    __int16 v72 = 2048;
                    uint64_t v73 = v46;
                    _os_log_debug_impl(&dword_1BF22B000, v37, OS_LOG_TYPE_DEBUG, "%@: guessing native shared cache: UUID:%@ slide=0x%0llX", buf, 0x20u);
                  }
                  *__error() = v36;
                  if (v23) {
                    goto LABEL_46;
                  }
                }

                continue;
              }
              int v27 = *__error();
              __int16 v28 = _sa_logt();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
              {
                int v56 = [v23 debugDescription];
                uint64_t v42 = [v6 uuid];
                int v43 = [v42 UUIDString];
                uint64_t v44 = [v6 slide];
                *(_DWORD *)long long buf = 138412802;
                uint64_t v69 = v56;
                __int16 v70 = 2112;
                uint64_t v71 = v43;
                __int16 v72 = 2048;
                uint64_t v73 = v44;
                _os_log_debug_impl(&dword_1BF22B000, v28, OS_LOG_TYPE_DEBUG, "%@: guessing shared cache based on earlier tasks with the same pid: UUID:%@ slide=0x%0llX", buf, 0x20u);
              }
              *__error() = v27;
              if (v23) {
                objc_setProperty_atomic(v23, v29, v6, 256);
              }
            }
          }
        }
        uint64_t v20 = [v5 countByEnumeratingWithState:&v59 objects:v67 count:16];
        if (!v20)
        {
LABEL_50:

          break;
        }
      }
    }
  }
}

void __77__SASampleStore_KPerf___parseKTraceFile_stackshotsOnly_warningsOut_errorOut___block_invoke_283(uint64_t a1)
{
  if ((unint64_t)ktrace_get_absolute_from_timestamp() >= *(void *)(*(void *)(*(void *)(a1 + 48) + 8)
                                                                           + 24))
  {
    id v13 = +[SATimestamp timestampWithMachAbsTime:0 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:0.0];
    uint64_t v2 = [*(id *)(a1 + 32) dataStyle];
    if (v2 == 3)
    {
      id v4 = [*(id *)(a1 + 32) sampleTimestamps];
      unint64_t v3 = [v4 count];
    }
    else
    {
      unint64_t v3 = 0x7FFFFFFFFFFFFFFFLL;
    }
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) objectAtIndexedSubscript:*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24)];
    uint64_t v7 = -[SASampleStore _addKCDataStackshot:timestamp:sampleIndex:shouldSkipSampleOut:primaryDataIsKPerf:addStaticInfoOnly:](v5, v6, v13, v3, 0, 1u, v2 != 3);

    uint64_t v8 = [*(id *)(a1 + 32) endTime];

    if (v8)
    {
      id v9 = [*(id *)(a1 + 32) endTime];
      [v13 guessMissingTimesBasedOnTimestamp:v9];
    }
    if (v2 == 3)
    {
      if (v7)
      {
        uint64_t v10 = *(void *)(a1 + 32);
        if (v10) {
          [*(id *)(v10 + 24) addObject:v13];
        }
      }
    }
    unint64_t v11 = ++*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
    if (v11 >= [*(id *)(a1 + 40) count])
    {
      if (*(unsigned char *)(a1 + 80)) {
        *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = -1;
      }
      else {
        ktrace_end();
      }
    }
    else
    {
      BOOL v12 = [*(id *)(a1 + 40) objectAtIndexedSubscript:*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24)];
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = [v12 unsignedLongLongValue];
    }
  }
}

- (void)forwardFillFromLastStackshot:(void *)a1
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if ([a1 dataSource] != 2)
  {
    int v20 = *__error();
    uint64_t v21 = _sa_logt();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v36 = [a1 dataSource];
      _os_log_error_impl(&dword_1BF22B000, v21, OS_LOG_TYPE_ERROR, "data source 0x%llx", buf, 0xCu);
    }

    *__error() = v20;
    char v22 = [a1 dataSource];
    _SASetCrashLogMessage(3686, "data source 0x%llx", v23, v24, v25, v26, v27, v28, v22);
    _os_crash();
    __break(1u);
  }
  id v4 = [a1 sampleTimestamps];
  uint64_t v5 = [v4 count];

  if (v5)
  {
    uint64_t v6 = [a1 sampleTimestamps];
    uint64_t v7 = [v6 count];

    uint64_t v8 = [a1 sampleTimestamps];
    id v9 = [v8 lastObject];

    if ([v9 machAbsTime] <= a2)
    {
LABEL_14:

      return;
    }
    uint64_t v10 = +[SATimestamp timestampWithMachAbsTime:a2 machAbsTimeSec:0 machContTime:0.0 machContTimeSec:0.0 wallTime:0.0];
    uint64_t v11 = [a1 indexOfLastSampleOnOrBeforeTimestamp:v10];
    if (v11 == 0x7FFFFFFFFFFFFFFFLL)
    {
      int v12 = *__error();
      id v13 = _sa_logt();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1BF22B000, v13, OS_LOG_TYPE_DEFAULT, "WARNING: Cannot forward-fill from last stackshot because there was no KPerf sample before the stackshot", buf, 2u);
      }

      *__error() = v12;
      goto LABEL_13;
    }
    int v14 = [a1 sampleTimestamps];
    id v15 = [v14 objectAtIndexedSubscript:v11];

    if ([v15 machAbsTime] == a2)
    {
      if (!v11)
      {
        int v18 = *__error();
        uint64_t v19 = _sa_logt();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1BF22B000, v19, OS_LOG_TYPE_DEFAULT, "WARNING: Cannot forward-fill from last stackshot because there was no KPerf sample before the stackshot", buf, 2u);
        }

        *__error() = v18;
        goto LABEL_12;
      }
      id v16 = [a1 sampleTimestamps];
      uint64_t v17 = [v16 objectAtIndexedSubscript:v11 - 1];

      id v15 = (id)v17;
    }
    v29[0] = MEMORY[0x1E4F143A8];
    v29[1] = 3221225472;
    v29[2] = __53__SASampleStore_KPerf__forwardFillFromLastStackshot___block_invoke;
    v29[3] = &unk_1E63F82B8;
    unint64_t v33 = a2;
    id v30 = v9;
    id v31 = a1;
    uint64_t v34 = v7 - 1;
    id v15 = v15;
    id v32 = v15;
    [a1 enumerateTasks:v29];

LABEL_12:
LABEL_13:

    goto LABEL_14;
  }
}

void __53__SASampleStore_KPerf__forwardFillFromLastStackshot___block_invoke(uint64_t a1, void *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = [v3 exitTimestamp];
  uint64_t v5 = v4;
  if (!v4) {
    goto LABEL_9;
  }
  if ((unint64_t)[v4 machAbsTime] <= *(void *)(a1 + 56))
  {
    id v6 = 0;
    goto LABEL_15;
  }
  if (![v5 lt:*(void *)(a1 + 32)]) {
    goto LABEL_9;
  }
  id v6 = v5;
  unint64_t v7 = [*(id *)(a1 + 40) indexOfLastSampleOnOrBeforeTimestamp:v6];
  unint64_t v8 = v7;
  if (v7 == 0x7FFFFFFFFFFFFFFFLL) {
    goto LABEL_15;
  }
  if (v7 > *(void *)(a1 + 64))
  {
    int v9 = *__error();
    uint64_t v10 = _sa_logt();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void *)(a1 + 64);
      *(_DWORD *)long long buf = 134218240;
      unint64_t v36 = v8;
      __int16 v37 = 2048;
      uint64_t v38 = v11;
      _os_log_error_impl(&dword_1BF22B000, v10, OS_LOG_TYPE_ERROR, "%lu < %lu", buf, 0x16u);
    }

    *__error() = v9;
    _SASetCrashLogMessage(3736, "%lu < %lu", v12, v13, v14, v15, v16, v17, v8);
    _os_crash();
    __break(1u);
LABEL_9:
    unint64_t v8 = *(void *)(a1 + 64);
    id v6 = *(id *)(a1 + 32);
  }
  int v18 = [v3 taskStates];
  uint64_t v19 = [v18 lastObject];

  if (v19)
  {
    int v20 = [v19 startTimestamp];
    int v21 = [v20 lt:*(void *)(a1 + 48)];

    if (v21)
    {
      v19[7] = v8;
      objc_setProperty_atomic(v19, v22, v6, 40);
    }
  }
  uint64_t v23 = [v3 threads];
  v27[0] = MEMORY[0x1E4F143A8];
  v27[1] = 3221225472;
  v27[2] = __53__SASampleStore_KPerf__forwardFillFromLastStackshot___block_invoke_317;
  v27[3] = &unk_1E63F8290;
  uint64_t v32 = *(void *)(a1 + 56);
  id v24 = v6;
  uint64_t v25 = *(void *)(a1 + 40);
  uint64_t v26 = *(void **)(a1 + 48);
  id v28 = v24;
  uint64_t v29 = v25;
  uint64_t v33 = *(void *)(a1 + 64);
  unint64_t v34 = v8;
  id v30 = v26;
  id v31 = v3;
  [v23 enumerateKeysAndObjectsUsingBlock:v27];

  id v6 = v24;
LABEL_15:
}

void __53__SASampleStore_KPerf__forwardFillFromLastStackshot___block_invoke_317(uint64_t a1, void *a2, void *a3)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  id v107 = a2;
  id v5 = a3;
  id v6 = [v5 exitTimestamp];
  unint64_t v7 = v6;
  if (!v6) {
    goto LABEL_10;
  }
  if ((unint64_t)[v6 machAbsTime] > *(void *)(a1 + 64))
  {
    if ([v7 lt:*(void *)(a1 + 32)])
    {
      id v8 = v7;
      unint64_t v9 = [*(id *)(a1 + 40) indexOfLastSampleOnOrBeforeTimestamp:v8];
      unint64_t v10 = v9;
      if (v9 == 0x7FFFFFFFFFFFFFFFLL) {
        goto LABEL_20;
      }
      if (v9 <= *(void *)(a1 + 72) && v9 <= *(void *)(a1 + 80))
      {
LABEL_11:
        int v21 = [v5 threadStates];
        char v22 = [v21 lastObject];

        if (v22
          && ([v22 startTimestamp],
              uint64_t v23 = objc_claimAutoreleasedReturnValue(),
              int v24 = [v23 lt:*(void *)(a1 + 48)],
              v23,
              v24))
        {
          -[SAThreadState setEndSampleIndex:]((uint64_t)v22, v10);
          objc_setProperty_atomic(v22, v25, v8, 56);
        }
        else
        {
          uint64_t v26 = [v5 threadStates];
          if ((unint64_t)[v26 count] >= 2)
          {
            uint64_t v27 = [v22 leafUserFrame];
            if (!v27)
            {
              int v28 = [*(id *)(a1 + 56) pid];

              if (v28)
              {
                unint64_t v29 = [v22 cpuTimeNs];
                if (v29)
                {
                  id v30 = [v5 threadStates];
                  uint64_t v31 = [v30 count];

                  while (1)
                  {
                    unint64_t v32 = v31 - 1;
                    if (v31 == 1) {
                      break;
                    }
                    uint64_t v33 = [v5 threadStates];
                    uint64_t v34 = v31 - 2;
                    id v35 = [v33 objectAtIndexedSubscript:v34];
                    unint64_t v36 = [v35 cpuTimeNs];

                    if (v36 < v29) {
                      break;
                    }
                    __int16 v37 = [v5 threadStates];
                    uint64_t v38 = [v37 objectAtIndexedSubscript:v34];
                    uint64_t v39 = [v38 leafUserFrame];

                    uint64_t v31 = v32;
                    if (v39)
                    {
                      if (v32 == 0x8000000000000000) {
                        goto LABEL_18;
                      }
                      int v40 = [v5 threadStates];
                      uint64_t v26 = [v40 objectAtIndexedSubscript:v32 - 1];

                      uint64_t v27 = [v26 leafUserFrame];
                      id newValue = [v26 leafOfCRootFramesReplacedBySwiftAsync];
                      obuint64_t j = [v26 dispatchQueue];
                      id v105 = [v26 swiftTask];
                      while (1)
                      {
                        uint64_t v41 = [v5 threadStates];
                        unint64_t v42 = [v41 count];

                        if (v32 >= v42) {
                          break;
                        }
                        int v43 = [v5 threadStates];
                        uint64_t v44 = [v43 objectAtIndexedSubscript:v32];

                        uint64_t v46 = [v44 leafUserFrame];
                        if (v46)
                        {
                          uint64_t v47 = [v44 leafUserFrame];

                          if (v47 != v27)
                          {
                            int v92 = *__error();
                            dispatch_semaphore_t v53 = _sa_logt();
                            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                            {
                              long long v95 = [v44 leafUserFrame];
                              id v54 = [v95 debugDescription];
                              uint64_t v98 = [v54 UTF8String];
                              id v55 = [v27 debugDescription];
                              uint64_t v56 = [v55 UTF8String];
                              *(_DWORD *)long long buf = 136315394;
                              unint64_t v109 = v98;
                              __int16 v110 = 2080;
                              uint64_t v111 = v56;
                              _os_log_error_impl(&dword_1BF22B000, v53, OS_LOG_TYPE_ERROR, "threadState.leafUserFrame %s != leafUserFrame %s", buf, 0x16u);
                            }
                            *__error() = v92;
                            int v57 = [v44 leafUserFrame];
                            id v58 = [v57 debugDescription];
                            char v99 = [v58 UTF8String];
                            id v59 = [v27 debugDescription];
                            [v59 UTF8String];
                            _SASetCrashLogMessage(3821, "threadState.leafUserFrame %s != leafUserFrame %s", v60, v61, v62, v63, v64, v65, v99);

                            _os_crash();
                            __break(1u);
LABEL_49:
                            int v93 = *__error();
                            long long v66 = _sa_logt();
                            if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
                            {
                              long long v96 = [v44 dispatchQueue];
                              id v67 = [v96 debugDescription];
                              uint64_t v100 = [v67 UTF8String];
                              id v68 = [obj debugDescription];
                              uint64_t v69 = [v68 UTF8String];
                              *(_DWORD *)long long buf = 136315394;
                              unint64_t v109 = v100;
                              __int16 v110 = 2080;
                              uint64_t v111 = v69;
                              _os_log_error_impl(&dword_1BF22B000, v66, OS_LOG_TYPE_ERROR, "threadState.dispatchQueue %s != dispatchQueue %s", buf, 0x16u);
                            }
                            *__error() = v93;
                            __int16 v70 = [v44 dispatchQueue];
                            id v71 = [v70 debugDescription];
                            char v101 = [v71 UTF8String];
                            id v72 = [obj debugDescription];
                            [v72 UTF8String];
                            _SASetCrashLogMessage(3824, "threadState.dispatchQueue %s != dispatchQueue %s", v73, v74, v75, v76, v77, v78, v101);

                            _os_crash();
                            __break(1u);
LABEL_52:
                            int v94 = *__error();
                            id v79 = _sa_logt();
                            if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
                            {
                              long long v97 = [v44 swiftTask];
                              id v80 = [v97 debugDescription];
                              uint64_t v102 = [v80 UTF8String];
                              id v81 = [v105 debugDescription];
                              uint64_t v82 = [v81 UTF8String];
                              *(_DWORD *)long long buf = 136315394;
                              unint64_t v109 = v102;
                              __int16 v110 = 2080;
                              uint64_t v111 = v82;
                              _os_log_error_impl(&dword_1BF22B000, v79, OS_LOG_TYPE_ERROR, "threadState.swiftTask %s != swiftTask %s", buf, 0x16u);
                            }
                            *__error() = v94;
                            uint64_t v83 = [v44 swiftTask];
                            id v84 = [v83 debugDescription];
                            char v103 = [v84 UTF8String];
                            id v85 = [v105 debugDescription];
                            [v85 UTF8String];
                            _SASetCrashLogMessage(3826, "threadState.swiftTask %s != swiftTask %s", v86, v87, v88, v89, v90, v91, v103);

                            _os_crash();
                            __break(1u);
                          }
                        }
                        if (v44)
                        {
                          objc_setProperty_atomic(v44, v45, v27, 64);
                          objc_setProperty_atomic(v44, v48, newValue, 72);
                        }
                        id v49 = [v44 dispatchQueue];
                        if (v49)
                        {
                          id v50 = [v44 dispatchQueue];

                          if (v50 != obj) {
                            goto LABEL_49;
                          }
                        }
                        if (v44) {
                          objc_storeWeak(v44 + 14, obj);
                        }
                        double v51 = [v44 swiftTask];
                        if (v51)
                        {
                          id v52 = [v44 swiftTask];

                          if (v52 != v105) {
                            goto LABEL_52;
                          }
                        }
                        if (v44) {
                          objc_storeWeak(v44 + 15, v105);
                        }

                        ++v32;
                      }

                      goto LABEL_16;
                    }
                  }
                }
              }
              goto LABEL_18;
            }
LABEL_16:
          }
        }
LABEL_18:

        goto LABEL_20;
      }
      int v11 = *__error();
      uint64_t v12 = _sa_logt();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = *(void *)(a1 + 72);
        uint64_t v14 = *(void *)(a1 + 80);
        *(_DWORD *)long long buf = 134218496;
        unint64_t v109 = v10;
        __int16 v110 = 2048;
        uint64_t v111 = v13;
        __int16 v112 = 2048;
        uint64_t v113 = v14;
        _os_log_error_impl(&dword_1BF22B000, v12, OS_LOG_TYPE_ERROR, "%lu < %lu, < %lu", buf, 0x20u);
      }

      *__error() = v11;
      _SASetCrashLogMessage(3770, "%lu < %lu, < %lu", v15, v16, v17, v18, v19, v20, v10);
      _os_crash();
      __break(1u);
    }
LABEL_10:
    unint64_t v10 = *(void *)(a1 + 80);
    id v8 = *(id *)(a1 + 32);
    goto LABEL_11;
  }
  id v8 = 0;
LABEL_20:
}

void __616__SASampleStore_KPerfPrivate__backfillThread_inTask_lastSampleIndex_timestamp_haveName_name_haveDispatchQueueId_dispatchQueueId_dispatchQueueLabel_leafKernelFrame_hasExclaveInKernelStack_haveUserStack_leafUserFrame_swiftTaskId_leafOfCRootFramesReplacedBySwiftAsync_threadExclavesInfo_haveSched_systemCpuTimeNs_userCpuTimeNs_basePriority_scheduledPriority_state_threadQos_threadRequestedQos_threadRequestedQosOverride_threadQosPromote_haveCycIns_instructions_cycles_haveSnap_ioTier_isIOPassive_isDarwinBG_isSuspended_isGlobalForcedIdle_isIdleWorkQueue_lastMadeRunnableTime_isOnCore_isOnCoreForLastSampleIndex_cpuNum___block_invoke(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v136 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v7 = v136;
    uint64_t v8 = (uint64_t)v7;
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 128) + 8) + 24))
    {
      if ([v7 filledName])
      {
        if (*(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) >= 1 && qword_1EB698F20 != 0)
        {
          int v10 = *__error();
          int v11 = (FILE *)qword_1EB698F20;
          uint64_t v12 = [*(id *)(a1 + 32) machAbsTime];
          uint64_t v13 = [*(id *)(a1 + 40) threadId];
          id v14 = [(id)v8 name];
          uint64_t v15 = [v14 UTF8String];
          uint64_t v16 = "no name";
          if (v15) {
            uint64_t v16 = (const char *)v15;
          }
          fprintf(v11, "%'llu Thread 0x%llx thread name %s backfilled to %d thread states (indexes %lu-%lu)\n", v12, v13, v16, *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + a3);

          *__error() = v10;
        }
        char v17 = 0;
        *(unsigned char *)(*(void *)(*(void *)(a1 + 128) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      }
      else
      {
        [(id)v8 setFilledName:1];
        if (v8) {
          objc_setProperty_atomic_copy((id)v8, v20, *(id *)(a1 + 48), 104);
        }
        char v17 = 1;
        if (!a3 && qword_1EB698F20)
        {
          int v21 = *__error();
          char v22 = (FILE *)qword_1EB698F20;
          uint64_t v23 = [*(id *)(a1 + 32) machAbsTime];
          uint64_t v24 = [*(id *)(a1 + 40) threadId];
          id v25 = [(id)v8 name];
          uint64_t v26 = [v25 UTF8String];
          uint64_t v27 = "no name";
          if (v26) {
            uint64_t v27 = (const char *)v26;
          }
          fprintf(v22, "%'llu Thread 0x%llx thread name %s backfilled to all (%d) thread states (indexes %lu-%lu)\n", v23, v24, v27, *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24));

          *__error() = v21;
          char v17 = 1;
        }
      }
    }
    else
    {
      char v17 = 0;
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 144) + 8) + 24))
    {
      if ([(id)v8 filledDispatchQueue])
      {
        if (*(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) >= 1 && qword_1EB698F20 != 0)
        {
          int v29 = *__error();
          id v30 = (FILE *)qword_1EB698F20;
          uint64_t v31 = [*(id *)(a1 + 32) machAbsTime];
          uint64_t v32 = [*(id *)(a1 + 40) threadId];
          uint64_t v33 = *(void **)(a1 + 56);
          if (v33) {
            uint64_t v33 = (void *)[v33 identifier];
          }
          fprintf(v30, "%'llu Thread 0x%llx dispatch queue %lld backfilled to %d thread states (indexes %lu-%lu)\n", v31, v32, v33, *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + a3);
          *__error() = v29;
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 144) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      }
      else
      {
        [(id)v8 setFilledDispatchQueue:1];
        uint64_t v34 = *(void **)(a1 + 56);
        if (v8)
        {
          objc_storeWeak((id *)(v8 + 112), v34);
          uint64_t v34 = *(void **)(a1 + 56);
        }
        if (v34)
        {
          id v35 = +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SADispatchQueueState, *(void **)(a1 + 40), a3);
          [*(id *)(a1 + 64) insertObject:v35 atIndex:0];
        }
        char v17 = 1;
        if (!a3 && qword_1EB698F20)
        {
          int v36 = *__error();
          __int16 v37 = (FILE *)qword_1EB698F20;
          uint64_t v38 = [*(id *)(a1 + 32) machAbsTime];
          uint64_t v39 = [*(id *)(a1 + 40) threadId];
          int v40 = *(void **)(a1 + 56);
          if (v40) {
            int v40 = (void *)[v40 identifier];
          }
          fprintf(v37, "%'llu Thread 0x%llx dispatch queue %lld backfilled to all (%d) thread states (indexes %lu-%lu)\n", v38, v39, v40, *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24));
          *__error() = v36;
        }
      }
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 152) + 8) + 24))
    {
      if ([(id)v8 filledUserStack])
      {
        if (*(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) >= 1 && qword_1EB698F20 != 0)
        {
          int v42 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu Thread 0x%llx user stack (leaf frame 0x%llx, swift async leaf 0x%llx) backfilled to %d thread states (indexes %lu-%lu)\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "threadId"), objc_msgSend(*(id *)(a1 + 72), "address"), objc_msgSend(*(id *)(a1 + 80), "address"), *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + a3);
          *__error() = v42;
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 152) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
        uint64_t v43 = *(void *)(*(void *)(a1 + 160) + 8);
        if (*(unsigned char *)(v43 + 24) && *(void *)(a1 + 200) == -1) {
          *(unsigned char *)(v43 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
        }
      }
      else
      {
        [(id)v8 setFilledUserStack:1];
        if (v8)
        {
          objc_setProperty_atomic((id)v8, v44, *(id *)(a1 + 72), 64);
          id v45 = (id *)(a1 + 80);
          objc_setProperty_atomic((id)v8, v46, *(id *)(a1 + 80), 72);
        }
        else
        {
          id v45 = (id *)(a1 + 80);
        }
        char v17 = 1;
        if (!a3 && qword_1EB698F20)
        {
          int v47 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu Thread 0x%llx user stack (leaf frame 0x%llx, swift async leaf 0x%llx) backfilled to all (%d) thread states (indexes %lu-%lu)\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "threadId"), objc_msgSend(*(id *)(a1 + 72), "address"), objc_msgSend(*v45, "address"), *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24));
          *__error() = v47;
          char v17 = 1;
        }
      }
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 160) + 8) + 24))
    {
      if ([(id)v8 filledSwiftTask])
      {
        if (*(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) >= 1 && qword_1EB698F20 != 0)
        {
          int v49 = *__error();
          id v50 = (FILE *)qword_1EB698F20;
          uint64_t v51 = [*(id *)(a1 + 32) machAbsTime];
          uint64_t v52 = [*(id *)(a1 + 40) threadId];
          dispatch_semaphore_t v53 = *(void **)(a1 + 88);
          if (v53) {
            dispatch_semaphore_t v53 = (void *)[v53 identifier];
          }
          fprintf(v50, "%'llu Thread 0x%llx swift task %lld backfilled to %d thread states (indexes %lu-%lu)\n", v51, v52, v53, *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + a3);
          *__error() = v49;
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 160) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      }
      else
      {
        [(id)v8 setFilledSwiftTask:1];
        id v54 = *(void **)(a1 + 88);
        if (v8)
        {
          objc_storeWeak((id *)(v8 + 120), v54);
          id v54 = *(void **)(a1 + 88);
        }
        if (v54)
        {
          id v55 = +[SARecipeState stateWithThread:threadStateIndex:]((uint64_t)SASwiftTaskState, *(void **)(a1 + 40), a3);
          [*(id *)(a1 + 96) insertObject:v55 atIndex:0];
        }
        char v17 = 1;
        if (!a3 && qword_1EB698F20)
        {
          int v56 = *__error();
          int v57 = (FILE *)qword_1EB698F20;
          uint64_t v58 = [*(id *)(a1 + 32) machAbsTime];
          uint64_t v59 = [*(id *)(a1 + 40) threadId];
          uint64_t v60 = *(void **)(a1 + 88);
          if (v60) {
            uint64_t v60 = (void *)[v60 identifier];
          }
          fprintf(v57, "%'llu Thread 0x%llx swift task %lld backfilled to all (%d) thread states (indexes %lu-%lu)\n", v58, v59, v60, *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24));
          *__error() = v56;
        }
      }
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 168) + 8) + 24))
    {
      if ([(id)v8 filledScheduling])
      {
        if (*(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) >= 1 && qword_1EB698F20 != 0)
        {
          int v62 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu Thread 0x%llx sched info (cpu time %lld (%lld + %lld), state 0x%x, priority %d (%d), qos %d, rqos %d, qoso %d, qosp %d) backfilled to %d thread states (indexes %lu-%lu)\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "threadId"), *(void *)(a1 + 216) + *(void *)(a1 + 208), *(void *)(a1 + 208), *(void *)(a1 + 216), *(_DWORD *)(a1 + 240), *(_DWORD *)(a1 + 248), *(_DWORD *)(a1 + 244), *(unsigned __int8 *)(a1 + 252), *(unsigned __int8 *)(a1 + 253), *(unsigned __int8 *)(a1 + 254), *(unsigned __int8 *)(a1 + 255), *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + a3);
          *__error() = v62;
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 168) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      }
      else
      {
        [(id)v8 setFilledScheduling:1];
        if (v8)
        {
          *(void *)(v8 + 144) = *(void *)(a1 + 208);
          *(void *)(v8 + 136) = *(void *)(a1 + 216);
          *(_DWORD *)(v8 + 40) = *(_DWORD *)(a1 + 240);
        }
        -[SAThreadState setBasePriority:]((int *)v8, *(_DWORD *)(a1 + 244));
        -[SAThreadState setScheduledPriority:]((int *)v8, *(_DWORD *)(a1 + 248));
        unsigned int v63 = *(unsigned __int8 *)(a1 + 252);
        if (v63 != 125) {
          -[SAThreadState setThreadQos:](v8, v63);
        }
        unsigned int v64 = *(unsigned __int8 *)(a1 + 253);
        if (v64 != 125) {
          -[SAThreadState setThreadRequestedQos:](v8, v64);
        }
        unsigned int v65 = *(unsigned __int8 *)(a1 + 254);
        if (v65 != 125) {
          -[SAThreadState setThreadRequestedQosOverride:](v8, v65);
        }
        unsigned int v66 = *(unsigned __int8 *)(a1 + 255);
        if (v66 != 125) {
          -[SAThreadState setThreadQosPromote:](v8, v66);
        }
        char v17 = 1;
        if (!a3 && qword_1EB698F20)
        {
          int v67 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu Thread 0x%llx sched info (cpu time %lld (%lld + %lld), state 0x%x, priority %d (%d), qos %d, rqos %d, qoso %d, qosp %d) backfilled to all (%d) thread states (indexes %lu-%lu)\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "threadId"), *(void *)(a1 + 216) + *(void *)(a1 + 208), *(void *)(a1 + 208), *(void *)(a1 + 216), *(_DWORD *)(a1 + 240), *(_DWORD *)(a1 + 248), *(_DWORD *)(a1 + 244), *(unsigned __int8 *)(a1 + 252), *(unsigned __int8 *)(a1 + 253), *(unsigned __int8 *)(a1 + 254), *(unsigned __int8 *)(a1 + 255), *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24));
          *__error() = v67;
        }
      }
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 176) + 8) + 24))
    {
      if ([(id)v8 filledCyclesInstructions])
      {
        if (*(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) >= 1 && qword_1EB698F20)
        {
          int v68 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu Thread 0x%llx thread instructions (%llu) cycles (%llu) backfilled to %d thread states (indexes %lu-%lu)\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "threadId"), *(void *)(a1 + 224), *(void *)(a1 + 232), *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + a3);
          *__error() = v68;
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 176) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      }
      else
      {
        [(id)v8 setFilledCyclesInstructions:1];
        if (v8)
        {
          *(void *)(v8 + 152) = *(void *)(a1 + 224);
          *(void *)(v8 + 160) = *(void *)(a1 + 232);
        }
        char v17 = 1;
        if (!a3 && qword_1EB698F20)
        {
          int v69 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu Thread 0x%llx thread instructions (%llu) cycles (%llu) backfilled to all (%d) thread states (indexes %lu-%lu)\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "threadId"), *(void *)(a1 + 224), *(void *)(a1 + 232), *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24));
          *__error() = v69;
        }
      }
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 184) + 8) + 24))
    {
      if ([(id)v8 filledSnapshot])
      {
        if (*(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) >= 1 && qword_1EB698F20)
        {
          uint64_t v130 = a3;
          uint64_t v132 = a4;
          int v122 = *__error();
          uint64_t v127 = (FILE *)qword_1EB698F20;
          uint64_t v124 = [*(id *)(a1 + 32) machAbsTime];
          uint64_t v121 = [*(id *)(a1 + 40) threadId];
          int v70 = *(unsigned __int8 *)(a1 + 256);
          int v71 = *(unsigned __int8 *)(a1 + 257);
          int v72 = *(unsigned __int8 *)(a1 + 258);
          int v73 = *(unsigned __int8 *)(a1 + 259);
          int v74 = *(unsigned __int8 *)(a1 + 260);
          int v75 = *(unsigned __int8 *)(a1 + 261);
          id v76 = [*(id *)(a1 + 104) debugDescription];
          fprintf(v127, "%'llu Thread 0x%llx snapshot info (io tier %d, passive %d, suspended %d, darwinbg %d, idlewq %d, gfi %d, runnable %s) backfilled to %d thread states (indexes %lu-%lu)\n", v124, v121, v70, v71, v72, v73, v74, v75, (const char *)[v76 UTF8String], *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24), v130 + 1, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + v130);

          *__error() = v122;
          a3 = v130;
          a4 = v132;
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 184) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      }
      else
      {
        [(id)v8 setFilledSnapshot:1];
        if (v8)
        {
          *(unsigned char *)(v8 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(unsigned char *)(a1 + 256);
          char v78 = *(unsigned char *)(v8 + 11) & 0x7F | ((*(unsigned char *)(a1 + 257) != 0) << 7);
          *(unsigned char *)(v8 + 11) = v78;
          *(unsigned char *)(v8 + 11) = v78 & 0xBF | (*(unsigned char *)(a1 + 258) << 6);
          char v79 = *(unsigned char *)(v8 + 15) & 0xBF | (*(unsigned char *)(a1 + 259) << 6);
          *(unsigned char *)(v8 + 15) = v79;
          *(unsigned char *)(v8 + 15) = v79 & 0x7F | ((*(unsigned char *)(a1 + 260) != 0) << 7);
        }
        if (*(unsigned char *)(a1 + 261))
        {
          uint64_t v80 = *(void *)(a1 + 40);
          if (v80) {
            *(unsigned char *)(v80 + 16) = 1;
          }
        }
        if (v8)
        {
          id v81 = *(void **)(a1 + 104);
          if (v81) {
            objc_setProperty_atomic((id)v8, v77, v81, 168);
          }
        }
        char v17 = 1;
        if (!a3 && qword_1EB698F20)
        {
          uint64_t v133 = a4;
          int v123 = *__error();
          uint64_t v128 = (FILE *)qword_1EB698F20;
          uint64_t v125 = [*(id *)(a1 + 32) machAbsTime];
          uint64_t v82 = [*(id *)(a1 + 40) threadId];
          int v83 = *(unsigned __int8 *)(a1 + 256);
          int v84 = *(unsigned __int8 *)(a1 + 257);
          int v85 = *(unsigned __int8 *)(a1 + 258);
          int v86 = *(unsigned __int8 *)(a1 + 259);
          int v87 = *(unsigned __int8 *)(a1 + 260);
          int v88 = *(unsigned __int8 *)(a1 + 261);
          id v89 = [*(id *)(a1 + 104) debugDescription];
          fprintf(v128, "%'llu Thread 0x%llx snapshot info (io tier %d, passive %d, suspended %d, darwinbg %d, idlewq %d, gfi %d, runnable %s) backfilled to all (%d) thread states (indexes %lu-%lu)\n", v125, v82, v83, v84, v85, v86, v87, v88, (const char *)[v89 UTF8String], *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24));

          *__error() = v123;
          char v17 = 1;
          a3 = 0;
          a4 = v133;
        }
      }
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 192) + 8) + 24))
    {
      if ([(id)v8 needsExclave])
      {
        [(id)v8 setNeedsExclave:0];
        if (v8) {
          objc_setProperty_atomic((id)v8, v90, *(id *)(a1 + 112), 176);
        }
        if (!a3 && qword_1EB698F20)
        {
          int v91 = *__error();
          int v92 = (FILE *)qword_1EB698F20;
          uint64_t v93 = [*(id *)(a1 + 32) machAbsTime];
          uint64_t v95 = [*(id *)(a1 + 40) threadId];
          id Property = *(id *)(a1 + 112);
          if (Property) {
            id Property = objc_getProperty(Property, v94, 16, 1);
          }
          id v134 = Property;
          uint64_t v98 = [v134 count];
          id v99 = *(id *)(a1 + 112);
          if (v99) {
            id v99 = objc_getProperty(v99, v97, 16, 1);
          }
          id v100 = v99;
          char v101 = [v100 lastObject];
          char v103 = v101;
          if (v101)
          {
            id v104 = objc_getProperty(v101, v102, 16, 1);
            int v105 = v91;
          }
          else
          {
            int v105 = v91;
            id v104 = 0;
          }
          id v106 = v104;
          fprintf(v92, "%'llu Thread 0x%llx exclave info (%lu exclaves, leaf frame 0x%llx) backfilled to all (%d) thread states (indexes %lu-%lu)\n", v93, v95, v98, [v106 address], *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24));

          *__error() = v105;
        }
        goto LABEL_149;
      }
      if (*(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) >= 1 && qword_1EB698F20)
      {
        int v107 = *__error();
        uint64_t v108 = (FILE *)qword_1EB698F20;
        uint64_t v109 = [*(id *)(a1 + 32) machAbsTime];
        uint64_t v111 = [*(id *)(a1 + 40) threadId];
        id v112 = *(id *)(a1 + 112);
        int v135 = a4;
        if (v112) {
          id v112 = objc_getProperty(v112, v110, 16, 1);
        }
        id v131 = v112;
        uint64_t v114 = [v131 count];
        id v115 = *(id *)(a1 + 112);
        uint64_t v126 = v111;
        if (v115) {
          id v115 = objc_getProperty(v115, v113, 16, 1);
        }
        id v129 = v115;
        uint64_t v116 = [v129 lastObject];
        uint64_t v118 = v116;
        if (v116) {
          id v119 = objc_getProperty(v116, v117, 16, 1);
        }
        else {
          id v119 = 0;
        }
        id v120 = v119;
        fprintf(v108, "%'llu Thread 0x%llx exclave info (%lu exclaves, leaf frame 0x%llx) backfilled to %d thread states (indexes %lu-%lu)\n", v109, v126, v114, [v120 address], *(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24), a3 + 1, *(int *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) + a3);

        a4 = v135;
        *__error() = v107;
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 192) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
    }
    if ((v17 & 1) == 0)
    {
      *a4 = 1;
LABEL_153:

      goto LABEL_154;
    }
LABEL_149:
    if ([*(id *)(a1 + 120) dataStyle] != 3)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 128) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      *(unsigned char *)(*(void *)(*(void *)(a1 + 168) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      *(unsigned char *)(*(void *)(*(void *)(a1 + 176) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      *(unsigned char *)(*(void *)(*(void *)(a1 + 184) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
    }
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 136) + 8) + 24);
    goto LABEL_153;
  }
  if (qword_1EB698F20)
  {
    uint64_t v18 = a3;
    int v19 = *__error();
    fprintf((FILE *)qword_1EB698F20, "%'llu Thread 0x%llx ran into non-kperf state at index %lu, stopping\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "threadId"), v18);
    *__error() = v19;
  }
  *a4 = 1;
LABEL_154:
}

void __380__SASampleStore_KPerfPrivate__backfillTask_lastSampleIndex_timestamp_haveSnap_terminatedThreadsUserTimeInNs_terminatedThreadsSystemTimeInNs_terminatedThreadsCycles_terminatedThreadsInstructions_suspendCount_pageins_isDarwinBG_isForeground_isBoosted_isDirty_haveWQFlags_wqExceededTotalThreadLimit_wqExceededConstrainedThreadLimit_haveMem_taskSizeInBytes_haveLatencyQos_latencyQos___block_invoke(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v40 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v7 = v40;
    id v8 = v7;
    uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
    if (!*(unsigned char *)(v9 + 24))
    {
      int v17 = 0;
      goto LABEL_46;
    }
    if (v7)
    {
      if (v7[120])
      {
        if (*(int *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) >= 1 && qword_1EB698F20 != 0)
        {
          int v26 = *__error();
          uint64_t v27 = (FILE *)qword_1EB698F20;
          uint64_t v28 = [*(id *)(a1 + 32) machAbsTime];
          int v29 = [*(id *)(a1 + 40) pid];
          int v30 = *(unsigned __int8 *)(a1 + 144);
          if (*(unsigned char *)(a1 + 144))
          {
            int v30 = *(unsigned __int8 *)(a1 + 145);
            int v31 = *(unsigned __int8 *)(a1 + 146);
          }
          else
          {
            int v31 = 0;
          }
          fprintf(v27, "%'llu task [%d] state (terminated cpu %llu, terminated instruction %llu, terminated cycles %llu, suspend count %d, pageins %u, darwinBG %d, foreground %d, boosted %d, dirty %d, wq total %d, wq constrained %d) backfilled to %d task states (indexes %lu-%lu)\n", v28, v29, *(void *)(a1 + 96) + *(void *)(a1 + 88), *(void *)(a1 + 112), *(void *)(a1 + 104), *(_DWORD *)(a1 + 128), *(_DWORD *)(a1 + 132), *(unsigned __int8 *)(a1 + 140), *(unsigned __int8 *)(a1 + 141), *(unsigned __int8 *)(a1 + 142), *(unsigned __int8 *)(a1 + 143), v30, v31, *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), a3 + 1,
            *(int *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) + a3);
          *__error() = v26;
          uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
        }
        int v17 = 0;
        *(unsigned char *)(v9 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
LABEL_46:
        uint64_t v32 = *(void *)(*(void *)(a1 + 72) + 8);
        if (!*(unsigned char *)(v32 + 24)) {
          goto LABEL_59;
        }
        if (v8)
        {
          if (*((unsigned char *)v8 + 121))
          {
            if (*(int *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) >= 1 && qword_1EB698F20 != 0)
            {
              int v35 = *__error();
              fprintf((FILE *)qword_1EB698F20, "%'llu task [%d] size %llu backfilled to %d task states (indexes %lu-%lu)\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "pid"), *(void *)(a1 + 120), *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), a3 + 1, *(int *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) + a3);
              *__error() = v35;
              uint64_t v32 = *(void *)(*(void *)(a1 + 72) + 8);
            }
            *(unsigned char *)(v32 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
LABEL_59:
            uint64_t v36 = *(void *)(*(void *)(a1 + 80) + 8);
            if (*(unsigned char *)(v36 + 24))
            {
              if (!v8)
              {
LABEL_63:
                if (!a3 && qword_1EB698F20)
                {
                  int v37 = *__error();
                  fprintf((FILE *)qword_1EB698F20, "%'llu task [%d] latency qos %d backfilled to all (%d) task states (indexes %lu-%lu)\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "pid"), *(_DWORD *)(a1 + 136), *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
                  *__error() = v37;
                }
LABEL_73:
                if ([*(id *)(a1 + 48) dataStyle] == 3)
                {
                  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
LABEL_76:

                  goto LABEL_77;
                }
LABEL_75:
                *a4 = 1;
                goto LABEL_76;
              }
              if ((*((unsigned char *)v8 + 122) & 1) == 0)
              {
                *((unsigned char *)v8 + 122) = 1;
                *((_DWORD *)v8 + 6) = *(_DWORD *)(a1 + 136);
                goto LABEL_63;
              }
              if (*(int *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) >= 1 && qword_1EB698F20 != 0)
              {
                int v39 = *__error();
                fprintf((FILE *)qword_1EB698F20, "%'llu task [%d] latency qos %d backfilled to %d task states (indexes %lu-%lu)\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "pid"), *(_DWORD *)(a1 + 136), *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), a3 + 1, *(int *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) + a3);
                *__error() = v39;
                uint64_t v36 = *(void *)(*(void *)(a1 + 80) + 8);
              }
              *(unsigned char *)(v36 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
            }
            if (!v17) {
              goto LABEL_75;
            }
            goto LABEL_73;
          }
          *((unsigned char *)v8 + 121) = 1;
          *((void *)v8 + 8) = *(void *)(a1 + 120);
        }
        int v17 = 1;
        if (!a3 && qword_1EB698F20)
        {
          int v33 = *__error();
          fprintf((FILE *)qword_1EB698F20, "%'llu task [%d] size %llu backfilled to all (%d) task states (indexes %lu-%lu)\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "pid"), *(void *)(a1 + 120), *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) + 1, 0, *(int *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
          *__error() = v33;
          int v17 = 1;
        }
        goto LABEL_59;
      }
      v7[120] = 1;
      *((void *)v7 + 9) = *(void *)(a1 + 88);
      *((void *)v7 + 10) = *(void *)(a1 + 96);
      *((void *)v7 + 12) = *(void *)(a1 + 104);
      *((void *)v7 + 11) = *(void *)(a1 + 112);
      *((_DWORD *)v7 + 2) = *(_DWORD *)(a1 + 128);
      *((_DWORD *)v7 + 4) = *(_DWORD *)(a1 + 132);
    }
    if (*(unsigned char *)(a1 + 140))
    {
      uint64_t v10 = [v7 ssFlags];
      if (v8) {
        *((void *)v8 + 14) = v10 | 0x40;
      }
    }
    if (*(unsigned char *)(a1 + 141))
    {
      uint64_t v11 = [v8 ssFlags];
      if (v8) {
        *((void *)v8 + 14) = v11 | 0x400;
      }
    }
    if (*(unsigned char *)(a1 + 142))
    {
      uint64_t v12 = [v8 ssFlags];
      if (v8) {
        *((void *)v8 + 14) = v12 | 0x800;
      }
    }
    if (*(unsigned char *)(a1 + 143))
    {
      uint64_t v13 = [v8 ssFlags];
      if (v8) {
        *((void *)v8 + 14) = v13 | 0x10000;
      }
    }
    if (*(unsigned char *)(a1 + 144))
    {
      uint64_t v14 = [v8 ssFlags];
      if (v8) {
        *((void *)v8 + 14) = v14 | 0x80000;
      }
      if (*(unsigned char *)(a1 + 145))
      {
        uint64_t v15 = [v8 ssFlags];
        if (v8) {
          *((void *)v8 + 14) = v15 | 0x40000;
        }
      }
      if (*(unsigned char *)(a1 + 146))
      {
        uint64_t v16 = [v8 ssFlags];
        if (v8) {
          *((void *)v8 + 14) = v16 | 0x20000;
        }
      }
    }
    int v17 = 1;
    if (!a3 && qword_1EB698F20)
    {
      int v18 = *__error();
      int v19 = (FILE *)qword_1EB698F20;
      uint64_t v20 = [*(id *)(a1 + 32) machAbsTime];
      int v21 = [*(id *)(a1 + 40) pid];
      int v22 = *(unsigned __int8 *)(a1 + 144);
      if (*(unsigned char *)(a1 + 144))
      {
        int v23 = *(unsigned __int8 *)(a1 + 145);
        int v22 = *(unsigned __int8 *)(a1 + 146);
      }
      else
      {
        int v23 = 0;
      }
      fprintf(v19, "%'llu task [%d] state (terminated cpu %llu, terminated instruction %llu, terminated cycles %llu, suspend count %d, pageins %u, darwinBG %d, foreground %d, boosted %d, dirty %d, wq total %d, wq constrained %d) backfilled to all (%d) task states (indexes %lu-%lu)\n", v20, v21, *(void *)(a1 + 96) + *(void *)(a1 + 88), *(void *)(a1 + 112), *(void *)(a1 + 104), *(_DWORD *)(a1 + 128), *(_DWORD *)(a1 + 132), *(unsigned __int8 *)(a1 + 140), *(unsigned __int8 *)(a1 + 141), *(unsigned __int8 *)(a1 + 142), *(unsigned __int8 *)(a1 + 143), v23, v22, *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) + 1, 0,
        *(int *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
      *__error() = v18;
      int v17 = 1;
    }
    goto LABEL_46;
  }
  if (qword_1EB698F20)
  {
    int v24 = *__error();
    fprintf((FILE *)qword_1EB698F20, "%'llu task [%d] ran into non-kperf state at index %lu, stopping\n", [*(id *)(a1 + 32) machAbsTime], objc_msgSend(*(id *)(a1 + 40), "pid"), a3);
    *__error() = v24;
  }
  *a4 = 1;
LABEL_77:
}

- (id)binaryFormat
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = [[PASampleTimeSeriesDataStore alloc] initWithSampleStore:self];
  id v29 = 0;
  id v3 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v2 requiringSecureCoding:1 error:&v29];
  id v4 = v29;
  if (![v3 length])
  {
    int v15 = *__error();
    uint64_t v16 = _sa_logt();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      id v26 = [v4 description];
      uint64_t v27 = [v26 UTF8String];
      *(_DWORD *)long long buf = 136315138;
      uLong v31 = v27;
      _os_log_error_impl(&dword_1BF22B000, v16, OS_LOG_TYPE_ERROR, "Unable to archive samples for binary format: %s", buf, 0xCu);
    }
    *__error() = v15;

    goto LABEL_13;
  }

  uLong v5 = [v3 length];
  id v6 = v3;
  uint64_t v7 = [v6 bytes];
  if (!v7)
  {
    int v17 = *__error();
    int v18 = _sa_logt();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v18, OS_LOG_TYPE_ERROR, "Unable to get bytes for binary format", buf, 2u);
    }

    *__error() = v17;
    goto LABEL_13;
  }
  id v8 = (const Bytef *)v7;
  uLong v9 = compressBound(v5);
  uLongf v28 = v9;
  uint64_t v10 = (Bytef *)malloc_type_malloc(v9 + 8, 0xCB9F53E7uLL);
  int v11 = compress(v10 + 8, &v28, v8, v5);

  int v12 = *__error();
  uint64_t v13 = _sa_logt();
  uint64_t v14 = v13;
  if (v11)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134218496;
      uLong v31 = v5;
      __int16 v32 = 2048;
      uLongf v33 = v9;
      __int16 v34 = 1024;
      LODWORD(v35) = v11;
      _os_log_error_impl(&dword_1BF22B000, v14, OS_LOG_TYPE_ERROR, "Unable to compress binary format of size %lu to estimated compressed size %lu: %d", buf, 0x1Cu);
    }

    *__error() = v12;
    free(v10);
LABEL_13:
    int v19 = 0;
    goto LABEL_14;
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134218496;
    uLong v31 = v5;
    __int16 v32 = 2048;
    uLongf v33 = v28;
    __int16 v34 = 2048;
    double v35 = (double)(v5 - v28) * 100.0 / (double)v5;
    _os_log_debug_impl(&dword_1BF22B000, v14, OS_LOG_TYPE_DEBUG, "Compressed %lu binary data into %lu (%.0f%% savings)", buf, 0x20u);
  }

  *__error() = v12;
  *(void *)uint64_t v10 = v5;
  v28 += 8;
  id v21 = objc_alloc(MEMORY[0x1E4F1CA58]);
  int v22 = (void *)[v21 initWithBytesNoCopy:v10 length:v28 freeWhenDone:1];
  int v19 = v22;
  if (v22)
  {
    id v23 = v22;
  }
  else
  {
    int v24 = *__error();
    id v25 = _sa_logt();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v25, OS_LOG_TYPE_ERROR, "Unable to create NSData for compressed binary format", buf, 2u);
    }

    *__error() = v24;
    free(v10);
  }

LABEL_14:
  return v19;
}

- (BOOL)saveBinaryFormatToStream:(__sFILE *)a3
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v4 = [(SASampleStore *)self binaryFormat];
  uLong v5 = v4;
  if (v4)
  {
    id v6 = [v4 base64EncodedDataWithOptions:34];

    if (v6)
    {
      size_t v7 = [v6 length];
      id v8 = (const void *)[v6 bytes];
      LOBYTE(v5) = 1;
      fwrite("Spindump binary format\n", 0x17uLL, 1uLL, a3);
      if (fwrite(v8, v7, 1uLL, a3) == 1)
      {
LABEL_8:

        return (char)v5;
      }
      int v9 = *__error();
      uLong v5 = _sa_logt();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v14[0] = 67109120;
        v14[1] = ferror(a3);
        uint64_t v10 = "Unable to save binary format: %d";
        int v11 = v5;
        uint32_t v12 = 8;
LABEL_11:
        _os_log_error_impl(&dword_1BF22B000, v11, OS_LOG_TYPE_ERROR, v10, (uint8_t *)v14, v12);
      }
    }
    else
    {
      int v9 = *__error();
      uLong v5 = _sa_logt();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v14[0]) = 0;
        uint64_t v10 = "Unable to get bytes for binary format";
        int v11 = v5;
        uint32_t v12 = 2;
        goto LABEL_11;
      }
    }

    LOBYTE(v5) = 0;
    *__error() = v9;
    goto LABEL_8;
  }
  return (char)v5;
}

+ (id)sampleStoreForSpindumpFile:(const char *)a3
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    goto LABEL_18;
  }
  int v5 = open(a3, 0);
  if (v5 == -1)
  {
    int v15 = *__error();
    uint64_t v16 = _sa_logt();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
LABEL_12:

      int v17 = 0;
      *__error() = v15;
      goto LABEL_19;
    }
    int v24 = *__error();
    v63.st_dev = 136315394;
    *(void *)&v63.st_mode = a3;
    WORD2(v63.st_ino) = 1024;
    *(_DWORD *)((char *)&v63.st_ino + 6) = v24;
    id v25 = "Unable to open %s: %{errno}d";
    id v26 = &v63;
    uint64_t v27 = v16;
    uint32_t v28 = 18;
LABEL_29:
    _os_log_error_impl(&dword_1BF22B000, v27, OS_LOG_TYPE_ERROR, v25, (uint8_t *)v26, v28);
    goto LABEL_12;
  }
  int v6 = v5;
  size_t v7 = fdopen(v5, "r");
  if (!v7)
  {
    int v18 = *__error();
    int v19 = _sa_logt();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      int v29 = *__error();
      v63.st_dev = 136315394;
      *(void *)&v63.st_mode = a3;
      WORD2(v63.st_ino) = 1024;
      *(_DWORD *)((char *)&v63.st_ino + 6) = v29;
      _os_log_error_impl(&dword_1BF22B000, v19, OS_LOG_TYPE_ERROR, "Unable to fopen %s: %{errno}d", (uint8_t *)&v63, 0x12u);
    }

    *__error() = v18;
    close(v6);
    goto LABEL_18;
  }
  id v8 = v7;
  int v9 = malloc_type_malloc(0x800uLL, 0x622A912BuLL);
  do
  {
    if (!fgets((char *)v9, 2048, v8))
    {
      free(v9);
      int v11 = *__error();
      uint32_t v12 = _sa_logt();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_17;
      }
      v63.st_dev = 136315138;
      *(void *)&v63.st_mode = a3;
      id v23 = &v63;
LABEL_53:
      _os_log_debug_impl(&dword_1BF22B000, v12, OS_LOG_TYPE_DEBUG, "Input file %s does not contain a binary format for spindump", (uint8_t *)v23, 0xCu);
      goto LABEL_17;
    }
  }
  while (strncmp("Spindump binary format", (const char *)v9, 0x16uLL));
  free(v9);
  uint64_t v10 = MEMORY[0x1C18A6470](v8);
  memset(&v63, 0, sizeof(v63));
  if (fstat(v6, &v63))
  {
    int v11 = *__error();
    uint32_t v12 = _sa_logt();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v13 = *__error();
      int v61 = 136315394;
      *(void *)int v62 = a3;
      *(_WORD *)&v62[8] = 1024;
      *(_DWORD *)&v62[10] = v13;
      uint64_t v14 = "Unable to fstat %s: %{errno}d";
      goto LABEL_10;
    }
    goto LABEL_17;
  }
  if (v63.st_size <= v10)
  {
    int v11 = *__error();
    uint32_t v12 = _sa_logt();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_17;
    }
    int v61 = 136315138;
    *(void *)int v62 = a3;
    id v23 = (stat *)&v61;
    goto LABEL_53;
  }
  id v21 = mmap(0, v63.st_size, 1, 1, v6, 0);
  if ((unint64_t)(v21 + 1) <= 1)
  {
    int v11 = *__error();
    uint32_t v12 = _sa_logt();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v22 = *__error();
      int v61 = 136315394;
      *(void *)int v62 = a3;
      *(_WORD *)&v62[8] = 1024;
      *(_DWORD *)&v62[10] = v22;
      uint64_t v14 = "Unable to mmap %s: %{errno}d";
LABEL_10:
      _os_log_error_impl(&dword_1BF22B000, v12, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v61, 0x12u);
    }
LABEL_17:

    *__error() = v11;
    fclose(v8);
LABEL_18:
    int v17 = 0;
    goto LABEL_19;
  }
  int v30 = v21;
  fclose(v8);
  off_t st_size = v63.st_size;
  if (v10 >= v63.st_size)
  {
    off_t v37 = v10;
    goto LABEL_65;
  }
  uint64_t v32 = 0;
  char v33 = 0;
  BOOL v34 = 1;
  uint64_t v35 = v10;
  off_t v36 = v10;
  off_t v37 = v10;
  while (2)
  {
    uint64_t v38 = v35 - v36;
    if (v32 && v38 > v32)
    {
      int v41 = *__error();
      int v42 = _sa_logt();
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_60;
      }
      int v61 = 134217984;
      *(void *)int v62 = v35;
      uint64_t v43 = "Found bad line length at %lld, ending scan";
      uint64_t v44 = v42;
      uint32_t v45 = 12;
      goto LABEL_59;
    }
    int v39 = (char)v30[v35];
    if ((v33 & 1) == 0)
    {
      if (((v39 & 0xDF) - 65) < 0x1Au
        || (v39 != 43 ? (BOOL v40 = (v39 - 47) >= 0xBu) : (BOOL v40 = 0), !v40))
      {
        char v33 = 0;
        goto LABEL_50;
      }
    }
    if (v39 == 61)
    {
      char v33 = 1;
      goto LABEL_50;
    }
    if (v30[v35] != 10)
    {
      int v41 = *__error();
      int v42 = _sa_logt();
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_60;
      }
      int v61 = 67109376;
      *(_DWORD *)int v62 = v39;
      *(_WORD *)&v62[4] = 2048;
      *(void *)&v62[6] = v35;
      uint64_t v43 = "Found invalid base64 character '%c' at %lld, ending scan";
      uint64_t v44 = v42;
      uint32_t v45 = 18;
LABEL_59:
      _os_log_debug_impl(&dword_1BF22B000, v44, OS_LOG_TYPE_DEBUG, v43, (uint8_t *)&v61, v45);
LABEL_60:

      *__error() = v41;
      if (!v34)
      {
        off_t st_size = v63.st_size;
        goto LABEL_65;
      }
      goto LABEL_64;
    }
    off_t v36 = v35 + 1;
    if (v32)
    {
      if (v38 != v32) {
        goto LABEL_63;
      }
    }
    else
    {
      uint64_t v32 = v38;
    }
    if ((v33 & 1) == 0)
    {
      char v33 = 0;
      off_t v37 = v35 + 1;
LABEL_50:
      BOOL v34 = ++v35 < v63.st_size;
      if (v63.st_size == v35) {
        goto LABEL_63;
      }
      continue;
    }
    break;
  }
  off_t v37 = v35 + 1;
  off_t v36 = v35 + 1;
LABEL_63:
  if (!v34) {
    goto LABEL_65;
  }
LABEL_64:
  off_t st_size = v36;
LABEL_65:
  uint64_t v46 = [objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytesNoCopy:&v30[v10] length:st_size - v10 freeWhenDone:0];
  if (!v46)
  {
    int v50 = *__error();
    uint64_t v51 = _sa_logt();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v61) = 0;
LABEL_87:
      _os_log_error_impl(&dword_1BF22B000, v51, OS_LOG_TYPE_ERROR, "Unable to create NSData for base64 binary format", (uint8_t *)&v61, 2u);
    }
LABEL_69:

    *__error() = v50;
    munmap(v30, v63.st_size);
    goto LABEL_18;
  }
  int v47 = (void *)v46;
  uint64_t v48 = [objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBase64EncodedData:v46 options:1];
  if (v48)
  {
    int v49 = (void *)v48;
    goto LABEL_76;
  }
  BOOL v52 = st_size <= v37;
  size_t v53 = st_size - v37;
  if (!v52)
  {
    id v54 = malloc_type_calloc(v53 + 1, 1uLL, 0x67DAB1E3uLL);
    memmove(v54, &v30[v37], v53);
    int v55 = *__error();
    int v56 = _sa_logt();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
    {
      int v61 = 136315138;
      *(void *)int v62 = v54;
      _os_log_debug_impl(&dword_1BF22B000, v56, OS_LOG_TYPE_DEBUG, "Possible extra text at end of base-64 encoded data, ignoring last line \"%s\"", (uint8_t *)&v61, 0xCu);
    }

    *__error() = v55;
    free(v54);
    uint64_t v57 = [objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytesNoCopy:&v30[v10] length:v37 - v10 freeWhenDone:0];

    if (v57)
    {
      int v49 = (void *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBase64EncodedData:v57 options:1];
      int v47 = (void *)v57;
      goto LABEL_76;
    }
    int v50 = *__error();
    uint64_t v51 = _sa_logt();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v61) = 0;
      goto LABEL_87;
    }
    goto LABEL_69;
  }
  int v49 = 0;
LABEL_76:

  if (munmap(v30, v63.st_size))
  {
    int v58 = *__error();
    uint64_t v59 = _sa_logt();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      int v60 = *__error();
      int v61 = 67109120;
      *(_DWORD *)int v62 = v60;
      _os_log_error_impl(&dword_1BF22B000, v59, OS_LOG_TYPE_ERROR, "Unable to unmap file: %{errno}d", (uint8_t *)&v61, 8u);
    }

    *__error() = v58;
  }
  if (!v49)
  {
    int v15 = *__error();
    uint64_t v16 = _sa_logt();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    LOWORD(v61) = 0;
    id v25 = "Unable to decode base64 binary format";
    id v26 = (stat *)&v61;
    uint64_t v27 = v16;
    uint32_t v28 = 2;
    goto LABEL_29;
  }
  int v17 = [a1 sampleStoreForBinaryFormat:v49];

LABEL_19:
  return v17;
}

+ (id)sampleStoreForBinaryFormat:(id)a3
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  id v3 = a3;
  id v4 = v3;
  if (!v3)
  {
    int v15 = *__error();
    uint64_t v16 = _sa_logt();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_WORD *)long long buf = 0;
    int v17 = "Nil data";
    int v18 = v16;
    uint32_t v19 = 2;
LABEL_14:
    _os_log_error_impl(&dword_1BF22B000, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
    goto LABEL_15;
  }
  uint64_t v5 = [v3 length];
  int v6 = (size_t *)[v4 bytes];
  id v8 = (const Bytef *)(v6 + 1);
  uLongf v7 = *v6;
  if (*v6 == -1)
  {
    int v15 = *__error();
    uint64_t v16 = _sa_logt();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_DWORD *)long long buf = 134217984;
    uLongf v40 = -1;
    int v17 = "Bad uncompressed size %llu";
    int v18 = v16;
    uint32_t v19 = 12;
    goto LABEL_14;
  }
  int v9 = (Bytef *)malloc_type_malloc(*v6, 0xDB0691B9uLL);
  if (!v9)
  {
    int v15 = *__error();
    uint64_t v16 = _sa_logt();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      int v20 = *__error();
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v40) = v20;
      int v17 = "Unable to allocate buffer for binary format: %{errno}d";
      int v18 = v16;
      uint32_t v19 = 8;
      goto LABEL_14;
    }
LABEL_15:

    id v21 = 0;
    *__error() = v15;
    goto LABEL_25;
  }
  uint64_t v10 = v9;
  destLeuint64_t n = v7;
  int v11 = uncompress(v9, &destLen, v8, v5 - 8);
  if (v11)
  {
    int v12 = v11;
    int v13 = *__error();
    uint64_t v14 = _sa_logt();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v40) = v12;
      _os_log_error_impl(&dword_1BF22B000, v14, OS_LOG_TYPE_ERROR, "Unable to decompress binary format: %d", buf, 8u);
    }

LABEL_24:
    *__error() = v13;
    free(v10);
    id v21 = 0;
    goto LABEL_25;
  }
  if (v7 != destLen)
  {
    int v13 = *__error();
    uint64_t v27 = _sa_logt();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134218240;
      uLongf v40 = destLen;
      __int16 v41 = 2048;
      uLongf v42 = v7;
      _os_log_error_impl(&dword_1BF22B000, v27, OS_LOG_TYPE_ERROR, "Unexpected uncompressed size %lu, expected %llu", buf, 0x16u);
    }

    goto LABEL_24;
  }
  id v22 = objc_alloc(MEMORY[0x1E4F1C9B8]);
  id v23 = (void *)[v22 initWithBytesNoCopy:v10 length:destLen freeWhenDone:1];
  if (v23)
  {
    id v37 = 0;
    int v24 = (void *)[objc_alloc(MEMORY[0x1E4F28DC0]) initForReadingFromData:v23 error:&v37];
    id v25 = v37;
    id v26 = v25;
    if (v24)
    {

      id v26 = [v24 decodeObjectOfClass:objc_opt_class() forKey:*MEMORY[0x1E4F284E8]];
      [v24 finishDecoding];
      if (v26)
      {
        id v21 = [v26 sampleStore];
        [v21 setDataGatheringOptions:628];
      }
      else
      {
        int v33 = *__error();
        BOOL v34 = _sa_logt();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl(&dword_1BF22B000, v34, OS_LOG_TYPE_ERROR, "Unable to unarchive binary format", buf, 2u);
        }

        id v26 = 0;
        id v21 = 0;
        *__error() = v33;
      }
    }
    else
    {
      int v31 = *__error();
      uint64_t v32 = _sa_logt();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        id v35 = [v26 description];
        uint64_t v36 = [v35 UTF8String];
        *(_DWORD *)long long buf = 136315138;
        uLongf v40 = v36;
        _os_log_error_impl(&dword_1BF22B000, v32, OS_LOG_TYPE_ERROR, "Unable to unarchive: %s", buf, 0xCu);
      }
      id v21 = 0;
      *__error() = v31;
    }
  }
  else
  {
    int v29 = *__error();
    int v30 = _sa_logt();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1BF22B000, v30, OS_LOG_TYPE_ERROR, "Unable to create NSData for binary format", buf, 2u);
    }

    *__error() = v29;
    free(v10);
    id v21 = 0;
  }

LABEL_25:
  return v21;
}

@end