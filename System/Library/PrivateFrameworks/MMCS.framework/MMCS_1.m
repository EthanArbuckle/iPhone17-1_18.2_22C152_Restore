void mmcs_local_chunk_satisfyer_perform_cold_3()
{
  __assert_rtn("mmcs_local_chunk_satisfyer_get_item_reader", "mmcs_local_chunk_satisfyer.c", 98, "!localChunkSatisfyer->currentSourceItemReaderWriter");
}

void mmcs_local_chunk_satisfyer_perform_cold_4()
{
}

void mmcs_local_chunk_satisfyer_perform_cold_5()
{
}

void mmcs_local_chunk_satisfyer_copy_chunk_cold_1()
{
}

void mmcs_local_chunk_satisfyer_copy_chunk_cold_2()
{
}

void mmcs_local_chunk_satisfyer_copy_chunk_cold_3()
{
  __assert_rtn("mmcs_local_chunk_satisfyer_copy_chunk", "mmcs_local_chunk_satisfyer.c", 142, "chunkInstance->satisfiedLocally == false");
}

void MMCSOperationStateTimeRangeFilteredRanges_cold_1()
{
}

void MMCSOperationStateTimeRangeFilteredRanges_cold_2()
{
}

void chunkserver__put_complete_at_edge_payload_trailer__get_packed_size_cold_1()
{
  __assert_rtn("chunkserver__put_complete_at_edge_payload_trailer__get_packed_size", "Chunk.pb-c.c", 244, "message->base.descriptor == &chunkserver__put_complete_at_edge_payload_trailer__descriptor");
}

void chunkserver__put_complete_at_edge_payload_trailer__pack_cold_1()
{
  __assert_rtn("chunkserver__put_complete_at_edge_payload_trailer__pack", "Chunk.pb-c.c", 251, "message->base.descriptor == &chunkserver__put_complete_at_edge_payload_trailer__descriptor");
}

void chunkserver__put_complete_at_edge_payload_trailer__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__put_complete_at_edge_payload_trailer__free_unpacked", "Chunk.pb-c.c", 277, "message->base.descriptor == &chunkserver__put_complete_at_edge_payload_trailer__descriptor");
}

void chunkserver__error_response__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__error_response__free_unpacked", "Chunk.pb-c.c", 322, "message->base.descriptor == &chunkserver__error_response__descriptor");
}

void chunkserver__method_completion_info__get_packed_size_cold_1()
{
  __assert_rtn("chunkserver__method_completion_info__get_packed_size", "Chunk.pb-c.c", 604, "message->base.descriptor == &chunkserver__method_completion_info__descriptor");
}

void chunkserver__method_completion_info__pack_cold_1()
{
  __assert_rtn("chunkserver__method_completion_info__pack", "Chunk.pb-c.c", 611, "message->base.descriptor == &chunkserver__method_completion_info__descriptor");
}

void chunkserver__method_completion_info__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__method_completion_info__free_unpacked", "Chunk.pb-c.c", 637, "message->base.descriptor == &chunkserver__method_completion_info__descriptor");
}

void chunkserver__method_completion_info_list__get_packed_size_cold_1()
{
  __assert_rtn("chunkserver__method_completion_info_list__get_packed_size", "Chunk.pb-c.c", 649, "message->base.descriptor == &chunkserver__method_completion_info_list__descriptor");
}

void chunkserver__method_completion_info_list__pack_cold_1()
{
  __assert_rtn("chunkserver__method_completion_info_list__pack", "Chunk.pb-c.c", 656, "message->base.descriptor == &chunkserver__method_completion_info_list__descriptor");
}

void chunkserver__method_completion_info_list__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__method_completion_info_list__free_unpacked", "Chunk.pb-c.c", 682, "message->base.descriptor == &chunkserver__method_completion_info_list__descriptor");
}

void chunkserver__file_chunk_lists__get_packed_size_cold_1()
{
  __assert_rtn("chunkserver__file_chunk_lists__get_packed_size", "Chunk.pb-c.c", 745, "message->base.descriptor == &chunkserver__file_chunk_lists__descriptor");
}

void chunkserver__file_chunk_lists__pack_cold_1()
{
  __assert_rtn("chunkserver__file_chunk_lists__pack", "Chunk.pb-c.c", 752, "message->base.descriptor == &chunkserver__file_chunk_lists__descriptor");
}

void chunkserver__storage_container_chunk_lists__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__storage_container_chunk_lists__free_unpacked", "Chunk.pb-c.c", 874, "message->base.descriptor == &chunkserver__storage_container_chunk_lists__descriptor");
}

void chunkserver__storage_container_error_list__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__storage_container_error_list__free_unpacked", "Chunk.pb-c.c", 964, "message->base.descriptor == &chunkserver__storage_container_error_list__descriptor");
}

void chunkserver__file_checksum_authorization_list__get_packed_size_cold_1()
{
  __assert_rtn("chunkserver__file_checksum_authorization_list__get_packed_size", "Chunk.pb-c.c", 1021, "message->base.descriptor == &chunkserver__file_checksum_authorization_list__descriptor");
}

void chunkserver__file_checksum_authorization_list__pack_cold_1()
{
  __assert_rtn("chunkserver__file_checksum_authorization_list__pack", "Chunk.pb-c.c", 1028, "message->base.descriptor == &chunkserver__file_checksum_authorization_list__descriptor");
}

void chunkserver__file_checksum_authorization_list__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__file_checksum_authorization_list__free_unpacked", "Chunk.pb-c.c", 1054, "message->base.descriptor == &chunkserver__file_checksum_authorization_list__descriptor");
}

void chunkserver__file_groups__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__file_groups__free_unpacked", "Chunk.pb-c.c", 1234, "message->base.descriptor == &chunkserver__file_groups__descriptor");
}

void chunkserver__get_chunk_keys_request__get_packed_size_cold_1()
{
  __assert_rtn("chunkserver__get_chunk_keys_request__get_packed_size", "Chunk.pb-c.c", 1561, "message->base.descriptor == &chunkserver__get_chunk_keys_request__descriptor");
}

void chunkserver__get_chunk_keys_request__pack_cold_1()
{
  __assert_rtn("chunkserver__get_chunk_keys_request__pack", "Chunk.pb-c.c", 1568, "message->base.descriptor == &chunkserver__get_chunk_keys_request__descriptor");
}

void chunkserver__get_chunk_keys_request__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__get_chunk_keys_request__free_unpacked", "Chunk.pb-c.c", 1594, "message->base.descriptor == &chunkserver__get_chunk_keys_request__descriptor");
}

void chunkserver__get_chunk_keys_response__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__get_chunk_keys_response__free_unpacked", "Chunk.pb-c.c", 1684, "message->base.descriptor == &chunkserver__get_chunk_keys_response__descriptor");
}

void chunkserver__put_file_chunk_keys__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__put_file_chunk_keys__free_unpacked", "Chunk.pb-c.c", 1729, "message->base.descriptor == &chunkserver__put_file_chunk_keys__descriptor");
}

void chunkserver__put_chunk_keys_request__get_packed_size_cold_1()
{
  __assert_rtn("chunkserver__put_chunk_keys_request__get_packed_size", "Chunk.pb-c.c", 1741, "message->base.descriptor == &chunkserver__put_chunk_keys_request__descriptor");
}

void chunkserver__put_chunk_keys_request__pack_cold_1()
{
  __assert_rtn("chunkserver__put_chunk_keys_request__pack", "Chunk.pb-c.c", 1748, "message->base.descriptor == &chunkserver__put_chunk_keys_request__descriptor");
}

void chunkserver__put_chunk_keys_request__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__put_chunk_keys_request__free_unpacked", "Chunk.pb-c.c", 1774, "message->base.descriptor == &chunkserver__put_chunk_keys_request__descriptor");
}

void chunkserver__put_chunk_keys_response__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__put_chunk_keys_response__free_unpacked", "Chunk.pb-c.c", 1819, "message->base.descriptor == &chunkserver__put_chunk_keys_response__descriptor");
}

void chunkserver__clone_complete_request__get_packed_size_cold_1()
{
  __assert_rtn("chunkserver__clone_complete_request__get_packed_size", "Chunk.pb-c.c", 1966, "message->base.descriptor == &chunkserver__clone_complete_request__descriptor");
}

void chunkserver__clone_complete_request__pack_cold_1()
{
  __assert_rtn("chunkserver__clone_complete_request__pack", "Chunk.pb-c.c", 1973, "message->base.descriptor == &chunkserver__clone_complete_request__descriptor");
}

void chunkserver__clone_complete_response__free_unpacked_cold_1()
{
  __assert_rtn("chunkserver__clone_complete_response__free_unpacked", "Chunk.pb-c.c", 2044, "message->base.descriptor == &chunkserver__clone_complete_response__descriptor");
}

void mmcs_base64_encode_cfdata_to_cstring_cold_1()
{
}

void MMCSItemFDReaderWriterGetCacheBlobWithName_cold_1()
{
}

void MMCSItemFDReaderWriterGetCacheBlobWithName_cold_2()
{
}

void MMCSItemFDReaderWriterSetCacheBlobWithName_cold_1()
{
}

void MMCSItemFDReaderWriterSetCacheBlobWithName_cold_2()
{
}

void MMCSItemFDReaderWriterWrite_cold_1()
{
  __assert_rtn("MMCSItemFDReaderWriterWrite", "mmcs_item_fd_reader_writer.c", 183, "fileReaderWriter->fd != -1");
}

void mmcs_operation_metric_test_cold_1()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 47, "range.relativeStart == 0.0");
}

void mmcs_operation_metric_test_cold_2()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 48, "range.duration == 1.0");
}

void mmcs_operation_metric_test_cold_3()
{
}

void mmcs_operation_metric_test_cold_4()
{
}

void mmcs_operation_metric_test_cold_5()
{
}

void mmcs_operation_metric_test_cold_6()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 76, "range.relativeStart == 0.0");
}

void mmcs_operation_metric_test_cold_7()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 77, "range.duration == 1.0");
}

void mmcs_operation_metric_test_cold_8()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 79, "range.relativeStart == 2.0");
}

void mmcs_operation_metric_test_cold_9()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 80, "range.duration == 1.0");
}

void mmcs_operation_metric_test_cold_10()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 89, "range.relativeStart == 0.0");
}

void mmcs_operation_metric_test_cold_11()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 90, "range.duration == 2.0");
}

void mmcs_operation_metric_test_cold_12()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 99, "range.relativeStart == 0.0");
}

void mmcs_operation_metric_test_cold_13()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 100, "range.duration == 1.5");
}

void mmcs_operation_metric_test_cold_14()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 122, "range.relativeStart == 1.0");
}

void mmcs_operation_metric_test_cold_15()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 123, "range.duration == 0.5");
}

void mmcs_operation_metric_test_cold_16()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 134, "range.relativeStart == 0.5");
}

void mmcs_operation_metric_test_cold_17()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 135, "range.duration == 0.5");
}

void mmcs_operation_metric_test_cold_18()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 137, "range.relativeStart == 1.25");
}

void mmcs_operation_metric_test_cold_19()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 138, "range.duration == 0.25");
}

void mmcs_operation_metric_test_cold_20()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 149, "range.relativeStart == 0.5");
}

void mmcs_operation_metric_test_cold_21()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 150, "range.duration == 0.5");
}

void mmcs_operation_metric_test_cold_22()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 170, "range.relativeStart == 0.5");
}

void mmcs_operation_metric_test_cold_23()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 171, "range.duration == 1.0");
}

void mmcs_operation_metric_test_cold_24()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 182, "range.relativeStart == 0.5");
}

void mmcs_operation_metric_test_cold_25()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 183, "range.duration == 1.0");
}

void mmcs_operation_metric_test_cold_26()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 180, "difference.count == 1");
}

void mmcs_operation_metric_test_cold_27()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 168, "difference.count == 1");
}

void mmcs_operation_metric_test_cold_28()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 159, "difference.count == 0");
}

void mmcs_operation_metric_test_cold_29()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 147, "difference.count == 1");
}

void mmcs_operation_metric_test_cold_30()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 132, "difference.count == 2");
}

void mmcs_operation_metric_test_cold_31()
{
  __assert_rtn("_test_filter", "mmcs_operation_metric.m", 120, "difference.count == 1");
}

void mmcs_operation_metric_test_cold_32()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 97, "merge.count == 1");
}

void mmcs_operation_metric_test_cold_33()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 87, "merge.count == 1");
}

void mmcs_operation_metric_test_cold_34()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 74, "merge.count == 2");
}

void mmcs_operation_metric_test_cold_35()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 66, "0 == merge.count");
}

void mmcs_operation_metric_test_cold_36()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 60, "0 == merge.count");
}

void mmcs_operation_metric_test_cold_37()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 54, "0 == merge.count");
}

void mmcs_operation_metric_test_cold_38()
{
  __assert_rtn("_test_merge", "mmcs_operation_metric.m", 45, "merge.count == 1");
}

void mmcs_http_request_options_network_behavior_type_cold_1()
{
}

void MMCSItemMemoryReaderWriterWrite_cold_1()
{
}

void _mmcs_RegisterChunksForItem_cold_1()
{
}

void mmcs_compute_signature_and_register_item_with_item_reader_writer_cold_1()
{
}

void mmcs_chunk_key_copy_wraptured_scheme_and_key_cold_1()
{
  __assert_rtn("mmcs_chunk_key_copy_wraptured_scheme_and_key", "mmcs_chunk.c", 363, "CFDataGetLength(unwrappedKey)==16");
}

void mmcs_chunk_key_copy_wraptured_scheme_and_key_cold_2()
{
  __assert_rtn("mmcs_chunk_key_copy_wraptured_scheme_and_key", "mmcs_chunk.c", 349, "CFDataGetLength(schemeAndKey) == 25");
}

void mmcs_chunk_key_copy_wraptured_scheme_and_key_cold_3()
{
  __assert_rtn("mmcs_chunk_key_copy_wraptured_scheme_and_key", "mmcs_chunk.c", 338, "CFDataGetLength(wrappedKey)==24");
}

void mmcs_chunk_key_copy_wraptured_scheme_and_key_cold_4()
{
  __assert_rtn("mmcs_chunk_key_copy_wraptured_scheme_and_key", "mmcs_chunk.c", 324, "CFDataGetLength(schemeAndKey) == 17");
}

void mmcs_chunk_progressive_v1_padded_chunk_length_cold_1()
{
}

void mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_1()
{
  __assert_rtn("mmcs_padded_chunk_length_with_policy_and_chunk_length", "mmcs_chunk.c", 412, "chunkLength != 0");
}

void mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_2(uint64_t a1)
{
  v2 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unsupported MMCSPaddingPolicy %ld requested", a1);
    v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      CFStringRef v6 = v3;
      _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v3) {
      CFRelease(v3);
    }
  }
  __assert_rtn("mmcs_padded_chunk_length_with_policy_and_chunk_length", "mmcs_chunk.c", 426, "false && \"Unsupported MMCSPaddingPolicy Requested\"");
}

void mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_3()
{
  __assert_rtn("mmcs_padded_chunk_length_with_policy_and_chunk_length", "mmcs_chunk.c", 431, "paddedChunkLength <= TWICE_MAX_FIXED_LENGTH_CHUNK_SIZE");
}

void mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_4()
{
  __assert_rtn("mmcs_chunk_1kb_padded_chunk_length", "mmcs_chunk.c", 388, "paddedLength <= (UInt64)UINT_MAX");
}

void mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_5()
{
  __assert_rtn("mmcs_padded_chunk_length_with_policy_and_chunk_length", "mmcs_chunk.c", 429, "paddedChunkLength != 0");
}

void mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_6()
{
  __assert_rtn("mmcs_padded_chunk_length_with_policy_and_chunk_length", "mmcs_chunk.c", 430, "paddedChunkLength >= chunkLength");
}

void mmcs_chunk_instance_equal_cold_1()
{
}

void mmcs_chunk_instance_equal_cold_2()
{
}

void mmcs_chunk_instance_get_length_cold_1()
{
}

void MMCSItemReaderWriterGetCacheBlobWithName_cold_1()
{
}

void MMCSItemReaderWriterSetCacheBlobWithName_cold_1()
{
}

void MMCSItemReaderWriterWrite_cold_1()
{
}

void MMCSItemReaderWriterWrite_cold_2()
{
}

void MMCSItemReaderWriterWrite_cold_3()
{
}

void MMCSItemReaderWriterWrite_cold_4()
{
}

void MMCSItemReaderWriterWrite_cold_5()
{
  __assert_rtn("MMCSItemReaderWriterWrite", "mmcs_item_reader_writer.c", 489, "postCompleteBlockBytes == (bufferLength - preCompleteBlockBytes) % readWriteContext->sparseBlockSize");
}

void MMCSItemReaderWriterWrite_cold_6()
{
  __assert_rtn("MMCSItemReaderWriterWrite", "mmcs_item_reader_writer.c", 419, "readWriteContext->sparseBlockSize == (*sparseContextPtr)->blockSize");
}

void trackWriteBlocks_cold_1()
{
}

void trackWriteBlocks_cold_2()
{
  __assert_rtn("trackWriteBlocks", "mmcs_item_reader_writer.c", 373, "sparseBlockSize != MMCS_ITEM_READER_WRITER_SPARSE_AWARE_DISABLED_BLOCK_SIZE && \"readerWriter doesn't support sparse blocks\"");
}

void trackWriteBlocks_cold_3()
{
}

void trackWriteBlocks_cold_4()
{
}

void trackWriteBlocks_cold_5()
{
}

void MMCSItemReaderWriterSeek_cold_1()
{
}

void MMCSItemReaderWriterSeek_cold_2()
{
}

void MMCSItemReaderWriterSeek_cold_3()
{
  __assert_rtn("MMCSItemReaderWriterSeek", "mmcs_item_reader_writer.c", 562, "sparseContext->blockSize == sparseBlockSize");
}

void MMCSItemReaderWriterCreateWithFileDescriptor_cold_1()
{
}

void MMCSItemReaderWriterCreateWithFileDescriptor_cold_2()
{
}

void MMCSItemReaderWriterCreateWithFileDescriptor_cold_3()
{
}

void mmcs_nshttp_context_init_cold_1()
{
  __assert_rtn("mmcs_nshttp_context_init", "mmcs_nsurlsession_context.m", 76, "hc->httpClass == mmcs_http_class_nsurlsession");
}

void mmcs_nshttp_did_open_cold_1()
{
}

void mmcs_container_schedule_request_callback_cold_1()
{
  __assert_rtn("mmcs_container_schedule_request_callback", "mmcs_container.c", 259, "kMMCSRequestStateNone <= transaction->requestState && kMMCSRequestStateDone >= transaction->requestState");
}

void mmcs_container_xmitcallback_cold_1()
{
}

void mmcs_container_xmitcallback_cold_2()
{
}

void mmcs_container_xmitcallback_cold_3()
{
  __assert_rtn("mmcs_container_xmitcallback", "mmcs_container.c", 514, "transaction->httpContext == hc");
}

void mmcs_engine_detect_working_directory_attributes_cold_1()
{
}

void MMCSGetDefaultProtocolVersion_cold_1()
{
}

void handle_response_downloadChunks_cold_1()
{
}

void handle_response_downloadChunks_cold_2()
{
}

void handle_response_downloadChunks_cold_3()
{
}

void handle_response_downloadChunks_cold_4()
{
  __assert_rtn("handle_response_downloadChunks", "mmcs_get.c", 105, "transaction->httpContext == hc");
}

void send_request_downloadChunks_cold_1()
{
}

void send_request_downloadChunks_cold_2()
{
}

void send_request_downloadChunks_cold_3(const __CFAllocator *a1)
{
  v2 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v3 = CFStringCreateWithFormat(a1, 0, @"unable to find first item for authGetChunks");
    v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      OUTLINED_FUNCTION_0(&dword_1DC1CA000, v5, v6, "%{public}@", v7, v8, v9, v10, 2u);
    }
    if (v3) {
      CFRelease(v3);
    }
  }
}

void send_request_downloadChunks_cold_4(const __CFAllocator *a1)
{
  v2 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v3 = CFStringCreateWithFormat(a1, 0, @"unable to add token header");
    v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      OUTLINED_FUNCTION_0(&dword_1DC1CA000, v5, v6, "%{public}@", v7, v8, v9, v10, 2u);
    }
    if (v3) {
      CFRelease(v3);
    }
  }
  __assert_rtn("send_request_authorizeGetForChunks", "mmcs_get.c", 1204, "addedAuthTokenHeader");
}

void send_request_downloadChunks_cold_5()
{
}

void send_request_downloadChunks_cold_6()
{
}

void send_request_downloadChunks_cold_7()
{
}

void send_request_downloadChunks_cold_8()
{
}

void send_request_downloadChunks_cold_9()
{
}

void send_request_downloadChunks_cold_10()
{
}

void send_request_downloadChunks_cold_11()
{
}

void send_request_downloadChunks_cold_12()
{
}

void handle_callback_downloadContainer_cold_1()
{
}

void handle_callback_downloadContainer_cold_2()
{
}

void mmcs_get_items_cold_1()
{
}

void process_authorization_array_cold_1()
{
}

void process_authorization_array_cold_2()
{
}

void process_authorization_array_cold_3()
{
}

void _mmcs_item_setup_chunk_references_still_outstanding_cold_1()
{
}

void mmcs_get_req_process_another_file_groups_message_cold_1()
{
  __assert_rtn("mmcs_get_req_process_another_file_groups_message", "mmcs_get.c", 898, "\"already have a clone context\" && mmcs_get_req_get_opaque_clone_context(mrc) == NULL");
}

void mmcs_perform_getComplete_cold_1()
{
}

void mmcs_perform_getComplete_cold_2()
{
}

void mmcs_perform_getComplete_cold_3()
{
}

void mmcs_perform_getComplete_cold_4()
{
}

void mmcs_get_container_container_index_for_message_index_cold_1()
{
  __assert_rtn("mmcs_get_container_container_index_for_message_index", "mmcs_get_container.c", 207, "messageIndex >= 0 && messageIndex < (uint64_t)containerImpl->messageChunkInfoCount");
}

void mmcs_get_container_process_data_cold_1()
{
}

void mmcs_get_container_process_data_cold_2()
{
}

void mmcs_get_container_process_data_cold_3()
{
}

void mmcs_get_container_process_data_cold_4()
{
}

void mmcs_get_container_process_data_cold_5()
{
}

void mmcs_get_container_process_data_cold_6()
{
}

void HttpContextPerformBlockAsync_cold_1(void *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  [a1 isValid];
  [a1 isTaskDone];
  OUTLINED_FUNCTION_1();
  CFStringRef v3 = CFStringCreateWithFormat(v2, 0, @"HTTPContext %@ is %s and %s but is missing runloop or mode");
  v4 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
    OUTLINED_FUNCTION_0_0(&dword_1DC1CA000, v5, v6, "%{public}@", v7, v8, v9, v10, v11, v12, v13, v14, 2u);
  }
  if (v3) {
    CFRelease(v3);
  }
}

void mmcs_perform_dispatch_target_create_source_cold_1()
{
}

void mmcs_perform_dispatch_target_create_timer_cold_1()
{
}

void mmcs_get_file_process_chunk_instance_with_padding_cold_1()
{
}

void mmcs_get_file_unprocess_chunk_instance_cold_1()
{
}

void mmcs_get_file_candidate_completed_with_success_cold_1(uint64_t a1)
{
  CFAllocatorRef v2 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"outstanding chunk references is not empty! %@", *(void *)(*(void *)a1 + 280));
    v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      CFStringRef v6 = v3;
      _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v3) {
      CFRelease(v3);
    }
  }
  __assert_rtn("mmcs_get_file_candidate_completed_with_success", "mmcs_get_file.c", 462, "0 && \"get file completed successfully but still has outstanding chunk references\"");
}

void mmcs_get_file_candidate_completed_with_success_cold_2()
{
}

void mmcs_get_file_finalize_file_after_validation_cold_1()
{
}

void mmcs_get_file_ensure_temp_file_is_open_with_length_check_cold_1()
{
}

void mmcs_get_file_init_temp_file_cold_1()
{
}

void mmcs_get_file_init_temp_file_cold_2()
{
}

void mmcs_get_file_init_temp_file_cold_3()
{
}

void mmcs_get_file_compute_remaining_work_cold_1()
{
}

void mmcs_get_file_compute_remaining_work_cold_2()
{
}

void mmcs_get_file_compute_remaining_work_cold_3()
{
}

void mmcs_get_file_compute_remaining_work_cold_4()
{
  __assert_rtn("mmcs_get_file_notify_locally_fulfilled", "mmcs_get_file.c", 1319, "!cp || chunkInstance->satisfiedLocally ^ (CKRegisteredChunkLocation(cp) != 't')");
}

void mmcs_get_file_compute_remaining_work_cold_5()
{
  __assert_rtn("mmcs_get_file_notify_locally_fulfilled", "mmcs_get_file.c", 1310, "!cp || chunkCount == getFile->item->chunksPartOfItemInstanceCount");
}

void mmcs_get_file_compute_remaining_work_cold_6()
{
}

void mmcs_get_file_fulfill_locally_cold_1()
{
}

void mmcs_get_file_fulfill_locally_cold_2()
{
}

void mmcs_get_file_fulfill_locally_cold_3()
{
}

void mmcs_get_file_fulfill_locally_cold_4()
{
  __assert_rtn("mmcs_get_file_fulfill_locally", "mmcs_get_file.c", 1207, "chunkCount == getFile->item->chunksPartOfItemInstanceCount");
}

void mmcs_get_file_complete_metadata_only_file_cold_1()
{
}

void mmcs_get_file_notify_locally_fulfilled_chunk_reference_cold_1()
{
}

void mmcs_index_set_add_index_cold_1()
{
}

void mmcs_index_set_add_range_cold_1()
{
}

void mmcs_index_set_contains_index_cold_1()
{
}

void mmcs_index_set_contains_range_cold_1()
{
}

void mmcs_index_set_count_cold_1()
{
}

void mmcs_working_directory_file_path_cold_1()
{
}

void mmcs_working_directory_file_path_cold_2()
{
  __assert_rtn("mmcs_working_directory_file_path", "mmcs_get_req_context.c", 56, "directoryLength > 0 && directoryLength <= PATH_MAX && \"Error computing length of working directory path.\"");
}

void mmcs_get_req_create_cold_1()
{
}

void mmcs_proxy_locator_prime_cold_1()
{
}

void getLocateOptions_cold_1()
{
}

void mmcs_get_state_decrement_outstanding_chunk_references_count_cold_1()
{
}

void mmcs_get_state_decrement_outstanding_chunk_references_count_cold_2(uint64_t *a1, uint64_t a2)
{
  v4 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v13 = a2;
    uint64_t v14 = *a1;
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"couldn't find %@ in %@");
    CFStringRef v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      OUTLINED_FUNCTION_0_1(&dword_1DC1CA000, v7, v8, "%{public}@", v9, v10, v11, v12, v13, v14, 2u);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
  __assert_rtn("mmcs_get_state_decrement_outstanding_chunk_references_count", "mmcs_get_state.c", 314, "0 && \"chunk accounting lost a chunk somewhere\"");
}

void mmcs_get_state_decrement_outstanding_chunk_references_count_cold_3()
{
}

void mmcs_get_state_decrement_outstanding_chunk_references_count_cold_4()
{
}

void mmcs_get_state_decrement_outstanding_chunk_references_count_cold_5(uint64_t *a1, uint64_t a2)
{
  v4 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v13 = *a1;
    uint64_t v14 = a2;
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"chunk count %ld for %@ went out of whack");
    CFStringRef v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      OUTLINED_FUNCTION_0_1(&dword_1DC1CA000, v7, v8, "%{public}@", v9, v10, v11, v12, v13, v14, 2u);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
  __assert_rtn("mmcs_get_state_decrement_outstanding_chunk_references_count", "mmcs_get_state.c", 310, "0 && \"bad chunk count when decrementing\"");
}

void mmcs_get_state_all_outstanding_chunk_references_contains_chunk_cold_1()
{
}

void mmcs_get_state_process_file_list_cold_1()
{
}

void mmcs_get_state_process_file_list_cold_2()
{
}

void mmcs_get_state_process_file_list_cold_3()
{
}

void mmcs_get_state_process_file_list_cold_4()
{
}

void mmcs_get_state_process_file_list_cold_5()
{
}

void mmcs_get_state_process_file_list_cold_6()
{
}

void _associate_files_and_containers_for_items_cold_1()
{
}

void _associate_files_and_containers_for_items_cold_2()
{
}

void _associate_files_and_containers_for_items_cold_3()
{
}

void _associate_files_and_containers_for_items_cold_4()
{
}

void mmcs_get_state_setup_derivative_files_and_containers_cold_1()
{
}

void file_skip_container_and_get_chunks_cold_1()
{
}

void mmcs_network_request_options_for_options_cold_1()
{
}

void mmcs_http_context_copy_vendor_name_cold_1()
{
}

void mmcs_http_context_enqueued_time_cold_1()
{
}

void mmcs_http_context_allocate_cold_1()
{
}

void _mmcs_http_context_init_cold_1()
{
}

void mmcs_http_context_create_cold_1()
{
}

void mmcs_http_context_create_cold_2()
{
}

void mmcs_http_context_create_cold_3()
{
}

void mmcs_http_context_create_cold_4()
{
}

void mmcs_http_context_send_cold_1()
{
}

void mmcs_http_context_send_cold_2()
{
}

void mmcs_item_copy_chunk_instances_from_item_cold_1()
{
  __assert_rtn("mmcs_item_copy_chunk_instances_from_item", "mmcs_item.c", 586, "chunkInstanceOffset == sourceInstance->chunkInstanceOffset");
}

void mmcs_item_copy_chunk_instances_from_item_cold_2()
{
}

void mmcs_item_copy_chunk_instances_from_item_cold_3()
{
  __assert_rtn("mmcs_item_copy_chunk_instances_from_item", "mmcs_item.c", 580, "sourceInstance->item == sourceItem");
}

void mmcs_item_copy_chunk_instances_from_item_cold_4()
{
  __assert_rtn("mmcs_item_copy_chunk_instances_from_item", "mmcs_item.c", 573, "destItem->chunksInstanceCount == 0");
}

void mmcs_item_calculate_chunks_in_requested_range_cold_1()
{
}

void mmcs_item_calculate_chunks_in_requested_range_cold_2()
{
}

void mmcs_item_calculate_chunks_in_requested_range_cold_3()
{
}

void mmcs_item_get_start_chunk_index_for_inner_item_cold_1()
{
}

void mmcs_item_get_start_chunk_index_for_inner_item_cold_2()
{
}

void mmcs_item_get_start_chunk_index_for_inner_item_cold_3()
{
}

void mmcs_item_get_start_chunk_index_for_inner_item_cold_4()
{
  __assert_rtn("mmcs_item_get_start_chunk_index_for_inner_item", "mmcs_item.c", 612, "instance->item == sourceItem");
}

void mmcs_item_get_start_chunk_index_for_inner_item_cold_5()
{
}

void mmcs_item_copy_ford_state_from_item_cold_1()
{
  __assert_rtn("mmcs_item_copy_ford_state_from_item", "mmcs_item.c", 657, "innerItemChunkInstance->item == innerItem");
}

void mmcs_item_copy_ford_state_from_item_cold_2()
{
  __assert_rtn("mmcs_item_copy_ford_state_from_item", "mmcs_item.c", 654, "sourceItemChunkInstance->item == sourceItem");
}

void mmcs_item_copy_ford_state_from_item_cold_3()
{
}

void mmcs_item_copy_ford_state_from_item_cold_4()
{
}

void mmcs_item_setup_chunk_references_cold_1()
{
}

void mmcs_item_setup_item_size_cold_1()
{
}

void mmcs_item_setup_item_padded_size_cold_1()
{
}

void mmcs_item_padded_length_cold_1()
{
}

void mmcs_report_is_valid_base_url_for_mobile_me_cold_1()
{
}

void mmcs_report_is_valid_base_url_for_mobile_me_cold_2()
{
}

void mmcs_create_FileChunkLists_cold_1()
{
}

void mmcs_put_request_create_FileChunkLists_cold_1()
{
}

void mmcs_register_request_create_FileChunkLists_cold_1()
{
}

void mmcs_register_request_create_FileChunkLists_cold_2()
{
  __assert_rtn("mmcs_register_request_create_FileChunkLists", "mmcs_protobuf.c", 1874, "currentItem == itemsToUploadCount");
}

void mmcs_register_request_create_FileChunkLists_cold_3()
{
}

void mmcs_update_request_create_AuthorizePutRequestBody_cold_1()
{
}

void mmcs_update_request_create_AuthorizePutRequestBody_cold_2()
{
  __assert_rtn("mmcs_update_request_create_FileChunkLists", "mmcs_protobuf.c", 1960, "currentItem == itemsToUploadCount");
}

void mmcs_update_request_create_AuthorizePutRequestBody_cold_3()
{
}

void mmcs_create_put_complete_at_edge_payload_trailer_cold_1()
{
}

void handle_response_uploadChunks_cold_1()
{
}

void handle_response_uploadChunks_cold_2()
{
}

void handle_response_uploadChunks_cold_3()
{
}

void handle_response_uploadChunks_cold_4()
{
  __assert_rtn("handle_response_uploadChunks", "mmcs_put.c", 832, "transaction->httpContext == hc");
}

void handle_response_uploadChunks_cold_5()
{
  __assert_rtn("handle_response_uploadChunks_vendorResponse", "mmcs_put.c", 501, "transaction->httpContext == hc");
}

void handle_response_uploadChunks_cold_6()
{
  __assert_rtn("handle_response_uploadChunks", "mmcs_put.c", 728, "transaction->httpContext == hc");
}

void mmcs_request_has_items_not_done_cold_1()
{
}

void mmcs_request_get_dataclass_cold_1()
{
}

void mmcs_request_get_dataclass_cold_2()
{
}

void mmcs_request_get_request_activity_marker_cold_1()
{
}

void mmcs_request_get_chunking_activity_marker_cold_1()
{
}

void mmcs_request_get_timing_activity_marker_cold_1()
{
}

void mmcs_put_container_schedule_cold_1()
{
  __assert_rtn("mmcs_put_container_schedule", "mmcs_put_container.c", 294, "NULL == transaction->httpContext");
}

void mmcs_put_req_context_create_cold_1()
{
  __assert_rtn("mmcs_put_req_context_create", "mmcs_put_req_context.c", 261, "nitems == 1");
}

void mmcs_put_req_context_init_items_for_section_cold_1()
{
  __assert_rtn("mmcs_put_req_context_init_items_for_section", "mmcs_put_req_context.c", 434, "1 == mrc->requestConcrete.putState->mr_nitems");
}

void mmcs_put_req_context_init_item_with_chunks_cold_1()
{
}

void mmcs_put_section_req_is_using_itemid_cold_1()
{
  __assert_rtn("mmcs_put_section_req_is_using_itemid", "mmcs_put_req_context.c", 1001, "mrc->requestConcrete.putState->mr_nitems == 1");
}

void mmcs_put_req_context_did_chunk_item_cold_1()
{
  __assert_rtn("mmcs_put_req_context_did_chunk_item", "mmcs_put_req_context.c", 1416, "item->chunkingProfiles == NULL");
}

void mmcs_register_item_signature_equals_cold_1()
{
}

void mmcs_register_item_signature_equals_cold_2()
{
}

void mmcs_register_item_signature_hash_cold_1()
{
}

void mmcs_put_state_create_cold_1()
{
}

void mmcs_put_state_container_will_be_retried_cold_1()
{
}

void mmcs_put_state_create_MethocCompletionInfoList_cold_1()
{
}

void mmcs_put_state_create_MethocCompletionInfoList_cold_2()
{
}

void mmcs_put_state_create_MethocCompletionInfoList_cold_3()
{
}

void mmcs_put_state_create_MethocCompletionInfoList_cold_4()
{
}

void opaque__file_reference_data__get_packed_size_cold_1()
{
  __assert_rtn("opaque__file_reference_data__get_packed_size", "Opaque.pb-c.c", 79, "message->base.descriptor == &opaque__file_reference_data__descriptor");
}

void opaque__file_reference_data__pack_cold_1()
{
  __assert_rtn("opaque__file_reference_data__pack", "Opaque.pb-c.c", 86, "message->base.descriptor == &opaque__file_reference_data__descriptor");
}

void opaque__file_reference_data__free_unpacked_cold_1()
{
  __assert_rtn("opaque__file_reference_data__free_unpacked", "Opaque.pb-c.c", 112, "message->base.descriptor == &opaque__file_reference_data__descriptor");
}

void mmcs_storage_container_stream_reset_cold_1()
{
}

void mmcs_storage_container_stream_read_cold_1()
{
  __assert_rtn("mmcs_storage_container_stream_read_payload_trailer", "mmcs_storage_container_stream.c", 133, "stream->chunkIndex == stream->storageContainer->chunkInstanceCount");
}

void mmcs_storage_container_stream_read_cold_2()
{
  __assert_rtn("mmcs_storage_container_stream_read", "mmcs_storage_container_stream.c", 537, "stream->chunkIndex == stream->storageContainer->chunkInstanceCount");
}

void mmcs_storage_container_stream_read_cold_3()
{
  __assert_rtn("mmcs_storage_container_stream_read", "mmcs_storage_container_stream.c", 536, "stream->chunkOffset == 0");
}

void mmcs_storage_container_stream_read_cold_4()
{
}

void mmcs_storage_container_stream_read_cold_5()
{
}

void mmcs_storage_container_stream_read_cold_6()
{
}

void mmcs_storage_container_stream_read_cold_7()
{
}

void hextostrdup_cold_1()
{
}

void mmcs_get_BOOLean_from_cftype_using_description_cold_1()
{
}

void MMCSGetChunks_cold_1()
{
}

void mmcs_perform_run_loop_target_create_source_cold_1()
{
}

void mmcs_perform_run_loop_target_create_timer_cold_1()
{
}

void mmcs_get_file_sparse_context_create_cold_1()
{
}

void mmcs_get_file_sparse_context_contains_zero_filled_block_cold_1()
{
}

void mmcs_get_file_sparse_context_contains_zero_filled_block_cold_2()
{
}

void mmcs_get_file_sparse_context_contains_zero_filled_block_cold_3()
{
}

void mmcs_perform_target_async_cold_1()
{
}

void metricsinfo__get_timed_out_cold_1()
{
}

void metricsinfo__get_http_status_cold_1()
{
}

void metricsinfo__get_start_name_resolution_cold_1()
{
}

void metricsinfo__get_stop_name_resolution_cold_1()
{
}

void metricsinfo__get_bytes_written_cold_1()
{
}

void metricsinfo__get_response_size_cold_1()
{
}

void metricsinfo__get_bytes_read_cold_1()
{
}

void mmcs_runloop_reply_job_execute_cold_1()
{
}

void mmcs_get_request_should_error_on_preallocation_failure_cold_1()
{
  __assert_rtn("mmcs_get_request_should_error_on_preallocation_failure", "mmcs_get_request.c", 61, "getState != nil");
}

void mmcs_get_request_is_insufficient_disk_space_mode_cold_1()
{
  __assert_rtn("mmcs_get_request_is_insufficient_disk_space_mode", "mmcs_get_request.c", 67, "getState != nil");
}

void mmcs_get_request_get_failed_to_preallocate_cold_1()
{
  __assert_rtn("mmcs_get_request_get_failed_to_preallocate", "mmcs_get_request.c", 74, "getState != nil");
}

void mmcs_get_request_set_failed_to_preallocate_cold_1()
{
  __assert_rtn("mmcs_get_request_set_failed_to_preallocate", "mmcs_get_request.c", 81, "getState != nil");
}

void mmcs_file_job_validate_file_callback_cold_1()
{
}

void mmcs_file_job_validate_file_callback_cold_2()
{
}

void mmcs_file_job_validate_file_callback_cold_3()
{
}

void mmcs_update_request_abort_cold_1()
{
}

void mmcs_update_items_cold_1()
{
}

void mmcs_update_request_process_authorize_put_response_cold_1()
{
}

void mmcs_update_items_send_get_chunk_keys_cold_1()
{
}

void mmcs_update_request_process_put_file_success_and_error_cold_1()
{
}

void mmcs_update_request_process_put_file_success_and_error_cold_2()
{
}

void mmcs_update_request_process_put_file_success_and_error_cold_3()
{
}

void mmcs_update_request_cleanup_cold_1()
{
}

void _add_item_result_cold_1_0()
{
}

void _add_item_result_cold_2_0()
{
}

void _add_item_result_cold_3_0()
{
}

void handle_response_get_chunk_keys_cold_1()
{
}

void handle_response_get_chunk_keys_cold_2()
{
}

void handle_response_get_chunk_keys_cold_3()
{
}

void handle_response_get_chunk_keys_cold_4()
{
}

void handle_response_put_chunk_keys_cold_1()
{
}

void handle_response_put_chunk_keys_cold_2()
{
}

void _add_put_item_cold_1()
{
}

void _add_put_item_cold_2()
{
}

void _add_put_item_cold_3()
{
  __assert_rtn("_add_put_item", "mmcs_update_request.c", 635, "CFArrayGetCount(updateItem->chunkSignatures) > 0 && CFArrayGetCount(updateItem->chunkSignatures) == CFArrayGetCount(updateItem->chunkKeys)");
}

void handle_response_downloadGetDerivativeContainer_cold_1()
{
}

void handle_response_downloadGetDerivativeContainer_cold_2()
{
}

void handle_response_downloadGetDerivativeContainer_cold_3()
{
  __assert_rtn("handle_response_downloadGetDerivativeContainer", "mmcs_get_derivative_container.c", 468, "transaction->httpContext == hc");
}

void handle_callback_downloadDerivativeDataBuffer_cold_1()
{
}

void handle_callback_downloadDerivativeDataBuffer_cold_2()
{
}

void XCFStringCreateWithBytesNoCopy_cold_1()
{
  __assert_rtn("XCFStringCreateWithBytesNoCopy", "mmcs_CoreFoundationUtils.c", 22, "contentsDeallocator == kCFAllocatorMalloc || contentsDeallocator == kCFAllocatorNull");
}

void XCFDataCreateWithBytesNoCopy_cold_1()
{
  __assert_rtn("XCFDataCreateWithBytesNoCopy", "mmcs_CoreFoundationUtils.c", 44, "bytesDeallocator == kCFAllocatorMalloc || bytesDeallocator == kCFAllocatorNull");
}

void mmcs_http_request_copy_cold_1()
{
}

void mmcs_http_request_copy_cold_2()
{
}

void mmcs_request_queue_max_requests_inflight_for_request_type_cold_1()
{
}

void mmcs_request_queue_max_requests_inflight_for_request_type_cold_2()
{
}

void mmcs_request_queue_max_requests_inflight_for_request_type_cold_3()
{
}

void mmcs_request_queue_schedule_cold_1()
{
  __assert_rtn("_do_foreground_requests", "mmcs_request_queue.c", 670, "(0 != mmcs_request_queue_total_requests_inflight_for_behavior_type(queue, requestType)) && \"Per request throughput monitor must be satisfied if nothing is in-flight\"");
}

void mmcs_request_queue_estimate_bandwidth_measurement_calculate_bps_cold_1()
{
}

void mmcs_request_queue_entry_ensure_minimum_bytes_per_period_requirement_cold_1()
{
}

void mmcs_transaction_cancel_enqueued_cold_1()
{
  __assert_rtn("mmcs_transaction_cancel_enqueued", "mmcs_transaction.c", 100, "kMMCSRequestStateEnqueued == transaction->requestState");
}

void mmcs_transaction_cancel_not_enqueued_cold_1()
{
  __assert_rtn("mmcs_transaction_cancel_not_enqueued", "mmcs_transaction.c", 109, "kMMCSRequestStateEnqueued != transaction->requestState");
}

void metricsinfo__httpmetrics_info__free_unpacked_cold_1()
{
  __assert_rtn("metricsinfo__httpmetrics_info__free_unpacked", "Networking.pb-c.c", 52, "message->base.descriptor == &metricsinfo__httpmetrics_info__descriptor");
}

void metricsinfo__socket_info__free_unpacked_cold_1()
{
  __assert_rtn("metricsinfo__socket_info__free_unpacked", "Networking.pb-c.c", 97, "message->base.descriptor == &metricsinfo__socket_info__descriptor");
}

void mmcs_update_item_set_error_if_not_already_done_cold_1()
{
}

void mmcs_update_item_set_put_receipt_if_not_already_done_cold_1()
{
}

void mmcs_request_type_as_c_string_cold_1()
{
}

void mmcs_request_type_as_c_string_cold_2()
{
}

void mmcs_request_type_as_c_string_cold_3()
{
}

uint64_t ACSLocateCachingServer()
{
  return MEMORY[0x1F410ABD8]();
}

uint64_t ACSMightCurrentNetworkHaveCachingServer()
{
  return MEMORY[0x1F410ABE0]();
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x1F40C9718](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x1F40C9720](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1F40C9728](c, data, *(void *)&len);
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1F40C9730](data, *(void *)&len, md);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x1F40C9778](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x1F40C9780](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1F40C9788](c, data, *(void *)&len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D7160](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1F40D7170](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1F40D7178](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFIndex CFArrayGetLastIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D71D0](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

void CFBinaryHeapAddValue(CFBinaryHeapRef heap, const void *value)
{
}

CFBinaryHeapRef CFBinaryHeapCreate(CFAllocatorRef allocator, CFIndex capacity, const CFBinaryHeapCallBacks *callBacks, const CFBinaryHeapCompareContext *compareContext)
{
  return (CFBinaryHeapRef)MEMORY[0x1F40D7370](allocator, capacity, callBacks, compareContext);
}

CFIndex CFBinaryHeapGetCount(CFBinaryHeapRef heap)
{
  return MEMORY[0x1F40D7378](heap);
}

const void *__cdecl CFBinaryHeapGetMinimum(CFBinaryHeapRef heap)
{
  return (const void *)MEMORY[0x1F40D7388](heap);
}

void CFBinaryHeapRemoveMinimumValue(CFBinaryHeapRef heap)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1F40D7420]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1F40D7538](bundleID);
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1F40D75D0](bundle, key);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1F40D77A8](cf);
}

CFStringRef CFCopyTypeIDDescription(CFTypeID type_id)
{
  return (CFStringRef)MEMORY[0x1F40D77D0](type_id);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1F40D77F8](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7808](allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7810](allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1F40D7818](allocator, bytes, length, bytesDeallocator);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1F40D7858](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1F40D7860]();
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x1F40D78B0](allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateDateFormatFromTemplate(CFAllocatorRef allocator, CFStringRef tmplate, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringRef)MEMORY[0x1F40D78B8](allocator, tmplate, options, locale);
}

CFStringRef CFDateFormatterCreateStringWithAbsoluteTime(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFAbsoluteTime at)
{
  return (CFStringRef)MEMORY[0x1F40D78D8](allocator, formatter, at);
}

Boolean CFDateFormatterGetAbsoluteTimeFromString(CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep, CFAbsoluteTime *atp)
{
  return MEMORY[0x1F40D78E8](formatter, string, rangep, atp);
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
}

void CFDateFormatterSetProperty(CFDateFormatterRef formatter, CFStringRef key, CFTypeRef value)
{
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7990](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1F40D7A18](theDict, key, value);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1F40D7A80](err);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7A90](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1F40D7A98](allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1F40D7AA8](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x1F40D7AB8](err);
}

CFTypeID CFErrorGetTypeID(void)
{
  return MEMORY[0x1F40D7AC0]();
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFDictionaryRef CFHTTPMessageCopyAllHeaderFields(CFHTTPMessageRef message)
{
  return (CFDictionaryRef)MEMORY[0x1F40D5288](message);
}

CFDataRef CFHTTPMessageCopyBody(CFHTTPMessageRef message)
{
  return (CFDataRef)MEMORY[0x1F40D5290](message);
}

CFStringRef CFHTTPMessageCopyHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField)
{
  return (CFStringRef)MEMORY[0x1F40D5298](message, headerField);
}

CFStringRef CFHTTPMessageCopyRequestMethod(CFHTTPMessageRef request)
{
  return (CFStringRef)MEMORY[0x1F40D52A0](request);
}

CFURLRef CFHTTPMessageCopyRequestURL(CFHTTPMessageRef request)
{
  return (CFURLRef)MEMORY[0x1F40D52A8](request);
}

CFStringRef CFHTTPMessageCopyResponseStatusLine(CFHTTPMessageRef response)
{
  return (CFStringRef)MEMORY[0x1F40D52B0](response);
}

CFStringRef CFHTTPMessageCopyVersion(CFHTTPMessageRef message)
{
  return (CFStringRef)MEMORY[0x1F40D52C0](message);
}

CFHTTPMessageRef CFHTTPMessageCreateRequest(CFAllocatorRef alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion)
{
  return (CFHTTPMessageRef)MEMORY[0x1F40D52D8](alloc, requestMethod, url, httpVersion);
}

CFHTTPMessageRef CFHTTPMessageCreateResponse(CFAllocatorRef alloc, CFIndex statusCode, CFStringRef statusDescription, CFStringRef httpVersion)
{
  return (CFHTTPMessageRef)MEMORY[0x1F40D52E0](alloc, statusCode, statusDescription, httpVersion);
}

CFIndex CFHTTPMessageGetResponseStatusCode(CFHTTPMessageRef response)
{
  return MEMORY[0x1F40D52E8](response);
}

void CFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData)
{
}

void CFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef value)
{
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1F40D7BA0](cf);
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1F40D7BE0](allocator, localeIdentifier);
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x1F40D7D78](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFNumberFormatterRef CFNumberFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  return (CFNumberFormatterRef)MEMORY[0x1F40D7D98](allocator, locale, style);
}

CFNumberRef CFNumberFormatterCreateNumberFromString(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFOptionFlags options)
{
  return (CFNumberRef)MEMORY[0x1F40D7DA0](allocator, formatter, string, rangep, options);
}

CFStringRef CFNumberFormatterCreateStringWithNumber(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberRef number)
{
  return (CFStringRef)MEMORY[0x1F40D7DA8](allocator, formatter, number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x1F40D7E90](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7EA0](key, applicationID);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F50](allocator, data, options, format, error);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F58](allocator, stream, streamLength, options, format, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFTypeRef CFReadStreamCopyProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1F40D7FA0](stream, propertyName);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1F40D7FC0](alloc, fileURL);
}

CFTypeID CFReadStreamGetTypeID(void)
{
  return MEMORY[0x1F40D7FE8]();
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF8](stream);
}

void CFReadStreamScheduleWithRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
}

void CFReadStreamSetDispatchQueue(CFReadStreamRef stream, dispatch_queue_t q)
{
}

void CFReadStreamUnscheduleFromRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1F40D80B0]();
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
}

void CFRunLoopRun(void)
{
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x1F40D8140](allocator, order, context);
}

void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source)
{
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
}

void CFRunLoopStop(CFRunLoopRef rl)
{
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  return (CFRunLoopTimerRef)MEMORY[0x1F40D8180](allocator, flags, order, callout, context, fireDate, interval);
}

CFAbsoluteTime CFRunLoopTimerGetNextFireDate(CFRunLoopTimerRef timer)
{
  MEMORY[0x1F40D81A8](timer);
  return result;
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1F40D81F8](theSet, value);
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  return (CFSetRef)MEMORY[0x1F40D8200](allocator, values, numValues, callBacks);
}

CFSetRef CFSetCreateCopy(CFAllocatorRef allocator, CFSetRef theSet)
{
  return (CFSetRef)MEMORY[0x1F40D8208](allocator, theSet);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8210](allocator, capacity, callBacks);
}

CFMutableSetRef CFSetCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFSetRef theSet)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8218](allocator, capacity, theSet);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1F40D8220](theSet);
}

const void *__cdecl CFSetGetValue(CFSetRef theSet, const void *value)
{
  return (const void *)MEMORY[0x1F40D8238](theSet, value);
}

void CFSetRemoveAllValues(CFMutableSetRef theSet)
{
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8390](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1F40D83D0](alloc, theString, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8410](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8440](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  return (CFStringRef)MEMORY[0x1F40D8478](alloc, buffer);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1F40D8498](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x1F40D84C8](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84E0](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringFindWithOptionsAndLocale(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFLocaleRef locale, CFRange *result)
{
  return MEMORY[0x1F40D84E8](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, locale, result);
}

void CFStringFold(CFMutableStringRef theString, CFStringCompareFlags theFlags, CFLocaleRef theLocale)
{
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1F40D8528](theString, idx);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  MEMORY[0x1F40D8548](str);
  return result;
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1F40D8568](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8590](length, *(void *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1F40D8600](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1F40D8608](theString, suffix);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

void CFStringNormalize(CFMutableStringRef theString, CFStringNormalizationForm theForm)
{
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D8708](allocator, ti);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1F40D8758](anURL, pathStyle);
}

CFStringRef CFURLCopyHostName(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8768](anURL);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8770](url);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8790](anURL);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8798](url);
}

CFStringRef CFURLCopyQueryString(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1F40D87A0](anURL, charactersToLeaveEscaped);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87C0](anURL);
}

CFStringRef CFURLCopyStrictPath(CFURLRef anURL, Boolean *isAbsolute)
{
  return (CFStringRef)MEMORY[0x1F40D87C8](anURL, isAbsolute);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D87F8](allocator, url, pathComponent, isDirectory);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1F40D8878](allocator, originalString, charactersToLeaveEscaped);
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D8888](allocator, URLBytes, length, *(void *)&encoding, baseURL);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88C0](allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

SInt32 CFURLGetPortNumber(CFURLRef anURL)
{
  return MEMORY[0x1F40D8910](anURL);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8918](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1F40D8928]();
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1F40D8988](alloc);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1F40D89B0](alloc, uuid);
}

CFTypeID CFWriteStreamGetTypeID(void)
{
  return MEMORY[0x1F40D8AC8]();
}

void CFWriteStreamScheduleWithRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
}

void CFWriteStreamSetDispatchQueue(CFWriteStreamRef stream, dispatch_queue_t q)
{
}

void CFWriteStreamUnscheduleFromRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
}

uint64_t CK2CalculateFileSignatureWithFlags()
{
  return MEMORY[0x1F4111848]();
}

uint64_t CK2CalculateItemSignatureWithFlags()
{
  return MEMORY[0x1F4111850]();
}

uint64_t CKChunkCoderCreate()
{
  return MEMORY[0x1F4111858]();
}

uint64_t CKChunkCoderFinish()
{
  return MEMORY[0x1F4111860]();
}

uint64_t CKChunkCoderUpdate()
{
  return MEMORY[0x1F4111868]();
}

uint64_t CKChunkDigestArgumentsV1Create()
{
  return MEMORY[0x1F4111870]();
}

uint64_t CKChunkDigestArgumentsV2WithBoundaryKeyCreate()
{
  return MEMORY[0x1F4111878]();
}

uint64_t CKChunkDigestArgumentsV2WithChunkKeyCreate()
{
  return MEMORY[0x1F4111880]();
}

uint64_t CKChunkDigestResultsChunkSignature()
{
  return MEMORY[0x1F4111888]();
}

uint64_t CKChunkDigestResultsCreate()
{
  return MEMORY[0x1F4111890]();
}

uint64_t CKChunkSchemeAndEncryptionKeySize()
{
  return MEMORY[0x1F4111898]();
}

uint64_t CKChunkSchemeAndSignatureSize()
{
  return MEMORY[0x1F41118A0]();
}

uint64_t CKChunkSignatureGeneratorCreate()
{
  return MEMORY[0x1F41118A8]();
}

uint64_t CKChunkSignatureGeneratorFinish()
{
  return MEMORY[0x1F41118B0]();
}

uint64_t CKChunkSignatureGeneratorUpdate()
{
  return MEMORY[0x1F41118B8]();
}

uint64_t CKChunkSignaturesEqual()
{
  return MEMORY[0x1F41118C0]();
}

uint64_t CKChunkStoreCreate()
{
  return MEMORY[0x1F41118C8]();
}

uint64_t CKChunkStoreInvalidate()
{
  return MEMORY[0x1F41118D0]();
}

uint64_t CKChunkStoreSetTestFlags()
{
  return MEMORY[0x1F41118D8]();
}

uint64_t CKChunkStoreTestFlags()
{
  return MEMORY[0x1F41118E0]();
}

uint64_t CKCommitDatabaseTransactions()
{
  return MEMORY[0x1F41118E8]();
}

uint64_t CKConvertTemporaryChunks()
{
  return MEMORY[0x1F41118F0]();
}

uint64_t CKCreateRegisteredChunk()
{
  return MEMORY[0x1F41118F8]();
}

uint64_t CKCreateRegisteredChunkWithSubchunkBlob()
{
  return MEMORY[0x1F4111900]();
}

uint64_t CKDecryptData()
{
  return MEMORY[0x1F4111908]();
}

uint64_t CKEncryptData()
{
  return MEMORY[0x1F4111910]();
}

uint64_t CKFileDigestArgumentsV1WithFileCreate()
{
  return MEMORY[0x1F4111918]();
}

uint64_t CKFileDigestArgumentsV1WithPackageCreate()
{
  return MEMORY[0x1F4111920]();
}

uint64_t CKFileDigestArgumentsV2ForPackageWithBoundaryKeyCreate()
{
  return MEMORY[0x1F4111928]();
}

uint64_t CKFileDigestArgumentsV2ForPackageWithVerificationKeyCreate()
{
  return MEMORY[0x1F4111930]();
}

uint64_t CKFileDigestArgumentsV2WithBoundaryKeyCreate()
{
  return MEMORY[0x1F4111938]();
}

uint64_t CKFileDigestArgumentsV2WithFileKeyCreate()
{
  return MEMORY[0x1F4111940]();
}

uint64_t CKFileDigestResultsCreate()
{
  return MEMORY[0x1F4111948]();
}

uint64_t CKFileDigestResultsEqual()
{
  return MEMORY[0x1F4111950]();
}

uint64_t CKFileDigestResultsFileLength()
{
  return MEMORY[0x1F4111958]();
}

uint64_t CKFileDigestResultsFileSignature()
{
  return MEMORY[0x1F4111960]();
}

uint64_t CKFileDigestResultsFileVerificationKey()
{
  return MEMORY[0x1F4111968]();
}

uint64_t CKFileDigestResultsHasFileLength()
{
  return MEMORY[0x1F4111970]();
}

uint64_t CKFileSchemeAndSignatureCopyCString()
{
  return MEMORY[0x1F4111978]();
}

uint64_t CKFileSchemeAndSignatureSize()
{
  return MEMORY[0x1F4111980]();
}

uint64_t CKFileSignatureCopy()
{
  return MEMORY[0x1F4111988]();
}

uint64_t CKFileSignatureGeneratorCreate()
{
  return MEMORY[0x1F4111990]();
}

uint64_t CKFileSignatureGeneratorFinish()
{
  return MEMORY[0x1F4111998]();
}

uint64_t CKFileSignatureGeneratorUpdate()
{
  return MEMORY[0x1F41119A0]();
}

uint64_t CKFileSignaturesEqual()
{
  return MEMORY[0x1F41119B0]();
}

uint64_t CKGetCacheBlobFd()
{
  return MEMORY[0x1F41119B8]();
}

uint64_t CKGetRegisteredChunks()
{
  return MEMORY[0x1F41119C0]();
}

uint64_t CKGetRegisteredChunksForItemID()
{
  return MEMORY[0x1F41119C8]();
}

uint64_t CKGetRegisteredFileMetadata()
{
  return MEMORY[0x1F41119D0]();
}

uint64_t CKGetRegisteredItems()
{
  return MEMORY[0x1F41119D8]();
}

uint64_t CKProfileResultsConfigurationVersion()
{
  return MEMORY[0x1F41119E0]();
}

uint64_t CKProfileResultsIsDefault()
{
  return MEMORY[0x1F41119E8]();
}

uint64_t CKProfileResultsResolvedFileExtension()
{
  return MEMORY[0x1F41119F0]();
}

uint64_t CKProfileResultsType()
{
  return MEMORY[0x1F41119F8]();
}

uint64_t CKProfileTypeDescription()
{
  return MEMORY[0x1F4111A00]();
}

uint64_t CKRegisterChunk()
{
  return MEMORY[0x1F4111A08]();
}

uint64_t CKRegisterChunksForItem()
{
  return MEMORY[0x1F4111A10]();
}

uint64_t CKRegisterFile()
{
  return MEMORY[0x1F4111A18]();
}

uint64_t CKRegisterItemAndChunks()
{
  return MEMORY[0x1F4111A20]();
}

uint64_t CKRegisterTemporaryChunk()
{
  return MEMORY[0x1F4111A28]();
}

uint64_t CKRegisteredChunkIsEncrypted()
{
  return MEMORY[0x1F4111A30]();
}

uint64_t CKRegisteredChunkItemID()
{
  return MEMORY[0x1F4111A38]();
}

uint64_t CKRegisteredChunkKey()
{
  return MEMORY[0x1F4111A40]();
}

uint64_t CKRegisteredChunkLength()
{
  return MEMORY[0x1F4111A48]();
}

uint64_t CKRegisteredChunkLocation()
{
  return MEMORY[0x1F4111A50]();
}

uint64_t CKRegisteredChunkOffset()
{
  return MEMORY[0x1F4111A58]();
}

uint64_t CKRegisteredChunkRowID()
{
  return MEMORY[0x1F4111A60]();
}

uint64_t CKRegisteredChunkSetItemID()
{
  return MEMORY[0x1F4111A68]();
}

uint64_t CKRegisteredChunkSetLength()
{
  return MEMORY[0x1F4111A70]();
}

uint64_t CKRegisteredChunkSetLocation()
{
  return MEMORY[0x1F4111A78]();
}

uint64_t CKRegisteredChunkSetOffset()
{
  return MEMORY[0x1F4111A80]();
}

uint64_t CKRegisteredChunkSetRowID()
{
  return MEMORY[0x1F4111A88]();
}

uint64_t CKRegisteredChunkSignature()
{
  return MEMORY[0x1F4111A90]();
}

uint64_t CKRegisteredChunkSignatureCopyCString()
{
  return MEMORY[0x1F4111A98]();
}

uint64_t CKRegisteredChunkSize()
{
  return MEMORY[0x1F4111AA0]();
}

uint64_t CKRegisteredChunkSuccessorOffset()
{
  return MEMORY[0x1F4111AA8]();
}

uint64_t CKRegisteredItemCount()
{
  return MEMORY[0x1F4111AB0]();
}

uint64_t CKRegisteredSubchunkDigest()
{
  return MEMORY[0x1F4111AB8]();
}

uint64_t CKRelocateTemporaryChunk()
{
  return MEMORY[0x1F4111AC0]();
}

uint64_t CKSchemeAndEncryptionKeySize()
{
  return MEMORY[0x1F4111AC8]();
}

uint64_t CKSchemeAndSignatureSize()
{
  return MEMORY[0x1F4111AD0]();
}

uint64_t CKSetCacheBlobFd()
{
  return MEMORY[0x1F4111AD8]();
}

uint64_t CKStreamCoderCreate()
{
  return MEMORY[0x1F4111AE0]();
}

uint64_t CKStreamCoderFinish()
{
  return MEMORY[0x1F4111AE8]();
}

uint64_t CKStreamCoderUpdate()
{
  return MEMORY[0x1F4111AF0]();
}

uint64_t CKStreamKeyDerivation()
{
  return MEMORY[0x1F4111AF8]();
}

uint64_t CKSubchunkBlobSize()
{
  return MEMORY[0x1F4111B00]();
}

uint64_t CKUnregisterChunksForItem()
{
  return MEMORY[0x1F4111B08]();
}

uint64_t CKUnregisterFile()
{
  return MEMORY[0x1F4111B10]();
}

uint64_t CKUnregisterTemporaryChunks()
{
  return MEMORY[0x1F4111B18]();
}

uint64_t CKValidateSignature()
{
  return MEMORY[0x1F4111B20]();
}

uint64_t CacheDeleteCopyAvailableSpaceForVolume()
{
  return MEMORY[0x1F410DC98]();
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1F40E7280](aClass);
}

uint64_t PCSCopyUnwrappedKey()
{
  return MEMORY[0x1F4146E20]();
}

uint64_t PCSCopyWrappedKey()
{
  return MEMORY[0x1F4146E28]();
}

uint64_t PCSMMCSCopyDecryptedData()
{
  return MEMORY[0x1F41470E0]();
}

uint64_t PCSMMCSCopyEncryptedData()
{
  return MEMORY[0x1F41470E8]();
}

SecKeyRef SecKeyCreateWithData(CFDataRef keyData, CFDictionaryRef attributes, CFErrorRef *error)
{
  return (SecKeyRef)MEMORY[0x1F40F6F08](keyData, attributes, error);
}

Boolean SecKeyVerifySignature(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef signedData, CFDataRef signature, CFErrorRef *error)
{
  return MEMORY[0x1F40F6F80](key, algorithm, signedData, signature, error);
}

uint64_t SecPaddingCompute()
{
  return MEMORY[0x1F40F6F98]();
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return MEMORY[0x1F40F70F0](rnd, count, bytes);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

uint64_t _CFURLRequestSetAllowedProtocolTypes()
{
  return MEMORY[0x1F40D5758]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

double __exp10(double a1)
{
  MEMORY[0x1F40C9B90](a1);
  return result;
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1F40C9C28]();
}

uint64_t __memmove_chk()
{
  return MEMORY[0x1F40C9C30]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x1F40C9C38]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x1F40C9CD0]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1F40C9CD8]();
}

os_activity_t _os_activity_create(void *dso, const char *description, os_activity_t activity, os_activity_flag_t flags)
{
  return (os_activity_t)MEMORY[0x1F40C9F70](dso, description, activity, *(void *)&flags);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1F40CA210](a1, *(void *)&a2);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1F40CA440](a1, a2);
}

void bzero(void *a1, size_t a2)
{
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1F40CB400](a1);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1F40CB9C0](flags, block);
}

void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1F40CBA88]();
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBAC0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBD0](label, attr, target);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

void dispatch_source_merge_data(dispatch_source_t source, uintptr_t value)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1F40CC058](*(void *)&a1, *(void *)&a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1F40CC1F0](a1, a2);
}

void free(void *a1)
{
}

ssize_t fsgetpath(char *a1, size_t a2, fsid_t *a3, uint64_t a4)
{
  return MEMORY[0x1F40CC2B0](a1, a2, a3, a4);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

int fstatfs(int a1, statfs *a2)
{
  return MEMORY[0x1F40CC2D0](*(void *)&a1, a2);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1F40CC2F0](*(void *)&a1, a2);
}

int fts_close(FTS *a1)
{
  return MEMORY[0x1F40CC2F8](a1);
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  return (FTS *)MEMORY[0x1F40CC300](a1, *(void *)&a2, a3);
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  return (FTSENT *)MEMORY[0x1F40CC308](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x1F40CC360](a1, a2, a3, a4, *(void *)&a5);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1F40CC3B0](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

int getpwuid_r(uid_t a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x1F40CC4F0](*(void *)&a1, a2, a3, a4, a5);
}

uid_t getuid(void)
{
  return MEMORY[0x1F40CC570]();
}

char *__cdecl inet_ntoa(in_addr a1)
{
  return (char *)MEMORY[0x1F40CC670](*(void *)&a1.s_addr);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1F40CC700]();
}

long double log10(long double __x)
{
  MEMORY[0x1F40CC880](__x);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1F40CC8F8](*(void *)&a1, a2, *(void *)&a3);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

int mkpath_np(const char *path, mode_t omode)
{
  return MEMORY[0x1F40CCE00](path, omode);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_enumerationMutation(id obj)
{
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1F4181748](self, _cmd, offset, atomic);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1F41818B8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1F41818D0](a1);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1F4181A28](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1F4181A30](obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181A40](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1F40CD120](a1);
}

void os_activity_scope_enter(os_activity_t activity, os_activity_scope_state_t state)
{
}

void os_activity_scope_leave(os_activity_scope_state_t state)
{
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

void os_release(void *object)
{
}

void *__cdecl os_retain(void *object)
{
  return (void *)MEMORY[0x1F40CD548](object);
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1F40CD5A0]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CD830](*(void *)&__fd, __buf, __nbyte, a4);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1F40CD9B8](a1, a2, a3, a4);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA78](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1F40CDA80](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA88](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA98](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1F40CDAC8](a1, a2);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CDBC0](*(void *)&__fd, __buf, __nbyte, a4);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1F40CDC60](a1);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x1F40CDC70](a1, a2, a3);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  return MEMORY[0x1F40CDF60](__name, __value, *(void *)&__overwrite);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x1F40CE118](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1F40CE188](*(void *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1F8](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1F40CE208](__s1, __n);
}

uint64_t sysconf(int a1)
{
  return MEMORY[0x1F40CE3B8](*(void *)&a1);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1F40CE3C0](a1, *(void *)&a2, a3, a4, a5, a6);
}

void syslog(int a1, const char *a2, ...)
{
}

int unlink(const char *a1)
{
  return MEMORY[0x1F40CE5E0](a1);
}

uint64_t voucher_adopt()
{
  return MEMORY[0x1F40CE708]();
}

uint64_t voucher_copy()
{
  return MEMORY[0x1F40CE710]();
}