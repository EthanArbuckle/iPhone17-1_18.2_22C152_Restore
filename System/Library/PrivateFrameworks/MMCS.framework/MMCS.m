void MMCSOperationMetricCombineMetrics(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  id v26;
  void *v27;
  void *v28;
  void *v29;
  id v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t j;
  id v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t k;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  id v43;
  id v44;
  uint64_t v45;
  id v46;
  id v47;
  id v48;
  id v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  long long v59;
  long long v60;
  long long v61;
  long long v62;
  long long v63;
  long long v64;
  long long v65;
  long long v66;
  long long v67;
  long long v68;
  long long v69;
  long long v70;
  unsigned char v71[128];
  unsigned char v72[128];
  unsigned char v73[128];
  uint64_t v74;

  v74 = *MEMORY[0x1E4F143B8];
  v44 = a1;
  v43 = a2;
  v50 = (void *)[v43 mutableCopy];
  v3 = (id)[v50 sortedArrayUsingSelector:sel_compareStartTime_];
  v49 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  v48 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  v47 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  v46 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  v4 = [MEMORY[0x1E4F1CA48] array];
  v5 = [MEMORY[0x1E4F1CA48] array];
  v45 = [v50 count];
  if (v45)
  {
    v6 = 0;
    v53 = 0;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    v57 = 0;
    v58 = 0;
    do
    {
      v52 = v6;
      v7 = objc_msgSend(v50, "objectAtIndexedSubscript:");
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v8 = [v7 rangesCopy];
      v9 = [v8 countByEnumeratingWithState:&v67 objects:v73 count:16];
      if (v9)
      {
        v10 = *(void *)v68;
        do
        {
          for (i = 0; i != v9; ++i)
          {
            if (*(void *)v68 != v10) {
              objc_enumerationMutation(v8);
            }
            v12 = *(void **)(*((void *)&v67 + 1) + 8 * i);
            v13 = [v12 operationState];
            v14 = v4;
            if (v13 != 1)
            {
              v15 = [v12 operationState];
              v14 = v5;
              if (v15) {
                continue;
              }
            }
            [v14 addObject:v12];
          }
          v9 = [v8 countByEnumeratingWithState:&v67 objects:v73 count:16];
        }
        while (v9);
      }

      v51 = [v7 bytesUploaded];
      v16 = [v7 bytesDownloaded];
      v17 = [v7 connections];
      v18 = [v7 connectionsCreated];
      v19 = [v7 bytesFulfilledLocally];
      v20 = [v7 bytesResumed];
      v21 = [v7 totalBytesByChunkProfile];
      mmcs_operation_metric_add_uint64_dictionary(v49, v21);

      v22 = [v7 chunkCountByChunkProfile];
      mmcs_operation_metric_add_uint64_dictionary(v48, v22);

      v23 = [v7 fileCountByChunkProfile];
      mmcs_operation_metric_add_uint64_dictionary(v47, v23);

      v24 = [v7 requestUUIDs];
      v25 = [v24 allObjects];
      [v46 addObjectsFromArray:v25];

      v58 += v51;
      v56 += v16;
      v57 += v17;
      v54 += v18;
      v55 += v19;
      v53 += v20;
      v6 = v52 + 1;
    }
    while (v52 + 1 != v45);
  }
  else
  {
    v57 = 0;
    v58 = 0;
    v55 = 0;
    v56 = 0;
    v53 = 0;
    v54 = 0;
  }
  v26 = v44;
  objc_sync_enter(v26);
  v27 = MMCSOperationStateTimeRangeMergedRanges(v26, v4);

  v28 = MMCSOperationStateTimeRangeMergedRanges(v26, v5);

  v29 = MMCSOperationStateTimeRangeFilteredRanges(v26, v28, v27);

  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v30 = v27;
  v31 = [v30 countByEnumeratingWithState:&v63 objects:v72 count:16];
  if (v31)
  {
    v32 = *(void *)v64;
    do
    {
      for (j = 0; j != v31; ++j)
      {
        if (*(void *)v64 != v32) {
          objc_enumerationMutation(v30);
        }
        [v26 addRange:*(void *)(*((void *)&v63 + 1) + 8 * j)];
      }
      v31 = [v30 countByEnumeratingWithState:&v63 objects:v72 count:16];
    }
    while (v31);
  }

  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v34 = v29;
  v35 = [v34 countByEnumeratingWithState:&v59 objects:v71 count:16];
  if (v35)
  {
    v36 = *(void *)v60;
    do
    {
      for (k = 0; k != v35; ++k)
      {
        if (*(void *)v60 != v36) {
          objc_enumerationMutation(v34);
        }
        [v26 addRange:*(void *)(*((void *)&v59 + 1) + 8 * k)];
      }
      v35 = [v34 countByEnumeratingWithState:&v59 objects:v71 count:16];
    }
    while (v35);
  }

  objc_msgSend(v26, "setBytesUploaded:", objc_msgSend(v26, "bytesUploaded") + v58);
  objc_msgSend(v26, "setBytesDownloaded:", objc_msgSend(v26, "bytesDownloaded") + v56);
  objc_msgSend(v26, "setConnections:", objc_msgSend(v26, "connections") + v57);
  objc_msgSend(v26, "setConnectionsCreated:", objc_msgSend(v26, "connectionsCreated") + v54);
  objc_msgSend(v26, "setBytesFulfilledLocally:", objc_msgSend(v26, "bytesFulfilledLocally") + v55);
  objc_msgSend(v26, "setBytesResumed:", objc_msgSend(v26, "bytesResumed") + v53);
  v38 = [v26 totalBytesByChunkProfile];
  mmcs_operation_metric_add_uint64_dictionary(v38, v49);

  v39 = [v26 chunkCountByChunkProfile];
  mmcs_operation_metric_add_uint64_dictionary(v39, v48);

  v40 = [v26 fileCountByChunkProfile];
  mmcs_operation_metric_add_uint64_dictionary(v40, v47);

  v41 = [v26 requestUUIDs];
  v42 = [v46 allObjects];
  [v41 addObjectsFromArray:v42];

  objc_sync_exit(v26);
}

void sub_1DC1CB980(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void mmcs_operation_metric_add_uint64_dictionary(void *a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  v5 = objc_msgSend(v4, "allKeys", 0);
  uint64_t v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v14;
    do
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v14 != v8) {
          objc_enumerationMutation(v5);
        }
        v10 = *(void **)(*((void *)&v13 + 1) + 8 * i);
        v11 = [v4 objectForKeyedSubscript:v10];
        v12 = v11;
        if (v11) {
          mmcs_operation_metric_increment_uint64_dictionary_key(v3, v10, [v11 unsignedLongLongValue]);
        }
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v7);
  }
}

id MMCSOperationStateTimeRangeFilteredRanges(void *a1, void *a2, void *a3)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  id v54 = a1;
  id v5 = a2;
  id v6 = a3;
  [v5 sortUsingSelector:sel_compareStartTime_];
  if (MMCSOperationStateTimeRangeHasOverlappingOperationsInArraySortedByStartTime(v5)) {
    MMCSOperationStateTimeRangeFilteredRanges_cold_1();
  }
  [v6 sortUsingSelector:sel_compareStartTime_];
  if (MMCSOperationStateTimeRangeHasOverlappingOperationsInArraySortedByStartTime(v6)) {
    MMCSOperationStateTimeRangeFilteredRanges_cold_2();
  }
  id v53 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v7 = [v6 count];
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  id obj = v5;
  uint64_t v51 = [obj countByEnumeratingWithState:&v55 objects:v59 count:16];
  if (v51)
  {
    unint64_t v8 = 0;
    uint64_t v50 = *(void *)v56;
    do
    {
      uint64_t v9 = 0;
      do
      {
        if (*(void *)v56 != v50) {
          objc_enumerationMutation(obj);
        }
        uint64_t v52 = v9;
        id v10 = *(id *)(*((void *)&v55 + 1) + 8 * v9);
        while (v8 < v7)
        {
          v11 = [v6 objectAtIndexedSubscript:v8];
          uint64_t v12 = [v11 compareStartTime:v10];
          uint64_t v13 = [v11 compareStopTime:v10];
          [v11 absoluteStop];
          double v15 = v14;
          [v10 absoluteStart];
          double v17 = v16;
          [v11 absoluteStart];
          double v19 = v18;
          [v10 absoluteStop];
          if (v12 == 1)
          {
            if (v13 != -1)
            {
              if (v19 >= v20)
              {
                [v53 addObject:v10];
              }
              else
              {
                uint64_t v41 = [v10 operationState];
                v42 = (void *)MEMORY[0x1E4F1C9C8];
                [v10 absoluteStart];
                v43 = objc_msgSend(v42, "dateWithTimeIntervalSinceReferenceDate:");
                [v11 absoluteStart];
                double v45 = v44;
                [v10 absoluteStart];
                v47 = (void *)[v54 newRangeWithOperationState:v41 startDate:v43 duration:v45 - v46];

                [v53 addObject:v47];
              }
LABEL_22:

              break;
            }
            uint64_t v21 = [v10 operationState];
            v22 = (void *)MEMORY[0x1E4F1C9C8];
            [v10 absoluteStart];
            v23 = objc_msgSend(v22, "dateWithTimeIntervalSinceReferenceDate:");
            [v11 absoluteStart];
            double v25 = v24;
            [v10 absoluteStart];
            v27 = (void *)[v54 newRangeWithOperationState:v21 startDate:v23 duration:v25 - v26];

            [v53 addObject:v27];
            uint64_t v28 = [v10 operationState];
            v29 = (void *)MEMORY[0x1E4F1C9C8];
            [v11 absoluteStart];
            v30 = objc_msgSend(v29, "dateWithTimeIntervalSinceReferenceDate:");
            [v10 absoluteStop];
            double v32 = v31;
            [v11 absoluteStart];
            uint64_t v34 = [v54 newRangeWithOperationState:v28 startDate:v30 duration:v32 - v33];

            goto LABEL_16;
          }
          if (v13 != -1) {
            goto LABEL_22;
          }
          if (v15 > v17)
          {
            uint64_t v35 = [v10 operationState];
            v36 = (void *)MEMORY[0x1E4F1C9C8];
            [v11 absoluteStop];
            v37 = objc_msgSend(v36, "dateWithTimeIntervalSinceReferenceDate:");
            [v10 absoluteStop];
            double v39 = v38;
            [v11 absoluteStop];
            uint64_t v34 = [v54 newRangeWithOperationState:v35 startDate:v37 duration:v39 - v40];

            ++v8;
LABEL_16:
            id v10 = (id)v34;
            goto LABEL_18;
          }
          ++v8;
LABEL_18:
        }
        if (v8 >= v7) {
          [v53 addObject:v10];
        }

        ++v9;
      }
      while (v52 + 1 != v51);
      uint64_t v51 = [obj countByEnumeratingWithState:&v55 objects:v59 count:16];
    }
    while (v51);
  }

  return v53;
}

id MMCSOperationStateTimeRangeMergedRanges(void *a1, void *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = [MEMORY[0x1E4F1CA48] array];
  if (v3 && v4)
  {
    [v4 sortUsingSelector:sel_compareStartTime_];
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    id v6 = v4;
    uint64_t v7 = [v6 countByEnumeratingWithState:&v30 objects:v34 count:16];
    if (v7)
    {
      uint64_t v8 = v7;
      id v29 = v4;
      id v9 = 0;
      uint64_t v10 = *(void *)v31;
      double v11 = 0.0;
      do
      {
        for (uint64_t i = 0; i != v8; ++i)
        {
          if (*(void *)v31 != v10) {
            objc_enumerationMutation(v6);
          }
          uint64_t v13 = *(void **)(*((void *)&v30 + 1) + 8 * i);
          if (v9)
          {
            [*(id *)(*((void *)&v30 + 1) + 8 * i) absoluteStart];
            if (v14 <= v11)
            {
              [v13 absoluteStop];
              if (v11 < v23) {
                double v11 = v23;
              }
            }
            else
            {
              uint64_t v15 = [v9 operationState];
              double v16 = (void *)MEMORY[0x1E4F1C9C8];
              [v9 absoluteStart];
              double v17 = objc_msgSend(v16, "dateWithTimeIntervalSinceReferenceDate:");
              [v9 absoluteStart];
              double v19 = (void *)[v3 newRangeWithOperationState:v15 startDate:v17 duration:v11 - v18];
              [v5 addObject:v19];

              id v20 = v13;
              [v20 absoluteStop];
              double v11 = v21;
              id v9 = v20;
            }
          }
          else
          {
            id v9 = v13;
            [v9 absoluteStop];
            double v11 = v22;
          }
        }
        uint64_t v8 = [v6 countByEnumeratingWithState:&v30 objects:v34 count:16];
      }
      while (v8);

      if (!v9)
      {
        id v4 = v29;
        goto LABEL_21;
      }
      uint64_t v24 = [v9 operationState];
      double v25 = (void *)MEMORY[0x1E4F1C9C8];
      [v9 absoluteStart];
      objc_msgSend(v25, "dateWithTimeIntervalSinceReferenceDate:");
      id v6 = (id)objc_claimAutoreleasedReturnValue();
      [v9 absoluteStart];
      v27 = (void *)[v3 newRangeWithOperationState:v24 startDate:v6 duration:v11 - v26];
      [v5 addObject:v27];

      id v4 = v29;
    }
    else
    {
      id v9 = 0;
    }

LABEL_21:
  }

  return v5;
}

BOOL MMCSOperationStateTimeRangeHasOverlappingOperationsInArraySortedByStartTime(void *a1)
{
  id v1 = a1;
  unint64_t v2 = [v1 count];
  if (v2 >= 2)
  {
    unint64_t v4 = v2;
    unint64_t v5 = 2;
    do
    {
      id v6 = [v1 objectAtIndexedSubscript:v5 - 2];
      uint64_t v7 = [v1 objectAtIndexedSubscript:v5 - 1];
      [v6 absoluteStop];
      double v9 = v8;
      [v7 absoluteStart];
      double v11 = v10;
      BOOL v3 = v9 > v10;

      if (v5 >= v4) {
        break;
      }
      ++v5;
    }
    while (v9 <= v11);
  }
  else
  {
    BOOL v3 = 0;
  }

  return v3;
}

uint64_t MMCSICloudAuthGetRequestOptions()
{
  if (MMCSICloudAuthGetRequestOptions_onceToken != -1) {
    dispatch_once_f(&MMCSICloudAuthGetRequestOptions_onceToken, 0, (dispatch_function_t)mmcs_proxy_locator_prime);
  }
  return 2 * (mmcs_proxy_locator_exists() != 0);
}

void __mmcs_proxy_locator_exists_block_invoke(uint64_t a1, char a2, CFErrorRef err)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  if (!err) {
    goto LABEL_13;
  }
  CFErrorDomain Domain = CFErrorGetDomain(err);
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E4F1D160]) && CFErrorGetCode(err) == 60)
  {
    id v6 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_13;
    }
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"might have caching server returned with error: %@", err);
    double v8 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 138543362;
    CFStringRef v14 = v7;
    double v9 = v8;
    os_log_type_t v10 = OS_LOG_TYPE_DEBUG;
  }
  else
  {
    double v11 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_13;
    }
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"might have caching server returned with error: %@", err);
    uint64_t v12 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 138543362;
    CFStringRef v14 = v7;
    double v9 = v12;
    os_log_type_t v10 = OS_LOG_TYPE_ERROR;
  }
  _os_log_impl(&dword_1DC1CA000, v9, v10, "%{public}@", buf, 0xCu);
LABEL_11:
  if (v7) {
    CFRelease(v7);
  }
LABEL_13:
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

uint64_t mmcs_proxy_locator_exists()
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 0;
  v0 = dispatch_semaphore_create(0);
  dispatch_retain(v0);
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef Options = (const __CFDictionary *)getLocateOptions();
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v1, 0, Options);
  uint64_t v10 = MEMORY[0x1E4F143A8];
  ACSMightCurrentNetworkHaveCachingServer();
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  dispatch_time_t v4 = dispatch_time(0, 1000000000);
  if (dispatch_semaphore_wait(v0, v4))
  {
    unint64_t v5 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v6 = CFStringCreateWithFormat(v1, 0, @"ACSMightCurrentNetworkHaveCachingServer took too long (more than 1 second)", v10, 0x40000000, __mmcs_proxy_locator_exists_block_invoke, &unk_1E6C33E50, &v11, v0);
      CFStringRef v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        CFStringRef v16 = v6;
        _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v6) {
        CFRelease(v6);
      }
    }
  }
  dispatch_release(v0);
  uint64_t v8 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  return v8;
}

__CFDictionary *MMCSICloudRequestHeadersCopy(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  mmcs_library_init();
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFStringRef client_header_value = mmcs_engine_create_client_header_value(a1);
    CFDictionaryAddValue(Mutable, @"x-mme-client-info", client_header_value);
    if (client_header_value) {
      CFRelease(client_header_value);
    }
    unint64_t v5 = (const void *)MMCSGetDefaultProtocolVersion();
    CFDictionaryAddValue(Mutable, @"x-apple-mmcs-proto-version", v5);
    CFBooleanRef cfBOOLean_from_cfpreferences_object_for_key = (const __CFBoolean *)mmcs_get_cfBOOLean_from_cfpreferences_object_for_key(@"UseEdge", 0);
    if (cfBOOLean_from_cfpreferences_object_for_key)
    {
      if (CFBooleanGetValue(cfBOOLean_from_cfpreferences_object_for_key)) {
        CFStringRef v7 = @"true";
      }
      else {
        CFStringRef v7 = @"false";
      }
      CFDictionaryAddValue(Mutable, @"x-apple-use-edge", v7);
    }
    CFBooleanRef v8 = (const __CFBoolean *)mmcs_get_cfBOOLean_from_cfpreferences_object_for_key(@"UseVendorIp", 0);
    if (v8)
    {
      if (CFBooleanGetValue(v8)) {
        double v9 = @"true";
      }
      else {
        double v9 = @"false";
      }
      CFDictionaryAddValue(Mutable, @"x-apple-use-vendor-ip", v9);
    }
    mmcs_report_initialize();
    CFTypeRef cf = 0;
    *(void *)value = 0;
    mmcs_report_copy_plist_header_values(value, &cf);
    if (*(void *)value)
    {
      CFDictionaryAddValue(Mutable, @"x-apple-mmcs-plist-version", *(const void **)value);
      if (*(void *)value) {
        CFRelease(*(CFTypeRef *)value);
      }
      *(void *)value = 0;
    }
    if (cf)
    {
      CFDictionaryAddValue(Mutable, @"x-apple-mmcs-plist-sha256", cf);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = 0;
    }
    mmcs_report_close();
  }
  else
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v11 = CFStringCreateWithFormat(v2, 0, @"Unable to allocate iCloudRequestHeaders");
      uint64_t v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)value = 138543362;
        *(void *)&value[4] = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "%{public}@", value, 0xCu);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
  }
  return Mutable;
}

CFStringRef mmcs_get_cfBOOLean_from_cfpreferences_object_for_key(const __CFString *a1, const __CFString *cfBOOLean_from_cftype_using_description)
{
  if (a1)
  {
    CFStringRef v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, @"com.apple.mmcs");
    if (v4)
    {
      CFStringRef v5 = v4;
      cfBOOLean_from_cftype_using_description = mmcs_get_cfBOOLean_from_cftype_using_description((uint64_t)a1, v4, (uint64_t)cfBOOLean_from_cftype_using_description);
      CFRelease(v5);
    }
  }
  return cfBOOLean_from_cftype_using_description;
}

uint64_t mmcs_report_initialize()
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  pthread_mutex_lock(&sReportingInfoInitLock);
  uint64_t v0 = gMMCS_MobileMeReporting;
  if (gMMCS_MobileMeReporting)
  {
LABEL_52:
    ++*(void *)(v0 + 24);
    return pthread_mutex_unlock(&sReportingInfoInitLock);
  }
  CFAllocatorRef v1 = malloc_type_malloc(0x48uLL, 0x1060040BBC8ADA9uLL);
  gMMCS_MobileMeReporting = (uint64_t)v1;
  if (v1)
  {
    _OWORD *v1 = 0u;
    v1[1] = 0u;
    v1[2] = xmmword_1DC251DF0;
    v1[3] = 0u;
    *((unsigned char *)v1 + 64) = 0;
    CFAbsoluteTime Current = 0.0;
    CFAbsoluteTime v40 = 0.0;
    uint64_t v38 = 0;
    CFPreferencesAppSynchronize(@"com.apple.mmcs");
    _getAbsoluteTimeFromPreferences(@"report.LastSuccessfulCheckTime", @"com.apple.mmcs", &v40);
    _getAbsoluteTimeFromPreferences(@"report.LastFailedCheckTime", @"com.apple.mmcs", &Current);
    if (_getAbsoluteTimeFromPreferences(@"report.TTL", @"com.apple.mmcs", (double *)&v38)) {
      *(void *)(gMMCS_MobileMeReporting + 40) = v38;
    }
    CFAllocatorRef v2 = (__CFDictionary *)CFPreferencesCopyAppValue(@"report.ReportLevels", @"com.apple.mmcs");
    BOOL v3 = v2;
    if (v2)
    {
      CFTypeID v4 = CFGetTypeID(v2);
      if (v4 == CFDictionaryGetTypeID())
      {
        CFStringRef v5 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          CFMutableDictionaryRef Mutable = v3;
LABEL_44:
          CFPropertyListRef v35 = CFPreferencesCopyAppValue(@"report.sha256", @"com.apple.mmcs");
          v36 = v35;
          if (v35)
          {
            CFTypeID v37 = CFGetTypeID(v35);
            if (v37 != CFStringGetTypeID())
            {
              CFRelease(v36);
              v36 = 0;
            }
          }
          _mmcs_report_setReportingInfo(0, v36, Mutable, 0, 0, v40, Current);
          if (v36) {
            CFRelease(v36);
          }
          if (Mutable) {
            CFRelease(Mutable);
          }
          uint64_t v0 = gMMCS_MobileMeReporting;
          goto LABEL_52;
        }
        CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Using MobileMe reporting levels from Preferences.");
        CFStringRef v7 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138543362;
          *(void *)&uint8_t buf[4] = v6;
          _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        CFMutableDictionaryRef Mutable = v3;
        if (!v6) {
          goto LABEL_44;
        }
LABEL_42:
        CFRelease(v6);
        goto LABEL_44;
      }
    }
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      *(void *)buf = 0x2000000;
      CFNumberRef v10 = CFNumberCreate(v9, kCFNumberSInt64Type, buf);
      if (v10)
      {
        CFNumberRef v11 = v10;
        CFDictionarySetValue(Mutable, @"chunker.max.fixed.length", v10);
        CFRelease(v11);
      }
      *(_DWORD *)buf = 2;
      CFNumberRef v12 = CFNumberCreate(v9, kCFNumberSInt32Type, buf);
      if (v12)
      {
        CFNumberRef v13 = v12;
        CFDictionarySetValue(Mutable, @"max.vendor.upload.connections.override", v12);
        CFRelease(v13);
      }
      *(_DWORD *)buf = 20;
      CFNumberRef v14 = CFNumberCreate(v9, kCFNumberSInt64Type, buf);
      if (v14)
      {
        CFNumberRef v15 = v14;
        CFDictionarySetValue(Mutable, @"max.vendor.download.connections.override", v14);
        CFRelease(v15);
      }
      CFDictionarySetValue(Mutable, @"auth.simulcast.response.signing.key.public.current", @"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEAocv/GNpYVOMkps9l8bGHZH8JvMEFQavMbuRpHNch+VpT7abwkns3kA7SnvG6Lv37ko5OkTLJc5ZmtO7fkbonw==");
      uint64_t v16 = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v16)
      {
        uint64_t v17 = v16;
        double v18 = (const void *)*MEMORY[0x1E4F1CFD0];
        CFDictionarySetValue(v16, @"vendor.url", (const void *)*MEMORY[0x1E4F1CFD0]);
        CFDictionarySetValue(v17, @"vendor.response.code", v18);
        CFDictionarySetValue(v17, @"client.error.on.failure", v18);
        CFDictionarySetValue(v17, @"status.line.on.failure", v18);
        double v19 = CFArrayCreateMutable(v9, 0, MEMORY[0x1E4F1D510]);
        if (v19)
        {
          id v20 = v19;
          CFArrayAppendValue(v19, @"*");
          CFDictionarySetValue(v17, @"vendor.headers.on.success", v20);
          CFRelease(v20);
        }
        double v21 = CFArrayCreateMutable(v9, 0, MEMORY[0x1E4F1D510]);
        if (v21)
        {
          double v22 = v21;
          CFArrayAppendValue(v21, @"*");
          CFDictionarySetValue(v17, @"vendor.headers.on.failure", v22);
          CFRelease(v22);
        }
        double v23 = CFArrayCreateMutable(v9, 0, MEMORY[0x1E4F1D510]);
        if (v23)
        {
          uint64_t v24 = v23;
          CFArrayAppendValue(v23, @"contentlength.bytes");
          CFArrayAppendValue(v24, @"vendor.roundtrip.millis");
          CFArrayAppendValue(v24, @"vendor.network.interface");
          CFArrayAppendValue(v24, @"vendor.nameresolution.millis");
          CFArrayAppendValue(v24, @"vendor.nameresolution.serverAddress");
          CFArrayAppendValue(v24, @"vendor.request.qos");
          CFDictionarySetValue(v17, @"vendor.kpis", v24);
          CFRelease(v24);
        }
        double v25 = CFArrayCreateMutable(v9, 0, MEMORY[0x1E4F1D510]);
        if (v25)
        {
          double v26 = v25;
          CFArrayAppendValue(v25, @"chunking.time.millis");
          CFArrayAppendValue(v26, @"authorizePut.millis");
          CFArrayAppendValue(v26, @"cachingServer.bytes");
          CFArrayAppendValue(v26, @"cachingServer.used");
          CFArrayAppendValue(v26, @"authorizeGetForFiles.millis");
          CFDictionarySetValue(v17, @"client.kpis", v26);
          CFRelease(v26);
        }
        CFDictionarySetValue(Mutable, @"putcomplete.verbosity.0", v17);
        CFDictionarySetValue(Mutable, @"getcomplete.verbosity.0", v17);
        CFRelease(v17);
      }
      v27 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
LABEL_41:
        CFStringRef v6 = (CFStringRef)v3;
        if (!v3) {
          goto LABEL_44;
        }
        goto LABEL_42;
      }
      CFStringRef v28 = CFStringCreateWithFormat(v9, 0, @"Using default MobileMe reporting levels.");
      id v29 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
LABEL_39:
        if (v28) {
          CFRelease(v28);
        }
        goto LABEL_41;
      }
      *(_DWORD *)buf = 138543362;
      *(void *)&uint8_t buf[4] = v28;
      long long v30 = v29;
      os_log_type_t v31 = OS_LOG_TYPE_DEBUG;
    }
    else
    {
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      long long v33 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
      CFStringRef v28 = CFStringCreateWithFormat(v9, 0, @"Failed to create default MobileMe reporting levels.");
      uint64_t v34 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_39;
      }
      *(_DWORD *)buf = 138543362;
      *(void *)&uint8_t buf[4] = v28;
      long long v30 = v34;
      os_log_type_t v31 = OS_LOG_TYPE_ERROR;
    }
    _os_log_impl(&dword_1DC1CA000, v30, v31, "%{public}@", buf, 0xCu);
    goto LABEL_39;
  }
  return pthread_mutex_unlock(&sReportingInfoInitLock);
}

uint64_t _getAbsoluteTimeFromPreferences(const __CFString *a1, const __CFString *a2, double *a3)
{
  CFBooleanRef v4 = (const __CFBoolean *)CFPreferencesCopyAppValue(a1, a2);
  uint64_t v5 = DoubleFromCFObject(v4, a3);
  if (v4) {
    CFRelease(v4);
  }
  return v5;
}

uint64_t DoubleFromCFObject(const __CFBoolean *a1, double *a2)
{
  if (IsValidCFBoolean(a1))
  {
    double Value = (double)CFBooleanGetValue(a1);
LABEL_3:
    *a2 = Value;
    return 1;
  }
  if (IsValidCFNumber(a1))
  {
    return CFNumberGetValue(a1, kCFNumberDoubleType, a2);
  }
  else
  {
    uint64_t result = (uint64_t)IsValidCFString(a1);
    if (result)
    {
      double Value = CFStringGetDoubleValue((CFStringRef)a1);
      goto LABEL_3;
    }
  }
  return result;
}

const void *IsValidCFNumber(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFNumberGetTypeID());
  }
  return result;
}

const void *IsValidCFBoolean(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFBooleanGetTypeID());
  }
  return result;
}

void mmcs_report_copy_plist_header_values(void *a1, CFTypeRef *a2)
{
  CFDictionaryRef theDict = 0;
  CFTypeRef cf = 0;
  if (a1) {
    p_CFDictionaryRef theDict = &theDict;
  }
  else {
    p_CFDictionaryRef theDict = 0;
  }
  if (a2) {
    p_CFTypeRef cf = &cf;
  }
  else {
    p_CFTypeRef cf = 0;
  }
  _mmcs_report_copyConfiguration(p_theDict, p_cf);
  CFDictionaryRef v6 = theDict;
  if (theDict)
  {
    *a1 = 0;
    double Value = CFDictionaryGetValue(v6, @"echo.header.plist.version");
    CFBooleanRef v8 = Value;
    if (Value)
    {
      CFRetain(Value);
      CFTypeID v9 = CFGetTypeID(v8);
      if (v9 == CFStringGetTypeID())
      {
        *a1 = v8;
        CFBooleanRef v8 = 0;
      }
    }
    if (cf
      && mmcs_get_BOOLean_from_cfdictionary_object_for_key(theDict, @"send.header.plist.sha256", 1))
    {
      *a2 = cf;
      CFTypeRef cf = 0;
    }
    if (v8) {
      CFRelease(v8);
    }
    if (theDict) {
      CFRelease(theDict);
    }
  }
  CFDictionaryRef theDict = 0;
  if (cf) {
    CFRelease(cf);
  }
}

void mmcs_report_close()
{
  pthread_mutex_lock(&sReportingInfoInitLock);
  if (gMMCS_MobileMeReporting
    && (uint64_t v0 = *(void *)(gMMCS_MobileMeReporting + 24) - 1, (*(void *)(gMMCS_MobileMeReporting + 24) = v0) == 0))
  {
    pthread_mutex_lock(&sReportingInfoAccessLock);
    CFTypeID v1 = (CFTypeRef *)gMMCS_MobileMeReporting;
    if (*(void *)gMMCS_MobileMeReporting)
    {
      CFRelease(*(CFTypeRef *)gMMCS_MobileMeReporting);
      CFTypeID v1 = (CFTypeRef *)gMMCS_MobileMeReporting;
    }
    CFTypeRef *v1 = 0;
    if (v1[1])
    {
      CFRelease(v1[1]);
      CFTypeID v1 = (CFTypeRef *)gMMCS_MobileMeReporting;
    }
    CFAllocatorRef v2 = v1[2];
    free(v1);
    gMMCS_MobileMeReporting = 0;
    pthread_mutex_unlock(&sReportingInfoAccessLock);
    pthread_mutex_unlock(&sReportingInfoInitLock);
    if (v2)
    {
      error_with_underlying_error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 38, 0, @"Cancelling plist fetch. Engine closing.", v3, v4, v5, v6, v8);
      mmcs_http_context_should_cancel(v2, error_with_underlying_error);
      if (error_with_underlying_error) {
        CFRelease(error_with_underlying_error);
      }
      C3BaseRelease(v2);
    }
  }
  else
  {
    pthread_mutex_unlock(&sReportingInfoInitLock);
  }
}

uint64_t mmcs_logging_logger_default()
{
  if (mmcs_logging_logger_default_once != -1) {
    dispatch_once(&mmcs_logging_logger_default_once, &__block_literal_global);
  }
  return mmcs_logging_logger_default_logger;
}

uint64_t mmcs_library_init()
{
  return pthread_once(&sOnceForLibrary, _mmcs_init_once_for_library);
}

uint64_t mmcs_get_BOOLean_from_cftype_using_description(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  if (!a2) {
    return a3;
  }
  uint64_t v3 = (uint64_t *)MEMORY[0x1E4F1CFD0];
  if (!a3) {
    uint64_t v3 = (uint64_t *)MEMORY[0x1E4F1CFC8];
  }
  CFBooleanRef cfBOOLean_from_cftype_using_description = (const __CFBoolean *)mmcs_get_cfBOOLean_from_cftype_using_description(a1, a2, *v3);
  if (!cfBOOLean_from_cftype_using_description) {
    mmcs_get_BOOLean_from_cftype_using_description_cold_1();
  }
  return CFBooleanGetValue(cfBOOLean_from_cftype_using_description);
}

CFStringRef mmcs_get_cfBOOLean_from_cftype_using_description(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    CFTypeID TypeID = CFBooleanGetTypeID();
    if (TypeID == CFGetTypeID(a2)) {
      return a2;
    }
    CFTypeID v7 = CFNumberGetTypeID();
    if (v7 == CFGetTypeID(a2))
    {
      int valuePtr = 0;
      if (CFNumberGetValue((CFNumberRef)a2, kCFNumberIntType, &valuePtr))
      {
        uint64_t v8 = MEMORY[0x1E4F1CFD0];
        if (!valuePtr) {
          uint64_t v8 = MEMORY[0x1E4F1CFC8];
        }
        return *(const __CFString **)v8;
      }
      double v19 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        return (const __CFString *)a3;
      }
      CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to convert CFNumberRef to integer for key '%@'.", a1);
      double v21 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        goto LABEL_30;
      }
      *(_DWORD *)buf = 138543362;
      CFStringRef v29 = v20;
LABEL_29:
      _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
LABEL_30:
      if (!v20) {
        return (const __CFString *)a3;
      }
      CFStringRef v18 = v20;
LABEL_44:
      CFRelease(v18);
      return (const __CFString *)a3;
    }
    CFTypeID v9 = CFStringGetTypeID();
    if (v9 == CFGetTypeID(a2))
    {
      if (CFStringCompare(a2, @"true", 1uLL) && CFStringCompare(a2, @"yes", 1uLL))
      {
        if (CFStringCompare(a2, @"false", 1uLL) && CFStringCompare(a2, @"no", 1uLL))
        {
          CFNumberRef v10 = mmcs_copy_cfnumber_from_cftype_using_description(a1, a2, 0);
          if (v10)
          {
            CFNumberRef v11 = v10;
            int valuePtr = 0;
            if (CFNumberGetValue(v10, kCFNumberIntType, &valuePtr))
            {
              CFNumberRef v12 = (uint64_t *)MEMORY[0x1E4F1CFD0];
              if (!valuePtr) {
                CFNumberRef v12 = (uint64_t *)MEMORY[0x1E4F1CFC8];
              }
              a3 = *v12;
            }
            else
            {
              double v23 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
              {
                CFStringRef v24 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to convert parsed string to integer for key '%@'.", a1);
                double v25 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 138543362;
                  CFStringRef v29 = v24;
                  _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
                }
                if (v24) {
                  CFRelease(v24);
                }
              }
            }
            CFStringRef v18 = (CFStringRef)v11;
            goto LABEL_44;
          }
          double v22 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            return (const __CFString *)a3;
          }
          CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to decode string '%@' as BOOLean for key '%@'.", a2, a1);
          double v21 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
            goto LABEL_30;
          }
          *(_DWORD *)buf = 138543362;
          CFStringRef v29 = v20;
          goto LABEL_29;
        }
        uint64_t v8 = MEMORY[0x1E4F1CFC8];
      }
      else
      {
        uint64_t v8 = MEMORY[0x1E4F1CFD0];
      }
      return *(const __CFString **)v8;
    }
    CFTypeID v13 = CFGetTypeID(a2);
    CFStringRef v14 = CFCopyTypeIDDescription(v13);
    CFNumberRef v15 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to recognized type id '%@' for BOOLean decoding for key '%@'.", v14, a1);
      uint64_t v17 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        CFStringRef v29 = v16;
        _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v16) {
        CFRelease(v16);
      }
    }
    if (v14)
    {
      CFStringRef v18 = v14;
      goto LABEL_44;
    }
  }
  return (const __CFString *)a3;
}

uint64_t mmcs_get_BOOLean_from_cfdictionary_object_for_key(const __CFDictionary *a1, void *key, uint64_t a3)
{
  if (!a1 || !key) {
    return a3;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, key);
  return mmcs_get_BOOLean_from_cftype_using_description((uint64_t)key, Value, a3);
}

CFStringRef mmcs_engine_create_client_header_value(uint64_t a1)
{
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.MMCS");
  if (BundleWithIdentifier) {
    BundleWithIdentifier = (__CFBundle *)CFBundleGetValueForInfoDictionaryKey(BundleWithIdentifier, (CFStringRef)*MEMORY[0x1E4F1D020]);
  }
  if (BundleWithIdentifier) {
    uint64_t v3 = (__CFString *)BundleWithIdentifier;
  }
  else {
    uint64_t v3 = @"unknown";
  }
  return copy_client_info_header(@"com.apple.icloud.content", (uint64_t)v3, a1, 0);
}

CFStringRef copy_client_info_header(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3) {
    return CFStringCreateWithFormat(0, 0, @"%@ <%@/%@ (UNKNOWN)>", sClientInfoHeaderTemplate, a1, a2);
  }
  if (a4) {
    return CFStringCreateWithFormat(0, 0, @"%@ <%@/%@ (%@/%@)>", sClientInfoHeaderTemplate, a1, a2, a3, a4);
  }
  return CFStringCreateWithFormat(0, 0, @"%@ <%@/%@ (%@)>", sClientInfoHeaderTemplate, a1, a2, a3);
}

uint64_t _mmcs_report_setReportingInfo(uint64_t a1, const void *a2, const void *a3, int a4, const void *a5, CFAbsoluteTime a6, CFAbsoluteTime a7)
{
  pthread_mutex_lock(&sReportingInfoAccessLock);
  uint64_t v14 = gMMCS_MobileMeReporting;
  if (!gMMCS_MobileMeReporting || a1 && *(void *)(gMMCS_MobileMeReporting + 16) != a1)
  {
    return pthread_mutex_unlock(&sReportingInfoAccessLock);
  }
  CFStringRef v16 = *(const void **)gMMCS_MobileMeReporting;
  if (*(void *)gMMCS_MobileMeReporting) {
    BOOL v17 = v16 == a3;
  }
  else {
    BOOL v17 = 0;
  }
  if (!v17)
  {
    if (v16)
    {
      CFRelease(v16);
      uint64_t v14 = gMMCS_MobileMeReporting;
    }
    *(void *)uint64_t v14 = 0;
    if (!a3) {
      goto LABEL_27;
    }
    CFRetain(a3);
    if (!a1) {
      goto LABEL_27;
    }
    if (!mmcs_http_context_get_response_message(a1)) {
      goto LABEL_27;
    }
    response_message = (__CFHTTPMessage *)mmcs_http_context_get_response_message(a1);
    if (!response_message) {
      goto LABEL_27;
    }
    CFStringRef v19 = CFHTTPMessageCopyHeaderFieldValue(response_message, @"Cache-Control");
    if (v19)
    {
      CFStringRef v20 = v19;
      CFRange v21 = CFStringFind(v19, @"max-age=", 1uLL);
      if (v21.location == -1) {
        goto LABEL_25;
      }
      v40.location = 0;
      v40.length = 0;
      v42.length = CFStringGetLength(v20) - (v21.location + v21.length);
      v42.location = v21.location + v21.length;
      int v22 = CFStringFindWithOptions(v20, @",", v42, 1uLL, &v40);
      CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFIndex v24 = v22 ? v40.location : CFStringGetLength(v20);
      v43.length = v24 - (v21.location + v21.length);
      v43.location = v21.location + v21.length;
      CFStringRef v25 = CFStringCreateWithSubstring(v23, v20, v43);
      if (!v25)
      {
LABEL_25:
        CFRelease(v20);
      }
      else
      {
        CFStringRef v26 = v25;
        DoubleCFStringRef Value = CFStringGetDoubleValue(v25);
        *(double *)(gMMCS_MobileMeReporting + 40) = DoubleValue;
        CFRelease(v26);
        CFRelease(v20);
        if (DoubleValue != 0.0) {
          goto LABEL_27;
        }
      }
    }
    *(void *)(gMMCS_MobileMeReporting + 40) = 0x40F5180000000000;
LABEL_27:
    uint64_t v14 = gMMCS_MobileMeReporting;
    *(void *)gMMCS_MobileMeReporting = a3;
    CFStringRef v28 = *(const void **)(v14 + 8);
    if (v28 != a2)
    {
      if (v28)
      {
        CFRelease(v28);
        uint64_t v14 = gMMCS_MobileMeReporting;
      }
      *(void *)(v14 + 8) = a2;
      if (a2)
      {
        CFRetain(a2);
        uint64_t v14 = gMMCS_MobileMeReporting;
      }
    }
  }
  *(CFAbsoluteTime *)(v14 + 48) = a7;
  *(CFAbsoluteTime *)(v14 + 56) = a6;
  v40.location = *(void *)(v14 + 40);
  uint64_t result = pthread_mutex_unlock(&sReportingInfoAccessLock);
  if (!a4) {
    return result;
  }
  CFLocaleRef v29 = CFLocaleCreate(0, @"en_US");
  CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef DateFormatFromTemplate = CFDateFormatterCreateDateFormatFromTemplate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"yyyy/MM/dd kk:mm:ss.SSSS", 0, v29);
  CFStringRef v32 = DateFormatFromTemplate;
  if (v29 && DateFormatFromTemplate)
  {
    long long v33 = CFDateFormatterCreate(v30, v29, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    uint64_t v34 = v33;
    if (v33) {
      CFDateFormatterSetFormat(v33, v32);
    }
    goto LABEL_38;
  }
  uint64_t v34 = 0;
  CFPropertyListRef v35 = 0;
  if (v29)
  {
LABEL_38:
    CFRelease(v29);
    CFPropertyListRef v35 = v34;
  }
  if (v32) {
    CFRelease(v32);
  }
  CFPreferencesSetAppValue(@"report.ReportLevels", a3, @"com.apple.mmcs");
  CFPreferencesSetAppValue(@"report.LastSuccessfulCheckTime", a5, @"com.apple.mmcs");
  CFPreferencesSetAppValue(@"report.sha256", a2, @"com.apple.mmcs");
  if (v35)
  {
    CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(v30, v35, a6);
    CFPreferencesSetAppValue(@"report.LastSuccessfulCheckDate", StringWithAbsoluteTime, @"com.apple.mmcs");
    if (StringWithAbsoluteTime) {
      CFRelease(StringWithAbsoluteTime);
    }
    CFPreferencesSetAppValue(@"report.LastFailedCheckTime", 0, @"com.apple.mmcs");
    CFStringRef v37 = CFDateFormatterCreateStringWithAbsoluteTime(v30, v35, a7);
    CFPreferencesSetAppValue(@"report.LastFailedCheckDate", v37, @"com.apple.mmcs");
    if (v37) {
      CFRelease(v37);
    }
    CFRelease(v35);
  }
  else
  {
    CFPreferencesSetAppValue(@"report.LastSuccessfulCheckDate", 0, @"com.apple.mmcs");
    CFPreferencesSetAppValue(@"report.LastFailedCheckTime", 0, @"com.apple.mmcs");
    CFPreferencesSetAppValue(@"report.LastFailedCheckDate", 0, @"com.apple.mmcs");
  }
  CFNumberRef v38 = CFNumberCreate(v30, kCFNumberDoubleType, &v40);
  if (v38)
  {
    CFNumberRef v39 = v38;
    CFPreferencesSetAppValue(@"report.TTL", v38, @"com.apple.mmcs");
    CFRelease(v39);
  }
  return CFPreferencesAppSynchronize(@"com.apple.mmcs");
}

void *_mmcs_report_copyConfiguration(void *result, void *a2)
{
  if (gMMCS_MobileMeReporting && *(void *)gMMCS_MobileMeReporting)
  {
    uint64_t v3 = result;
    pthread_mutex_lock(&sReportingInfoAccessLock);
    uint64_t v4 = (CFTypeRef *)gMMCS_MobileMeReporting;
    if (gMMCS_MobileMeReporting)
    {
      if (v3)
      {
        *uint64_t v3 = 0;
        CFTypeRef v5 = *v4;
        if (*v4)
        {
          CFRetain(*v4);
          *uint64_t v3 = v5;
        }
      }
      if (a2)
      {
        *a2 = 0;
        uint64_t v6 = *(void *)(gMMCS_MobileMeReporting + 8);
        if (v6)
        {
          CFRetain(*(CFTypeRef *)(gMMCS_MobileMeReporting + 8));
          *a2 = v6;
        }
      }
    }
    return (void *)pthread_mutex_unlock(&sReportingInfoAccessLock);
  }
  return result;
}

uint64_t MMCSGetDefaultProtocolVersion()
{
  uint64_t result = _kMMCSEngineDefaultProtocolVersion;
  if (!_kMMCSEngineDefaultProtocolVersion) {
    MMCSGetDefaultProtocolVersion_cold_1();
  }
  return result;
}

const void *IsValidCFString(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFStringGetTypeID());
  }
  return result;
}

uint64_t getLocateOptions()
{
  pthread_once(&sLocatorVars_once, (void (*)(void))_LocatorVars_init_once);
  uint64_t result = sLocateOptions;
  if (!sLocateOptions) {
    getLocateOptions_cold_1();
  }
  return result;
}

void mmcs_warm(uint64_t a1, const __CFDictionary *a2, void (*a3)(uint64_t, CFDictionaryRef))
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = _os_activity_create(&dword_1DC1CA000, "mmcs-warm", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v6, &state);
  CFTypeID v7 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEFAULT, "mmcs_warm starting", buf, 2u);
  }
  if (a2)
  {
    CFStringRef Value = (void *)CFDictionaryGetValue(a2, @"kMMCSWarmContainerState");
    if (Value)
    {
      uint64_t v14 = Value;
      CFTypeID TypeID = CFDataGetTypeID();
      if (TypeID == CFGetTypeID(v14))
      {
        CFStringRef v16 = malloc_type_calloc(1uLL, 0x18uLL, 0xA00402214FCE6uLL);
        if (v16)
        {
          if (v6) {
            os_retain(v6);
          }
          *CFStringRef v16 = v6;
          v16[1] = a1;
          v16[2] = a3;
        }
        mmcs_http_warm(v14, (uint64_t)v16, (void (*)(uint64_t, CFErrorRef))mmcs_warm_complete);
        if (!v6) {
          goto LABEL_21;
        }
LABEL_20:
        os_release(v6);
        goto LABEL_21;
      }
    }
    error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, @"kMMCSWarmContainerHostname required but not provided.", v9, v10, v11, v12, v13, v21);
  }
  else
  {
    error = mmcs_cferror_create_error(@"com.apple.mmcs", 40, @"Missing required parameters.");
  }
  CFStringRef v18 = error;
  if (!error) {
    mmcs_warm_cold_1();
  }
  if (a3)
  {
    CFErrorDomain Domain = CFErrorGetDomain(error);
    if (!CFEqual(@"com.apple.mmcs", Domain)) {
      mmcs_warm_cold_2();
    }
    values = v18;
    *(void *)buf = @"kMMCSResultError";
    CFDictionaryRef v20 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)buf, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    a3(a1, v20);
    if (v20) {
      CFRelease(v20);
    }
  }
  CFRelease(v18);
  if (v6) {
    goto LABEL_20;
  }
LABEL_21:
  os_activity_scope_leave(&state);
}

void mmcs_warm_complete(uint64_t a1, const void *a2)
{
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)a1, &state);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFTypeRef v5 = Mutable;
  if (a2) {
    CFDictionarySetValue(Mutable, @"kMMCSResultError", a2);
  }
  uint64_t v6 = *(void (**)(void, __CFDictionary *))(a1 + 16);
  if (v6) {
    v6(*(void *)(a1 + 8), v5);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  free((void *)a1);
  CFTypeID v7 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEFAULT, "mmcs_warm complete", v8, 2u);
  }
  os_activity_scope_leave(&state);
}

void mmcs_http_warm(void *a1, uint64_t a2, void (*a3)(uint64_t, CFErrorRef))
{
  id v5 = a1;
  uint64_t v6 = [C2WarmRequest alloc];
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = __mmcs_http_warm_block_invoke;
  v9[3] = &__block_descriptor_48_e17_v16__0__NSError_8l;
  v9[4] = a3;
  v9[5] = a2;
  CFTypeID v7 = [(C2WarmRequest *)v6 initWithData:v5 callback:v9];

  if (v7)
  {
    [(C2WarmRequest *)v7 send];
  }
  else
  {
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 1, @"Error generating C2WarmRequest.");
    a3(a2, error);
    if (error) {
      CFRelease(error);
    }
  }
}

uint64_t __mmcs_http_warm_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

void mmcs_register_request_abort(uint64_t a1, CFErrorRef err, void (*a3)(uint64_t, CFDictionaryRef))
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  if (err && a3)
  {
    CFErrorDomain Domain = CFErrorGetDomain(err);
    if (!CFEqual(@"com.apple.mmcs", Domain)) {
      mmcs_register_request_abort_cold_1();
    }
    values = err;
    keys[0] = @"kMMCSResultError";
    CFDictionaryRef v7 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    a3(a1, v7);
    if (v7) {
      CFRelease(v7);
    }
  }
}

uint64_t mmcs_register_request_has_items_not_done(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 304) + 32);
}

uint64_t mmcs_register_request_is_using_itemid(uint64_t a1, uint64_t a2)
{
  uint64_t result = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 8));
  if (result >= 1)
  {
    uint64_t v5 = result;
    for (CFIndex i = 0; i != v5; ++i)
    {
      if (*(unsigned char *)(a2 + 8)) {
        break;
      }
      ValueAtIndex = (CFNumberRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 8), i);
      uint64_t valuePtr = 0;
      uint64_t result = CFNumberGetValue(ValueAtIndex[2], kCFNumberSInt64Type, &valuePtr);
      if (result)
      {
        if (valuePtr == *(void *)a2) {
          *(unsigned char *)(a2 + 8) = 1;
        }
      }
    }
  }
  return result;
}

void mmcs_register_request_append_description(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    CFStringRef v2 = _mmcs_request_copy_description(*(void *)a1);
    if (v2)
    {
      CFStringRef v3 = v2;
      CFStringAppend(*(CFMutableStringRef *)(a1 + 16), v2);
      CFRelease(v3);
    }
  }
}

void mmcs_register_request_finalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 304);
  CFStringRef v3 = *(const void **)(v2 + 8);
  if (v3)
  {
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 304);
  }
  *(void *)(v2 + 8) = 0;
  uint64_t v4 = *(void *)(a1 + 304);
  uint64_t v5 = *(const void **)(v4 + 40);
  if (v5)
  {
    CFRelease(v5);
    uint64_t v4 = *(void *)(a1 + 304);
  }
  *(void *)(v4 + 40) = 0;
  uint64_t v6 = *(void *)(a1 + 304);
  CFDictionaryRef v7 = *(const void **)(v6 + 24);
  if (v7)
  {
    C3BaseRelease(v7);
    uint64_t v6 = *(void *)(a1 + 304);
  }
  *(void *)(v6 + 24) = 0;
}

uint64_t mmcs_register_request_stop_with_error(uint64_t a1, const void *a2)
{
  if (*(unsigned char *)(a1 + 144)) {
    return 0;
  }
  C3BaseRetain((CFTypeRef)a1);
  *(unsigned char *)(a1 + 144) = 1;
  if (a2)
  {
    CFRetain(a2);
    *(void *)(a1 + 152) = a2;
  }
  else
  {
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 4, @"Register request was cancelled.");
    CFRetain(error);
    *(void *)(a1 + 152) = error;
    if (error) {
      CFRelease(error);
    }
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 304) + 24);
  if (v6) {
    mmcs_chunk_job_cancel(v6);
  }
  mmcs_register_request_cleanup(a1);
  C3BaseRelease((CFTypeRef)a1);
  return 1;
}

void mmcs_register_request_cleanup(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 200), &state);
  mmcs_engine_commit_if_anything_outstanding(*(void **)(a1 + 32));
  *(unsigned char *)(*(void *)(a1 + 304) + 32) = 0;
  v27.opaque[0] = 0;
  v27.opaque[1] = 0;
  request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  os_activity_scope_enter(request_activity_marker, &v27);
  CFStringRef v3 = mmcs_request_copy_description(a1);
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppend(Mutable, @"(");
  CFArrayRef v6 = *(const __CFArray **)(*(void *)(a1 + 304) + 8);
  if (v6)
  {
    CFIndex Count = CFArrayGetCount(v6);
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      for (CFIndex i = 0; i != v8; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 8), i);
        CFStringRef v11 = mmcs_register_item_copy_short_description((uint64_t)ValueAtIndex);
        if (i) {
          CFStringAppend(Mutable, @", ");
        }
        CFStringAppend(Mutable, v11);
        if (v11) {
          CFRelease(v11);
        }
      }
    }
  }
  CFStringAppend(Mutable, @""));
  CFStringRef v12 = CFStringCreateWithFormat(v4, 0, @"%@ %@", v3, Mutable);
  if (v3) {
    CFRelease(v3);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t v13 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v14 = CFStringCreateWithFormat(v4, 0, @"Engine %p completed request %@", *(void *)(a1 + 32), v12);
    CFNumberRef v15 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      CFStringRef v29 = v14;
      _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
    }
    if (v14) {
      CFRelease(v14);
    }
  }
  if (v12) {
    CFRelease(v12);
  }
  CFStringRef v16 = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  BOOL v17 = v16;
  CFStringRef v18 = *(const void **)(*(void *)(a1 + 304) + 40);
  if (v18) {
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 144))
  {
    CFStringRef v18 = *(const void **)(a1 + 152);
    if (!v18) {
      mmcs_register_request_cleanup_cold_1();
    }
LABEL_23:
    CFDictionarySetValue(v16, @"kMMCSResultError", v18);
    goto LABEL_24;
  }
  CFMutableArrayRef v22 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v23 = *(const __CFArray **)(*(void *)(a1 + 304) + 8);
  v33.length = CFArrayGetCount(v23);
  v33.location = 0;
  CFArrayApplyFunction(v23, v33, (CFArrayApplierFunction)_add_item_result, v22);
  CFDictionarySetValue(v17, @"kMMCSRequestOptionItemOptions", v22);
  if (v22) {
    CFRelease(v22);
  }
  if (*(unsigned char *)(*(void *)(a1 + 304) + 48))
  {
    CFDataRef AuthorizePutRequestBody = mmcs_register_request_create_AuthorizePutRequestBody(a1);
    if (AuthorizePutRequestBody)
    {
      CFDataRef v25 = AuthorizePutRequestBody;
      CFDictionarySetValue(v17, @"kMMCSRequestOptionReturnPreauthorizationRequestObject", AuthorizePutRequestBody);
      CFRelease(v25);
    }
  }
LABEL_24:
  CFStringRef v19 = mmcs_request_copy_description(a1);
  CFDictionaryRef v20 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    CFStringRef v21 = *(const __CFString **)(a1 + 32);
    *(_DWORD *)buf = 134218242;
    CFStringRef v29 = v21;
    __int16 v30 = 2114;
    CFStringRef v31 = v19;
    _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_INFO, "Engine %p request will notify request %{public}@ done", buf, 0x16u);
  }
  if (v19) {
    CFRelease(v19);
  }
  (**(void (***)(void, __CFDictionary *))(a1 + 304))(*(void *)(a1 + 40), v17);
  if (v17) {
    CFRelease(v17);
  }
  os_activity_scope_leave(&v27);
  mmcs_engine_remove_request(*(void *)(a1 + 32), (const void *)a1);
  os_activity_scope_leave(&state);
}

void mmcs_register_items(uint64_t a1, uint64_t a2, void *a3, void (*a4)(uint64_t, CFDictionaryRef))
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  CFIndex v8 = _os_activity_create(&dword_1DC1CA000, "mmcs-register-items", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v8, &state);
  CFErrorRef v122 = 0;
  v120.opaque[0] = 0;
  if (!mmcs_request_allocate((uint64_t *)&v120, 5, 64) || (uint64_t v14 = v120.opaque[0]) == 0)
  {
    CFIndex v24 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, @"Cannot allocate register request", v9, v10, v11, v12, v13, v108);
    CFDataRef v25 = v24;
    uint64_t v14 = 0;
LABEL_106:
    CFErrorRef v122 = v24;
    goto LABEL_107;
  }
  if (!_mmcs_request_init(v120.opaque[0], a1, a2, a3, 0, 0, v8, &v122))
  {
    CFStringRef v26 = @"Cannot initialize register request";
    CFIndex v27 = 37;
LABEL_105:
    CFIndex v24 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v27, v26, v15, v16, v17, v18, v19, v108);
    CFDataRef v25 = v24;
    goto LABEL_106;
  }
  **(void **)(v14 + 304) = a4;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *(void *)(*(void *)(v14 + 304) + 8) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &_register_items_array_callbacks);
  *(unsigned char *)(*(void *)(v14 + 304) + 48) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a3, @"kMMCSRequestOptionReturnPreauthorizationRequestObject", 0);
  char v20 = 1;
  *(unsigned char *)(*(void *)(v14 + 304) + 49) = 1;
  char BOOLean_from_cfdictionary_object_for_key = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a3, @"kMMCSRequestOptionUseFORD", 0);
  CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)a3, @"kMMCSRequestOptionReturnOpaqueCloneContext");
  if (Value)
  {
    CFMutableArrayRef v22 = Value;
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v22))
    {
      CFRetain(v22);
      char v20 = 0;
      *(void *)(*(void *)(v14 + 304) + 56) = v22;
    }
    else
    {
      char v20 = 1;
    }
  }
  CFStringRef v28 = CFDictionaryGetValue((CFDictionaryRef)a3, @"kMMCSRequestOptionItemOptions");
  if (!v28 || (CFStringRef v29 = v28, v30 = CFArrayGetTypeID(), v30 != CFGetTypeID(v29)))
  {
    char v108 = (char)a3;
    CFStringRef v26 = @"expected item options array in request options %@";
LABEL_104:
    CFIndex v27 = 40;
    goto LABEL_105;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)v29);
  if (!Count)
  {
    char v108 = (char)a3;
    CFStringRef v26 = @"did not expect empty item options array in request options %@";
    goto LABEL_104;
  }
  CFIndex v32 = Count;
  uint64_t v109 = a2;
  char v110 = v20;
  uint64_t v113 = a1;
  v111 = a4;
  if (Count < 1)
  {
LABEL_42:
    int v70 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a3, @"kMMCSRequestOptionRetrievePastRegistration", 0);
    uint64_t v71 = *(void *)(v14 + 304);
    if (!v70)
    {
      *(unsigned char *)(v71 + 32) = 0;
      *(void *)(v14 + 224) = voucher_copy();
      mmcs_engine_add_request(v113, (const void *)v14);
      mmcs_register_items_schedule_job(v14);
      goto LABEL_110;
    }
    *(unsigned char *)(v71 + 32) = 1;
    mmcs_engine_add_request(v113, (const void *)v14);
    CFIndex v72 = CFArrayGetCount(*(CFArrayRef *)(*(void *)(v14 + 304) + 8));
    a2 = v109;
    if (v72 < 1)
    {
LABEL_102:
      mmcs_register_request_cleanup(v14);
      goto LABEL_109;
    }
    CFIndex v73 = v72;
    CFIndex v74 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(v14 + 304) + 8), v74);
      v120.opaque[0] = 0;
      v120.opaque[1] = 0;
      os_activity_scope_enter(*((os_activity_t *)ValueAtIndex + 18), &v120);
      uint64_t v121 = 0;
      if (!CFNumberGetValue(*((CFNumberRef *)ValueAtIndex + 2), kCFNumberSInt64Type, &v121))
      {
        v93 = @"Error with itemID.";
LABEL_72:
        *((void *)ValueAtIndex + 16) = mmcs_cferror_create_error(@"com.apple.mmcs", 8, v93);
        os_activity_scope_leave(&v120);
        goto LABEL_101;
      }
      v76 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
      {
        char v108 = v121;
        CFStringRef v77 = CFStringCreateWithFormat(allocator, 0, @"Attempting to retrieve past-registration for itemId:%lld");
        v78 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          CFStringRef v125 = v77;
          _os_log_impl(&dword_1DC1CA000, v78, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
        }
        if (v77) {
          CFRelease(v77);
        }
      }
      uint64_t valuePtr = 0;
      if ((CKGetRegisteredFileMetadata() & 1) == 0)
      {
        v93 = @"Error occurred locating file signature.";
        goto LABEL_72;
      }
      v79 = (const void *)CKFileDigestResultsFileVerificationKey();
      mmcs_register_item_set_file_verification_key((uint64_t)ValueAtIndex, v79);
      v80 = (const UInt8 *)CKFileDigestResultsFileSignature();
      v81 = (void *)CKFileSchemeAndSignatureCopyCString();
      v82 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        char v108 = (char)v81;
        CFStringRef v83 = CFStringCreateWithFormat(allocator, 0, @"sig:%s");
        v84 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          CFStringRef v125 = v83;
          _os_log_impl(&dword_1DC1CA000, v84, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
        }
        if (v83) {
          CFRelease(v83);
        }
      }
      CFIndex v85 = v73;
      if (v81) {
        free(v81);
      }
      CFIndex v86 = CKFileSchemeAndSignatureSize();
      *((void *)ValueAtIndex + 12) = CFDataCreate(allocator, v80, v86);
      uint64_t v118 = 0;
      uint64_t v118 = CKFileDigestResultsFileLength();
      *((void *)ValueAtIndex + 13) = CFNumberCreate(allocator, kCFNumberSInt64Type, &v118);
      v87 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
      {
        char v108 = v118;
        CFStringRef v88 = CFStringCreateWithFormat(allocator, 0, @"len:%llu");
        v89 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          CFStringRef v125 = v88;
          _os_log_impl(&dword_1DC1CA000, v89, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
        }
        if (v88) {
          CFRelease(v88);
        }
      }
      unint64_t v116 = 0;
      v117 = 0;
      int v90 = CKGetRegisteredChunksForItemID();
      if (v90 && v117)
      {
        if (v116)
        {
          unint64_t v91 = 0;
          uint64_t v92 = 0;
          do
          {
            v92 += CKRegisteredChunkLength();
            CKRegisteredChunkSize();
            ++v91;
          }
          while (v91 < v116);
        }
        else
        {
          uint64_t v92 = 0;
        }
        if (((v94 = (unsigned char *)CKFileDigestResultsFileSignature()) != 0 && (*v94 & 0x7F) == 4
           || CKFileDigestResultsHasFileLength())
          && v92 != CKFileDigestResultsFileLength())
        {
          v95 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v95, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1DC1CA000, v95, OS_LOG_TYPE_FAULT, "fileLengthCheck != CKFileDigestResultsFileLength(fileDigestResults)", buf, 2u);
          }
        }
      }
      v96 = v117;
      if (!*((unsigned char *)ValueAtIndex + 137)) {
        break;
      }
      if (v117) {
        int v97 = v90;
      }
      else {
        int v97 = 0;
      }
      a4 = v111;
      if (v97 != 1)
      {
        *((void *)ValueAtIndex + 16) = mmcs_cferror_create_error(@"com.apple.mmcs", 8, @"Error occurred locating chunk list.");
        v96 = v117;
LABEL_88:
        if (v96) {
          free(v96);
        }
        goto LABEL_90;
      }
      mmcs_print_registered_chunk_list((uint64_t)v117, v116);
      *((void *)ValueAtIndex + 15) = CFNumberCreate(allocator, kCFNumberSInt64Type, &v116);
      *((void *)ValueAtIndex + 10) = v117;
LABEL_90:
      v117 = 0;
      if (*((void *)ValueAtIndex + 6) || *(unsigned char *)(*(void *)(v14 + 304) + 49))
      {
        CFStringRef v115 = 0;
        CFStringRef v115 = mmcs_register_item_padded_length((uint64_t)ValueAtIndex);
        if (!v115)
        {
          CFErrorRef v122 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Error Calculating Padded File Size", v98, v99, v100, v101, v102, v108);
          goto LABEL_129;
        }
        *((void *)ValueAtIndex + 14) = CFNumberCreate(allocator, kCFNumberSInt64Type, &v115);
        v103 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
        {
          char v108 = (char)v115;
          CFStringRef v104 = CFStringCreateWithFormat(allocator, 0, @"padLen:%llu");
          v105 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138543362;
            CFStringRef v125 = v104;
            _os_log_impl(&dword_1DC1CA000, v105, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
          }
          if (v104) {
            CFRelease(v104);
          }
        }
      }
      if (valuePtr) {
        C3BaseRelease(valuePtr);
      }
      os_activity_scope_leave(&v120);
      CFIndex v73 = v85;
LABEL_101:
      if (++v74 == v73) {
        goto LABEL_102;
      }
    }
    a4 = v111;
    goto LABEL_88;
  }
  CFIndex v33 = 0;
  while (1)
  {
    uint64_t v34 = CFArrayGetValueAtIndex((CFArrayRef)v29, v33);
    CFTypeID v35 = CFGetTypeID(v34);
    if (v35 != CFDictionaryGetTypeID())
    {
      char v108 = (char)v34;
      CFStringRef v106 = @"expected item option to be a dictionary %@";
      goto LABEL_120;
    }
    CFIndex v41 = v32;
    CFRange v42 = CFDictionaryGetValue((CFDictionaryRef)v34, @"kMMCSItemID");
    if (!v42 || (v43 = v42, CFTypeID v44 = CFGetTypeID(v42), v44 != CFNumberGetTypeID()))
    {
      char v108 = (char)v34;
      CFStringRef v106 = @"expected item option dictionary to include an itemID. Got: %@";
LABEL_120:
      CFIndex v107 = 40;
LABEL_122:
      CFDataRef v25 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v107, v106, v36, v37, v38, v39, v40, v108);
      CFErrorRef v122 = v25;
      a2 = v109;
      goto LABEL_107;
    }
    uint64_t v121 = 0;
    if (!mmcs_register_item_create(&v121, v43))
    {
      CFStringRef v106 = @"unable to create register item";
      CFIndex v107 = 1;
      goto LABEL_122;
    }
    request_activity_marker = mmcs_request_get_request_activity_marker(v14);
    double v46 = _os_activity_create(&dword_1DC1CA000, "mmcs-register-item", request_activity_marker, OS_ACTIVITY_FLAG_DEFAULT);
    *(void *)(v121 + 144) = v46;
    v120.opaque[0] = 0;
    v120.opaque[1] = 0;
    os_activity_scope_enter(v46, &v120);
    uint64_t v47 = v121;
    *(unsigned char *)(v121 + 64) = BOOLean_from_cfdictionary_object_for_key;
    *(void *)(v47 + 40) = 0;
    v48 = CFDictionaryGetValue((CFDictionaryRef)v34, @"kMMCSBoundaryKey");
    if (v48)
    {
      v49 = v48;
      CFTypeID v50 = CFDataGetTypeID();
      CFTypeID v51 = CFGetTypeID(v49);
      uint64_t v52 = v121;
      if (v50 == v51)
      {
        mmcs_register_item_set_boundary_key(v121, v49);
        uint64_t v52 = v121;
        *(unsigned char *)(v121 + 64) = 1;
        *(unsigned char *)(v52 + 137) = v110;
        *(void *)(v52 + 40) = 2;
      }
      a4 = v111;
    }
    else
    {
      uint64_t v52 = v121;
    }
    uint64_t cfindex_from_options = mmcs_get_cfindex_from_options(@"kMMCSPaddingPolicy", (const __CFDictionary *)v34, *(void *)(v52 + 40));
    *(void *)(v121 + 40) = cfindex_from_options;
    *(unsigned char *)(*(void *)(v14 + 304) + 49) = cfindex_from_options != 0;
    BOOL v54 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)v34, @"kMMCSRegisterFileOptionPublic", 0) == 0;
    uint64_t v55 = v121;
    *(unsigned char *)(v121 + 136) = v54;
    char v56 = *(unsigned char *)(*(void *)(v14 + 304) + 48);
    *(unsigned char *)(v55 + 137) = v56;
    *(unsigned char *)(v55 + 137) = *(unsigned char *)(*(void *)(v14 + 304) + 49) | v56;
    char v57 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)v34, @"kMMCSRegisterFileOptionChunk", 0);
    *(unsigned char *)(v121 + 137) |= v57;
    char v58 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)v34, @"kMMCSRequestOptionReturnRegisteredChunks", 0);
    *(unsigned char *)(v121 + 138) = v58;
    uint64_t valuePtr = 0;
    CFNumberGetValue((CFNumberRef)v43, kCFNumberSInt64Type, &valuePtr);
    CFDictionaryRef cached_ranged_items = mmcs_engine_get_cached_ranged_items(v113, valuePtr);
    if (cached_ranged_items)
    {
      *(void *)(v121 + 152) = cached_ranged_items;
      CFRetain(cached_ranged_items);
    }
    if (!mmcs_wrapping_state_init_with_option_dict(v121 + 24, (CFDictionaryRef)v34, @"kMMCSWrappingState", (uint64_t)&v122))break; {
    CFIndex v32 = v41;
    }
    uint64_t v65 = *(void *)(v14 + 304);
    if ((*(unsigned char *)(v65 + 48) || *(unsigned char *)(v65 + 49)) && !*(unsigned char *)(v121 + 137))
    {
      v117 = 0;
      uint64_t v118 = 0;
      unint64_t v116 = 0;
      if (CFNumberGetValue(*(CFNumberRef *)(v121 + 16), kCFNumberSInt64Type, &v116))
      {
        if (CKGetRegisteredChunksForItemID())
        {
          *(void *)(v121 + 80) = v118;
          CFNumberRef v66 = CFNumberCreate(allocator, kCFNumberSInt64Type, &v117);
          *(void *)(v121 + 120) = v66;
        }
        else
        {
          v67 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            char v108 = v116;
            CFStringRef v68 = CFStringCreateWithFormat(allocator, 0, @"Could not get chunk list for itemId:%lld");
            v69 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138543362;
              CFStringRef v125 = v68;
              _os_log_impl(&dword_1DC1CA000, v69, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            }
            if (v68) {
              CFRelease(v68);
            }
          }
        }
      }
      uint64_t v65 = *(void *)(v14 + 304);
    }
    CFArrayAppendValue(*(CFMutableArrayRef *)(v65 + 8), (const void *)v121);
    if (v121) {
      C3BaseRelease((CFTypeRef)v121);
    }
    uint64_t v121 = 0;
    os_activity_scope_leave(&v120);
    if (v41 == ++v33) {
      goto LABEL_42;
    }
  }
  a2 = v109;
  if (!v122) {
    CFErrorRef v122 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, @"unable to initialize wrapping state", v60, v61, v62, v63, v64, v108);
  }
  if (v121) {
    C3BaseRelease((CFTypeRef)v121);
  }
  uint64_t v121 = 0;
LABEL_129:
  os_activity_scope_leave(&v120);
  CFDataRef v25 = v122;
LABEL_107:
  if (!v25) {
    mmcs_register_items_cold_1();
  }
  mmcs_register_request_abort(a2, v25, a4);
LABEL_109:
  if (v14) {
LABEL_110:
  }
    C3BaseRelease((CFTypeRef)v14);
  if (v122) {
    CFRelease(v122);
  }
  if (v8) {
    os_release(v8);
  }
  os_activity_scope_leave(&state);
}

void mmcs_register_items_schedule_job(uint64_t a1)
{
  uint64_t v2 = mmcs_chunk_instance_offset(a1);
  while (1)
  {
    uint64_t v3 = *(void *)(a1 + 304);
    CFIndex v4 = *(void *)(v3 + 16);
    if (v4 >= CFArrayGetCount(*(CFArrayRef *)(v3 + 8))) {
      break;
    }
    ValueAtIndex = (unsigned __int8 *)CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 8), *(void *)(*(void *)(a1 + 304) + 16));
    state.opaque[0] = 0;
    state.opaque[1] = 0;
    os_activity_scope_enter(*((os_activity_t *)ValueAtIndex + 18), &state);
    uint64_t itemid = mmcs_register_item_get_itemid((uint64_t)ValueAtIndex);
    uint64_t v34 = 0;
    *(void *)CFTypeID v35 = 0;
    uint64_t v7 = mmcs_engine_owner(v2);
    uint64_t requestor = mmcs_request_get_requestor(a1);
    if (mmcs_engine_get_item_reader_writer_for_item_callback(v2, v7, requestor, itemid, v35, (CFTypeRef *)&v34)&& MMCSItemReaderWriterOpen(*(uint64_t *)v35, (CFTypeRef *)&v34))
    {
      uint64_t FileTypeHint = MMCSItemReaderWriterGetFileTypeHint(*(uint64_t *)v35);
      int v16 = mmcs_fixed_chunk_size_for_item_type_hint(FileTypeHint);
      *(void *)&long long v29 = 0;
      *((void *)&v29 + 1) = a1;
      CFTypeID v30 = C3BaseRetain;
      CFStringRef v31 = C3BaseRelease;
      uint64_t v32 = 0;
      CFIndex v33 = mmcs_register_request_did_chunk_item;
      uint64_t v17 = mmcs_register_and_chunk_job_create(&v29, v2, *(const void **)v35, itemid, v16, ValueAtIndex[137], ValueAtIndex[136], *((const void **)ValueAtIndex + 6), 0, *((void **)ValueAtIndex + 18));
      if (v17)
      {
        uint64_t v23 = v17;
        CFIndex v24 = *(__CFArray **)(a1 + 184);
        if (v24)
        {
          CFDataRef v25 = *(void **)(v23 + 200);
          if (v25) {
            mmcs_metrics_request_add_chunking_info(v24, v25);
          }
        }
        *(void *)(*(void *)(a1 + 304) + 24) = v23;
        mmcs_engine_chunk_job_dispatch_async(v23, *(void *)(v2 + 24));
        char v26 = 0;
        goto LABEL_12;
      }
      CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"NULL chunk job", v18, v19, v20, v21, v22, cf);
    }
    else
    {
      CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_file_error_wrapping_error_to_release(v34, (char)@"Unable to register item", v9, v10, v11, v12, v13, v14);
    }
    *((void *)ValueAtIndex + 16) = file_error_wrapping_error_to_release;
    uint64_t v34 = 0;
    ++*(void *)(*(void *)(a1 + 304) + 16);
    char v26 = 1;
LABEL_12:
    if (*(void *)v35) {
      C3BaseRelease(*(CFTypeRef *)v35);
    }
    os_activity_scope_leave(&state);
    if ((v26 & 1) == 0) {
      return;
    }
  }
  mmcs_register_request_cleanup(a1);
}

void _add_item_result(uint64_t a1, __CFArray *a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFArrayRef v6 = *(const void **)(a1 + 16);
  if (!v6) {
    _add_item_result_cold_1();
  }
  uint64_t v7 = Mutable;
  CFDictionarySetValue(Mutable, @"kMMCSItemID", v6);
  CFIndex v8 = *(const void **)(a1 + 96);
  if (v8)
  {
    CFDictionarySetValue(v7, @"kMMCSSignature", v8);
    uint64_t v9 = *(const void **)(a1 + 104);
    if (v9) {
      CFDictionarySetValue(v7, @"kMMCSFileSize", v9);
    }
    uint64_t v10 = *(const void **)(a1 + 112);
    if (v10) {
      CFDictionarySetValue(v7, @"kMMCSPaddedFileSize", v10);
    }
    uint64_t v11 = *(const void **)(a1 + 120);
    if (v11) {
      CFDictionarySetValue(v7, @"kMMCSChunkCount", v11);
    }
    if (*(unsigned char *)(a1 + 138))
    {
      if (*(void *)(a1 + 80))
      {
        CFIndex valuePtr = 0;
        if (CFNumberGetValue(*(CFNumberRef *)(a1 + 120), kCFNumberCFIndexType, &valuePtr))
        {
          uint64_t v34 = a2;
          uint64_t v12 = CFArrayCreateMutable(v4, valuePtr, MEMORY[0x1E4F1D510]);
          if (valuePtr >= 1)
          {
            CFIndex v13 = 0;
            uint64_t v14 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
            uint64_t v15 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
            do
            {
              int v16 = CFDictionaryCreateMutable(v4, 0, v14, v15);
              uint64_t v35 = 0;
              uint64_t v35 = CKRegisteredChunkItemID();
              CFNumberRef v17 = CFNumberCreate(v4, kCFNumberSInt64Type, &v35);
              if (v17)
              {
                CFNumberRef v18 = v17;
                CFDictionaryAddValue(v16, @"itemID", v17);
                CFRelease(v18);
              }
              LODWORD(v35) = 0;
              LODWORD(v35) = CKRegisteredChunkLength();
              CFNumberRef v19 = CFNumberCreate(v4, kCFNumberSInt32Type, &v35);
              if (v19)
              {
                CFNumberRef v20 = v19;
                CFDictionaryAddValue(v16, @"length", v19);
                CFRelease(v20);
              }
              int v21 = CKRegisteredChunkLocation();
              CFStringRef v22 = CFStringCreateWithFormat(v4, 0, @"%c", v21);
              if (v22)
              {
                CFStringRef v23 = v22;
                CFDictionaryAddValue(v16, @"location", v22);
                CFRelease(v23);
              }
              uint64_t v35 = 0;
              uint64_t v35 = CKRegisteredChunkOffset();
              CFNumberRef v24 = CFNumberCreate(v4, kCFNumberSInt64Type, &v35);
              if (v24)
              {
                CFNumberRef v25 = v24;
                CFDictionaryAddValue(v16, @"offset", v24);
                CFRelease(v25);
              }
              uint64_t v35 = 0;
              uint64_t v35 = CKRegisteredChunkRowID();
              CFNumberRef v26 = CFNumberCreate(v4, kCFNumberSInt64Type, &v35);
              if (v26)
              {
                CFNumberRef v27 = v26;
                CFDictionaryAddValue(v16, @"rowID", v26);
                CFRelease(v27);
              }
              CFStringRef v28 = (const UInt8 *)CKRegisteredChunkSignature();
              CKRegisteredChunkSignature();
              CFIndex v29 = CKChunkSchemeAndSignatureSize();
              CFDataRef v30 = CFDataCreate(v4, v28, v29);
              if (v30)
              {
                CFDataRef v31 = v30;
                CFDictionaryAddValue(v16, @"signature", v30);
                CFRelease(v31);
              }
              CFArrayAppendValue(v12, v16);
              if (v16) {
                CFRelease(v16);
              }
              CKRegisteredChunkSize();
              ++v13;
            }
            while (v13 < valuePtr);
          }
          CFDictionarySetValue(v7, @"kMMCSRegisteredChunks", v12);
          a2 = v34;
          if (v12) {
            CFRelease(v12);
          }
        }
      }
    }
  }
  else
  {
    uint64_t v32 = *(__CFError **)(a1 + 128);
    if (!v32) {
      _add_item_result_cold_2();
    }
    CFErrorDomain Domain = CFErrorGetDomain(v32);
    if (!CFEqual(@"com.apple.mmcs", Domain)) {
      _add_item_result_cold_3();
    }
    CFDictionarySetValue(v7, @"kMMCSResultError", *(const void **)(a1 + 128));
  }
  CFArrayAppendValue(a2, v7);
  if (v7) {
    CFRelease(v7);
  }
}

void mmcs_register_request_did_chunk_item(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a2 + 288), &state);
  if (*(unsigned char *)(a1 + 144)) {
    goto LABEL_2;
  }
  uint64_t v4 = *(void *)(a1 + 304);
  if (*(void *)(v4 + 24) == a2)
  {
    *(void *)(v4 + 24) = 0;
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 8), *(void *)(*(void *)(a1 + 304) + 16));
    if (ValueAtIndex[15]) {
      mmcs_register_request_did_chunk_item_cold_3();
    }
    uint64_t v9 = ValueAtIndex;
    if (ValueAtIndex[10]) {
      mmcs_register_request_did_chunk_item_cold_2();
    }
    uint64_t itemid = mmcs_register_item_get_itemid((uint64_t)ValueAtIndex);
    if (*(void *)(a2 + 160) != itemid)
    {
      uint64_t v12 = itemid;
      CFIndex v13 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_46;
      }
      CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Job itemID %llu does not match register itemID %llu", *(void *)(a2 + 160), v12);
      uint64_t v15 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        *(void *)&uint8_t buf[4] = v14;
        int v16 = v15;
        os_log_type_t v17 = OS_LOG_TYPE_ERROR;
LABEL_17:
        _os_log_impl(&dword_1DC1CA000, v16, v17, "%{public}@", buf, 0xCu);
      }
LABEL_18:
      if (v14) {
        CFRelease(v14);
      }
      goto LABEL_46;
    }
    uint64_t v11 = *(const void **)(a2 + 280);
    if (v11)
    {
      CFRetain(v11);
      v9[16] = *(void *)(a2 + 280);
LABEL_46:
      C3BaseRelease((CFTypeRef)a2);
      ++*(void *)(*(void *)(a1 + 304) + 16);
      mmcs_register_items_schedule_job(a1);
      goto LABEL_2;
    }
    CFNumberRef v18 = (const UInt8 *)CKFileDigestResultsFileSignature();
    v9[12] = MMCSSignatureCopyData(v18);
    uint64_t valuePtr = CKFileDigestResultsFileLength();
    CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    v9[13] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
    CFNumberRef v20 = (const void *)CKFileDigestResultsFileVerificationKey();
    mmcs_register_item_set_file_verification_key((uint64_t)v9, v20);
    if (*(unsigned char *)(a2 + 82))
    {
      CFNumberRef v26 = *(const void **)(a2 + 264);
      if (v26)
      {
        *(void *)buf = 0;
        if (mmcs_chunking_profile_create((uint64_t *)buf, *(void *)(a2 + 256), v26))
        {
          if (*(void *)buf)
          {
            if (v9[9]) {
              mmcs_register_request_did_chunk_item_cold_1();
            }
            v9[9] = CFArrayCreateMutable(v19, 0, &kC3BaseArrayCallBacks);
            CFNumberRef v27 = *(const void **)buf;
          }
          else
          {
            CFNumberRef v27 = 0;
          }
        }
        else
        {
          if (*(void *)buf) {
            C3BaseRelease(*(CFTypeRef *)buf);
          }
          CFNumberRef v27 = 0;
          *(void *)buf = 0;
        }
        CFStringRef v28 = (__CFArray *)v9[9];
        if (v28)
        {
          CFArrayAppendValue(v28, v27);
          CFNumberRef v27 = *(const void **)buf;
        }
        if (v27) {
          C3BaseRelease(v27);
        }
      }
      v9[15] = CFNumberCreate(v19, kCFNumberSInt64Type, (const void *)(a2 + 256));
      v9[10] = *(void *)(a2 + 248);
      *(void *)(a2 + 248) = 0;
    }
    if (v9[6])
    {
      *(void *)buf = mmcs_register_item_padded_length((uint64_t)v9);
      if (!*(void *)buf)
      {
        CFStringRef v31 = @"Error Calculating Padded File Size";
        CFIndex v32 = 1;
        goto LABEL_45;
      }
      v9[14] = CFNumberCreate(v19, kCFNumberSInt64Type, buf);
    }
    if (!*(void *)(a2 + 256)) {
      goto LABEL_46;
    }
    if ((valuePtr & 0x8000000000000000) == 0)
    {
      mmcs_engine_add_bytes_chunked(*(void *)(a2 + 144), valuePtr);
      mmcs_engine_commit_if_over_threshold(*(void **)(a2 + 144));
      CFIndex v29 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_46;
      }
      CFStringRef v14 = CFStringCreateWithFormat(v19, 0, @"Got %llu chunks for %lld", *(void *)(a2 + 256), *(void *)(a2 + 160));
      CFDataRef v30 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138543362;
        *(void *)&uint8_t buf[4] = v14;
        int v16 = v30;
        os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
        goto LABEL_17;
      }
      goto LABEL_18;
    }
    char v33 = valuePtr;
    CFStringRef v31 = @"Calculated item size was too large (%llu) for item %lld";
    CFIndex v32 = 17;
LABEL_45:
    v9[16] = mmcs_cferror_create_with_format(@"com.apple.mmcs", v32, v31, v21, v22, v23, v24, v25, v33);
    goto LABEL_46;
  }
  uint64_t v5 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unrecogized chunk job. Ignoring");
    uint64_t v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v6) {
      CFRelease(v6);
    }
  }
LABEL_2:
  os_activity_scope_leave(&state);
}

BOOL mmcs_local_chunk_satisfyer_create(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  *a1 = 0;
  uint64_t v12 = C3TypeRegister(&mmcs_local_chunk_satisfyerGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v12, 0x40uLL);
  if (!Instance) {
    return *a1 != 0;
  }
  uint64_t v14 = Instance;
  *(void *)(Instance + 16) = a2;
  MMCSEngineRetain(a2);
  *(void *)(v14 + 24) = a3;
  *(void *)(v14 + 32) = a4;
  *(void *)(v14 + 40) = a5;
  *(unsigned char *)(v14 + 48) = a6;
  BOOL result = 1;
  *a1 = v14;
  return result;
}

uint64_t mmcs_local_chunk_satisfyer_perform(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6, CFTypeRef *a7)
{
  char v11 = 0;
  uint64_t v12 = 0;
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  CFTypeRef v88 = 0;
  v89 = 0;
  CFIndex v13 = a1 + 8;
  do
  {
    int v87 = dword_1DC2516E8[v12];
    CKRegisteredChunkSignature();
    if ((CKGetRegisteredChunks() & 1) == 0)
    {
      v79 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v80 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to CKGetRegisteredChunks");
        v81 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          *(void *)v94 = v80;
          _os_log_impl(&dword_1DC1CA000, v81, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
        }
        if (v80) {
          CFRelease(v80);
        }
      }
LABEL_97:
      uint64_t v78 = 1;
      CFTypeRef v77 = v88;
      if (v88) {
        goto LABEL_98;
      }
      return v78;
    }
    uint64_t v14 = (void *)CKRegisteredChunkSignatureCopyCString();
    uint64_t v15 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)v94 = v87;
      *(_WORD *)&v94[4] = 2048;
      *(void *)&v94[6] = v89;
      *(_WORD *)&v94[14] = 2080;
      *(void *)&v94[16] = v14;
      _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_DEBUG, "CKGetRegisteredChunks returned %d chunks in chunk list %p for signature %s", buf, 0x1Cu);
    }
    if (v14) {
      free(v14);
    }
    if (!v89 || !v87) {
      goto LABEL_97;
    }
    char v84 = v11;
    if (v87 < 1)
    {
      int v34 = 0;
      char v71 = 0;
      goto LABEL_81;
    }
    int v16 = 0;
    int v17 = 1;
    while (1)
    {
      if (v17 == 1) {
        int v16 = (char *)v89;
      }
      else {
        v16 += CKRegisteredChunkSize();
      }
      int v18 = CKRegisteredChunkLength();
      if (v18 != CKRegisteredChunkLength())
      {
        if (**(unsigned char **)(a2 + 56)) {
          mmcs_local_chunk_satisfyer_perform_cold_5();
        }
        int v19 = CKRegisteredChunkLength();
        uint64_t v20 = *(void *)(a2 + 56);
        *(_DWORD *)(v20 + 4) = v19;
        *(unsigned char *)(v20 + 64) = 1;
        *(void *)(*(void *)(a2 + 56) + 16) = CKRegisteredChunkKey();
        *(_DWORD *)(a2 + 64) = CKRegisteredChunkLength();
        CKRegisteredChunkLength();
        CKRegisteredChunkSetLength();
      }
      if (CKRegisteredChunkLocation() != 116 && CKRegisteredChunkLocation() != 114)
      {
        int v34 = 0;
        goto LABEL_72;
      }
      if (*v13 && CKRegisteredChunkItemID() == a1[7])
      {
        CFErrorRef v21 = 0;
        goto LABEL_66;
      }
      mmcs_local_chunk_satisfyer_clear_source_fd_cache((uint64_t)a1);
      CFErrorRef file_error_with_format = 0;
      if (CKRegisteredChunkLocation() == 116)
      {
        CFTypeRef cf = 0;
        unint64_t v91 = 0;
        uint64_t v22 = a1[2];
        uint64_t v23 = CKRegisteredChunkItemID();
        if (mmcs_engine_file_path(v22, "tmpm", v23, &v91, (CFErrorRef *)&cf))
        {
          uint64_t v24 = open(v91, 0);
          if ((v24 & 0x80000000) != 0)
          {
            CFIndex v50 = *__error();
            CFTypeID v51 = (void *)CKRegisteredChunkSignatureCopyCString();
            char v52 = (char)v91;
            CKRegisteredChunkItemID();
            CFErrorRef file_error_with_format = mmcs_cferror_create_file_error_with_format(v50, @"Unable to open temporary file %s for item %lld while looking for chunk %s", v53, v54, v55, v56, v57, v58, v52);
            if (v51) {
              free(v51);
            }
          }
          else
          {
            int v25 = v24;
            CFNumberRef v26 = MMCSItemReaderWriterCreateWithFileDescriptor(v24, 0, 0, 0, &file_error_with_format);
            *CFIndex v13 = (uint64_t)v26;
            if (v26)
            {
              char v27 = 0;
              goto LABEL_50;
            }
            double Current = CFAbsoluteTimeGetCurrent();
            if (close(v25))
            {
              uint64_t v60 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
              {
                int v61 = *__error();
                uint64_t v62 = __error();
                uint64_t v63 = strerror(*v62);
                *(_DWORD *)buf = 67109634;
                *(_DWORD *)v94 = v25;
                *(_WORD *)&v94[4] = 1024;
                *(_DWORD *)&v94[6] = v61;
                *(_WORD *)&v94[10] = 2080;
                *(void *)&v94[12] = v63;
                _os_log_impl(&dword_1DC1CA000, v60, OS_LOG_TYPE_ERROR, "error closing file descriptor (%d) : posix error %d (%s)", buf, 0x18u);
              }
            }
            double v64 = CFAbsoluteTimeGetCurrent() - Current;
            if (v64 > 0.25)
            {
              uint64_t v65 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109376;
                *(_DWORD *)v94 = v25;
                *(_WORD *)&v94[4] = 2048;
                *(double *)&v94[6] = v64;
                _os_log_impl(&dword_1DC1CA000, v65, OS_LOG_TYPE_ERROR, "closing fd (%d) took %.3f seconds!", buf, 0x12u);
              }
            }
          }
        }
        else
        {
          CFRange v43 = (void *)CKRegisteredChunkSignatureCopyCString();
          CFTypeID v44 = (void *)cf;
          char v45 = CKRegisteredChunkItemID();
          CFErrorRef file_error_with_format = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 9, v44, @"Unable to open file descriptor for item %lld while looking for chunk %s", v46, v47, v48, v49, v45);
          if (v43) {
            free(v43);
          }
          if (cf) {
            CFRelease(cf);
          }
          CFTypeRef cf = 0;
        }
        char v27 = 1;
LABEL_50:
        if (v91) {
          free(v91);
        }
        if ((v27 & 1) == 0)
        {
LABEL_53:
          if (MMCSItemReaderWriterOpen(*v13, (CFTypeRef *)&file_error_with_format))
          {
            CFErrorRef v21 = 0;
            char v66 = 0;
            CFErrorRef v67 = file_error_with_format;
            if (file_error_with_format) {
              goto LABEL_62;
            }
            goto LABEL_63;
          }
          if (*v13) {
            C3BaseRelease((CFTypeRef)*v13);
          }
          *CFIndex v13 = 0;
        }
        goto LABEL_59;
      }
      if (CKRegisteredChunkLocation() == 114)
      {
        uint64_t v28 = a1[2];
        uint64_t v29 = mmcs_engine_owner(v28);
        uint64_t v30 = a1[3];
        uint64_t v31 = CKRegisteredChunkItemID();
        int item_reader_writer_for_item_callback = mmcs_engine_get_item_reader_writer_for_item_callback(v28, v29, v30, v31, v13, (CFTypeRef *)&file_error_with_format);
        uint64_t v33 = a1[8];
        if (item_reader_writer_for_item_callback)
        {
          if (!v33) {
            mmcs_local_chunk_satisfyer_perform_cold_4();
          }
          a1[7] = CKRegisteredChunkItemID();
          goto LABEL_53;
        }
        if (v33) {
          mmcs_local_chunk_satisfyer_perform_cold_3();
        }
        a1[7] = 0;
LABEL_59:
        CFErrorRef v42 = file_error_with_format;
        goto LABEL_60;
      }
      uint64_t v35 = (void *)CKRegisteredChunkSignatureCopyCString();
      uint64_t v36 = a1[7];
      CKRegisteredChunkLocation();
      CFErrorRef v42 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Source item %lld had invalid registered chunk location %c for chunk %s", v37, v38, v39, v40, v41, v36);
      CFErrorRef file_error_with_format = v42;
      if (v35) {
        free(v35);
      }
LABEL_60:
      if (!v42) {
        mmcs_local_chunk_satisfyer_perform_cold_1();
      }
      CFRetain(v42);
      char v66 = 1;
      CFErrorRef v21 = file_error_with_format;
      CFErrorRef v67 = file_error_with_format;
      if (file_error_with_format) {
LABEL_62:
      }
        CFRelease(v67);
LABEL_63:
      if (v66)
      {
        CFStringRef v68 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v69 = CKRegisteredChunkItemID();
          *(_DWORD *)buf = 134218242;
          *(void *)v94 = v69;
          *(_WORD *)&v94[8] = 2112;
          *(void *)&v94[10] = v21;
          _os_log_impl(&dword_1DC1CA000, v68, OS_LOG_TYPE_DEBUG, "Failed to get fd for item %lld : %@", buf, 0x16u);
        }
LABEL_70:
        int v34 = 0;
        if (!v21) {
          goto LABEL_72;
        }
        goto LABEL_71;
      }
LABEL_66:
      LOBYTE(file_error_with_format) = 0;
      int v70 = mmcs_local_chunk_satisfyer_copy_chunk((uint64_t)a1, a2, a3, (uint64_t)v16, a4, a5, a6, &file_error_with_format, &v88);
      if ((_BYTE)file_error_with_format)
      {
        CKRegisteredChunkItemID();
        CKUnregisterFile();
        mmcs_local_chunk_satisfyer_clear_source_fd_cache((uint64_t)a1);
      }
      if (v70) {
        break;
      }
      CFIndex v73 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
      {
        uint64_t v74 = CKRegisteredChunkItemID();
        *(_DWORD *)buf = 134218242;
        *(void *)v94 = v74;
        *(_WORD *)&v94[8] = 2114;
        *(void *)&v94[10] = v88;
        _os_log_impl(&dword_1DC1CA000, v73, OS_LOG_TYPE_ERROR, "Failed to write chunk to item %lld with error: %{public}@", buf, 0x16u);
      }
      int v34 = 1;
      if (!v21) {
        goto LABEL_72;
      }
LABEL_71:
      CFRelease(v21);
LABEL_72:
      char v71 = 0;
      if (!v34 && v17++ < v87) {
        continue;
      }
      goto LABEL_81;
    }
    if ((_BYTE)file_error_with_format) {
      goto LABEL_70;
    }
    int v34 = 0;
    char v71 = 1;
LABEL_81:
    if (v89) {
      free(v89);
    }
    v89 = 0;
    if (v34) {
      char v75 = 1;
    }
    else {
      char v75 = v71;
    }
    char v76 = v75 | v84;
    char v11 = 1;
    uint64_t v12 = 1;
  }
  while ((v76 & 1) == 0);
  if (!v34) {
    goto LABEL_97;
  }
  CFTypeRef v77 = v88;
  if (!v88) {
    mmcs_local_chunk_satisfyer_perform_cold_2();
  }
  if (a7)
  {
    CFRetain(v88);
    uint64_t v78 = 0;
    CFTypeRef v77 = v88;
    *a7 = v88;
    if (!v77) {
      return v78;
    }
  }
  else
  {
    uint64_t v78 = 0;
  }
LABEL_98:
  CFRelease(v77);
  return v78;
}

uint64_t mmcs_local_chunk_satisfyer_copy_chunk(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, unint64_t a7, unsigned char *a8, void *a9)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  if (a8) {
    *a8 = 0;
  }
  if (a9) {
    *a9 = 0;
  }
  uint64_t v71 = CKRegisteredChunkItemID();
  CFTypeRef v75 = 0;
  if (*(unsigned char *)(a2 + 48)) {
    mmcs_local_chunk_satisfyer_copy_chunk_cold_3();
  }
  uint64_t v15 = mmcs_chunk_instance_chunk_coder_create(a2, a5);
  if (!v15)
  {
    char v27 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"Error creating chunk coder for chunkInstance.", v16, v17, v18, v19, v20, v67);
LABEL_89:
    uint64_t v65 = 1;
    goto LABEL_90;
  }
  CFErrorRef v21 = (const void *)v15;
  uint64_t v69 = a2;
  int v70 = a8;
  unint64_t v22 = CKRegisteredChunkLength();
  uint64_t v23 = CKRegisteredChunkOffset();
  unint64_t v24 = CKRegisteredChunkOffset();
  while (1)
  {
    if (v22 >= a7) {
      uint64_t v25 = a7;
    }
    else {
      uint64_t v25 = v22;
    }
    unint64_t v74 = 0;
    if (!MMCSItemReaderWriterRead(*(void *)(a1 + 64), v23, a6, v25, (uint64_t)&v74, (CFErrorRef *)&v75))
    {
      int v28 = 0;
      char v27 = 0;
      int v26 = 1;
      goto LABEL_43;
    }
    if (!v74) {
      break;
    }
    CKChunkCoderUpdate();
    CFTypeRef v72 = 0;
    unint64_t v73 = 0;
    MMCSItemReaderWriterWrite(*(void *)(a1 + 32), *(uint64_t ***)(a1 + 40), v24, a6, v74, &v73, &v72);
    if (v72)
    {
      uint64_t v38 = *__error();
      uint64_t v39 = (void *)CKRegisteredChunkSignatureCopyCString();
      uint64_t v40 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v41 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFErrorRef v42 = strerror(v38);
        CFStringRef v43 = CFStringCreateWithFormat(v41, 0, @"Chunk %s could not be written: %s(%d)", v39, v42, v38);
        CFTypeID v44 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138543362;
          CFStringRef v77 = v43;
          _os_log_impl(&dword_1DC1CA000, v44, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v43) {
          CFRelease(v43);
        }
      }
      char v27 = (void *)v72;
      if (!v39) {
        goto LABEL_33;
      }
LABEL_32:
      free(v39);
LABEL_33:
      int v26 = 0;
      int v28 = 1;
      goto LABEL_43;
    }
    if (v73 != v74)
    {
      uint64_t v39 = (void *)CKRegisteredChunkSignatureCopyCString();
      char v45 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v51 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Chunk %s could not be completely written", v39);
        char v52 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138543362;
          CFStringRef v77 = v51;
          _os_log_impl(&dword_1DC1CA000, v52, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v51) {
          CFRelease(v51);
        }
      }
      char v27 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"Chunk %s could not be completely written", v46, v47, v48, v49, v50, (char)v39);
      if (!v39) {
        goto LABEL_33;
      }
      goto LABEL_32;
    }
    v24 += v73;
    v23 += v73;
    v22 -= v73;
    if (!v22)
    {
      int v26 = 0;
      char v27 = 0;
      int v28 = 0;
      BOOL v29 = 1;
      goto LABEL_44;
    }
  }
  char v27 = (void *)CKRegisteredChunkSignatureCopyCString();
  uint64_t v30 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v36 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Chunk %s was not found locally from item %lld which has been truncated. Unregistering item %lld", v27, v71, v71);
    uint64_t v37 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138543362;
      CFStringRef v77 = v36;
      _os_log_impl(&dword_1DC1CA000, v37, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v36) {
      CFRelease(v36);
    }
  }
  CFTypeRef v75 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"Chunk %s was not found locally from item %lld which has been truncated. Unregistering item %lld", v31, v32, v33, v34, v35, (char)v27);
  if (v27)
  {
    free(v27);
    int v28 = 0;
    char v27 = 0;
  }
  else
  {
    int v28 = 0;
  }
  int v26 = 1;
LABEL_43:
  BOOL v29 = v22 == 0;
LABEL_44:
  uint64_t v53 = CKRegisteredChunkSuccessorOffset();
  uint64_t v54 = v53;
  int v55 = v28 | v26;
  if (v28 | v26) {
    BOOL v56 = 0;
  }
  else {
    BOOL v56 = v29;
  }
  if (v24 != v53) {
    BOOL v56 = 0;
  }
  if (!v55 && !v56) {
    mmcs_local_chunk_satisfyer_copy_chunk_cold_2();
  }
  if (v26) {
    BOOL v57 = 0;
  }
  else {
    BOOL v57 = v29;
  }
  if (!v57) {
    goto LABEL_63;
  }
  LODWORD(v58) = CKChunkCoderFinish();
  if (!v58)
  {
    uint64_t v58 = (void *)CKRegisteredChunkSignatureCopyCString();
    v59 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef cf = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Chunk %s was found locally from item %lld but the data does not match. Unregistering item %lld", v58, v71, v71);
      uint64_t v60 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138543362;
        CFStringRef v77 = cf;
        _os_log_impl(&dword_1DC1CA000, v60, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (cf) {
        CFRelease(cf);
      }
    }
    if (v58)
    {
      free(v58);
LABEL_63:
      LODWORD(v58) = 0;
    }
  }
  C3BaseRelease(v21);
  if (!v55 && v58 && v24 == v54)
  {
    if (gMMCS_DebugLevel >= 4)
    {
      int v61 = (__CFString *)CKRegisteredChunkSignatureCopyCString();
      uint64_t v62 = mmcs_logging_logger_chunk();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        CFStringRef v77 = v61;
        __int16 v78 = 2048;
        uint64_t v79 = v71;
        _os_log_impl(&dword_1DC1CA000, v62, OS_LOG_TYPE_DEFAULT, "Chunk %{public}s was found locally from item %lld", buf, 0x16u);
      }
      if (v61) {
        free(v61);
      }
    }
    *(void *)(a1 + 72) += CKRegisteredChunkLength();
    *(unsigned char *)(v69 + 48) = 1;
  }
  if (v26) {
    BOOL v63 = 1;
  }
  else {
    BOOL v63 = v58 == 0;
  }
  int v64 = v63;
  if (v70 && v64)
  {
    if (CKRegisteredChunkItemID() && CKRegisteredChunkItemID())
    {
      CKRegisteredChunkItemID();
      CKUnregisterFile();
    }
    *int v70 = 1;
  }
  if (!v28) {
    goto LABEL_89;
  }
  if (!v27) {
    mmcs_local_chunk_satisfyer_copy_chunk_cold_1();
  }
  if (a9)
  {
    CFRetain(v27);
    uint64_t v65 = 0;
    *a9 = v27;
  }
  else
  {
    uint64_t v65 = 0;
  }
LABEL_90:
  if (v75) {
    CFRelease(v75);
  }
  CFTypeRef v75 = 0;
  if (v27) {
    CFRelease(v27);
  }
  return v65;
}

void mmcs_local_chunk_satisfyer_clear_source_fd_cache(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2)
  {
    MMCSItemReaderWriterEnsureClosed(v2);
    uint64_t v3 = *(const void **)(a1 + 64);
    if (v3) {
      C3BaseRelease(v3);
    }
    *(void *)(a1 + 64) = 0;
  }
  *(void *)(a1 + 56) = 0;
}

uint64_t mmcs_external_chunk_satisfyer_perform(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, void *a6)
{
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex v13 = (const UInt8 *)CKRegisteredChunkSignature();
  uint64_t v14 = CKRegisteredChunkSignature();
  CFIndex v15 = mmcs_chunk_signature_size_with_scheme(v14);
  CFDataRef v16 = CFDataCreate(v12, v13, v15);
  if (!v16) {
    return 1;
  }
  CFDataRef v17 = v16;
  uint64_t v28 = 0;
  CFTypeRef cf = 0;
  uint64_t v18 = a1[2];
  uint64_t v19 = *(void **)(v18 + 152);
  uint64_t v20 = mmcs_engine_owner(v18);
  int ItemReaderWriterForChunkSignature = MMCSEngineClientContextGetItemReaderWriterForChunkSignature(v19, v20, a1[3], (uint64_t)v17, &v28, &cf);
  uint64_t v22 = v28;
  if (ItemReaderWriterForChunkSignature) {
    BOOL v23 = v28 == 0;
  }
  else {
    BOOL v23 = 1;
  }
  if (v23)
  {
    uint64_t v25 = 1;
  }
  else
  {
    a1[7] = 0;
    a1[8] = v22;
    uint64_t RegisteredChunk = mmcs_chunk_reference_create_RegisteredChunk();
    CKRegisteredChunkSetItemID();
    char v27 = 0;
    uint64_t v25 = mmcs_local_chunk_satisfyer_copy_chunk((uint64_t)a1, a2, a3, RegisteredChunk, 2, a4, a5, &v27, a6);
  }
  if (cf) {
    CFRelease(cf);
  }
  CFRelease(v17);
  return v25;
}

void _mmcs_local_chunk_satisfyerCFFinalize(uint64_t a1)
{
  mmcs_local_chunk_satisfyer_clear_source_fd_cache(a1);
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    MMCSEngineRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

BOOL _mmcs_local_chunk_satisfyerCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_local_chunk_satisfyerCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_local_chunk_satisfyerCFCopyDebugDescription()
{
  return 0;
}

CFStringRef mmcs_url_copy_query_value_for_tag(const __CFURL *a1, uint64_t a2)
{
  CFStringRef v2 = 0;
  if (!a1 || !a2) {
    return v2;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@=", a2);
  if (!v5) {
    return 0;
  }
  CFStringRef v6 = v5;
  CFStringRef String = CFURLCopyQueryString(a1, 0);
  if (!String)
  {
    CFRelease(v6);
    return 0;
  }
  CFStringRef v8 = String;
  CFRange v9 = CFStringFind(String, v6, 1uLL);
  if (v9.location == -1)
  {
    CFStringRef v13 = 0;
  }
  else
  {
    v16.length = CFStringGetLength(v8) - (v9.location + v9.length);
    result.CFIndex location = 0;
    result.length = 0;
    v16.CFIndex location = v9.location + v9.length;
    int v10 = CFStringFindWithOptions(v8, @"&", v16, 0, &result);
    CFIndex location = result.location;
    if (v10) {
      BOOL v12 = result.location == -1;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
      CFIndex location = CFStringGetLength(v8);
      result.CFIndex location = location;
      result.length = 0;
    }
    v17.length = location - (v9.location + v9.length);
    v17.CFIndex location = v9.location + v9.length;
    CFStringRef v13 = CFStringCreateWithSubstring(v4, v8, v17);
    if (v13)
    {
      CFStringRef v2 = CFURLCreateStringByReplacingPercentEscapes(v4, v13, &stru_1F363CBE8);
      goto LABEL_18;
    }
  }
  CFStringRef v2 = 0;
LABEL_18:
  CFRelease(v6);
  CFRelease(v8);
  if (v13) {
    CFRelease(v13);
  }
  return v2;
}

double chunkserver__chunk_info__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C2FF08;
  a1[3] = unk_1E6C2FF18;
  a1[4] = xmmword_1E6C2FF28;
  double result = dbl_1E6C2FEF8[0];
  *a1 = chunkserver__chunk_info__init_init_value;
  a1[1] = *(_OWORD *)dbl_1E6C2FEF8;
  return result;
}

double chunkserver__ford_info__init(uint64_t a1)
{
  double result = *(double *)&chunkserver__ford_info__init_init_value;
  *(_OWORD *)a1 = chunkserver__ford_info__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C2FF48;
  *(void *)(a1 + 32) = 0;
  return result;
}

double chunkserver__container_element__init(uint64_t a1)
{
  double result = *(double *)&chunkserver__container_element__init_init_value;
  *(_OWORD *)a1 = chunkserver__container_element__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)algn_1E6C2FF70;
  *(void *)(a1 + 32) = 0;
  return result;
}

double chunkserver__name_value_pair__init(uint64_t a1)
{
  double result = *(double *)&chunkserver__name_value_pair__init_init_value;
  *(_OWORD *)a1 = chunkserver__name_value_pair__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C2FF98;
  *(void *)(a1 + 32) = 0;
  return result;
}

double chunkserver__host_info__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 96) = xmmword_1E6C30010;
  *(_OWORD *)(a1 + 112) = unk_1E6C30020;
  *(_OWORD *)(a1 + 128) = xmmword_1E6C30030;
  *(void *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C2FFD0;
  *(_OWORD *)(a1 + 48) = unk_1E6C2FFE0;
  *(_OWORD *)(a1 + 64) = xmmword_1E6C2FFF0;
  *(_OWORD *)(a1 + 80) = unk_1E6C30000;
  double result = *(double *)&chunkserver__host_info__init_init_value;
  *(_OWORD *)a1 = chunkserver__host_info__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C2FFC0;
  return result;
}

double chunkserver__put_complete_at_edge_payload_trailer__init(_OWORD *a1)
{
  *a1 = chunkserver__put_complete_at_edge_payload_trailer__init_init_value;
  a1[1] = unk_1E6C30058;
  double result = 0.0;
  a1[2] = xmmword_1E6C30068;
  a1[3] = unk_1E6C30078;
  return result;
}

uint64_t chunkserver__put_complete_at_edge_payload_trailer__get_packed_size(void **a1)
{
  if (*a1 != &chunkserver__put_complete_at_edge_payload_trailer__descriptor) {
    chunkserver__put_complete_at_edge_payload_trailer__get_packed_size_cold_1();
  }
  return protobuf_c_message_get_packed_size((uint64_t)a1);
}

uint64_t chunkserver__put_complete_at_edge_payload_trailer__pack(void **a1, uint64_t a2)
{
  if (*a1 != &chunkserver__put_complete_at_edge_payload_trailer__descriptor) {
    chunkserver__put_complete_at_edge_payload_trailer__pack_cold_1();
  }
  return protobuf_c_message_pack((uint64_t)a1, a2);
}

void **chunkserver__put_complete_at_edge_payload_trailer__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__put_complete_at_edge_payload_trailer__descriptor) {
      chunkserver__put_complete_at_edge_payload_trailer__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__error_response__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C300A8;
  a1[3] = unk_1E6C300B8;
  a1[4] = xmmword_1E6C300C8;
  double result = dbl_1E6C30098[0];
  *a1 = chunkserver__error_response__init_init_value;
  a1[1] = *(_OWORD *)dbl_1E6C30098;
  return result;
}

void **chunkserver__error_response__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__error_response__descriptor) {
      chunkserver__error_response__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__file_error__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 32) = xmmword_1E6C300F8;
  *(_OWORD *)(a1 + 48) = unk_1E6C30108;
  *(void *)(a1 + 64) = 0;
  double result = dbl_1E6C300E8[0];
  *(_OWORD *)a1 = chunkserver__file_error__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)dbl_1E6C300E8;
  return result;
}

double chunkserver__file_success__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C30140;
  a1[3] = unk_1E6C30150;
  a1[4] = xmmword_1E6C30160;
  a1[5] = unk_1E6C30170;
  double result = *(double *)&chunkserver__file_success__init_init_value;
  *a1 = chunkserver__file_success__init_init_value;
  a1[1] = *(_OWORD *)algn_1E6C30130;
  return result;
}

double chunkserver__chunk_error_index__init(uint64_t a1)
{
  *(_OWORD *)a1 = chunkserver__chunk_error_index__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)algn_1E6C30190;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C301A0;
  *(void *)(a1 + 48) = 0;
  return result;
}

double chunkserver__file_chunk_error__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C301D8;
  a1[3] = unk_1E6C301E8;
  a1[4] = xmmword_1E6C301F8;
  double result = dbl_1E6C301C8[0];
  *a1 = chunkserver__file_chunk_error__init_init_value;
  a1[1] = *(_OWORD *)dbl_1E6C301C8;
  return result;
}

double chunkserver__storage_container_error__init(_OWORD *a1)
{
  *a1 = chunkserver__storage_container_error__init_init_value;
  a1[1] = unk_1E6C30218;
  double result = 0.0;
  a1[2] = xmmword_1E6C30228;
  return result;
}

double chunkserver__method_completion_info__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 128) = xmmword_1E6C302B8;
  *(_OWORD *)(a1 + 144) = unk_1E6C302C8;
  *(_OWORD *)(a1 + 160) = xmmword_1E6C302D8;
  *(void *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 64) = xmmword_1E6C30278;
  *(_OWORD *)(a1 + 80) = unk_1E6C30288;
  *(_OWORD *)(a1 + 96) = xmmword_1E6C30298;
  *(_OWORD *)(a1 + 112) = unk_1E6C302A8;
  *(_OWORD *)a1 = chunkserver__method_completion_info__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C30248;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30258;
  *(_OWORD *)(a1 + 48) = unk_1E6C30268;
  return result;
}

uint64_t chunkserver__method_completion_info__get_packed_size(void **a1)
{
  if (*a1 != &chunkserver__method_completion_info__descriptor) {
    chunkserver__method_completion_info__get_packed_size_cold_1();
  }
  return protobuf_c_message_get_packed_size((uint64_t)a1);
}

uint64_t chunkserver__method_completion_info__pack(void **a1, uint64_t a2)
{
  if (*a1 != &chunkserver__method_completion_info__descriptor) {
    chunkserver__method_completion_info__pack_cold_1();
  }
  return protobuf_c_message_pack((uint64_t)a1, a2);
}

void *chunkserver__method_completion_info__unpack(uint64_t (**a1)(), unint64_t a2, char *a3)
{
  return protobuf_c_message_unpack((uint64_t)&chunkserver__method_completion_info__descriptor, a1, a2, a3);
}

void **chunkserver__method_completion_info__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__method_completion_info__descriptor) {
      chunkserver__method_completion_info__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__method_completion_info_list__init(_OWORD *a1)
{
  *a1 = chunkserver__method_completion_info_list__init_init_value;
  a1[1] = unk_1E6C30300;
  double result = 0.0;
  a1[2] = xmmword_1E6C30310;
  a1[3] = unk_1E6C30320;
  return result;
}

uint64_t chunkserver__method_completion_info_list__get_packed_size(void **a1)
{
  if (*a1 != &chunkserver__method_completion_info_list__descriptor) {
    chunkserver__method_completion_info_list__get_packed_size_cold_1();
  }
  return protobuf_c_message_get_packed_size((uint64_t)a1);
}

uint64_t chunkserver__method_completion_info_list__pack(void **a1, uint64_t a2)
{
  if (*a1 != &chunkserver__method_completion_info_list__descriptor) {
    chunkserver__method_completion_info_list__pack_cold_1();
  }
  return protobuf_c_message_pack((uint64_t)a1, a2);
}

void **chunkserver__method_completion_info_list__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__method_completion_info_list__descriptor) {
      chunkserver__method_completion_info_list__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__file_chunk_list__chunking_profile__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30350;
  *(_OWORD *)(a1 + 48) = unk_1E6C30360;
  *(void *)(a1 + 64) = 0;
  double result = dbl_1E6C30340[0];
  *(_OWORD *)a1 = chunkserver__file_chunk_list__chunking_profile__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)dbl_1E6C30340;
  return result;
}

double chunkserver__file_chunk_list__init(_OWORD *a1)
{
  a1[4] = xmmword_1E6C303B8;
  a1[5] = unk_1E6C303C8;
  a1[6] = xmmword_1E6C303D8;
  a1[7] = unk_1E6C303E8;
  *a1 = chunkserver__file_chunk_list__init_init_value;
  a1[1] = unk_1E6C30388;
  double result = 0.0;
  a1[2] = xmmword_1E6C30398;
  a1[3] = unk_1E6C303A8;
  return result;
}

double chunkserver__file_chunk_lists__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30418;
  *(_OWORD *)(a1 + 48) = unk_1E6C30428;
  *(_OWORD *)(a1 + 64) = xmmword_1E6C30438;
  *(void *)(a1 + 80) = 0;
  double result = *(double *)&chunkserver__file_chunk_lists__init_init_value;
  *(_OWORD *)a1 = chunkserver__file_chunk_lists__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C30408;
  return result;
}

uint64_t chunkserver__file_chunk_lists__get_packed_size(void **a1)
{
  if (*a1 != &chunkserver__file_chunk_lists__descriptor) {
    chunkserver__file_chunk_lists__get_packed_size_cold_1();
  }
  return protobuf_c_message_get_packed_size((uint64_t)a1);
}

uint64_t chunkserver__file_chunk_lists__pack(void **a1, uint64_t a2)
{
  if (*a1 != &chunkserver__file_chunk_lists__descriptor) {
    chunkserver__file_chunk_lists__pack_cold_1();
  }
  return protobuf_c_message_pack((uint64_t)a1, a2);
}

double chunkserver__storage_container_chunk_list__container_upload_element__init(uint64_t a1)
{
  *(_OWORD *)a1 = chunkserver__storage_container_chunk_list__container_upload_element__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C30460;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30470;
  *(void *)(a1 + 48) = 0;
  return result;
}

double chunkserver__storage_container_chunk_list__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C304A8;
  a1[3] = unk_1E6C304B8;
  a1[4] = xmmword_1E6C304C8;
  double result = dbl_1E6C30498[0];
  *a1 = chunkserver__storage_container_chunk_list__init_init_value;
  a1[1] = *(_OWORD *)dbl_1E6C30498;
  return result;
}

double chunkserver__storage_container_chunk_lists__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 64) = xmmword_1E6C30518;
  *(_OWORD *)(a1 + 80) = unk_1E6C30528;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)a1 = chunkserver__storage_container_chunk_lists__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C304E8;
  double result = dbl_1E6C30508[0];
  *(_OWORD *)(a1 + 32) = xmmword_1E6C304F8;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)dbl_1E6C30508;
  return result;
}

void *chunkserver__storage_container_chunk_lists__unpack(uint64_t (**a1)(), unint64_t a2, char *a3)
{
  return protobuf_c_message_unpack((uint64_t)&chunkserver__storage_container_chunk_lists__descriptor, a1, a2, a3);
}

void **chunkserver__storage_container_chunk_lists__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__storage_container_chunk_lists__descriptor) {
      chunkserver__storage_container_chunk_lists__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__authorize_simulcast_response__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30560;
  *(_OWORD *)(a1 + 48) = unk_1E6C30570;
  *(void *)(a1 + 64) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = chunkserver__authorize_simulcast_response__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)algn_1E6C30550;
  return result;
}

void *chunkserver__authorize_simulcast_response__unpack(uint64_t (**a1)(), unint64_t a2, char *a3)
{
  return protobuf_c_message_unpack((uint64_t)&chunkserver__authorize_simulcast_response__descriptor, a1, a2, a3);
}

double chunkserver__storage_container_error_list__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 32) = xmmword_1E6C305A8;
  *(_OWORD *)(a1 + 48) = unk_1E6C305B8;
  *(void *)(a1 + 64) = 0;
  double result = dbl_1E6C30598[0];
  *(_OWORD *)a1 = chunkserver__storage_container_error_list__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)dbl_1E6C30598;
  return result;
}

void *chunkserver__storage_container_error_list__unpack(uint64_t (**a1)(), unint64_t a2, char *a3)
{
  return protobuf_c_message_unpack((uint64_t)&chunkserver__storage_container_error_list__descriptor, a1, a2, a3);
}

void **chunkserver__storage_container_error_list__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__storage_container_error_list__descriptor) {
      chunkserver__storage_container_error_list__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__file_checksum_authorization__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C305F0;
  a1[3] = unk_1E6C30600;
  a1[4] = xmmword_1E6C30610;
  a1[5] = unk_1E6C30620;
  double result = *(double *)&chunkserver__file_checksum_authorization__init_init_value;
  *a1 = chunkserver__file_checksum_authorization__init_init_value;
  a1[1] = unk_1E6C305E0;
  return result;
}

double chunkserver__file_checksum_authorization_list__init(uint64_t a1)
{
  *(_OWORD *)a1 = chunkserver__file_checksum_authorization_list__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C30640;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30650;
  *(void *)(a1 + 48) = 0;
  return result;
}

uint64_t chunkserver__file_checksum_authorization_list__get_packed_size(void **a1)
{
  if (*a1 != &chunkserver__file_checksum_authorization_list__descriptor) {
    chunkserver__file_checksum_authorization_list__get_packed_size_cold_1();
  }
  return protobuf_c_message_get_packed_size((uint64_t)a1);
}

uint64_t chunkserver__file_checksum_authorization_list__pack(void **a1, uint64_t a2)
{
  if (*a1 != &chunkserver__file_checksum_authorization_list__descriptor) {
    chunkserver__file_checksum_authorization_list__pack_cold_1();
  }
  return protobuf_c_message_pack((uint64_t)a1, a2);
}

void **chunkserver__file_checksum_authorization_list__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__file_checksum_authorization_list__descriptor) {
      chunkserver__file_checksum_authorization_list__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__container_element_reference__init(uint64_t a1)
{
  double result = *(double *)&chunkserver__container_element_reference__init_init_value;
  *(_OWORD *)a1 = chunkserver__container_element_reference__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C30678;
  *(void *)(a1 + 32) = 0;
  return result;
}

double chunkserver__file_checksum_chunk_references__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 64) = xmmword_1E6C306D0;
  *(_OWORD *)(a1 + 80) = unk_1E6C306E0;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)a1 = chunkserver__file_checksum_chunk_references__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C306A0;
  double result = dbl_1E6C306C0[0];
  *(_OWORD *)(a1 + 32) = xmmword_1E6C306B0;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)dbl_1E6C306C0;
  return result;
}

double chunkserver__file_checksum_storage_host_chunk_lists__init(uint64_t a1)
{
  *(_OWORD *)a1 = chunkserver__file_checksum_storage_host_chunk_lists__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C30708;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30718;
  *(void *)(a1 + 48) = 0;
  return result;
}

double chunkserver__file_groups__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 64) = xmmword_1E6C30770;
  *(_OWORD *)(a1 + 80) = unk_1E6C30780;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)a1 = chunkserver__file_groups__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C30740;
  double result = dbl_1E6C30760[0];
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30750;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)dbl_1E6C30760;
  return result;
}

void *chunkserver__file_groups__unpack(uint64_t (**a1)(), unint64_t a2, char *a3)
{
  return protobuf_c_message_unpack((uint64_t)&chunkserver__file_groups__descriptor, a1, a2, a3);
}

void **chunkserver__file_groups__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__file_groups__descriptor) {
      chunkserver__file_groups__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__storage_host_chunk_list__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C307B8;
  a1[3] = unk_1E6C307C8;
  a1[4] = xmmword_1E6C307D8;
  a1[5] = unk_1E6C307E8;
  double result = *(double *)&chunkserver__storage_host_chunk_list__init_init_value;
  *a1 = chunkserver__storage_host_chunk_list__init_init_value;
  a1[1] = unk_1E6C307A8;
  return result;
}

double chunkserver__chunk_key__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C30818;
  a1[3] = unk_1E6C30828;
  a1[4] = xmmword_1E6C30838;
  double result = dbl_1E6C30808[0];
  *a1 = chunkserver__chunk_key__init_init_value;
  a1[1] = *(_OWORD *)dbl_1E6C30808;
  return result;
}

double chunkserver__get_file_chunk_keys__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30868;
  *(_OWORD *)(a1 + 48) = unk_1E6C30878;
  *(void *)(a1 + 64) = 0;
  double result = dbl_1E6C30858[0];
  *(_OWORD *)a1 = chunkserver__get_file_chunk_keys__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)dbl_1E6C30858;
  return result;
}

double chunkserver__get_chunk_keys_request__init(_OWORD *a1)
{
  *a1 = chunkserver__get_chunk_keys_request__init_init_value;
  a1[1] = unk_1E6C308A0;
  double result = 0.0;
  a1[2] = xmmword_1E6C308B0;
  return result;
}

uint64_t chunkserver__get_chunk_keys_request__get_packed_size(void **a1)
{
  if (*a1 != &chunkserver__get_chunk_keys_request__descriptor) {
    chunkserver__get_chunk_keys_request__get_packed_size_cold_1();
  }
  return protobuf_c_message_get_packed_size((uint64_t)a1);
}

uint64_t chunkserver__get_chunk_keys_request__pack(void **a1, uint64_t a2)
{
  if (*a1 != &chunkserver__get_chunk_keys_request__descriptor) {
    chunkserver__get_chunk_keys_request__pack_cold_1();
  }
  return protobuf_c_message_pack((uint64_t)a1, a2);
}

void **chunkserver__get_chunk_keys_request__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__get_chunk_keys_request__descriptor) {
      chunkserver__get_chunk_keys_request__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__file_chunk_keys__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C308E0;
  a1[3] = unk_1E6C308F0;
  a1[4] = xmmword_1E6C30900;
  double result = 0.0;
  *a1 = chunkserver__file_chunk_keys__init_init_value;
  a1[1] = *(_OWORD *)algn_1E6C308D0;
  return result;
}

double chunkserver__get_chunk_keys_response__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C30930;
  a1[3] = unk_1E6C30940;
  a1[4] = xmmword_1E6C30950;
  double result = dbl_1E6C30920[0];
  *a1 = chunkserver__get_chunk_keys_response__init_init_value;
  a1[1] = *(_OWORD *)dbl_1E6C30920;
  return result;
}

void *chunkserver__get_chunk_keys_response__unpack(uint64_t (**a1)(), unint64_t a2, char *a3)
{
  return protobuf_c_message_unpack((uint64_t)&chunkserver__get_chunk_keys_response__descriptor, a1, a2, a3);
}

void **chunkserver__get_chunk_keys_response__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__get_chunk_keys_response__descriptor) {
      chunkserver__get_chunk_keys_response__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__put_file_chunk_keys__init(_OWORD *a1)
{
  a1[2] = xmmword_1E6C30980;
  a1[3] = unk_1E6C30990;
  a1[4] = xmmword_1E6C309A0;
  a1[5] = unk_1E6C309B0;
  double result = *(double *)&chunkserver__put_file_chunk_keys__init_init_value;
  *a1 = chunkserver__put_file_chunk_keys__init_init_value;
  a1[1] = *(_OWORD *)algn_1E6C30970;
  return result;
}

void **chunkserver__put_file_chunk_keys__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__put_file_chunk_keys__descriptor) {
      chunkserver__put_file_chunk_keys__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__put_chunk_keys_request__init(uint64_t a1)
{
  double result = *(double *)&chunkserver__put_chunk_keys_request__init_init_value;
  *(_OWORD *)a1 = chunkserver__put_chunk_keys_request__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)algn_1E6C309D0;
  *(void *)(a1 + 32) = 0;
  return result;
}

uint64_t chunkserver__put_chunk_keys_request__get_packed_size(void **a1)
{
  if (*a1 != &chunkserver__put_chunk_keys_request__descriptor) {
    chunkserver__put_chunk_keys_request__get_packed_size_cold_1();
  }
  return protobuf_c_message_get_packed_size((uint64_t)a1);
}

uint64_t chunkserver__put_chunk_keys_request__pack(void **a1, uint64_t a2)
{
  if (*a1 != &chunkserver__put_chunk_keys_request__descriptor) {
    chunkserver__put_chunk_keys_request__pack_cold_1();
  }
  return protobuf_c_message_pack((uint64_t)a1, a2);
}

void **chunkserver__put_chunk_keys_request__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__put_chunk_keys_request__descriptor) {
      chunkserver__put_chunk_keys_request__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__put_chunk_keys_response__init(uint64_t a1)
{
  *(_OWORD *)a1 = chunkserver__put_chunk_keys_response__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C309F8;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30A08;
  *(void *)(a1 + 48) = 0;
  return result;
}

void *chunkserver__put_chunk_keys_response__unpack(uint64_t (**a1)(), unint64_t a2, char *a3)
{
  return protobuf_c_message_unpack((uint64_t)&chunkserver__put_chunk_keys_response__descriptor, a1, a2, a3);
}

void **chunkserver__put_chunk_keys_response__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__put_chunk_keys_response__descriptor) {
      chunkserver__put_chunk_keys_response__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double chunkserver__clone_complete_request__init(uint64_t a1)
{
  double result = *(double *)&chunkserver__clone_complete_request__init_init_value;
  *(_OWORD *)a1 = chunkserver__clone_complete_request__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)algn_1E6C30A30;
  *(void *)(a1 + 32) = 0;
  return result;
}

uint64_t chunkserver__clone_complete_request__get_packed_size(void **a1)
{
  if (*a1 != &chunkserver__clone_complete_request__descriptor) {
    chunkserver__clone_complete_request__get_packed_size_cold_1();
  }
  return protobuf_c_message_get_packed_size((uint64_t)a1);
}

uint64_t chunkserver__clone_complete_request__pack(void **a1, uint64_t a2)
{
  if (*a1 != &chunkserver__clone_complete_request__descriptor) {
    chunkserver__clone_complete_request__pack_cold_1();
  }
  return protobuf_c_message_pack((uint64_t)a1, a2);
}

double chunkserver__clone_complete_response__init(uint64_t a1)
{
  *(_OWORD *)a1 = chunkserver__clone_complete_response__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C30A58;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C30A68;
  *(void *)(a1 + 48) = 0;
  return result;
}

void *chunkserver__clone_complete_response__unpack(uint64_t (**a1)(), unint64_t a2, char *a3)
{
  return protobuf_c_message_unpack((uint64_t)&chunkserver__clone_complete_response__descriptor, a1, a2, a3);
}

void **chunkserver__clone_complete_response__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &chunkserver__clone_complete_response__descriptor) {
      chunkserver__clone_complete_response__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

uint64_t mmcs_case_insensitive_set_create(void *a1, CFStringRef *a2, int64_t a3)
{
  *a1 = 0;
  uint64_t v6 = C3TypeRegister(&mmcs_case_insensitive_setGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v6, 0x10uLL);
  if (result)
  {
    CFStringRef v8 = (void *)result;
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    CFRange v9 = (CFLocaleRef *)(result + 16);
    CFLocaleRef v10 = CFLocaleCreate(0, @"en_US");
    *CFRange v9 = v10;
    if (!v10) {
      goto LABEL_18;
    }
    char v11 = (const void **)malloc_type_calloc(a3, 8uLL, 0x6004044C4A2DFuLL);
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (a3 < 1)
    {
      v8[3] = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v11, 0, MEMORY[0x1E4F1D548]);
    }
    else
    {
      CFIndex v13 = 0;
      do
      {
        if (*a2)
        {
          CFMutableDictionaryRef MutableCopy = CFStringCreateMutableCopy(v12, 0, *a2);
          if (MutableCopy)
          {
            CFIndex v15 = MutableCopy;
            CFStringLowercase(MutableCopy, *v9);
            v11[v13++] = v15;
          }
        }
        ++a2;
        --a3;
      }
      while (a3);
      v8[3] = CFSetCreate(v12, v11, v13, MEMORY[0x1E4F1D548]);
      if (v13 >= 1)
      {
        CFRange v16 = v11;
        do
        {
          if (*v16) {
            CFRelease(*v16);
          }
          *v16++ = 0;
          --v13;
        }
        while (v13);
      }
    }
    free(v11);
    if (v8[3])
    {
      *a1 = v8;
      return 1;
    }
    else
    {
LABEL_18:
      C3BaseRelease(v8);
      return 0;
    }
  }
  return result;
}

uint64_t mmcs_case_insensitive_set_contains(uint64_t a1, CFStringRef theString)
{
  if (!a1) {
    return 0;
  }
  if (!theString) {
    return 0;
  }
  CFMutableDictionaryRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theString);
  if (!MutableCopy) {
    return 0;
  }
  CFAllocatorRef v4 = MutableCopy;
  CFStringLowercase(MutableCopy, *(CFLocaleRef *)(a1 + 16));
  uint64_t v5 = CFSetContainsValue(*(CFSetRef *)(a1 + 24), v4);
  CFRelease(v4);
  return v5;
}

void _mmcs_case_insensitive_setCFFinalize(uint64_t a1)
{
  CFStringRef v2 = *(const void **)(a1 + 24);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)(a1 + 24) = 0;
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + 16) = 0;
}

BOOL _mmcs_case_insensitive_setCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_case_insensitive_setCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_case_insensitive_setCFCopyDebugDescription()
{
  return 0;
}

CFIndex mmcs_base64_encode_cfdata_to_cstring(CFIndex result)
{
  if (result)
  {
    CFDataRef v1 = (const __CFData *)result;
    uint64_t result = (CFIndex)CFDataGetBytePtr((CFDataRef)result);
    if (result)
    {
      CFIndex v2 = result;
      uint64_t result = CFDataGetLength(v1);
      if (result)
      {
        uint64_t v3 = result / 3;
        uint64_t v4 = result % 3 ? result % 3 + 1 : 0;
        uint64_t result = (CFIndex)malloc_type_calloc(1uLL, (4 * (result / 3) + 4 * (result % 3 != 0)) | 1, 0xBCE91E3EuLL);
        if (result)
        {
          uint64_t v5 = v4 + 4 * v3;
          uint64_t v6 = v5 + 3;
          if (v5 >= 0) {
            uint64_t v6 = v4 + 4 * v3;
          }
          uint64_t v7 = v6 >> 2;
          uint64_t v8 = (v4 & 3) != 0 ? v7 + 1 : v7;
          if (v8 >= 1)
          {
            uint64_t v9 = 0;
            uint64_t v10 = v5 - 1;
            char v11 = (unsigned __int8 *)(v2 + 1);
            CFIndex v12 = result + 1;
            while (1)
            {
              *(unsigned char *)(result + v9) = base64ValueLookupArray[(unint64_t)*(v11 - 1) >> 2];
              if (v10 == v9) {
                mmcs_base64_encode_cfdata_to_cstring_cold_1();
              }
              if (v5 - 2 == v9)
              {
                *(unsigned char *)(result + v10) = base64ValueLookupArray[16 * (*(v11 - 1) & 3)];
                uint64_t v10 = v9 + 2;
                char v14 = 61;
                goto LABEL_22;
              }
              *(unsigned char *)(v12 + v9) = base64ValueLookupArray[(16 * (*(v11 - 1) & 3)) | ((unint64_t)*v11 >> 4)];
              if (v5 - 3 == v9) {
                break;
              }
              CFIndex v13 = v12 + v9;
              *(unsigned char *)(v13 + 1) = base64ValueLookupArray[(4 * (*v11 & 0xF)) | ((unint64_t)v11[1] >> 6)];
              *(unsigned char *)(v13 + 2) = base64ValueLookupArray[v11[1] & 0x3F];
              v9 += 4;
              v11 += 3;
              if (!--v8) {
                return result;
              }
            }
            char v14 = base64ValueLookupArray[4 * (*v11 & 0xF)];
LABEL_22:
            *(unsigned char *)(result + v10) = v14;
            *(unsigned char *)(result + v9 + 3) = 61;
          }
        }
      }
    }
  }
  return result;
}

CFDataRef mmcs_base64_encoded_cstring_to_cfdata(const char *a1)
{
  size_t v2 = strlen(a1);
  if (v2)
  {
    unint64_t v3 = v2;
    size_t v4 = 0;
    while (1)
    {
      int v5 = a1[v4];
      if ((v5 - 48) >= 0xA && (v5 & 0xFFFFFFDF) - 65 >= 0x1A)
      {
        unsigned int v7 = v5 - 43;
        BOOL v8 = v7 > 0x34;
        uint64_t v9 = (1 << v7) & 0x10000000000015;
        if (v8 || v9 == 0) {
          break;
        }
      }
      if (v2 == ++v4)
      {
        size_t v4 = v2;
        break;
      }
    }
    if (v4)
    {
      unint64_t v11 = v4 & 3;
      uint64_t v12 = (v4 & 3) != 0 ? (v4 >> 2) + 1 : v4 >> 2;
      CFIndex v13 = (UInt8 *)malloc_type_calloc(1uLL, 3 * v12, 0xBC3E4984uLL);
      if (v13)
      {
        char v14 = v13;
        if (v12)
        {
          unint64_t v15 = 0;
          unint64_t v16 = v12 - 1;
          if (v11 <= 1) {
            uint64_t v17 = 1;
          }
          else {
            uint64_t v17 = v11;
          }
          if (v11) {
            uint64_t v18 = v17;
          }
          else {
            uint64_t v18 = 4;
          }
          CFIndex v36 = 3 * v12;
LABEL_27:
          uint64_t v19 = 3 * v15;
          int v37 = 0;
          if (v15 >= v16)
          {
            uint64_t v22 = 0;
            while (1)
            {
              int v23 = decimalValueFromBase64CString((uint64_t)a1, v3, v15, v22);
              *((unsigned char *)&v37 + v22) = v23;
              if (v23 == 255) {
                break;
              }
              if (v18 == ++v22)
              {
                switch(v11)
                {
                  case 1uLL:
                    uint64_t v28 = &v14[v19];
                    *(_WORD *)uint64_t v28 = 0;
                    v28[2] = 0;
                    CFIndex v29 = v36 - 3;
                    break;
                  case 2uLL:
                    uint64_t v30 = &v14[v19];
                    UInt8 *v30 = (4 * v37) | (BYTE1(v37) >> 4) & 3;
                    *(_WORD *)(v30 + 1) = 0;
                    CFIndex v29 = v36 - 2;
                    break;
                  case 3uLL:
                    uint64_t v31 = &v14[v19];
                    char v32 = BYTE1(v37);
                    *uint64_t v31 = (4 * v37) | (BYTE1(v37) >> 4) & 3;
                    v31[1] = (BYTE2(v37) >> 2) & 0xF | v14[v19 + 1] | (16 * v32);
                    v31[2] = 0;
                    CFIndex v29 = v36 - 1;
                    break;
                  default:
                    goto LABEL_36;
                }
                CFIndex v36 = v29;
LABEL_41:
                unint64_t v16 = v12 - 1;
                if (++v15 != v12) {
                  goto LABEL_27;
                }
                if (!v36) {
                  break;
                }
                CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                CFAllocatorRef v34 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
                return XCFDataCreateWithBytesNoCopy(v33, v14, v36, v34);
              }
            }
          }
          else
          {
            uint64_t v20 = 0;
            while (1)
            {
              int v21 = decimalValueFromBase64CString((uint64_t)a1, v3, v15, v20);
              *((unsigned char *)&v37 + v20) = v21;
              if (v21 == 255) {
                break;
              }
              if (++v20 == 4)
              {
LABEL_36:
                unint64_t v24 = &v14[v19];
                char v25 = BYTE1(v37);
                *unint64_t v24 = (4 * v37) | (BYTE1(v37) >> 4) & 3;
                char v26 = v14[v19 + 1] | (16 * v25);
                char v27 = BYTE2(v37);
                v24[1] = (BYTE2(v37) >> 2) & 0xF | v26;
                v24[2] = HIBYTE(v37) & 0x3F | v14[v19 + 2] | (v27 << 6);
                goto LABEL_41;
              }
            }
          }
        }
        free(v14);
      }
    }
  }
  return 0;
}

uint64_t decimalValueFromBase64CString(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 + 4 * a3;
  if (v4 >= a2) {
    return 0;
  }
  int v5 = *(unsigned __int8 *)(a1 + v4);
  unsigned __int8 v6 = v5 - 65;
  if ((v5 - 65) >= 0x1A)
  {
    if ((v5 - 97) <= 0x19) {
      return (v5 - 71);
    }
    if ((v5 - 48) <= 9) {
      return (v5 + 4);
    }
    if (v5 > 46)
    {
      if (v5 == 47 || v5 == 95) {
        return 63;
      }
      return -1;
    }
    unsigned __int8 v6 = 62;
    if (v5 != 43 && v5 != 45) {
      return -1;
    }
  }
  return v6;
}

uint64_t MMCSItemFDReaderWriterCreateWithFileDescriptor(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if ((a1 & 0x80000000) != 0)
  {
    unint64_t v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Attempted to create MMCSItemFDReaderWriter with invalid file descriptor (%d)", a1);
      unsigned __int8 v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        CFStringRef v8 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
    return 0;
  }
  else
  {
    uint64_t v2 = C3TypeRegister(&MMCSItemFDReaderWriterGetTypeID_typeID);
    uint64_t result = C3TypeCreateInstance_(0, v2, 8uLL);
    if (result) {
      *(_DWORD *)(result + 16) = a1;
    }
  }
  return result;
}

void *MMCSItemReaderWriterCreateWithPlainFileDescriptor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = MMCSItemFDReaderWriterCreateWithFileDescriptor(a1);
  if (!v7) {
    return 0;
  }
  CFStringRef v8 = (const void *)v7;
  v11[0] = 7;
  v11[1] = v7;
  v11[2] = a2;
  v11[3] = a3;
  v11[4] = C3BaseRetain;
  v11[5] = C3BaseRelease;
  v11[6] = MMCSItemFDReaderWriterStat1;
  v11[7] = MMCSItemFDReaderWriterOpen;
  v11[8] = MMCSItemFDReaderWriterRead;
  v11[9] = MMCSItemFDReaderWriterClose;
  v11[10] = MMCSItemFDReaderWriterGetCacheBlobWithName;
  v11[11] = MMCSItemFDReaderWriterSetCacheBlobWithName;
  v11[12] = MMCSItemFDReaderWriterInvalidate;
  v11[13] = MMCSItemFDReaderWriterWrite;
  v11[14] = MMCSItemFDReaderWriterCopyAndClearProperty;
  v11[15] = MMCSItemFDReaderWriterSeek;
  v11[16] = a4;
  v11[17] = MMCSItemFDReaderWriterCopyProperty;
  v11[18] = MMCSItemFDReaderWriterSync;
  v11[19] = MMCSItemFDReaderWriterValidated;
  uint64_t v9 = MMCSItemReaderWriterCreate(v11);
  C3BaseRelease(v8);
  return v9;
}

uint64_t MMCSItemFDReaderWriterStat1(uint64_t a1, uint64_t a2, __CFDictionary **a3, CFErrorRef *a4)
{
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  memset(&v33, 0, sizeof(v33));
  if (fstat(*(_DWORD *)(a2 + 16), &v33) == -1)
  {
    uint64_t v12 = __error();
    int v13 = *v12;
    CFErrorRef v14 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D160], *v12, 0);
    int v15 = *(_DWORD *)(a2 + 16);
    strerror(v13);
    error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 39, v14, @"Stating the fd (%d) readerWriter failed: %s", v16, v17, v18, v19, v15);
    if (v14) {
      CFRelease(v14);
    }
    CFMutableDictionaryRef Mutable = 0;
    if (a4)
    {
LABEL_27:
      CFRetain(error_with_underlying_error);
      *a4 = error_with_underlying_error;
    }
  }
  else
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      __darwin_ino64_t valuePtr = v33.st_size;
      CFNumberRef v9 = CFNumberCreate(v7, kCFNumberSInt64Type, &valuePtr);
      if (v9)
      {
        CFNumberRef v10 = v9;
        CFDictionaryAddValue(Mutable, @"kMMCSItemReaderWriterFileSize", v9);
        CFRelease(v10);
        int v11 = 1;
      }
      else
      {
        int v11 = 0;
      }
      __darwin_ino64_t valuePtr = v33.st_ino;
      CFNumberRef v22 = CFNumberCreate(v7, kCFNumberSInt64Type, &valuePtr);
      if (v22)
      {
        CFNumberRef v23 = v22;
        CFDictionaryAddValue(Mutable, @"kMMCSItemReaderWriterFileSystemFileNumber", v22);
        CFRelease(v23);
      }
      else
      {
        int v11 = 0;
      }
      __darwin_ino64_t valuePtr = v33.st_mtimespec.tv_sec;
      CFNumberRef v24 = CFNumberCreate(v7, kCFNumberSInt64Type, &valuePtr);
      if (v24)
      {
        CFNumberRef v25 = v24;
        CFDictionaryAddValue(Mutable, @"kMMCSItemReaderWriterFileModificationTime", v24);
        CFRelease(v25);
      }
      else
      {
        int v11 = 0;
      }
      __uint32_t st_gen = v33.st_gen;
      CFNumberRef v26 = CFNumberCreate(v7, kCFNumberSInt32Type, &st_gen);
      if (v26)
      {
        CFNumberRef v27 = v26;
        CFDictionaryAddValue(Mutable, @"kMMCSItemReaderWriterFileGenerationNumber", v26);
        CFRelease(v27);
        if (v11)
        {
          if (a3)
          {
            CFRetain(Mutable);
            error_with_underlying_CFErrorRef error = 0;
            *a3 = Mutable;
          }
          else
          {
            error_with_underlying_CFErrorRef error = 0;
          }
          uint64_t v28 = 1;
LABEL_34:
          CFRelease(Mutable);
          uint64_t v29 = v28;
          if (!error_with_underlying_error) {
            return v29;
          }
          goto LABEL_30;
        }
      }
      int v21 = @"MMCSItemFDReaderStat1 create number failed";
    }
    else
    {
      int v21 = @"MMCSItemFDReaderStat1 create statsDict";
    }
    error_with_underlying_CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 36, v21);
    if (a4) {
      goto LABEL_27;
    }
  }
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  if (Mutable) {
    goto LABEL_34;
  }
  if (error_with_underlying_error) {
LABEL_30:
  }
    CFRelease(error_with_underlying_error);
  return v29;
}

uint64_t MMCSItemFDReaderWriterOpen(uint64_t a1, uint64_t a2, CFErrorRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(a2 + 16) & 0x80000000) == 0) {
    return 1;
  }
  if (!a3) {
    return 0;
  }
  CFErrorRef v10 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"Opening the fd (%d) reader writer failed: invalid file descriptor", a4, a5, a6, a7, a8, *(_DWORD *)(a2 + 16));
  uint64_t result = 0;
  *a3 = v10;
  return result;
}

uint64_t MMCSItemFDReaderWriterRead(int a1, uint64_t a2, off_t a3, void *__buf, size_t __nbyte, ssize_t *a6, CFErrorRef *a7)
{
  ssize_t v10 = pread(*(_DWORD *)(a2 + 16), __buf, __nbyte, a3);
  if (v10 == -1)
  {
    uint64_t v12 = __error();
    if (a7)
    {
      int v13 = *v12;
      CFErrorRef v14 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D160], *v12, 0);
      int v15 = *(_DWORD *)(a2 + 16);
      strerror(v13);
      *a7 = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 39, v14, @"Reading from the fd (%d) readerWriter failed: %s", v16, v17, v18, v19, v15);
      if (v14) {
        CFRelease(v14);
      }
    }
    return 0;
  }
  else
  {
    *a6 = v10;
    return 1;
  }
}

uint64_t MMCSItemFDReaderWriterClose(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  int v3 = *(_DWORD *)(a2 + 16);
  if (v3 < 0) {
    return 1;
  }
  if (close(v3) == -1)
  {
    CFAllocatorRef v7 = __error();
    if (a3)
    {
      int v8 = *v7;
      CFErrorRef v9 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D160], *v7, 0);
      int v10 = *(_DWORD *)(a2 + 16);
      strerror(v8);
      *a3 = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 39, v9, @"Closing the fd (%d) reader failed: %s", v11, v12, v13, v14, v10);
      if (v9) {
        CFRelease(v9);
      }
    }
    uint64_t result = 0;
  }
  else
  {
    uint64_t result = 1;
  }
  *(_DWORD *)(a2 + 16) = -1;
  return result;
}

uint64_t MMCSItemFDReaderWriterGetCacheBlobWithName(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFErrorRef cf = 0;
  if (!a1) {
    MMCSItemFDReaderWriterGetCacheBlobWithName_cold_1();
  }
  if (!a2) {
    MMCSItemFDReaderWriterGetCacheBlobWithName_cold_2();
  }
  int v9 = *(_DWORD *)(a2 + 16);
  CFStringRef v10 = *(const __CFString **)(*(void *)(a1 + 24) + 24);
  if (v10) {
    CStringWithCFCFStringRef String = createCStringWithCFString(v10);
  }
  else {
    CStringWithCFCFStringRef String = 0;
  }
  if (v9 == -1)
  {
    uint64_t v17 = 0;
    CFErrorRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"MMCSItemFDReaderGetCacheBlobWithName fd==-1", a4, (uint64_t)a5, a6, a7, a8, v20);
    if (!CStringWithCFString) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v17 = CKGetCacheBlobFd();
  if (CStringWithCFString) {
LABEL_8:
  }
    free(CStringWithCFString);
LABEL_9:
  CFErrorRef v18 = cf;
  if (a5 && !v17)
  {
    if (!cf)
    {
      CFErrorRef v18 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"MMCSItemFDReaderGetCacheBlobWithName no error provided", v12, v13, v14, v15, v16, v20);
      CFErrorRef cf = v18;
    }
    CFRetain(v18);
    CFErrorRef v18 = cf;
    *a5 = cf;
  }
  if (v18) {
    CFRelease(v18);
  }
  return v17;
}

uint64_t MMCSItemFDReaderWriterSetCacheBlobWithName(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFErrorRef cf = 0;
  if (!a1) {
    MMCSItemFDReaderWriterSetCacheBlobWithName_cold_1();
  }
  if (!a2) {
    MMCSItemFDReaderWriterSetCacheBlobWithName_cold_2();
  }
  int v9 = *(_DWORD *)(a2 + 16);
  CFStringRef v10 = *(const __CFString **)(*(void *)(a1 + 24) + 24);
  if (v10) {
    CStringWithCFCFStringRef String = createCStringWithCFString(v10);
  }
  else {
    CStringWithCFCFStringRef String = 0;
  }
  if (v9 == -1)
  {
    uint64_t v17 = 0;
    CFErrorRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"MMCSItemFDReaderWriterSetCacheBlobWithName fd==-1", a4, (uint64_t)a5, a6, a7, a8, v20);
    if (!CStringWithCFString) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v17 = CKSetCacheBlobFd();
  if (CStringWithCFString) {
LABEL_8:
  }
    free(CStringWithCFString);
LABEL_9:
  CFErrorRef v18 = cf;
  if (a5 && !v17)
  {
    if (!cf)
    {
      CFErrorRef v18 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"MMCSItemFDReaderWriterSetCacheBlobWithName no error provided", v12, v13, v14, v15, v16, v20);
      CFErrorRef cf = v18;
    }
    CFRetain(v18);
    CFErrorRef v18 = cf;
    *a5 = cf;
  }
  if (v18) {
    CFRelease(v18);
  }
  return v17;
}

uint64_t MMCSItemFDReaderWriterWrite(int a1, uint64_t a2, off_t a3, void *__buf, size_t __nbyte, ssize_t *a6, CFErrorRef *a7)
{
  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 == -1) {
    MMCSItemFDReaderWriterWrite_cold_1();
  }
  ssize_t v11 = pwrite(v7, __buf, __nbyte, a3);
  if (v11 < 0)
  {
    uint64_t v13 = __error();
    if (a7)
    {
      int v14 = *v13;
      CFErrorRef v15 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D160], *v13, 0);
      int v16 = *(_DWORD *)(a2 + 16);
      strerror(v14);
      *a7 = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 39, v15, @"Writing to the fd (%d) readerWriter failed: %s", v17, v18, v19, v20, v16);
      if (v15) {
        CFRelease(v15);
      }
    }
    return 0;
  }
  else
  {
    *a6 = v11;
    return 1;
  }
}

CFNumberRef MMCSItemFDReaderWriterCopyAndClearProperty(int a1, uint64_t a2, CFStringRef theString1)
{
  if (CFStringCompare(theString1, @"kMMCSItemReaderWriterPropertyUnderlyingFileDescriptor", 0)) {
    return 0;
  }
  int v6 = *(_DWORD *)(a2 + 16);
  CFStringRef v5 = (_DWORD *)(a2 + 16);
  if (v6 == -1) {
    return 0;
  }
  CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, v5);
  _DWORD *v5 = -1;
  return result;
}

uint64_t MMCSItemFDReaderWriterSeek(int a1, uint64_t a2, off_t a3, CFErrorRef *a4)
{
  off_t v7 = lseek(*(_DWORD *)(a2 + 16), a3, 0);
  if (v7 == -1)
  {
    int v14 = __error();
    if (a4)
    {
      int v15 = *v14;
      CFErrorRef v16 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D160], *v14, 0);
      int v17 = *(_DWORD *)(a2 + 16);
      strerror(v15);
      *a4 = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 39, v16, @"Seeking from the fd (%d) readerWriter failed: %s", v18, v19, v20, v21, v17);
      if (v16) {
        CFRelease(v16);
      }
    }
  }
  else
  {
    if (v7 == a3) {
      return 1;
    }
    if (a4)
    {
      CFErrorRef v22 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"Seeking from the fd (%d) readerWriter failed. Offset requested %lld. Offset returned %lld.", v8, v9, v10, v11, v12, *(_DWORD *)(a2 + 16));
      uint64_t result = 0;
      *a4 = v22;
      return result;
    }
  }
  return 0;
}

uint64_t MMCSItemFDReaderWriterCopyProperty()
{
  return 0;
}

uint64_t MMCSItemFDReaderWriterSync(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  if (!fcntl(*(_DWORD *)(a2 + 16), 51)) {
    return 1;
  }
  if (!a3) {
    return 0;
  }
  int v5 = *(_DWORD *)(a2 + 16);
  __error();
  int v6 = __error();
  strerror(*v6);
  CFErrorRef v12 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"fcntl F_FULLFSYNC for fd (%d) readerWriter failed. %d %s"), v7, v8, v9, v10, v11, v5);
  uint64_t result = 0;
  *a3 = v12;
  return result;
}

uint64_t MMCSItemFDReaderWriterValidated()
{
  return 1;
}

void _MMCSItemFDReaderWriterCFFinalize(uint64_t a1)
{
  *(void *)&v14[7] = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)(a1 + 16) & 0x80000000) == 0)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    if (close(*(_DWORD *)(a1 + 16)))
    {
      int v3 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        int v4 = *(_DWORD *)(a1 + 16);
        int v5 = *__error();
        int v6 = __error();
        uint64_t v7 = strerror(*v6);
        int v11 = 67109634;
        int v12 = v4;
        __int16 v13 = 1024;
        *(_DWORD *)int v14 = v5;
        v14[2] = 2080;
        *(void *)&v14[3] = v7;
        _os_log_impl(&dword_1DC1CA000, v3, OS_LOG_TYPE_ERROR, "error closing file descriptor (%d) : posix error %d (%s)", (uint8_t *)&v11, 0x18u);
      }
    }
    double v8 = CFAbsoluteTimeGetCurrent() - Current;
    if (v8 > 0.25)
    {
      uint64_t v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        int v10 = *(_DWORD *)(a1 + 16);
        int v11 = 67109376;
        int v12 = v10;
        __int16 v13 = 2048;
        *(double *)int v14 = v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "closing fd (%d) took %.3f seconds!", (uint8_t *)&v11, 0x12u);
      }
    }
    *(_DWORD *)(a1 + 16) = -1;
  }
}

BOOL _MMCSItemFDReaderWriterCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _MMCSItemFDReaderWriterCFCopyFormatDescription()
{
  return 0;
}

uint64_t _MMCSItemFDReaderWriterCFCopyDebugDescription()
{
  return 0;
}

void mmcs_operation_metric_reference_time()
{
  if (*(double *)&mmcs_operation_metric_reference_time_origin == 0.0) {
    mmcs_operation_metric_reference_time_origin = CFAbsoluteTimeGetCurrent();
  }
}

void mmcs_operation_metric_increment_uint64_dictionary_key(void *a1, void *a2, uint64_t a3)
{
  if (a1 && a2)
  {
    id v5 = a2;
    id v6 = a1;
    uint64_t v7 = [v6 objectForKeyedSubscript:v5];
    uint64_t v8 = [v7 unsignedLongLongValue];

    id v9 = [NSNumber numberWithUnsignedLongLong:v8 + a3];
    [v6 setObject:v9 forKeyedSubscript:v5];
  }
}

void mmcs_operation_metric_test()
{
  uint64_t v0 = [MEMORY[0x1E4F1CA48] array];
  CFDataRef v1 = create(1, 0.0, 1.0);
  [v0 addObject:v1];

  uint64_t v2 = [MMCSOperationMetric alloc];
  int v3 = [MEMORY[0x1E4F1C9C8] date];
  int v4 = [(MMCSOperationMetric *)v2 initWithDate:v3];

  id v5 = MMCSOperationStateTimeRangeMergedRanges(v4, v0);
  if ([v5 count] != 1) {
    mmcs_operation_metric_test_cold_38();
  }
  id v6 = [v5 firstObject];
  [v6 relativeStart];
  if (v7 != 0.0) {
    mmcs_operation_metric_test_cold_1();
  }
  [v6 duration];
  if (v8 != 1.0) {
    mmcs_operation_metric_test_cold_2();
  }
  id v9 = MMCSOperationStateTimeRangeMergedRanges(0, v0);

  if (!v9) {
    mmcs_operation_metric_test_cold_3();
  }
  if ([v9 count]) {
    mmcs_operation_metric_test_cold_37();
  }
  int v10 = MMCSOperationStateTimeRangeMergedRanges(v4, 0);

  if (!v10) {
    mmcs_operation_metric_test_cold_4();
  }
  if ([v10 count]) {
    mmcs_operation_metric_test_cold_36();
  }
  int v11 = MMCSOperationStateTimeRangeMergedRanges(0, 0);

  if (!v11) {
    mmcs_operation_metric_test_cold_5();
  }
  if ([v11 count]) {
    mmcs_operation_metric_test_cold_35();
  }
  int v12 = [MEMORY[0x1E4F1CA48] array];

  __int16 v13 = create(1, 0.0, 1.0);
  [v12 addObject:v13];

  int v14 = create(1, 2.0, 1.0);
  [v12 addObject:v14];

  int v15 = MMCSOperationStateTimeRangeMergedRanges(v4, v12);

  if ([v15 count] != 2) {
    mmcs_operation_metric_test_cold_34();
  }
  CFErrorRef v16 = [v15 firstObject];

  [v16 relativeStart];
  if (v17 != 0.0) {
    mmcs_operation_metric_test_cold_6();
  }
  [v16 duration];
  if (v18 != 1.0) {
    mmcs_operation_metric_test_cold_7();
  }
  uint64_t v19 = [v15 objectAtIndexedSubscript:1];

  [v19 relativeStart];
  if (v20 != 2.0) {
    mmcs_operation_metric_test_cold_8();
  }
  [v19 duration];
  if (v21 != 1.0) {
    mmcs_operation_metric_test_cold_9();
  }
  CFErrorRef v22 = [MEMORY[0x1E4F1CA48] array];

  CFNumberRef v23 = create(1, 0.0, 1.0);
  [v22 addObject:v23];

  CFNumberRef v24 = create(1, 1.0, 1.0);
  [v22 addObject:v24];

  CFNumberRef v25 = MMCSOperationStateTimeRangeMergedRanges(v4, v22);

  if ([v25 count] != 1) {
    mmcs_operation_metric_test_cold_33();
  }
  CFNumberRef v26 = [v25 firstObject];

  [v26 relativeStart];
  if (v27 != 0.0) {
    mmcs_operation_metric_test_cold_10();
  }
  [v26 duration];
  if (v28 != 2.0) {
    mmcs_operation_metric_test_cold_11();
  }
  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];

  uint64_t v30 = create(1, 0.0, 1.0);
  [v29 addObject:v30];

  uint64_t v31 = create(1, 0.5, 1.0);
  [v29 addObject:v31];

  char v32 = MMCSOperationStateTimeRangeMergedRanges(v4, v29);

  if ([v32 count] != 1) {
    mmcs_operation_metric_test_cold_32();
  }
  stat v33 = [v32 firstObject];

  [v33 relativeStart];
  if (v34 != 0.0) {
    mmcs_operation_metric_test_cold_12();
  }
  [v33 duration];
  if (v35 != 1.5) {
    mmcs_operation_metric_test_cold_13();
  }

  CFIndex v36 = [MMCSOperationMetric alloc];
  int v37 = [MEMORY[0x1E4F1C9C8] date];
  uint64_t v38 = [(MMCSOperationMetric *)v36 initWithDate:v37];

  uint64_t v39 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v40 = [MEMORY[0x1E4F1CA48] array];
  CFAllocatorRef v41 = create(0, 0.5, 1.0);
  [v40 addObject:v41];

  CFErrorRef v42 = create(1, 0.0, 1.0);
  [v39 addObject:v42];

  CFStringRef v43 = MMCSOperationStateTimeRangeFilteredRanges(v38, v40, v39);
  if ([v43 count] != 1) {
    mmcs_operation_metric_test_cold_31();
  }
  CFTypeID v44 = [v43 firstObject];
  [v44 relativeStart];
  if (v45 != 1.0) {
    mmcs_operation_metric_test_cold_14();
  }
  [v44 duration];
  if (v46 != 0.5) {
    mmcs_operation_metric_test_cold_15();
  }
  uint64_t v47 = [MEMORY[0x1E4F1CA48] array];

  uint64_t v48 = [MEMORY[0x1E4F1CA48] array];

  uint64_t v49 = create(0, 0.5, 1.0);
  [v48 addObject:v49];

  uint64_t v50 = create(1, 1.0, 0.25);
  [v47 addObject:v50];

  CFStringRef v51 = MMCSOperationStateTimeRangeFilteredRanges(v38, v48, v47);

  if ([v51 count] != 2) {
    mmcs_operation_metric_test_cold_30();
  }
  char v52 = [v51 objectAtIndexedSubscript:0];

  [v52 relativeStart];
  if (v53 != 0.5) {
    mmcs_operation_metric_test_cold_16();
  }
  [v52 duration];
  if (v54 != 0.5) {
    mmcs_operation_metric_test_cold_17();
  }
  int v55 = [v51 objectAtIndexedSubscript:1];

  [v55 relativeStart];
  if (v56 != 1.25) {
    mmcs_operation_metric_test_cold_18();
  }
  [v55 duration];
  if (v57 != 0.25) {
    mmcs_operation_metric_test_cold_19();
  }
  uint64_t v58 = [MEMORY[0x1E4F1CA48] array];

  v59 = [MEMORY[0x1E4F1CA48] array];

  uint64_t v60 = create(0, 0.5, 1.0);
  [v59 addObject:v60];

  int v61 = create(1, 1.0, 1.0);
  [v58 addObject:v61];

  uint64_t v62 = MMCSOperationStateTimeRangeFilteredRanges(v38, v59, v58);

  if ([v62 count] != 1) {
    mmcs_operation_metric_test_cold_29();
  }
  BOOL v63 = [v62 firstObject];

  [v63 relativeStart];
  if (v64 != 0.5) {
    mmcs_operation_metric_test_cold_20();
  }
  [v63 duration];
  if (v65 != 0.5) {
    mmcs_operation_metric_test_cold_21();
  }
  char v66 = [MEMORY[0x1E4F1CA48] array];

  char v67 = [MEMORY[0x1E4F1CA48] array];

  CFStringRef v68 = create(0, 0.5, 1.0);
  [v67 addObject:v68];

  uint64_t v69 = create(1, 0.0, 2.0);
  [v66 addObject:v69];

  int v70 = MMCSOperationStateTimeRangeFilteredRanges(v38, v67, v66);

  if ([v70 count]) {
    mmcs_operation_metric_test_cold_28();
  }
  uint64_t v71 = [MEMORY[0x1E4F1CA48] array];

  CFTypeRef v72 = [MEMORY[0x1E4F1CA48] array];

  unint64_t v73 = create(0, 0.5, 1.0);
  [v72 addObject:v73];

  unint64_t v74 = create(1, 0.0, 0.25);
  [v71 addObject:v74];

  CFTypeRef v75 = MMCSOperationStateTimeRangeFilteredRanges(v38, v72, v71);

  if ([v75 count] != 1) {
    mmcs_operation_metric_test_cold_27();
  }
  char v76 = [v75 firstObject];

  [v76 relativeStart];
  if (v77 != 0.5) {
    mmcs_operation_metric_test_cold_22();
  }
  [v76 duration];
  if (v78 != 1.0) {
    mmcs_operation_metric_test_cold_23();
  }
  uint64_t v79 = [MEMORY[0x1E4F1CA48] array];

  id v86 = [MEMORY[0x1E4F1CA48] array];

  uint64_t v80 = create(0, 0.5, 1.0);
  [v86 addObject:v80];

  v81 = create(1, 2.0, 0.25);
  [v79 addObject:v81];

  v82 = MMCSOperationStateTimeRangeFilteredRanges(v38, v86, v79);

  if ([v82 count] != 1) {
    mmcs_operation_metric_test_cold_26();
  }
  CFStringRef v83 = [v82 firstObject];

  [v83 relativeStart];
  if (v84 != 0.5) {
    mmcs_operation_metric_test_cold_24();
  }
  [v83 duration];
  if (v85 != 1.0) {
    mmcs_operation_metric_test_cold_25();
  }
}

MMCSOperationMetric *mmcs_metrics_create_metric_object(uint64_t a1)
{
  if (a1 && (uint64_t v2 = *(const void **)(a1 + 16)) != 0)
  {
    int v3 = CFEqual(@"put", v2);
    int v4 = *(const void **)(a1 + 16);
    if (v3)
    {
      BOOL v5 = 1;
      if (!v4) {
        goto LABEL_7;
      }
LABEL_49:
      if (CFEqual(@"get", v4)) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = CFEqual(@"getSection", *(CFTypeRef *)(a1 + 16)) != 0;
      }
      goto LABEL_8;
    }
    BOOL v5 = CFEqual(@"putSection", v4) != 0;
    int v4 = *(const void **)(a1 + 16);
    if (v4) {
      goto LABEL_49;
    }
  }
  else
  {
    BOOL v5 = 0;
  }
LABEL_7:
  BOOL v6 = 0;
LABEL_8:
  double v7 = [MMCSOperationMetric alloc];
  double v8 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:*(double *)(a1 + 32)];
  id v9 = [(MMCSOperationMetric *)v7 initWithDate:v8];

  double v10 = *(double *)(a1 + 32);
  double v11 = *(double *)(a1 + 40);
  BOOL v13 = v11 <= 0.0 || v10 <= 0.0 || v10 > v11;
  double v14 = v11 - v10;
  if (v13) {
    double v14 = 0.0;
  }
  [(MMCSOperationMetric *)v9 setDuration:v14];
  if (*(void *)(a1 + 136))
  {
    int v15 = [MEMORY[0x1E4F1CA48] array];
    CFArrayRef v16 = *(const __CFArray **)(a1 + 136);
    v33.length = CFArrayGetCount(v16);
    v33.CFIndex location = 0;
    CFArrayApplyFunction(v16, v33, (CFArrayApplierFunction)add_chunking_metric, v15);
    if ([v15 count]) {
      MMCSOperationMetricCombineMetrics(v9, v15);
    }
  }
  if (*(void *)(a1 + 72))
  {
    double v17 = [MEMORY[0x1E4F1CA48] array];
    CFArrayRef v18 = *(const __CFArray **)(a1 + 72);
    v34.length = CFArrayGetCount(v18);
    v34.CFIndex location = 0;
    CFArrayApplyFunction(v18, v34, (CFArrayApplierFunction)add_http_metric, v17);
    if ([v17 count]) {
      MMCSOperationMetricCombineMetrics(v9, v17);
    }
  }
  if (*(void *)(a1 + 80))
  {
    uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
    CFArrayRef v20 = *(const __CFArray **)(a1 + 80);
    v35.length = CFArrayGetCount(v20);
    v35.CFIndex location = 0;
    CFArrayApplyFunction(v20, v35, (CFArrayApplierFunction)add_http_metric, v19);
    if ([v19 count]) {
      MMCSOperationMetricCombineMetrics(v9, v19);
    }
  }
  if (*(void *)(a1 + 88)) {
    BOOL v21 = v5;
  }
  else {
    BOOL v21 = 0;
  }
  if (v21)
  {
    CFErrorRef v22 = [MEMORY[0x1E4F1CA48] array];
    CFArrayRef v23 = *(const __CFArray **)(a1 + 88);
    v36.length = CFArrayGetCount(v23);
    v36.CFIndex location = 0;
    CFArrayApplyFunction(v23, v36, (CFArrayApplierFunction)add_http_metric, v22);
    CFNumberRef v24 = [(MMCSOperationMetric *)v9 ranges];
    CFNumberRef v25 = v24;
    if (v24 && [v24 count])
    {
      CFNumberRef v26 = [v25 lastObject];
      if ([v22 count])
      {
        unint64_t v27 = 0;
        do
        {
          double v28 = [v22 objectAtIndexedSubscript:v27];
          [v28 absoluteStop];
          double v30 = v29;
          [v26 absoluteStop];
          if (v30 >= v31) {
            ++v27;
          }
          else {
            [v22 removeObjectAtIndex:v27];
          }
        }
        while (v27 < [v22 count]);
      }
    }
    else
    {
      CFNumberRef v26 = 0;
    }
    if ([v22 count]) {
      MMCSOperationMetricCombineMetrics(v9, v22);
    }
  }
  if (v6)
  {
    [(MMCSOperationMetric *)v9 setBytesFulfilledByPeers:*(void *)(a1 + 104)];
    [(MMCSOperationMetric *)v9 setBytesFulfilledLocally:*(void *)(a1 + 112)];
    [(MMCSOperationMetric *)v9 setBytesResumed:*(void *)(a1 + 120)];
  }
  [(MMCSOperationMetric *)v9 rangesCompleted];
  return v9;
}

void add_chunking_metric(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(double *)(a1 + 48) > 0.0 && !*(unsigned char *)(a1 + 72) && !*(void *)(a1 + 64))
  {
    id v16 = v3;
    int v4 = [MMCSOperationMetric alloc];
    BOOL v5 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:*(double *)(a1 + 48)];
    BOOL v6 = [(MMCSOperationMetric *)v4 initWithDate:v5];

    double v7 = *(double *)(a1 + 48);
    double v8 = *(double *)(a1 + 56);
    BOOL v10 = v8 <= 0.0 || v7 <= 0.0 || v7 > v8;
    double v11 = v8 - v7;
    if (v10) {
      double v11 = 0.0;
    }
    [(MMCSOperationMetric *)v6 setDuration:v11];
    id v12 = *(id *)(a1 + 40);
    BOOL v13 = [(MMCSOperationMetric *)v6 totalBytesByChunkProfile];
    mmcs_operation_metric_increment_uint64_dictionary_key(v13, v12, *(void *)(a1 + 24));

    double v14 = [(MMCSOperationMetric *)v6 chunkCountByChunkProfile];
    mmcs_operation_metric_increment_uint64_dictionary_key(v14, v12, *(void *)(a1 + 32));

    int v15 = [(MMCSOperationMetric *)v6 fileCountByChunkProfile];
    mmcs_operation_metric_increment_uint64_dictionary_key(v15, v12, 1);

    [v16 addObject:v6];
    id v3 = v16;
  }
}

void add_http_metric(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = a1[3];
  if (*(double *)(v4 + 56) > 0.0)
  {
    id v29 = v3;
    BOOL v5 = [MMCSOperationMetric alloc];
    BOOL v6 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:*(double *)(a1[3] + 56)];
    double v7 = [(MMCSOperationMetric *)v5 initWithDate:v6];

    double v8 = *(double *)(v4 + 56);
    double v9 = 0.0;
    if (*(_DWORD *)(v4 + 224))
    {
      double v10 = *(double *)(v4 + 232);
      BOOL v12 = v8 <= 0.0 || v10 <= 0.0 || v10 > v8;
      double v13 = v8 - v10;
      if (v12) {
        double v14 = 0.0;
      }
      else {
        double v14 = v13;
      }
      if (v14 > 0.0)
      {
        int v15 = [MMCSOperationStateTimeRange alloc];
        id v16 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:*(double *)(v4 + 232)];
        double v17 = [(MMCSOperationStateTimeRange *)v15 initWithOperationState:0 startDate:v16 duration:v14];

        [(MMCSOperationMetric *)v7 addRange:v17];
        double v8 = *(double *)(v4 + 56);
      }
    }
    else
    {
      double v14 = 0.0;
    }
    double v18 = *(double *)(v4 + 104);
    BOOL v20 = v18 <= 0.0 || v8 <= 0.0 || v8 > v18;
    double v21 = v18 - v8;
    if (!v20) {
      double v9 = v21;
    }
    if (v9 > 0.0)
    {
      CFErrorRef v22 = [MMCSOperationStateTimeRange alloc];
      CFArrayRef v23 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:*(double *)(v4 + 56)];
      CFNumberRef v24 = [(MMCSOperationStateTimeRange *)v22 initWithOperationState:1 startDate:v23 duration:v9];

      [(MMCSOperationMetric *)v7 addRange:v24];
    }
    [(MMCSOperationMetric *)v7 setDuration:v14 + v9];
    [(MMCSOperationMetric *)v7 rangesCompleted];
    if (*(uint64_t *)(v4 + 112) >= 1) {
      -[MMCSOperationMetric setBytesUploaded:](v7, "setBytesUploaded:");
    }
    if (*(_DWORD *)(v4 + 168)) {
      [(MMCSOperationMetric *)v7 setBytesDownloaded:*(void *)(v4 + 176)];
    }
    [(MMCSOperationMetric *)v7 setConnections:1];
    [(MMCSOperationMetric *)v7 setConnectionsCreated:*(_DWORD *)(a1[7] + 44) == 0];
    CFUUIDRef v25 = (const __CFUUID *)a1[5];
    if (v25)
    {
      CFStringRef v26 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v25);
      if (v26)
      {
        CFStringRef v27 = v26;
        double v28 = [(MMCSOperationMetric *)v7 requestUUIDs];
        [v28 addObject:v27];

        CFRelease(v27);
      }
    }
    [v29 addObject:v7];

    id v3 = v29;
  }
}

MMCSOperationStateTimeRange *create(uint64_t a1, double a2, double a3)
{
  BOOL v6 = [MMCSOperationStateTimeRange alloc];
  double v7 = (void *)MEMORY[0x1E4F1C9C8];
  double Current = *(double *)&mmcs_operation_metric_reference_time_origin;
  if (*(double *)&mmcs_operation_metric_reference_time_origin == 0.0)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    mmcs_operation_metric_reference_time_origin = *(void *)&Current;
  }
  double v9 = [v7 dateWithTimeIntervalSinceReferenceDate:Current + a2];
  double v10 = [(MMCSOperationStateTimeRange *)v6 initWithOperationState:a1 startDate:v9 duration:a3];

  return v10;
}

uint64_t mmcs_perform_run_loop_timer_create(void *a1, _OWORD *a2, uint64_t a3, const __CFArray *a4)
{
  *a1 = 0;
  int v15 = 0;
  long long v7 = a2[1];
  v14[0] = *a2;
  v14[1] = v7;
  uint64_t v8 = mmcs_perform_timer_create((uint64_t *)&v15, 1, 8, v14);
  double v9 = v15;
  if (v8 && v15)
  {
    double v10 = (CFRunLoopTimerRef *)v15[7];
    context.version = 0;
    context.info = v15;
    context.retain = (const void *(__cdecl *)(const void *))C3BaseRetain;
    context.release = (void (__cdecl *)(const void *))C3BaseRelease;
    context.copyDescription = 0;
    CFRunLoopTimerRef v11 = CFRunLoopTimerCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 6.3113904e10, 6.3113904e10, 0, 0, (CFRunLoopTimerCallBack)mmcs_perform_run_loop_timer_perform_callback, &context);
    CFRunLoopTimerRef *v10 = v11;
    XCFRunLoopAddTimerToModes(a3, (uint64_t)v11, a4);
    C3BaseRetain(v15);
    double v9 = v15;
    *a1 = v15;
  }
  if (v9) {
    C3BaseRelease(v9);
  }
  return v8;
}

uint64_t mmcs_perform_run_loop_timer_perform_callback(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(a2 + 48))(a2, *(void *)(a2 + 24));
}

void mmcs_perform_run_loop_timer_finalize(uint64_t a1)
{
  CFDataRef v1 = *(CFTypeRef **)(a1 + 56);
  if (*v1) {
    CFRelease(*v1);
  }
  CFTypeRef *v1 = 0;
}

double mmcs_perform_run_loop_timer_get_next_fire_date(uint64_t a1)
{
  return CFRunLoopTimerGetNextFireDate(**(CFRunLoopTimerRef **)(a1 + 56));
}

void mmcs_perform_run_loop_timer_set_next_fire_date(uint64_t a1, CFAbsoluteTime a2)
{
}

void mmcs_perform_run_loop_timer_invalidate(uint64_t a1)
{
  CFDataRef v1 = *(CFRunLoopTimerRef **)(a1 + 56);
  if (*v1)
  {
    CFRunLoopTimerInvalidate(*v1);
    if (*v1) {
      CFRelease(*v1);
    }
    CFRunLoopTimerRef *v1 = 0;
  }
}

__CFString *MMCSRequestOptionsDiscretionaryNetworkBehaviorGetString(unint64_t a1)
{
  if (a1 > 2) {
    return @"unknown";
  }
  else {
    return off_1E6C335E8[a1];
  }
}

void mmcs_http_request_options_append_description(uint64_t a1, __CFString *a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  BOOL v6 = Mutable;
  if (*(unsigned char *)(a1 + 104)) {
    long long v7 = @"allowsRetry";
  }
  else {
    long long v7 = @"!allowsRetry";
  }
  CFArrayAppendValue(Mutable, v7);
  CFBooleanRef v8 = *(const __CFBoolean **)(a1 + 112);
  if (v8)
  {
    if (CFBooleanGetValue(v8)) {
      double v9 = @"privacyProxyFailClosedOverride";
    }
    else {
      double v9 = @"!privacyProxyFailClosedOverride";
    }
    CFArrayAppendValue(v6, v9);
  }
  CFBooleanRef v10 = *(const __CFBoolean **)(a1 + 120);
  if (v10)
  {
    if (CFBooleanGetValue(v10)) {
      CFRunLoopTimerRef v11 = @"useNWLoaderOverride";
    }
    else {
      CFRunLoopTimerRef v11 = @"!useNWLoaderOverride";
    }
    CFArrayAppendValue(v6, v11);
  }
  unint64_t v12 = *(void *)(a1 + 88);
  if (v12 <= 2) {
    CFArrayAppendValue(v6, off_1E6C33600[v12]);
  }
  unint64_t v13 = *(void *)(a1 + 96);
  if (v13 <= 2) {
    CFArrayAppendValue(v6, off_1E6C33618[v13]);
  }
  if (*(void *)(a1 + 16))
  {
    CFStringRef v14 = CFStringCreateWithFormat(v4, 0, @"if=%@", *(void *)(a1 + 16));
    CFArrayAppendValue(v6, v14);
    if (v14) {
      CFRelease(v14);
    }
  }
  if (*(unsigned char *)(a1 + 74)) {
    int v15 = @"allowsCell";
  }
  else {
    int v15 = @"!allowsCell";
  }
  CFArrayAppendValue(v6, v15);
  if (*(unsigned char *)(a1 + 72)) {
    id v16 = @"powerPluggedIn";
  }
  else {
    id v16 = @"!powerPluggedIn";
  }
  CFArrayAppendValue(v6, v16);
  if (*(unsigned char *)(a1 + 73)) {
    double v17 = @"allowsPowerNapScheduling";
  }
  else {
    double v17 = @"!allowsPowerNapScheduling";
  }
  CFArrayAppendValue(v6, v17);
  if (*(void *)(a1 + 48))
  {
    CFStringRef v18 = CFStringCreateWithFormat(v4, 0, @"connectionPoolName=%@", *(void *)(a1 + 48));
    CFArrayAppendValue(v6, v18);
    if (v18) {
      CFRelease(v18);
    }
  }
  CFNumberRef v19 = *(const __CFNumber **)(a1 + 56);
  if (v19)
  {
    uint64_t valuePtr = -1;
    if (CFNumberGetValue(v19, kCFNumberCFIndexType, &valuePtr))
    {
      CFStringRef v20 = CFStringCreateWithFormat(v4, 0, @"networkServiceType=%lld", valuePtr);
      CFArrayAppendValue(v6, v20);
      if (v20) {
        CFRelease(v20);
      }
    }
  }
  if (*(void *)(a1 + 24))
  {
    CFStringRef v21 = CFStringCreateWithFormat(v4, 0, @"app=%@", *(void *)(a1 + 24));
    CFArrayAppendValue(v6, v21);
    if (v21) {
      CFRelease(v21);
    }
  }
  if (*(void *)(a1 + 32))
  {
    CFStringRef v22 = CFStringCreateWithFormat(v4, 0, @"app2=%@", *(void *)(a1 + 32));
    CFArrayAppendValue(v6, v22);
    if (v22) {
      CFRelease(v22);
    }
  }
  if (*(void *)(a1 + 40)) {
    CFArrayAppendValue(v6, @"auditToken=Y");
  }
  CFIndex Count = CFArrayGetCount(v6);
  if (Count >= 1)
  {
    CFIndex v24 = Count;
    for (CFIndex i = 0; i != v24; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, i);
      CFStringAppend(a2, @" ");
      CFStringAppend(a2, ValueAtIndex);
    }
  }
  if (v6) {
    CFRelease(v6);
  }
}

CFTypeRef myCFTypeRetainCallBack(int a1, CFTypeRef cf)
{
  return CFRetain(cf);
}

void myCFTypeReleaseCallBack(int a1, CFTypeRef cf)
{
}

BOOL caseInsensitveStringEqualCallBack(const __CFString *a1, const __CFString *a2)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1) && (CFTypeID v5 = CFStringGetTypeID(), v5 == CFGetTypeID(a2))) {
    return CFStringCompare(a1, a2, 1uLL) == kCFCompareEqualTo;
  }
  else {
    return 0;
  }
}

CFHashCode caseInsensitiveStringHashCallBack(CFStringRef theString)
{
  CFMutableDictionaryRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theString);
  CFStringFold(MutableCopy, 1uLL, 0);
  CFHashCode v2 = CFHash(MutableCopy);
  CFRelease(MutableCopy);
  return v2;
}

uint64_t mmcs_http_request_options_create_with_dictionary(uint64_t *a1, const __CFDictionary *a2)
{
  uint64_t v4 = C3TypeRegister(&mmcs_http_request_optionsGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v4, 0x90uLL);
  if (result)
  {
    uint64_t v6 = result;
    *(void *)(result + 88) = 0;
    long long v7 = (unint64_t *)(result + 88);
    *(void *)(result + 80) = -1;
    *(_DWORD *)(result + 74) = 257;
    *(void *)(result + 112) = 0;
    CFBooleanRef v8 = (CFTypeRef *)(result + 112);
    *(unsigned char *)(result + 152) = 0;
    *(void *)(result + 96) = 0;
    *(unsigned char *)(result + 104) = 0;
    *(void *)(result + 120) = 0;
    if (a2)
    {
      *(unsigned char *)(result + 72) = mmcs_get_BOOLean_from_cfdictionary_object_for_key(a2, @"kMMCSRequestOptionRequiresPowerPluggedIn", *(unsigned __int8 *)(result + 72));
      uint64_t BOOLean_from_cfdictionary_object_for_key = mmcs_get_BOOLean_from_cfdictionary_object_for_key(a2, @"kMMCSRequestOptionAllowsCellularAccess", *(unsigned __int8 *)(v6 + 74));
      *(unsigned char *)(v6 + 74) = BOOLean_from_cfdictionary_object_for_key;
      *(unsigned char *)(v6 + 75) = mmcs_get_BOOLean_from_cfdictionary_object_for_key(a2, @"kMMCSRequestOptionAllowsExpensiveAccess", BOOLean_from_cfdictionary_object_for_key);
      *(unsigned char *)(v6 + 73) = mmcs_get_BOOLean_from_cfdictionary_object_for_key(a2, @"kMMCSRequestOptionAllowsPowerNapScheduling", *(unsigned __int8 *)(v6 + 73));
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"kMMCSRequestOptionQoS");
      if (Value)
      {
        CFNumberRef v11 = Value;
        CFTypeID v12 = CFGetTypeID(Value);
        if (v12 == CFNumberGetTypeID())
        {
          unint64_t valuePtr = 0;
          if (CFNumberGetValue(v11, kCFNumberCFIndexType, &valuePtr))
          {
            if ((valuePtr & 0x8000000000000000) != 0)
            {
              uint64_t v13 = -1;
            }
            else if (valuePtr >= 0x11)
            {
              if (valuePtr >= 0x19)
              {
                uint64_t v13 = 33;
                if (valuePtr < 0x21) {
                  uint64_t v13 = 25;
                }
              }
              else
              {
                uint64_t v13 = 17;
              }
            }
            else
            {
              uint64_t v13 = 9;
            }
            *(void *)(v6 + 80) = v13;
          }
        }
      }
      CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kMMCSRequestOptionDiscretionaryNetworkBehavior");
      if (v14)
      {
        CFNumberRef v15 = v14;
        CFTypeID v16 = CFGetTypeID(v14);
        if (v16 == CFNumberGetTypeID())
        {
          unint64_t valuePtr = -1;
          if (CFNumberGetValue(v15, kCFNumberCFIndexType, &valuePtr)) {
            *long long v7 = valuePtr;
          }
        }
      }
      CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kMMCSRequestOptionDuetPreClearedMode");
      if (v17)
      {
        CFNumberRef v18 = v17;
        CFTypeID v19 = CFGetTypeID(v17);
        if (v19 == CFNumberGetTypeID())
        {
          unint64_t valuePtr = -1;
          if (CFNumberGetValue(v18, kCFNumberCFIndexType, &valuePtr)) {
            *(void *)(v6 + 96) = valuePtr;
          }
        }
      }
      CFBooleanRef v20 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"kMMCSRequestOptionAllowsRetryForBackgroundDataTasks");
      if (v20)
      {
        CFBooleanRef v21 = v20;
        CFTypeID v22 = CFGetTypeID(v20);
        if (v22 == CFBooleanGetTypeID()) {
          *(unsigned char *)(v6 + 104) = CFBooleanGetValue(v21);
        }
      }
      CFArrayRef v23 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionPrivacyProxyFailClosedOverride");
      if (v23)
      {
        CFIndex v24 = v23;
        CFTypeID v25 = CFGetTypeID(v23);
        if (v25 == CFBooleanGetTypeID()) {
          *CFBooleanRef v8 = CFRetain(v24);
        }
      }
      CFStringRef v26 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionUseNWLoaderOverride");
      if (v26)
      {
        CFStringRef v27 = v26;
        CFTypeID v28 = CFGetTypeID(v26);
        if (v28 == CFBooleanGetTypeID()) {
          *(void *)(v6 + 120) = CFRetain(v27);
        }
      }
      id v29 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionMetricOptions");
      if (v29)
      {
        double v30 = v29;
        CFRetain(v29);
        *(void *)(v6 + 128) = v30;
      }
      double v31 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionNetworkingDelegate");
      if (v31)
      {
        char v32 = v31;
        CFRetain(v31);
        *(void *)(v6 + 136) = v32;
      }
      CFRange v33 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionSourceApplicationBundleIdentifier");
      if (v33)
      {
        CFRange v34 = v33;
        CFTypeID v35 = CFGetTypeID(v33);
        if (v35 == CFStringGetTypeID()) {
          *(void *)(v6 + 24) = CFRetain(v34);
        }
      }
      CFRange v36 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionSourceApplicationSecondaryBundleIdentifier");
      if (v36)
      {
        int v37 = v36;
        CFTypeID v38 = CFGetTypeID(v36);
        if (v38 == CFStringGetTypeID()) {
          *(void *)(v6 + 32) = CFRetain(v37);
        }
      }
      uint64_t v39 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionSourceApplicationAuditTokenData");
      if (v39)
      {
        uint64_t v40 = v39;
        CFTypeID v41 = CFGetTypeID(v39);
        if (v41 == CFDataGetTypeID()) {
          *(void *)(v6 + 40) = CFRetain(v40);
        }
      }
      CFErrorRef v42 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionBackgroundConnectionPoolName");
      if (v42)
      {
        CFStringRef v43 = v42;
        CFTypeID v44 = CFGetTypeID(v42);
        if (v44 == CFStringGetTypeID()) {
          *(void *)(v6 + 48) = CFRetain(v43);
        }
      }
      double v45 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionBoundInterfaceIdentifier");
      if (v45)
      {
        double v46 = v45;
        CFTypeID v47 = CFGetTypeID(v45);
        if (v47 == CFStringGetTypeID()) {
          *(void *)(v6 + 16) = CFRetain(v46);
        }
      }
      uint64_t v48 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionNetworkServiceType");
      if (v48)
      {
        uint64_t v49 = v48;
        CFTypeID v50 = CFGetTypeID(v48);
        if (v50 == CFNumberGetTypeID()) {
          *(void *)(v6 + 56) = CFRetain(v49);
        }
      }
      CFDictionaryRef v51 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"kMMCSRequestOptionInsertHeaders");
      if (v51)
      {
        CFDictionaryRef v52 = v51;
        CFTypeID v53 = CFGetTypeID(v51);
        if (v53 == CFDictionaryGetTypeID())
        {
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &_myCFStringCaseInsensitiveKeyCallbacks, MEMORY[0x1E4F1D540]);
          CFDictionaryApplyFunction(v52, (CFDictionaryApplierFunction)_add_values, Mutable);
          *(void *)(v6 + 64) = Mutable;
        }
      }
      int v55 = CFDictionaryGetValue(a2, @"kMMCSRequestOptionContainerType");
      if (v55)
      {
        double v56 = v55;
        CFTypeID v57 = CFGetTypeID(v55);
        if (v57 == CFNumberGetTypeID()) {
          *(void *)(v6 + 144) = CFRetain(v56);
        }
      }
    }
    if (a1) {
      *a1 = v6;
    }
    else {
      C3BaseRelease((CFTypeRef)v6);
    }
    return 1;
  }
  return result;
}

uint64_t mmcs_http_request_options_create_copy(uint64_t a1)
{
  uint64_t v2 = C3TypeRegister(&mmcs_http_request_optionsGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v2, 0x90uLL);
  if (Instance)
  {
    CFStringRef v4 = *(const __CFString **)(a1 + 16);
    CFTypeID v5 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (v4) {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4);
    }
    else {
      CFStringRef Copy = 0;
    }
    *(void *)(Instance + 16) = Copy;
    CFStringRef v7 = *(const __CFString **)(a1 + 24);
    if (v7) {
      CFStringRef v8 = CFStringCreateCopy(*v5, v7);
    }
    else {
      CFStringRef v8 = 0;
    }
    *(void *)(Instance + 24) = v8;
    CFStringRef v9 = *(const __CFString **)(a1 + 32);
    if (v9) {
      CFStringRef v10 = CFStringCreateCopy(*v5, v9);
    }
    else {
      CFStringRef v10 = 0;
    }
    *(void *)(Instance + 32) = v10;
    CFTypeRef v11 = *(CFTypeRef *)(a1 + 40);
    if (v11) {
      CFTypeRef v11 = CFRetain(v11);
    }
    *(void *)(Instance + 40) = v11;
    CFStringRef v12 = *(const __CFString **)(a1 + 48);
    if (v12) {
      CFStringRef v13 = CFStringCreateCopy(*v5, v12);
    }
    else {
      CFStringRef v13 = 0;
    }
    *(void *)(Instance + 48) = v13;
    CFTypeRef v14 = *(CFTypeRef *)(a1 + 56);
    if (v14) {
      CFTypeRef v14 = CFRetain(v14);
    }
    *(void *)(Instance + 56) = v14;
    CFDictionaryRef v15 = *(const __CFDictionary **)(a1 + 64);
    if (v15) {
      CFDictionaryRef v16 = CFDictionaryCreateCopy(*v5, v15);
    }
    else {
      CFDictionaryRef v16 = 0;
    }
    *(void *)(Instance + 64) = v16;
    *(_DWORD *)(Instance + 72) = *(_DWORD *)(a1 + 72);
    *(_WORD *)(Instance + 76) = *(_WORD *)(a1 + 76);
    *(_OWORD *)(Instance + 80) = *(_OWORD *)(a1 + 80);
    *(void *)(Instance + 96) = *(void *)(a1 + 96);
    *(unsigned char *)(Instance + 104) = *(unsigned char *)(a1 + 104);
    CFTypeRef v17 = *(CFTypeRef *)(a1 + 112);
    if (v17) {
      CFTypeRef v17 = CFRetain(v17);
    }
    *(void *)(Instance + 112) = v17;
    CFTypeRef v18 = *(CFTypeRef *)(a1 + 120);
    if (v18) {
      CFTypeRef v18 = CFRetain(v18);
    }
    *(void *)(Instance + 120) = v18;
    CFTypeRef v19 = *(CFTypeRef *)(a1 + 128);
    if (v19) {
      CFTypeRef v19 = CFRetain(v19);
    }
    *(void *)(Instance + 128) = v19;
    CFTypeRef v20 = *(CFTypeRef *)(a1 + 136);
    if (v20) {
      CFTypeRef v20 = CFRetain(v20);
    }
    *(void *)(Instance + 136) = v20;
    CFTypeRef v21 = *(CFTypeRef *)(a1 + 144);
    if (v21) {
      CFTypeRef v21 = CFRetain(v21);
    }
    *(void *)(Instance + 144) = v21;
    *(unsigned char *)(Instance + 152) = *(unsigned char *)(a1 + 152);
  }
  return Instance;
}

double mmcs_http_request_options_create_promoted_to_foreground_copy(uint64_t a1)
{
  uint64_t copy = mmcs_http_request_options_create_copy(a1);
  if (copy)
  {
    if (!*(void *)(copy + 96))
    {
      double result = NAN;
      *(_OWORD *)(copy + 80) = xmmword_1DC251C20;
      *(unsigned char *)(copy + 104) = 0;
    }
  }
  return result;
}

uint64_t mmcs_http_request_options_create_override_network_service_type_to_background_system_initiated_copy(uint64_t a1)
{
  uint64_t copy = mmcs_http_request_options_create_copy(a1);
  uint64_t v2 = copy;
  if (copy)
  {
    id v3 = *(const void **)(copy + 56);
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(v2 + 56) = 0;
    uint64_t valuePtr = 5;
    *(void *)(v2 + 56) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
  }
  return v2;
}

uint64_t mmcs_http_request_options_create_proxy_copy(uint64_t a1)
{
  uint64_t result = mmcs_http_request_options_create_copy(a1);
  if (result)
  {
    *(_WORD *)(result + 76) = 257;
    *(unsigned char *)(result + 152) = 0;
  }
  return result;
}

void mmcs_http_request_options_set_inserted_header(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryRef v6 = *(const __CFDictionary **)(a1 + 64);
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v6)
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v7, 0, v6);
    CFStringRef v9 = MutableCopy;
    if (!a3)
    {
      CFDictionaryRemoveValue(MutableCopy, a2);
      goto LABEL_6;
    }
  }
  else
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(v7, 0, &_myCFStringCaseInsensitiveKeyCallbacks, MEMORY[0x1E4F1D540]);
    CFStringRef v9 = MutableCopy;
  }
  CFDictionarySetValue(MutableCopy, a2, a3);
LABEL_6:
  if (!CFDictionaryGetCount(v9))
  {
    if (v9) {
      CFRelease(v9);
    }
    CFStringRef v9 = 0;
  }
  CFStringRef v10 = *(const void **)(a1 + 64);
  if (v10) {
    CFRelease(v10);
  }
  *(void *)(a1 + 64) = v9;
}

void mmcs_http_request_options_add_inserted_header_if_absent(uint64_t a1, void *key, const void *a3)
{
  CFDictionaryRef v6 = *(const __CFDictionary **)(a1 + 64);
  if (!v6 || !CFDictionaryContainsKey(v6, key))
  {
    mmcs_http_request_options_set_inserted_header(a1, key, a3);
  }
}

BOOL mmcs_http_request_options_is_background(BOOL result)
{
  if (result) {
    return *(void *)(result + 88) || *(void *)(result + 96) || *(unsigned char *)(result + 104) != 0;
  }
  return result;
}

uint64_t mmcs_http_request_options_get_discretionary_network_behavior(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

uint64_t mmcs_http_request_options_network_behavior_type(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 88);
    if (v1 == 2)
    {
      unint64_t v2 = *(void *)(result + 96);
      if (v2 < 3) {
        return qword_1DC251C30[v2];
      }
    }
    else
    {
      if (v1 == 1) {
        return 3;
      }
      if (v1) {
        mmcs_http_request_options_network_behavior_type_cold_1();
      }
      if (*(void *)(result + 96) || *(unsigned char *)(result + 104)) {
        return 1;
      }
    }
    return 0;
  }
  return result;
}

BOOL mmcs_http_request_options_should_use_bk_sys(uint64_t a1, int a2, uint64_t a3, unint64_t a4)
{
  if (a2) {
    BOOL v4 = *(unsigned char *)(a1 + 74) == 0;
  }
  else {
    BOOL v4 = 0;
  }
  return v4 && a3 != 1 && a4 >> 20 > 4;
}

void _mmcs_http_request_optionsCFFinalize(void *a1)
{
  unint64_t v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  a1[2] = 0;
  id v3 = (const void *)a1[16];
  if (v3) {
    CFRelease(v3);
  }
  a1[16] = 0;
  BOOL v4 = (const void *)a1[17];
  if (v4) {
    CFRelease(v4);
  }
  a1[17] = 0;
  CFTypeID v5 = (const void *)a1[3];
  if (v5) {
    CFRelease(v5);
  }
  a1[3] = 0;
  CFDictionaryRef v6 = (const void *)a1[4];
  if (v6) {
    CFRelease(v6);
  }
  a1[4] = 0;
  CFAllocatorRef v7 = (const void *)a1[5];
  if (v7) {
    CFRelease(v7);
  }
  a1[5] = 0;
  CFStringRef v8 = (const void *)a1[6];
  if (v8) {
    CFRelease(v8);
  }
  a1[6] = 0;
  CFStringRef v9 = (const void *)a1[7];
  if (v9) {
    CFRelease(v9);
  }
  a1[7] = 0;
  CFStringRef v10 = (const void *)a1[8];
  if (v10) {
    CFRelease(v10);
  }
  a1[8] = 0;
  CFTypeRef v11 = (const void *)a1[14];
  if (v11) {
    CFRelease(v11);
  }
  a1[14] = 0;
  CFStringRef v12 = (const void *)a1[15];
  if (v12) {
    CFRelease(v12);
  }
  a1[15] = 0;
}

BOOL _mmcs_http_request_optionsCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_http_request_optionsCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_http_request_optionsCFCopyDebugDescription()
{
  return 0;
}

void _add_values(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

void sub_1DC1D69F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1DC1D6C04(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1DC1D6D5C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t MMCSItemMemoryReaderWriterCreateWithData(const void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = C3TypeRegister(&MMCSItemMemoryReaderWriterGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v2, 0x10uLL);
  uint64_t v4 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = a1;
    CFRetain(a1);
    *(void *)(v4 + 24) = 0;
  }
  return v4;
}

uint64_t MMCSItemMemoryReaderWriterCreateWithMutableData(const void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = C3TypeRegister(&MMCSItemMemoryReaderWriterGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v2, 0x10uLL);
  uint64_t v4 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = 0;
    *(void *)(Instance + 24) = a1;
    CFRetain(a1);
  }
  return v4;
}

void *MMCSItemReaderWriterCreateWithData(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = MMCSItemMemoryReaderWriterCreateWithData(a1);
  if (!v5) {
    return 0;
  }
  CFDictionaryRef v6 = (const void *)v5;
  v9[0] = 3;
  v9[1] = v5;
  v9[2] = a2;
  v9[3] = a3;
  v9[4] = C3BaseRetain;
  v9[5] = C3BaseRelease;
  void v9[6] = MMCSItemMemoryReaderWriterStat1;
  v9[7] = MMCSItemMemoryReaderWriterOpen;
  v9[8] = MMCSItemMemoryReaderWriterRead;
  v9[9] = MMCSItemMemoryReaderWriterClose;
  memset(&v9[10], 0, 24);
  v9[13] = MMCSItemMemoryReaderWriterWrite;
  v9[14] = 0;
  CFAllocatorRef v7 = MMCSItemReaderWriterCreate(v9);
  C3BaseRelease(v6);
  return v7;
}

void *MMCSItemReaderWriterCreateWithMutableData(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = MMCSItemMemoryReaderWriterCreateWithMutableData(a1);
  if (!v5) {
    return 0;
  }
  CFDictionaryRef v6 = (const void *)v5;
  v9[0] = 3;
  v9[1] = v5;
  v9[2] = a2;
  v9[3] = a3;
  v9[4] = C3BaseRetain;
  v9[5] = C3BaseRelease;
  void v9[6] = MMCSItemMemoryReaderWriterStat1;
  v9[7] = MMCSItemMemoryReaderWriterOpen;
  v9[8] = MMCSItemMemoryReaderWriterRead;
  v9[9] = MMCSItemMemoryReaderWriterClose;
  memset(&v9[10], 0, 24);
  v9[13] = MMCSItemMemoryReaderWriterWrite;
  v9[14] = 0;
  CFAllocatorRef v7 = MMCSItemReaderWriterCreate(v9);
  C3BaseRelease(v6);
  return v7;
}

void _MMCSItemMemoryReaderWriterCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)(a1 + 16) = 0;
}

BOOL _MMCSItemMemoryReaderWriterCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _MMCSItemMemoryReaderWriterCFCopyFormatDescription()
{
  return 0;
}

uint64_t _MMCSItemMemoryReaderWriterCFCopyDebugDescription()
{
  return 0;
}

uint64_t MMCSItemMemoryReaderWriterStat1(uint64_t a1, uint64_t a2, __CFDictionary **a3, CFErrorRef *a4)
{
  CFDataRef v6 = *(const __CFData **)(a2 + 24);
  if (!v6) {
    CFDataRef v6 = *(const __CFData **)(a2 + 16);
  }
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFIndex valuePtr = CFDataGetLength(v6);
    CFNumberRef v14 = CFNumberCreate(v7, kCFNumberSInt64Type, &valuePtr);
    if (v14)
    {
      CFNumberRef v15 = v14;
      CFDictionaryAddValue(Mutable, @"kMMCSItemReaderWriterFileSize", v14);
      CFRelease(v15);
      if (a3)
      {
        CFRetain(Mutable);
        CFErrorRef v16 = 0;
        *a3 = Mutable;
      }
      else
      {
        CFErrorRef v16 = 0;
      }
      uint64_t v18 = 1;
      goto LABEL_19;
    }
  }
  CFErrorRef v17 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, @"No memory to create statsDict", v8, v9, v10, v11, v12, v21);
  CFErrorRef v16 = v17;
  if (a4)
  {
    CFRetain(v17);
    *a4 = v16;
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  if (Mutable)
  {
LABEL_19:
    CFRelease(Mutable);
    uint64_t v19 = v18;
    if (!v16) {
      return v19;
    }
    goto LABEL_15;
  }
  if (v16) {
LABEL_15:
  }
    CFRelease(v16);
  return v19;
}

uint64_t MMCSItemMemoryReaderWriterOpen()
{
  return 1;
}

uint64_t MMCSItemMemoryReaderWriterRead(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, size_t a5, size_t *a6, CFErrorRef *a7)
{
  CFDataRef v12 = *(const __CFData **)(a2 + 24);
  if (!v12) {
    CFDataRef v12 = *(const __CFData **)(a2 + 16);
  }
  unint64_t Length = CFDataGetLength(v12);
  size_t v19 = Length - a3;
  if (Length >= a3)
  {
    if (Length == a3)
    {
      *a6 = 0;
    }
    else
    {
      BytePtr = CFDataGetBytePtr(v12);
      if (v19 >= a5) {
        size_t v24 = a5;
      }
      else {
        size_t v24 = v19;
      }
      memcpy(a4, &BytePtr[a3], v24);
      *a6 = v24;
    }
    return 1;
  }
  else
  {
    CFErrorRef v20 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"Read offset beyond the range of the readerWriter memory buffer", v14, v15, v16, v17, v18, v25);
    CFErrorRef v21 = v20;
    if (a7)
    {
      CFRetain(v20);
      *a7 = v21;
    }
    if (v21) {
      CFRelease(v21);
    }
    return 0;
  }
}

uint64_t MMCSItemMemoryReaderWriterClose()
{
  return 1;
}

uint64_t MMCSItemMemoryReaderWriterWrite(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5, size_t *a6)
{
  CFDataRef v6 = *(const __CFData **)(a2 + 24);
  if (!v6) {
    MMCSItemMemoryReaderWriterWrite_cold_1();
  }
  unint64_t Length = CFDataGetLength(v6);
  if (a5 + a3 > Length)
  {
    CFDataIncreaseLength(*(CFMutableDataRef *)(a2 + 24), a5 + a3 - Length);
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(a2 + 24));
  }
  size_t v13 = Length - a3;
  if (Length == a3)
  {
    a5 = 0;
  }
  else
  {
    uint64_t v14 = (UInt8 *)&CFDataGetBytePtr(*(CFDataRef *)(a2 + 24))[a3];
    if (v13 < a5) {
      a5 = v13;
    }
    memcpy(v14, a4, a5);
  }
  *a6 = a5;
  return 1;
}

BOOL mmcs_chunking_profile_create(uint64_t *a1, uint64_t a2, const void *a3)
{
  *a1 = 0;
  uint64_t v6 = C3TypeRegister(&mmcs_chunking_profileGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v6, 0x10uLL);
  uint64_t v8 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = a2;
    *(void *)(Instance + 24) = a3;
    C3BaseRetain(a3);
    *a1 = v8;
  }
  return v8 != 0;
}

void _mmcs_chunking_profileCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    C3BaseRelease(v2);
  }
  *(void *)(a1 + 24) = 0;
}

BOOL _mmcs_chunking_profileCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_chunking_profileCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_chunking_profileCFCopyDebugDescription()
{
  return 0;
}

uint64_t mmcs_fixed_chunk_size_for_item_type_hint(uint64_t cf2)
{
  int v3 = 0;
  if (cf2)
  {
    cf2 = CFEqual(@"com.apple.mmcs.kMMCSFixedLengthChunkerFileHint", (CFTypeRef)cf2);
    if (cf2)
    {
      int chunker_max_fixed_length = mmcs_report_get_chunker_max_fixed_length(&v3);
      if (v3 < 0x2000000 || chunker_max_fixed_length == 0) {
        return 0x2000000;
      }
      else {
        return v3;
      }
    }
  }
  return cf2;
}

uint64_t mmcs_RegisterChunksForItem(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void **a7, void *a8, unsigned __int8 a9, char a10, uint64_t a11, CFTypeRef *a12, CFTypeRef *a13, CFTypeRef *a14)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  CFTypeRef v40 = 0;
  CFTypeRef v41 = 0;
  CFTypeRef v39 = 0;
  if (a12) {
    *a12 = 0;
  }
  if (a13) {
    *a13 = 0;
  }
  if (a14) {
    *a14 = 0;
  }
  unsigned int v37 = a6;
  int v17 = _mmcs_RegisterChunksForItem(a1, a2, a3, a4, a6, (uint64_t)a7, (uint64_t)a8, a9, a10, a11);
  if (!a7) {
    goto LABEL_47;
  }
  if (!v17) {
    goto LABEL_47;
  }
  uint64_t v18 = (char *)*a7;
  if (!*a7) {
    goto LABEL_47;
  }
  if (!*a8) {
    goto LABEL_36;
  }
  uint64_t v34 = a3;
  unint64_t v19 = 1;
  do
  {
    uint64_t v20 = CKRegisteredChunkKey();
    if (a9)
    {
      if (!v20) {
        goto LABEL_16;
      }
    }
    else if (v20)
    {
LABEL_16:
      int v21 = 0;
      goto LABEL_17;
    }
    int v21 = 1;
LABEL_17:
    unsigned int v22 = CKRegisteredChunkSize();
    if (!v21) {
      break;
    }
    v18 += v22;
  }
  while (v19++ < *a8);
  if (v21)
  {
LABEL_36:
    if (a12 && v40)
    {
      C3BaseRetain(v40);
      *a12 = v40;
    }
    uint64_t v28 = 1;
    if (a13 && v39)
    {
      C3BaseRetain(v39);
      *a13 = v39;
    }
    goto LABEL_50;
  }
  if (*a7) {
    free(*a7);
  }
  *a7 = 0;
  if (v40) {
    C3BaseRelease(v40);
  }
  CFTypeRef v40 = 0;
  uint64_t v24 = a1;
  if (v39) {
    C3BaseRelease(v39);
  }
  CFTypeRef v39 = 0;
  char v25 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v26 = "un";
    if (a9) {
      CFStringRef v26 = "";
    }
    CFStringRef cf = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unregistering chunks for item %lld because they need to be %sencrypted.", v34, v26, &v40, &v39, &v41);
    CFStringRef v27 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      CFStringRef v43 = cf;
      _os_log_impl(&dword_1DC1CA000, v27, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
    }
    uint64_t v24 = a1;
    if (cf) {
      CFRelease(cf);
    }
  }
  if (CKUnregisterChunksForItem())
  {
    if (_mmcs_RegisterChunksForItem(v24, a2, v34, a4, v37, (uint64_t)a7, (uint64_t)a8, a9, a10, a11)) {
      goto LABEL_36;
    }
  }
  else
  {
    id v29 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v30 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unable to unregister chunks for item %lld before rechunking.", v34);
      double v31 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        CFStringRef v43 = v30;
        _os_log_impl(&dword_1DC1CA000, v31, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v30) {
        CFRelease(v30);
      }
    }
  }
LABEL_47:
  uint64_t v28 = 0;
  if (a14 && v41)
  {
    CFRetain(v41);
    uint64_t v28 = 0;
    *a14 = v41;
  }
LABEL_50:
  if (v40) {
    C3BaseRelease(v40);
  }
  CFTypeRef v40 = 0;
  if (v39) {
    C3BaseRelease(v39);
  }
  CFTypeRef v39 = 0;
  if (v41) {
    CFRelease(v41);
  }
  return v28;
}

uint64_t _mmcs_RegisterChunksForItem(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, uint64_t a10)
{
  if ((a9 & 0x7F) == 4)
  {
    if (!(a4 | a10)) {
      _mmcs_RegisterChunksForItem_cold_1();
    }
    if (a10)
    {
      CKFileDigestArgumentsV2WithBoundaryKeyCreate();
      CKChunkDigestArgumentsV2WithBoundaryKeyCreate();
    }
  }
  else
  {
    CKFileDigestArgumentsV1WithFileCreate();
    CKChunkDigestArgumentsV1Create();
  }
  uint64_t v11 = MMCSItemReaderWriterCKItemReadContextCreate(a2);
  uint64_t v12 = CKRegisterChunksForItem();
  if (v11) {
    free(v11);
  }
  return v12;
}

uint64_t mmcs_compute_signature_and_register_item_with_item_reader_writer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, void *a7, _DWORD *a8, void *a9, void *a10, void **a11)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (a9) {
    *a9 = 0;
  }
  uint64_t v16 = MMCSItemReaderWriterCKItemReadContextCreate(a3);
  int v17 = v16;
  if (a5)
  {
    unsigned int v18 = mmcs_fixed_chunk_size_for_item_type_hint(v16[2]);
    if (a6)
    {
      CKFileDigestArgumentsV2WithBoundaryKeyCreate();
      CKChunkDigestArgumentsV2WithBoundaryKeyCreate();
    }
    else
    {
      CKFileDigestArgumentsV1WithFileCreate();
      CKChunkDigestArgumentsV1Create();
    }
    *(_DWORD *)buf_4 = 0;
    *(void *)&buf_4[4] = a2;
    int buf = 1;
    uint64_t v40 = 0;
    uint64_t v39 = v18;
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v19 = CKRegisterItemAndChunks();
    if (v19) {
      CKFileDigestResultsFileLength();
    }
    free(v17);
    if (v19)
    {
      if (a7) {
        *a7 = 0;
      }
      if (a10) {
        *a10 = 0;
      }
      if (a8) {
        *a8 = 0;
      }
      if (a9) {
        *a9 = 0;
      }
    }
    return v19;
  }
  if (a6) {
    CKFileDigestArgumentsV2WithBoundaryKeyCreate();
  }
  else {
    CKFileDigestArgumentsV1WithFileCreate();
  }
  if ((CK2CalculateItemSignatureWithFlags() & 1) == 0)
  {
    uint64_t v20 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"failed to calculate signature");
      CFStringRef v26 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        int buf = 138543362;
        *(void *)buf_4 = v25;
        _os_log_impl(&dword_1DC1CA000, v26, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v25) {
        CFRelease(v25);
      }
    }
    if (!a11) {
      goto LABEL_49;
    }
    uint64_t v19 = (uint64_t)*a11;
    error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 18, *a11, @"Unable to calculate signature.", v21, v22, v23, v24, v36);
LABEL_47:
    *a11 = error_with_underlying_error;
    if (!v19) {
      goto LABEL_50;
    }
    CFRelease((CFTypeRef)v19);
    goto LABEL_49;
  }
  if (!CKFileDigestResultsFileLength())
  {
    uint64_t v28 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v29 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"file is empty");
      CFStringRef v30 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        int buf = 138543362;
        *(void *)buf_4 = v29;
        _os_log_impl(&dword_1DC1CA000, v30, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v29) {
        CFRelease(v29);
      }
    }
    if (a11)
    {
      uint64_t v19 = 0;
      *a11 = mmcs_cferror_create_error(@"com.apple.mmcs", 18, @"Unable to calculate signature for zero-length file.");
      goto LABEL_50;
    }
LABEL_49:
    uint64_t v19 = 0;
    goto LABEL_50;
  }
  if ((CKRegisterFile() & 1) == 0)
  {
    double v31 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v32 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"failed to register file");
      CFRange v33 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        int buf = 138543362;
        *(void *)buf_4 = v32;
        _os_log_impl(&dword_1DC1CA000, v33, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v32) {
        CFRelease(v32);
      }
    }
    if (!a11) {
      goto LABEL_49;
    }
    uint64_t v19 = (uint64_t)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to register item %lld", a2);
    error_with_underlying_CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 19, (void *)v19);
    goto LABEL_47;
  }
  uint64_t v19 = 1;
LABEL_50:
  if (v17) {
    free(v17);
  }
  char v34 = v19 ^ 1;
  if (!a7) {
    char v34 = 1;
  }
  if ((v34 & 1) == 0) {
    *a7 = 0;
  }
  return v19;
}

uint64_t mmcs_GetSortedRegisteredChunksForItemID(uint64_t a1, const __CFString *a2, void **a3, uint64_t *a4, void *a5, uint64_t *a6)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (a6) {
    *a6 = 0;
  }
  if (!CKGetRegisteredChunksForItemID())
  {
LABEL_31:
    if (a3) {
      goto LABEL_32;
    }
    goto LABEL_35;
  }
  if ((CKGetRegisteredFileMetadata() & 1) == 0)
  {
    uint64_t v21 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 134217984;
      CFStringRef v25 = a2;
      _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_ERROR, "Expected registered file information for itemID %llu", buf, 0xCu);
    }
    goto LABEL_31;
  }
  int v11 = 1;
  if (!a3 || !a4 || !*a3 || !*a4)
  {
LABEL_25:
    if (a6) {
      mmcs_chunking_profile_create(a6, *a4, 0);
    }
    if (a5)
    {
      CFDataRef v19 = (const __CFData *)CKFileDigestResultsFileVerificationKey();
      uint64_t v20 = CKFileDigestResultsFileLength();
      *a5 = mmcs_create_RangedItem(v19, v20);
    }
    return v11;
  }
  unint64_t v12 = 0;
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    if (!v12)
    {
      if (!CKRegisteredChunkOffset()) {
        goto LABEL_23;
      }
      unsigned int v18 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v16 = CFStringCreateWithFormat(alloc, 0, @"Item %lld chunk list error: first chunk doesn't begin at 0", a2);
        int v17 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          goto LABEL_19;
        }
        goto LABEL_20;
      }
LABEL_22:
      int v11 = 0;
      goto LABEL_23;
    }
    unint64_t v13 = CKRegisteredChunkSuccessorOffset();
    if (v13 < CKRegisteredChunkOffset() || (uint64_t v14 = CKRegisteredChunkSuccessorOffset(), v14 != CKRegisteredChunkOffset()))
    {
      uint64_t v15 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v16 = CFStringCreateWithFormat(alloc, 0, @"Item %lld chunk list error: gap or overlap between chunk %llu and chunk %llu", a2, v12 - 1, v12);
        int v17 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
LABEL_19:
          *(_DWORD *)int buf = 138543362;
          CFStringRef v25 = v16;
          _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
LABEL_20:
        if (v16) {
          CFRelease(v16);
        }
      }
      goto LABEL_22;
    }
LABEL_23:
    CKRegisteredChunkSize();
    ++v12;
  }
  while (v12 < *a4);
  if (v11) {
    goto LABEL_25;
  }
LABEL_32:
  if (*a3) {
    free(*a3);
  }
  *a3 = 0;
LABEL_35:
  LOBYTE(v11) = 0;
  if (a4) {
    *a4 = 0;
  }
  return v11;
}

__CFData *mmcs_chunk_key_copy_wraptured_scheme_and_key(CFDataRef theData, const __CFData *a2, int a3, CFErrorRef *a4)
{
  if (a4) {
    *a4 = 0;
  }
  CFIndex Length = CFDataGetLength(theData);
  if (a3)
  {
    if (Length != 17) {
      mmcs_chunk_key_copy_wraptured_scheme_and_key_cold_4();
    }
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v10 = CFDataGetBytePtr(theData) + 1;
    CFIndex v11 = CFDataGetLength(theData);
    CFDataRef v12 = CFDataCreate(v9, v10, v11 - 1);
    CFDataRef v13 = (const __CFData *)PCSCopyWrappedKey();
    if (v13)
    {
      uint64_t v14 = (__CFString *)v13;
      if (CFDataGetLength(v13) != 24) {
        mmcs_chunk_key_copy_wraptured_scheme_and_key_cold_3();
      }
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(v9, 0);
      CFDataSetLength(Mutable, 25);
      BytePtr = CFDataGetBytePtr((CFDataRef)v14);
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      CFErrorRef v18 = 0;
      UInt8 *MutableBytePtr = 2;
      uint64_t v19 = *((void *)BytePtr + 2);
      *(_OWORD *)(MutableBytePtr + 1) = *(_OWORD *)BytePtr;
      *(void *)(MutableBytePtr + 17) = v19;
LABEL_17:
      CFRelease(v14);
      CFTypeID v38 = Mutable;
      goto LABEL_18;
    }
    uint64_t v26 = mmcs_key_description_create_with_cfdata(theData, 1);
    uint64_t v14 = mmcs_key_description_create_with_cfdata(a2, 0);
    CFErrorRef v32 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"PCS wrapping of key %@ using wrapping key %@ failed", v27, v28, v29, v30, v31, (char)v26);
  }
  else
  {
    if (Length != 25) {
      mmcs_chunk_key_copy_wraptured_scheme_and_key_cold_2();
    }
    CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v21 = CFDataGetBytePtr(theData) + 1;
    CFIndex v22 = CFDataGetLength(theData);
    CFDataRef v12 = CFDataCreate(v20, v21, v22 - 1);
    CFDataRef v23 = (const __CFData *)PCSCopyUnwrappedKey();
    if (v23)
    {
      uint64_t v14 = (__CFString *)v23;
      if (CFDataGetLength(v23) != 16) {
        mmcs_chunk_key_copy_wraptured_scheme_and_key_cold_1();
      }
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(v20, 0);
      CFDataSetLength(Mutable, 17);
      uint64_t v24 = CFDataGetBytePtr((CFDataRef)v14);
      CFStringRef v25 = CFDataGetMutableBytePtr(Mutable);
      CFErrorRef v18 = 0;
      *CFStringRef v25 = 1;
      *(_OWORD *)(v25 + 1) = *(_OWORD *)v24;
      goto LABEL_17;
    }
    uint64_t v26 = mmcs_key_description_create_with_cfdata(theData, 1);
    uint64_t v14 = mmcs_key_description_create_with_cfdata(a2, 0);
    CFErrorRef v32 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 12, @"PCS unwrapping of key %@ using wrapping key %@ failed", v33, v34, v35, v36, v37, (char)v26);
  }
  CFErrorRef v18 = v32;
  if (v26) {
    CFRelease(v26);
  }
  CFMutableDictionaryRef Mutable = 0;
  CFTypeID v38 = 0;
  if (v14) {
    goto LABEL_17;
  }
LABEL_18:
  if (v12) {
    CFRelease(v12);
  }
  if (a4 && !v38)
  {
    CFRetain(v18);
    *a4 = v18;
  }
  if (v18) {
    CFRelease(v18);
  }
  return v38;
}

uint64_t mmcs_chunk_progressive_v1_padded_chunk_length(int a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    mmcs_chunk_progressive_v1_padded_chunk_length_cold_1();
  }
  uint64_t v2 = SecPaddingCompute();
  if (v2 < 0)
  {
    int v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"SecPaddingCompute error %ld", v2);
      uint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v8 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  return (v2 + a1);
}

uint64_t mmcs_padded_chunk_length_with_policy_and_chunk_length(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_1();
  }
  unsigned int v2 = a2;
  if (a1)
  {
    if (a1 == 2)
    {
      uint64_t result = mmcs_chunk_progressive_v1_padded_chunk_length(a2);
    }
    else
    {
      if (a1 != 1) {
        mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_2(a1);
      }
      unint64_t v3 = a2 + 1023;
      if (HIDWORD(v3)) {
        mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_4();
      }
      uint64_t result = v3 & 0x1FFFFFC00;
    }
    if (!result) {
      mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_5();
    }
    if (result < v2) {
      mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_6();
    }
  }
  else
  {
    uint64_t result = a2;
  }
  if (result >= 0x2800001) {
    mmcs_padded_chunk_length_with_policy_and_chunk_length_cold_3();
  }
  return result;
}

CFStringRef mmcs_chunk_instance_copy_description(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CFStringRef v3 = mmcs_item_copy_description(v2);
  }
  else {
    CFStringRef v3 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 56);
  if (v4) {
    CFStringRef v5 = mmcs_chunk_reference_copy_description(v4);
  }
  else {
    CFStringRef v5 = 0;
  }
  CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<chunk_instance %p> item:%@ ordering:%d chunk:%@", a1, v3, *(unsigned int *)(a1 + 24), v5);
  if (v3) {
    CFRelease(v3);
  }
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t mmcs_chunk_instance_equal(uint64_t a1, uint64_t a2)
{
  if (a1 && *(_DWORD *)a1 != 1) {
    mmcs_chunk_instance_equal_cold_2();
  }
  if (a2 && *(_DWORD *)a2 != 1) {
    mmcs_chunk_instance_equal_cold_1();
  }
  if (a1 == a2) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24) || *(void *)(a1 + 8) != *(void *)(a2 + 8)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(a2 + 56);
  return mmcs_chunk_reference_equal(v3, v4);
}

uint64_t mmcs_chunk_instance_hash(uint64_t a1)
{
  return *(void *)(a1 + 56) ^ *(void *)(a1 + 8);
}

BOOL mmcs_chunk_instance_is_chunk_reference(_DWORD *a1)
{
  return *a1 == 1;
}

uint64_t mmcs_chunk_instance_init(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)a1 = 1;
  *(void *)(a1 + 56) = a2;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 8) = a5;
  *(void *)(a1 + 16) = -1;
  *(unsigned char *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 4);
  return 1;
}

uint64_t mmcs_chunk_instance_init_with_source_instance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 24) = a5;
  *(_DWORD *)a1 = 1;
  *(void *)(a1 + 56) = a3;
  *(void *)(a1 + 32) = a4;
  *(void *)(a1 + 8) = a6;
  *(void *)(a1 + 16) = -1;
  *(unsigned char *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  return 1;
}

double mmcs_chunk_instance_init_with_file_opaque_reference_data(uint64_t a1, uint64_t a2, int a3, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 16) = -1;
  *(_DWORD *)(a1 + 24) = a3;
  *(_DWORD *)a1 = 2;
  *(void *)(a1 + 80) = cf;
  *(void *)(a1 + 32) = a2;
  return result;
}

double mmcs_chunk_instance_init_with_file_opaque_reference_length(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 24) = a3;
  *(_DWORD *)a1 = 3;
  *(_DWORD *)(a1 + 96) = a4;
  *(void *)(a1 + 32) = a2;
  *(void *)(a1 + 8) = a5;
  *(void *)(a1 + 16) = -1;
  return result;
}

uint64_t mmcs_chunk_instance_create(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  *a1 = 0;
  uint64_t v10 = (char *)malloc_type_malloc(0x68uLL, 0x1060040917B5EB5uLL);
  if (!v10) {
    return 0;
  }
  *(_OWORD *)(v10 + 20) = 0u;
  *(_OWORD *)(v10 + 4) = 0u;
  *(_OWORD *)(v10 + 52) = 0u;
  *(_OWORD *)(v10 + 36) = 0u;
  *((_DWORD *)v10 + 25) = 0;
  *(_OWORD *)(v10 + 84) = 0u;
  *(_OWORD *)(v10 + 68) = 0u;
  *((_DWORD *)v10 + 6) = a4;
  uint64_t v11 = 1;
  *(_DWORD *)uint64_t v10 = 1;
  *((void *)v10 + 7) = a2;
  *((void *)v10 + 4) = a3;
  *((void *)v10 + 1) = a5;
  *((void *)v10 + 2) = -1;
  *((_DWORD *)v10 + 16) = *(_DWORD *)(a2 + 4);
  *a1 = v10;
  return v11;
}

void mmcs_chunk_instance_finalize(void *a1)
{
  a1[1] = 0;
  a1[7] = 0;
  uint64_t v2 = (const void *)a1[10];
  if (v2) {
    CFRelease(v2);
  }
  a1[10] = 0;
  uint64_t v3 = (const void *)a1[11];
  if (v3) {
    CFRelease(v3);
  }
  a1[11] = 0;
}

BOOL mmcs_chunk_instance_is_ford(_DWORD *a1)
{
  return (*a1 & 0xFFFFFFFE) == 2;
}

CFIndex mmcs_chunk_instance_get_length(CFDataRef *a1)
{
  int v1 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 == 3) {
    return *((unsigned int *)a1 + 24);
  }
  if (v1 == 2) {
    return CFDataGetLength(a1[10]);
  }
  if (v1 != 1) {
    mmcs_chunk_instance_get_length_cold_1();
  }
  return *((unsigned int *)a1 + 16);
}

void mmcs_chunk_instance_dealloc(void *a1)
{
  mmcs_chunk_instance_finalize(a1);
  if (a1)
  {
    free(a1);
  }
}

void mmcs_chunk_instance_was_put(uint64_t a1, uint64_t a2)
{
  mmcs_item_remove_outstanding_chunk_reference(*(void *)(a1 + 8), *(const void **)(a1 + 56));
  int has_outstanding_chunk_references = mmcs_item_has_outstanding_chunk_references(*(void *)(a1 + 8));
  if (a2)
  {
    if (!has_outstanding_chunk_references)
    {
      CFStringRef v5 = *(__CFSet **)(a2 + 8);
      if (v5)
      {
        CFStringRef v6 = *(const void **)(a1 + 8);
        CFSetSetValue(v5, v6);
      }
    }
  }
}

uint64_t mmcs_chunk_instance_offset(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t mmcs_chunk_instance_create_RegisteredChunk()
{
  uint64_t RegisteredChunk = mmcs_chunk_reference_create_RegisteredChunk();
  if (RegisteredChunk)
  {
    CKRegisteredChunkSetItemID();
    CKRegisteredChunkSetOffset();
    CKRegisteredChunkSetLocation();
  }
  return RegisteredChunk;
}

void *MMCSItemReaderWriterCreate(void *a1)
{
  if (*a1 > 7uLL) {
    return 0;
  }
  size_t v2 = qword_1DC251C60[*a1];
  uint64_t v3 = C3TypeRegister(&MMCSItemReaderWriterGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v3, 0x10uLL);
  CFStringRef v5 = (void *)Instance;
  if (!Instance) {
    return v5;
  }
  *(_DWORD *)(Instance + 16) = 0;
  CFStringRef v6 = malloc_type_calloc(1uLL, v2, 0xA4F008A0uLL);
  v5[3] = v6;
  if (!v6)
  {
    C3BaseRelease(v5);
    return 0;
  }
  memcpy(v6, a1, v2);
  CFAllocatorRef v7 = (void *)v5[3];
  CFStringRef v8 = (const void *)v7[2];
  if (v8)
  {
    CFRetain(v8);
    CFAllocatorRef v7 = (void *)v5[3];
  }
  uint64_t v9 = (const void *)v7[3];
  if (v9)
  {
    CFRetain(v9);
    CFAllocatorRef v7 = (void *)v5[3];
  }
  uint64_t v10 = (void (*)(void))v7[4];
  if (v10) {
    v10(v7[1]);
  }
  return v5;
}

BOOL MMCSItemReaderWriterEquals(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t MMCSItemReaderWriterOpen(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(unsigned char *)(a1 + 22))
  {
    CFStringRef v10 = @"Opening the readerWriter failed because it is already open";
LABEL_7:
    CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, v10, v5, v6, v7, v8, v9, v20);
    os_unfair_lock_unlock(v4);
    uint64_t v17 = 0;
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 23))
  {
    CFStringRef v10 = @"Opening the readerWriter failed because it is already opening";
    goto LABEL_7;
  }
  if (*(unsigned char *)(a1 + 21))
  {
    CFStringRef v10 = @"Opening the readerWriter failed because it is has been opened before";
    goto LABEL_7;
  }
  *(unsigned char *)(a1 + 23) = 1;
  os_unfair_lock_unlock(v4);
  uint64_t v17 = (*(uint64_t (**)(uint64_t, void, CFTypeRef *))(*(void *)(a1 + 24) + 56))(a1, *(void *)(*(void *)(a1 + 24) + 8), &cf);
  os_unfair_lock_lock(v4);
  *(_WORD *)(a1 + 22) = v17;
  if (v17) {
    *(unsigned char *)(a1 + 21) = 1;
  }
  os_unfair_lock_unlock(v4);
LABEL_8:
  CFTypeRef v18 = cf;
  if (a2 && !v17)
  {
    CFTypeRef cf = mmcs_cferror_create_file_error_wrapping_error_to_release((__CFError *)cf, (char)@"Opening the readerWriter failed. ", v11, v12, v13, v14, v15, v16);
    CFRetain(cf);
    CFTypeRef v18 = cf;
    *a2 = cf;
  }
  if (v18) {
    CFRelease(v18);
  }
  return v17;
}

uint64_t MMCSItemReaderWriterSync(uint64_t a1, CFErrorRef *a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (*(uint64_t *)v2 < 6) {
    return 1;
  }
  uint64_t v10 = (*(uint64_t (**)(void))(v2 + 144))();
  CFErrorRef v11 = 0;
  if (a2 && !v10)
  {
    CFErrorRef cf = mmcs_cferror_create_file_error_wrapping_error_to_release(0, (char)@"Syncing  the readerWriter failed. ", v4, v5, v6, v7, v8, v9);
    CFRetain(cf);
    CFErrorRef v11 = cf;
    *a2 = cf;
  }
  if (v11) {
    CFRelease(v11);
  }
  return v10;
}

uint64_t MMCSItemReaderWriterSetNeverClose(uint64_t result, char a2)
{
  *(unsigned char *)(result + 20) = a2;
  return result;
}

void MMCSItemReaderWriterEnsureClosed(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1 && *(unsigned char *)(a1 + 22))
  {
    CFTypeRef cf = 0;
    if (!MMCSItemReaderWriterClose(a1, (CFErrorRef *)&cf))
    {
      if (cf) {
        int v1 = mmcs_cferror_copy_description((__CFError *)cf);
      }
      else {
        int v1 = 0;
      }
      uint64_t v2 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        uint64_t v3 = @"unknown";
        if (v1) {
          uint64_t v3 = v1;
        }
        CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Error closing item reader writer: %@", v3);
        uint64_t v5 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v8 = v4;
          _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v4) {
          CFRelease(v4);
        }
      }
      if (v1) {
        CFRelease(v1);
      }
    }
    if (cf) {
      CFRelease(cf);
    }
  }
}

uint64_t MMCSItemReaderWriterIsOpen(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 22);
}

uint64_t MMCSItemReaderWriterClose(uint64_t a1, CFErrorRef *a2)
{
  CFErrorRef file_error_wrapping_error_to_release = 0;
  CFStringRef v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(unsigned char *)(a1 + 23))
  {
    CFStringRef v10 = @"Cannot close the readerWriter because it is still opening";
  }
  else
  {
    if (*(unsigned char *)(a1 + 22))
    {
      if (*(unsigned char *)(a1 + 20))
      {
        os_unfair_lock_unlock(v4);
        return 1;
      }
      *(unsigned char *)(a1 + 22) = 0;
      os_unfair_lock_unlock(v4);
      uint64_t v18 = (*(uint64_t (**)(uint64_t, void, CFErrorRef *))(*(void *)(a1 + 24) + 72))(a1, *(void *)(*(void *)(a1 + 24) + 8), &file_error_wrapping_error_to_release);
      CFErrorRef v11 = file_error_wrapping_error_to_release;
      if (a2) {
        goto LABEL_4;
      }
      goto LABEL_6;
    }
    CFStringRef v10 = @"Cannot close the readerWriter because it is not open";
  }
  CFErrorRef v11 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, v10, v5, v6, v7, v8, v9, v20);
  CFErrorRef file_error_wrapping_error_to_release = v11;
  os_unfair_lock_unlock(v4);
  uint64_t v18 = 0;
  if (a2)
  {
LABEL_4:
    if (!v18)
    {
      CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_file_error_wrapping_error_to_release(v11, (char)@"Closing the readerWriter failed. ", v12, v13, v14, v15, v16, v17);
      CFRetain(file_error_wrapping_error_to_release);
      CFErrorRef v11 = file_error_wrapping_error_to_release;
      *a2 = file_error_wrapping_error_to_release;
    }
  }
LABEL_6:
  if (v11) {
    CFRelease(v11);
  }
  return v18;
}

uint64_t MMCSItemReaderWriterStat(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  CFTypeRef error = 0;
  uint64_t v10 = *(void *)(a1 + 24);
  if (*(void *)v10)
  {
    if (*(uint64_t *)v10 >= 1)
    {
      uint64_t v11 = (*(uint64_t (**)(void))(v10 + 48))();
      if (!a3) {
        goto LABEL_14;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v17 = 0;
    if ((*(unsigned int (**)(uint64_t))(v10 + 48))(a1))
    {
      CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFNumberRef v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &v17);
      if (v13)
      {
        CFNumberRef v14 = v13;
        values = v13;
        keys[0] = @"kMMCSItemReaderWriterFileSize";
        uint64_t v11 = 1;
        CFTypeRef cf = CFDictionaryCreate(v12, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFRelease(v14);
        if (!a3) {
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t v11 = 0;
        CFTypeRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 36, @"MMCSItemReaderWriterStat create number failed");
        if (!a3) {
          goto LABEL_14;
        }
      }
      goto LABEL_10;
    }
  }
  uint64_t v11 = 0;
  if (!a3)
  {
LABEL_14:
    if (a2 && v11)
    {
      CFRetain(cf);
      *a2 = cf;
    }
    CFTypeRef v15 = error;
    if (error) {
      goto LABEL_18;
    }
    goto LABEL_19;
  }
LABEL_10:
  if (v11) {
    goto LABEL_14;
  }
  CFTypeRef error = mmcs_cferror_create_file_error_wrapping_error_to_release((__CFError *)error, (char)@"Stat'ing the readerWriter failed. ", (uint64_t)a3, a4, a5, a6, a7, a8);
  CFRetain(error);
  CFTypeRef v15 = error;
  *a3 = error;
  if (v15) {
LABEL_18:
  }
    CFRelease(v15);
LABEL_19:
  CFTypeRef error = 0;
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t MMCSItemReaderWriterRead(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, CFErrorRef *a6)
{
  uint64_t v13 = (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 64))();
  CFErrorRef v14 = 0;
  if (a6 && !v13)
  {
    CFErrorRef cf = mmcs_cferror_create_file_error_wrapping_error_to_release(0, (char)@"Reading from the readerWriter failed. ", v7, v8, v9, v10, v11, v12);
    CFRetain(cf);
    CFErrorRef v14 = cf;
    *a6 = cf;
  }
  if (v14) {
    CFRelease(v14);
  }
  return v13;
}

uint64_t MMCSItemReaderWriterGetCacheBlobWithName(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(uint64_t **)(a1 + 24);
  if (*v9 < 1)
  {
    if (!*v9) {
      MMCSItemReaderWriterGetCacheBlobWithName_cold_1();
    }
LABEL_6:
    uint64_t v11 = 0;
    if (!a4) {
      return v11;
    }
    goto LABEL_7;
  }
  uint64_t v10 = (uint64_t (*)(void))v9[10];
  if (!v10) {
    goto LABEL_6;
  }
  uint64_t v11 = v10();
  if (!a4) {
    return v11;
  }
LABEL_7:
  if (!v11)
  {
    CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_file_error_wrapping_error_to_release(0, (char)@"Getting the cache blob from the readerWriter failed. ", a3, (uint64_t)a4, a5, a6, a7, a8);
    CFRetain(file_error_wrapping_error_to_release);
    *a4 = file_error_wrapping_error_to_release;
    if (file_error_wrapping_error_to_release) {
      CFRelease(file_error_wrapping_error_to_release);
    }
  }
  return v11;
}

uint64_t MMCSItemReaderWriterSetCacheBlobWithName(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(uint64_t **)(a1 + 24);
  if (*v9 < 1)
  {
    if (!*v9) {
      MMCSItemReaderWriterSetCacheBlobWithName_cold_1();
    }
LABEL_6:
    uint64_t v11 = 0;
    if (!a4) {
      return v11;
    }
    goto LABEL_7;
  }
  uint64_t v10 = (uint64_t (*)(void))v9[11];
  if (!v10) {
    goto LABEL_6;
  }
  uint64_t v11 = v10();
  if (!a4) {
    return v11;
  }
LABEL_7:
  if (!v11)
  {
    CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_file_error_wrapping_error_to_release(0, (char)@"Setting the cache blob from the readerWriter failed. ", a3, (uint64_t)a4, a5, a6, a7, a8);
    CFRetain(file_error_wrapping_error_to_release);
    *a4 = file_error_wrapping_error_to_release;
    if (file_error_wrapping_error_to_release) {
      CFRelease(file_error_wrapping_error_to_release);
    }
  }
  return v11;
}

uint64_t MMCSItemReaderWriterGetFileTypeHint(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1) {
      return *(void *)(v1 + 16);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t MMCSItemReaderWriterWrite(uint64_t a1, uint64_t **a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t *a6, CFTypeRef *a7)
{
  uint64_t v7 = a7;
  unint64_t v9 = a5;
  if (a7) {
    *a7 = 0;
  }
  if (a6) {
    *a6 = 0;
  }
  CFErrorRef v14 = *(uint64_t **)(a1 + 24);
  if (*v14 <= 2) {
    MMCSItemReaderWriterWrite_cold_1();
  }
  if (*v14 == 3 || (unint64_t v15 = v14[16]) == 0)
  {
    CFTypeRef cf = 0;
    uint64_t v16 = (uint64_t (*)(uint64_t, uint64_t, unint64_t, uint64_t, unint64_t, unint64_t *, CFTypeRef *))v14[13];
    if (!v16) {
      MMCSItemReaderWriterWrite_cold_2();
    }
    uint64_t v23 = v16(a1, v14[1], a3, a4, a5, a6, &cf);
    CFTypeRef v24 = cf;
    if (v7 && !v23)
    {
      CFTypeRef cf = mmcs_cferror_create_file_error_wrapping_error_to_release((__CFError *)cf, (char)@"Writing to the readerWriter failed. ", v17, v18, v19, v20, v21, v22);
      CFRetain(cf);
      CFTypeRef v24 = cf;
      *uint64_t v7 = cf;
    }
    if (v24) {
      CFRelease(v24);
    }
    return v23;
  }
  if (!v14[13]) {
    MMCSItemReaderWriterWrite_cold_3();
  }
  if (!a2) {
    MMCSItemReaderWriterWrite_cold_4();
  }
  if (*a2)
  {
    if (v15 != (*a2)[2]) {
      MMCSItemReaderWriterWrite_cold_6();
    }
  }
  else
  {
    if (!mmcs_get_file_sparse_context_create(a2, v15))
    {
      *a2 = 0;
      uint64_t v23 = 0;
      *uint64_t v7 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, @"Failed to create sparse context.", v26, v27, v28, v29, v30, v66);
      return v23;
    }
    unint64_t v15 = v14[16];
    (*a2)[2] = v15;
  }
  int v70 = (uint64_t *)a2;
  unint64_t v71 = a3;
  if (a3 % v15)
  {
    if (v15 - a3 % v15 >= v9) {
      unint64_t v31 = v9;
    }
    else {
      unint64_t v31 = v15 - a3 % v15;
    }
    int v32 = !mmcs_zcmp(a4, v31);
    unint64_t v15 = v14[16];
  }
  else
  {
    int v32 = 0;
    unint64_t v31 = 0;
  }
  uint64_t v72 = a1;
  unint64_t v33 = v9 - v31;
  if (v15 > v9 - v31)
  {
    unint64_t v34 = 0;
    uint64_t v35 = 0;
    unint64_t v36 = v9 - v31;
    goto LABEL_53;
  }
  unint64_t v68 = v9;
  uint64_t v69 = v7;
  uint64_t v35 = 0;
  unint64_t v34 = 0;
  unint64_t v67 = v9 - v31;
  unint64_t v37 = v33 / v15;
  if (v37 <= 1) {
    uint64_t v38 = 1;
  }
  else {
    uint64_t v38 = v37;
  }
  do
  {
    BOOL v39 = mmcs_zcmp(a4 + v31, v15);
    if (!v39)
    {
      if ((v32 & 1) == 0) {
        unint64_t v34 = v31;
      }
      if (!((a6 == 0) | v32 & 1))
      {
        *a6 += v31 + v35;
        unint64_t v34 = v31;
      }
      goto LABEL_48;
    }
    if ((v32 & 1) == 0) {
      goto LABEL_48;
    }
    CFTypeRef v40 = (CFTypeRef)(v31 - v34);
    CFTypeRef file_error_wrapping_error_to_release = 0;
    CFTypeRef cf = 0;
    uint64_t v23 = ((uint64_t (*)(uint64_t, void, unint64_t, unint64_t, unint64_t, CFTypeRef *, CFTypeRef *))v14[13])(v72, *(void *)(*(void *)(v72 + 24) + 8), v34 + v71, a4 + v34, v31 - v34, &cf, &file_error_wrapping_error_to_release);
    if (v23)
    {
      trackWriteBlocks(v72, *v70, v34 + v71, (uint64_t)cf);
LABEL_37:
      CFTypeRef v47 = file_error_wrapping_error_to_release;
      if (!file_error_wrapping_error_to_release) {
        goto LABEL_39;
      }
LABEL_38:
      CFRelease(v47);
      goto LABEL_39;
    }
    if (!v69) {
      goto LABEL_37;
    }
    CFTypeRef file_error_wrapping_error_to_release = mmcs_cferror_create_file_error_wrapping_error_to_release((__CFError *)file_error_wrapping_error_to_release, (char)@"Writing to the readerWriter failed. ", v41, v42, v43, v44, v45, v46);
    CFRetain(file_error_wrapping_error_to_release);
    CFTypeRef v47 = file_error_wrapping_error_to_release;
    CFTypeRef *v69 = file_error_wrapping_error_to_release;
    if (v47) {
      goto LABEL_38;
    }
LABEL_39:
    CFTypeRef v48 = cf;
    if (a6) {
      *a6 += (unint64_t)cf;
    }
    if (!v23) {
      return v23;
    }
    unint64_t v34 = v31;
    if (v40 != v48) {
      return v23;
    }
LABEL_48:
    int v32 = !v39;
    unint64_t v15 = v14[16];
    v31 += v15;
    uint64_t v35 = -(uint64_t)v34;
    --v38;
  }
  while (v38);
  unint64_t v9 = v68;
  uint64_t v7 = v69;
  unint64_t v36 = v68 - v31;
  unint64_t v33 = v67;
LABEL_53:
  if (v36 != v33 % v15) {
    MMCSItemReaderWriterWrite_cold_5();
  }
  if (v31 == v9 || mmcs_zcmp(a4 + v31, v36))
  {
    if (v32)
    {
      CFTypeRef file_error_wrapping_error_to_release = 0;
      CFTypeRef cf = 0;
      uint64_t v23 = ((uint64_t (*)(uint64_t, void, unint64_t, unint64_t, unint64_t, CFTypeRef *, CFTypeRef *))v14[13])(v72, *(void *)(*(void *)(v72 + 24) + 8), v34 + v71, a4 + v34, v31 - v34, &cf, &file_error_wrapping_error_to_release);
      if (v23)
      {
        trackWriteBlocks(v72, *v70, v34 + v71, (uint64_t)cf);
        goto LABEL_59;
      }
      if (v7)
      {
        CFTypeRef file_error_wrapping_error_to_release = mmcs_cferror_create_file_error_wrapping_error_to_release((__CFError *)file_error_wrapping_error_to_release, (char)@"Writing to the readerWriter failed. ", v49, v50, v51, v52, v53, v54);
        CFRetain(file_error_wrapping_error_to_release);
        CFTypeRef v55 = file_error_wrapping_error_to_release;
        *uint64_t v7 = file_error_wrapping_error_to_release;
        if (!v55)
        {
LABEL_61:
          CFTypeRef v56 = cf;
          if (a6) {
            *a6 += (unint64_t)cf;
          }
          if (!v23 || (CFTypeRef)(v31 - v34) != v56) {
            return v23;
          }
LABEL_67:
          if (v31 == v9)
          {
            if (a6) {
              char v57 = v32;
            }
            else {
              char v57 = 1;
            }
            if (v57) {
              return v23;
            }
          }
          else if (!a6)
          {
            return v23;
          }
          *a6 = v9;
          return v23;
        }
      }
      else
      {
LABEL_59:
        CFTypeRef v55 = file_error_wrapping_error_to_release;
        if (!file_error_wrapping_error_to_release) {
          goto LABEL_61;
        }
      }
      CFRelease(v55);
      goto LABEL_61;
    }
    uint64_t v23 = 0;
    goto LABEL_67;
  }
  char v58 = v32 ^ 1;
  if (!a6) {
    char v58 = 0;
  }
  if (v58)
  {
    *a6 += v31 + v35;
  }
  else
  {
    if (v32) {
      unint64_t v31 = v34;
    }
    unint64_t v36 = v9 - v31;
  }
  CFTypeRef file_error_wrapping_error_to_release = 0;
  CFTypeRef cf = 0;
  uint64_t v23 = ((uint64_t (*)(uint64_t, void, unint64_t, unint64_t, unint64_t, CFTypeRef *, CFTypeRef *))v14[13])(v72, *(void *)(*(void *)(v72 + 24) + 8), v31 + v71, a4 + v31, v36, &cf, &file_error_wrapping_error_to_release);
  if (v23)
  {
    trackWriteBlocks(v72, *v70, v31 + v71, (uint64_t)cf);
    goto LABEL_88;
  }
  if (v7)
  {
    CFTypeRef file_error_wrapping_error_to_release = mmcs_cferror_create_file_error_wrapping_error_to_release((__CFError *)file_error_wrapping_error_to_release, (char)@"Writing to the readerWriter failed. ", v59, v60, v61, v62, v63, v64);
    CFRetain(file_error_wrapping_error_to_release);
    CFTypeRef v65 = file_error_wrapping_error_to_release;
    *uint64_t v7 = file_error_wrapping_error_to_release;
    if (!v65) {
      goto LABEL_90;
    }
LABEL_89:
    CFRelease(v65);
  }
  else
  {
LABEL_88:
    CFTypeRef v65 = file_error_wrapping_error_to_release;
    if (file_error_wrapping_error_to_release) {
      goto LABEL_89;
    }
  }
LABEL_90:
  if (a6) {
    *a6 += (unint64_t)cf;
  }
  return v23;
}

void *trackWriteBlocks(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  CFStringRef v4 = *(uint64_t **)(a1 + 24);
  if (*v4 <= 3) {
    trackWriteBlocks_cold_1();
  }
  unint64_t v5 = v4[16];
  if (!v5) {
    trackWriteBlocks_cold_2();
  }
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v7 = *(void *)(a2 + 32);
  if (v7 <= a4 + a3) {
    unint64_t v7 = a4 + a3;
  }
  *(void *)(a2 + 32) = v7;
  if (!v6) {
    trackWriteBlocks_cold_3();
  }
  unint64_t v8 = a3 / v5;
  if (a3 / v5 >= 0x7FFFFFFF) {
    trackWriteBlocks_cold_4();
  }
  unint64_t v9 = (a4 + a3 - 1) / v5;
  if (v9 >= 0x7FFFFFFF) {
    trackWriteBlocks_cold_5();
  }
  return mmcs_index_set_add_range(v6, v8, v9);
}

uint64_t MMCSItemReaderWriterSeek(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  if (a4) {
    *a4 = 0;
  }
  unint64_t v5 = *(uint64_t **)(a1 + 24);
  if (*v5 < 4) {
    return 1;
  }
  uint64_t v6 = v5[16];
  if (!v6) {
    return 1;
  }
  if (!a2) {
    MMCSItemReaderWriterSeek_cold_1();
  }
  if (*(void *)(a2 + 16) != v6) {
    MMCSItemReaderWriterSeek_cold_3();
  }
  unint64_t v7 = (uint64_t (*)(void))v5[15];
  if (!v7) {
    MMCSItemReaderWriterSeek_cold_2();
  }
  uint64_t v14 = v7();
  CFErrorRef v15 = 0;
  if (a4 && !v14)
  {
    CFErrorRef cf = mmcs_cferror_create_file_error_wrapping_error_to_release(0, (char)@"Seeking with readerWriter failed. ", v8, v9, v10, v11, v12, v13);
    CFRetain(cf);
    CFErrorRef v15 = cf;
    *a4 = cf;
  }
  if (v15) {
    CFRelease(v15);
  }
  return v14;
}

uint64_t MMCSItemReaderWriterValidated(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5)
{
  if (a5) {
    *a5 = 0;
  }
  uint64_t v6 = *(uint64_t **)(a1 + 24);
  if (*v6 < 7) {
    return 1;
  }
  unint64_t v7 = (uint64_t (*)(void))v6[19];
  if (!v7) {
    return 1;
  }
  uint64_t v14 = v7();
  CFErrorRef v15 = 0;
  if (a5 && !v14)
  {
    CFErrorRef cf = mmcs_cferror_create_file_error_wrapping_error_to_release(0, (char)@"Seeking with readerWriter failed. ", v8, v9, v10, v11, v12, v13);
    CFRetain(cf);
    CFErrorRef v15 = cf;
    *a5 = cf;
  }
  if (v15) {
    CFRelease(v15);
  }
  return v14;
}

void *MMCSItemReaderWriterCKItemReadContextCreate(uint64_t a1)
{
  uint64_t v2 = *(const void **)(*(void *)(a1 + 24) + 16);
  if (v2 && CFEqual(v2, @"com.apple.mmcs.kMMCSFixedLengthChunkerFileHint")) {
    uint64_t v2 = (const void *)MMCSGetCKCustomFixedChunkFileTypeHintString();
  }
  double result = malloc_type_calloc(1uLL, 0x68uLL, 0x10E0040C92A543BuLL);
  if (result)
  {
    CFStringRef v4 = *(uint64_t **)(a1 + 24);
    uint64_t v5 = *v4;
    *(_DWORD *)double result = 3;
    result[1] = a1;
    result[2] = v2;
    result[3] = v4[3];
    result[4] = C3BaseRetain;
    result[5] = C3BaseRelease;
    result[6] = _MMCSItemReaderWriter_CKItemReadContextOpen;
    result[7] = _MMCSItemReaderWriter_CKItemReadContextClose;
    result[8] = _MMCSItemReaderWriter_CKItemReadContextStat;
    result[9] = _MMCSItemReaderWriter_CKItemReadContextRead;
    BOOL v6 = v5 <= 0;
    if (v5 <= 0) {
      unint64_t v7 = 0;
    }
    else {
      unint64_t v7 = _MMCSItemReaderWriter_CKItemReadContextGetCacheBlob;
    }
    if (v6) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = _MMCSItemReaderWriter_CKItemReadContextSetCacheBlob;
    }
    result[10] = v7;
    result[11] = v8;
    result[12] = _MMCSItemReaderWriter_CKItemReadContextCopyPropertyV3;
  }
  return result;
}

uint64_t _MMCSItemReaderWriter_CKItemReadContextOpen(uint64_t a1, void *a2, void *a3)
{
  if (a3) {
    *a3 = 0;
  }
  *a2 = a1;
  return 1;
}

BOOL _MMCSItemReaderWriter_CKItemReadContextStat(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef theDict = 0;
  int v9 = MMCSItemReaderWriterStat(a1, (CFTypeRef *)&theDict, a3, a4, a5, a6, a7, a8);
  if (v9)
  {
    *(void *)(a2 + 32) = 0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kMMCSItemReaderWriterFileSize");
    if (Value)
    {
      uint64_t v15 = 0;
      if (CFNumberGetValue(Value, kCFNumberSInt64Type, &v15)) {
        *(void *)a2 = v15;
      }
    }
    CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kMMCSItemReaderWriterFileSystemFileNumber");
    if (v11)
    {
      uint64_t v15 = 0;
      if (CFNumberGetValue(v11, kCFNumberSInt64Type, &v15)) {
        *(void *)(a2 + 8) = v15;
      }
    }
    CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kMMCSItemReaderWriterFileModificationTime");
    if (v12)
    {
      uint64_t v15 = 0;
      if (CFNumberGetValue(v12, kCFNumberSInt64Type, &v15)) {
        *(void *)(a2 + 16) = v15;
      }
    }
    CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kMMCSItemReaderWriterFileGenerationNumber");
    if (v13)
    {
      LODWORD(v15) = 0;
      if (CFNumberGetValue(v13, kCFNumberSInt32Type, &v15))
      {
        *(_DWORD *)(a2 + 28) = v15;
        *(unsigned char *)(a2 + 24) = 1;
      }
    }
  }
  if (theDict) {
    CFRelease(theDict);
  }
  return v9 != 0;
}

uint64_t _MMCSItemReaderWriter_CKItemReadContextCopyPropertyV3(uint64_t a1, CFTypeRef cf1)
{
  if (!a1 || !cf1) {
    return 0;
  }
  if (!CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E4F58F68]))
  {
    if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E4F58F88]))
    {
      CFNumberRef v12 = *(uint64_t **)(a1 + 24);
      if (*v12 < 5) {
        return 0;
      }
      int v9 = (uint64_t (*)(uint64_t, uint64_t, __CFString *))v12[17];
      if (!v9) {
        return 0;
      }
      uint64_t v10 = v12[1];
      CFNumberRef v11 = @"kMMCSItemSubchunkLength";
    }
    else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E4F58F80]))
    {
      CFNumberRef v13 = *(uint64_t **)(a1 + 24);
      if (*v13 < 5) {
        return 0;
      }
      int v9 = (uint64_t (*)(uint64_t, uint64_t, __CFString *))v13[17];
      if (!v9) {
        return 0;
      }
      uint64_t v10 = v13[1];
      CFNumberRef v11 = @"kMMCSItemChunkProfileConfigurationVersion";
    }
    else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E4F58F78]))
    {
      uint64_t v14 = *(uint64_t **)(a1 + 24);
      if (*v14 < 5) {
        return 0;
      }
      int v9 = (uint64_t (*)(uint64_t, uint64_t, __CFString *))v14[17];
      if (!v9) {
        return 0;
      }
      uint64_t v10 = v14[1];
      CFNumberRef v11 = @"kMMCSItemChunkProfileConfigurationFileExtensionToProfileMap";
    }
    else
    {
      if (!CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E4F58F70])) {
        return 0;
      }
      uint64_t v15 = *(uint64_t **)(a1 + 24);
      if (*v15 < 5) {
        return 0;
      }
      int v9 = (uint64_t (*)(uint64_t, uint64_t, __CFString *))v15[17];
      if (!v9) {
        return 0;
      }
      uint64_t v10 = v15[1];
      CFNumberRef v11 = @"kMMCSItemChunkProfileConfigurationDefaultProfilePolicy";
    }
    goto LABEL_32;
  }
  CFStringRef v4 = *(uint64_t **)(a1 + 24);
  if (*v4 < 5 || (uint64_t v5 = (uint64_t (*)(uint64_t, uint64_t, __CFString *))v4[17]) == 0)
  {
    CFBooleanRef cfBOOLean_from_cftype_using_description = (const __CFBoolean *)mmcs_get_cfBOOLean_from_cftype_using_description(@"kMMCSChunkerAllowItemChunkLengthServerConfigurationOverride", 0, 0);
    if (cfBOOLean_from_cftype_using_description) {
      goto LABEL_9;
    }
LABEL_12:
    if (!mmcs_report_chunker_allow_item_chunk_length_28455742()) {
      return 0;
    }
    goto LABEL_13;
  }
  CFStringRef v6 = (const __CFString *)v5(a1, v4[1], @"kMMCSChunkerAllowItemChunkLengthServerConfigurationOverride");
  CFBooleanRef cfBOOLean_from_cftype_using_description = (const __CFBoolean *)mmcs_get_cfBOOLean_from_cftype_using_description(@"kMMCSChunkerAllowItemChunkLengthServerConfigurationOverride", v6, 0);
  if (v6) {
    CFRelease(v6);
  }
  if (!cfBOOLean_from_cftype_using_description) {
    goto LABEL_12;
  }
LABEL_9:
  if (!CFBooleanGetValue(cfBOOLean_from_cftype_using_description)) {
    return 0;
  }
LABEL_13:
  uint64_t v8 = *(uint64_t **)(a1 + 24);
  if (*v8 < 5) {
    return 0;
  }
  int v9 = (uint64_t (*)(uint64_t, uint64_t, __CFString *))v8[17];
  if (!v9) {
    return 0;
  }
  uint64_t v10 = v8[1];
  CFNumberRef v11 = @"kMMCSItemChunkLength";
LABEL_32:
  return v9(a1, v10, v11);
}

unsigned char *MMCSItemReaderWriterCreateWithFileDescriptor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  memset(&v48, 0, sizeof(v48));
  if (fstat(a1, &v48) < 0)
  {
    int v20 = *__error();
    CFIndex v21 = v20;
    strerror(v20);
    CFErrorRef file_error_with_format = mmcs_cferror_create_file_error_with_format(v21, @"fstat(%d) failed: %s", v22, v23, v24, v25, v26, v27, a1);
    goto LABEL_14;
  }
  if ((v48.st_mode & 0xF000) == 0xA000)
  {
    bzero(v50, 0x400uLL);
    if ((get_path_for_fd(a1, v50) & 0x80000000) != 0)
    {
      int v30 = *__error();
      CFIndex v31 = v30;
      strerror(v30);
      CFErrorRef file_error_with_format = mmcs_cferror_create_file_error_with_format(v31, @"getpath(%d) failed: %s", v32, v33, v34, v35, v36, v37, a1);
    }
    else
    {
      bzero(bytes, 0x400uLL);
      ssize_t v10 = readlink(v50, (char *)bytes, 0x400uLL);
      if ((v10 & 0x8000000000000000) == 0)
      {
        CFDataRef v11 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, v10);
        if (v11)
        {
          CFDataRef v17 = v11;
          uint64_t v18 = MMCSItemReaderWriterCreateWithData(v11, a2, a3);
          CFRelease(v17);
          CFErrorRef v19 = 0;
          if (!a5)
          {
LABEL_19:
            if (v19) {
              CFRelease(v19);
            }
            goto LABEL_21;
          }
LABEL_16:
          if (v18) {
            goto LABEL_19;
          }
          if (v19)
          {
            CFRetain(v19);
            *a5 = v19;
            goto LABEL_27;
          }
LABEL_26:
          CFErrorRef v19 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"Creating the readerWriter failed for an unspecified reason", v12, v13, v14, v15, v16, v47);
          CFRetain(v19);
          *a5 = v19;
          if (!v19) {
            return 0;
          }
LABEL_27:
          CFRelease(v19);
          return 0;
        }
        CFErrorRef v19 = 0;
LABEL_15:
        uint64_t v18 = 0;
        if (!a5) {
          goto LABEL_19;
        }
        goto LABEL_16;
      }
      int v38 = *__error();
      CFIndex v39 = v38;
      strerror(v38);
      CFErrorRef file_error_with_format = mmcs_cferror_create_file_error_with_format(v39, @"readlink(%d) failed: %s", v40, v41, v42, v43, v44, v45, a1);
    }
LABEL_14:
    CFErrorRef v19 = file_error_with_format;
    goto LABEL_15;
  }
  uint64_t v29 = MMCSItemReaderWriterCreateWithPlainFileDescriptor(a1, a2, a3, a4);
  uint64_t v18 = v29;
  if (a5 && !v29) {
    goto LABEL_26;
  }
LABEL_21:
  if (v18)
  {
    if (v18[21]) {
      MMCSItemReaderWriterCreateWithFileDescriptor_cold_3();
    }
    if (v18[23]) {
      MMCSItemReaderWriterCreateWithFileDescriptor_cold_2();
    }
    if (v18[22]) {
      MMCSItemReaderWriterCreateWithFileDescriptor_cold_1();
    }
  }
  return v18;
}

uint64_t MMCSGetCacheBlobFd()
{
  return CKGetCacheBlobFd();
}

uint64_t MMCSSetCacheBlobFd()
{
  return CKSetCacheBlobFd();
}

void _MMCSItemReaderWriterCFFinalize(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (*(unsigned char *)(a1 + 22))
  {
    if (!MMCSItemReaderWriterClose(a1, (CFErrorRef *)&cf))
    {
      uint64_t v2 = mmcs_cferror_copy_description((__CFError *)cf);
      uint64_t v3 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Error closing item reader: %@", v2);
        uint64_t v5 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v11 = v4;
          _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v4) {
          CFRelease(v4);
        }
      }
      if (v2) {
        CFRelease(v2);
      }
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  CFTypeRef cf = 0;
  CFStringRef v6 = *(void **)(a1 + 24);
  if (v6)
  {
    if (*(uint64_t *)v6 >= 2)
    {
      unint64_t v7 = (void (*)(void))*((void *)v6 + 12);
      if (v7)
      {
        v7(*((void *)v6 + 1));
        CFStringRef v6 = *(void **)(a1 + 24);
      }
    }
    uint64_t v8 = (void (*)(void))*((void *)v6 + 5);
    if (v8)
    {
      v8(*((void *)v6 + 1));
      CFStringRef v6 = *(void **)(a1 + 24);
    }
    if (*((void *)v6 + 2))
    {
      CFRelease(*((CFTypeRef *)v6 + 2));
      CFStringRef v6 = *(void **)(a1 + 24);
    }
    *((void *)v6 + 2) = 0;
    if (*((void *)v6 + 3))
    {
      CFRelease(*((CFTypeRef *)v6 + 3));
      CFStringRef v6 = *(void **)(a1 + 24);
    }
    free(v6);
    *(void *)(a1 + 24) = 0;
  }
}

BOOL _MMCSItemReaderWriterCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _MMCSItemReaderWriterCFCopyFormatDescription()
{
  return 0;
}

uint64_t _MMCSItemReaderWriterCFCopyDebugDescription()
{
  return 0;
}

uint64_t mmcs_cache_delete_get_available_bytes_from_mount_path()
{
  uint64_t v2 = 0;
  CFTypeRef cf = 0;
  CFNumberRef v0 = (const __CFNumber *)CacheDeleteCopyAvailableSpaceForVolume();
  CFNumberGetValue(v0, kCFNumberLongLongType, &v2);
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef cf = 0;
  if (v0) {
    CFRelease(v0);
  }
  return v2;
}

CFStringRef mmcs_cache_delete_copy_mount_path_from_directory(const __CFURL *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  bzero(&v7, 0x878uLL);
  CFStringRef v2 = CFURLCopyFileSystemPath(a1, kCFURLPOSIXPathStyle);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = v2;
  CStringPtr = CFStringGetCStringPtr(v2, 0x8000100u);
  if (CStringPtr && !statfs(CStringPtr, &v7)) {
    CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7.f_mntonname, 0x8000100u);
  }
  else {
    CFStringRef v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

uint64_t mmcs_nshttp_context_alloc(void *a1)
{
  CFStringRef v2 = (void *)MEMORY[0x1E019B260]();
  *a1 = 0;
  uint64_t v5 = 0;
  uint64_t v3 = mmcs_http_context_allocate(&v5, 2, 8);
  if (v3) {
    *a1 = v5;
  }
  return v3;
}

BOOL mmcs_nshttp_context_init(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = MEMORY[0x1E019B260]();
  if (*(_DWORD *)(a1 + 16) != 2) {
    mmcs_nshttp_context_init_cold_1();
  }
  uint64_t v5 = (void *)v4;
  if (_mmcs_http_context_init(a1, a2))
  {
    *(unsigned char *)(a1 + 400) = *(void *)(a2 + 56) != 0;
    **(void **)(a1 + 624) = [[MMCSHTTPContext alloc] initWithContext:a1 options:a2 activityMarker:mmcs_http_context_get_activity_marker(a1)];
    BOOL v6 = **(void **)(a1 + 624) != 0;
  }
  else
  {
    BOOL v6 = 0;
  }
  return v6;
}

void mmcs_nshttp_context_append_description(uint64_t a1)
{
  CFStringRef v2 = (void *)MEMORY[0x1E019B260]();
  uint64_t v3 = *(void *)a1;
  if (*(void *)a1)
  {
    uint64_t v4 = objc_msgSend((id)objc_msgSend(**(id **)(v3 + 624), "dataTask"), "taskIdentifier");
    uint64_t v5 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(**(id **)(v3 + 624), "urlSession"), "configuration"), "identifier");
    if (v5 && v4 != 0)
    {
      uint64_t v7 = v5;
      mmcs_op_requestor_context_indent(a1);
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @" <%@>.<%lu>\n", v7, v4);
    }
  }
}

uint64_t mmcs_nshttp_copy_perform_target(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 608);
  if (v1) {
    C3BaseRetain(*(CFTypeRef *)(a1 + 608));
  }
  return v1;
}

void mmcs_nshttp_context_cleanup_response(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = (void *)MEMORY[0x1E019B260]();
  if (gMMCS_DebugLevel >= 4)
  {
    uint64_t v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cleanup response %p and %@", a1, **(void **)(a1 + 624));
      uint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v8 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  [**(id **)(a1 + 624) cleanupResponse];
  BOOL v6 = **(void ***)(a1 + 624);
  if (v6)
  {

    **(void **)(a1 + 624) = 0;
  }
}

void mmcs_nshttp_context_finalize(uint64_t a1)
{
  CFStringRef v2 = (void *)MEMORY[0x1E019B260]();
  mmcs_nshttp_context_invalidate(a1);
  uint64_t v3 = **(void ***)(a1 + 624);
  if (v3)
  {

    **(void **)(a1 + 624) = 0;
  }
}

void mmcs_nshttp_context_invalidate(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = (void *)MEMORY[0x1E019B260]();
  if (gMMCS_DebugLevel >= 4)
  {
    uint64_t v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Invalidate %p and %@", a1, **(void **)(a1 + 624));
      uint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v7 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  [**(id **)(a1 + 624) invalidate];
}

void mmcs_nshttp_context_did_complete(uint64_t a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = (void *)MEMORY[0x1E019B260]();
  mmcs_nshttp_context_invalidate(a1);
  if (!*(void *)(a1 + 520))
  {
    if (!*(void *)(a1 + 488)) {
      goto LABEL_57;
    }
    CFDataRef v5 = (const __CFData *)mmcs_http_context_copy_response_body(a1);
    if (!v5)
    {
      metricsinfo__set_response_size(a1 + 24, 0);
      mmcs_metrics_harvest_http_info(*(void *)(a1 + 488), a1);
      goto LABEL_57;
    }
    CFDataRef v6 = v5;
    CFIndex Length = CFDataGetLength(v5);
    metricsinfo__set_response_size(a1 + 24, Length);
    mmcs_metrics_harvest_http_info(*(void *)(a1 + 488), a1);
    CFTypeRef v8 = v6;
LABEL_56:
    CFRelease(v8);
    goto LABEL_57;
  }
  if (!*(unsigned char *)(a1 + 289)
    || mmcs_http_context_has_timedout(a1) && mmcs_http_context_is_timedout(a1))
  {
    if (!*(void *)(a1 + 328))
    {
      uint64_t v3 = mmcs_http_context_copy_cferror_for_http_status_not_ok(a1);
      mmcs_http_context_set_error(a1, v3);
      if (v3) {
        CFRelease(v3);
      }
    }
    CFStringRef v4 = mmcs_logging_logger_default();
    XCFPrint(v4, @"HttpContextError", *(void **)(a1 + 328));
    mmcs_metrics_harvest_http_info(*(void *)(a1 + 488), a1);
    (*(void (**)(uint64_t, void, void))(a1 + 520))(a1, 0, *(void *)(a1 + 576));
    goto LABEL_57;
  }
  CFDataRef v9 = (const __CFData *)mmcs_http_context_copy_response_body(a1);
  CFDataRef v10 = v9;
  CFTypeRef cf = v9;
  if (v9) {
    CFIndex v11 = CFDataGetLength(v9);
  }
  else {
    CFIndex v11 = 0;
  }
  metricsinfo__set_response_size(a1 + 24, v11);
  if (!*(void *)(a1 + 328) && !mmcs_http_context_status_succeeded(a1))
  {
    uint64_t v12 = mmcs_http_context_copy_cferror_for_http_status_not_ok(a1);
    mmcs_http_context_set_error(a1, v12);
    if (v12) {
      CFRelease(v12);
    }
  }
  if (mmcs_http_context_has_http_status(a1))
  {
    if (!v10 || mmcs_http_context_status_succeeded(a1)) {
      goto LABEL_38;
    }
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    BytePtr = CFDataGetBytePtr(v10);
    CFIndex v15 = CFDataGetLength(v10);
    *(double *)&CFStringRef v16 = COERCE_DOUBLE(XCFStringCreateWithBytesNoCopy(v13, BytePtr, v15, 0x8000100u, 0, (const __CFAllocator *)*MEMORY[0x1E4F1CFA0]));
    CFDataRef v17 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(double *)&CFStringRef v18 = COERCE_DOUBLE(CFStringCreateWithFormat(v13, 0, @"Server returned error. HTTP Response Body\n%@", v16));
      CFErrorRef v19 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 138543362;
        double v36 = *(double *)&v18;
        _os_log_impl(&dword_1DC1CA000, v19, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (*(double *)&v18 != 0.0) {
        CFRelease(v18);
      }
    }
  }
  else
  {
    int v20 = mmcs_logging_logger_default();
    BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    if (v10)
    {
      if (!v21) {
        goto LABEL_38;
      }
      *(double *)&CFStringRef v16 = COERCE_DOUBLE(CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"http context %p did not get a http status, with a %lld byte body.", a1, *(void *)(a1 + 200)));
      uint64_t v22 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 138543362;
      double v36 = *(double *)&v16;
    }
    else
    {
      if (!v21) {
        goto LABEL_38;
      }
      *(double *)&CFStringRef v16 = COERCE_DOUBLE(CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"http context %p did not get a http status, with no body.", a1));
      uint64_t v22 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 138543362;
      double v36 = *(double *)&v16;
    }
    _os_log_impl(&dword_1DC1CA000, v22, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
  }
LABEL_36:
  if (*(double *)&v16 != 0.0) {
    CFRelease(v16);
  }
LABEL_38:
  double v23 = mmcs_http_context_elapsed_seconds(a1);
  double v24 = v23;
  if (v23 == 0.0 || (uint64_t v25 = *(void *)(a1 + 216), v25 < 0))
  {
    uint64_t v28 = 0;
  }
  else
  {
    uint64_t v26 = *(void *)(a1 + 160);
    uint64_t v27 = v26 + v25;
    if (v26 >= 0) {
      uint64_t v28 = v27;
    }
    else {
      uint64_t v28 = 0;
    }
  }
  if ((double)v28 * 8.0 / v23 / 1000.0 / 1000.0 >= 0.5 || v23 <= 10.0 || v23 == 0.0) {
    os_log_type_t v31 = OS_LOG_TYPE_DEFAULT;
  }
  else {
    os_log_type_t v31 = OS_LOG_TYPE_ERROR;
  }
  uint64_t v32 = mmcs_logging_logger_network_performance();
  if (os_log_type_enabled(v32, v31))
  {
    double v33 = mmcs_http_context_enqueued_seconds(a1);
    *(_DWORD *)int buf = 134218752;
    double v36 = (double)v28 * 8.0 / v24 / 1000.0 / 1000.0;
    __int16 v37 = 2048;
    double v38 = v24;
    __int16 v39 = 2048;
    uint64_t v40 = v28;
    __int16 v41 = 2048;
    double v42 = v33;
    _os_log_impl(&dword_1DC1CA000, v32, v31, "Observed %0.4lf Mbps over %0.4lf seconds for %lld bytes. %0.4lf seconds in queue.", buf, 0x2Au);
  }
  mmcs_metrics_harvest_http_info(*(void *)(a1 + 488), a1);
  (*(void (**)(uint64_t, CFTypeRef *, void))(a1 + 520))(a1, &cf, *(void *)(a1 + 576));
  CFTypeRef v8 = cf;
  if (cf) {
    goto LABEL_56;
  }
LABEL_57:
}

uint64_t mmcs_nshttp_context_actual_bytes_written(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 152)) {
    return metricsinfo__get_bytes_written(a1 + 24);
  }
  else {
    return 0;
  }
}

uint64_t mmcs_nshttp_write_request_body(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFDataRef v6 = (void *)MEMORY[0x1E019B260]();
  if (gMMCS_DebugLevel >= 5)
  {
    CFStringRef v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"http context %p buffer %p len %lld", a1, a2, a3);
      CFDataRef v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v13 = v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v8) {
        CFRelease(v8);
      }
    }
  }
  uint64_t v10 = [**(id **)(a1 + 624) writeRequestBody:a2 maxLength:a3];
  return v10;
}

void mmcs_nshttp_set_request_body_done(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = (void *)MEMORY[0x1E019B260]();
  if (gMMCS_DebugLevel >= 5)
  {
    uint64_t v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"http context %p", a1);
      CFDataRef v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v7 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  [**(id **)(a1 + 624) requestBodyDone];
  *(void *)(a1 + 160) = [**(id **)(a1 + 624) countOfRequestBodyBytesSent];
}

uint64_t mmcs_nshttp_request_body_can_accept_data(uint64_t a1)
{
  CFStringRef v2 = (void *)MEMORY[0x1E019B260]();
  uint64_t v3 = [**(id **)(a1 + 624) requestBodyCanAcceptData];
  return v3;
}

BOOL mmcs_nshttp_context_send(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  CFDataRef v5 = (void *)MEMORY[0x1E019B260]();
  *(_DWORD *)(a1 + 484) = 0;
  mmcs_http_context_set_perform_target(a1, a3);
  CFDataRef v6 = *(__CFHTTPMessage **)(a1 + 336);
  if (v6)
  {
    CFStringRef v7 = CFHTTPMessageCopyRequestMethod(v6);
    if (v7)
    {
      CFStringRef v8 = v7;
      CFDataRef v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v40 = v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_INFO, "HttpMethod (%{public}@)", buf, 0xCu);
      }
      CFRelease(v8);
    }
    CFURLRef v10 = CFHTTPMessageCopyRequestURL(*(CFHTTPMessageRef *)(a1 + 336));
    if (v10)
    {
      CFURLRef v11 = v10;
      CFStringRef v12 = CFURLCopyStrictPath(v10, 0);
      if (v12)
      {
        CFStringRef v13 = v12;
        uint64_t v14 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v40 = (CFStringRef)v11;
          _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_DEFAULT, "HttpURL (%{public}@)", buf, 0xCu);
        }
        CFRelease(v13);
      }
      CFRelease(v11);
    }
    CFStringRef v15 = CFHTTPMessageCopyVersion(*(CFHTTPMessageRef *)(a1 + 336));
    if (v15)
    {
      CFStringRef v16 = v15;
      CFDataRef v17 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v40 = v16;
        _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_INFO, "HttpRequestVersion (%{public}@)", buf, 0xCu);
      }
      CFRelease(v16);
    }
    CFDictionaryRef v18 = CFHTTPMessageCopyAllHeaderFields(*(CFHTTPMessageRef *)(a1 + 336));
    if (v18)
    {
      CFDictionaryRef v19 = v18;
      __int16 v37 = v5;
      CFIndex Count = CFDictionaryGetCount(v18);
      uint64_t v36 = (uint64_t)&v36;
      MEMORY[0x1F4188790](Count);
      BOOL v21 = (CFStringRef *)((char *)&v36 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v21, 8 * Count);
      MEMORY[0x1F4188790](v22);
      double v23 = v21;
      bzero(v21, 8 * Count);
      CFDictionaryGetKeysAndValues(v19, (const void **)v21, (const void **)v21);
      if (Count >= 1)
      {
        *(void *)&long long v24 = 138543618;
        long long v38 = v24;
        do
        {
          if (*v21)
          {
            if (*v23)
            {
              uint64_t v25 = mmcs_logging_logger_default();
              os_log_type_t v26 = mmcs_logging_log_header_level(*v21);
              if (os_log_type_enabled(v25, v26))
              {
                CFStringRef v27 = *v21;
                CFStringRef v28 = *v23;
                *(_DWORD *)int buf = v38;
                CFStringRef v40 = v27;
                __int16 v41 = 2114;
                CFStringRef v42 = v28;
                _os_log_impl(&dword_1DC1CA000, v25, v26, "RequestHeader (%{public}@:%{public}@)", buf, 0x16u);
              }
            }
          }
          ++v23;
          ++v21;
          --Count;
        }
        while (Count);
      }
      CFRelease(v19);
      CFDataRef v5 = v37;
    }
  }
  uint64_t v29 = (FILE **)(a1 + 424);
  if (debug_begin_writing_http_message_to_file(a1, *(__CFHTTPMessage **)(a1 + 336), (FILE **)(a1 + 424), *(const __CFString **)(a1 + 264), 0)&& !*(unsigned char *)(a1 + 400)&& *v29)
  {
    CFDataRef v30 = CFHTTPMessageCopyBody(*(CFHTTPMessageRef *)(a1 + 336));
    if (v30)
    {
      CFDataRef v31 = v30;
      BytePtr = CFDataGetBytePtr(v30);
      size_t Length = CFDataGetLength(v31);
      fwrite(BytePtr, Length, 1uLL, *v29);
      CFRelease(v31);
    }
    fclose(*v29);
    void *v29 = 0;
  }
  [**(id **)(a1 + 624) setRequestIsStreamed:*(unsigned char *)(a1 + 400) != 0];
  uint64_t v34 = (__CFError *)[**(id **)(a1 + 624) send];
  if (v34) {
    mmcs_http_context_set_error(a1, v34);
  }
  return v34 == 0;
}

uint64_t mmcs_nshttp_context_will_reset_request(uint64_t result)
{
  *(_DWORD *)(result + 296) = 1;
  return result;
}

uint64_t mmcs_nshttp_get_http_context(uint64_t a1)
{
  return **(void **)(a1 + 624);
}

uint64_t mmcs_nshttp_received_data(uint64_t a1, void *a2)
{
  CFStringRef v4 = (void *)MEMORY[0x1E019B260]();
  metricsinfo__set_bytes_read(a1 + 24, [a2 length] + *(void *)(a1 + 216));
  double Current = CFAbsoluteTimeGetCurrent();
  double v6 = *(double *)(a1 + 320);
  *(double *)(a1 + 320) = Current;
  if (*(int *)(a1 + 296) <= 2) {
    *(_DWORD *)(a1 + 296) = 3;
  }
  if (*(void *)(a1 + 552))
  {
    memset(v9, 0, sizeof(v9));
    mmcs_network_activity_make([a2 length], 1, (uint64_t)v9, v6, Current);
    (*(void (**)(uint64_t, _OWORD *, void))(a1 + 552))(a1, v9, *(void *)(a1 + 576));
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = __mmcs_nshttp_received_data_block_invoke;
  v8[3] = &__block_descriptor_40_e29_v40__0r_v8__NSRange_QQ_16_B32l;
  v8[4] = a1;
  [a2 enumerateByteRangesUsingBlock:v8];
  return 1;
}

void __mmcs_nshttp_received_data_block_invoke(uint64_t a1, void *__ptr, uint64_t a3, size_t __size, unsigned char *a5)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)(a1 + 32);
  CFURLRef v11 = *(FILE **)(v10 + 432);
  if (v11)
  {
    fwrite(__ptr, __size, 1uLL, v11);
    uint64_t v10 = *(void *)(a1 + 32);
  }
  CFStringRef v12 = *(unsigned int (**)(void))(v10 + 528);
  if (v12)
  {
    if (!v12())
    {
      if (a5) {
        *a5 = 1;
      }
      CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Error processing data", v13, v14, v15, v16, v17, v22);
      CFDictionaryRef v18 = mmcs_cferror_copy_description(cf);
      CFDictionaryRef v19 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"stopping http request %p due to data processing error %@ byte range (%lu, %lu)", *(void *)(a1 + 32), v18, a3, __size);
        BOOL v21 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v25 = v20;
          _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v20) {
          CFRelease(v20);
        }
      }
      if (v18) {
        CFRelease(v18);
      }
      mmcs_http_context_set_error(*(void *)(a1 + 32), cf);
      if (cf) {
        CFRelease(cf);
      }
      mmcs_http_context_transaction_complete(*(void *)(a1 + 32));
    }
  }
  else
  {
    mmcs_http_write_response_body(v10, (const UInt8 *)__ptr, __size);
  }
}

void mmcs_nshttp_did_complete(uint64_t a1, id a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CFStringRef v4 = (void *)MEMORY[0x1E019B260]();
  if (!*(unsigned char *)(a1 + 290) && !*(_DWORD *)(a1 + 56))
  {
    *(unsigned char *)(a1 + 288) = 1;
    if (!a2)
    {
      if (*(void *)(a1 + 536) && mmcs_http_context_status_succeeded(a1))
      {
        id v22 = 0;
        a2 = 0;
        if (!(*(unsigned int (**)(uint64_t, id *))(a1 + 536))(a1, &v22))
        {
          uint64_t v10 = v22;
          if (!v22)
          {
            uint64_t v10 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Error processing data", v5, v6, v7, v8, v9, v21);
            id v22 = v10;
          }
          CFURLRef v11 = mmcs_cferror_copy_description((__CFError *)v10);
          CFStringRef v12 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"stopping http request %p due to data processing error %@ at end of response stream", a1, v11);
            uint64_t v14 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 138543362;
              CFStringRef v24 = v13;
              _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            }
            if (v13) {
              CFRelease(v13);
            }
          }
          if (v11) {
            CFRelease(v11);
          }
          a2 = v22;
        }
      }
      else
      {
        a2 = 0;
      }
    }
    *(unsigned char *)(a1 + 289) = 1;
    uint64_t v15 = *(void (**)(void))(a1 + 544);
    if (v15) {
      v15(*(void *)(a1 + 568));
    }
    if (a2)
    {
      uint64_t v16 = (void *)[a2 domain];
      uint64_t v17 = *MEMORY[0x1E4F289A0];
      if ([v16 isEqualToString:*MEMORY[0x1E4F289A0]])
      {
        if ([a2 code] == -999 && !*(unsigned char *)(a1 + 290))
        {
          CFDictionaryRef v18 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"context %p received timeout error from NSURLSessionTask but is not marked as cancelled", a1);
            CFStringRef v20 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 138543362;
              CFStringRef v24 = v19;
              _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            }
            if (v19) {
              CFRelease(v19);
            }
          }
        }
      }
      if (objc_msgSend((id)objc_msgSend(a2, "domain"), "isEqualToString:", v17)
        && [a2 code] == -1001)
      {
        metricsinfo__set_timed_out(a1 + 24, 1);
      }
      mmcs_nshttp_transform_and_set_error(a1, a2);
    }
    else if (mmcs_http_context_response_received_time(a1) == 0.0)
    {
      *(CFAbsoluteTime *)(a1 + 120) = CFAbsoluteTimeGetCurrent();
    }
    _mmcs_nshttp_capture_transaction_state(a1, (void *)[**(id **)(a1 + 624) timingData]);
    mmcs_http_context_transaction_complete(a1);
  }
}

void mmcs_nshttp_transform_and_set_error(uint64_t a1, void *a2)
{
  CFStringRef v4 = (void *)MEMORY[0x1E019B260]();
  uint64_t v5 = [a2 localizedFailureReason];
  uint64_t v6 = [a2 localizedDescription];
  uint64_t v7 = (void *)[a2 domain];
  if ([v7 isEqualToString:*MEMORY[0x1E4F289A0]] && objc_msgSend(a2, "code") == -1001)
  {
    stream_status_string = mmcs_http_get_stream_status_string(*(_DWORD *)(a1 + 296));
    CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"The operation timed out while %@. NSURLSession error: %@ (%@)", stream_status_string, v6, v5);
    error_with_underlying_CFTypeRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 3, a2, @"%@", v14, v15, v16, v17, (char)v13);
    if (v13) {
      CFRelease(v13);
    }
  }
  else
  {
    error_with_underlying_CFTypeRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 38, a2, @"NSURLSession error: %@ (%@)", v8, v9, v10, v11, v6);
  }
  mmcs_http_context_set_error(a1, error_with_underlying_error);
  if (error_with_underlying_error) {
    CFRelease(error_with_underlying_error);
  }
}

uint64_t _mmcs_nshttp_capture_transaction_state(uint64_t a1, void *a2)
{
  CFStringRef v4 = (objc_class *)objc_opt_class();
  ClassValueForKey = (void *)TimingDataGetClassValueForKey(a2, v4, @"_kCFNTimingDataConnectionReused", 1);
  if (ClassValueForKey) {
    *(_DWORD *)(a1 + 484) = [ClassValueForKey intValue] != 0;
  }
  uint64_t v6 = (objc_class *)objc_opt_class();
  CFStringRef v7 = (const __CFString *)TimingDataGetClassValueForKey(a2, v6, @"_kCFNTimingDataConnectionInterfaceIdentifier", 1);
  if (v7) {
    metricsinfo__set_request_url_with_cfstring(a1 + 440, v7);
  }
  uint64_t v8 = *(__CFError **)(a1 + 328);
  int v10 = !v8
     || (CFErrorDomain Domain = CFErrorGetDomain(v8), !CFEqual(@"com.apple.mmcs", Domain))
     || CFErrorGetCode(*(CFErrorRef *)(a1 + 328)) != 3;
  uint64_t v11 = (objc_class *)objc_opt_class();
  CFStringRef v12 = (void *)TimingDataGetClassValueForKey(a2, v11, @"_kCFNTimingDataConnectionPeerAddress", v10);
  if (v12)
  {
    uint64_t v13 = [v12 bytes];
    v14.s_addr = *(_DWORD *)(v13 + 4);
    uint64_t v15 = inet_ntoa(v14);
    if (v15)
    {
      *(_DWORD *)(a1 + 480) = bswap32(*(unsigned __int16 *)(v13 + 2)) >> 16;
      socketinfo__set_peer_address_with_c_string(a1 + 440, v15);
    }
  }
  objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", @"_kCFNTimingDataDomainLookupStart"), "doubleValue");
  metricsinfo__set_start_name_resolution(a1 + 24, v16);
  objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", @"_kCFNTimingDataDomainLookupEnd"), "doubleValue");
  metricsinfo__set_stop_name_resolution(a1 + 24, v17);
  objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", @"_kCFNTimingDataFetchStart"), "doubleValue");
  *(void *)(a1 + 280) = v18;
  objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", @"_kCFNTimingDataTimingDataInit"), "doubleValue");
  return metricsinfo__set_connection_init_time(a1 + 24, v19);
}

void mmcs_nshttp_did_open(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = MEMORY[0x1E019B260]();
  if (*(void *)(a1 + 392)) {
    mmcs_nshttp_did_open_cold_1();
  }
  uint64_t v3 = (void *)v2;
  uint64_t v4 = objc_msgSend((id)objc_msgSend(**(id **)(a1 + 624), "dataTask"), "response");
  if (v4)
  {
    uint64_t v5 = (void *)v4;
    *(CFAbsoluteTime *)(a1 + 320) = CFAbsoluteTimeGetCurrent();
    uint64_t v6 = [v5 statusCode];
    metricsinfo__set_http_status(a1 + 24, v6);
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v8 = (const __CFString *)[MEMORY[0x1E4F28D20] localizedStringForStatusCode:v6];
    Response = CFHTTPMessageCreateResponse(v7, v6, v8, (CFStringRef)*MEMORY[0x1E4F18F90]);
    int v10 = (void *)[v5 allHeaderFields];
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 3221225472;
    v27[2] = __mmcs_nshttp_did_open_block_invoke;
    v27[3] = &__block_descriptor_40_e15_v32__0_8_16_B24l;
    v27[4] = Response;
    [v10 enumerateKeysAndObjectsUsingBlock:v27];
    *(void *)(a1 + 392) = Response;
    if (Response)
    {
      CFStringRef v11 = CFHTTPMessageCopyResponseStatusLine(Response);
      if (v11)
      {
        CFStringRef v12 = v11;
        uint64_t v13 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v29 = v12;
          _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_DEFAULT, "HttpStatus (%{public}@)", buf, 0xCu);
        }
        CFRelease(v12);
      }
      CFDictionaryRef v14 = CFHTTPMessageCopyAllHeaderFields(*(CFHTTPMessageRef *)(a1 + 392));
      if (v14)
      {
        CFDictionaryRef v15 = v14;
        CFIndex Count = CFDictionaryGetCount(v14);
        v25[1] = v25;
        MEMORY[0x1F4188790](Count);
        double v17 = (CFStringRef *)((char *)v25 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0));
        bzero(v17, 8 * Count);
        MEMORY[0x1F4188790](v18);
        double v19 = v17;
        bzero(v17, 8 * Count);
        CFDictionaryGetKeysAndValues(v15, (const void **)v17, (const void **)v17);
        if (Count >= 1)
        {
          *(void *)&long long v20 = 138543618;
          long long v26 = v20;
          do
          {
            if (*v17)
            {
              if (*v19)
              {
                char v21 = mmcs_logging_logger_default();
                os_log_type_t v22 = mmcs_logging_log_header_level(*v17);
                if (os_log_type_enabled(v21, v22))
                {
                  CFStringRef v23 = *v17;
                  CFStringRef v24 = *v19;
                  *(_DWORD *)int buf = v26;
                  CFStringRef v29 = v23;
                  __int16 v30 = 2114;
                  CFStringRef v31 = v24;
                  _os_log_impl(&dword_1DC1CA000, v21, v22, "ResponseHeader (%{public}@:%{public}@)", buf, 0x16u);
                }
              }
            }
            ++v19;
            ++v17;
            --Count;
          }
          while (Count);
        }
        CFRelease(v15);
      }
    }
    debug_begin_writing_http_message_to_file(a1, *(__CFHTTPMessage **)(a1 + 392), (FILE **)(a1 + 432), *(const __CFString **)(a1 + 264), 1);
  }
}

void __mmcs_nshttp_did_open_block_invoke(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
}

void mmcs_nshttp_will_retry_in_background(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)MEMORY[0x1E019B260]();
  mmcs_nshttp_transform_and_set_error(a1, a2);
  _mmcs_nshttp_capture_transaction_state(a1, (void *)[**(id **)(a1 + 624) timingData]);
  CFDataRef v5 = (const __CFData *)mmcs_http_context_copy_response_body(a1);
  if (v5)
  {
    CFDataRef v6 = v5;
    CFIndex Length = CFDataGetLength(v5);
    metricsinfo__set_response_size(a1 + 24, Length);
    mmcs_metrics_harvest_http_info(*(void *)(a1 + 488), a1);
    CFRelease(v6);
  }
  else
  {
    metricsinfo__set_response_size(a1 + 24, 0);
    mmcs_metrics_harvest_http_info(*(void *)(a1 + 488), a1);
  }
  CFStringRef v8 = *(void (**)(uint64_t, void, void))(a1 + 512);
  if (v8) {
    v8(a1, *(void *)(a1 + 576), *(void *)(a1 + 328));
  }
  mmcs_http_reset_response_state_for_background_retry(a1);
}

uint64_t mmcs_nshttp_sent_data(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return metricsinfo__set_bytes_written(a1 + 24, a3);
}

void mmcs_nshttp_schedule_stream(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x1E019B260]();
  mmcs_perform_target_stream_schedule(*(void *)(a1 + 608));
}

uint64_t TimingDataGetClassValueForKey(void *a1, objc_class *a2, uint64_t a3, int a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = objc_msgSend(a1, "objectForKeyedSubscript:");
  if (!v7)
  {
    if (a4)
    {
      double v16 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v18 = NSStringFromClass(a2);
        double v19 = (objc_class *)objc_opt_class();
        long long v20 = NSStringFromClass(v19);
        CFStringRef v12 = CFStringCreateWithFormat(v17, 0, @"Expected %@ for key %@, got %@", v18, a3, v20);
        char v21 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_11;
        }
        *(_DWORD *)int buf = 138543362;
        CFStringRef v24 = v12;
        CFDictionaryRef v14 = v21;
        os_log_type_t v15 = OS_LOG_TYPE_DEBUG;
LABEL_10:
        _os_log_impl(&dword_1DC1CA000, v14, v15, "%{public}@", buf, 0xCu);
LABEL_11:
        if (v12) {
          CFRelease(v12);
        }
      }
    }
    return 0;
  }
  uint64_t v8 = v7;
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    uint64_t v9 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef v11 = NSStringFromClass(a2);
      CFStringRef v12 = CFStringCreateWithFormat(v10, 0, @"Expected %@ got %@", v11, v8);
      uint64_t v13 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_11;
      }
      *(_DWORD *)int buf = 138543362;
      CFStringRef v24 = v12;
      CFDictionaryRef v14 = v13;
      os_log_type_t v15 = OS_LOG_TYPE_ERROR;
      goto LABEL_10;
    }
    return 0;
  }
  return v8;
}

uint64_t mmcs_chunk_reference_create(void *a1, int a2, unsigned char *a3, uint64_t a4, char a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v10 = malloc_type_malloc(0x48uLL, 0x1030040BCC12766uLL);
  *a1 = 0;
  if (v10)
  {
    v10[1] = a2;
    *((unsigned char *)v10 + 64) = (*a3 & 0x7F) != 4;
    *(unsigned char *)CFAllocatorRef v10 = a5;
    *((void *)v10 + 1) = a3;
    *((void *)v10 + 2) = a4;
    *((unsigned char *)v10 + 24) = 0;
    *((void *)v10 + 4) = 0;
    *((void *)v10 + 6) = 0;
    *((void *)v10 + 7) = 0;
    *a1 = v10;
  }
  else
  {
    CFStringRef v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"malloc\n");
      uint64_t v13 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        int v15 = 138543362;
        CFStringRef v16 = v12;
        _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v15, 0xCu);
      }
      if (v12) {
        CFRelease(v12);
      }
    }
  }
  return 1;
}

void mmcs_chunk_reference_add_instance(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4)
  {
    if (mmcs_chunk_instance_equal(v4, (uint64_t)a2)) {
      return;
    }
    CFMutableDictionaryRef Mutable = *(__CFSet **)(a1 + 56);
    if (!Mutable)
    {
      CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &chunkInstanceEqualitySetCallbacks);
      *(void *)(a1 + 56) = Mutable;
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = *(__CFSet **)(a1 + 56);
    if (!Mutable)
    {
      *(void *)(a1 + 48) = a2;
      return;
    }
  }
  CFSetSetValue(Mutable, a2);
}

void mmcs_chunk_reference_apply_function_to_instances(uint64_t a1, void (__cdecl *a2)(const void *, void *), void *a3)
{
  if (a2)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    if (v6) {
      ((void (*)(uint64_t, void *))a2)(v6, a3);
    }
    CFSetRef v7 = *(const __CFSet **)(a1 + 56);
    if (v7 && CFSetGetCount(v7) >= 1)
    {
      CFSetRef v8 = *(const __CFSet **)(a1 + 56);
      CFSetApplyFunction(v8, a2, a3);
    }
  }
}

CFSetRef mmcs_chunk_reference_get_first_chunk_instance(uint64_t a1)
{
  CFSetRef result = *(const __CFSet **)(a1 + 48);
  CFSetRef context = result;
  if (!result)
  {
    CFSetRef result = *(const __CFSet **)(a1 + 56);
    if (result)
    {
      if (CFSetGetCount(result) < 1)
      {
        return 0;
      }
      else
      {
        CFSetApplyFunction(*(CFSetRef *)(a1 + 56), (CFSetApplierFunction)_first_instance, &context);
        return context;
      }
    }
  }
  return result;
}

uint64_t _first_instance(uint64_t result, void *a2)
{
  if (a2)
  {
    if (!*a2) {
      *a2 = result;
    }
  }
  return result;
}

void mmcs_chunk_reference_was_put(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4) {
    mmcs_chunk_instance_was_put(v4, (uint64_t)a2);
  }
  CFSetRef v5 = *(const __CFSet **)(a1 + 56);
  if (v5)
  {
    if (CFSetGetCount(v5) >= 1)
    {
      CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFSetRef *)(a1 + 56));
      CFSetApplyFunction(Copy, (CFSetApplierFunction)mmcs_chunk_instance_was_put, a2);
      if (Copy)
      {
        CFRelease(Copy);
      }
    }
  }
}

void mmcs_chunk_reference_was_read(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = a2;
  v3[1] = mmcs_item_chunk_instance_was_read;
  v3[2] = a3;
  _mmcs_chunk_reference_was_VERB(a1, v3);
}

void _mmcs_chunk_reference_was_VERB(uint64_t a1, void *a2)
{
  uint64_t v5 = *(void *)(a1 + 48);
  CFSetRef v4 = *(const __CFSet **)(a1 + 56);
  uint64_t v6 = v5 != 0;
  if (v4) {
    v6 += CFSetGetCount(v4);
  }
  if (v6 == 1)
  {
    uint64_t v7 = *(void *)(a1 + 48);
    if (v7) {
      ((void (*)(void, void, void))a2[1])(*(void *)(v7 + 8), *a2, a2[2]);
    }
    CFSetRef v8 = *(const __CFSet **)(a1 + 56);
    if (v8 && CFSetGetCount(v8) >= 1)
    {
      CFSetRef v9 = *(const __CFSet **)(a1 + 56);
      CFSetApplyFunction(v9, (CFSetApplierFunction)_chunk_instance_was_VERB_applier, a2);
    }
  }
  else if (v6 >= 2)
  {
    CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &itemItemIDEqualitySetCallbacks);
    if (Mutable)
    {
      CFStringRef v11 = Mutable;
      uint64_t v12 = *(void *)(a1 + 48);
      if (v12) {
        CFSetAddValue(Mutable, *(const void **)(v12 + 8));
      }
      CFSetRef v13 = *(const __CFSet **)(a1 + 56);
      if (v13 && CFSetGetCount(v13) >= 1) {
        CFSetApplyFunction(*(CFSetRef *)(a1 + 56), (CFSetApplierFunction)_add_item, v11);
      }
      CFSetApplyFunction(v11, (CFSetApplierFunction)_item_was_VERB_applier, a2);
      CFRelease(v11);
    }
  }
}

void mmcs_chunk_reference_was_unread(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = a2;
  v3[1] = mmcs_item_chunk_instance_was_unread;
  v3[2] = a3;
  _mmcs_chunk_reference_was_VERB(a1, v3);
}

uint64_t mmcs_chunk_reference_create_RegisteredChunk()
{
  uint64_t v0 = CKCreateRegisteredChunkWithSubchunkBlob();
  if (v0) {
    CKRegisteredChunkSetLength();
  }
  return v0;
}

CFStringRef mmcs_chunk_reference_copy_description(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 8);
  if (v2)
  {
    unint64_t v3 = CKChunkSchemeAndSignatureSize();
    uint64_t v2 = hextostrdup(v2, v3);
  }
  CFSetRef v4 = *(char **)(a1 + 16);
  if (!v4
    || (v5 = CKChunkSchemeAndEncryptionKeySize(), (uint64_t v6 = mmcs_key_description_create_with_bytes(v4, v5, 1)) == 0))
  {
    CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<chunk_ref %p> (%s %d)", a1, v2, *(unsigned int *)(a1 + 4));
    uint64_t v7 = 0;
    char v9 = 1;
    if (!v2) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v7 = v6;
  CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<chunk_ref %p> (%s %@ %d)", a1, v2, v6, *(unsigned int *)(a1 + 4));
  char v9 = 0;
  if (v2) {
LABEL_8:
  }
    free(v2);
LABEL_9:
  if ((v9 & 1) == 0) {
    CFRelease(v7);
  }
  return v8;
}

void mmcs_chunk_reference_append_signature_length_description(uint64_t a1, CFMutableStringRef theString)
{
  CFSetRef v4 = *(char **)(a1 + 8);
  if (v4)
  {
    unint64_t v5 = CKChunkSchemeAndSignatureSize();
    uint64_t v6 = hextostrdup(v4, v5);
    CFStringAppendFormat(theString, 0, @"(%s %d)", v6, *(unsigned int *)(a1 + 4));
    if (v6)
    {
      free(v6);
    }
  }
  else
  {
    CFStringAppendFormat(theString, 0, @"(%s %d)", 0, *(unsigned int *)(a1 + 4));
  }
}

uint64_t mmcs_chunk_reference_equal(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (a1)
  {
    if (a2) {
      return CKChunkSignaturesEqual();
    }
  }
  return result;
}

uint64_t mmcs_chunk_reference_hash(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0;
  }
}

void mmcs_chunk_reference_finalize(unsigned __int8 *a1)
{
  *((void *)a1 + 6) = 0;
  uint64_t v2 = (const void *)*((void *)a1 + 7);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)a1 + 7) = 0;
  if (!*a1)
  {
    *((void *)a1 + 1) = 0;
    goto LABEL_11;
  }
  unint64_t v3 = (void *)*((void *)a1 + 1);
  if (v3)
  {
    free(v3);
    int v4 = *a1;
    *((void *)a1 + 1) = 0;
    if (!v4) {
      goto LABEL_11;
    }
  }
  else
  {
    *((void *)a1 + 1) = 0;
  }
  unint64_t v5 = (void *)*((void *)a1 + 2);
  if (v5) {
    free(v5);
  }
LABEL_11:
  *((void *)a1 + 2) = 0;
  if (a1[24])
  {
    uint64_t v6 = (void *)*((void *)a1 + 4);
    if (v6) {
      free(v6);
    }
    *((void *)a1 + 4) = 0;
  }
}

void mmcs_chunk_reference_dealloc(unsigned __int8 *a1)
{
  mmcs_chunk_reference_finalize(a1);
  if (a1)
  {
    free(a1);
  }
}

uint64_t _chunk_instance_was_VERB_applier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, void))(a2 + 8))(*(void *)(a1 + 8), *(void *)a2, *(void *)(a2 + 16));
}

void _add_item(uint64_t a1, CFMutableSetRef theSet)
{
}

uint64_t _item_was_VERB_applier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(a2 + 8))(a1, *(void *)a2, *(void *)(a2 + 16));
}

os_log_t __mmcs_logging_logger_default_block_invoke()
{
  os_log_t result = os_log_create("com.apple.mmcs", "default");
  mmcs_logging_logger_default_logger = (uint64_t)result;
  return result;
}

uint64_t mmcs_logging_logger_chunk()
{
  if (mmcs_logging_logger_chunk_once != -1) {
    dispatch_once(&mmcs_logging_logger_chunk_once, &__block_literal_global_5);
  }
  return mmcs_logging_logger_chunk_logger;
}

os_log_t __mmcs_logging_logger_chunk_block_invoke()
{
  os_log_t result = os_log_create("com.apple.mmcs", "chunk");
  mmcs_logging_logger_chunk_logger = (uint64_t)result;
  return result;
}

uint64_t mmcs_logging_logger_network_performance()
{
  if (mmcs_logging_logger_network_performance_once != -1) {
    dispatch_once(&mmcs_logging_logger_network_performance_once, &__block_literal_global_9);
  }
  return mmcs_logging_logger_network_performance_logger;
}

os_log_t __mmcs_logging_logger_network_performance_block_invoke()
{
  os_log_t result = os_log_create("com.apple.mmcs", "network.performance");
  mmcs_logging_logger_network_performance_logger = (uint64_t)result;
  return result;
}

uint64_t mmcs_logging_logger_summary()
{
  if (mmcs_logging_logger_summary_once != -1) {
    dispatch_once(&mmcs_logging_logger_summary_once, &__block_literal_global_13);
  }
  return mmcs_logging_logger_summary_logger;
}

os_log_t __mmcs_logging_logger_summary_block_invoke()
{
  os_log_t result = os_log_create("com.apple.mmcs", "summary");
  mmcs_logging_logger_summary_logger = (uint64_t)result;
  return result;
}

uint64_t mmcs_logging_log_header_level(CFStringRef theString)
{
  if (mmcs_logging_log_header_level_MMCS_MMCS_HEADER_WHITELIST_SET_BLOCK == -1)
  {
    if (theString) {
      return 2
    }
           * (mmcs_case_insensitive_set_contains(mmcs_logging_log_header_level_MMCS_HEADER_WHITELIST_SET, theString) == 0);
  }
  else
  {
    dispatch_once(&mmcs_logging_log_header_level_MMCS_MMCS_HEADER_WHITELIST_SET_BLOCK, &__block_literal_global_17);
    if (theString) {
      return 2
    }
           * (mmcs_case_insensitive_set_contains(mmcs_logging_log_header_level_MMCS_HEADER_WHITELIST_SET, theString) == 0);
  }
  return 2;
}

uint64_t __mmcs_logging_log_header_level_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v1[2] = xmmword_1E6C33798;
  v1[3] = *(_OWORD *)&off_1E6C337A8;
  v1[4] = xmmword_1E6C337B8;
  v1[0] = xmmword_1E6C33778;
  v1[1] = *(_OWORD *)&off_1E6C33788;
  return mmcs_case_insensitive_set_create(&mmcs_logging_log_header_level_MMCS_HEADER_WHITELIST_SET, (CFStringRef *)v1, 10);
}

void XCFPrintArray(NSObject *a1, uint64_t a2, const __CFArray *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFArrayGetCount(a3);
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    CFIndex v8 = 0;
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v8);
      if (ValueAtIndex)
      {
        CFDictionaryRef v11 = ValueAtIndex;
        CFTypeID v12 = CFGetTypeID(ValueAtIndex);
        if (v12 == CFDictionaryGetTypeID())
        {
          CFStringRef v13 = CFStringCreateWithFormat(v9, 0, @"%@:%ld", a2, v8);
          XCFPrintDictionary(a1, (uint64_t)v13, v11);
          if (!v13) {
            goto LABEL_13;
          }
          goto LABEL_12;
        }
        CFTypeID v14 = CFGetTypeID(v11);
        if (v14 == CFArrayGetTypeID())
        {
          CFStringRef v13 = CFStringCreateWithFormat(v9, 0, @"%@:%ld", a2, v8);
          XCFPrintArray(a1, v13, v11);
          if (!v13) {
            goto LABEL_13;
          }
LABEL_12:
          CFRelease(v13);
          goto LABEL_13;
        }
        CFTypeID v15 = CFGetTypeID(v11);
        if (v15 != CFErrorGetTypeID())
        {
          if (os_log_type_enabled(a1, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)int buf = 138543874;
            uint64_t v17 = a2;
            __int16 v18 = 2048;
            CFIndex v19 = v8;
            __int16 v20 = 2114;
            CFDictionaryRef v21 = v11;
            _os_log_impl(&dword_1DC1CA000, a1, OS_LOG_TYPE_INFO, "%{public}@:%ld %{public}@", buf, 0x20u);
          }
          goto LABEL_13;
        }
        CFStringRef v13 = CFStringCreateWithFormat(v9, 0, @"%@:%ld", a2, v8);
        XCFPrintError(a1, v13, v11);
        if (v13) {
          goto LABEL_12;
        }
      }
LABEL_13:
      ++v8;
    }
    while (v7 != v8);
  }
}

void XCFPrintDictionary(NSObject *a1, uint64_t a2, const __CFDictionary *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int64_t Count = CFDictionaryGetCount(a3);
  CFIndex v7 = (const void **)malloc_type_calloc(Count, 8uLL, 0x6004044C4A2DFuLL);
  CFIndex v8 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
  CFDictionaryRef v9 = a3;
  CFAllocatorRef v10 = v7;
  CFDictionaryGetKeysAndValues(v9, v7, v8);
  if (Count >= 1)
  {
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFTypeID v12 = v8;
    do
    {
      if (*v7 && *v12)
      {
        CFTypeID v13 = CFGetTypeID(*v12);
        if (v13 == CFDictionaryGetTypeID())
        {
          CFStringRef v14 = CFStringCreateWithFormat(v11, 0, @"%@/%@", a2, *v7);
          XCFPrintDictionary(a1, v14, *v12);
        }
        else
        {
          CFTypeID v15 = CFGetTypeID(*v12);
          if (v15 == CFArrayGetTypeID())
          {
            CFStringRef v14 = CFStringCreateWithFormat(v11, 0, @"%@/%@", a2, *v7);
            XCFPrintArray(a1, v14, *v12);
          }
          else
          {
            CFTypeID v16 = CFGetTypeID(*v12);
            if (v16 == CFErrorGetTypeID())
            {
              CFStringRef v14 = CFStringCreateWithFormat(v11, 0, @"%@/%@", a2, *v7);
              XCFPrintError(a1, v14, (CFErrorRef)*v12);
            }
            else
            {
              CFTypeID v17 = CFGetTypeID(*v12);
              if (v17 != CFDataGetTypeID()
                || !CFEqual(@"kMMCSBoundaryKey", *v7) && !CFEqual(@"kMMCSReferenceObject", *v7))
              {
                if (os_log_type_enabled(a1, OS_LOG_TYPE_INFO))
                {
                  CFIndex v19 = *v7;
                  CFStringRef v20 = (const __CFString *)*v12;
                  *(_DWORD *)int buf = 138543874;
                  uint64_t v22 = a2;
                  __int16 v23 = 2114;
                  CFStringRef v24 = v19;
                  __int16 v25 = 2114;
                  CFStringRef v26 = v20;
                  _os_log_impl(&dword_1DC1CA000, a1, OS_LOG_TYPE_INFO, "%{public}@ %{public}@:%{public}@", buf, 0x20u);
                }
                goto LABEL_13;
              }
              CFStringRef v14 = mmcs_key_description_create_with_cfdata((const __CFData *)*v12, 0);
              if (os_log_type_enabled(a1, OS_LOG_TYPE_INFO))
              {
                __int16 v18 = *v7;
                *(_DWORD *)int buf = 138543874;
                uint64_t v22 = a2;
                __int16 v23 = 2114;
                CFStringRef v24 = v18;
                __int16 v25 = 2114;
                CFStringRef v26 = v14;
                _os_log_impl(&dword_1DC1CA000, a1, OS_LOG_TYPE_INFO, "%{public}@ %{public}@:%{public}@", buf, 0x20u);
              }
            }
          }
        }
        if (v14) {
          CFRelease(v14);
        }
      }
LABEL_13:
      ++v12;
      ++v7;
      --Count;
    }
    while (Count);
  }
  free(v10);
  free(v8);
}

void XCFPrintError(NSObject *a1, const __CFString *a2, CFErrorRef err)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  CFErrorDomain Domain = CFErrorGetDomain(err);
  CFIndex Code = CFErrorGetCode(err);
  if (Domain)
  {
    if (CFEqual(@"com.apple.mmcs", Domain))
    {
      os_log_type_t v8 = 16 * (Code != 4);
    }
    else
    {
      int v9 = CFEqual((CFTypeRef)*MEMORY[0x1E4F18F50], Domain);
      if (Code == -999 || v9 == 0) {
        os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
      }
      else {
        os_log_type_t v8 = OS_LOG_TYPE_ERROR;
      }
    }
  }
  else
  {
    os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
  }
  if (os_log_type_enabled(a1, v8))
  {
    *(_DWORD *)int buf = 138543874;
    CFStringRef v36 = a2;
    __int16 v37 = 2114;
    CFErrorDomain v38 = Domain;
    __int16 v39 = 2048;
    CFIndex v40 = Code;
    _os_log_impl(&dword_1DC1CA000, a1, v8, "%{public}@ %{public}@/%ld", buf, 0x20u);
  }
  CFDictionaryRef v11 = CFErrorCopyUserInfo(err);
  if (v11)
  {
    CFDictionaryRef v12 = v11;
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFErrorDomain v14 = CFErrorGetDomain(err);
    CFIndex v15 = CFErrorGetCode(err);
    CFStringRef v16 = CFStringCreateWithFormat(v13, 0, @"%@, %@/%ld", a2, v14, v15);
    if (CFDictionaryContainsKey(v12, (const void *)*MEMORY[0x1E4F1D140])) {
      BOOL v17 = CFDictionaryContainsKey(v12, (const void *)*MEMORY[0x1E4F1D170]) != 0;
    }
    else {
      BOOL v17 = 0;
    }
    if (CFDictionaryContainsKey(v12, @"NSErrorFailingURLStringKey")) {
      BOOL v18 = CFDictionaryContainsKey(v12, @"NSErrorFailingURLKey") != 0;
    }
    else {
      BOOL v18 = 0;
    }
    if (CFDictionaryContainsKey(v12, @"_kCFStreamErrorDomainKey")) {
      BOOL v19 = CFDictionaryContainsKey(v12, @"_kCFStreamErrorCodeKey") != 0;
    }
    else {
      BOOL v19 = 0;
    }
    if (!v17 && !v18 && !v19 || (CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v13, 0, v12)) == 0)
    {
      CFDictionaryRef v21 = v12;
LABEL_53:
      XCFPrintDictionary(a1, v16, v21);
      if (v16) {
        CFRelease(v16);
      }
      CFRelease(v21);
      return;
    }
    CFDictionaryRef v21 = MutableCopy;
    if (v17)
    {
      CFDictionaryRemoveValue(MutableCopy, (const void *)*MEMORY[0x1E4F1D170]);
      if (!v18)
      {
LABEL_28:
        if (!v19) {
          goto LABEL_52;
        }
        goto LABEL_33;
      }
    }
    else if (!v18)
    {
      goto LABEL_28;
    }
    CFDictionaryRemoveValue(v21, @"NSErrorFailingURLStringKey");
    if (!v19)
    {
LABEL_52:
      CFRelease(v12);
      goto LABEL_53;
    }
LABEL_33:
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v21, @"_kCFStreamErrorDomainKey");
    CFStringRef v23 = (const __CFString *)CFDictionaryGetValue(v21, @"_kCFStreamErrorCodeKey");
    if (!Value) {
      goto LABEL_52;
    }
    CFStringRef v24 = v23;
    if (!v23) {
      goto LABEL_52;
    }
    CFTypeID v25 = CFGetTypeID(Value);
    if (v25 == CFNumberGetTypeID())
    {
      *(_DWORD *)int buf = 0;
      CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, buf);
      CFStringRef v26 = mmcs_cfnetwork_cfstream_error_domain_copy_description(*(int *)buf);
      size_t v27 = strlen(v26);
      CFStringRef Value = CFStringCreateWithBytes(v13, (const UInt8 *)v26, v27, 0x8000100u, 0);
      if (v26) {
        free(v26);
      }
      CFTypeID v28 = CFGetTypeID(v24);
      if (v28 != CFNumberGetTypeID()) {
        goto LABEL_42;
      }
      int valuePtr = 0;
      CFNumberGetValue((CFNumberRef)v24, kCFNumberSInt32Type, &valuePtr);
      if (*MEMORY[0x1E4F19010] == *(_DWORD *)buf)
      {
        CFStringRef v29 = mmcs_cfnetwork_cfstream_http_error_copy_description(valuePtr);
      }
      else
      {
        if (*(_DWORD *)buf != 1) {
          goto LABEL_42;
        }
        CFStringRef v31 = strerror(valuePtr);
        CFStringRef v29 = strdup(v31);
      }
      uint64_t v32 = (UInt8 *)v29;
      if (v29)
      {
        size_t v33 = strlen(v29);
        CFStringRef v24 = CFStringCreateWithBytes(v13, v32, v33, 0x8000100u, 0);
        free(v32);
        goto LABEL_43;
      }
    }
    else
    {
      CFRetain(Value);
    }
LABEL_42:
    CFRetain(v24);
LABEL_43:
    if (mmcs_logging_logger_default_once != -1) {
      dispatch_once(&mmcs_logging_logger_default_once, &__block_literal_global);
    }
    __int16 v30 = mmcs_logging_logger_default_logger;
    if (os_log_type_enabled((os_log_t)mmcs_logging_logger_default_logger, v8))
    {
      *(_DWORD *)int buf = 138543874;
      CFStringRef v36 = v16;
      __int16 v37 = 2114;
      CFErrorDomain v38 = Value;
      __int16 v39 = 2114;
      CFIndex v40 = (CFIndex)v24;
      _os_log_impl(&dword_1DC1CA000, v30, v8, "%{public}@ CFStreamUnderlyingError %{public}@/%{public}@", buf, 0x20u);
    }
    if (Value) {
      CFRelease(Value);
    }
    if (v24) {
      CFRelease(v24);
    }
    CFDictionaryRemoveValue(v21, @"_kCFStreamErrorDomainKey");
    CFDictionaryRemoveValue(v21, @"_kCFStreamErrorCodeKey");
    goto LABEL_52;
  }
}

void XCFPrint(os_log_t oslog, const __CFString *a2, void *cf)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    goto LABEL_18;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFDictionaryGetTypeID())
  {
    XCFPrintDictionary(oslog, (uint64_t)a2, (const __CFDictionary *)cf);
    return;
  }
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 == CFArrayGetTypeID())
  {
    XCFPrintArray(oslog, (uint64_t)a2, (const __CFArray *)cf);
    return;
  }
  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 == CFErrorGetTypeID())
  {
    XCFPrintError(oslog, a2, (CFErrorRef)cf);
  }
  else
  {
LABEL_18:
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
    {
      int v9 = 138543618;
      CFStringRef v10 = a2;
      __int16 v11 = 2114;
      CFDictionaryRef v12 = cf;
      _os_log_impl(&dword_1DC1CA000, oslog, OS_LOG_TYPE_INFO, "%{public}@ %{public}@", (uint8_t *)&v9, 0x16u);
    }
  }
}

uint64_t mmcs_container_create(uint64_t *a1, int a2, uint64_t a3)
{
  *a1 = 0;
  uint64_t v6 = C3TypeRegister(&mmcs_containerGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v6, a3 + 96);
  if (result)
  {
    uint64_t v8 = result;
    *(_DWORD *)(result + 64) = a2;
    *(void *)(result + 88) = result + 96;
    if (mmcs_transaction_create((uint64_t *)(result + 16), (const void *)result))
    {
      *(void *)(v8 + 56) = 0;
      *(_OWORD *)(v8 + 40) = 0u;
      *(_OWORD *)(v8 + 24) = 0u;
      uint64_t result = 1;
      *(_DWORD *)(v8 + 68) = 1;
      *(void *)(v8 + 72) = 0;
      *(void *)(v8 + 80) = 0;
      *a1 = v8;
    }
    else
    {
      C3BaseRelease((CFTypeRef)v8);
      return 0;
    }
  }
  return result;
}

CFTypeRef mmcs_container_set_http_clock_skew_metrics(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 72);
  if (result != cf)
  {
    if (result) {
      C3BaseRelease(result);
    }
    *(void *)(a1 + 72) = cf;
    return C3BaseRetain(cf);
  }
  return result;
}

void mmcs_container_invalidate_transactions(uint64_t a1)
{
  mmcs_transaction_invalidate(*(void *)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 24);
  mmcs_transaction_invalidate(v2);
}

void *mmcs_container_set_error(void *result, CFTypeRef cf)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFTypeRef v2 = (CFTypeRef)result[5];
  if (v2 != cf)
  {
    int v4 = result;
    if (v2)
    {
      unint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"stomping error for container");
        CFTypeID v7 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          int v9 = 138543362;
          CFStringRef v10 = v6;
          _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v9, 0xCu);
        }
        if (v6) {
          CFRelease(v6);
        }
      }
      uint64_t v8 = (const void *)v4[5];
      if (v8) {
        CFRelease(v8);
      }
    }
    v4[5] = cf;
    return CFRetain(cf);
  }
  return result;
}

void *mmcs_container_set_complete_error(void *result, CFTypeRef cf)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFTypeRef v2 = (CFTypeRef)result[7];
  if (v2 != cf)
  {
    int v4 = result;
    if (v2)
    {
      unint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"stomping complete error for container");
        CFTypeID v7 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          int v9 = 138543362;
          CFStringRef v10 = v6;
          _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v9, 0xCu);
        }
        if (v6) {
          CFRelease(v6);
        }
      }
      uint64_t v8 = (const void *)v4[7];
      if (v8) {
        CFRelease(v8);
      }
    }
    v4[7] = cf;
    return CFRetain(cf);
  }
  return result;
}

void *mmcs_container_set_complete_error_if_absent(void *result, CFTypeRef cf)
{
  if (!result[7]) {
    return mmcs_container_set_complete_error(result, cf);
  }
  return result;
}

void mmcs_container_clear_complete_error(uint64_t a1)
{
  CFTypeRef v2 = *(const void **)(a1 + 56);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)(a1 + 56) = 0;
}

uint64_t mmcs_container_get_primary_error(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  if (!result) {
    return *(void *)(a1 + 56);
  }
  return result;
}

void mmcs_container_reset_error_for_retry(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 40);
  if (!v1) {
    return;
  }
  CFMutableDictionaryRef Mutable = *(__CFArray **)(a1 + 48);
  if (Mutable) {
    goto LABEL_5;
  }
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  *(void *)(a1 + 48) = Mutable;
  if (Mutable)
  {
    uint64_t v1 = *(const void **)(a1 + 40);
LABEL_5:
    CFArrayAppendValue(Mutable, v1);
  }
  int v4 = *(const void **)(a1 + 40);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 40) = 0;
}

uint64_t mmcs_container_remember_error(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 64);
  if (v4) {
    uint64_t v5 = ((uint64_t (*)(uint64_t))_containerCallbacks[11 * v4 + 4])(a1);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t server_version = mmcs_request_get_server_version(v5);
  uint64_t result = mmcs_server_version_compare(server_version, v7, 3, 9);
  if (result != -1)
  {
    int v9 = _containerCallbacks[11 * *(int *)(a1 + 64) + 3];
    return ((uint64_t (*)(uint64_t, uint64_t))v9)(a1, a2);
  }
  return result;
}

uint64_t mmcs_container_mmcs_request(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 64);
  if (v1) {
    return _containerCallbacks[11 * v1 + 4]();
  }
  else {
    return 0;
  }
}

uint64_t mmcs_container_requirements(uint64_t a1)
{
  return _containerCallbacks[11 * *(int *)(a1 + 64) + 7]();
}

BOOL mmcs_container_request_enqueued_or_inflight(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 68) & 0xFFFFFFFE) == 2;
}

BOOL mmcs_container_is_done(uint64_t a1)
{
  return *(_DWORD *)(a1 + 68) == 4;
}

BOOL mmcs_container_is_done_and_failed(uint64_t a1)
{
  return *(_DWORD *)(a1 + 68) == 4 && *(void *)(a1 + 40) != 0;
}

uint64_t mmcs_container_cancel_request_callback(uint64_t a1, __CFError *a2)
{
  return 1;
}

BOOL mmcs_container_schedule_request_callback(uint64_t a1, unsigned char *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = *(_DWORD *)(a1 + 48);
  if (v2 >= 5) {
    mmcs_container_schedule_request_callback_cold_1();
  }
  if (v2 == 2)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    if (*(_DWORD *)(v5 + 64) == 1
      && mmcs_request_is_container_resumable_limp_mode(***(void ***)(v5 + 88)))
    {
      unsigned int done = mmcs_put_state_containers_done_count(**(void **)(v5 + 88));
      unsigned int v7 = mmcs_put_state_containers_failed_count(**(void **)(v5 + 88));
      if (done && v7 < done)
      {
        CFErrorRef v23 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Simulate a container failure after making some resumable progress.", v8, v9, v10, v11, v12, v24);
        mmcs_container_set_error((void *)v5, v23);
        *(_DWORD *)(v5 + 68) = 4;
        if (v23) {
          CFRelease(v23);
        }
        *(_DWORD *)(a1 + 48) = 4;
        *a2 = 0;
        return 1;
      }
    }
    if ((*(_DWORD *)(v5 + 64) - 1) >= 3)
    {
      CFErrorDomain v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"impending doom: bad container->containerClass is %d", *(unsigned int *)(v5 + 64));
        CFStringRef v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v26 = v15;
          _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v15) {
          CFRelease(v15);
        }
      }
    }
    int v17 = ((uint64_t (*)(uint64_t, uint64_t))_containerCallbacks[11 * *(int *)(v5 + 64) + 1])(v5, a1);
    char v18 = v17;
    if (v17)
    {
      *(_DWORD *)(a1 + 48) = 3;
      if (!a2) {
        return 1;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 48) = 4;
      ((void (*)(uint64_t, uint64_t))_containerCallbacks[11 * *(int *)(v5 + 64) + 2])(v5, a1);
      if (!a2) {
        return 1;
      }
    }
    *a2 = v18;
    return 1;
  }
  BOOL v19 = mmcs_logging_logger_default();
  BOOL result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  if (result)
  {
    CFStringRef v21 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"expected request state kMMCSRequestStateEnqueued (%d); got %d",
            2,
            *(unsigned int *)(a1 + 48));
    uint64_t v22 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 138543362;
      CFStringRef v26 = v21;
      _os_log_impl(&dword_1DC1CA000, v22, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v21) {
      CFRelease(v21);
    }
    return 0;
  }
  return result;
}

void mmcs_container_cancel(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(_DWORD *)(a1 + 68) = 4;
    uint64_t v4 = *(void *)(a1 + 24);
    if (v4) {
      ((void (*)(uint64_t, uint64_t, uint64_t))_containerCallbacks[11 * *(int *)(a1 + 64) + 5])(a1, v4, a2);
    }
    uint64_t v5 = _containerCallbacks[11 * *(int *)(a1 + 64) + 5];
    uint64_t v6 = *(void *)(a1 + 16);
    ((void (*)(uint64_t, uint64_t, uint64_t))v5)(a1, v6, a2);
  }
  else
  {
    unsigned int v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"attempting to cancel null container");
      uint64_t v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        int v10 = 138543362;
        CFStringRef v11 = v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v10, 0xCu);
      }
      if (v8) {
        CFRelease(v8);
      }
    }
  }
}

CFURLRef mmcs_container_copy_vendor_url(uint64_t a1)
{
  return CFHTTPMessageCopyRequestURL(*(CFHTTPMessageRef *)(*(void *)(*(void *)(a1 + 16) + 24) + 16));
}

void _mmcs_container_create_proxy_transaction_impl(uint64_t a1, const __CFURL *a2, const __CFBoolean *a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 32);
  if (!v4 || !CFDictionaryGetCount(v4)) {
    return;
  }
  int v7 = *(_DWORD *)(a1 + 64);
  if (!v7 || (uint64_t v8 = ((uint64_t (*)(uint64_t))_containerCallbacks[11 * v7 + 4])(a1)) == 0)
  {
    CFStringRef v15 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
LABEL_16:
      int v17 = 0;
      CFURLRef v14 = 0;
      goto LABEL_17;
    }
    *(_WORD *)CFErrorDomain v38 = 0;
    CFStringRef v16 = "Error invoking get_request for proxy transaction.";
LABEL_15:
    _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_ERROR, v16, v38, 2u);
    goto LABEL_16;
  }
  uint64_t v9 = v8;
  uint64_t v10 = a1 + 24;
  if (!mmcs_transaction_create((uint64_t *)(a1 + 24), (const void *)a1))
  {
    CFStringRef v15 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    *(_WORD *)CFErrorDomain v38 = 0;
    CFStringRef v16 = "Error invoking mmcs_transaction_create for proxy transaction.";
    goto LABEL_15;
  }
  if (mmcs_request_get_proxy_down(v9))
  {
    CFStringRef v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_test or cupidity said to use proxy url https://localhost:5555 for gets");
      uint64_t v13 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CFErrorDomain v38 = 138543362;
        *(void *)&v38[4] = v12;
        _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_DEFAULT, "%{public}@", v38, 0xCu);
      }
      if (v12) {
        CFRelease(v12);
      }
    }
    a2 = XCFURLCreateWithCString("https://localhost:5555");
    CFURLRef v14 = a2;
  }
  else
  {
    CFURLRef v14 = 0;
  }
  if (!mmcs_http_request_copy((void *)(*(void *)(a1 + 24) + 24), *(void **)(*(void *)(a1 + 16) + 24)))
  {
    CFTypeID v28 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFErrorDomain v38 = 0;
      CFStringRef v29 = "Error invoking mmcs_http_request_copy for proxy transaction.";
LABEL_42:
      _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_ERROR, v29, v38, 2u);
    }
LABEL_43:
    int v17 = 0;
    goto LABEL_17;
  }
  CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, *(CFDictionaryRef *)(a1 + 32));
  if (!MutableCopy)
  {
    CFTypeID v28 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFErrorDomain v38 = 0;
      CFStringRef v29 = "Error generating extraHeader dictionary for proxy transaction.";
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  int v17 = MutableCopy;
  CFErrorRef v23 = mmcs_request_copy_persistent_identifier(v9);
  if (!v23)
  {
    __int16 v30 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    *(_WORD *)CFErrorDomain v38 = 0;
    CFStringRef v31 = "Error invoking mmcs_request_copy_persistent_identifier for proxy transaction.";
    goto LABEL_62;
  }
  char v24 = v23;
  CFDictionaryAddValue(v17, @"x-apple-persistent-identifier", v23);
  CFRelease(v24);
  proxy_uint64_t copy = (const void *)mmcs_http_request_options_create_proxy_copy(*(void *)(*(void *)(*(void *)v10 + 24)
                                                                                   + 24));
  if (!proxy_copy)
  {
    __int16 v30 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    *(_WORD *)CFErrorDomain v38 = 0;
    CFStringRef v31 = "Error invoking mmcs_http_request_options_create_proxy_copy for proxy transaction.";
    goto LABEL_62;
  }
  CFStringRef v26 = proxy_copy;
  mmcs_http_request_set_options(*(void *)(*(void *)v10 + 24), proxy_copy);
  CFRelease(v26);
  if (a3 && CFBooleanGetValue(a3))
  {
    uint64_t v27 = *(void *)(*(void *)(*(void *)v10 + 24) + 24);
    if (!v27) {
      goto LABEL_55;
    }
    if (*(void *)(v27 + 80) == 9) {
      goto LABEL_56;
    }
    *(void *)CFErrorDomain v38 = 5;
    CFNumberRef v32 = CFNumberCreate(v21, kCFNumberSInt64Type, v38);
    size_t v33 = *(const void **)(*(void *)(*(void *)(*(void *)v10 + 24) + 24) + 56);
    if (v33) {
      BOOL v34 = CFEqual(v33, v32) == 0;
    }
    else {
      BOOL v34 = 1;
    }
    if (v32) {
      CFRelease(v32);
    }
    if (!v34) {
LABEL_56:
    }
      uint64_t v35 = @"low";
    else {
LABEL_55:
    }
      uint64_t v35 = @"default";
    CFDictionaryAddValue(v17, @"x-apple-cache-urgency", v35);
  }
  CFStringRef v36 = (__CFHTTPMessage *)mmcs_epilogue_buffer_length(*(void *)(*(void *)v10 + 24));
  CFHTTPMessageRef v37 = XCFHTTPMessageCopyWithNewURLAndHeaders(v36, a2, v17);
  if (!v37)
  {
    __int16 v30 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    *(_WORD *)CFErrorDomain v38 = 0;
    CFStringRef v31 = "Error creating modifiedRequest for proxy transaction.";
LABEL_62:
    _os_log_impl(&dword_1DC1CA000, v30, OS_LOG_TYPE_ERROR, v31, v38, 2u);
LABEL_17:
    char v18 = *(const void **)(a1 + 24);
    if (v18) {
      C3BaseRelease(v18);
    }
    CFHTTPMessageRef v19 = 0;
    CFHTTPMessageRef v20 = 0;
    *(void *)(a1 + 24) = 0;
    if (!v17) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  CFHTTPMessageRef v19 = v37;
  mmcs_http_request_set_msg(*(void *)(*(void *)v10 + 24), v37);
LABEL_20:
  CFRelease(v17);
  CFHTTPMessageRef v20 = v19;
LABEL_21:
  if (v14) {
    CFRelease(v14);
  }
  if (v20) {
    CFRelease(v20);
  }
}

uint64_t mmcs_container_create_proxy_transaction(uint64_t a1)
{
  return _containerCallbacks[11 * *(int *)(a1 + 64) + 6]();
}

BOOL mmcs_container_check_expired(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    double v5 = *(double *)(v4 + 40);
    if (v5 == 0.0) {
      return 0;
    }
    double Current = CFAbsoluteTimeGetCurrent();
    double v11 = Current;
    if (gMMCS_DebugLevel >= 4)
    {
      CFStringRef String = XCFAbsoluteTimeDateFormatterCreateString(Current);
      CFStringRef v13 = XCFAbsoluteTimeDateFormatterCreateString(v5);
      CFURLRef v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"current time: %@, url expiry time: %@", String, v13);
        CFStringRef v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v39 = v15;
          _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v15) {
          CFRelease(v15);
        }
      }
      if (String) {
        CFRelease(String);
      }
      if (v13) {
        CFRelease(v13);
      }
    }
    if (v5 > v11) {
      return 0;
    }
    if (gMMCS_DebugLevel >= 4)
    {
      uint64_t v22 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"skipping %s transaction %p of container <%p %s> because url expired", a3, a2, a1, a4);
        char v24 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v39 = v23;
          _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v23) {
          CFRelease(v23);
        }
      }
    }
    if (!mmcs_transaction_is_proxy(a2))
    {
      uint64_t v25 = a1[9];
      if (v25)
      {
        double v26 = *(double *)(v25 + 16);
        double v27 = v26 - *(double *)(v25 + 24);
        double v28 = v5 - v26;
        CFAllocatorRef v29 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        unint64_t v30 = mmcs_time_convert_cfabsolutetime_to_server_time(v26);
        unint64_t v31 = mmcs_time_convert_cfabsolutetime_to_server_time(*(double *)(v25 + 24));
        CFStringRef v32 = CFStringCreateWithFormat(v29, 0, @" authorizedWindowSeconds=%.3lf estimatedClockSkewSecondsAtAuthorize=%.3lf localTimeAtAuthorizeResponse=%llu serverTimeSentInAuthorizeResponse=%llu", *(void *)&v28, *(void *)&v27, v30, v31);
      }
      else
      {
        CFStringRef v32 = 0;
      }
      mmcs_time_convert_cfabsolutetime_to_server_time(v11);
      mmcs_time_convert_cfabsolutetime_to_server_time(v5);
      CFStringRef retry_requested = (const __CFString *)mmcs_cferror_create_retry_requested(0, 0, @"%s container's url expired(secondsExpiredAtLocalExpiryTest=%.3lf localTimeAtExpiryTest=%llu urlExpiryTime=%llu%@)", v33, v34, v35, v36, v37, a3);
      if (v32) {
        CFRelease(v32);
      }
      if (retry_requested)
      {
        mmcs_container_set_error(a1, retry_requested);
        uint64_t v21 = 1;
LABEL_19:
        CFRelease(retry_requested);
        return v21;
      }
    }
    return 1;
  }
  else
  {
    char v18 = mmcs_logging_logger_default();
    BOOL result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (result)
    {
      CFStringRef retry_requested = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null request");
      CFHTTPMessageRef v20 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v39 = retry_requested;
        _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      uint64_t v21 = 0;
      BOOL result = 0;
      if (retry_requested) {
        goto LABEL_19;
      }
    }
  }
  return result;
}

uint64_t mmcs_container_copy_simple_description(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 64);
  if (v1) {
    return _containerCallbacks[11 * v1 + 8]();
  }
  else {
    return 0;
  }
}

int64x2_t mmcs_container_append_description(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 >= 11
    && *(_DWORD *)(*(void *)(v2 + 16) + 48) == 2
    && ((uint64_t v4 = *(void *)(v2 + 24)) == 0 || *(_DWORD *)(v4 + 48) == 2))
  {
    *(void *)(a1 + 40) = v3 + 1;
  }
  else if ((*(_DWORD *)(v2 + 68) & 0xFFFFFFFE) == 2)
  {
    long long v5 = *(_OWORD *)(a1 + 16);
    long long v9 = *(_OWORD *)a1;
    long long v10 = v5;
    int64x2_t v11 = *(int64x2_t *)(a1 + 32);
    *((void *)&v10 + 1) = *((void *)&v5 + 1) + 1;
    mmcs_op_requestor_context_indent(a1);
    int v6 = *(_DWORD *)(v2 + 64);
    if (v6)
    {
      int v7 = (const void *)((uint64_t (*)(uint64_t))_containerCallbacks[11 * v6 + 8])(v2);
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @"<container %p> %@\n", v2, v7, v9, v10, *(_OWORD *)&v11);
      if (v7) {
        CFRelease(v7);
      }
    }
    else
    {
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @"<container %p> %@\n", v2, 0, v9, v10, *(_OWORD *)&v11);
    }
    *(void *)&long long v9 = *(void *)(v2 + 16);
    mmcs_transaction_append_description((uint64_t)&v9);
    if (*(void *)(v2 + 24))
    {
      *(void *)&long long v9 = *(void *)(v2 + 24);
      mmcs_transaction_append_description((uint64_t)&v9);
    }
    int64x2_t result = vaddq_s64(*(int64x2_t *)(a1 + 32), v11);
    *(int64x2_t *)(a1 + 32) = result;
  }
  return result;
}

uint64_t mmcs_container_request_queue(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 64);
  if (v1) {
    uint64_t v2 = _containerCallbacks[11 * v1 + 4]();
  }
  else {
    uint64_t v2 = 0;
  }
  return *(void *)(mmcs_chunk_instance_offset(v2) + 48);
}

uint64_t mmcs_container_xmitcallback(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a1) {
    mmcs_container_xmitcallback_cold_1();
  }
  if (!a3) {
    mmcs_container_xmitcallback_cold_2();
  }
  if (a3[2] != a1) {
    mmcs_container_xmitcallback_cold_3();
  }
  int v5 = *(_DWORD *)(a3[8] + 64);
  if (v5) {
    uint64_t v6 = _containerCallbacks[11 * v5 + 4]();
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(void *)(mmcs_chunk_instance_offset(v6) + 48);
  double Current = CFAbsoluteTimeGetCurrent();
  return mmcs_request_queue_request_did_transmit(v7, a3, a2, Current);
}

uint64_t mmcs_container_process_data(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 64);
  if (v1 >= 2) {
    return _containerCallbacks[11 * (int)v1 + 9]();
  }
  else {
    return 0;
  }
}

uint64_t mmcs_container_invalidate(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 64);
  if (v1 >= 2) {
    return _containerCallbacks[11 * (int)v1 + 10]();
  }
  return result;
}

void _mmcs_containerCFFinalize(uint64_t a1)
{
  uint64_t v2 = _containerCallbacks[11 * *(int *)(a1 + 64)];
  if (v2) {
    ((void (*)(uint64_t))v2)(a1);
  }
  mmcs_transaction_invalidate(*(void *)(a1 + 16));
  mmcs_transaction_invalidate(*(void *)(a1 + 24));
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3) {
    C3BaseRelease(v3);
  }
  *(void *)(a1 + 16) = 0;
  uint64_t v4 = *(const void **)(a1 + 72);
  if (v4) {
    C3BaseRelease(v4);
  }
  *(void *)(a1 + 72) = 0;
  int v5 = *(const void **)(a1 + 24);
  if (v5) {
    C3BaseRelease(v5);
  }
  *(void *)(a1 + 24) = 0;
  uint64_t v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(a1 + 32) = 0;
  uint64_t v7 = *(const void **)(a1 + 40);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(a1 + 40) = 0;
  uint64_t v8 = *(const void **)(a1 + 48);
  if (v8) {
    CFRelease(v8);
  }
  *(void *)(a1 + 48) = 0;
  long long v9 = *(const void **)(a1 + 56);
  if (v9) {
    CFRelease(v9);
  }
  *(void *)(a1 + 56) = 0;
  long long v10 = *(void **)(a1 + 80);
  if (v10) {
    os_release(v10);
  }
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 64) = 0;
}

BOOL _mmcs_containerCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_containerCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_containerCFCopyDebugDescription()
{
  return 0;
}

uint64_t mmcs_engine_detect_working_directory_attributes(const __CFURL *a1, uint64_t *a2, BOOL *a3, unsigned char *a4, CFErrorRef *a5)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  if (!a2 || !a3 || !a4) {
    mmcs_engine_detect_working_directory_attributes_cold_1();
  }
  bzero(buffer, 0x400uLL);
  if (!a1)
  {
    CFStringRef v29 = @"Working Directory Required";
    CFIndex v30 = 40;
LABEL_19:
    CFErrorRef v31 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v30, v29, v10, v11, v12, v13, v14, (char)f_fstypename);
    goto LABEL_20;
  }
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    CFErrorRef v31 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, @"Error Retrieving File System Path for Working Directory, %@", v15, v16, v17, v18, v19, (char)a1);
LABEL_20:
    CFErrorRef v28 = v31;
LABEL_21:
    uint64_t result = 0;
    if (a5) {
      *a5 = v28;
    }
    return result;
  }
  bzero(&v57, 0x878uLL);
  if (statfs((const char *)buffer, &v57))
  {
    CFHTTPMessageRef v20 = __error();
    int v21 = *v20;
    CFErrorRef v22 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D160], *v20, 0);
    strerror(v21);
    error_with_underlying_CFTypeRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 39, v22, @"Stating File System for Working Directory (%s) Failed with Error (%s)", v23, v24, v25, v26, (char)buffer);
    goto LABEL_8;
  }
  if (!v57.f_bsize)
  {
    LOBYTE(f_fstypename) = 0;
    CFStringRef v29 = @"Invalid File System Block Size: %llu";
LABEL_18:
    CFIndex v30 = 39;
    goto LABEL_19;
  }
  *a2 = v57.f_bsize;
  uint64_t v48 = 0;
  long long v47 = xmmword_1DC251CE0;
  long long v44 = 0u;
  long long v45 = 0u;
  int v46 = 0;
  if (getattrlist(v57.f_mntonname, &v47, &v44, 0x24uLL, 0))
  {
    CFStringRef v32 = __error();
    int v33 = *v32;
    CFErrorRef v22 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D160], *v32, 0);
    char v43 = strerror(v33);
    error_with_underlying_CFTypeRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 39, v22, @"Retrieving File System Attributes of working directory failed: %s", v34, v35, v36, v37, v43);
LABEL_8:
    CFErrorRef v28 = error_with_underlying_error;
    if (v22) {
      CFRelease(v22);
    }
    goto LABEL_21;
  }
  if ((BYTE4(v45) & 0x40) == 0)
  {
    f_fstypename = v57.f_fstypename;
    CFStringRef v29 = @"Unknown Support of VOL_CAP_FMT_SPARSE_FILES for %s";
    goto LABEL_18;
  }
  *a4 = BYTE4(v44) & 0x40;
  *a3 = (*(_DWORD *)v57.f_fstypename ^ 0x73667061 | v57.f_fstypename[4]) == 0;
  CFStringRef v39 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v40 = "Supported";
    uint64_t v41 = *a2;
    if (!*a4) {
      uint64_t v40 = "Not Supported";
    }
    *(_DWORD *)int buf = 136446978;
    uint64_t v50 = v57.f_fstypename;
    __int16 v51 = 2082;
    uint64_t v52 = v40;
    __int16 v53 = 2048;
    uint64_t v54 = v41;
    __int16 v55 = 2048;
    uint64_t f_bfree = v57.f_bfree;
    _os_log_impl(&dword_1DC1CA000, v39, OS_LOG_TYPE_DEFAULT, "File System %{public}s, Sparse Files %{public}s, Block Size %llu, Free Blocks %llu", buf, 0x2Au);
  }
  return 1;
}

uint64_t mmcs_engine_get_sparse_block_size()
{
  return 0;
}

uint64_t mmcs_engine_is_apple_file_system(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 136);
}

uint64_t MMCSIsEngineInitialized()
{
  return _isMMCSEngineInitialized;
}

uint64_t MMCSGetCKCustomFixedChunkFileTypeHintString()
{
  return _kMMCS_kCKCustomFixedChunkFileTypeHint;
}

uint64_t mmcs_engine_get_item_reader_writer_for_item_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, CFTypeRef *a6)
{
  uint64_t ItemReaderWriterForItem = MMCSEngineClientContextGetItemReaderWriterForItem(*(void *)(a1 + 152), *(void *)(*(void *)(a1 + 152) + 8), a3, a4, 0, a5, a6);
  uint64_t v13 = ItemReaderWriterForItem;
  if (a6 && !ItemReaderWriterForItem && !*a6) {
    *a6 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"Creating the item readerWriter failed for an unspecified reason", v8, v9, v10, v11, v12, v15);
  }
  return v13;
}

uint64_t mmcs_engine_owner(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 152) + 8);
}

uint64_t MMCSEngineCreate(const void *a1, const void *a2, const __CFURL *a3, const void *a4, const __CFString *a5, const __CFDictionary *a6, uint64_t *a7)
{
  uint64_t v16 = 0;
  if (mmcs_perform_run_loop_target_create((uint64_t *)&v16, a1, a2))
  {
    uint64_t Internal = _MMCSEngineCreateInternal(v16, a3, a4, a5, a6, a7);
    if (v16) {
      C3BaseRelease(v16);
    }
  }
  else
  {
    uint64_t v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v15 = 0;
      _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "Couldn't allocate mmcs_perform_target", v15, 2u);
    }
    return 0;
  }
  return Internal;
}

uint64_t _MMCSEngineCreateInternal(const void *a1, const __CFURL *a2, const void *a3, const __CFString *a4, const __CFDictionary *a5, uint64_t *a6)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  pthread_once(&sOnceForLibrary, _mmcs_init_once_for_library);
  mmcs_proxy_locator_prime();
  uint64_t v12 = 0;
  if (a2 && a6)
  {
    if ((unint64_t)*a6 > 2)
    {
      if (*a6 >= 3 && (a6[2] == 0) == (a6[8] == 0)) {
        return 0;
      }
    }
    else if (!a6[2])
    {
      return 0;
    }
    bzero(buffer, 0x400uLL);
    if (CFURLGetFileSystemRepresentation(a2, 1u, buffer, 1024))
    {
      mkdir_recursive((uint64_t)buffer, 0x1C0u);
      mmcs_engine_cleanup_workpath((char *)buffer, @"new");
    }
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v14 = CKChunkStoreCreate();
    if (v14)
    {
      CFStringRef v15 = (CFStringRef)v14;
      uint64_t v16 = C3TypeRegister(&mmcs_engineGetTypeID_typeID);
      uint64_t Instance = C3TypeCreateInstance_(0, v16, 0xC8uLL);
      if (Instance)
      {
        uint64_t v12 = Instance;
        *(void *)(Instance + 16) = v15;
        CFRetain(v15);
        *(void *)(v12 + 56) = a1;
        C3BaseRetain(a1);
        *(void *)(v12 + 128) = a2;
        CFRetain(a2);
        *(void *)(v12 + 24) = mmcs_job_queue_create();
        *(unsigned char *)(v12 + 120) = 0;
        *(void *)(v12 + 152) = MMCSEngineClientContextCopy(a6);
        CFSetCallBacks callBacks = *(CFSetCallBacks *)byte_1F363C8A0;
        *(void *)(v12 + 160) = CFSetCreateMutable(v13, 0, &callBacks);
        *(unsigned char *)(v12 + 168) = 1;
        *(unsigned char *)(v12 + 175) = 1;
        *(unsigned char *)(v12 + 184) = 1;
        *(_DWORD *)(v12 + 170) = 0x1000000;
        *(void *)(v12 + 72) = a3;
        CFRetain(a3);
        *(void *)(v12 + 80) = mmcs_engine_create_client_header_value((uint64_t)a3);
        if (mmcs_request_queue_create((void *)(v12 + 48)))
        {
          if (a4) {
            *(void *)(v12 + 88) = CFStringCreateCopy(v13, a4);
          }
          if (!a5) {
            goto LABEL_37;
          }
          *(unsigned char *)(v12 + 168) = mmcs_get_BOOLean_from_cfdictionary_object_for_key(a5, @"VerifyPutItemContent", *(unsigned __int8 *)(v12 + 168));
          *(unsigned char *)(v12 + 170) = mmcs_get_BOOLean_from_cfdictionary_object_for_key(a5, @"EnableGetResume", *(unsigned __int8 *)(v12 + 170));
          *(unsigned char *)(v12 + 184) = mmcs_get_BOOLean_from_cfdictionary_object_for_key(a5, @"EnableAttemptedPersistedConnections", *(unsigned __int8 *)(v12 + 184));
          *(unsigned char *)(v12 + 171) = mmcs_get_BOOLean_from_cfdictionary_object_for_key(a5, @"EnableLocallySatisfiedGets", *(unsigned __int8 *)(v12 + 171));
          *(unsigned char *)(v12 + 172) = mmcs_get_BOOLean_from_cfdictionary_object_for_key(a5, @"EnableGetChunks", *(unsigned __int8 *)(v12 + 172));
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a5, @"kMMCSEnginePropertyTestMaxInflightContainerRequests");
          if (Value)
          {
            CFNumberRef v19 = Value;
            CFTypeID v20 = CFGetTypeID(Value);
            if (v20 == CFNumberGetTypeID())
            {
              *(void *)int valuePtr = 0;
              if (CFNumberGetValue(v19, kCFNumberCFIndexType, valuePtr))
              {
                uint64_t v21 = *(void *)valuePtr;
                if (*(uint64_t *)valuePtr >= 1)
                {
                  *(unsigned char *)(v12 + 169) = 1;
                  mmcs_request_queue_set_test_max_requests_inflight(*(void *)(v12 + 48), v21);
                  mmcs_request_queue_set_test_requests_inflight(*(void *)(v12 + 48), *(uint64_t *)valuePtr, 1);
                  mmcs_request_queue_set_test_requests_inflight(*(void *)(v12 + 48), *(uint64_t *)valuePtr, 0);
                }
              }
            }
          }
          CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(a5, @"kMMCSEnginePropertyMaxConsecutiveNetworkErrors");
          if (v22 && (v23 = v22, CFTypeID v24 = CFGetTypeID(v22), v24 == CFNumberGetTypeID()))
          {
            *(_DWORD *)int valuePtr = 0;
            uint64_t v25 = 3;
            if (CFNumberGetValue(v23, kCFNumberIntType, valuePtr))
            {
              uint64_t v26 = *(unsigned int *)valuePtr;
              if ((*(_DWORD *)valuePtr & 0x80000000) == 0)
              {
                mmcs_request_queue_set_test_max_consecutive_network_errors(*(void *)(v12 + 48), *(unsigned int *)valuePtr);
                uint64_t v25 = v26;
              }
            }
          }
          else
          {
LABEL_37:
            uint64_t v25 = 3;
          }
          if (*(unsigned char *)(v12 + 184))
          {
            mmcs_read_stream_pool_create((void *)(v12 + 32), @"icloud_pool_", 20, 0xAu, 1.0);
            CFStringRef v32 = (uint64_t *)(v12 + 40);
            mmcs_read_stream_pool_create((void *)(v12 + 40), @"vendor_pool_", 20, 0xAu, 1.0);
            uint64_t v33 = *(void *)(v12 + 32);
            if (v33) {
              mmcs_read_stream_pool_schedule(v33, *(CFTypeRef *)(v12 + 56));
            }
            if (*v32) {
              mmcs_read_stream_pool_schedule(*v32, *(CFTypeRef *)(v12 + 56));
            }
          }
          if (!_kMMCSEngineDefaultProtocolVersion) {
            MMCSGetDefaultProtocolVersion_cold_1();
          }
          *(void *)(v12 + 64) = _kMMCSEngineDefaultProtocolVersion;
          *(unsigned char *)(v12 + 174) = 1;
          uint64_t v34 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v35 = CFStringCreateWithFormat(v13, 0, @"Created mmcs engine (%p) '%@' %@ DebugLevel:%ld", v12, a3, a4, gMMCS_DebugLevel);
            uint64_t v36 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int valuePtr = 138543362;
              *(void *)&valuePtr[4] = v35;
              _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
            }
            if (v35) {
              CFRelease(v35);
            }
          }
          uint64_t v37 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            if (*(unsigned char *)(v12 + 168)) {
              CFErrorDomain v38 = "true";
            }
            else {
              CFErrorDomain v38 = "false";
            }
            CFStringRef v39 = CFStringCreateWithFormat(v13, 0, @"mmcs_engine verifySentChunks: %s", v38);
            uint64_t v40 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int valuePtr = 138543362;
              *(void *)&valuePtr[4] = v39;
              _os_log_impl(&dword_1DC1CA000, v40, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
            }
            if (v39) {
              CFRelease(v39);
            }
          }
          uint64_t v41 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v42 = CFStringCreateWithFormat(v13, 0, @"mmcs_engine maxConsecutiveNetworkErrors: %lu", v25);
            char v43 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int valuePtr = 138543362;
              *(void *)&valuePtr[4] = v42;
              _os_log_impl(&dword_1DC1CA000, v43, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
            }
            if (v42) {
              CFRelease(v42);
            }
          }
          long long v44 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            if (*(unsigned char *)(v12 + 170)) {
              long long v45 = "true";
            }
            else {
              long long v45 = "false";
            }
            CFStringRef v46 = CFStringCreateWithFormat(v13, 0, @"mmcs_engine enableGetResume: %s", v45);
            long long v47 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int valuePtr = 138543362;
              *(void *)&valuePtr[4] = v46;
              _os_log_impl(&dword_1DC1CA000, v47, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
            }
            if (v46) {
              CFRelease(v46);
            }
          }
          uint64_t v48 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            if (*(unsigned char *)(v12 + 171)) {
              uint64_t v49 = "true";
            }
            else {
              uint64_t v49 = "false";
            }
            CFStringRef v50 = CFStringCreateWithFormat(v13, 0, @"mmcs_engine enableLocallySatisfiedGets: %s", v49);
            __int16 v51 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int valuePtr = 138543362;
              *(void *)&valuePtr[4] = v50;
              _os_log_impl(&dword_1DC1CA000, v51, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
            }
            if (v50) {
              CFRelease(v50);
            }
          }
          uint64_t v52 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            if (*(unsigned char *)(v12 + 172)) {
              __int16 v53 = "true";
            }
            else {
              __int16 v53 = "false";
            }
            CFStringRef v54 = CFStringCreateWithFormat(v13, 0, @"mmcs_engine enableGetChunks: %s", v53);
            __int16 v55 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int valuePtr = 138543362;
              *(void *)&valuePtr[4] = v54;
              _os_log_impl(&dword_1DC1CA000, v55, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
            }
            if (v54) {
              CFRelease(v54);
            }
          }
          CFTypeRef v56 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            if (*(unsigned char *)(v12 + 184)) {
              statfs v57 = "true";
            }
            else {
              statfs v57 = "false";
            }
            CFStringRef v58 = CFStringCreateWithFormat(v13, 0, @"mmcs_engine enableAttemptedPersistedConnections: %s", v57);
            uint64_t v59 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int valuePtr = 138543362;
              *(void *)&valuePtr[4] = v58;
              _os_log_impl(&dword_1DC1CA000, v59, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
            }
            if (v58) {
              CFRelease(v58);
            }
          }
          if (!*(unsigned char *)(v12 + 170))
          {
            uint64_t v60 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
            {
              CFStringRef v61 = CFStringCreateWithFormat(v13, 0, @"Cleaning up orphaned temporary files");
              uint64_t v62 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int valuePtr = 138543362;
                *(void *)&valuePtr[4] = v61;
                _os_log_impl(&dword_1DC1CA000, v62, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
              }
              if (v61) {
                CFRelease(v61);
              }
            }
            mmcs_engine_cleanup_workpath((char *)buffer, @"tmpm");
          }
          mmcs_report_initialize();
          CFTypeRef cf = 0;
          if (mmcs_engine_detect_working_directory_attributes(a2, (uint64_t *)(v12 + 144), (BOOL *)(v12 + 136), (unsigned char *)(v12 + 137), (CFErrorRef *)&cf))
          {
            CFRelease(v15);
            return v12;
          }
          unint64_t v67 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            unint64_t v68 = mmcs_cferror_copy_description((__CFError *)cf);
            *(_DWORD *)int valuePtr = 138543362;
            *(void *)&valuePtr[4] = v68;
            _os_log_impl(&dword_1DC1CA000, v67, OS_LOG_TYPE_ERROR, "Couldn't detect working directory attributes with error: %{public}@", valuePtr, 0xCu);
          }
          CFTypeRef v66 = cf;
          if (!cf) {
            goto LABEL_112;
          }
        }
        else
        {
          uint64_t v63 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
            goto LABEL_112;
          }
          CFStringRef v64 = CFStringCreateWithFormat(v13, 0, @"Couldn't allocate requestQueue");
          CFTypeRef v65 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int valuePtr = 138543362;
            *(void *)&valuePtr[4] = v64;
            _os_log_impl(&dword_1DC1CA000, v65, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
          }
          if (!v64) {
            goto LABEL_112;
          }
          CFTypeRef v66 = v64;
        }
        CFRelease(v66);
LABEL_112:
        CFRelease(v15);
        C3BaseRelease((CFTypeRef)v12);
        return 0;
      }
      CFStringRef v29 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v30 = CFStringCreateWithFormat(v13, 0, @"Couldn't allocate mmcs_engine");
        CFErrorRef v31 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          LODWORD(callBacks.version) = 138543362;
          *(CFIndex *)((char *)&callBacks.version + 4) = (CFIndex)v30;
          _os_log_impl(&dword_1DC1CA000, v31, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&callBacks, 0xCu);
        }
        if (v30) {
          CFRelease(v30);
        }
      }
    }
    else
    {
      double v27 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      CFStringRef v15 = CFStringCreateWithFormat(v13, 0, @"The chunk store is NULL");
      CFErrorRef v28 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        LODWORD(callBacks.version) = 138543362;
        *(CFIndex *)((char *)&callBacks.version + 4) = (CFIndex)v15;
        _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&callBacks, 0xCu);
      }
      if (!v15) {
        return 0;
      }
    }
    CFRelease(v15);
    return 0;
  }
  return v12;
}

uint64_t MMCSEngineCreateWithTargetDispatchQueue(dispatch_queue_t target, const __CFURL *a2, const void *a3, const __CFString *a4, const __CFDictionary *a5, uint64_t *a6)
{
  dispatch_queue_t v11 = dispatch_queue_create_with_target_V2("com.apple.mmcs", 0, target);
  if (!v11) {
    return 0;
  }
  uint64_t v12 = v11;
  uint64_t v17 = 0;
  if (!mmcs_perform_dispatch_target_create((uint64_t *)&v17, v11))
  {
    uint64_t v14 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "Couldn't allocate mmcs_perform_target", v16, 2u);
    }
    return 0;
  }
  uint64_t Internal = _MMCSEngineCreateInternal(v17, a2, a3, a4, a5, a6);
  if (v17) {
    C3BaseRelease(v17);
  }
  uint64_t v17 = 0;
  dispatch_release(v12);
  return Internal;
}

uint64_t mmcs_engine_force_commit(void *a1)
{
  uint64_t result = a1[2];
  if (result)
  {
    uint64_t result = CKCommitDatabaseTransactions();
    a1[12] = 0;
    a1[13] = 0;
    ++a1[14];
  }
  return result;
}

void *mmcs_engine_commit_if_over_threshold(void *result)
{
  unsigned int v1 = result + 12;
  if ((unint64_t)((double)(unint64_t)result[13] * 1.5)
     + (unint64_t)(double)(unint64_t)result[12] >= 0xF4240)
  {
    uint64_t v2 = result;
    uint64_t result = (void *)result[2];
    if (result)
    {
      uint64_t result = (void *)CKCommitDatabaseTransactions();
      void *v1 = 0;
      v1[1] = 0;
      ++v2[14];
    }
  }
  return result;
}

void *mmcs_engine_commit_if_anything_outstanding(void *result)
{
  unsigned int v1 = result;
  uint64_t v2 = result + 12;
  if (result[12] || result[13])
  {
    uint64_t result = (void *)result[2];
    if (result)
    {
      uint64_t result = (void *)CKCommitDatabaseTransactions();
      *uint64_t v2 = 0;
      v2[1] = 0;
      ++v1[14];
    }
  }
  return result;
}

uint64_t mmcs_engine_add_bytes_chunked(uint64_t result, uint64_t a2)
{
  *(void *)(result + 96) += a2;
  return result;
}

uint64_t mmcs_engine_add_bytes_got(uint64_t result, uint64_t a2)
{
  *(void *)(result + 104) += a2;
  return result;
}

void mmcs_engine_poll_for_preferences_update(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 169))
  {
    CFNumberRef v3 = 0;
    CFNumberRef number = 0;
    mmcs_report_copy_vendor_request_queue_config(&number, &v3);
    if (number)
    {
      uint64_t valuePtr = 0;
      if (CFNumberGetValue(number, kCFNumberCFIndexType, &valuePtr)) {
        mmcs_request_queue_set_server_upper_bound_requests_inflight(*(void *)(a1 + 48), valuePtr, 1);
      }
      if (number) {
        CFRelease(number);
      }
      CFNumberRef number = 0;
    }
    if (v3)
    {
      uint64_t valuePtr = 0;
      if (CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr)) {
        mmcs_request_queue_set_server_upper_bound_requests_inflight(*(void *)(a1 + 48), valuePtr, 0);
      }
      if (v3) {
        CFRelease(v3);
      }
    }
  }
}

uint64_t mmcs_engine_has_request_using_itemid(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  uint64_t v4 = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 160), (CFSetApplierFunction)mmcs_request_is_using_itemid, &v3);
  return v4;
}

void mmcs_engine_append_requests_description(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 && !*(unsigned char *)(v1 + 120) && CFSetGetCount(*(CFSetRef *)(v1 + 160)) >= 1)
  {
    CFArrayRef v3 = XCFSetMutableCopyValues(*(const __CFSet **)(v1 + 160), &kC3BaseArrayCallBacks);
    v5.length = CFArrayGetCount(v3);
    v5.CFIndex location = 0;
    CFArraySortValues(v3, v5, (CFComparatorFunction)_request_index_comparator, 0);
    v6.length = CFArrayGetCount(v3);
    v6.CFIndex location = 0;
    CFArrayApplyFunction(v3, v6, (CFArrayApplierFunction)_request_description_applier, a1);
    CFRelease(v3);
  }
}

uint64_t _request_index_comparator(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = mmcs_request_index(a1);
  uint64_t v4 = mmcs_request_index(a2);
  if (v3 < v4) {
    return -1;
  }
  else {
    return v3 > v4;
  }
}

uint64_t _request_description_applier(unint64_t a1, uint64_t a2)
{
  v3[1] = *(_OWORD *)(a2 + 16);
  v3[0] = a1;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  return mmcs_request_append_description((uint64_t)v3);
}

void mmcs_engine_add_request(uint64_t a1, const void *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (mmcs_request_is_chunking_library_corruption_mode((uint64_t)a2))
  {
    if (CKChunkStoreTestFlags())
    {
      mmcs_request_reset_chunking_library_corruption_mode((uint64_t)a2);
    }
    else
    {
      CKChunkStoreTestFlags();
      CKChunkStoreSetTestFlags();
    }
  }
  uint64_t v4 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    CFStringRef v5 = mmcs_request_copy_description((uint64_t)a2);
    CFRange v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v9 = 134218242;
      uint64_t v10 = a1;
      __int16 v11 = 2114;
      CFStringRef v12 = v5;
      _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_INFO, "Engine %p is adding request %{public}@", (uint8_t *)&v9, 0x16u);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
  if (!CFSetGetCount(*(CFSetRef *)(a1 + 160)))
  {
    uint64_t v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        LOWORD(v9) = 0;
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_INFO, "Engine Status: was idle, going active", (uint8_t *)&v9, 2u);
      }
    }
  }
  CFSetSetValue(*(CFMutableSetRef *)(a1 + 160), a2);
}

uint64_t mmcs_engine_remove_request(uint64_t a1, const void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  if (CFSetGetValue(*(CFSetRef *)(a1 + 160), a2) != a2)
  {
    uint64_t v4 = mmcs_logging_logger_default();
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v5) {
      return result;
    }
    CFStringRef v7 = mmcs_request_copy_description((uint64_t)a2);
    uint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 134218242;
      uint64_t v15 = a1;
      __int16 v16 = 2114;
      CFStringRef v17 = v7;
      _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEFAULT, "Engine %p didn't recognize request %{public}@", (uint8_t *)&v14, 0x16u);
    }
    if (v7) {
      CFRelease(v7);
    }
    return 0;
  }
  if (CFSetGetCount(*(CFSetRef *)(a1 + 160)) == 1)
  {
    int v9 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        LOWORD(v14) = 0;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_INFO, "Engine Status: was active, going idle", (uint8_t *)&v14, 2u);
      }
    }
  }
  __int16 v11 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    CFStringRef v12 = mmcs_request_copy_description((uint64_t)a2);
    uint64_t v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      int v14 = 134218242;
      uint64_t v15 = a1;
      __int16 v16 = 2114;
      CFStringRef v17 = v12;
      _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_INFO, "Engine %p is removing request %{public}@", (uint8_t *)&v14, 0x16u);
    }
    if (v12) {
      CFRelease(v12);
    }
  }
  if (mmcs_request_is_chunking_library_corruption_mode((uint64_t)a2))
  {
    CKChunkStoreTestFlags();
    CKChunkStoreSetTestFlags();
  }
  XCFSetSafelyRemoveValue(*(void **)(a1 + 160), a2);
  return 1;
}

BOOL mmcs_engine_contains_request(uint64_t a1, const void *a2)
{
  return a2 && CFSetGetValue(*(CFSetRef *)(a1 + 160), a2) == a2;
}

void mmcs_engine_cache_ranged_items(uint64_t a1, void *key, void *value)
{
  CFMutableDictionaryRef Mutable = *(__CFDictionary **)(a1 + 208);
  if (!Mutable)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
    *(void *)(a1 + 208) = Mutable;
  }
  CFDictionaryAddValue(Mutable, key, value);
}

void mmcs_engine_copy_cached_ranged_items(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 208);
  if (v4)
  {
    CFNumberRef Value = CFDictionaryGetValue(v4, a2);
    if (Value)
    {
      CFStringRef v7 = Value;
      uint64_t v8 = *(__CFDictionary **)(a1 + 208);
      CFDictionaryAddValue(v8, a3, v7);
    }
  }
}

CFDictionaryRef mmcs_engine_get_cached_ranged_items(uint64_t a1, const void *a2)
{
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 208);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  }
  return result;
}

void mmcs_engine_clear_cached_ranged_items(uint64_t a1, const void *a2)
{
  uint64_t v3 = *(__CFDictionary **)(a1 + 208);
  if (v3)
  {
    CFDictionaryRemoveValue(v3, a2);
    if (!CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 208)))
    {
      CFRelease(*(CFTypeRef *)(a1 + 208));
      *(void *)(a1 + 208) = 0;
    }
  }
}

void MMCSEngineRelease(CFTypeRef cf)
{
  if (cf) {
    C3BaseRelease(cf);
  }
}

void MMCSEngineDestroy(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1 && !*(unsigned char *)(a1 + 120))
  {
    if (*(void *)(a1 + 16))
    {
      CKCommitDatabaseTransactions();
      *(void *)(a1 + 96) = 0;
      *(void *)(a1 + 104) = 0;
      ++*(void *)(a1 + 112);
    }
    uint64_t v2 = mmcs_logging_logger_default();
    BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    CFDictionaryRef v4 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (v3)
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Closing mmcs (%p)", a1);
      CFRange v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v14 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
    *(unsigned char *)(a1 + 120) = 1;
    mmcs_report_close();
    CFSetApplyFunction(*(CFSetRef *)(a1 + 160), (CFSetApplierFunction)_log_in_use, 0);
    _mmcs_engine_cancel_requests(a1, 0);
    CFStringRef v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v8 = CFStringCreateWithFormat(*v4, 0, @"Waiting for mmcs job queue");
      int v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v14 = v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v8) {
        CFRelease(v8);
      }
    }
    mmcs_job_queue_sync_halt(*(void *)(a1 + 24));
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v11 = CFStringCreateWithFormat(*v4, 0, @"mmcs job queue halted");
      CFStringRef v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v14 = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
    if (*(void *)(a1 + 16)) {
      CKChunkStoreInvalidate();
    }
    C3BaseRelease((CFTypeRef)a1);
  }
}

void _log_in_use(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (mmcs_request_has_items_not_done(a1))
  {
    CFStringRef v2 = mmcs_request_copy_description(a1);
    BOOL v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Closing mmcs with outstanding request %@", v2);
      CFStringRef v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 138543362;
        CFStringRef v7 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
    if (v2) {
      CFRelease(v2);
    }
  }
}

void _mmcs_engine_cancel_requests(uint64_t a1, void *a2)
{
  if (CFSetGetCount(*(CFSetRef *)(a1 + 160)) >= 1)
  {
    CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFSetRef *)(a1 + 160));
    CFSetApplyFunction(Copy, (CFSetApplierFunction)mmcs_request_cancel_with_requestor, a2);
    if (Copy)
    {
      CFRelease(Copy);
    }
  }
}

void MMCSEngineCancelRequests(uint64_t a1, void *a2)
{
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 120)) {
      _mmcs_engine_cancel_requests(a1, a2);
    }
  }
}

CFSetRef MMCSEngineIsActive(const __CFSet *result)
{
  if (result)
  {
    CFDictionaryRef result = (const __CFSet *)*((void *)result + 20);
    if (result) {
      return (const __CFSet *)(CFSetGetCount(result) > 0);
    }
  }
  return result;
}

void _mmcs_init_once_for_library()
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  _isMMCSEngineInitialized = 1;
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F1D140], @"Memory could not be allocated for the intended error");
  mmcs_no_memory_error_init(Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  CFPreferencesAppSynchronize(@"com.apple.mmcs");
  CFNumberRef v2 = (const __CFNumber *)CFPreferencesCopyAppValue(@"DebugLevel", @"com.apple.mmcs");
  if (v2)
  {
    CFNumberRef v3 = v2;
    if (IsValidCFNumber(v2))
    {
      CFNumberGetValue(v3, kCFNumberCFIndexType, &gMMCS_DebugLevel);
    }
    else if (IsValidCFString(v3))
    {
      gMMCS_DebugLevel = CFStringGetIntValue((CFStringRef)v3);
    }
    CFRelease(v3);
  }
  CFURLRef v4 = CFURLCreateWithFileSystemPath(v0, @"/Library/Managed Preferences/mobile/com.apple.mmcs.plist", kCFURLPOSIXPathStyle, 0);
  if (v4)
  {
    CFURLRef v5 = v4;
    CFRange v6 = CFReadStreamCreateWithFile(v0, v4);
    if (!v6)
    {
      CFDictionaryRef v9 = v5;
LABEL_21:
      CFRelease(v9);
      goto LABEL_22;
    }
    CFStringRef v7 = v6;
    if (CFReadStreamOpen(v6))
    {
      error[0] = 0;
      format[0] = 0;
      CFDictionaryRef v8 = (const __CFDictionary *)CFPropertyListCreateWithStream(v0, v7, 0, 0, format, error);
      CFReadStreamClose(v7);
    }
    else
    {
      CFDictionaryRef v8 = 0;
    }
    CFRelease(v7);
    CFRelease(v5);
    if (v8)
    {
      if (IsValidCFDictionary(v8))
      {
        CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v8, @"DebugLevel");
        if (Value)
        {
          LODWORD(error[0]) = 0;
          if (IntFromCFObject(Value, (SInt32 *)error)) {
            gMMCS_DebugLevel = SLODWORD(error[0]);
          }
        }
      }
      CFDictionaryRef v9 = v8;
      goto LABEL_21;
    }
  }
LABEL_22:
  if (gMMCS_DebugLevel >= 5)
  {
    setenv("CS_LOG_VERBOSE", "1", 1);
    error[0] = 0;
    log_dir_path = getenv("MMCS_LOG_DIR");
    if (!log_dir_path) {
      log_dir_path = (char *)get_log_dir_path("");
    }
    asprintf((char **)error, "%s/ubiquity-chunkstore.log", log_dir_path);
    if (error[0])
    {
      setenv("CS_LOG_PATH", (const char *)error[0], 1);
      if (error[0]) {
        free(error[0]);
      }
    }
  }
  CFStringRef v12 = (char *)malloc_type_malloc(0x8000uLL, 0x862C05EuLL);
  uint64_t v13 = malloc_type_malloc(0x8000uLL, 0x1EBCB2E3uLL);
  CFStringRef v14 = malloc_type_malloc(0x8000uLL, 0xB441DDC2uLL);
  uint64_t v15 = v14;
  format[0] = 0;
  *(void *)bytes = 0;
  if (v12 && v13 && v14)
  {
    uint64_t v16 = 0;
    int8x16_t v17 = (int8x16_t)xmmword_1DC251CD0;
    v18.i64[0] = 0x1010101010101010;
    v18.i64[1] = 0x1010101010101010;
    do
    {
      *(int8x16_t *)&v12[v16] = v17;
      v16 += 16;
      int8x16_t v17 = vaddq_s8(v17, v18);
    }
    while (v16 != 0x8000);
    if (!CKChunkDigestArgumentsV1Create()) {
      goto LABEL_74;
    }
    memcpy(v13, v12, 0x8000uLL);
    CKEncryptData();
    CKChunkDigestResultsChunkSignature();
    if (CKValidateSignature())
    {
      memcpy(v15, v13, 0x8000uLL);
      CKDecryptData();
      if (!memcmp(v12, v15, 0x8000uLL))
      {
        int v24 = 0;
LABEL_49:
        if (format[0]) {
          CFRelease((CFTypeRef)format[0]);
        }
        if (*(void *)bytes) {
          CFRelease(*(CFTypeRef *)bytes);
        }
        if (v12) {
          free(v12);
        }
        if (v13) {
          free(v13);
        }
        if (v15) {
          free(v15);
        }
        if (v24) {
LABEL_74:
        }
          abort();
        error[0] = 0;
        error[1] = 0;
        format[0] = 0;
        format[1] = 0;
        memset(bytes, 0, sizeof(bytes));
        *(void *)CFErrorRef v31 = 0;
        CFDataRef v25 = CFDataCreate(v0, (const UInt8 *)error, 16);
        CFDataRef v26 = CFDataCreate(v0, (const UInt8 *)format, 16);
        CFDataRef v27 = CFDataCreate(v0, bytes, 16);
        CFDataRef v28 = v27;
        if (v25 && v26 && v27)
        {
          CKStreamKeyDerivation();
        }
        else if (!v25)
        {
LABEL_66:
          if (v26) {
            CFRelease(v26);
          }
          if (v28) {
            CFRelease(v28);
          }
          if (*(void *)v31) {
            CFRelease(*(CFTypeRef *)v31);
          }
          goto LABEL_74;
        }
        CFRelease(v25);
        goto LABEL_66;
      }
      CFNumberRef v19 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        CFTypeID v20 = (__CFError *)CFStringCreateWithFormat(v0, 0, @"encryption/decryption failed!");
        uint64_t v21 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          goto LABEL_46;
        }
        LODWORD(error[0]) = 138543362;
        *(CFErrorRef *)((char *)error + 4) = v20;
        goto LABEL_45;
      }
    }
    else
    {
      CFNumberRef v23 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        CFTypeID v20 = (__CFError *)CFStringCreateWithFormat(v0, 0, @"CKValidateSignature failed!");
        uint64_t v21 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          goto LABEL_46;
        }
        LODWORD(error[0]) = 138543362;
        *(CFErrorRef *)((char *)error + 4) = v20;
LABEL_45:
        _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)error, 0xCu);
LABEL_46:
        if (v20) {
          CFRelease(v20);
        }
      }
    }
  }
  else
  {
    CFNumberRef v22 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      CFTypeID v20 = (__CFError *)CFStringCreateWithFormat(v0, 0, @"malloc");
      uint64_t v21 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
        goto LABEL_46;
      }
      LODWORD(error[0]) = 138543362;
      *(CFErrorRef *)((char *)error + 4) = v20;
      goto LABEL_45;
    }
  }
  int v24 = 1;
  goto LABEL_49;
}

uint64_t mmcs_engine_cleanup_workpath(char *a1, const __CFString *a2)
{
  v28[2] = *(char **)MEMORY[0x1E4F143B8];
  v28[0] = a1;
  v28[1] = 0;
  CFNumberRef v3 = fts_open(v28, 28, 0);
  CFURLRef v4 = fts_read(v3);
  if (v4)
  {
    CFURLRef v5 = v4;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (2)
    {
      switch(v5->fts_info)
      {
        case 4u:
        case 7u:
          CFNumberRef v22 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v23 = CFStringCreateWithFormat(v6, 0, @"Error in enumeration: fts_errno => %d", v5->fts_errno);
            int v24 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 138543362;
              CFStringRef v27 = v23;
              _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            }
            if (v23) {
              CFRelease(v23);
            }
          }
          return fts_close(v3);
        case 8u:
        case 0xBu:
          CFStringRef v7 = CFStringCreateWithCString(v6, v5->fts_path, 0x8000100u);
          if (!v7) {
            goto LABEL_19;
          }
          CFStringRef v8 = v7;
          CFStringRef PathComponent = XCFStringCopyLastPathComponent(v7);
          if (!PathComponent) {
            goto LABEL_18;
          }
          CFStringRef v10 = PathComponent;
          if (!CFStringHasPrefix(PathComponent, a2)) {
            goto LABEL_17;
          }
          int v11 = unlink(v5->fts_path);
          CFStringRef v12 = mmcs_logging_logger_default();
          if (v11)
          {
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              fts_path = v5->fts_path;
              uint64_t v14 = *__error();
              uint64_t v15 = __error();
              uint64_t v16 = strerror(*v15);
              CFStringRef v17 = CFStringCreateWithFormat(v6, 0, @"error cleaning up file %s: (%d)%s", fts_path, v14, v16);
              int8x16_t v18 = mmcs_logging_logger_default();
              if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
                goto LABEL_15;
              }
              *(_DWORD *)int buf = 138543362;
              CFStringRef v27 = v17;
              CFNumberRef v19 = v18;
              os_log_type_t v20 = OS_LOG_TYPE_ERROR;
              goto LABEL_14;
            }
          }
          else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v17 = CFStringCreateWithFormat(v6, 0, @"cleaning up file %s", v5->fts_path);
            uint64_t v21 = mmcs_logging_logger_default();
            if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_15;
            }
            *(_DWORD *)int buf = 138543362;
            CFStringRef v27 = v17;
            CFNumberRef v19 = v21;
            os_log_type_t v20 = OS_LOG_TYPE_DEFAULT;
LABEL_14:
            _os_log_impl(&dword_1DC1CA000, v19, v20, "%{public}@", buf, 0xCu);
LABEL_15:
            if (v17) {
              CFRelease(v17);
            }
          }
LABEL_17:
          CFRelease(v10);
LABEL_18:
          CFRelease(v8);
          goto LABEL_19;
        default:
LABEL_19:
          CFURLRef v5 = fts_read(v3);
          if (!v5) {
            return fts_close(v3);
          }
          continue;
      }
    }
  }
  return fts_close(v3);
}

void _mmcs_engineCFFinalize(void *a1)
{
  CFNumberRef v2 = (const void *)a1[20];
  if (v2) {
    CFRelease(v2);
  }
  a1[20] = 0;
  CFNumberRef v3 = (const void *)a1[10];
  if (v3) {
    CFRelease(v3);
  }
  a1[10] = 0;
  CFURLRef v4 = (const void *)a1[9];
  if (v4) {
    CFRelease(v4);
  }
  a1[9] = 0;
  CFURLRef v5 = (const void *)a1[11];
  if (v5) {
    CFRelease(v5);
  }
  a1[11] = 0;
  CFAllocatorRef v6 = (const void *)a1[7];
  if (v6) {
    C3BaseRelease(v6);
  }
  a1[7] = 0;
  CFStringRef v7 = (const void *)a1[16];
  if (v7) {
    CFRelease(v7);
  }
  CFStringRef v8 = (void *)a1[19];
  if (v8) {
    MMCSEngineClientContextFree(v8);
  }
  CFDictionaryRef v9 = (const void *)a1[2];
  if (v9) {
    CFRelease(v9);
  }
  a1[2] = 0;
  CFStringRef v10 = (const void *)a1[3];
  if (v10) {
    C3BaseRelease(v10);
  }
  a1[3] = 0;
  int v11 = (const void *)a1[22];
  if (v11) {
    CFRelease(v11);
  }
  a1[22] = 0;
  CFStringRef v12 = (void *)a1[4];
  if (v12)
  {
    mmcs_read_stream_pool_close(v12);
    uint64_t v13 = (const void *)a1[4];
    if (v13) {
      C3BaseRelease(v13);
    }
    a1[4] = 0;
  }
  uint64_t v14 = (void *)a1[5];
  if (v14)
  {
    mmcs_read_stream_pool_close(v14);
    uint64_t v15 = (const void *)a1[5];
    if (v15) {
      C3BaseRelease(v15);
    }
    a1[5] = 0;
  }
  uint64_t v16 = (const void *)a1[6];
  if (v16) {
    C3BaseRelease(v16);
  }
  a1[6] = 0;
  a1[8] = 0;
  a1[24] = 0;
  a1[25] = 0;
}

BOOL _mmcs_engineCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_engineCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_engineCFCopyDebugDescription()
{
  return 0;
}

void handle_response_downloadChunks(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = 0;
  }
  if (!a1) {
    handle_response_downloadChunks_cold_1();
  }
  if (!a3) {
    handle_response_downloadChunks_cold_2();
  }
  if (*(void *)(a3 + 16) != a1) {
    handle_response_downloadChunks_cold_4();
  }
  uint64_t v6 = *(void *)(a3 + 64);
  if (!v6)
  {
    CFStringRef v17 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null container in get, transaction %p context %p", a3, a1);
    CFNumberRef v19 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    LODWORD(state.opaque[0]) = 138543362;
    *(uint64_t *)((char *)state.opaque + 4) = (uint64_t)v18;
    goto LABEL_31;
  }
  uint64_t v7 = *(void *)(v6 + 88);
  if (!v7)
  {
    os_log_type_t v20 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null containerImpl in get, container %p context %p", v6, a1);
    CFNumberRef v19 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    LODWORD(state.opaque[0]) = 138543362;
    *(uint64_t *)((char *)state.opaque + 4) = (uint64_t)v18;
    goto LABEL_31;
  }
  CFStringRef v8 = *(CFDictionaryRef **)v7;
  *(_DWORD *)(a3 + 48) = 4;
  if (v8)
  {
    mmcs_http_context_uuid_hash_code(a1);
    kdebug_trace();
    if (!mmcs_http_context_is_connection_reused(a1)) {
      kdebug_trace();
    }
    CFDictionaryRef v9 = *v8;
    state.opaque[0] = 0;
    state.opaque[1] = 0;
    request_activity_marker = mmcs_request_get_request_activity_marker((uint64_t)v9);
    os_activity_scope_enter(request_activity_marker, &state);
    CFTypeRef cf = 0;
    C3BaseRetain(v9);
    char v72 = 1;
    ++*(void *)(*((void *)v9 + 38) + 24);
    if (*((unsigned char *)v9 + 272))
    {
      if (!*((unsigned char *)v9 + 72))
      {
        int v11 = (__CFString *)mmcs_http_context_copy_blocked_application_header_value(a1);
        if (v11)
        {
          CFTypeRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 51, v11);
          mmcs_http_context_set_error(a1, error);
        }
      }
    }
    uint64_t v13 = *(void *)(*((void *)v9 + 4) + 48);
    if (mmcs_transaction_is_proxy(a3) || mmcs_http_context_is_background(a1)) {
      uint64_t v14 = 0;
    }
    else {
      uint64_t v14 = (__CFError *)mmcs_http_context_get_error(a1);
    }
    int is_connection_reused = mmcs_http_context_is_connection_reused(a1);
    double Current = CFAbsoluteTimeGetCurrent();
    mmcs_request_queue_request_did_complete(v13, (void *)a3, v14, is_connection_reused, (BOOL *)&v72, Current);
    if (*(unsigned char *)(*((void *)v9 + 38) + 40)) {
      goto LABEL_21;
    }
    if (*((unsigned char *)v9 + 144))
    {
      int has_outstanding_asynchronous_work = mmcs_get_req_has_outstanding_asynchronous_work((uint64_t)v9);
      CFStringRef v23 = mmcs_logging_logger_default();
      BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG);
      if (has_outstanding_asynchronous_work)
      {
        if (v24)
        {
          CFStringRef v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Request is cancelled but has_outstanding_asynchronous_work  (Get request %p)", v9);
          CFDataRef v26 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 138543362;
            *(void *)&uint8_t buf[4] = v25;
            _os_log_impl(&dword_1DC1CA000, v26, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v25) {
            CFRelease(v25);
          }
        }
        goto LABEL_21;
      }
      if (v24)
      {
        CFStringRef v38 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cancelled and downloads complete. All done! (Get request %p)", v9);
        CFStringRef v39 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 138543362;
          *(void *)&uint8_t buf[4] = v38;
          _os_log_impl(&dword_1DC1CA000, v39, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v38) {
          CFRelease(v38);
        }
      }
      CFErrorRef v40 = (CFErrorRef)*((void *)v9 + 19);
      goto LABEL_60;
    }
    uint64_t v27 = mmcs_http_context_get_error(a1);
    if (!v27)
    {
      if (mmcs_get_container_is_body_complete(v6, (CFErrorRef *)&cf))
      {
        int v42 = 0;
        BOOL v43 = 0;
        goto LABEL_108;
      }
      mmcs_container_set_error((void *)v6, cf);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = 0;
LABEL_87:
      uint64_t v48 = *((void *)v9 + 4);
      if (!*(unsigned char *)(v48 + 172)
        || !*(unsigned char *)(v48 + 170)
        || !mmcs_get_container_contains_only_chunk_reference_elements(v6))
      {
        goto LABEL_104;
      }
      if (*(void *)(v7 + 88))
      {
        uint64_t v49 = 0;
        unint64_t v50 = 0;
        unint64_t v51 = 0;
        do
        {
          v50 += mmcs_chunk_instance_get_length((CFDataRef *)(*(void *)(v7 + 120) + v49));
          ++v51;
          v49 += 104;
        }
        while (v51 < *(void *)(v7 + 88));
      }
      else
      {
        unint64_t v50 = 0;
      }
      uint64_t v52 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
      {
        __int16 v53 = " ";
        if (v50 > 0x7D000) {
          __int16 v53 = "not ";
        }
        CFStringRef v54 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%llu bytes of complete chunks downloaded already. Will %sretry this request", v50, v53);
        __int16 v55 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 138543362;
          *(void *)&uint8_t buf[4] = v54;
          _os_log_impl(&dword_1DC1CA000, v55, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v54) {
          CFRelease(v54);
        }
      }
      if (v50 <= 0x7D000)
      {
LABEL_104:
        uint64_t v56 = *(void *)(a3 + 32);
        if (v56 >= 1) {
          *(void *)(a3 + 32) = --v56;
        }
        BOOL v43 = v56 != 0;
        goto LABEL_107;
      }
LABEL_103:
      BOOL v43 = 0;
LABEL_107:
      int v42 = 1;
LABEL_108:
      if (v72 && (mmcs_transaction_is_proxy(a3) ? (int v57 = 1) : (int v57 = v43), (v42 & v57) == 1))
      {
        uint64_t metrics = mmcs_http_context_get_metrics(a1);
        mmcs_metrics_http_info_set_final_try_in_request(metrics, 0);
        mmcs_get_container_retry(v6, a3);
      }
      else
      {
        uint64_t v59 = mmcs_http_context_get_metrics(a1);
        mmcs_metrics_http_info_set_final_try_in_request(v59, 1);
        *(_DWORD *)(v6 + 68) = 4;
        unsigned int reporting_level = mmcs_request_get_reporting_level(***(void ***)(v6 + 88));
        method_completion_info = mmcs_get_complete_create_method_completion_info(v6, a3, reporting_level, 0);
        mmcs_transaction_add_method_completion_info(a3, method_completion_info);
        uint64_t v62 = *(void *)(a3 + 16);
        if (v62)
        {
          mmcs_http_context_invalidate(v62);
          uint64_t v63 = *(const void **)(a3 + 16);
          if (v63) {
            C3BaseRelease(v63);
          }
        }
        *(void *)(a3 + 16) = 0;
        if (v42) {
          mmcs_get_state_fail_container(v8, (void *)v6);
        }
      }
      --*(void *)(*((void *)v9 + 38) + 24);
      if (mmcs_get_req_has_outstanding_asynchronous_work((uint64_t)v9)
        || *(void *)(*((void *)v9 + 38) + 24))
      {
        goto LABEL_21;
      }
      if (mmcs_get_container_contains_only_chunk_reference_elements(v6))
      {
        CFStringRef v64 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)int buf = 134217984;
          *(void *)&uint8_t buf[4] = v9;
          _os_log_impl(&dword_1DC1CA000, v64, OS_LOG_TYPE_INFO, "Chunk downloads complete. All done! (Get request %p)", buf, 0xCu);
        }
        uint64_t v41 = (uint64_t)v9;
        CFErrorRef v40 = 0;
        goto LABEL_61;
      }
      if (!mmcs_get_container_contains_only_ford_elements(v6)) {
        handle_response_downloadChunks_cold_3();
      }
      CFTypeRef v65 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int buf = 134217984;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl(&dword_1DC1CA000, v65, OS_LOG_TYPE_INFO, "FORD downloads complete. Download chunks! (Get request %p)", buf, 0xCu);
      }
      *(void *)int buf = 0;
      if (send_request_downloadChunks((uint64_t)v9, (CFErrorRef *)buf) != -1) {
        goto LABEL_21;
      }
      CFErrorRef v40 = *(CFErrorRef *)buf;
      if (!*(void *)buf)
      {
        CFErrorRef v40 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed to check for local state after downloading FORD.", v66, v67, v68, v69, v70, v71);
        *(void *)int buf = v40;
      }
LABEL_60:
      uint64_t v41 = (uint64_t)v9;
LABEL_61:
      mmcs_get_req_context_cleanup(v41, (uint64_t)v40);
LABEL_21:
      C3BaseRelease(v9);
      os_activity_scope_leave(&state);
      return;
    }
    CFDataRef v28 = (__CFError *)v27;
    host_CFTypeRef error = mmcs_cferror_copy_transformed_cannot_find_host_error(a1);
    CFErrorRef v30 = host_error;
    if (host_error) {
      CFErrorRef v31 = host_error;
    }
    else {
      CFErrorRef v31 = v28;
    }
    mmcs_container_set_error((void *)v6, v31);
    CFErrorDomain Domain = CFErrorGetDomain(v31);
    CFIndex Code = CFErrorGetCode(v31);
    if (!CFEqual(@"com.apple.mmcs", Domain))
    {
      if (CFEqual((CFTypeRef)*MEMORY[0x1E4F1D158], Domain))
      {
        BOOL v44 = Code == -9810;
      }
      else
      {
        if (!CFEqual((CFTypeRef)*MEMORY[0x1E4F18F50], Domain))
        {
          BOOL v34 = CFEqual((CFTypeRef)*MEMORY[0x1E4F1D160], Domain) != 0;
          goto LABEL_84;
        }
        BOOL v44 = Code == -1005;
      }
      BOOL v34 = v44;
LABEL_84:
      if (v30) {
        CFRelease(v30);
      }
      if (!v34) {
        goto LABEL_103;
      }
      goto LABEL_87;
    }
    BOOL v34 = 1;
    if (Code > 15)
    {
      if (Code == 16)
      {
        CFDictionaryRef v45 = CFErrorCopyUserInfo(v31);
        if (!v45) {
          goto LABEL_84;
        }
        CFDictionaryRef v36 = v45;
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v45, @"kMMCSErrorSupplementalDictionaryKey");
        if (Value)
        {
          CFStringRef v47 = (const __CFString *)CFDictionaryGetValue(Value, @"Retry-After");
          if (v47) {
            BOOL v34 = CFStringGetIntValue(v47) < 6;
          }
        }
        goto LABEL_83;
      }
      if (Code == 38) {
        goto LABEL_84;
      }
    }
    else
    {
      if (Code == 3) {
        goto LABEL_84;
      }
      if (Code == 6)
      {
        CFDictionaryRef v35 = CFErrorCopyUserInfo(v31);
        if (v35)
        {
          CFDictionaryRef v36 = v35;
          CFNumberRef v37 = (const __CFNumber *)CFDictionaryGetValue(v35, @"kMMCSErrorHTTPStatusKey");
          if (v37)
          {
            *(void *)int buf = -1;
            CFNumberGetValue(v37, kCFNumberCFIndexType, buf);
            BOOL v34 = *(void *)buf == 500;
          }
          else
          {
            BOOL v34 = 0;
          }
LABEL_83:
          CFRelease(v36);
          goto LABEL_84;
        }
      }
    }
    BOOL v34 = 0;
    goto LABEL_84;
  }
  uint64_t v21 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null get state backref in get container %p context %p", v6, a1);
    CFNumberRef v19 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    LODWORD(state.opaque[0]) = 138543362;
    *(uint64_t *)((char *)state.opaque + 4) = (uint64_t)v18;
LABEL_31:
    _os_log_impl(&dword_1DC1CA000, v19, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&state, 0xCu);
LABEL_32:
    if (v18) {
      CFRelease(v18);
    }
  }
}

uint64_t send_request_downloadChunks(uint64_t a1, CFErrorRef *a2)
{
  uint64_t v149 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  os_activity_scope_enter(request_activity_marker, &state);
  if (a2)
  {
    *a2 = 0;
    CFURLRef v5 = (unsigned char *)(a1 + 144);
    if (*(unsigned char *)(a1 + 144))
    {
LABEL_7:
      uint64_t v7 = *(__CFError **)(a1 + 152);
      *a2 = v7;
      CFRetain(v7);
      goto LABEL_8;
    }
  }
  else
  {
    CFURLRef v5 = (unsigned char *)(a1 + 144);
    if (*(unsigned char *)(a1 + 144)) {
      goto LABEL_8;
    }
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 304) + 112);
  mmcs_get_item_progress_make_state_progress(3, (uint64_t)&v127, 0.0);
  mmcs_get_request_set_progress_and_notify_all_items_not_done(a1, &v127);
  if (*(unsigned char *)(a1 + 144))
  {
LABEL_6:
    if (a2) {
      goto LABEL_7;
    }
LABEL_8:
    uint64_t v8 = 0xFFFFFFFFLL;
    goto LABEL_9;
  }
  uint64_t v10 = *(void *)(*(void *)(a1 + 304) + 120);
  if (v10)
  {
    CFAbsoluteTimeGetCurrent();
    mmcs_perform_timer_set_next_fire_date(v10);
  }
  if (v6)
  {
    CFSetApplyFunction(*(CFSetRef *)(*(void *)(a1 + 304) + 72), (CFSetApplierFunction)_mmcs_item_setup_chunk_references, *(void **)(*(void *)(a1 + 304) + 112));
    if (gMMCS_DebugLevel >= 5)
    {
      int v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v125 = *(void *)(*(void *)(*(void *)(a1 + 304) + 112) + 88);
        CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"populated counts dictionary: %@");
        uint64_t v13 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 138543362;
          *(void *)&uint8_t buf[4] = v12;
          _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v12) {
          CFRelease(v12);
        }
      }
    }
    if (CFArrayGetCount(*(CFArrayRef *)(v6 + 56)) >= 1)
    {
      CFIndex v14 = 0;
      do
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(*(void *)(a1 + 304) + 112) + 56), v14);
        if (!mmcs_get_container_contains_only_ford_elements((uint64_t)ValueAtIndex)) {
          send_request_downloadChunks_cold_5();
        }
        if (mmcs_container_get_primary_error((uint64_t)ValueAtIndex))
        {
          uint64_t v16 = ValueAtIndex[11];
          if (*(void *)(v16 + 48))
          {
            unint64_t v17 = 0;
            do
            {
              uint64_t v18 = *(void *)(v16 + 120);
              if (!mmcs_chunk_instance_is_ford((_DWORD *)(v18 + 104 * v17))) {
                send_request_downloadChunks_cold_11();
              }
              CFDictionaryRef Value = (const void **)CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 104), *(const void **)(v18 + 104 * v17 + 8));
              if (!Value) {
                send_request_downloadChunks_cold_12();
              }
              CFArrayRef items_array_for_item = (const __CFArray *)mmcs_get_req_context_get_items_array_for_item(a1, Value[1]);
              if (CFArrayGetCount(items_array_for_item) >= 1)
              {
                CFIndex v21 = 0;
                do
                {
                  CFNumberRef v22 = CFArrayGetValueAtIndex(items_array_for_item, v21);
                  CFStringRef v23 = CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 104), v22);
                  mmcs_get_state_fail_file_state((uint64_t)v23, (uint64_t)ValueAtIndex);
                  ++v21;
                }
                while (v21 < CFArrayGetCount(items_array_for_item));
              }
              ++v17;
              uint64_t v16 = ValueAtIndex[11];
            }
            while (v17 < *(void *)(v16 + 48));
          }
        }
        ++v14;
      }
      while (v14 < CFArrayGetCount(*(CFArrayRef *)(v6 + 56)));
    }
    if (CFArrayGetCount(*(CFArrayRef *)(v6 + 48)) >= 1)
    {
      CFIndex v24 = 0;
      do
      {
        CFStringRef v25 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v6 + 48), v24);
        if (!mmcs_get_container_contains_only_chunk_reference_elements((uint64_t)v25)) {
          send_request_downloadChunks_cold_6();
        }
        uint64_t v26 = v25[11];
        if (*(void *)(v26 + 48))
        {
          uint64_t v27 = 0;
          unint64_t v28 = 0;
          do
          {
            uint64_t v29 = *(void *)(v26 + 120) + v27;
            if (!mmcs_chunk_instance_is_chunk_reference((_DWORD *)v29)) {
              send_request_downloadChunks_cold_9();
            }
            if (!mmcs_chunk_reference_get_first_chunk_instance(*(void *)(v29 + 56)))
            {
              if (CFSetContainsValue(*(CFSetRef *)(v6 + 96), *(const void **)(v29 + 56)))
              {
                uint64_t v30 = *(void *)(v29 + 56);
                if (!*(void *)(v30 + 16) && **(char **)(v30 + 8) < 0) {
                  send_request_downloadChunks_cold_10();
                }
              }
            }
            ++v28;
            uint64_t v26 = v25[11];
            v27 += 104;
          }
          while (v28 < *(void *)(v26 + 48));
        }
        ++v24;
      }
      while (v24 < CFArrayGetCount(*(CFArrayRef *)(v6 + 48)));
    }
    CFStringRef v31 = *(const __CFString **)(*(void *)(a1 + 304) + 48);
    if (v31)
    {
      mmcs_get_cfindex_from_cftype_using_description(@"CacheDeleteAvailableSpaceClass", v31, 2);
      CFSetRef v32 = *(const __CFSet **)(*(void *)(a1 + 304) + 72);
      *(void *)int buf = 0;
      CFSetApplyFunction(v32, (CFSetApplierFunction)_mmcs_item_add_item_size, buf);
      unint64_t v33 = *(void *)buf;
      uint64_t v34 = mmcs_chunk_instance_offset(a1);
      CFStringRef v35 = mmcs_cache_delete_copy_mount_path_from_directory(*(const __CFURL **)(v34 + 128));
      unint64_t v36 = mmcs_cache_delete_get_available_bytes_from_mount_path();
      if (v35) {
        CFRelease(v35);
      }
      if (v33 > v36 || mmcs_get_request_is_insufficient_disk_space_mode(a1))
      {
        CFNumberRef v37 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 134218240;
          *(void *)&uint8_t buf[4] = v33;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v36;
          _os_log_impl(&dword_1DC1CA000, v37, OS_LOG_TYPE_ERROR, "Insufficent disk space, needed %lld but found %lld", buf, 0x16u);
        }
        if (a2) {
          *a2 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 48, @"Insufficent disk space, needed %lld but found %lld", v38, v39, v40, v41, v42, v33);
        }
        goto LABEL_8;
      }
    }
    if (*(void *)(v6 + 16))
    {
      uint64_t v43 = 0;
      unint64_t v44 = 0;
      do
      {
        uint64_t v45 = *(void *)(v6 + 32);
        if (!v45) {
          send_request_downloadChunks_cold_7();
        }
        uint64_t v46 = v45 + v43;
        uint64_t v47 = *(void *)(v45 + v43 + 8);
        if (!v47) {
          send_request_downloadChunks_cold_8();
        }
        if (mmcs_get_file_compute_remaining_work((uint64_t **)(v45 + v43)))
        {
          if (*v5) {
            goto LABEL_6;
          }
          if (mmcs_item_is_derivative(*(void *)(v46 + 8)))
          {
            CFSetApplyFunction(*(CFSetRef *)(v47 + 280), (CFSetApplierFunction)_decrement_outstanding_chunk_reference, (void *)v6);
            CFSetRemoveAllValues(*(CFMutableSetRef *)(v47 + 280));
          }
          else if (!mmcs_get_file_has_outstanding_chunks(v46))
          {
            mmcs_get_file_candidate_completed_with_success(v46);
          }
        }
        ++v44;
        v43 += 128;
      }
      while (v44 < *(void *)(v6 + 16));
    }
  }
  mmcs_engine_poll_for_preferences_update(*(void *)(a1 + 32));
  char v126 = *(unsigned char *)(*(void *)(a1 + 32) + 172);
  if (!v6 || (mmcs_get_file_omit_containers_not_needed(v6, &v126), !*(unsigned char *)(*(void *)(a1 + 32) + 172)) || !v126)
  {
    if (mmcs_request_setup_proxy_locator_for_containers(a1, *(CFArrayRef *)(v6 + 48)))
    {
      mmcs_proxy_locator_locate(*(void *)(a1 + 192));
LABEL_97:
      uint64_t v8 = 0;
      goto LABEL_9;
    }
    int v60 = *(unsigned __int8 *)(a1 + 72);
    CFStringRef v61 = mmcs_logging_logger_default();
    if (v60)
    {
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v62 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"couldn't create proxy locator");
        uint64_t v63 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_94;
        }
        *(_DWORD *)int buf = 138543362;
        *(void *)&uint8_t buf[4] = v62;
        CFStringRef v64 = v63;
        os_log_type_t v65 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_93;
      }
    }
    else if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v62 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"not using proxy locator");
      id v86 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_94;
      }
      *(_DWORD *)int buf = 138543362;
      *(void *)&uint8_t buf[4] = v62;
      CFStringRef v64 = v86;
      os_log_type_t v65 = OS_LOG_TYPE_DEBUG;
LABEL_93:
      _os_log_impl(&dword_1DC1CA000, v64, v65, "%{public}@", buf, 0xCu);
LABEL_94:
      if (v62) {
        CFRelease(v62);
      }
    }
    scheduleGetChunkAndDerivativeContainers((void *)a1);
    goto LABEL_97;
  }
  uint64_t v48 = mmcs_request_get_request_activity_marker(a1);
  uint64_t v49 = _os_activity_create(&dword_1DC1CA000, "mmcs-auth-get-for-chunks", v48, OS_ACTIVITY_FLAG_DEFAULT);
  v130.opaque[0] = 0;
  v130.opaque[1] = 0;
  os_activity_scope_enter(v49, &v130);
  __int16 v55 = *(uint64_t **)(a1 + 32);
  if (a2) {
    *a2 = 0;
  }
  if (*v5)
  {
    CFTypeRef error = *(void **)(a1 + 152);
    if (error)
    {
      CFRetain(error);
      CFDataRef v57 = 0;
      CFURLRef v58 = 0;
      uint64_t v59 = 0;
LABEL_146:
      if (a2)
      {
        CFRetain(error);
        *a2 = (CFErrorRef)error;
      }
      if (error) {
        CFRelease(error);
      }
      uint64_t v8 = 0xFFFFFFFFLL;
      goto LABEL_151;
    }
    CFDataRef v57 = 0;
    CFURLRef v58 = 0;
    uint64_t v59 = 0;
LABEL_145:
    CFTypeRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Unknown error in %s", v50, v51, v52, v53, v54, (char)"send_request_authorizeGetForChunks");
    goto LABEL_146;
  }
  CFSetRef v66 = *(const __CFSet **)(*(void *)(a1 + 304) + 88);
  if (!v66) {
    goto LABEL_161;
  }
  if (CFSetGetCount(v66) <= 0)
  {
    CFSetRef v87 = *(const __CFSet **)(*(void *)(a1 + 304) + 88);
    if (v87)
    {
      if (CFSetGetCount(v87) <= 0) {
        send_request_downloadChunks_cold_2();
      }
      CFTypeRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"No items for get chunks", v88, v89, v90, v91, v92, v125);
      uint64_t v59 = 0;
      CFURLRef v58 = 0;
      goto LABEL_143;
    }
LABEL_161:
    send_request_downloadChunks_cold_1();
  }
  CFAllocatorRef v67 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFURLRef v58 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFURLRef *)(a1 + 160), @"authorizeGet", 0);
  if (!v58)
  {
    CFTypeRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Unable to create URL %s", v68, v69, v70, v71, v72, (char)"send_request_authorizeGetForChunks");
    uint64_t v59 = 0;
LABEL_143:
    CFDataRef v57 = 0;
LABEL_144:
    if (error) {
      goto LABEL_146;
    }
    goto LABEL_145;
  }
  CFDataRef v73 = AuthorizeGetBodyCreate(a1, 0);
  CFDataRef v57 = v73;
  if (!v73)
  {
    CFErrorRef v93 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Unable to create body %s", v74, v75, v76, v77, v78, (char)"send_request_authorizeGetForChunks");
LABEL_110:
    CFTypeRef error = v93;
    uint64_t v59 = 0;
    goto LABEL_144;
  }
  CFIndex Length = CFDataGetLength(v73);
  CFStringRef v80 = (const __CFString *)v55[8];
  CFStringRef v81 = (const __CFString *)v55[10];
  CFStringRef dataclass = (const __CFString *)mmcs_request_get_dataclass(a1);
  http_protobuf_message = create_http_protobuf_message(v80, v81, dataclass, *(const __CFString **)(a1 + 168), *(const __CFString **)(a1 + 176), v58, v57);
  if (!http_protobuf_message)
  {
    v94 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v100 = CFStringCreateWithFormat(v67, 0, @"unable to create auth get chunks msg");
      uint64_t v101 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 138543362;
        *(void *)&uint8_t buf[4] = v100;
        _os_log_impl(&dword_1DC1CA000, v101, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v100) {
        CFRelease(v100);
      }
    }
    CFErrorRef v93 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Unable to create message %s", v95, v96, v97, v98, v99, (char)"send_request_authorizeGetForChunks");
    goto LABEL_110;
  }
  uint64_t v59 = http_protobuf_message;
  CFRelease(v57);
  mmcs_request_insert_headers(a1, v59);
  uint64_t v84 = *(void *)(a1 + 304);
  CFIndex v85 = Length;
  if (*(unsigned char *)(v84 + 10))
  {
    CFHTTPMessageSetHeaderFieldValue(v59, @"x-apple-mmcs-authorize-individual-files", @"T");
    uint64_t v84 = *(void *)(a1 + 304);
  }
  if (!*(void *)(v84 + 168))
  {
LABEL_117:
    send_request_downloadChunks_cold_3(v67);
    goto LABEL_118;
  }
  unint64_t v102 = 0;
  uint64_t v103 = 176;
  while (1)
  {
    unsigned int chunks = mmcs_item_needs_auth_get_chunks(v84 + v103);
    uint64_t v84 = *(void *)(a1 + 304);
    if (chunks) {
      break;
    }
    ++v102;
    v103 += 416;
    if (v102 >= *(void *)(v84 + 168)) {
      goto LABEL_117;
    }
  }
  if (!mmcs_http_msg_add_item_token_header(v59, (uint64_t *)(v84 + v103), 0, 0)) {
LABEL_118:
  }
    send_request_downloadChunks_cold_4(v67);
  long long v147 = 0u;
  long long v146 = 0u;
  *(void *)int buf = @"authorizeGetForChunks";
  *(void *)&uint8_t buf[8] = v59;
  *(void *)&buf[16] = *(void *)(a1 + 56);
  uint64_t v134 = *(void *)(a1 + 96);
  uint64_t v135 = 0;
  uint64_t v136 = -1;
  v148 = 0;
  uint64_t v138 = 0;
  uint64_t v139 = 0;
  CFIndex v137 = v85;
  v140 = mmcs_get_req_context_will_retry_auth_get_chunks_after_error;
  v141 = handle_response_authorizeGetForChunks;
  uint64_t v142 = 0;
  uint64_t v143 = 0;
  uint64_t v144 = 0;
  uint64_t v145 = a1;
  *(void *)&long long v146 = mmcs_engine_get_sparse_block_size();
  *((void *)&v146 + 1) = mmcs_engine_owner((uint64_t)v55);
  LOBYTE(v147) = 0;
  *((void *)&v147 + 1) = 0;
  v148 = v49;
  memset(v129, 0, sizeof(v129));
  mmcs_read_stream_pool_parameters_make_pool_timeout_max(v55[4], 100, (uint64_t)v129, 90.0);
  if (!mmcs_http_context_create((void *)(*(void *)(a1 + 304) + 136), *(_DWORD *)(a1 + 140), (uint64_t)buf))
  {
    CFIndex v107 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v113 = CFStringCreateWithFormat(v67, 0, @"unable to create http context");
      v114 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v131 = 138543362;
        CFStringRef v132 = v113;
        _os_log_impl(&dword_1DC1CA000, v114, OS_LOG_TYPE_ERROR, "%{public}@", v131, 0xCu);
      }
      if (v113) {
        CFRelease(v113);
      }
    }
    CFErrorRef v115 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Unable to create http %s", v108, v109, v110, v111, v112, (char)"send_request_authorizeGetForChunks");
    goto LABEL_142;
  }
  if (*(void *)(a1 + 184))
  {
    mmcs_http_context_make_metrics(*(char **)(*(void *)(a1 + 304) + 136), @"authGetChunks", 0, *(void *)(a1 + 56), 0);
    v105 = *(__CFArray **)(a1 + 184);
    uint64_t metrics = (void *)mmcs_http_context_get_metrics(*(void *)(*(void *)(a1 + 304) + 136));
    mmcs_metrics_request_add_http_info_for_auth(v105, metrics);
  }
  mmcs_http_context_update_voucher(*(void *)(*(void *)(a1 + 304) + 136));
  mmcs_http_context_uuid_hash_code(*(void *)(*(void *)(a1 + 304) + 136));
  kdebug_trace();
  if (!mmcs_http_context_send(*(void *)(*(void *)(a1 + 304) + 136), (uint64_t)v129, v55[7]))
  {
    unint64_t v116 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v122 = CFStringCreateWithFormat(v67, 0, @"unable to send http msg");
      v123 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v131 = 138543362;
        CFStringRef v132 = v122;
        _os_log_impl(&dword_1DC1CA000, v123, OS_LOG_TYPE_ERROR, "%{public}@", v131, 0xCu);
      }
      if (v122) {
        CFRelease(v122);
      }
    }
    uint64_t v124 = *(void *)(*(void *)(a1 + 304) + 128);
    if (v124 && mmcs_http_context_get_error(v124))
    {
      CFTypeRef error = (void *)mmcs_http_context_get_error(*(void *)(*(void *)(a1 + 304) + 128));
      CFRetain(error);
      goto LABEL_143;
    }
    CFErrorRef v115 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Unable to send http context for auth get request message", v117, v118, v119, v120, v121, v125);
LABEL_142:
    CFTypeRef error = v115;
    goto LABEL_143;
  }
  uint64_t v8 = 0;
  CFDataRef v57 = 0;
LABEL_151:
  if (v59) {
    CFRelease(v59);
  }
  if (v57) {
    CFRelease(v57);
  }
  if (v58) {
    CFRelease(v58);
  }
  if (v49) {
    os_release(v49);
  }
  os_activity_scope_leave(&v130);
LABEL_9:
  os_activity_scope_leave(&state);
  return v8;
}

uint64_t handle_callback_downloadContainer(uint64_t a1, const UInt8 *a2, CFIndex a3, CFErrorRef *a4)
{
  if (a4)
  {
    *a4 = 0;
    if (!mmcs_http_context_has_http_status(a1))
    {
      uint64_t v8 = *(void *)(mmcs_http_context_get_user_data(a1) + 64);
      if (v8)
      {
        CFStringRef container_copy_simple_description = mmcs_get_container_copy_simple_description(v8);
        if (a1)
        {
          request_message = (__CFHTTPMessage *)mmcs_http_context_get_request_message(a1);
          response_message = (__CFHTTPMessage *)mmcs_http_context_get_response_message(a1);
          goto LABEL_20;
        }
      }
      else
      {
        CFStringRef container_copy_simple_description = 0;
      }
      request_message = 0;
      response_message = 0;
LABEL_20:
      *a4 = mmcs_cferror_create_with_request_response_and_format(@"com.apple.mmcs", 1, request_message, response_message, 0, @"Context %p while downloading container %@ does not have a status", v9, v10, a1);
      if (container_copy_simple_description) {
        CFRelease(container_copy_simple_description);
      }
      return 0;
    }
  }
  else
  {
    uint64_t result = mmcs_http_context_has_http_status(a1);
    if (!result) {
      return result;
    }
  }
  if ((unint64_t)(mmcs_http_context_http_status(a1) - 300) > 0xFFFFFFFFFFFFFF9BLL)
  {
    uint64_t user_data = mmcs_http_context_get_user_data(a1);
    uint64_t v16 = *(uint64_t **)(*(void *)(user_data + 64) + 88);
    unint64_t v17 = (uint64_t *)*v16;
    if (!*v16) {
      handle_callback_downloadContainer_cold_1();
    }
    uint64_t v18 = user_data;
    if (!*v17 || mmcs_request_is_cancelled(*v17)) {
      handle_callback_downloadContainer_cold_2();
    }
    uint64_t result = mmcs_get_state_process_container_data(*v16, v18);
    if (a4 && !result)
    {
      if (!*a4)
      {
        CFErrorRef v24 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 11, @"There was an unspecified error processing data from container %s", v19, v20, v21, v22, v23, v16[2]);
        uint64_t result = 0;
        *a4 = v24;
        return result;
      }
      return 0;
    }
  }
  else
  {
    if (a3 >= 1) {
      mmcs_http_write_response_body(a1, a2, a3);
    }
    return 1;
  }
  return result;
}

uint64_t handle_container_request_will_retry_after_error(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t result = mmcs_http_context_get_user_data(a1);
  if (a3)
  {
    uint64_t v5 = result;
    if (result)
    {
      uint64_t v6 = *(void **)(result + 64);
      if (v6)
      {
        mmcs_container_set_error(*(void **)(result + 64), a3);
        return mmcs_get_container_will_retry(v6, v5);
      }
    }
  }
  return result;
}

uint64_t mmcs_get_req_is_using_itemid(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 304);
  if (*(void *)(v2 + 168))
  {
    unint64_t v3 = 0;
    int v4 = *(unsigned __int8 *)(a2 + 8);
    uint64_t v5 = 348;
    do
    {
      if (v4) {
        break;
      }
      if (*(void *)(v2 + v5 - 132) == *(void *)a2 && *(_DWORD *)(v2 + v5) != 5)
      {
        int v4 = 1;
        *(unsigned char *)(a2 + 8) = 1;
        uint64_t v2 = *(void *)(result + 304);
      }
      else
      {
        int v4 = 0;
      }
      ++v3;
      v5 += 416;
    }
    while (v3 < *(void *)(v2 + 168));
  }
  return result;
}

uint64_t mmcs_get_items(uint64_t a1, uint64_t a2, const __CFDictionary *a3, const void *a4, const char *a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, CFErrorRef *a10)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  unint64_t v17 = _os_activity_create(&dword_1DC1CA000, "mmcs-get-items", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v17, &state);
  CFTypeRef v89 = 0;
  if (a10) {
    *a10 = 0;
  }
  uint64_t v18 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_get_items called for %llu items", a6);
    uint64_t v20 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 138543362;
      CFStringRef v92 = v19;
      _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v19) {
      CFRelease(v19);
    }
  }
  if (a3) {
    BOOL v21 = CFDictionaryContainsKey(a3, @"kMMCSRequestOptionPreauthorization") != 0;
  }
  else {
    BOOL v21 = 0;
  }
  if (a9) {
    char v22 = 1;
  }
  else {
    char v22 = v21;
  }
  if (a1 && a4 && a5 && a7 && a8 && (v22 & 1) != 0)
  {
    if ((int)a6 < 1) {
      BOOL v21 = 1;
    }
    if (!v21)
    {
      uint64_t v23 = 0;
      while (*(void *)(a9 + 8 * v23))
      {
        if (a6 == ++v23) {
          goto LABEL_26;
        }
      }
      CFStringRef v35 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v41 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Missing auth token for item at index %d.", v23);
        uint64_t v42 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v92 = v41;
          _os_log_impl(&dword_1DC1CA000, v42, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v41) {
          CFRelease(v41);
        }
      }
      uint64_t v27 = a10;
      if (a10)
      {
        CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 35, @"Missing auth token for item at index %d.", v36, v37, v38, v39, v40, v23);
        goto LABEL_42;
      }
      goto LABEL_111;
    }
LABEL_26:
    if (*(unsigned char *)(a1 + 120))
    {
      CFErrorRef v24 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Engine is already closed.");
        uint64_t v26 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v92 = v25;
          _os_log_impl(&dword_1DC1CA000, v26, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v25) {
          CFRelease(v25);
        }
      }
      uint64_t v27 = a10;
      if (a10)
      {
        unint64_t v28 = @"Engine is already closed.";
LABEL_41:
        CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 35, v28);
LABEL_42:
        uint64_t v33 = 0;
        CFErrorRef *v27 = error;
        goto LABEL_112;
      }
      goto LABEL_111;
    }
    if (!mmcs_get_req_create(&v89, a1, a2, a3, a4, a5, 0, 0, a6, (uint64_t)a7, a8, a9, 0, 0, v17, a10))
    {
      uint64_t v43 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v44 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to create authGet request");
        uint64_t v45 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v92 = v44;
          _os_log_impl(&dword_1DC1CA000, v45, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v44) {
          CFRelease(v44);
        }
      }
      uint64_t v27 = a10;
      if (a10 && !*a10)
      {
        unint64_t v28 = @"Failed to create authGet request.";
        goto LABEL_41;
      }
      goto LABEL_111;
    }
    if (!v89) {
      mmcs_get_items_cold_1();
    }
    uint64_t v34 = a10;
    if (a6)
    {
      while (!mmcs_engine_has_request_using_itemid(a1, *a7))
      {
        ++a7;
        if (!--a6) {
          goto LABEL_77;
        }
      }
      uint64_t v46 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v52 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Item %lld is being used by another request.", *a7);
        uint64_t v53 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v92 = v52;
          _os_log_impl(&dword_1DC1CA000, v53, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        uint64_t v34 = a10;
        if (v52) {
          CFRelease(v52);
        }
      }
      CFErrorRef v54 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 35, @"Item %lld is being used by another request.", v47, v48, v49, v50, v51, *a7);
      if (v54)
      {
        CFErrorRef v55 = v54;
        uint64_t v56 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v57 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Item %lld is already being used by another request.", *a7);
          CFURLRef v58 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 138543362;
            CFStringRef v92 = v57;
            _os_log_impl(&dword_1DC1CA000, v58, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          uint64_t v34 = a10;
          if (v57) {
            CFRelease(v57);
          }
        }
        if (v34)
        {
          *uint64_t v34 = v55;
          goto LABEL_111;
        }
        uint64_t v79 = v55;
LABEL_110:
        CFRelease(v79);
        goto LABEL_111;
      }
    }
LABEL_77:
    mmcs_engine_add_request(a1, v89);
    mmcs_metrics_request_started(*((void *)v89 + 23), *(void *)(*((void *)v89 + 38) + 168));
    uint64_t v59 = voucher_copy();
    int v60 = v89;
    *((void *)v89 + 28) = v59;
    CFTypeRef cf = 0;
    if (v60[144])
    {
      CFStringRef v61 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v62 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Request cancelled.");
        uint64_t v63 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v92 = v62;
          _os_log_impl(&dword_1DC1CA000, v63, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        uint64_t v34 = a10;
        if (v62) {
          CFRelease(v62);
        }
      }
      if (v34)
      {
        CFRetain(*((CFTypeRef *)v89 + 19));
        *uint64_t v34 = (CFErrorRef)*((void *)v89 + 19);
      }
      goto LABEL_111;
    }
    if (CFSetGetCount(*(CFSetRef *)(*((void *)v60 + 38) + 80)) <= 0)
    {
      uint64_t v71 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v77 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"No items in the get request.");
        uint64_t v78 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 138543362;
          CFStringRef v92 = v77;
          _os_log_impl(&dword_1DC1CA000, v78, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        uint64_t v34 = a10;
        if (v77) {
          CFRelease(v77);
        }
      }
      if (!v34) {
        goto LABEL_111;
      }
      uint64_t v79 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 35, @"There were no items in the get request", v72, v73, v74, v75, v76, v86);
      goto LABEL_108;
    }
    if (*((void *)v89 + 33))
    {
      CFTypeID v64 = CFGetTypeID(*((CFTypeRef *)v89 + 33));
      if (v64 == CFDataGetTypeID())
      {
        int v65 = process_authorization_data((uint64_t)v89, *((void **)v89 + 33), &cf);
        uint64_t v34 = a10;
      }
      else
      {
        CFTypeID v80 = CFGetTypeID(*((CFTypeRef *)v89 + 33));
        BOOL v81 = v80 == CFArrayGetTypeID();
        uint64_t v34 = a10;
        if (!v81) {
          goto LABEL_103;
        }
        int v65 = process_authorization_array((uint64_t)v89, *((CFArrayRef *)v89 + 33), &cf);
      }
    }
    else
    {
      int v65 = send_request_authorizeGetForFiles((uint64_t)v89, &cf);
    }
    if (v65)
    {
      uint64_t v33 = 1;
      goto LABEL_112;
    }
LABEL_103:
    if (!cf) {
      CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed to start get request", v66, v67, v68, v69, v70, v86);
    }
    v82 = mmcs_logging_logger_default();
    XCFPrint(v82, @"AuthorizeGetForFiles Send Error", (void *)cf);
    CFStringRef v83 = v89;
    uint64_t v84 = *((void *)v89 + 38);
    if (*(unsigned char *)(v84 + 41)) {
      *(unsigned char *)(v84 + 41) = 0;
    }
    mmcs_metrics_request_set_error(v83[23], cf);
    mmcs_get_req_context_cleanup((uint64_t)v89, (uint64_t)cf);
    uint64_t v79 = (void *)cf;
    if (!v34)
    {
      if (!cf) {
        goto LABEL_111;
      }
      goto LABEL_110;
    }
LABEL_108:
    *uint64_t v34 = (CFErrorRef)v79;
    goto LABEL_111;
  }
  uint64_t v29 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v30 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Missing required parameters");
    CFStringRef v31 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 138543362;
      CFStringRef v92 = v30;
      _os_log_impl(&dword_1DC1CA000, v31, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v30) {
      CFRelease(v30);
    }
  }
  uint64_t v27 = a10;
  if (a10)
  {
    unint64_t v28 = @"Missing required parameters.";
    goto LABEL_41;
  }
LABEL_111:
  uint64_t v33 = 0;
LABEL_112:
  if (v89) {
    CFRelease(v89);
  }
  CFTypeRef v89 = 0;
  if (v17) {
    os_release(v17);
  }
  os_activity_scope_leave(&state);
  return v33;
}

uint64_t process_authorization_data(uint64_t a1, void *a2, CFTypeRef *a3)
{
  values[1] = *(void **)MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  values[0] = a2;
  CFArrayRef v5 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 1, MEMORY[0x1E4F1D510]);
  if (v5)
  {
    CFArrayRef v6 = v5;
    uint64_t v7 = process_authorization_array(a1, v5, &cf);
    CFRelease(v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  if (!a3 || v7)
  {
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    *a3 = cf;
  }
  return v7;
}

uint64_t process_authorization_array(uint64_t a1, CFArrayRef theArray, void *a3)
{
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (a3) {
    *a3 = 0;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    unint64_t v11 = 0;
    goto LABEL_14;
  }
  CFIndex v7 = Count;
  CFIndex v8 = 0;
  unsigned int v9 = 0;
  int v10 = 0;
  unint64_t v11 = 0;
  do
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v8);
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID != CFGetTypeID(ValueAtIndex))
    {
      uint64_t v66 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v72 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Expected CFDataRef type");
        uint64_t v73 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v72;
          _os_log_impl(&dword_1DC1CA000, v73, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v72) {
          CFRelease(v72);
        }
      }
      CFStringRef v74 = @"Expected CFDataRef type";
      goto LABEL_75;
    }
    CFIndex Length = CFDataGetLength((CFDataRef)ValueAtIndex);
    BytePtr = (char *)CFDataGetBytePtr((CFDataRef)ValueAtIndex);
    uint64_t v16 = chunkserver__file_groups__unpack(0, Length, BytePtr);
    if (!v16)
    {
      uint64_t v75 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v76 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Malformed response body");
        CFStringRef v77 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v76;
          _os_log_impl(&dword_1DC1CA000, v77, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v76) {
          CFRelease(v76);
        }
      }
      CFStringRef v74 = @"Malformed response body";
LABEL_75:
      uint64_t v65 = 0;
      CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, v74, v67, v68, v69, v70, v71, v105);
      goto LABEL_124;
    }
    unint64_t v17 = v16;
    uint64_t v18 = file_groups_message_file_count((uint64_t)v16);
    if (*((_DWORD *)v17 + 18) && v9 <= *((_DWORD *)v17 + 19)) {
      unsigned int v9 = *((_DWORD *)v17 + 19);
    }
    v11 += v18;
    v10 |= *((_DWORD *)v17 + 18);
    chunkserver__file_groups__free_unpacked((void **)v17, 0);
    ++v8;
  }
  while (v7 != v8);
  if (v10) {
    mmcs_request_set_reporting_level(a1, v9);
  }
LABEL_14:
  *(unsigned char *)(*(void *)(a1 + 304) + 41) = mmcs_get_req_context_wants_getComplete(a1);
  CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFSetRef MutableCopy = CFSetCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, *(CFSetRef *)(*(void *)(a1 + 304) + 80));
  if (v11 < CFSetGetCount(MutableCopy))
  {
    BOOL v21 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v22 = CFStringCreateWithFormat(v19, 0, @"not able to get containers for all files");
      uint64_t v23 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v22;
        _os_log_impl(&dword_1DC1CA000, v23, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v22) {
        CFRelease(v22);
      }
    }
  }
  if (!mmcs_get_state_create((void *)(*(void *)(a1 + 304) + 112), a1, *(void *)(*(void *)(a1 + 304) + 168)))
  {
    CFStringRef v57 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v63 = CFStringCreateWithFormat(v19, 0, @"mmcs_get_state_create");
      CFTypeID v64 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v63;
        _os_log_impl(&dword_1DC1CA000, v64, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v63) {
        CFRelease(v63);
      }
    }
    uint64_t v65 = 0;
    uint64_t v33 = 0;
    CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"mmcs_get_state_create", v58, v59, v60, v61, v62, v105);
    int v34 = 1;
    goto LABEL_118;
  }
  CFErrorRef v24 = CFSetCreateMutableCopy(v19, 0, MutableCopy);
  CFIndex v25 = CFArrayGetCount(theArray);
  if (v25 >= 1)
  {
    CFIndex v26 = v25;
    CFIndex v27 = 0;
    while (1)
    {
      unint64_t v28 = CFArrayGetValueAtIndex(theArray, v27);
      CFTypeID v29 = CFDataGetTypeID();
      if (v29 != CFGetTypeID(v28)) {
        break;
      }
      CFIndex v30 = CFDataGetLength((CFDataRef)v28);
      CFStringRef v31 = (char *)CFDataGetBytePtr((CFDataRef)v28);
      CFSetRef v32 = (void **)chunkserver__file_groups__unpack(0, v30, v31);
      if (!v32)
      {
        uint64_t v90 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v91 = CFStringCreateWithFormat(v19, 0, @"Malformed response body");
          CFStringRef v92 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = v91;
            _os_log_impl(&dword_1DC1CA000, v92, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (v91) {
            CFRelease(v91);
          }
        }
        CFStringRef v89 = @"Malformed response body";
LABEL_92:
        uint64_t v33 = 0;
        uint64_t v65 = 0;
        CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, v89, v82, v83, v84, v85, v86, v105);
        goto LABEL_93;
      }
      uint64_t v33 = v32;
      int v34 = 1;
      if (!mmcs_get_req_process_another_file_groups_message(a1, v24, (uint64_t)v32, 1, &cf))
      {
        uint64_t v65 = 0;
        goto LABEL_116;
      }
      chunkserver__file_groups__free_unpacked(v33, 0);
      if (v26 == ++v27) {
        goto LABEL_27;
      }
    }
    BOOL v81 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v87 = CFStringCreateWithFormat(v19, 0, @"Expected CFDataRef type");
      uint64_t v88 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v87;
        _os_log_impl(&dword_1DC1CA000, v88, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v87) {
        CFRelease(v87);
      }
    }
    CFStringRef v89 = @"Expected CFDataRef type";
    goto LABEL_92;
  }
LABEL_27:
  uint64_t v40 = *(void *)(*(void *)(a1 + 304) + 112);
  if (*(void *)(v40 + 16))
  {
    unint64_t v41 = 0;
    uint64_t v42 = 8;
    do
    {
      CFSetRemoveValue(v24, *(const void **)(*(void *)(v40 + 32) + v42));
      ++v41;
      uint64_t v40 = *(void *)(*(void *)(a1 + 304) + 112);
      v42 += 128;
    }
    while (v41 < *(void *)(v40 + 16));
  }
  if (CFSetGetCount(v24) >= 1)
  {
    CFStringRef v43 = CFCopyDescription(v24);
    CFStringRef v44 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      LOBYTE(v105) = (_BYTE)v43;
      CFStringRef v45 = CFStringCreateWithFormat(v19, 0, @"The server did not reply about the following items but should have: %@");
      uint64_t v46 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v45;
        _os_log_impl(&dword_1DC1CA000, v46, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v45) {
        CFRelease(v45);
      }
    }
    if (v43) {
      CFRelease(v43);
    }
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 8, @"Item not found on the server");
    mmcs_get_item_progress_make_done_error((uint64_t)error, &v106);
    mmcs_get_request_set_progress_and_notify_items_like_items_in_set(a1, v24, &v106);
    if (error) {
      CFRelease(error);
    }
  }
  CFSetApplyFunction(*(CFSetRef *)(*(void *)(a1 + 304) + 72), (CFSetApplierFunction)_mmcs_item_setup_metadata_only, *(void **)(*(void *)(a1 + 304) + 112));
  if (gMMCS_DebugLevel >= 5)
  {
    uint64_t v48 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v105 = *(void *)(*(void *)(*(void *)(a1 + 304) + 112) + 88);
      CFStringRef v49 = CFStringCreateWithFormat(v19, 0, @"populated counts dictionary: %@");
      uint64_t v50 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v49;
        _os_log_impl(&dword_1DC1CA000, v50, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v49) {
        CFRelease(v49);
      }
    }
  }
  uint64_t v51 = *(void *)(*(void *)(a1 + 304) + 112);
  if (v51 && *(void *)(v51 + 16))
  {
    unint64_t v52 = 0;
    uint64_t v53 = 8;
    do
    {
      uint64_t v54 = *(void *)(v51 + 32);
      if (!v54) {
        process_authorization_array_cold_2();
      }
      uint64_t v55 = *(void *)(v54 + v53);
      if (!v55) {
        process_authorization_array_cold_3();
      }
      if (mmcs_item_is_metadata_only(*(void *)(v54 + v53)) && !*(unsigned char *)(v55 + 104)) {
        mmcs_get_file_complete_metadata_only_file(v54 + v53 - 8);
      }
      ++v52;
      v53 += 128;
    }
    while (v52 < *(void *)(v51 + 16));
  }
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  os_activity_scope_enter(request_activity_marker, &state);
  CFTypeRef cf = 0;
  if (*(unsigned char *)(a1 + 144))
  {
    CFTypeRef cf = *(CFTypeRef *)(a1 + 152);
    CFRetain(cf);
    os_activity_scope_leave(&state);
LABEL_115:
    uint64_t v33 = 0;
    int v34 = 0;
    uint64_t v65 = 1;
    goto LABEL_116;
  }
  uint64_t v78 = *(void *)(*(void *)(a1 + 304) + 112);
  if (!v78) {
    process_authorization_array_cold_1();
  }
  if (!CFArrayGetCount(*(CFArrayRef *)(v78 + 56)))
  {
    int v80 = send_request_downloadChunks(a1, (CFErrorRef *)&cf);
    goto LABEL_114;
  }
  v109.opaque[0] = 0;
  v109.opaque[1] = 0;
  uint64_t v79 = mmcs_request_get_request_activity_marker(a1);
  os_activity_scope_enter(v79, &v109);
  CFTypeRef cf = 0;
  if (*(unsigned char *)(a1 + 144))
  {
    CFTypeRef cf = *(CFTypeRef *)(a1 + 152);
    CFRetain(cf);
    int v80 = -1;
    goto LABEL_113;
  }
  uint64_t v93 = *(void *)(*(void *)(a1 + 304) + 112);
  if (!mmcs_request_setup_proxy_locator_for_containers(a1, *(CFArrayRef *)(v93 + 56)))
  {
    int v94 = *(unsigned __int8 *)(a1 + 72);
    uint64_t v95 = mmcs_logging_logger_default();
    if (v94)
    {
      if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v96 = CFStringCreateWithFormat(v19, 0, @"couldn't create proxy locator");
        uint64_t v97 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_106;
        }
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v96;
        uint64_t v98 = v97;
        os_log_type_t v99 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_105;
      }
    }
    else if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v96 = CFStringCreateWithFormat(v19, 0, @"not using proxy locator");
      CFStringRef v100 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_106;
      }
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v96;
      uint64_t v98 = v100;
      os_log_type_t v99 = OS_LOG_TYPE_DEBUG;
LABEL_105:
      _os_log_impl(&dword_1DC1CA000, v98, v99, "%{public}@", (uint8_t *)&buf, 0xCu);
LABEL_106:
      if (v96) {
        CFRelease(v96);
      }
    }
    scheduleGetContainers((void *)a1, *(const __CFArray **)(v93 + 56));
    if (!mmcs_get_req_has_outstanding_asynchronous_work(a1))
    {
      uint64_t v101 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v101, OS_LOG_TYPE_INFO))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_1DC1CA000, v101, OS_LOG_TYPE_INFO, "Downloads complete. All done!", (uint8_t *)&buf, 2u);
      }
      mmcs_get_req_context_cleanup(a1, 0);
    }
    goto LABEL_112;
  }
  *(void *)&long long buf = MEMORY[0x1E4F143A8];
  *((void *)&buf + 1) = 0x40000000;
  uint64_t v111 = __send_request_downloadFord_block_invoke;
  uint64_t v112 = &__block_descriptor_tmp_270;
  uint64_t v113 = v93;
  uint64_t v114 = a1;
  mmcs_proxy_locator_locate(*(void *)(a1 + 192));
LABEL_112:
  int v80 = 0;
LABEL_113:
  os_activity_scope_leave(&v109);
LABEL_114:
  os_activity_scope_leave(&state);
  if (v80 != -1) {
    goto LABEL_115;
  }
  if (!cf) {
    CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed to check for local state", v35, v36, v37, v38, v39, v105);
  }
  CFStringRef v104 = mmcs_logging_logger_default();
  XCFPrint(v104, @"CheckForLocalStateIssue", (void *)cf);
  uint64_t v33 = 0;
  uint64_t v65 = 0;
LABEL_93:
  int v34 = 1;
LABEL_116:
  if (v24) {
    CFRelease(v24);
  }
LABEL_118:
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (v33)
  {
    chunkserver__file_groups__free_unpacked(v33, 0);
    if ((v34 & 1) == 0) {
      return v65;
    }
  }
  else if (!v34)
  {
    return v65;
  }
LABEL_124:
  unint64_t v102 = (void *)cf;
  if (a3)
  {
    if (!cf) {
      unint64_t v102 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Failed to process auth get response for files", v35, v36, v37, v38, v39, v105);
    }
    *a3 = v102;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v65;
}

uint64_t send_request_authorizeGetForFiles(uint64_t a1, void *a2)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  CFArrayRef v5 = _os_activity_create(&dword_1DC1CA000, "mmcs-auth-get-for-files", request_activity_marker, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v5, &state);
  CFArrayRef v6 = *(uint64_t **)(a1 + 32);
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFURLRef v13 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFURLRef *)(a1 + 160), @"authorizeGet", 0);
  if (!v13)
  {
    CFStringRef v30 = @"Unable to create auth get request url";
LABEL_12:
    CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, v30, v8, v9, v10, v11, v12, v60[0]);
    goto LABEL_13;
  }
  CFDataRef v14 = AuthorizeGetBodyCreate(a1, 1);
  if (!v14)
  {
    CFStringRef v30 = @"Unable to create auth get request body";
    goto LABEL_12;
  }
  CFDataRef v15 = v14;
  mmcs_get_item_progress_make_state(2, &v65);
  mmcs_get_request_set_progress_and_notify_all_items_not_done(a1, &v65);
  CFIndex Length = CFDataGetLength(v15);
  CFStringRef v17 = (const __CFString *)v6[8];
  CFStringRef v18 = (const __CFString *)v6[10];
  CFStringRef dataclass = (const __CFString *)mmcs_request_get_dataclass(a1);
  http_protobuf_message = (__CFString *)create_http_protobuf_message(v17, v18, dataclass, *(const __CFString **)(a1 + 168), *(const __CFString **)(a1 + 176), v13, v15);
  CFRelease(v15);
  if (*(unsigned char *)(a1 + 144))
  {
    CFRetain(*(CFTypeRef *)(a1 + 152));
    CFErrorRef error = *(const void **)(a1 + 152);
    CFIndex v27 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    CFStringRef v28 = CFStringCreateWithFormat(v7, 0, @"request was cancelled");
    CFTypeID v29 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      goto LABEL_8;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v68 = v28;
LABEL_7:
    _os_log_impl(&dword_1DC1CA000, v29, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
LABEL_8:
    if (v28) {
      CFRelease(v28);
    }
    goto LABEL_14;
  }
  if (!http_protobuf_message)
  {
    CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Unable to create auth get request message", v21, v22, v23, v24, v25, v60[0]);
    unint64_t v41 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      http_protobuf_message = (__CFString *)CFStringCreateWithFormat(v7, 0, @"unable to create auth get msg");
      uint64_t v42 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v68 = http_protobuf_message;
        _os_log_impl(&dword_1DC1CA000, v42, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (!http_protobuf_message) {
        goto LABEL_14;
      }
      CFRelease(http_protobuf_message);
    }
LABEL_13:
    http_protobuf_message = 0;
    goto LABEL_14;
  }
  mmcs_request_insert_headers(a1, http_protobuf_message);
  uint64_t v34 = *(void *)(a1 + 304);
  if (*(unsigned char *)(v34 + 10))
  {
    CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)http_protobuf_message, @"x-apple-mmcs-authorize-individual-files", @"T");
    uint64_t v34 = *(void *)(a1 + 304);
  }
  if (!mmcs_http_msg_add_items_token_header((__CFHTTPMessage *)http_protobuf_message, *(void *)(v34 + 168), v34 + 176, 0, 0))
  {
    CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Unable to add token header to auth get request message", v35, v36, v37, v38, v39, v60[0]);
    CFStringRef v43 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    CFStringRef v28 = CFStringCreateWithFormat(v7, 0, @"unable to add token header");
    CFTypeID v29 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
      goto LABEL_8;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v68 = v28;
    goto LABEL_7;
  }
  uint64_t v62 = 0;
  v61[0] = @"authorizeGetForFiles";
  v61[1] = http_protobuf_message;
  v61[2] = *(void *)(a1 + 56);
  v61[3] = *(void *)(a1 + 96);
  if (mmcs_request_is_background(a1)) {
    uint64_t v40 = *(void *)(a1 + 104);
  }
  else {
    uint64_t v40 = 0;
  }
  v61[4] = v40;
  v61[5] = -1;
  v61[6] = Length;
  v61[7] = 0;
  v61[8] = 0;
  v61[9] = mmcs_get_req_context_will_retry_auth_get_file_after_error;
  v61[10] = handle_response_authorizeGetForFiles;
  memset(&v61[11], 0, 24);
  v61[14] = a1;
  v61[15] = mmcs_engine_get_sparse_block_size();
  v61[16] = mmcs_engine_owner((uint64_t)v6);
  LOBYTE(v62) = 0;
  uint64_t v63 = 0;
  CFTypeID v64 = v5;
  memset(v60, 0, sizeof(v60));
  mmcs_read_stream_pool_parameters_make_pool_timeout_max(v6[4], 100, (uint64_t)v60, 90.0);
  if (mmcs_http_context_create((void *)(*(void *)(a1 + 304) + 128), *(_DWORD *)(a1 + 140), (uint64_t)v61))
  {
    if (*(void *)(a1 + 184))
    {
      mmcs_http_context_make_metrics(*(char **)(*(void *)(a1 + 304) + 128), @"authGet", 0, *(void *)(a1 + 56), 0);
      CFStringRef v44 = *(__CFArray **)(a1 + 184);
      uint64_t metrics = (void *)mmcs_http_context_get_metrics(*(void *)(*(void *)(a1 + 304) + 128));
      mmcs_metrics_request_add_http_info_for_auth(v44, metrics);
    }
    mmcs_http_context_update_voucher(*(void *)(*(void *)(a1 + 304) + 128));
    mmcs_http_context_uuid_hash_code(*(void *)(*(void *)(a1 + 304) + 128));
    kdebug_trace();
    if (mmcs_http_context_send(*(void *)(*(void *)(a1 + 304) + 128), (uint64_t)v60, v6[7]))
    {
      uint64_t v31 = 1;
LABEL_19:
      CFRelease(http_protobuf_message);
      uint64_t v32 = v31;
      goto LABEL_20;
    }
    uint64_t v56 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v57 = CFStringCreateWithFormat(v7, 0, @"unable to send http msg");
      uint64_t v58 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v68 = v57;
        _os_log_impl(&dword_1DC1CA000, v58, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v57) {
        CFRelease(v57);
      }
    }
    uint64_t v59 = *(void *)(*(void *)(a1 + 304) + 128);
    if (v59 && mmcs_http_context_get_error(v59))
    {
      CFErrorRef error = (const void *)mmcs_http_context_get_error(*(void *)(*(void *)(a1 + 304) + 128));
      CFRetain(error);
      goto LABEL_14;
    }
    CFStringRef v54 = @"Unable to send http context for auth get request message";
    CFIndex v55 = 1;
  }
  else
  {
    uint64_t v46 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v52 = CFStringCreateWithFormat(v7, 0, @"unable to create http context");
      uint64_t v53 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v68 = v52;
        _os_log_impl(&dword_1DC1CA000, v53, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v52) {
        CFRelease(v52);
      }
    }
    CFStringRef v54 = @"Unable to create http context for auth get request message";
    CFIndex v55 = 37;
  }
  CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", v55, v54, v47, v48, v49, v50, v51, v60[0]);
LABEL_14:
  if (error)
  {
    if (a2)
    {
      CFRetain(error);
      *a2 = error;
    }
    CFRelease(error);
  }
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  if (http_protobuf_message) {
    goto LABEL_19;
  }
LABEL_20:
  if (v13) {
    CFRelease(v13);
  }
  if (v5) {
    os_release(v5);
  }
  os_activity_scope_leave(&state);
  return v32;
}

void _decrement_outstanding_chunk_reference(const void *a1, CFMutableDictionaryRef *a2)
{
}

void __send_request_downloadChunks_block_invoke(uint64_t a1)
{
}

void scheduleGetChunkAndDerivativeContainers(void *a1)
{
  uint64_t v2 = *(void *)(a1[38] + 112);
  if (v2)
  {
    scheduleGetContainers(a1, *(const __CFArray **)(v2 + 64));
    scheduleGetContainers(a1, *(const __CFArray **)(v2 + 48));
  }
  else
  {
    mmcs_proxy_locator_finish(a1[24]);
  }
  if (!mmcs_get_req_has_outstanding_asynchronous_work((uint64_t)a1))
  {
    unint64_t v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int v4 = 0;
      _os_log_impl(&dword_1DC1CA000, v3, OS_LOG_TYPE_INFO, "Downloads complete. All done!", v4, 2u);
    }
    mmcs_get_req_context_cleanup((uint64_t)a1, 0);
  }
}

void _mmcs_item_setup_chunk_references(uint64_t a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!mmcs_item_is_metadata_only(a1))
  {
    mmcs_item_setup_chunk_references((void *)a1);
    double Current = CFAbsoluteTimeGetCurrent();
    CFSetApplyFunction(*(CFSetRef *)(a1 + 280), (CFSetApplierFunction)_mmcs_item_setup_chunk_references_still_outstanding, a2);
    if (gMMCS_DebugLevel >= 5)
    {
      CFArrayRef v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
        CFStringRef v8 = CFStringCreateWithFormat(v6, 0, @"constructing maintained structure took %.6fus", (v7 - Current) * 1000000.0);
        uint64_t v9 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v11 = v8;
          _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v8) {
          CFRelease(v8);
        }
      }
    }
    if (!mmcs_item_is_derivative(a1))
    {
      mmcs_item_setup_item_size(a1);
      mmcs_item_setup_item_padded_size(a1);
    }
  }
}

void _mmcs_item_setup_chunk_references_still_outstanding(void *value, CFDictionaryRef *a2)
{
  if (!CFSetContainsValue(*(CFSetRef *)(*((void *)*a2 + 38) + 104), value)) {
    _mmcs_item_setup_chunk_references_still_outstanding_cold_1();
  }
  valuea = (void *)1;
  if (CFDictionaryGetValueIfPresent(a2[11], value, (const void **)&valuea))
  {
    int v4 = (char *)valuea + 1;
    valuea = (char *)valuea + 1;
  }
  else
  {
    CFSetAddValue(a2[12], value);
    int v4 = (char *)valuea;
  }
  CFDictionarySetValue(a2[11], value, v4);
}

uint64_t _mmcs_item_add_item_size(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t result = mmcs_item_is_metadata_only(result);
    if (!result) {
      *a2 += *(void *)(v3 + 16);
    }
  }
  return result;
}

void mmcs_get_req_context_will_retry_auth_get_chunks_after_error(uint64_t a1, uint64_t a2, __CFError *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFArrayRef v5 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    CFStringRef v6 = mmcs_request_copy_description(a2);
    CFAbsoluteTime v7 = mmcs_cferror_copy_description(a3);
    CFStringRef v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ retry auth get chunk after error %@", v6, v7);
      uint64_t v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v12 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v6) {
      CFRelease(v6);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
}

void handle_response_authorizeGetForChunks(uint64_t a1, CFDataRef *a2, uint64_t a3)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  mmcs_http_context_uuid_hash_code(a1);
  kdebug_trace();
  if (!mmcs_http_context_is_connection_reused(a1)) {
    kdebug_trace();
  }
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  request_activity_marker = mmcs_request_get_request_activity_marker(a3);
  os_activity_scope_enter(request_activity_marker, &state);
  BOOL v7 = mmcs_http_context_status_succeeded(a1);
  if (!a2 || !v7 || !*a2)
  {
    uint64_t error = mmcs_http_context_get_error(a1);
    mmcs_get_req_context_cleanup(a3, error);
    goto LABEL_93;
  }
  CFStringRef v8 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    char Length = CFDataGetLength(*a2);
    CFStringRef v10 = CFStringCreateWithFormat(v9, 0, @"Got %ld bytes");
    CFStringRef v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v10) {
      CFRelease(v10);
    }
  }
  mmcs_http_context_validate_request_uuid_with_response(a1);
  http_clock_skew_metrics_with_http_CFSetRef context = mmcs_create_http_clock_skew_metrics_with_http_context(a1);
  if (http_clock_skew_metrics_with_http_context)
  {
    uint64_t v13 = http_clock_skew_metrics_with_http_context;
    mmcs_request_set_http_clock_skew_metrics(a3, http_clock_skew_metrics_with_http_context);
    CFRelease(v13);
  }
  CFIndex v14 = CFDataGetLength(*a2);
  BytePtr = (char *)CFDataGetBytePtr(*a2);
  uint64_t v16 = (void **)chunkserver__file_groups__unpack(0, v14, BytePtr);
  mmcs_http_context_cleanup_response(a1);
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = 0;
  if (v16)
  {
    CFTypeRef v75 = 0;
    CFTypeRef cf = 0;
    unint64_t v17 = file_groups_message_file_count((uint64_t)v16);
    uint64_t v18 = *(void *)(a3 + 304);
    CFSetRef v19 = *(const __CFSet **)(v18 + 88);
    if (v19)
    {
      if (v17 >= CFSetGetCount(*(CFSetRef *)(v18 + 88)))
      {
        CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      }
      else
      {
        uint64_t v20 = mmcs_logging_logger_default();
        BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
        CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        if (v21)
        {
          CFStringRef v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"not able to get containers for all files");
          uint64_t v24 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v23;
            _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
          }
          if (v23) {
            CFRelease(v23);
          }
        }
      }
      CFSetRef MutableCopy = CFSetCreateMutableCopy(v22, 0, v19);
      int req_process_another_file_groups_message = mmcs_get_req_process_another_file_groups_message(a3, MutableCopy, (uint64_t)v16, 0, &cf);
      BOOL v43 = req_process_another_file_groups_message == 0;
      if (!req_process_another_file_groups_message)
      {
        int v44 = 0;
        if (!MutableCopy) {
          goto LABEL_54;
        }
        goto LABEL_53;
      }
      uint64_t v47 = *(void *)(*(void *)(a3 + 304) + 112);
      if (*(void *)(v47 + 16))
      {
        unint64_t v48 = 0;
        uint64_t v49 = 8;
        do
        {
          CFSetRemoveValue(MutableCopy, *(const void **)(*(void *)(v47 + 32) + v49));
          ++v48;
          uint64_t v47 = *(void *)(*(void *)(a3 + 304) + 112);
          v49 += 128;
        }
        while (v48 < *(void *)(v47 + 16));
      }
      if (CFSetGetCount(MutableCopy) >= 1)
      {
        CFStringRef v50 = CFCopyDescription(MutableCopy);
        uint64_t v51 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          char Length = (char)v50;
          CFStringRef v52 = CFStringCreateWithFormat(v22, 0, @"The server did not reply about the following items but should have: %@");
          uint64_t v53 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v52;
            _os_log_impl(&dword_1DC1CA000, v53, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v52) {
            CFRelease(v52);
          }
        }
        if (v50) {
          CFRelease(v50);
        }
        CFErrorRef v54 = mmcs_cferror_create_error(@"com.apple.mmcs", 8, @"Item not found on the server");
        mmcs_get_item_progress_make_done_error((uint64_t)v54, buf);
        mmcs_get_request_set_progress_and_notify_items_like_items_in_set(a3, MutableCopy, (long long *)buf);
        if (v54) {
          CFRelease(v54);
        }
      }
      int v44 = 1;
      if (MutableCopy) {
LABEL_53:
      }
        CFRelease(MutableCopy);
    }
    else
    {
      uint64_t v35 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v41 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mrc->itemsWithDistinctSignaturesForGetChunks is NULL");
        uint64_t v42 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v41;
          _os_log_impl(&dword_1DC1CA000, v42, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v41) {
          CFRelease(v41);
        }
      }
      BOOL v43 = 1;
      int v44 = 0;
      CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"mrc->itemsWithDistinctSignaturesForGetChunks is NULL", v36, v37, v38, v39, v40, Length);
    }
LABEL_54:
    CFTypeRef v55 = cf;
    if (v43 && cf)
    {
      CFRetain(cf);
      CFTypeRef v55 = cf;
      CFTypeRef v75 = cf;
    }
    if (v55) {
      CFRelease(v55);
    }
    if (v44)
    {
      if (mmcs_request_setup_proxy_locator_for_containers(a3, *(CFArrayRef *)(*(void *)(*(void *)(a3 + 304) + 112) + 40)))
      {
        mmcs_proxy_locator_locate(*(void *)(a3 + 192));
LABEL_71:
        int v59 = 0;
        goto LABEL_76;
      }
      if (mmcs_get_req_schedule_new_containers(a3, &v75) != -1) {
        goto LABEL_71;
      }
      uint64_t v60 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v57 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to schedule new containers");
        uint64_t v58 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
LABEL_66:
          if (v57) {
            CFRelease(v57);
          }
          goto LABEL_75;
        }
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v57;
LABEL_65:
        _os_log_impl(&dword_1DC1CA000, v58, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        goto LABEL_66;
      }
    }
    else
    {
      uint64_t v56 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v57 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to process auth get response for chunks");
        uint64_t v58 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
          goto LABEL_66;
        }
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v57;
        goto LABEL_65;
      }
    }
LABEL_75:
    int v59 = 1;
LABEL_76:
    int v61 = *(unsigned __int8 *)(a3 + 72);
    uint64_t v62 = mmcs_logging_logger_default();
    if (v61)
    {
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v68 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"couldn't create proxy locator");
        uint64_t v69 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_84;
        }
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v68;
        uint64_t v70 = v69;
        os_log_type_t v71 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_83;
      }
    }
    else if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v68 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"not using proxy locator");
      CFStringRef v72 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_84;
      }
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v68;
      uint64_t v70 = v72;
      os_log_type_t v71 = OS_LOG_TYPE_DEBUG;
LABEL_83:
      _os_log_impl(&dword_1DC1CA000, v70, v71, "%{public}@", buf, 0xCu);
LABEL_84:
      if (v68) {
        CFRelease(v68);
      }
    }
    if (v59)
    {
      uint64_t v73 = v75;
      if (!v75)
      {
        uint64_t v73 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed handle_response_authorizeGetForChunks", v63, v64, v65, v66, v67, Length);
        CFTypeRef v75 = v73;
      }
      mmcs_get_req_context_cleanup(a3, (uint64_t)v73);
      if (v75) {
        CFRelease(v75);
      }
      CFTypeRef v75 = 0;
    }
    chunkserver__file_groups__free_unpacked(v16, 0);
    goto LABEL_93;
  }
  CFIndex v26 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v32 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Malformed response body");
    uint64_t v33 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v32;
      _os_log_impl(&dword_1DC1CA000, v33, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v32) {
      CFRelease(v32);
    }
  }
  CFErrorRef v34 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Malformed response body", v27, v28, v29, v30, v31, Length);
  mmcs_get_req_context_cleanup(a3, (uint64_t)v34);
  if (v34) {
    CFRelease(v34);
  }
LABEL_93:
  os_activity_scope_leave(&state);
}

void __handle_response_authorizeGetForChunks_block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (mmcs_get_req_schedule_new_containers(*(void *)(a1 + 32), &cf) == -1)
  {
    uint64_t v2 = mmcs_logging_logger_default();
    BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
    int v4 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (v3)
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to schedule new containers");
      CFStringRef v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v19 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
    mmcs_proxy_locator_finish(*(void *)(*(void *)(a1 + 32) + 192));
    CFStringRef v12 = cf;
    if (!cf)
    {
      CFStringRef v12 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed handle_response_authorizeGetForChunks", v7, v8, v9, v10, v11, v16);
      CFTypeRef cf = v12;
    }
    mmcs_get_req_context_cleanup(*(void *)(a1 + 32), (uint64_t)v12);
    uint64_t v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v14 = CFStringCreateWithFormat(*v4, 0, @"cleaned up get request because containers failed to schedule. mrc: %p", *(void *)(a1 + 32));
      CFDataRef v15 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v19 = v14;
        _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v14) {
        CFRelease(v14);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t mmcs_get_req_schedule_new_containers(uint64_t a1, void *a2)
{
  if (a2)
  {
    *a2 = 0;
    if (*(unsigned char *)(a1 + 144))
    {
      BOOL v3 = *(const void **)(a1 + 152);
      *a2 = v3;
      CFRetain(v3);
      return 0xFFFFFFFFLL;
    }
  }
  else if (*(unsigned char *)(a1 + 144))
  {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 304) + 112);
  if (v5) {
    mmcs_get_file_omit_containers_not_needed(v5, 0);
  }
  scheduleGetChunkAndDerivativeContainers((void *)a1);
  return 0;
}

uint64_t file_groups_message_file_count(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 24)) {
    return 0;
  }
  uint64_t v2 = 0;
  unint64_t v3 = 0;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8 * v3);
    if (!*(void *)(v5 + 40))
    {
      CFStringRef v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v7 = CFStringCreateWithFormat(v4, 0, @"No files to download");
        uint64_t v8 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v14 = v7;
          _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v7) {
          CFRelease(v7);
        }
      }
    }
    if (!*(void *)(v5 + 24))
    {
      uint64_t v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v10 = CFStringCreateWithFormat(v4, 0, @"No containers to download");
        uint64_t v11 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v14 = v10;
          _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v10) {
          CFRelease(v10);
        }
      }
    }
    v2 += *(void *)(v5 + 40);
    ++v3;
  }
  while (v3 < *(void *)(a1 + 24));
  return v2;
}

uint64_t mmcs_get_req_process_another_file_groups_message(uint64_t a1, __CFSet *a2, uint64_t a3, int a4, CFTypeRef *a5)
{
  uint64_t v5 = a3;
  uint64_t v124 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (*(void *)(a3 + 24))
  {
    unint64_t v9 = 0;
    int v10 = 1;
    do
    {
      if (!mmcs_get_state_process_file_list(*(void *)(*(void *)(a1 + 304) + 112), *(void **)(*(void *)(v5 + 32) + 8 * v9), a4, 1, &cf))
      {
        uint64_t v69 = 0;
        goto LABEL_114;
      }
      ++v9;
    }
    while (v9 < *(void *)(v5 + 24));
  }
  if (*(_DWORD *)(v5 + 80))
  {
    if (mmcs_get_req_get_opaque_clone_context(a1)) {
      mmcs_get_req_process_another_file_groups_message_cold_1();
    }
    CFDataRef Data = ProtobufCBinaryData_CreateData((CFDataRef)(v5 + 88));
    mmcs_get_req_set_opaque_clone_context(a1, Data);
    CFRelease(Data);
  }
  uint64_t v93 = a1;
  theSet = a2;
  uint64_t v91 = v5;
  CFTypeRef cf = 0;
  if (*(void *)(v5 + 40))
  {
    uint64_t v12 = 0;
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v14 = @"apple.mme";
    while (1)
    {
      uint64_t v15 = *(void *)(*(void *)(v5 + 48) + 8 * v12);
      if (!mmcs_file_signature_is_valid_n(*(void *)(v15 + 32), *(void *)(v15 + 24)))
      {
        uint64_t v70 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v76 = CFStringCreateWithFormat(v13, 0, @"Invalid file signature in FileGroup FileError file_checksum");
          CFStringRef v77 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
          {
            LODWORD(CFDictionaryAddValue(theDict, key, value) = 138543362;
            *(void *)((char *)&value + 4) = v76;
            _os_log_impl(&dword_1DC1CA000, v77, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&value, 0xCu);
          }
          if (v76) {
            CFRelease(v76);
          }
        }
        uint64_t v69 = 0;
        CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Invalid file signature in FileGroup FileError file_checksum", v71, v72, v73, v74, v75, v88);
        int v10 = 1;
        goto LABEL_114;
      }
      char v16 = mmcs_file_signature_to_hexstring(*(char **)(v15 + 32));
      uint64_t v17 = *(void *)(v15 + 40);
      CFStringRef v18 = CFStringCreateWithCString(v13, *(const char **)(v17 + 24), 0x8000100u);
      int v19 = *(_DWORD *)(v17 + 32);
      int v20 = CFEqual(v18, v14);
      BOOL v24 = v19 == 1 || v19 == 6;
      uint64_t v25 = 16;
      if (!v24) {
        uint64_t v25 = 8;
      }
      if (v20) {
        CFIndex v26 = v25;
      }
      else {
        CFIndex v26 = 8;
      }
      CFErrorRef error_with_error_response_and_format = mmcs_cferror_create_error_with_error_response_and_format(1, 0, v26, (__CFError *)v17, @"The server returned an error for signature %s", v21, v22, v23, (char)v16);
      if (*(_DWORD *)(v15 + 48)) {
        CFDataRef v28 = ProtobufCBinaryData_CreateData((CFDataRef)(v15 + 56));
      }
      else {
        CFDataRef v28 = 0;
      }
      long long v122 = 0u;
      long long v123 = 0u;
      long long v120 = 0u;
      long long v121 = 0u;
      long long v118 = 0u;
      long long v119 = 0u;
      long long v116 = 0u;
      long long v117 = 0u;
      long long v114 = 0u;
      long long v115 = 0u;
      long long v112 = 0u;
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      long long v108 = 0u;
      long long v109 = 0u;
      long long v106 = 0u;
      long long v107 = 0u;
      long long v104 = 0u;
      long long v105 = 0u;
      long long v102 = 0u;
      long long v103 = 0u;
      long long v100 = 0u;
      long long v101 = 0u;
      long long value = 0u;
      long long v99 = 0u;
      *(void *)&long long value = *(void *)(v15 + 32);
      *(void *)&long long v101 = v28;
      uint64_t v29 = CFSetGetValue(*(CFSetRef *)(*(void *)(a1 + 304) + 80), &value);
      if (v28) {
        CFRelease(v28);
      }
      if (v29) {
        break;
      }
      uint64_t v35 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        char v88 = (char)v16;
        CFStringRef v30 = CFStringCreateWithFormat(v13, 0, @"Server referenced an item in FileGroup FileError with signature %s which is not in itemsWithDistinctSignatures. This FileError will be ignored.");
        uint64_t v36 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v97 = v30;
          _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        goto LABEL_40;
      }
LABEL_42:
      if (v16) {
        free(v16);
      }
      if (error_with_error_response_and_format) {
        CFRelease(error_with_error_response_and_format);
      }
      if ((unint64_t)++v12 >= *(void *)(v5 + 40)) {
        goto LABEL_47;
      }
    }
    if (CFSetContainsValue(theSet, v29))
    {
      CFSetRemoveValue(theSet, v29);
      CFStringRef v30 = mmcs_item_copy_description((uint64_t)v29);
      uint64_t v31 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v32 = v14;
        char v88 = (char)v30;
        CFStringRef v33 = CFStringCreateWithFormat(v13, 0, @"Server returned error for item %@ %@");
        CFErrorRef v34 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v97 = v33;
          _os_log_impl(&dword_1DC1CA000, v34, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        CFStringRef v14 = v32;
        if (v33) {
          CFRelease(v33);
        }
      }
      mmcs_get_item_progress_make_done_error((uint64_t)error_with_error_response_and_format, &v95);
      mmcs_get_request_set_progress_and_notify_items_like_item(a1, v29, &v95);
      uint64_t v5 = v91;
    }
    else
    {
      CFStringRef v30 = mmcs_item_copy_description((uint64_t)v29);
      uint64_t v37 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        char v88 = (char)error_with_error_response_and_format;
        CFStringRef v38 = CFStringCreateWithFormat(v13, 0, @"Server returned file error %@ for item %@ which has already been handled. The error wil be ignored and no additional notification will be sent to client.");
        uint64_t v39 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v97 = v38;
          _os_log_impl(&dword_1DC1CA000, v39, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
        }
        uint64_t v5 = v91;
        if (v38) {
          CFRelease(v38);
        }
      }
    }
LABEL_40:
    if (v30) {
      CFRelease(v30);
    }
    goto LABEL_42;
  }
LABEL_47:
  CFTypeRef cf = 0;
  if (!*(void *)(v5 + 56))
  {
LABEL_99:
    int v10 = 0;
    goto LABEL_113;
  }
  uint64_t v40 = 0;
  CFAllocatorRef v41 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  while (1)
  {
    uint64_t v42 = *(void *)(*(void *)(v5 + 64) + 8 * v40);
    if (!mmcs_file_signature_is_valid_n(*(void *)(v42 + 32), *(void *)(v42 + 24))) {
      break;
    }
    uint64_t v92 = v40;
    BOOL v43 = mmcs_file_signature_to_hexstring(*(char **)(v42 + 32));
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v41, 0, MEMORY[0x1E4F1D510]);
    if (*(void *)(v42 + 40))
    {
      unint64_t v45 = 0;
      do
      {
        uint64_t v46 = *(void *)(*(void *)(v42 + 48) + 8 * v45);
        if (mmcs_chunk_signature_is_valid_n(*(void *)(v46 + 32), *(void *)(v46 + 24))) {
          uint64_t v47 = mmcs_chunk_signature_to_hexstring(*(char **)(v46 + 32));
        }
        else {
          uint64_t v47 = strdup("(invalid chunk signature)");
        }
        uint64_t v51 = v47;
        CFErrorRef v52 = mmcs_cferror_create_error_with_error_response_and_format(1, 0, 8, *(__CFError **)(v46 + 40), @"The server returned an error for chunk %s file signature %s", v48, v49, v50, (char)v47);
        uint64_t v53 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
        {
          char v88 = (char)v51;
          CFStringRef v54 = CFStringCreateWithFormat(v41, 0, @"The server returned an error for chunk %s at index %u for an item with signature %s:%@");
          CFTypeRef v55 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(CFDictionaryAddValue(theDict, key, value) = 138543362;
            *(void *)((char *)&value + 4) = v54;
            _os_log_impl(&dword_1DC1CA000, v55, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&value, 0xCu);
          }
          if (v54) {
            CFRelease(v54);
          }
        }
        CFArrayAppendValue(Mutable, v52);
        if (v52) {
          CFRelease(v52);
        }
        if (v51) {
          free(v51);
        }
        ++v45;
      }
      while (v45 < *(void *)(v42 + 40));
    }
    if (CFArrayGetCount(Mutable) == 1)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, 0);
      CFRetain(ValueAtIndex);
    }
    else
    {
      CFDictionaryRef ValueAtIndex = mmcs_cferror_create_error_with_underlying_errors(@"com.apple.mmcs", 8, @"There were errors with the chunks in the file", Mutable, 0);
    }
    if (*(_DWORD *)(v42 + 56)) {
      CFDataRef v57 = ProtobufCBinaryData_CreateData((CFDataRef)(v42 + 64));
    }
    else {
      CFDataRef v57 = 0;
    }
    long long v122 = 0u;
    long long v123 = 0u;
    long long v120 = 0u;
    long long v121 = 0u;
    long long v118 = 0u;
    long long v119 = 0u;
    long long v116 = 0u;
    long long v117 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v110 = 0u;
    long long v111 = 0u;
    long long v108 = 0u;
    long long v109 = 0u;
    long long v106 = 0u;
    long long v107 = 0u;
    long long v104 = 0u;
    long long v105 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    long long v100 = 0u;
    long long v101 = 0u;
    long long value = 0u;
    long long v99 = 0u;
    *(void *)&long long value = *(void *)(v42 + 32);
    *(void *)&long long v101 = v57;
    uint64_t v58 = CFSetGetValue(*(CFSetRef *)(*(void *)(v93 + 304) + 80), &value);
    if (v58)
    {
      int v59 = v58;
      if (CFSetContainsValue(theSet, v58))
      {
        CFSetRemoveValue(theSet, v59);
        CFStringRef v60 = mmcs_item_copy_description((uint64_t)v59);
        int v61 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
        {
          char v88 = (char)v60;
          CFStringRef v62 = CFStringCreateWithFormat(v41, 0, @"Server returned error for item %@ %@");
          uint64_t v63 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v97 = v62;
            _os_log_impl(&dword_1DC1CA000, v63, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v62) {
            CFRelease(v62);
          }
        }
        mmcs_get_item_progress_make_done_error((uint64_t)ValueAtIndex, &v95);
        mmcs_get_request_set_progress_and_notify_items_like_item(v93, v59, &v95);
      }
      else
      {
        CFStringRef v60 = mmcs_item_copy_description((uint64_t)v59);
        uint64_t v66 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          char v88 = (char)ValueAtIndex;
          CFStringRef v67 = CFStringCreateWithFormat(v41, 0, @"Server returned file chunk error %@ for item %@ which has already been handled. Suppressing notification to client since it is likely already sent.");
          CFStringRef v68 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v97 = v67;
            _os_log_impl(&dword_1DC1CA000, v68, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
          }
          if (v67) {
            CFRelease(v67);
          }
        }
      }
      uint64_t v5 = v91;
LABEL_88:
      if (v60) {
        CFRelease(v60);
      }
      goto LABEL_90;
    }
    uint64_t v64 = mmcs_logging_logger_default();
    uint64_t v5 = v91;
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      char v88 = (char)v43;
      CFStringRef v60 = CFStringCreateWithFormat(v41, 0, @"Server referenced an item in FileGroup FileChunkError with signature %s which is not in itemsWithDistinctSignatures. This FileChunkError will be ignored.");
      uint64_t v65 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v97 = v60;
        _os_log_impl(&dword_1DC1CA000, v65, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      goto LABEL_88;
    }
LABEL_90:
    if (v57) {
      CFRelease(v57);
    }
    if (v43) {
      free(v43);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (ValueAtIndex) {
      CFRelease(ValueAtIndex);
    }
    uint64_t v40 = v92 + 1;
    if ((unint64_t)(v92 + 1) >= *(void *)(v5 + 56)) {
      goto LABEL_99;
    }
  }
  uint64_t v78 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v84 = CFStringCreateWithFormat(v41, 0, @"Invalid file signature in FileGroup FileChunkError file_checksum");
    uint64_t v85 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
    {
      LODWORD(CFDictionaryAddValue(theDict, key, value) = 138543362;
      *(void *)((char *)&value + 4) = v84;
      _os_log_impl(&dword_1DC1CA000, v85, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&value, 0xCu);
    }
    if (v84) {
      CFRelease(v84);
    }
  }
  CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Invalid file signature in FileGroup FileChunkError file_checksum", v79, v80, v81, v82, v83, v88);
  int v10 = 1;
LABEL_113:
  uint64_t v69 = v10 ^ 1u;
LABEL_114:
  CFTypeRef v86 = cf;
  if (a5 && v10 && cf)
  {
    CFRetain(cf);
    CFTypeRef v86 = cf;
    *a5 = cf;
  }
  if (v86) {
    CFRelease(v86);
  }
  return v69;
}

void scheduleGetContainers(void *a1, const __CFArray *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  request_activity_marker = mmcs_request_get_request_activity_marker((uint64_t)a1);
  os_activity_scope_enter(request_activity_marker, &state);
  ++*(void *)(a1[38] + 32);
  CFIndex Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    CFIndex v7 = 0;
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a2, v7);
      uint64_t v9 = (uint64_t)ValueAtIndex;
      int v10 = ValueAtIndex + 3;
      if (ValueAtIndex[3])
      {
        if (gMMCS_DebugLevel >= 4)
        {
          uint64_t v11 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v12 = CFStringCreateWithFormat(alloc, 0, @"using proxy transaction for container %s", *(void *)(*(void *)(v9 + 88) + 16));
            CFAllocatorRef v13 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 138543362;
              *(void *)((char *)&buf + 4) = v12;
              _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&buf, 0xCu);
            }
            if (v12) {
              CFRelease(v12);
            }
          }
        }
        int v14 = 2;
      }
      else
      {
        int v10 = ValueAtIndex + 2;
        int v14 = 3;
      }
      uint64_t v15 = *v10;
      *(_DWORD *)(v9 + 68) = v14;
      if (*(_DWORD *)(v15 + 48) == 1)
      {
        if (*(_DWORD *)(v9 + 64) == 2 && !mmcs_get_container_is_needed(v9))
        {
          *(_DWORD *)(v15 + 48) = 4;
          *(_DWORD *)(*(void *)(v9 + 16) + 48) = 4;
          *(_DWORD *)(v9 + 68) = 4;
        }
        else
        {
          uint64_t v16 = mmcs_http_request_options_network_behavior_type(*(void *)(*(void *)(v15 + 24) + 24));
          uint64_t v17 = mmcs_request_type_for_behavior_and_activity(v16, 1);
          mmcs_container_requirements(v9);
          *(void *)&long long buf = 0;
          *((void *)&buf + 1) = v15;
          uint64_t v18 = a1[11];
          uint64_t v23 = v17;
          uint64_t v24 = v18;
          long long v27 = 0u;
          long long v28 = 0u;
          long long v29 = 0u;
          long long v30 = 0u;
          long long v25 = 0u;
          long long v26 = 0u;
          uint64_t v31 = mmcs_container_schedule_request_callback;
          CFStringRef v32 = mmcs_container_cancel_request_callback;
          CFStringRef v33 = C3BaseRetain;
          CFErrorRef v34 = C3BaseRelease;
          *(_DWORD *)(v15 + 48) = 2;
          double Current = CFAbsoluteTimeGetCurrent();
          *(double *)(v15 + 56) = Current;
          mmcs_request_queue_enqueue_request(*(void *)(a1[4] + 48), (uint64_t)&buf, Current);
        }
      }
      ++v7;
    }
    while (v6 != v7);
  }
  mmcs_proxy_locator_finish(a1[24]);
  --*(void *)(a1[38] + 32);
  os_activity_scope_leave(&state);
}

void _mmcs_item_setup_metadata_only(void *a1)
{
  if (mmcs_item_is_metadata_only((uint64_t)a1))
  {
    mmcs_item_setup_chunk_references(a1);
    mmcs_item_setup_item_size((uint64_t)a1);
    mmcs_item_setup_item_padded_size((uint64_t)a1);
  }
}

void __send_request_downloadFord_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 40);
  if (v3) {
    scheduleGetContainers(v2, *(const __CFArray **)(v3 + 56));
  }
  else {
    mmcs_proxy_locator_finish(v2[24]);
  }
  if (!mmcs_get_req_has_outstanding_asynchronous_work(*(void *)(a1 + 40)))
  {
    CFAllocatorRef v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_INFO, "Downloads complete. All done!", buf, 2u);
    }
    mmcs_get_req_context_cleanup(*(void *)(a1 + 40), 0);
    uint64_t v5 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"cleaned up get request because no outstanding work left. mrc: %p", *(void *)(a1 + 40));
      CFIndex v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v9 = v6;
        _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v6) {
        CFRelease(v6);
      }
    }
  }
}

void mmcs_get_req_context_will_retry_auth_get_file_after_error(uint64_t a1, uint64_t a2, __CFError *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    CFStringRef v6 = mmcs_request_copy_description(a2);
    CFIndex v7 = mmcs_cferror_copy_description(a3);
    uint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ retry auth get file after error %@", v6, v7);
      uint64_t v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v12 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v6) {
      CFRelease(v6);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
}

void handle_response_authorizeGetForFiles(uint64_t a1, CFDataRef *a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  mmcs_http_context_uuid_hash_code(a1);
  kdebug_trace();
  if (!mmcs_http_context_is_connection_reused(a1)) {
    kdebug_trace();
  }
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  request_activity_marker = mmcs_request_get_request_activity_marker(a3);
  os_activity_scope_enter(request_activity_marker, &state);
  BOOL v7 = mmcs_http_context_status_succeeded(a1);
  if (!a2 || !v7 || !*a2)
  {
    uint64_t error = mmcs_http_context_get_error(a1);
    mmcs_get_req_context_cleanup(a3, error);
    if (!a2) {
      goto LABEL_27;
    }
    goto LABEL_24;
  }
  mmcs_http_context_validate_request_uuid_with_response(a1);
  *(void *)(a3 + 120) = mmcs_get_proto_version(a1);
  *(void *)(a3 + 128) = v8;
  http_clock_skew_metrics_with_http_CFSetRef context = mmcs_create_http_clock_skew_metrics_with_http_context(a1);
  if (http_clock_skew_metrics_with_http_context)
  {
    uint64_t v10 = http_clock_skew_metrics_with_http_context;
    mmcs_request_set_http_clock_skew_metrics(a3, http_clock_skew_metrics_with_http_context);
    CFRelease(v10);
  }
  mmcs_http_context_cleanup_response(a1);
  uint64_t v11 = mmcs_server_version_compare(*(void *)(a3 + 120), *(void *)(a3 + 128), 5, 0);
  CFStringRef v12 = mmcs_logging_logger_default();
  if (v11 == -1)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v31 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Server version %ld.%ld not supported. Must be at least %ld.%ld", *(void *)(a3 + 120), *(void *)(a3 + 128), 5, 0, state.opaque[0], state.opaque[1]);
      CFStringRef v32 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v31;
        _os_log_impl(&dword_1DC1CA000, v32, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v31) {
        CFRelease(v31);
      }
    }
    CFErrorRef v33 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Server version %ld.%ld not supported. Must be at least %ld.%ld", v26, v27, v28, v29, v30, *(void *)(a3 + 120));
    mmcs_get_req_context_cleanup(a3, (uint64_t)v33);
    if (!v33) {
      goto LABEL_27;
    }
    CFErrorRef v34 = v33;
LABEL_35:
    CFRelease(v34);
    goto LABEL_27;
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    char Length = CFDataGetLength(*a2);
    CFStringRef v20 = CFStringCreateWithFormat(v19, 0, @"Got %ld bytes");
    uint64_t v21 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v20) {
      CFRelease(v20);
    }
  }
  if (*(unsigned char *)(a3 + 249))
  {
    CFDataRef v22 = *a2;
    if (*a2)
    {
      CFDataRef v23 = *(CFDataRef *)(a3 + 256);
      if (v23 != v22)
      {
        if (v23) {
          CFRelease(v23);
        }
        *(void *)(a3 + 256) = 0;
        CFRetain(v22);
        *(void *)(a3 + 256) = v22;
      }
    }
  }
  if (*(unsigned char *)(a3 + 248))
  {
    CFErrorRef authorization_error_with_format = mmcs_cferror_create_authorization_error_with_format(*a2, @"Successfully get fetched authorization", v13, v14, v15, v16, v17, v18, Length);
    mmcs_get_req_context_cleanup(a3, (uint64_t)authorization_error_with_format);
    if (authorization_error_with_format) {
      CFRelease(authorization_error_with_format);
    }
LABEL_24:
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = 0;
    goto LABEL_27;
  }
  *(void *)long long buf = 0;
  int v40 = process_authorization_data(a3, *a2, (CFTypeRef *)buf);
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = 0;
  if (!v40)
  {
    CFErrorRef v41 = *(CFErrorRef *)buf;
    if (!*(void *)buf)
    {
      CFErrorRef v41 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed to download chunks", v35, v36, v37, v38, v39, Length);
      *(void *)long long buf = v41;
    }
    mmcs_get_req_context_cleanup(a3, (uint64_t)v41);
    CFErrorRef v34 = *(CFErrorRef *)buf;
    if (*(void *)buf) {
      goto LABEL_35;
    }
  }
LABEL_27:
  os_activity_scope_leave(&state);
}

void OUTLINED_FUNCTION_0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void XCFRunLoopAddTimerToModes(uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  v4[0] = a1;
  v4[1] = a2;
  v5.length = CFArrayGetCount(theArray);
  v5.CFIndex location = 0;
  CFArrayApplyFunction(theArray, v5, (CFArrayApplierFunction)_XCFRunLoopAddTimerToModesApplier, v4);
}

void _XCFRunLoopAddTimerToModesApplier(CFRunLoopMode mode, CFRunLoopRef *a2)
{
}

void XCFRunLoopAddSourceToModes(uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  v4[0] = a1;
  v4[1] = a2;
  v5.length = CFArrayGetCount(theArray);
  v5.CFIndex location = 0;
  CFArrayApplyFunction(theArray, v5, (CFArrayApplierFunction)_XCFRunLoopAddSourceToModesApplier, v4);
}

void _XCFRunLoopAddSourceToModesApplier(CFRunLoopMode mode, CFRunLoopRef *a2)
{
}

void *mmcs_get_complete_create_method_completion_info(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t request = mmcs_get_container_get_request(a1);
  MethodCompletionInfo = Create_MethodCompletionInfo(*(__CFError **)(a1 + 40), *(__CFHTTPMessage **)(*(void *)(*(void *)(a1 + 16) + 24) + 16), *(void *)(a2 + 16), *(const char **)(*(void *)(a1 + 88) + 24), a3, 0, a4);
  if (MethodCompletionInfo)
  {
    vendor_http_stats = mmcs_report_create_vendor_http_stats(*(void *)(a2 + 16), 0, a3);
    unsigned int reporting_level = mmcs_request_get_reporting_level(request);
    if (mmcs_report_want_report(0, reporting_level))
    {
      CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Mutable)
      {
        if (request)
        {
          uint64_t v14 = *(void *)(*(void *)(request + 304) + 128);
          if (v14)
          {
            double v15 = mmcs_http_context_elapsed_seconds(v14);
            CFStringRef MillisStringFromAbsoluteTime = createMillisStringFromAbsoluteTime(v15);
            if (MillisStringFromAbsoluteTime)
            {
              CFStringRef v17 = MillisStringFromAbsoluteTime;
              CFDictionaryAddValue(Mutable, @"authorizeGetForFiles.millis", MillisStringFromAbsoluteTime);
              CFRelease(v17);
            }
          }
        }
        if (mmcs_transaction_is_proxy(a2))
        {
          CFDictionaryAddValue(Mutable, @"cachingServer.used", @"true");
          uint64_t bytes_from_caching_server = mmcs_transaction_get_bytes_from_caching_server(a2);
          if (bytes_from_caching_server)
          {
            uint64_t v19 = bytes_from_caching_server;
            CFStringRef v20 = CFStringCreateWithFormat(v12, 0, @"%llu", bytes_from_caching_server);
            if (v20)
            {
              CFStringRef v21 = v20;
              CFDictionaryAddValue(Mutable, @"cachingServer.bytes", v20);
              CFRelease(v21);
            }
            if (gMMCS_DebugLevel >= 5)
            {
              CFDataRef v22 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                CFStringRef v23 = CFStringCreateWithFormat(v12, 0, @"proxy get got %llu from caching server", v19);
                uint64_t v24 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138543362;
                  CFStringRef v27 = v23;
                  _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
                }
                if (v23) {
                  CFRelease(v23);
                }
              }
            }
          }
        }
        else
        {
          CFDictionaryAddValue(Mutable, @"cachingServer.used", @"false");
        }
      }
    }
    else
    {
      CFMutableDictionaryRef Mutable = 0;
    }
    MethodCompletionInfo_SetReportingProperties(MethodCompletionInfo, vendor_http_stats, Mutable);
    if (vendor_http_stats) {
      CFRelease(vendor_http_stats);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  return MethodCompletionInfo;
}

uint64_t mmcs_perform_getComplete(uint64_t a1)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  uint64_t v3 = _os_activity_create(&dword_1DC1CA000, "mmcs-get-complete", request_activity_marker, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v3, &state);
  uint64_t v4 = 0;
  if (*(unsigned char *)(a1 + 144))
  {
LABEL_46:
    if (!v3) {
      goto LABEL_48;
    }
LABEL_47:
    os_release(v3);
    goto LABEL_48;
  }
  CFRange v5 = *(uint64_t **)(a1 + 32);
  if (CFSetGetCount(*(CFSetRef *)(*(void *)(a1 + 304) + 80)) < 1
    || (CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
        (CFURLRef v7 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFURLRef *)(a1 + 160), @"getComplete", 0)) == 0))
  {
    uint64_t v4 = 0;
    goto LABEL_46;
  }
  CFURLRef v8 = v7;
  CFStringRef v9 = malloc_type_malloc(0x40uLL, 0x10F0040790CF86CuLL);
  if (!v9) {
    goto LABEL_51;
  }
  uint64_t v10 = v9;
  chunkserver__method_completion_info_list__init(v9);
  *((void *)v10 + 3) = 0;
  uint64_t v11 = mmcs_get_req_context_get_get_state(a1);
  if (!v11) {
    goto LABEL_49;
  }
  uint64_t v12 = v11;
  CFStringRef v68 = v5;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v11 + 40));
  if (Count < 1) {
    goto LABEL_49;
  }
  CFIndex v14 = Count;
  CFURLRef v69 = v8;
  uint64_t v15 = 0;
  for (CFIndex i = 0; i != v14; ++i)
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v12 + 40), i);
    int v18 = ValueAtIndex[16];
    if (v18 != 3)
    {
      uint64_t v19 = ValueAtIndex;
      if (v18 != 2 || !*(unsigned char *)(*((void *)ValueAtIndex + 11) + 32))
      {
        uint64_t v20 = *((void *)ValueAtIndex + 3);
        if (v20)
        {
          if (*(void *)(v20 + 16)) {
            mmcs_perform_getComplete_cold_4();
          }
          CFArrayRef v21 = *(const __CFArray **)(v20 + 40);
          if (v21) {
            v15 += CFArrayGetCount(v21);
          }
        }
        uint64_t v22 = *((void *)v19 + 2);
        if (v22)
        {
          if (*(void *)(v22 + 16)) {
            mmcs_perform_getComplete_cold_3();
          }
          CFArrayRef v23 = *(const __CFArray **)(v22 + 40);
          if (v23) {
            v15 += CFArrayGetCount(v23);
          }
        }
        if (*((void *)v19 + 5)) {
          ++v15;
        }
      }
    }
  }
  if (v15 <= 0)
  {
LABEL_49:
    *((void *)v10 + 4) = 0;
    goto LABEL_50;
  }
  uint64_t v24 = malloc_type_calloc(1uLL, 8 * v15, 0x2004093837F09uLL);
  *((void *)v10 + 4) = v24;
  if (!v24)
  {
LABEL_50:
    chunkserver__method_completion_info_list__free_unpacked((void **)v10, 0);
    goto LABEL_51;
  }
  CFIndex v25 = CFArrayGetCount(*(CFArrayRef *)(v12 + 40));
  if (v25 < 1) {
    goto LABEL_55;
  }
  CFIndex v26 = v25;
  CFIndex v27 = 0;
  char v67 = 0;
  CFIndex v66 = v25 - 1;
  do
  {
    while (1)
    {
      uint64_t v28 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v12 + 40), v27);
      int v29 = v28[16];
      if (v29 == 3) {
        break;
      }
      uint64_t v30 = (uint64_t)v28;
      if (v29 == 2)
      {
        if (*(unsigned char *)(*((void *)v28 + 11) + 32)) {
          break;
        }
      }
      uint64_t v31 = *((void *)v28 + 3);
      if (v31)
      {
        if (*(void *)(v31 + 16)) {
          mmcs_perform_getComplete_cold_2();
        }
        CFArrayRef v32 = *(const __CFArray **)(v31 + 40);
        if (v32)
        {
          v94.length = CFArrayGetCount(*(CFArrayRef *)(v31 + 40));
          v94.CFIndex location = 0;
          CFArrayApplyFunction(v32, v94, (CFArrayApplierFunction)_copy_methodCompletionInfoToList, v10);
        }
      }
      uint64_t v33 = *(void *)(v30 + 16);
      if (v33)
      {
        if (*(void *)(v33 + 16)) {
          mmcs_perform_getComplete_cold_1();
        }
        CFArrayRef v34 = *(const __CFArray **)(v33 + 40);
        if (v34)
        {
          v95.length = CFArrayGetCount(*(CFArrayRef *)(v33 + 40));
          v95.CFIndex location = 0;
          CFArrayApplyFunction(v34, v95, (CFArrayApplierFunction)_copy_methodCompletionInfoToList, v10);
        }
      }
      if (!*(void *)(v30 + 40)) {
        break;
      }
      uint64_t v35 = *(void *)(v30 + 16);
      unsigned int reporting_level = mmcs_request_get_reporting_level(a1);
      method_completion_info = mmcs_get_complete_create_method_completion_info(v30, v35, reporting_level, 0);
      if (method_completion_info)
      {
        uint64_t v39 = *((void *)v10 + 3);
        uint64_t v38 = *((void *)v10 + 4);
        *((void *)v10 + 3) = v39 + 1;
        *(void *)(v38 + 8 * v39) = method_completion_info;
        break;
      }
      char v67 = 1;
      BOOL v40 = v66 == v27++;
      CFURLRef v8 = v69;
      if (v40) {
        goto LABEL_50;
      }
    }
    ++v27;
  }
  while (v26 != v27);
  CFURLRef v8 = v69;
  if (v67) {
    goto LABEL_50;
  }
LABEL_55:
  if (*((void *)v10 + 3) != v15)
  {
    uint64_t v53 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v54 = CFStringCreateWithFormat(v6, 0, @"error MethodCompletionInfoList (getComplete) creating response list");
      CFTypeRef v55 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v54;
        _os_log_impl(&dword_1DC1CA000, v55, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v54) {
        CFRelease(v54);
      }
    }
    goto LABEL_50;
  }
  uint64_t packed_size = chunkserver__method_completion_info_list__get_packed_size((void **)v10);
  BOOL v43 = (const UInt8 *)malloc_type_malloc(packed_size, 0xF4C8A611uLL);
  chunkserver__method_completion_info_list__pack((void **)v10, (uint64_t)v43);
  CFDataRef v44 = XCFDataCreateWithBytesNoCopy(v6, v43, packed_size, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
  chunkserver__method_completion_info_list__free_unpacked((void **)v10, 0);
  if (!v44) {
    goto LABEL_80;
  }
  CFStringRef v45 = (const __CFString *)v68[8];
  CFStringRef v46 = (const __CFString *)v68[10];
  CFStringRef dataclass = (const __CFString *)mmcs_request_get_dataclass(a1);
  http_protobuf_message = create_http_protobuf_message(v45, v46, dataclass, *(const __CFString **)(a1 + 168), *(const __CFString **)(a1 + 176), v69, v44);
  CFRelease(v44);
  if (!http_protobuf_message)
  {
    uint64_t v58 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = (uint64_t)CFStringCreateWithFormat(v6, 0, @"unable to create getComplete msg");
      int v59 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v4;
        _os_log_impl(&dword_1DC1CA000, v59, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      CFURLRef v8 = v69;
      if (!v4) {
        goto LABEL_52;
      }
      CFRelease((CFTypeRef)v4);
LABEL_51:
      uint64_t v4 = 0;
      goto LABEL_52;
    }
LABEL_80:
    uint64_t v4 = 0;
    CFURLRef v8 = v69;
    goto LABEL_52;
  }
  mmcs_request_insert_headers(a1, http_protobuf_message);
  uint64_t v49 = *(void *)(*(void *)(a1 + 304) + 112);
  if (!v49 || !CFArrayGetCount(*(CFArrayRef *)(v49 + 40)))
  {
    uint64_t v56 = mmcs_logging_logger_default();
    CFURLRef v8 = v69;
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = (uint64_t)CFStringCreateWithFormat(v6, 0, @"no containers for get request");
      CFDataRef v57 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
LABEL_73:
        if (!v4) {
          goto LABEL_85;
        }
        CFRelease((CFTypeRef)v4);
        goto LABEL_84;
      }
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v4;
LABEL_72:
      _os_log_impl(&dword_1DC1CA000, v57, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
      goto LABEL_73;
    }
LABEL_84:
    uint64_t v4 = 0;
    goto LABEL_85;
  }
  uint64_t v50 = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(*(void *)(a1 + 304) + 112) + 40), 0);
  CFURLRef v8 = v69;
  if (!mmcs_get_container_http_msg_add_token_header((uint64_t)v50, http_protobuf_message))
  {
    CFStringRef v60 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      int v61 = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(*(void *)(a1 + 304) + 112) + 40), 0);
      uint64_t v4 = (uint64_t)CFStringCreateWithFormat(v6, 0, @"unable to add get container token header for container %s", *(void *)(v61[11] + 16));
      CFDataRef v57 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
        goto LABEL_73;
      }
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v4;
      goto LABEL_72;
    }
    goto LABEL_84;
  }
  mmcs_http_request_options_create_promoted_to_foreground_copy(*(void *)(a1 + 56));
  CFErrorRef v52 = v51;
  *(void *)&long long buf = @"getComplete";
  *((void *)&buf + 1) = http_protobuf_message;
  uint64_t v75 = v51;
  uint64_t v76 = *(void *)(a1 + 96);
  uint64_t v77 = 0;
  uint64_t v78 = -1;
  uint64_t v90 = 0;
  uint64_t v80 = 0;
  uint64_t v81 = 0;
  uint64_t v79 = -1;
  uint64_t v82 = mmcs_get_complete_will_retry_after_error;
  uint64_t v83 = handle_response_getComplete;
  uint64_t v84 = 0;
  uint64_t v85 = 0;
  uint64_t v86 = 0;
  uint64_t v87 = a1;
  uint64_t sparse_block_size = mmcs_engine_get_sparse_block_size();
  uint64_t v89 = mmcs_engine_owner((uint64_t)v68);
  uint64_t v91 = 0;
  uint64_t v92 = v3;
  memset(v70, 0, sizeof(v70));
  mmcs_read_stream_pool_parameters_make_pool_timeout_max(v68[4], 100, (uint64_t)v70, 90.0);
  if (!mmcs_http_context_create((void *)(*(void *)(a1 + 304) + 144), *(_DWORD *)(a1 + 140), (uint64_t)&buf))
  {
    CFStringRef v62 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    uint64_t v4 = (uint64_t)CFStringCreateWithFormat(v6, 0, @"unable to create getComplete http context");
    uint64_t v63 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v72 = 138543362;
      uint64_t v73 = v4;
      _os_log_impl(&dword_1DC1CA000, v63, OS_LOG_TYPE_ERROR, "%{public}@", v72, 0xCu);
    }
LABEL_95:
    if (!v4) {
      goto LABEL_98;
    }
    CFRelease((CFTypeRef)v4);
LABEL_97:
    uint64_t v4 = 0;
    goto LABEL_98;
  }
  mmcs_get_req_context_setup_complete_metrics((__CFArray *)a1, (uint64_t)v52);
  mmcs_http_context_update_voucher(*(void *)(*(void *)(a1 + 304) + 144));
  mmcs_http_context_uuid_hash_code(*(void *)(*(void *)(a1 + 304) + 144));
  kdebug_trace();
  if (!mmcs_http_context_send(*(void *)(*(void *)(a1 + 304) + 144), (uint64_t)v70, v68[7]))
  {
    uint64_t v64 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
      goto LABEL_97;
    }
    uint64_t v4 = (uint64_t)CFStringCreateWithFormat(v6, 0, @"unable to send getComplete http msg");
    uint64_t v65 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v72 = 138543362;
      uint64_t v73 = v4;
      _os_log_impl(&dword_1DC1CA000, v65, OS_LOG_TYPE_ERROR, "%{public}@", v72, 0xCu);
    }
    CFURLRef v8 = v69;
    goto LABEL_95;
  }
  uint64_t v4 = 1;
LABEL_98:
  if (v52) {
    C3BaseRelease(v52);
  }
LABEL_85:
  CFRelease(http_protobuf_message);
LABEL_52:
  CFRelease(v8);
  if (v3) {
    goto LABEL_47;
  }
LABEL_48:
  os_activity_scope_leave(&state);
  return v4;
}

void mmcs_get_complete_will_retry_after_error(uint64_t a1, uint64_t a2, __CFError *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFRange v5 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    CFStringRef v6 = mmcs_request_copy_description(a2);
    CFURLRef v7 = mmcs_cferror_copy_description(a3);
    CFURLRef v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ retry get complete after error %@", v6, v7);
      uint64_t v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v12 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v6) {
      CFRelease(v6);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
}

uint64_t handle_response_getComplete(uint64_t a1, CFDataRef *a2, uint64_t *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  mmcs_http_context_uuid_hash_code(a1);
  kdebug_trace();
  if (!mmcs_http_context_is_connection_reused(a1)) {
    kdebug_trace();
  }
  BOOL v6 = mmcs_http_context_status_succeeded(a1);
  if (!a2 || !v6 || !*a2)
  {
    BOOL has_http_status = mmcs_http_context_has_http_status(a1);
    uint64_t v13 = mmcs_logging_logger_default();
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (has_http_status)
    {
      if (!v14) {
        goto LABEL_22;
      }
      CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v16 = mmcs_http_context_http_status(a1);
      CFStringRef v17 = CFStringCreateWithFormat(v15, 0, @"GetComplete (%p) HTTP status: %d", a1, v16);
      int v18 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v25 = v17;
    }
    else
    {
      if (!v14) {
        goto LABEL_22;
      }
      CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"GetComplete (%p) has no http status!", a1);
      int v18 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
LABEL_20:
        if (v17) {
          CFRelease(v17);
        }
LABEL_22:
        if (!a2) {
          return mmcs_get_req_done_phase2(a3);
        }
        goto LABEL_34;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v25 = v17;
    }
    _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
    goto LABEL_20;
  }
  CFIndex Length = CFDataGetLength(*a2);
  BytePtr = (char *)CFDataGetBytePtr(*a2);
  CFStringRef v9 = (void **)chunkserver__storage_container_error_list__unpack(0, Length, BytePtr);
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = 0;
  if (!v9) {
    goto LABEL_36;
  }
  uint64_t state = mmcs_get_req_context_get_get_state((uint64_t)a3);
  if (!state)
  {
    uint64_t v19 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_33;
    }
    CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"NULL getState for hc %p get request %p", a1, a3);
    CFArrayRef v21 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v25 = v20;
LABEL_30:
      _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
LABEL_31:
    if (v20) {
      CFRelease(v20);
    }
    goto LABEL_33;
  }
  uint64_t v11 = state;
  if (!*(void *)(state + 40))
  {
    uint64_t v22 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_33;
    }
    CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"NULL getState->containers for hc %p get request %p getState %p", a1, a3, v11);
    CFArrayRef v21 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v25 = v20;
      goto LABEL_30;
    }
    goto LABEL_31;
  }
  mmcs_get_state_process_storage_container_error_list(state, (uint64_t)v9);
LABEL_33:
  chunkserver__storage_container_error_list__free_unpacked(v9, 0);
LABEL_34:
  if (*a2) {
    CFRelease(*a2);
  }
LABEL_36:
  *a2 = 0;
  return mmcs_get_req_done_phase2(a3);
}

char *_copy_methodCompletionInfoToList(void **a1, uint64_t a2)
{
  uint64_t result = Copy_MethodCompletionInfo(a1);
  if (result)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    uint64_t v4 = *(void *)(a2 + 32);
    *(void *)(a2 + 24) = v5 + 1;
    *(void *)(v4 + 8 * v5) = result;
  }
  return result;
}

uint64_t mmcs_get_container_create(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v42 = 0;
  uint64_t result = mmcs_container_create((uint64_t *)&v42, 2, 192);
  if (result)
  {
    request_activity_marker = mmcs_request_get_request_activity_marker(*a2);
    os_activity_t v8 = _os_activity_create(&dword_1DC1CA000, "mmcs-get-container", request_activity_marker, OS_ACTIVITY_FLAG_DEFAULT);
    CFStringRef v9 = v42;
    v42[10] = v8;
    uint64_t v10 = v9[11];
    *(void *)uint64_t v10 = a2;
    uint64_t v11 = *(void *)(a3 + 32);
    uint64_t v12 = *(void *)(a3 + 64);
    unint64_t v13 = v11 + v12;
    if (__CFADD__(v11, v12))
    {
      BOOL v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Sum of the number of chunk infos and the number of container elements will overflow");
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v44 = v15;
          goto LABEL_28;
        }
        goto LABEL_29;
      }
      goto LABEL_31;
    }
    if (v11 && v12)
    {
      CFStringRef v17 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cannot have both chunk infos and container elements");
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v44 = v15;
          goto LABEL_28;
        }
        goto LABEL_29;
      }
      goto LABEL_31;
    }
    if (v11)
    {
      if (v13)
      {
        int v18 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_FAULT, "Cannot have chunk infos in MMCS Protocol version 5 download.", buf, 2u);
        }
        goto LABEL_31;
      }
      goto LABEL_22;
    }
    if (!v12)
    {
      CFArrayRef v21 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cannot have neither chunk infos or container elements");
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v44 = v15;
          goto LABEL_28;
        }
        goto LABEL_29;
      }
      goto LABEL_31;
    }
    if (!v13)
    {
LABEL_22:
      CFStringRef v20 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cannot have zero container chunk instances");
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v44 = v15;
          goto LABEL_28;
        }
        goto LABEL_29;
      }
      goto LABEL_31;
    }
    *(void *)(v10 + 56) = v13;
    if (v13 >> 62)
    {
      uint64_t v19 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Overflow detected in computing the size of memory to be allocated for containerIndexForMessageIndex.");
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v44 = v15;
          goto LABEL_28;
        }
        goto LABEL_29;
      }
      goto LABEL_31;
    }
    uint64_t v22 = malloc_type_calloc(1uLL, 4 * v13, 0x3371A3D2uLL);
    *(void *)(v10 + 72) = v22;
    if (!v22)
    {
      uint64_t v24 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Allocation failure");
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v44 = v15;
          goto LABEL_28;
        }
        goto LABEL_29;
      }
      goto LABEL_31;
    }
    if (*(void *)(a3 + 32))
    {
      uint64_t v23 = **(void **)(a3 + 40) + 24;
    }
    else
    {
      uint64_t v25 = **(void **)(a3 + 72);
      if (!v25)
      {
        uint64_t v39 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Missing container element.");
          uint64_t v16 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v44 = v15;
            goto LABEL_28;
          }
          goto LABEL_29;
        }
        goto LABEL_31;
      }
      uint64_t v26 = *(void *)(v25 + 24);
      if (v26) {
        uint64_t v23 = v26 + 24;
      }
      else {
        uint64_t v23 = 0;
      }
    }
    _DWORD *v22 = 0;
    ++*(void *)(v10 + 40);
    if (v13 >= 2)
    {
      int v27 = 0;
      for (uint64_t i = 1; v13 != i; ++i)
      {
        if (*(void *)(a3 + 32))
        {
          uint64_t v29 = *(void *)(*(void *)(a3 + 40) + 8 * i) + 24;
          if (!v23) {
            goto LABEL_57;
          }
        }
        else
        {
          uint64_t v30 = *(void *)(*(void *)(a3 + 72) + 8 * i);
          if (!v30)
          {
            CFErrorRef v41 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Missing container element.");
              uint64_t v16 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                CFStringRef v44 = v15;
LABEL_28:
                _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              goto LABEL_29;
            }
            goto LABEL_31;
          }
          uint64_t v31 = *(void *)(v30 + 24);
          if (v31) {
            uint64_t v29 = v31 + 24;
          }
          else {
            uint64_t v29 = 0;
          }
          if (!v23)
          {
LABEL_57:
            v22[i] = ++v27;
            ++*(void *)(v10 + 40);
            uint64_t v23 = v29;
            continue;
          }
        }
        if (!v29) {
          goto LABEL_57;
        }
        BOOL v32 = ProtobufCBinaryData_Equals(v23, v29);
        uint64_t v22 = *(_DWORD **)(v10 + 72);
        if (!v32) {
          goto LABEL_57;
        }
        v22[i] = v27;
      }
    }
    *(void *)(v10 + 48) = 0;
    *(void *)(v10 + 8) = 0;
    uint64_t v33 = *(const char **)(a3 + 48);
    if (v33) {
      *(void *)(v10 + 16) = strdup(v33);
    }
    CFArrayRef v34 = *(const char **)(a3 + 56);
    if (v34) {
      *(void *)(v10 + 24) = strdup(v34);
    }
    *(unsigned char *)(v10 + 32) = 0;
    if (*(_DWORD *)(a3 + 80) && (*(unsigned char *)(a3 + 88) & 1) != 0) {
      *(unsigned char *)(v10 + 32) = 1;
    }
    *(unsigned char *)(v10 + 80) = 0;
    *(void *)(v10 + 96) = 0;
    *(void *)(v10 + 104) = 0;
    *(void *)(v10 + 88) = 0;
    *(unsigned char *)(v10 + 180) = 1;
    *(_OWORD *)(v10 + 144) = 0u;
    *(_OWORD *)(v10 + 160) = 0u;
    unint64_t v35 = *(void *)(v10 + 40);
    if (!is_mul_ok(v35, 0x68uLL))
    {
      uint64_t v36 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Overflow detected in computing the size of container instances to be allocated");
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v44 = v15;
          goto LABEL_28;
        }
        goto LABEL_29;
      }
      goto LABEL_31;
    }
    size_t v37 = 104 * v35;
    uint64_t v38 = malloc_type_malloc(104 * v35, 0x42031FECuLL);
    *(void *)(v10 + 120) = v38;
    if (v38)
    {
      bzero(v38, v37);
      C3BaseRetain(**(CFTypeRef **)v10);
      *a1 = v42;
      return 1;
    }
    else
    {
      BOOL v40 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"malloc");
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v44 = v15;
          goto LABEL_28;
        }
LABEL_29:
        if (v15) {
          CFRelease(v15);
        }
      }
LABEL_31:
      uint64_t result = (uint64_t)v42;
      if (v42)
      {
        C3BaseRelease(v42);
        return 0;
      }
    }
  }
  return result;
}

void mmcs_get_container_create_proxy_transaction(uint64_t a1, const __CFURL *a2, const __CFBoolean *a3)
{
  if (*(unsigned char *)(*(void *)(a1 + 88) + 180)) {
    _mmcs_container_create_proxy_transaction_impl(a1, a2, a3);
  }
}

uint64_t mmcs_get_container_is_needed(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 88) + 180);
}

uint64_t mmcs_get_container_get_request(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 88);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0;
  }
}

void mmcs_get_container_invalidate(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  uint64_t v3 = *(CFTypeRef **)v2;
  if (*(void *)v2)
  {
    if (*v3) {
      C3BaseRelease(*v3);
    }
    *(void *)uint64_t v2 = 0;
  }
  uint64_t v4 = *(const void **)(v2 + 152);
  if (v4) {
    C3BaseRelease(v4);
  }
  *(void *)(v2 + 152) = 0;
  uint64_t v5 = *(const void **)(v2 + 160);
  if (v5) {
    C3BaseRelease(v5);
  }
  *(void *)(v2 + 160) = 0;
  BOOL v6 = *(const void **)(v2 + 144);
  if (v6) {
    C3BaseRelease(v6);
  }
  *(void *)(v2 + 144) = 0;
  mmcs_container_invalidate_transactions(a1);
}

uint64_t mmcs_get_container_container_index_for_message_index(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (*(void *)(v2 + 56) <= a2) {
    mmcs_get_container_container_index_for_message_index_cold_1();
  }
  return *(int *)(*(void *)(v2 + 72) + 4 * a2);
}

uint64_t mmcs_get_container_http_msg_add_token_header(uint64_t a1, __CFHTTPMessage *a2)
{
  uint64_t result = 0;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    uint64_t v5 = *(void *)(a1 + 88);
    if (!v5) {
      return 0;
    }
    uint64_t result = *(void *)(v5 + 16);
    if (!result) {
      return result;
    }
    BOOL v6 = *(const char **)(v5 + 24);
    if (!v6)
    {
      uint64_t v10 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
        return 1;
      }
      CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Missing token for container %s", *(void *)(v5 + 16));
      uint64_t v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v17 = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (!v11) {
        return 1;
      }
      CFStringRef v9 = v11;
LABEL_13:
      CFRelease(v9);
      return 1;
    }
    CFStringRef v7 = mmcs_item_copy_token_header_value((char *)result, 0, v6, 0, 0);
    if (v7)
    {
      CFStringRef v8 = v7;
      CFHTTPMessageSetHeaderFieldValue(a2, @"x-apple-mmcs-auth", v7);
      CFStringRef v9 = v8;
      goto LABEL_13;
    }
    unint64_t v13 = mmcs_logging_logger_default();
    uint64_t result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    if (result)
    {
      CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to create token header for get container %s", *(void *)(v5 + 16));
      CFStringRef v15 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v17 = v14;
        _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v14) {
        CFRelease(v14);
      }
      return 0;
    }
  }
  return result;
}

BOOL mmcs_get_container_contains_only_ford_elements(uint64_t a1)
{
  return *(_DWORD *)(*(void *)(a1 + 88) + 176) == 2;
}

BOOL mmcs_get_container_contains_only_chunk_reference_elements(uint64_t a1)
{
  return *(_DWORD *)(*(void *)(a1 + 88) + 176) == 1;
}

uint64_t mmcs_get_container_add_ford_instance(uint64_t a1, int a2, unint64_t *a3, uint64_t a4, CFErrorRef *a5)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (a5) {
    *a5 = 0;
  }
  CFStringRef v9 = *(void **)(a1 + 88);
  unint64_t v10 = v9[6];
  if (v10 > v9[5])
  {
    CFStringRef v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"instance count overflow");
      unint64_t v13 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v47 = v12;
        _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v12) {
        CFRelease(v12);
      }
    }
    if (a5)
    {
      CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<get_container %p>", a1);
      *a5 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Chunk instance overflow in container %@ with capacity %ld", v15, v16, v17, v18, v19, (char)v14);
      if (v14) {
        CFRelease(v14);
      }
    }
    return 0;
  }
  if (!a3)
  {
    if (!v10)
    {
      unint64_t v21 = 0;
      goto LABEL_46;
    }
    uint64_t v37 = v9[15] + 104 * v10;
    uint64_t v38 = *(void *)(v37 - 72);
    unint64_t v21 = v38 + mmcs_chunk_instance_get_length((CFDataRef *)(v37 - 104));
    if (gMMCS_DebugLevel < 5) {
      goto LABEL_46;
    }
    uint64_t v39 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_46;
    }
    CFStringRef container_copy_simple_description = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Inferring chunk instance offset %lld", v21);
    CFErrorRef v41 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v47 = container_copy_simple_description;
      _os_log_impl(&dword_1DC1CA000, v41, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    goto LABEL_42;
  }
  unint64_t v21 = *a3;
  if (gMMCS_DebugLevel >= 5)
  {
    uint64_t v22 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      char v45 = v21;
      CFStringRef v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Setting explicit chunk instance offset %lld");
      uint64_t v24 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v47 = v23;
        _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v23) {
        CFRelease(v23);
      }
    }
  }
  uint64_t v25 = v9[6];
  if (!v25)
  {
    if (!v21)
    {
      v9[16] = 0;
      goto LABEL_46;
    }
    v9[16] = v21;
    if (gMMCS_DebugLevel < 5)
    {
LABEL_46:
      mmcs_chunk_instance_init_with_file_opaque_reference_length(v9[15] + 104 * v9[6], v21, v9[6], a2, a4);
      ++v9[6];
      return 1;
    }
    CFStringRef container_copy_simple_description = mmcs_get_container_copy_simple_description(a1);
    if (gMMCS_DebugLevel >= 5)
    {
      uint64_t v42 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v43 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Preparing for %ld bytes to ignore in container %@", v9[16], container_copy_simple_description);
        CFStringRef v44 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v47 = v43;
          _os_log_impl(&dword_1DC1CA000, v44, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v43) {
          CFRelease(v43);
        }
      }
    }
LABEL_42:
    if (container_copy_simple_description) {
      CFRelease(container_copy_simple_description);
    }
    goto LABEL_46;
  }
  uint64_t v26 = v9[15] + 104 * v25;
  uint64_t v27 = *(void *)(v26 - 72);
  if (v21 >= v27 + (unint64_t)mmcs_chunk_instance_get_length((CFDataRef *)(v26 - 104))) {
    goto LABEL_46;
  }
  uint64_t v28 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v34 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Chunk cannot go backward!");
    unint64_t v35 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v47 = v34;
      _os_log_impl(&dword_1DC1CA000, v35, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v34) {
      CFRelease(v34);
    }
  }
  if (!a5) {
    return 0;
  }
  CFErrorRef v36 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Chunk cannot go backward!", v29, v30, v31, v32, v33, v45);
  uint64_t result = 0;
  *a5 = v36;
  return result;
}

CFStringRef mmcs_get_container_copy_description(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<get_container %p>", a1);
}

CFStringRef mmcs_get_container_copy_simple_description(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  uint64_t v2 = *(__CFHTTPMessage **)(*(void *)(*(void *)(a1 + 16) + 24) + 16);
  if (!v2) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s", *(void *)(v1 + 16));
  }
  CFStringRef v3 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Range");
  if (!v3) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s", *(void *)(v1 + 16));
  }
  CFStringRef v4 = v3;
  CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s(%@)", *(void *)(v1 + 16), v3);
  CFRelease(v4);
  return v5;
}

uint64_t mmcs_get_container_add_chunk_instance(uint64_t a1, int a2, unint64_t *a3, unsigned char *a4, uint64_t *a5, unsigned char *a6, CFErrorRef *a7)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (a7) {
    *a7 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  uint64_t v12 = *(void *)(a1 + 88);
  if (*(void *)(v12 + 48) > *(void *)(v12 + 40))
  {
    unint64_t v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"instance count overflow");
      uint64_t v15 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v60 = v14;
        _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v14) {
        CFRelease(v14);
      }
    }
    if (a7)
    {
      CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<get_container %p>", a1);
      *a7 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Chunk instance overflow in container %@ with capacity %ld", v17, v18, v19, v20, v21, (char)v16);
      if (v16) {
        CFRelease(v16);
      }
    }
    return 0;
  }
  chunk_reference = mmcs_get_req_get_or_create_chunk_reference(**(void **)v12, a2, a4, 0, a6);
  if (!chunk_reference)
  {
    BOOL v40 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v41 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"create chunk reference");
      uint64_t v42 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v60 = v41;
        _os_log_impl(&dword_1DC1CA000, v42, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v41) {
        CFRelease(v41);
      }
    }
    if (!a7) {
      return 0;
    }
    CFStringRef v39 = @"Unable to create chunk reference";
    goto LABEL_66;
  }
  uint64_t v23 = (uint64_t)chunk_reference;
  if (a3)
  {
    unint64_t v24 = *a3;
    if (gMMCS_DebugLevel >= 5)
    {
      uint64_t v25 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        LOBYTE(v58) = v24;
        CFStringRef v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Setting explicit chunk instance offset %lld");
        uint64_t v27 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v60 = v26;
          _os_log_impl(&dword_1DC1CA000, v27, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v26) {
          CFRelease(v26);
        }
      }
    }
    uint64_t v28 = *(void *)(v12 + 48);
    if (v28)
    {
      uint64_t v29 = *(void *)(v12 + 120) + 104 * v28;
      uint64_t v30 = *(void *)(v29 - 72);
      if (v24 < v30 + (unint64_t)mmcs_chunk_instance_get_length((CFDataRef *)(v29 - 104)))
      {
        uint64_t v31 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v37 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Chunk cannot go backward!");
          uint64_t v38 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v60 = v37;
            _os_log_impl(&dword_1DC1CA000, v38, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v37) {
            CFRelease(v37);
          }
        }
        if (!a7) {
          return 0;
        }
        CFStringRef v39 = @"Chunk cannot go backward!";
LABEL_66:
        CFErrorRef v57 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, v39, v32, v33, v34, v35, v36, v58);
        uint64_t result = 0;
        *a7 = v57;
        return result;
      }
      goto LABEL_55;
    }
    if (!v24)
    {
      *(void *)(v12 + 128) = 0;
      goto LABEL_55;
    }
    *(void *)(v12 + 128) = v24;
    if (gMMCS_DebugLevel < 5) {
      goto LABEL_55;
    }
    CFStringRef container_copy_simple_description = mmcs_get_container_copy_simple_description(a1);
    if (gMMCS_DebugLevel >= 5)
    {
      uint64_t v49 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v58 = *(void *)(v12 + 128);
        CFStringRef v50 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Preparing for %ld bytes to ignore in container %@");
        uint64_t v51 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v60 = v50;
          _os_log_impl(&dword_1DC1CA000, v51, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v50) {
          CFRelease(v50);
        }
      }
    }
LABEL_51:
    if (container_copy_simple_description) {
      CFRelease(container_copy_simple_description);
    }
    goto LABEL_55;
  }
  uint64_t v43 = *(void *)(v12 + 48);
  if (!v43)
  {
    unint64_t v24 = 0;
    goto LABEL_55;
  }
  uint64_t v44 = *(void *)(v12 + 120) + 104 * v43;
  uint64_t v45 = *(void *)(v44 - 72);
  unint64_t v24 = v45 + mmcs_chunk_instance_get_length((CFDataRef *)(v44 - 104));
  if (gMMCS_DebugLevel >= 5)
  {
    CFStringRef v46 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
    {
      LOBYTE(v58) = v24;
      CFStringRef container_copy_simple_description = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Inferring chunk instance offset %lld");
      uint64_t v48 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v60 = container_copy_simple_description;
        _os_log_impl(&dword_1DC1CA000, v48, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      goto LABEL_51;
    }
  }
LABEL_55:
  if (!mmcs_chunk_instance_init(*(void *)(v12 + 120) + 104 * *(void *)(v12 + 48), v23, v24, *(void *)(v12 + 48), 0))
  {
    CFStringRef v54 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v55 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_chunk_instance_init");
      uint64_t v56 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v60 = v55;
        _os_log_impl(&dword_1DC1CA000, v56, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v55) {
        CFRelease(v55);
      }
    }
    if (!a7) {
      return 0;
    }
    CFStringRef v39 = @"Unable to init chunk instance";
    goto LABEL_66;
  }
  uint64_t v52 = *(void *)(v12 + 48);
  *(_DWORD *)(*(void *)(v12 + 120) + 104 * v52 + 64) = a2;
  if (a5) {
    *a5 = v23;
  }
  *(void *)(v12 + 48) = v52 + 1;
  return 1;
}

uint64_t mmcs_get_container_requirements@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6 = mmcs_http_request_options_network_behavior_type(*(void *)(*(void *)(a2 + 24) + 24));
  uint64_t v7 = mmcs_request_type_for_behavior_and_activity(v6, 1);
  *a3 = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[1] = 0u;
  mmcs_http_request_make_request_requirements(*(void *)(a2 + 24), (uint64_t)a3);
  uint64_t result = mmcs_get_container_get_body_size(a1);
  *((void *)a3 + v7 + 2) = result;
  return result;
}

uint64_t mmcs_get_container_get_body_size(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 88);
  uint64_t v2 = v1[8];
  if (!v2)
  {
    if (v1[6])
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      uint64_t v2 = 0;
      do
      {
        uint64_t v5 = v1[15];
        if (v4)
        {
          uint64_t v6 = v5 + v3;
          uint64_t v7 = *(void *)(v6 + 32);
          uint64_t v8 = *(void *)(v6 - 72);
          uint64_t v9 = v7 - (v8 + mmcs_chunk_instance_get_length((CFDataRef *)(v6 - 104)));
          uint64_t v5 = v1[15];
        }
        else
        {
          uint64_t v9 = *(void *)(v5 + 32);
        }
        v2 += v9 + mmcs_chunk_instance_get_length((CFDataRef *)(v5 + v3));
        ++v4;
        v3 += 104;
      }
      while (v4 < v1[6]);
    }
    else
    {
      uint64_t v2 = 0;
    }
    v1[8] = v2;
  }
  return v2;
}

uint64_t mmcs_get_container_set_needed(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(result + 88) + 180) = a2;
  return result;
}

__CFSet *mmcs_get_container_copy_chunk_reference_set(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &chunkReferenceSignatureEqualitySetCallbacks);
  uint64_t v3 = *(void *)(a1 + 88);
  if (*(void *)(v3 + 48))
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(v3 + 120) + v4;
      if (mmcs_chunk_instance_is_chunk_reference((_DWORD *)v6)) {
        CFSetSetValue(Mutable, *(const void **)(v6 + 56));
      }
      ++v5;
      v4 += 104;
    }
    while (v5 < *(void *)(v3 + 48));
  }
  return Mutable;
}

BOOL mmcs_get_container_is_body_complete(uint64_t a1, CFErrorRef *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 88);
  if (a2) {
    *a2 = 0;
  }
  uint64_t body_size = mmcs_get_container_get_body_size(a1);
  uint64_t v6 = *(void *)(v4 + 104);
  if (body_size != v6)
  {
    uint64_t v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v9 = mmcs_get_container_get_body_size(a1);
      CFStringRef v10 = CFStringCreateWithFormat(v8, 0, @"Expected body of %lu; got %lu", v9, *(void *)(v4 + 104));
      CFStringRef v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v20 = v10;
        _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v10) {
        CFRelease(v10);
      }
    }
    if (a2)
    {
      char v12 = mmcs_get_container_get_body_size(a1);
      *a2 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 38, @"The expected size of the container get (%lu) didn't match the number of bytes received (%lu).", v13, v14, v15, v16, v17, v12);
    }
  }
  return body_size == v6;
}

uint64_t mmcs_get_container_process_data(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, CFErrorRef *a6)
{
  uint64_t v9 = (uint64_t)a1;
  uint64_t v343 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a1[11];
  uint64_t v11 = *(void *)(v10 + 128);
  if (v11)
  {
    if (v11 >= (uint64_t)a4) {
      unint64_t v12 = a4;
    }
    else {
      unint64_t v12 = *(void *)(v10 + 128);
    }
    if (gMMCS_DebugLevel >= 4)
    {
      CFStringRef container_copy_simple_description = mmcs_get_container_copy_simple_description((uint64_t)a1);
      uint64_t v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        LOBYTE(v275) = v12;
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Ignored next %ld bytes in container %@");
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v15;
          _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        uint64_t v9 = (uint64_t)a1;
        if (v15) {
          CFRelease(v15);
        }
      }
      if (container_copy_simple_description) {
        CFRelease(container_copy_simple_description);
      }
    }
    *(void *)(v10 + 128) -= v12;
    *(void *)(v10 + 104) += v12;
  }
  else
  {
    unint64_t v12 = 0;
  }
  unint64_t v318 = a4 - v12;
  if (a4 <= v12) {
    return 1;
  }
  if (gMMCS_DebugLevel >= 5)
  {
    uint64_t v17 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      LOBYTE(v275) = a4 - v12;
      CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Processing %ld bytes of container");
      uint64_t v19 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl(&dword_1DC1CA000, v19, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v18) {
        CFRelease(v18);
      }
    }
  }
  uint64_t v279 = a2;
  CFErrorRef error = 0;
  uint64_t v20 = *(void *)(v9 + 88);
  if (mmcs_request_is_container_interrupted_mode(**(void **)v20))
  {
    unint64_t v21 = *(void *)(v20 + 104) + v318;
    if (v21 > (unint64_t)((double)(unint64_t)mmcs_get_container_get_body_size(v9) * 0.1))
    {
      CFErrorRef v27 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Simulate a container failure after making around 10 percent progress.", v22, v23, v24, v25, v26, v275);
      char v305 = 0;
LABEL_25:
      int v293 = 0;
      CFErrorRef error = v27;
      goto LABEL_26;
    }
  }
  if (!v318 || (unint64_t v30 = *(void *)(v20 + 88), v30 >= *(void *)(v20 + 48)))
  {
    *(void *)(v20 + 104) += v318;
    unsigned __int8 v28 = 1;
LABEL_418:
    CFErrorRef v29 = error;
    if (error) {
      goto LABEL_419;
    }
    return v28;
  }
  char v305 = 0;
  uint64_t v319 = a3 + v12;
  uint64_t v31 = 0;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v278 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
  int v293 = 1;
  unint64_t v32 = v318;
  while (1)
  {
    uint64_t v33 = *(void *)(v20 + 120);
    uint64_t v34 = (CFDataRef *)(v33 + 104 * v30);
    unsigned int length = mmcs_chunk_instance_get_length(v34);
    uint64_t v36 = *(void *)(v20 + 96);
    unint64_t v322 = length - v36;
    unint64_t v37 = v322 >= v32 ? v32 : length - v36;
    unint64_t v320 = v37;
    if (*(_DWORD *)v34 != 1) {
      break;
    }
    v317 = (unsigned char *)(v319 + v31);
    v309 = (const void **)(v33 + 104 * v30 + 56);
    int state_all_outstanding_chunk_references_contains_chunk = mmcs_get_state_all_outstanding_chunk_references_contains_chunk(*(CFSetRef **)v20, *v309);
    BOOL v72 = state_all_outstanding_chunk_references_contains_chunk == 0;
    int v302 = state_all_outstanding_chunk_references_contains_chunk;
    unint64_t v306 = v30;
    if (state_all_outstanding_chunk_references_contains_chunk)
    {
      if (!*(void *)(v20 + 112))
      {
        uint64_t v73 = mmcs_chunk_instance_chunk_coder_create(v33 + 104 * v30, 2);
        *(void *)(v20 + 112) = v73;
        if (!v73)
        {
          uint64_t v83 = @"no chunk coder";
          goto LABEL_147;
        }
      }
      if (gMMCS_DebugLevel >= 5)
      {
        uint64_t v74 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
        {
          LOBYTE(v275) = v319 + v31;
          CFStringRef v75 = CFStringCreateWithFormat(allocator, 0, @"decrypting %p len %lu (of buffer %p)");
          uint64_t v76 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v75;
            _os_log_impl(&dword_1DC1CA000, v76, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          uint64_t v34 = (CFDataRef *)(v33 + 104 * v30);
          if (v75) {
            CFRelease(v75);
          }
        }
        if (v37) {
          BOOL v77 = gMMCS_DebugLevel < 5;
        }
        else {
          BOOL v77 = 1;
        }
        if (!v77)
        {
          uint64_t v78 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
          {
            unint64_t v79 = v32;
            uint64_t v80 = v34;
            LOBYTE(v275) = *v317;
            CFStringRef v81 = CFStringCreateWithFormat(allocator, 0, @"%u %u");
            uint64_t v82 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v81;
              _os_log_impl(&dword_1DC1CA000, v82, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            uint64_t v34 = v80;
            unint64_t v32 = v79;
            unint64_t v37 = v320;
            if (v81) {
              CFRelease(v81);
            }
          }
        }
      }
      if (!CKChunkCoderUpdate())
      {
        uint64_t v83 = @"CKChunkCoderUpdate";
LABEL_147:
        int v293 = 0;
        CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 22, v83);
        goto LABEL_252;
      }
    }
    else
    {
      *(void *)(v20 + 136) += v37;
    }
    uint64_t v86 = (unsigned __int8 *)*((void *)*v309 + 4);
    if (v86)
    {
      BOOL v289 = v72;
      v313 = v34;
      uint64_t v315 = v33;
      uint64_t v304 = v31;
      uint64_t v87 = (void *)a1[11];
      cfa = *(void **)(v87[15] + 104 * v87[11] + 56);
      uint64_t v299 = cfa[4];
      if (v299)
      {
        if (!v37) {
          mmcs_get_container_process_data_cold_5();
        }
        unint64_t v88 = *((unsigned int *)cfa + 1);
        unint64_t v89 = v87[21];
        BOOL v77 = v88 > v89;
        unint64_t v90 = v88 - v89;
        if (!v77) {
          mmcs_get_container_process_data_cold_6();
        }
        BOOL v91 = v90 < v37 || v322 <= v32;
        unint64_t v92 = v90 >= v37 ? v37 : v90;
        if (v92)
        {
          unint64_t v93 = (unint64_t)*v86 << 10;
          CFRange v94 = (CFTypeRef *)(v87 + 18);
          CFRange v95 = (CFTypeRef *)(v87 + 20);
          CFStringRef v96 = v317;
          BOOL v283 = v91;
          while (1)
          {
            if (!*v94)
            {
              if (!v87[19]) {
                CKChunkDigestArgumentsV1Create();
              }
              CKSchemeAndSignatureSize();
              unint64_t v37 = v320;
              BOOL v91 = v283;
              if (!CKChunkDigestResultsCreate()
                || !CKChunkSignatureGeneratorCreate()
                || !*v94)
              {
                goto LABEL_196;
              }
              unint64_t v89 = v87[21];
            }
            unint64_t v97 = v89 % v93;
            char v98 = v97 + v92 >= v93 || v91;
            if ((v98 & 1) == 0)
            {
              CKChunkSignatureGeneratorUpdate();
              v87[21] += v92;
              goto LABEL_196;
            }
            unint64_t v99 = v32;
            unint64_t v100 = (v93 - v97);
            unint64_t v101 = v92 >= v100 ? v100 : v92;
            uint64_t v325 = 0;
            CKChunkSignatureGeneratorUpdate();
            if (!CKChunkSignatureGeneratorFinish()) {
              break;
            }
            if (v325) {
              C3BaseRelease((CFTypeRef)v325);
            }
            uint64_t v325 = 0;
            if (*v94) {
              C3BaseRelease(*v94);
            }
            CFTypeRef *v94 = 0;
            if (*v95) {
              C3BaseRelease(*v95);
            }
            unint64_t v89 = v87[21] + v101;
            if (v91) {
              unint64_t v89 = 0;
            }
            v87[20] = 0;
            v87[21] = v89;
            v96 += v101;
            v92 -= v101;
            unint64_t v32 = v99;
            unint64_t v37 = v320;
            if (!v92) {
              goto LABEL_196;
            }
          }
          v133 = mmcs_logging_logger_default();
          unint64_t v32 = v99;
          unint64_t v37 = v320;
          if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v134 = CFStringCreateWithFormat(allocator, 0, @"CKChunkSignatureGeneratorFinish failed\n");
            uint64_t v135 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v134;
              _os_log_impl(&dword_1DC1CA000, v135, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            }
            if (v134) {
              CFRelease(v134);
            }
          }
          if (v325) {
            C3BaseRelease((CFTypeRef)v325);
          }
          uint64_t v325 = 0;
          if (*v94) {
            C3BaseRelease(*v94);
          }
          CFTypeRef *v94 = 0;
          if (*v95) {
            C3BaseRelease(*v95);
          }
          CFTypeRef *v95 = 0;
        }
      }
LABEL_196:
      BOOL v102 = v299 != 0;
      uint64_t v31 = v304;
      uint64_t v34 = v313;
      uint64_t v33 = v315;
      BOOL v72 = v289;
    }
    else
    {
      BOOL v102 = 1;
    }
    BOOL v136 = v322 <= v32;
    if (!v302) {
      BOOL v136 = 0;
    }
    v305 |= v136;
    if (v322 <= v32 || !v102)
    {
      if (*(void *)(v20 + 112) && CKChunkCoderFinish()) {
        BOOL v72 = 1;
      }
      BOOL v137 = v102 && v72;
      if (v137 && error)
      {
        CFRelease(error);
        CFErrorRef error = 0;
      }
      uint64_t v138 = *(const void **)(v20 + 112);
      if (v138) {
        C3BaseRelease(v138);
      }
      *(void *)(v20 + 112) = 0;
      if (!v137)
      {
        v265 = mmcs_chunk_signature_to_hexstring(*((char **)*v309 + 1));
        CFStringRef v268 = mmcs_get_container_copy_simple_description((uint64_t)a1);
        uint64_t v269 = *(void *)(v279 + 16);
        if (v269)
        {
          request_message = (__CFHTTPMessage *)mmcs_http_context_get_request_message(v269);
          uint64_t v271 = *(void *)(v279 + 16);
          if (v271)
          {
            response_message = (__CFHTTPMessage *)mmcs_http_context_get_response_message(v271);
LABEL_428:
            CFErrorRef v273 = error;
            if (v102) {
              CFStringRef v274 = @"Chunk data verification failed for chunk %s in container %@ at chunk index %lu at offset %llu length %u (relative to the container's range)";
            }
            else {
              CFStringRef v274 = @"Subchunk data verification failed for chunk %s in container %@ at chunk index %lu at offset %llu length %u (relative to the container's range)";
            }
            CFErrorRef error = mmcs_cferror_create_with_request_response_and_format(@"com.apple.mmcs", 11, request_message, response_message, error, v274, v266, v267, (char)v265);
            if (v265) {
              free(v265);
            }
            if (v268) {
              CFRelease(v268);
            }
            if (v273) {
              CFRelease(v273);
            }
            goto LABEL_437;
          }
        }
        else
        {
          request_message = 0;
        }
        response_message = 0;
        goto LABEL_428;
      }
    }
    unsigned int v139 = mmcs_chunk_instance_get_length(v34);
    unint64_t v140 = *(void *)(v20 + 96);
    if (v140 < v139) {
      mmcs_get_state_process_chunk_with_padding(*(void *)v20, a1, (uint64_t)*v309, v140, (uint64_t)v317, v37);
    }
LABEL_252:
    uint64_t v84 = v32 - v37;
    v31 += v37;
    *(void *)(v20 + 96) += v37;
    if (v322 <= v32)
    {
      if (*(unsigned char *)(mmcs_chunk_instance_offset(**(void **)v20) + 170))
      {
        uint64_t v162 = mmcs_chunk_instance_offset(**(void **)v20);
        unsigned int v163 = mmcs_chunk_instance_get_length(v34);
        mmcs_engine_add_bytes_got(v162, v163);
        v164 = (void *)mmcs_chunk_instance_offset(**(void **)v20);
        mmcs_engine_commit_if_over_threshold(v164);
      }
      v165 = v34;
      unint64_t v166 = *(void *)(v20 + 88) + 1;
      if (v166 < *(void *)(v20 + 48))
      {
        uint64_t v167 = *(void *)(v20 + 120);
        uint64_t v168 = v33 + 104 * v306;
        uint64_t v170 = *(void *)(v168 + 32);
        v169 = (uint64_t *)(v168 + 32);
        v171 = v165;
        unint64_t v172 = v170 + mmcs_chunk_instance_get_length(v165);
        unint64_t v173 = *(void *)(v167 + 104 * v166 + 32);
        if (v172 < v173)
        {
          uint64_t v174 = *v169;
          uint64_t v175 = v173 - (v174 + mmcs_chunk_instance_get_length(v171));
          *(void *)(v20 + 128) = v175;
          uint64_t v176 = gMMCS_DebugLevel;
          if (gMMCS_DebugLevel > 4)
          {
            CFStringRef v177 = mmcs_get_container_copy_simple_description((uint64_t)a1);
            if (gMMCS_DebugLevel >= 5)
            {
              v178 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v178, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v275 = *(void *)(v20 + 128);
                CFStringRef v179 = CFStringCreateWithFormat(allocator, 0, @"Ignoring next %ld bytes in container %@");
                v180 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v180, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)long long buf = 138543362;
                  *(void *)&uint8_t buf[4] = v179;
                  _os_log_impl(&dword_1DC1CA000, v180, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                }
                if (v179) {
                  CFRelease(v179);
                }
              }
            }
            if (v177) {
              CFRelease(v177);
            }
            uint64_t v176 = gMMCS_DebugLevel;
            uint64_t v175 = *(void *)(v20 + 128);
          }
          if (v175 >= v84) {
            uint64_t v181 = v84;
          }
          else {
            uint64_t v181 = v175;
          }
          if (v176 >= 4)
          {
            CFStringRef v182 = mmcs_get_container_copy_simple_description((uint64_t)a1);
            v183 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v183, OS_LOG_TYPE_DEBUG))
            {
              LOBYTE(v275) = v181;
              CFStringRef v184 = CFStringCreateWithFormat(allocator, 0, @"Ignored next %ld bytes in container %@");
              v185 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v185, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v184;
                _os_log_impl(&dword_1DC1CA000, v185, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
              }
              if (v184) {
                CFRelease(v184);
              }
            }
            if (v182) {
              CFRelease(v182);
            }
          }
          *(void *)(v20 + 128) -= v181;
          v84 -= v181;
          v31 += v181;
        }
      }
      unint64_t v85 = 0;
      ++*(void *)(v20 + 88);
      goto LABEL_280;
    }
LABEL_281:
    unint64_t v32 = v84;
    unint64_t v30 = *(void *)(v20 + 88);
    unint64_t v186 = *(void *)(v20 + 48);
    if (v30 == v186) {
      goto LABEL_26;
    }
    if (*(_DWORD *)(a1[11] + 176) != 2)
    {
      if (!mmcs_get_state_has_files_which_still_needs_container(*(void *)v20, a1))
      {
        CFErrorRef v27 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 34, @"Container %s is no longer needed.", v187, v188, v189, v190, v191, *(void *)(v20 + 16));
        goto LABEL_25;
      }
      unint64_t v30 = *(void *)(v20 + 88);
      unint64_t v186 = *(void *)(v20 + 48);
    }
    if (v30 >= v186 || !v32) {
      goto LABEL_26;
    }
  }
  if (*(_DWORD *)v34 != 3) {
    mmcs_get_container_process_data_cold_1();
  }
  uint64_t v38 = v33 + 104 * v30;
  CFStringRef v41 = *(__CFData **)(v38 + 88);
  BOOL v40 = (CFTypeRef *)(v38 + 88);
  CFMutableDictionaryRef Mutable = v41;
  if (!v41)
  {
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(allocator, *(unsigned int *)(v33 + 104 * v30 + 96));
    *BOOL v40 = Mutable;
  }
  CFDataAppendBytes(Mutable, (const UInt8 *)(v319 + v31), v37);
  if (v322 > v32)
  {
    uint64_t v84 = v32 - v37;
    v31 += v37;
    unint64_t v85 = *(void *)(v20 + 96) + v37;
LABEL_280:
    *(void *)(v20 + 96) = v85;
    goto LABEL_281;
  }
  uint64_t v42 = (uint64_t *)a1[11];
  uint64_t v43 = v33 + 104 * v30;
  uint64_t v44 = *(void **)(v43 + 8);
  uint64_t v314 = v33;
  v316 = (uint64_t *)(v43 + 8);
  v324 = 0;
  unint64_t v306 = v30;
  v312 = (CFDataRef *)v43;
  if (!v44)
  {
    long long v103 = mmcs_logging_logger_default();
    int v104 = 1;
    if (os_log_type_enabled(v103, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v103, OS_LOG_TYPE_INFO, "Unneeded FORD downloaded.", buf, 2u);
      long long v105 = v324;
      if (v324) {
        goto LABEL_225;
      }
      CFErrorRef error = 0;
      goto LABEL_249;
    }
    goto LABEL_229;
  }
  v301 = v42;
  key = v44;
  CFDataRef v45 = (const __CFData *)PCSMMCSCopyDecryptedData();
  if (*v40) {
    CFRelease(*v40);
  }
  *BOOL v40 = 0;
  uint64_t v303 = v31;
  unint64_t v286 = v32;
  if (!v45)
  {
    v308 = "Unable to Decrypt FORD";
    CFIndex v106 = 42;
    goto LABEL_227;
  }
  CFIndex v46 = CFDataGetLength(v45);
  CFDataRef cf = v45;
  BytePtr = (char *)CFDataGetBytePtr(v45);
  uint64_t v48 = (void **)opaque__file_reference_data__unpack(0, v46, BytePtr);
  if (!v48)
  {
    int v104 = 0;
    v308 = "Unable to Decode Protobuf";
    uint64_t v288 = 43;
    goto LABEL_222;
  }
  uint64_t v49 = v48[3];
  v298 = v48;
  if (v49)
  {
    if ((**(unsigned char **)*v316 & 0x7F) != 4 && (**(unsigned char **)*v316 & 8) == 0)
    {
      uint64_t v288 = 45;
      v141 = "File Key State Unexpected";
    }
    else
    {
      if (*(void *)(*v316 + 144) == *((void *)v49 + 3))
      {
        uint64_t v51 = a1[11];
        uint64_t v52 = v316;
        if (*((_DWORD *)v49 + 10))
        {
          CFDataRef v53 = XCFDataCreateWithBytesNoCopy(allocator, *((const UInt8 **)v49 + 7), *((void *)v49 + 6), v278);
          *((void *)v49 + 6) = 0;
          *((void *)v49 + 7) = 0;
          if (!*(void *)(*v316 + 400)) {
            mmcs_item_set_file_verification_key(*v316, v53);
          }
          if (v53) {
            CFRelease(v53);
          }
        }
        CFDictionaryRef Value = (char ***)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)v51 + 104), (const void *)*v316);
        if (!Value) {
          mmcs_get_container_process_data_cold_4();
        }
        if (*((void *)v49 + 3))
        {
          uint64_t v54 = 0;
          unint64_t v55 = 0;
          uint64_t v56 = 0;
          while (1)
          {
            uint64_t v57 = *(void *)(*v52 + 272);
            uint64_t v58 = *(void *)(*((void *)v49 + 4) + 8 * v55);
            uint64_t v59 = v57 + v54;
            uint64_t v60 = *(void *)(v57 + v54 + 56);
            if (!*(void *)(v60 + 16))
            {
              *(void *)(v60 + 16) = *(void *)(v58 + 32);
              *(void *)(v58 + 32) = 0;
            }
            uint64_t v61 = *(unsigned int *)(v60 + 4);
            uint64_t v62 = v61;
            if (*(_DWORD *)(v58 + 40))
            {
              if (*(void *)(v58 + 48) != 4)
              {
                uint64_t v288 = 45;
                v254 = "Unexpected Number of Bytes for Chunk Length";
                goto LABEL_388;
              }
              uint64_t v62 = **(unsigned int **)(v58 + 56);
              if (!v62)
              {
                uint64_t v288 = 45;
                v254 = "Chunk Length Cannot Have Zero Bytes";
                goto LABEL_388;
              }
            }
            if (gMMCS_DebugLevel >= 4 && (v62 != v61 || v56 != *(void *)(v57 + v54 + 32)))
            {
              v307 = mmcs_file_signature_to_hexstring(*Value[1]);
              v287 = mmcs_chunk_signature_to_hexstring(*(char **)(*(void *)(v59 + 56) + 8));
              uint64_t v63 = mmcs_logging_logger_chunk();
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v64 = Value[1];
                uint64_t v65 = v64[5];
                CFStringRef v66 = (const __CFString *)v64[18];
                uint64_t v67 = *(unsigned int *)(*(void *)(v59 + 56) + 4);
                uint64_t v68 = *(void *)(v57 + v54 + 32);
                *(_DWORD *)long long buf = 134220034;
                *(void *)&uint8_t buf[4] = v65;
                __int16 v327 = 2082;
                v328 = v307;
                __int16 v329 = 2048;
                CFStringRef v330 = (CFStringRef)(v55 + 1);
                __int16 v331 = 2048;
                CFStringRef v332 = v66;
                __int16 v333 = 2082;
                v334 = v287;
                __int16 v335 = 2048;
                uint64_t v336 = v67;
                __int16 v337 = 2048;
                uint64_t v338 = v62;
                __int16 v339 = 2048;
                uint64_t v340 = v68;
                __int16 v341 = 2048;
                uint64_t v342 = v56;
                _os_log_impl(&dword_1DC1CA000, v63, OS_LOG_TYPE_DEFAULT, "Item %lld with file signature %{public}s updated chunk %llu of %llu with chunk signature %{public}s updated instance length from %llu to %llu and offset from %llu to %llu", buf, 0x5Cu);
              }
              if (v307) {
                free(v307);
              }
              if (v287) {
                free(v287);
              }
            }
            uint64_t v69 = *(void *)(v59 + 56);
            *(_DWORD *)(v69 + 4) = v62;
            *(unsigned char *)(v69 + 64) = 1;
            *(void *)(v57 + v54 + 32) = v56;
            if (*(_DWORD *)(v58 + 64))
            {
              *(void *)(v69 + 40) = *(void *)(v58 + 72);
              uint64_t v70 = *(unsigned char **)(v58 + 80);
              *(void *)(v69 + 32) = v70;
              *(unsigned char *)(v69 + 24) = 1;
              *(void *)(v58 + 72) = 0;
              *(void *)(v58 + 80) = 0;
              if (!v70 || !*v70)
              {
                uint64_t v288 = 45;
                v254 = "Unexpected value for Max Subchunk length in Subchunk Digest, V1";
                goto LABEL_388;
              }
              if (CKSubchunkBlobSize() != *(void *)(*(void *)(v59 + 56) + 40)) {
                break;
              }
            }
            v56 += v62;
            ++v55;
            v54 += 104;
            uint64_t v52 = v316;
            if (v55 >= *((void *)v49 + 3))
            {
              v308 = 0;
              uint64_t v288 = 0;
              unint64_t v30 = v306;
              unint64_t v32 = v286;
              unint64_t v37 = v320;
              goto LABEL_339;
            }
          }
          uint64_t v288 = 45;
          v254 = "Unexpected Number of Bytes for Subchunk Digest, V1";
LABEL_388:
          v308 = v254;
          unint64_t v30 = v306;
          unint64_t v32 = v286;
          unint64_t v37 = v320;
          goto LABEL_220;
        }
        v308 = 0;
        uint64_t v288 = 0;
        unint64_t v32 = v286;
        goto LABEL_339;
      }
      uint64_t v288 = 45;
      v141 = "Unexpected Number of Chunks";
    }
    v308 = v141;
    goto LABEL_219;
  }
  long long v107 = v48[4];
  if (!v107)
  {
    v192 = v48[5];
    unint64_t v32 = v286;
    if (v192)
    {
      uint64_t v325 = 0;
      uint64_t v193 = *((void *)v192 + 5);
      if (v193)
      {
        if (v193 == *(void *)(*v316 + 144))
        {
          uint64_t v194 = a1[11];
          CFDataRef v195 = XCFDataCreateWithBytesNoCopy(allocator, *((const UInt8 **)v192 + 4), *((void *)v192 + 3), v278);
          *((void *)v192 + 3) = 0;
          *((void *)v192 + 4) = 0;
          if (!*(void *)(*v316 + 400)) {
            mmcs_item_set_file_verification_key(*v316, v195);
          }
          if (v195) {
            CFRelease(v195);
          }
          v311 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)v194 + 104), (const void *)*v316);
          if (!v311) {
            mmcs_get_container_process_data_cold_2();
          }
          uint64_t v196 = *((void *)v192 + 5);
          if (v196)
          {
            v197 = (uint64_t *)*((void *)v192 + 6);
            uint64_t v198 = *(void *)(*v316 + 272) + 56;
            while (1)
            {
              uint64_t v199 = *v197;
              uint64_t v200 = *(void *)v198;
              if (!*(void *)(*(void *)v198 + 16))
              {
                *(void *)(v200 + 16) = *(void *)(v199 + 32);
                *(void *)(v199 + 32) = 0;
              }
              if (*(_DWORD *)(v199 + 40))
              {
                *(void *)(v200 + 40) = *(void *)(v199 + 48);
                v201 = *(unsigned char **)(v199 + 56);
                *(void *)(v200 + 32) = v201;
                char v202 = 1;
                *(unsigned char *)(v200 + 24) = 1;
                *(void *)(v199 + 48) = 0;
                *(void *)(v199 + 56) = 0;
                if (!v201 || !*v201) {
                  break;
                }
              }
              v198 += 104;
              ++v197;
              if (!--v196) {
                goto LABEL_304;
              }
            }
            v255 = "Unexpected value for Max Subchunk length in Subchunk Digest, V3";
          }
          else
          {
LABEL_304:
            if (!mmcs_index_set_create(&v325))
            {
              char v202 = 1;
              v308 = "mmcs_index_set_create";
              uint64_t v228 = 37;
LABEL_393:
              unint64_t v30 = v306;
              goto LABEL_394;
            }
            unint64_t v203 = *((void *)v192 + 7);
            if (!v203)
            {
LABEL_330:
              uint64_t v224 = mmcs_index_set_count(v325);
              unint64_t v30 = v306;
              if (v224 == *(void *)(*((void *)v311 + 1) + 144)
                && mmcs_index_set_contains_range(v325, 0, (int)v224 - 1))
              {
                uint64_t v225 = *(void *)(*((void *)v311 + 1) + 144);
                if (v225)
                {
                  uint64_t v226 = 0;
                  v227 = (uint64_t *)(*(void *)(*v316 + 272) + 56);
                  do
                  {
                    v308 = 0;
                    uint64_t v228 = 0;
                    char v202 = 0;
                    *(v227 - 3) = v226;
                    uint64_t v229 = *v227;
                    v227 += 13;
                    v226 += *(unsigned int *)(v229 + 4);
                    --v225;
                  }
                  while (v225);
                }
                else
                {
                  v308 = 0;
                  uint64_t v228 = 0;
                  char v202 = 0;
                }
              }
              else
              {
                char v202 = 1;
                v308 = "Check Set Failure";
                uint64_t v228 = 45;
              }
LABEL_394:
              if (v325) {
                C3BaseRelease((CFTypeRef)v325);
              }
              uint64_t v288 = v228;
              uint64_t v48 = v298;
              if (v202) {
                goto LABEL_221;
              }
              goto LABEL_340;
            }
            unint64_t v204 = 0;
            while (1)
            {
              v205 = v192;
              uint64_t v206 = *(void *)(*((void *)v192 + 8) + 8 * v204);
              uint64_t v207 = **(unsigned int **)(v206 + 32);
              if (!v207)
              {
                char v202 = 1;
                v255 = "Chunk Length Cannot Have Zero Bytes";
                goto LABEL_392;
              }
              unint64_t v208 = *(void *)(v206 + 40);
              if (v208) {
                break;
              }
LABEL_329:
              ++v204;
              v192 = v205;
              if (v204 >= v203) {
                goto LABEL_330;
              }
            }
            unint64_t v281 = v204;
            uint64_t v285 = v206;
            unint64_t v209 = 0;
            while (1)
            {
              v210 = *(int **)(*(void *)(v206 + 48) + 8 * v209);
              if (!v210[7]) {
                break;
              }
              int v211 = v210[8];
              if (v211 >= 1) {
                goto LABEL_314;
              }
LABEL_327:
              if (++v209 >= v208)
              {
                unint64_t v203 = v205[7];
                unint64_t v204 = v281;
                goto LABEL_329;
              }
            }
            int v211 = 1;
LABEL_314:
            v291 = (void *)v209;
            uint64_t v212 = v210[6];
            uint64_t v213 = v212 + v211;
            uint64_t v214 = 104 * (int)v212 + 56;
            while (1)
            {
              uint64_t v215 = *(void *)(*v316 + 272);
              mmcs_index_set_add_index(v325, v212);
              if (gMMCS_DebugLevel >= 4 && v207 != *(_DWORD *)(*(void *)(v215 + v214) + 4))
              {
                v216 = mmcs_file_signature_to_hexstring(**((char ***)v311 + 1));
                v217 = mmcs_chunk_signature_to_hexstring(*(char **)(*(void *)(v215 + v214) + 8));
                v218 = mmcs_logging_logger_chunk();
                if (os_log_type_enabled(v218, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v219 = *((void *)v311 + 1);
                  uint64_t v220 = *(void *)(v219 + 40);
                  CFStringRef v221 = *(const __CFString **)(v219 + 144);
                  uint64_t v222 = *(unsigned int *)(*(void *)(v215 + v214) + 4);
                  *(_DWORD *)long long buf = 134219522;
                  *(void *)&uint8_t buf[4] = v220;
                  __int16 v327 = 2082;
                  v328 = v216;
                  __int16 v329 = 2048;
                  CFStringRef v330 = (CFStringRef)(v212 + 1);
                  __int16 v331 = 2048;
                  CFStringRef v332 = v221;
                  __int16 v333 = 2082;
                  v334 = v217;
                  __int16 v335 = 2048;
                  uint64_t v336 = v222;
                  __int16 v337 = 2048;
                  uint64_t v338 = v207;
                  _os_log_impl(&dword_1DC1CA000, v218, OS_LOG_TYPE_DEFAULT, "Item %lld with file signature %{public}s updated chunk %llu of %llu with chunk signature %{public}s updated instance length from %llu to %llu", buf, 0x48u);
                }
                if (v216) {
                  free(v216);
                }
                unint64_t v32 = v286;
                unint64_t v37 = v320;
                if (v217) {
                  free(v217);
                }
              }
              uint64_t v223 = *(void *)(v215 + v214);
              *(_DWORD *)(v223 + 4) = v207;
              *(unsigned char *)(v223 + 64) = 1;
              if (*(void *)(v223 + 32))
              {
                if (CKSubchunkBlobSize() != *(void *)(*(void *)(v215 + v214) + 40)) {
                  break;
                }
              }
              ++v212;
              v214 += 104;
              if (v212 >= v213)
              {
                uint64_t v206 = v285;
                unint64_t v208 = *(void *)(v285 + 40);
                unint64_t v209 = (unint64_t)v291;
                goto LABEL_327;
              }
            }
            char v202 = 1;
            v255 = "Unexpected Number of Bytes for Subchunk Digest, V3";
          }
        }
        else
        {
          char v202 = 1;
          v255 = "Unexpected Number of Chunks";
        }
LABEL_392:
        v308 = v255;
        uint64_t v228 = 45;
        goto LABEL_393;
      }
      uint64_t v288 = 45;
      v241 = "Unexpected Number of Chunks";
    }
    else
    {
      uint64_t v288 = 44;
      v241 = "Unsupported Version";
    }
    v308 = v241;
    goto LABEL_221;
  }
  unint64_t v32 = v286;
  if (!*((void *)v107 + 5))
  {
    uint64_t v288 = 45;
    v308 = "Unexpected Number of Chunk Groups";
    goto LABEL_221;
  }
  uint64_t v108 = a1[11];
  CFDataRef v109 = XCFDataCreateWithBytesNoCopy(allocator, *((const UInt8 **)v107 + 4), *((void *)v107 + 3), v278);
  *((void *)v107 + 3) = 0;
  *((void *)v107 + 4) = 0;
  if (!*(void *)(*v316 + 400)) {
    mmcs_item_set_file_verification_key(*v316, v109);
  }
  if (v109) {
    CFRelease(v109);
  }
  v284 = (char ***)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)v108 + 104), (const void *)*v316);
  if (!v284) {
    mmcs_get_container_process_data_cold_3();
  }
  unint64_t v110 = *((void *)v107 + 5);
  if (v110)
  {
    CFStringRef v111 = 0;
    int v277 = 0;
    uint64_t v112 = 0;
    v276 = v107;
    while (1)
    {
      long long v113 = *(void **)(*((void *)v107 + 6) + 8 * (void)v111);
      if (v113[3] != 4) {
        break;
      }
      uint64_t v114 = *(unsigned int *)v113[4];
      if (!v114)
      {
        uint64_t v288 = 45;
        v256 = "Chunk Length Cannot Have Zero Bytes";
        goto LABEL_400;
      }
      if (v113[5])
      {
        unint64_t v115 = 0;
        CFStringRef v280 = (const __CFString *)((char *)&v111->isa + 1);
        uint64_t v116 = 104 * v277;
        v310 = v113;
        while (1)
        {
          uint64_t v117 = *(void *)(*v316 + 272);
          uint64_t v118 = *(void *)(v113[6] + 8 * v115);
          uint64_t v119 = v117 + v116;
          uint64_t v120 = *(void *)(v117 + v116 + 56);
          if (!*(void *)(v120 + 16))
          {
            *(void *)(v120 + 16) = *(void *)(v118 + 32);
            *(void *)(v118 + 32) = 0;
          }
          if (gMMCS_DebugLevel >= 4 && (v114 != *(_DWORD *)(v120 + 4) || v112 != *(void *)(v117 + v116 + 32)))
          {
            v290 = mmcs_file_signature_to_hexstring(*v284[1]);
            long long v121 = mmcs_chunk_signature_to_hexstring(*(char **)(*(void *)(v119 + 56) + 8));
            long long v122 = mmcs_logging_logger_chunk();
            if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
            {
              long long v123 = v284[1];
              uint64_t v124 = v123[5];
              CFStringRef v125 = (const __CFString *)v123[18];
              uint64_t v126 = *(unsigned int *)(*(void *)(v119 + 56) + 4);
              uint64_t v127 = *(void *)(v117 + v116 + 32);
              *(_DWORD *)long long buf = 134220034;
              *(void *)&uint8_t buf[4] = v124;
              __int16 v327 = 2082;
              v328 = v290;
              __int16 v329 = 2048;
              CFStringRef v330 = v280;
              __int16 v331 = 2048;
              CFStringRef v332 = v125;
              __int16 v333 = 2082;
              v334 = v121;
              __int16 v335 = 2048;
              uint64_t v336 = v126;
              __int16 v337 = 2048;
              uint64_t v338 = v114;
              __int16 v339 = 2048;
              uint64_t v340 = v127;
              __int16 v341 = 2048;
              uint64_t v342 = v112;
              _os_log_impl(&dword_1DC1CA000, v122, OS_LOG_TYPE_DEFAULT, "Item %lld with file signature %{public}s updated chunk %llu of %llu with chunk signature %{public}s updated instance length from %llu to %llu and offset from %llu to %llu", buf, 0x5Cu);
            }
            if (v290) {
              free(v290);
            }
            long long v113 = v310;
            if (v121)
            {
              free(v121);
              long long v113 = v310;
            }
          }
          uint64_t v128 = *(void *)(v119 + 56);
          *(_DWORD *)(v128 + 4) = v114;
          *(unsigned char *)(v128 + 64) = 1;
          *(void *)(v117 + v116 + 32) = v112;
          uint64_t v129 = v114;
          unint64_t v37 = v320;
          if (*(_DWORD *)(v118 + 40))
          {
            *(void *)(v128 + 40) = *(void *)(v118 + 48);
            os_activity_scope_state_s v130 = *(unsigned char **)(v118 + 56);
            *(void *)(v128 + 32) = v130;
            *(unsigned char *)(v128 + 24) = 1;
            *(void *)(v118 + 48) = 0;
            *(void *)(v118 + 56) = 0;
            if (!v130)
            {
              uint64_t v288 = 45;
              v308 = "Unexpected value for Max Subchunk length in Subchunk Digest, V2";
              unint64_t v30 = v306;
LABEL_219:
              unint64_t v32 = v286;
LABEL_220:
              uint64_t v48 = v298;
LABEL_221:
              opaque__file_reference_data__free_unpacked(v48, 0);
              int v104 = 0;
LABEL_222:
              uint64_t v142 = cf;
LABEL_223:
              CFRelease(v142);
              goto LABEL_224;
            }
            unint64_t v32 = v286;
            if (!*v130)
            {
              uint64_t v288 = 45;
              v256 = "Unexpected value for Max Subchunk length in Subchunk Digest, V2";
              goto LABEL_400;
            }
            uint64_t v131 = CKSubchunkBlobSize();
            uint64_t v132 = *(void *)(v119 + 56);
            if (v131 != *(void *)(v132 + 40))
            {
              uint64_t v288 = 45;
              v256 = "Unexpected Number of Bytes for Subchunk Digest, V2";
              goto LABEL_400;
            }
            uint64_t v129 = *(unsigned int *)(v132 + 4);
            long long v113 = v310;
          }
          v112 += v129;
          ++v115;
          v116 += 104;
          if (v115 >= v113[5])
          {
            v277 += v115;
            long long v107 = v276;
            unint64_t v110 = v276[5];
            unint64_t v32 = v286;
            CFStringRef v111 = v280;
            goto LABEL_181;
          }
        }
      }
      CFStringRef v111 = (const __CFString *)((char *)v111 + 1);
LABEL_181:
      if ((unint64_t)v111 >= v110)
      {
        v308 = 0;
        uint64_t v288 = 0;
        unint64_t v30 = v306;
        goto LABEL_339;
      }
    }
    uint64_t v288 = 45;
    v256 = "Unexpected Number of Bytes for Chunk Length";
LABEL_400:
    v308 = v256;
    unint64_t v30 = v306;
    goto LABEL_220;
  }
  v308 = 0;
  uint64_t v288 = 0;
LABEL_339:
  uint64_t v48 = v298;
LABEL_340:
  CFMutableDictionaryRef v230 = CFDictionaryCreateMutable(allocator, (CFIndex)v48[6], 0, MEMORY[0x1E4F1D540]);
  v232 = key;
  v231 = v298;
  v233 = v230;
  int v234 = *((unsigned __int8 *)key + 216);
  CFIndex v235 = (CFIndex)v298[6];
  if (!*((unsigned char *)key + 216))
  {
    v237 = 0;
    goto LABEL_344;
  }
  if (v235)
  {
    CFMutableArrayRef v236 = CFArrayCreateMutable(0, v235, &kAssignArrayCallBacks);
    v232 = key;
    v231 = v298;
    v237 = v236;
    CFIndex v235 = (CFIndex)v298[6];
LABEL_344:
    if (v235)
    {
      unint64_t v238 = 0;
      v239 = 0;
      do
      {
        uint64_t v325 = 0;
        *(void *)long long buf = 0;
        if (!mmcs_RangedItem_copyFileVerificationKey_copyItemLength(*((CFDataRef *)v231[7] + v238), buf, &v325))
        {
          int v104 = 0;
          uint64_t v288 = 45;
          v308 = "Ranged Item Missing Required Fields";
          goto LABEL_403;
        }
        v239 += v325;
        CFDictionarySetValue(v233, v239, *(const void **)buf);
        if (v237)
        {
          RangedItem = mmcs_create_RangedItem(*(const __CFData **)buf, v325);
          CFArrayAppendValue(v237, RangedItem);
        }
        if (*(void *)buf) {
          CFRelease(*(CFTypeRef *)buf);
        }
        ++v238;
        v231 = v298;
      }
      while (v238 < (unint64_t)v298[6]);
      unint64_t v37 = v320;
      v232 = key;
    }
  }
  else
  {
    v237 = 0;
  }
  if (v232[50])
  {
    v242 = CFDictionaryGetValue(v233, (const void *)(v232[48] + v232[47]));
    if (!v242)
    {
      int v104 = 0;
      uint64_t v288 = 40;
      v308 = "Ranged Item Not Found with Requested Offset and Length";
      goto LABEL_404;
    }
    mmcs_item_set_file_verification_key((uint64_t)v232, v242);
  }
  v243 = CFDictionaryGetValue(*(CFDictionaryRef *)(*v301 + 104), v232);
  v244 = v243;
  if (v234)
  {
    if (v237) {
      key[15] = v237;
    }
    mmcs_get_file_complete_metadata_only_file((uint64_t)v243);
    v237 = 0;
  }
  mmcs_get_state_initialize_duplicate_file_states(*v301, v244, (uint64_t *)&v324);
  if (v324)
  {
    int v104 = 0;
    goto LABEL_404;
  }
  CFArrayRef v245 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(*(void *)*v301 + 304) + 64), key);
  if (!v245 || (v246 = v245, CFIndex Count = CFArrayGetCount(v245), Count < 1))
  {
    int v104 = 1;
    goto LABEL_404;
  }
  CFIndex v248 = Count;
  CFIndex v249 = 0;
  while (2)
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v246, v249);
    if (ValueAtIndex == key)
    {
LABEL_374:
      if (v248 == ++v249)
      {
        int v104 = 1;
        goto LABEL_402;
      }
      continue;
    }
    break;
  }
  uint64_t v251 = (uint64_t)ValueAtIndex;
  mmcs_item_copy_ford_state_from_item(ValueAtIndex, (uint64_t)key);
  if (!key[50])
  {
LABEL_372:
    if (*(unsigned char *)(v251 + 216))
    {
      v253 = CFDictionaryGetValue(*(CFDictionaryRef *)(*v301 + 104), (const void *)v251);
      mmcs_get_file_complete_metadata_only_file((uint64_t)v253);
    }
    goto LABEL_374;
  }
  v252 = CFDictionaryGetValue(v233, (const void *)(*(void *)(v251 + 384) + *(void *)(v251 + 376)));
  if (v252)
  {
    mmcs_item_set_file_verification_key(v251, v252);
    goto LABEL_372;
  }
  int v104 = 0;
  uint64_t v288 = 40;
  v308 = "Duplicate Ranged Item Not Found with Requested Offset and Length";
LABEL_402:
  unint64_t v32 = v286;
LABEL_403:
  unint64_t v37 = v320;
LABEL_404:
  opaque__file_reference_data__free_unpacked(v298, 0);
  if (v233) {
    CFRelease(v233);
  }
  CFRelease(cf);
  uint64_t v142 = v237;
  if (v237) {
    goto LABEL_223;
  }
LABEL_224:
  long long v105 = v324;
  uint64_t v31 = v303;
  if (v324)
  {
LABEL_225:
    CFRetain(v105);
    int v104 = 0;
    uint64_t v143 = v324;
    CFErrorRef v144 = (CFErrorRef)v324;
    goto LABEL_246;
  }
  CFIndex v106 = v288;
  if (!v308)
  {
LABEL_229:
    CFErrorRef v144 = 0;
    goto LABEL_245;
  }
LABEL_227:
  unint64_t v145 = v30;
  long long v146 = mmcs_file_signature_to_hexstring(*(char **)*v316);
  CFDataRef v147 = *(const __CFData **)(*v316 + 48);
  if (v147) {
    CFStringRef StringDescription = XCFDataCreateStringDescription(v147);
  }
  else {
    CFStringRef StringDescription = @"(null reference)";
  }
  CFStringRef v149 = mmcs_get_container_copy_simple_description((uint64_t)a1);
  uint64_t v150 = *(void *)(v279 + 16);
  if (v150)
  {
    uint64_t v151 = mmcs_http_context_get_request_message(v150);
    uint64_t v152 = *(void *)(v279 + 16);
    v300 = (__CFHTTPMessage *)v151;
    if (v152)
    {
      v153 = (__CFHTTPMessage *)mmcs_http_context_get_response_message(v152);
      goto LABEL_236;
    }
  }
  else
  {
    v300 = 0;
  }
  v153 = 0;
LABEL_236:
  v154 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v154, OS_LOG_TYPE_FAULT))
  {
    uint64_t v155 = v301[11];
    CFIndex v156 = v106;
    uint64_t v157 = *(void *)(v314 + 104 * v145 + 32);
    int v158 = mmcs_chunk_instance_get_length(v312);
    *(_DWORD *)long long buf = 136447746;
    *(void *)&uint8_t buf[4] = v308;
    __int16 v327 = 2082;
    v328 = v146;
    __int16 v329 = 2114;
    CFStringRef v330 = StringDescription;
    __int16 v331 = 2114;
    CFStringRef v332 = v149;
    __int16 v333 = 2048;
    v334 = (unsigned char *)v155;
    __int16 v335 = 2048;
    uint64_t v336 = v157;
    CFIndex v106 = v156;
    __int16 v337 = 1024;
    LODWORD(v338) = v158;
    _os_log_impl(&dword_1DC1CA000, v154, OS_LOG_TYPE_FAULT, "FORD failed (%{public}s) for file %{public}s with reference %{public}@ in container %{public}@ at element index %lu at offset %llu length %u (relative to the container's range)", buf, 0x44u);
  }
  mmcs_chunk_instance_get_length(v312);
  CFErrorRef v144 = mmcs_cferror_create_with_request_response_and_format(@"com.apple.mmcs", v106, v300, v153, 0, @"FORD failed (%s) for file %s with reference %@ in container %@ at element index %lu at offset %llu length %u (relative to the container's range)", v159, v160, (char)v308);
  if (v146) {
    free(v146);
  }
  uint64_t v31 = v303;
  unint64_t v32 = v286;
  if (StringDescription) {
    CFRelease(StringDescription);
  }
  if (v149) {
    CFRelease(v149);
  }
  int v104 = 0;
  unint64_t v37 = v320;
LABEL_245:
  uint64_t v143 = v324;
LABEL_246:
  CFErrorRef error = v144;
  if (v143) {
    CFRelease(v143);
  }
  if (v104)
  {
LABEL_249:
    v161 = *(void **)(*v316 + 120);
    if (v161) {
      mmcs_engine_cache_ranged_items(*(void *)(**(void **)v20 + 32), *(void **)(*v316 + 40), v161);
    }
    uint64_t v34 = v312;
    uint64_t v33 = v314;
    goto LABEL_252;
  }
LABEL_437:
  int v293 = 0;
LABEL_26:
  unsigned __int8 v28 = v293;
  if (!a6 || v293)
  {
    if (v293)
    {
      unint64_t v257 = *(void *)(v20 + 88);
      unint64_t v258 = *(void *)(v20 + 48);
      *(void *)(v20 + 104) += v318;
      if (v257 < v258 && v305 && mmcs_request_is_container_resumable_limp_mode(**(void **)v20))
      {
        unsigned __int8 v28 = 0;
        if (a6) {
          *a6 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Simulate a container failure after making some resumable progress.", v259, v260, v261, v262, v263, v275);
        }
        return v28;
      }
    }
    goto LABEL_418;
  }
  CFRetain(error);
  CFErrorRef v29 = error;
  *a6 = error;
  if (!error) {
    return v28;
  }
LABEL_419:
  CFRelease(v29);
  return v28;
}

uint64_t mmcs_get_container_schedule(uint64_t a1, uint64_t a2)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = _os_activity_create(&dword_1DC1CA000, "mmcs-get-schedule", *(os_activity_t *)(a1 + 80), OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v4, &state);
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t v6 = 0;
  if (!mmcs_container_check_expired((void *)a1, a2, (uint64_t)"get", *(void *)(v5 + 16)))
  {
    uint64_t v7 = *(uint64_t **)v5;
    if (*(void *)v5)
    {
      uint64_t v8 = *v7;
      if (*v7)
      {
        uint64_t v9 = mmcs_chunk_instance_offset(*v7);
        if (v9)
        {
          uint64_t v10 = v9;
          if (*(double *)(a2 + 56) == 0.0)
          {
            uint64_t v11 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"enqueueTime should be defined for get request");
              uint64_t v13 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v12;
                _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v12) {
                CFRelease(v12);
              }
            }
          }
          uint64_t v61 = 0;
          CFDataRef v45 = @"getContainer";
          long long v46 = *(_OWORD *)(*(void *)(a2 + 24) + 16);
          double network_timeout_period = mmcs_request_get_network_timeout_period(v8);
          if (mmcs_request_is_background(v8)) {
            uint64_t v14 = *(void *)(*(void *)(a2 + 24) + 40);
          }
          else {
            uint64_t v14 = 0;
          }
          uint64_t v48 = v14;
          uint64_t v49 = -1;
          uint64_t v51 = 0;
          uint64_t v52 = 0;
          uint64_t body_size = mmcs_get_container_get_body_size(a1);
          CFDataRef v53 = handle_container_request_will_retry_after_error;
          uint64_t v54 = handle_response_downloadChunks;
          unint64_t v55 = handle_callback_downloadContainer;
          uint64_t v56 = 0;
          uint64_t v57 = mmcs_container_xmitcallback;
          uint64_t v58 = a2;
          uint64_t sparse_block_size = mmcs_engine_get_sparse_block_size();
          uint64_t v60 = mmcs_engine_owner(v10);
          LOBYTE(v61) = 1;
          uint64_t v62 = *(void *)(a2 + 56);
          uint64_t v63 = v4;
          *(_OWORD *)CFDataRef cf = 0u;
          long long v44 = 0u;
          mmcs_read_stream_pool_parameters_make_pool(*(void *)(v10 + 40), cf);
          unint64_t v21 = (uint64_t *)(a2 + 16);
          unsigned int http_class = mmcs_request_get_http_class(v8);
          int v23 = mmcs_http_context_create((void *)(a2 + 16), http_class, (uint64_t)&v45);
          if (v23)
          {
            mmcs_http_context_set_to_mobileme(*(void *)(a2 + 16), 0);
            mmcs_http_context_extract_vendor_name_from_message_and_create_pool_parameters(*(void *)(a2 + 16), *(void *)(v10 + 40), (uint64_t)buf);
            *(_OWORD *)CFDataRef cf = *(_OWORD *)buf;
            long long v44 = v66;
            uint64_t v24 = *(void *)(*(void *)(a2 + 24) + 24);
            if (mmcs_get_req_context_get_current_request_metrics(v8))
            {
              uint64_t v25 = *(void *)(*(void *)(a2 + 64) + 88);
              uint64_t v26 = *(const char **)(v25 + 16);
              CFStringRef v27 = v26 ? CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v26, 0x8000100u) : 0;
              mmcs_transaction_make_req_context_metrics((__CFArray *)a2, **(void **)v25, v24, @"getContainer", v27);
              if (v27) {
                CFRelease(v27);
              }
            }
            mmcs_http_context_update_voucher(*v21);
            mmcs_http_context_uuid_hash_code(*v21);
            kdebug_trace();
            int v28 = mmcs_http_context_send(*v21, (uint64_t)cf, *(void *)(v10 + 56));
          }
          else
          {
            int v28 = 0;
          }
          if (cf[1]) {
            CFRelease(cf[1]);
          }
          if (v23)
          {
            if (v28)
            {
              uint64_t v6 = 1;
              if (!v4) {
                goto LABEL_28;
              }
              goto LABEL_27;
            }
            CFStringRef v39 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v40 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unable to send http message");
              CFStringRef v41 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v40;
                _os_log_impl(&dword_1DC1CA000, v41, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v40) {
                CFRelease(v40);
              }
            }
            CFStringRef v37 = @"Unable to send http request";
            CFIndex v38 = 1;
          }
          else
          {
            CFErrorRef v29 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v35 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unable to create http context");
              uint64_t v36 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v35;
                _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v35) {
                CFRelease(v35);
              }
            }
            CFStringRef v37 = @"Unable to create http context";
            CFIndex v38 = 37;
          }
          uint64_t v16 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v38, v37, v30, v31, v32, v33, v34, v42);
          setErrorAndFailContainer(a1, v16);
          if (!v16) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }
        uint64_t v19 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
LABEL_25:
          uint64_t v6 = 0;
          goto LABEL_26;
        }
        uint64_t v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null engine backref in container %p", a1);
        uint64_t v17 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
LABEL_23:
          if (v16)
          {
LABEL_24:
            CFRelease(v16);
            goto LABEL_25;
          }
          goto LABEL_25;
        }
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v16;
      }
      else
      {
        CFStringRef v18 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          goto LABEL_25;
        }
        uint64_t v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null get request backref in container %p", a1);
        uint64_t v17 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          goto LABEL_23;
        }
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v16;
      }
    }
    else
    {
      CFStringRef v15 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      uint64_t v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null get state backref in container %p", a1);
      uint64_t v17 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v16;
    }
    _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    goto LABEL_23;
  }
LABEL_26:
  if (v4) {
LABEL_27:
  }
    os_release(v4);
LABEL_28:
  os_activity_scope_leave(&state);
  return v6;
}

void setErrorAndFailContainer(uint64_t a1, const void *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    mmcs_container_set_error((void *)a1, a2);
  }
  else
  {
    uint64_t v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"There should always be an error set here for container %p", a1);
      uint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v7 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  mmcs_get_state_fail_container(**(CFDictionaryRef ***)(a1 + 88), (void *)a1);
}

uint64_t mmcs_get_container_add_method_completion_info(uint64_t a1, uint64_t a2)
{
  unsigned int reporting_level = mmcs_request_get_reporting_level(***(void ***)(a1 + 88));
  method_completion_info = mmcs_get_complete_create_method_completion_info(a1, a2, reporting_level, 1);
  return mmcs_transaction_add_method_completion_info(a2, method_completion_info);
}

void mmcs_get_container_failed_to_schedule_transaction(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 68) = 4;
  uint64_t v1 = ***(void ***)(a1 + 88);
  if (!mmcs_get_req_has_outstanding_asynchronous_work(v1))
  {
    uint64_t v2 = *(void *)(v1 + 304);
    if (!*(void *)(v2 + 24) && !*(void *)(v2 + 32))
    {
      uint64_t v3 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        int v4 = 134217984;
        uint64_t v5 = v1;
        _os_log_impl(&dword_1DC1CA000, v3, OS_LOG_TYPE_INFO, "Downloads complete. All done! (Get request %p)", (uint8_t *)&v4, 0xCu);
      }
      mmcs_get_req_context_cleanup(v1, 0);
    }
  }
}

uint64_t mmcs_get_container_retry(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (mmcs_transaction_is_proxy(a2))
  {
    int v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"caching server failed; retrying with vendor");
      uint64_t v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
  }
  CFStringRef v7 = **(uint64_t ***)(a1 + 88);
  if (v7) {
    uint64_t v8 = *v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *(void *)(a2 + 16);
  if (v10) {
    mmcs_http_context_invalidate(v10);
  }
  _mmcs_get_container_reset_for_retry((void *)a1, a2);
  uint64_t v11 = *(const void **)(a2 + 16);
  if (v11) {
    C3BaseRelease(v11);
  }
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a1 + 68) = 3;
  *(_DWORD *)(v9 + 48) = 2;
  *(CFAbsoluteTime *)(v9 + 56) = CFAbsoluteTimeGetCurrent();
  uint64_t v12 = mmcs_http_request_options_network_behavior_type(*(void *)(*(void *)(v9 + 24) + 24));
  uint64_t v13 = mmcs_request_type_for_behavior_and_activity(v12, 1);
  mmcs_container_requirements(a1);
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = v9;
  uint64_t v17 = v13;
  uint64_t discretionary_network_behavior = mmcs_http_request_options_get_discretionary_network_behavior(v8);
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v25 = mmcs_container_schedule_request_callback;
  uint64_t v26 = mmcs_container_cancel_request_callback;
  CFStringRef v27 = C3BaseRetain;
  int v28 = C3BaseRelease;
  uint64_t v14 = mmcs_chunk_instance_offset(v8);
  mmcs_request_queue_enqueue_request(*(void *)(v14 + 48), (uint64_t)&buf, *(double *)(v9 + 56));
  return 1;
}

double _mmcs_get_container_reset_for_retry(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[11];
  mmcs_container_remember_error((uint64_t)a1, a2);
  mmcs_container_reset_error_for_retry((uint64_t)a1);
  int v4 = *(_DWORD *)(a1[11] + 176);
  if (v4 == 1)
  {
    unint64_t v10 = *(void *)(v3 + 88);
    if (v10 < *(void *)(v3 + 48))
    {
      uint64_t v11 = *(void *)(v3 + 96);
      if (v11 >= 1)
      {
        uint64_t v12 = *(void *)(*(void *)(v3 + 120) + 104 * v10 + 56);
        if (v11 >= (unint64_t)*(unsigned int *)(v12 + 4)) {
          uint64_t v13 = *(unsigned int *)(v12 + 4);
        }
        else {
          uint64_t v13 = *(void *)(v3 + 96);
        }
        mmcs_get_state_unprocess_chunk_data(*(void *)v3, a1, v12, v13);
      }
    }
  }
  else if (v4 == 2)
  {
    unint64_t v5 = *(void *)(v3 + 48);
    if (v5)
    {
      unint64_t v6 = 0;
      uint64_t v7 = 88;
      do
      {
        uint64_t v8 = *(void *)(v3 + 120);
        uint64_t v9 = *(const void **)(v8 + v7);
        if (v9)
        {
          CFRelease(v9);
          unint64_t v5 = *(void *)(v3 + 48);
        }
        *(void *)(v8 + v7) = 0;
        ++v6;
        v7 += 104;
      }
      while (v6 < v5);
    }
  }
  uint64_t v14 = *(const void **)(v3 + 112);
  if (v14) {
    C3BaseRelease(v14);
  }
  double result = 0.0;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_OWORD *)(v3 + 104) = 0u;
  *(void *)(v3 + 128) = *(void *)(*(void *)(v3 + 120) + 32);
  *(void *)(v3 + 136) = 0;
  return result;
}

uint64_t mmcs_get_container_will_retry(void *a1, uint64_t a2)
{
  return 1;
}

void mmcs_get_container_finalize(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 88);
  void *v1 = 0;
  uint64_t v2 = (void *)v1[2];
  if (v2) {
    free(v2);
  }
  v1[2] = 0;
  uint64_t v3 = (void *)v1[3];
  if (v3) {
    free(v3);
  }
  v1[3] = 0;
  int v4 = (const void *)v1[1];
  if (v4) {
    CFRelease(v4);
  }
  v1[1] = 0;
  unint64_t v5 = (const void *)v1[14];
  if (v5) {
    C3BaseRelease(v5);
  }
  v1[14] = 0;
  unint64_t v6 = (const void *)v1[18];
  if (v6) {
    C3BaseRelease(v6);
  }
  v1[18] = 0;
  uint64_t v7 = (const void *)v1[19];
  if (v7) {
    C3BaseRelease(v7);
  }
  v1[19] = 0;
  uint64_t v8 = (const void *)v1[20];
  if (v8) {
    C3BaseRelease(v8);
  }
  v1[20] = 0;
  uint64_t v9 = (void *)v1[15];
  if (v9)
  {
    if (!v1[5]) {
      goto LABEL_20;
    }
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      mmcs_chunk_instance_finalize((void *)(v1[15] + v10));
      ++v11;
      v10 += 104;
    }
    while (v11 < v1[5]);
    uint64_t v9 = (void *)v1[15];
    if (v9) {
LABEL_20:
    }
      free(v9);
    v1[15] = 0;
  }
  _OWORD v1[5] = 0;
  v1[6] = 0;
  uint64_t v12 = (void *)v1[9];
  if (v12) {
    free(v12);
  }
  v1[9] = 0;
  uint64_t v13 = (const void *)v1[23];
  if (v13)
  {
    C3BaseRelease(v13);
    v1[23] = 0;
  }
}

void mmcs_get_container_cancel_transaction(void *a1, unsigned int *a2, __CFError *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2[12] == 2)
  {
    unint64_t v6 = (uint64_t **)a1[11];
    uint64_t v7 = mmcs_chunk_instance_offset(**v6);
    mmcs_transaction_cancel_enqueued(a2, *(void *)(v7 + 48), (uint64_t)a3);
    if (a1[5]) {
      uint64_t v8 = (__CFError *)a1[5];
    }
    else {
      uint64_t v8 = a3;
    }
    setErrorAndFailContainer((uint64_t)a1, v8);
    if (!mmcs_get_req_has_outstanding_asynchronous_work(**v6))
    {
      uint64_t v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        uint64_t v10 = **v6;
        int v11 = 134217984;
        uint64_t v12 = v10;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_INFO, "Downloads complete. All done! (Get request %p)", (uint8_t *)&v11, 0xCu);
      }
      mmcs_get_req_context_cleanup(**v6, 0);
    }
  }
  else
  {
    mmcs_transaction_cancel_not_enqueued((uint64_t)a2, a3);
    mmcs_container_set_error(a1, a3);
  }
}

double mmcs_time_convert_server_time_to_cfabsolutetime(unint64_t a1)
{
  return (double)a1 / 1000.0 + -978307200.0;
}

unint64_t mmcs_time_convert_cfabsolutetime_to_server_time(double a1)
{
  return (unint64_t)((a1 + 978307200.0) * 1000.0);
}

CFAbsoluteTime mmcs_time_convert_date_header_to_cfabsolutetime(const __CFString *a1)
{
  if (!a1) {
    return 0.0;
  }
  CFAbsoluteTime atp = 0.0;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFLocaleRef v3 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"en_US");
  if (!v3) {
    return 0.0;
  }
  CFLocaleRef v4 = v3;
  CFDateFormatterRef v5 = CFDateFormatterCreate(v2, v3, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
  if (v5)
  {
    unint64_t v6 = v5;
    CFTimeZoneRef v7 = CFTimeZoneCreateWithTimeIntervalFromGMT(v2, 0.0);
    if (v7)
    {
      CFTimeZoneRef v8 = v7;
      CFDateFormatterSetProperty(v6, (CFStringRef)*MEMORY[0x1E4F1D0F8], v7);
      uint64_t v9 = 0;
      while (1)
      {
        CFDateFormatterSetFormat(v6, off_1E6C33828[v9]);
        if (CFDateFormatterGetAbsoluteTimeFromString(v6, a1, 0, &atp)) {
          break;
        }
        if (++v9 == 3)
        {
          CFAbsoluteTime atp = 0.0;
          break;
        }
      }
      CFRelease(v8);
    }
    CFRelease(v6);
  }
  CFRelease(v4);
  return atp;
}

void sub_1DC1ED594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_activity_scope_state_s state)
{
}

void sub_1DC1ED900(_Unwind_Exception *exception_object)
{
}

void sub_1DC1EDCA0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void HttpContextPerformBlockAsync(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = mmcs_nshttp_copy_perform_target([v3 hc]);
  if (!v5)
  {
    uint64_t v9 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      HttpContextPerformBlockAsync_cold_1(v3);
    }
    __assert_rtn("HttpContextPerformBlockAsync", "MMCSHTTPContext.m", 54, "performTarget");
  }
  unint64_t v6 = (const void *)v5;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = __HttpContextPerformBlockAsync_block_invoke;
  v10[3] = &unk_1E6C33910;
  id v11 = v3;
  id v12 = v4;
  id v7 = v4;
  id v8 = v3;
  mmcs_perform_target_async((uint64_t)v6, (uint64_t)v10);
  C3BaseRelease(v6);
}

void sub_1DC1EDFBC(_Unwind_Exception *exception_object)
{
}

void sub_1DC1EE1CC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void appendTrailers(uint64_t a1, uint64_t a2)
{
  mmcs_nshttp_get_http_context(a1);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  id v3 = [v4 inputStream];
  [v3 setProperty:a2 forKey:*MEMORY[0x1E4F1CCC8]];
}

void sub_1DC1EEFB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

void sub_1DC1EF360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,os_activity_scope_state_s state)
{
}

void sub_1DC1EF894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,os_activity_scope_state_s state)
{
}

void sub_1DC1EFF34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,os_activity_scope_state_s state)
{
}

void sub_1DC1F04BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
}

void HttpContextPerformBlockSync(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = dispatch_semaphore_create(0);
  uint64_t v6 = mmcs_nshttp_copy_perform_target([v3 hc]);
  if (!v6)
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      HttpContextPerformBlockAsync_cold_1(v3);
    }
    __assert_rtn("HttpContextPerformBlockSync", "MMCSHTTPContext.m", 72, "performTarget");
  }
  id v7 = (const void *)v6;
  dispatch_retain(v5);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = __HttpContextPerformBlockSync_block_invoke;
  v11[3] = &unk_1E6C33960;
  id v12 = v3;
  id v13 = v4;
  uint64_t v14 = v5;
  id v8 = v4;
  id v9 = v3;
  mmcs_perform_target_async((uint64_t)v7, (uint64_t)v11);
  C3BaseRelease(v7);
  dispatch_semaphore_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v5);
}

void sub_1DC1F0BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,os_activity_scope_state_s state)
{
}

void sub_1DC1F1348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,os_activity_scope_state_s state)
{
}

void sub_1DC1F1A40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,os_activity_scope_state_s state)
{
  objc_sync_exit(v21);
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void __HttpContextPerformBlockAsync_block_invoke(uint64_t a1)
{
  if (*(void *)([*(id *)(a1 + 32) hc] + 592)) {
    os_retain(*(void **)([*(id *)(a1 + 32) hc] + 592));
  }
  [*(id *)(a1 + 32) hc];
  voucher_adopt();
  CFAllocatorRef v2 = (void *)MEMORY[0x1E019B260]();
  objc_msgSend(MEMORY[0x1E4F50D38], "annotateCallstackForContainerType:block:", objc_msgSend(*(id *)(a1 + 32), "containerType"), *(void *)(a1 + 40));
  id v3 = (void *)voucher_adopt();
  if (v3)
  {
    os_release(v3);
  }
}

void __HttpContextPerformBlockSync_block_invoke(uint64_t a1)
{
  if (*(void *)([*(id *)(a1 + 32) hc] + 592)) {
    os_retain(*(void **)([*(id *)(a1 + 32) hc] + 592));
  }
  [*(id *)(a1 + 32) hc];
  voucher_adopt();
  CFAllocatorRef v2 = (void *)MEMORY[0x1E019B260]();
  objc_msgSend(MEMORY[0x1E4F50D38], "annotateCallstackForContainerType:block:", objc_msgSend(*(id *)(a1 + 32), "containerType"), *(void *)(a1 + 40));
  id v3 = (void *)voucher_adopt();
  if (v3) {
    os_release(v3);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
  id v4 = *(NSObject **)(a1 + 48);
  dispatch_release(v4);
}

void OUTLINED_FUNCTION_0_0(void *a1, int a2, int a3, const char *a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
  _os_log_impl(a1, v13, OS_LOG_TYPE_ERROR, a4, &buf, 0xCu);
}

uint64_t mmcs_perform_dispatch_target_create(uint64_t *a1, const void *a2)
{
  uint64_t v7 = 0;
  uint64_t result = mmcs_perform_target_create(&v7, 2, 8);
  if (result)
  {
    uint64_t v5 = v7;
    if (v7)
    {
      uint64_t v6 = *(void **)(v7 + 24);
      C3BaseRetain(a2);
      *uint64_t v6 = a2;
      *a1 = v5;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void mmcs_perform_dispatch_target_finalize(uint64_t a1)
{
  uint64_t v1 = *(dispatch_object_t **)(a1 + 24);
  if (*v1)
  {
    dispatch_release(*v1);
    dispatch_object_t *v1 = 0;
  }
}

void mmcs_perform_dispatch_target_async(uint64_t a1, void *a2)
{
}

void mmcs_perform_dispatch_target_stream_schedule(int a1, CFTypeRef cf)
{
  CFTypeID v2 = CFGetTypeID(cf);
  if (v2 == CFReadStreamGetTypeID())
  {
    JUMPOUT(0x1E019A1A0);
  }
  if (v2 == CFWriteStreamGetTypeID())
  {
    JUMPOUT(0x1E019A6D0);
  }
  id v3 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl(&dword_1DC1CA000, v3, OS_LOG_TYPE_ERROR, "Unknown stream type. Failed to schedule request", v4, 2u);
  }
}

void mmcs_perform_dispatch_target_stream_unschedule(int a1, CFTypeRef cf)
{
  CFTypeID v2 = CFGetTypeID(cf);
  if (v2 == CFReadStreamGetTypeID())
  {
    JUMPOUT(0x1E019A1A0);
  }
  if (v2 == CFWriteStreamGetTypeID())
  {
    JUMPOUT(0x1E019A6D0);
  }
  id v3 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl(&dword_1DC1CA000, v3, OS_LOG_TYPE_ERROR, "Unknown stream type. Failed to unschedule request", v4, 2u);
  }
}

uint64_t mmcs_perform_dispatch_target_create_source(uint64_t a1, void **a2, _OWORD *a3)
{
  id v3 = *(NSObject ***)(a1 + 24);
  if (!v3) {
    mmcs_perform_dispatch_target_create_source_cold_1();
  }
  id v4 = *v3;
  long long v5 = a3[1];
  v7[0] = *a3;
  v7[1] = v5;
  return mmcs_perform_dispatch_source_create(a2, v7, v4);
}

uint64_t mmcs_perform_dispatch_target_create_timer(uint64_t a1, CFTypeRef *a2, _OWORD *a3)
{
  id v3 = *(NSObject ***)(a1 + 24);
  if (!v3) {
    mmcs_perform_dispatch_target_create_timer_cold_1();
  }
  id v4 = *v3;
  long long v5 = a3[1];
  v7[0] = *a3;
  v7[1] = v5;
  return mmcs_perform_dispatch_timer_create(a2, v7, v4);
}

void mmcs_get_file_close_temp_reader_writer(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3)
  {
    MMCSItemReaderWriterEnsureClosed(v3);
    id v4 = *(const void **)(a1 + 24);
    if (v4) {
      C3BaseRelease(v4);
    }
    *(void *)(a1 + 24) = 0;
  }
  double v5 = CFAbsoluteTimeGetCurrent() - Current;
  if (v5 > 0.25)
  {
    uint64_t v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = 134217984;
      double v8 = v5;
      _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "Close of item took %.3f seconds", (uint8_t *)&v7, 0xCu);
    }
  }
}

void mmcs_get_file_finalize(void *a1)
{
  if (*a1)
  {
    *a1 = 0;
    a1[1] = 0;
  }
  uint64_t v3 = a1 + 4;
  CFTypeID v2 = (void *)a1[4];
  if (v2) {
    free(v2);
  }
  *uint64_t v3 = 0;
  a1[5] = 0;
  mmcs_get_file_close_temp_reader_writer((uint64_t)a1);
  id v4 = (void *)a1[2];
  if (v4) {
    free(v4);
  }
  a1[2] = 0;
  double v5 = (const void *)a1[6];
  if (v5) {
    CFRelease(v5);
  }
  a1[6] = 0;
  uint64_t v6 = (const void *)a1[7];
  if (v6) {
    CFRelease(v6);
  }
  a1[7] = 0;
  int v7 = (const void *)a1[15];
  if (v7) {
    C3BaseRelease(v7);
  }
  a1[15] = 0;
}

uint64_t mmcs_get_file_init(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 115) = 0;
  *(unsigned char *)(a1 + 113) = a4;
  *(unsigned char *)(a1 + 114) = a5;
  return 1;
}

CFStringRef mmcs_get_file_copy_description(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<file_state %p>", a1);
}

uint64_t mmcs_get_file_process_chunk_reference_with_padding(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, CFTypeRef *a6)
{
  int is_outstanding_chunk_reference = mmcs_item_is_outstanding_chunk_reference(*(void *)(a1 + 8), (const void *)a2);
  uint64_t result = 1;
  if (is_outstanding_chunk_reference)
  {
    context[0] = a1;
    context[1] = a3;
    context[2] = a4;
    context[3] = a5;
    uint64_t v18 = 1;
    p_CFTypeRef cf = &cf;
    CFTypeRef cf = 0;
    uint64_t v14 = *(void *)(a2 + 48);
    if (v14) {
      mmcs_get_file_process_chunk_instance_with_padding(v14, (uint64_t)context);
    }
    CFSetRef v15 = *(const __CFSet **)(a2 + 56);
    if (v15) {
      CFSetApplyFunction(v15, (CFSetApplierFunction)mmcs_get_file_process_chunk_instance_with_padding, context);
    }
    mmcs_item_update_get_progress(*(void *)(a1 + 8), a5);
    if (mmcs_chunk_instance_get_length(*(CFDataRef **)(a2 + 48)) == a5 + a3)
    {
      mmcs_item_remove_outstanding_chunk_reference(*(void *)(a1 + 8), (const void *)a2);
      mmcs_get_state_decrement_outstanding_chunk_references_count(*(CFMutableDictionaryRef **)a1, (const void *)a2);
    }
    CFTypeRef v16 = cf;
    if (a6 && !(_BYTE)v18 && cf)
    {
      CFRetain(cf);
      CFTypeRef v16 = cf;
      *a6 = cf;
    }
    if (v16) {
      CFRelease(v16);
    }
    return v18;
  }
  return result;
}

void mmcs_get_file_process_chunk_instance_with_padding(uint64_t a1, uint64_t a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!mmcs_chunk_instance_is_chunk_reference((_DWORD *)a1)) {
    mmcs_get_file_process_chunk_instance_with_padding_cold_1();
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(void *)(*(void *)a2 + 8) == v4
    && CFBooleanGetValue(*(CFBooleanRef *)(a1 + 72))
    && *(unsigned char *)(a2 + 32)
    && mmcs_item_is_outstanding_chunk_reference(v4, *(const void **)(a1 + 56)))
  {
    unint64_t v41 = 0;
    CFTypeRef cf = 0;
    mmcs_chunk_instance_offset(***(void ***)a2);
    uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 56) + 4) - *(void *)(a2 + 8);
    uint64_t v6 = v5 & ~(v5 >> 63);
    if (v6 >= *(void *)(a2 + 24)) {
      int64_t v7 = *(void *)(a2 + 24);
    }
    else {
      int64_t v7 = v6;
    }
    if (mmcs_get_file_ensure_temp_file_is_open_with_length_check(*(void *)a2, &cf, -1))
    {
      if (v7 <= 0)
      {
        unint64_t v11 = 0;
        unint64_t v41 = 0;
      }
      else
      {
        uint64_t v8 = *(void *)(*(void *)a2 + 24);
        uint64_t v9 = (uint64_t **)(*(void *)a2 + 120);
        uint64_t v10 = mmcs_chunk_instance_offset(a1);
        if (!MMCSItemReaderWriterWrite(v8, v9, *(void *)(a2 + 8) + v10, *(void *)(a2 + 16), v7, &v41, &cf))
        {
          if (cf)
          {
LABEL_25:
            long long v22 = mmcs_cferror_copy_description((__CFError *)cf);
            long long v23 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v24 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@", v22);
              uint64_t v25 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                CFStringRef v44 = v24;
                _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v24) {
                CFRelease(v24);
              }
            }
            if (v22) {
              CFRelease(v22);
            }
            uint64_t v26 = *(void **)(a2 + 40);
            if (v26 && !*v26)
            {
              CFRetain(cf);
              **(void **)(a2 + 40) = cf;
            }
            *(unsigned char *)(a2 + 32) = 0;
LABEL_36:
            if (cf) {
              CFRelease(cf);
            }
            return;
          }
          CFStringRef v17 = mmcs_chunk_instance_copy_description(a1);
          CFErrorRef v21 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"Unknown error occurred for %@", v27, v28, v29, v30, v31, (char)v17);
LABEL_23:
          CFTypeRef cf = v21;
          if (v17) {
            CFRelease(v17);
          }
          goto LABEL_25;
        }
        unint64_t v11 = v41;
      }
      if (v11 == v7)
      {
        if (mmcs_chunk_instance_get_length((CFDataRef *)a1) != *(_DWORD *)(a2 + 24) + *(_DWORD *)(a2 + 8)) {
          goto LABEL_36;
        }
        uint64_t RegisteredChunk = (void *)mmcs_chunk_instance_create_RegisteredChunk();
        CKRegisteredChunkSetRowID();
        if (*(unsigned char *)(*(void *)a2 + 113) && (CKRelocateTemporaryChunk() & 1) == 0)
        {
          CFStringRef v32 = mmcs_chunk_instance_copy_description(a1);
          CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 20, @"Unable to register chunk instance %@", v33, v34, v35, v36, v37, (char)v32);
          if (v32) {
            CFRelease(v32);
          }
          char v20 = 1;
        }
        else
        {
          char v20 = 0;
        }
        uint64_t v38 = *(void *)(*(void *)a2 + 24);
        uint64_t v39 = mmcs_chunk_instance_offset(a1);
        MMCSItemReaderWriterValidated(v38, 2, v39, *(unsigned int *)(*(void *)(a1 + 56) + 4), 0);
        if (RegisteredChunk) {
          free(RegisteredChunk);
        }
        if ((v20 & 1) == 0) {
          goto LABEL_36;
        }
        goto LABEL_25;
      }
      CFStringRef v17 = mmcs_chunk_instance_copy_description(a1);
      LOBYTE(v40) = (_BYTE)v17;
      CFStringRef v18 = @"Unable to write all chunk data for %@: %lu read %lu written";
    }
    else
    {
      CFStringRef v17 = mmcs_chunk_instance_copy_description(a1);
      uint64_t v40 = *(void *)(*(void *)a2 + 24);
      CFStringRef v18 = @"TempReaderWriter (%p) not open for %@";
    }
    CFErrorRef v21 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 11, v18, v12, v13, v14, v15, v16, v40);
    goto LABEL_23;
  }
}

void mmcs_get_file_unprocess_chunk_reference(uint64_t a1, void *a2, uint64_t a3)
{
  if (mmcs_item_is_outstanding_chunk_reference(*(void *)(a1 + 8), a2))
  {
    v8[0] = a1;
    v8[1] = a3;
    uint64_t v6 = a2[6];
    if (v6) {
      mmcs_get_file_unprocess_chunk_instance(v6, v8);
    }
    CFSetRef v7 = (const __CFSet *)a2[7];
    if (v7) {
      CFSetApplyFunction(v7, (CFSetApplierFunction)mmcs_get_file_unprocess_chunk_instance, v8);
    }
  }
}

void mmcs_get_file_unprocess_chunk_instance(uint64_t a1, void *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!mmcs_chunk_instance_is_chunk_reference((_DWORD *)a1)) {
    mmcs_get_file_unprocess_chunk_instance_cold_1();
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(void *)(*a2 + 8) == v4)
  {
    if (mmcs_item_is_outstanding_chunk_reference(*(void *)(a1 + 8), *(const void **)(a1 + 56)))
    {
      uint64_t v8 = a2[1];
      mmcs_item_update_get_unprogress(v4, v8);
    }
  }
  else
  {
    uint64_t v5 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"skipping chunk instance for now");
      CFSetRef v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        int v9 = 138543362;
        CFStringRef v10 = v6;
        _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&v9, 0xCu);
      }
      if (v6) {
        CFRelease(v6);
      }
    }
  }
}

uint64_t mmcs_get_file_process_derivative_buffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int a5, const void *a6, CFTypeRef *a7)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  unint64_t v32 = 0;
  CFTypeRef cf = 0;
  if (!mmcs_get_file_ensure_temp_file_is_open_with_length_check(a1, &cf, -1))
  {
    uint64_t v31 = *(void *)(a1 + 24);
    CFStringRef v21 = @"TempReaderWriter (%p) not open";
LABEL_6:
    CFIndex v22 = 11;
LABEL_7:
    long long v23 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v22, v21, v14, v15, v16, v17, v18, v31);
    CFTypeRef cf = v23;
    goto LABEL_8;
  }
  uint64_t v19 = MMCSItemReaderWriterWrite(*(void *)(a1 + 24), (uint64_t **)(a1 + 120), a2, a3, a4, &v32, &cf);
  if (v19)
  {
    uint64_t v20 = v19;
    if (v32 == a4) {
      goto LABEL_18;
    }
    LOBYTE(v31) = a4;
    CFStringRef v21 = @"Unable to write all deriviative data: %lu read %lu written";
    goto LABEL_6;
  }
  long long v23 = (void *)cf;
  if (!cf)
  {
    CFStringRef v21 = @"Unknown error occurred";
    CFIndex v22 = 39;
    goto LABEL_7;
  }
LABEL_8:
  CFStringRef v24 = mmcs_cferror_copy_description((__CFError *)v23);
  uint64_t v25 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@", v24);
    uint64_t v27 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v35 = v26;
      _os_log_impl(&dword_1DC1CA000, v27, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v26) {
      CFRelease(v26);
    }
  }
  if (v24) {
    CFRelease(v24);
  }
  if (!a7 || *a7)
  {
    uint64_t v20 = 0;
LABEL_18:
    CFTypeRef v28 = cf;
    if (!cf) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  CFRetain(cf);
  uint64_t v20 = 0;
  CFTypeRef v28 = cf;
  *a7 = cf;
  if (v28) {
LABEL_19:
  }
    CFRelease(v28);
LABEL_20:
  if (v20) {
    mmcs_item_update_get_derivative_progress(*(void *)(a1 + 8), a4);
  }
  if (a5 && !*(unsigned char *)(a1 + 115))
  {
    mmcs_get_request_notify_item_with_pending_progress(**(void **)a1, *(void *)(a1 + 8));
    uint64_t v29 = *(void *)(a1 + 8);
    *(void *)(v29 + 16) = a4 + a2;
    *(void *)(v29 + 24) = a4 + a2;
    mmcs_item_set_derivative_digest_results_for_file_validation(v29, a6);
    mmcs_get_file_candidate_completed_with_success(a1);
  }
  return v20;
}

void mmcs_get_file_candidate_completed_with_success(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **(void **)a1;
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  request_activity_marker = mmcs_request_get_request_activity_marker(v2);
  os_activity_scope_enter(request_activity_marker, &state);
  if (*(unsigned char *)(a1 + 115)) {
    goto LABEL_41;
  }
  uint64_t v4 = *(void *)(a1 + 120);
  if (v4)
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 16);
    if (v5 <= 0) {
      mmcs_get_file_candidate_completed_with_success_cold_2();
    }
    if (*(void *)(v4 + 32) < (unint64_t)v5)
    {
      *(void *)long long buf = 0;
      if (!mmcs_get_file_ensure_temp_file_is_open_with_length_check(a1, buf, -1))
      {
LABEL_32:
        CFErrorRef error = *(CFErrorRef *)buf;
        if (*(void *)buf) {
          goto LABEL_37;
        }
        uint64_t v11 = @"An unknown error occurred while opening the item reader writer.";
        goto LABEL_36;
      }
      if (!MMCSItemReaderWriterSeek(*(void *)(a1 + 24), *(void *)(a1 + 120), *(void *)(*(void *)(a1 + 8) + 16), (CFErrorRef *)buf))
      {
        CFErrorRef error = *(CFErrorRef *)buf;
        if (*(void *)buf) {
          goto LABEL_37;
        }
        uint64_t v11 = @"An unknown error occurred while seeking the item reader writer.";
        goto LABEL_36;
      }
    }
    CFStringRef v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      BOOL file_sparse_context_contains_zero_filled_block = mmcs_get_file_sparse_context_contains_zero_filled_block(*(void **)(a1 + 120));
      uint64_t v8 = "Sparse";
      if (!file_sparse_context_contains_zero_filled_block) {
        uint64_t v8 = "Dense";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEFAULT, "Sparse Aware Output Produced %s File.", buf, 0xCu);
    }
  }
  int v9 = (uint64_t *)(a1 + 8);
  if (mmcs_item_is_metadata_only(*(void *)(a1 + 8))) {
    goto LABEL_12;
  }
  if (CFSetGetCount(*(CFSetRef *)(*v9 + 280)) >= 1) {
    mmcs_get_file_candidate_completed_with_success_cold_1(a1 + 8);
  }
  *(void *)long long buf = 0;
  if (!mmcs_get_file_ensure_temp_file_is_open_with_length_check(a1, buf, -1)) {
    goto LABEL_32;
  }
  if (MMCSItemReaderWriterSync(*(void *)(a1 + 24), (CFErrorRef *)buf))
  {
LABEL_12:
    *(unsigned char *)(a1 + 115) = 1;
    ++*(void *)(*(void *)a1 + 24);
    if (mmcs_item_is_metadata_only(*(void *)(a1 + 8))
      || mmcs_item_has_requested_length_at_file_offset(*v9) && !*(void *)(*v9 + 400)
      || !*(unsigned char *)(a1 + 114))
    {
      mmcs_get_file_finalize_file_after_validation((uint64_t **)a1);
    }
    else
    {
      uint64_t v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        uint64_t v13 = *(void *)(*v9 + 40);
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v13;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_INFO, "item %llu being validated", buf, 0xCu);
      }
      if (mmcs_get_request_is_validation_queue_empty(v2))
      {
        if (*(void *)(a1 + 24))
        {
          if (gMMCS_DebugLevel >= 5)
          {
            uint64_t v14 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"leaving temp file for item %llu open for reuse", *(void *)(*v9 + 40));
              uint64_t v16 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v15;
                _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
              }
              if (v15) {
                CFRelease(v15);
              }
            }
          }
        }
      }
      else
      {
        mmcs_get_file_close_temp_reader_writer(a1);
      }
      mmcs_get_req_validate_get_file(v2, (void *)a1);
    }
    goto LABEL_41;
  }
  CFErrorRef error = *(CFErrorRef *)buf;
  if (!*(void *)buf)
  {
    uint64_t v11 = @"An unknown error occurred while syncing the item reader writer.";
LABEL_36:
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 39, v11);
    *(void *)long long buf = error;
  }
LABEL_37:
  mmcs_get_file_completed_with_error(a1, (uint64_t)error);
  if (*(void *)buf) {
    CFRelease(*(CFTypeRef *)buf);
  }
LABEL_41:
  os_activity_scope_leave(&state);
}

uint64_t mmcs_get_file_abort_writing_file(uint64_t **a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  uint64_t v3 = mmcs_chunk_instance_offset(v2);
  if (!mmcs_get_req_context_use_reader_writer_callback(**a1))
  {
    if (!*(unsigned char *)(v3 + 170) || mmcs_get_request_get_failed_to_preallocate(v2) && *((unsigned char *)a1 + 112))
    {
      uint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
      {
        CFStringRef v6 = a1[2];
        *(_DWORD *)long long buf = 136315138;
        CFStringRef v16 = (CFStringRef)v6;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_INFO, "Unlinking %s due to abort", buf, 0xCu);
      }
      mmcs_get_file_close_temp_reader_writer((uint64_t)a1);
      CFSetRef v7 = (const char *)a1[2];
      if (v7)
      {
        unlink(v7);
        uint64_t v8 = a1[2];
        if (v8) {
          free(v8);
        }
      }
      a1[2] = 0;
      CKUnregisterTemporaryChunks();
      CKUnregisterFile();
      mmcs_engine_force_commit((void *)v3);
      int v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        uint64_t v10 = a1[1][5];
        *(_DWORD *)long long buf = 134217984;
        CFStringRef v16 = (CFStringRef)v10;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_INFO, "Committed unregister of partially downloaded item %lld and its temporary chunks", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Leaving partial results for item %lld in chunk store and file %s", a1[1][5], a1[2]);
        uint64_t v13 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v16 = v12;
          _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v12) {
          CFRelease(v12);
        }
      }
      mmcs_get_file_close_temp_reader_writer((uint64_t)a1);
      uint64_t v14 = a1[2];
      if (v14) {
        free(v14);
      }
      a1[2] = 0;
    }
  }
  return 1;
}

void mmcs_get_file_completed_with_error(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 115))
  {
    uint64_t v4 = **(void **)a1;
    if (CFSetGetCount(*(CFSetRef *)(*(void *)(a1 + 8) + 280)) >= 1)
    {
      uint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Decrementing outstanding chunk references due to item %lld completing.", *(void *)(*(void *)(a1 + 8) + 40));
        CFSetRef v7 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v14 = v6;
          _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
        }
        if (v6) {
          CFRelease(v6);
        }
      }
      CFSetApplyFunction(*(CFSetRef *)(*(void *)(a1 + 8) + 280), (CFSetApplierFunction)mmcs_get_file_decrement_outstanding_chunk_references_count, *(void **)a1);
      mmcs_item_remove_all_outstanding_chunk_reference(*(void *)(a1 + 8));
    }
    *(unsigned char *)(a1 + 115) = 1;
    ++*(void *)(*(void *)a1 + 24);
    uint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Completed download of file for item %lld", *(void *)(*(void *)(a1 + 8) + 40));
      uint64_t v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v14 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    uint64_t v11 = *(uint64_t **)(a1 + 8);
    mmcs_get_file_abort_writing_file((uint64_t **)a1);
    mmcs_get_item_progress_make_done_error(a2, v12);
    mmcs_get_request_set_progress_and_notify_item(v4, v11, v12);
  }
}

void mmcs_get_file_decrement_outstanding_chunk_references_count(const void *a1, CFMutableDictionaryRef *a2)
{
}

void mmcs_get_file_metadata_completed_with_error(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 115))
  {
    uint64_t v4 = **(void **)a1;
    if (CFSetGetCount(*(CFSetRef *)(*(void *)(a1 + 8) + 280)) >= 1 && gMMCS_DebugLevel >= 5)
    {
      CFStringRef v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"outstanding chunk references is not empty! %@", *(void *)(*(void *)(a1 + 8) + 280));
        uint64_t v8 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v15 = v7;
          _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v7) {
          CFRelease(v7);
        }
      }
    }
    *(unsigned char *)(a1 + 115) = 1;
    ++*(void *)(*(void *)a1 + 24);
    CFStringRef v9 = *(uint64_t **)(a1 + 8);
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Completed download of metadata for item %lld with error %@", v9[5], a2);
      CFStringRef v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v15 = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
    mmcs_get_item_progress_make_done_error(a2, v13);
    mmcs_get_request_set_progress_and_notify_item(v4, v9, v13);
  }
}

void mmcs_get_file_finalize_file_after_validation(uint64_t **a1)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **a1;
  uint64_t v3 = mmcs_chunk_instance_offset(v2);
  uint64_t v4 = a1[1];
  mmcs_get_file_close_temp_reader_writer((uint64_t)a1);
  bzero(__str, 0x400uLL);
  if (mmcs_get_req_context_use_reader_writer_callback(v2)
    || mmcs_item_is_metadata_only((uint64_t)a1[1]))
  {
LABEL_19:
    if (*((unsigned char *)a1 + 113))
    {
      if ((CKConvertTemporaryChunks() & 1) == 0)
      {
        CFIndex v22 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to convert temporary chunks for item %lld", v4[5]);
          CFStringRef v24 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v49 = v23;
            _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v23) {
            CFRelease(v23);
          }
        }
      }
    }
    uint64_t v25 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = v4[5];
      *(_DWORD *)long long buf = 134217984;
      CFStringRef v49 = (CFStringRef)v26;
      _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_DEFAULT, "itemId %llu completed", buf, 0xCu);
    }
    if (mmcs_get_req_context_use_reader_writer_callback(v2)) {
      uint64_t v27 = 0;
    }
    else {
      uint64_t v27 = __str;
    }
    mmcs_get_req_item_set_done_success_and_notify_item(v2, v4, (uint64_t)v27);
    return;
  }
  uint64_t v5 = (const char *)a1[2];
  if (!v5) {
    mmcs_get_file_finalize_file_after_validation_cold_1();
  }
  if (gMMCS_DebugLevel >= 4)
  {
    int is_apple_file_system = mmcs_engine_is_apple_file_system(v3);
    uint64_t v5 = (const char *)a1[2];
    if (is_apple_file_system)
    {
      uint64_t v46 = 0;
      CFStringRef v47 = 0;
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      int v7 = mmcs_file_extents(v5, (off_t *)&v47, &v46, &v45, &v44);
      uint64_t v8 = mmcs_logging_logger_default();
      CFStringRef v9 = v8;
      if (v7)
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v10 = "Error retrieving file extent information.";
          CFStringRef v11 = v9;
          os_log_type_t v12 = OS_LOG_TYPE_ERROR;
          uint32_t v13 = 2;
LABEL_11:
          _os_log_impl(&dword_1DC1CA000, v11, v12, v10, buf, v13);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = a1[1][5];
        *(_DWORD *)long long buf = 134219008;
        CFStringRef v49 = (CFStringRef)v14;
        __int16 v50 = 2048;
        uint64_t v51 = v47;
        __int16 v52 = 2048;
        uint64_t v53 = v46;
        __int16 v54 = 2048;
        uint64_t v55 = v45;
        __int16 v56 = 2048;
        uint64_t v57 = v44;
        uint64_t v10 = "itemId %llu had %llu bytes in %llu blocks represented by blocks of width %llu bytes and %llu extents.";
        CFStringRef v11 = v9;
        os_log_type_t v12 = OS_LOG_TYPE_DEFAULT;
        uint32_t v13 = 52;
        goto LABEL_11;
      }
      uint64_t v5 = (const char *)a1[2];
    }
  }
  CFStringRef v15 = ub_dirname_alloced(v5);
  if (v15)
  {
    uint64_t v16 = v15;
    snprintf((char *)__str, 0x400uLL, "%s/new-0x%016llx", v15, v4[5]);
    free(v16);
  }
  else
  {
    __strlcpy_chk();
    __strlcat_chk();
  }
  uint64_t v17 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = a1[2];
    uint64_t v20 = v4[5];
    *(_DWORD *)long long buf = 136315650;
    CFStringRef v49 = (CFStringRef)v19;
    __int16 v50 = 2080;
    uint64_t v51 = __str;
    __int16 v52 = 2048;
    uint64_t v53 = v20;
    _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_DEFAULT, "Renaming %s to %s for item %lld", buf, 0x20u);
  }
  rename((const std::__fs::filesystem::path *)a1[2], __str, v18);
  if (v21 != -1) {
    goto LABEL_19;
  }
  CFIndex v28 = *__error();
  uint64_t v29 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v31 = a1[2];
    unint64_t v32 = strerror(v28);
    CFStringRef v33 = CFStringCreateWithFormat(v30, 0, @"Failed to rename %s to %s: %s", v31, __str, v32);
    uint64_t v34 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v49 = v33;
      _os_log_impl(&dword_1DC1CA000, v34, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v33) {
      CFRelease(v33);
    }
  }
  CFStringRef v35 = a1[2];
  strerror(v28);
  CFErrorRef file_error_with_format = mmcs_cferror_create_file_error_with_format(v28, @"Failed to rename %s to %s: %s(%d)", v36, v37, v38, v39, v40, v41, (char)v35);
  mmcs_get_file_abort_writing_file(a1);
  mmcs_get_item_progress_make_done_error((uint64_t)file_error_with_format, v43);
  mmcs_get_request_set_progress_and_notify_item(v2, v4, v43);
  if (file_error_with_format) {
    CFRelease(file_error_with_format);
  }
}

uint64_t mmcs_get_file_ensure_temp_file_is_open(uint64_t a1, void *a2)
{
  return mmcs_get_file_ensure_temp_file_is_open_with_length_check(a1, a2, -1);
}

CFIndex mmcs_get_file_has_outstanding_chunks(uint64_t a1)
{
  return mmcs_item_has_outstanding_chunk_references(*(void *)(a1 + 8));
}

uint64_t mmcs_get_file_ensure_temp_file_is_open_with_length_check(uint64_t a1, void *a2, off_t a3)
{
  uint64_t v133 = *MEMORY[0x1E4F143B8];
  if (a2) {
    *a2 = 0;
  }
  CFStringRef v6 = (void *)(a1 + 24);
  if (*(void *)(a1 + 24)) {
    return 1;
  }
  uint64_t v8 = **(void **)a1;
  uint64_t v9 = mmcs_chunk_instance_offset(v8);
  if ((mmcs_get_req_context_use_reader_writer_callback(**(void **)a1) != 0) != (*(void *)(a1 + 16) == 0)) {
    mmcs_get_file_ensure_temp_file_is_open_with_length_check_cold_1();
  }
  if (!mmcs_get_req_context_use_reader_writer_callback(**(void **)a1))
  {
    int v15 = access(*(const char **)(a1 + 16), 0);
    memset(&cf, 0, sizeof(cf));
    uint64_t v16 = open(*(const char **)(a1 + 16), 514, 384);
    CFTypeRef v130 = 0;
    if ((v16 & 0x80000000) != 0)
    {
      CFIndex v33 = *__error();
      uint64_t v34 = mmcs_logging_logger_default();
      BOOL v35 = os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
      uint64_t v36 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
      if (v35)
      {
        CFStringRef v37 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to open/create file path %s for item %lld", *(void *)(a1 + 16), *(void *)(*(void *)(a1 + 8) + 40));
        uint64_t v38 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          buf.st_dev = 138543362;
          *(void *)&buf.st_mode = v37;
          _os_log_impl(&dword_1DC1CA000, v38, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v37) {
          CFRelease(v37);
        }
      }
      if (!a2) {
        return 0;
      }
      CFMutableStringRef Mutable = CFStringCreateMutable(*v36, 0);
      uint64_t v40 = ub_dirname_alloced(*(const char **)(a1 + 16));
      if (v40)
      {
        uint64_t v41 = v40;
        while (1)
        {
          if (CFStringGetLength(Mutable) >= 1) {
            CFStringAppend(Mutable, @"\n");
          }
          memset(&buf, 0, sizeof(buf));
          if (stat(v41, &buf) == -1)
          {
            uint64_t v43 = __error();
            uint64_t v44 = *v43;
            uint64_t v119 = strerror(*v43);
            CFStringAppendFormat(Mutable, 0, @"stat (%s) failed: %s (%d)", v41, v119, v44);
          }
          else
          {
            char v42 = (buf.st_mode & 0xF000) == 0x4000 ? "isDir" : "isNotDir";
            CFStringAppendFormat(Mutable, 0, @"stat (%s) %s", v41, v42, v120);
          }
          if (!strcmp("/", v41)) {
            break;
          }
          uint64_t v45 = ub_dirname_alloced(v41);
          free(v41);
          uint64_t v41 = v45;
          if (!v45) {
            goto LABEL_89;
          }
        }
        free(v41);
      }
LABEL_89:
      uint64_t v64 = *(void *)(a1 + 16);
      strerror(v33);
      *a2 = mmcs_cferror_create_file_error_with_format(v33, @"Unable to open file path %s for item %lld: %s\n%@\n", v65, v66, v67, v68, v69, v70, v64);
      if (!Mutable) {
        return 0;
      }
      CFErrorRef v14 = (CFErrorRef)Mutable;
      goto LABEL_22;
    }
    uint64_t v17 = v16;
    if (fstat(v16, &cf))
    {
      CFIndex v18 = *__error();
      uint64_t v19 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to get stat file path %s for item %lld", *(void *)(a1 + 16), *(void *)(*(void *)(a1 + 8) + 40));
        int v21 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          buf.st_dev = 138543362;
          *(void *)&buf.st_mode = v20;
          _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v20) {
          CFRelease(v20);
        }
      }
      uint64_t v22 = *(void *)(a1 + 16);
      strerror(v18);
      CFErrorRef file_error_with_format = mmcs_cferror_create_file_error_with_format(v18, @"Unable to stat file path %s for item %lld: %s", v23, v24, v25, v26, v27, v28, v22);
      CFAllocatorRef v30 = *(uint64_t **)a1;
      uint64_t v31 = *(uint64_t **)(a1 + 8);
      uint64_t v32 = *v30;
      mmcs_get_item_progress_make_done_error((uint64_t)file_error_with_format, v129);
      mmcs_get_request_set_progress_and_notify_item(v32, v31, v129);
      if (a2) {
        *a2 = CFRetain(file_error_with_format);
      }
      if (file_error_with_format) {
        CFRelease(file_error_with_format);
      }
      close(v17);
      return 0;
    }
    BOOL is_derivative = mmcs_item_is_derivative(*(void *)(a1 + 8));
    if ((a3 & 0x8000000000000000) == 0 || !is_derivative)
    {
      if (a3 < 0) {
        a3 = *(void *)(*(void *)(a1 + 8) + 16);
      }
      if (cf.st_size > a3)
      {
        CFStringRef v47 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          uint64_t v48 = *(void *)(a1 + 8);
          uint64_t v49 = *(void *)(v48 + 40);
          uint64_t v50 = *(void *)(v48 + 16);
          buf.st_dev = 134218496;
          *(void *)&buf.st_mode = v49;
          WORD2(buf.st_ino) = 2048;
          *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = cf.st_size;
          HIWORD(buf.st_gid) = 2048;
          *(void *)&buf.st_rdev = v50;
          _os_log_impl(&dword_1DC1CA000, v47, OS_LOG_TYPE_ERROR, "Truncating oversized temp file %llu of %llu bytes to %llu bytes", (uint8_t *)&buf, 0x20u);
        }
        if (ftruncate(v17, *(void *)(*(void *)(a1 + 8) + 16)) == -1)
        {
          int v51 = *__error();
          __int16 v52 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            uint64_t v53 = strerror(v51);
            buf.st_dev = 136315138;
            *(void *)&buf.st_mode = v53;
            _os_log_impl(&dword_1DC1CA000, v52, OS_LOG_TYPE_ERROR, "Failed to truncate temp file with error %s", (uint8_t *)&buf, 0xCu);
          }
        }
      }
    }
    if (mmcs_item_get_default_reader_writer_sparse_aware(*(void *)(a1 + 8))) {
      uint64_t sparse_block_size = mmcs_engine_get_sparse_block_size();
    }
    else {
      uint64_t sparse_block_size = 0;
    }
    if (v15
      && !sparse_block_size
      && mmcs_engine_is_apple_file_system(v9)
      && !mmcs_item_is_derivative(*(void *)(a1 + 8))
      && !mmcs_item_has_requested_length_at_file_offset(*(void *)(a1 + 8)))
    {
      int BOOLean_from_cfpreferences_object_for_key = mmcs_get_BOOLean_from_cfpreferences_object_for_key(@"UsePreallocate", 1);
      BOOL v72 = mmcs_logging_logger_default();
      BOOL v73 = os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT);
      if (BOOLean_from_cfpreferences_object_for_key)
      {
        if (v73)
        {
          uint64_t v74 = *(void *)(a1 + 8);
          uint64_t v75 = *(void *)(v74 + 16);
          __darwin_ino64_t v76 = *(void *)(v74 + 40);
          buf.st_dev = 134218240;
          *(void *)&buf.st_mode = v75;
          WORD2(buf.st_ino) = 2048;
          *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = v76;
          _os_log_impl(&dword_1DC1CA000, v72, OS_LOG_TYPE_DEFAULT, "Preallocating %llu bytes for itemId %llu,", (uint8_t *)&buf, 0x16u);
        }
        *(unsigned char *)(a1 + 112) = 1;
        double Current = CFAbsoluteTimeGetCurrent();
        uint64_t v78 = *(void *)(a1 + 8);
        uint64_t v80 = *(void *)(v78 + 16);
        unint64_t v79 = (void *)(v78 + 16);
        if (v80 < 1)
        {
          uint64_t v81 = 0;
          uint64_t v83 = 0;
        }
        else
        {
          uint64_t v81 = 0;
          uint64_t v82 = 1;
          while (1)
          {
            uint64_t v83 = v82;
            uint64_t v127 = 0;
            uint64_t v128 = 0;
            v126[0] = 0x30000000ALL;
            uint64_t v84 = *v79 - v81;
            v126[1] = 0;
            uint64_t v127 = v84;
            if (fcntl(v17, 42, v126) == -1)
            {
              int v90 = *__error();
              __errnum = mmcs_logging_logger_default();
              if (!os_log_type_enabled(__errnum, OS_LOG_TYPE_ERROR)) {
                goto LABEL_108;
              }
              uint64_t v91 = *(void *)(a1 + 8);
              uint64_t v121 = *(void *)(v91 + 40);
              __darwin_ino64_t v122 = *(void *)(v91 + 16);
              uint64_t v123 = v127;
              unint64_t v92 = strerror(v90);
              buf.st_dev = 134219010;
              *(void *)&buf.st_mode = v121;
              WORD2(buf.st_ino) = 2048;
              *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = v122;
              HIWORD(buf.st_gid) = 2048;
              unint64_t v93 = __errnum;
              *(void *)&buf.st_rdev = v123;
              LOWORD(buf.st_atimespec.tv_sec) = 1024;
              *(_DWORD *)((char *)&buf.st_atimespec.tv_sec + 2) = v90;
              HIWORD(buf.st_atimespec.tv_sec) = 2080;
              buf.st_atimespec.tv_nsec = (uint64_t)v92;
              CFRange v94 = "Preallocation for itemId %llu of %llu bytes failed to allocate %llu bytes with posix error %d (%s).";
              uint32_t v95 = 48;
              goto LABEL_107;
            }
            if (v128 <= 0) {
              break;
            }
            v81 += v128;
            uint64_t v85 = *(void *)(a1 + 8);
            uint64_t v86 = *(void *)(v85 + 16);
            unint64_t v79 = (void *)(v85 + 16);
            uint64_t v82 = v83 + 1;
            if (v81 >= v86) {
              goto LABEL_108;
            }
          }
          CFStringRef v96 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v96, OS_LOG_TYPE_ERROR)) {
            goto LABEL_108;
          }
          uint64_t v97 = *(void *)(a1 + 8);
          uint64_t v98 = *(void *)(v97 + 40);
          __darwin_ino64_t v99 = *(void *)(v97 + 16);
          buf.st_dev = 134218496;
          *(void *)&buf.st_mode = v98;
          WORD2(buf.st_ino) = 2048;
          *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = v99;
          HIWORD(buf.st_gid) = 2048;
          *(void *)&buf.st_rdev = v127;
          CFRange v94 = "Preallocation for itemId %llu of %llu bytes failed to allocate %llu bytes.";
          unint64_t v93 = v96;
          uint32_t v95 = 32;
LABEL_107:
          _os_log_impl(&dword_1DC1CA000, v93, OS_LOG_TYPE_ERROR, v94, (uint8_t *)&buf, v95);
        }
LABEL_108:
        double v100 = CFAbsoluteTimeGetCurrent() - Current;
        if (v100 > 0.25 || v81 < *(void *)(*(void *)(a1 + 8) + 16)) {
          os_log_type_t v102 = OS_LOG_TYPE_ERROR;
        }
        else {
          os_log_type_t v102 = OS_LOG_TYPE_DEFAULT;
        }
        long long v103 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v103, v102))
        {
          uint64_t v104 = *(void *)(a1 + 8);
          uint64_t v105 = *(void *)(v104 + 40);
          uint64_t v106 = *(void *)(v104 + 16);
          long long v107 = "successful";
          if (v81 < v106) {
            long long v107 = "failed";
          }
          CFStringRef __errnuma = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Preallocated %llu bytes for itemId %llu of %llu bytes %s after %.3f seconds over %llu preallocation calls.", v81, v105, v106, v107, *(void *)&v100, v83);
          uint64_t v108 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v108, v102))
          {
            buf.st_dev = 138543362;
            *(void *)&buf.st_mode = __errnuma;
            _os_log_impl(&dword_1DC1CA000, v108, v102, "%{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (__errnuma) {
            CFRelease(__errnuma);
          }
        }
        if (mmcs_get_request_should_error_on_preallocation_failure(v8))
        {
          uint64_t v109 = *(void *)(a1 + 8);
          if (v81 < *(void *)(v109 + 16) || *(unsigned char *)(v109 + 408))
          {
            unint64_t v110 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v111 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to preallocate item %lld", *(void *)(*(void *)(a1 + 8) + 40));
              uint64_t v112 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
              {
                buf.st_dev = 138543362;
                *(void *)&buf.st_mode = v111;
                _os_log_impl(&dword_1DC1CA000, v112, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
              }
              if (v111) {
                CFRelease(v111);
              }
            }
            mmcs_get_request_set_failed_to_preallocate(v8, 1);
            error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 48, 0, @"Failed to preallocate item %lld", v113, v114, v115, v116, *(void *)(*(void *)(a1 + 8) + 40));
            CFErrorRef v118 = error_with_underlying_error;
            if (a2) {
              *a2 = CFRetain(error_with_underlying_error);
            }
            if (v118) {
              CFRelease(v118);
            }
            goto LABEL_86;
          }
        }
      }
      else if (v73)
      {
        uint64_t v87 = *(void *)(a1 + 8);
        uint64_t v88 = *(void *)(v87 + 40);
        __darwin_ino64_t v89 = *(void *)(v87 + 16);
        buf.st_dev = 134218240;
        *(void *)&buf.st_mode = v88;
        WORD2(buf.st_ino) = 2048;
        *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = v89;
        _os_log_impl(&dword_1DC1CA000, v72, OS_LOG_TYPE_DEFAULT, "Preallocation skipped for itemId %llu of %llu bytes", (uint8_t *)&buf, 0x16u);
      }
    }
    os_log_type_t v12 = MMCSItemReaderWriterCreateWithFileDescriptor(v17, 0, 0, sparse_block_size, (CFErrorRef *)&v130);
    *CFStringRef v6 = v12;
    if (v12 && !v130) {
      goto LABEL_9;
    }
    uint64_t v55 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v61 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"An error occurred creating temp reader writer for item %lld", *(void *)(*(void *)(a1 + 8) + 40));
      uint64_t v62 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        buf.st_dev = 138543362;
        *(void *)&buf.st_mode = v61;
        _os_log_impl(&dword_1DC1CA000, v62, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v61) {
        CFRelease(v61);
      }
    }
    uint64_t v63 = v130;
    if (!v130)
    {
      uint64_t v63 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"An unknown error occurred creating temp fd reader writer for item %lld", v56, v57, v58, v59, v60, *(void *)(*(void *)(a1 + 8) + 40));
      CFTypeRef v130 = v63;
    }
    if (a2)
    {
      *a2 = CFRetain(v63);
      uint64_t v63 = v130;
    }
    if (v63) {
      CFRelease(v63);
    }
    CFTypeRef v130 = 0;
LABEL_86:
    mmcs_get_file_close_temp_reader_writer(a1);
    return 0;
  }
  *(void *)&cf.st_dev = 0;
  uint64_t v10 = mmcs_engine_owner(v9);
  uint64_t requestor = mmcs_request_get_requestor(**(void **)a1);
  if (mmcs_engine_get_item_reader_writer_for_item_callback(v9, v10, requestor, *(void *)(*(void *)(a1 + 8) + 40), (void *)(a1 + 24), (CFTypeRef *)&cf))
  {
    os_log_type_t v12 = (unsigned char *)*v6;
    if (*v6)
    {
LABEL_9:
      *(void *)&cf.st_dev = 0;
      if (MMCSItemReaderWriterOpen((uint64_t)v12, (CFTypeRef *)&cf)) {
        return 1;
      }
      CFErrorRef error = *(CFErrorRef *)&cf.st_dev;
      if (!*(void *)&cf.st_dev)
      {
        CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 39, @"An unknown error occurred while opening the item reader writer.");
        *(void *)&cf.st_dev = error;
      }
      if (a2)
      {
        *a2 = CFRetain(error);
        CFErrorRef error = *(CFErrorRef *)&cf.st_dev;
      }
      if (error) {
        CFRelease(error);
      }
      *(void *)&cf.st_dev = 0;
      goto LABEL_86;
    }
  }
  CFErrorRef v14 = *(CFErrorRef *)&cf.st_dev;
  if (!*(void *)&cf.st_dev)
  {
    CFErrorRef v14 = mmcs_cferror_create_error(@"com.apple.mmcs", 39, @"An unknown error occurred retrieving item reader writer from callback for download.");
    *(void *)&cf.st_dev = v14;
  }
  if (a2)
  {
    *a2 = CFRetain(v14);
    CFErrorRef v14 = *(CFErrorRef *)&cf.st_dev;
  }
  if (!v14) {
    return 0;
  }
LABEL_22:
  CFRelease(v14);
  return 0;
}

uint64_t mmcs_get_file_init_temp_file(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a2) {
    *a2 = 0;
  }
  uint64_t v4 = **(void **)a1;
  uint64_t v5 = mmcs_chunk_instance_offset(v4);
  CFTypeRef cf = 0;
  if (mmcs_item_is_metadata_only(*(void *)(a1 + 8))) {
    mmcs_get_file_init_temp_file_cold_3();
  }
  if (*(void *)(a1 + 24)) {
    mmcs_get_file_init_temp_file_cold_2();
  }
  CFStringRef v6 = (void **)(a1 + 16);
  if (*(void *)(a1 + 16)) {
    mmcs_get_file_init_temp_file_cold_1();
  }
  if (!mmcs_engine_file_path(v5, "tmpm", *(void *)(*(void *)(a1 + 8) + 40), (char **)(a1 + 16), (CFErrorRef *)&cf))
  {
    if (*v6) {
      free(*v6);
    }
    *CFStringRef v6 = 0;
    os_log_type_t v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to get file path for item %lld", *(void *)(*(void *)(a1 + 8) + 40));
      CFErrorRef v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)stat buf = 138543362;
        CFStringRef v21 = v13;
        _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v13) {
        CFRelease(v13);
      }
    }
    CFErrorRef error = cf;
    if (!cf)
    {
      uint64_t v16 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to get work path for item %lld", *(void *)(*(void *)(a1 + 8) + 40));
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 10, v16);
      CFTypeRef cf = error;
      if (v16)
      {
        CFRelease(v16);
        CFErrorRef error = cf;
      }
    }
    uint64_t v17 = *(uint64_t **)(a1 + 8);
    mmcs_get_item_progress_make_done_error((uint64_t)error, v18);
    mmcs_get_request_set_progress_and_notify_item(v4, v17, v18);
    if (a2) {
      *a2 = CFRetain(cf);
    }
    uint64_t v10 = 0;
    uint64_t result = 0;
    CFStringRef v8 = (const __CFString *)cf;
    if (!cf) {
      return result;
    }
LABEL_27:
    CFRelease(v8);
    return v10;
  }
  if (!*(unsigned char *)(v5 + 170))
  {
    CKUnregisterFile();
    unlink(*(const char **)(a1 + 16));
  }
  int v7 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
    return 1;
  }
  CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Opened file %s", *v6);
  uint64_t v9 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)stat buf = 138543362;
    CFStringRef v21 = v8;
    _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
  }
  uint64_t v10 = 1;
  uint64_t result = 1;
  if (v8) {
    goto LABEL_27;
  }
  return result;
}

double mmcs_get_file_local_fulfillment_elapsed_seconds(uint64_t a1)
{
  double v1 = *(double *)(a1 + 64);
  double result = 0.0;
  if (v1 != 0.0)
  {
    double v3 = *(double *)(a1 + 72);
    BOOL v4 = v3 < v1 || v3 == 0.0;
    double result = v3 - v1;
    if (v4) {
      return 0.0;
    }
  }
  return result;
}

uint64_t mmcs_get_file_compute_remaining_work(uint64_t **a1)
{
  uint64_t v168 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = mmcs_chunk_instance_offset(**a1);
  CFTypeRef error = 0;
  if (*((unsigned char *)a1 + 115)) {
    return 1;
  }
  uint64_t v3 = v2;
  if (mmcs_item_is_derivative((uint64_t)a1[1])) {
    return 1;
  }
  if (!mmcs_item_is_metadata_only((uint64_t)a1[1]))
  {
    if (!mmcs_get_req_context_use_reader_writer_callback(**a1)
      && !mmcs_get_file_init_temp_file((uint64_t)a1, &error))
    {
      if (!error) {
        CFTypeRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 1, @"An unknown error creating temp file.");
      }
      goto LABEL_169;
    }
    if (!mmcs_get_file_ensure_temp_file_is_open_with_length_check((uint64_t)a1, &error, -1))
    {
LABEL_169:
      mmcs_get_file_completed_with_error((uint64_t)a1, (uint64_t)error);
      if (error) {
        CFRelease(error);
      }
      CFTypeRef error = 0;
      mmcs_get_file_close_temp_reader_writer((uint64_t)a1);
      return 0;
    }
  }
  if (!*((unsigned char *)a1 + 113)) {
    goto LABEL_155;
  }
  uint64_t v5 = **a1;
  uint64_t v6 = mmcs_chunk_instance_offset(v5);
  CFTypeRef v153 = 0;
  CFTypeRef cf = 0;
  CFTypeRef error = 0;
  CFDataRef v7 = (const __CFData *)a1[1][50];
  if (v7) {
    CFDataGetBytePtr(v7);
  }
  if (CKFileDigestResultsCreate())
  {
    if (CKGetRegisteredFileMetadata())
    {
      if (!CKFileDigestResultsEqual())
      {
        CFStringRef v13 = CFCopyDescription(cf);
        CFStringRef v14 = CFCopyDescription(v153);
        int v15 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v21 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"file signature mismatch for %lld item has %@ != %@ for the chunk store", a1[1][5], v13, v14);
          uint64_t v22 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)stat buf = 138543362;
            *(void *)&uint8_t buf[4] = v21;
            _os_log_impl(&dword_1DC1CA000, v22, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v21) {
            CFRelease(v21);
          }
        }
        CFErrorRef v9 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 28, @"The file signature changed: from %@ on the item to %@ registered in the chunk store for item %lld. Perhaps the item should be unregistered.", v16, v17, v18, v19, v20, (char)v13);
        uint64_t v23 = a1[1];
        mmcs_get_item_progress_make_done_error((uint64_t)v9, buf);
        mmcs_get_request_set_progress_and_notify_item(v5, v23, (unsigned int *)buf);
        if (v13) {
          CFRelease(v13);
        }
        if (v14) {
          CFRelease(v14);
        }
        goto LABEL_46;
      }
      if (!*(unsigned char *)(v6 + 170))
      {
        uint64_t v143 = a1[1][5];
        CFStringRef v8 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Item %lld was already registered. Perhaps the item should be unregistered.");
        CFErrorRef v9 = mmcs_cferror_create_error(@"com.apple.mmcs", 32, v8);
        if (v8) {
          CFRelease(v8);
        }
        uint64_t v10 = a1[1];
        CFErrorRef v11 = v9;
LABEL_45:
        mmcs_get_item_progress_make_done_error((uint64_t)v11, buf);
        mmcs_get_request_set_progress_and_notify_item(v5, v10, (unsigned int *)buf);
LABEL_46:
        if (v9)
        {
          CFRetain(v9);
          CFTypeRef error = v9;
          int v24 = 1;
        }
        else
        {
          int v24 = 0;
        }
        goto LABEL_49;
      }
      goto LABEL_33;
    }
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = 0;
    CFDataRef v12 = (const __CFData *)a1[1][50];
    if (v12) {
      CFDataGetBytePtr(v12);
    }
    if (CKFileDigestResultsCreate())
    {
      if ((CKRegisterFile() & 1) == 0)
      {
        CFStringRef v26 = mmcs_item_copy_description((uint64_t)a1[1]);
        uint64_t v27 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          LOBYTE(v143) = (_BYTE)v26;
          CFStringRef v28 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to register item %@");
          uint64_t v29 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)stat buf = 138543362;
            *(void *)&uint8_t buf[4] = v28;
            _os_log_impl(&dword_1DC1CA000, v29, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v28) {
            CFRelease(v28);
          }
        }
        if (v26) {
          CFRelease(v26);
        }
        CFErrorRef v11 = mmcs_cferror_create_error(@"com.apple.mmcs", 19, @"Unable to register item");
        CFErrorRef v9 = v11;
        uint64_t v10 = a1[1];
        goto LABEL_45;
      }
LABEL_33:
      int v24 = 0;
      CFErrorRef v9 = 0;
      char v25 = 0;
      goto LABEL_50;
    }
  }
  int v24 = 0;
  CFErrorRef v9 = 0;
LABEL_49:
  char v25 = 1;
LABEL_50:
  if (cf) {
    C3BaseRelease(cf);
  }
  CFTypeRef cf = 0;
  if (v153) {
    C3BaseRelease(v153);
  }
  CFTypeRef v153 = 0;
  if (v24) {
    C3BaseRelease(v9);
  }
  if (v25) {
    goto LABEL_169;
  }
  CFTypeRef error = 0;
  CFTypeRef v152 = 0;
  uint64_t v30 = **a1;
  uint64_t v31 = mmcs_chunk_instance_offset(v30);
  uint64_t v32 = (uint64_t)a1[1];
  uint64_t v151 = 0;
  if (!*(unsigned char *)(v31 + 170) && (CKUnregisterChunksForItem() & 1) == 0) {
    goto LABEL_89;
  }
  unint64_t v150 = 0;
  if (!mmcs_GetSortedRegisteredChunksForItemID(*(void *)(v31 + 16), *(const __CFString **)(v32 + 40), &v151, (uint64_t *)&v150, 0, 0)|| !v151|| !v150)
  {
    if (CKUnregisterChunksForItem())
    {
      __int16 v52 = a1[1];
      if (v52[19])
      {
        uint64_t v146 = v30;
        uint64_t v53 = 0;
        unint64_t v54 = 0;
        while (1)
        {
          uint64_t v55 = 104 * v53;
          do
          {
            uint64_t v56 = v52[34];
            CFBooleanRef v57 = *(const __CFBoolean **)(v56 + v55 + 72);
            if (!v57) {
              mmcs_get_file_compute_remaining_work_cold_6();
            }
            uint64_t v58 = v53;
            uint64_t v59 = v55;
            if (CFBooleanGetValue(v57)) {
              break;
            }
            ++v53;
            __int16 v52 = a1[1];
            uint64_t v55 = v59 + 104;
          }
          while (v58 + 1 < (unint64_t)v52[18]);
          if (!CFBooleanGetValue(*(CFBooleanRef *)(v56 + v59 + 72)))
          {
            CFStringRef v130 = @"chunksPartOfItemInstanceCount/partOfItem mismatch";
            goto LABEL_220;
          }
          uint64_t v65 = *(void *)(v56 + v59 + 56);
          if (!*(void *)(v65 + 16) && **(char **)(v65 + 8) < 0) {
            break;
          }
          uint64_t RegisteredChunk = mmcs_chunk_instance_create_RegisteredChunk();
          if (!RegisteredChunk)
          {
            CFStringRef v130 = @"No memory to create a registered chunk";
            goto LABEL_218;
          }
          uint64_t v67 = (void *)RegisteredChunk;
          if (!v54 && CKRegisteredChunkOffset())
          {
            CFStringRef v130 = @"Registered offset of first chunk non-zero.";
LABEL_220:
            CFIndex v136 = 1;
LABEL_221:
            uint64_t v69 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v136, v130, v60, v61, v62, v63, v64, v143);
            goto LABEL_222;
          }
          if ((CKRegisterChunk() & 1) == 0)
          {
            free(v67);
            uint64_t v69 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 29, @"chunk for item %lld could not be registered.", v131, v132, v133, v134, v135, *(void *)(v32 + 40));
            goto LABEL_222;
          }
          uint64_t v53 = v58 + 1;
          *(void *)(v56 + v59 + 40) = CKRegisteredChunkRowID();
          free(v67);
          char v68 = 0;
          ++v54;
          __int16 v52 = a1[1];
          if (v54 >= v52[19]) {
            goto LABEL_150;
          }
        }
        CFStringRef v130 = @"Cannot register encrypted chunk without encryption key.";
LABEL_218:
        CFIndex v136 = 36;
        goto LABEL_221;
      }
      goto LABEL_149;
    }
LABEL_89:
    uint64_t v69 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 29, @"chunks for item %lld could not be unregistered.", v33, v34, v35, v36, v37, *(void *)(v32 + 40));
    goto LABEL_91;
  }
  if (v150 != *(void *)(v32 + 152))
  {
    uint64_t v69 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 29, @"chunklists length mismatch for item %lld. Expected %llu got %llu from the chunk store. Perhaps the item should be unregistered.", v38, v39, v40, v41, v42, *(void *)(v32 + 40));
    goto LABEL_91;
  }
  if (mmcs_item_is_metadata_only(v32)) {
    goto LABEL_149;
  }
  if (v150)
  {
    uint64_t v43 = 0;
    unint64_t v44 = 0;
    while (1)
    {
      uint64_t v45 = *(void *)(v32 + 272);
      if (CKRegisteredChunkOffset() != *(void *)(v45 + v43 + 32)) {
        break;
      }
      if (CKRegisteredChunkLength() != *(_DWORD *)(*(void *)(v45 + v43 + 56) + 4)) {
        break;
      }
      CKRegisteredChunkSignature();
      if ((CKChunkSignaturesEqual() & 1) == 0) {
        break;
      }
      if (CKRegisteredChunkLocation() != 116 && CKRegisteredChunkLocation() != 110)
      {
        uint64_t v137 = *(void *)(v32 + 40);
        CKRegisteredChunkLocation();
        uint64_t v69 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 29, @"chunk for item %lld at chunk index %llu has location %c. Perhaps the item should be unregistered.", v138, v139, v140, v141, v142, v137);
        goto LABEL_91;
      }
      *(void *)(v45 + v43 + 40) = CKRegisteredChunkRowID();
      CKRegisteredChunkSize();
      ++v44;
      unint64_t v51 = v150;
      v43 += 104;
      if (v44 >= v150) {
        goto LABEL_102;
      }
    }
    uint64_t v69 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 29, @"chunk mismatch for item %lld at chunk index %llu. Perhaps the item should be unregistered.", v46, v47, v48, v49, v50, *(void *)(v32 + 40));
LABEL_91:
    CFTypeRef v152 = v69;
    goto LABEL_92;
  }
  unint64_t v51 = 0;
LABEL_102:
  if (!mmcs_get_file_create_buffer((uint64_t)a1, (CFErrorRef *)&v152))
  {
    uint64_t v69 = v152;
    goto LABEL_92;
  }
  if (!v51)
  {
LABEL_149:
    char v68 = 0;
    goto LABEL_150;
  }
  uint64_t v146 = v30;
  uint64_t v78 = 0;
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  unint64_t v145 = v51;
  while (1)
  {
    uint64_t v79 = a1[1][34];
    if (CKRegisteredChunkLocation() == 116) {
      break;
    }
LABEL_147:
    char v68 = 0;
    CKRegisteredChunkSize();
    if (++v78 == v51) {
      goto LABEL_150;
    }
  }
  uint64_t v147 = v79;
  uint64_t v81 = (uint64_t)a1[4];
  uint64_t v80 = a1[5];
  mmcs_chunk_instance_offset(**a1);
  uint64_t v82 = (const void *)mmcs_chunk_instance_chunk_coder_create(v79 + 104 * v78, 3);
  uint64_t v83 = (uint64_t *)CKRegisteredChunkLength();
  uint64_t v84 = CKRegisteredChunkOffset();
  while (1)
  {
    uint64_t v85 = (uint64_t)(v83 >= v80 ? v80 : v83);
    CFTypeRef v153 = 0;
    CFTypeRef cf = 0;
    int v86 = MMCSItemReaderWriterRead((uint64_t)a1[3], v84, v81, v85, (uint64_t)&v153, (CFErrorRef *)&cf);
    uint64_t v87 = (__CFString *)cf;
    if (!v86 || cf != 0) {
      break;
    }
    if (!v153) {
      goto LABEL_130;
    }
    CKChunkCoderUpdate();
    v84 += (uint64_t)v153;
    uint64_t v83 = (uint64_t *)((char *)v83 - (unint64_t)v153);
    if (!v83) {
      goto LABEL_132;
    }
  }
  if (cf) {
    uint64_t v87 = mmcs_cferror_copy_description((__CFError *)cf);
  }
  if (v87) {
    __darwin_ino64_t v89 = v87;
  }
  else {
    __darwin_ino64_t v89 = @"unknown";
  }
  int v90 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
  {
    LOBYTE(v143) = (_BYTE)v89;
    CFStringRef v91 = CFStringCreateWithFormat(alloc, 0, @"reading from readerWriter failed with error: %@");
    unint64_t v92 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)stat buf = 138543362;
      *(void *)&uint8_t buf[4] = v91;
      _os_log_impl(&dword_1DC1CA000, v92, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v91) {
      CFRelease(v91);
    }
  }
  CFRelease(v89);
  if (cf) {
    CFRelease(cf);
  }
LABEL_130:
  if (v83)
  {
    BOOL v93 = 0;
    goto LABEL_133;
  }
LABEL_132:
  BOOL v93 = CKChunkCoderFinish() != 0;
LABEL_133:
  unint64_t v51 = v145;
  if (v82) {
    C3BaseRelease(v82);
  }
  CFRange v94 = (void *)CKRegisteredChunkSignatureCopyCString();
  uint32_t v95 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v96 = "needs";
    if (v93) {
      CFStringRef v96 = "has";
    }
    CFStringRef v97 = CFStringCreateWithFormat(alloc, 0, @"Temporary file for item %lld %s chunk %s", a1[1][5], v96, v94);
    uint64_t v98 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)stat buf = 138543362;
      *(void *)&uint8_t buf[4] = v97;
      _os_log_impl(&dword_1DC1CA000, v98, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v97) {
      CFRelease(v97);
    }
  }
  if (v94) {
    free(v94);
  }
  a1[10] = (uint64_t *)((char *)a1[10] + CKRegisteredChunkLength());
  if (v93)
  {
    a1[11] = (uint64_t *)((char *)a1[11] + CKRegisteredChunkLength());
    *(unsigned char *)(v147 + 104 * v78 + 48) = 1;
    goto LABEL_147;
  }
  *(unsigned char *)(v147 + 104 * v78 + 48) = 0;
  if (CKRelocateTemporaryChunk()) {
    goto LABEL_147;
  }
  uint64_t v69 = mmcs_cferror_create_error(@"com.apple.mmcs", 29, @"A temporary chunk could not be registered as needed.");
LABEL_222:
  CFTypeRef v152 = v69;
  uint64_t v30 = v146;
LABEL_92:
  if (!v69) {
    CFTypeRef v152 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"No local error was specified", v70, v71, v72, v73, v74, v143);
  }
  uint64_t v75 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v76 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to register chunks for item %lld: %@", *(void *)(v32 + 40), v152);
    BOOL v77 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)stat buf = 138543362;
      *(void *)&uint8_t buf[4] = v76;
      _os_log_impl(&dword_1DC1CA000, v77, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v76) {
      CFRelease(v76);
    }
  }
  mmcs_get_item_progress_make_done_error((uint64_t)v152, buf);
  mmcs_get_request_set_progress_and_notify_item(v30, (uint64_t *)v32, (unsigned int *)buf);
  CFTypeRef error = CFRetain(v152);
  char v68 = 1;
LABEL_150:
  if (v152) {
    CFRelease(v152);
  }
  CFTypeRef v152 = 0;
  if (v151) {
    free(v151);
  }
  if (v68) {
    goto LABEL_169;
  }
LABEL_155:
  if (mmcs_item_is_metadata_only((uint64_t)a1[1])) {
    goto LABEL_201;
  }
  if (*(unsigned char *)(v3 + 171) && !mmcs_get_file_fulfill_locally((uint64_t)a1, (CFErrorRef *)&error)) {
    goto LABEL_169;
  }
  CFTypeRef error = 0;
  uint64_t v99 = **a1;
  uint64_t v100 = mmcs_chunk_instance_offset(v99);
  CFTypeRef cf = 0;
  *(void *)stat buf = 0;
  if (!*((unsigned char *)a1 + 113)
    || (mmcs_GetSortedRegisteredChunksForItemID(*(void *)(v100 + 16), (const __CFString *)a1[1][5], (void **)buf, (uint64_t *)&cf, 0, 0)? (BOOL v101 = *(void *)buf == 0): (BOOL v101 = 1), !v101 ? (v102 = cf == 0) : (v102 = 1), !v102))
  {
    CFAllocatorRef v103 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &chunkReferenceSignatureEqualitySetCallbacks);
    CFSetRef v105 = CFSetCreateMutable(v103, 0, &chunkReferenceSignatureEqualitySetCallbacks);
    uint64_t v106 = *(void *)buf;
    uint64_t v148 = v99;
    if (*(void *)buf)
    {
      CFTypeRef v107 = cf;
      uint64_t v108 = a1[1];
      if (cf != (CFTypeRef)v108[19]) {
        mmcs_get_file_compute_remaining_work_cold_5();
      }
    }
    else
    {
      uint64_t v108 = a1[1];
      CFTypeRef v107 = (CFTypeRef)v108[19];
    }
    if (v107)
    {
      uint64_t v109 = 0;
      unint64_t v110 = 0;
      do
      {
        uint64_t v111 = 104 * v109;
        do
        {
          uint64_t v112 = v108[34];
          CFBooleanRef v113 = *(const __CFBoolean **)(v112 + v111 + 72);
          if (!v113) {
            mmcs_get_file_compute_remaining_work_cold_1();
          }
          uint64_t v114 = v109;
          uint64_t v115 = v111;
          if (CFBooleanGetValue(v113)) {
            break;
          }
          uint64_t v109 = v114 + 1;
          uint64_t v108 = a1[1];
          uint64_t v111 = v115 + 104;
        }
        while (v114 + 1 < (unint64_t)v108[18]);
        if (!CFBooleanGetValue(*(CFBooleanRef *)(v112 + v115 + 72))) {
          mmcs_get_file_compute_remaining_work_cold_2();
        }
        if (!mmcs_chunk_instance_is_chunk_reference((_DWORD *)(v112 + v115))) {
          mmcs_get_file_compute_remaining_work_cold_3();
        }
        uint64_t v116 = v112 + v115;
        if (v106)
        {
          int v117 = *(unsigned __int8 *)(v112 + v115 + 48);
          if (v117 == (CKRegisteredChunkLocation() != 116)) {
            mmcs_get_file_compute_remaining_work_cold_4();
          }
          if (*(unsigned char *)(v116 + 48)) {
            CFErrorRef v118 = Mutable;
          }
          else {
            CFErrorRef v118 = v105;
          }
          CFSetAddValue(v118, *(const void **)(v112 + v115 + 56));
          v106 += CKRegisteredChunkSize();
        }
        else
        {
          if (*(unsigned char *)(v112 + v115 + 48)) {
            uint64_t v119 = Mutable;
          }
          else {
            uint64_t v119 = v105;
          }
          CFSetAddValue(v119, *(const void **)(v116 + 56));
        }
        uint64_t v109 = v114 + 1;
        ++v110;
        uint64_t v108 = a1[1];
      }
      while (v110 < v108[19]);
    }
    XCFSetRemoveValuesFromSet(Mutable, v105);
    CFSetApplyFunction(Mutable, (CFSetApplierFunction)mmcs_get_file_notify_locally_fulfilled_chunk_reference, a1);
    mmcs_get_request_notify_item_with_pending_progress(v148, (uint64_t)a1[1]);
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v105) {
      CFRelease(v105);
    }
    if (*(void *)buf) {
      free(*(void **)buf);
    }
  }
  uint64_t v120 = a1[4];
  if (v120) {
    free(v120);
  }
  a1[4] = 0;
  a1[5] = 0;
  mmcs_get_file_close_temp_reader_writer((uint64_t)a1);
LABEL_201:
  double v121 = *((double *)a1 + 8);
  double v122 = 0.0;
  if (v121 != 0.0
    && (double v123 = *((double *)a1 + 9), v123 != 0.0)
    && v123 >= v121
    && (double v122 = v123 - v121, v123 - v121 != 0.0)
    || a1[11]
    || a1[12]
    || a1[10]
    || a1[13])
  {
    uint64_t v124 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v125 = a1[1][5];
      uint64_t v126 = a1[12];
      uint64_t v127 = a1[13];
      uint64_t v129 = a1[10];
      uint64_t v128 = a1[11];
      *(_DWORD *)stat buf = 134219520;
      *(void *)&uint8_t buf[4] = v125;
      __int16 v156 = 2048;
      double v157 = v122;
      __int16 v158 = 2048;
      uint64_t v159 = (char *)v128 + (void)v126 + (unint64_t)v127;
      __int16 v160 = 2048;
      v161 = v129;
      __int16 v162 = 2048;
      unsigned int v163 = v128;
      __int16 v164 = 2048;
      v165 = v126;
      __int16 v166 = 2048;
      uint64_t v167 = v127;
      _os_log_impl(&dword_1DC1CA000, v124, OS_LOG_TYPE_DEFAULT, "itemId:%llu local fulfillment took %0.4lf seconds for %llu bytes. Validated for Resume (%llu bytes), Resumed (%llu bytes), Fullfilled Locally (%llu bytes), Fullfilled By Peers (%llu bytes)", buf, 0x48u);
    }
  }
  return 1;
}

uint64_t mmcs_get_file_fulfill_locally(uint64_t a1, CFErrorRef *a2)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (a2) {
    *a2 = 0;
  }
  *(CFAbsoluteTime *)(a1 + 64) = CFAbsoluteTimeGetCurrent();
  if (!mmcs_get_file_create_buffer(a1, a2))
  {
    LOBYTE(v16) = 0;
    return v16;
  }
  uint64_t v4 = **(void **)a1;
  uint64_t v5 = mmcs_chunk_instance_offset(v4);
  uint64_t v53 = 0;
  uint64_t requestor = mmcs_request_get_requestor(v4);
  if (!mmcs_local_chunk_satisfyer_create((uint64_t *)&v53, v5, requestor, *(void *)(a1 + 24), a1 + 120, *(unsigned char *)(a1 + 113)))
  {
    LOBYTE(v16) = 0;
    *a2 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed to initialize mmcs_local_chunk_satisfyer", v7, v8, v9, v10, v11, v50);
    return v16;
  }
  if (!*(unsigned char *)(a1 + 113))
  {
    uint64_t v17 = 0;
    int v16 = 1;
    uint64_t v18 = -1;
    do
    {
      uint64_t v19 = *(void *)(a1 + 8);
      if ((unint64_t)++v18 >= *(void *)(v19 + 144)) {
        break;
      }
      uint64_t v20 = *(void *)(v19 + 272) + v17;
      uint64_t RegisteredChunk = (void *)mmcs_chunk_instance_create_RegisteredChunk();
      int v22 = mmcs_local_chunk_satisfyer_perform(v53, v20, (uint64_t)RegisteredChunk, 3, *(void *)(a1 + 32), *(void *)(a1 + 40), (CFTypeRef *)a2);
      uint64_t v23 = v53;
      *(void *)(a1 + 96) += v53[9];
      v23[9] = 0;
      if (v22)
      {
        if (*(unsigned char *)(v20 + 48))
        {
          uint64_t v24 = 0;
        }
        else
        {
          if (!mmcs_external_chunk_satisfyer_perform(v23, v20, (uint64_t)RegisteredChunk, *(void *)(a1 + 32), *(void *)(a1 + 40), a2))int v16 = 0; {
          uint64_t v23 = v53;
          }
          uint64_t v24 = v53[9];
        }
      }
      else
      {
        uint64_t v24 = 0;
        int v16 = 0;
      }
      *(void *)(a1 + 104) += v24;
      v23[9] = 0;
      if (RegisteredChunk) {
        free(RegisteredChunk);
      }
      v17 += 104;
    }
    while (v16);
    goto LABEL_61;
  }
  unint64_t v51 = 0;
  __int16 v52 = 0;
  int SortedRegisteredChunksForItemID = mmcs_GetSortedRegisteredChunksForItemID(*(void *)(v5 + 16), *(const __CFString **)(*(void *)(a1 + 8) + 40), (void **)&v52, (uint64_t *)&v51, 0, 0);
  CFStringRef v13 = v52;
  if (SortedRegisteredChunksForItemID) {
    BOOL v14 = v52 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14 || v51 == 0)
  {
    LOBYTE(v16) = 1;
    if (v52) {
      goto LABEL_60;
    }
    goto LABEL_61;
  }
  if (v51 != *(void *)(*(void *)(a1 + 8) + 152)) {
    mmcs_get_file_fulfill_locally_cold_4();
  }
  uint64_t v25 = 0;
  unint64_t v26 = 0;
  int v16 = 1;
  do
  {
    uint64_t v27 = *(void *)(a1 + 8);
    uint64_t v28 = 104 * v25;
    do
    {
      uint64_t v29 = v25;
      uint64_t v30 = *(void *)(v27 + 272);
      CFBooleanRef v31 = *(const __CFBoolean **)(v30 + v28 + 72);
      if (!v31) {
        mmcs_get_file_fulfill_locally_cold_1();
      }
      uint64_t v32 = v28;
      if (CFBooleanGetValue(v31)) {
        break;
      }
      uint64_t v25 = v29 + 1;
      uint64_t v27 = *(void *)(a1 + 8);
      uint64_t v28 = v32 + 104;
    }
    while ((unint64_t)(v29 + 1) < *(void *)(v27 + 144));
    uint64_t v33 = v30 + v32;
    if (!CFBooleanGetValue(*(CFBooleanRef *)(v30 + v32 + 72))) {
      mmcs_get_file_fulfill_locally_cold_2();
    }
    CKRegisteredChunkSignature();
    if ((CKChunkSignaturesEqual() & 1) == 0) {
      mmcs_get_file_fulfill_locally_cold_3();
    }
    if (mmcs_item_is_outstanding_chunk_reference(*(void *)(a1 + 8), *(const void **)(v33 + 56)))
    {
      if (CKRegisteredChunkLocation() == 110)
      {
        int v34 = mmcs_local_chunk_satisfyer_perform(v53, v30 + v32, (uint64_t)v13, 3, *(void *)(a1 + 32), *(void *)(a1 + 40), (CFTypeRef *)a2);
        uint64_t v35 = v53;
        *(void *)(a1 + 96) += v53[9];
        v35[9] = 0;
        if (!v34)
        {
          uint64_t v37 = 0;
LABEL_50:
          int v16 = 0;
          *(void *)(a1 + 104) += v37;
          v35[9] = 0;
          goto LABEL_54;
        }
        uint64_t v36 = v30 + v32;
        if (*(unsigned char *)(v36 + 48))
        {
          uint64_t v37 = 0;
        }
        else
        {
          int v44 = mmcs_external_chunk_satisfyer_perform(v35, v33, (uint64_t)v13, *(void *)(a1 + 32), *(void *)(a1 + 40), a2);
          uint64_t v35 = v53;
          uint64_t v37 = v53[9];
          if (!v44) {
            goto LABEL_50;
          }
        }
        *(void *)(a1 + 104) += v37;
        v35[9] = 0;
        if (*(unsigned char *)(v36 + 48) && (CKRelocateTemporaryChunk() & 1) == 0)
        {
          *a2 = mmcs_cferror_create_error(@"com.apple.mmcs", 29, @"A temporary chunk could not be relocated as needed.");
          uint64_t v46 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          {
            uint64_t v47 = CKRegisteredChunkItemID();
            CFErrorRef v48 = *a2;
            *(_DWORD *)stat buf = 134218242;
            uint64_t v55 = v47;
            __int16 v56 = 2114;
            CFErrorRef v57 = v48;
            _os_log_impl(&dword_1DC1CA000, v46, OS_LOG_TYPE_ERROR, "Failed to write chunk to item %lld with error: %{public}@", buf, 0x16u);
          }
LABEL_48:
          int v16 = 0;
        }
      }
      else
      {
        if (CKRegisteredChunkLocation() != 116)
        {
          if (a2)
          {
            uint64_t v38 = (void *)CKRegisteredChunkSignatureCopyCString();
            CKRegisteredChunkLocation();
            *a2 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 39, @"Chunk %s for item %lld had unexpected location %d", v39, v40, v41, v42, v43, (char)v38);
            free(v38);
          }
          goto LABEL_48;
        }
        *(unsigned char *)(v30 + v32 + 48) = 1;
      }
    }
LABEL_54:
    unsigned int v45 = CKRegisteredChunkSize();
    if (!v16) {
      break;
    }
    uint64_t v25 = v29 + 1;
    v13 += v45;
    ++v26;
  }
  while (v26 < v51);
  CFStringRef v13 = v52;
  if (v52) {
LABEL_60:
  }
    free(v13);
LABEL_61:
  if (v53) {
    C3BaseRelease(v53);
  }
  uint64_t v53 = 0;
  *(CFAbsoluteTime *)(a1 + 72) = CFAbsoluteTimeGetCurrent();
  return v16;
}

uint64_t mmcs_get_file_complete_metadata_only_file(uint64_t a1)
{
  v40[3] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  uint64_t v2 = **(void **)a1;
  mmcs_chunk_instance_offset(v2);
  v40[0] = 0;
  CFDataRef v3 = *(const __CFData **)(*(void *)(a1 + 8) + 400);
  if (v3) {
    CFDataGetBytePtr(v3);
  }
  if (CKFileDigestResultsCreate())
  {
    if (CKRegisterFile())
    {
      CFTypeRef error = 0;
      int v5 = 0;
      goto LABEL_17;
    }
    CFStringRef v6 = mmcs_item_copy_description(*(void *)(a1 + 8));
    uint64_t v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOBYTE(v36) = (_BYTE)v6;
      CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to register item %@");
      uint64_t v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)stat buf = 138543362;
        CFStringRef v39 = v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v8) {
        CFRelease(v8);
      }
    }
    if (v6) {
      CFRelease(v6);
    }
    CFTypeRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 19, @"Unable to register item");
    uint64_t v10 = *(uint64_t **)(a1 + 8);
    mmcs_get_item_progress_make_done_error((uint64_t)error, buf);
    mmcs_get_request_set_progress_and_notify_item(v2, v10, (unsigned int *)buf);
    if (error)
    {
      CFRetain(error);
      C3BaseRelease(error);
    }
  }
  else
  {
    CFTypeRef error = 0;
  }
  int v5 = 1;
LABEL_17:
  if (v40[0]) {
    C3BaseRelease(v40[0]);
  }
  if (v5) {
    goto LABEL_40;
  }
  uint64_t v11 = **(void **)a1;
  mmcs_chunk_instance_offset(v11);
  CFDataRef v12 = *(uint64_t **)(a1 + 8);
  if (!CKUnregisterChunksForItem())
  {
    uint64_t v36 = v12[5];
    CFStringRef v25 = @"chunks for item %lld could not be unregistered.";
LABEL_30:
    CFIndex v26 = 29;
LABEL_31:
    CFErrorRef v32 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v26, v25, v13, v14, v15, v16, v17, v36);
    if (!v32) {
      CFErrorRef v32 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"No local error was specified", v27, v28, v29, v30, v31, v37);
    }
    uint64_t v33 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v34 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to register chunks for item %lld: %@", v12[5], v32);
      uint64_t v35 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v40[0]) = 138543362;
        *(CFTypeRef *)((char *)v40 + 4) = v34;
        _os_log_impl(&dword_1DC1CA000, v35, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)v40, 0xCu);
      }
      if (v34) {
        CFRelease(v34);
      }
    }
    mmcs_get_item_progress_make_done_error((uint64_t)v32, buf);
    mmcs_get_request_set_progress_and_notify_item(v11, v12, (unsigned int *)buf);
    CFTypeRef error = CFRetain(v32);
    if (v32) {
      CFRelease(v32);
    }
LABEL_40:
    mmcs_get_file_metadata_completed_with_error(a1, (uint64_t)error);
    uint64_t v23 = 0;
    uint64_t result = 0;
    if (!error) {
      return result;
    }
    goto LABEL_41;
  }
  if (v12[18])
  {
    uint64_t v18 = 0;
    unint64_t v19 = 0;
    while (1)
    {
      uint64_t v20 = v12[34];
      if (!*(void *)(v20 + v18 + 72)) {
        mmcs_get_file_complete_metadata_only_file_cold_1();
      }
      uint64_t RegisteredChunk = mmcs_chunk_instance_create_RegisteredChunk();
      if (!RegisteredChunk)
      {
        CFStringRef v25 = @"No memory to create a registered chunk";
        CFIndex v26 = 36;
        goto LABEL_31;
      }
      int v22 = (void *)RegisteredChunk;
      CKRegisteredChunkSetLocation();
      if ((CKRegisterChunk() & 1) == 0) {
        break;
      }
      *(void *)(v20 + v18 + 40) = CKRegisteredChunkRowID();
      free(v22);
      ++v19;
      v18 += 104;
      if (v19 >= v12[18]) {
        goto LABEL_27;
      }
    }
    free(v22);
    uint64_t v36 = v12[5];
    CFStringRef v25 = @"chunk for item %lld could not be registered.";
    goto LABEL_30;
  }
LABEL_27:
  mmcs_get_req_item_set_done_success_and_notify_item(v11, v12, 0);
  uint64_t v23 = 1;
  uint64_t result = 1;
  if (!error) {
    return result;
  }
LABEL_41:
  CFRelease(error);
  return v23;
}

uint64_t mmcs_get_file_create_buffer(uint64_t a1, CFErrorRef *a2)
{
  if (*(void *)(a1 + 32)) {
    return 1;
  }
  *(void *)(a1 + 40) = 0x8000;
  uint64_t v4 = malloc_type_malloc(0x8000uLL, 0xAE2500E0uLL);
  *(void *)(a1 + 32) = v4;
  if (v4) {
    return 1;
  }
  if (!a2) {
    return 0;
  }
  CFErrorRef v11 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, @"No memory to create buffer for get_file", v5, v6, v7, v8, v9, v12);
  uint64_t result = 0;
  *a2 = v11;
  return result;
}

void mmcs_get_file_notify_locally_fulfilled_chunk_reference(unsigned int *a1, uint64_t a2)
{
  if (!mmcs_item_remove_outstanding_chunk_reference(*(void *)(a2 + 8), a1)) {
    mmcs_get_file_notify_locally_fulfilled_chunk_reference_cold_1();
  }
  mmcs_get_state_decrement_outstanding_chunk_references_count(*(CFMutableDictionaryRef **)a2, a1);
  uint64_t v4 = *(void *)(a2 + 8);
  unint64_t v5 = a1[1];
  mmcs_item_update_get_progress(v4, v5);
}

BOOL mmcs_index_set_create(uint64_t *a1)
{
  *a1 = 0;
  uint64_t v2 = C3TypeRegister(&mmcs_index_setGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v2, 8uLL);
  if (Instance)
  {
    *(void *)(Instance + 16) = objc_alloc_init(MEMORY[0x1E4F28E60]);
    *a1 = Instance;
  }
  return Instance != 0;
}

uint64_t mmcs_index_set_add_index(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (!v2) {
    mmcs_index_set_add_index_cold_1();
  }
  return [v2 addIndex:a2];
}

void *mmcs_index_set_add_range(uint64_t a1, int a2, int a3)
{
  uint64_t result = *(void **)(a1 + 16);
  if (!result) {
    mmcs_index_set_add_range_cold_1();
  }
  if (a3 - a2 != -1)
  {
    return objc_msgSend(result, "addIndexesInRange:", a2, a3 - a2 + 1);
  }
  return result;
}

uint64_t mmcs_index_set_contains_index(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (!v2) {
    mmcs_index_set_contains_index_cold_1();
  }
  return [v2 containsIndex:a2];
}

uint64_t mmcs_index_set_contains_range(uint64_t a1, int a2, int a3)
{
  CFDataRef v3 = *(void **)(a1 + 16);
  if (!v3) {
    mmcs_index_set_contains_range_cold_1();
  }
  uint64_t v4 = 1;
  if (a3 - a2 != -1) {
    return objc_msgSend(v3, "containsIndexesInRange:", a2, a3 - a2 + 1);
  }
  return v4;
}

uint64_t mmcs_index_set_count(uint64_t a1)
{
  double v1 = *(void **)(a1 + 16);
  if (!v1) {
    mmcs_index_set_count_cold_1();
  }
  return [v1 count];
}

uint64_t mmcs_index_set_apply_function(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDataRef v3 = *(void **)(a1 + 16);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __mmcs_index_set_apply_function_block_invoke;
  v5[3] = &__block_descriptor_48_e24_v32__0__NSRange_QQ_8_B24l;
  v5[4] = a2;
  v5[5] = a3;
  return [v3 enumerateRangesUsingBlock:v5];
}

uint64_t __mmcs_index_set_apply_function_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  unint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, void))(result + 32);
  if (v5) {
    uint64_t result = v5(a2, a3, *(void *)(result + 40));
  }
  *a4 = 0;
  return result;
}

void _mmcs_index_setCFFinalize(uint64_t a1)
{
  double v1 = *(void **)(a1 + 16);
  if (v1) {
}
  }

BOOL _mmcs_index_setCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_index_setCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_index_setCFCopyDebugDescription()
{
  return 0;
}

UInt8 *mmcs_working_directory_file_path(const __CFURL *a1, const char *a2, uint64_t a3, char **a4, CFErrorRef *a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!a4) {
    mmcs_working_directory_file_path_cold_1();
  }
  uint64_t result = (UInt8 *)malloc_type_calloc(1uLL, 0x401uLL, 0x881DD53EuLL);
  if (result)
  {
    CFErrorRef v11 = (char *)result;
    if (CFURLGetFileSystemRepresentation(a1, 1u, result, 1025))
    {
      size_t v12 = strnlen(v11, 0x400uLL);
      if (v12 - 1025 <= 0xFFFFFFFFFFFFFBFFLL) {
        mmcs_working_directory_file_path_cold_2();
      }
      if (snprintf(&v11[v12], 1025 - v12, "/%s-0x%016llx", a2, a3) > 0)
      {
        size_t v13 = strlen(v11) + 1;
        uint64_t v14 = (char *)malloc_type_calloc(1uLL, v13, 0x94A10851uLL);
        *a4 = v14;
        if (v14)
        {
          strncpy(v14, v11, v13);
          free(v11);
          return (UInt8 *)1;
        }
        goto LABEL_18;
      }
      if (!a5)
      {
LABEL_18:
        free(v11);
        return 0;
      }
      unint64_t v19 = __error();
      strerror(*v19);
      __error();
      CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Unable to get file path for item %lld: snprintf returned %d. %s(%d)", v20, v21, v22, v23, v24, a3);
    }
    else
    {
      uint64_t v15 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Bad working directory passed to MMCSEngineRef.");
        uint64_t v17 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)stat buf = 138543362;
          CFStringRef v26 = v16;
          _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v16) {
          CFRelease(v16);
        }
      }
      if (!a5) {
        goto LABEL_18;
      }
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 10, @"Bad working directory passed to MMCSEngineRef.");
    }
    *a5 = error;
    goto LABEL_18;
  }
  return result;
}

UInt8 *mmcs_engine_file_path(uint64_t a1, const char *a2, uint64_t a3, char **a4, CFErrorRef *a5)
{
  return mmcs_working_directory_file_path(*(const __CFURL **)(a1 + 128), a2, a3, a4, a5);
}

uint64_t mmcs_get_item_progress_make_state@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0xBFF0000000000000;
  *(_DWORD *)a2 = result;
  a2[2] = 0;
  return result;
}

uint64_t mmcs_get_item_progress_make_state_progress@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  *(void *)a2 = 0;
  *(_DWORD *)a2 = result;
  *(double *)(a2 + 8) = a3;
  *(void *)(a2 + 16) = 0;
  return result;
}

void mmcs_get_item_progress_make_done_error(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  a2[1] = 0xBFF0000000000000;
  *(_DWORD *)a2 = 5;
  if (!a1)
  {
    uint64_t v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"non-NULL error expected");
      uint64_t v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        int v7 = 138543362;
        CFStringRef v8 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v7, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
  }
  a2[2] = a1;
}

void mmcs_get_request_set_progress_and_notify_item(uint64_t a1, uint64_t *a2, unsigned int *a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  __int16 v32 = 0;
  *(_OWORD *)stat buf = *(_OWORD *)a3;
  uint64_t v34 = *((void *)a3 + 2);
  mmcs_item_set_get_progress((uint64_t)a2, (unsigned int *)buf, (BOOL *)&v32 + 1, (char *)&v32);
  uint64_t v6 = *((void *)a3 + 2);
  if (*a3 == 5)
  {
    if (!v6)
    {
      int v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Notifying that get item is done without an error specified. Creating an internal error instead.");
        uint64_t v14 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)stat buf = 138543362;
          *(void *)&uint8_t buf[4] = v13;
          _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v13) {
          CFRelease(v13);
        }
      }
      uint64_t v15 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Notifying get item state done without an error specified.", v8, v9, v10, v11, v12, v31);
      uint64_t v6 = (uint64_t)v15;
      goto LABEL_19;
    }
LABEL_18:
    uint64_t v15 = 0;
    goto LABEL_19;
  }
  if (!v6) {
    goto LABEL_18;
  }
  uint64_t v15 = mmcs_cferror_copy_description(*((__CFError **)a3 + 2));
  CFStringRef v16 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Notifying a get item state change %d with error %@.", *a3, v15);
    uint64_t v18 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)stat buf = 138543362;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v17) {
      CFRelease(v17);
    }
  }
  if (v15)
  {
    CFRelease(v15);
    uint64_t v15 = 0;
  }
  uint64_t v6 = 0;
LABEL_19:
  if (mmcs_engine_get_sparse_block_size()) {
    mmcs_engine_get_sparse_block_size();
  }
  if (HIBYTE(v32))
  {
    uint64_t v19 = *(void *)(a1 + 40);
    uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 152);
    uint64_t v21 = a2[5];
    CFDataRef v22 = (const __CFData *)a2[50];
    if (v22) {
      BytePtr = CFDataGetBytePtr(v22);
    }
    else {
      BytePtr = (const UInt8 *)*a2;
    }
    MMCSEngineClientContextGetItemProgress(v20, v19, v21, (uint64_t)BytePtr, *a3, v6);
  }
  if ((_BYTE)v32)
  {
    results_dictionary_for_item = mmcs_item_create_results_dictionary_for_item(a2);
    uint64_t v25 = *(void *)(a1 + 32);
    uint64_t v26 = *(void *)(a1 + 40);
    uint64_t v27 = *(void **)(v25 + 152);
    uint64_t v28 = a2[5];
    CFDataRef v29 = (const __CFData *)a2[50];
    uint64_t v30 = v29 ? CFDataGetBytePtr(v29) : (const UInt8 *)*a2;
    MMCSEngineClientContextGetItemDone(v27, v26, v28, (uint64_t)v30, 0, v6, (uint64_t)results_dictionary_for_item);
    if (results_dictionary_for_item) {
      CFRelease(results_dictionary_for_item);
    }
  }
  if (v15) {
    CFRelease(v15);
  }
}

void mmcs_get_request_set_progress_and_notify_items_like_item(uint64_t a1, const void *a2, long long *a3)
{
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 304) + 64), a2);
  if (Value)
  {
    CFArrayRef v6 = Value;
    uint64_t v7 = a1;
    long long v8 = *a3;
    uint64_t v9 = *((void *)a3 + 2);
    v10.unsigned int length = CFArrayGetCount(Value);
    v10.CFIndex location = 0;
    CFArrayApplyFunction(v6, v10, (CFArrayApplierFunction)_mmcs_item_set_progress_and_notify, &v7);
  }
}

void _mmcs_item_set_progress_and_notify(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  long long v4 = *(_OWORD *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 24);
  mmcs_get_request_set_progress_and_notify_item(v3, a1, (unsigned int *)&v4);
}

void mmcs_get_request_set_progress_and_notify_items_like_items_in_set(uint64_t a1, CFSetRef theSet, long long *a3)
{
  if (theSet)
  {
    uint64_t v3 = a1;
    long long v4 = *a3;
    uint64_t v5 = *((void *)a3 + 2);
    CFSetApplyFunction(theSet, (CFSetApplierFunction)_mmcs_get_request_set_progress_and_notify_items_like_items_in_set_applier, &v3);
  }
}

void _mmcs_get_request_set_progress_and_notify_items_like_items_in_set_applier(const void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  long long v4 = *(_OWORD *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 24);
  mmcs_get_request_set_progress_and_notify_items_like_item(v3, a1, &v4);
}

void mmcs_get_req_item_set_done_success_and_notify_item(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  __int16 v22 = 0;
  *(void *)&long long buf = 5;
  *((void *)&buf + 1) = 0xBFF0000000000000;
  uint64_t v24 = 0;
  mmcs_item_set_get_progress((uint64_t)a2, (unsigned int *)&buf, (BOOL *)&v22 + 1, (char *)&v22);
  if (mmcs_engine_get_sparse_block_size()) {
    mmcs_engine_get_sparse_block_size();
  }
  if (HIBYTE(v22))
  {
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 152);
    uint64_t v8 = a2[5];
    CFDataRef v9 = (const __CFData *)a2[50];
    if (v9) {
      BytePtr = CFDataGetBytePtr(v9);
    }
    else {
      BytePtr = (const UInt8 *)*a2;
    }
    MMCSEngineClientContextGetItemProgress(v7, v6, v8, (uint64_t)BytePtr, 5, 0);
  }
  int v11 = v22;
  if (a3 && !(_BYTE)v22)
  {
    uint64_t v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Ignoring successful get of %s", a3);
      uint64_t v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v13;
        _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v13) {
        CFRelease(v13);
      }
    }
    int v11 = v22;
  }
  if (v11)
  {
    results_dictionary_for_item = mmcs_item_create_results_dictionary_for_item(a2);
    uint64_t v16 = *(void *)(a1 + 32);
    uint64_t v17 = *(void *)(a1 + 40);
    uint64_t v18 = *(void **)(v16 + 152);
    uint64_t v19 = a2[5];
    CFDataRef v20 = (const __CFData *)a2[50];
    if (v20) {
      uint64_t v21 = CFDataGetBytePtr(v20);
    }
    else {
      uint64_t v21 = (const UInt8 *)*a2;
    }
    MMCSEngineClientContextGetItemDone(v18, v17, v19, (uint64_t)v21, a3, 0, (uint64_t)results_dictionary_for_item);
    if (results_dictionary_for_item) {
      CFRelease(results_dictionary_for_item);
    }
  }
}

void mmcs_get_request_set_progress_and_notify_all_items_not_done(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(void *)(a1 + 304);
  if (*(void *)(v2 + 168))
  {
    unint64_t v5 = 0;
    uint64_t v6 = 348;
    do
    {
      if (*(_DWORD *)(v2 + v6) != 5)
      {
        long long v7 = *a2;
        uint64_t v8 = *((void *)a2 + 2);
        mmcs_get_request_set_progress_and_notify_item(a1, (uint64_t *)(v2 + v6 - 172), (unsigned int *)&v7);
        uint64_t v2 = *(void *)(a1 + 304);
      }
      ++v5;
      v6 += 416;
    }
    while (v5 < *(void *)(v2 + 168));
  }
}

uint64_t mmcs_get_request_notify_all_items_with_pending_progress(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 304);
  if (*(void *)(v1 + 168))
  {
    uint64_t v2 = result;
    unint64_t v3 = 0;
    uint64_t v4 = 348;
    do
    {
      if (*(_DWORD *)(v1 + v4) != 5)
      {
        uint64_t result = mmcs_get_request_notify_item_with_pending_progress(v2, v1 + v4 - 172);
        uint64_t v1 = *(void *)(v2 + 304);
      }
      ++v3;
      v4 += 416;
    }
    while (v3 < *(void *)(v1 + 168));
  }
  return result;
}

uint64_t mmcs_get_request_notify_item_with_pending_progress(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 328))
  {
    uint64_t v3 = result;
    *(unsigned char *)(a2 + 328) = 0;
    if (mmcs_engine_get_sparse_block_size()) {
      mmcs_engine_get_sparse_block_size();
    }
    uint64_t v4 = *(void *)(v3 + 40);
    uint64_t v5 = *(void *)(*(void *)(v3 + 32) + 152);
    uint64_t v6 = *(void *)(a2 + 40);
    uint64_t v7 = *(void *)a2;
    uint64_t v8 = *(unsigned int *)(a2 + 172);
    uint64_t v9 = *(void *)(a2 + 192);
    return MMCSEngineClientContextGetItemProgress(v5, v4, v6, v7, v8, v9);
  }
  return result;
}

const void *mmcs_get_req_get_chunk_reference(uint64_t a1, int a2, uint64_t a3, unint64_t a4)
{
  v5[0] = 0;
  uint64_t v10 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  v5[1] = a2;
  uint64_t v6 = a3;
  long long v7 = a4;
  return CFSetGetValue(*(CFSetRef *)(*(void *)(a1 + 304) + 104), v5);
}

void *mmcs_get_req_get_or_create_chunk_reference(uint64_t a1, int a2, unsigned char *a3, uint64_t a4, unsigned char *a5)
{
  if (a5) {
    *a5 = 0;
  }
  LODWORD(value[0]) = 0;
  uint64_t v15 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  HIDWORD(value[0]) = a2;
  value[1] = a3;
  long long v12 = (unint64_t)a4;
  uint64_t result = (void *)CFSetGetValue(*(CFSetRef *)(*(void *)(a1 + 304) + 104), value);
  value[0] = result;
  if (result)
  {
    if (a5) {
      *a5 = 1;
    }
  }
  else if (mmcs_chunk_reference_create(value, a2, a3, a4, 1))
  {
    CFSetSetValue(*(CFMutableSetRef *)(*(void *)(a1 + 304) + 104), value[0]);
    return value[0];
  }
  else
  {
    return 0;
  }
  return result;
}

__CFDictionary *mmcs_wrapping_state_create_wrapping_state_dictionary(uint64_t a1)
{
  if (!*(void *)a1 && !*(void *)(a1 + 8)) {
    return 0;
  }
  CFMutableSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v3 = Mutable;
  if (*(void *)a1) {
    CFDictionarySetValue(Mutable, @"kMMCSReferenceSignature", *(const void **)a1);
  }
  uint64_t v4 = *(const void **)(a1 + 8);
  if (v4) {
    CFDictionarySetValue(v3, @"kMMCSReferenceObject", v4);
  }
  return v3;
}

uint64_t mmcs_wrapping_state_init_with_dictionary(uint64_t a1, CFDictionaryRef theDict, CFErrorRef *a3)
{
  CFArrayRef Value = CFDictionaryGetValue(theDict, @"kMMCSReferenceSignature");
  if (Value && (CFTypeID v7 = CFDataGetTypeID(), v7 != CFGetTypeID(Value)))
  {
    CFErrorRef v26 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Invalid item option kMMCSReferenceSignature type: Expected data, Got %@", v8, v9, v10, v11, v12, (char)Value);
  }
  else
  {
    long long v13 = CFDictionaryGetValue(theDict, @"kMMCSReferenceObject");
    if (!v13)
    {
LABEL_7:
      mmcs_wrapping_state_set_reference_signature_and_object(a1, Value, v13);
      return 1;
    }
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v13))
    {
      if (CFDataGetLength((CFDataRef)v13) == 16 || CFDataGetLength((CFDataRef)v13) == 32) {
        goto LABEL_7;
      }
      CFErrorRef v26 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Invalid item option kMMCSReferenceObject type: Expected data 16 bytes long, Got %@", v20, v21, v22, v23, v24, (char)v13);
    }
    else
    {
      CFErrorRef v26 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Invalid item option kMMCSReferenceObject type: Expected data, Got %@", v15, v16, v17, v18, v19, (char)v13);
    }
  }
  CFErrorRef v27 = v26;
  if (a3)
  {
    *a3 = v26;
    CFRetain(v26);
  }
  if (v27) {
    CFRelease(v27);
  }
  return 0;
}

uint64_t mmcs_wrapping_state_init_with_option_dict(uint64_t a1, CFDictionaryRef theDict, void *key, uint64_t a4)
{
  char v5 = (char)key;
  CFTypeRef cf = 0;
  CFArrayRef Value = CFDictionaryGetValue(theDict, key);
  if (!Value) {
    return 1;
  }
  uint64_t v8 = Value;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v8))
  {
    CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Invalid item option %@ type: Expected dictionary, Got %@", v10, v11, v12, v13, v14, v5);
LABEL_7:
    if (a4)
    {
      CFTypeRef v15 = cf;
      *(void *)a4 = cf;
      CFRetain(v15);
      a4 = 0;
    }
    goto LABEL_9;
  }
  if (!mmcs_wrapping_state_init_with_dictionary(a1, (CFDictionaryRef)v8, (CFErrorRef *)&cf)) {
    goto LABEL_7;
  }
  a4 = 1;
LABEL_9:
  if (cf) {
    CFRelease(cf);
  }
  return a4;
}

uint64_t mmcs_get_req_context_get_current_request_metrics(uint64_t a1)
{
  return *(void *)(a1 + 184);
}

__CFArray *mmcs_get_req_context_setup_complete_metrics(__CFArray *result, uint64_t a2)
{
  if (*((void *)result + 23))
  {
    uint64_t v2 = result;
    mmcs_http_context_make_metrics(*(char **)(*((void *)result + 38) + 144), @"getComplete", 0, a2, 0);
    uint64_t v3 = (__CFArray *)*((void *)v2 + 23);
    uint64_t metrics = (void *)mmcs_http_context_get_metrics(*(void *)(*((void *)v2 + 38) + 144));
    return mmcs_metrics_request_add_http_info_for_completion(v3, metrics);
  }
  return result;
}

uint64_t mmcs_get_req_context_get_get_state(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 304) + 112);
}

uint64_t mmcs_get_req_context_use_registry(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 304) + 8);
}

uint64_t mmcs_get_req_context_use_reader_writer_callback(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 304) + 9);
}

uint64_t mmcs_get_req_context_force_get_chunks(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 304) + 13);
}

const void *mmcs_get_req_context_get_items_array_for_item(uint64_t a1, const void *a2)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 304) + 64), a2);
}

uint64_t mmcs_get_req_context_should_validate_file_content_for_v1(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 304) + 11);
}

uint64_t mmcs_get_req_context_should_validate_file_content_for_v2(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 304) + 12);
}

uint64_t mmcs_get_req_create(void *a1, uint64_t a2, uint64_t a3, void *a4, const void *a5, const char *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, CFErrorRef *a16)
{
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    mmcs_get_req_create_cold_1();
  }
  uint64_t v23 = a16;
  *a1 = 0;
  uint64_t v124 = 0;
  if (!mmcs_get_request_alloc(&v124, a9) || !v124)
  {
    if (!a16)
    {
LABEL_107:
      int v117 = v124;
      if (*(void *)(v124[38] + 120))
      {
        mmcs_perform_timer_invalidate(*(void *)(v124[38] + 120));
        int v117 = v124;
        uint64_t v118 = v124[38];
        if (*(void *)(v118 + 120))
        {
          CFRelease(*(CFTypeRef *)(v118 + 120));
          int v117 = v124;
          uint64_t v118 = v124[38];
        }
        *(void *)(v118 + 120) = 0;
      }
      C3BaseRelease(v117);
      return 0;
    }
    CFStringRef v40 = @"Cannot allocate get request";
    CFIndex v41 = 36;
LABEL_13:
    CFErrorRef *v23 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v41, v40, v24, v25, v26, v27, v28, Count);
    goto LABEL_107;
  }
  kdebug_trace();
  CFErrorRef v123 = 0;
  if (!_mmcs_request_init((uint64_t)v124, a2, a3, a4, a5, a6, a15, &v123))
  {
    if (a16) {
      *a16 = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 37, v123, @"Cannot initialize underlying mmcs_request", v29, v30, v31, v32, Count);
    }
    if (v123) {
      CFRelease(v123);
    }
    CFErrorRef v123 = 0;
    goto LABEL_107;
  }
  uint64_t v33 = (uint64_t)v124;
  *(unsigned char *)(v124[38] + 59) = 0;
  *(unsigned char *)(*(void *)(v33 + 304) + 60) = 1;
  *(unsigned char *)(*(void *)(v33 + 304) + 41) = 0;
  BOOL v34 = 1;
  if (!a7)
  {
    uint64_t dataclass = mmcs_request_get_dataclass(v33);
    if (dataclass)
    {
      uint64_t v36 = "enabled";
      if (mmcs_request_is_cloudkit_dataclass(v33))
      {
        CFStringRef container_identifier = (const __CFString *)mmcs_request_get_container_identifier(v33);
        uint64_t v38 = (uint64_t (*)(uint64_t, uint64_t))container_identifier;
        if (container_identifier)
        {
          CFComparisonResult v39 = CFStringCompare(container_identifier, @"com.apple.clouddocs", 1uLL);
          BOOL v34 = v39 != kCFCompareEqualTo;
          if (v39 == kCFCompareEqualTo) {
            uint64_t v36 = "disabled";
          }
        }
        else
        {
          BOOL v34 = 0;
          uint64_t v36 = "disabled";
        }
      }
      else
      {
        uint64_t v38 = 0;
      }
    }
    else
    {
      BOOL v34 = 0;
      uint64_t v38 = 0;
      uint64_t v36 = "disabled";
    }
    uint64_t v42 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = v36;
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = dataclass;
      *(_WORD *)&buf[22] = 2114;
      uint64_t v126 = v38;
      _os_log_impl(&dword_1DC1CA000, v42, OS_LOG_TYPE_DEFAULT, "file content validation %{public}s by default for dataclass %{public}@ with container %{public}@. Does not impact chunk validation.", buf, 0x20u);
    }
    uint64_t v23 = a16;
  }
  uint64_t v43 = (uint64_t)v124;
  *(unsigned char *)(v124[38] + 11) = v34;
  *(unsigned char *)(*(void *)(v43 + 304) + 12) = 1;
  *(_WORD *)(*(void *)(v43 + 304) + 8) = 1;
  *(unsigned char *)(*(void *)(v43 + 304) + 57) = 0;
  *(unsigned char *)(*(void *)(v43 + 304) + 56) = 0;
  *(void *)(*(void *)(v43 + 304) + 48) = 0;
  *(unsigned char *)(*(void *)(v43 + 304) + 13) = 0;
  *(unsigned char *)(*(void *)(v43 + 304) + 58) = 0;
  **(void **)(v43 + 304) = 0;
  *(unsigned char *)(v124[38] + 10) = 0;
  char BOOLean_from_cfdictionary_object_for_key = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionReturnOpaqueCloneContext", 0);
  *(unsigned char *)(v124[38] + 152) = BOOLean_from_cfdictionary_object_for_key;
  CFStringRef cfBOOLean_from_cfpreferences_object_for_key = mmcs_get_cfBOOLean_from_cfpreferences_object_for_key(@"kMMCSDefaultReaderWriterSparseAware", 0);
  if (a4)
  {
    char v46 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionReaderWriterCallbackForDownloads", *(unsigned __int8 *)(v124[38] + 9));
    uint64_t v47 = (uint64_t)v124;
    *(unsigned char *)(v124[38] + 9) = v46;
    char v48 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestValidateFileContents", *(unsigned __int8 *)(*(void *)(v47 + 304) + 11));
    uint64_t v49 = (uint64_t)v124;
    *(unsigned char *)(v124[38] + 11) = v48;
    char v50 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestValidateFileContents", *(unsigned __int8 *)(*(void *)(v49 + 304) + 12));
    uint64_t v51 = (uint64_t)v124;
    *(unsigned char *)(v124[38] + 12) = v50;
    char v52 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionUseRegistryForDownloads", *(unsigned __int8 *)(*(void *)(v51 + 304) + 8));
    uint64_t v53 = (uint64_t)v124;
    *(unsigned char *)(v124[38] + 8) = v52;
    CFNumberRef v54 = mmcs_copy_cfnumber_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionCacheDeleteAvailableSpaceClass", *(const void **)(*(void *)(v53 + 304) + 48));
    uint64_t v55 = (uint64_t)v124;
    *(void *)(v124[38] + 48) = v54;
    char v56 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionErrorOnPreallocationFailure", *(unsigned __int8 *)(*(void *)(v55 + 304) + 56));
    uint64_t v57 = (uint64_t)v124;
    *(unsigned char *)(v124[38] + 56) = v56;
    char v58 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionForceGetChunks", *(unsigned __int8 *)(*(void *)(v57 + 304) + 13));
    uint64_t v59 = (uint64_t)v124;
    *(unsigned char *)(v124[38] + 13) = v58;
    char v60 = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionInsufficientDiskSpaceMode", *(unsigned __int8 *)(*(void *)(v59 + 304) + 58));
    *(unsigned char *)(v124[38] + 58) = v60;
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionItemOptions");
    if (Value)
    {
      CFTypeID TypeID = CFArrayGetTypeID();
      if (TypeID == CFGetTypeID(Value))
      {
        if (CFArrayGetCount(Value) != a9)
        {
          if (!v23) {
            goto LABEL_107;
          }
          char Count = CFArrayGetCount(Value);
          CFStringRef v40 = @"Item options array had %d elements but request had %d elements";
LABEL_31:
          CFIndex v41 = 37;
          goto LABEL_13;
        }
      }
      else
      {
        CFArrayRef Value = 0;
      }
    }
    cfchar BOOLean_from_cfdictionary_object_for_key = (const __CFBoolean *)mmcs_get_cfBOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestForceGetCompleteRequest", 0);
    if (cfBOOLean_from_cfdictionary_object_for_key)
    {
      CFBooleanRef v64 = cfBOOLean_from_cfdictionary_object_for_key;
      *(unsigned char *)(v124[38] + 59) = 1;
      Boolean v65 = CFBooleanGetValue(cfBOOLean_from_cfdictionary_object_for_key);
      *(unsigned char *)(v124[38] + 60) = v65;
      CFRelease(v64);
    }
    CFStringRef cfBOOLean_from_cfpreferences_object_for_key = mmcs_get_cfBOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSDefaultReaderWriterSparseAware", (uint64_t)cfBOOLean_from_cfpreferences_object_for_key);
  }
  else
  {
    CFArrayRef Value = 0;
  }
  CFAllocatorRef v66 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &itemsBySignatureReferenceDictionaryKeyCallbacks, MEMORY[0x1E4F1D540]);
  *(void *)(v124[38] + 64) = Mutable;
  CFMutableSetRef v68 = CFSetCreateMutable(v66, 0, &itemSignatureReferenceEqualitySetCallbacks);
  *(void *)(v124[38] + 80) = v68;
  CFMutableSetRef v69 = CFSetCreateMutable(v66, 0, &itemItemIDEqualitySetCallbacks);
  *(void *)(v124[38] + 72) = v69;
  CFMutableSetRef v70 = CFSetCreateMutable(v66, 0, &chunkReferenceSignatureEqualitySetCallbacks);
  uint64_t v72 = (uint64_t)v124;
  *(void *)(v124[38] + 104) = v70;
  uint64_t v121 = (uint64_t)cfBOOLean_from_cfpreferences_object_for_key;
  CFArrayRef v122 = Value;
  if (*(unsigned char *)(a2 + 175))
  {
    uint64_t v73 = mmcs_metrics_request_create(@"get");
    uint64_t v72 = (uint64_t)v124;
    v124[23] = v73;
  }
  *(void *)(*(void *)(v72 + 304) + 168) = a9;
  uint64_t v74 = *(void **)(v72 + 304);
  if (!v74[8]) {
    goto LABEL_107;
  }
  if (!v74[10]) {
    goto LABEL_107;
  }
  if (!v74[9]) {
    goto LABEL_107;
  }
  if (!v74[13]) {
    goto LABEL_107;
  }
  if (!*(void *)(v72 + 168)) {
    goto LABEL_107;
  }
  uint64_t v75 = *(void *)(a2 + 56);
  *(void *)long long buf = v72;
  *(void *)&uint8_t buf[8] = C3BaseRetain;
  *(void *)&uint8_t buf[16] = C3BaseRelease;
  uint64_t v126 = _mmcs_get_req_context_progress_timer_fired;
  if (!mmcs_perform_target_create_timer(v75, (uint64_t)(v74 + 15), buf, v71)) {
    goto LABEL_107;
  }
  uint64_t v77 = v124[38];
  if (*(void *)(v77 + 168))
  {
    uint64_t v78 = 0;
    unint64_t v79 = 0;
    uint64_t v80 = a12;
    uint64_t v120 = v23;
    do
    {
      uint64_t v81 = v80 ? *(const char **)(v80 + 8 * v79) : 0;
      uint64_t v82 = (unsigned char **)(v77 + v78 + 176);
      if (!mmcs_item_init((uint64_t)v82, *(void *)(a10 + 8 * v79), *(unsigned __int8 **)(a11 + 8 * v79), v81, 0, 2, 0, v76))goto LABEL_107; {
      if (a13)
      }
        *(void *)(v77 + v78 + 520) = *(void *)(a13 + 8 * v79);
      if (a14) {
        *(void *)(v77 + v78 + 192) = *(void *)(a14 + 8 * v79);
      }
      if (v122)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v122, v79);
        CFTypeID v84 = CFDictionaryGetTypeID();
        if (v84 != CFGetTypeID(ValueAtIndex))
        {
          if (!v23) {
            goto LABEL_107;
          }
          char Count = (char)ValueAtIndex;
          CFStringRef v40 = @"Invalid item option type: Expected dictionary, Got %@";
          goto LABEL_31;
        }
        if (!mmcs_wrapping_state_init_with_option_dict(v77 + v78 + 224, (CFDictionaryRef)ValueAtIndex, @"kMMCSUnwrappingState", (uint64_t)v23))goto LABEL_107; {
        CFNumberRef v85 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"kMMCSFileSize");
        }
        if (v85)
        {
          if (a14)
          {
            int v86 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v87 = CFStringCreateWithFormat(v66, 0, @"Ignoring kMMCSFileSize because lengths are set");
              uint64_t v88 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v87;
                _os_log_impl(&dword_1DC1CA000, v88, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v87) {
                CFRelease(v87);
              }
            }
          }
          else
          {
            CFNumberRef v89 = v85;
            CFTypeID v90 = CFGetTypeID(v85);
            if (v90 == CFNumberGetTypeID())
            {
              *(void *)long long buf = 0;
              if (CFNumberGetValue(v89, kCFNumberSInt64Type, buf)) {
                *(void *)(v77 + v78 + 200) = *(void *)buf;
              }
            }
          }
        }
        CFNumberRef v91 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"kMMCSRequestedFileOffset");
        if (v91)
        {
          CFNumberRef v92 = v91;
          CFTypeID v93 = CFGetTypeID(v91);
          if (v93 == CFNumberGetTypeID())
          {
            *(void *)long long buf = 0;
            if (CFNumberGetValue(v92, kCFNumberSInt64Type, buf)) {
              *(void *)(v77 + v78 + 552) = *(void *)buf;
            }
          }
        }
        CFNumberRef v94 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"kMMCSRequestedLengthAtFileOffset");
        if (v94)
        {
          CFNumberRef v95 = v94;
          CFTypeID v96 = CFGetTypeID(v94);
          if (v96 == CFNumberGetTypeID())
          {
            *(void *)long long buf = 0;
            if (CFNumberGetValue(v95, kCFNumberSInt64Type, buf))
            {
              *(void *)(v77 + v78 + 560) = *(void *)buf;
              *(unsigned char *)(v124[38] + 10) = 0;
            }
          }
        }
        CFStringRef v97 = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"kMMCSRequestedRangeSignature");
        if (v97)
        {
          uint64_t v98 = v97;
          CFTypeID v99 = CFGetTypeID(v97);
          if (v99 == CFDataGetTypeID())
          {
            CFRetain(v98);
            *(void *)(v77 + v78 + 576) = v98;
          }
        }
        uint64_t v100 = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"kMMCSDerivativeAssetDownloadURL");
        if (v100)
        {
          BOOL v101 = v100;
          CFTypeID v102 = CFGetTypeID(v100);
          if (v102 == CFURLGetTypeID())
          {
            *(void *)(v77 + v78 + 536) = v101;
            CFRetain(v101);
          }
        }
        CFNumberRef v103 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"kMMCSDerivativeAssetEstimatedSize");
        if (v103)
        {
          CFNumberRef v104 = v103;
          CFTypeID v105 = CFGetTypeID(v103);
          if (v105 == CFNumberGetTypeID())
          {
            *(void *)long long buf = 0;
            if (CFNumberGetValue(v104, kCFNumberSInt64Type, buf))
            {
              uint64_t v106 = *(void *)buf;
              uint64_t v107 = v77 + v78;
              *(void *)(v107 + 488) = *(void *)buf;
              *(void *)(v107 + 192) = v106;
            }
          }
        }
        CFStringRef v108 = mmcs_get_cfBOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)ValueAtIndex, @"kMMCSDefaultReaderWriterSparseAware", v121);
        mmcs_item_set_default_reader_writer_sparse_aware(v77 + v78 + 176, (uint64_t)v108);
        uint64_t v109 = v77 + v78;
        *(unsigned char *)(v109 + 392) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)ValueAtIndex, @"kMMCSMetadataOnly", *(unsigned __int8 *)(v77 + v78 + 392));
        *(unsigned char *)(v109 + 584) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)ValueAtIndex, @"kMMCSFailPreallocationMode", *(unsigned __int8 *)(v77 + v78 + 584));
        uint64_t v23 = v120;
      }
      if ((**v82 & 0x7F) == 4 || (**v82 & 8) != 0) {
        *(unsigned char *)(v77 + v78 + 280) = 1;
      }
      CFSetAddValue(*(CFMutableSetRef *)(v124[38] + 72), (const void *)(v77 + v78 + 176));
      uint64_t v111 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v124[38] + 64), (const void *)(v77 + v78 + 176));
      if (!v111)
      {
        CFMutableArrayRef v112 = CFArrayCreateMutable(v66, 0, &itemArrayCallbacks);
        if (!v112) {
          goto LABEL_107;
        }
        uint64_t v111 = v112;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v124[38] + 64), (const void *)(v77 + v78 + 176), v112);
        CFRelease(v111);
        CFSetAddValue(*(CFMutableSetRef *)(v124[38] + 80), (const void *)(v77 + v78 + 176));
      }
      CFArrayAppendValue((CFMutableArrayRef)v111, (const void *)(v77 + v78 + 176));
      if (*(unsigned char *)(v77 + v78 + 584))
      {
        CFBooleanRef v113 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1DC1CA000, v113, OS_LOG_TYPE_ERROR, "********************* ENABLING TESTING MODE WHICH PRETENDS PREALLOCATION FAILS *********************", buf, 2u);
        }
      }
      ++v79;
      uint64_t v77 = v124[38];
      v78 += 416;
      uint64_t v80 = a12;
    }
    while (v79 < *(void *)(v77 + 168));
  }
  uint64_t v114 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)long long buf = v124;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(v124[38] + 64), (CFDictionaryApplierFunction)mmcs_get_req_context_items_by_signature_description, buf);
  }
  if (*(unsigned char *)(v124[38] + 58))
  {
    uint64_t v115 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v115, OS_LOG_TYPE_ERROR, "********************* ENABLING TESTING MODE WHICH PRETENDS THERE IS INSUFFICIENT DISK SPACE *********************", buf, 2u);
    }
  }
  *a1 = v124;
  return 1;
}

uint64_t _mmcs_get_req_context_progress_timer_fired(uint64_t a1, uint64_t a2)
{
  uint64_t result = mmcs_get_request_notify_all_items_with_pending_progress(a2);
  uint64_t v4 = *(void *)(*(void *)(a2 + 304) + 120);
  if (v4)
  {
    CFAbsoluteTimeGetCurrent();
    return mmcs_perform_timer_set_next_fire_date(v4);
  }
  return result;
}

void mmcs_get_request_finalize(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 304) + 120))
  {
    uint64_t v2 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)BOOL v34 = 0;
      _os_log_impl(&dword_1DC1CA000, v2, OS_LOG_TYPE_FAULT, "progressTimer must always be invalidated/freed first to break retain cycle, invariant violation.", v34, 2u);
    }
  }
  uint64_t v3 = *(void **)(a1 + 304);
  uint64_t v4 = v3[16];
  if (v4)
  {
    mmcs_http_context_clear_user_data(v4);
    mmcs_http_context_invalidate(*(void *)(*(void *)(a1 + 304) + 128));
    uint64_t v5 = *(void *)(a1 + 304);
    uint64_t v6 = *(const void **)(v5 + 128);
    if (v6)
    {
      C3BaseRelease(v6);
      uint64_t v5 = *(void *)(a1 + 304);
    }
    *(void *)(v5 + 128) = 0;
    uint64_t v3 = *(void **)(a1 + 304);
  }
  uint64_t v7 = v3[17];
  if (v7)
  {
    mmcs_http_context_clear_user_data(v7);
    mmcs_http_context_invalidate(*(void *)(*(void *)(a1 + 304) + 136));
    uint64_t v8 = *(void *)(a1 + 304);
    uint64_t v9 = *(const void **)(v8 + 136);
    if (v9)
    {
      C3BaseRelease(v9);
      uint64_t v8 = *(void *)(a1 + 304);
    }
    *(void *)(v8 + 136) = 0;
    uint64_t v3 = *(void **)(a1 + 304);
  }
  uint64_t v10 = v3[18];
  if (v10)
  {
    mmcs_http_context_invalidate(v10);
    uint64_t v11 = *(void *)(a1 + 304);
    uint64_t v12 = *(const void **)(v11 + 144);
    if (v12)
    {
      C3BaseRelease(v12);
      uint64_t v11 = *(void *)(a1 + 304);
    }
    *(void *)(v11 + 144) = 0;
    uint64_t v3 = *(void **)(a1 + 304);
  }
  uint64_t v13 = (const void *)v3[8];
  if (v13)
  {
    CFRelease(v13);
    uint64_t v3 = *(void **)(a1 + 304);
  }
  v3[8] = 0;
  uint64_t v14 = *(void *)(a1 + 304);
  CFTypeRef v15 = *(const void **)(v14 + 80);
  if (v15)
  {
    CFRelease(v15);
    uint64_t v14 = *(void *)(a1 + 304);
  }
  *(void *)(v14 + 80) = 0;
  uint64_t v16 = *(void *)(a1 + 304);
  uint64_t v17 = *(const void **)(v16 + 72);
  if (v17)
  {
    CFRelease(v17);
    uint64_t v16 = *(void *)(a1 + 304);
  }
  *(void *)(v16 + 72) = 0;
  uint64_t v18 = *(void *)(a1 + 304);
  uint64_t v19 = *(const void **)(v18 + 88);
  if (v19)
  {
    CFRelease(v19);
    uint64_t v18 = *(void *)(a1 + 304);
  }
  *(void *)(v18 + 88) = 0;
  uint64_t v20 = *(void *)(a1 + 304);
  uint64_t v21 = *(const void **)(v20 + 96);
  if (v21)
  {
    CFRelease(v21);
    uint64_t v20 = *(void *)(a1 + 304);
  }
  *(void *)(v20 + 96) = 0;
  uint64_t v22 = *(void *)(a1 + 304);
  CFSetRef v23 = *(const __CFSet **)(v22 + 104);
  if (v23)
  {
    CFSetApplyFunction(v23, (CFSetApplierFunction)dealloc_chunk_references, 0);
    uint64_t v24 = *(void *)(a1 + 304);
    uint64_t v25 = *(const void **)(v24 + 104);
    if (v25)
    {
      CFRelease(v25);
      uint64_t v24 = *(void *)(a1 + 304);
    }
    *(void *)(v24 + 104) = 0;
    uint64_t v22 = *(void *)(a1 + 304);
  }
  uint64_t v26 = *(const void **)(v22 + 16);
  if (v26)
  {
    CFRelease(v26);
    uint64_t v22 = *(void *)(a1 + 304);
  }
  *(void *)(v22 + 16) = 0;
  uint64_t v27 = *(CFTypeRef **)(a1 + 304);
  if (*v27)
  {
    CFRelease(*v27);
    uint64_t v27 = *(CFTypeRef **)(a1 + 304);
  }
  CFTypeRef *v27 = 0;
  uint64_t v28 = *(void *)(a1 + 304);
  uint64_t v29 = *(const void **)(v28 + 160);
  if (v29)
  {
    CFRelease(v29);
    uint64_t v28 = *(void *)(a1 + 304);
  }
  *(void *)(v28 + 160) = 0;
  uint64_t v30 = *(void *)(a1 + 304);
  uint64_t v31 = *(void **)(v30 + 112);
  if (v31)
  {
    mmcs_get_state_dealloc(v31);
    *(void *)(*(void *)(a1 + 304) + 112) = 0;
    uint64_t v30 = *(void *)(a1 + 304);
  }
  if (*(void *)(v30 + 168))
  {
    unint64_t v32 = 0;
    uint64_t v33 = 176;
    do
    {
      mmcs_item_finalize(v30 + v33);
      ++v32;
      uint64_t v30 = *(void *)(a1 + 304);
      v33 += 416;
    }
    while (v32 < *(void *)(v30 + 168));
  }
  *(void *)(v30 + 168) = 0;
}

BOOL mmcs_get_request_has_items_not_done(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  unint64_t v2 = *(void *)(v1 + 168);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (int *)(v1 + 348);
  unint64_t v4 = 1;
  do
  {
    int v5 = *v3;
    if (v4 >= v2) {
      break;
    }
    ++v4;
    v3 += 104;
  }
  while (v5 == 5);
  return v5 != 5;
}

BOOL mmcs_get_request_stop_with_error(uint64_t a1, CFErrorRef error)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  int v4 = *(unsigned __int8 *)(a1 + 144);
  int v5 = mmcs_logging_logger_default();
  BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
  if (v4)
  {
    if (result)
    {
      CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Already cancelling. Ignoring stop of get request %p.", a1);
      uint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v25 = v7;
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v7) {
        CFRelease(v7);
      }
      return 0;
    }
    return result;
  }
  if (result)
  {
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Stopping get request %p", a1);
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v25 = v9;
      _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v9) {
      CFRelease(v9);
    }
  }
  C3BaseRetain((CFTypeRef)a1);
  *(unsigned char *)(a1 + 144) = 1;
  if (error)
  {
    CFErrorRef v11 = 0;
  }
  else
  {
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 4, @"Get was cancelled.");
    CFErrorRef v11 = error;
  }
  CFRetain(error);
  *(void *)(a1 + 152) = error;
  mmcs_http_context_should_cancel(*(unsigned char **)(*(void *)(a1 + 304) + 128), error);
  mmcs_http_context_should_cancel(*(unsigned char **)(*(void *)(a1 + 304) + 136), *(__CFError **)(a1 + 152));
  mmcs_http_context_should_cancel(*(unsigned char **)(*(void *)(a1 + 304) + 144), *(__CFError **)(a1 + 152));
  uint64_t v12 = *(void *)(*(void *)(a1 + 304) + 112);
  if (v12)
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v12 + 40));
    if (Count >= 1)
    {
      CFIndex v14 = Count;
      for (CFIndex i = 0; i != v14; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v12 + 40), i);
        mmcs_container_cancel((uint64_t)ValueAtIndex, *(void *)(a1 + 152));
      }
    }
  }
  while (1)
  {
    uint64_t v18 = *(CFSetRef **)(a1 + 304);
    CFArrayRef v21 = v18[2];
    if (!v21) {
      break;
    }
    CFIndex v17 = CFArrayGetCount(v21);
    uint64_t v18 = *(CFSetRef **)(a1 + 304);
    if (v17 < 1) {
      break;
    }
    uint64_t v19 = (uint64_t **)CFArrayGetValueAtIndex(v18[2], 0);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(void *)(a1 + 304) + 16), 0);
    mmcs_get_file_abort_writing_file(v19);
    uint64_t v20 = v19[1];
    mmcs_get_item_progress_make_done_error(*(void *)(a1 + 152), buf);
    mmcs_get_request_set_progress_and_notify_item(a1, v20, (unsigned int *)buf);
  }
  if (*v18 && CFSetGetCount(*v18) >= 1)
  {
    CFSetApplyFunction(**(CFSetRef **)(a1 + 304), (CFSetApplierFunction)cancel_file_jobs, *(void **)(a1 + 152));
    CFSetRemoveAllValues(**(CFMutableSetRef **)(a1 + 304));
    char v22 = 0;
  }
  else
  {
    char v22 = 1;
  }
  uint64_t v23 = *(void *)(a1 + 192);
  if (v23 && mmcs_proxy_locator_is_locating(v23))
  {
    mmcs_proxy_locator_cancel(*(void *)(a1 + 192));
LABEL_32:
    mmcs_metrics_request_set_error(*(void *)(a1 + 184), *(const void **)(a1 + 152));
    mmcs_get_req_context_cleanup(a1, *(void *)(a1 + 152));
    goto LABEL_33;
  }
  if ((v22 & 1) == 0) {
    goto LABEL_32;
  }
LABEL_33:
  if (v11) {
    CFRelease(v11);
  }
  C3BaseRelease((CFTypeRef)a1);
  return 1;
}

void mmcs_get_req_context_cleanup(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(*(void *)(a1 + 304) + 120);
  if (v4)
  {
    mmcs_perform_timer_invalidate(v4);
    uint64_t v5 = *(void *)(a1 + 304);
    uint64_t v6 = *(const void **)(v5 + 120);
    if (v6)
    {
      CFRelease(v6);
      uint64_t v5 = *(void *)(a1 + 304);
    }
    *(void *)(v5 + 120) = 0;
  }
  if (a2)
  {
    v19[0] = 5;
    v19[1] = 0xBFF0000000000000;
    v19[2] = a2;
    CFStringRef v7 = (long long *)v19;
  }
  else
  {
    if (!*(unsigned char *)(a1 + 144)) {
      goto LABEL_10;
    }
    CFStringRef v7 = (long long *)v18;
    mmcs_get_item_progress_make_done_error(*(void *)(a1 + 152), v18);
  }
  mmcs_get_request_set_progress_and_notify_all_items_not_done(a1, v7);
LABEL_10:
  if (mmcs_engine_contains_request(*(void *)(a1 + 32), (const void *)a1))
  {
    if (*(unsigned char *)(*(void *)(a1 + 304) + 41))
    {
      if (gMMCS_DebugLevel >= 4)
      {
        uint64_t v8 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Deferring client request completed callback.");
          uint64_t v10 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v21 = v9;
            _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v9) {
            CFRelease(v9);
          }
        }
      }
    }
    else
    {
      if (gMMCS_DebugLevel >= 4)
      {
        CFTypeRef v15 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Performing client request completed callback.");
          CFIndex v17 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v21 = v16;
            _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v16) {
            CFRelease(v16);
          }
        }
      }
      mmcs_get_req_call_client_request_completed(a1);
    }
    if (!*(unsigned char *)(*(void *)(a1 + 304) + 41) || !mmcs_perform_getComplete(a1)) {
      mmcs_get_req_done_phase2((uint64_t *)a1);
    }
  }
  else
  {
    CFStringRef v11 = mmcs_request_copy_description(a1);
    uint64_t v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"ignoring unknown get req %@", v11);
      CFIndex v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v21 = v13;
        _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v13) {
        CFRelease(v13);
      }
    }
    if (v11) {
      CFRelease(v11);
    }
  }
}

void mmcs_get_request_append_description(uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  long long v2 = *(_OWORD *)(a1 + 16);
  long long context = *(_OWORD *)a1;
  *(_OWORD *)theCFStringRef String = v2;
  int64x2_t v22 = *(int64x2_t *)(a1 + 32);
  theString[1] = (CFMutableStringRef)(*((void *)&v2 + 1) + 1);
  if (*(void *)(a1 + 16))
  {
    CFStringRef v4 = _mmcs_request_copy_description(v1);
    if (v4)
    {
      CFStringRef v5 = v4;
      mmcs_op_requestor_context_indent(a1);
      CFStringAppend(*(CFMutableStringRef *)(a1 + 16), v5);
      CFStringAppend(*(CFMutableStringRef *)(a1 + 16), @"\n");
      CFRelease(v5);
      uint64_t v6 = *(void **)(v1 + 304);
      uint64_t v7 = v6[16];
      if (v7)
      {
        BOOL is_sending = mmcs_http_context_is_sending(v7);
        uint64_t v6 = *(void **)(v1 + 304);
        if (is_sending)
        {
          *(void *)&long long context = v6[16];
          mmcs_http_context_append_description((uint64_t)&context);
          uint64_t v6 = *(void **)(v1 + 304);
        }
      }
      uint64_t v9 = v6[17];
      if (v9)
      {
        BOOL v10 = mmcs_http_context_is_sending(v9);
        uint64_t v6 = *(void **)(v1 + 304);
        if (v10)
        {
          *(void *)&long long context = v6[17];
          mmcs_http_context_append_description((uint64_t)&context);
          uint64_t v6 = *(void **)(v1 + 304);
        }
      }
      uint64_t v11 = v6[14];
      if (v11)
      {
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v11 + 40));
        if (Count >= 1)
        {
          CFIndex v13 = Count;
          for (CFIndex i = 0; i != v13; ++i)
          {
            *(void *)&long long context = CFArrayGetValueAtIndex(*(CFArrayRef *)(v11 + 40), i);
            mmcs_container_append_description((uint64_t)&context);
          }
        }
        int64x2_t v15 = vaddq_s64(*(int64x2_t *)(a1 + 32), v22);
        *(int64x2_t *)(a1 + 32) = v15;
        if (v15.i64[1] >= 11)
        {
          mmcs_op_requestor_context_indent((uint64_t)&context);
          CFStringAppendFormat(theString[0], 0, @"<%ld more container(s)> enqueued\n", *(void *)(a1 + 40) - 10);
        }
      }
      CFSetRef v16 = **(const __CFSet ***)(v1 + 304);
      if (v16)
      {
        if (CFSetGetCount(v16) >= 1)
        {
          CFSetRef Copy = CFSetCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], **(CFSetRef **)(v1 + 304));
          if (Copy)
          {
            CFSetRef v18 = Copy;
            CFSetApplyFunction(Copy, (CFSetApplierFunction)_mmcs_get_request_append_description_file_job, &context);
            CFRelease(v18);
          }
        }
      }
      uint64_t v19 = *(void *)(*(void *)(v1 + 304) + 144);
      if (v19)
      {
        if (mmcs_http_context_is_sending(v19))
        {
          *(void *)&long long context = *(void *)(*(void *)(v1 + 304) + 144);
          mmcs_http_context_append_description((uint64_t)&context);
        }
      }
    }
  }
}

void _mmcs_get_request_append_description_file_job(uint64_t a1, void *a2)
{
  *a2 = a1;
  mmcs_file_job_append_description((uint64_t)a2);
}

void mmcs_get_req_add_item_for_get_chunks(uint64_t a1, void *value)
{
  CFStringRef v4 = *(__CFSet **)(*(void *)(a1 + 304) + 88);
  if (!v4)
  {
    *(void *)(*(void *)(a1 + 304) + 88) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &itemSignatureReferenceEqualitySetCallbacks);
    CFStringRef v4 = *(__CFSet **)(*(void *)(a1 + 304) + 88);
  }
  CFSetAddValue(v4, value);
  CFStringRef v5 = *(__CFSet **)(*(void *)(a1 + 304) + 96);
  if (!v5)
  {
    *(void *)(*(void *)(a1 + 304) + 96) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &itemItemIDEqualitySetCallbacks);
    CFStringRef v5 = *(__CFSet **)(*(void *)(a1 + 304) + 96);
  }
  CFSetAddValue(v5, value);
}

uint64_t mmcs_get_req_context_wants_getComplete(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (*(unsigned char *)(v1 + 59)) {
    return *(unsigned __int8 *)(v1 + 60);
  }
  unsigned int reporting_level = mmcs_request_get_reporting_level(a1);
  return mmcs_report_want_report(0, reporting_level);
}

uint64_t mmcs_get_req_done_phase2(uint64_t *a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1[38] + 41))
  {
    if (gMMCS_DebugLevel >= 4)
    {
      long long v2 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Performing deferred client file failures callback.");
        CFStringRef v4 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          int v11 = 138543362;
          CFStringRef v12 = v3;
          _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&v11, 0xCu);
        }
        if (v3) {
          CFRelease(v3);
        }
      }
    }
    CFStringRef v5 = *(CFArrayRef **)(a1[38] + 112);
    if (v5) {
      mmcs_get_state_container_fail_deferred_files(v5);
    }
    if (gMMCS_DebugLevel >= 4)
    {
      uint64_t v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Performing deferred client request completed callback.");
        uint64_t v8 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          int v11 = 138543362;
          CFStringRef v12 = v7;
          _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&v11, 0xCu);
        }
        if (v7) {
          CFRelease(v7);
        }
      }
    }
    mmcs_get_req_call_client_request_completed((uint64_t)a1);
  }
  mmcs_get_req_context_log_timing((uint64_t)a1);
  uint64_t v9 = *(void *)(a1[38] + 112);
  if (v9) {
    mmcs_get_state_invalidate(v9);
  }
  return mmcs_engine_remove_request(a1[4], a1);
}

void mmcs_get_req_call_client_request_completed(uint64_t a1)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  os_activity_scope_enter(request_activity_marker, &state);
  kdebug_trace();
  uint64_t v8 = *(void *)(a1 + 304);
  uint64_t v9 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (*(void *)(v8 + 168))
  {
    unint64_t v10 = 0;
    int v11 = 0;
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v13 = 348;
    do
    {
      if (*(_DWORD *)(v8 + v13) != 5)
      {
        CFStringRef v14 = mmcs_item_copy_description(v8 + v13 - 172);
        int64x2_t v15 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          char v38 = (char)v14;
          CFStringRef v16 = CFStringCreateWithFormat(v12, 0, @"Expected item %@ to be done by now.");
          CFIndex v17 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v42 = v16;
            _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v16) {
            CFRelease(v16);
          }
        }
        if (v14) {
          CFRelease(v14);
        }
        int v11 = 1;
      }
      ++v10;
      uint64_t v8 = *(void *)(a1 + 304);
      v13 += 416;
    }
    while (v10 < *(void *)(v8 + 168));
    uint64_t v9 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (v11)
    {
      CFErrorRef v18 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"The item should have already completed.", v3, v4, v5, v6, v7, v38);
      mmcs_get_item_progress_make_done_error((uint64_t)v18, &v39);
      mmcs_get_request_set_progress_and_notify_all_items_not_done(a1, &v39);
      if (v18) {
        CFRelease(v18);
      }
    }
  }
  *(unsigned char *)(*(void *)(a1 + 304) + 40) = 1;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(*v9, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (*(void *)(a1 + 184) && *(void *)(a1 + 32))
  {
    *(void *)(*(void *)(a1 + 32) + 192) = C3BaseRetain((CFTypeRef)a1);
    uint64_t v20 = *(void *)(a1 + 184);
    if (v20)
    {
      _mmcs_metrics_request_stopped(*(void *)(a1 + 184), 0, *(const void **)(a1 + 152));
      CFDictionaryRef Count = *(const __CFDictionary **)(*(void *)(a1 + 304) + 64);
      if (Count) {
        CFDictionaryRef Count = (const __CFDictionary *)CFDictionaryGetCount(Count);
      }
      *(void *)(v20 + 96) = Count;
      *(double *)(v20 + 24) = mmcs_server_version_as_double(*(void *)(a1 + 120), *(void *)(a1 + 128));
      uint64_t v22 = *(void *)(*(void *)(a1 + 304) + 112);
      if (v22 && *(void *)(v22 + 16))
      {
        uint64_t v23 = 0;
        unint64_t v24 = 0;
        int64x2_t v25 = *(int64x2_t *)(v20 + 104);
        uint64_t v26 = *(void *)(v20 + 120);
        do
        {
          uint64_t v27 = (int8x16_t *)(*(void *)(v22 + 32) + v23);
          int64x2_t v25 = vaddq_s64((int64x2_t)vextq_s8(v27[6], v27[6], 8uLL), v25);
          *(int64x2_t *)(v20 + 104) = v25;
          v26 += v27[5].i64[1];
          *(void *)(v20 + 120) = v26;
          ++v24;
          uint64_t v22 = *(void *)(*(void *)(a1 + 304) + 112);
          v23 += 128;
        }
        while (v24 < *(void *)(v22 + 16));
      }
    }
    metric_object = mmcs_metrics_create_metric_object(*(void *)(a1 + 184));
    CFDictionarySetValue(Mutable, @"metricObject", metric_object);
    if (metric_object) {
      CFRelease(metric_object);
    }
  }
  if (*(unsigned char *)(a1 + 249))
  {
    uint64_t v29 = *(const void **)(a1 + 256);
    if (v29) {
      CFDictionarySetValue(Mutable, @"kMMCSResultDownloadAuthorization", v29);
    }
  }
  CFStringRef v30 = mmcs_request_copy_description(a1);
  uint64_t v31 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
  {
    CFStringRef v32 = *(const __CFString **)(a1 + 32);
    *(_DWORD *)long long buf = 134218242;
    CFStringRef v42 = v32;
    __int16 v43 = 2112;
    CFStringRef v44 = v30;
    _os_log_impl(&dword_1DC1CA000, v31, OS_LOG_TYPE_INFO, "Engine %p request will notify request %@ done", buf, 0x16u);
  }
  if (v30) {
    CFRelease(v30);
  }
  uint64_t v33 = *(void *)(a1 + 304);
  if (*(unsigned char *)(v33 + 152))
  {
    BOOL v34 = *(const void **)(v33 + 160);
    if (v34) {
      CFDictionarySetValue(Mutable, @"kMMCSRequestOptionReturnOpaqueCloneContext", v34);
    }
  }
  uint64_t v35 = *(void *)(a1 + 32);
  if (v35) {
    MMCSEngineClientContextRequestCompleted(*(uint64_t **)(v35 + 152), *(void *)(a1 + 40), (uint64_t)Mutable);
  }
  if (*(void *)(a1 + 184))
  {
    uint64_t v36 = *(void *)(a1 + 32);
    if (v36)
    {
      char v37 = *(const void **)(v36 + 192);
      if (v37)
      {
        C3BaseRelease(v37);
        uint64_t v36 = *(void *)(a1 + 32);
      }
      *(void *)(v36 + 192) = 0;
    }
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  os_activity_scope_leave(&state);
}

void mmcs_get_req_context_log_timing(uint64_t a1)
{
  uint64_t v162 = *MEMORY[0x1E4F143B8];
  long long v2 = mmcs_logging_logger_summary();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    state.opaque[0] = 0;
    state.opaque[1] = 0;
    timing_activity_marker = mmcs_request_get_timing_activity_marker(a1);
    os_activity_scope_enter(timing_activity_marker, &state);
    uint64_t v4 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"GET request timing=========================================");
      uint64_t v6 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
    CFStringRef v7 = mmcs_request_copy_description(a1);
    uint64_t v8 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"engine %p request %@", *(void *)(a1 + 32), v7);
      unint64_t v10 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v7) {
      CFRelease(v7);
    }
    if (*(unsigned char *)(a1 + 144))
    {
      int v11 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"\trequest was cancelled.");
        uint64_t v13 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v12;
          _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v12) {
          CFRelease(v12);
        }
      }
    }
    if (*(void *)(a1 + 264))
    {
      CFStringRef v14 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"\tmmcs was pre-authorized by client application");
        CFStringRef v16 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v15;
          _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v15) {
          CFRelease(v15);
        }
      }
    }
    if (*(void *)(*(void *)(a1 + 304) + 128))
    {
      CFIndex v17 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        double v19 = mmcs_http_context_elapsed_seconds(*(void *)(*(void *)(a1 + 304) + 128));
        CFStringRef v20 = CFStringCreateWithFormat(v18, 0, @"\tmmcs get auth:     \t%0.4lf sec.", *(void *)&v19);
        CFStringRef v21 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v20;
          _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v20) {
          CFRelease(v20);
        }
      }
      uint64_t v22 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        double v24 = mmcs_http_context_enqueued_seconds(*(void *)(*(void *)(a1 + 304) + 128));
        CFStringRef v25 = CFStringCreateWithFormat(v23, 0, @"\tmmcs get auth(inQ):  \t%0.4lf sec.", *(void *)&v24);
        uint64_t v26 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v25;
          _os_log_impl(&dword_1DC1CA000, v26, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v25) {
          CFRelease(v25);
        }
      }
    }
    if (*(void *)(*(void *)(a1 + 304) + 136))
    {
      uint64_t v27 = mmcs_logging_logger_summary();
      BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG);
      CFAllocatorRef v29 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (v28)
      {
        double v30 = mmcs_http_context_elapsed_seconds(*(void *)(*(void *)(a1 + 304) + 136));
        CFStringRef v31 = CFStringCreateWithFormat(v29, 0, @"\tmmcs get chunks auth:\t%0.4lf sec.", *(void *)&v30);
        CFStringRef v32 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v31;
          _os_log_impl(&dword_1DC1CA000, v32, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v31) {
          CFRelease(v31);
        }
      }
      uint64_t v33 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        double v34 = mmcs_http_context_enqueued_seconds(*(void *)(*(void *)(a1 + 304) + 136));
        CFStringRef v35 = CFStringCreateWithFormat(v29, 0, @"\tmmcs get chunks auth(inQ):\t%0.4lf sec.", *(void *)&v34);
        uint64_t v36 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v35;
          _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v35) {
          CFRelease(v35);
        }
      }
    }
    else
    {
      CFAllocatorRef v29 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    }
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v29, 0, &itemArrayCallbacks);
    uint64_t v38 = *(void *)(a1 + 304);
    if (*(void *)(v38 + 168))
    {
      unint64_t v39 = 0;
      uint64_t v40 = 176;
      do
      {
        CFArrayAppendValue(Mutable, (const void *)(v38 + v40));
        ++v39;
        uint64_t v38 = *(void *)(a1 + 304);
        v40 += 416;
      }
      while (v39 < *(void *)(v38 + 168));
    }
    if (CFArrayGetCount(Mutable) >= 1)
    {
      theArray = Mutable;
      uint64_t v156 = a1;
      CFAllocatorRef alloc = v29;
      do
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, 0);
        CFStringRef v42 = mmcs_file_signature_to_hexstring(*(char **)ValueAtIndex);
        __int16 v43 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v44 = CFStringCreateWithFormat(v29, 0, @"\tsignature: %s", v42);
          uint64_t v45 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = v44;
            _os_log_impl(&dword_1DC1CA000, v45, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (v44) {
            CFRelease(v44);
          }
        }
        CCFStringRef StringDescription = XCFDataCreateCStringDescription(*((const __CFData **)ValueAtIndex + 6));
        uint64_t v47 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v48 = CFStringCreateWithFormat(v29, 0, @"\treference: %s", CStringDescription);
          uint64_t v49 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = v48;
            _os_log_impl(&dword_1DC1CA000, v49, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (v48) {
            CFRelease(v48);
          }
        }
        char v50 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v51 = CFStringCreateWithFormat(v29, 0, @"\tsize: %lld bytes (not valid if no authGet response)", *((void *)ValueAtIndex + 2));
          char v52 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = v51;
            _os_log_impl(&dword_1DC1CA000, v52, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (v51) {
            CFRelease(v51);
          }
        }
        uint64_t v53 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v54 = CFStringCreateWithFormat(v29, 0, @"\tunique size: %lld bytes", *((void *)ValueAtIndex + 37));
          uint64_t v55 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = v54;
            _os_log_impl(&dword_1DC1CA000, v55, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (v54) {
            CFRelease(v54);
          }
        }
        char v56 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v57 = CFStringCreateWithFormat(v29, 0, @"\titem: %llu", *((void *)ValueAtIndex + 5));
          char v58 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = v57;
            _os_log_impl(&dword_1DC1CA000, v58, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (v57) {
            CFRelease(v57);
          }
        }
        if (v42) {
          free(v42);
        }
        if (CStringDescription) {
          free(CStringDescription);
        }
        uint64_t v59 = *(void *)(*(void *)(a1 + 304) + 112);
        if (v59)
        {
          if (!mmcs_item_is_derivative((uint64_t)ValueAtIndex) && *(void *)(v59 + 16))
          {
            uint64_t v60 = 0;
            unint64_t v61 = 0;
            do
            {
              uint64_t v62 = *(void *)(v59 + 32);
              if (*(const void **)(v62 + v60 + 8) == ValueAtIndex)
              {
                uint64_t v63 = mmcs_logging_logger_summary();
                if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v64 = *(void *)(*(void *)(v62 + v60 + 8) + 40);
                  double file_local_fulfillment_elapsed_seconds = mmcs_get_file_local_fulfillment_elapsed_seconds(v62 + v60);
                  CFStringRef v66 = CFStringCreateWithFormat(alloc, 0, @"\tlocal fulfillment of item %llu: %0.4lf sec, %llu bytes", v64, *(void *)&file_local_fulfillment_elapsed_seconds, *(void *)(v62 + v60 + 96) + *(void *)(v62 + v60 + 88));
                  uint64_t v67 = mmcs_logging_logger_summary();
                  if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
                  {
                    LODWORD(buf) = 138543362;
                    *(void *)((char *)&buf + 4) = v66;
                    _os_log_impl(&dword_1DC1CA000, v67, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
                  }
                  if (v66) {
                    CFRelease(v66);
                  }
                }
                CFMutableSetRef v68 = mmcs_logging_logger_summary();
                if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
                {
                  CFStringRef v69 = CFStringCreateWithFormat(alloc, 0, @"\t                                   %llu bytes validated for resume", *(void *)(v62 + v60 + 80));
                  CFMutableSetRef v70 = mmcs_logging_logger_summary();
                  if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
                  {
                    LODWORD(buf) = 138543362;
                    *(void *)((char *)&buf + 4) = v69;
                    _os_log_impl(&dword_1DC1CA000, v70, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
                  }
                  if (v69) {
                    CFRelease(v69);
                  }
                }
                uint64_t v71 = mmcs_logging_logger_summary();
                if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
                {
                  CFStringRef v72 = CFStringCreateWithFormat(alloc, 0, @"\t                                   %llu bytes resumed", *(void *)(v62 + v60 + 88));
                  uint64_t v73 = mmcs_logging_logger_summary();
                  if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
                  {
                    LODWORD(buf) = 138543362;
                    *(void *)((char *)&buf + 4) = v72;
                    _os_log_impl(&dword_1DC1CA000, v73, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
                  }
                  if (v72) {
                    CFRelease(v72);
                  }
                }
                uint64_t v74 = mmcs_logging_logger_summary();
                if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
                {
                  CFStringRef v75 = CFStringCreateWithFormat(alloc, 0, @"\t                                   %llu bytes fulfilled locally", *(void *)(v62 + v60 + 96));
                  uint64_t v76 = mmcs_logging_logger_summary();
                  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
                  {
                    LODWORD(buf) = 138543362;
                    *(void *)((char *)&buf + 4) = v75;
                    _os_log_impl(&dword_1DC1CA000, v76, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
                  }
                  if (v75) {
                    CFRelease(v75);
                  }
                }
                uint64_t v77 = mmcs_logging_logger_summary();
                if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
                {
                  CFStringRef v78 = CFStringCreateWithFormat(alloc, 0, @"\t                                   %llu bytes fulfilled by peers", *(void *)(v62 + v60 + 104));
                  unint64_t v79 = mmcs_logging_logger_summary();
                  if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
                  {
                    LODWORD(buf) = 138543362;
                    *(void *)((char *)&buf + 4) = v78;
                    _os_log_impl(&dword_1DC1CA000, v79, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
                  }
                  if (v78) {
                    CFRelease(v78);
                  }
                }
              }
              ++v61;
              v60 += 128;
            }
            while (v61 < *(void *)(v59 + 16));
          }
          CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v59 + 40));
          if (Count >= 1)
          {
            CFIndex v81 = Count;
            for (CFIndex i = 0; i != v81; ++i)
            {
              uint64_t v83 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v59 + 40), i);
              CFSetRef state_copy_file_states_for_container = mmcs_get_state_copy_file_states_for_container(v59, v83);
              *(void *)&long long buf = 0;
              *((void *)&buf + 1) = ValueAtIndex;
              if (state_copy_file_states_for_container)
              {
                CFSetRef v85 = state_copy_file_states_for_container;
                CFSetApplyFunction(state_copy_file_states_for_container, (CFSetApplierFunction)item_match_applier, &buf);
                CFRelease(v85);
                if ((_BYTE)buf)
                {
                  int v86 = *(__CFHTTPMessage **)(*(void *)(*((void *)v83 + 2) + 24) + 16);
                  if (v86) {
                    CFStringRef v87 = CFHTTPMessageCopyHeaderFieldValue(v86, @"Range");
                  }
                  else {
                    CFStringRef v87 = 0;
                  }
                  uint64_t v88 = mmcs_logging_logger_summary();
                  if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
                  {
                    CFStringRef v89 = CFStringCreateWithFormat(alloc, 0, @"\t req container idx:\t%lu", i);
                    CFTypeID v90 = mmcs_logging_logger_summary();
                    if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)long long context = 138543362;
                      CFStringRef v160 = v89;
                      _os_log_impl(&dword_1DC1CA000, v90, OS_LOG_TYPE_DEBUG, "%{public}@", context, 0xCu);
                    }
                    if (v89) {
                      CFRelease(v89);
                    }
                  }
                  CFStringRef v91 = (const __CFString *)mmcs_container_copy_simple_description((uint64_t)v83);
                  if (v91)
                  {
                    CFStringRef v92 = v91;
                    CStringWithCFCFStringRef String = createCStringWithCFString(v91);
                    CFNumberRef v94 = mmcs_logging_logger_summary();
                    if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
                    {
                      CFNumberRef v95 = "(no container description)";
                      if (CStringWithCFString) {
                        CFNumberRef v95 = (const char *)CStringWithCFString;
                      }
                      CFStringRef v96 = CFStringCreateWithFormat(alloc, 0, @"\t     container:\t%s", v95);
                      CFStringRef v97 = mmcs_logging_logger_summary();
                      if (os_log_type_enabled(v97, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)long long context = 138543362;
                        CFStringRef v160 = v96;
                        _os_log_impl(&dword_1DC1CA000, v97, OS_LOG_TYPE_DEBUG, "%{public}@", context, 0xCu);
                      }
                      if (v96) {
                        CFRelease(v96);
                      }
                    }
                    if (CStringWithCFString) {
                      free(CStringWithCFString);
                    }
                    CFRelease(v92);
                  }
                  if (*((_DWORD *)v83 + 16) == 2)
                  {
                    uint64_t v98 = *((void *)v83 + 11);
                    CFTypeID v99 = mmcs_logging_logger_summary();
                    if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v100 = *(const char **)(v98 + 16);
                      if (!v100) {
                        uint64_t v100 = "(no key)";
                      }
                      CFStringRef v101 = CFStringCreateWithFormat(alloc, 0, @"\t     container key:\t%s", v100);
                      CFTypeID v102 = mmcs_logging_logger_summary();
                      if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)long long context = 138543362;
                        CFStringRef v160 = v101;
                        _os_log_impl(&dword_1DC1CA000, v102, OS_LOG_TYPE_DEBUG, "%{public}@", context, 0xCu);
                      }
                      if (v101) {
                        CFRelease(v101);
                      }
                    }
                    CFNumberRef v103 = *(const UInt8 **)(v98 + 16);
                    if (v103)
                    {
                      size_t v104 = strlen(*(const char **)(v98 + 16));
                      CFStringRef v105 = CFStringCreateWithBytes(alloc, v103, v104, 0x8000100u, 0);
                      if (v105)
                      {
                        CFStringRef v106 = v105;
                        double v107 = COERCE_DOUBLE(mmcs_container_id_info_parse_container_id(v105));
                        CFRelease(v106);
                        if (v107 != 0.0)
                        {
                          CFStringRef String = XCFAbsoluteTimeDateFormatterCreateString(v107);
                          if (String)
                          {
                            CFStringRef v109 = String;
                            unint64_t v110 = mmcs_logging_logger_summary();
                            if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
                            {
                              CFStringRef v111 = CFStringCreateWithFormat(alloc, 0, @"\t  upload auth date:\t%@", v109);
                              CFMutableArrayRef v112 = mmcs_logging_logger_summary();
                              if (os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG))
                              {
                                *(_DWORD *)long long context = 138543362;
                                CFStringRef v160 = v111;
                                _os_log_impl(&dword_1DC1CA000, v112, OS_LOG_TYPE_DEBUG, "%{public}@", context, 0xCu);
                              }
                              if (v111) {
                                CFRelease(v111);
                              }
                            }
                            CFRelease(v109);
                          }
                          CFBooleanRef v113 = mmcs_logging_logger_summary();
                          if (os_log_type_enabled(v113, OS_LOG_TYPE_DEBUG))
                          {
                            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
                            CFStringRef v115 = CFStringCreateWithFormat(alloc, 0, @"\t time since upload:\t%f", Current - v107);
                            uint64_t v116 = mmcs_logging_logger_summary();
                            if (os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG))
                            {
                              *(_DWORD *)long long context = 138543362;
                              CFStringRef v160 = v115;
                              _os_log_impl(&dword_1DC1CA000, v116, OS_LOG_TYPE_DEBUG, "%{public}@", context, 0xCu);
                            }
                            if (v115) {
                              CFRelease(v115);
                            }
                          }
                        }
                      }
                    }
                    int v117 = mmcs_logging_logger_summary();
                    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v118 = @"unknown range";
                      if (v87) {
                        uint64_t v118 = (__CFString *)v87;
                      }
                      CFStringRef v119 = CFStringCreateWithFormat(alloc, 0, @"\t             range:\t%@", v118);
                      uint64_t v120 = mmcs_logging_logger_summary();
                      if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)long long context = 138543362;
                        CFStringRef v160 = v119;
                        _os_log_impl(&dword_1DC1CA000, v120, OS_LOG_TYPE_DEBUG, "%{public}@", context, 0xCu);
                      }
                      if (v119) {
                        CFRelease(v119);
                      }
                    }
                    if (v87) {
                      CFRelease(v87);
                    }
                    uint64_t v121 = mmcs_logging_logger_summary();
                    if (os_log_type_enabled(v121, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t body_size = mmcs_get_container_get_body_size((uint64_t)v83);
                      CFStringRef v123 = CFStringCreateWithFormat(alloc, 0, @"\t     expected size:\t%lu bytes", body_size);
                      uint64_t v124 = mmcs_logging_logger_summary();
                      if (os_log_type_enabled(v124, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)long long context = 138543362;
                        CFStringRef v160 = v123;
                        _os_log_impl(&dword_1DC1CA000, v124, OS_LOG_TYPE_DEBUG, "%{public}@", context, 0xCu);
                      }
                      if (v123) {
                        CFRelease(v123);
                      }
                    }
                    uint64_t v125 = mmcs_logging_logger_summary();
                    if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
                    {
                      CFStringRef v126 = CFStringCreateWithFormat(alloc, 0, @"\t     total bytes not decrypted:\t%lu bytes", *(void *)(v98 + 136));
                      uint64_t v127 = mmcs_logging_logger_summary();
                      if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)long long context = 138543362;
                        CFStringRef v160 = v126;
                        _os_log_impl(&dword_1DC1CA000, v127, OS_LOG_TYPE_DEBUG, "%{public}@", context, 0xCu);
                      }
                      if (v126) {
                        CFRelease(v126);
                      }
                    }
                    if (!*(unsigned char *)(v98 + 180))
                    {
                      uint64_t v128 = mmcs_logging_logger_summary();
                      if (os_log_type_enabled(v128, OS_LOG_TYPE_DEBUG))
                      {
                        CFStringRef v129 = CFStringCreateWithFormat(alloc, 0, @"\t    container %lu was not needed", i);
                        CFStringRef v130 = mmcs_logging_logger_summary();
                        if (os_log_type_enabled(v130, OS_LOG_TYPE_DEBUG))
                        {
                          *(_DWORD *)long long context = 138543362;
                          CFStringRef v160 = v129;
                          _os_log_impl(&dword_1DC1CA000, v130, OS_LOG_TYPE_DEBUG, "%{public}@", context, 0xCu);
                        }
                        if (v129) {
                          CFRelease(v129);
                        }
                      }
                    }
                  }
                  mmcs_transaction_log_timing(*((void *)v83 + 2));
                  uint64_t v131 = *((void *)v83 + 3);
                  if (v131) {
                    mmcs_transaction_log_timing(v131);
                  }
                  uint64_t v132 = (__CFError *)*((void *)v83 + 5);
                  if (v132)
                  {
                    uint64_t v133 = mmcs_cferror_copy_description(v132);
                    uint64_t v134 = mmcs_logging_logger_summary();
                    if (os_log_type_enabled(v134, OS_LOG_TYPE_DEBUG))
                    {
                      CFStringRef v135 = CFStringCreateWithFormat(alloc, 0, @"\terror :           \t%@", v133);
                      CFIndex v136 = mmcs_logging_logger_summary();
                      if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)long long context = 138543362;
                        CFStringRef v160 = v135;
                        _os_log_impl(&dword_1DC1CA000, v136, OS_LOG_TYPE_DEBUG, "%{public}@", context, 0xCu);
                      }
                      if (v135) {
                        CFRelease(v135);
                      }
                    }
                    if (v133) {
                      CFRelease(v133);
                    }
                  }
                  CFArrayRef v137 = (const __CFArray *)*((void *)v83 + 6);
                  if (v137)
                  {
                    *(_DWORD *)long long context = 1;
                    v163.unsigned int length = CFArrayGetCount(v137);
                    v163.CFIndex location = 0;
                    CFArrayApplyFunction(v137, v163, (CFArrayApplierFunction)_log_error, context);
                  }
                }
              }
            }
          }
        }
        uint64_t v138 = (__CFError *)*((void *)ValueAtIndex + 24);
        CFAllocatorRef v29 = alloc;
        if (v138)
        {
          uint64_t v139 = mmcs_cferror_copy_description(v138);
          uint64_t v140 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v140, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v141 = CFStringCreateWithFormat(alloc, 0, @"\terror:             \t%@", v139);
            uint64_t v142 = mmcs_logging_logger_summary();
            if (os_log_type_enabled(v142, OS_LOG_TYPE_DEBUG))
            {
              LODWORD(buf) = 138543362;
              *(void *)((char *)&buf + 4) = v141;
              _os_log_impl(&dword_1DC1CA000, v142, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
            }
            if (v141) {
              CFRelease(v141);
            }
          }
          uint64_t v143 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
          {
            CFErrorRef v144 = MMCSGetItemStateCString(*((_DWORD *)ValueAtIndex + 44));
            CFStringRef v145 = CFStringCreateWithFormat(alloc, 0, @"\terror state:       \t%s", v144);
            uint64_t v146 = mmcs_logging_logger_summary();
            if (os_log_type_enabled(v146, OS_LOG_TYPE_DEBUG))
            {
              LODWORD(buf) = 138543362;
              *(void *)((char *)&buf + 4) = v145;
              _os_log_impl(&dword_1DC1CA000, v146, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
            }
            if (v145) {
              CFRelease(v145);
            }
          }
          if (v139) {
            CFRelease(v139);
          }
        }
        CFMutableDictionaryRef Mutable = theArray;
        CFArrayRemoveValueAtIndex(theArray, 0);
        a1 = v156;
      }
      while (CFArrayGetCount(theArray) > 0);
    }
    if (*(void *)(*(void *)(a1 + 304) + 144))
    {
      uint64_t v147 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v147, OS_LOG_TYPE_DEBUG))
      {
        double v148 = mmcs_http_context_elapsed_seconds(*(void *)(*(void *)(a1 + 304) + 144));
        CFStringRef v149 = CFStringCreateWithFormat(v29, 0, @"\tmmcs get complete:     \t%0.4lf sec.", *(void *)&v148);
        unint64_t v150 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v150, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v149;
          _os_log_impl(&dword_1DC1CA000, v150, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v149) {
          CFRelease(v149);
        }
      }
      uint64_t v151 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
      {
        double v152 = mmcs_http_context_enqueued_seconds(*(void *)(*(void *)(a1 + 304) + 144));
        CFStringRef v153 = CFStringCreateWithFormat(v29, 0, @"\tmmcs get complete(inQ):\t%0.4lf sec.", *(void *)&v152);
        v154 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v154, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v153;
          _os_log_impl(&dword_1DC1CA000, v154, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v153) {
          CFRelease(v153);
        }
      }
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    os_activity_scope_leave(&state);
  }
}

uint64_t mmcs_get_req_has_outstanding_asynchronous_work(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 304);
  uint64_t v3 = *(CFArrayRef **)(v2 + 112);
  if (v3)
  {
    if (mmcs_get_state_has_outstanding_async_transactions(v3)) {
      goto LABEL_8;
    }
    uint64_t v2 = *(void *)(a1 + 304);
  }
  if ((!*(void *)v2 || CFSetGetCount(*(CFSetRef *)v2) <= 0)
    && mmcs_proxy_locator_is_done(*(void *)(a1 + 192)))
  {
    return 0;
  }
LABEL_8:
  if (!mmcs_proxy_locator_is_done(*(void *)(a1 + 192)))
  {
    CFStringRef v5 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"waiting to hear back from ACS");
      CFStringRef v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 138543362;
        CFStringRef v9 = v6;
        _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&v8, 0xCu);
      }
      if (v6) {
        CFRelease(v6);
      }
    }
  }
  return 1;
}

void mmcs_get_req_add_file_job(uint64_t a1, void *value)
{
  uint64_t v4 = **(__CFSet ***)(a1 + 304);
  if (!v4)
  {
    CFSetCallBacks v5 = *(CFSetCallBacks *)byte_1F363C8D0;
    **(void **)(a1 + 304) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &v5);
    uint64_t v4 = **(__CFSet ***)(a1 + 304);
  }
  CFSetSetValue(v4, value);
}

CFIndex mmcs_get_req_validate_get_file(uint64_t a1, void *value)
{
  uint64_t v4 = *(__CFArray **)(*(void *)(a1 + 304) + 16);
  if (!v4)
  {
    *(void *)(*(void *)(a1 + 304) + 16) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    uint64_t v4 = *(__CFArray **)(*(void *)(a1 + 304) + 16);
  }
  CFArrayAppendValue(v4, value);
  return mmcs_get_req_context_schedule_file_jobs(a1);
}

CFIndex mmcs_get_req_context_schedule_file_jobs(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 304); ; uint64_t i = *(void *)(a1 + 304))
  {
    CFIndex result = *(void *)(i + 16);
    if (!result) {
      break;
    }
    CFIndex result = CFArrayGetCount((CFArrayRef)result);
    if (result < 1) {
      break;
    }
    uint64_t v4 = *(CFSetRef **)(a1 + 304);
    if (*v4)
    {
      CFIndex result = CFSetGetCount(*v4);
      if (result > 0) {
        return result;
      }
      uint64_t v4 = *(CFSetRef **)(a1 + 304);
    }
    CFDictionaryRef ValueAtIndex = (uint64_t **)CFArrayGetValueAtIndex(v4[2], 0);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(void *)(a1 + 304) + 16), 0);
    uint64_t v6 = *(void *)(a1 + 32);
    CFErrorRef v15 = 0;
    *(void *)&long long v10 = 0;
    *((void *)&v10 + 1) = a1;
    int v11 = C3BaseRetain;
    CFStringRef v12 = C3BaseRelease;
    uint64_t v13 = 0;
    CFStringRef v14 = mmcs_get_req_context_did_validate_item;
    CFStringRef v7 = (void *)mmcs_file_job_create(&v10, v6, (uint64_t)ValueAtIndex, &v15);
    if (v7)
    {
      int v8 = v7;
      mmcs_get_req_add_file_job(a1, v7);
      mmcs_engine_file_job_dispatch_async((uint64_t)v8, *(void *)(v6 + 24));
      C3BaseRelease(v8);
    }
    else
    {
      mmcs_get_file_abort_writing_file(ValueAtIndex);
      CFStringRef v9 = ValueAtIndex[1];
      mmcs_get_item_progress_make_done_error((uint64_t)v15, &v10);
      mmcs_get_request_set_progress_and_notify_item(a1, v9, (unsigned int *)&v10);
      if (v15) {
        CFRelease(v15);
      }
    }
  }
  return result;
}

void mmcs_get_req_set_opaque_clone_context(uint64_t a1, CFTypeRef cf)
{
  uint64_t v3 = *(void *)(a1 + 304);
  CFTypeRef v4 = *(CFTypeRef *)(v3 + 160);
  if (v4 != cf)
  {
    if (v4)
    {
      CFRelease(v4);
      uint64_t v3 = *(void *)(a1 + 304);
    }
    *(void *)(v3 + 160) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(*(void *)(a1 + 304) + 160) = cf;
  }
}

uint64_t mmcs_get_req_get_opaque_clone_context(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 304) + 160);
}

uint64_t item_match_applier(uint64_t result, uint64_t a2)
{
  if (*(void *)(a2 + 8) == *(void *)(result + 8)) {
    *(unsigned char *)a2 = 1;
  }
  return result;
}

void _log_error(__CFError *a1, unsigned int *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = mmcs_cferror_copy_description(a1);
  CFTypeRef v4 = mmcs_logging_logger_summary();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"\tprevious error %d:           \t%@", *a2, v3);
    uint64_t v6 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v8 = v5;
      _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
  if (v3) {
    CFRelease(v3);
  }
  ++*a2;
}

void mmcs_get_req_context_items_by_signature_description(uint64_t a1, const __CFArray *a2)
{
}

void mmcs_get_req_context_did_validate_item(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  CFTypeRef v4 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"completed file job %p", a2);
    uint64_t v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      uint64_t v41 = (uint64_t)v5;
      _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
  if (!*(unsigned char *)(a1 + 144))
  {
    uint64_t v7 = *(void *)(a1 + 304);
    if (!*(unsigned char *)(v7 + 40))
    {
      if (*(void *)v7 && CFSetContainsValue(*(CFSetRef *)v7, (const void *)a2))
      {
        if (a2)
        {
          C3BaseRetain((CFTypeRef)a2);
          CFSetRemoveValue(**(CFMutableSetRef **)(a1 + 304), (const void *)a2);
          mmcs_get_req_context_schedule_file_jobs(a1);
          uint64_t v8 = *(void *)(a2 + 136);
          uint64_t v9 = *(uint64_t **)(v8 + 8);
          if (*(unsigned char *)(a2 + 216))
          {
            double v11 = *(double *)(a2 + 200);
            double v10 = *(double *)(a2 + 208);
            uint64_t v12 = CKFileDigestResultsFileLength();
            uint64_t v13 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            {
              CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Validated the contents of file %s (%llu bytes) for item %llu in %lf sec. (%.3lf MB/sec)", *(void *)(v8 + 16), v12, v9[5], v10 - v11, (double)(unint64_t)v12 * 0.0009765625 * 0.0009765625 / (v10 - v11));
              CFErrorRef v15 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 138543362;
                uint64_t v41 = (uint64_t)v14;
                _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
              }
              if (v14) {
                CFRelease(v14);
              }
            }
          }
          else
          {
            uint64_t v20 = *(void *)(a2 + 232);
            CFStringRef v21 = mmcs_logging_logger_default();
            BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
            if (v20)
            {
              if (v22)
              {
                CFStringRef v28 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Could not validate contents of file %s for item %llu: %@", *(void *)(v8 + 16), v9[5], *(void *)(a2 + 232));
                CFAllocatorRef v29 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = 138543362;
                  uint64_t v41 = (uint64_t)v28;
                  _os_log_impl(&dword_1DC1CA000, v29, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
                }
                if (v28) {
                  CFRelease(v28);
                }
              }
              CFRetain(*(CFTypeRef *)(a2 + 232));
              CFIndex v17 = *(const void **)(a2 + 232);
            }
            else
            {
              if (v22)
              {
                CFStringRef v30 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Could not validate contents of file %s for item %llu with unspecified error", *(void *)(v8 + 16), v9[5]);
                CFStringRef v31 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = 138543362;
                  uint64_t v41 = (uint64_t)v30;
                  _os_log_impl(&dword_1DC1CA000, v31, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
                }
                if (v30) {
                  CFRelease(v30);
                }
              }
              CFIndex v17 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 12, @"There was an unspecified error while trying to validate the contents of item %llu", v23, v24, v25, v26, v27, v9[5]);
            }
            if (v17)
            {
              mmcs_get_file_abort_writing_file((uint64_t **)v8);
              v39[0] = 5;
              v39[1] = 0xBFF0000000000000;
              v39[2] = v17;
              mmcs_get_request_set_progress_and_notify_item(a1, v9, (unsigned int *)v39);
              char v32 = 0;
              goto LABEL_43;
            }
          }
          mmcs_get_file_finalize_file_after_validation((uint64_t **)v8);
          CFIndex v17 = 0;
          char v32 = 1;
LABEL_43:
          if (*(unsigned char *)(a1 + 144))
          {
LABEL_44:
            uint64_t v33 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            {
              CFStringRef v34 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Clean up put request as last step of cancel");
              CFStringRef v35 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 138543362;
                uint64_t v41 = (uint64_t)v34;
                _os_log_impl(&dword_1DC1CA000, v35, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
              }
              if (v34) {
                CFRelease(v34);
              }
            }
            mmcs_metrics_request_set_error(*(void *)(a1 + 184), *(const void **)(a1 + 152));
            uint64_t v36 = *(void *)(a1 + 152);
LABEL_50:
            mmcs_get_req_context_cleanup(a1, v36);
            goto LABEL_51;
          }
          CFSetRef v37 = **(const __CFSet ***)(a1 + 304);
          if (v37)
          {
            if (CFSetGetCount(v37) <= 0)
            {
              if (!*(unsigned char *)(a1 + 144) && !mmcs_get_req_has_outstanding_asynchronous_work(a1))
              {
                uint64_t v38 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)long long buf = 134217984;
                  uint64_t v41 = a1;
                  _os_log_impl(&dword_1DC1CA000, v38, OS_LOG_TYPE_INFO, "Downloads complete. All done! (Get request %p)", buf, 0xCu);
                }
                uint64_t v36 = 0;
                goto LABEL_50;
              }
            }
            else if (*(unsigned char *)(a1 + 144))
            {
              goto LABEL_44;
            }
          }
LABEL_51:
          C3BaseRelease((CFTypeRef)a2);
          if (v32) {
            return;
          }
          goto LABEL_52;
        }
        double v19 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          return;
        }
        CFIndex v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"NULL job. Ignoring");
        CFAllocatorRef v18 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          uint64_t v41 = (uint64_t)v17;
          goto LABEL_21;
        }
      }
      else
      {
        CFStringRef v16 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          return;
        }
        CFIndex v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unrecogized chunk job. Ignoring");
        CFAllocatorRef v18 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          uint64_t v41 = (uint64_t)v17;
LABEL_21:
          _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
      }
      if (!v17) {
        return;
      }
LABEL_52:
      CFRelease(v17);
    }
  }
}

__CFString *mmcs_key_description_create_with_bytes(char *a1, unint64_t a2, int a3)
{
  unint64_t v4 = a2;
  CFStringRef v5 = a1;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (a2 && a3)
  {
    uint64_t v7 = hextostrdup(a1, 1uLL);
    --v4;
    ++v5;
  }
  else
  {
    uint64_t v7 = 0;
    if (!a1)
    {
      CFStringRef v9 = @"NULL keyData";
      goto LABEL_21;
    }
  }
  if (!v4)
  {
    CFStringRef v9 = @"0-length keyData";
    goto LABEL_21;
  }
  if (mmcs_zcmp((uint64_t)v5, v4))
  {
    CFStringRef v8 = CFStringCreateWithFormat(*v6, 0, @"zero-filled %llu bytes", v4);
    if (v8) {
      CFStringRef v9 = v8;
    }
    else {
      CFStringRef v9 = @"zero-filled";
    }
    goto LABEL_21;
  }
  *(_OWORD *)md = 0u;
  long long v25 = 0u;
  memset(&c, 0, sizeof(c));
  CC_SHA256_Init(&c);
  CC_SHA256_Update(&c, v5, v4);
  CC_SHA256_Final(md, &c);
  CFAllocatorRef v10 = *v6;
  CFDataRef v11 = XCFDataCreateWithBytesNoCopy(*v6, md, 6, (const __CFAllocator *)*MEMORY[0x1E4F1CFA0]);
  if (v11)
  {
    CFDataRef v12 = v11;
    uint64_t v13 = (const char *)mmcs_base64_encode_cfdata_to_cstring((CFIndex)v11);
    if (v13)
    {
      CFStringRef v14 = (UInt8 *)v13;
      size_t v15 = strlen(v13);
      CFStringRef v16 = XCFStringCreateWithBytesNoCopy(v10, v14, v15, 0x600u, 0, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
      if (!v16)
      {
        CFRelease(v12);
        free(v14);
        CFStringRef v16 = @"Error-Wrapping-Serialized-Hash";
        goto LABEL_19;
      }
    }
    else
    {
      CFStringRef v16 = @"Error-Serializing-Hash";
    }
    CFRelease(v12);
  }
  else
  {
    CFStringRef v16 = @"Error-Wrapping-Hash";
  }
LABEL_19:
  CFStringRef v9 = CFStringCreateWithFormat(v10, 0, @"%llu bytes with hash %@", v4, v16);
  CFRelease(v16);
  if (!v9) {
    CFStringRef v9 = @"non-zero-filled";
  }
LABEL_21:
  CFAllocatorRef v17 = *v6;
  if (a3)
  {
    CFAllocatorRef v18 = "error";
    if (v7) {
      CFAllocatorRef v18 = v7;
    }
    CFStringRef v19 = CFStringCreateWithFormat(v17, 0, @"KeyWithScheme<%s,%@>", v18, v9);
  }
  else
  {
    CFStringRef v19 = CFStringCreateWithFormat(v17, 0, @"Key<%@>", v9, v22);
  }
  CFStringRef v20 = v19;
  CFRelease(v9);
  if (v7) {
    free(v7);
  }
  if (v20) {
    return (__CFString *)v20;
  }
  else {
    return @"Key<Error>";
  }
}

__CFString *mmcs_key_description_create_with_cfdata(const __CFData *a1, int a2)
{
  if (!a1) {
    return @"Key<NULL key>";
  }
  BytePtr = (char *)CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  return mmcs_key_description_create_with_bytes(BytePtr, Length, a2);
}

uint64_t mmcs_proxy_locator_should_disable_for_request(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  CFStringRef dataclass = (const __CFString *)mmcs_request_get_dataclass(a1);
  uint64_t v3 = mmcs_logging_logger_default();
  if (!dataclass)
  {
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"request does not have a dataclass");
    CFDataRef v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v15 = v11;
LABEL_26:
      _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
LABEL_27:
    if (v11) {
      CFRelease(v11);
    }
    return 0;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"engine dataclass: %@", dataclass);
    CFStringRef v5 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v15 = v4;
      _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v4) {
      CFRelease(v4);
    }
  }
  uint64_t v6 = 1;
  if (CFStringCompare(dataclass, @"com.apple.Dataclass.Messenger", 1uLL))
  {
    uint64_t v6 = 1;
    if (CFStringCompare(dataclass, @"com.apple.Dataclass.Backup", 1uLL))
    {
      uint64_t v6 = 1;
      if (CFStringCompare(dataclass, @"com.apple.Dataclass.MediaStream", 1uLL))
      {
        uint64_t v6 = 1;
        if (CFStringCompare(dataclass, @"com.apple.Dataclass.FaceTime", 1uLL))
        {
          uint64_t v6 = 1;
          if (CFStringCompare(dataclass, @"com.apple.Dataclass.SharePlay", 1uLL))
          {
            if (!mmcs_request_is_cloudkit_dataclass(a1)) {
              return 0;
            }
            CFStringRef container_identifier = (const __CFString *)mmcs_request_get_container_identifier(a1);
            CFStringRef v8 = mmcs_logging_logger_default();
            if (container_identifier)
            {
              if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
              {
                CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"container id is %@", container_identifier);
                CFAllocatorRef v10 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)long long buf = 138543362;
                  CFStringRef v15 = v9;
                  _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                }
                if (v9) {
                  CFRelease(v9);
                }
              }
              uint64_t v6 = 1;
              if (CFStringCompare(container_identifier, @"com.apple.backup.ios", 1uLL) == kCFCompareEqualTo) {
                return v6;
              }
              uint64_t v6 = 1;
              if (CFStringCompare(container_identifier, @"iCloud.com.apple.Feldspar", 1uLL) == kCFCompareEqualTo) {
                return v6;
              }
              uint64_t v6 = 1;
              if (CFStringCompare(container_identifier, @"com.apple.freeform", 1uLL) == kCFCompareEqualTo) {
                return v6;
              }
              return 0;
            }
            if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
              return 0;
            }
            CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"request via cloudkit does not have a container identifier");
            CFDataRef v12 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v15 = v11;
              goto LABEL_26;
            }
            goto LABEL_27;
          }
        }
      }
    }
  }
  return v6;
}

uint64_t mmcs_proxy_locator_create(uint64_t *a1, CFArrayRef theArray, const void *a3)
{
  if (!theArray) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  uint64_t result = 0;
  if (a3)
  {
    if (Count)
    {
      *a1 = 0;
      uint64_t v8 = C3TypeRegister(&mmcs_proxy_locatorGetTypeID_typeID);
      uint64_t result = C3TypeCreateInstance_(0, v8, 0x20uLL);
      if (result)
      {
        uint64_t v9 = result;
        *(_DWORD *)(result + 20) = 0;
        CFArrayRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theArray);
        *(void *)(v9 + 32) = Copy;
        *(_WORD *)(v9 + 40) = 0;
        *(unsigned char *)(v9 + 42) = 0;
        if (Copy)
        {
          *(void *)(v9 + 24) = a3;
          C3BaseRetain(a3);
          *a1 = v9;
          return 1;
        }
        else
        {
          C3BaseRelease((CFTypeRef)v9);
          return 0;
        }
      }
    }
  }
  return result;
}

void mmcs_proxy_locator_invalidate(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(const void **)(a1 + 24);
    *(void *)(a1 + 24) = 0;
    if (v2) {
      C3BaseRelease(v2);
    }
  }
}

uint64_t mmcs_proxy_locator_prime()
{
  pthread_once(&sLocatorVars_once, (void (*)(void))_LocatorVars_init_once);
  if (!sDummyURL) {
    mmcs_proxy_locator_prime_cold_1();
  }
  getLocateOptions();
  return ACSLocateCachingServer();
}

CFIndex mmcs_proxy_locator_locate(uint64_t a1)
{
  C3BaseRetain((CFTypeRef)a1);
  *(unsigned char *)(a1 + 40) = 1;
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  if (result >= 1)
  {
    CFIndex v3 = 0;
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), v3);
      CFURLRef v6 = mmcs_container_copy_vendor_url((uint64_t)ValueAtIndex);
      CFDictionaryRef Options = (const __CFDictionary *)getLocateOptions();
      CFSetRef MutableCopy = CFDictionaryCreateMutableCopy(v4, 0, Options);
      uint64_t v9 = mmcs_request_copy_persistent_identifier(*(void *)(a1 + 24));
      CFDictionaryAddValue(MutableCopy, @"x-apple-persistent-identifier", v9);
      ACSLocateCachingServer();
      if (v6) {
        CFRelease(v6);
      }
      if (v9) {
        CFRelease(v9);
      }
      if (MutableCopy) {
        CFRelease(MutableCopy);
      }
      ++v3;
      CFIndex result = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
    }
    while (v3 < result);
  }
  return result;
}

void __mmcs_proxy_locator_locate_block_invoke(uint64_t a1, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  if (a4) {
    CFRetain(a4);
  }
  uint64_t v8 = mmcs_chunk_instance_offset(*(void *)(*(void *)(a1 + 40) + 24));
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  v12[2] = __mmcs_proxy_locator_locate_block_invoke_2;
  v12[3] = &unk_1E6C33E78;
  CFTypeRef v14 = cf;
  CFTypeRef v15 = a4;
  uint64_t v9 = *(void *)(a1 + 48);
  CFTypeRef v16 = a3;
  uint64_t v17 = v9;
  long long v13 = *(_OWORD *)(a1 + 32);
  CFAllocatorRef v10 = *(const void **)(v8 + 56);
  C3BaseRetain(v10);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __runOnMainRunLoop_block_invoke;
  block[3] = &unk_1E6C33EC8;
  block[4] = v12;
  dispatch_block_t v11 = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, block);
  mmcs_perform_target_async(*(void *)(v8 + 56), (uint64_t)v11);
  if (v10) {
    C3BaseRelease(v10);
  }
  _Block_release(v11);
}

void __mmcs_proxy_locator_locate_block_invoke_2(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  ++*(_DWORD *)(v2 + 20);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 32));
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(int *)(v4 + 20);
  if (*(unsigned char *)(v4 + 41))
  {
    CFURLRef v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"proxy locator was cancelled. bailing.");
      uint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v30 = v7;
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
    if (Count == v5)
    {
      uint64_t v9 = *(void *)(a1 + 40);
      *(unsigned char *)(v9 + 40) = 0;
      CFAllocatorRef v10 = *(const void **)(v9 + 24);
      *(void *)(v9 + 24) = 0;
      if (v10) {
        C3BaseRelease(v10);
      }
      dispatch_block_t v11 = *(const void **)(a1 + 40);
      if (v11) {
        C3BaseRelease(v11);
      }
    }
    return;
  }
  CFDataRef v12 = *(__CFError **)(a1 + 56);
  if (*(void *)(a1 + 48))
  {
    if (!v12)
    {
      CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), (const void *)*MEMORY[0x1E4F4E2A0]);
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 40) + 32), *(void *)(a1 + 72));
      mmcs_container_create_proxy_transaction((uint64_t)ValueAtIndex);
      goto LABEL_31;
    }
  }
  else if (!v12)
  {
    uint64_t v22 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"couldn't get proxy url with no error");
    CFStringRef v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_29;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v30 = v16;
LABEL_27:
    CFAllocatorRef v18 = v21;
    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
LABEL_28:
    _os_log_impl(&dword_1DC1CA000, v18, v19, "%{public}@", buf, 0xCu);
LABEL_29:
    if (v16) {
      CFRelease(v16);
    }
    goto LABEL_31;
  }
  CFErrorDomain Domain = CFErrorGetDomain(v12);
  if (!CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E4F1D160]) || CFErrorGetCode(*(CFErrorRef *)(a1 + 56)) != 60)
  {
    CFStringRef v20 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"couldn't get proxy url with error: %@", *(void *)(a1 + 56));
    CFStringRef v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_29;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v30 = v16;
    goto LABEL_27;
  }
  CFTypeRef v15 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"couldn't get proxy url with error: %@", *(void *)(a1 + 56));
    uint64_t v17 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_29;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v30 = v16;
    CFAllocatorRef v18 = v17;
    os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
    goto LABEL_28;
  }
LABEL_31:
  if (Count == v5)
  {
    *(unsigned char *)(*(void *)(a1 + 40) + 40) = 0;
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    uint64_t v23 = *(void *)(a1 + 40);
    if (v23)
    {
      uint64_t v24 = *(const void **)(v23 + 24);
      *(void *)(v23 + 24) = 0;
      if (v24) {
        C3BaseRelease(v24);
      }
      long long v25 = *(const void **)(a1 + 40);
      if (v25) {
        C3BaseRelease(v25);
      }
    }
  }
  uint64_t v26 = *(const void **)(a1 + 48);
  if (v26) {
    CFRelease(v26);
  }
  uint64_t v27 = *(const void **)(a1 + 64);
  if (v27) {
    CFRelease(v27);
  }
  CFStringRef v28 = *(const void **)(a1 + 56);
  if (v28) {
    CFRelease(v28);
  }
}

void mmcs_proxy_locator_cancel(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"cancelling ACS locator. disregarding any callbacks.");
      uint64_t v4 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = 138543362;
        CFStringRef v6 = v3;
        _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&v5, 0xCu);
      }
      if (v3) {
        CFRelease(v3);
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
    *(_WORD *)(a1 + 41) = 257;
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  }
}

uint64_t mmcs_proxy_locator_is_locating(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 40);
  }
  return result;
}

uint64_t mmcs_proxy_locator_is_done(uint64_t a1)
{
  if (a1) {
    return *(unsigned __int8 *)(a1 + 42);
  }
  else {
    return 1;
  }
}

uint64_t mmcs_proxy_locator_finish(uint64_t result)
{
  if (result) {
    *(unsigned char *)(result + 42) = 1;
  }
  return result;
}

void _mmcs_proxy_locatorCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)(a1 + 32) = 0;
  CFStringRef v3 = *(const void **)(a1 + 24);
  if (v3) {
    C3BaseRelease(v3);
  }
  *(void *)(a1 + 24) = 0;
}

BOOL _mmcs_proxy_locatorCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_proxy_locatorCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_proxy_locatorCFCopyDebugDescription()
{
  return 0;
}

CFURLRef _LocatorVars_init_once()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  sLocateCFDictionaryRef Options = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v0, 0, v1, v2);
  uint64_t v4 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F4E2B0], (const void *)*MEMORY[0x1E4F1CFD0]);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F4E2B8], v4);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F4E2C0], v4);
  CFDictionaryAddValue((CFMutableDictionaryRef)sLocateOptions, (const void *)*MEMORY[0x1E4F4E2A8], Mutable);
  CFDictionaryAddValue((CFMutableDictionaryRef)sLocateOptions, (const void *)*MEMORY[0x1E4F4E2C8], v4);
  if (Mutable) {
    CFRelease(Mutable);
  }
  CFURLRef result = XCFURLCreateWithCString("https://www.apple.com");
  sDummyURL = (uint64_t)result;
  return result;
}

uint64_t __runOnMainRunLoop_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void mmcs_get_state_invalidate(uint64_t a1)
{
  CFArrayRef v1 = *(const __CFArray **)(a1 + 40);
  if (v1)
  {
    v2.unsigned int length = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    v2.CFIndex location = 0;
    CFArrayApplyFunction(v1, v2, (CFArrayApplierFunction)mmcs_container_invalidate_applier, 0);
  }
}

void mmcs_get_state_dealloc(void *a1)
{
  *a1 = 0;
  CFRange v2 = (void *)a1[4];
  if (v2)
  {
    if (!a1[1]) {
      goto LABEL_6;
    }
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      mmcs_get_file_finalize((void *)(a1[4] + v3));
      ++v4;
      v3 += 128;
    }
    while (v4 < a1[1]);
    CFRange v2 = (void *)a1[4];
    if (v2) {
LABEL_6:
    }
      free(v2);
    a1[4] = 0;
  }
  a1[1] = 0;
  a1[2] = 0;
  int v5 = (const void *)a1[10];
  if (v5) {
    CFRelease(v5);
  }
  a1[10] = 0;
  CFStringRef v6 = (const void *)a1[9];
  if (v6) {
    CFRelease(v6);
  }
  a1[9] = 0;
  uint64_t v7 = (const void *)a1[5];
  if (v7) {
    CFRelease(v7);
  }
  a1[5] = 0;
  uint64_t v8 = (const void *)a1[6];
  if (v8) {
    CFRelease(v8);
  }
  a1[6] = 0;
  uint64_t v9 = (const void *)a1[7];
  if (v9) {
    CFRelease(v9);
  }
  a1[7] = 0;
  CFAllocatorRef v10 = (const void *)a1[8];
  if (v10) {
    CFRelease(v10);
  }
  a1[8] = 0;
  dispatch_block_t v11 = (const void *)a1[11];
  if (v11) {
    CFRelease(v11);
  }
  a1[11] = 0;
  CFDataRef v12 = (const void *)a1[12];
  if (v12) {
    CFRelease(v12);
  }
  a1[12] = 0;
  long long v13 = (const void *)a1[13];
  if (v13) {
    CFRelease(v13);
  }
  free(a1);
}

BOOL mmcs_get_state_init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  if (a3 >> 57)
  {
    uint64_t v3 = mmcs_logging_logger_default();
    BOOL result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Multiplication overflow detected in computing the memory size to be allocated");
    CFStringRef v6 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    LODWORD(keyCallBacks.version) = 138543362;
    *(CFIndex *)((char *)&keyCallBacks.version + 4) = (CFIndex)v5;
    goto LABEL_30;
  }
  size_t v8 = a3 << 7;
  uint64_t v9 = malloc_type_malloc(a3 << 7, 0x7E316EB6uLL);
  *(void *)(a1 + 32) = v9;
  if (!v9)
  {
    uint64_t v17 = mmcs_logging_logger_default();
    BOOL result = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"malloc");
    CFStringRef v6 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    LODWORD(keyCallBacks.version) = 138543362;
    *(CFIndex *)((char *)&keyCallBacks.version + 4) = (CFIndex)v5;
    goto LABEL_30;
  }
  bzero(v9, v8);
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &containerArrayCallbacks);
  *(void *)(a1 + 40) = Mutable;
  if (!Mutable)
  {
    CFAllocatorRef v18 = mmcs_logging_logger_default();
    BOOL result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    CFStringRef v5 = CFStringCreateWithFormat(v10, 0, @"malloc");
    CFStringRef v6 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    LODWORD(keyCallBacks.version) = 138543362;
    *(CFIndex *)((char *)&keyCallBacks.version + 4) = (CFIndex)v5;
    goto LABEL_30;
  }
  CFMutableArrayRef v12 = CFArrayCreateMutable(v10, 0, &containerArrayCallbacks);
  *(void *)(a1 + 48) = v12;
  if (!v12)
  {
    os_log_type_t v19 = mmcs_logging_logger_default();
    BOOL result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    CFStringRef v5 = CFStringCreateWithFormat(v10, 0, @"malloc");
    CFStringRef v6 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    LODWORD(keyCallBacks.version) = 138543362;
    *(CFIndex *)((char *)&keyCallBacks.version + 4) = (CFIndex)v5;
    goto LABEL_30;
  }
  CFMutableArrayRef v13 = CFArrayCreateMutable(v10, 0, &containerArrayCallbacks);
  *(void *)(a1 + 56) = v13;
  if (!v13)
  {
    CFStringRef v20 = mmcs_logging_logger_default();
    BOOL result = os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    CFStringRef v5 = CFStringCreateWithFormat(v10, 0, @"malloc");
    CFStringRef v6 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    LODWORD(keyCallBacks.version) = 138543362;
    *(CFIndex *)((char *)&keyCallBacks.version + 4) = (CFIndex)v5;
    goto LABEL_30;
  }
  CFMutableArrayRef v14 = CFArrayCreateMutable(v10, 0, &containerArrayCallbacks);
  *(void *)(a1 + 64) = v14;
  if (!v14)
  {
    CFStringRef v21 = mmcs_logging_logger_default();
    BOOL result = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    CFStringRef v5 = CFStringCreateWithFormat(v10, 0, @"malloc");
    CFStringRef v6 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    LODWORD(keyCallBacks.version) = 138543362;
    *(CFIndex *)((char *)&keyCallBacks.version + 4) = (CFIndex)v5;
    goto LABEL_30;
  }
  CFMutableDictionaryRef v15 = CFDictionaryCreateMutable(v10, 0, 0, 0);
  *(void *)(a1 + 104) = v15;
  if (v15)
  {
    CFDictionaryKeyCallBacks keyCallBacks = *(CFDictionaryKeyCallBacks *)byte_1F363C900;
    CFStringRef v16 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    *(void *)(a1 + 80) = CFDictionaryCreateMutable(v10, 0, &keyCallBacks, MEMORY[0x1E4F1D540]);
    CFDictionaryKeyCallBacks v23 = *(CFDictionaryKeyCallBacks *)byte_1F363C930;
    *(void *)(a1 + 72) = CFDictionaryCreateMutable(v10, 0, &v23, v16);
    *(void *)(a1 + 88) = CFDictionaryCreateMutable(v10, 0, &chunkReferenceSignatureEqualityDictionaryKeyCallbacks, 0);
    *(void *)(a1 + 96) = CFSetCreateMutable(v10, 0, &chunkReferenceSignatureEqualitySetCallbacks);
    return 1;
  }
  uint64_t v22 = mmcs_logging_logger_default();
  BOOL result = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  if (result)
  {
    CFStringRef v5 = CFStringCreateWithFormat(v10, 0, @"malloc");
    CFStringRef v6 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
LABEL_31:
      if (v5) {
        CFRelease(v5);
      }
      return 0;
    }
    LODWORD(keyCallBacks.version) = 138543362;
    *(CFIndex *)((char *)&keyCallBacks.version + 4) = (CFIndex)v5;
LABEL_30:
    _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&keyCallBacks, 0xCu);
    goto LABEL_31;
  }
  return result;
}

BOOL mmcs_get_state_create(void *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  CFStringRef v6 = malloc_type_malloc(0x70uLL, 0x10200409DBB4D49uLL);
  if (v6)
  {
    uint64_t v7 = v6;
    if (mmcs_get_state_init((uint64_t)v6, a2, a3))
    {
      *a1 = v7;
      return 1;
    }
    mmcs_get_state_dealloc(v7);
  }
  else
  {
    uint64_t v9 = mmcs_logging_logger_default();
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"malloc");
    dispatch_block_t v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = 138543362;
      CFStringRef v13 = v10;
      _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v12, 0xCu);
    }
    if (v10) {
      CFRelease(v10);
    }
  }
  return 0;
}

uint64_t mmcs_get_file_omit_containers_not_needed(uint64_t a1, char *a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 16)) {
    goto LABEL_13;
  }
  uint64_t v4 = 0;
  unint64_t v5 = 1;
  int v6 = 1;
  do
  {
    uint64_t v7 = *(void *)(a1 + 32) + v4;
    if (!*(unsigned char *)(v7 + 115)
      && !mmcs_item_is_derivative(*(void *)(v7 + 8))
      && !mmcs_item_is_metadata_only(*(void *)(v7 + 8)))
    {
      int v6 = 0;
    }
    BOOL v8 = v5++ >= *(void *)(a1 + 16);
    v4 += 128;
  }
  while (!v8 && v6 != 0);
  if (v6)
  {
LABEL_13:
    CFArrayRef v10 = *(const __CFArray **)(a1 + 48);
    v42.unsigned int length = CFArrayGetCount(v10);
    v42.CFIndex location = 0;
    CFArrayApplyFunction(v10, v42, (CFArrayApplierFunction)mmcs_get_container_set_needed_applier, 0);
LABEL_14:
    char v36 = 0;
    goto LABEL_15;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  if (!Count) {
    goto LABEL_14;
  }
  CFIndex v13 = Count;
  char v36 = 0;
  CFIndex v14 = 0;
  CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v34 = a2;
  CFIndex v35 = Count;
  do
  {
    CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v14);
    container_copy_chunk_reference_set = mmcs_get_container_copy_chunk_reference_set((uint64_t)ValueAtIndex);
    uint64_t context = 0;
    CFSetApplyFunction(container_copy_chunk_reference_set, (CFSetApplierFunction)count_bytes_applier, &context);
    CFAllocatorRef v18 = mmcs_logging_logger_default();
    CFStringRef container_copy_simple_description = 0;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO)) {
      CFStringRef container_copy_simple_description = mmcs_get_container_copy_simple_description((uint64_t)ValueAtIndex);
    }
    CFIndex v20 = CFSetGetCount(container_copy_chunk_reference_set);
    XCFSetRemoveValuesFromSet(container_copy_chunk_reference_set, *(CFSetRef *)(a1 + 96));
    if (v20 == CFSetGetCount(container_copy_chunk_reference_set))
    {
      CFStringRef v21 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v22 = CFStringCreateWithFormat(v15, 0, @"Omitting the download of container %@ which not needed.", container_copy_simple_description);
        CFDictionaryKeyCallBacks v23 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v40 = v22;
          _os_log_impl(&dword_1DC1CA000, v23, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v22) {
          CFRelease(v22);
        }
      }
      mmcs_get_container_set_needed((uint64_t)ValueAtIndex, 0);
    }
    else
    {
      unint64_t v37 = 0;
      CFSetApplyFunction(container_copy_chunk_reference_set, (CFSetApplierFunction)count_bytes_applier, &v37);
      uint64_t v24 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v25 = context;
        CFAllocatorRef v26 = v15;
        CFIndex v27 = v20 - CFSetGetCount(container_copy_chunk_reference_set);
        uint64_t v28 = context - v37;
        CFIndex v29 = CFSetGetCount(container_copy_chunk_reference_set);
        CFIndex v33 = v27;
        CFAllocatorRef v15 = v26;
        CFStringRef v30 = CFStringCreateWithFormat(v26, 0, @"Container %@ has %ld chunks %llu bytes (%ld chunks %llu bytes needed, %ld chunks %llu bytes not needed).", container_copy_simple_description, v20, v25, v33, v28, v29, v37);
        uint64_t v31 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v40 = v30;
          _os_log_impl(&dword_1DC1CA000, v31, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        a2 = v34;
        CFIndex v13 = v35;
        if (v30) {
          CFRelease(v30);
        }
      }
      if (a2 && *a2 && (mmcs_get_req_context_force_get_chunks(*(void *)a1) || v37 > 0x7D000))
      {
        CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), ValueAtIndex);
        CFSetApplyFunction(Value, (CFSetApplierFunction)file_skip_container_and_get_chunks, ValueAtIndex);
        mmcs_get_container_set_needed((uint64_t)ValueAtIndex, 0);
        char v36 = 1;
      }
    }
    if (container_copy_simple_description) {
      CFRelease(container_copy_simple_description);
    }
    if (container_copy_chunk_reference_set) {
      CFRelease(container_copy_chunk_reference_set);
    }
    ++v14;
  }
  while (v13 != v14);
LABEL_15:
  if (a2) {
    *a2 = v36;
  }
  return 1;
}

uint64_t count_bytes_applier(uint64_t result, void *a2)
{
  *a2 += *(unsigned int *)(result + 4);
  return result;
}

void mmcs_get_state_decrement_outstanding_chunk_references_count(CFMutableDictionaryRef *a1, const void *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  double Current = CFAbsoluteTimeGetCurrent();
  long long value = (void *)-1;
  CFStringRef v5 = mmcs_chunk_reference_copy_description((uint64_t)a2);
  if (!CFSetContainsValue(*(CFSetRef *)(*((void *)*a1 + 38) + 104), a2)) {
    mmcs_get_state_decrement_outstanding_chunk_references_count_cold_1();
  }
  int v6 = a1 + 11;
  if (!CFDictionaryGetValueIfPresent(a1[11], a2, (const void **)&value)) {
    mmcs_get_state_decrement_outstanding_chunk_references_count_cold_2((uint64_t *)a1 + 11, (uint64_t)v5);
  }
  if (gMMCS_DebugLevel >= 5)
  {
    uint64_t v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"trying to remove chunk %@ with count %ld", v5, value);
      uint64_t v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v23 = v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v8) {
        CFRelease(v8);
      }
    }
  }
  if ((uint64_t)value < 2)
  {
    if (value != (void *)1)
    {
      if (CFSetContainsValue(*(CFSetRef *)(*((void *)*a1 + 38) + 104), a2)) {
        mmcs_get_state_decrement_outstanding_chunk_references_count_cold_5((uint64_t *)&value, (uint64_t)v5);
      }
      mmcs_get_state_decrement_outstanding_chunk_references_count_cold_4();
    }
    CFDictionaryRemoveValue(a1[11], a2);
    CFSetRemoveValue(a1[12], a2);
  }
  else
  {
    long long value = (char *)value - 1;
    if (!CFSetContainsValue(a1[12], a2)) {
      mmcs_get_state_decrement_outstanding_chunk_references_count_cold_3();
    }
    CFArrayRef v10 = CFSetGetValue(a1[12], a2);
    dispatch_block_t v11 = v10;
    if (gMMCS_DebugLevel >= 5)
    {
      CFStringRef v12 = mmcs_chunk_reference_copy_description((uint64_t)v10);
      if (gMMCS_DebugLevel >= 5)
      {
        CFIndex v13 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"found heap chunk reference %@", v12);
          CFAllocatorRef v15 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v23 = v14;
            _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v14) {
            CFRelease(v14);
          }
        }
      }
      if (v12) {
        CFRelease(v12);
      }
    }
    CFDictionaryReplaceValue(*v6, v11, value);
  }
  if (gMMCS_DebugLevel >= 5)
  {
    CFStringRef v16 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFAbsoluteTime v18 = CFAbsoluteTimeGetCurrent();
      CFStringRef v19 = CFStringCreateWithFormat(v17, 0, @"removing chunk from maintained structure took %.6fus", (v18 - Current) * 1000000.0);
      CFIndex v20 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v23 = v19;
        _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v19) {
        CFRelease(v19);
      }
    }
  }
  if (v5) {
    CFRelease(v5);
  }
}

uint64_t mmcs_get_state_all_outstanding_chunk_references_contains_chunk(CFSetRef *a1, const void *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  double Current = CFAbsoluteTimeGetCurrent();
  if (!CFSetContainsValue(*(CFSetRef *)(*((void *)*a1 + 38) + 104), a2)) {
    mmcs_get_state_all_outstanding_chunk_references_contains_chunk_cold_1();
  }
  uint64_t v5 = CFSetContainsValue(a1[12], a2);
  if (gMMCS_DebugLevel >= 5)
  {
    int v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFAbsoluteTime v8 = CFAbsoluteTimeGetCurrent();
      CFStringRef v9 = CFStringCreateWithFormat(v7, 0, @"consulting maintained structure took %.6fus", (v8 - Current) * 1000000.0);
      CFArrayRef v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v13 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
  }
  return v5;
}

uint64_t mmcs_get_state_process_file_list(uint64_t a1, void *a2, int a3, int a4, CFTypeRef *a5)
{
  uint64_t v5 = a5;
  uint64_t v7 = a1;
  uint64_t v352 = *MEMORY[0x1E4F143B8];
  v349[0] = 0;
  v349[1] = 0;
  long long value = 0;
  CFTypeRef v348 = 0;
  if (a5) {
    *a5 = 0;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
  unint64_t v325 = *(void *)(v7 + 16);
  __int16 v335 = *(void **)v7;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
  CFMutableDictionaryRef v10 = CFDictionaryCreateMutable(v9, 0, 0, 0);
  v334 = CFDictionaryCreateMutable(v9, 0, 0, 0);
  dispatch_block_t v11 = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E4F1D530], 0);
  unint64_t v12 = a2[5];
  if (v12)
  {
    for (unint64_t i = 0; i < v12; ++i)
    {
      uint64_t v14 = *(void **)(a2[6] + 8 * i);
      uint64_t v15 = v14[12];
      if (v15)
      {
        *(void *)uint64_t valuePtr = *(void *)(v15 + 32) | (*(void *)(v15 + 24) << 32);
        CFNumberRef v16 = CFNumberCreate(v9, kCFNumberSInt64Type, valuePtr);
        if (!v16)
        {
          LOBYTE(v19) = 0;
          int v98 = 1;
          goto LABEL_312;
        }
        CFNumberRef v17 = v16;
        CFDictionaryAddValue(v11, v16, v14);
        CFRelease(v17);
        unint64_t v12 = a2[5];
      }
    }
  }
  __int16 v327 = v5;
  CFAllocatorRef alloc = v9;
  uint64_t v338 = (uint64_t *)v7;
  __int16 v333 = v10;
  if (a2[3])
  {
    uint64_t v18 = 0;
    CFStringRef v19 = &valuePtr[8];
    CFDictionaryRef theDict = v11;
    while (1)
    {
      uint64_t v329 = v18;
      uint64_t v20 = *(void *)(a2[4] + 8 * v18);
      if (value) {
        C3BaseRelease(value);
      }
      long long value = 0;
      if (!mmcs_get_container_create(&value, (uint64_t *)v7, v20))
      {
        v231 = mmcs_logging_logger_default();
        uint64_t v5 = v327;
        CFDataRef v195 = Mutable;
        if (os_log_type_enabled(v231, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v232 = CFStringCreateWithFormat(v9, 0, @"mmcs_get_container_create");
          v233 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v233, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t valuePtr = 138543362;
            *(void *)&valuePtr[4] = v232;
            _os_log_impl(&dword_1DC1CA000, v233, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
          }
          if (v232) {
            CFRelease(v232);
          }
        }
        CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 36, @"mmcs_get_container_create failed");
        goto LABEL_411;
      }
      state.opaque[0] = 0;
      state.opaque[1] = 0;
      os_activity_scope_enter(*((os_activity_t *)value + 10), &state);
      CFStringRef v21 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        size_t v22 = strlen(*(const char **)(v20 + 48));
        CFStringRef v23 = CFStringCreateWithBytes(v9, *(const UInt8 **)(v20 + 48), v22, 0x8000100u, 0);
        double v24 = COERCE_DOUBLE(mmcs_container_id_info_parse_container_id(v23));
        double v25 = v24;
        if (v24 == 0.0) {
          CFStringRef String = 0;
        }
        else {
          CFStringRef String = XCFAbsoluteTimeDateFormatterCreateString(v24);
        }
        CFIndex v27 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
        {
          double v28 = -1.0;
          if (v25 != 0.0) {
            double v28 = CFAbsoluteTimeGetCurrent() - v25;
          }
          *(_DWORD *)uint64_t valuePtr = 138543874;
          *(void *)&valuePtr[4] = v23;
          *(_WORD *)&unsigned char valuePtr[12] = 2048;
          *(double *)&valuePtr[14] = v28;
          *(_WORD *)&valuePtr[22] = 2114;
          *(void *)&valuePtr[24] = String;
          _os_log_impl(&dword_1DC1CA000, v27, OS_LOG_TYPE_INFO, "Container %{public}@ upload authorized %0.4lf seconds ago at %{public}@", valuePtr, 0x20u);
        }
        if (v23) {
          CFRelease(v23);
        }
        uint64_t v7 = (uint64_t)v338;
        if (String) {
          CFRelease(String);
        }
      }
      CFIndex v29 = (const void *)v335[14];
      if (v29) {
        mmcs_container_set_http_clock_skew_metrics((uint64_t)value, v29);
      }
      uint64_t v30 = *(void *)(v20 + 64);
      if (*(void *)(v20 + 32)) {
        break;
      }
      if (!v30)
      {
LABEL_310:
        os_activity_scope_leave(&state);
        LOBYTE(v19) = 0;
        int v98 = 1;
        goto LABEL_311;
      }
      int v31 = 0;
      int v32 = 0;
      uint64_t v33 = *(void *)(v20 + 72);
      do
      {
        if (*(void *)(*(void *)v33 + 24))
        {
          int v32 = 1;
        }
        else
        {
          if (!*(void *)(*(void *)v33 + 32)) {
            goto LABEL_310;
          }
          int v31 = 1;
        }
        v33 += 8;
        --v30;
      }
      while (v30);
      if (v32 && v31)
      {
        uint64_t v269 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v269, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t valuePtr = 0;
          _os_log_impl(&dword_1DC1CA000, v269, OS_LOG_TYPE_ERROR, "Container contains both ford and chunks.", valuePtr, 2u);
        }
        CFTypeRef v348 = mmcs_cferror_create_error(@"com.apple.mmcs", 6, @"Container contains both ford and chunks.");
        goto LABEL_310;
      }
      if (v32) {
        goto LABEL_41;
      }
      if (!v31) {
        mmcs_get_state_process_file_list_cold_6();
      }
      CFArrayAppendValue(*(CFMutableArrayRef *)(v7 + 56), value);
      *(_DWORD *)(*((void *)value + 11) + 176) = 2;
      CFIndex v35 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t valuePtr = 0;
        _os_log_impl(&dword_1DC1CA000, v35, OS_LOG_TYPE_INFO, "ContainerType: MMCSGetContainerTypeFORD", valuePtr, 2u);
      }
      mmcs_get_container_set_needed((uint64_t)value, 0);
LABEL_47:
      CFArrayAppendValue(*(CFMutableArrayRef *)(v7 + 40), value);
      char v36 = (CFTypeRef *)(*((void *)value + 2) + 24);
      uint64_t v37 = *(void *)(v20 + 24);
      http_request_options = (const void *)mmcs_request_get_http_request_options(*(void *)v7);
      int should_disable_vendor_tls = mmcs_request_should_disable_vendor_tls(*(void *)v7);
      if (!mmcs_http_request_create_with_host_info(v36, v37, http_request_options, should_disable_vendor_tls, (CFErrorRef *)&v348))
      {
        v243 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v243, OS_LOG_TYPE_ERROR))
        {
          uint64_t v321 = *(void *)(*((void *)value + 11) + 16);
          CFStringRef v244 = CFStringCreateWithFormat(v9, 0, @"Unable to create message for container %s");
          CFArrayRef v245 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v245, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t valuePtr = 138543362;
            *(void *)&valuePtr[4] = v244;
            _os_log_impl(&dword_1DC1CA000, v245, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
          }
          if (v244) {
            CFRelease(v244);
          }
        }
        goto LABEL_310;
      }
      dispatch_block_t v11 = theDict;
      if (mmcs_request_get_url_expiry_override((uint64_t)v335))
      {
        CFStringRef v40 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v321 = *(void *)(*(void *)(v20 + 24) + 120);
          CFStringRef v41 = CFStringCreateWithFormat(v9, 0, @"overriding url expiry %llu from content server");
          CFRange v42 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t valuePtr = 138543362;
            *(void *)&valuePtr[4] = v41;
            _os_log_impl(&dword_1DC1CA000, v42, OS_LOG_TYPE_DEBUG, "%{public}@", valuePtr, 0xCu);
          }
          if (v41) {
            CFRelease(v41);
          }
        }
        uint64_t v43 = *(void *)(*((void *)value + 2) + 24);
        int url_expiry_override = mmcs_request_get_url_expiry_override((uint64_t)v335);
        mmcs_http_request_override_url_expiry(v43, url_expiry_override);
      }
      uint64_t v45 = *(void *)(*(void *)(v20 + 24) + 128);
      if (v45)
      {
        size_t v46 = strlen(*(const char **)(v45 + 24));
        CFStringRef v47 = CFStringCreateWithBytes(alloc, *(const UInt8 **)(v45 + 24), v46, 0x8000100u, 0);
        size_t v48 = strlen(*(const char **)(v45 + 32));
        CFStringRef v49 = CFStringCreateWithBytes(alloc, *(const UInt8 **)(v45 + 32), v48, 0x8000100u, 0);
        char v50 = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        *((void *)value + 4) = v50;
        CFDictionaryAddValue(v50, v47, v49);
        CFStringRef v51 = mmcs_logging_logger_default();
        os_log_type_t v52 = mmcs_logging_log_header_level(v47);
        if (os_log_type_enabled(v51, v52))
        {
          *(_DWORD *)uint64_t valuePtr = 138543618;
          *(void *)&valuePtr[4] = v47;
          *(_WORD *)&unsigned char valuePtr[12] = 2114;
          *(void *)&valuePtr[14] = v49;
          _os_log_impl(&dword_1DC1CA000, v51, v52, "AcceleratorRequestHeader (%{public}@:%{public}@)", valuePtr, 0x16u);
        }
        if (v47) {
          CFRelease(v47);
        }
        dispatch_block_t v11 = theDict;
        if (v49) {
          CFRelease(v49);
        }
      }
      uint64_t v53 = *(void *)(v20 + 64) + *(void *)(v20 + 32);
      if (v53)
      {
        uint64_t v54 = 0;
        while (1)
        {
          if (*(void *)(v20 + 32))
          {
            uint64_t v55 = *(void *)(*(void *)(v20 + 40) + 8 * v54);
            goto LABEL_66;
          }
          uint64_t v64 = *(void *)(*(void *)(v20 + 72) + 8 * v54);
          if (!*(void *)(v64 + 32))
          {
            uint64_t v55 = *(void *)(v64 + 24);
            dispatch_block_t v11 = theDict;
            if (!v55)
            {
              v217 = mmcs_logging_logger_default();
              BOOL v218 = os_log_type_enabled(v217, OS_LOG_TYPE_ERROR);
              uint64_t v7 = (uint64_t)v338;
              uint64_t v5 = v327;
              CFDataRef v195 = Mutable;
              CFMutableDictionaryRef v10 = v333;
              if (v218)
              {
                CFStringRef v219 = CFStringCreateWithFormat(alloc, 0, @"Unknown element type.");
                uint64_t v220 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v220, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)uint64_t valuePtr = 138543362;
                  *(void *)&valuePtr[4] = v219;
                  _os_log_impl(&dword_1DC1CA000, v220, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
                }
                if (v219) {
                  CFRelease(v219);
                }
              }
              goto LABEL_330;
            }
LABEL_66:
            if (v54 && ProtobufCBinaryData_Equals((uint64_t)v349, v55 + 24)) {
              goto LABEL_116;
            }
            ProtobufCBinaryData_SetCopyBufferLen(v349, *(const void **)(v55 + 32), *(void *)(v55 + 24));
            uint64_t v56 = CKChunkSchemeAndSignatureSize();
            unint64_t v57 = *(void *)(v55 + 24);
            if (v56 != v57)
            {
              uint64_t v198 = hextostrdup(*(char **)(v55 + 32), v57);
              uint64_t v199 = mmcs_logging_logger_default();
              CFMutableDictionaryRef v10 = v333;
              if (os_log_type_enabled(v199, OS_LOG_TYPE_ERROR))
              {
                uint64_t v200 = CKChunkSchemeAndSignatureSize();
                CFStringRef v201 = CFStringCreateWithFormat(alloc, 0, @"Chunk rejected (%s): unexpected signature size. Expected: %lu, got: %lu.", v198, v200, *(void *)(v55 + 24));
                char v202 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v202, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)uint64_t valuePtr = 138543362;
                  *(void *)&valuePtr[4] = v201;
                  _os_log_impl(&dword_1DC1CA000, v202, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
                }
                if (v201) {
                  CFRelease(v201);
                }
              }
              CKChunkSchemeAndSignatureSize();
              CFTypeRef v348 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Chunk rejected (%s): unexpected signature size. Expected: %lu, got: %lu.", v203, v204, v205, v206, v207, (char)v198);
              uint64_t v7 = (uint64_t)v338;
              if (v198) {
                free(v198);
              }
              goto LABEL_310;
            }
            if (!a3 && !mmcs_get_req_get_chunk_reference(*v338, *(_DWORD *)(v55 + 64), *(void *)(v55 + 32), 0))
            {
              char v58 = hextostrdup(*(char **)(v55 + 32), *(void *)(v55 + 24));
              uint64_t v59 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
              {
                LOBYTE(v321) = (_BYTE)v58;
                CFStringRef v60 = CFStringCreateWithFormat(alloc, 0, @"Unknown chunk %s received");
                unint64_t v61 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)uint64_t valuePtr = 138543362;
                  *(void *)&valuePtr[4] = v60;
                  _os_log_impl(&dword_1DC1CA000, v61, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
                }
                dispatch_block_t v11 = theDict;
                if (v60) {
                  CFRelease(v60);
                }
              }
              if (v58) {
                free(v58);
              }
            }
            buf[0] = 0;
            char v344 = 0;
            if (*(_DWORD *)(v55 + 68))
            {
              uint64_t v62 = *(unsigned int *)(v55 + 72);
              uint64_t v63 = (unint64_t *)&v345;
            }
            else
            {
              uint64_t v63 = 0;
              uint64_t v62 = 0;
            }
            uint64_t v345 = v62;
            if (mmcs_get_container_add_chunk_instance((uint64_t)value, *(_DWORD *)(v55 + 64), v63, *(unsigned char **)(v55 + 32), buf, &v344, (CFErrorRef *)&v348))
            {
              if (gMMCS_DebugLevel >= 4)
              {
                CFStringRef v69 = hextostrdup(*(char **)(v55 + 32), *(void *)(v55 + 24));
                CFMutableSetRef v70 = mmcs_logging_logger_chunk();
                if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v71 = *(void *)(v20 + 64) + *(void *)(v20 + 32);
                  int v72 = *(_DWORD *)(v55 + 64);
                  uint64_t v73 = "true";
                  if (!*(_DWORD *)(v55 + 68)) {
                    uint64_t v73 = "false";
                  }
                  *(_DWORD *)uint64_t valuePtr = 134219266;
                  *(void *)&valuePtr[4] = v54 + 1;
                  *(_WORD *)&unsigned char valuePtr[12] = 2048;
                  *(void *)&valuePtr[14] = v71;
                  *(_WORD *)&valuePtr[22] = 1024;
                  *(_DWORD *)&valuePtr[24] = v72;
                  *(_WORD *)&valuePtr[28] = 2080;
                  *(void *)&valuePtr[30] = v73;
                  *(_WORD *)&valuePtr[38] = 2048;
                  *(void *)&valuePtr[40] = v345;
                  *(_WORD *)&valuePtr[48] = 2082;
                  *(void *)&valuePtr[50] = v69;
                  _os_log_impl(&dword_1DC1CA000, v70, OS_LOG_TYPE_DEFAULT, "Chunk %lu of %zu with byteLength %u and offset %s:%llu has signature %{public}s", valuePtr, 0x3Au);
                }
                if (v69) {
                  free(v69);
                }
              }
              if (!v344) {
                *(void *)(v55 + 32) = 0;
              }
              if (buf[0])
              {
                int v74 = 0;
                goto LABEL_115;
              }
              CFStringRef v75 = hextostrdup(*(char **)(v55 + 32), *(void *)(v55 + 24));
              uint64_t v76 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)uint64_t valuePtr = 136446210;
                *(void *)&valuePtr[4] = v75;
                _os_log_impl(&dword_1DC1CA000, v76, OS_LOG_TYPE_ERROR, "Chunk with signature %{public}s couldn't find associated chunk reference.", valuePtr, 0xCu);
              }
              if (v75) {
                free(v75);
              }
            }
            goto LABEL_105;
          }
          ProtobufCBinaryData_SetCopyBufferLen(v349, 0, 0);
          if (!*(_DWORD *)(*(void *)(v64 + 32) + 24))
          {
            unint64_t v208 = mmcs_logging_logger_default();
            uint64_t v7 = (uint64_t)v338;
            if (os_log_type_enabled(v208, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t valuePtr = 0;
              _os_log_impl(&dword_1DC1CA000, v208, OS_LOG_TYPE_ERROR, "FORD Info must have non-zero length.", valuePtr, 2u);
            }
            CFTypeRef v348 = mmcs_cferror_create_error(@"com.apple.mmcs", 6, @"FORD Info must have non-zero length.");
            uint64_t v5 = v327;
            CFDataRef v195 = Mutable;
            CFMutableDictionaryRef v10 = v333;
LABEL_330:
            os_activity_scope_leave(&state);
            goto LABEL_331;
          }
          uint64_t v345 = v54 | (v329 << 32);
          CFNumberRef v65 = CFNumberCreate(alloc, kCFNumberSInt64Type, &v345);
          if (!v65)
          {
            uint64_t v77 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t valuePtr = 0;
              _os_log_impl(&dword_1DC1CA000, v77, OS_LOG_TYPE_ERROR, "Failed to generate CFNumberRef for storageContainerIndex", valuePtr, 2u);
            }
            CFIndex v78 = 36;
            unint64_t v79 = @"Failed to generate CFNumberRef for storageContainerIndex";
            goto LABEL_112;
          }
          CFNumberRef v66 = v65;
          uint64_t v67 = CFDictionaryGetValue(theDict, v65);
          CFRelease(v66);
          if (!v67)
          {
            uint64_t v80 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t valuePtr = 0;
              _os_log_impl(&dword_1DC1CA000, v80, OS_LOG_TYPE_ERROR, "Failed to find fileChecksumChunkReferences for storageContainerIndex", valuePtr, 2u);
            }
            CFIndex v78 = 1;
            unint64_t v79 = @"Failed to find fileChecksumChunkReferences for storageContainerIndex";
LABEL_112:
            CFTypeRef v348 = mmcs_cferror_create_error(@"com.apple.mmcs", v78, v79);
            goto LABEL_113;
          }
          CFDataRef v68 = v67[14] ? ProtobufCBinaryData_CreateData((CFDataRef)(v67 + 16)) : 0;
          uint64_t v81 = *((void *)v67 + 4);
          uint64_t v82 = v335[38];
          if (a3) {
            break;
          }
          CFSetRef v83 = *(const __CFSet **)(v82 + 88);
          if (v83) {
            goto LABEL_122;
          }
          CFNumberRef v94 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
          {
            CFStringRef cfa = CFStringCreateWithFormat(alloc, 0, @"itemsForGetChunks is NULL");
            CFNumberRef v95 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf[0]) = 138543362;
              *(uint64_t *)((char *)buf + 4) = (uint64_t)cfa;
              _os_log_impl(&dword_1DC1CA000, v95, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)buf, 0xCu);
            }
            if (cfa) {
              CFRelease(cfa);
            }
          }
          CFTypeID v84 = 0;
          if (v68) {
            goto LABEL_123;
          }
LABEL_124:
          CFSetRef v85 = *(_DWORD **)(v64 + 32);
          if (v85[8])
          {
            uint64_t v86 = v85[9];
            CFStringRef v87 = (unint64_t *)buf;
          }
          else
          {
            CFStringRef v87 = 0;
            uint64_t v86 = 0;
          }
          buf[0] = v86;
          if (!mmcs_get_container_add_ford_instance((uint64_t)value, v85[7], v87, (uint64_t)v84, (CFErrorRef *)&v348))
          {
            if (!v348)
            {
              CFTypeID v93 = mmcs_logging_logger_default();
              dispatch_block_t v11 = theDict;
              if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)uint64_t valuePtr = 0;
                _os_log_impl(&dword_1DC1CA000, v93, OS_LOG_TYPE_ERROR, "Unspecified error performing mmcs_get_container_add_ford_instance", valuePtr, 2u);
              }
              CFTypeRef v348 = mmcs_cferror_create_error(@"com.apple.mmcs", 1, @"Unspecified error performing mmcs_get_container_add_ford_instance");
LABEL_105:
              int v74 = 5;
              goto LABEL_115;
            }
LABEL_113:
            int v74 = 5;
LABEL_114:
            dispatch_block_t v11 = theDict;
            goto LABEL_115;
          }
          if (!v84
            || (CFDictionaryAddValue(Mutable, v84, v67),
                mmcs_get_container_set_needed((uint64_t)value, 1),
                uint64_t v88 = mmcs_logging_logger_default(),
                !os_log_type_enabled(v88, OS_LOG_TYPE_INFO)))
          {
            int v74 = 32;
            goto LABEL_114;
          }
          CFTypeRef cf = mmcs_file_signature_to_hexstring(*v84);
          CCFStringRef StringDescription = XCFDataCreateCStringDescription((const __CFData *)v84[6]);
          CFTypeID v90 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v90, OS_LOG_TYPE_INFO))
          {
            uint64_t v91 = *(unsigned int *)(*(void *)(v64 + 32) + 28);
            CFStringRef v92 = v84[5];
            *(_DWORD *)uint64_t valuePtr = 134219010;
            *(void *)&valuePtr[4] = buf[0];
            *(_WORD *)&unsigned char valuePtr[12] = 2048;
            *(void *)&valuePtr[14] = v91;
            *(_WORD *)&valuePtr[22] = 2048;
            *(void *)&valuePtr[24] = v92;
            *(_WORD *)&valuePtr[32] = 2082;
            *(void *)&valuePtr[34] = cf;
            *(_WORD *)&valuePtr[42] = 2082;
            *(void *)&valuePtr[44] = CStringDescription;
            _os_log_impl(&dword_1DC1CA000, v90, OS_LOG_TYPE_INFO, "FORD container instance at offset %llu with length %llu for itemId:%llu sig:%{public}s ref:%{public}s", valuePtr, 0x34u);
          }
          if (cf) {
            free(cf);
          }
          dispatch_block_t v11 = theDict;
          if (CStringDescription) {
            free(CStringDescription);
          }
          int v74 = 32;
LABEL_115:
          if ((v74 | 0x20) != 0x20)
          {
            os_activity_scope_leave(&state);
            CFMutableDictionaryRef v10 = v333;
            if (v74 != 5) {
              return v19;
            }
            LOBYTE(v19) = 0;
            int v98 = 1;
            uint64_t v7 = (uint64_t)v338;
LABEL_311:
            uint64_t v5 = v327;
LABEL_312:
            CFDataRef v195 = Mutable;
            goto LABEL_413;
          }
LABEL_116:
          if (v53 == ++v54) {
            goto LABEL_149;
          }
        }
        CFSetRef v83 = *(const __CFSet **)(v82 + 80);
LABEL_122:
        memset(&valuePtr[56], 0, 360);
        memset(&valuePtr[8], 0, 40);
        *(void *)uint64_t valuePtr = v81;
        *(void *)&valuePtr[48] = v68;
        CFTypeID v84 = (char **)CFSetGetValue(v83, valuePtr);
        if (!v68) {
          goto LABEL_124;
        }
LABEL_123:
        CFRelease(v68);
        goto LABEL_124;
      }
LABEL_149:
      os_activity_scope_leave(&state);
      uint64_t v18 = v329 + 1;
      CFAllocatorRef v9 = alloc;
      uint64_t v7 = (uint64_t)v338;
      CFMutableDictionaryRef v10 = v333;
      if ((unint64_t)(v329 + 1) >= a2[3]) {
        goto LABEL_150;
      }
    }
    if (v30) {
      goto LABEL_310;
    }
LABEL_41:
    CFArrayAppendValue(*(CFMutableArrayRef *)(v7 + 48), value);
    *(_DWORD *)(*((void *)value + 11) + 176) = 1;
    CFStringRef v34 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t valuePtr = 0;
      _os_log_impl(&dword_1DC1CA000, v34, OS_LOG_TYPE_INFO, "ContainerType: MMCSGetContainerTypeChunks", valuePtr, 2u);
    }
    goto LABEL_47;
  }
LABEL_150:
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v96 = v335[38];
  uint64_t v5 = v327;
  if (a3)
  {
    CFSetRef v97 = *(const __CFSet **)(v96 + 80);
  }
  else
  {
    CFSetRef v97 = *(const __CFSet **)(v96 + 88);
    if (!v97)
    {
      unint64_t v209 = mmcs_logging_logger_default();
      CFDataRef v195 = Mutable;
      if (os_log_type_enabled(v209, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v215 = CFStringCreateWithFormat(v9, 0, @"itemsForGetChunks is NULL");
        v216 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v216, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t valuePtr = 138543362;
          *(void *)&valuePtr[4] = v215;
          _os_log_impl(&dword_1DC1CA000, v216, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
        }
        if (v215) {
          CFRelease(v215);
        }
      }
      int v98 = 1;
      LOBYTE(v19) = 0;
      CFTypeRef v348 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"itemsForGetChunks is NULL.", v210, v211, v212, v213, v214, v321);
      goto LABEL_413;
    }
  }
  if (a2[5])
  {
    uint64_t v99 = 0;
    if (v10) {
      BOOL v100 = v334 == 0;
    }
    else {
      BOOL v100 = 1;
    }
    char v101 = !v100;
    char v328 = v101;
    CFSetRef v324 = v97;
    while (1)
    {
      uint64_t v102 = *(void *)(a2[6] + 8 * v99);
      if (*(void *)(v102 + 24) != 21)
      {
        uint64_t v251 = mmcs_logging_logger_default();
        CFDataRef v195 = Mutable;
        if (os_log_type_enabled(v251, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v257 = CFStringCreateWithFormat(v9, 0, @"Bad length for file checksum length");
          unint64_t v258 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v258, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t valuePtr = 138543362;
            *(void *)&valuePtr[4] = v257;
            _os_log_impl(&dword_1DC1CA000, v258, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
          }
          if (v257) {
            CFRelease(v257);
          }
        }
        LOBYTE(v321) = 21;
        CFStringRef v259 = @"Bad length for file checksum, expected size: %d, got: %lu.";
        goto LABEL_382;
      }
      uint64_t v330 = v99;
      if (*(_DWORD *)(v102 + 56))
      {
        if (*(void *)(v102 + 64) != 21)
        {
          v265 = mmcs_logging_logger_default();
          CFDataRef v195 = Mutable;
          if (os_log_type_enabled(v265, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v266 = CFStringCreateWithFormat(v9, 0, @"Bad length for reference signature length");
            uint64_t v267 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v267, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)uint64_t valuePtr = 138543362;
              *(void *)&valuePtr[4] = v266;
              _os_log_impl(&dword_1DC1CA000, v267, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
            }
            if (v266) {
              CFRelease(v266);
            }
          }
          LOBYTE(v321) = 21;
          CFStringRef v259 = @"Bad length for reference signature, expected size: %d, got: %lu.";
LABEL_382:
          CFIndex v268 = 6;
          goto LABEL_410;
        }
        CFDataRef Data = ProtobufCBinaryData_CreateData((CFDataRef)(v102 + 64));
      }
      else
      {
        CFDataRef Data = 0;
      }
      memset(&valuePtr[48], 0, 368);
      memset(valuePtr, 0, 48);
      *(void *)uint64_t valuePtr = *(void *)(v102 + 32);
      *(void *)&valuePtr[48] = Data;
      size_t v104 = CFSetGetValue(v97, valuePtr);
      if (Data) {
        CFRelease(Data);
      }
      if (v104) {
        break;
      }
      uint64_t v114 = hextostrdup(*(char **)(v102 + 32), *(void *)(v102 + 24));
      if (*(_DWORD *)(v102 + 56)) {
        CFStringRef v115 = hextostrdup(*(char **)(v102 + 72), *(void *)(v102 + 64));
      }
      else {
        CFStringRef v115 = 0;
      }
      uint64_t v121 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t valuePtr = 136315394;
        *(void *)&valuePtr[4] = v114;
        *(_WORD *)&unsigned char valuePtr[12] = 2080;
        *(void *)&valuePtr[14] = v115;
        _os_log_impl(&dword_1DC1CA000, v121, OS_LOG_TYPE_DEFAULT, "could not find item for signature %s reference %s", valuePtr, 0x16u);
      }
      if (v114) {
        free(v114);
      }
      CFAllocatorRef v9 = alloc;
      if (v115) {
        free(v115);
      }
LABEL_223:
      uint64_t v99 = v330 + 1;
      if ((unint64_t)(v330 + 1) >= a2[5]) {
        goto LABEL_224;
      }
    }
    CFStringRef v105 = *(const UInt8 **)(v102 + 80);
    if (v105)
    {
      size_t v106 = strlen(*(const char **)(v102 + 80));
      CFStringRef v107 = CFStringCreateWithBytes(alloc, v105, v106, 0x8000100u, 0);
      if (v107)
      {
        CFStringRef v108 = v107;
        mmcs_item_set_MIME_type((uint64_t)v104, v107);
        CFRelease(v108);
      }
    }
    __int16 v331 = v104;
    if (a3)
    {
      if (mmcs_item_set_chunk_instance_capacity((uint64_t)v104, *(void *)(v102 + 40)))
      {
        unint64_t v109 = *(void *)(v7 + 16);
        if (v109 >= *(void *)(v7 + 8))
        {
          BOOL v283 = mmcs_logging_logger_default();
          CFDataRef v195 = Mutable;
          if (os_log_type_enabled(v283, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v289 = CFStringCreateWithFormat(alloc, 0, @"mmcs_get_file overflow");
            v290 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v290, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)uint64_t valuePtr = 138543362;
              *(void *)&valuePtr[4] = v289;
              _os_log_impl(&dword_1DC1CA000, v290, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
            }
            if (v289) {
              CFRelease(v289);
            }
          }
          int v98 = 1;
          LOBYTE(v19) = 0;
          CFTypeRef v348 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"mmcs_get_file overflow", v284, v285, v286, v287, v288, v321);
          goto LABEL_413;
        }
        unint64_t v110 = (unsigned char **)v104;
        uint64_t v111 = *(void *)(v7 + 32);
        char req_context_use_registry = mmcs_get_req_context_use_registry((uint64_t)v335);
        if ((**v110 & 0x7F) == 4) {
          should_validate_file_content_for_CFRange v2 = mmcs_get_req_context_should_validate_file_content_for_v2((uint64_t)v335);
        }
        else {
          should_validate_file_content_for_CFRange v2 = mmcs_get_req_context_should_validate_file_content_for_v1((uint64_t)v335);
        }
        char v122 = should_validate_file_content_for_v2;
        uint64_t v120 = (const void *)(v111 + (v109 << 7));
        if (mmcs_item_is_derivative((uint64_t)v331)) {
          char v123 = 0;
        }
        else {
          char v123 = req_context_use_registry;
        }
        if (!mmcs_get_file_init((uint64_t)v120, v7, (uint64_t)v331, v123, v122))
        {
          v291 = mmcs_logging_logger_default();
          CFDataRef v195 = Mutable;
          CFMutableDictionaryRef v10 = v333;
          if (os_log_type_enabled(v291, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v281 = CFStringCreateWithFormat(alloc, 0, @"mmcs_get_file_init");
            v282 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v282, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)uint64_t valuePtr = 138543362;
              *(void *)&valuePtr[4] = v281;
LABEL_406:
              _os_log_impl(&dword_1DC1CA000, v282, OS_LOG_TYPE_DEBUG, "%{public}@", valuePtr, 0xCu);
            }
            goto LABEL_407;
          }
          goto LABEL_409;
        }
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v7 + 104), v331, v120);
        char theDicta = 0;
        goto LABEL_206;
      }
      if (!a4 || !v104[34])
      {
        CFStringRef v280 = mmcs_logging_logger_default();
        CFDataRef v195 = Mutable;
        if (os_log_type_enabled(v280, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v281 = CFStringCreateWithFormat(alloc, 0, @"could not initialize chunk instance capacity");
          v282 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v282, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t valuePtr = 138543362;
            *(void *)&valuePtr[4] = v281;
            goto LABEL_406;
          }
LABEL_407:
          if (v281) {
            CFRelease(v281);
          }
        }
LABEL_409:
        CFStringRef v259 = @"mmcs_get_file_init";
        CFIndex v268 = 37;
LABEL_410:
        CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", v268, v259, v252, v253, v254, v255, v256, v321);
LABEL_411:
        LOBYTE(v19) = 0;
        CFTypeRef v348 = error;
        goto LABEL_412;
      }
      int v117 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v118 = CFStringCreateWithFormat(alloc, 0, @"could not initialize chunk instance capacity because it already was");
        CFStringRef v119 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v119, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t valuePtr = 138543362;
          *(void *)&valuePtr[4] = v118;
          _os_log_impl(&dword_1DC1CA000, v119, OS_LOG_TYPE_DEBUG, "%{public}@", valuePtr, 0xCu);
        }
        if (v118) {
          CFRelease(v118);
        }
      }
      uint64_t v116 = CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 104), v104);
      if (!v116)
      {
        CFStringRef v302 = mmcs_item_copy_description((uint64_t)v104);
        v313 = mmcs_logging_logger_default();
        CFDataRef v195 = Mutable;
        if (os_log_type_enabled(v313, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v319 = CFStringCreateWithFormat(alloc, 0, @"B unable to find file state for item %@", v302);
          unint64_t v320 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v320, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t valuePtr = 138543362;
            *(void *)&valuePtr[4] = v319;
            _os_log_impl(&dword_1DC1CA000, v320, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
          }
          if (v319) {
            CFRelease(v319);
          }
        }
        CFErrorRef v312 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"B unable to find file state for item %@", v314, v315, v316, v317, v318, (char)v302);
LABEL_446:
        CFTypeRef v348 = v312;
        if (v302)
        {
LABEL_447:
          CFRelease(v302);
          goto LABEL_331;
        }
        LOBYTE(v19) = 0;
        int v98 = 1;
        goto LABEL_413;
      }
    }
    else
    {
      uint64_t v116 = CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 104), v104);
      if (!v116)
      {
        CFStringRef v302 = mmcs_item_copy_description((uint64_t)v104);
        uint64_t v303 = mmcs_logging_logger_default();
        BOOL v304 = os_log_type_enabled(v303, OS_LOG_TYPE_ERROR);
        CFDataRef v195 = Mutable;
        if (v304)
        {
          CFStringRef v310 = CFStringCreateWithFormat(alloc, 0, @"C unable to find file state for item %@", v302);
          v311 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v311, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t valuePtr = 138543362;
            *(void *)&valuePtr[4] = v310;
            _os_log_impl(&dword_1DC1CA000, v311, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
          }
          if (v310) {
            CFRelease(v310);
          }
        }
        CFErrorRef v312 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"C unable to find file state for item %@", v305, v306, v307, v308, v309, (char)v302);
        goto LABEL_446;
      }
    }
    uint64_t v120 = v116;
    char theDicta = 1;
LABEL_206:
    if (*(void *)(v102 + 40))
    {
      unint64_t v124 = 0;
      while (1)
      {
        uint64_t v125 = *(void *)(*(void *)(v102 + 48) + 8 * v124);
        unint64_t v126 = *(void *)(v125 + 24);
        if (v126 >= CFArrayGetCount(*(CFArrayRef *)(v7 + 40))) {
          break;
        }
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 40), *(void *)(v125 + 24) + Count);
        uint64_t v128 = ValueAtIndex[11];
        unint64_t v129 = *(void *)(v125 + 32);
        if (v129 >= *(void *)(v128 + 56))
        {
          CFIndex v235 = mmcs_logging_logger_default();
          uint64_t v7 = (uint64_t)v338;
          uint64_t v5 = v327;
          CFDataRef v195 = Mutable;
          if (os_log_type_enabled(v235, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v241 = CFStringCreateWithFormat(alloc, 0, @"chunk index out of range");
            v242 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v242, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)uint64_t valuePtr = 138543362;
              *(void *)&valuePtr[4] = v241;
              _os_log_impl(&dword_1DC1CA000, v242, OS_LOG_TYPE_DEBUG, "%{public}@", valuePtr, 0xCu);
            }
            if (v241) {
              CFRelease(v241);
            }
          }
          CFErrorRef v230 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"chunk index %llu out of range %lu.", v236, v237, v238, v239, v240, *(void *)(v125 + 32));
LABEL_350:
          LOBYTE(v19) = 0;
          CFTypeRef v348 = v230;
          int v98 = 1;
LABEL_351:
          CFMutableDictionaryRef v10 = v333;
          goto LABEL_413;
        }
        CFStringRef v130 = ValueAtIndex;
        uint64_t v131 = *(void *)(v128 + 120);
        uint64_t container_container_index_for_message_index = mmcs_get_container_container_index_for_message_index((uint64_t)ValueAtIndex, v129);
        uint64_t v133 = container_container_index_for_message_index;
        if ((theDicta & 1) == 0)
        {
          appended = mmcs_item_append_chunk_instance((char **)v331, *(void *)(v131 + 104 * container_container_index_for_message_index + 56), (CFErrorRef *)&v348);
          if (!appended)
          {
            LOBYTE(v19) = 0;
            int v98 = 1;
            uint64_t v7 = (uint64_t)v338;
            uint64_t v5 = v327;
            CFDataRef v195 = Mutable;
            goto LABEL_351;
          }
          if ((v328 & 1) == 0) {
            mmcs_get_state_process_file_list_cold_5();
          }
          CFStringRef v135 = appended;
          CFDictionarySetValue(v333, appended, v120);
          unint64_t v136 = *(void *)(v125 + 24);
          if (v136 >= a2[3])
          {
            CFArrayRef v246 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v246, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t valuePtr = 0;
              _os_log_impl(&dword_1DC1CA000, v246, OS_LOG_TYPE_ERROR, "Processing file chunk references yielded container index beyond limit.", valuePtr, 2u);
            }
            v247 = @"Processing file chunk references yielded container index beyond limit.";
            goto LABEL_367;
          }
          unint64_t v137 = *(void *)(v125 + 32);
          uint64_t v138 = *(void *)(a2[4] + 8 * v136);
          if (v137 >= *(void *)(v138 + 64))
          {
            CFIndex v248 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v248, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t valuePtr = 0;
              _os_log_impl(&dword_1DC1CA000, v248, OS_LOG_TYPE_ERROR, "Processing file chunk references yielded chunk index beyond limit.", valuePtr, 2u);
            }
            v247 = @"Processing file chunk references yielded chunk index beyond limit.";
            goto LABEL_367;
          }
          uint64_t v139 = *(const void **)(*(void *)(*(void *)(v138 + 72) + 8 * v137) + 24);
          if (!v139)
          {
            CFIndex v249 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v249, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t valuePtr = 0;
              _os_log_impl(&dword_1DC1CA000, v249, OS_LOG_TYPE_ERROR, "Processing file chunk references failed to discover chunk_info.", valuePtr, 2u);
            }
            v247 = @"Processing file chunk references failed to discover chunk_info";
LABEL_367:
            LOBYTE(v19) = 0;
            CFTypeRef v348 = mmcs_cferror_create_error(@"com.apple.mmcs", 6, v247);
            int v98 = 1;
            uint64_t v7 = (uint64_t)v338;
            uint64_t v5 = v327;
            CFDataRef v195 = Mutable;
            CFMutableDictionaryRef v10 = v333;
            v250 = v334;
            goto LABEL_414;
          }
          CFDictionarySetValue(v334, v135, v139);
        }
        if (a3)
        {
          mmcs_get_state_associate_file_and_container((uint64_t)v338, v120, v130);
        }
        else
        {
          *(void *)uint64_t valuePtr = v338;
          *(void *)&valuePtr[8] = v130;
          mmcs_chunk_reference_apply_function_to_instances(*(void *)(v131 + 104 * v133 + 56), (void (__cdecl *)(const void *, void *))_associate_files_and_containers_for_items, valuePtr);
        }
        ++v124;
        uint64_t v7 = (uint64_t)v338;
        if (v124 >= *(void *)(v102 + 40)) {
          goto LABEL_221;
        }
      }
      CFStringRef v221 = mmcs_logging_logger_default();
      uint64_t v5 = v327;
      CFDataRef v195 = Mutable;
      if (os_log_type_enabled(v221, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v222 = CFStringCreateWithFormat(alloc, 0, @"container index out of range");
        uint64_t v223 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v223, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t valuePtr = 138543362;
          *(void *)&valuePtr[4] = v222;
          _os_log_impl(&dword_1DC1CA000, v223, OS_LOG_TYPE_DEBUG, "%{public}@", valuePtr, 0xCu);
        }
        if (v222) {
          CFRelease(v222);
        }
      }
      uint64_t v224 = *(void *)(v125 + 24);
      CFArrayGetCount(*(CFArrayRef *)(v7 + 40));
      CFErrorRef v230 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"container index %llu out of range %llu.", v225, v226, v227, v228, v229, v224);
      goto LABEL_350;
    }
LABEL_221:
    uint64_t v5 = v327;
    CFMutableDictionaryRef v10 = v333;
    CFAllocatorRef v9 = alloc;
    CFSetRef v97 = v324;
    if ((theDicta & 1) == 0) {
      ++*(void *)(v7 + 16);
    }
    goto LABEL_223;
  }
LABEL_224:
  if (!a3)
  {
    int v98 = 0;
    LOBYTE(v19) = 1;
    goto LABEL_312;
  }
  CFIndex v343 = CFArrayGetCount(*(CFArrayRef *)(v7 + 40));
  if (Count >= v343)
  {
LABEL_296:
    unint64_t v193 = *(void *)(v7 + 16);
    unint64_t v194 = v193 - v325;
    uint64_t v5 = v327;
    CFDataRef v195 = Mutable;
    CFMutableDictionaryRef v10 = v333;
    if (v193 > v325)
    {
      uint64_t v196 = v325 << 7;
      do
      {
        v197 = (void *)(*(void *)(v7 + 32) + v196);
        if (!*(unsigned char *)(v197[1] + 104))
        {
          mmcs_get_state_initialize_duplicate_file_states(v7, v197, (uint64_t *)&v348);
          if (v348) {
            goto LABEL_331;
          }
        }
        v196 += 128;
      }
      while (--v194);
    }
    if (!mmcs_get_state_setup_derivative_files_and_containers((CFMutableArrayRef *)v7, &v348)) {
      goto LABEL_331;
    }
    int v98 = 0;
    LOBYTE(v19) = 1;
    goto LABEL_413;
  }
  CFIndex v140 = Count;
  while (1)
  {
    CFDictionaryRef theDictb = (CFDictionaryRef)CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 40), v140);
    uint64_t v141 = *((void *)theDictb + 11);
    if (*(uint64_t *)(v141 + 48) >= 1) {
      break;
    }
LABEL_295:
    ++v140;
    uint64_t v7 = (uint64_t)v338;
    if (v140 == v343) {
      goto LABEL_296;
    }
  }
  uint64_t v142 = 0;
  uint64_t v143 = 0;
  while (1)
  {
    uint64_t v144 = *(void *)(v141 + 120);
    if (mmcs_chunk_instance_is_ford((_DWORD *)(v144 + v142))) {
      goto LABEL_230;
    }
    if (!mmcs_chunk_instance_is_chunk_reference((_DWORD *)(v144 + v142))) {
      mmcs_get_state_process_file_list_cold_1();
    }
    uint64_t v145 = v144 + v142;
    CFSetRef first_chunk_instance = mmcs_chunk_reference_get_first_chunk_instance(*(void *)(v144 + v142 + 56));
    if (!first_chunk_instance
      || (CFSetRef v147 = first_chunk_instance, !mmcs_chunk_instance_is_chunk_reference((_DWORD *)(v144 + v142))))
    {
      CFRange v163 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t valuePtr = 0;
        _os_log_impl(&dword_1DC1CA000, v163, OS_LOG_TYPE_DEBUG, "Container chunk instance not referenced by file.", valuePtr, 2u);
      }
      goto LABEL_230;
    }
    double v148 = CFDictionaryGetValue(v334, v147);
    if (!v148) {
      mmcs_get_state_process_file_list_cold_2();
    }
    CFStringRef v149 = v148;
    uint64_t v150 = *(void *)(v145 + 56);
    uint64_t v151 = *(void *)(v150 + 16);
    if (v148[10]) {
      break;
    }
    if (v151)
    {
LABEL_252:
      if (gMMCS_DebugLevel < 4) {
        goto LABEL_230;
      }
      __int16 v164 = mmcs_chunk_signature_to_hexstring(*(char **)(v150 + 8));
      v165 = *(char **)(*(void *)(v145 + 56) + 16);
      unint64_t v166 = CKChunkSchemeAndEncryptionKeySize();
      uint64_t v167 = mmcs_key_description_create_with_bytes(v165, v166, 1);
      uint64_t v168 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v168, OS_LOG_TYPE_DEBUG))
      {
        LOBYTE(v321) = (_BYTE)v167;
        CFStringRef v169 = CFStringCreateWithFormat(alloc, 0, @"Re-using existing key %@ for chunk %s");
        uint64_t v170 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v170, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t valuePtr = 138543362;
          *(void *)&valuePtr[4] = v169;
          _os_log_impl(&dword_1DC1CA000, v170, OS_LOG_TYPE_DEBUG, "%{public}@", valuePtr, 0xCu);
        }
        if (v169) {
          CFRelease(v169);
        }
      }
      if (v164) {
        free(v164);
      }
      if (!v167) {
        goto LABEL_230;
      }
      v171 = v167;
      goto LABEL_294;
    }
    if (**(char **)(v150 + 8) < 0)
    {
      unint64_t v172 = (const void **)CFDictionaryGetValue(v333, v147);
      if (!v172) {
        mmcs_get_state_process_file_list_cold_3();
      }
      unint64_t v173 = CFDictionaryGetValue(Mutable, v172[1]);
      if (!v173 || !v173[12])
      {
        CFTypeRef v348 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Encrypted chunk is not referenced by FORD or chunk encryption keys.", v174, v175, v176, v177, v178, v321);
        uint64_t v7 = (uint64_t)v338;
        uint64_t v5 = v327;
        CFDataRef v195 = Mutable;
        CFMutableDictionaryRef v10 = v333;
        goto LABEL_331;
      }
    }
LABEL_230:
    ++v143;
    v142 += 104;
    if (v143 >= *(void *)(v141 + 48)) {
      goto LABEL_295;
    }
  }
  if (v151) {
    goto LABEL_252;
  }
  double v152 = CFDictionaryGetValue(v333, v147);
  if (!v152)
  {
    uint64_t v270 = v144 + v142;
    uint64_t v271 = mmcs_chunk_signature_to_hexstring(*(char **)(*(void *)(v270 + 56) + 8));
    v272 = mmcs_logging_logger_default();
    uint64_t v7 = (uint64_t)v338;
    CFDataRef v195 = Mutable;
    if (os_log_type_enabled(v272, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v278 = CFStringCreateWithFormat(alloc, 0, @"File state not found for chunk with signature %s in container %s at index %llu of %llu. Chunk reference %p", v271, *(void *)(*((void *)theDictb + 11) + 16), v143, *(void *)(v141 + 48), *(void *)(v270 + 56));
      uint64_t v279 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v279, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t valuePtr = 138543362;
        *(void *)&valuePtr[4] = v278;
        _os_log_impl(&dword_1DC1CA000, v279, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
      }
      if (v278) {
        CFRelease(v278);
      }
    }
    CFTypeRef v348 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"File state not found for chunk with signature %s in container %s at index %llu of %llu. Chunk reference %p", v273, v274, v275, v276, v277, (char)v271);
    uint64_t v5 = v327;
    CFMutableDictionaryRef v10 = v333;
    if (v271) {
      free(v271);
    }
    goto LABEL_331;
  }
  CFStringRef v153 = v152;
  CFDataRef v154 = CFDataCreate(alloc, *((const UInt8 **)v149 + 7), *((void *)v149 + 6));
  if (!v154) {
    goto LABEL_230;
  }
  uint64_t v155 = v153[1];
  CFDataRef v336 = v154;
  if (*(void *)(v155 + 48))
  {
    CFDataRef v156 = *(const __CFData **)(v155 + 56);
    if (!v156) {
      mmcs_get_state_process_file_list_cold_4();
    }
    state.opaque[0] = 0;
    CFArrayRef Copy = mmcs_chunk_key_copy_wraptured_scheme_and_key(v154, v156, 0, (CFErrorRef *)&state);
    if (Copy)
    {
      if (gMMCS_DebugLevel >= 4)
      {
        CFStringRef v158 = mmcs_item_copy_description(v155);
        uint64_t v159 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v159, OS_LOG_TYPE_DEBUG))
        {
          LOBYTE(v321) = (_BYTE)v158;
          CFStringRef v160 = CFStringCreateWithFormat(alloc, 0, @"Unwrapped using item %@ ref %@");
          v161 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t valuePtr = 138543362;
            *(void *)&valuePtr[4] = v160;
            _os_log_impl(&dword_1DC1CA000, v161, OS_LOG_TYPE_DEBUG, "%{public}@", valuePtr, 0xCu);
          }
          if (v160)
          {
            CFStringRef v162 = v160;
            goto LABEL_274;
          }
        }
        goto LABEL_275;
      }
    }
    else if (gMMCS_DebugLevel >= 4)
    {
      CFStringRef v158 = mmcs_item_copy_description(v155);
      CFStringRef v179 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v179, OS_LOG_TYPE_DEBUG))
      {
        LOBYTE(v321) = (_BYTE)v158;
        CFStringRef v180 = CFStringCreateWithFormat(alloc, 0, @"Unable to unwrap using item %@ ref %@: %@");
        uint64_t v181 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v181, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t valuePtr = 138543362;
          *(void *)&valuePtr[4] = v180;
          _os_log_impl(&dword_1DC1CA000, v181, OS_LOG_TYPE_DEBUG, "%{public}@", valuePtr, 0xCu);
        }
        if (v180)
        {
          CFStringRef v162 = v180;
LABEL_274:
          CFRelease(v162);
        }
      }
LABEL_275:
      if (v158) {
        CFRelease(v158);
      }
    }
    if (state.opaque[0]) {
      CFRelease((CFTypeRef)state.opaque[0]);
    }
  }
  else
  {
    CFArrayRef Copy = CFDataCreateCopy(alloc, v154);
  }
  if (!Copy)
  {
LABEL_293:
    v171 = (__CFString *)v336;
LABEL_294:
    CFRelease(v171);
    goto LABEL_230;
  }
  int64_t Length = CFDataGetLength(Copy);
  if (Length >= 1)
  {
    CFIndex v183 = Length;
    CFStringRef v184 = (UInt8 *)malloc_type_malloc(Length, 0x31B55D3BuLL);
    v353.CFIndex location = 0;
    v353.unsigned int length = v183;
    CFDataGetBytes(Copy, v353, v184);
    if (((char)*v184 & 0x80000000) == 0 && CKChunkSchemeAndEncryptionKeySize() == v183)
    {
      CFRelease(Copy);
      uint64_t v185 = *(void *)(v145 + 56);
      *(void *)(v185 + 16) = v184;
      if (gMMCS_DebugLevel >= 4)
      {
        unint64_t v186 = mmcs_chunk_signature_to_hexstring(*(char **)(v185 + 8));
        uint64_t v187 = *(char **)(*(void *)(v145 + 56) + 16);
        unint64_t v188 = CKChunkSchemeAndEncryptionKeySize();
        uint64_t v189 = mmcs_key_description_create_with_bytes(v187, v188, 1);
        uint64_t v190 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v190, OS_LOG_TYPE_DEBUG))
        {
          LOBYTE(v321) = (_BYTE)v189;
          CFStringRef v191 = CFStringCreateWithFormat(alloc, 0, @"Unwrapped key %@ for chunk %s");
          v192 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v192, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)uint64_t valuePtr = 138543362;
            *(void *)&valuePtr[4] = v191;
            _os_log_impl(&dword_1DC1CA000, v192, OS_LOG_TYPE_DEBUG, "%{public}@", valuePtr, 0xCu);
          }
          if (v191) {
            CFRelease(v191);
          }
        }
        if (v186) {
          free(v186);
        }
        if (v189) {
          CFRelease(v189);
        }
      }
      goto LABEL_293;
    }
  }
  CFStringRef v302 = mmcs_key_description_create_with_cfdata(Copy, 1);
  CFRelease(Copy);
  CFTypeRef v348 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"wrapped encryption key %@ once unwrapped is not valid: %@", v260, v261, v262, v263, v264, (char)v336);
  uint64_t v7 = (uint64_t)v338;
  uint64_t v5 = v327;
  CFDataRef v195 = Mutable;
  CFMutableDictionaryRef v10 = v333;
  if (v302) {
    goto LABEL_447;
  }
LABEL_331:
  LOBYTE(v19) = 0;
LABEL_412:
  int v98 = 1;
LABEL_413:
  v250 = v334;
  if (v334) {
LABEL_414:
  }
    CFRelease(v250);
  if (v10) {
    CFRelease(v10);
  }
  if (v195) {
    CFRelease(v195);
  }
  if (value) {
    C3BaseRelease(value);
  }
  long long value = 0;
  ProtobufCBinaryData_SetCopyBufferLen(v349, 0, 0);
  if (v98)
  {
    v297 = v348;
    if (!v348)
    {
      v297 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Unspecified error in mmcs_get_state_process_file_list", v292, v293, v294, v295, v296, v321);
      CFTypeRef v348 = v297;
    }
    if (v5)
    {
      CFRetain(v297);
      CFTypeRef *v5 = v348;
    }
    CFIndex v298 = CFArrayGetCount(*(CFArrayRef *)(v7 + 40));
    if (Count < v298)
    {
      CFIndex v299 = v298;
      do
      {
        v300 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 40), Count);
        if (!v300[5]) {
          mmcs_container_set_error(v300, v348);
        }
        ++Count;
      }
      while (v299 != Count);
    }
  }
  if (v348) {
    CFRelease(v348);
  }
  return v19;
}

void mmcs_get_state_associate_file_and_container(uint64_t a1, const void *a2, void *key)
{
  CFSetRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), key);
  if (!Value)
  {
    CFSetCallBacks v8 = *(CFSetCallBacks *)byte_1F363C960;
    CFSetRef Value = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &v8);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), key, Value);
    if (Value) {
      CFRelease(Value);
    }
  }
  CFSetAddValue((CFMutableSetRef)Value, a2);
  uint64_t v7 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!v7)
  {
    CFSetCallBacks v8 = *(CFSetCallBacks *)byte_1F363C990;
    uint64_t v7 = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &v8);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 80), a2, v7);
    if (v7) {
      CFRelease(v7);
    }
  }
  CFSetAddValue((CFMutableSetRef)v7, key);
}

void _associate_files_and_containers_for_items(uint64_t a1, uint64_t **a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  CFRange v2 = *a2;
  uint64_t v3 = **a2;
  if (!v3) {
    _associate_files_and_containers_for_items_cold_1();
  }
  uint64_t v4 = *(const void **)(a1 + 8);
  if (!v4) {
    _associate_files_and_containers_for_items_cold_2();
  }
  uint64_t v5 = *(void *)(v3 + 304);
  if (!*(void *)(v5 + 88)) {
    _associate_files_and_containers_for_items_cold_3();
  }
  CFSetRef v6 = *(const __CFSet **)(v5 + 96);
  if (!v6) {
    _associate_files_and_containers_for_items_cold_4();
  }
  if (!CFSetContainsValue(v6, v4))
  {
    CFMutableDictionaryRef v10 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"this item not participating in getChunks");
    unint64_t v12 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    int v14 = 138543362;
    CFStringRef v15 = v11;
    goto LABEL_16;
  }
  CFSetRef Value = CFDictionaryGetValue((CFDictionaryRef)v2[13], v4);
  if (Value)
  {
    CFAllocatorRef v9 = a2[1];
    mmcs_get_state_associate_file_and_container((uint64_t)v2, Value, v9);
    return;
  }
  CFStringRef v13 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
    return;
  }
  CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"expected to find a file for the item");
  unint64_t v12 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    int v14 = 138543362;
    CFStringRef v15 = v11;
LABEL_16:
    _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v14, 0xCu);
  }
LABEL_17:
  if (v11) {
    CFRelease(v11);
  }
}

uint64_t mmcs_get_state_initialize_duplicate_file_states(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = (void *)a2[1];
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(*(void *)a1 + 304) + 64), v5);
  if (CFArrayGetCount(Value) < 1)
  {
LABEL_14:
    uint64_t result = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    if (result >= 1)
    {
      for (CFIndex i = 0; i < result; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), i);
        uint64_t v20 = *(const void **)(ValueAtIndex[11] + 184);
        if (v20)
        {
          CFRelease(v20);
          *(void *)(ValueAtIndex[11] + 184) = 0;
        }
        uint64_t result = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
      }
    }
    return result;
  }
  CFIndex v7 = 0;
  while (1)
  {
    CFSetCallBacks v8 = (unsigned char **)CFArrayGetValueAtIndex(Value, v7);
    if (v8 == v5) {
      goto LABEL_13;
    }
    unint64_t v9 = *(void *)(a1 + 16);
    if (v9 >= *(void *)(a1 + 8)) {
      break;
    }
    CFMutableDictionaryRef v10 = v8;
    uint64_t v11 = *(void *)(a1 + 32);
    *(void *)(a1 + 16) = v9 + 1;
    char req_context_use_registry = mmcs_get_req_context_use_registry(v4);
    if ((**v10 & 0x7F) == 4) {
      should_validate_file_content_for_CFRange v2 = mmcs_get_req_context_should_validate_file_content_for_v2(v4);
    }
    else {
      should_validate_file_content_for_CFRange v2 = mmcs_get_req_context_should_validate_file_content_for_v1(v4);
    }
    char v14 = should_validate_file_content_for_v2;
    CFStringRef v15 = (const void *)(v11 + (v9 << 7));
    if (mmcs_item_is_derivative((uint64_t)v10)) {
      char v16 = 0;
    }
    else {
      char v16 = req_context_use_registry;
    }
    mmcs_get_file_init((uint64_t)v15, *(void *)(*(void *)(v4 + 304) + 112), (uint64_t)v10, v16, v14);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), v10, v15);
    if (!mmcs_item_copy_chunk_instances_from_item((uint64_t)v10, (uint64_t)v5))
    {
      uint64_t v30 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v31 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unable to copy chunk instances from item %lld to %lld", v10[5], v5[5]);
        int v32 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v37 = v31;
          _os_log_impl(&dword_1DC1CA000, v32, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v31) {
          CFRelease(v31);
        }
      }
      uint64_t v33 = v10[5];
      CFStringRef v29 = @"unable to copy chunk instances from item %lld to %lld";
      goto LABEL_32;
    }
    mmcs_get_state_associate_duplicate_file_and_containers_for_file(a1, (uint64_t)v15, a2);
LABEL_13:
    if (++v7 >= CFArrayGetCount(Value)) {
      goto LABEL_14;
    }
  }
  CFStringRef v21 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v27 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"duplicate mmcs_get_file overflow");
    double v28 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v37 = v27;
      _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v27) {
      CFRelease(v27);
    }
  }
  CFStringRef v29 = @"duplicate mmcs_get_file overflow";
LABEL_32:
  uint64_t result = (uint64_t)mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, v29, v22, v23, v24, v25, v26, (char)v33);
  *a3 = result;
  return result;
}

uint64_t mmcs_get_state_setup_derivative_files_and_containers(CFMutableArrayRef *a1, CFTypeRef *a2)
{
  uint64_t v2 = (uint64_t)*a1;
  CFTypeRef cf = 0;
  if (!a1[2]) {
    return 1;
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  while (1)
  {
    CFSetCallBacks v8 = (void *)((char *)a1[4] + v5);
    uint64_t v9 = v8[1];
    if (mmcs_item_is_derivative(v9)) {
      break;
    }
LABEL_13:
    ++v6;
    v5 += 128;
    if (v6 >= (unint64_t)a1[2])
    {
      uint64_t v24 = 1;
      CFErrorRef error = cf;
      if (!cf) {
        return v24;
      }
      goto LABEL_25;
    }
  }
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(a1[10], v8);
  if (Value)
  {
    CFSetRef Copy = CFSetCreateCopy(v7, Value);
    if (!Copy) {
      mmcs_get_state_setup_derivative_files_and_containers_cold_1();
    }
    CFSetRef v12 = Copy;
    context[0] = a1;
    context[1] = v8;
    CFSetApplyFunction(Copy, (CFSetApplierFunction)_disassociate_chunk_container_applier, context);
    CFRelease(v12);
  }
  if (mmcs_get_req_context_use_reader_writer_callback(v2)
    || mmcs_get_file_init_temp_file((uint64_t)v8, &cf))
  {
    context[0] = 0;
    if (mmcs_get_derivative_container_create(context, v9, 1, (uint64_t *)a1))
    {
      http_request_options = (const void *)mmcs_request_get_http_request_options(v2);
      if (mmcs_http_request_create_with_url((CFTypeRef *)(*((void *)context[0] + 2) + 24), *(const __CFURL **)(v9 + 360), http_request_options, (CFErrorRef *)&cf))
      {
        CFArrayAppendValue(a1[5], context[0]);
        CFArrayAppendValue(a1[8], context[0]);
        mmcs_get_state_associate_file_and_container((uint64_t)a1, v8, context[0]);
        if (context[0]) {
          C3BaseRelease(context[0]);
        }
        goto LABEL_13;
      }
      CFErrorRef error = cf;
      if (cf) {
        goto LABEL_23;
      }
LABEL_21:
      CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Unspecified error in mmcs_get_state_setup_derivative_files_and_containers", v19, v20, v21, v22, v23, v27);
      CFTypeRef cf = error;
      goto LABEL_23;
    }
    CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"mmcs_get_derivative_container_create", v13, v14, v15, v16, v17, v27);
LABEL_18:
    CFTypeRef cf = error;
    if (error) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }
  CFErrorRef error = cf;
  if (!cf)
  {
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 1, @"An unknown error creating temp file.");
    goto LABEL_18;
  }
LABEL_23:
  if (a2)
  {
    CFRetain(error);
    uint64_t v24 = 0;
    CFErrorRef error = cf;
    *a2 = cf;
    if (!error) {
      return v24;
    }
    goto LABEL_25;
  }
  uint64_t v24 = 0;
  if (error) {
LABEL_25:
  }
    CFRelease(error);
  return v24;
}

void mmcs_get_state_associate_duplicate_file_and_containers_for_file(uint64_t a1, uint64_t a2, void *key)
{
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), key);
  if (Value)
  {
    v6[0] = a1;
    v6[1] = a2;
    CFSetApplyFunction(Value, (CFSetApplierFunction)_associate_container_applier, v6);
  }
}

void _associate_container_applier(void *key, uint64_t *a2)
{
  uint64_t v4 = (void *)a2[1];
  uint64_t v5 = (void *)v4[1];
  if (!v5[50])
  {
LABEL_13:
    uint64_t v12 = *a2;
    mmcs_get_state_associate_file_and_container(v12, v4, key);
    return;
  }
  CFMutableArrayRef Mutable = *(__CFSet **)(*((void *)key + 11) + 184);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &chunkReferenceSignatureEqualitySetCallbacks);
    CFAllocatorRef v7 = (void *)*((void *)key + 11);
    if (v7[6])
    {
      unint64_t v8 = 0;
      uint64_t v9 = 56;
      do
      {
        CFSetAddValue(Mutable, *(const void **)(v7[15] + v9));
        ++v8;
        CFAllocatorRef v7 = (void *)*((void *)key + 11);
        v9 += 104;
      }
      while (v8 < v7[6]);
    }
    v7[23] = Mutable;
  }
  if (v5[19])
  {
    uint64_t v10 = 0;
    for (uint64_t i = 56; !CFSetContainsValue(Mutable, *(const void **)(v5[34] + i)); i += 104)
    {
      if ((unint64_t)++v10 >= v5[19]) {
        return;
      }
    }
    uint64_t v4 = (void *)a2[1];
    goto LABEL_13;
  }
}

uint64_t mmcs_get_state_process_container_data(uint64_t a1, uint64_t a2)
{
  return mmcs_container_process_data(*(void *)(a2 + 64));
}

void mmcs_get_state_process_derivative_data(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 a6, uint64_t a7)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), a2);
  if (Value)
  {
    *(void *)&long long v17 = a2;
    *((void *)&v17 + 1) = a3;
    uint64_t v18 = a4;
    uint64_t v19 = a5;
    uint64_t v21 = a7;
    uint64_t v20 = a6;
    CFSetApplyFunction(Value, (CFSetApplierFunction)mmcs_get_state_process_derivative_container_data_for_file_state, &v17);
  }
  else
  {
    uint64_t v14 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"processing container data with no file states");
      uint64_t v16 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v17) = 138543362;
        *(void *)((char *)&v17 + 4) = v15;
        _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v17, 0xCu);
      }
      if (v15) {
        CFRelease(v15);
      }
    }
  }
}

void mmcs_get_state_process_derivative_container_data_for_file_state(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 115))
  {
    CFTypeRef cf = 0;
    if (!mmcs_get_file_process_derivative_buffer(a1, *(void *)(a2 + 8), *(void *)(a2 + 16), *(void *)(a2 + 24), *(unsigned __int8 *)(a2 + 32), *(const void **)(a2 + 40), &cf))
    {
      unint64_t v8 = cf;
      if (!cf)
      {
        unint64_t v8 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 33, @"The item failed for an unspecified reason.", v3, v4, v5, v6, v7, v9);
        CFTypeRef cf = v8;
      }
      mmcs_get_file_completed_with_error(a1, (uint64_t)v8);
      if (cf) {
        CFRelease(cf);
      }
    }
  }
}

void mmcs_get_state_process_chunk_with_padding(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), a2);
  if (Value)
  {
    *(void *)&long long v15 = a2;
    *((void *)&v15 + 1) = a3;
    uint64_t v16 = a4;
    uint64_t v17 = a5;
    uint64_t v18 = a6;
    CFSetApplyFunction(Value, (CFSetApplierFunction)mmcs_get_state_process_container_data_for_file_state, &v15);
  }
  else
  {
    uint64_t v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"processing container data with no file states");
      uint64_t v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v15) = 138543362;
        *(void *)((char *)&v15 + 4) = v13;
        _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v15, 0xCu);
      }
      if (v13) {
        CFRelease(v13);
      }
    }
  }
}

void mmcs_get_state_process_container_data_for_file_state(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 115))
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (!mmcs_item_is_derivative(v4) && !mmcs_item_is_metadata_only(v4))
    {
      CFTypeRef cf = 0;
      if (mmcs_get_file_process_chunk_reference_with_padding(a1, *(void *)(a2 + 8), *(void *)(a2 + 16), *(void *)(a2 + 24), *(void *)(a2 + 32), &cf))
      {
        if (!mmcs_item_has_outstanding_chunk_references(v4)) {
          mmcs_get_file_candidate_completed_with_success(a1);
        }
      }
      else
      {
        uint64_t v10 = cf;
        if (!cf)
        {
          uint64_t v10 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 33, @"The item failed for an unspecified reason.", v5, v6, v7, v8, v9, v11);
          CFTypeRef cf = v10;
        }
        mmcs_get_file_completed_with_error(a1, (uint64_t)v10);
        if (cf) {
          CFRelease(cf);
        }
      }
    }
  }
}

void mmcs_get_state_unprocess_chunk_data(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), a2);
  if (Value)
  {
    *(void *)&long long v11 = a2;
    *((void *)&v11 + 1) = a3;
    uint64_t v12 = a4;
    CFSetApplyFunction(Value, (CFSetApplierFunction)mmcs_get_state_unprocess_container_data_for_file_state, &v11);
  }
  else
  {
    uint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unprocessing container data with no file states");
      uint64_t v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v11) = 138543362;
        *(void *)((char *)&v11 + 4) = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v11, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
  }
}

void mmcs_get_state_unprocess_container_data_for_file_state(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 115) && !mmcs_item_is_derivative(*(void *)(a1 + 8)))
  {
    uint64_t v4 = *(void **)(a2 + 8);
    uint64_t v5 = *(void *)(a2 + 16);
    mmcs_get_file_unprocess_chunk_reference(a1, v4, v5);
  }
}

CFSetRef mmcs_get_state_has_files_which_still_needs_container(uint64_t a1, const void *a2)
{
  CFSetRef result = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), a2);
  unsigned __int8 context = 0;
  if (result)
  {
    CFSetApplyFunction(result, (CFSetApplierFunction)mmcs_get_file_which_still_needs_container, &context);
    return (const __CFSet *)context;
  }
  return result;
}

uint64_t mmcs_get_file_which_still_needs_container(uint64_t result, unsigned char *a2)
{
  if (*(unsigned char *)(result + 115))
  {
    BOOL v3 = 0;
  }
  else
  {
    CFSetRef result = mmcs_item_is_derivative(*(void *)(result + 8));
    BOOL v3 = result == 0;
  }
  *a2 |= v3;
  return result;
}

CFSetRef mmcs_get_state_copy_file_states_for_container(uint64_t a1, const void *a2)
{
  CFSetRef result = (CFSetRef)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), a2);
  if (result)
  {
    CFSetRef v3 = result;
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    return CFSetCreateCopy(v4, v3);
  }
  return result;
}

void mmcs_get_state_fail_file_state(uint64_t a1, uint64_t a2)
{
  uint64_t buf[3] = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = *(__CFError **)(a2 + 40);
  if (v4)
  {
    CFErrorDomain Domain = CFErrorGetDomain(v4);
    if (CFEqual(@"com.apple.mmcs", Domain))
    {
      if (CFErrorGetCode(*(CFErrorRef *)(a2 + 40)) == 16)
      {
        uint64_t v6 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"get file failed, returning container error");
          uint64_t v8 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf[0]) = 138543362;
            *(void *)((char *)buf + 4) = v7;
            _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)buf, 0xCu);
          }
          if (v7) {
            CFRelease(v7);
          }
        }
        mmcs_get_file_completed_with_error(a1, *(void *)(a2 + 40));
        return;
      }
    }
  }
  CFStringRef v9 = *(__CFError **)(a2 + 56);
  if (v9)
  {
    CFErrorDomain v10 = CFErrorGetDomain(v9);
    if (CFEqual(@"com.apple.mmcs", v10)
      && CFErrorGetCode(*(CFErrorRef *)(a2 + 56)) == 7
      && (CFDictionaryRef v11 = CFErrorCopyUserInfo(*(CFErrorRef *)(a2 + 56))) != 0)
    {
      CFDictionaryRef v12 = v11;
      CFSetRef Value = (__CFError *)CFDictionaryGetValue(v11, (const void *)*MEMORY[0x1E4F1D190]);
      if (Value
        && (uint64_t v14 = Value, v15 = CFGetTypeID(Value), v15 == CFErrorGetTypeID())
        && (CFErrorDomain v16 = CFErrorGetDomain(v14), CFEqual(@"apple.mme", v16)))
      {
        if (CFErrorGetCode(v14) == 13) {
          CFIndex v17 = 8;
        }
        else {
          CFIndex v17 = 23;
        }
      }
      else
      {
        CFIndex v17 = 23;
      }
      CFRelease(v12);
    }
    else
    {
      CFIndex v17 = 23;
    }
    uint64_t v18 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"get file failed, vendor request failed.");
      uint64_t v20 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf[0]) = 138543362;
        *(void *)((char *)buf + 4) = v19;
        _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)buf, 0xCu);
      }
      if (v19) {
        CFRelease(v19);
      }
    }
    *(_OWORD *)long long buf = 0uLL;
    uint64_t v21 = *(void *)(a2 + 40);
    if (v21)
    {
      buf[0] = *(void *)(a2 + 40);
      LODWORD(v21) = 1;
    }
    buf[v21] = *(void *)(a2 + 56);
    CFArrayRef v22 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)buf, (v21 + 1), MEMORY[0x1E4F1D510]);
    CFErrorRef error_with_underlying_errors = mmcs_cferror_create_error_with_underlying_errors(@"com.apple.mmcs", v17, @"Vendor request failed", v22, 0);
    if (v22) {
      CFRelease(v22);
    }
LABEL_40:
    mmcs_get_file_completed_with_error(a1, (uint64_t)error_with_underlying_errors);
    if (!error_with_underlying_errors) {
      return;
    }
    CFErrorRef v40 = error_with_underlying_errors;
    goto LABEL_59;
  }
  error_with_underlying_CFErrorRef error = *(CFErrorRef *)(a2 + 40);
  if (!error_with_underlying_error)
  {
    int v32 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      char v52 = a2;
      CFStringRef v38 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"get file failed: container %p has no error");
      unint64_t v39 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 138543362;
        *(void *)((char *)buf + 4) = v38;
        _os_log_impl(&dword_1DC1CA000, v39, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)buf, 0xCu);
      }
      if (v38) {
        CFRelease(v38);
      }
    }
    CFErrorRef error_with_underlying_errors = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Get failed", v33, v34, v35, v36, v37, v52);
    goto LABEL_40;
  }
  CFErrorDomain v25 = CFErrorGetDomain(*(CFErrorRef *)(a2 + 40));
  if (!CFEqual(@"com.apple.mmcs", v25)) {
    goto LABEL_51;
  }
  CFIndex Code = CFErrorGetCode(*(CFErrorRef *)(a2 + 40));
  if ((unint64_t)(Code - 42) < 5)
  {
    error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 11, *(void **)(a2 + 40), @"FORD data malformed.", v27, v28, v29, v30, v52);
    CFNumberRef v31 = error_with_underlying_error;
    goto LABEL_52;
  }
  if (Code == 6 && (CFDictionaryRef v41 = CFErrorCopyUserInfo(*(CFErrorRef *)(a2 + 40))) != 0)
  {
    CFDictionaryRef v42 = v41;
    CFNumberRef v31 = (const __CFNumber *)CFDictionaryGetValue(v41, @"kMMCSErrorHTTPStatusKey");
    if (v31)
    {
      CFTypeID TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(v31))
      {
        buf[0] = 0;
        int v44 = CFNumberGetValue(v31, kCFNumberCFIndexType, buf);
        CFNumberRef v31 = 0;
        if (v44 && buf[0] == 404)
        {
          error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 8, *(void **)(a2 + 40), @"Vendor request failed", v45, v46, v47, v48, v52);
          CFNumberRef v31 = error_with_underlying_error;
        }
      }
      else
      {
        CFNumberRef v31 = 0;
      }
    }
    CFRelease(v42);
  }
  else
  {
LABEL_51:
    CFNumberRef v31 = 0;
  }
LABEL_52:
  CFStringRef v49 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v50 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"get file failed, returning container error");
    CFStringRef v51 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf[0]) = 138543362;
      *(void *)((char *)buf + 4) = v50;
      _os_log_impl(&dword_1DC1CA000, v51, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)buf, 0xCu);
    }
    if (v50) {
      CFRelease(v50);
    }
  }
  mmcs_get_file_completed_with_error(a1, (uint64_t)error_with_underlying_error);
  if (v31)
  {
    CFErrorRef v40 = v31;
LABEL_59:
    CFRelease(v40);
  }
}

void mmcs_get_state_fail_container(CFDictionaryRef *a1, void *a2)
{
  if (!*(unsigned char *)(*((void *)*a1 + 38) + 41))
  {
    CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(a1[9], a2);
    if (Value) {
      CFSetApplyFunction(Value, (CFSetApplierFunction)mmcs_get_state_fail_file_state, a2);
    }
    *(unsigned char *)(a2[11] + 80) = 1;
  }
}

void mmcs_get_state_container_fail_deferred_files(CFArrayRef *a1)
{
  if (*(unsigned char *)(*((void *)*a1 + 38) + 41))
  {
    CFIndex Count = CFArrayGetCount(a1[5]);
    if (Count >= 1)
    {
      CFIndex v3 = Count;
      CFIndex v4 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1[5], v4);
        uint64_t v6 = ValueAtIndex;
        int v7 = *((_DWORD *)ValueAtIndex + 16);
        if (v7 == 3) {
          break;
        }
        if (v7 == 2)
        {
          uint64_t v8 = *((void *)ValueAtIndex + 11);
          if ((*((void *)ValueAtIndex + 5) || *((void *)ValueAtIndex + 7)) && !*(unsigned char *)(v8 + 80))
          {
            CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(a1[9], ValueAtIndex);
            if (Value) {
              CFSetApplyFunction(Value, (CFSetApplierFunction)mmcs_get_state_fail_file_state, v6);
            }
          }
          CFErrorDomain v10 = (unsigned char *)(v8 + 80);
LABEL_18:
          unsigned char *v10 = 1;
        }
        if (v3 == ++v4) {
          return;
        }
      }
      uint64_t v11 = *((void *)ValueAtIndex + 11);
      if ((*((void *)ValueAtIndex + 5) || *((void *)ValueAtIndex + 7)) && !*(unsigned char *)(v11 + 16))
      {
        CFSetRef v12 = (const __CFSet *)CFDictionaryGetValue(a1[9], ValueAtIndex);
        if (v12) {
          CFSetApplyFunction(v12, (CFSetApplierFunction)mmcs_get_state_fail_file_state, v6);
        }
      }
      CFErrorDomain v10 = (unsigned char *)(v11 + 16);
      goto LABEL_18;
    }
  }
}

void mmcs_get_state_fail_deriviative_container(uint64_t a1, void *a2)
{
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), a2);
  if (Value)
  {
    CFSetApplyFunction(Value, (CFSetApplierFunction)mmcs_get_state_fail_derivative_file_state, a2);
  }
}

void mmcs_get_state_fail_derivative_file_state(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 40);
  uint64_t v5 = mmcs_logging_logger_default();
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"get file failed, returning container error");
      int v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v18 = v6;
        _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v6) {
        CFRelease(v6);
      }
    }
    mmcs_get_file_completed_with_error(a1, *(void *)(a2 + 40));
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      char v16 = a2;
      CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"get file failed: container %p has no error");
      uint64_t v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v18 = v13;
        _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v13) {
        CFRelease(v13);
      }
    }
    CFErrorRef v15 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Get failed", v8, v9, v10, v11, v12, v16);
    mmcs_get_file_completed_with_error(a1, (uint64_t)v15);
    if (v15) {
      CFRelease(v15);
    }
  }
}

void mmcs_get_state_process_storage_container_error_list(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    unint64_t v39 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v40 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Malformed getComplete response body");
      CFDictionaryRef v41 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v46 = v40;
        _os_log_impl(&dword_1DC1CA000, v41, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v40) {
        CFRelease(v40);
      }
    }
    return;
  }
  uint64_t v2 = a2;
  if (!*(void *)(a2 + 24)) {
    return;
  }
  unint64_t v4 = 0;
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    uint64_t v5 = *(void **)(*(void *)(v2 + 32) + 8 * v4);
    CFStringRef v6 = (const char *)v5[3];
    int v7 = (const char *)v5[5];
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    if (Count < 1) {
      goto LABEL_42;
    }
    CFIndex v9 = Count;
    uint64_t v43 = v5;
    uint64_t v10 = 1;
    do
    {
      CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), v10 - 1);
      CFErrorRef v15 = 0;
      if (!v6) {
        goto LABEL_10;
      }
      char v16 = ValueAtIndex;
      if (LODWORD(ValueAtIndex[2].isa) == 3) {
        goto LABEL_10;
      }
      if (strcmp(*(const char **)(ValueAtIndex[2].length + 16), v6)) {
        goto LABEL_9;
      }
      if (!v7)
      {
        uint64_t v23 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          goto LABEL_9;
        }
        CFStringRef v19 = CFStringCreateWithFormat(alloc, 0, @"Expected byte-range field in protobuf message");
        uint64_t v24 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          goto LABEL_28;
        }
        goto LABEL_34;
      }
      int v17 = strncmp("bytes=", v7, 6uLL);
      CFStringRef v18 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(*((void *)v16->data + 3) + 16), @"Range");
      if (!v18)
      {
        CFErrorDomain v25 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
LABEL_9:
          CFErrorRef v15 = 0;
          goto LABEL_10;
        }
        CFStringRef v19 = CFStringCreateWithFormat(alloc, 0, @"Get container http message missing byte-range header");
        uint64_t v24 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
LABEL_28:
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v46 = v19;
          _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
LABEL_34:
        CFErrorRef v15 = 0;
        goto LABEL_35;
      }
      CFStringRef v19 = v18;
      if (v17 && CFStringHasPrefix(v18, @"bytes="))
      {
        v48.unsigned int length = CFStringGetLength(v19) - 6;
        v48.CFIndex location = 6;
        CFStringRef v20 = CFStringCreateWithSubstring(alloc, v19, v48);
        CFRelease(v19);
        CFStringRef v19 = v20;
      }
      CStringWithCFCFStringRef String = createCStringWithCFString(v19);
      if (!CStringWithCFString)
      {
        uint64_t v26 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          CFErrorRef v15 = (__CFString *)CFStringCreateWithFormat(alloc, 0, @"Couldn't create string");
          uint64_t v27 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v46 = v15;
            _os_log_impl(&dword_1DC1CA000, v27, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (!v15) {
            goto LABEL_35;
          }
          CFRelease(v15);
        }
        goto LABEL_34;
      }
      CFArrayRef v22 = CStringWithCFString;
      if (!strcmp((const char *)CStringWithCFString, v7)) {
        CFErrorRef v15 = v16;
      }
      else {
        CFErrorRef v15 = 0;
      }
      free(v22);
LABEL_35:
      if (v19) {
        CFRelease(v19);
      }
LABEL_10:
      if (v10 >= v9) {
        break;
      }
      ++v10;
    }
    while (!v15);
    uint64_t v2 = a2;
    uint64_t v5 = v43;
    if (v15)
    {
      uint64_t v28 = (__CFError *)v43[4];
      if (v28)
      {
        uint64_t v29 = (const char *)v43[3];
        if (!v29) {
          uint64_t v29 = "(null)";
        }
        CFErrorRef error_with_error_response_and_format = (__CFString *)mmcs_cferror_create_error_with_error_response_and_format(1, 0, 7, v28, @"The server returned a container error for container %s byte range %s", v12, v13, v14, (char)v29);
        mmcs_container_set_complete_error(v15, error_with_error_response_and_format);
        CFNumberRef v31 = mmcs_logging_logger_default();
        XCFPrint(v31, @"ContainerCompleteIssue", error_with_error_response_and_format);
        goto LABEL_49;
      }
      uint64_t v36 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        uint64_t v37 = (const char *)v43[3];
        if (!v37) {
          uint64_t v37 = "(null)";
        }
        CFStringRef v38 = (const char *)v43[5];
        if (!v38) {
          CFStringRef v38 = "(null)";
        }
        CFErrorRef error_with_error_response_and_format = (__CFString *)CFStringCreateWithFormat(alloc, 0, @"no error for storage container with key %s byte range %s", v37, v38);
        uint64_t v35 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
LABEL_48:
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v46 = error_with_error_response_and_format;
          _os_log_impl(&dword_1DC1CA000, v35, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
LABEL_49:
        if (error_with_error_response_and_format) {
          CFRelease(error_with_error_response_and_format);
        }
      }
      goto LABEL_51;
    }
LABEL_42:
    int v32 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      uint64_t v33 = (const char *)v5[3];
      if (!v33) {
        uint64_t v33 = "(null)";
      }
      uint64_t v34 = (const char *)v5[5];
      if (!v34) {
        uint64_t v34 = "(null)";
      }
      CFErrorRef error_with_error_response_and_format = (__CFString *)CFStringCreateWithFormat(alloc, 0, @"no storage container matching key %s byte range %s", v33, v34);
      uint64_t v35 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        goto LABEL_48;
      }
      goto LABEL_49;
    }
LABEL_51:
    ++v4;
  }
  while (v4 < *(void *)(v2 + 24));
}

uint64_t mmcs_get_state_has_outstanding_async_transactions(CFArrayRef *a1)
{
  CFIndex Count = CFArrayGetCount(a1[5]);
  if (Count < 1) {
    goto LABEL_6;
  }
  CFIndex v3 = Count;
  uint64_t v4 = 1;
  do
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1[5], v4 - 1);
    uint64_t result = mmcs_container_request_enqueued_or_inflight((uint64_t)ValueAtIndex);
    if (v4 >= v3) {
      break;
    }
    ++v4;
  }
  while (!result);
  if (!result)
  {
LABEL_6:
    return mmcs_get_state_has_outstanding_http_transactions(a1);
  }
  return result;
}

uint64_t mmcs_get_state_has_outstanding_http_transactions(CFArrayRef *a1)
{
  CFIndex Count = CFArrayGetCount(a1[5]);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    uint64_t v4 = 1;
    do
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1[5], v4 - 1);
      uint64_t v6 = *(void *)(ValueAtIndex[2] + 16);
      if (v6) {
        BOOL is_sending = mmcs_http_context_is_sending(v6);
      }
      else {
        BOOL is_sending = 0;
      }
      uint64_t v8 = ValueAtIndex[3];
      if (v8)
      {
        uint64_t v9 = *(void *)(v8 + 16);
        if (v9) {
          LODWORD(v8) = mmcs_http_context_is_sending(v9);
        }
        else {
          LODWORD(v8) = 0;
        }
      }
      int v10 = is_sending | v8;
      if (v4 >= v3) {
        break;
      }
      ++v4;
    }
    while (!v10);
    if (v10) {
      return 1;
    }
  }
  uint64_t result = *(void *)(*((void *)*a1 + 38) + 136);
  if (result) {
    return mmcs_http_context_is_sending(result);
  }
  return result;
}

void file_skip_container_and_get_chunks(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 88);
  CFMutableArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &chunkReferenceSignatureEqualitySetCallbacks);
  if (*(void *)(v3 + 48))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(v3 + 120) + v5;
      if (!mmcs_chunk_instance_is_chunk_reference((_DWORD *)v7)) {
        file_skip_container_and_get_chunks_cold_1();
      }
      if (CFSetContainsValue(*(CFSetRef *)(*(void *)(a1 + 8) + 280), *(const void **)(v7 + 56))) {
        CFSetSetValue(Mutable, *(const void **)(v7 + 56));
      }
      ++v6;
      v5 += 104;
    }
    while (v6 < *(void *)(v3 + 48));
  }
  if (CFSetGetCount(Mutable) >= 1)
  {
    mmcs_get_req_add_item_for_get_chunks(**(void **)a1, *(void **)(a1 + 8));
    uint64_t v8 = *(void *)(a1 + 8);
    if (!*(void *)(v8 + 288))
    {
      mmcs_item_set_get_chunk_references(v8, Mutable);
      if (!Mutable) {
        return;
      }
      goto LABEL_11;
    }
    mmcs_item_add_get_chunk_references(v8, Mutable);
  }
  if (!Mutable) {
    return;
  }
LABEL_11:
  CFRelease(Mutable);
}

void _disassociate_chunk_container_applier(void *key, void *a2)
{
  if (key && *((_DWORD *)key + 16) == 2 && *(_DWORD *)(*((void *)key + 11) + 176) == 1)
  {
    uint64_t v4 = *a2;
    uint64_t v3 = (const void *)a2[1];
    CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(*a2 + 72), key);
    if (Value)
    {
      unint64_t v6 = Value;
      if (!CFSetContainsValue(Value, v3))
      {
        uint64_t v7 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, "odd missing fileState", buf, 2u);
        }
      }
      CFSetRemoveValue(v6, v3);
    }
    else
    {
      uint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CFErrorRef v15 = 0;
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_ERROR, "odd missing files", v15, 2u);
      }
    }
    CFSetRef v9 = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 80), v3);
    if (v9)
    {
      int v10 = v9;
      if (!CFSetContainsValue(v9, key))
      {
        uint64_t v11 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v14 = 0;
          _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_ERROR, "odd missing container", v14, 2u);
        }
      }
      CFSetRemoveValue(v10, key);
    }
    else
    {
      uint64_t v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v13 = 0;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "odd missing containers", v13, 2u);
      }
    }
  }
}

void OUTLINED_FUNCTION_0_1(void *a1, int a2, int a3, const char *a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint8_t buf)
{
  _os_log_impl(a1, v11, OS_LOG_TYPE_ERROR, a4, &buf, 0xCu);
}

BOOL mmcs_http_clock_skew_metrics_create(uint64_t *a1, double a2, double a3)
{
  *a1 = 0;
  uint64_t v6 = C3TypeRegister(&mmcs_http_clock_skew_metricsGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v6, 0x10uLL);
  if (Instance)
  {
    *(double *)(Instance + 16) = a3;
    *(double *)(Instance + 24) = a2;
    *a1 = Instance;
  }
  return Instance != 0;
}

BOOL _mmcs_http_clock_skew_metricsCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_http_clock_skew_metricsCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_http_clock_skew_metricsCFCopyDebugDescription()
{
  return 0;
}

uint64_t mmcs_put_request_alloc(void *a1, int a2, uint64_t a3)
{
  *a1 = 0;
  uint64_t v7 = 0;
  if (!a3) {
    return 0;
  }
  if (!is_mul_ok(a3 - 1, 0x1A0uLL)) {
    return 0;
  }
  unint64_t v3 = 416 * (a3 - 1);
  if (v3 >= 0xFFFFFFFFFFFFFDC8) {
    return 0;
  }
  if (a2) {
    int v6 = 3;
  }
  else {
    int v6 = 1;
  }
  uint64_t result = mmcs_request_allocate(&v7, v6, v3 + 568);
  if (result) {
    *a1 = v7;
  }
  return result;
}

BOOL mmcs_put_request_is_section(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 3;
}

uint64_t mmcs_put_request_item_count(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 304) + 144);
}

CFErrorRef mmcs_no_memory_error_init(CFDictionaryRef userInfo)
{
  CFErrorRef result = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"com.apple.mmcs", 37, userInfo);
  sNoMemoryError = (uint64_t)result;
  return result;
}

uint64_t mmcs_no_memory_error_create()
{
  if (!sNoMemoryError) {
    abort();
  }
  CFRetain((CFTypeRef)sNoMemoryError);
  return sNoMemoryError;
}

CFErrorRef mmcs_cferror_create_error_with_userInfo(const __CFString *cf2, CFIndex a2, CFDictionaryRef theDict)
{
  CFDictionaryRef v3 = theDict;
  if (theDict && !CFDictionaryGetCount(theDict)) {
    CFDictionaryRef v3 = 0;
  }
  CFEqual(@"com.apple.mmcs", cf2);
  CFErrorRef result = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cf2, a2, v3);
  if (!result)
  {
    return (CFErrorRef)mmcs_no_memory_error_create();
  }
  return result;
}

CFErrorRef mmcs_cferror_create_error_with_underlying_errors(const __CFString *a1, CFIndex a2, void *a3, const __CFArray *a4, const void *a5)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    uint64_t v11 = Mutable;
    mmcs_user_info_add_description(Mutable, a3);
    if (a4)
    {
      if (CFArrayGetCount(a4) == 1)
      {
        uint64_t v12 = (__CFString *)*MEMORY[0x1E4F1D190];
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a4, 0);
        uint64_t v14 = v11;
        CFErrorRef v15 = v12;
      }
      else
      {
        CFErrorRef v15 = @"kMMCSErrorUnderlyingErrorArrayKey";
        uint64_t v14 = v11;
        CFDictionaryRef ValueAtIndex = a4;
      }
      CFDictionarySetValue(v14, v15, ValueAtIndex);
    }
    if (a5)
    {
      if (CFDictionaryGetCount((CFDictionaryRef)a5) >= 1) {
        CFDictionarySetValue(v11, @"kMMCSErrorSupplementalDictionaryKey", a5);
      }
    }
    CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(a1, a2, v11);
    CFRelease(v11);
    return error_with_userInfo;
  }
  else
  {
    return mmcs_cferror_create_error_with_userInfo(a1, a2, 0);
  }
}

CFErrorRef mmcs_cferror_create_error(const __CFString *a1, CFIndex a2, void *a3)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  mmcs_user_info_add_description(Mutable, a3);
  CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(a1, a2, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return error_with_userInfo;
}

CFErrorRef mmcs_cferror_create_with_format(const __CFString *a1, CFIndex a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11 = (__CFString *)CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a3, &a9);
  CFErrorRef error = mmcs_cferror_create_error(a1, a2, v11);
  if (v11) {
    CFRelease(v11);
  }
  return error;
}

CFErrorRef mmcs_cferror_create_file_error_with_format(CFIndex a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F1D160];
  char v12 = strerror(a1);
  CFErrorRef v18 = mmcs_cferror_create_with_format(v11, a1, @"%s(%d)", v13, v14, v15, v16, v17, v12);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  mmcs_user_info_add_description_with_format_and_arguments(Mutable, a2, &a9);
  if (v18)
  {
    mmcs_user_info_add_underlying_error(Mutable, v18);
    CFRelease(v18);
  }
  CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(@"com.apple.mmcs", 39, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return error_with_userInfo;
}

CFErrorRef mmcs_cferror_create_authorization_error_with_format(const void *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  mmcs_user_info_add_description_with_format_and_arguments(Mutable, a2, &a9);
  if (a1) {
    CFDictionarySetValue(Mutable, @"kMMCSErrorAuthorizationBodyDictionaryKey", a1);
  }
  CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(@"com.apple.mmcs", 0, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return error_with_userInfo;
}

CFErrorRef mmcs_cferror_create_error_with_error_response_and_format(int a1, int a2, CFIndex a3, __CFError *a4, const __CFString *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  mmcs_user_info_add_description_with_format_and_arguments(Mutable, a5, &a9);
  if (a4)
  {
    cferror_with_error_response = create_cferror_with_error_response(a4);
    if (cferror_with_error_response)
    {
      uint64_t v16 = cferror_with_error_response;
      CFErrorDomain Domain = CFErrorGetDomain(cferror_with_error_response);
      int v18 = CFEqual(@"apple.mme", Domain);
      int v19 = v18;
      if (a1 && v18 && CFErrorGetCode(v16) == 7)
      {
        a3 = 13;
      }
      else if (a2 && v19 && CFErrorGetCode(v16) == 20)
      {
        a3 = 13;
      }
      mmcs_user_info_add_underlying_error(Mutable, v16);
      CFRelease(v16);
    }
  }
  CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(@"com.apple.mmcs", a3, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return error_with_userInfo;
}

CFErrorRef mmcs_cferror_create_error_with_underlying_error(const __CFString *a1, CFIndex a2, void *a3, const __CFString *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  mmcs_user_info_add_description_with_format_and_arguments(Mutable, a4, &a9);
  if (a3) {
    mmcs_user_info_add_underlying_error(Mutable, a3);
  }
  CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(a1, a2, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return error_with_userInfo;
}

CFErrorRef mmcs_cferror_create_with_request_response_and_format(const __CFString *a1, CFIndex a2, __CFHTTPMessage *a3, __CFHTTPMessage *a4, void *a5, const __CFString *a6, uint64_t a7, uint64_t a8, char a9)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  mmcs_user_info_add_description_with_format_and_arguments(Mutable, a6, &a9);
  if (a3) {
    mmcs_user_info_add_http_message_request(Mutable, a3);
  }
  if (a4) {
    mmcs_user_info_add_http_message_response(Mutable, a4);
  }
  if (a5) {
    mmcs_user_info_add_underlying_error(Mutable, a5);
  }
  CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(a1, a2, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return error_with_userInfo;
}

CFErrorRef mmcs_cferror_create_item_signature_chunk_signature_error_with_format(const __CFString *a1, CFIndex a2, uint64_t a3, const UInt8 *a4, const UInt8 *a5, void *a6, const __CFString *a7, uint64_t a8, char a9)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  mmcs_user_info_add_description_with_format_and_arguments(Mutable, a7, &a9);
  mmcs_user_info_add_itemID(Mutable, a3);
  if (a4) {
    mmcs_user_info_add_fileSignature(Mutable, a4);
  }
  if (a5) {
    mmcs_user_info_add_chunkSignature(Mutable, a5);
  }
  if (a6) {
    mmcs_user_info_add_underlying_error(Mutable, a6);
  }
  CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(a1, a2, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return error_with_userInfo;
}

CFErrorRef mmcs_cferror_create_with_swiss_army_knife(const __CFString *a1, CFIndex a2, const __CFArray *a3, const void *a4, const void **a5, const void **a6, uint64_t a7, CFStringRef format, ...)
{
  va_start(va, format);
  CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v16 = (__CFString *)CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, format, va);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v15, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(a1, a2, 0);
    if (!v16) {
      return error_with_userInfo;
    }
    goto LABEL_15;
  }
  int v18 = Mutable;
  mmcs_user_info_add_description(Mutable, v16);
  if (a3)
  {
    if (CFArrayGetCount(a3) == 1)
    {
      int v19 = (__CFString *)*MEMORY[0x1E4F1D190];
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a3, 0);
      uint64_t v21 = v18;
      CFArrayRef v22 = v19;
    }
    else
    {
      CFArrayRef v22 = @"kMMCSErrorUnderlyingErrorArrayKey";
      uint64_t v21 = v18;
      CFDictionaryRef ValueAtIndex = a3;
    }
    CFDictionarySetValue(v21, v22, ValueAtIndex);
  }
  if (a4 && CFDictionaryGetCount((CFDictionaryRef)a4) >= 1) {
    CFDictionarySetValue(v18, @"kMMCSErrorSupplementalDictionaryKey", a4);
  }
  if (a7 >= 1)
  {
    do
    {
      CFErrorDomain v25 = *a5++;
      uint64_t v24 = v25;
      uint64_t v26 = *a6++;
      CFDictionaryAddValue(v18, v24, v26);
      --a7;
    }
    while (a7);
  }
  CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(a1, a2, v18);
  CFRelease(v18);
  if (v16) {
LABEL_15:
  }
    CFRelease(v16);
  return error_with_userInfo;
}

CFErrorRef mmcs_cferror_create_retry_requested(uint64_t a1, const __CFArray *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v12 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a3, &a9);
  if (a1)
  {
    CFStringRef v13 = CFStringCreateWithFormat(v11, 0, @"%u", a1);
    keys[0] = @"Retry-After";
    keys[1] = @"kMMCSErrorRetryClientInitiatedKey";
    uint64_t v14 = (void *)*MEMORY[0x1E4F1CFD0];
    values[0] = (void *)v13;
    values[1] = v14;
    CFDictionaryRef v15 = CFDictionaryCreate(v11, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFErrorRef v16 = mmcs_cferror_create_with_swiss_army_knife(@"com.apple.mmcs", 16, a2, v15, 0, 0, 0, @"%@. Retry after %@ seconds", v12, v13, &a9);
  }
  else
  {
    keys[0] = @"kMMCSErrorRetryClientInitiatedKey";
    values[0] = *(void **)MEMORY[0x1E4F1CFD0];
    CFDictionaryRef v15 = CFDictionaryCreate(v11, (const void **)keys, (const void **)values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFErrorRef v16 = mmcs_cferror_create_with_swiss_army_knife(@"com.apple.mmcs", 16, a2, v15, 0, 0, 0, @"%@. Retry immediately", v12, v19, &a9);
  }
  CFErrorRef v17 = v16;
  if (v15) {
    CFRelease(v15);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v17;
}

CFErrorRef mmcs_cferror_copy_transformed_cannot_find_host_error(uint64_t a1)
{
  CFErrorRef error = (__CFError *)mmcs_http_context_get_error(a1);
  CFErrorDomain Domain = CFErrorGetDomain(error);
  CFIndex Code = CFErrorGetCode(error);
  int v5 = CFEqual(@"NSURLErrorDomain", Domain);
  CFErrorRef retry_requested = 0;
  if (v5 && Code == -1003)
  {
    CFArrayRef v7 = XCFArrayCreateWithObject(error);
    uint64_t v8 = mmcs_http_context_copy_request_url(a1);
    if (!v8)
    {
      CFErrorRef retry_requested = mmcs_cferror_create_retry_requested(60, v7, @"Unable to find host %@", v9, v10, v11, v12, v13, 0);
      if (!v7) {
        return retry_requested;
      }
      goto LABEL_7;
    }
    uint64_t v14 = v8;
    CFStringRef v15 = CFURLCopyHostName(v8);
    CFErrorRef retry_requested = mmcs_cferror_create_retry_requested(60, v7, @"Unable to find host %@", v16, v17, v18, v19, v20, (char)v15);
    CFRelease(v14);
    if (v15) {
      CFRelease(v15);
    }
    if (v7) {
LABEL_7:
    }
      CFRelease(v7);
  }
  return retry_requested;
}

CFErrorRef mmcs_cferror_create_file_error_wrapping_error_to_release(__CFError *a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v9 = (__CFString *)a1;
    uint64_t v10 = mmcs_cferror_copy_short_description(a1);
    error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 39, v9, @"%@%@", v11, v12, v13, v14, a2);
    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
    uint64_t v9 = @"The reason was not specified";
    error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 39, 0, @"%@%@", a5, a6, a7, a8, a2);
  }
  CFRelease(v9);
  return error_with_underlying_error;
}

uint64_t mmcs_perform_timer_create(uint64_t *a1, int a2, uint64_t a3, _OWORD *a4)
{
  *a1 = 0;
  size_t v7 = a3 + 64;
  uint64_t v8 = C3TypeRegister(&mmcs_perform_timerGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v8, v7);
  if (result)
  {
    uint64_t v10 = result;
    *(_DWORD *)(result + 16) = a2;
    long long v11 = a4[1];
    *(_OWORD *)(result + 24) = *a4;
    *(_OWORD *)(result + 40) = v11;
    uint64_t v12 = *(void (**)(void))(result + 32);
    if (v12)
    {
      if (*(void *)(result + 24)) {
        v12();
      }
    }
    *(void *)(v10 + 56) = v10 + 64;
    *a1 = v10;
    return 1;
  }
  return result;
}

double mmcs_perform_timer_get_next_fire_date(uint64_t a1)
{
  CFArrayRef v1 = (void (*)(void))_performTimerCallbacks[4 * *(int *)(a1 + 16)];
  if (!v1) {
    return -1.0;
  }
  v1();
  return result;
}

uint64_t mmcs_perform_timer_set_next_fire_date(uint64_t result)
{
  uint64_t v1 = *(int *)(result + 16);
  if (v1) {
    return ((uint64_t (*)(void))_performTimerCallbacks[4 * v1 + 1])();
  }
  return result;
}

uint64_t mmcs_perform_timer_invalidate(uint64_t result)
{
  uint64_t v1 = *(int *)(result + 16);
  if (v1) {
    return ((uint64_t (*)(void))_performTimerCallbacks[4 * v1 + 2])();
  }
  return result;
}

uint64_t _mmcs_perform_timerCFFinalize(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(int *)(result + 16);
  if (v2) {
    double result = ((uint64_t (*)(uint64_t))_performTimerCallbacks[4 * v2 + 3])(result);
  }
  CFDictionaryRef v3 = *(uint64_t (**)(void))(v1 + 40);
  if (v3)
  {
    double result = *(void *)(v1 + 24);
    if (result)
    {
      return v3();
    }
  }
  return result;
}

BOOL _mmcs_perform_timerCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_perform_timerCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_perform_timerCFCopyDebugDescription()
{
  return 0;
}

uint64_t mmcs_read_stream_pool_parameters_make_pool@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  a2[1] = 0;
  a2[2] = 0xBFF0000000000000;
  a2[3] = 0;
  return result;
}

uint64_t mmcs_read_stream_pool_parameters_make_pool_timeout_max@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>, double a4@<D0>)
{
  *(void *)(a3 + 24) = 0;
  *(void *)a3 = result;
  *(void *)(a3 + 8) = 0;
  *(double *)(a3 + 16) = a4;
  *(_DWORD *)(a3 + 24) = a2;
  return result;
}

__CFDictionary *mmcs_network_request_options_for_options(const __CFDictionary *a1)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"kMMCSRequestOptionStreamOptions");
  if (!Value) {
    return 0;
  }
  CFDictionaryRef v2 = Value;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFSetRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, Value);
  int v5 = (const void *)*MEMORY[0x1E4F190B8];
  if (CFDictionaryGetValue(v2, (const void *)*MEMORY[0x1E4F190B8]))
  {
    int v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v7 = CFStringCreateWithFormat(v3, 0, @"Stream option kCFStreamPropertyDataContextOnDemand ignored.");
      uint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v30 = v7;
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
    CFDictionaryRemoveValue(MutableCopy, v5);
  }
  uint64_t v9 = (const void *)*MEMORY[0x1E4F19070];
  uint64_t v10 = CFDictionaryGetValue(v2, (const void *)*MEMORY[0x1E4F19070]);
  if (v10)
  {
    CFDictionarySetValue(MutableCopy, @"kMMCSRequestOptionBoundInterfaceIdentifier", v10);
    CFDictionaryRemoveValue(MutableCopy, v9);
  }
  long long v11 = (const void *)*MEMORY[0x1E4F190F0];
  cfchar BOOLean_from_cfdictionary_object_for_key = (const __CFBoolean *)mmcs_get_cfBOOLean_from_cfdictionary_object_for_key(v2, (void *)*MEMORY[0x1E4F190F0], 0);
  uint64_t v13 = (const void **)MEMORY[0x1E4F1CFC8];
  uint64_t v14 = (const void **)MEMORY[0x1E4F1CFD0];
  if (cfBOOLean_from_cfdictionary_object_for_key)
  {
    if (CFBooleanGetValue(cfBOOLean_from_cfdictionary_object_for_key)) {
      CFStringRef v15 = v13;
    }
    else {
      CFStringRef v15 = v14;
    }
    CFDictionarySetValue(MutableCopy, @"kMMCSRequestOptionAllowsCellularAccess", *v15);
    CFDictionaryRemoveValue(MutableCopy, v11);
  }
  CFBooleanRef v16 = (const __CFBoolean *)mmcs_get_cfBOOLean_from_cfdictionary_object_for_key(v2, @"kMMCSRequestOptionUseNWLoaderOverride", 0);
  if (v16)
  {
    if (CFBooleanGetValue(v16)) {
      uint64_t v17 = v13;
    }
    else {
      uint64_t v17 = v14;
    }
    CFDictionarySetValue(MutableCopy, @"kMMCSRequestOptionUseNWLoaderOverride", *v17);
  }
  uint64_t v18 = (const void *)*MEMORY[0x1E4F19018];
  uint64_t v19 = CFDictionaryGetValue(v2, (const void *)*MEMORY[0x1E4F19018]);
  if (!v19) {
    goto LABEL_50;
  }
  uint64_t v20 = v19;
  CFTypeID v21 = CFGetTypeID(v19);
  if (v21 == CFStringGetTypeID())
  {
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E4F19058]))
    {
      int v22 = 2;
LABEL_47:
      *(_DWORD *)long long buf = v22;
      CFNumberRef v26 = CFNumberCreate(v3, kCFNumberSInt32Type, buf);
      if (!v26) {
        mmcs_network_request_options_for_options_cold_1();
      }
      CFDictionarySetValue(MutableCopy, @"kMMCSRequestOptionNetworkServiceType", v26);
      goto LABEL_49;
    }
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E4F19028]))
    {
      int v22 = 3;
      goto LABEL_47;
    }
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E4F19060]))
    {
      int v22 = 4;
      goto LABEL_47;
    }
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E4F19030]))
    {
      int v22 = 5;
      goto LABEL_47;
    }
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E4F19050]))
    {
      int v22 = 6;
      goto LABEL_47;
    }
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E4F19040]))
    {
      int v22 = 7;
      goto LABEL_47;
    }
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E4F19020]))
    {
      int v22 = 8;
      goto LABEL_47;
    }
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E4F19048]))
    {
      int v22 = 9;
      goto LABEL_47;
    }
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x1E4F19038]))
    {
      int v22 = 10;
      goto LABEL_47;
    }
    uint64_t v28 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v24 = CFStringCreateWithFormat(v3, 0, @"Stream option kCFStreamNetworkServiceType ignored. Unknown type %@", v20);
      CFErrorDomain v25 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
LABEL_29:
        if (v24) {
          CFRelease(v24);
        }
        goto LABEL_49;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v30 = v24;
LABEL_28:
      _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v23 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v24 = CFStringCreateWithFormat(v3, 0, @"Stream option kCFStreamPropertyNoCellular ignored. Expected string. Got %@", v20);
      CFErrorDomain v25 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_29;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v30 = v24;
      goto LABEL_28;
    }
  }
LABEL_49:
  CFDictionaryRemoveValue(MutableCopy, v18);
LABEL_50:
  if (MutableCopy && !CFDictionaryGetCount(MutableCopy))
  {
    CFRelease(MutableCopy);
    return 0;
  }
  return MutableCopy;
}

void mmcs_http_context_extract_vendor_name_from_message_and_create_pool_parameters(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  CFStringRef v5 = (const __CFString *)mmcs_http_context_copy_vendor_name(a1);
  CFStringRef v6 = v5;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  if (v5) {
    CFRetain(v5);
  }
  CFDictionaryRef v7 = (const __CFDictionary *)mmcs_report_copy_vendor_configuration_with_name(v6);
  if (!v7)
  {
    *(void *)(a3 + 16) = 0xBFF0000000000000;
    *(void *)(a3 + 24) = 0;
    *(void *)a3 = a2;
    *(void *)(a3 + 8) = v6;
    if (!v6) {
      return;
    }
    goto LABEL_15;
  }
  CFDictionaryRef v8 = v7;
  int valuePtr = 0;
  CFDictionaryRef Value = CFDictionaryGetValue(v7, @"connection.max.requests");
  if (Value)
  {
    uint64_t v10 = Value;
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v10)
      && (!CFNumberGetValue((CFNumberRef)v10, kCFNumberSInt32Type, &valuePtr) || valuePtr < 0))
    {
      int valuePtr = 0;
    }
  }
  CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(v8, @"connection.max.idle.millis");
  double v13 = -1.0;
  if (v12)
  {
    CFNumberRef v14 = v12;
    CFTypeID v15 = CFNumberGetTypeID();
    if (v15 == CFGetTypeID(v14))
    {
      uint64_t v16 = 0;
      if (CFNumberGetValue(v14, kCFNumberSInt64Type, &v16))
      {
        if ((v16 & 0x8000000000000000) == 0) {
          double v13 = (double)v16 / 1000.0;
        }
      }
    }
  }
  CFRelease(v8);
  *(void *)(a3 + 24) = 0;
  *(void *)a3 = a2;
  *(void *)(a3 + 8) = v6;
  *(double *)(a3 + 16) = v13;
  *(_DWORD *)(a3 + 24) = valuePtr;
  if (v6) {
LABEL_15:
  }
    CFRelease(v6);
}

const void *mmcs_http_context_copy_vendor_name(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 576);
  uint64_t v2 = *(void *)(v1 + 24);
  if (!v2) {
    mmcs_http_context_copy_vendor_name_cold_1();
  }
  double result = *(const void **)(v2 + 32);
  if (result)
  {
    CFRetain(result);
    return *(const void **)(*(void *)(v1 + 24) + 32);
  }
  return result;
}

BOOL debug_begin_writing_http_message_to_file(uint64_t a1, __CFHTTPMessage *a2, FILE **a3, const __CFString *a4, int a5)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (char *)debug_begin_writing_http_message_to_file_dumpdir;
  if ((debug_begin_writing_http_message_to_file_didCheck & 1) == 0 && !debug_begin_writing_http_message_to_file_dumpdir)
  {
    uint64_t v10 = getenv("MMCS_HTTP_DEBUG_DIR");
    debug_begin_writing_http_message_to_file_dumpdir = (uint64_t)v10;
    debug_begin_writing_http_message_to_file_didCheck = 1;
  }
  if (!v10) {
    return 1;
  }
  CFURLRef v11 = CFHTTPMessageCopyRequestURL(*(CFHTTPMessageRef *)(a1 + 336));
  CFStringRef PathComponent = CFURLCopyLastPathComponent(v11);
  if (v11) {
    CFRelease(v11);
  }
  bzero(__str, 0x400uLL);
  bzero(__filename, 0x400uLL);
  int v62 = 0;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v57 = 0u;
  *(_OWORD *)CFStringRef v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  int v55 = 0;
  CFStringGetCString(PathComponent, buffer, 100, 0x8000100u);
  if (PathComponent) {
    CFRelease(PathComponent);
  }
  if (a4)
  {
    double v13 = v49;
    CFStringGetCString(a4, v49, 100, 0x8000100u);
  }
  else
  {
    double v13 = buffer;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&sMMCSHTTPClassLock);
  uint64_t v14 = sMMCSHTTPMessageSequenceNumber++;
  os_unfair_lock_unlock((os_unfair_lock_t)&sMMCSHTTPClassLock);
  CFTypeID v15 = (const char *)debug_begin_writing_http_message_to_file_dumpdir;
  pid_t v16 = getpid();
  if (a5) {
    uint64_t v17 = "response";
  }
  else {
    uint64_t v17 = "request";
  }
  uint64_t v48 = v14;
  snprintf(__str, 0x400uLL, "%s/httpdebug.pid%d.tx%04ld.seq%08ld.%p.%s.%s.headers.txt", v15, v16, *(void *)(a1 + 272), v14, (const void *)a1, v13, v17);
  uint64_t v18 = fopen(__str, "w");
  uint64_t v19 = mmcs_logging_logger_default();
  if (!v18)
  {
    BOOL result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    CFStringRef v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to open %s", __str);
    CFNumberRef v26 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      goto LABEL_57;
    }
    *(_DWORD *)long long buf = 138543362;
    *(void *)&uint8_t buf[4] = v25;
    goto LABEL_56;
  }
  CFStringRef v46 = v13;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Writing message headers to %s", __str);
    CFTypeID v21 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v20) {
      CFRelease(v20);
    }
  }
  memset(v82, 0, sizeof(v82));
  long long v81 = 0u;
  long long v80 = 0u;
  long long v79 = 0u;
  long long v78 = 0u;
  long long v77 = 0u;
  long long v76 = 0u;
  long long v75 = 0u;
  long long v74 = 0u;
  long long v73 = 0u;
  long long v72 = 0u;
  long long v71 = 0u;
  long long v70 = 0u;
  long long v69 = 0u;
  long long v68 = 0u;
  long long v67 = 0u;
  long long v66 = 0u;
  *(_OWORD *)long long buf = 0u;
  uint64_t v47 = a3;
  uint64_t v45 = v17;
  if (a5)
  {
    CFStringRef v22 = CFHTTPMessageCopyVersion(a2);
    if (v22)
    {
      CFStringRef v23 = v22;
      CFStringGetCString(v22, (char *)buf, 300, 0x8000100u);
      CFRelease(v23);
    }
    else
    {
      buf[0] = 0;
    }
    if (*(_DWORD *)(a1 + 68))
    {
      int http_status = metricsinfo__get_http_status(a1 + 24);
      fprintf(v18, "%s %ld ", (const char *)buf, http_status);
    }
    CFStringRef v30 = CFHTTPMessageCopyResponseStatusLine(a2);
  }
  else
  {
    CFStringRef v27 = CFHTTPMessageCopyRequestMethod(a2);
    CFStringGetCString(v27, (char *)buf, 300, 0x8000100u);
    if (v27) {
      CFRelease(v27);
    }
    fprintf(v18, "%s ", (const char *)buf);
    CFURLRef v28 = CFHTTPMessageCopyRequestURL(a2);
    CFStringRef v29 = CFURLCopyPath(v28);
    if (v28) {
      CFRelease(v28);
    }
    CFStringGetCString(v29, (char *)buf, 300, 0x8000100u);
    if (v29) {
      CFRelease(v29);
    }
    fprintf(v18, "%s ", (const char *)buf);
    CFStringRef v30 = CFHTTPMessageCopyVersion(a2);
  }
  CFStringRef v32 = v30;
  CFStringGetCString(v30, (char *)buf, 300, 0x8000100u);
  if (v32) {
    CFRelease(v32);
  }
  fprintf(v18, "%s\n", (const char *)buf);
  CFDictionaryRef v33 = CFHTTPMessageCopyAllHeaderFields(a2);
  CFIndex Count = CFDictionaryGetCount(v33);
  uint64_t v35 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  uint64_t v36 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  CFDictionaryGetKeysAndValues(v33, v35, v36);
  if (Count < 1)
  {
    if (!v35) {
      goto LABEL_46;
    }
  }
  else
  {
    uint64_t v37 = (const __CFString **)v35;
    CFStringRef v38 = (const __CFString **)v36;
    do
    {
      CFStringRef v39 = *v37++;
      CFStringGetCString(v39, (char *)buf, 300, 0x8000100u);
      fprintf(v18, "%s: ", (const char *)buf);
      CFStringRef v40 = *v38++;
      CFStringGetCString(v40, (char *)buf, 300, 0x8000100u);
      fprintf(v18, "%s\n", (const char *)buf);
      --Count;
    }
    while (Count);
  }
  free(v35);
LABEL_46:
  if (v36) {
    free(v36);
  }
  if (v33) {
    CFRelease(v33);
  }
  fputs("\nWARNING: this is not an exact copy of the headers on the wire\n", v18);
  fclose(v18);
  CFDictionaryRef v41 = (const char *)debug_begin_writing_http_message_to_file_dumpdir;
  pid_t v42 = getpid();
  snprintf(__filename, 0x400uLL, "%s/httpdebug.pid%d.tx%04ld.seq%08ld.%p.%s.%s.body.bin", v41, v42, *(void *)(a1 + 272), v48, (const void *)a1, v46, v45);
  uint64_t v43 = fopen(__filename, "w");
  if (v43)
  {
    NSObject *v47 = v43;
    return 1;
  }
  int v44 = mmcs_logging_logger_default();
  BOOL result = os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
  if (result)
  {
    CFStringRef v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to open %s", __filename);
    CFNumberRef v26 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
LABEL_57:
      if (v25) {
        CFRelease(v25);
      }
      return 0;
    }
    *(_DWORD *)long long buf = 138543362;
    *(void *)&uint8_t buf[4] = v25;
LABEL_56:
    _os_log_impl(&dword_1DC1CA000, v26, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    goto LABEL_57;
  }
  return result;
}

void mmcs_http_write_response_body(uint64_t a1, const UInt8 *a2, CFIndex a3)
{
}

CFErrorRef mmcs_http_context_copy_cferror_for_http_status_not_ok(uint64_t a1)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(const void **)(a1 + 408);
  if (v2)
  {
    CFRetain(v2);
    CFAllocatorRef v3 = *(const void **)(a1 + 408);
  }
  else
  {
    CFAllocatorRef v3 = 0;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    if (*(_DWORD *)(a1 + 68))
    {
      int http_status = metricsinfo__get_http_status(a1 + 24);
      CFStringRef v7 = CFStringCreateWithFormat(v4, 0, @"The server returned HTTP status code: %ld", http_status);
    }
    else
    {
      CFStringRef v7 = @"The server did not return an HTTP status code";
    }
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F1D140], v7);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F1D170], v7);
    if (v7) {
      CFRelease(v7);
    }
    if (*(_DWORD *)(a1 + 68)) {
      uint64_t v8 = (int)metricsinfo__get_http_status(a1 + 24);
    }
    else {
      uint64_t v8 = -1;
    }
    *(void *)int valuePtr = v8;
    CFNumberRef v9 = CFNumberCreate(v4, kCFNumberCFIndexType, valuePtr);
    CFDictionarySetValue(Mutable, @"kMMCSErrorHTTPStatusKey", v9);
    if (v9) {
      CFRelease(v9);
    }
    if (v3)
    {
      CFDictionarySetValue(Mutable, @"kMMCSErrorHTTPBodyKey", v3);
      BytePtr = CFDataGetBytePtr((CFDataRef)v3);
      CFIndex Length = CFDataGetLength((CFDataRef)v3);
      CFStringRef v12 = CFStringCreateWithBytes(v4, BytePtr, Length, 0x8000100u, 0);
      if (v12)
      {
        CFStringRef v13 = v12;
        CFDictionarySetValue(Mutable, @"kMMCSErrorHTTPBodyStringKey", v12);
        CFRelease(v13);
      }
    }
    uint64_t v14 = *(const void **)(a1 + 328);
    if (v14) {
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F1D190], v14);
    }
    CFTypeID v15 = *(__CFHTTPMessage **)(a1 + 336);
    if (v15) {
      mmcs_user_info_add_http_message_request(Mutable, v15);
    }
  }
  if (v3) {
    CFRelease(v3);
  }
  int v16 = *(unsigned __int8 *)(a1 + 292);
  uint64_t v17 = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v18 = *(_DWORD *)(a1 + 68);
  if (!v16)
  {
    if (!v18)
    {
      uint64_t v31 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex v22 = 6;
        if (!v17) {
          goto LABEL_57;
        }
        goto LABEL_81;
      }
      CFStringRef v32 = CFStringCreateWithFormat(v4, 0, @"mmcs http context <%p> does not have http status", a1);
      CFDictionaryRef v33 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int valuePtr = 138543362;
        *(void *)&valuePtr[4] = v32;
        _os_log_impl(&dword_1DC1CA000, v33, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
      }
      CFIndex v22 = 6;
      if (v32) {
        goto LABEL_79;
      }
LABEL_80:
      if (!v17) {
        goto LABEL_57;
      }
      goto LABEL_81;
    }
    CFStringRef v23 = (const __CFString *)mmcs_http_context_copy_vendor_name(a1);
    if (v23)
    {
      CFStringRef v24 = v23;
      CFStringRef v25 = CFHTTPMessageCopyRequestMethod(*(CFHTTPMessageRef *)(a1 + 336));
      if (v25)
      {
        CFStringRef v26 = v25;
        CFStringRef v27 = mmcs_report_copy_vendor_retryable_http_errors(v24, v25);
        CFRelease(v24);
        CFStringRef v24 = v26;
      }
      else
      {
        CFStringRef v27 = 0;
      }
      CFRelease(v24);
      uint64_t v38 = (int)metricsinfo__get_http_status(a1 + 24);
      if (v27)
      {
        if (mmcs_index_set_contains_index((uint64_t)v27, v38)) {
          CFIndex v22 = 16;
        }
        else {
          CFIndex v22 = 6;
        }
        C3BaseRelease(v27);
        goto LABEL_75;
      }
    }
    else
    {
      uint64_t v38 = (int)metricsinfo__get_http_status(a1 + 24);
    }
    if (v38 == 503 || v38 == 500) {
      CFIndex v22 = 16;
    }
    else {
      CFIndex v22 = 6;
    }
LABEL_75:
    if (v22 == 16 && v38 == 503)
    {
      CFStringRef v40 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 392), @"Retry-After");
      if (v40)
      {
        CFStringRef v32 = v40;
        CFDictionarySetValue(v17, @"Retry-After", v40);
        CFDictionarySetValue(v17, @"kMMCSErrorRetryClientInitiatedKey", (const void *)*MEMORY[0x1E4F1CFC8]);
        CFIndex v22 = 16;
LABEL_79:
        CFRelease(v32);
        goto LABEL_80;
      }
      CFIndex v22 = 16;
      if (!v17) {
        goto LABEL_57;
      }
LABEL_81:
      if (CFDictionaryGetCount(v17) < 1) {
        goto LABEL_56;
      }
      goto LABEL_55;
    }
    goto LABEL_80;
  }
  if (!v18)
  {
    CFURLRef v28 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v29 = CFStringCreateWithFormat(v4, 0, @"mmcs http context <%p> does not have http status", a1);
      CFStringRef v30 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int valuePtr = 138543362;
        *(void *)&valuePtr[4] = v29;
        _os_log_impl(&dword_1DC1CA000, v30, OS_LOG_TYPE_DEFAULT, "%{public}@", valuePtr, 0xCu);
      }
      if (v29) {
        CFRelease(v29);
      }
    }
    goto LABEL_42;
  }
  int v19 = metricsinfo__get_http_status(a1 + 24);
  if (v19 != 503)
  {
    if (v19 == 401)
    {
      CFIndex v22 = 14;
      if (!v17) {
        goto LABEL_57;
      }
      goto LABEL_54;
    }
    if (v19 == 330)
    {
      CFStringRef v20 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 392), @"X-Apple-MMe-Host");
      if (v20)
      {
        CFStringRef v21 = v20;
        CFDictionarySetValue(v17, @"X-Apple-MMe-Host", v20);
        CFRelease(v21);
      }
      CFIndex v22 = 15;
      if (!v17) {
        goto LABEL_57;
      }
LABEL_54:
      if (CFDictionaryGetCount(v17) <= 0)
      {
LABEL_56:
        CFRelease(v17);
        goto LABEL_57;
      }
LABEL_55:
      CFDictionarySetValue(Mutable, @"kMMCSErrorSupplementalDictionaryKey", v17);
      goto LABEL_56;
    }
LABEL_42:
    CFIndex v22 = 6;
    if (!v17) {
      goto LABEL_57;
    }
    goto LABEL_54;
  }
  CFStringRef v34 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 392), @"Retry-After");
  if (v34)
  {
    CFStringRef v35 = v34;
    CFDictionarySetValue(v17, @"Retry-After", v34);
    CFDictionarySetValue(v17, @"kMMCSErrorRetryClientInitiatedKey", (const void *)*MEMORY[0x1E4F1CFC8]);
    CFRelease(v35);
  }
  CFIndex v22 = 16;
  if (v17) {
    goto LABEL_54;
  }
LABEL_57:
  CFErrorRef error_with_userInfo = mmcs_cferror_create_error_with_userInfo(@"com.apple.mmcs", v22, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return error_with_userInfo;
}

const void *mmcs_http_context_copy_response_body(uint64_t a1)
{
  BOOL result = *(const void **)(a1 + 408);
  if (result)
  {
    CFRetain(result);
    return *(const void **)(a1 + 408);
  }
  return result;
}

BOOL mmcs_http_context_has_http_status(uint64_t a1)
{
  return *(_DWORD *)(a1 + 68) != 0;
}

uint64_t mmcs_http_context_http_status(uint64_t a1)
{
  return (int)metricsinfo__get_http_status(a1 + 24);
}

CFStringRef mmcs_item_copy_token_header_value(char *cStr, const char *a2, const char *a3, uint64_t a4, int a5)
{
  if (!cStr) {
    return 0;
  }
  CFStringRef v9 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  CFStringRef v10 = CFStringCreateWithCString(0, a3, 0x8000100u);
  if (a2)
  {
    CFStringRef v11 = CFStringCreateWithCString(0, a2, 0x8000100u);
    if (v11)
    {
      CFStringRef v12 = v11;
      a2 = (const char *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @" %@", v11);
      CFRelease(v12);
    }
    else
    {
      a2 = 0;
    }
  }
  uint64_t v14 = &stru_1F363CBE8;
  if (a2) {
    uint64_t v14 = (__CFString *)a2;
  }
  if (a5)
  {
    if (a4 < 1)
    {
      CFStringRef v13 = 0;
      if (!v9) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
    CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@%@ %lld %@", v9, v14, a4, v10);
  }
  else
  {
    CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@%@ %@", v9, v14, v10);
  }
  CFStringRef v13 = v15;
  if (v9) {
LABEL_14:
  }
    CFRelease(v9);
LABEL_15:
  if (v10) {
    CFRelease(v10);
  }
  if (a2) {
    CFRelease(a2);
  }
  return v13;
}

double mmcs_http_context_start_time(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

double mmcs_http_context_enqueued_time(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 248)) {
    mmcs_http_context_enqueued_time_cold_1();
  }
  return *(double *)(a1 + 256);
}

uint64_t mmcs_http_context_has_enqueued_time(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 248);
}

double mmcs_http_context_response_received_time(uint64_t a1)
{
  return *(double *)(a1 + 120);
}

double mmcs_http_context_stop_time(uint64_t a1)
{
  return *(double *)(a1 + 128);
}

uint64_t mmcs_http_context_copy_uuid(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (v1) {
    CFRetain(*(CFTypeRef *)(a1 + 304));
  }
  return v1;
}

__CFHTTPMessage *mmcs_http_context_copy_request_url(uint64_t a1)
{
  BOOL result = *(__CFHTTPMessage **)(a1 + 336);
  if (result) {
    return CFHTTPMessageCopyRequestURL(result);
  }
  return result;
}

CFStringRef mmcs_http_context_copy_interface_identifier(uint64_t a1)
{
  return socketinfo__create_cfstring_with_interface_identifier(a1 + 440);
}

uint64_t mmcs_http_context_get_interface_identifier(uint64_t a1)
{
  return *(void *)(a1 + 464);
}

uint64_t mmcs_http_context_get_response_message(uint64_t a1)
{
  return *(void *)(a1 + 392);
}

uint64_t mmcs_http_context_get_request_message(uint64_t a1)
{
  return *(void *)(a1 + 336);
}

uint64_t mmcs_http_context_get_request_options(uint64_t a1)
{
  return *(void *)(a1 + 368);
}

CFStringRef mmcs_http_context_copy_destination_address(uint64_t a1)
{
  return socketinfo__create_cfstring_with_peer_address(a1 + 440);
}

uint64_t mmcs_http_context_get_destination_address(uint64_t a1)
{
  return *(void *)(a1 + 472);
}

uint64_t mmcs_http_context_destination_port(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 480);
}

uint64_t mmcs_http_context_has_bytes_written(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 152);
}

uint64_t mmcs_http_context_bytes_written(uint64_t a1)
{
  return metricsinfo__get_bytes_written(a1 + 24);
}

uint64_t mmcs_http_context_has_bytes_read(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 208);
}

uint64_t mmcs_http_context_bytes_read(uint64_t a1)
{
  return metricsinfo__get_bytes_read(a1 + 24);
}

uint64_t mmcs_http_context_request_size(uint64_t a1)
{
  return *(void *)(a1 + 136);
}

uint64_t mmcs_http_context_has_response_size(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 192);
}

uint64_t mmcs_http_context_response_size(uint64_t a1)
{
  return metricsinfo__get_response_size(a1 + 24);
}

CFHashCode mmcs_http_context_uuid_hash_code(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(const void **)(a1 + 304)) != 0) {
    return CFHash(v1);
  }
  else {
    return 0;
  }
}

uint64_t mmcs_http_context_get_metrics(uint64_t a1)
{
  return *(void *)(a1 + 488);
}

const void *mmcs_http_context_copy_error(uint64_t a1)
{
  BOOL result = *(const void **)(a1 + 328);
  if (result)
  {
    CFRetain(result);
    return *(const void **)(a1 + 328);
  }
  return result;
}

uint64_t mmcs_http_context_get_error(uint64_t a1)
{
  return *(void *)(a1 + 328);
}

__CFHTTPMessage *mmcs_http_context_copy_header_field_value(uint64_t a1, const __CFString *a2)
{
  BOOL result = *(__CFHTTPMessage **)(a1 + 392);
  if (result) {
    return (__CFHTTPMessage *)CFHTTPMessageCopyHeaderFieldValue(result, a2);
  }
  return result;
}

BOOL mmcs_http_context_is_background(uint64_t a1)
{
  return mmcs_http_request_options_is_background(*(void *)(a1 + 368));
}

uint64_t mmcs_http_context_is_connection_reused(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 484);
}

uint64_t mmcs_http_context_is_cancelled(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 290);
}

uint64_t mmcs_http_context_is_complete(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t mmcs_http_context_is_to_mobile_me(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 292);
}

uint64_t mmcs_http_context_is_container_upload(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 294);
}

uint64_t mmcs_http_context_has_timedout(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 60);
}

uint64_t mmcs_http_context_is_timedout(uint64_t a1)
{
  return metricsinfo__get_timed_out(a1 + 24);
}

uint64_t mmcs_http_context_get_user_data(uint64_t a1)
{
  return *(void *)(a1 + 576);
}

uint64_t mmcs_http_context_clear_user_data(uint64_t result)
{
  *(void *)(result + 576) = 0;
  return result;
}

uint64_t mmcs_http_msg_add_items_token_header(__CFHTTPMessage *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  if (!a1 || !a2 || !a3) {
    return 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = a3;
  while (a4)
  {
    if (mmcs_item_needs_put(v11)) {
      goto LABEL_11;
    }
    ++v10;
    v11 += 416;
    if (a2 == v10)
    {
      CFStringRef v12 = 0;
      goto LABEL_12;
    }
  }
  uint64_t v10 = 0;
LABEL_11:
  CFStringRef v12 = (uint64_t *)(a3 + 416 * v10);
LABEL_12:
  return mmcs_http_msg_add_item_token_header(a1, v12, a4, a5);
}

uint64_t mmcs_http_msg_add_item_token_header(__CFHTTPMessage *a1, uint64_t *a2, int a3, int a4)
{
  if (!a2) {
    return 0;
  }
  CFAllocatorRef v4 = (char *)*a2;
  if (!*a2) {
    return 0;
  }
  uint64_t v7 = 8;
  if (!a3) {
    uint64_t v7 = 6;
  }
  uint64_t v8 = (char *)a2[v7];
  CFStringRef v9 = (const char *)a2[1];
  uint64_t v10 = mmcs_item_padded_length(a2);
  return mmcs_http_msg_add_auth_header(a1, v4, v8, v9, v10, a4);
}

uint64_t mmcs_http_msg_add_items_token_header_simulcast(__CFHTTPMessage *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  if (a2)
  {
    if (a1)
    {
      uint64_t v5 = a3;
      if (a3)
      {
        for (uint64_t i = a2; !mmcs_item_needs_put(i); i += 416)
        {
          if (!--v5) {
            return 0;
          }
        }
        CFStringRef v7 = CFStringCreateWithCString(0, *(const char **)(i + 8), 0x8000100u);
        CFHTTPMessageSetHeaderFieldValue(a1, @"x-apple-mmcs-auth", v7);
        return 1;
      }
    }
  }
  return result;
}

uint64_t mmcs_http_msg_add_auth_header(__CFHTTPMessage *a1, char *a2, char *CStringDescription, const char *a4, uint64_t a5, int a6)
{
  uint64_t v6 = 0;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a2 || !a4) {
    return v6;
  }
  CFStringRef v12 = mmcs_file_signature_to_hexstring(a2);
  if (CStringDescription) {
    CCFStringRef StringDescription = XCFDataCreateCStringDescription((const __CFData *)CStringDescription);
  }
  CFStringRef v13 = mmcs_item_copy_token_header_value(v12, CStringDescription, a4, a5, a6);
  if (v13)
  {
    CFStringRef v14 = v13;
    CFHTTPMessageSetHeaderFieldValue(a1, @"x-apple-mmcs-auth", v13);
    CFRelease(v14);
    uint64_t v6 = 1;
    if (!v12) {
      goto LABEL_8;
    }
  }
  else
  {
    int v16 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to create token header for item %s", v12);
      int v18 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v20 = v17;
        _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v17) {
        CFRelease(v17);
      }
    }
    uint64_t v6 = 0;
    if (!v12) {
      goto LABEL_8;
    }
  }
  free(v12);
LABEL_8:
  if (CStringDescription) {
    free(CStringDescription);
  }
  return v6;
}

void mmcs_http_context_set_perform_target(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 608);
  if (v3 != cf)
  {
    if (v3) {
      C3BaseRelease(v3);
    }
    *(void *)(a1 + 608) = 0;
    if (cf)
    {
      *(void *)(a1 + 608) = cf;
      C3BaseRetain(cf);
    }
  }
}

__CFString *mmcs_http_class_description(unsigned int a1)
{
  if (a1 > 3) {
    return @"unknown mmcs_http_class";
  }
  else {
    return off_1E6C33F28[a1];
  }
}

const void *mmcs_http_class_for_string(const void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(v1) && !CFEqual(v1, @"mmcs_http_class_none")) {
      return (const void *)(2 * (CFEqual(v1, @"mmcs_http_class_nsurlsession") != 0));
    }
    else {
      return 0;
    }
  }
  return result;
}

const void *mmcs_http_class_default_value(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFPropertyListRef v2 = CFPreferencesCopyAppValue(@"http_class", @"com.apple.mmcs");
  if (v2)
  {
    CFTypeRef v3 = v2;
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(v3))
    {
      uint64_t v5 = mmcs_http_class_for_string(v3);
      if (v5)
      {
        uint64_t v6 = v5;
        CFRelease(v3);
        return v6;
      }
      uint64_t v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Ignoring user default for http_class. Unknown http class \"%@\"", v3);
        CFStringRef v9 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          goto LABEL_12;
        }
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v13 = v8;
LABEL_11:
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
LABEL_12:
        if (v8) {
          CFRelease(v8);
        }
      }
    }
    else
    {
      CFStringRef v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Ignoring user default for http_class. Expect string value, got %@", v3);
        CFStringRef v9 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          goto LABEL_12;
        }
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v13 = v8;
        goto LABEL_11;
      }
    }
    CFRelease(v3);
  }
  return (const void *)a1;
}

uint64_t mmcs_http_context_get_activity_marker(uint64_t a1)
{
  return *(void *)(a1 + 584);
}

double mmcs_http_total_timeout(double DoubleValue)
{
  CFStringRef v2 = (const __CFString *)CFPreferencesCopyAppValue(@"http.totalTimeout", @"com.apple.mmcs");
  if (v2)
  {
    CFStringRef v3 = v2;
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(v3))
    {
      DoubleCFDictionaryRef Value = CFStringGetDoubleValue(v3);
    }
    else
    {
      CFTypeID v5 = CFNumberGetTypeID();
      if (v5 == CFGetTypeID(v3))
      {
        double valuePtr = 0.0;
        if (CFNumberGetValue((CFNumberRef)v3, kCFNumberDoubleType, &valuePtr)) {
          DoubleCFDictionaryRef Value = valuePtr;
        }
      }
    }
    CFRelease(v3);
  }
  return DoubleValue;
}

uint64_t mmcs_http_context_allocate(uint64_t *a1, int a2, uint64_t a3)
{
  *a1 = 0;
  switch(a2)
  {
    case 3:
      uint64_t v6 = (uint64_t *)&mmcs_http_class_curlGetTypeID_typeID;
      break;
    case 2:
      uint64_t v6 = (uint64_t *)&mmcs_http_class_nsurlsessionGetTypeID_typeID;
      break;
    case 1:
      uint64_t v6 = (uint64_t *)&mmcs_http_class_cfhttpGetTypeID_typeID;
      break;
    default:
      goto LABEL_11;
  }
  uint64_t v7 = C3TypeRegister(v6);
  if (!v7) {
LABEL_11:
  }
    mmcs_http_context_allocate_cold_1();
  uint64_t result = C3TypeCreateInstance_(0, v7, a3 + 632);
  if (result)
  {
    *(_DWORD *)(result + 16) = a2;
    *(void *)(result + 624) = result + 632;
    *a1 = result;
    return 1;
  }
  return result;
}

CFStringRef _mmcs_http_context_init(uint64_t a1, uint64_t a2)
{
  if (!a2 || !*(void *)(a2 + 8)) {
    return 0;
  }
  uint64_t v4 = _mmcs_http_transactionIndex++;
  *(void *)(a1 + 272) = v4;
  double v5 = *(double *)(a2 + 144);
  uint64_t v6 = a1 + 24;
  uint64_t v7 = a1 + 24;
  if (v5 == 0.0) {
    metricsinfo__clear_enqueued_time(v7);
  }
  else {
    metricsinfo__set_enqueued_time(v7, v5);
  }
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  metricsinfo__clear_start_name_resolution(v6);
  metricsinfo__clear_stop_name_resolution(v6);
  *(void *)(a1 + 336) = CFRetain(*(CFTypeRef *)(a2 + 8));
  CFStringRef v9 = *(const void **)(a2 + 16);
  if (!v9) {
    _mmcs_http_context_init_cold_1();
  }
  *(void *)(a1 + 368) = C3BaseRetain(v9);
  uint64_t v10 = *(const void **)a2;
  *(void *)(a1 + 264) = *(void *)a2;
  if (v10) {
    CFRetain(v10);
  }
  *(_OWORD *)(a1 + 376) = *(_OWORD *)(a2 + 24);
  *(_WORD *)(a1 + 288) = 0;
  *(unsigned char *)(a1 + 290) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_WORD *)(a1 + 292) = 1;
  *(unsigned char *)(a1 + 294) = 0;
  metricsinfo__clear_http_status(v6);
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *(void *)(a1 + 304) = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  *(_OWORD *)(a1 + 520) = *(_OWORD *)(a2 + 80);
  uint64_t v12 = *(void *)(a2 + 104);
  *(void *)(a1 + 536) = *(void *)(a2 + 96);
  *(void *)(a1 + 552) = v12;
  *(void *)(a1 + 560) = 0;
  uint64_t v13 = *(void *)(a2 + 112);
  *(void *)(a1 + 544) = *(void *)(a2 + 120);
  *(void *)(a1 + 568) = *(void *)(a2 + 128);
  *(void *)(a1 + 576) = v13;
  *(_OWORD *)(a1 + 352) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 496) = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 512) = *(void *)(a2 + 72);
  *(_DWORD *)(a1 + 296) = 0;
  *(unsigned char *)(a1 + 416) = 0;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 136) = -1;
  uint64_t v14 = *(void **)(a2 + 152);
  if (v14)
  {
    os_retain(v14);
    uint64_t v15 = *(void *)(a2 + 152);
  }
  else
  {
    uint64_t v15 = 0;
  }
  *(void *)(a1 + 584) = v15;
  *(void *)(a1 + 592) = voucher_copy();
  *(void *)(a1 + 616) = 0;
  metricsinfo__clear_response_size(v6);
  metricsinfo__clear_timed_out(v6);
  metricsinfo__clear_bytes_written(v6);
  metricsinfo__clear_last_send_time(v6);
  metricsinfo__clear_bytes_read(v6);
  metricsinfo__clear_bytes_write_buffered(v6);
  metricsinfo__clear_actual_bytes_written(v6);
  CFUUIDRef v16 = *(const __CFUUID **)(a1 + 304);
  if (v16)
  {
    CFStringRef result = CFUUIDCreateString(v11, v16);
    if (!result) {
      return result;
    }
    CFStringRef v17 = result;
    CFHTTPMessageSetHeaderFieldValue(*(CFHTTPMessageRef *)(a2 + 8), @"x-apple-request-uuid", result);
    CFRelease(v17);
  }
  *(void *)(a1 + 408) = CFDataCreateMutable(v11, 0);
  return (CFStringRef)1;
}

uint64_t mmcs_http_context_create(void *a1, unsigned int a2, uint64_t a3)
{
  CFTypeRef v11 = 0;
  if (!a1) {
    mmcs_http_context_create_cold_1();
  }
  if (a2 - 4 <= 0xFFFFFFFC) {
    mmcs_http_context_create_cold_2();
  }
  CFStringRef v3 = (uint64_t (*)(CFTypeRef *))callbacks[15 * a2];
  if (!v3) {
    mmcs_http_context_create_cold_3();
  }
  uint64_t v4 = &callbacks[15 * a2];
  uint64_t v6 = v4[1];
  double v5 = (uint64_t (**)(CFTypeRef, uint64_t))(v4 + 1);
  if (!v6) {
    mmcs_http_context_create_cold_4();
  }
  uint64_t result = v3(&v11);
  if (result)
  {
    int v10 = (*v5)(v11, a3);
    uint64_t result = (uint64_t)v11;
    if (v10)
    {
      *a1 = v11;
      return 1;
    }
    else if (v11)
    {
      C3BaseRelease(v11);
      return 0;
    }
  }
  return result;
}

void mmcs_http_context_finalize(uint64_t a1)
{
  CFStringRef v2 = (void (*)(uint64_t))callbacks[15 * *(int *)(a1 + 16) + 14];
  if (v2) {
    v2(a1);
  }
  CFStringRef v3 = *(const void **)(a1 + 608);
  if (v3)
  {
    C3BaseRelease(v3);
    *(void *)(a1 + 608) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 600);
  if (v4)
  {
    C3BaseRelease(v4);
    *(void *)(a1 + 600) = 0;
  }
  double v5 = *(const void **)(a1 + 264);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(a1 + 264) = 0;
  uint64_t v6 = *(const void **)(a1 + 336);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(a1 + 336) = 0;
  uint64_t v7 = *(const void **)(a1 + 368);
  if (v7) {
    C3BaseRelease(v7);
  }
  *(void *)(a1 + 368) = 0;
  CFStringRef v8 = *(const void **)(a1 + 392);
  if (v8) {
    CFRelease(v8);
  }
  *(void *)(a1 + 392) = 0;
  CFStringRef v9 = *(const void **)(a1 + 328);
  if (v9) {
    CFRelease(v9);
  }
  *(void *)(a1 + 328) = 0;
  int v10 = *(const void **)(a1 + 304);
  if (v10) {
    CFRelease(v10);
  }
  *(void *)(a1 + 304) = 0;
  CFTypeRef v11 = *(void **)(a1 + 488);
  if (v11)
  {
    mmcs_metrics_http_info_release(v11);
    *(void *)(a1 + 488) = 0;
  }
  uint64_t v12 = *(const void **)(a1 + 408);
  if (v12) {
    CFRelease(v12);
  }
  *(void *)(a1 + 408) = 0;
  uint64_t v13 = *(FILE **)(a1 + 424);
  if (v13)
  {
    fclose(v13);
    *(void *)(a1 + 424) = 0;
  }
  uint64_t v14 = *(FILE **)(a1 + 432);
  if (v14)
  {
    fclose(v14);
    *(void *)(a1 + 432) = 0;
  }
  metricsinfo__set_request_url_with_cfstring(a1 + 24, 0);
  metricsinfo__set_http_error_with_cferror(a1 + 24, 0);
  socketinfo__set_interface_identifier_with_c_string(a1 + 440, 0);
  socketinfo__set_peer_address_with_c_string(a1 + 440, 0);
  *(void *)(a1 + 520) = 0;
  *(void *)(a1 + 576) = 0;
  uint64_t v15 = *(void **)(a1 + 584);
  if (v15) {
    os_release(v15);
  }
  *(void *)(a1 + 584) = 0;
  CFUUIDRef v16 = *(void **)(a1 + 592);
  if (v16) {
    os_release(v16);
  }
  *(void *)(a1 + 592) = 0;
  CFStringRef v17 = *(const void **)(a1 + 616);
  if (v17) {
    CFRelease(v17);
  }
  *(void *)(a1 + 616) = 0;
}

void mmcs_http_context_invalidate(uint64_t a1)
{
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &v3);
  CFStringRef v2 = (void (*)(uint64_t))callbacks[15 * *(int *)(a1 + 16) + 13];
  if (v2) {
    v2(a1);
  }
  mmcs_http_context_cleanup_response(a1);
  os_activity_scope_leave(&v3);
}

void mmcs_http_context_cleanup_response(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  v8.opaque[0] = 0;
  v8.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &v8);
  if (*(_DWORD *)(a1 + 56))
  {
    CFStringRef v2 = (void (*)(uint64_t))callbacks[15 * *(int *)(a1 + 16) + 12];
    if (v2) {
      v2(a1);
    }
    os_activity_scope_state_s v3 = *(const void **)(a1 + 392);
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 392) = 0;
    uint64_t v4 = *(const void **)(a1 + 408);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 408) = 0;
  }
  else
  {
    double v5 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"called before http transactionComplete");
      uint64_t v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v10 = v6;
        _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v6) {
        CFRelease(v6);
      }
    }
  }
  os_activity_scope_leave(&v8);
}

uint64_t mmcs_http_context_is_request_body_done(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 416);
}

void mmcs_http_context_set_error(uint64_t a1, __CFError *cf)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  os_activity_scope_state_s v3 = *(__CFError **)(a1 + 328);
  if (v3 != cf)
  {
    if (v3)
    {
      double v5 = mmcs_cferror_copy_description(v3);
      CFStringRef v6 = mmcs_cferror_copy_description(cf);
      uint64_t v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"stomping error %@ with %@", v5, v6);
        CFStringRef v9 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v54 = v8;
          _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v8) {
          CFRelease(v8);
        }
      }
      CFStringRef v10 = *(const void **)(a1 + 328);
      if (v10) {
        CFRelease(v10);
      }
      *(void *)(a1 + 328) = 0;
      if (v5) {
        CFRelease(v5);
      }
      if (v6) {
        CFRelease(v6);
      }
    }
    if (!cf) {
      goto LABEL_89;
    }
    unint64_t v11 = gMMCS_DebugLevel;
    if (gMMCS_DebugLevel < 3)
    {
LABEL_88:
      CFRetain(cf);
LABEL_89:
      long long v52 = cf;
LABEL_90:
      *(void *)(a1 + 328) = v52;
      return;
    }
    CFLocaleRef v12 = CFLocaleCreate(0, @"en_US");
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef DateFormatFromTemplate = CFDateFormatterCreateDateFormatFromTemplate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"yyyy/MM/dd kk:mm:ss.SSSS", 0, v12);
    CFStringRef v15 = DateFormatFromTemplate;
    if (v12 && DateFormatFromTemplate)
    {
      CFUUIDRef v16 = CFDateFormatterCreate(v13, v12, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
      CFStringRef v17 = v16;
      if (v16) {
        CFDateFormatterSetFormat(v16, v15);
      }
    }
    else
    {
      CFStringRef v17 = 0;
      int v18 = 0;
      if (!v12) {
        goto LABEL_22;
      }
    }
    CFRelease(v12);
    int v18 = v17;
LABEL_22:
    if (v15) {
      CFRelease(v15);
    }
    CFMutableArrayRef Mutable = CFStringCreateMutable(v13, 0);
    CFStringRef v20 = Mutable;
    if (!Mutable)
    {
LABEL_76:
      CFDictionaryRef v46 = CFErrorCopyUserInfo(cf);
      CFSetRef MutableCopy = CFDictionaryCreateMutableCopy(v13, 0, v46);
      CFDictionaryRef v48 = MutableCopy;
      if (v20 && MutableCopy)
      {
        CFDictionarySetValue(MutableCopy, @"debug description:mmcs_http", v20);
        CFStringRef Domain = CFErrorGetDomain(cf);
        CFIndex Code = CFErrorGetCode(cf);
        CFErrorRef v51 = CFErrorCreate(v13, Domain, Code, v48);
      }
      else
      {
        CFErrorRef v51 = 0;
        long long v52 = 0;
        if (!MutableCopy) {
          goto LABEL_81;
        }
      }
      CFRelease(v48);
      long long v52 = v51;
LABEL_81:
      if (v46) {
        CFRelease(v46);
      }
      if (v20) {
        CFRelease(v20);
      }
      if (v18) {
        CFRelease(v18);
      }
      if (v52) {
        goto LABEL_90;
      }
      goto LABEL_88;
    }
    uint64_t v21 = *(int *)(a1 + 16);
    if (v21 > 3) {
      CFIndex v22 = @"unknown mmcs_http_class";
    }
    else {
      CFIndex v22 = off_1E6C33F28[v21];
    }
    CFStringAppendFormat(Mutable, 0, @" class:%@", v22);
    CFStringRef v23 = *(__CFHTTPMessage **)(a1 + 336);
    if (v23)
    {
      CFURLRef v24 = CFHTTPMessageCopyRequestURL(v23);
      if (v24)
      {
        CFURLRef v25 = v24;
        CFStringRef v26 = CFURLGetString(v24);
        CFStringAppendFormat(v20, 0, @" url:%@", v26);
        CFRelease(v25);
      }
      if (v11 >= 4)
      {
        CFStringRef v27 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 336), @"x-apple-mme-dsid");
        if (v27)
        {
          CFStringRef v28 = v27;
          CFStringAppendFormat(v20, 0, @" x-apple-mme-dsid:%@", v27);
          CFRelease(v28);
        }
        CFStringRef v29 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 336), @"x-apple-mmcs-auth");
        if (v29)
        {
          CFStringRef v30 = v29;
          CFStringAppendFormat(v20, 0, @" x-apple-mmcs-auth:%@", v29);
          CFRelease(v30);
        }
LABEL_37:
        double v31 = *(double *)(a1 + 80);
        if (v31 == 0.0)
        {
          CFStringAppend(v20, @" start: (none)");
        }
        else
        {
          if (!v18)
          {
            if (*(double *)(a1 + 128) != 0.0)
            {
LABEL_49:
              int v34 = 1;
              goto LABEL_50;
            }
LABEL_48:
            CFStringAppend(v20, @" stop: (none)");
            goto LABEL_49;
          }
          CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(v13, v18, v31);
          if (StringWithAbsoluteTime)
          {
            CFStringRef v33 = StringWithAbsoluteTime;
            CFStringAppend(v20, @" start:");
            CFStringAppend(v20, v33);
            CFRelease(v33);
          }
        }
        double v35 = *(double *)(a1 + 128);
        if (v35 != 0.0)
        {
          if (v18)
          {
            CFStringRef v36 = CFDateFormatterCreateStringWithAbsoluteTime(v13, v18, v35);
            if (v36)
            {
              CFStringRef v37 = v36;
              CFStringAppend(v20, @" stop:");
              CFStringAppend(v20, v37);
              CFRelease(v37);
            }
          }
          goto LABEL_49;
        }
        goto LABEL_48;
      }
    }
    else if (v11 >= 4)
    {
      goto LABEL_37;
    }
    int v34 = 0;
LABEL_50:
    if (*(_DWORD *)(a1 + 68))
    {
      uint64_t http_status = metricsinfo__get_http_status(a1 + 24);
      CFStringAppendFormat(v20, 0, @" httpStatus:%d", http_status);
    }
    if (*(unsigned char *)(a1 + 152))
    {
      uint64_t bytes_written = metricsinfo__get_bytes_written(a1 + 24);
      CFStringAppendFormat(v20, 0, @" bytesWritten:%lld", bytes_written);
    }
    if (*(unsigned char *)(a1 + 208))
    {
      uint64_t v40 = metricsinfo__get_bytes_read(a1 + 24);
      CFStringAppendFormat(v20, 0, @" bytesRead:%lld", v40);
    }
    if (v34)
    {
      CFUUIDRef v41 = *(const __CFUUID **)(a1 + 304);
      if (v41)
      {
        CFStringRef v42 = CFUUIDCreateString(v13, v41);
        if (v42)
        {
          CFStringRef v43 = v42;
          CFStringAppend(v20, @" uuid:");
          CFStringAppend(v20, v43);
          CFRelease(v43);
        }
      }
    }
    uint64_t v44 = *(unsigned int *)(a1 + 296);
    if (v44 > 3) {
      uint64_t v45 = @"meandering";
    }
    else {
      uint64_t v45 = streamStatusString[v44];
    }
    CFStringAppendFormat(v20, 0, @" streamState:%@", v45);
    if (*(void *)(a1 + 464)) {
      CFStringAppendFormat(v20, 0, @" interfaceIdentifier:%s", *(void *)(a1 + 464));
    }
    if (*(void *)(a1 + 472)) {
      CFStringAppendFormat(v20, 0, @" destination:%s:%u", *(void *)(a1 + 472), *(unsigned int *)(a1 + 480));
    }
    if (*(_DWORD *)(a1 + 208)) {
      CFStringAppend(v20, @" c_finished");
    }
    if (*(_DWORD *)(a1 + 56)) {
      CFStringAppend(v20, @" transactionComplete");
    }
    if (*(_DWORD *)(a1 + 60) && metricsinfo__get_timed_out(a1 + 24)) {
      CFStringAppend(v20, @" timedOut");
    }
    if (*(unsigned char *)(a1 + 290)) {
      CFStringAppend(v20, @" cancelled");
    }
    goto LABEL_76;
  }
}

uint64_t mmcs_http_context_update_voucher(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 592);
  if (v2) {
    os_release(v2);
  }
  *(void *)(a1 + 592) = 0;
  uint64_t result = voucher_copy();
  *(void *)(a1 + 592) = result;
  return result;
}

uint64_t mmcs_http_context_set_to_mobileme(uint64_t result, char a2)
{
  *(unsigned char *)(result + 292) = a2;
  return result;
}

uint64_t mmcs_http_context_set_to_configuration(uint64_t result, char a2)
{
  *(unsigned char *)(result + 293) = a2;
  return result;
}

uint64_t mmcs_http_context_set_is_container_upload(uint64_t result, char a2)
{
  *(unsigned char *)(result + 294) = a2;
  return result;
}

uint64_t mmcs_http_context_validate_request_uuid_with_response(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 292)) {
    return 1;
  }
  CFUUIDRef v2 = *(const __CFUUID **)(a1 + 304);
  if (v2)
  {
    CFRetain(*(CFTypeRef *)(a1 + 304));
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v4 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2);
    if (v4)
    {
      CFStringRef v5 = v4;
      CFStringRef v6 = *(__CFHTTPMessage **)(a1 + 392);
      if (v6 && (CFStringRef v7 = CFHTTPMessageCopyHeaderFieldValue(v6, @"x-apple-request-uuid")) != 0)
      {
        CFStringRef v8 = v7;
        result.CFIndex location = 0;
        result.unsigned int length = 0;
        CFLocaleRef v9 = CFLocaleCreate(0, @"en_US");
        v26.unsigned int length = CFStringGetLength(v8);
        uint64_t v10 = 1;
        v26.CFIndex location = 0;
        if (!CFStringFindWithOptionsAndLocale(v8, v5, v26, 1uLL, v9, &result))
        {
          unint64_t v11 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v12 = CFStringCreateWithFormat(v3, 0, @"Context %p expected header x-apple-request-uuid: %@ got %@", a1, v5, v8);
            CFAllocatorRef v13 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v23 = v12;
              _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            }
            if (v12) {
              CFRelease(v12);
            }
          }
          uint64_t v10 = 0;
        }
        if (v9) {
          CFRelease(v9);
        }
        CFRelease(v8);
      }
      else
      {
        CFUUIDRef v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v17 = CFStringCreateWithFormat(v3, 0, @"Context %p expected header x-apple-request-uuid: %@", a1, v5);
          int v18 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LODWORD(result.location) = 138543362;
            *(CFIndex *)((char *)&result.location + 4) = (CFIndex)v17;
            _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&result, 0xCu);
          }
          if (v17) {
            CFRelease(v17);
          }
        }
        uint64_t v10 = 0;
      }
    }
    else
    {
      int v19 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = 0;
        goto LABEL_35;
      }
      CFStringRef v5 = CFStringCreateWithFormat(v3, 0, @"Context %p could not create string of request uuid", a1);
      CFStringRef v20 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        LODWORD(result.location) = 138543362;
        *(CFIndex *)((char *)&result.location + 4) = (CFIndex)v5;
        _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&result, 0xCu);
      }
      uint64_t v10 = 0;
      if (!v5) {
        goto LABEL_35;
      }
    }
    CFRelease(v5);
LABEL_35:
    CFRelease(v2);
    return v10;
  }
  uint64_t v14 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
    return 0;
  }
  CFUUIDRef v2 = (const __CFUUID *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Context %p has no request uuid", a1);
  CFStringRef v15 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LODWORD(result.location) = 138543362;
    *(CFIndex *)((char *)&result.location + 4) = (CFIndex)v2;
    _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&result, 0xCu);
  }
  uint64_t v10 = 0;
  if (v2) {
    goto LABEL_35;
  }
  return v10;
}

char *mmcs_http_context_make_metrics(char *result, const void *a2, const void *a3, uint64_t a4, char a5)
{
  if (result)
  {
    CFStringRef v5 = result;
    CFRange result = mmcs_metrics_http_info_create(a2, a3, a4, a5);
    *((void *)v5 + 61) = result;
  }
  return result;
}

void mmcs_http_context_mark_as_writing(uint64_t a1)
{
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &v3);
  CFUUIDRef v2 = (void (*)(uint64_t))callbacks[15 * *(int *)(a1 + 16) + 5];
  if (v2) {
    v2(a1);
  }
  *(_DWORD *)(a1 + 296) = 2;
  os_activity_scope_leave(&v3);
}

void mmcs_http_context_did_stop_with_error(uint64_t a1, uint64_t a2)
{
  v5.opaque[0] = 0;
  v5.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &v5);
  CFStringRef v4 = (void (*)(uint64_t, uint64_t))callbacks[15 * *(int *)(a1 + 16) + 10];
  if (v4) {
    v4(a1, a2);
  }
  os_activity_scope_leave(&v5);
}

void mmcs_http_context_should_cancel(unsigned char *a1, __CFError *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1 && !a1[288] && !a1[289] && !a1[290])
  {
    CFStringRef v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"http context %p should cancel", a1);
      CFStringRef v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v8 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
    a1[290] = 1;
    if (a2) {
      mmcs_http_context_set_error((uint64_t)a1, a2);
    }
    mmcs_http_context_did_stop_with_error((uint64_t)a1, (uint64_t)a2);
    mmcs_http_context_transaction_complete((uint64_t)a1);
  }
}

void mmcs_http_context_transaction_complete(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 56))
  {
    CFUUIDRef v2 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"http context %p already complete", a1);
      CFStringRef v4 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf.opaque[0]) = 138543362;
        *(uint64_t *)((char *)buf.opaque + 4) = (uint64_t)v3;
        _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v3) {
        CFRelease(v3);
      }
    }
  }
  else
  {
    *(CFAbsoluteTime *)(a1 + 128) = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)(a1 + 56) = 1;
    CFStringRef v5 = *(FILE **)(a1 + 432);
    if (v5)
    {
      fclose(v5);
      *(void *)(a1 + 432) = 0;
    }
    buf.opaque[0] = 0;
    buf.opaque[1] = 0;
    os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &buf);
    CFStringRef v6 = (void (*)(uint64_t))callbacks[15 * *(int *)(a1 + 16) + 11];
    if (v6) {
      v6(a1);
    }
    os_activity_scope_leave(&buf);
  }
}

void mmcs_http_context_should_stop_with_error(uint64_t a1, __CFError *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1 && !*(unsigned char *)(a1 + 288) && !*(unsigned char *)(a1 + 289))
  {
    CFStringRef v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"http context %p should stop", a1);
      CFStringRef v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v8 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
    if (a2) {
      mmcs_http_context_set_error(a1, a2);
    }
    mmcs_http_context_did_stop_with_error(a1, (uint64_t)a2);
    mmcs_http_context_transaction_complete(a1);
  }
}

BOOL mmcs_http_context_status_succeeded(uint64_t a1)
{
  return *(_DWORD *)(a1 + 68) && metricsinfo__get_http_status(a1 + 24) - 200 < 0x64;
}

__CFString *mmcs_http_get_stream_status_string(unsigned int a1)
{
  if (a1 > 3) {
    return @"meandering";
  }
  else {
    return streamStatusString[a1];
  }
}

uint64_t mmcs_http_context_actual_bytes_written(uint64_t a1)
{
  v5.opaque[0] = 0;
  v5.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &v5);
  CFUUIDRef v2 = (uint64_t (*)(uint64_t))callbacks[15 * *(int *)(a1 + 16) + 6];
  if (v2) {
    uint64_t v3 = v2(a1);
  }
  else {
    uint64_t v3 = 0;
  }
  os_activity_scope_leave(&v5);
  return v3;
}

uint64_t mmcs_http_context_actual_bytes_read(uint64_t a1)
{
  return *(void *)(a1 + 216);
}

BOOL mmcs_http_context_is_sending(uint64_t a1)
{
  return *(_DWORD *)(a1 + 296) && *(unsigned char *)(a1 + 56) == 0;
}

uint64_t mmcs_http_context_send(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &state);
  mmcs_http_context_will_reset_request(a1);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a1 + 80) = Current;
  *(CFAbsoluteTime *)(a1 + 280) = Current;
  *(CFAbsoluteTime *)(a1 + 312) = Current;
  *(CFAbsoluteTime *)(a1 + 320) = Current;
  CFStringRef v7 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))callbacks[15 * *(int *)(a1 + 16) + 3];
  if (!v7) {
    mmcs_http_context_send_cold_1();
  }
  uint64_t v8 = v7(a1, a2, a3);
  uint64_t v9 = *(__CFHTTPMessage **)(a1 + 336);
  if (*(unsigned char *)(a1 + 400))
  {
    CFStringRef v10 = CFHTTPMessageCopyHeaderFieldValue(v9, @"Content-Length");
    if (!v10)
    {
      IntCFDictionaryRef Value = -1;
      goto LABEL_10;
    }
    unint64_t v11 = v10;
    IntCFDictionaryRef Value = CFStringGetIntValue(v10);
  }
  else
  {
    CFDataRef v13 = CFHTTPMessageCopyBody(v9);
    if (!v13)
    {
      IntCFDictionaryRef Value = 0;
      goto LABEL_10;
    }
    unint64_t v11 = v13;
    IntCFDictionaryRef Value = CFDataGetLength(v13);
  }
  CFRelease(v11);
LABEL_10:
  *(void *)(a1 + 136) = IntValue;
  if (!*(void *)(a1 + 488) && gMMCS_DebugLevel < 3) {
    goto LABEL_22;
  }
  uint64_t v14 = mmcs_logging_logger_default();
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
  if (IntValue == -1)
  {
    if (!v15) {
      goto LABEL_22;
    }
    CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"context (%p) sending request with unknown length body", a1);
    CFStringRef v17 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_20;
    }
    *(_DWORD *)os_activity_scope_state_s buf = 138543362;
    CFStringRef v21 = v16;
  }
  else
  {
    if (!v15) {
      goto LABEL_22;
    }
    CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"context (%p) sending %lld body bytes", a1, *(void *)(a1 + 136));
    CFStringRef v17 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_20;
    }
    *(_DWORD *)os_activity_scope_state_s buf = 138543362;
    CFStringRef v21 = v16;
  }
  _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
LABEL_20:
  if (v16) {
    CFRelease(v16);
  }
LABEL_22:
  if (!v8)
  {
    if (!*(void *)(a1 + 328)) {
      mmcs_http_context_send_cold_2();
    }
    mmcs_http_context_transaction_complete(a1);
  }
  os_activity_scope_leave(&state);
  return v8;
}

void mmcs_http_context_will_reset_request(uint64_t a1)
{
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &v3);
  *(_DWORD *)(a1 + 296) = 0;
  *(unsigned char *)(a1 + 416) = 0;
  CFUUIDRef v2 = (void (*)(uint64_t))callbacks[15 * *(int *)(a1 + 16) + 4];
  if (v2) {
    v2(a1);
  }
  os_activity_scope_leave(&v3);
}

uint64_t mmcs_http_reset_context_for_new_stream(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFUUIDRef v2 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"context (%p) resetting for new stream", a1);
    CFStringRef v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)os_activity_scope_state_s buf = 138543362;
      CFStringRef v14 = v3;
      _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v3) {
      CFRelease(v3);
    }
  }
  *(_DWORD *)(a1 + 296) = 0;
  *(_OWORD *)(a1 + 136) = xmmword_1DC251C20;
  metricsinfo__clear_bytes_written(a1 + 24);
  *(void *)(a1 + 312) = 0;
  metricsinfo__clear_last_send_time(a1 + 24);
  metricsinfo__clear_timed_out(a1 + 24);
  metricsinfo__clear_http_status(a1 + 24);
  metricsinfo__clear_start_name_resolution(a1 + 24);
  metricsinfo__clear_stop_name_resolution(a1 + 24);
  metricsinfo__clear_response_size(a1 + 24);
  metricsinfo__clear_bytes_read(a1 + 24);
  mmcs_http_context_will_reset_request(a1);
  *(_DWORD *)(a1 + 484) = 0;
  os_activity_scope_state_s v5 = (FILE **)(a1 + 424);
  CFStringRef v6 = *(FILE **)(a1 + 424);
  if (v6)
  {
    fclose(v6);
    FILE *v5 = 0;
  }
  uint64_t result = debug_begin_writing_http_message_to_file(a1, *(__CFHTTPMessage **)(a1 + 336), (FILE **)(a1 + 424), *(const __CFString **)(a1 + 264), 0);
  if (result && !*(unsigned char *)(a1 + 400) && *v5)
  {
    CFDataRef v8 = CFHTTPMessageCopyBody(*(CFHTTPMessageRef *)(a1 + 336));
    if (v8)
    {
      CFDataRef v9 = v8;
      BytePtr = CFDataGetBytePtr(v8);
      size_t Length = CFDataGetLength(v9);
      fwrite(BytePtr, Length, 1uLL, *v5);
      CFRelease(v9);
    }
    uint64_t result = fclose(*v5);
    FILE *v5 = 0;
  }
  CFStringRef v12 = *(uint64_t (**)(uint64_t, void))(a1 + 504);
  if (v12) {
    return v12(a1, *(void *)(a1 + 576));
  }
  return result;
}

void mmcs_http_reset_response_state_for_background_retry(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  CFUUIDRef v2 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"http context %p", a1);
    CFStringRef v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)os_activity_scope_state_s buf = 138543362;
      CFStringRef v15 = v3;
      _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v3) {
      CFRelease(v3);
    }
  }
  os_activity_scope_state_s v5 = *(FILE **)(a1 + 432);
  if (v5)
  {
    fclose(v5);
    *(void *)(a1 + 432) = 0;
  }
  *(void *)(a1 + 120) = 0;
  metricsinfo__clear_start_name_resolution(a1 + 24);
  metricsinfo__clear_stop_name_resolution(a1 + 24);
  *(void *)(a1 + 280) = 0;
  *(_WORD *)(a1 + 288) = 0;
  metricsinfo__clear_timed_out(a1 + 24);
  *(_DWORD *)(a1 + 56) = 0;
  metricsinfo__clear_http_status(a1 + 24);
  CFStringRef v6 = *(void **)(a1 + 488);
  if (v6)
  {
    mmcs_metrics_http_info_release(v6);
    *(void *)(a1 + 488) = 0;
  }
  metricsinfo__clear_response_size(a1 + 24);
  *(void *)(a1 + 144) = 0;
  metricsinfo__clear_bytes_written(a1 + 24);
  *(void *)(a1 + 312) = 0;
  metricsinfo__clear_last_send_time(a1 + 24);
  metricsinfo__clear_bytes_read(a1 + 24);
  CFStringRef v7 = *(__CFData **)(a1 + 408);
  if (v7) {
    CFDataSetLength(v7, 0);
  }
  CFDataRef v8 = *(FILE **)(a1 + 432);
  if (v8)
  {
    fclose(v8);
    *(void *)(a1 + 432) = 0;
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a1 + 80) = Current;
  *(CFAbsoluteTime *)(a1 + 312) = Current;
  *(CFAbsoluteTime *)(a1 + 320) = Current;
  *(CFAbsoluteTime *)(a1 + 280) = Current;
  CFStringRef v10 = *(const void **)(a1 + 328);
  if (v10) {
    CFRelease(v10);
  }
  *(void *)(a1 + 328) = 0;
  unint64_t v11 = *(const void **)(a1 + 392);
  if (v11) {
    CFRelease(v11);
  }
  *(void *)(a1 + 392) = 0;
  CFStringRef v12 = *(void **)(a1 + 464);
  if (v12) {
    free(v12);
  }
  *(void *)(a1 + 464) = 0;
  CFDataRef v13 = *(void **)(a1 + 472);
  if (v13) {
    free(v13);
  }
  *(void *)(a1 + 472) = 0;
  *(_DWORD *)(a1 + 480) = 0;
}

size_t mmcs_http_write_request_body(uint64_t a1, const void *a2, uint64_t a3)
{
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &state);
  CFStringRef v6 = (uint64_t (*)(uint64_t, const void *, uint64_t))callbacks[15 * *(int *)(a1 + 16) + 7];
  if (v6)
  {
    uint64_t v7 = v6(a1, a2, a3);
    size_t v8 = v7;
    if (v7 >= 1)
    {
      *(void *)(a1 + 144) += v7;
      double Current = CFAbsoluteTimeGetCurrent();
      if (*(void *)(a1 + 552))
      {
        memset(v12, 0, sizeof(v12));
        mmcs_network_activity_make(v8, 0, (uint64_t)v12, *(double *)(a1 + 312), Current);
        (*(void (**)(uint64_t, os_activity_scope_state_s *, void))(a1 + 552))(a1, v12, *(void *)(a1 + 576));
      }
      *(double *)(a1 + 312) = Current;
      CFStringRef v10 = *(FILE **)(a1 + 424);
      if (v10) {
        fwrite(a2, v8, 1uLL, v10);
      }
    }
  }
  else
  {
    size_t v8 = -1;
  }
  os_activity_scope_leave(&state);
  return v8;
}

void mmcs_http_set_request_body_done(uint64_t a1)
{
  v4.opaque[0] = 0;
  v4.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &v4);
  CFUUIDRef v2 = *(FILE **)(a1 + 424);
  if (v2)
  {
    fclose(v2);
    *(void *)(a1 + 424) = 0;
  }
  *(unsigned char *)(a1 + 416) = 1;
  CFStringRef v3 = (void (*)(uint64_t))callbacks[15 * *(int *)(a1 + 16) + 8];
  if (v3) {
    v3(a1);
  }
  os_activity_scope_leave(&v4);
}

uint64_t mmcs_http_request_body_can_accept_data(uint64_t a1)
{
  v5.opaque[0] = 0;
  v5.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 584), &v5);
  CFUUIDRef v2 = (uint64_t (*)(uint64_t))callbacks[15 * *(int *)(a1 + 16) + 9];
  if (v2) {
    uint64_t v3 = v2(a1);
  }
  else {
    uint64_t v3 = 0;
  }
  os_activity_scope_leave(&v5);
  return v3;
}

__CFHTTPMessage *create_http_protobuf_message(const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const __CFURL *a6, const __CFData *a7)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (gMMCS_DebugLevel <= 4)
  {
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  }
  else
  {
    CFStringRef v14 = mmcs_logging_logger_default();
    BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v15)
    {
      CFStringRef v17 = CFStringCreateWithFormat(v16, 0, @"url: %@", a6);
      int v18 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        *(void *)&uint8_t buf[4] = v17;
        _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v17) {
        CFRelease(v17);
      }
    }
  }
  Request = CFHTTPMessageCreateRequest(v16, @"POST", a6, (CFStringRef)*MEMORY[0x1E4F18F90]);
  CFStringRef v20 = Request;
  if (Request)
  {
    CFHTTPMessageSetHeaderFieldValue(Request, @"Content-Type", @"application/vnd.com.apple.me.ubchunk+protobuf");
    CFHTTPMessageSetHeaderFieldValue(v20, @"Accept", @"application/vnd.com.apple.me.ubchunk+protobuf");
    CFHTTPMessageSetHeaderFieldValue(v20, @"x-apple-mmcs-proto-version", a1);
    CFHTTPMessageSetHeaderFieldValue(v20, @"x-mme-client-info", a2);
    CFHTTPMessageSetHeaderFieldValue(v20, @"x-apple-mmcs-dataclass", a3);
    CFStringRef value = 0;
    *(void *)os_activity_scope_state_s buf = 0;
    mmcs_report_copy_plist_header_values(buf, (CFTypeRef *)&value);
    if (*(void *)buf)
    {
      CFHTTPMessageSetHeaderFieldValue(v20, @"x-apple-mmcs-plist-version", *(CFStringRef *)buf);
      if (*(void *)buf) {
        CFRelease(*(CFTypeRef *)buf);
      }
      *(void *)os_activity_scope_state_s buf = 0;
    }
    if (value)
    {
      CFHTTPMessageSetHeaderFieldValue(v20, @"x-apple-mmcs-plist-sha256", value);
      if (value) {
        CFRelease(value);
      }
      CFStringRef value = 0;
    }
    if (a4) {
      CFHTTPMessageSetHeaderFieldValue(v20, @"x-apple-mme-dsid", a4);
    }
    if (a5) {
      CFHTTPMessageSetHeaderFieldValue(v20, @"x-apple-caller-request-uuid", a5);
    }
    CFHTTPMessageSetBody(v20, a7);
  }
  else
  {
    CFStringRef v21 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v22 = CFStringCreateWithFormat(v16, 0, @"Failed creating request to %@", a6);
      CFStringRef v23 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        *(void *)&uint8_t buf[4] = v22;
        _os_log_impl(&dword_1DC1CA000, v23, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v22) {
        CFRelease(v22);
      }
    }
  }
  return v20;
}

double mmcs_http_context_elapsed_seconds(uint64_t a1)
{
  double v1 = *(double *)(a1 + 80);
  double v2 = *(double *)(a1 + 128);
  BOOL v4 = v2 < v1 || v2 == 0.0 || v1 == 0.0;
  double result = v2 - v1;
  if (v4) {
    return 0.0;
  }
  return result;
}

double mmcs_http_context_enqueued_seconds(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v1 = *(_DWORD *)(a1 + 232);
  if (*(_DWORD *)(a1 + 248))
  {
    if (v1)
    {
      double v2 = *(double *)(a1 + 240);
    }
    else
    {
      double v2 = *(double *)(a1 + 80);
      if (v2 == 0.0) {
        return 0.0;
      }
    }
    double v4 = *(double *)(a1 + 256);
  }
  else
  {
    double v3 = 0.0;
    if (!v1) {
      return v3;
    }
    double v4 = *(double *)(a1 + 80);
    if (v4 == 0.0) {
      return v3;
    }
    double v2 = *(double *)(a1 + 240);
  }
  double v3 = v2 - v4;
  if (v2 - v4 < 0.0)
  {
    os_activity_scope_state_s v5 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"ignoring enqueued duration of %lf", *(void *)&v3);
      uint64_t v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v10 = v6;
        _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v6) {
        CFRelease(v6);
      }
    }
  }
  return v3;
}

void mmcs_http_context_name_resolution_seconds(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 88))
  {
    if (*(_DWORD *)(a1 + 104))
    {
      uint64_t v1 = a1 + 24;
      metricsinfo__get_start_name_resolution(a1 + 24);
      metricsinfo__get_stop_name_resolution(v1);
    }
  }
}

__CFString *mmcs_http_context_class_description(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 16);
  if (v1 > 3) {
    return @"unknown mmcs_http_class";
  }
  else {
    return off_1E6C33F28[v1];
  }
}

void mmcs_http_context_append_description(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(v2 + 584), &state);
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v15 = *(_OWORD *)a1;
  long long v16 = v3;
  long long v17 = *(_OWORD *)(a1 + 32);
  *((void *)&v16 + 1) = *((void *)&v3 + 1) + 1;
  if (!*(_DWORD *)(v2 + 56))
  {
    mmcs_op_requestor_context_indent(a1);
    uint64_t v4 = *(int *)(v2 + 16);
    if (v4 > 3) {
      os_activity_scope_state_s v5 = @"unknown mmcs_http_class";
    }
    else {
      os_activity_scope_state_s v5 = off_1E6C33F28[v4];
    }
    CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @"<%@ %p>", v5, v2, v15, v16, v17);
    CFStringRef v6 = *(__CFString **)(a1 + 16);
    uint64_t v7 = *(__CFHTTPMessage **)(v2 + 336);
    if (v7)
    {
      CFURLRef v8 = CFHTTPMessageCopyRequestURL(v7);
      if (v8)
      {
        CFURLRef v9 = v8;
        CFStringRef v10 = CFURLGetString(v8);
        if (v10) {
          CFStringAppend(v6, v10);
        }
        CFRelease(v9);
      }
    }
    mmcs_http_request_options_append_description(*(void *)(v2 + 368), v6);
    uint64_t v11 = *(void *)(v2 + 368);
    if (v11 && mmcs_http_request_options_is_background(v11)) {
      CFStringAppendFormat(v6, 0, @" sendSize=%llu, receiveSize=%llu", *(void *)(v2 + 352), *(void *)(v2 + 360));
    }
    uint64_t v12 = *(unsigned int *)(v2 + 296);
    if (v12 > 3) {
      CFDataRef v13 = @"meandering";
    }
    else {
      CFDataRef v13 = streamStatusString[v12];
    }
    CFStringAppendFormat(v6, 0, @" streamState=%@", v13);
    CFStringAppend(*(CFMutableStringRef *)(a1 + 16), @"\n");
    CFStringRef v14 = (void (*)(long long *))callbacks[15 * *(int *)(v2 + 16) + 2];
    if (v14) {
      v14(&v15);
    }
  }
  os_activity_scope_leave(&state);
}

CFStringRef mmcs_http_context_copy_blocked_application_header_value(uint64_t a1)
{
  uint64_t v1 = *(__CFHTTPMessage **)(a1 + 392);
  if (!v1) {
    return 0;
  }
  CFDictionaryRef v2 = CFHTTPMessageCopyAllHeaderFields(v1);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v2, @"x-apple-mmcs-blocked-apps");
  if (Value)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Value);
    if (!v2) {
      return Copy;
    }
    goto LABEL_7;
  }
  CFStringRef Copy = 0;
  if (v2) {
LABEL_7:
  }
    CFRelease(v2);
  return Copy;
}

BOOL _mmcs_http_class_cfhttpCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_http_class_cfhttpCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_http_class_cfhttpCFCopyDebugDescription()
{
  return 0;
}

BOOL _mmcs_http_class_nsurlsessionCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_http_class_nsurlsessionCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_http_class_nsurlsessionCFCopyDebugDescription()
{
  return 0;
}

BOOL _mmcs_http_class_curlCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_http_class_curlCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_http_class_curlCFCopyDebugDescription()
{
  return 0;
}

const void *mmcs_index_set_create_with_string(const __CFString *a1)
{
  CFStringRef v10 = 0;
  if (!mmcs_index_set_create((uint64_t *)&v10)) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  if (Length < 1)
  {
    CFIndex v4 = 0;
    uint64_t v7 = -1;
LABEL_14:
    int v8 = token((uint64_t)v10, a1, v4, v7, Length);
    double result = v10;
    if (v8 || !v10) {
      return result;
    }
LABEL_18:
    C3BaseRelease(result);
    return 0;
  }
  CFIndex v3 = 0;
  CFIndex v4 = 0;
  uint64_t v5 = -1;
  while (1)
  {
    int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v3);
    if (CharacterAtIndex == 45) {
      break;
    }
    if (CharacterAtIndex == 44)
    {
      if (!token((uint64_t)v10, a1, v4, v5, v3)) {
        goto LABEL_17;
      }
      CFIndex v4 = v3 + 1;
      uint64_t v7 = -1;
    }
    else
    {
      uint64_t v7 = v5;
    }
LABEL_11:
    ++v3;
    uint64_t v5 = v7;
    if (Length == v3) {
      goto LABEL_14;
    }
  }
  uint64_t v7 = v3;
  if (v5 < 0) {
    goto LABEL_11;
  }
LABEL_17:
  double result = v10;
  if (v10) {
    goto LABEL_18;
  }
  return result;
}

uint64_t token(uint64_t a1, const __CFString *a2, CFIndex a3, uint64_t a4, uint64_t a5)
{
  CFIndex v5 = a5 - a3;
  if (a5 - a3 >= 3)
  {
    CFLocaleRef v11 = CFLocaleCreate(0, @"en_US");
    if (v11)
    {
      CFLocaleRef v12 = v11;
      CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef v14 = CFNumberFormatterCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v11, kCFNumberFormatterNoStyle);
      if (!v14)
      {
        uint64_t v20 = 0;
LABEL_31:
        CFRelease(v12);
        return v20;
      }
      long long v15 = v14;
      if (a4 < 0)
      {
        rangep.CFIndex location = a3;
        rangep.unsigned int length = v5;
        CFNumberRef v21 = CFNumberFormatterCreateNumberFromString(v13, v14, a2, &rangep, 1uLL);
        LODWORD(valuePtr.location) = -1;
        if (v21)
        {
          CFNumberRef v22 = v21;
          CFNumberGetValue(v21, kCFNumberSInt32Type, &valuePtr);
          if ((LODWORD(valuePtr.location) - 100) > 0x383)
          {
            uint64_t v20 = 0;
          }
          else
          {
            mmcs_index_set_add_index(a1, valuePtr.location);
            uint64_t v20 = 1;
          }
          CFNumberRef v24 = v22;
          goto LABEL_29;
        }
        uint64_t v20 = 0;
LABEL_30:
        CFRelease(v15);
        goto LABEL_31;
      }
      rangep.CFIndex location = a3;
      rangep.unsigned int length = a4 - a3;
      valuePtr.CFIndex location = a4 + 1;
      valuePtr.unsigned int length = a5 - (a4 + 1);
      int v26 = -1;
      int v27 = -1;
      CFNumberRef v16 = CFNumberFormatterCreateNumberFromString(v13, v14, a2, &rangep, 1uLL);
      CFNumberRef v17 = CFNumberFormatterCreateNumberFromString(v13, v15, a2, &valuePtr, 1uLL);
      CFNumberRef v18 = v17;
      if (v16) {
        BOOL v19 = v17 == 0;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19)
      {
        uint64_t v20 = 0;
        if (!v16)
        {
LABEL_24:
          if (v18)
          {
            CFNumberRef v24 = v18;
LABEL_29:
            CFRelease(v24);
            goto LABEL_30;
          }
          goto LABEL_30;
        }
      }
      else
      {
        int Value = CFNumberGetValue(v16, kCFNumberSInt32Type, &v27);
        if (Value && CFNumberGetValue(v18, kCFNumberSInt32Type, &v26))
        {
          uint64_t v20 = 0;
          if (v27 >= 100 && v26 <= 999)
          {
            mmcs_index_set_add_range(a1, v27, v26);
            uint64_t v20 = 1;
          }
        }
        else
        {
          uint64_t v20 = 0;
        }
      }
      CFRelease(v16);
      goto LABEL_24;
    }
  }
  return 0;
}

uint64_t mmcs_file_extents(const char *a1, off_t *a2, void *a3, void *a4, void *a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v9 = open(a1, 0, 0);
  if (v9 < 0) {
    return 0xFFFFFFFFLL;
  }
  int v10 = v9;
  memset(v19, 0, 20);
  bzero(&v20, 0x878uLL);
  memset(&v18, 0, sizeof(v18));
  if (!fstatfs(v10, &v20) && !fstat(v10, &v18))
  {
    off_t st_size = v18.st_size;
    if (v18.st_size)
    {
      uint64_t v14 = 0;
      int v15 = 0;
      uint64_t v16 = 0;
      while (1)
      {
        *(void *)((char *)v19 + 4) = st_size;
        *(void *)((char *)&v19[1] + 4) = v16;
        if (fcntl(v10, 65, v19) == -1) {
          break;
        }
        uint64_t f_bsize = v20.f_bsize;
        v16 += *(void *)((char *)v19 + 4);
        v15 += (*(void *)((char *)v19 + 4) + (unint64_t)(v20.f_bsize - 1)) / v20.f_bsize;
        ++v14;
        st_size -= *(void *)((char *)v19 + 4);
        if (!st_size)
        {
          if (a2) {
            *a2 = v18.st_size;
          }
          if (a4) {
            *a4 = f_bsize;
          }
          if (a3) {
            *a3 = v15;
          }
          uint64_t v11 = 0;
          if (a5) {
            *a5 = v14;
          }
          goto LABEL_5;
        }
      }
    }
  }
  uint64_t v11 = 0xFFFFFFFFLL;
LABEL_5:
  close(v10);
  return v11;
}

uint64_t mmcs_perform_dispatch_timer_create(CFTypeRef *a1, _OWORD *a2, NSObject *a3)
{
  *a1 = 0;
  CFTypeRef cf = 0;
  long long v5 = a2[1];
  v10[0] = *a2;
  v10[1] = v5;
  uint64_t v6 = mmcs_perform_timer_create((uint64_t *)&cf, 2, 24, v10);
  CFTypeRef v7 = cf;
  if (v6 && cf)
  {
    int v8 = (NSObject **)*((void *)cf + 7);
    dispatch_retain(a3);
    *int v8 = a3;
    mmcs_perform_timer_set_next_fire_date((uint64_t)cf);
    C3BaseRetain(cf);
    CFTypeRef v7 = cf;
    *a1 = cf;
  }
  if (v7) {
    C3BaseRelease(v7);
  }
  return v6;
}

void mmcs_perform_dispatch_timer_finalize(uint64_t a1)
{
  uint64_t v1 = *(dispatch_object_t **)(a1 + 56);
  CFDictionaryRef v2 = v1[1];
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(v1[1]);
    v1[1] = 0;
  }
  if (*v1)
  {
    dispatch_release(*v1);
    dispatch_object_t *v1 = 0;
  }
}

double mmcs_perform_dispatch_timer_get_next_fire_date(uint64_t a1)
{
  return *(double *)(*(void *)(a1 + 56) + 16);
}

void mmcs_perform_dispatch_timer_set_next_fire_date(void *a1, double a2)
{
  uint64_t v3 = a1[7];
  *(double *)(v3 + 16) = a2;
  if (a2 >= 6.3113904e10)
  {
    dispatch_time_t v6 = -1;
  }
  else
  {
    if (a2 - CFAbsoluteTimeGetCurrent() <= 0.0)
    {
      int64_t v5 = 0;
    }
    else
    {
      double v4 = *(double *)(v3 + 16);
      int64_t v5 = (uint64_t)((v4 - CFAbsoluteTimeGetCurrent()) * 1000000000.0);
    }
    dispatch_time_t v6 = dispatch_time(0, v5);
  }
  CFTypeRef v7 = *(NSObject **)(v3 + 8);
  if (v7)
  {
    dispatch_source_set_timer(v7, v6, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
  else
  {
    *(void *)(v3 + 8) = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)v3);
    C3BaseRetain(a1);
    dispatch_set_context(*(dispatch_object_t *)(v3 + 8), a1);
    dispatch_set_finalizer_f(*(dispatch_object_t *)(v3 + 8), (dispatch_function_t)mmcs_perform_timer_context_finalize_callback);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v3 + 8), (dispatch_function_t)mmcs_perform_dispatch_timer_perform_callback);
    dispatch_source_set_timer(*(dispatch_source_t *)(v3 + 8), v6, 0xFFFFFFFFFFFFFFFFLL, 0);
    int v8 = *(NSObject **)(v3 + 8);
    dispatch_resume(v8);
  }
}

void mmcs_perform_timer_context_finalize_callback(CFTypeRef cf)
{
  if (cf) {
    C3BaseRelease(cf);
  }
}

uint64_t mmcs_perform_dispatch_timer_perform_callback(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, void))(a1 + 48))(a1, *(void *)(a1 + 24));
}

void mmcs_perform_dispatch_timer_invalidate(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  CFDictionaryRef v2 = *(NSObject **)(v1 + 8);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
  }
}

uint64_t mmcs_perform_source_create(uint64_t *a1, int a2, uint64_t a3, _OWORD *a4)
{
  *a1 = 0;
  size_t v7 = a3 + 64;
  uint64_t v8 = C3TypeRegister(&mmcs_perform_sourceGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v8, v7);
  if (result)
  {
    uint64_t v10 = result;
    *(_DWORD *)(result + 16) = a2;
    long long v11 = a4[1];
    *(_OWORD *)(result + 24) = *a4;
    *(_OWORD *)(result + 40) = v11;
    CFLocaleRef v12 = *(void (**)(void))(result + 32);
    if (v12)
    {
      if (*(void *)(result + 24)) {
        v12();
      }
    }
    *(void *)(v10 + 56) = v10 + 64;
    *a1 = v10;
    return 1;
  }
  return result;
}

uint64_t mmcs_perform_source_invalidate(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 16);
  if (v1) {
    return _performSourceCallbacks[3 * v1 + 1]();
  }
  return result;
}

uint64_t _mmcs_perform_sourceCFFinalize(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(_DWORD *)(result + 16);
  if (v2) {
    uint64_t result = ((uint64_t (*)(uint64_t))_performSourceCallbacks[3 * v2 + 2])(result);
  }
  uint64_t v3 = *(uint64_t (**)(void))(v1 + 40);
  if (v3)
  {
    uint64_t result = *(void *)(v1 + 24);
    if (result)
    {
      return v3();
    }
  }
  return result;
}

BOOL _mmcs_perform_sourceCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_perform_sourceCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_perform_sourceCFCopyDebugDescription()
{
  return 0;
}

uint64_t mmcs_item_init(uint64_t a1, uint64_t a2, unsigned __int8 *a3, const char *a4, uint64_t a5, uint64_t a6, CFErrorRef *a7, uint64_t a8)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 40) = a2;
  if (!a3)
  {
    if (a7)
    {
      LOBYTE(v29) = a2;
      CFStringRef v13 = @"NULL signature for item %lld";
      goto LABEL_8;
    }
    return 0;
  }
  int v10 = a5;
  if ((a5 & 1) != 0 && *a3 == 129)
  {
    if (a7)
    {
      LOBYTE(v29) = a2;
      CFStringRef v13 = @"signature for item %lld requires the item to be put unencrypted";
LABEL_8:
      CFIndex v14 = 40;
LABEL_9:
      CFErrorRef v15 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v14, v13, (uint64_t)a4, a5, a6, (uint64_t)a7, a8, v29);
LABEL_10:
      CFErrorRef v16 = v15;
      uint64_t result = 0;
      *a7 = v16;
      return result;
    }
    return 0;
  }
  stat v18 = mmcs_file_signature_copy(a3);
  *(void *)a1 = v18;
  if (!v18)
  {
    if (!a7) {
      return 0;
    }
    uint64_t v29 = *(void *)(a1 + 40);
    CFStringRef v13 = @"Unable to allocate signature for item %lld";
LABEL_30:
    CFIndex v14 = 37;
    goto LABEL_9;
  }
  if (a4)
  {
    BOOL v19 = strdup(a4);
    *(void *)(a1 + 8) = v19;
    if (!v19)
    {
      if (!a7) {
        return 0;
      }
      uint64_t v29 = *(void *)(a1 + 40);
      CFStringRef v13 = @"Unable to allocate token for item %lld";
      goto LABEL_30;
    }
  }
  *(void *)(a1 + 16) = -1;
  *(_DWORD *)(a1 + 32) = v10;
  *(void *)(a1 + 272) = 0;
  *(unsigned char *)(a1 + 392) = 0;
  CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *(void *)(a1 + 280) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &chunkReferenceSignatureEqualitySetCallbacks);
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 160) = a6;
  if (a6 == 2)
  {
    *(void *)(a1 + 172) = 1;
    return 1;
  }
  if (a6 == 1)
  {
    *(void *)(a1 + 164) = 1;
    return 1;
  }
  uint64_t v21 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v27 = CFStringCreateWithFormat(v20, 0, @"Invalid operation type %d", a6);
    CFStringRef v28 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)os_activity_scope_state_s buf = 138543362;
      CFStringRef v31 = v27;
      _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v27) {
      CFRelease(v27);
    }
  }
  if (a7)
  {
    CFErrorRef v15 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Invalid operation type (%d) for item %lld", v22, v23, v24, v25, v26, *(_DWORD *)(a1 + 160));
    goto LABEL_10;
  }
  return 0;
}

BOOL mmcs_item_set_chunk_instance_capacity(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 272)) {
    return 0;
  }
  *(void *)(a1 + 136) = a2;
  if (!is_mul_ok(a2, 0x68uLL)) {
    return 0;
  }
  double v4 = malloc_type_calloc(1uLL, 104 * a2, 0xAC2CBF25uLL);
  *(void *)(a1 + 272) = v4;
  return v4 != 0;
}

void mmcs_item_set_section_identifier(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 336);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 336) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 336) = cf;
  }
}

void mmcs_item_finalize(uint64_t a1)
{
  mmcs_wrapping_state_set_reference_signature_and_object(a1 + 48, 0, 0);
  mmcs_wrapping_state_set_reference_signature_and_object(a1 + 64, 0, 0);
  int v2 = *(const void **)(a1 + 200);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 200) = 0;
  }
  *(void *)(a1 + 352) = 0;
  CFTypeRef v3 = *(const void **)(a1 + 80);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 80) = 0;
  }
  double v4 = *(const void **)(a1 + 88);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 88) = 0;
  }
  int64_t v5 = *(const void **)(a1 + 112);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(a1 + 112) = 0;
  dispatch_time_t v6 = *(const void **)(a1 + 120);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(a1 + 120) = 0;
  size_t v7 = *(const void **)(a1 + 208);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(a1 + 208) = 0;
  uint64_t v8 = *(const void **)(a1 + 280);
  if (v8) {
    CFRelease(v8);
  }
  *(void *)(a1 + 280) = 0;
  int v9 = *(const void **)(a1 + 288);
  if (v9) {
    CFRelease(v9);
  }
  *(void *)(a1 + 288) = 0;
  int v10 = *(const void **)(a1 + 184);
  if (v10) {
    CFRelease(v10);
  }
  *(void *)(a1 + 184) = 0;
  long long v11 = *(const void **)(a1 + 224);
  if (v11) {
    CFRelease(v11);
  }
  *(void *)(a1 + 224) = 0;
  CFLocaleRef v12 = *(const void **)(a1 + 336);
  if (v12) {
    CFRelease(v12);
  }
  *(void *)(a1 + 336) = 0;
  CFStringRef v13 = *(const void **)(a1 + 240);
  if (v13) {
    CFRelease(v13);
  }
  *(void *)(a1 + 240) = 0;
  CFIndex v14 = *(const void **)(a1 + 192);
  if (v14) {
    CFRelease(v14);
  }
  *(void *)(a1 + 192) = 0;
  CFErrorRef v15 = *(const void **)(a1 + 360);
  if (v15) {
    CFRelease(v15);
  }
  *(void *)(a1 + 360) = 0;
  CFErrorRef v16 = *(const void **)(a1 + 368);
  if (v16) {
    C3BaseRelease(v16);
  }
  *(void *)(a1 + 368) = 0;
  CFNumberRef v17 = *(const void **)(a1 + 400);
  if (v17) {
    CFRelease(v17);
  }
  *(void *)(a1 + 400) = 0;
  stat v18 = *(void **)(a1 + 272);
  if (v18) {
    free(v18);
  }
  *(void *)(a1 + 272) = 0;
  if (*(void *)a1) {
    free(*(void **)a1);
  }
  *(void *)a1 = 0;
  BOOL v19 = *(void **)(a1 + 8);
  if (v19) {
    free(v19);
  }
  *(void *)(a1 + 8) = 0;
  CFAllocatorRef v20 = *(void **)(a1 + 128);
  if (v20) {
    free(v20);
  }
  *(void *)(a1 + 128) = 0;
}

void mmcs_item_set_MIME_type(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 200);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 200) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

uint64_t mmcs_item_set_default_reader_writer_sparse_aware(uint64_t result, uint64_t a2)
{
  *(void *)(result + 352) = a2;
  return result;
}

void mmcs_item_set_boundary_key(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 80);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 80) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 80) = cf;
  }
}

void mmcs_item_set_file_verification_key(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 88);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 88) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 88) = cf;
  }
}

CFStringRef mmcs_item_copy_description(uint64_t a1)
{
  int v2 = mmcs_file_signature_to_hexstring(*(char **)a1);
  CFDataRef v3 = *(const __CFData **)(a1 + 400);
  if (v3)
  {
    BytePtr = (char *)CFDataGetBytePtr(v3);
    int64_t v5 = mmcs_file_signature_to_hexstring(BytePtr);
  }
  else
  {
    int64_t v5 = 0;
  }
  CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<req_item %p> id:%lld sig:%s rsig:%s roff:%lld rlen:%lld wrap ref:%@ unwrap ref:%@ chunks:%lld", a1, *(void *)(a1 + 40), v2, v5, *(void *)(a1 + 376), *(void *)(a1 + 384), *(void *)(a1 + 64), *(void *)(a1 + 48), *(void *)(a1 + 144));
  if (v2) {
    free(v2);
  }
  if (v5) {
    free(v5);
  }
  return v6;
}

void mmcs_item_items_by_signature_description(uint64_t a1, CFArrayRef theArray, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a3 == 2)
  {
    double v4 = mmcs_file_signature_to_hexstring(*(char **)a1);
    CCFStringRef StringDescription = XCFDataCreateCStringDescription(*(const __CFData **)(a1 + 64));
    CFStringRef v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(a1 + 336);
      *(_DWORD *)int v9 = 138543874;
      *(void *)&v9[4] = v7;
      __int16 v10 = 2082;
      long long v11 = v4;
      __int16 v12 = 2082;
      CFStringRef v13 = CStringDescription;
      _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_INFO, "sectionId:%{public}@ sig:%{public}s ref:%{public}s", v9, 0x20u);
    }
    if (v4) {
      free(v4);
    }
    if (CStringDescription) {
      free(CStringDescription);
    }
  }
  else
  {
    *(void *)int v9 = a3;
    v15.unsigned int length = CFArrayGetCount(theArray);
    v15.CFIndex location = 0;
    CFArrayApplyFunction(theArray, v15, (CFArrayApplierFunction)_item_by_signature_description, v9);
  }
}

void _item_by_signature_description(uint64_t a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 384))
  {
    CFDataRef v3 = *(const __CFData **)(a1 + 400);
    if (v3)
    {
      BytePtr = (char *)CFDataGetBytePtr(v3);
      CCFStringRef StringDescription = mmcs_file_signature_to_hexstring(BytePtr);
    }
    else
    {
      CCFStringRef StringDescription = 0;
    }
    long long v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = *(void *)(a1 + 40);
      CFStringRef v13 = *(unsigned char **)(a1 + 376);
      uint64_t v14 = *(void *)(a1 + 384);
      int v15 = 134218754;
      uint64_t v16 = v12;
      __int16 v17 = 2080;
      stat v18 = CStringDescription;
      __int16 v19 = 2048;
      CFAllocatorRef v20 = v13;
      __int16 v21 = 2048;
      uint64_t v22 = v14;
      _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_INFO, "itemId:%llu rsig:%s itemOffset:%lld itemLength:%lld", (uint8_t *)&v15, 0x2Au);
    }
  }
  else
  {
    uint64_t v7 = mmcs_file_signature_to_hexstring(*(char **)a1);
    uint64_t v8 = 64;
    if (*a2 == 3) {
      uint64_t v8 = 48;
    }
    CCFStringRef StringDescription = XCFDataCreateCStringDescription(*(const __CFData **)(a1 + v8));
    int v9 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = *(void *)(a1 + 40);
      int v15 = 134218498;
      uint64_t v16 = v10;
      __int16 v17 = 2082;
      stat v18 = v7;
      __int16 v19 = 2082;
      CFAllocatorRef v20 = CStringDescription;
      _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_INFO, "itemId:%llu sig:%{public}s ref:%{public}s", (uint8_t *)&v15, 0x20u);
    }
    if (v7) {
      free(v7);
    }
  }
  if (CStringDescription) {
    free(CStringDescription);
  }
}

BOOL mmcs_item_itemid_equals(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 40) == *(void *)(a2 + 40);
}

uint64_t mmcs_item_itemid_hash(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

BOOL mmcs_item_equals(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t mmcs_item_signature_reference_equals(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = CKFileSignaturesEqual();
      if (result)
      {
        uint64_t result = XCFSafelyEquals(*(void *)(a1 + 64), *(void *)(a2 + 64));
        if (result) {
          return XCFSafelyEquals(*(void *)(a1 + 48), *(void *)(a2 + 48));
        }
      }
    }
  }
  return result;
}

unint64_t mmcs_item_signature_reference_hash(uint64_t **a1)
{
  uint64_t v2 = **a1;
  unint64_t v3 = (unint64_t)XCFSafelyHash(a1[8]);
  return v3 ^ (unint64_t)XCFSafelyHash(a1[6]) ^ v2;
}

void mmcs_item_set_size(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2 < 0)
    {
      double v4 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Item size must not be negative (itemid: %lld size: %lld)!\n", *(void *)(a1 + 40), a2);
        CFStringRef v6 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_activity_scope_state_s buf = 138543362;
          CFStringRef v8 = v5;
          _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v5) {
          CFRelease(v5);
        }
      }
    }
    else
    {
      *(void *)(a1 + 16) = a2;
    }
  }
}

void mmcs_item_set_padded_size(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2 < 0)
    {
      double v4 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Item padded size must not be negative (itemid: %lld size: %lld)!\n", *(void *)(a1 + 40), a2);
        CFStringRef v6 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_activity_scope_state_s buf = 138543362;
          CFStringRef v8 = v5;
          _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v5) {
          CFRelease(v5);
        }
      }
    }
    else
    {
      *(void *)(a1 + 24) = a2;
    }
  }
}

uint64_t mmcs_item_is_encrypted(char **a1)
{
  if (**a1 < 0) {
    return 0;
  }
  else {
    return (_BYTE)a1[4] & 1;
  }
}

uint64_t mmcs_item_is_metadata_only(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 216);
}

BOOL mmcs_item_is_derivative(uint64_t a1)
{
  return *(void *)(a1 + 360) != 0;
}

BOOL mmcs_item_has_requested_length_at_file_offset(uint64_t a1)
{
  return *(void *)(a1 + 384) != 0;
}

BOOL mmcs_item_needs_put(uint64_t a1)
{
  return *(uint64_t *)(a1 + 16) >= 1 && *(_DWORD *)(a1 + 164) != 7;
}

uint64_t mmcs_item_set_does_not_need_put(uint64_t result)
{
  *(void *)(result + 16) = -2;
  return result;
}

void mmcs_item_set_put_receipt_with_expiry_time(uint64_t a1, CFTypeRef cf, double a3)
{
  CFTypeRef v5 = *(CFTypeRef *)(a1 + 224);
  if (v5 != cf)
  {
    if (v5) {
      CFRelease(v5);
    }
    *(void *)(a1 + 224) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 224) = cf;
  }
  *(double *)(a1 + 232) = a3;
}

void mmcs_wrapping_state_set_reference_signature_and_object(uint64_t a1, CFTypeRef cf, CFTypeRef a3)
{
  CFTypeRef v5 = *(CFTypeRef *)a1;
  if (v5 != cf)
  {
    if (v5) {
      CFRelease(v5);
    }
    *(void *)a1 = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)a1 = cf;
  }
  CFTypeRef v7 = *(CFTypeRef *)(a1 + 8);
  if (v7 != a3)
  {
    if (v7) {
      CFRelease(v7);
    }
    *(void *)(a1 + 8) = 0;
    if (a3) {
      CFRetain(a3);
    }
    *(void *)(a1 + 8) = a3;
  }
}

uint64_t mmcs_wrapping_state_is_equal(const void **a1, const void **a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = *a2;
  if (v2 == v3) {
    return 1;
  }
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 0;
  }
  else {
    return CFEqual(v2, v3);
  }
}

const void *mmcs_wrapping_state_hash(const void **a1)
{
  uint64_t result = *a1;
  if (result) {
    return (const void *)CFHash(result);
  }
  return result;
}

void mmcs_item_set_server_error(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 240);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 240) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 240) = cf;
  }
}

uint64_t mmcs_item_add_outstanding_chunk_reference(uint64_t a1, void *a2)
{
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 280), a2)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 296) + *(unsigned int *)(a2[6] + 64);
  *(void *)(a1 + 296) = v5;
  *(void *)(a1 + 304) = v5;
  CFSetSetValue(*(CFMutableSetRef *)(a1 + 280), a2);
  return 1;
}

uint64_t mmcs_item_is_outstanding_chunk_reference(uint64_t a1, const void *a2)
{
  return CFSetContainsValue(*(CFSetRef *)(a1 + 280), a2);
}

void mmcs_item_append_put_container_error(uint64_t a1, void *value)
{
  CFMutableArrayRef Mutable = *(__CFArray **)(a1 + 184);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    *(void *)(a1 + 184) = Mutable;
  }
  CFArrayAppendValue(Mutable, value);
}

void mmcs_item_update_get_progress(uint64_t a1, unint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (gMMCS_DebugLevel >= 5)
  {
    BOOL v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Item %p received %llu bytes\n", a1, a2);
      CFStringRef v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v18 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
  }
  unint64_t v7 = *(void *)(a1 + 304);
  BOOL v8 = v7 >= a2;
  unint64_t v9 = v7 - a2;
  if (!v8)
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"outstandingChunkReferencesPlaintextSizeRequested underflow averted\n");
      uint64_t v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v18 = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
    unint64_t v9 = 0;
  }
  *(void *)(a1 + 304) = v9;
  double v13 = (double)*(unint64_t *)(a1 + 296);
  double v14 = v13 - (double)v9;
  if (v14 < 0.0) {
    double v14 = 0.0;
  }
  double v15 = v14 / v13;
  if (v15 > 1.0) {
    double v15 = 1.0;
  }
  mmcs_get_item_progress_make_state_progress(3, (uint64_t)v16, v15);
  mmcs_item_set_get_progress(a1, v16, 0, 0);
}

void mmcs_item_set_get_progress(uint64_t a1, unsigned int *a2, BOOL *a3, char *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  int v8 = *(_DWORD *)(a1 + 172);
  unsigned int v9 = *a2;
  if ((int)*a2 < v8)
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Invalid item state transition %d to %d\n", *(unsigned int *)(a1 + 172), *a2);
      uint64_t v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v22 = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
    return;
  }
  if (v8 == 5) {
    return;
  }
  BOOL v13 = v8 != v9 || *(double *)(a1 + 248) != *((double *)a2 + 1) || !*(void *)(a1 + 192) && *((void *)a2 + 2);
  if (v9 == 5)
  {
    *(_DWORD *)(a1 + 176) = v8;
    char v14 = 1;
  }
  else
  {
    char v14 = 0;
  }
  if (v8 == v9)
  {
    if (MMCSGetItemStateIsDeterminant(v8))
    {
      *(unsigned char *)(a1 + 328) = 1;
      goto LABEL_23;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 172) = v9;
  }
  *(unsigned char *)(a1 + 328) = 0;
LABEL_23:
  *(void *)(a1 + 248) = *((void *)a2 + 1);
  if (!*(void *)(a1 + 192))
  {
    double v15 = (const void *)*((void *)a2 + 2);
    if (v15)
    {
      *(void *)(a1 + 192) = CFRetain(v15);
      uint64_t v16 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        CFStringRef v17 = *(const __CFString **)(a1 + 40);
        CFStringRef v18 = MMCSPutItemStateCString(*(_DWORD *)(a1 + 168));
        *(_DWORD *)os_activity_scope_state_s buf = 134218242;
        CFStringRef v22 = v17;
        __int16 v23 = 2082;
        uint64_t v24 = v18;
        _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_INFO, "Item issue. itemId:%llu state:%{public}s", buf, 0x16u);
      }
      CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"itemId:%llu issue", *(void *)(a1 + 40));
      CFAllocatorRef v20 = mmcs_logging_logger_default();
      XCFPrint(v20, v19, *(void **)(a1 + 192));
      if (v19) {
        CFRelease(v19);
      }
    }
  }
  if (a3) {
    *a3 = v13;
  }
  if (a4) {
    *a4 = v14;
  }
}

void mmcs_item_update_get_unprogress(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (gMMCS_DebugLevel >= 5)
  {
    BOOL v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Item %p unhandling %llu bytes\n", a1, a2);
      CFStringRef v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v13 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
  }
  unint64_t v7 = *(void *)(a1 + 304) + a2;
  *(void *)(a1 + 304) = v7;
  double v8 = (double)*(unint64_t *)(a1 + 296);
  double v9 = v8 - (double)v7;
  if (v9 < 0.0) {
    double v9 = 0.0;
  }
  double v10 = v9 / v8;
  if (v10 > 1.0) {
    double v10 = 1.0;
  }
  mmcs_get_item_progress_make_state_progress(3, (uint64_t)v11, v10);
  mmcs_item_set_get_progress(a1, v11, 0, 0);
}

void mmcs_item_update_get_derivative_progress(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a1 + 312);
  unint64_t v4 = *(void *)(a1 + 320) + a2;
  *(void *)(a1 + 320) = v4;
  if (v4 >= v3) {
    double v5 = 0.9;
  }
  else {
    double v5 = (double)v4 / (double)v3 * 0.9;
  }
  mmcs_get_item_progress_make_state_progress(3, (uint64_t)v6, v5);
  mmcs_item_set_get_progress(a1, v6, 0, 0);
}

void mmcs_item_update_unget_derivative_progress(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 312);
  unint64_t v3 = *(void *)(a1 + 320);
  BOOL v5 = v3 >= a2;
  unint64_t v6 = v3 - a2;
  if (v5) {
    unint64_t v7 = v6;
  }
  else {
    unint64_t v7 = 0;
  }
  *(void *)(a1 + 320) = v7;
  if (v7 >= v4) {
    double v8 = 0.9;
  }
  else {
    double v8 = (double)v7 / (double)v4 * 0.9;
  }
  mmcs_get_item_progress_make_state_progress(3, (uint64_t)v9, v8);
  mmcs_item_set_get_progress(a1, v9, 0, 0);
}

void mmcs_item_remove_all_outstanding_chunk_reference(uint64_t a1)
{
}

uint64_t mmcs_item_remove_outstanding_chunk_reference(uint64_t a1, const void *a2)
{
  uint64_t result = CFSetContainsValue(*(CFSetRef *)(a1 + 280), a2);
  if (result)
  {
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 280), a2);
    return 1;
  }
  return result;
}

void mmcs_item_chunk_instance_was_read(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 160) == 1 && (*(_DWORD *)(a1 + 164) - 3) <= 1)
  {
    unint64_t v5 = *(void *)(a1 + 304);
    BOOL v6 = v5 >= a3;
    unint64_t v7 = v5 - a3;
    if (!v6)
    {
      double v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"outstandingChunkReferencesPlaintextSizeRequested underflow averted\n");
        double v10 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_activity_scope_state_s buf = 138543362;
          CFStringRef v18 = v9;
          _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v9) {
          CFRelease(v9);
        }
      }
      unint64_t v7 = 0;
    }
    *(void *)(a1 + 304) = v7;
    double v11 = (double)*(unint64_t *)(a1 + 296);
    double v12 = v11 - (double)v7;
    if (v12 < 0.0) {
      double v12 = 0.0;
    }
    double v13 = v12 / v11;
    if (v13 > 1.0) {
      double v13 = 1.0;
    }
    uint64_t v14 = *(char **)a1;
    uint64_t v15 = *(void *)(a1 + 64);
    mmcs_put_item_progress_make_state_progress(4, (uint64_t)v16, v13);
    mmcs_put_request_set_progress_for_items_with_signature_reference(a2, v14, v15, (uint64_t)v16);
  }
}

void mmcs_item_chunk_instance_was_unread(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 160) == 1 && *(_DWORD *)(a1 + 164) == 4)
  {
    unint64_t v5 = *(void *)(a1 + 296);
    unint64_t v6 = *(void *)(a1 + 304) + a3;
    *(void *)(a1 + 304) = v6;
    if (v5 < v6)
    {
      unint64_t v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"outstandingChunkReferencesPlaintextSizeRequested overflow averted\n");
        CFStringRef v9 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_activity_scope_state_s buf = 138543362;
          CFStringRef v16 = v8;
          _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v8) {
          CFRelease(v8);
        }
      }
      unint64_t v6 = *(void *)(a1 + 296);
      *(void *)(a1 + 304) = v6;
      unint64_t v5 = v6;
    }
    double v10 = (double)v5 - (double)v6;
    if (v10 < 0.0) {
      double v10 = 0.0;
    }
    double v11 = v10 / (double)v5;
    if (v11 > 1.0) {
      double v11 = 1.0;
    }
    double v12 = *(char **)a1;
    uint64_t v13 = *(void *)(a1 + 64);
    mmcs_put_item_progress_make_state_progress(4, (uint64_t)v14, v11);
    mmcs_put_request_set_progress_for_items_with_signature_reference(a2, v12, v13, (uint64_t)v14);
  }
}

BOOL mmcs_item_copy_chunk_instances_from_item(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 400))
  {
    *(unsigned char *)(a1 + 392) = 1;
    unint64_t v4 = mmcs_item_calculate_chunks_in_requested_range(a2, (void *)a1);
    uint64_t start_chunk_index_for_inner_item = mmcs_item_get_start_chunk_index_for_inner_item(a2, a1);
  }
  else
  {
    uint64_t start_chunk_index_for_inner_item = 0;
    unint64_t v4 = *(void *)(a2 + 144);
  }
  if (mmcs_item_set_chunk_instance_capacity(a1, v4))
  {
    if (*(void *)(a1 + 144)) {
      mmcs_item_copy_chunk_instances_from_item_cold_4();
    }
    if (v4)
    {
      uint64_t v6 = 0;
      uint64_t v19 = *MEMORY[0x1E4F1CFD0];
      uint64_t v7 = 104 * start_chunk_index_for_inner_item;
      do
      {
        uint64_t v8 = *(void *)(a2 + 272);
        if (*(void *)(v8 + v7 + 8) != a2) {
          mmcs_item_copy_chunk_instances_from_item_cold_3();
        }
        uint64_t v9 = *(void *)(a1 + 272);
        uint64_t v10 = *(void *)(a1 + 144);
        uint64_t v11 = v9 + 104 * v10;
        uint64_t v13 = *(void *)(v11 + 72);
        double v12 = (void *)(v11 + 72);
        if (v13) {
          mmcs_item_copy_chunk_instances_from_item_cold_2();
        }
        if (!*(void *)(a1 + 400) && v6 != *(void *)(v8 + v7 + 32)) {
          mmcs_item_copy_chunk_instances_from_item_cold_1();
        }
        uint64_t v14 = v8 + v7;
        mmcs_chunk_instance_init_with_source_instance(v9 + 104 * v10, v8 + v7, *(void *)(v8 + v7 + 56), v6, *(_DWORD *)(v8 + v7 + 24), a1);
        mmcs_chunk_reference_add_instance(*(void *)(v14 + 56), (const void *)(v9 + 104 * v10));
        ++*(void *)(a1 + 144);
        mmcs_item_add_outstanding_chunk_reference(a1, *(void **)(v9 + 104 * v10 + 56));
        void *v12 = v19;
        ++*(void *)(a1 + 152);
        v6 += *(unsigned int *)(*(void *)(v14 + 56) + 4);
        v7 += 104;
        --v4;
      }
      while (v4);
    }
    return 1;
  }
  else
  {
    CFStringRef v16 = mmcs_logging_logger_default();
    BOOL result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (result)
    {
      CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to set chunk instance capacity for item %lld\n", *(void *)(a1 + 40));
      CFStringRef v18 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v21 = v17;
        _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v17) {
        CFRelease(v17);
      }
      return 0;
    }
  }
  return result;
}

uint64_t mmcs_item_calculate_chunks_in_requested_range(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[48];
  if (!v2) {
    mmcs_item_calculate_chunks_in_requested_range_cold_1();
  }
  if (!a2[50]) {
    mmcs_item_calculate_chunks_in_requested_range_cold_2();
  }
  if (!*(void *)(a1 + 144)) {
    return 0;
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  char v7 = 0;
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  unint64_t v10 = a2[47] + v2;
  do
  {
    uint64_t v11 = *(void *)(a1 + 272) + v5;
    if (!mmcs_chunk_instance_is_chunk_reference((_DWORD *)v11)) {
      mmcs_item_calculate_chunks_in_requested_range_cold_3();
    }
    unint64_t v12 = v9 + *(unsigned int *)(*(void *)(v11 + 56) + 4);
    if (v12 <= a2[47] || v9 >= v10)
    {
      if (v7) {
        return v8;
      }
    }
    else
    {
      ++v8;
    }
    if (v12 >= v10) {
      char v7 = 1;
    }
    ++v6;
    v5 += 104;
    v9 += *(unsigned int *)(*(void *)(v11 + 56) + 4);
  }
  while (v6 < *(void *)(a1 + 144));
  return v8;
}

uint64_t mmcs_item_get_start_chunk_index_for_inner_item(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 392)) {
    mmcs_item_get_start_chunk_index_for_inner_item_cold_5();
  }
  if (!*(unsigned char *)(a2 + 392)) {
    mmcs_item_get_start_chunk_index_for_inner_item_cold_1();
  }
  uint64_t v2 = *(void *)(a1 + 136);
  if (!v2) {
LABEL_13:
  }
    mmcs_item_get_start_chunk_index_for_inner_item_cold_2();
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  unint64_t v5 = *(void *)(a2 + 376);
  uint64_t v6 = *(void *)(a1 + 272) + 56;
  while (1)
  {
    if (*(void *)(v6 - 48) != a1) {
      mmcs_item_get_start_chunk_index_for_inner_item_cold_4();
    }
    if (!*(unsigned char *)(*(void *)v6 + 64)) {
      mmcs_item_get_start_chunk_index_for_inner_item_cold_3();
    }
    unint64_t v7 = v4 + *(unsigned int *)(*(void *)v6 + 4);
    if (v7 > v5 && v4 < *(void *)(a2 + 384) + v5) {
      return v3;
    }
    ++v3;
    v6 += 104;
    unint64_t v4 = v7;
    if (v2 == v3) {
      goto LABEL_13;
    }
  }
}

uint64_t mmcs_item_copy_ford_state_from_item(void *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 392)) {
    mmcs_item_copy_ford_state_from_item_cold_4();
  }
  if (!a1[50]) {
    mmcs_item_set_file_verification_key((uint64_t)a1, *(CFTypeRef *)(a2 + 88));
  }
  uint64_t v4 = *(void *)(a2 + 144);
  uint64_t v5 = a1[50];
  if (v4 != a1[18])
  {
    if (!v5) {
      mmcs_item_copy_ford_state_from_item_cold_3();
    }
LABEL_9:
    uint64_t result = mmcs_item_get_start_chunk_index_for_inner_item(a2, (uint64_t)a1);
    uint64_t v4 = a1[18];
    if (!v4) {
      return result;
    }
    goto LABEL_10;
  }
  if (v5) {
    goto LABEL_9;
  }
  uint64_t result = 0;
  if (!v4) {
    return result;
  }
LABEL_10:
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = *(void *)(a2 + 272) + 104 * result;
  do
  {
    if (*(void *)(v9 + v7 + 8) != a2) {
      mmcs_item_copy_ford_state_from_item_cold_2();
    }
    uint64_t v10 = a1[34] + v7;
    if (*(void **)(v10 + 8) != a1) {
      mmcs_item_copy_ford_state_from_item_cold_1();
    }
    *(void *)(v10 + 32) = v8;
    v8 += *(unsigned int *)(*(void *)(v9 + v7 + 56) + 4);
    v7 += 104;
    --v4;
  }
  while (v4);
  return result;
}

uint64_t mmcs_item_file_verification_key(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

char *mmcs_item_append_chunk_instance(char **a1, uint64_t a2, CFErrorRef *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (a3) {
    *a3 = 0;
  }
  unint64_t v6 = (unint64_t)a1[18];
  if (v6 < (unint64_t)a1[17])
  {
    uint64_t v7 = *a1;
    BOOL v9 = (**a1 & 8) == 0 && (**a1 & 0x7F) != 4;
    if ((((**(unsigned char **)(a2 + 8) & 0x7F) == 4) ^ v9))
    {
      uint64_t v10 = a1[34];
      uint64_t v11 = &v10[104 * v6];
      if (v6) {
        uint64_t v12 = *(void *)&v10[104 * v6 - 72] + *(unsigned int *)(*(void *)&v10[104 * v6 - 48] + 4);
      }
      else {
        uint64_t v12 = 0;
      }
      if (mmcs_chunk_instance_init((uint64_t)v11, a2, v12, v6, (uint64_t)a1))
      {
        mmcs_chunk_reference_add_instance(a2, v11);
        ++a1[18];
        return v11;
      }
      if (a3)
      {
        CFStringRef v21 = @"mmcs_chunk_instance_init";
        CFIndex v22 = 37;
        goto LABEL_20;
      }
    }
    else if (a3)
    {
      __int16 v23 = mmcs_file_signature_to_hexstring(v7);
      uint64_t v24 = mmcs_chunk_signature_to_hexstring(*(char **)(a2 + 8));
      *a3 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Observed inconsistent encryption type between item signature %s and chunk signature %s.", v25, v26, v27, v28, v29, (char)v23);
      if (v23) {
        free(v23);
      }
      if (v24) {
        free(v24);
      }
    }
    return 0;
  }
  uint64_t v13 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"chunk instance overflow\n");
    CFAllocatorRef v20 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)os_activity_scope_state_s buf = 138543362;
      CFStringRef v33 = v19;
      _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v19) {
      CFRelease(v19);
    }
  }
  if (!a3) {
    return 0;
  }
  CFStringRef v31 = a1[17];
  CFStringRef v21 = @"Unable to append chunk instance; capacity %llu exceeded.";
  CFIndex v22 = 6;
LABEL_20:
  uint64_t v11 = 0;
  *a3 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v22, v21, v14, v15, v16, v17, v18, (char)v31);
  return v11;
}

void mmcs_item_setup_chunk_references(void *a1)
{
  if (!a1[19])
  {
    if (a1[18])
    {
      uint64_t v2 = 0;
      unint64_t v3 = 0;
      unint64_t v4 = 0;
      unint64_t v17 = 0;
      int v5 = 0;
      unint64_t v14 = a1[48] + a1[47];
      uint64_t v15 = 0;
      uint64_t v16 = *MEMORY[0x1E4F1CFC8];
      uint64_t v6 = *MEMORY[0x1E4F1CFD0];
      do
      {
        uint64_t v7 = a1[34];
        if (!mmcs_chunk_instance_is_chunk_reference((_DWORD *)(v7 + v2))) {
          mmcs_item_setup_chunk_references_cold_1();
        }
        uint64_t v8 = *(void *)(v7 + v2 + 56);
        uint64_t v9 = *(unsigned int *)(v8 + 4);
        if (a1[48])
        {
          if (a1[50])
          {
            *(void *)(v7 + v2 + 32) = 0;
            uint64_t v10 = v16;
          }
          else
          {
            ++a1[19];
            uint64_t v10 = v6;
          }
          *(void *)(v7 + v2 + 72) = v10;
          if (v4 + v9 > a1[47])
          {
            unint64_t v11 = v17;
            if (!v5) {
              unint64_t v11 = v4;
            }
            unint64_t v17 = v11;
            if (v4 < v14)
            {
              mmcs_item_add_outstanding_chunk_reference((uint64_t)a1, (void *)v8);
              if (a1[50])
              {
                *(void *)(v7 + v2 + 72) = v6;
                ++a1[19];
                *(void *)(v7 + v2 + 32) = v15;
              }
              v15 += v9;
            }
            int v5 = 1;
          }
        }
        else
        {
          mmcs_item_add_outstanding_chunk_reference((uint64_t)a1, (void *)v8);
          *(void *)(v7 + v2 + 72) = v6;
          ++a1[19];
        }
        ++v3;
        v2 += 104;
        v4 += v9;
      }
      while (v3 < a1[18]);
    }
    else
    {
      unint64_t v17 = 0;
      uint64_t v15 = 0;
    }
    if (a1[50])
    {
      if (a1[47] != v17)
      {
        CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 45, @"requestedFileOffset is expected to align with chunks when a signature is validated");
        mmcs_get_item_progress_make_done_error((uint64_t)error, v18);
      }
      if (a1[48] != v15)
      {
        CFErrorRef v13 = mmcs_cferror_create_error(@"com.apple.mmcs", 45, @"requestedLengthAtFileOffset is expected to align with chunks when a signature is validated");
        mmcs_get_item_progress_make_done_error((uint64_t)v13, v18);
      }
    }
    else
    {
      a1[47] = v17;
      a1[48] = v15;
    }
  }
}

void mmcs_item_setup_item_size(uint64_t a1)
{
  if (*(void *)(a1 + 144))
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(a1 + 272);
      CFBooleanRef v6 = *(const __CFBoolean **)(v5 + v2 + 72);
      if (!v6) {
        mmcs_item_setup_item_size_cold_1();
      }
      if (CFBooleanGetValue(v6)) {
        v3 += *(unsigned int *)(*(void *)(v5 + v2 + 56) + 4);
      }
      ++v4;
      v2 += 104;
    }
    while (v4 < *(void *)(a1 + 144));
  }
  else
  {
    uint64_t v3 = 0;
  }
  mmcs_item_set_size(a1, v3);
}

void mmcs_item_setup_item_padded_size(uint64_t a1)
{
  if (*(void *)(a1 + 144))
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(a1 + 272);
      CFBooleanRef v6 = *(const __CFBoolean **)(v5 + v2 + 72);
      if (!v6) {
        mmcs_item_setup_item_padded_size_cold_1();
      }
      if (CFBooleanGetValue(v6)) {
        v3 += *(unsigned int *)(v5 + v2 + 64);
      }
      ++v4;
      v2 += 104;
    }
    while (v4 < *(void *)(a1 + 144));
  }
  else
  {
    uint64_t v3 = 0;
  }
  mmcs_item_set_padded_size(a1, v3);
}

CFBooleanRef mmcs_item_get_default_reader_writer_sparse_aware(uint64_t a1)
{
  CFBooleanRef result = *(const __CFBoolean **)(a1 + 352);
  if (result) {
    return (const __CFBoolean *)(CFBooleanGetValue(result) != 0);
  }
  return result;
}

CFIndex mmcs_item_has_outstanding_chunk_references(uint64_t a1)
{
  CFIndex result = CFSetGetCount(*(CFSetRef *)(a1 + 280));
  if (result) {
    return *(void *)(a1 + 360) == 0;
  }
  return result;
}

void mmcs_item_set_get_chunk_references(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 288);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 288) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 288) = cf;
  }
}

void mmcs_item_add_get_chunk_references(uint64_t a1, CFSetRef theSet)
{
  if (theSet && CFSetGetCount(theSet) >= 1)
  {
    CFMutableSetRef Mutable = *(CFMutableSetRef *)(a1 + 288);
    if (!Mutable)
    {
      CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &chunkReferenceSignatureEqualitySetCallbacks);
      *(void *)(a1 + 288) = Mutable;
    }
    XCFSetAddValuesFromSet(Mutable, theSet);
  }
}

CFSetRef mmcs_item_needs_auth_get_chunks(uint64_t a1)
{
  CFSetRef result = *(const __CFSet **)(a1 + 288);
  if (result) {
    return (const __CFSet *)(CFSetGetCount(result) > 0);
  }
  return result;
}

void mmcs_item_set_put_progress(uint64_t a1, unsigned int *a2, BOOL *a3, char *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  int v8 = *(_DWORD *)(a1 + 164);
  unsigned int v9 = *a2;
  if ((int)*a2 < v8)
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Invalid item state transition %d to %d\n", *(unsigned int *)(a1 + 164), *a2);
      uint64_t v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v22 = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
    return;
  }
  if (v8 == 7) {
    return;
  }
  BOOL v13 = v8 != v9 || *(double *)(a1 + 248) != *((double *)a2 + 1) || !*(void *)(a1 + 192) && *((void *)a2 + 4);
  if (v9 == 7)
  {
    *(_DWORD *)(a1 + 168) = v8;
    char v14 = 1;
  }
  else
  {
    char v14 = 0;
  }
  if (v8 == v9)
  {
    if (MMCSPutItemStateIsDeterminant(v8))
    {
      *(unsigned char *)(a1 + 328) = 1;
      goto LABEL_23;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 164) = v9;
  }
  *(unsigned char *)(a1 + 328) = 0;
LABEL_23:
  *(void *)(a1 + 248) = *((void *)a2 + 1);
  if (!*(void *)(a1 + 192))
  {
    uint64_t v15 = (const void *)*((void *)a2 + 4);
    if (v15)
    {
      *(void *)(a1 + 192) = CFRetain(v15);
      uint64_t v16 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        CFStringRef v17 = *(const __CFString **)(a1 + 40);
        uint64_t v18 = MMCSPutItemStateCString(*(_DWORD *)(a1 + 168));
        *(_DWORD *)os_activity_scope_state_s buf = 134218242;
        CFStringRef v22 = v17;
        __int16 v23 = 2082;
        uint64_t v24 = v18;
        _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_INFO, "Item issue. itemId:%llu state:%{public}s", buf, 0x16u);
      }
      CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"itemId:%llu issue", *(void *)(a1 + 40));
      CFAllocatorRef v20 = mmcs_logging_logger_default();
      XCFPrint(v20, v19, *(void **)(a1 + 192));
      if (v19) {
        CFRelease(v19);
      }
    }
  }
  if (a3) {
    *a3 = v13;
  }
  if (a4) {
    *a4 = v14;
  }
}

double mmcs_item_chunking_elapsed_seconds(uint64_t a1)
{
  double v1 = *(double *)(a1 + 256);
  double result = 0.0;
  if (v1 != 0.0)
  {
    double v3 = *(double *)(a1 + 264);
    BOOL v4 = v3 < v1 || v3 == 0.0;
    double result = v3 - v1;
    if (v4) {
      return 0.0;
    }
  }
  return result;
}

uint64_t mmcs_item_padded_length(uint64_t *a1)
{
  if (!a1) {
    mmcs_item_padded_length_cold_1();
  }
  if (!a1[18]) {
    return 0;
  }
  unint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 56;
  do
  {
    v3 += mmcs_padded_chunk_length_with_policy_and_chunk_length(a1[12], *(unsigned int *)(*(void *)(a1[34] + v4) + 4));
    ++v2;
    v4 += 104;
  }
  while (v2 < a1[18]);
  return v3;
}

uint64_t mmcs_item_padded_chunk_length(uint64_t a1, uint64_t a2)
{
  return mmcs_padded_chunk_length_with_policy_and_chunk_length(*(void *)(a1 + 96), a2);
}

__CFDictionary *mmcs_item_create_results_dictionary_for_item(uint64_t *a1)
{
  if (a1[18])
  {
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v4 = a1[19];
    if (!v4) {
      uint64_t v4 = a1[18];
    }
    uint64_t valuePtr = v4;
    CFNumberRef v5 = CFNumberCreate(v2, kCFNumberSInt64Type, &valuePtr);
    CFDictionarySetValue(Mutable, @"kMMCSChunkCount", v5);
    if (v5) {
      CFRelease(v5);
    }
    CFBooleanRef v6 = a1 + 2;
    if (a1[2] <= 0)
    {
LABEL_14:
      int v8 = a1 + 3;
      if (a1[3] <= 0) {
        goto LABEL_22;
      }
      if (Mutable)
      {
LABEL_20:
        uint64_t valuePtr = 0;
        uint64_t valuePtr = *v8;
        CFNumberRef v9 = CFNumberCreate(v2, kCFNumberSInt64Type, &valuePtr);
        CFDictionarySetValue(Mutable, @"kMMCSPaddedFileSize", v9);
        if (v9) {
          CFRelease(v9);
        }
LABEL_22:
        if (!a1[48]) {
          goto LABEL_29;
        }
        uint64_t v10 = a1 + 48;
        if (Mutable) {
          goto LABEL_25;
        }
        goto LABEL_24;
      }
LABEL_19:
      CFMutableSetRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      goto LABEL_20;
    }
    if (Mutable)
    {
LABEL_12:
      uint64_t valuePtr = 0;
      uint64_t valuePtr = *v6;
      CFNumberRef v7 = CFNumberCreate(v2, kCFNumberSInt64Type, &valuePtr);
      CFDictionarySetValue(Mutable, @"kMMCSFileSize", v7);
      if (v7) {
        CFRelease(v7);
      }
      goto LABEL_14;
    }
LABEL_11:
    CFMutableSetRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    goto LABEL_12;
  }
  CFBooleanRef v6 = a1 + 2;
  if (a1[2] >= 1)
  {
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    goto LABEL_11;
  }
  int v8 = a1 + 3;
  if (a1[3] >= 1)
  {
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    goto LABEL_19;
  }
  if (!a1[48])
  {
    CFMutableSetRef Mutable = 0;
    goto LABEL_29;
  }
  uint64_t v10 = a1 + 48;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
LABEL_24:
  CFMutableSetRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
LABEL_25:
  uint64_t valuePtr = a1[47];
  CFNumberRef v11 = CFNumberCreate(v2, kCFNumberSInt64Type, &valuePtr);
  CFDictionarySetValue(Mutable, @"kMMCSResultFileOffset", v11);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t valuePtr = 0;
  uint64_t valuePtr = *v10;
  CFNumberRef v12 = CFNumberCreate(v2, kCFNumberSInt64Type, &valuePtr);
  CFDictionarySetValue(Mutable, @"kMMCSResultLengthAtFileOffset", v12);
  if (v12) {
    CFRelease(v12);
  }
LABEL_29:
  BOOL v13 = (const void *)a1[11];
  if (v13) {
    CFDictionarySetValue(Mutable, @"kMMCSVerificationKey", v13);
  }
  return Mutable;
}

__CFData *mmcs_item_create_chunk_key_concatenation(uint64_t a1)
{
  CFMutableSetRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (*(void *)(a1 + 144))
  {
    unint64_t v3 = 0;
    uint64_t v4 = 56;
    do
    {
      CFNumberRef v5 = *(const UInt8 **)(*(void *)(*(void *)(a1 + 272) + v4) + 16);
      CFIndex v6 = CKChunkSchemeAndEncryptionKeySize();
      CFDataAppendBytes(Mutable, v5, v6);
      ++v3;
      v4 += 104;
    }
    while (v3 < *(void *)(a1 + 144));
  }
  return Mutable;
}

uint64_t mmcs_item_chunk_key_at_index(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(*(void *)(a1 + 272) + 104 * a2 + 56) + 16);
}

uint64_t mmcs_item_get_file_signature_scheme_for_derivative_validation()
{
  return 129;
}

uint64_t mmcs_item_create_arguments_for_derivative_validation_signature_generator()
{
  return 0;
}

CFTypeRef mmcs_item_set_derivative_digest_results_for_file_validation(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 368);
  if (v4) {
    C3BaseRelease(v4);
  }
  *(void *)(a1 + 368) = 0;
  CFTypeRef result = C3BaseRetain(cf);
  *(void *)(a1 + 368) = cf;
  return result;
}

uint64_t mmcs_item_signature(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t mmcs_item_padding_policy(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t mmcs_item_chunk_count(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

uint64_t mmcs_item_chunk_length_at_index(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 272) + 104 * a2 + 56) + 4);
}

uint64_t mmcs_item_chunk_signature_at_index(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(*(void *)(a1 + 272) + 104 * a2 + 56) + 8);
}

uint64_t mmcs_item_chunk_subchunk_digest_at_index(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(*(void *)(a1 + 272) + 104 * a2 + 56) + 32);
}

uint64_t mmcs_item_ranged_items(uint64_t a1)
{
  return *(void *)(a1 + 120);
}

void *mmcs_report_tickle(void *result)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (gMMCS_MobileMeReporting)
  {
    double v1 = result;
    double Current = CFAbsoluteTimeGetCurrent();
    pthread_mutex_lock(&sReportingInfoAccessLock);
    if (gMMCS_MobileMeReporting)
    {
      double v3 = *(double *)(gMMCS_MobileMeReporting + 48);
      BOOL v4 = v3 != 0.0 && Current - v3 > *(double *)(gMMCS_MobileMeReporting + 32);
      if (v3 == 0.0 && Current - *(double *)(gMMCS_MobileMeReporting + 56) > *(double *)(gMMCS_MobileMeReporting + 40)
        || v4)
      {
        if (*(unsigned char *)(gMMCS_MobileMeReporting + 64))
        {
          CFNumberRef v5 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Background fetch for MobileMe configs is already underway.");
            CFNumberRef v7 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)os_activity_scope_state_s buf = 138543362;
              CFStringRef v13 = v6;
              _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v6) {
              CFRelease(v6);
            }
          }
        }
        else
        {
          pthread_t v11 = 0;
          int v8 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Scheduling fetch for MobileMe configs.");
            uint64_t v10 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)os_activity_scope_state_s buf = 138543362;
              CFStringRef v13 = v9;
              _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v9) {
              CFRelease(v9);
            }
          }
          *(unsigned char *)(gMMCS_MobileMeReporting + 64) = 1;
          C3BaseRetain(v1);
          pthread_create(&v11, 0, (void *(__cdecl *)(void *))_mmcs_report_fetchFromMobileMe, v1);
        }
      }
    }
    return (void *)pthread_mutex_unlock(&sReportingInfoAccessLock);
  }
  return result;
}

uint64_t _mmcs_report_fetchFromMobileMe(const void *a1)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = _os_activity_create(&dword_1DC1CA000, "mmcs-fetch-plist", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v2, &state);
  double v3 = mmcs_logging_logger_default();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v4)
  {
    CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_config_fetcher started.");
    CFNumberRef v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v6;
      _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
    }
    if (v6) {
      CFRelease(v6);
    }
  }
  CFURLRef v8 = CFURLCreateWithString(v5, @"https://gateway.icloud.com/configuration/configurations/internetservices/mobileme/content/content-1.0.plist", 0);
  if (v8)
  {
    CFURLRef v9 = v8;
    Request = CFHTTPMessageCreateRequest(v5, @"GET", v8, (CFStringRef)*MEMORY[0x1E4F18F90]);
    CFRelease(v9);
    if (!Request) {
      goto LABEL_31;
    }
    CFStringRef client_header_value = mmcs_engine_create_client_header_value(0);
    if (client_header_value)
    {
      CFStringRef v12 = client_header_value;
      CFHTTPMessageSetHeaderFieldValue(Request, @"x-mme-client-info", client_header_value);
      CFRelease(v12);
    }
    CFRunLoopRef Current = CFRunLoopGetCurrent();
    CFRetain(Current);
    *(void *)&long long buf = @"content_plist";
    *((void *)&buf + 1) = Request;
    uint64_t v29 = a1;
    long long v30 = xmmword_1DC251DE0;
    uint64_t v31 = -1;
    uint64_t v32 = -1;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v33 = 0;
    CFStringRef v36 = mmcs_reporting_fetch_operation_http_callback;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v42 = 0;
    CFRunLoopRef v40 = Current;
    uint64_t v41 = 0;
    uint64_t v43 = 1;
    uint64_t v44 = 0;
    uint64_t v45 = v2;
    CFTypeRef cf = 0;
    unsigned int v14 = mmcs_http_class_default_value(2);
    if (!mmcs_http_context_create(&cf, v14, (uint64_t)&buf)) {
      goto LABEL_30;
    }
    C3BaseRetain(cf);
    mmcs_http_context_set_to_configuration((uint64_t)cf, 1);
    mmcs_http_context_set_to_mobileme((uint64_t)cf, 1);
    pthread_mutex_lock(&sReportingInfoAccessLock);
    if (gMMCS_MobileMeReporting && !*(void *)(gMMCS_MobileMeReporting + 16))
    {
      *(void *)(gMMCS_MobileMeReporting + 16) = cf;
      pthread_mutex_unlock(&sReportingInfoAccessLock);
      CFArrayRef v18 = CFArrayCreate(v5, MEMORY[0x1E4F1D410], 1, MEMORY[0x1E4F1D510]);
      uint64_t v25 = 0;
      mmcs_perform_run_loop_target_create((uint64_t *)&v25, Current, v18);
      if (mmcs_http_context_send((uint64_t)cf, 0, (uint64_t)v25))
      {
        memset(&v24, 0, sizeof(v24));
        CFStringRef v19 = CFRunLoopSourceCreate(v5, 0, &v24);
        CFRunLoopAddSource(Current, v19, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
        CFRunLoopRun();
        if (v19) {
          CFRelease(v19);
        }
      }
      else
      {
        _mmcs_report_clearFetchContext(cf);
      }
      if (v18) {
        CFRelease(v18);
      }
      CFTypeRef v15 = v25;
      if (!v25) {
        goto LABEL_28;
      }
    }
    else
    {
      pthread_mutex_unlock(&sReportingInfoAccessLock);
      mmcs_http_context_invalidate((uint64_t)cf);
      CFTypeRef v15 = cf;
      if (!cf)
      {
LABEL_30:
        CFRelease(Request);
        goto LABEL_31;
      }
    }
    C3BaseRelease(v15);
LABEL_28:
    if (cf) {
      C3BaseRelease(cf);
    }
    goto LABEL_30;
  }
  uint64_t v16 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    Request = (__CFHTTPMessage *)CFStringCreateWithFormat(v5, 0, @"Failed to create URL for MobileMe reporting levels.");
    CFStringRef v17 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = Request;
      _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
    }
    if (Request) {
      goto LABEL_30;
    }
  }
LABEL_31:
  if (a1) {
    C3BaseRelease(a1);
  }
  if (v2) {
    os_release(v2);
  }
  pthread_mutex_lock(&sReportingInfoAccessLock);
  if (gMMCS_MobileMeReporting) {
    *(unsigned char *)(gMMCS_MobileMeReporting + 64) = 0;
  }
  pthread_mutex_unlock(&sReportingInfoAccessLock);
  CFAllocatorRef v20 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v21 = CFStringCreateWithFormat(v5, 0, @"mmcs_config_fetcher completed.");
    CFStringRef v22 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v21;
      _os_log_impl(&dword_1DC1CA000, v22, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
    }
    if (v21) {
      CFRelease(v21);
    }
  }
  os_activity_scope_leave(&state);
  return 0;
}

const void *mmcs_report_copy_vendor_configuration_with_name(CFStringRef a1)
{
  v11[2] = *MEMORY[0x1E4F143B8];
  CFDictionaryRef theDict = 0;
  _mmcs_report_copyConfiguration(&theDict, 0);
  if (!theDict) {
    return 0;
  }
  if (a1) {
    a1 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@.%@", @"vendor.dc.configuration", a1);
  }
  uint64_t v2 = 0;
  v11[0] = a1;
  v11[1] = @"vendor.dc.configuration";
  char v3 = 1;
  while (1)
  {
    char v4 = v3;
    CFAllocatorRef v5 = (const void *)v11[v2];
    if (v5)
    {
      int Value = CFDictionaryGetValue(theDict, v5);
      if (Value)
      {
        CFNumberRef v7 = Value;
        CFTypeID TypeID = CFDictionaryGetTypeID();
        if (TypeID == CFGetTypeID(v7)) {
          break;
        }
      }
    }
    char v3 = 0;
    uint64_t v2 = 1;
    if ((v4 & 1) == 0)
    {
      CFNumberRef v7 = 0;
      if (!a1) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }
  CFRetain(v7);
  if (a1) {
LABEL_10:
  }
    CFRelease(a1);
LABEL_11:
  if (theDict) {
    CFRelease(theDict);
  }
  return v7;
}

const void *mmcs_report_copy_vendor_retryable_http_errors(const __CFString *a1, const __CFString *a2)
{
  CFDictionaryRef v3 = (const __CFDictionary *)mmcs_report_copy_vendor_configuration_with_name(a1);
  if (v3)
  {
    CFDictionaryRef v4 = v3;
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFLocaleRef v6 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"en_US");
    if (v6)
    {
      CFNumberRef v7 = v6;
      CFIndex Length = CFStringGetLength(a2);
      CFSetRef MutableCopy = CFStringCreateMutableCopy(v5, Length, a2);
      uint64_t v10 = MutableCopy;
      if (!MutableCopy)
      {
LABEL_12:
        CFRelease(v7);
        goto LABEL_13;
      }
      CFStringLowercase(MutableCopy, (CFLocaleRef)v7);
      CFStringRef v11 = CFStringCreateWithFormat(v5, 0, @"retry.%@.http_response_code", v10);
      CFRelease(v7);
      CFRelease(v10);
      if (v11)
      {
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v4, v11);
        if (Value && (CFStringRef v13 = Value, TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v13))) {
          uint64_t v10 = mmcs_index_set_create_with_string(v13);
        }
        else {
          uint64_t v10 = 0;
        }
        CFNumberRef v7 = v11;
        goto LABEL_12;
      }
    }
    uint64_t v10 = 0;
LABEL_13:
    CFRelease(v4);
    return v10;
  }
  return 0;
}

void mmcs_report_copy_vendor_request_queue_config(void *a1, void *a2)
{
  CFDictionaryRef theDict = 0;
  _mmcs_report_copyConfiguration(&theDict, 0);
  if (theDict)
  {
    if (a1)
    {
      CFStringRef Value = CFDictionaryGetValue(theDict, @"max.vendor.upload.connections.override");
      if (Value)
      {
        CFAllocatorRef v5 = Value;
        CFTypeID TypeID = CFNumberGetTypeID();
        if (TypeID == CFGetTypeID(v5))
        {
          CFRetain(v5);
          *a1 = v5;
        }
      }
    }
    if (a2)
    {
      CFNumberRef v7 = CFDictionaryGetValue(theDict, @"max.vendor.download.connections.override");
      if (v7)
      {
        CFURLRef v8 = v7;
        CFTypeID v9 = CFNumberGetTypeID();
        if (v9 == CFGetTypeID(v8))
        {
          CFRetain(v8);
          *a2 = v8;
        }
      }
    }
    if (theDict) {
      CFRelease(theDict);
    }
  }
}

uint64_t mmcs_report_want_report(int a1, unsigned int a2)
{
  CFDictionaryRef theDict = 0;
  _mmcs_report_copyConfiguration(&theDict, 0);
  if (!theDict) {
    return 0;
  }
  uint64_t v4 = a2;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (a1)
  {
    CFStringRef v6 = @"putcomplete.verbosity.%ld";
    goto LABEL_5;
  }
  CFStringRef v6 = @"getcomplete.verbosity.%ld";
  for (CFStringRef i = CFStringCreateWithFormat(v5, 0, @"getcomplete.verbosity.%ld", v4);
        ;
        CFStringRef i = CFStringCreateWithFormat(v5, 0, v6, v4))
  {
    CFStringRef v8 = i;
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, i);
    if (v8) {
      CFRelease(v8);
    }
    if (Value && CFDictionaryGetCount(Value) >= 1) {
      break;
    }
    if (v4-- <= 0)
    {
      uint64_t v11 = 0;
      CFDictionaryRef v12 = theDict;
      if (!theDict) {
        return v11;
      }
      goto LABEL_16;
    }
LABEL_5:
    ;
  }
  CFDictionaryRef v12 = theDict;
  uint64_t v11 = 1;
  if (!theDict) {
    return v11;
  }
LABEL_16:
  CFRelease(v12);
  return v11;
}

const void *mmcs_report_value_for_config_key(const void *a1, int a2, unsigned int a3)
{
  CFDictionaryRef theDict = 0;
  _mmcs_report_copyConfiguration(&theDict, 0);
  CFDictionaryRef v6 = theDict;
  if (!a1 || !theDict)
  {
LABEL_14:
    CFTypeRef v15 = 0;
    uint64_t v16 = 0;
    if (!v6) {
      return v16;
    }
LABEL_15:
    CFRelease(v6);
    return v15;
  }
  uint64_t v7 = a3;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (a2)
  {
    CFStringRef v9 = @"putcomplete.verbosity.%ld";
    goto LABEL_6;
  }
  CFStringRef v9 = @"getcomplete.verbosity.%ld";
  for (CFStringRef i = CFStringCreateWithFormat(v8, 0, @"getcomplete.verbosity.%ld", v7);
        ;
        CFStringRef i = CFStringCreateWithFormat(v8, 0, v9, v7))
  {
    CFStringRef v11 = i;
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, i);
    if (v11) {
      CFRelease(v11);
    }
    if (Value)
    {
      CFStringRef v13 = CFDictionaryGetValue(Value, a1);
      if (v13) {
        break;
      }
    }
    if (v7-- < 1)
    {
      CFDictionaryRef v6 = theDict;
      goto LABEL_14;
    }
LABEL_6:
    ;
  }
  CFTypeRef v15 = v13;
  CFDictionaryRef v6 = theDict;
  uint64_t v16 = v15;
  if (theDict) {
    goto LABEL_15;
  }
  return v16;
}

BOOL mmcs_report_is_valid_base_url_for_configs(const __CFArray *a1, const __CFArray *a2, CFURLRef anURL)
{
  int v3 = 0;
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!a2 || !a1)
  {
    int v6 = 0;
    goto LABEL_54;
  }
  int v6 = 0;
  if (!anURL) {
    goto LABEL_54;
  }
  CFStringRef v8 = CFURLCopyHostName(anURL);
  if (!v8)
  {
    int v3 = 0;
LABEL_53:
    int v6 = 0;
    goto LABEL_54;
  }
  CFStringRef v9 = v8;
  if (CFArrayGetCount(a1) >= 1)
  {
    CFIndex v10 = 0;
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, v10);
      if (ValueAtIndex)
      {
        CFStringRef v13 = ValueAtIndex;
        CFTypeID v14 = CFGetTypeID(ValueAtIndex);
        if (v14 == CFStringGetTypeID())
        {
          int v3 = 1;
          if (CFStringCompare(v13, v9, 1uLL) == kCFCompareEqualTo) {
            goto LABEL_28;
          }
          if (CFStringHasPrefix(v13, @".") && CFStringHasSuffix(v9, v13))
          {
            int v3 = 1;
            goto LABEL_28;
          }
          CFTypeRef v15 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v16 = CFStringCreateWithFormat(v11, 0, @"Did not match %@ from config as suffix of hostname %@.", v13, v9);
            CFStringRef v17 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v47 = v16;
              CFArrayRef v18 = v17;
              os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
              goto LABEL_18;
            }
            goto LABEL_19;
          }
        }
        else
        {
          CFAllocatorRef v20 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            CFTypeID v21 = CFGetTypeID(v13);
            CFStringRef v16 = CFStringCreateWithFormat(v11, 0, @"Invalid typeId %llu provided for %@ element.", v21, @"metaserver.allowed.hostname.suffix");
            CFStringRef v22 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v47 = v16;
              CFArrayRef v18 = v22;
              os_log_type_t v19 = OS_LOG_TYPE_ERROR;
LABEL_18:
              _os_log_impl(&dword_1DC1CA000, v18, v19, "%{public}@", buf, 0xCu);
            }
LABEL_19:
            if (v16) {
              CFRelease(v16);
            }
          }
        }
      }
      ++v10;
    }
    while (v10 < CFArrayGetCount(a1));
  }
  __int16 v23 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v24 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Metaserver Hostname %@ Not Allowed", v9);
    uint64_t v25 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v47 = v24;
      _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v24) {
      CFRelease(v24);
    }
  }
  int v3 = 0;
LABEL_28:
  CFRelease(v9);
  CFStringRef v26 = CFURLCopyScheme(anURL);
  if (!v26) {
    goto LABEL_53;
  }
  CFStringRef v27 = v26;
  if (CFArrayGetCount(a2) >= 1)
  {
    CFIndex v28 = 0;
    CFAllocatorRef v29 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      CFStringRef v30 = (const __CFString *)CFArrayGetValueAtIndex(a2, v28);
      if (v30)
      {
        CFStringRef v31 = v30;
        CFTypeID v32 = CFGetTypeID(v30);
        if (v32 == CFStringGetTypeID())
        {
          int v6 = 1;
          if (CFStringCompare(v27, v31, 1uLL) == kCFCompareEqualTo) {
            goto LABEL_50;
          }
          uint64_t v33 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_43;
          }
          CFStringRef v34 = CFStringCreateWithFormat(v29, 0, @"Did not match %@ from config as suffix of scheme %@.", v31, v27);
          uint64_t v35 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v47 = v34;
            CFStringRef v36 = v35;
            os_log_type_t v37 = OS_LOG_TYPE_DEBUG;
            goto LABEL_40;
          }
          goto LABEL_41;
        }
        uint64_t v38 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          CFTypeID v39 = CFGetTypeID(v31);
          CFStringRef v34 = CFStringCreateWithFormat(v29, 0, @"Invalid typeId %llu provided for %@ element.", v39, @"metaserver.allowed.schemes");
          CFRunLoopRef v40 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v47 = v34;
            CFStringRef v36 = v40;
            os_log_type_t v37 = OS_LOG_TYPE_ERROR;
LABEL_40:
            _os_log_impl(&dword_1DC1CA000, v36, v37, "%{public}@", buf, 0xCu);
          }
LABEL_41:
          if (v34) {
            CFRelease(v34);
          }
        }
      }
LABEL_43:
      ++v28;
    }
    while (v28 < CFArrayGetCount(a2));
  }
  uint64_t v41 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v42 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Metaserver Scheme %@ Not Allowed", v27);
    uint64_t v43 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v47 = v42;
      _os_log_impl(&dword_1DC1CA000, v43, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v42) {
      CFRelease(v42);
    }
  }
  int v6 = 0;
LABEL_50:
  CFRelease(v27);
LABEL_54:
  if (v3) {
    BOOL v44 = v6 == 0;
  }
  else {
    BOOL v44 = 1;
  }
  return !v44;
}

BOOL mmcs_report_is_valid_base_url_for_mobile_me(const __CFArray *a1, CFStringRef a2, const __CFURL *a3)
{
  CFTypeRef cf = 0;
  _mmcs_report_copyConfiguration(&cf, 0);
  CFDictionaryRef v6 = (const __CFDictionary *)cf;
  if (!cf) {
    return 0;
  }
  uint64_t v7 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (!a1)
  {
LABEL_7:
    CFMutableSetRef Mutable = CFArrayCreateMutable(*v7, 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFIndex v10 = Mutable;
      CFArrayAppendValue(Mutable, @".icloud.com");
      CFArrayAppendValue(v10, @".icloud.com.cn");
      a1 = (const __CFArray *)mmcs_report_copy_cfarray_with_key(v6, @"metaserver.allowed.hostname.suffix", v10);
      CFRelease(v10);
      if (a1) {
        goto LABEL_9;
      }
    }
    else
    {
      a1 = (const __CFArray *)mmcs_report_copy_cfarray_with_key(v6, @"metaserver.allowed.hostname.suffix", 0);
      if (a1) {
        goto LABEL_9;
      }
    }
    mmcs_report_is_valid_base_url_for_mobile_me_cold_1();
  }
  if (!CFArrayGetCount(a1))
  {
    CFDictionaryRef v6 = (const __CFDictionary *)cf;
    goto LABEL_7;
  }
  CFRetain(a1);
LABEL_9:
  if (a2 && CFArrayGetCount((CFArrayRef)a2))
  {
    CFRetain(a2);
    goto LABEL_14;
  }
  CFDictionaryRef v11 = (const __CFDictionary *)cf;
  CFDictionaryRef v12 = CFArrayCreateMutable(*v7, 0, MEMORY[0x1E4F1D510]);
  if (v12)
  {
    CFStringRef v13 = v12;
    CFArrayAppendValue(v12, @"https");
    a2 = mmcs_report_copy_cfarray_with_key(v11, @"metaserver.allowed.schemes", v13);
    CFRelease(v13);
    if (a2) {
      goto LABEL_14;
    }
LABEL_20:
    mmcs_report_is_valid_base_url_for_mobile_me_cold_2();
  }
  a2 = mmcs_report_copy_cfarray_with_key(v11, @"metaserver.allowed.schemes", 0);
  if (!a2) {
    goto LABEL_20;
  }
LABEL_14:
  BOOL is_valid_base_url_for_configs = mmcs_report_is_valid_base_url_for_configs(a1, (const __CFArray *)a2, a3);
  CFRelease(a1);
  CFRelease(a2);
  if (cf) {
    CFRelease(cf);
  }
  return is_valid_base_url_for_configs;
}

uint64_t mmcs_report_is_enabled_for_config_key(const void *a1, int a2, unsigned int a3)
{
  CFStringRef v3 = (const __CFString *)mmcs_report_value_for_config_key(a1, a2, a3);
  return mmcs_get_BOOLean_from_cftype_using_description(@"mmcsReportConfigKey", v3, 0);
}

uint64_t mmcs_report_property_for_config_key(const void *a1, const void *a2, int a3, unsigned int a4)
{
  CFDictionaryRef theDict = 0;
  _mmcs_report_copyConfiguration(&theDict, 0);
  CFDictionaryRef v8 = theDict;
  if (!a2 || !a1 || !theDict)
  {
LABEL_16:
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    if (!v8) {
      return v18;
    }
LABEL_17:
    CFRelease(v8);
    return v17;
  }
  uint64_t v9 = a4;
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (a3)
  {
    CFStringRef v11 = @"putcomplete.verbosity.%ld";
    goto LABEL_7;
  }
  CFStringRef v11 = @"getcomplete.verbosity.%ld";
  for (CFStringRef i = CFStringCreateWithFormat(v10, 0, @"getcomplete.verbosity.%ld", v9);
        ;
        CFStringRef i = CFStringCreateWithFormat(v10, 0, v11, v9))
  {
    CFStringRef v13 = i;
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, i);
    if (v13) {
      CFRelease(v13);
    }
    if (Value)
    {
      CFArrayRef v15 = (const __CFArray *)CFDictionaryGetValue(Value, a1);
      if (IsValidCFArray(v15))
      {
        v21.unsigned int length = CFArrayGetCount(v15);
        v21.CFIndex location = 0;
        if (CFArrayContainsValue(v15, v21, a2)) {
          break;
        }
      }
    }
    if (v9-- <= 0)
    {
      CFDictionaryRef v8 = theDict;
      goto LABEL_16;
    }
LABEL_7:
    ;
  }
  CFDictionaryRef v8 = theDict;
  uint64_t v17 = 1;
  uint64_t v18 = 1;
  if (theDict) {
    goto LABEL_17;
  }
  return v18;
}

__CFDictionary *mmcs_report_create_vendor_http_stats(uint64_t a1, int a2, unsigned int a3)
{
  int v6 = mmcs_report_property_for_config_key(@"vendor.kpis", @"vendor.roundtrip.millis", a2, a3);
  int v7 = mmcs_report_property_for_config_key(@"vendor.kpis", @"contentlength.bytes", a2, a3);
  int v8 = mmcs_report_property_for_config_key(@"vendor.kpis", @"vendor.nameresolution.millis", a2, a3);
  int v9 = mmcs_report_property_for_config_key(@"vendor.kpis", @"vendor.nameresolution.serverAddress", a2, a3);
  int v10 = mmcs_report_property_for_config_key(@"vendor.kpis", @"vendor.request.qos", a2, a3);
  int v11 = mmcs_report_property_for_config_key(@"vendor.kpis", @"vendor.network.interface", a2, a3);
  if (!a1) {
    return 0;
  }
  int v12 = v11;
  if (!v6 && !v7 && !v8 && !v10 && !v11) {
    return 0;
  }
  CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    if (v6)
    {
      double v16 = mmcs_http_context_elapsed_seconds(a1);
      CFStringRef MillisStringFromAbsoluteTime = createMillisStringFromAbsoluteTime(v16);
      if (MillisStringFromAbsoluteTime)
      {
        CFStringRef v18 = MillisStringFromAbsoluteTime;
        CFDictionaryAddValue(Mutable, @"vendor.roundtrip.millis", MillisStringFromAbsoluteTime);
        CFRelease(v18);
      }
    }
    if (v7)
    {
      uint64_t v19 = a2 ? mmcs_http_context_actual_bytes_written(a1) : mmcs_http_context_actual_bytes_read(a1);
      CFStringRef v20 = CFStringCreateWithFormat(v15, 0, @"%lld", v19);
      if (v20)
      {
        CFStringRef v21 = v20;
        CFDictionaryAddValue(Mutable, @"contentlength.bytes", v20);
        CFRelease(v21);
      }
    }
    if (v8)
    {
      mmcs_http_context_name_resolution_seconds(a1);
      CFStringRef v23 = createMillisStringFromAbsoluteTime(v22);
      if (v23)
      {
        CFStringRef v24 = v23;
        CFDictionaryAddValue(Mutable, @"vendor.nameresolution.millis", v23);
        CFRelease(v24);
      }
    }
    if (v9)
    {
      CFStringRef v25 = mmcs_http_context_copy_destination_address(a1);
      if (v25)
      {
        CFStringRef v26 = v25;
        CFDictionaryAddValue(Mutable, @"vendor.nameresolution.serverAddress", v25);
        CFRelease(v26);
      }
    }
    if (v10)
    {
      uint64_t request_options = mmcs_http_context_get_request_options(a1);
      unint64_t discretionary_network_behavior = mmcs_http_request_options_get_discretionary_network_behavior(request_options);
      CFStringRef String = MMCSRequestOptionsDiscretionaryNetworkBehaviorGetString(discretionary_network_behavior);
      if (String)
      {
        CFStringRef v30 = String;
        CFDictionaryAddValue(Mutable, @"vendor.request.qos", String);
        CFRelease(v30);
      }
    }
    if (v12)
    {
      CFStringRef v31 = mmcs_http_context_copy_interface_identifier(a1);
      if (v31)
      {
        CFStringRef v32 = v31;
        CFDictionaryAddValue(Mutable, @"vendor.network.interface", v31);
        CFRelease(v32);
      }
    }
  }
  return Mutable;
}

CFTypeRef mmcs_report_copy_headers_from_vendor_response(__CFHTTPMessage *a1, int a2, int a3, unsigned int a4)
{
  CFDictionaryRef v7 = CFHTTPMessageCopyAllHeaderFields(a1);
  CFDictionaryRef theDict = 0;
  _mmcs_report_copyConfiguration(&theDict, 0);
  CFTypeRef v8 = 0;
  CFDictionaryRef v9 = theDict;
  if (v7 && theDict)
  {
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFMutableDictionaryRef v12 = Mutable;
      uint64_t v13 = 0;
      int v14 = 0;
      if (a2) {
        CFAllocatorRef v15 = @"vendor.headers.on.success";
      }
      else {
        CFAllocatorRef v15 = @"vendor.headers.on.failure";
      }
      long long v26 = 0u;
      *(_OWORD *)CFTypeRef cf = 0u;
      CFMutableDictionaryRef context = Mutable;
      if (a3)
      {
        CFStringRef v16 = @"putcomplete.verbosity.%u";
        goto LABEL_10;
      }
      CFStringRef v16 = @"getcomplete.verbosity.%u";
      for (CFStringRef i = CFStringCreateWithFormat(v10, 0, @"getcomplete.verbosity.%u", 0);
            ;
            CFStringRef i = CFStringCreateWithFormat(v10, 0, v16, v13))
      {
        if (i)
        {
          CFStringRef v18 = i;
          if (CFDictionaryContainsKey(theDict, i))
          {
            CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, v18);
            if (Value)
            {
              cf[0] = CFDictionaryGetValue(Value, v15);
              if (cf[0])
              {
                CFTypeID TypeID = CFArrayGetTypeID();
                if (TypeID == CFGetTypeID(cf[0]))
                {
                  CFArrayRef v21 = (const __CFArray *)cf[0];
                  v28.unsigned int length = CFArrayGetCount((CFArrayRef)cf[0]);
                  v28.CFIndex location = 0;
                  if (CFArrayContainsValue(v21, v28, @"*"))
                  {
                    CFRelease(v18);
                    CFDictionaryRef v22 = v7;
                    goto LABEL_22;
                  }
                  CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)_collect_response_headers, &context);
                  int v14 = 1;
                }
              }
            }
            else
            {
              cf[0] = 0;
            }
          }
          CFRelease(v18);
        }
        uint64_t v13 = (v13 + 1);
        if (v13 > a4) {
          break;
        }
LABEL_10:
        ;
      }
      CFDictionaryRef v22 = v12;
      if (v14)
      {
LABEL_22:
        CFTypeRef v8 = CFRetain(v22);
        goto LABEL_25;
      }
      CFTypeRef v8 = 0;
LABEL_25:
      CFRelease(v12);
    }
    else
    {
      CFTypeRef v8 = 0;
    }
    CFDictionaryRef v9 = theDict;
  }
  if (v9) {
    CFRelease(v9);
  }
  CFDictionaryRef theDict = 0;
  if (v7) {
    CFRelease(v7);
  }
  return v8;
}

void _collect_response_headers(uint64_t a1, uint64_t a2, void *a3)
{
  a3[3] = a1;
  a3[4] = a2;
  CFArrayRef v4 = (const __CFArray *)a3[1];
  v5.unsigned int length = CFArrayGetCount(v4);
  v5.CFIndex location = 0;
  CFArrayApplyFunction(v4, v5, (CFArrayApplierFunction)_collectHeadersWhichMatch, a3);
  a3[3] = 0;
  a3[4] = 0;
}

uint64_t mmcs_report_get_chunker_max_fixed_length(_DWORD *a1)
{
  int valuePtr = 0;
  CFDictionaryRef theDict = 0;
  _mmcs_report_copyConfiguration(&theDict, 0);
  if (!theDict) {
    return 0;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"chunker.max.fixed.length");
  CFNumberRef v3 = Value;
  if (Value)
  {
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFNumberGetTypeID()) {
      CFNumberRef v3 = (const __CFNumber *)(CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr) != 0);
    }
    else {
      CFNumberRef v3 = 0;
    }
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (a1 && v3)
  {
    *a1 = valuePtr;
    return 1;
  }
  return (uint64_t)v3;
}

uint64_t mmcs_report_chunker_allow_item_chunk_length_28455742()
{
  CFTypeRef cf = 0;
  _mmcs_report_copyConfiguration(&cf, 0);
  if (!cf) {
    return 0;
  }
  uint64_t BOOLean_from_cfdictionary_object_for_key = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)cf, @"chunker.allow.item.chunk.length.28455742", 0);
  if (cf) {
    CFRelease(cf);
  }
  return BOOLean_from_cfdictionary_object_for_key;
}

__CFString *mmcs_report_auth_simulcast_response_signing_key_public_current()
{
  CFDictionaryRef theDict = 0;
  _mmcs_report_copyConfiguration(&theDict, 0);
  if (!theDict) {
    return 0;
  }
  CFNumberRef Value = (__CFString *)CFDictionaryGetValue(theDict, @"auth.simulcast.response.signing.key.public.current");
  CFSetRef MutableCopy = Value;
  if (Value)
  {
    CFTypeID v2 = CFGetTypeID(Value);
    if (v2 == CFStringGetTypeID())
    {
      CStringPtr = CFStringGetCStringPtr(MutableCopy, 0x8000100u);
      CFDataRef v4 = mmcs_base64_encoded_cstring_to_cfdata(CStringPtr);
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFIndex Length = CFDataGetLength(v4);
      CFSetRef MutableCopy = (__CFString *)CFDataCreateMutableCopy(v5, Length, v4);
      v9.CFIndex location = 0;
      v9.unsigned int length = 26;
      CFDataDeleteBytes((CFMutableDataRef)MutableCopy, v9);
      if (v4) {
        CFRelease(v4);
      }
    }
    else
    {
      CFSetRef MutableCopy = 0;
    }
  }
  if (theDict) {
    CFRelease(theDict);
  }
  return MutableCopy;
}

CFStringRef mmcs_report_auth_simulcast_response_signing_key_public_prior()
{
  CFDictionaryRef theDict = 0;
  _mmcs_report_copyConfiguration(&theDict, 0);
  if (!theDict) {
    return 0;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"auth.simulcast.response.signing.key.public.prior");
  CFStringRef v1 = Value;
  if (Value)
  {
    CFTypeID v2 = CFGetTypeID(Value);
    if (v2 == CFStringGetTypeID())
    {
      CStringPtr = CFStringGetCStringPtr(v1, 0x8000100u);
      CFStringRef v1 = (const __CFString *)mmcs_base64_encoded_cstring_to_cfdata(CStringPtr);
    }
    else
    {
      CFStringRef v1 = 0;
    }
  }
  if (theDict) {
    CFRelease(theDict);
  }
  return v1;
}

void mmcs_reporting_fetch_operation_http_callback(const void *a1, CFDataRef *a2, __CFRunLoop *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  BOOL v6 = mmcs_http_context_status_succeeded((uint64_t)a1);
  CFDictionaryRef v7 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (!a2 || !v6 || !*a2)
  {
    if (mmcs_http_context_is_cancelled((uint64_t)a1))
    {
      CFAllocatorRef v15 = "was cancelled";
    }
    else if (mmcs_http_context_has_timedout((uint64_t)a1) {
           && mmcs_http_context_is_timedout((uint64_t)a1))
    }
    {
      CFAllocatorRef v15 = "timed out";
    }
    else if (a2 && *a2)
    {
      CFAllocatorRef v15 = "failed";
    }
    else
    {
      CFAllocatorRef v15 = "had no response body";
    }
    BOOL has_http_status = mmcs_http_context_has_http_status((uint64_t)a1);
    uint64_t v17 = mmcs_logging_logger_default();
    if (has_http_status)
    {
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_20;
      }
      CFAllocatorRef v18 = *v7;
      uint64_t v19 = mmcs_http_context_http_status((uint64_t)a1);
      CFStringRef v20 = CFStringCreateWithFormat(v18, 0, @"Request to MobileMe config server %s with status: %d.", v15, v19);
      CFArrayRef v21 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_18;
      }
      c.count[0] = 138543362;
      *(void *)&c.count[1] = v20;
      CFDictionaryRef v22 = v21;
      os_log_type_t v23 = OS_LOG_TYPE_DEBUG;
    }
    else
    {
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_20;
      }
      CFStringRef v20 = CFStringCreateWithFormat(*v7, 0, @"Request to MobileMe config server %s has no status!", v15);
      CFStringRef v24 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
LABEL_18:
        if (v20) {
          CFRelease(v20);
        }
LABEL_20:
        BOOL v25 = 0;
        CFStringRef v12 = 0;
        CFPropertyListRef v26 = 0;
        if (!a2) {
          goto LABEL_42;
        }
        goto LABEL_39;
      }
      c.count[0] = 138543362;
      *(void *)&c.count[1] = v20;
      CFDictionaryRef v22 = v24;
      os_log_type_t v23 = OS_LOG_TYPE_DEFAULT;
    }
    _os_log_impl(&dword_1DC1CA000, v22, v23, "%{public}@", (uint8_t *)&c, 0xCu);
    goto LABEL_18;
  }
  *(_OWORD *)md = 0u;
  long long v42 = 0u;
  memset(&c, 0, sizeof(c));
  CC_SHA256_Init(&c);
  BytePtr = CFDataGetBytePtr(*a2);
  CC_LONG Length = CFDataGetLength(*a2);
  CC_SHA256_Update(&c, BytePtr, Length);
  CC_SHA256_Final(md, &c);
  CFAllocatorRef v10 = *v7;
  CFDataRef v11 = XCFDataCreateWithBytesNoCopy(*v7, md, 32, (const __CFAllocator *)*MEMORY[0x1E4F1CFA0]);
  CFStringRef v12 = (CFStringRef)v11;
  if (v11)
  {
    uint64_t v13 = (char *)mmcs_base64_encode_cfdata_to_cstring((CFIndex)v11);
    CFRelease(v12);
    if (v13)
    {
      size_t v14 = strlen(v13);
      CFStringRef v12 = XCFStringCreateWithBytesNoCopy(v10, (const UInt8 *)v13, v14, 0x600u, 0, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
      if (!v12) {
        free(v13);
      }
    }
    else
    {
      CFStringRef v12 = 0;
    }
  }
  CFErrorRef error = 0;
  CFPropertyListFormat format = 0;
  CFPropertyListRef v26 = CFPropertyListCreateWithData(v10, *a2, 0, &format, &error);
  if (error)
  {
    CFStringRef v27 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v28 = CFStringCreateWithFormat(v10, 0, @"Failed to create configuration plist (%@) ", error);
      CFAllocatorRef v29 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v39 = v28;
        _os_log_impl(&dword_1DC1CA000, v29, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v28) {
        CFRelease(v28);
      }
    }
    if (error) {
      CFRelease(error);
    }
  }
  BOOL v25 = v26 != 0;
LABEL_39:
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = 0;
LABEL_42:
  *(void *)c.count = CFAbsoluteTimeGetCurrent();
  CFAllocatorRef v30 = *v7;
  CFNumberRef v31 = CFNumberCreate(*v7, kCFNumberDoubleType, &c);
  uint64_t v32 = *(void *)c.count;
  if (v25)
  {
    _mmcs_report_setReportingInfo((uint64_t)a1, v12, v26, 1, v31, *(CFAbsoluteTime *)c.count, 0.0);
    if (!v31) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  pthread_mutex_lock(&sReportingInfoAccessLock);
  if (!gMMCS_MobileMeReporting || a1 && *(const void **)(gMMCS_MobileMeReporting + 16) != a1)
  {
    pthread_mutex_unlock(&sReportingInfoAccessLock);
    if (!v31) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  *(void *)(gMMCS_MobileMeReporting + 48) = v32;
  pthread_mutex_unlock(&sReportingInfoAccessLock);
  CFPreferencesSetAppValue(@"report.LastFailedCheckTime", v31, @"com.apple.mmcs");
  CFPreferencesAppSynchronize(@"com.apple.mmcs");
  if (v31) {
LABEL_49:
  }
    CFRelease(v31);
LABEL_50:
  if (v26) {
    CFRelease(v26);
  }
  if (v12) {
    CFRelease(v12);
  }
  uint64_t v33 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v34 = CFStringCreateWithFormat(v30, 0, @"Remote fetch completed (%d)", v25);
    uint64_t v35 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      c.count[0] = 138543362;
      *(void *)&c.count[1] = v34;
      _os_log_impl(&dword_1DC1CA000, v35, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&c, 0xCu);
    }
    if (v34) {
      CFRelease(v34);
    }
  }
  _mmcs_report_clearFetchContext(a1);
  CFRunLoopStop(a3);
  if (a3) {
    CFRelease(a3);
  }
}

uint64_t _mmcs_report_clearFetchContext(const void *a1)
{
  pthread_mutex_lock(&sReportingInfoAccessLock);
  if (gMMCS_MobileMeReporting)
  {
    if (*(const void **)(gMMCS_MobileMeReporting + 16) == a1)
    {
      *(void *)(gMMCS_MobileMeReporting + 16) = 0;
      mmcs_http_context_invalidate((uint64_t)a1);
      if (a1) {
        C3BaseRelease(a1);
      }
    }
  }
  return pthread_mutex_unlock(&sReportingInfoAccessLock);
}

CFStringRef mmcs_report_copy_cfarray_with_key(const __CFDictionary *a1, const void *a2, const void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
LABEL_11:
    CFStringRef v6 = 0;
    goto LABEL_12;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, a2);
  CFStringRef v6 = Value;
  if (!Value) {
    goto LABEL_12;
  }
  CFTypeID v7 = CFGetTypeID(Value);
  if (v7 != CFArrayGetTypeID())
  {
    CFTypeRef v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFTypeID v10 = CFGetTypeID(v6);
      CFStringRef v6 = CFStringCreateWithFormat(v9, 0, @"Invalid typeId %llu provided for %@.", v10, a2);
      CFDataRef v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v14 = v6;
        _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (!v6) {
        goto LABEL_12;
      }
      CFRelease(v6);
    }
    goto LABEL_11;
  }
  if (CFArrayGetCount((CFArrayRef)v6))
  {
    CFRetain(v6);
    return v6;
  }
LABEL_12:
  if (a3)
  {
    CFRetain(a3);
    return (CFStringRef)a3;
  }
  return v6;
}

void _collectHeadersWhichMatch(const __CFString *a1, uint64_t a2)
{
  CFStringRef v3 = *(const __CFString **)(a2 + 24);
  if (v3 && *(void *)a2 && CFStringCompare(a1, v3, 1uLL) == kCFCompareEqualTo)
  {
    CFDataRef v4 = *(__CFDictionary **)a2;
    CFAllocatorRef v5 = *(const void **)(a2 + 24);
    CFStringRef v6 = *(const void **)(a2 + 32);
    CFDictionarySetValue(v4, v5, v6);
  }
}

void ProtobufCBinaryData_SetCopyBufferLen(void *a1, const void *a2, size_t size)
{
  if (a2 && size)
  {
    CFStringRef v6 = malloc_type_malloc(size, 0xFC9FF968uLL);
    *a1 = size;
    memcpy(v6, a2, size);
    CFTypeID v7 = (void *)a1[1];
    if (v7) {
      free(v7);
    }
    a1[1] = v6;
  }
  else
  {
    CFTypeRef v8 = (void *)a1[1];
    if (v8) {
      free(v8);
    }
    *a1 = 0;
    a1[1] = 0;
  }
}

CFDataRef ProtobufCBinaryData_CreateData(CFDataRef result)
{
  if (result) {
    return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *((const UInt8 **)result + 1), *(void *)result);
  }
  return result;
}

BOOL ProtobufCBinaryData_Equals(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a1 && a2) {
    return *(void *)a1 == *(void *)a2
  }
        && memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), *(void *)a1) == 0;
  return result;
}

void ProtobufCBinaryData_SetData(CFIndex *a1, CFDataRef theData)
{
  CFDataRef v4 = (void *)a1[1];
  if (v4) {
    free(v4);
  }
  *a1 = 0;
  a1[1] = 0;
  if (theData)
  {
    CFIndex Length = CFDataGetLength(theData);
    CFStringRef v6 = (UInt8 *)malloc_type_malloc(Length, 0xE9353146uLL);
    v7.CFIndex location = 0;
    v7.unsigned int length = Length;
    CFDataGetBytes(theData, v7, v6);
    *a1 = Length;
    a1[1] = (CFIndex)v6;
  }
}

__CFString *ProtobufCString_SetString(__CFString **a1, const __CFString *a2)
{
  if (a2)
  {
    BOOL result = createCStringWithCFString(a2);
  }
  else
  {
    BOOL result = *a1;
    if (*a1)
    {
      free(result);
      BOOL result = 0;
    }
  }
  *a1 = result;
  return result;
}

void *chunkserver__get_file_chunk_keys__create()
{
  CFAllocatorRef v0 = malloc_type_malloc(0x48uLL, 0x10700404B5FC448uLL);
  chunkserver__get_file_chunk_keys__init((uint64_t)v0);
  return v0;
}

_OWORD *chunkserver__get_chunk_keys_request__create(uint64_t a1)
{
  CFTypeID v2 = malloc_type_malloc(0x30uLL, 0x10E00407CC324CDuLL);
  CFStringRef v3 = v2;
  if (v2)
  {
    chunkserver__get_chunk_keys_request__init(v2);
    if (a1)
    {
      CFDataRef v4 = malloc_type_malloc(8 * a1, 0x2004093837F09uLL);
      *((void *)v3 + 4) = v4;
      if (!v4)
      {
        chunkserver__get_chunk_keys_request__free_unpacked((void **)v3, 0);
        return 0;
      }
    }
  }
  return v3;
}

CFDataRef chunkserver__get_chunk_keys_request__create_data(void **a1)
{
  uint64_t packed_size = chunkserver__get_chunk_keys_request__get_packed_size(a1);
  CFStringRef v3 = (const UInt8 *)malloc_type_malloc(packed_size, 0xAE412335uLL);
  chunkserver__get_chunk_keys_request__pack(a1, (uint64_t)v3);
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
  return XCFDataCreateWithBytesNoCopy(v4, v3, packed_size, v5);
}

void **chunkserver__put_chunk_keys_request__create(uint64_t a1)
{
  CFTypeID v2 = (void **)malloc_type_malloc(0x28uLL, 0x10E00409A86192AuLL);
  CFStringRef v3 = v2;
  if (v2)
  {
    chunkserver__put_chunk_keys_request__init((uint64_t)v2);
    if (a1)
    {
      CFAllocatorRef v4 = malloc_type_malloc(8 * a1, 0x2004093837F09uLL);
      v3[4] = v4;
      if (!v4)
      {
        chunkserver__put_chunk_keys_request__free_unpacked(v3, 0);
        return 0;
      }
    }
  }
  return v3;
}

CFDataRef chunkserver__put_chunk_keys_request__create_data(void **a1)
{
  uint64_t packed_size = chunkserver__put_chunk_keys_request__get_packed_size(a1);
  CFStringRef v3 = (const UInt8 *)malloc_type_malloc(packed_size, 0x497DD7AFuLL);
  chunkserver__put_chunk_keys_request__pack(a1, (uint64_t)v3);
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
  return XCFDataCreateWithBytesNoCopy(v4, v3, packed_size, v5);
}

_OWORD *chunkserver__put_file_chunk_keys__create(uint64_t a1)
{
  CFTypeID v2 = malloc_type_malloc(0x60uLL, 0x10F0040B8968E1DuLL);
  CFStringRef v3 = v2;
  if (v2)
  {
    chunkserver__put_file_chunk_keys__init(v2);
    if (a1)
    {
      CFAllocatorRef v4 = malloc_type_malloc(8 * a1, 0x2004093837F09uLL);
      *((void *)v3 + 6) = v4;
      if (!v4)
      {
        chunkserver__put_file_chunk_keys__free_unpacked((void **)v3, 0);
        return 0;
      }
    }
  }
  return v3;
}

_OWORD *chunkserver__chunk_key__create()
{
  CFAllocatorRef v0 = malloc_type_malloc(0x50uLL, 0x1070040FC70CDAEuLL);
  chunkserver__chunk_key__init(v0);
  return v0;
}

void *mmcs_create_RangedItem(const __CFData *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    CFTypeID v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFAllocatorRef v18 = 0;
      CFDataRef v11 = "mmcs_create_FileReferenceDataV1Chunk fileVerificationKey required.";
      CFStringRef v12 = v18;
LABEL_18:
      CFStringRef v14 = v10;
      uint32_t v15 = 2;
      goto LABEL_19;
    }
    return 0;
  }
  CFAllocatorRef v4 = malloc_type_malloc(0x38uLL, 0x1070040B7852850uLL);
  if (!v4)
  {
    uint64_t v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CFAllocatorRef v18 = 136315138;
      *(void *)&v18[4] = "mmcs_create_RangedItem";
      CFDataRef v11 = "%s failed to allocate rangedItem.";
      CFStringRef v12 = v18;
      CFStringRef v14 = v13;
      uint32_t v15 = 12;
LABEL_19:
      _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, v11, v12, v15);
      return 0;
    }
    return 0;
  }
  CFAllocatorRef v5 = v4;
  opaque__file_reference_data__ranged_item__init((uint64_t)v4);
  *(void *)CFAllocatorRef v18 = a2;
  ProtobufCBinaryData_SetCopyBufferLen(v5 + 5, v18, 8uLL);
  if (!v5[6])
  {
    CFTypeID v10 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    __int16 v17 = 0;
    CFDataRef v11 = "mmcs_create_FileReferenceDataV1Chunk failed to allocate chunk_length.";
LABEL_17:
    CFStringRef v12 = (uint8_t *)&v17;
    goto LABEL_18;
  }
  if (CFDataGetLength(a1) != 32)
  {
    CFTypeID v10 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    __int16 v17 = 0;
    CFDataRef v11 = "mmcs_create_FileReferenceDataV1Chunk unexpected fileVerificationKey length.";
    goto LABEL_17;
  }
  CFStringRef v6 = malloc_type_malloc(0x20uLL, 0x61357C2EuLL);
  v5[4] = v6;
  if (!v6)
  {
    CFTypeID v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      __int16 v17 = 0;
      CFDataRef v11 = "mmcs_create_FileReferenceDataV1Chunk failed to allocate file verification key.";
      goto LABEL_17;
    }
    return 0;
  }
  CFRange v7 = v6;
  v5[3] = 32;
  BytePtr = CFDataGetBytePtr(a1);
  long long v9 = *((_OWORD *)BytePtr + 1);
  *CFRange v7 = *(_OWORD *)BytePtr;
  v7[1] = v9;
  return v5;
}

CFDataRef mmcs_RangedItem_copyFileVerificationKey_copyItemLength(CFDataRef result, void *a2, void *a3)
{
  if (result)
  {
    CFDataRef v4 = result;
    CFAllocatorRef v5 = (const UInt8 *)*((void *)result + 4);
    if (v5 && *((void *)result + 5) == 8)
    {
      CFRange v7 = (void *)((char *)result + 24);
      BOOL result = XCFDataCreateWithBytesNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v5, *((void *)result + 3), (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
      if (result)
      {
        if (a2)
        {
          *CFRange v7 = 0;
          *((void *)v4 + 4) = 0;
          *a2 = result;
          BOOL result = 0;
        }
        if (a3) {
          *a3 = **((void **)v4 + 6);
        }
        if (result) {
          CFRelease(result);
        }
        return (CFDataRef)1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t mmcs_item_create_FileOpaqueReferenceData(uint64_t a1)
{
  if (a1)
  {
    FileReferenceCFDataRef Data = mmcs_generic_item_create_FileReferenceData(a1, (uint64_t)mmcs_item_generic_item_callbacks);
    if (FileReferenceData)
    {
      CFStringRef v3 = FileReferenceData;
      CFDataRef v4 = *(const void **)(a1 + 72);
      if (v4)
      {
        CFTypeID v5 = CFGetTypeID(v4);
        if (v5 == CFDataGetTypeID())
        {
          uint64_t file_reference_data_with_cfdata = mmcs_create_file_reference_data_with_cfdata(v3);
          if (file_reference_data_with_cfdata)
          {
LABEL_20:
            mmcs_free_FileReferenceData(v3);
            return file_reference_data_with_cfdata;
          }
          CFRange v7 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            __int16 v14 = 0;
            CFTypeRef v8 = "mmcs_item_create_FileOpaqueReferenceData failed to create cfdata from fileReferenceData.";
            long long v9 = (uint8_t *)&v14;
LABEL_18:
            _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, v8, v9, 2u);
          }
        }
        else
        {
          CFRange v7 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint32_t v15 = 0;
            CFTypeRef v8 = "mmcs_item_create_FileOpaqueReferenceData must have CFDataRef referenceObject.";
            long long v9 = v15;
            goto LABEL_18;
          }
        }
      }
      else
      {
        CFRange v7 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          __int16 v16 = 0;
          CFTypeRef v8 = "mmcs_item_create_FileOpaqueReferenceData cannot have NULL referenceObject.";
          long long v9 = (uint8_t *)&v16;
          goto LABEL_18;
        }
      }
      uint64_t file_reference_data_with_cfdata = 0;
      goto LABEL_20;
    }
    CFTypeID v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      CFDataRef v11 = "mmcs_item_create_FileOpaquedReferenceData failed to create fileReferenceData.";
      CFStringRef v12 = buf;
      goto LABEL_12;
    }
  }
  else
  {
    CFTypeID v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      __int16 v18 = 0;
      CFDataRef v11 = "mmcs_item_create_FileOpaquedReferenceData cannot have NULL item.";
      CFStringRef v12 = (uint8_t *)&v18;
LABEL_12:
      _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, v11, v12, 2u);
    }
  }
  return 0;
}

void **mmcs_generic_item_create_FileReferenceData(uint64_t a1, uint64_t a2)
{
  uint64_t v152 = *MEMORY[0x1E4F143B8];
  CFDataRef v4 = (unsigned char *)(*(uint64_t (**)(void))a2)();
  if (!v4)
  {
    uint64_t v48 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceData";
    CFStringRef v49 = "%s failed, cannot have no signature";
    goto LABEL_85;
  }
  CFTypeID v5 = v4;
  if ((*v4 & 0x7F) != 4 && (*v4 & 8) == 0)
  {
    uint64_t v48 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceData";
    CFStringRef v49 = "%s failed, FORD unexpected for non-MMCSv2 file";
    goto LABEL_85;
  }
  if ((char)*v4 < 0)
  {
    uint64_t v48 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceData";
    CFStringRef v49 = "%s failed, FORD unexpected for unencrypted file";
    goto LABEL_85;
  }
  if (!(*(uint64_t (**)(uint64_t))(a2 + 8))(a1))
  {
    uint64_t v48 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceData";
    CFStringRef v49 = "%s failed, Sha2HMAC signature cannot have NULL fileVerificationKey.";
    goto LABEL_85;
  }
  if ((char)*v5 < 0)
  {
    uint64_t v48 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceData";
    CFStringRef v49 = "%s failed, Sha2HMAC signature cannot be unencrypted.";
    goto LABEL_85;
  }
  CFArrayRef v7 = (const __CFArray *)(*(uint64_t (**)(uint64_t))(a2 + 64))(a1);
  CFArrayRef v8 = v7;
  if ((*v5 & 8) != 0)
  {
    if (!v7)
    {
      uint64_t v48 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceData";
      CFStringRef v49 = "%s failed, Sha2HMAC package must have ranged items.";
      goto LABEL_85;
    }
    if (!CFArrayGetCount(v7))
    {
      uint64_t v48 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceData";
      CFStringRef v49 = "%s failed, Sha2HMAC package must have non-zero ranged items.";
      goto LABEL_85;
    }
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(a2 + 24))(a1);
  if (!v9)
  {
    long long v50 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      goto LABEL_78;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
    CFErrorRef v51 = "%s failed, cannot have no-chunks";
LABEL_77:
    _os_log_impl(&dword_1DC1CA000, v50, OS_LOG_TYPE_ERROR, v51, buf, 0xCu);
    goto LABEL_78;
  }
  uint64_t v10 = v9;
  CFDataRef v11 = (unsigned char *)(*(uint64_t (**)(uint64_t))a2)(a1);
  if (!v11)
  {
    long long v50 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      goto LABEL_78;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
    CFErrorRef v51 = "%s failed, cannot have no signature";
    goto LABEL_77;
  }
  if ((*v11 & 0x7F) != 4 && (*v11 & 8) == 0)
  {
    long long v50 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      goto LABEL_78;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
    CFErrorRef v51 = "%s failed, FORD unexpected for non-MMCSv2 file";
    goto LABEL_77;
  }
  if ((char)*v11 < 0)
  {
    long long v50 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      goto LABEL_78;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
    CFErrorRef v51 = "%s failed, FORD unexpected for unencrypted file";
    goto LABEL_77;
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t))(a2 + 8))(a1);
  if (!v13)
  {
    long long v50 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      goto LABEL_78;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
    CFErrorRef v51 = "%s failed, cannot have NULL fileVerificationKey";
    goto LABEL_77;
  }
  CFDataRef v14 = (const __CFData *)v13;
  FileReferenceCFDataRef Data = (void **)mmcs_create_FileReferenceData(v8);
  if (!FileReferenceData)
  {
    long long v50 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
      CFErrorRef v51 = "%s failed to invoke mmcs_create_FileReferenceData";
      goto LABEL_77;
    }
LABEL_78:
    __int16 v16 = 0;
    goto LABEL_79;
  }
  __int16 v16 = FileReferenceData;
  __int16 v17 = malloc_type_malloc(8 * v10, 0x2004093837F09uLL);
  if (!v17)
  {
    CFStringRef v54 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
      goto LABEL_79;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
    uint64_t v55 = "%s failed to allocate chunk list";
    goto LABEL_94;
  }
  __int16 v18 = v17;
  uint64_t v19 = malloc_type_malloc(0x40uLL, 0x10F0040790CF86CuLL);
  if (!v19)
  {
    uint64_t v56 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v56, OS_LOG_TYPE_ERROR, "mmcs_create_FileReferenceDataV1 failed to allocate fileReferenceData.", buf, 2u);
    }
    free(v18);
    CFStringRef v54 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
      goto LABEL_79;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
    uint64_t v55 = "%s failed to invoke mmcs_create_FileReferenceDataV1";
LABEL_94:
    long long v57 = v54;
    uint32_t v58 = 12;
    goto LABEL_112;
  }
  CFStringRef v20 = v19;
  opaque__file_reference_data__v1__init(v19);
  *((void *)v20 + 3) = 0;
  *((void *)v20 + 4) = v18;
  *((_DWORD *)v20 + 10) = 1;
  BytePtr = CFDataGetBytePtr(v14);
  CFIndex Length = CFDataGetLength(v14);
  uint64_t v23 = 0;
  BOOL v24 = BytePtr != 0;
  BOOL v25 = Length != 0;
  BOOL v26 = !v24 || !v25;
  if (v24 && v25) {
    CFIndex v27 = Length;
  }
  else {
    CFIndex v27 = 0;
  }
  if (v26) {
    CFStringRef v28 = 0;
  }
  else {
    CFStringRef v28 = BytePtr;
  }
  *((void *)v20 + 6) = v27;
  *((void *)v20 + 7) = v28;
  v16[3] = v20;
  uint64_t v145 = v20;
  do
  {
    char v29 = *(unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, v23);
    if ((v29 & 0x7F) != 4)
    {
      long long v59 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v23;
        uint64_t v55 = "%s observed inconsistent signature type between registerItem->signature and registerItem->chunks[%llu]->signature.";
        goto LABEL_111;
      }
      goto LABEL_79;
    }
    if ((v29 & 0x80) == 0)
    {
      long long v59 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v23;
        uint64_t v55 = "%s observed inconsistent encryption between registerItem->signature and registerItem->chunks[%llu]->signature.";
        goto LABEL_111;
      }
      goto LABEL_79;
    }
    uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(a1, v23);
    int v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 32))(a1, v23);
    uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 48))(a1, v23);
    if (!v32)
    {
      long long v60 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
        goto LABEL_109;
      }
      *(_WORD *)long long buf = 0;
      long long v61 = "mmcs_create_FileReferenceDataV1Chunk cannot have NULL chunkEncryptionKey.";
LABEL_105:
      _os_log_impl(&dword_1DC1CA000, v60, OS_LOG_TYPE_ERROR, v61, buf, 2u);
      goto LABEL_109;
    }
    uint64_t v33 = v32;
    uint64_t v34 = CKChunkSchemeAndEncryptionKeySize();
    if (!v34)
    {
      long long v60 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
        goto LABEL_109;
      }
      *(_WORD *)long long buf = 0;
      long long v61 = "mmcs_create_FileReferenceDataV1Chunk cannot have zero length chunkEncryptionSignature.";
      goto LABEL_105;
    }
    uint64_t v35 = v34;
    uint64_t v147 = v23;
    CFStringRef v36 = malloc_type_malloc(0x58uLL, 0x10700408B6EF5B1uLL);
    if (!v36)
    {
      long long v60 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
        goto LABEL_109;
      }
      *(_WORD *)long long buf = 0;
      long long v61 = "mmcs_create_FileReferenceDataV1Chunk failed to allocate fileReferenceDataChunk.";
      goto LABEL_105;
    }
    os_log_type_t v37 = v36;
    opaque__file_reference_data__v1__chunk__init((uint64_t)v36);
    if (!v31) {
      goto LABEL_38;
    }
    *(_DWORD *)long long buf = v31;
    ProtobufCBinaryData_SetCopyBufferLen(v37 + 6, buf, 4uLL);
    if (!v37[7])
    {
      int v62 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v150 = 0;
        _os_log_impl(&dword_1DC1CA000, v62, OS_LOG_TYPE_ERROR, "mmcs_create_FileReferenceDataV1Chunk failed to allocate chunk_length.", v150, 2u);
      }
      uint64_t v23 = v147;
LABEL_109:
      long long v59 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v23;
        uint64_t v55 = "%s observed error processing registerItem->chunks[%llu]";
LABEL_111:
        long long v57 = v59;
        uint32_t v58 = 22;
LABEL_112:
        _os_log_impl(&dword_1DC1CA000, v57, OS_LOG_TYPE_ERROR, v55, buf, v58);
      }
LABEL_79:
      long long v52 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV1";
        _os_log_impl(&dword_1DC1CA000, v52, OS_LOG_TYPE_ERROR, "%s failed to create fileReferenceData", buf, 0xCu);
      }
      if (v16) {
        mmcs_free_FileReferenceData(v16);
      }
      uint64_t v48 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceData";
      CFStringRef v49 = "%s failed, cannot have NULL fileReferenceData";
LABEL_85:
      _os_log_impl(&dword_1DC1CA000, v48, OS_LOG_TYPE_ERROR, v49, buf, 0xCu);
      return 0;
    }
    *((_DWORD *)v37 + 10) = 1;
LABEL_38:
    v37[3] = v35;
    v37[4] = v33;
    if (v30)
    {
      uint64_t v38 = CKSubchunkBlobSize();
      if (v38) {
        uint64_t v39 = v30;
      }
      else {
        uint64_t v39 = 0;
      }
      v37[9] = v38;
      v37[10] = v39;
      int v40 = 1;
    }
    else
    {
      int v40 = 0;
    }
    *((_DWORD *)v37 + 16) = v40;
    uint64_t v42 = *((void *)v145 + 3);
    uint64_t v41 = *((void *)v145 + 4);
    *((void *)v145 + 3) = v42 + 1;
    *(void *)(v41 + 8 * v42) = v37;
    uint64_t v23 = v147 + 1;
  }
  while (v10 != v147 + 1);
  uint64_t v43 = (*(uint64_t (**)(uint64_t))(a2 + 24))(a1);
  if (!v43)
  {
    uint64_t v46 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
      goto LABEL_152;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV2";
    CFStringRef v47 = "%s failed, cannot have no-chunks";
LABEL_151:
    _os_log_impl(&dword_1DC1CA000, v46, OS_LOG_TYPE_ERROR, v47, buf, 0xCu);
    goto LABEL_152;
  }
  uint64_t v44 = v43;
  uint64_t v45 = (unsigned char *)(*(uint64_t (**)(uint64_t))a2)(a1);
  if (!v45)
  {
    uint64_t v46 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
      goto LABEL_152;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV2";
    CFStringRef v47 = "%s failed, cannot have no signature";
    goto LABEL_151;
  }
  if ((*v45 & 0x7F) != 4 && (*v45 & 8) == 0)
  {
    uint64_t v46 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV2";
      CFStringRef v47 = "%s failed, FORD unexpected for non-MMCSv2 file";
      goto LABEL_151;
    }
LABEL_152:
    CFNumberRef v65 = 0;
LABEL_153:
    CFTypeID v93 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v93, OS_LOG_TYPE_ERROR, "mmcs_item_create_FileReferenceData failed to create fileReferenceData", buf, 2u);
    }
    if (v65) {
      mmcs_free_FileReferenceData(v65);
    }
    CFNumberRef v94 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceData";
      goto LABEL_159;
    }
    goto LABEL_160;
  }
  if ((char)*v45 < 0)
  {
    uint64_t v46 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
      goto LABEL_152;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV2";
    CFStringRef v47 = "%s failed, FORD unexpected for unencrypted file";
    goto LABEL_151;
  }
  uint64_t v63 = (*(uint64_t (**)(uint64_t))(a2 + 8))(a1);
  if (!v63)
  {
    uint64_t v46 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
      goto LABEL_152;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV2";
    CFStringRef v47 = "%s failed, cannot have NULL fileVerificationKey";
    goto LABEL_151;
  }
  CFDataRef v64 = (const __CFData *)v63;
  CFNumberRef v65 = (void **)mmcs_create_FileReferenceData(v8);
  if (!v65) {
    goto LABEL_153;
  }
  uint64_t v144 = (void **)malloc_type_malloc(0x38uLL, 0x10F0040167B91E7uLL);
  if (!v144) {
    goto LABEL_153;
  }
  opaque__file_reference_data__v2__init((uint64_t)v144);
  v65[4] = v144;
  long long v66 = CFDataGetBytePtr(v64);
  CFIndex v67 = CFDataGetLength(v64);
  uint64_t v146 = 0;
  uint64_t v148 = 0;
  int v143 = 0;
  BOOL v68 = v66 != 0;
  BOOL v69 = v67 != 0;
  BOOL v70 = !v68 || !v69;
  if (v68 && v69) {
    CFIndex v71 = v67;
  }
  else {
    CFIndex v71 = 0;
  }
  if (v70) {
    long long v72 = 0;
  }
  else {
    long long v72 = v66;
  }
  v144[3] = (void *)v71;
  v144[4] = (void *)v72;
  while (2)
  {
    long long v73 = (unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, v148);
    int v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 32))(a1, v148);
    uint64_t v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 48))(a1, v148);
    if ((*v73 & 0x7F) != 4)
    {
      CFNumberRef v95 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
        goto LABEL_153;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV2";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v148;
      uint64_t v96 = "%s observed inconsistent signature type between registerItem->signature and registerItem->chunks[%llu]->signature.";
      CFSetRef v97 = v95;
      uint32_t v98 = 22;
LABEL_165:
      _os_log_impl(&dword_1DC1CA000, v97, OS_LOG_TYPE_ERROR, v96, buf, v98);
      goto LABEL_153;
    }
    if ((*v73 & 0x80) == 0)
    {
      uint64_t v99 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v99, OS_LOG_TYPE_ERROR)) {
        goto LABEL_153;
      }
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v148;
      uint64_t v96 = "mmcs_item_create_FileReferenceData observed inconsistent encryption between registerItem->signature and regi"
            "sterItem->ri_chunkInstances[%llu].chunkReference->signature.";
      CFSetRef v97 = v99;
      uint32_t v98 = 12;
      goto LABEL_165;
    }
    uint64_t v76 = v75;
    if (v143 != v74)
    {
      long long v77 = malloc_type_realloc(v144[6], 8 * (void)v144[5] + 8, 0x2004093837F09uLL);
      if (!v77) {
        goto LABEL_153;
      }
      v144[6] = v77;
      uint64_t v146 = malloc_type_malloc(0x38uLL, 0x10F0040167B91E7uLL);
      if (!v146) {
        goto LABEL_153;
      }
      opaque__file_reference_data__v2__chunk_group__init((uint64_t)v146);
      long long v79 = v144[5];
      long long v78 = v144[6];
      v144[5] = (char *)v79 + 1;
      v78[(void)v79] = v146;
      *(_DWORD *)long long buf = v74;
      ProtobufCBinaryData_SetCopyBufferLen((void *)v146 + 3, buf, 4uLL);
      int v143 = v74;
      if (!*((void *)v146 + 4)) {
        goto LABEL_153;
      }
    }
    if (!v76) {
      goto LABEL_153;
    }
    uint64_t v80 = CKChunkSchemeAndEncryptionKeySize();
    if (!v80) {
      goto LABEL_153;
    }
    uint64_t v81 = v80;
    uint64_t v82 = malloc_type_malloc(0x40uLL, 0x10700407A2CD8F7uLL);
    double v83 = opaque__file_reference_data__v2__chunk_group__chunk__init(v82);
    v82[3] = v81;
    v82[4] = v76;
    uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t, double))(a2 + 56))(a1, v148, v83);
    if (v84)
    {
      uint64_t v85 = v84;
      uint64_t v86 = CKSubchunkBlobSize();
      uint64_t v87 = v86 ? v85 : 0;
      v82[6] = v86;
      v82[7] = v87;
      int v88 = 1;
    }
    else
    {
      int v88 = 0;
    }
    *((_DWORD *)v82 + 10) = v88;
    CFStringRef v89 = malloc_type_realloc(*((void **)v146 + 6), 8 * *((void *)v146 + 5) + 8, 0x2004093837F09uLL);
    if (!v89) {
      goto LABEL_153;
    }
    uint64_t v90 = *((void *)v146 + 5);
    *((void *)v146 + 5) = v90 + 1;
    *((void *)v146 + 6) = v89;
    v89[v90] = v82;
    if (v44 != ++v148) {
      continue;
    }
    break;
  }
  unint64_t packed_size = opaque__file_reference_data__get_packed_size(v65);
  if (packed_size && opaque__file_reference_data__get_packed_size(v16) > packed_size)
  {
    CFStringRef v92 = v16;
    __int16 v16 = v65;
  }
  else
  {
    CFStringRef v92 = v65;
  }
  mmcs_free_FileReferenceData(v92);
  uint64_t v100 = (*(uint64_t (**)(uint64_t))(a2 + 24))(a1);
  if (!v100)
  {
    CFNumberRef v103 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
      goto LABEL_219;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV3";
    size_t v104 = "%s failed, cannot have no-chunks";
LABEL_218:
    _os_log_impl(&dword_1DC1CA000, v103, OS_LOG_TYPE_ERROR, v104, buf, 0xCu);
    goto LABEL_219;
  }
  unint64_t v101 = v100;
  uint64_t v102 = (unsigned char *)(*(uint64_t (**)(uint64_t))a2)(a1);
  if (!v102)
  {
    CFNumberRef v103 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
      goto LABEL_219;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV3";
    size_t v104 = "%s failed, cannot have no signature";
    goto LABEL_218;
  }
  if ((*v102 & 0x7F) != 4 && (*v102 & 8) == 0)
  {
    CFNumberRef v103 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV3";
      size_t v104 = "%s failed, FORD unexpected for non-MMCSv2 file";
      goto LABEL_218;
    }
LABEL_219:
    CFBooleanRef v113 = 0;
    CFDictionaryRef Mutable = 0;
    goto LABEL_220;
  }
  if ((char)*v102 < 0)
  {
    CFNumberRef v103 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
      goto LABEL_219;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV3";
    size_t v104 = "%s failed, FORD unexpected for unencrypted file";
    goto LABEL_218;
  }
  uint64_t v105 = (*(uint64_t (**)(uint64_t))(a2 + 8))(a1);
  if (!v105)
  {
    CFNumberRef v103 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v103, OS_LOG_TYPE_ERROR)) {
      goto LABEL_219;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV3";
    size_t v104 = "%s failed, cannot have NULL fileVerificationKey";
    goto LABEL_218;
  }
  CFDataRef v106 = (const __CFData *)v105;
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
LABEL_233:
    CFBooleanRef v113 = 0;
    goto LABEL_220;
  }
  for (uint64_t i = 0; i != v101; ++i)
  {
    unint64_t v109 = (const void *)(*(unsigned int (**)(uint64_t, uint64_t))(a2 + 32))(a1, i);
    *(void *)long long buf = 0;
    CFStringRef Value = CFDictionaryGetValue(Mutable, v109);
    *(void *)long long buf = Value;
    if (!Value)
    {
      if (!mmcs_index_set_create((uint64_t *)buf)) {
        goto LABEL_233;
      }
      CFDictionarySetValue(Mutable, v109, *(const void **)buf);
      CFStringRef Value = *(const void **)buf;
      if (*(void *)buf)
      {
        C3BaseRelease(*(CFTypeRef *)buf);
        CFStringRef Value = *(const void **)buf;
      }
    }
    mmcs_index_set_add_index((uint64_t)Value, i);
  }
  *(void *)long long buf = 0;
  mmcs_index_set_create((uint64_t *)buf);
  CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)_chunkLengthIndexSetChecker, *(void **)buf);
  if (!mmcs_index_set_contains_range(*(uint64_t *)buf, 0, (int)v101 - 1))
  {
    uint64_t v111 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v150 = 0;
      _os_log_impl(&dword_1DC1CA000, v111, OS_LOG_TYPE_ERROR, "index set missing indexes", v150, 2u);
    }
  }
  if (mmcs_index_set_count(*(uint64_t *)buf) != v101)
  {
    CFMutableArrayRef v112 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v150 = 0;
      _os_log_impl(&dword_1DC1CA000, v112, OS_LOG_TYPE_ERROR, "index set wrong number of indexes", v150, 2u);
    }
  }
  if (*(void *)buf) {
    C3BaseRelease(*(CFTypeRef *)buf);
  }
  CFBooleanRef v113 = (void **)mmcs_create_FileReferenceData(v8);
  if (!v113 || (uint64_t v114 = malloc_type_malloc(0x48uLL, 0x10F00406B62C39FuLL)) == 0)
  {
LABEL_220:
    CFStringRef v135 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v150 = 0;
      _os_log_impl(&dword_1DC1CA000, v135, OS_LOG_TYPE_ERROR, "mmcs_item_create_FileReferenceData failed to create fileReferenceData", v150, 2u);
    }
    if (v113)
    {
      mmcs_free_FileReferenceData(v113);
      CFBooleanRef v113 = 0;
    }
    goto LABEL_224;
  }
  CFStringRef v115 = v114;
  opaque__file_reference_data__v3__init((uint64_t)v114);
  v113[5] = v115;
  uint64_t v116 = CFDataGetBytePtr(v106);
  CFIndex v117 = CFDataGetLength(v106);
  BOOL v118 = v116 != 0;
  BOOL v119 = v117 != 0;
  BOOL v120 = !v118 || !v119;
  if (v118 && v119) {
    CFIndex v121 = v117;
  }
  else {
    CFIndex v121 = 0;
  }
  if (v120) {
    char v122 = 0;
  }
  else {
    char v122 = v116;
  }
  v115[3] = v121;
  v115[4] = v122;
  char v123 = malloc_type_malloc(8 * v101, 0x2004093837F09uLL);
  if (!v123)
  {
    unint64_t v137 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v137, OS_LOG_TYPE_ERROR)) {
      goto LABEL_220;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v138 = "mmcs_item_create_FileReferenceData failed to allocate chunk list";
    uint64_t v139 = v137;
    uint32_t v140 = 2;
    goto LABEL_243;
  }
  uint64_t v124 = 0;
  v115[6] = v123;
  if (v101 <= 1) {
    uint64_t v125 = 1;
  }
  else {
    uint64_t v125 = v101;
  }
  uint64_t v149 = v125;
  while (2)
  {
    unint64_t v126 = (unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a1, v124);
    uint64_t v127 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 48))(a1, v124);
    uint64_t v128 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 32))(a1, v124);
    uint64_t v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(a1, v124);
    if ((*v126 & 0x7F) != 4)
    {
      uint64_t v141 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v141, OS_LOG_TYPE_ERROR)) {
        goto LABEL_220;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceDataUsingV3";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v124;
      uint64_t v138 = "%s observed inconsistent signature type between registerItem->signature and registerItem->chunks[%llu]->signature.";
      uint64_t v139 = v141;
      uint32_t v140 = 22;
LABEL_243:
      _os_log_impl(&dword_1DC1CA000, v139, OS_LOG_TYPE_ERROR, v138, buf, v140);
      goto LABEL_220;
    }
    if ((*v126 & 0x80) == 0)
    {
      uint64_t v142 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v142, OS_LOG_TYPE_ERROR)) {
        goto LABEL_220;
      }
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v124;
      uint64_t v138 = "mmcs_item_create_FileReferenceData observed inconsistent encryption between registerItem->signature and reg"
             "isterItem->ri_chunkInstances[%llu].chunkReference->signature.";
LABEL_242:
      uint64_t v139 = v142;
      uint32_t v140 = 12;
      goto LABEL_243;
    }
    FileReferenceDataV3Chunk = mmcs_create_FileReferenceDataV3Chunk(v127, v128, v129);
    if (!FileReferenceDataV3Chunk)
    {
      uint64_t v142 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v142, OS_LOG_TYPE_ERROR)) {
        goto LABEL_220;
      }
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v124;
      uint64_t v138 = "mmcs_item_create_FileReferenceData observed error processing registerItem->ri_chunkInstances[%llu].chunkReference";
      goto LABEL_242;
    }
    uint64_t v132 = v115[5];
    uint64_t v131 = v115[6];
    v115[5] = v132 + 1;
    *(void *)(v131 + 8 * v132) = FileReferenceDataV3Chunk;
    if (v149 != ++v124) {
      continue;
    }
    break;
  }
  CFIndex Count = CFDictionaryGetCount(Mutable);
  uint64_t v134 = malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  v115[8] = v134;
  if (!v134) {
    goto LABEL_220;
  }
  *(void *)&uint8_t buf[8] = 0;
  *(void *)&uint8_t buf[16] = 1;
  *(void *)long long buf = v115;
  CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)_add_index_set, buf);
  if (!buf[16]) {
    goto LABEL_220;
  }
LABEL_224:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (!v113)
  {
    CFNumberRef v94 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "mmcs_generic_item_create_FileReferenceData";
LABEL_159:
      _os_log_impl(&dword_1DC1CA000, v94, OS_LOG_TYPE_ERROR, "%s failed, cannot have NULL fileReferenceData", buf, 0xCu);
    }
LABEL_160:
    mmcs_free_FileReferenceData(v16);
    return 0;
  }
  unint64_t v136 = opaque__file_reference_data__get_packed_size(v113);
  if (v136 && opaque__file_reference_data__get_packed_size(v16) > v136)
  {
    mmcs_free_FileReferenceData(v16);
    return v113;
  }
  else
  {
    mmcs_free_FileReferenceData(v113);
  }
  return v16;
}

uint64_t mmcs_create_file_reference_data_with_cfdata(void **a1)
{
  size_t packed_size = opaque__file_reference_data__get_packed_size(a1);
  if (packed_size)
  {
    CFIndex v3 = packed_size;
    CFDataRef v4 = (UInt8 *)malloc_type_malloc(packed_size, 0x4EA161EBuLL);
    if (v4)
    {
      CFTypeID v5 = v4;
      if (v3 == opaque__file_reference_data__pack(a1, (uint64_t)v4))
      {
        CFDataRef v6 = XCFDataCreateWithBytesNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v5, v3, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
        if (v6)
        {
          CFDataRef v7 = v6;
          uint64_t v8 = PCSMMCSCopyEncryptedData();
          CFRelease(v7);
          return v8;
        }
        uint64_t v13 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          goto LABEL_16;
        }
        __int16 v16 = 0;
        CFDataRef v14 = "mmcs_create_file_reference_data_with_cfdata failed to allocate CFData wrapping body buffer";
        uint32_t v15 = (uint8_t *)&v16;
      }
      else
      {
        uint64_t v13 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
LABEL_16:
          free(v5);
          return 0;
        }
        __int16 v17 = 0;
        CFDataRef v14 = "mmcs_create_file_reference_data_with_cfdata failed to serialize fileReferenceData to expected size";
        uint32_t v15 = (uint8_t *)&v17;
      }
      _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, v14, v15, 2u);
      goto LABEL_16;
    }
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      CFDataRef v11 = "mmcs_create_file_reference_data_with_cfdata failed to allocate buffer for serialized fileReferenceData";
      CFStringRef v12 = buf;
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      __int16 v19 = 0;
      CFDataRef v11 = "mmcs_create_file_reference_data_with_cfdata invalid size for serialized fileReferenceData";
      CFStringRef v12 = (uint8_t *)&v19;
LABEL_10:
      _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, v11, v12, 2u);
    }
  }
  return 0;
}

void **mmcs_free_FileReferenceData(void **result)
{
  if (result)
  {
    CFStringRef v1 = result;
    result[6] = 0;
    CFTypeID v2 = result[7];
    if (v2) {
      free(v2);
    }
    v1[7] = 0;
    CFIndex v3 = v1[3];
    if (v3)
    {
      unint64_t v4 = v3[3];
      if (v4)
      {
        for (unint64_t i = 0; i < v4; ++i)
        {
          uint64_t v6 = *(void *)(v3[4] + 8 * i);
          if (v6)
          {
            *(_DWORD *)(v6 + 64) = 0;
            *(void *)(v6 + 24) = 0;
            *(void *)(v6 + 32) = 0;
            *(void *)(v6 + 72) = 0;
            *(void *)(v6 + 80) = 0;
            unint64_t v4 = v3[3];
          }
        }
      }
      v3[6] = 0;
      v3[7] = 0;
    }
    CFDataRef v7 = v1[4];
    if (v7)
    {
      unint64_t v8 = v7[5];
      if (v8)
      {
        for (unint64_t j = 0; j < v8; ++j)
        {
          uint64_t v10 = *(void *)(v7[6] + 8 * j);
          if (v10 && *(void *)(v10 + 40))
          {
            unint64_t v11 = 0;
            uint64_t v12 = *(void *)(v10 + 48);
            do
            {
              uint64_t v13 = *(void *)(v12 + 8 * v11);
              *(void *)(v13 + 24) = 0;
              *(void *)(v13 + 32) = 0;
              uint64_t v14 = *(void *)(*(void *)(v10 + 48) + 8 * v11);
              *(void *)(v14 + 48) = 0;
              *(void *)(v14 + 56) = 0;
              unint64_t v15 = *(void *)(v10 + 40);
              uint64_t v12 = *(void *)(v10 + 48);
              *(_DWORD *)(*(void *)(v12 + 8 * v11++) + 40) = 0;
            }
            while (v11 < v15);
            unint64_t v8 = v7[5];
          }
        }
      }
      v7[3] = 0;
      v7[4] = 0;
    }
    __int16 v16 = v1[5];
    if (v16)
    {
      unint64_t v17 = v16[5];
      if (v17)
      {
        for (unint64_t k = 0; k < v17; ++k)
        {
          uint64_t v19 = *(void *)(v16[6] + 8 * k);
          if (v19)
          {
            *(void *)(v19 + 24) = 0;
            *(void *)(v19 + 32) = 0;
            *(_DWORD *)(v19 + 40) = 0;
            *(void *)(v19 + 48) = 0;
            *(void *)(v19 + 56) = 0;
            unint64_t v17 = v16[5];
          }
        }
      }
      v16[3] = 0;
      v16[4] = 0;
    }
    return opaque__file_reference_data__free_unpacked(v1, 0);
  }
  return result;
}

uint64_t mmcs_register_item_create_FileOpaqueReferenceData(uint64_t a1)
{
  if (a1)
  {
    FileReferenceCFDataRef Data = mmcs_generic_item_create_FileReferenceData(a1, (uint64_t)mmcs_register_item_generic_item_callbacks);
    if (FileReferenceData)
    {
      CFIndex v3 = FileReferenceData;
      unint64_t v4 = *(const void **)(a1 + 32);
      if (v4)
      {
        CFTypeID v5 = CFGetTypeID(v4);
        if (v5 == CFDataGetTypeID())
        {
          uint64_t file_reference_data_with_cfdata = mmcs_create_file_reference_data_with_cfdata(v3);
          if (file_reference_data_with_cfdata)
          {
LABEL_20:
            mmcs_free_FileReferenceData(v3);
            return file_reference_data_with_cfdata;
          }
          CFDataRef v7 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            __int16 v14 = 0;
            unint64_t v8 = "mmcs_register_item_create_FileOpaquedReferenceData failed to create cfdata from fileReferenceData.";
            uint64_t v9 = (uint8_t *)&v14;
LABEL_18:
            _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, v8, v9, 2u);
          }
        }
        else
        {
          CFDataRef v7 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)unint64_t v15 = 0;
            unint64_t v8 = "mmcs_register_item_create_FileOpaquedReferenceData must have CFDataRef referenceObject.";
            uint64_t v9 = v15;
            goto LABEL_18;
          }
        }
      }
      else
      {
        CFDataRef v7 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          __int16 v16 = 0;
          unint64_t v8 = "mmcs_register_item_create_FileOpaquedReferenceData cannot have NULL referenceObject.";
          uint64_t v9 = (uint8_t *)&v16;
          goto LABEL_18;
        }
      }
      uint64_t file_reference_data_with_cfdata = 0;
      goto LABEL_20;
    }
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      unint64_t v11 = "mmcs_register_item_create_FileOpaquedReferenceData failed to create fileReferenceData.";
      uint64_t v12 = buf;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      __int16 v18 = 0;
      unint64_t v11 = "mmcs_register_item_create_FileOpaquedReferenceData cannot have NULL registerItem.";
      uint64_t v12 = (uint8_t *)&v18;
LABEL_12:
      _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, v11, v12, 2u);
    }
  }
  return 0;
}

void mmcs_free_ChunkInfo(void *a1)
{
  if (a1)
  {
    a1[3] = 0;
    a1[4] = 0;
    CFTypeID v2 = (void *)a1[7];
    if (v2) {
      free(v2);
    }
    free(a1);
  }
}

CFIndex *mmcs_create_ChunkInfo(int a1, char *a2, const UInt8 *a3, __CFData *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    unint64_t v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFTypeRef cf = 0;
      uint64_t v12 = "ChunkInfo cannot have NULL chunkSignature.";
      goto LABEL_35;
    }
    return 0;
  }
  if (!a1)
  {
    unint64_t v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFTypeRef cf = 0;
      uint64_t v12 = "ChunkInfo cannot have zero length chunk.";
      goto LABEL_35;
    }
    return 0;
  }
  uint64_t v8 = CKChunkSchemeAndSignatureSize();
  if (!v8)
  {
    unint64_t v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFTypeRef cf = 0;
      uint64_t v12 = "ChunkInfo cannot have zero length chunkSignature.";
      goto LABEL_35;
    }
    return 0;
  }
  unint64_t v9 = v8;
  if (a3)
  {
    CFIndex v10 = CKChunkSchemeAndEncryptionKeySize();
    if (!v10)
    {
      unint64_t v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CFTypeRef cf = 0;
        uint64_t v12 = "ChunkInfo cannot have zero length chunkEncryptionSignature.";
LABEL_35:
        _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_ERROR, v12, cf, 2u);
        return 0;
      }
      return 0;
    }
  }
  else
  {
    CFIndex v10 = 0;
  }
  if (a4)
  {
    if ((*(void *)a4 == 0) != (*((void *)a4 + 1) == 0))
    {
      unint64_t v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CFTypeRef cf = 0;
        uint64_t v12 = "ChunkInfo cannot have partial complete pcs info.";
        goto LABEL_35;
      }
      return 0;
    }
    if (!a3 && *(void *)a4)
    {
      unint64_t v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CFTypeRef cf = 0;
        uint64_t v12 = "ChunkInfo cannot have reference signature without encryption signature.";
        goto LABEL_35;
      }
      return 0;
    }
  }
  uint64_t v13 = (CFIndex *)malloc_type_malloc(0x50uLL, 0x10700403FCE3692uLL);
  if (!v13)
  {
    unint64_t v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFTypeRef cf = 0;
      uint64_t v12 = "ChunkInfo failed to allocate Chunkserver__ChunkInfo";
      goto LABEL_35;
    }
    return 0;
  }
  __int16 v14 = v13;
  if (!a3)
  {
    CFDataRef v16 = 0;
    goto LABEL_39;
  }
  CFDataRef v15 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a3, v10);
  CFDataRef v16 = v15;
  if (!v15)
  {
    __int16 v18 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFTypeRef cf = 0;
      uint64_t v19 = "ChunkInfo failed to create schemeAndKey for chunkEncryptionSignature";
      CFStringRef v20 = cf;
      goto LABEL_57;
    }
LABEL_58:
    free(v14);
    __int16 v14 = 0;
    a4 = 0;
    goto LABEL_64;
  }
  if (a4)
  {
    CFDataRef v17 = (const __CFData *)*((void *)a4 + 1);
    if (v17)
    {
      *(void *)CFTypeRef cf = 0;
      a4 = mmcs_chunk_key_copy_wraptured_scheme_and_key(v15, v17, 1, (CFErrorRef *)cf);
      if (*(void *)cf) {
        CFRelease(*(CFTypeRef *)cf);
      }
      *(void *)CFTypeRef cf = 0;
      if (!a4)
      {
        __int16 v18 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          __int16 v29 = 0;
          uint64_t v19 = "ChunkInfo failed to create wrappedKey for chunkEncryptionSignature";
          CFStringRef v20 = (uint8_t *)&v29;
LABEL_57:
          _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_ERROR, v19, v20, 2u);
          goto LABEL_58;
        }
        goto LABEL_58;
      }
      goto LABEL_40;
    }
LABEL_39:
    a4 = 0;
  }
LABEL_40:
  if (gMMCS_DebugLevel < 4) {
    CFDictionaryRef Mutable = 0;
  }
  else {
    CFDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  }
  chunkserver__chunk_info__init(v14);
  *((_DWORD *)v14 + 16) = a1;
  v14[3] = v9;
  v14[4] = (CFIndex)a2;
  if (Mutable)
  {
    uint64_t v23 = hextostrdup(a2, v9);
    CFStringAppendFormat(Mutable, 0, @"chunk sig %s", v23);
    if (v23) {
      free(v23);
    }
    if (!a3) {
      goto LABEL_61;
    }
    *((_DWORD *)v14 + 10) = 1;
    BOOL v24 = mmcs_key_description_create_with_cfdata(v16, 1);
    CFStringAppendFormat(Mutable, 0, @" key %@", v24);
    if (v24) {
      CFRelease(v24);
    }
    if (a4)
    {
      CFStringRef StringDescription = XCFDataCreateStringDescription(a4);
      CFStringAppendFormat(Mutable, 0, @" encrypted key %@", StringDescription);
      if (StringDescription) {
        CFRelease(StringDescription);
      }
      goto LABEL_54;
    }
    goto LABEL_59;
  }
  if (a3)
  {
    *((_DWORD *)v14 + 10) = 1;
    if (a4)
    {
LABEL_54:
      BOOL v26 = v14 + 6;
      CFDataRef v27 = a4;
      goto LABEL_60;
    }
LABEL_59:
    BOOL v26 = v14 + 6;
    CFDataRef v27 = v16;
LABEL_60:
    ProtobufCBinaryData_SetData(v26, v27);
    if (!Mutable) {
      goto LABEL_64;
    }
LABEL_61:
    CFStringRef v28 = mmcs_logging_logger_chunk();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CFTypeRef cf = 138543362;
      *(void *)&cf[4] = Mutable;
      _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_DEFAULT, "ChunkInfo %{public}@", cf, 0xCu);
    }
    CFRelease(Mutable);
  }
LABEL_64:
  if (v16) {
    CFRelease(v16);
  }
  if (a4) {
    CFRelease(a4);
  }
  return v14;
}

_DWORD *mmcs_create_FordInfo(int a1)
{
  if (a1)
  {
    CFTypeID v2 = malloc_type_malloc(0x28uLL, 0x10600401BE82CDFuLL);
    CFIndex v3 = v2;
    if (v2)
    {
      chunkserver__ford_info__init((uint64_t)v2);
      v3[6] = 1;
      v3[7] = a1;
      v3[8] = 0;
    }
  }
  else
  {
    unint64_t v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_ERROR, "FordInfo cannot have zero length fileOpaqueReferenceDataLength.", v6, 2u);
    }
    return 0;
  }
  return v3;
}

void mmcs_free_ChunkingProfile(void *a1)
{
  if (a1)
  {
    CFTypeID v2 = (void *)a1[5];
    if (v2) {
      free(v2);
    }
    a1[5] = 0;
    CFIndex v3 = (void *)a1[6];
    if (v3) {
      free(v3);
    }
    a1[6] = 0;
    unint64_t v4 = (void *)a1[8];
    if (v4) {
      free(v4);
    }
    free(a1);
  }
}

_DWORD *mmcs_create_ChunkingProfile(uint64_t a1)
{
  if (a1)
  {
    CFTypeID v2 = malloc_type_malloc(0x48uLL, 0x10700402FA450D5uLL);
    CFIndex v3 = v2;
    if (v2)
    {
      chunkserver__file_chunk_list__chunking_profile__init((uint64_t)v2);
      v3[6] = 1;
      *((void *)v3 + 4) = *(void *)(a1 + 16);
      CFStringRef v4 = (const __CFString *)CKProfileResultsConfigurationVersion();
      if (v4) {
        *((void *)v3 + 6) = createCStringWithCFString(v4);
      }
      CFStringRef v5 = (const __CFString *)CKProfileResultsResolvedFileExtension();
      if (v5) {
        *((void *)v3 + 8) = createCStringWithCFString(v5);
      }
      if (CKProfileResultsType())
      {
        CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFDataRef v7 = (const char *)CKProfileTypeDescription();
        CFStringRef v8 = CFStringCreateWithCString(v6, v7, 0x8000100u);
        *((void *)v3 + 5) = createCStringWithCFString(v8);
        if (v8) {
          CFRelease(v8);
        }
      }
      CFBooleanRef IsDefault = (const __CFBoolean *)CKProfileResultsIsDefault();
      v3[14] = IsDefault != 0;
      if (IsDefault) {
        v3[15] = CFBooleanGetValue(IsDefault) != 0;
      }
    }
  }
  else
  {
    CFIndex v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v12[0] = 0;
      _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "chunkingProfile cannot be NULL.", (uint8_t *)v12, 2u);
    }
    return 0;
  }
  return v3;
}

void mmcs_free_FileChunkList(void *a1)
{
  if (a1)
  {
    a1[3] = 0;
    a1[4] = 0;
    a1[5] = 0;
    a1[9] = 0;
    a1[10] = 0;
    if (a1[6])
    {
      unint64_t v2 = 0;
      do
        mmcs_free_ChunkInfo(*(void **)(a1[7] + 8 * v2++));
      while (v2 < a1[6]);
    }
    if (a1[14])
    {
      unint64_t v3 = 0;
      do
        mmcs_free_ChunkingProfile(*(void **)(a1[15] + 8 * v3++));
      while (v3 < a1[14]);
    }
    CFStringRef v4 = (void *)a1[12];
    if (v4) {
      free(v4);
    }
    CFStringRef v5 = (void *)a1[7];
    if (v5) {
      free(v5);
    }
    a1[7] = 0;
    CFAllocatorRef v6 = (void *)a1[15];
    if (v6) {
      free(v6);
    }
    a1[15] = 0;
    CFDataRef v7 = (void *)a1[11];
    if (v7) {
      free(v7);
    }
    free(a1);
  }
}

_OWORD *mmcs_create_FileChunkList(uint64_t a1, uint64_t a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1)
  {
    uint64_t v19 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      __int16 v37 = 0;
      CFStringRef v20 = "FileChunkList cannot have NULL fileSignature.";
      CFArrayRef v21 = (uint8_t *)&v37;
      goto LABEL_27;
    }
    return 0;
  }
  if (!a5)
  {
    uint64_t v19 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      __int16 v36 = 0;
      CFStringRef v20 = "FileChunkList cannot have zero length chunk.";
      CFArrayRef v21 = (uint8_t *)&v36;
      goto LABEL_27;
    }
    return 0;
  }
  if (!a6)
  {
    uint64_t v19 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      __int16 v35 = 0;
      CFStringRef v20 = "FileChunkList cannot have NULL chunkList.";
      CFArrayRef v21 = (uint8_t *)&v35;
      goto LABEL_27;
    }
    return 0;
  }
  uint64_t v17 = CKFileSchemeAndSignatureSize();
  if (!v17)
  {
    uint64_t v19 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      CFStringRef v20 = "FileChunkList cannot have zero length fileSignature.";
      CFArrayRef v21 = buf;
      goto LABEL_27;
    }
    return 0;
  }
  uint64_t v18 = v17;
  if (a4 && (*(void *)a4 == 0) != (*(void *)(a4 + 8) == 0))
  {
    uint64_t v19 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      __int16 v33 = 0;
      CFStringRef v20 = "FileChunkList cannot have partial complete pcs info.";
      CFArrayRef v21 = (uint8_t *)&v33;
LABEL_27:
      _os_log_impl(&dword_1DC1CA000, v19, OS_LOG_TYPE_ERROR, v20, v21, 2u);
      return 0;
    }
    return 0;
  }
  CFDictionaryRef v22 = malloc_type_malloc(0x80uLL, 0x10F00400DC2D0DAuLL);
  uint64_t v23 = v22;
  if (v22)
  {
    chunkserver__file_chunk_list__init(v22);
    *((void *)v23 + 3) = v18;
    *((void *)v23 + 4) = a1;
    if (a4 && (CFDataRef v24 = *(const __CFData **)a4) != 0)
    {
      *((_DWORD *)v23 + 16) = 1;
      BytePtr = CFDataGetBytePtr(v24);
      CFIndex Length = CFDataGetLength(*(CFDataRef *)a4);
      BOOL v27 = BytePtr != 0;
      BOOL v28 = Length != 0;
      BOOL v29 = !v27 || !v28;
      if (v27 && v28) {
        CFIndex v30 = Length;
      }
      else {
        CFIndex v30 = 0;
      }
      if (v29) {
        uint64_t v31 = 0;
      }
      else {
        uint64_t v31 = BytePtr;
      }
      *((void *)v23 + 9) = v30;
      *((void *)v23 + 10) = v31;
    }
    else
    {
      *((_DWORD *)v23 + 16) = 0;
      *((void *)v23 + 9) = 0;
      *((void *)v23 + 10) = 0;
    }
    *((void *)v23 + 5) = a2;
    if (a3) {
      *((void *)v23 + 11) = createCStringWithCFString(a3);
    }
    *((void *)v23 + 6) = a5;
    *((void *)v23 + 7) = a6;
    if (a7) {
      *((void *)v23 + 12) = a7;
    }
    if (a8 && a9)
    {
      *((void *)v23 + 14) = a8;
      *((void *)v23 + 15) = a9;
    }
  }
  return v23;
}

void mmcs_free_FileChunkLists(void *a1)
{
  if (a1)
  {
    if (a1[3])
    {
      unint64_t v2 = 0;
      do
        mmcs_free_FileChunkList(*(void **)(a1[4] + 8 * v2++));
      while (v2 < a1[3]);
    }
    unint64_t v3 = (void *)a1[4];
    if (v3) {
      free(v3);
    }
    a1[4] = 0;
    CFStringRef v4 = (void *)a1[10];
    if (v4) {
      free(v4);
    }
    free(a1);
  }
}

void *mmcs_create_FileChunkLists(int a1, int a2, uint64_t a3, const __CFData *a4, uint64_t a5)
{
  if (!a3)
  {
    uint64_t v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      __int16 v20 = 0;
      __int16 v14 = "FileChunkLists cannot have zero length chunk count.";
      CFDataRef v15 = (uint8_t *)&v20;
LABEL_18:
      _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, v14, v15, 2u);
    }
    return 0;
  }
  if (!a5)
  {
    uint64_t v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v19 = 0;
      __int16 v14 = "FileChunkLists cannot have NULL fileChunkLists.";
      CFDataRef v15 = v19;
      goto LABEL_18;
    }
    return 0;
  }
  CFIndex v10 = malloc_type_malloc(0x58uLL, 0x10F00405CAB4923uLL);
  chunkserver__file_chunk_lists__init((uint64_t)v10);
  v10[3] = a3;
  void v10[4] = a5;
  *((_DWORD *)v10 + 12) = 1;
  v10[7] = 65;
  if (a1 && a2) {
    mmcs_create_FileChunkLists_cold_1();
  }
  if (a1 == 2 && !a4)
  {
    v10[7] = 81;
    unint64_t v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_INFO, "Asking for Inline Put Complete Request Version 2", buf, 2u);
    }
  }
  if (a2)
  {
    v10[7] |= 2uLL;
    uint64_t v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_INFO, "Request LAN Asset Cache Headers", v17, 2u);
    }
  }
  if (a4)
  {
    ProtobufCBinaryData_SetData(v10 + 9, a4);
    *((_DWORD *)v10 + 16) = 1;
  }
  return v10;
}

void *mmcs_put_request_create_FileChunkLists(uint64_t a1)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v43 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v44 = "PutRequest cannot be NULL.";
LABEL_55:
    _os_log_impl(&dword_1DC1CA000, v43, OS_LOG_TYPE_ERROR, v44, buf, 2u);
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 304);
  if (!v2)
  {
    uint64_t v43 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v44 = "PutRequest cannot have NULL putState.";
    goto LABEL_55;
  }
  if (!*(void *)(v2 + 144))
  {
    uint64_t v43 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v44 = "PutRequest cannot have zero state item count.";
    goto LABEL_55;
  }
  unint64_t Count = CFSetGetCount(*(CFSetRef *)(v2 + 56));
  size_t v4 = 8 * Count;
  MEMORY[0x1F4188790](Count);
  CFStringRef v5 = (char *)&v61 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero((char *)&v61 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0), v4);
  bzero((char *)&v61 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0), v4);
  uint64_t v6 = *(void *)(a1 + 304);
  if (!*(void *)(v6 + 144)) {
    goto LABEL_51;
  }
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  uint64_t v9 = 152;
  do
  {
    uint64_t v10 = v6 + v9;
    CFStringRef Value = CFSetGetValue(*(CFSetRef *)(v6 + 56), (const void *)(v6 + v9));
    if (!Value)
    {
      uint64_t v43 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v44 = "PutRequest putState distinct item list corrupt";
        goto LABEL_55;
      }
      return 0;
    }
    if ((const void *)v10 == Value && mmcs_item_needs_put(v10))
    {
      if (v8 >= Count)
      {
        uint64_t v43 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        *(_WORD *)long long buf = 0;
        uint64_t v44 = "PutRequest too many distinct items!";
        goto LABEL_55;
      }
      *(void *)&v5[8 * v8++] = v10;
    }
    ++v7;
    uint64_t v6 = *(void *)(a1 + 304);
    v9 += 416;
  }
  while (v7 < *(void *)(v6 + 144));
  if (!v8)
  {
LABEL_51:
    uint64_t v43 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v44 = "PutRequest no items in the put request available";
      goto LABEL_55;
    }
    return 0;
  }
  uint64_t v12 = malloc_type_malloc(8 * v8, 0x2004093837F09uLL);
  for (uint64_t i = 0; i != v8; uint64_t i = v38 + 1)
  {
    uint64_t v14 = *(void *)&v5[8 * i];
    if (!v14) {
      mmcs_put_request_create_FileChunkLists_cold_1();
    }
    if (!*(unsigned char *)(v14 + 104))
    {
      FordInfo = 0;
      goto LABEL_21;
    }
    FileOpaqueReferenceCFDataRef Data = (const __CFData *)mmcs_item_create_FileOpaqueReferenceData(*(void *)&v5[8 * i]);
    *(void *)(v14 + 208) = FileOpaqueReferenceData;
    if (!FileOpaqueReferenceData)
    {
      uint64_t v55 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        CFStringRef v54 = "mmcs_item_create_FileChunkList failed to create fileOpaqueMetadataReference.";
LABEL_93:
        _os_log_impl(&dword_1DC1CA000, v55, OS_LOG_TYPE_ERROR, v54, buf, 2u);
      }
LABEL_78:
      v12[i] = 0;
      CFErrorRef v51 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC1CA000, v51, OS_LOG_TYPE_ERROR, "Unable to create file chunk list for item.", buf, 2u);
      }
      if (i)
      {
        for (uint64_t j = 0; j != i; ++j)
          mmcs_free_FileChunkList((void *)v12[j]);
      }
      free(v12);
      return 0;
    }
    int Length = CFDataGetLength(FileOpaqueReferenceData);
    if (!Length)
    {
      uint64_t v55 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        CFStringRef v54 = "mmcs_item_create_FileChunkList cannot have 0 length fileOpaqueMetadataReference.";
        goto LABEL_93;
      }
      goto LABEL_78;
    }
    FordInfo = mmcs_create_FordInfo(Length);
    if (!FordInfo)
    {
      uint64_t v55 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
        goto LABEL_78;
      }
      *(_WORD *)long long buf = 0;
      CFStringRef v54 = "mmcs_item_create_FileChunkList failed to create fordInfo.";
      goto LABEL_93;
    }
LABEL_21:
    uint64_t v65 = i;
    CFArrayRef v18 = *(const __CFArray **)(v14 + 112);
    if (v18)
    {
      CFIndex v19 = CFArrayGetCount(v18);
      uint64_t v20 = v19;
      if (v19 >= 1)
      {
        CFArrayRef v21 = malloc_type_malloc(8 * v19, 0x2004093837F09uLL);
        if (v21)
        {
          CFDictionaryRef v22 = v21;
          CFIndex v23 = 0;
          while (1)
          {
            CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v14 + 112), v23);
            ChunkingProfile = mmcs_create_ChunkingProfile((uint64_t)ValueAtIndex);
            v22[v23] = ChunkingProfile;
            if (!ChunkingProfile) {
              break;
            }
            if (v20 == ++v23) {
              goto LABEL_30;
            }
          }
          CFDataRef v64 = (void **)v22;
          CFStringRef v47 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_1DC1CA000, v47, OS_LOG_TYPE_ERROR, "chunkProfiles[i] undefined.", buf, 2u);
          }
          BOOL v27 = 0;
          uint64_t v29 = 0;
          uint64_t v20 = v23;
        }
        else
        {
          uint32_t v58 = FordInfo;
          long long v59 = v12;
          long long v60 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_1DC1CA000, v60, OS_LOG_TYPE_ERROR, "mmcs_item_create_FileChunkList failed to allocate chunkProfiles.", buf, 2u);
          }
          CFDataRef v64 = 0;
          BOOL v27 = 0;
          uint64_t v29 = 0;
          uint64_t v12 = v59;
          FordInfo = v58;
        }
        goto LABEL_64;
      }
      CFDictionaryRef v22 = 0;
    }
    else
    {
      CFDictionaryRef v22 = 0;
      uint64_t v20 = 0;
    }
LABEL_30:
    BOOL v26 = (void **)malloc_type_malloc(8 * *(void *)(v14 + 144), 0x2004093837F09uLL);
    if (!v26)
    {
      CFDataRef v64 = (void **)v22;
      long long v53 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC1CA000, v53, OS_LOG_TYPE_ERROR, "mmcs_item_create_FileChunkList failed to allocate chunks.", buf, 2u);
      }
      BOOL v27 = 0;
      uint64_t v29 = 0;
LABEL_64:
      if (FordInfo) {
        free(FordInfo);
      }
      if (v64)
      {
        if (v20 >= 1)
        {
          uint64_t v48 = v64;
          do
          {
            CFStringRef v49 = *v48++;
            mmcs_free_ChunkingProfile(v49);
            --v20;
          }
          while (v20);
        }
        free(v64);
      }
      uint64_t i = v65;
      if (v27)
      {
        if (v29)
        {
          long long v50 = v27;
          do
          {
            mmcs_free_ChunkInfo(*v50);
            if (*v50) {
              free(*v50);
            }
            *v50++ = 0;
            --v29;
          }
          while (v29);
        }
        free(v27);
      }
      goto LABEL_78;
    }
    BOOL v27 = v26;
    uint64_t v28 = *(void *)(v14 + 144);
    if (v28)
    {
      uint64_t v63 = v12;
      CFDataRef v64 = (void **)v22;
      int v62 = FordInfo;
      uint64_t v29 = 0;
      long long v66 = (__CFData *)(v14 + 64);
      uint64_t v30 = 56;
      while (1)
      {
        uint64_t v31 = *(void *)(*(void *)(v14 + 272) + v30);
        int v32 = mmcs_item_padded_chunk_length(v14, *(unsigned int *)(v31 + 4));
        if (*(unsigned char *)(v14 + 104))
        {
          __int16 v33 = 0;
          uint64_t v34 = 0;
        }
        else
        {
          uint64_t v34 = *(const UInt8 **)(v31 + 16);
          __int16 v33 = v66;
        }
        ChunkInfo = mmcs_create_ChunkInfo(v32, *(char **)(v31 + 8), v34, v33);
        v27[v29] = ChunkInfo;
        if (!ChunkInfo) {
          break;
        }
        ++v29;
        v30 += 104;
        if (v28 == v29)
        {
          uint64_t v36 = *(void *)(v14 + 144);
          FordInfo = v62;
          uint64_t v12 = v63;
          CFDictionaryRef v22 = v64;
          goto LABEL_40;
        }
      }
      uint64_t v45 = mmcs_logging_logger_default();
      BOOL v46 = os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
      FordInfo = v62;
      uint64_t v12 = v63;
      if (v46)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC1CA000, v45, OS_LOG_TYPE_ERROR, "chunks[i] undefined.", buf, 2u);
      }
      goto LABEL_64;
    }
    uint64_t v36 = 0;
LABEL_40:
    FileChunkList = mmcs_create_FileChunkList(*(void *)v14, *(void *)(v14 + 8), *(const __CFString **)(v14 + 200), v14 + 64, v36, (uint64_t)v27, (uint64_t)FordInfo, v20, (uint64_t)v22);
    if (!FileChunkList)
    {
      CFDataRef v64 = (void **)v22;
      long long v57 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC1CA000, v57, OS_LOG_TYPE_ERROR, "mmcs_register_item_create_FileReferenceData failed to create fileReferenceData", buf, 2u);
      }
      uint64_t v29 = v28;
      goto LABEL_64;
    }
    uint64_t v38 = v65;
    v12[v65] = FileChunkList;
  }
  int v39 = *(_DWORD *)(a1 + 68);
  int v40 = *(unsigned __int8 *)(a1 + 72);
  CFDataRef v41 = *(const __CFData **)(*(void *)(a1 + 304) + 120);
  return mmcs_create_FileChunkLists(v39, v40, v8, v41, (uint64_t)v12);
}

CFDataRef mmcs_put_request_create_AuthorizePutRequestBody(uint64_t a1)
{
  FileChunkLists = (void **)mmcs_put_request_create_FileChunkLists(a1);
  return mmcs_create_AuthorizePutRequestBody(FileChunkLists);
}

CFDataRef mmcs_create_AuthorizePutRequestBody(void **a1)
{
  if (a1)
  {
    size_t packed_size = chunkserver__file_chunk_lists__get_packed_size(a1);
    if (packed_size)
    {
      CFIndex v3 = packed_size;
      size_t v4 = (UInt8 *)malloc_type_malloc(packed_size, 0xF99FBD28uLL);
      if (v4)
      {
        CFStringRef v5 = v4;
        if (v3 == chunkserver__file_chunk_lists__pack(a1, (uint64_t)v4))
        {
          CFDataRef v6 = XCFDataCreateWithBytesNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v5, v3, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
          if (v6)
          {
LABEL_21:
            mmcs_free_FileChunkLists(a1);
            return v6;
          }
          unint64_t v7 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
            goto LABEL_19;
          }
          __int16 v15 = 0;
          unint64_t v8 = "AuthorizePutRequestBody failed to allocate CFData wrapping body buffer";
          uint64_t v9 = (uint8_t *)&v15;
        }
        else
        {
          unint64_t v7 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
LABEL_19:
            free(v5);
            goto LABEL_20;
          }
          *(_WORD *)CFDataRef v16 = 0;
          unint64_t v8 = "AuthorizePutRequestBody failed to create request body of expected size";
          uint64_t v9 = v16;
        }
        _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, v8, v9, 2u);
        goto LABEL_19;
      }
      unint64_t v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v17 = 0;
        uint64_t v12 = "AuthorizePutRequestBody failed to allocate request body buffer";
        uint64_t v13 = v17;
        goto LABEL_15;
      }
    }
    else
    {
      unint64_t v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        __int16 v18 = 0;
        uint64_t v12 = "AuthorizePutRequestBody invalid request size";
        uint64_t v13 = (uint8_t *)&v18;
LABEL_15:
        _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_ERROR, v12, v13, 2u);
      }
    }
LABEL_20:
    CFDataRef v6 = 0;
    goto LABEL_21;
  }
  uint64_t v10 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "AuthorizePutRequestBody cannot have NULL fileChunkLists.", buf, 2u);
  }
  return 0;
}

CFDataRef mmcs_register_request_create_AuthorizePutRequestBody(uint64_t a1)
{
  FileChunkLists = (void **)mmcs_register_request_create_FileChunkLists(a1);
  return mmcs_create_AuthorizePutRequestBody(FileChunkLists);
}

void *mmcs_register_request_create_FileChunkLists(uint64_t a1)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    CFArrayRef v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    CFDictionaryRef v22 = "RegisterRequest cannot be NULL.";
    goto LABEL_39;
  }
  uint64_t v2 = *(void *)(a1 + 304);
  if (!v2)
  {
    CFArrayRef v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    CFDictionaryRef v22 = "RegisterRequest cannot have NULL registerState.";
    goto LABEL_39;
  }
  CFArrayRef v3 = *(const __CFArray **)(v2 + 8);
  if (!v3)
  {
    CFArrayRef v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    CFDictionaryRef v22 = "RegisterRequest cannot have NULL registerItems.";
    goto LABEL_39;
  }
  if (CFArrayGetCount(v3) < 1)
  {
    CFArrayRef v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    CFDictionaryRef v22 = "RegisterRequest cannot have zero registerItems.";
    goto LABEL_39;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 8)) < 1) {
    goto LABEL_35;
  }
  CFIndex v5 = 0;
  uint64_t v6 = 0;
  *(void *)&long long v4 = 138412290;
  long long v87 = v4;
  do
  {
    unint64_t v7 = (__CFError *)*((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 8), v5) + 16);
    if (v7)
    {
      unint64_t v8 = mmcs_cferror_copy_description(v7);
      uint64_t v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = v87;
        unint64_t v90 = (unint64_t)v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "RegisterItem exited registration with error: %@", buf, 0xCu);
      }
      if (v8) {
        CFRelease(v8);
      }
    }
    else
    {
      ++v6;
    }
    ++v5;
  }
  while (v5 < CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 8)));
  if (!v6)
  {
LABEL_35:
    CFArrayRef v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    CFDictionaryRef v22 = "RegisterRequest had no items available after registration.";
    goto LABEL_39;
  }
  CFDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &registerItemSignatureEqualitySetCallbacks);
  if (CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 8)) >= 1)
  {
    CFIndex v11 = 0;
    do
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 8), v11);
      if (!ValueAtIndex[16])
      {
        uint64_t v13 = ValueAtIndex;
        if (!CFSetContainsValue(Mutable, ValueAtIndex)) {
          CFSetAddValue(Mutable, v13);
        }
      }
      ++v11;
    }
    while (v11 < CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 8)));
  }
  CFIndex Count = CFSetGetCount(Mutable);
  size_t v15 = 8 * Count;
  MEMORY[0x1F4188790]();
  CFDataRef v16 = (char *)&v81 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero((char *)&v81 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0), v15);
  if (CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 8)) < 1)
  {
    CFIndex v18 = 0;
  }
  else
  {
    CFIndex v17 = 0;
    CFIndex v18 = 0;
    do
    {
      CFIndex v19 = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 8), v17);
      if (!v19[16])
      {
        uint64_t v20 = v19;
        if (CFSetContainsValue(Mutable, v19))
        {
          if (v18 >= Count) {
            mmcs_register_request_create_FileChunkLists_cold_3();
          }
          *(void *)&v16[8 * v18] = v20;
          CFSetRemoveValue(Mutable, v20);
          ++v18;
        }
      }
      ++v17;
    }
    while (v17 < CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 8)));
  }
  if (v18 != Count) {
    mmcs_register_request_create_FileChunkLists_cold_2();
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (!Count)
  {
    CFArrayRef v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    CFDictionaryRef v22 = "RegisterRequest no items in the put request available";
LABEL_39:
    _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_ERROR, v22, buf, 2u);
    return 0;
  }
  CFDataRef v24 = malloc_type_malloc(v15, 0x2004093837F09uLL);
  BOOL v25 = v24;
  if (Count < 1) {
    return mmcs_create_FileChunkLists(*(_DWORD *)(a1 + 68), *(unsigned __int8 *)(a1 + 72), Count, *(const __CFData **)(*(void *)(a1 + 304) + 56), (uint64_t)v25);
  }
  uint64_t v26 = 0;
  uint64_t v84 = v24;
  uint64_t v82 = (char *)&v81 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  while (1)
  {
    uint64_t v27 = *(void *)&v16[8 * v26];
    if (!v27) {
      mmcs_register_request_create_FileChunkLists_cold_1();
    }
    unint64_t valuePtr = 0;
    if (!*(void *)(v27 + 80))
    {
      uint64_t v76 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
        goto LABEL_111;
      }
      *(_WORD *)long long buf = 0;
      BOOL v69 = "RegisterItem cannot have NULL chunks.";
      goto LABEL_133;
    }
    if (*(unsigned char *)(v27 + 64))
    {
      FileOpaqueReferenceCFDataRef Data = (const __CFData *)mmcs_register_item_create_FileOpaqueReferenceData(v27);
      if (!FileOpaqueReferenceData)
      {
        uint64_t v76 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
          goto LABEL_111;
        }
        *(_WORD *)long long buf = 0;
        BOOL v69 = "mmcs_register_item_create_FileChunkList failed to create fileOpaqueMetadataReference.";
        goto LABEL_133;
      }
      CFDataRef v29 = FileOpaqueReferenceData;
      int Length = CFDataGetLength(FileOpaqueReferenceData);
      CFRelease(v29);
      if (!Length)
      {
        uint64_t v76 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
          goto LABEL_111;
        }
        *(_WORD *)long long buf = 0;
        BOOL v69 = "mmcs_register_item_create_FileChunkList cannot have 0 length fileOpaqueMetadataReference.";
        goto LABEL_133;
      }
      FordInfo = mmcs_create_FordInfo(Length);
      if (!FordInfo)
      {
        uint64_t v76 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
          goto LABEL_111;
        }
        *(_WORD *)long long buf = 0;
        BOOL v69 = "mmcs_register_item_create_FileChunkList failed to create fordInfo";
LABEL_133:
        _os_log_impl(&dword_1DC1CA000, v76, OS_LOG_TYPE_ERROR, v69, buf, 2u);
        goto LABEL_111;
      }
    }
    else
    {
      FordInfo = 0;
    }
    CFArrayRef v32 = *(const __CFArray **)(v27 + 72);
    if (!v32)
    {
      uint64_t v36 = 0;
      uint64_t v34 = 0;
      goto LABEL_65;
    }
    CFIndex v33 = CFArrayGetCount(v32);
    uint64_t v34 = v33;
    if (v33 >= 1) {
      break;
    }
    uint64_t v36 = 0;
LABEL_65:
    int Value = CFNumberGetValue(*(CFNumberRef *)(v27 + 120), kCFNumberSInt64Type, &valuePtr);
    uint64_t v86 = v36;
    if (!Value)
    {
      BOOL v70 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        CFIndex v71 = "RegisterItem cannot parse registerItem->chunkCount value.";
        long long v72 = v70;
        uint32_t v73 = 2;
        goto LABEL_123;
      }
LABEL_137:
      uint64_t v43 = 0;
      goto LABEL_97;
    }
    if (!valuePtr)
    {
      int v74 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 134217984;
        unint64_t v90 = valuePtr;
        CFIndex v71 = "RegisterItem cannot registerItem->chunkCount has invalid value %llu.";
        long long v72 = v74;
        uint32_t v73 = 12;
LABEL_123:
        _os_log_impl(&dword_1DC1CA000, v72, OS_LOG_TYPE_ERROR, v71, buf, v73);
      }
      goto LABEL_137;
    }
    uint64_t v85 = v26;
    int v41 = *(char *)CFDataGetBytePtr(*(CFDataRef *)(v27 + 96));
    uint64_t v42 = malloc_type_malloc(8 * valuePtr, 0x2004093837F09uLL);
    if (!v42)
    {
      uint64_t v75 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC1CA000, v75, OS_LOG_TYPE_ERROR, "RegisterItem failed to allocate request chunk list.", buf, 2u);
      }
      uint64_t v43 = 0;
      BOOL v25 = v84;
      uint64_t v26 = v85;
      goto LABEL_97;
    }
    uint64_t v43 = v42;
    double v83 = FordInfo;
    if (valuePtr)
    {
      unint64_t v44 = 0;
      uint64_t v45 = *(void *)(v27 + 80);
      *(void *)&long long v87 = v27 + 24;
      while (1)
      {
        if (!v45)
        {
          long long v57 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
            goto LABEL_93;
          }
          *(_DWORD *)long long buf = 134218240;
          unint64_t v90 = v44 + 1;
          __int16 v91 = 2048;
          unint64_t v92 = valuePtr;
          uint32_t v58 = "RegisterItem chunk %llu of %llu not returned.";
          long long v59 = v57;
          uint32_t v60 = 22;
          goto LABEL_92;
        }
        if (v41 >= 0 != (CKRegisteredChunkKey() != 0)) {
          break;
        }
        uint64_t v46 = CKRegisteredChunkLength();
        int v47 = mmcs_register_item_padded_chunk_length(v27, v46);
        uint64_t v48 = (char *)CKRegisteredChunkSignature();
        int v49 = *(unsigned __int8 *)(v27 + 64);
        if (*(unsigned char *)(v27 + 64))
        {
          long long v50 = 0;
        }
        else
        {
          long long v50 = (const UInt8 *)CKRegisteredChunkKey();
          int v49 = *(unsigned __int8 *)(v27 + 64);
        }
        if (v49) {
          CFErrorRef v51 = 0;
        }
        else {
          CFErrorRef v51 = (__CFData *)v87;
        }
        ChunkInfo = mmcs_create_ChunkInfo(v47, v48, v50, v51);
        v43[v44] = ChunkInfo;
        if (!ChunkInfo) {
          goto LABEL_94;
        }
        v45 += CKRegisteredChunkSize();
        if (++v44 >= valuePtr) {
          goto LABEL_80;
        }
      }
      uint64_t v61 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
        goto LABEL_93;
      }
      *(_WORD *)long long buf = 0;
      uint32_t v58 = "RegisterItem inconsistent Encryption between File and Chunks.";
      long long v59 = v61;
      uint32_t v60 = 2;
LABEL_92:
      _os_log_impl(&dword_1DC1CA000, v59, OS_LOG_TYPE_ERROR, v58, buf, v60);
LABEL_93:
      v43[v44] = 0;
LABEL_94:
      int v62 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC1CA000, v62, OS_LOG_TYPE_ERROR, "chunkList[i] undefined.", buf, 2u);
      }
      unint64_t valuePtr = v44;
      BOOL v25 = v84;
      uint64_t v26 = v85;
      FordInfo = v83;
      goto LABEL_97;
    }
LABEL_80:
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v27 + 96));
    FordInfo = v83;
    FileChunkList = mmcs_create_FileChunkList((uint64_t)BytePtr, 0, 0, v27 + 24, valuePtr, (uint64_t)v43, (uint64_t)v83, v34, (uint64_t)v86);
    if (!FileChunkList)
    {
      long long v79 = mmcs_logging_logger_default();
      BOOL v80 = os_log_type_enabled(v79, OS_LOG_TYPE_ERROR);
      BOOL v25 = v84;
      uint64_t v26 = v85;
      if (v80)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC1CA000, v79, OS_LOG_TYPE_ERROR, "mmcs_register_item_create_FileReferenceData failed to create fileReferenceData", buf, 2u);
      }
      goto LABEL_97;
    }
    BOOL v25 = v84;
    uint64_t v55 = v85;
    v84[v85] = FileChunkList;
    uint64_t v26 = v55 + 1;
    CFDataRef v16 = v82;
    if (v26 == Count) {
      return mmcs_create_FileChunkLists(*(_DWORD *)(a1 + 68), *(unsigned __int8 *)(a1 + 72), Count, *(const __CFData **)(*(void *)(a1 + 304) + 56), (uint64_t)v25);
    }
  }
  __int16 v35 = (void **)malloc_type_malloc(8 * v33, 0x2004093837F09uLL);
  if (!v35)
  {
    long long v78 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v78, OS_LOG_TYPE_ERROR, "mmcs_item_create_FileChunkList failed to allocate chunkProfiles.", buf, 2u);
    }
    uint64_t v86 = 0;
    goto LABEL_137;
  }
  uint64_t v36 = v35;
  CFIndex v37 = 0;
  while (1)
  {
    uint64_t v38 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v27 + 72), v37);
    ChunkingProfile = mmcs_create_ChunkingProfile((uint64_t)v38);
    v36[v37] = ChunkingProfile;
    if (!ChunkingProfile) {
      break;
    }
    if (v34 == ++v37) {
      goto LABEL_65;
    }
  }
  uint64_t v86 = v36;
  uint64_t v56 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1DC1CA000, v56, OS_LOG_TYPE_ERROR, "chunkProfiles[i] undefined.", buf, 2u);
  }
  uint64_t v43 = 0;
  uint64_t v34 = v37;
LABEL_97:
  if (FordInfo) {
    free(FordInfo);
  }
  if (v86)
  {
    if (v34 >= 1)
    {
      uint64_t v63 = v86;
      do
      {
        CFDataRef v64 = *v63++;
        mmcs_free_ChunkingProfile(v64);
        --v34;
      }
      while (v34);
    }
    free(v86);
  }
  if (v43)
  {
    if (valuePtr)
    {
      for (unint64_t i = 0; i < valuePtr; ++i)
      {
        mmcs_free_ChunkInfo((void *)v43[i]);
        long long v66 = (void *)v43[i];
        if (v66) {
          free(v66);
        }
        v43[i] = 0;
      }
    }
    free(v43);
  }
LABEL_111:
  v25[v26] = 0;
  CFIndex v67 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1DC1CA000, v67, OS_LOG_TYPE_ERROR, "Unable to create file chunk list for item.", buf, 2u);
  }
  if (v26)
  {
    for (uint64_t j = 0; j != v26; ++j)
      mmcs_free_FileChunkList((void *)v25[j]);
  }
  free(v25);
  return 0;
}

CFDataRef mmcs_update_request_create_AuthorizePutRequestBody(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    CFIndex v19 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v20 = "updateRequest cannot be NULL.";
LABEL_39:
    _os_log_impl(&dword_1DC1CA000, v19, OS_LOG_TYPE_ERROR, v20, buf, 2u);
    goto LABEL_40;
  }
  uint64_t v2 = *(void *)(a1 + 304);
  if (!v2)
  {
    CFIndex v19 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v20 = "updateRequest cannot have NULL updateState.";
    goto LABEL_39;
  }
  CFArrayRef v3 = *(const __CFArray **)(v2 + 16);
  if (!v3)
  {
    CFIndex v19 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v20 = "updateRequest cannot have NULL updateItems.";
    goto LABEL_39;
  }
  if (CFArrayGetCount(v3) < 1)
  {
    CFIndex v19 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v20 = "updateRequest cannot have zero updateItems.";
    goto LABEL_39;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 16)) < 1) {
    goto LABEL_35;
  }
  CFIndex v4 = 0;
  uint64_t v5 = 0;
  do
  {
    uint64_t v6 = (__CFError *)*((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 16), v4) + 5);
    if (v6)
    {
      unint64_t v7 = mmcs_cferror_copy_description(v6);
      unint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v55 = v7;
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_ERROR, "updateItem exited registration with error: %@", buf, 0xCu);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
    else
    {
      ++v5;
    }
    ++v4;
  }
  while (v4 < CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 16)));
  if (!v5)
  {
LABEL_35:
    CFIndex v19 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v20 = "updateRequest had no items available after registration.";
    goto LABEL_39;
  }
  CFDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &_update_items_wrap_set_callbacks);
  if (CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 16)) >= 1)
  {
    CFIndex v10 = 0;
    do
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 16), v10);
      if (!ValueAtIndex[5])
      {
        uint64_t v12 = ValueAtIndex;
        if (!CFSetContainsValue(Mutable, ValueAtIndex)) {
          CFSetAddValue(Mutable, v12);
        }
      }
      ++v10;
    }
    while (v10 < CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 16)));
  }
  CFIndex Count = CFSetGetCount(Mutable);
  uint64_t v14 = malloc_type_calloc(Count, 8uLL, 0x80040B8603338uLL);
  if (CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 16)) < 1)
  {
    CFIndex v16 = 0;
  }
  else
  {
    CFIndex v15 = 0;
    CFIndex v16 = 0;
    do
    {
      CFIndex v17 = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 16), v15);
      if (!v17[5])
      {
        CFIndex v18 = v17;
        if (CFSetContainsValue(Mutable, v17))
        {
          if (v16 >= Count) {
            mmcs_update_request_create_AuthorizePutRequestBody_cold_3();
          }
          v14[v16] = v18;
          CFSetRemoveValue(Mutable, v18);
          ++v16;
        }
      }
      ++v15;
    }
    while (v15 < CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 16)));
  }
  if (v16 != Count) {
    mmcs_update_request_create_AuthorizePutRequestBody_cold_2();
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (!Count)
  {
    uint64_t v43 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v43, OS_LOG_TYPE_ERROR, "updateRequest no items in the put request available", buf, 2u);
    }
    goto LABEL_88;
  }
  CFIndex v23 = malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  CFDataRef v24 = v23;
  if (Count < 1)
  {
LABEL_60:
    free(v14);
    FileChunkLists = (void **)mmcs_create_FileChunkLists(0, 0, Count, *(const __CFData **)(*(void *)(a1 + 304) + 88), (uint64_t)v24);
    return mmcs_create_AuthorizePutRequestBody(FileChunkLists);
  }
  uint64_t v25 = 0;
  CFErrorRef v51 = v23;
  long long v52 = v14;
  CFIndex v50 = Count;
  while (1)
  {
    uint64_t v26 = (CFDataRef *)v14[v25];
    if (!v26) {
      mmcs_update_request_create_AuthorizePutRequestBody_cold_1();
    }
    CFArrayRef v27 = v26[12];
    if (!v27)
    {
      unint64_t v44 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        goto LABEL_82;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v45 = "updateItem cannot have NULL chunkSignatures.";
LABEL_73:
      _os_log_impl(&dword_1DC1CA000, v44, OS_LOG_TYPE_ERROR, v45, buf, 2u);
      goto LABEL_82;
    }
    if (!v26[13])
    {
      unint64_t v44 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        goto LABEL_82;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v45 = "updateItem cannot have NULL chunkKeys.";
      goto LABEL_73;
    }
    if (!CFArrayGetCount(v27))
    {
      unint64_t v44 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        goto LABEL_82;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v45 = "updateItem cannot have 0 chunkSignatures.";
      goto LABEL_73;
    }
    CFIndex v28 = CFArrayGetCount(v26[12]);
    if (v28 != CFArrayGetCount(v26[13]))
    {
      unint64_t v44 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        goto LABEL_82;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v45 = "updateItem cannot have a different number of signatures and keys.";
      goto LABEL_73;
    }
    CFIndex v29 = CFArrayGetCount(v26[12]);
    uint64_t v30 = (void **)malloc_type_malloc(8 * v29, 0x2004093837F09uLL);
    if (!v30)
    {
      unint64_t v44 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        goto LABEL_82;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v45 = "updateItem failed to allocate request chunk list.";
      goto LABEL_73;
    }
    uint64_t v31 = v30;
    uint64_t v53 = v25;
    CFIndex v32 = CFArrayGetCount(v26[12]);
    if (v32 >= 1)
    {
      CFIndex v33 = v32;
      for (CFIndex i = 0; i != v33; ++i)
      {
        CFDataRef v35 = (const __CFData *)CFArrayGetValueAtIndex(v26[12], i);
        CFDataRef v36 = (const __CFData *)CFArrayGetValueAtIndex(v26[13], i);
        CFNumberRef v37 = (const __CFNumber *)CFArrayGetValueAtIndex(v26[14], i);
        *(_DWORD *)long long buf = 0;
        CFNumberGetValue(v37, kCFNumberSInt32Type, buf);
        int v38 = *(_DWORD *)buf;
        BytePtr = (char *)CFDataGetBytePtr(v35);
        int v40 = CFDataGetBytePtr(v36);
        v31[i] = mmcs_create_ChunkInfo(v38, BytePtr, v40, (__CFData *)(v26 + 10));
      }
    }
    int v41 = CFDataGetBytePtr(v26[2]);
    FileChunkList = mmcs_create_FileChunkList((uint64_t)v41, 0, 0, (uint64_t)(v26 + 10), v29, (uint64_t)v31, 0, 0, 0);
    if (!FileChunkList) {
      break;
    }
    CFIndex Count = v50;
    CFDataRef v24 = v51;
    uint64_t v14 = v52;
    v51[v53] = FileChunkList;
    uint64_t v25 = v53 + 1;
    if (v53 + 1 == v50) {
      goto LABEL_60;
    }
  }
  uint64_t v46 = mmcs_logging_logger_default();
  CFDataRef v24 = v51;
  uint64_t v14 = v52;
  uint64_t v25 = v53;
  if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1DC1CA000, v46, OS_LOG_TYPE_ERROR, "mmcs_update_item_create_FileChunkList failed to create fileReferenceData", buf, 2u);
  }
  if (v29)
  {
    int v47 = v31;
    do
    {
      mmcs_free_ChunkInfo(*v47);
      if (*v47) {
        free(*v47);
      }
      *v47++ = 0;
      --v29;
    }
    while (v29);
  }
  free(v31);
LABEL_82:
  v24[v25] = 0;
  uint64_t v48 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1DC1CA000, v48, OS_LOG_TYPE_ERROR, "Unable to create file chunk list for item.", buf, 2u);
  }
  if (v25)
  {
    for (uint64_t j = 0; j != v25; ++j)
      mmcs_free_FileChunkList((void *)v24[j]);
  }
  free(v24);
LABEL_88:
  free(v14);
LABEL_40:
  FileChunkLists = 0;
  return mmcs_create_AuthorizePutRequestBody(FileChunkLists);
}

CFDataRef mmcs_create_put_complete_at_edge_payload_trailer(const __CFData *a1, const __CFData *a2)
{
  CFIndex v4 = (CFIndex *)malloc_type_malloc(0x40uLL, 0x10700407A2CD8F7uLL);
  uint64_t v5 = v4;
  if (!v4)
  {
    CFIndex v15 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    __int16 v23 = 0;
    CFIndex v16 = "mmcs_create_put_complete_at_edge_payload_trailer failed to create protobuf object.";
    CFIndex v17 = (uint8_t *)&v23;
LABEL_17:
    _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_ERROR, v16, v17, 2u);
    goto LABEL_22;
  }
  chunkserver__put_complete_at_edge_payload_trailer__init(v4);
  ProtobufCBinaryData_SetData(v5 + 3, a1);
  if (a2)
  {
    *((_DWORD *)v5 + 10) = 1;
    ProtobufCBinaryData_SetData(v5 + 6, a2);
  }
  uint64_t packed_size = chunkserver__put_complete_at_edge_payload_trailer__get_packed_size((void **)v5);
  if (!packed_size)
  {
    CFIndex v15 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    __int16 v22 = 0;
    CFIndex v16 = "mmcs_create_put_complete_at_edge_payload_trailer invalid request size";
    CFIndex v17 = (uint8_t *)&v22;
    goto LABEL_17;
  }
  uint64_t v7 = packed_size;
  CFIndex v8 = packed_size + 4;
  if (packed_size + 4 <= 0) {
    mmcs_create_put_complete_at_edge_payload_trailer_cold_1();
  }
  uint64_t v9 = malloc_type_malloc(packed_size + 4, 0x1EE4726DuLL);
  if (!v9)
  {
    CFIndex v15 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      CFIndex v16 = "mmcs_create_put_complete_at_edge_payload_trailer failed to allocate request body buffer";
      CFIndex v17 = buf;
      goto LABEL_17;
    }
LABEL_22:
    CFDataRef v11 = 0;
    goto LABEL_23;
  }
  CFIndex v10 = v9;
  *uint64_t v9 = bswap32(v7);
  if (v7 != chunkserver__put_complete_at_edge_payload_trailer__pack((void **)v5, (uint64_t)(v9 + 1)))
  {
    uint64_t v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v20 = 0;
      uint64_t v13 = "mmcs_create_put_complete_at_edge_payload_trailer failed to create request body of expected size";
      uint64_t v14 = v20;
      goto LABEL_20;
    }
LABEL_21:
    free(v10);
    goto LABEL_22;
  }
  CFDataRef v11 = XCFDataCreateWithBytesNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (const UInt8 *)v10, v8, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
  if (!v11)
  {
    uint64_t v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      __int16 v19 = 0;
      uint64_t v13 = "mmcs_create_put_complete_at_edge_payload_trailer failed to allocate CFData wrapping body buffer";
      uint64_t v14 = (uint8_t *)&v19;
LABEL_20:
      _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, v13, v14, 2u);
      goto LABEL_21;
    }
    goto LABEL_21;
  }
LABEL_23:
  chunkserver__put_complete_at_edge_payload_trailer__free_unpacked((void **)v5, 0);
  return v11;
}

CFDataRef AuthorizeGetBodyCreate(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 304);
  uint64_t v3 = 80;
  if (!a2) {
    uint64_t v3 = 88;
  }
  if (*(void *)(v2 + 168))
  {
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    CFSetRef v8 = *(const __CFSet **)(v2 + v3);
    uint64_t v9 = 176;
    do
    {
      uint64_t v10 = v2 + v9;
      if ((const void *)(v2 + v9) == CFSetGetValue(v8, (const void *)(v2 + v9))
        && (a2 || mmcs_item_needs_auth_get_chunks(v10)))
      {
        ++v7;
      }
      ++v6;
      uint64_t v2 = *(void *)(a1 + 304);
      v9 += 416;
    }
    while (v6 < *(void *)(v2 + 168));
    if (v7 >= 1)
    {
      CFDataRef v11 = (void **)malloc_type_malloc(0x38uLL, 0x10E004083CC9259uLL);
      if (v11)
      {
        uint64_t v12 = v11;
        chunkserver__file_checksum_authorization_list__init((uint64_t)v11);
        v12[3] = 0;
        void v12[4] = malloc_type_malloc(8 * v7, 0x2004093837F09uLL);
        uint64_t v13 = *(void *)(a1 + 304);
        if (*(void *)(v13 + 168))
        {
          unint64_t v14 = 0;
          CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t v43 = v12;
          do
          {
            CFIndex v15 = (const void **)(v13 + 416 * v14 + 176);
            if (v15 == CFSetGetValue(v8, v15))
            {
              if (a2)
              {
                CFMutableSetRef MutableCopy = 0;
              }
              else
              {
                if (!mmcs_item_needs_auth_get_chunks((uint64_t)v15)) {
                  goto LABEL_35;
                }
                CFMutableSetRef MutableCopy = CFSetCreateMutableCopy(allocator, 0, *(CFSetRef *)(v13 + 416 * v14 + 464));
                CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 304) + 64), v15);
                if (CFArrayGetCount(Value) >= 1)
                {
                  CFIndex v25 = 0;
                  do
                  {
                    CFStringRef ValueAtIndex = (const void **)CFArrayGetValueAtIndex(Value, v25);
                    if (v15 != ValueAtIndex)
                    {
                      CFArrayRef v27 = (CFSetRef *)ValueAtIndex;
                      if (mmcs_item_needs_auth_get_chunks((uint64_t)ValueAtIndex)) {
                        XCFSetAddValuesFromSet(MutableCopy, v27[36]);
                      }
                    }
                    ++v25;
                  }
                  while (v25 < CFArrayGetCount(Value));
                }
              }
              CFIndex v17 = *v15;
              uint64_t v18 = v13 + 416 * v14;
              CFDataRef v19 = *(const __CFData **)(v18 + 224);
              uint64_t v20 = *(const char **)(v18 + 184);
              CFArrayRef v21 = malloc_type_malloc(0x60uLL, 0x1070040B2EF5D3EuLL);
              if (!v21)
              {
                chunkserver__file_checksum_authorization_list__free_unpacked(v43, 0);
                if (MutableCopy) {
                  CFRelease(MutableCopy);
                }
                goto LABEL_59;
              }
              __int16 v22 = v21;
              chunkserver__file_checksum_authorization__init(v21);
              *((void *)v22 + 3) = CKFileSchemeAndSignatureSize();
              *((void *)v22 + 4) = mmcs_file_signature_copy(v17);
              if (v19)
              {
                *((_DWORD *)v22 + 16) = 1;
                ProtobufCBinaryData_SetData((CFIndex *)v22 + 9, v19);
              }
              if (v20) {
                __int16 v23 = strdup(v20);
              }
              else {
                __int16 v23 = 0;
              }
              uint64_t v12 = v43;
              *((void *)v22 + 5) = v23;
              if (!a2)
              {
                CFIndex Count = CFSetGetCount(MutableCopy);
                *((void *)v22 + 6) = Count;
                *((void *)v22 + 7) = malloc_type_calloc(1uLL, 16 * Count, 0x1010040466105CCuLL);
                context[0] = v22;
                context[1] = 0;
                CFSetApplyFunction(MutableCopy, (CFSetApplierFunction)add_checksum_applier, context);
              }
              uint64_t v30 = v43[3];
              CFIndex v29 = v43[4];
              v43[3] = (char *)v30 + 1;
              v29[(void)v30] = v22;
              if (MutableCopy) {
                CFRelease(MutableCopy);
              }
            }
LABEL_35:
            ++v14;
            uint64_t v13 = *(void *)(a1 + 304);
          }
          while (v14 < *(void *)(v13 + 168));
        }
        if (*(unsigned char *)(a1 + 72))
        {
          *((_DWORD *)v12 + 10) = 1;
          unsigned int v12[6] = (void *)((unint64_t)v12[6] | 2);
          uint64_t v13 = *(void *)(a1 + 304);
        }
        if (*(unsigned char *)(v13 + 152))
        {
          *((_DWORD *)v12 + 10) = 1;
          unsigned int v12[6] = (void *)((unint64_t)v12[6] | 0x10);
        }
        size_t packed_size = chunkserver__file_checksum_authorization_list__get_packed_size(v12);
        if (packed_size)
        {
          CFIndex v32 = packed_size;
          CFIndex v33 = (UInt8 *)malloc_type_malloc(packed_size, 0xF6E7B525uLL);
          if (v33)
          {
            uint64_t v34 = v33;
            if (v32 == chunkserver__file_checksum_authorization_list__pack(v12, (uint64_t)v33))
            {
              CFDataRef v35 = XCFDataCreateWithBytesNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v34, v32, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
              if (v35)
              {
LABEL_56:
                chunkserver__file_checksum_authorization_list__free_unpacked(v12, 0);
                return v35;
              }
              CFDataRef v36 = mmcs_logging_logger_default();
              if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
                goto LABEL_54;
              }
              LOWORD(context[0]) = 0;
              CFNumberRef v37 = "AuthorizeGetBodyCreate failed to allocate CFData wrapping body buffer";
            }
            else
            {
              CFDataRef v36 = mmcs_logging_logger_default();
              if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
              {
LABEL_54:
                free(v34);
                goto LABEL_55;
              }
              LOWORD(context[0]) = 0;
              CFNumberRef v37 = "AuthorizeGetBodyCreate failed to create request body of expected size";
            }
            _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_ERROR, v37, (uint8_t *)context, 2u);
            goto LABEL_54;
          }
          int v38 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            LOWORD(context[0]) = 0;
            int v39 = "AuthorizeGetBodyCreate failed to allocate request body buffer";
            goto LABEL_50;
          }
        }
        else
        {
          int v38 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            LOWORD(context[0]) = 0;
            int v39 = "AuthorizeGetBodyCreate invalid request size";
LABEL_50:
            _os_log_impl(&dword_1DC1CA000, v38, OS_LOG_TYPE_ERROR, v39, (uint8_t *)context, 2u);
          }
        }
LABEL_55:
        CFDataRef v35 = 0;
        goto LABEL_56;
      }
    }
  }
LABEL_59:
  int v40 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
  {
    LOWORD(context[0]) = 0;
    _os_log_impl(&dword_1DC1CA000, v40, OS_LOG_TYPE_ERROR, "AuthorizeGetBodyCreate cannot have NULL fileCheksumAuthList.", (uint8_t *)context, 2u);
  }
  return 0;
}

__CFHTTPMessage *mmcs_get_proto_version(uint64_t a1)
{
  BOOL result = mmcs_http_context_copy_header_field_value(a1, @"x-apple-mmcs-proto-version");
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = mmcs_server_version_make_from_CFString((CFStringRef)result);
    CFRelease(v2);
    return (__CFHTTPMessage *)v3;
  }
  return result;
}

__CFHTTPMessage *mmcs_create_http_clock_skew_metrics_with_http_context(uint64_t a1)
{
  BOOL result = mmcs_http_context_copy_header_field_value(a1, @"Date");
  if (result)
  {
    uint64_t v3 = result;
    double v4 = mmcs_time_convert_date_header_to_cfabsolutetime((const __CFString *)result);
    CFRelease(v3);
    if (v4 == 0.0)
    {
      return 0;
    }
    else
    {
      uint64_t v6 = 0;
      double v5 = mmcs_http_context_response_received_time(a1);
      if (mmcs_http_clock_skew_metrics_create(&v6, v4, v5)) {
        return (__CFHTTPMessage *)v6;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t chunkserver__file_success__parse_and_validate(uint64_t a1, CFDataRef *a2, CFDataRef *a3, CFStringRef *a4, CFNumberRef *a5, CFErrorRef *a6)
{
  if (a2) {
    *a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  if (a6) {
    *a6 = 0;
  }
  if (mmcs_file_signature_is_valid_n(*(void *)(a1 + 32), *(void *)(a1 + 24)))
  {
    CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDataRef v18 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(const UInt8 **)(a1 + 32), *(void *)(a1 + 24));
    if (v18)
    {
      CFDataRef v19 = v18;
      if (*(_DWORD *)(a1 + 56))
      {
        CFDataRef v20 = CFDataCreate(v17, *(const UInt8 **)(a1 + 72), *(void *)(a1 + 64));
        if (!v20)
        {
          CFStringRef v21 = @"Invalid signature";
          goto LABEL_26;
        }
      }
      else
      {
        CFDataRef v20 = 0;
      }
      CFIndex v25 = *(const UInt8 **)(a1 + 48);
      if (v25)
      {
        size_t v26 = strlen(*(const char **)(a1 + 48));
        if (v26)
        {
          CFStringRef v27 = CFStringCreateWithBytes(v17, v25, v26, 0x8000100u, 0);
          if (v27)
          {
            CFStringRef v28 = v27;
            if (*(_DWORD *)(a1 + 80)) {
              CFNumberRef v29 = CFNumberCreate(v17, kCFNumberSInt64Type, (const void *)(a1 + 88));
            }
            else {
              CFNumberRef v29 = 0;
            }
            if ((*(_DWORD *)(a1 + 40) - 3) < 3)
            {
              if (a2)
              {
                CFRetain(v19);
                *a2 = v19;
              }
              if (a3 && v20)
              {
                CFRetain(v20);
                *a3 = v20;
              }
              if (a4)
              {
                CFRetain(v28);
                *a4 = v28;
              }
              CFErrorRef v23 = 0;
              uint64_t v24 = 1;
              if (a5 && v29)
              {
                CFRetain(v29);
                CFErrorRef v23 = 0;
                *a5 = v29;
              }
              goto LABEL_30;
            }
            CFErrorRef v23 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Invalid succes code %d when put receipt is present", v12, v13, v14, v15, v16, *(_DWORD *)(a1 + 40));
LABEL_27:
            uint64_t v24 = 0;
            if (a6 && v23)
            {
              CFRetain(v23);
              uint64_t v24 = 0;
              *a6 = v23;
            }
LABEL_30:
            CFRelease(v19);
            if (v20) {
              CFRelease(v20);
            }
            if (v28) {
              CFRelease(v28);
            }
            if (v29) {
              CFRelease(v29);
            }
            goto LABEL_36;
          }
        }
      }
      CFStringRef v21 = @"Invalid return receipt";
LABEL_26:
      CFErrorRef v23 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, v21, v12, v13, v14, v15, v16, v31);
      CFStringRef v28 = 0;
      CFNumberRef v29 = 0;
      goto LABEL_27;
    }
  }
  CFErrorRef v22 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Invalid signature", v12, v13, v14, v15, v16, v31);
  CFErrorRef v23 = v22;
  uint64_t v24 = 0;
  if (a6 && v22)
  {
    CFRetain(v22);
    uint64_t v24 = 0;
    *a6 = v23;
LABEL_37:
    CFRelease(v23);
    return v24;
  }
LABEL_36:
  if (v23) {
    goto LABEL_37;
  }
  return v24;
}

uint64_t chunkserver__file_error__parse_and_validate(uint64_t a1, CFDataRef *a2, CFDataRef *a3, CFErrorRef *a4, CFErrorRef *a5, CFIndex a6, CFStringRef format, ...)
{
  va_start(va, format);
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v14 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, format, va);
  if (a2) {
    *a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  if (mmcs_file_signature_is_valid_n(*(void *)(a1 + 32), *(void *)(a1 + 24)))
  {
    CFDataRef v20 = CFDataCreate(v13, *(const UInt8 **)(a1 + 32), *(void *)(a1 + 24));
    if (v20)
    {
      CFDataRef v21 = v20;
      if (*(_DWORD *)(a1 + 48))
      {
        CFDataRef v24 = CFDataCreate(v13, *(const UInt8 **)(a1 + 64), *(void *)(a1 + 56));
        if (!v24)
        {
          CFStringRef v25 = @"Invalid signature";
          CFIndex v26 = 6;
LABEL_25:
          CFErrorRef v27 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v26, v25, v22, v23, v17, v18, v19, v33);
          char v28 = 0;
          goto LABEL_26;
        }
      }
      else
      {
        CFDataRef v24 = 0;
      }
      CFErrorRef error_with_error_response_and_format = mmcs_cferror_create_error_with_error_response_and_format(1, 0, a6, *(__CFError **)(a1 + 40), @"%@", v17, v18, v19, (char)v14);
      if (error_with_error_response_and_format)
      {
        CFErrorRef v30 = error_with_error_response_and_format;
        if (a2)
        {
          CFRetain(v21);
          *a2 = v21;
        }
        if (a3 && v24)
        {
          CFRetain(v24);
          *a3 = v24;
        }
        if (a4)
        {
          CFRetain(v30);
          CFErrorRef v27 = 0;
          char v28 = 0;
          *a4 = v30;
        }
        else
        {
          CFErrorRef v27 = 0;
          char v28 = 0;
        }
        uint64_t v31 = 1;
        if (v14) {
          goto LABEL_30;
        }
        goto LABEL_31;
      }
      CFStringRef v25 = @"Unable to create CFError from Chunkserver__FileError";
      CFIndex v26 = 37;
      goto LABEL_25;
    }
  }
  CFErrorRef v27 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Invalid signature", v15, v16, v17, v18, v19, v33);
  CFDataRef v21 = 0;
  CFDataRef v24 = 0;
  char v28 = 1;
LABEL_26:
  uint64_t v31 = 0;
  CFErrorRef v30 = 0;
  if (a5 && v27)
  {
    CFRetain(v27);
    CFErrorRef v30 = 0;
    uint64_t v31 = 0;
    *a5 = v27;
  }
  if (v14) {
LABEL_30:
  }
    CFRelease(v14);
LABEL_31:
  if ((v28 & 1) == 0) {
    CFRelease(v21);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v30) {
    CFRelease(v30);
  }
  if (v27) {
    CFRelease(v27);
  }
  return v31;
}

CFErrorRef create_cferror_with_error_response(__CFError *a1)
{
  CFErrorRef error_with_underlying_errors = a1;
  if (a1)
  {
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (*((void *)a1 + 6))
    {
      CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      if (*((void *)error_with_underlying_errors + 6))
      {
        unint64_t v4 = 0;
        do
        {
          cferror_with_error_response = (const void *)create_cferror_with_error_response(*(void *)(*((void *)error_with_underlying_errors + 7) + 8 * v4));
          if (cferror_with_error_response)
          {
            uint64_t v6 = cferror_with_error_response;
            CFArrayAppendValue(Mutable, cferror_with_error_response);
            CFRelease(v6);
          }
          ++v4;
        }
        while (v4 < *((void *)error_with_underlying_errors + 6));
      }
    }
    else
    {
      CFDictionaryRef Mutable = 0;
    }
    if (*((void *)error_with_underlying_errors + 8))
    {
      uint64_t v7 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (*((void *)error_with_underlying_errors + 8))
      {
        for (unint64_t i = 0; i < *((void *)error_with_underlying_errors + 8); ++i)
        {
          uint64_t v9 = *(void *)(*((void *)error_with_underlying_errors + 9) + 8 * i);
          if (v9)
          {
            size_t v10 = strlen(*(const char **)(v9 + 24));
            CFStringRef v11 = CFStringCreateWithBytes(v2, *(const UInt8 **)(v9 + 24), v10, 0x8000100u, 0);
            uint64_t v12 = *(const char **)(v9 + 32);
            size_t v13 = strlen(v12);
            CFStringRef v14 = CFStringCreateWithBytes(v2, (const UInt8 *)v12, v13, 0x8000100u, 0);
            CFStringRef v15 = v14;
            if (v11) {
              BOOL v16 = v14 == 0;
            }
            else {
              BOOL v16 = 1;
            }
            if (!v16)
            {
              CFDictionarySetValue(v7, v11, v14);
LABEL_24:
              CFRelease(v11);
              if (!v15) {
                continue;
              }
LABEL_21:
              CFRelease(v15);
              continue;
            }
            if (v11) {
              goto LABEL_24;
            }
            if (v14) {
              goto LABEL_21;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v7 = 0;
    }
    uint64_t v17 = (UInt8 *)*((void *)error_with_underlying_errors + 5);
    if (v17)
    {
      size_t v18 = strlen(*((const char **)error_with_underlying_errors + 5));
      uint64_t v17 = (UInt8 *)CFStringCreateWithBytes(v2, v17, v18, 0x8000100u, 0);
    }
    if (*((void *)error_with_underlying_errors + 3)) {
      uint64_t v19 = (const char *)*((void *)error_with_underlying_errors + 3);
    }
    else {
      uint64_t v19 = "";
    }
    size_t v20 = strlen(v19);
    CFStringRef v21 = CFStringCreateWithBytes(v2, (const UInt8 *)v19, v20, 0x8000100u, 0);
    CFStringRef v22 = v21;
    if (!v21) {
      CFStringRef v21 = @"Unknown Error Domain";
    }
    CFErrorRef error_with_underlying_errors = mmcs_cferror_create_error_with_underlying_errors(v21, *((int *)error_with_underlying_errors + 8), v17, Mutable, v7);
    if (v22) {
      CFRelease(v22);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v7) {
      CFRelease(v7);
    }
    if (v17) {
      CFRelease(v17);
    }
  }
  return error_with_underlying_errors;
}

_OWORD *create_error_response_for_Error(__CFError *a1)
{
  CFAllocatorRef v2 = malloc_type_malloc(0x50uLL, 0x10F00405BFF1630uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    chunkserver__error_response__init(v2);
    CFStringRef Domain = CFErrorGetDomain(a1);
    *((void *)v3 + 3) = createCStringWithCFString(Domain);
    *((_DWORD *)v3 + 8) = CFErrorGetCode(a1);
    *((void *)v3 + 8) = 0;
    CFStringRef v5 = CFErrorCopyDescription(a1);
    if (v5)
    {
      CFStringRef v6 = v5;
      *((void *)v3 + 5) = createCStringWithCFString(v5);
      CFRelease(v6);
    }
    CFDictionaryRef v7 = CFErrorCopyUserInfo(a1);
    if (v7)
    {
      CFDictionaryRef v8 = v7;
      if (CFDictionaryGetValue(v7, (const void *)*MEMORY[0x1E4F1D190]))
      {
        CFErrorRef v9 = 0;
      }
      else
      {
        CFErrorRef v9 = mmcs_cfnetwork_copy_underlying_stream_error(v8);
        if (!v9)
        {
LABEL_15:
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v8, @"kMMCSErrorSupplementalDictionaryKey");
          if (IsValidCFDictionary(Value))
          {
            CFIndex Count = CFDictionaryGetCount(Value);
            *((void *)v3 + 9) = malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
            CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)copy_error_response_nv_pairs, v3);
          }
          if (v9) {
            CFRelease(v9);
          }
          CFRelease(v8);
          return v3;
        }
      }
      error_response_for_Error = (void **)create_error_response_for_Error();
      uint64_t v12 = malloc_type_malloc(8uLL, 0x2004093837F09uLL);
      *((void *)v3 + 7) = v12;
      if (v12)
      {
        uint64_t v13 = *((void *)v3 + 6);
        *((void *)v3 + 6) = v13 + 1;
        v12[v13] = error_response_for_Error;
      }
      else
      {
        CFStringRef v14 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          v18[0] = 0;
          _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "malloc", (uint8_t *)v18, 2u);
        }
        chunkserver__error_response__free_unpacked(error_response_for_Error, 0);
      }
      goto LABEL_15;
    }
  }
  else
  {
    size_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "malloc", buf, 2u);
    }
  }
  return v3;
}

void *copy_error_response_nv_pairs(const __CFString *a1, __CFString *a2, uint64_t a3)
{
  BOOL result = createNameValuePair(a1, a2);
  uint64_t v6 = *(void *)(a3 + 64);
  uint64_t v5 = *(void *)(a3 + 72);
  *(void *)(a3 + 64) = v6 + 1;
  *(void *)(v5 + 8 * v6) = result;
  return result;
}

char *Copy_MethodCompletionInfo(void **a1)
{
  size_t packed_size = chunkserver__method_completion_info__get_packed_size(a1);
  BOOL result = (char *)malloc_type_malloc(packed_size, 0xFF16A821uLL);
  if (result)
  {
    unint64_t v4 = result;
    unint64_t v5 = chunkserver__method_completion_info__pack(a1, (uint64_t)result);
    uint64_t v6 = chunkserver__method_completion_info__unpack(0, v5, v4);
    free(v4);
    return (char *)v6;
  }
  return result;
}

_DWORD *Create_MethodCompletionInfo(__CFError *a1, __CFHTTPMessage *a2, uint64_t a3, const char *a4, unsigned int a5, int a6, int a7)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  CFStringRef v14 = malloc_type_malloc(0xB8uLL, 0x10F004063C8919BuLL);
  if (!v14) {
    return v14;
  }
  if (a1)
  {
    CFErrorDomain Domain = CFErrorGetDomain(a1);
    if (CFEqual(@"com.apple.mmcs", Domain) && CFErrorGetCode(a1) == 38)
    {
      CFDictionaryRef v16 = CFErrorCopyUserInfo(a1);
      CFDictionaryRef Value = (__CFError *)CFDictionaryGetValue(v16, (const void *)*MEMORY[0x1E4F1D190]);
      if (Value)
      {
        size_t v18 = Value;
        CFTypeRef cf = mmcs_cferror_copy_description(a1);
        uint64_t v45 = mmcs_cferror_copy_description(v18);
        uint64_t v19 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138412546;
          uint64_t v47 = (uint64_t)v45;
          __int16 v48 = 2112;
          int v49 = cf;
          _os_log_impl(&dword_1DC1CA000, v19, OS_LOG_TYPE_DEBUG, "Reporting underlyingError %@ back to iCloud instead of %@", buf, 0x16u);
        }
        if (cf) {
          CFRelease(cf);
        }
        if (v45) {
          CFRelease(v45);
        }
      }
      else
      {
        size_t v18 = a1;
      }
      if (v16) {
        CFRelease(v16);
      }
    }
    else
    {
      size_t v18 = a1;
    }
  }
  else
  {
    size_t v18 = 0;
  }
  chunkserver__method_completion_info__init((uint64_t)v14);
  v14[44] = 1;
  v14[45] = a7;
  if (v18 && mmcs_report_is_enabled_for_config_key(@"client.error.on.failure", a6, a5)) {
    *((void *)v14 + 11) = create_error_response_for_Error(v18);
  }
  if (!a2)
  {
    uint64_t v23 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_28;
    }
    *(_WORD *)long long buf = 0;
    CFDataRef v24 = "expected request url.";
    goto LABEL_27;
  }
  CFURLRef v20 = CFHTTPMessageCopyRequestURL(a2);
  if (v20)
  {
    CFURLRef v21 = v20;
    CFStringRef v22 = CFURLGetString(v20);
    *((void *)v14 + 3) = createCStringWithCFString(v22);
    CFRelease(v21);
    goto LABEL_28;
  }
  uint64_t v23 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    CFDataRef v24 = "can't get request url.";
LABEL_27:
    _os_log_impl(&dword_1DC1CA000, v23, OS_LOG_TYPE_ERROR, v24, buf, 2u);
  }
LABEL_28:
  if (a3 && mmcs_http_context_get_response_message(a3))
  {
    if (mmcs_report_is_enabled_for_config_key(@"vendor.response.code", a6, a5))
    {
      if (mmcs_http_context_has_http_status(a3))
      {
        int v25 = mmcs_http_context_http_status(a3);
      }
      else
      {
        CFIndex v26 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 134217984;
          uint64_t v47 = a3;
          _os_log_impl(&dword_1DC1CA000, v26, OS_LOG_TYPE_ERROR, "mmcs http context <%p> does not have status code!", buf, 0xCu);
        }
        int v25 = -1;
      }
      v14[8] = v25;
    }
    BOOL v27 = mmcs_http_context_status_succeeded(a3);
    response_message = (__CFHTTPMessage *)mmcs_http_context_get_response_message(a3);
    *((void *)v14 + 6) = 0;
    CFDictionaryRef v29 = (const __CFDictionary *)mmcs_report_copy_headers_from_vendor_response(response_message, v27, a6, a5);
    if (v29)
    {
      CFDictionaryRef v30 = v29;
      CFIndex Count = CFDictionaryGetCount(v29);
      *((void *)v14 + 7) = malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
      CFDictionaryApplyFunction(v30, (CFDictionaryApplierFunction)copy_vendor_response_headers, v14);
      CFRelease(v30);
    }
    if (!v27)
    {
      if (mmcs_report_is_enabled_for_config_key(@"status.line.on.failure", a6, a5))
      {
        CFIndex v32 = (__CFHTTPMessage *)mmcs_http_context_get_response_message(a3);
        CFStringRef v33 = CFHTTPMessageCopyResponseStatusLine(v32);
        if (v33)
        {
          CFStringRef v34 = v33;
          *((void *)v14 + 5) = createCStringWithCFString(v33);
          CFRelease(v34);
        }
      }
      if (mmcs_is_apple_internal_install())
      {
        CFStringRef v35 = (const __CFString *)mmcs_report_value_for_config_key(@"vendor.body.max.bytes.on.failure.internal", a6, a5);
        uint64_t cfindex_from_cftype_using_description = mmcs_get_cfindex_from_cftype_using_description(@"vendor.body.max.bytes.on.failure.internal", v35, 0);
        if (cfindex_from_cftype_using_description >= 1)
        {
          int64_t Length = cfindex_from_cftype_using_description;
          CFDataRef v38 = (const __CFData *)mmcs_http_context_copy_response_body(a3);
          if (v38)
          {
            CFDataRef v39 = v38;
            if (Length < CFDataGetLength(v38) || (int64_t Length = CFDataGetLength(v39)) != 0)
            {
              int v40 = malloc_type_malloc(Length, 0x8B011156uLL);
              *((void *)v14 + 10) = v40;
              if (v40)
              {
                int v41 = v40;
                *((void *)v14 + 9) = Length;
                BytePtr = CFDataGetBytePtr(v39);
                memcpy(v41, BytePtr, Length);
                uint8_t v14[16] = 1;
              }
            }
            CFRelease(v39);
          }
        }
      }
    }
  }
  if (a4) {
    *((void *)v14 + 19) = strdup(a4);
  }
  return v14;
}

void MethodCompletionInfo_SetReportingProperties(void *a1, CFDictionaryRef theDict, CFDictionaryRef a3)
{
  a1[15] = 0;
  if (theDict)
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    a1[16] = malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)copy_vendor_nv_pairs, a1);
  }
  a1[18] = 0;
  if (a3)
  {
    CFIndex v7 = CFDictionaryGetCount(a3);
    a1[18] = malloc_type_malloc(8 * v7, 0x2004093837F09uLL);
    CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)copy_client_nv_pairs, a1);
  }
}

void *copy_vendor_nv_pairs(const __CFString *a1, __CFString *a2, uint64_t a3)
{
  BOOL result = createNameValuePair(a1, a2);
  uint64_t v6 = *(void *)(a3 + 120);
  uint64_t v5 = *(void *)(a3 + 128);
  *(void *)(a3 + 120) = v6 + 1;
  *(void *)(v5 + 8 * v6) = result;
  return result;
}

void *copy_client_nv_pairs(const __CFString *a1, __CFString *a2, uint64_t a3)
{
  BOOL result = createNameValuePair(a1, a2);
  uint64_t v6 = *(void *)(a3 + 136);
  uint64_t v5 = *(void *)(a3 + 144);
  *(void *)(a3 + 136) = v6 + 1;
  *(void *)(v5 + 8 * v6) = result;
  return result;
}

_OWORD *mmcs_create_FileReferenceData(const __CFArray *a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = malloc_type_malloc(0x40uLL, 0x10E004044EB5B3DuLL);
  if (!v2)
  {
    CFDictionaryRef v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v11 = 136315138;
      uint64_t v12 = "mmcs_create_FileReferenceData";
      CFErrorRef v9 = "%s failed to allocate fileReferenceData.";
LABEL_12:
      _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v11, 0xCu);
    }
    return 0;
  }
  uint64_t v3 = v2;
  opaque__file_reference_data__init(v2);
  if (!a1) {
    return v3;
  }
  CFIndex Count = CFArrayGetCount(a1);
  uint64_t v5 = malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  if (!v5)
  {
    CFDictionaryRef v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v11 = 136315138;
      uint64_t v12 = "mmcs_create_FileReferenceData";
      CFErrorRef v9 = "%s failed to allocate package section item list";
      goto LABEL_12;
    }
    return 0;
  }
  uint64_t v6 = v5;
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
      v6[i] = CFArrayGetValueAtIndex(a1, i);
  }
  *((void *)v3 + 6) = Count;
  *((void *)v3 + 7) = v6;
  return v3;
}

uint64_t _chunkLengthIndexSetChecker(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return mmcs_index_set_apply_function(a2, (uint64_t)_index_set_applier_function, a3);
}

_OWORD *mmcs_create_FileReferenceDataV3Chunk(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    int v11 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    __int16 v17 = 0;
    uint64_t v12 = "mmcs_create_FileReferenceDataV1Chunk cannot have NULL chunkEncryptionKey.";
    uint64_t v13 = (uint8_t *)&v17;
LABEL_15:
    _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_ERROR, v12, v13, 2u);
    return 0;
  }
  uint64_t v5 = CKChunkSchemeAndEncryptionKeySize();
  if (!v5)
  {
    int v11 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    __int16 v16 = 0;
    uint64_t v12 = "mmcs_create_FileReferenceDataV1Chunk cannot have zero length chunkEncryptionSignature.";
    uint64_t v13 = (uint8_t *)&v16;
    goto LABEL_15;
  }
  uint64_t v6 = v5;
  CFIndex v7 = malloc_type_malloc(0x40uLL, 0x10700407A2CD8F7uLL);
  if (!v7)
  {
    int v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      __int16 v15 = 0;
      uint64_t v12 = "mmcs_create_FileReferenceDataV1Chunk failed to allocate fileReferenceDataChunk.";
      uint64_t v13 = (uint8_t *)&v15;
      goto LABEL_15;
    }
    return 0;
  }
  CFDictionaryRef v8 = v7;
  opaque__file_reference_data__v3__chunk__init(v7);
  *((void *)v8 + 3) = v6;
  *((void *)v8 + 4) = a1;
  if (a3)
  {
    uint64_t v9 = CKSubchunkBlobSize();
    if (v9) {
      uint64_t v10 = a3;
    }
    else {
      uint64_t v10 = 0;
    }
    *((void *)v8 + 6) = v9;
    *((void *)v8 + 7) = v10;
    *((_DWORD *)v8 + 10) = 1;
  }
  else
  {
    *((_DWORD *)v8 + 10) = 0;
  }
  return v8;
}

void _add_index_set(int a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 16))
  {
    uint64_t v6 = *(void *)a3;
    CFIndex v7 = malloc_type_malloc(0x38uLL, 0x10F0040167B91E7uLL);
    if (!v7) {
      goto LABEL_5;
    }
    CFDictionaryRef v8 = v7;
    opaque__file_reference_data__v3__chunk_length_index_set__init((uint64_t)v7);
    uint64_t v10 = *(void *)(v6 + 56);
    uint64_t v9 = *(void *)(v6 + 64);
    *(void *)(v6 + 56) = v10 + 1;
    *(void *)(v9 + 8 * v10) = v8;
    int v11 = a1;
    ProtobufCBinaryData_SetCopyBufferLen(v8 + 3, &v11, 4uLL);
    if (v8[4])
    {
      *(void *)(a3 + 8) = v8;
      mmcs_index_set_apply_function(a2, (uint64_t)_add_index_set_range, a3);
    }
    else
    {
LABEL_5:
      *(unsigned char *)(a3 + 16) = 0;
    }
  }
}

void *_index_set_applier_function(void *result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 1)
  {
    uint64_t v10 = v3;
    uint64_t v11 = v4;
    int v6 = (int)result;
    int v7 = a2 + result - 1;
    if (mmcs_index_set_contains_range(a3, (int)result, v7))
    {
      CFDictionaryRef v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v9 = 0;
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_ERROR, "index set overlap", v9, 2u);
      }
    }
    return mmcs_index_set_add_range(a3, v6, v7);
  }
  return result;
}

void _add_index_set_range(int a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 16))
  {
    if (a2
      && (uint64_t v6 = *(void *)(a3 + 8),
          (int v7 = malloc_type_realloc(*(void **)(v6 + 48), 8 * *(void *)(v6 + 40) + 8, 0x2004093837F09uLL)) != 0))
    {
      *(void *)(v6 + 48) = v7;
      CFDictionaryRef v8 = malloc_type_malloc(0x28uLL, 0x10600409AC856DDuLL);
      opaque__file_reference_data__v3__chunk_length_index_set__index_range__init((uint64_t)v8);
      uint64_t v10 = *(void *)(v6 + 40);
      uint64_t v9 = *(void *)(v6 + 48);
      *(void *)(v6 + 40) = v10 + 1;
      *(void *)(v9 + 8 * v10) = v8;
      v8[6] = a1;
      if (a2 >= 2)
      {
        v8[7] = 1;
        v8[8] = a2;
      }
    }
    else
    {
      *(unsigned char *)(a3 + 16) = 0;
    }
  }
}

void *add_checksum_applier(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)(*(void *)(*a2 + 56) + 16 * a2[1]);
  *uint64_t v4 = mmcs_chunk_signature_size_with_scheme(*(void *)(a1 + 8));
  BOOL result = mmcs_chunk_signature_copy(*(const void **)(a1 + 8));
  v4[1] = result;
  ++a2[1];
  return result;
}

void *createNameValuePair(const __CFString *a1, __CFString *a2)
{
  uint64_t v4 = malloc_type_malloc(0x28uLL, 0x1070040084410A6uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    chunkserver__name_value_pair__init((uint64_t)v4);
    v5[3] = createCStringWithCFString(a1);
    CFTypeID v6 = CFGetTypeID(a2);
    if (v6 != CFStringGetTypeID())
    {
      CFTypeID v7 = CFGetTypeID(a2);
      if (v7 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue((CFBooleanRef)a2)) {
          a2 = @"true";
        }
        else {
          a2 = @"false";
        }
      }
      else
      {
        a2 = @"(null)";
      }
    }
    v5[4] = createCStringWithCFString(a2);
  }
  return v5;
}

void *copy_vendor_response_headers(const __CFString *a1, __CFString *a2, uint64_t a3)
{
  BOOL result = createNameValuePair(a1, a2);
  uint64_t v6 = *(void *)(a3 + 48);
  uint64_t v5 = *(void *)(a3 + 56);
  *(void *)(a3 + 48) = v6 + 1;
  *(void *)(v5 + 8 * v6) = result;
  return result;
}

uint64_t mmcs_http_session_pool_entry_equal_callback(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (!a1 || !a2) {
    return result;
  }
  uint64_t v4 = *(const void **)(a1 + 32);
  uint64_t v5 = *(const void **)(a2 + 32);
  if (v4 == v5) {
    return 1;
  }
  uint64_t result = 0;
  if (v4)
  {
    if (v5) {
      return CFEqual(v4, v5);
    }
  }
  return result;
}

void schedulePutComplete(uint64_t *a1)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  unsigned int done = mmcs_put_state_containers_done_count((uint64_t)a1);
  BOOL v5 = v3 == done;
  if (v3 != done && CFAbsoluteTimeGetCurrent() - *(double *)(*(void *)(v2 + 304) + 16) < 0.0) {
    return;
  }
  uint64_t v84 = done;
  request_activity_marker = mmcs_request_get_request_activity_marker(v2);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  object = _os_activity_create(&dword_1DC1CA000, "mmcs-put-complete", request_activity_marker, OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(object, &state);
  CFTypeID v7 = *(uint64_t **)(v2 + 32);
  CFStringRef value = 0;
  if (*(unsigned char *)(v2 + 144))
  {
    CFErrorRef error = (void *)CFRetain(*(CFTypeRef *)(v2 + 152));
    CFStringRef v14 = 0;
    CFDataRef v15 = 0;
    CFURLRef v16 = 0;
    CFDictionaryRef Mutable = 0;
LABEL_5:
    int v18 = 0;
    goto LABEL_6;
  }
  uint64_t v82 = v7;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &kC3BaseArrayCallBacks);
  if (a1[1])
  {
    unint64_t v20 = 0;
    do
    {
      CFURLRef v21 = *(void **)(a1[8] + 8 * v20);
      if (mmcs_put_container_needs_put_complete((uint64_t)v21, v5))
      {
        CFStringRef v22 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v23 = **(void **)(v21[11] + 8);
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = v23;
          _os_log_impl(&dword_1DC1CA000, v22, OS_LOG_TYPE_DEFAULT, "Adding container %{public}s to putComplete.", (uint8_t *)&buf, 0xCu);
        }
        *(unsigned char *)(v21[11] + 33) = 1;
        mmcs_container_clear_complete_error((uint64_t)v21);
        CFArrayAppendValue(Mutable, v21);
      }
      ++v20;
    }
    while (v20 < a1[1]);
  }
  if (CFArrayGetCount(Mutable))
  {
    if (*(void *)(*(void *)(v2 + 304) + 120)) {
      CFStringRef v24 = @"cloneComplete";
    }
    else {
      CFStringRef v24 = @"putComplete";
    }
    CFURLRef v16 = CFURLCreateCopyAppendingPathComponent(allocator, *(CFURLRef *)(v2 + 160), v24, 0);
    if (!v16)
    {
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, @"Failed to create putComplete request url");
      CFStringRef v14 = 0;
      CFDataRef v15 = 0;
      int v18 = 0;
      goto LABEL_6;
    }
    if (*(void *)(*(void *)(v2 + 304) + 80))
    {
      if (mmcs_put_complete_create((CFArrayRef **)&value, *a1, Mutable))
      {
        CFSetAddValue(*(CFMutableSetRef *)(*(void *)(v2 + 304) + 128), value);
        if (*(void *)(*(void *)(v2 + 304) + 120)) {
          CFDataRef clone_complete_request_body = mmcs_put_state_create_clone_complete_request_body(v2, (uint64_t)a1, (uint64_t)value);
        }
        else {
          CFDataRef clone_complete_request_body = mmcs_put_state_create_put_complete_request_body((uint64_t)a1, (uint64_t)value);
        }
        CFDataRef v15 = clone_complete_request_body;
        if (clone_complete_request_body)
        {
          if (v3 == v84)
          {
            mmcs_put_request_notify_all_items_with_pending_progress((void *)v2);
            if (*(unsigned char *)(v2 + 144))
            {
LABEL_83:
              CFDataRef v38 = (void *)CFRetain(*(CFTypeRef *)(v2 + 152));
LABEL_84:
              CFErrorRef error = v38;
              CFStringRef v14 = 0;
              goto LABEL_5;
            }
            mmcs_put_item_progress_make_state(5, v87);
            mmcs_put_request_set_progress_and_notify_all_items_not_done(v2, (uint64_t)v87);
          }
          if (*(unsigned char *)(v2 + 144)) {
            goto LABEL_83;
          }
          CFStringRef v42 = (const __CFString *)v82[8];
          CFStringRef v43 = (const __CFString *)v82[10];
          CFStringRef dataclass = (const __CFString *)mmcs_request_get_dataclass(v2);
          http_protobuf_message = create_http_protobuf_message(v42, v43, dataclass, *(const __CFString **)(v2 + 168), *(const __CFString **)(v2 + 176), v16, v15);
          if (!http_protobuf_message)
          {
            long long v52 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v53 = CFStringCreateWithFormat(allocator, 0, @"unable to create put complete msg");
              CFStringRef v54 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
              {
                LODWORD(buf) = 138543362;
                *(void *)((char *)&buf + 4) = v53;
                _os_log_impl(&dword_1DC1CA000, v54, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
              }
              if (v53) {
                CFRelease(v53);
              }
            }
            CFDataRef v38 = mmcs_cferror_create_error(@"com.apple.mmcs", 37, @"Failed to create put complete msg");
            goto LABEL_84;
          }
          CFStringRef v14 = http_protobuf_message;
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)value + 3), 0);
          if (!mmcs_put_container_http_msg_add_token_header((uint64_t)ValueAtIndex, v14))
          {
            uint64_t v55 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v61 = CFStringCreateWithFormat(allocator, 0, @"unable to add put container token header");
              int v62 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
              {
                LODWORD(buf) = 138543362;
                *(void *)((char *)&buf + 4) = v61;
                _os_log_impl(&dword_1DC1CA000, v62, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
              }
              if (v61) {
                CFRelease(v61);
              }
            }
            CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed to add put container token header", v56, v57, v58, v59, v60, v81);
            goto LABEL_5;
          }
          mmcs_request_insert_headers(v2, v14);
          mmcs_http_request_options_create_promoted_to_foreground_copy(*(void *)(v2 + 56));
          CFStringRef v108 = 0;
          long long v107 = 0u;
          long long v106 = 0u;
          *(void *)&long long buf = @"putComplete";
          *((void *)&buf + 1) = v14;
          __int16 v48 = v47;
          uint64_t v93 = v47;
          uint64_t v94 = *(void *)(v2 + 96);
          uint64_t v95 = 0;
          uint64_t v96 = -1;
          uint64_t v98 = 0;
          uint64_t v99 = 0;
          uint64_t v97 = -1;
          uint64_t v100 = mmcs_put_req_will_retry_put_complete_after_error;
          unint64_t v101 = handle_response_putComplete;
          uint64_t v102 = 0;
          uint64_t v103 = 0;
          uint64_t v104 = 0;
          uint64_t v105 = value;
          *(void *)&long long v106 = mmcs_engine_get_sparse_block_size();
          *((void *)&v106 + 1) = mmcs_engine_owner((uint64_t)v82);
          LOBYTE(v107) = 0;
          *((void *)&v107 + 1) = 0;
          CFStringRef v108 = object;
          memset(v86, 0, sizeof(v86));
          mmcs_read_stream_pool_parameters_make_pool_timeout_max(v82[4], 100, (uint64_t)v86, 90.0);
          if (mmcs_http_context_create((void *)value + 1, *(_DWORD *)(v2 + 140), (uint64_t)&buf))
          {
            mmcs_put_req_context_make_put_complete_metrics((__CFArray *)v2, (uint64_t)value, (uint64_t)v48);
            *(unsigned char *)(*(void *)(v2 + 304) + 136) = v5;
            if (mmcs_http_context_send(*((void *)value + 1), (uint64_t)v86, v82[7]))
            {
              if (gMMCS_DebugLevel >= 4)
              {
                int v49 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
                {
                  CFStringRef v50 = CFStringCreateWithFormat(allocator, 0, @"sent mmcs_put_complete (%p) for put request: %p", value, v2);
                  CFErrorRef v51 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)unint64_t v90 = 138543362;
                    CFStringRef v91 = v50;
                    _os_log_impl(&dword_1DC1CA000, v51, OS_LOG_TYPE_DEBUG, "%{public}@", v90, 0xCu);
                  }
                  if (v50) {
                    CFRelease(v50);
                  }
                }
              }
              CFErrorRef error = 0;
              *(CFAbsoluteTime *)(*(void *)(v2 + 304) + 16) = CFAbsoluteTimeGetCurrent();
              int v18 = 1;
              goto LABEL_132;
            }
            long long v72 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v78 = CFStringCreateWithFormat(allocator, 0, @"unable to send http msg");
              long long v79 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)unint64_t v90 = 138543362;
                CFStringRef v91 = v78;
                _os_log_impl(&dword_1DC1CA000, v79, OS_LOG_TYPE_ERROR, "%{public}@", v90, 0xCu);
              }
              if (v78) {
                CFRelease(v78);
              }
            }
            uint64_t v80 = *((void *)value + 1);
            if (v80 && mmcs_http_context_get_error(v80))
            {
              CFErrorRef error = (void *)mmcs_http_context_get_error(*((void *)value + 1));
              CFRetain(error);
LABEL_131:
              int v18 = 0;
LABEL_132:
              if (v48) {
                C3BaseRelease(v48);
              }
LABEL_6:
              BOOL v19 = v18 != 0;
              if (!v18 && !error) {
                CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Unknown local error %s", v8, v9, v10, v11, v12, (char)"send_request_putComplete");
              }
              if (!value) {
                goto LABEL_34;
              }
              if (!v18)
              {
                mmcs_put_complete_set_error_and_push_to_containers((uint64_t)value, error);
LABEL_33:
                CFStringRef value = 0;
                BOOL v19 = v18;
LABEL_34:
                if (!Mutable) {
                  goto LABEL_38;
                }
                if (!v19)
                {
                  v110.unsigned int length = CFArrayGetCount(Mutable);
                  v110.CFIndex location = 0;
                  CFArrayApplyFunction(Mutable, v110, (CFArrayApplierFunction)failed_to_send_put_complete, error);
                }
LABEL_37:
                CFRelease(Mutable);
LABEL_38:
                BOOL v27 = 0;
                if (!v18 && error)
                {
                  CFRetain(error);
                  BOOL v27 = error;
                }
                if (v14) {
                  CFRelease(v14);
                }
                if (v15) {
                  CFRelease(v15);
                }
                if (v16) {
                  CFRelease(v16);
                }
                if (error) {
                  CFRelease(error);
                }
                goto LABEL_49;
              }
LABEL_32:
              int v18 = 1;
              goto LABEL_33;
            }
            CFErrorRef v71 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed to send http msg %s", v73, v74, v75, v76, v77, (char)"send_request_putComplete");
          }
          else
          {
            uint64_t v63 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v69 = CFStringCreateWithFormat(allocator, 0, @"unable to create http context");
              BOOL v70 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)unint64_t v90 = 138543362;
                CFStringRef v91 = v69;
                _os_log_impl(&dword_1DC1CA000, v70, OS_LOG_TYPE_ERROR, "%{public}@", v90, 0xCu);
              }
              if (v69) {
                CFRelease(v69);
              }
            }
            CFErrorRef v71 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Failed to create http context %s", v64, v65, v66, v67, v68, (char)"send_request_putComplete");
          }
          CFErrorRef error = v71;
          goto LABEL_131;
        }
        CFDataRef v39 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v40 = CFStringCreateWithFormat(allocator, 0, @"unable to create putComplete request");
          int v41 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = v40;
            _os_log_impl(&dword_1DC1CA000, v41, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (v40) {
            CFRelease(v40);
          }
        }
        CFStringRef v34 = @"Failed to create putComplete request body";
      }
      else
      {
        CFStringRef v35 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v36 = CFStringCreateWithFormat(allocator, 0, @"unable to create mmcs_put_complete");
          CFNumberRef v37 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = v36;
            _os_log_impl(&dword_1DC1CA000, v37, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (v36) {
            CFRelease(v36);
          }
        }
        CFStringRef v34 = @"Failed to create mmcs_put_complete";
      }
    }
    else
    {
      uint64_t v31 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v32 = CFStringCreateWithFormat(allocator, 0, @"no put state");
        CFStringRef v33 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v32;
          _os_log_impl(&dword_1DC1CA000, v33, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v32) {
          CFRelease(v32);
        }
      }
      CFStringRef v34 = @"no put state";
    }
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, v34);
    CFStringRef v14 = 0;
    CFDataRef v15 = 0;
    goto LABEL_5;
  }
  CFIndex v26 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_1DC1CA000, v26, OS_LOG_TYPE_DEFAULT, "no containers were eligible for putComplete.", (uint8_t *)&buf, 2u);
  }
  if (value)
  {
    CFURLRef v16 = 0;
    CFDataRef v15 = 0;
    CFStringRef v14 = 0;
    CFErrorRef error = 0;
    goto LABEL_32;
  }
  CFErrorRef error = 0;
  CFStringRef v14 = 0;
  CFDataRef v15 = 0;
  CFURLRef v16 = 0;
  BOOL v27 = 0;
  int v18 = 1;
  if (Mutable) {
    goto LABEL_37;
  }
LABEL_49:
  if (object) {
    os_release(object);
  }
  os_activity_scope_leave(&state);
  if (!v18)
  {
    if (v3 == v84)
    {
      mmcs_put_request_context_cleanup(v2, (uint64_t)v27);
    }
    else
    {
      char v28 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v29 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Incremental put complete failed with error: %@", v27);
        CFDictionaryRef v30 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v29;
          _os_log_impl(&dword_1DC1CA000, v30, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v29) {
          CFRelease(v29);
        }
      }
    }
  }
  if (v27) {
    CFRelease(v27);
  }
}

void handle_response_uploadChunks(uint64_t a1, CFDataRef *a2, uint64_t a3)
{
  uint64_t v147 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    handle_response_uploadChunks_cold_1();
  }
  if (!a3) {
    handle_response_uploadChunks_cold_2();
  }
  if (*(void *)(a3 + 16) != a1) {
    handle_response_uploadChunks_cold_6();
  }
  uint64_t v6 = *(void *)(a3 + 64);
  CFTypeID v7 = **(uint64_t ***)(v6 + 88);
  uint64_t v8 = *v7;
  if (!v7[7])
  {
    uint64_t v9 = *(const void **)(a1 + 616);
    if (v9)
    {
      CFRetain(v9);
      uint64_t v10 = *(void *)(a1 + 616);
    }
    else
    {
      uint64_t v10 = 0;
    }
    v7[7] = v10;
  }
  if (*(unsigned char *)(v8 + 272))
  {
    if (!*(unsigned char *)(v8 + 72))
    {
      int v25 = (__CFString *)mmcs_http_context_copy_blocked_application_header_value(a1);
      if (v25)
      {
        CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 51, v25);
        goto LABEL_66;
      }
    }
  }
  response_message = (__CFHTTPMessage *)mmcs_http_context_get_response_message(a1);
  if (response_message
    && (CFStringRef v12 = CFHTTPMessageCopyHeaderFieldValue(response_message, @"x-apple-put-complete-response")) != 0)
  {
    CFStringRef v13 = v12;
    if (CFStringCompare(v12, @"true", 1uLL))
    {
      if (CFStringCompare(v13, @"false", 1uLL))
      {
        CFRelease(v13);
LABEL_63:
        char v140 = 0;
        CFStringRef v27 = @"ResponseHeader x-apple-put-complete-response malformed with value %@";
LABEL_64:
        CFIndex v28 = 6;
        goto LABEL_65;
      }
      CFStringRef v29 = (const __CFBoolean **)MEMORY[0x1E4F1CFC8];
    }
    else
    {
      CFStringRef v29 = (const __CFBoolean **)MEMORY[0x1E4F1CFD0];
    }
    CFBooleanRef v19 = *v29;
    CFRelease(v13);
    if (!v19) {
      goto LABEL_63;
    }
  }
  else
  {
    CFBooleanRef v19 = 0;
  }
  uint64_t metrics = mmcs_http_context_get_metrics(a1);
  mmcs_metrics_http_info_set_inline_edge_complete(metrics, (uint64_t)v19);
  is_put_complete_at_edge_protocol_uint64_t v2 = mmcs_http_request_is_put_complete_at_edge_protocol_v2(*(void *)(a3 + 24));
  is_request_body_unsigned int done = mmcs_http_context_is_request_body_done(a1);
  if (!is_put_complete_at_edge_protocol_v2)
  {
    if (!v19) {
      goto LABEL_28;
    }
    uint64_t v23 = 3;
    goto LABEL_22;
  }
  if (v19)
  {
    uint64_t v23 = 2;
LABEL_22:
    if (CFBooleanGetValue(v19))
    {
      uint64_t v24 = 1;
      goto LABEL_32;
    }
    goto LABEL_28;
  }
  if (is_request_body_done)
  {
    uint64_t v24 = 1;
    uint64_t v23 = 2;
    goto LABEL_32;
  }
LABEL_28:
  if (!*(unsigned char *)(v8 + 296))
  {
    uint64_t v24 = 2;
    uint64_t v23 = 1;
LABEL_32:
    if (!*(unsigned char *)(v8 + 297)) {
      uint64_t v24 = v23;
    }
    if (v24 != 1)
    {
      if (v24 != 2 && !*(unsigned char *)(v8 + 296))
      {
        CFStringRef v27 = @"PutCompleteAtEdge Returned Without Being Requested By Vendor When PutCompleteAtEdge Response Was Not Required";
        goto LABEL_64;
      }
      CFDictionaryRef v30 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC1CA000, v30, OS_LOG_TYPE_DEFAULT, "Handling PutComplete Response", buf, 2u);
      }
      uint64_t v31 = _os_activity_create(&dword_1DC1CA000, "mmcs-inline-put-complete", *(os_activity_t *)(v6 + 80), OS_ACTIVITY_FLAG_DEFAULT);
      state.opaque[0] = 0;
      state.opaque[1] = 0;
      os_activity_scope_enter(v31, &state);
      C3BaseRetain((CFTypeRef)a3);
      uint64_t v32 = *(void *)(*(void *)(***(void ***)(v6 + 88) + 32) + 48);
      int is_connection_reused = mmcs_http_context_is_connection_reused(a1);
      double Current = CFAbsoluteTimeGetCurrent();
      mmcs_request_queue_request_did_complete(v32, (void *)a3, 0, is_connection_reused, 0, Current);
      mmcs_put_container_vendor_put_done(v6);
      uint64_t v35 = mmcs_http_context_get_metrics(a1);
      mmcs_metrics_http_info_set_final_try_in_request(v35, 1);
      method_completion_info = mmcs_put_container_create_method_completion_info((void *)v6, a3, 0);
      mmcs_transaction_add_method_completion_info(a3, method_completion_info);
      CFStringRef value = 0;
      uint64_t v42 = *(void *)(v6 + 88);
      uint64_t v43 = **(void **)v42;
      if (*(unsigned char *)(v42 + 33))
      {
        unint64_t v44 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 16, @"Already handled putComplete for this container. Retry", v37, v38, v39, v40, v41, v140);
      }
      else
      {
        *(unsigned char *)(v42 + 33) = 1;
        uint64_t v75 = *(const void **)(v6 + 56);
        if (v75) {
          CFRelease(v75);
        }
        *(void *)(v6 + 56) = 0;
        mmcs_put_request_notify_all_items_with_pending_progress((void *)v43);
        if (!*(unsigned char *)(v43 + 144))
        {
          CFArrayRef v77 = XCFArrayCreateWithObject((const void *)v6);
          if (mmcs_put_complete_create((CFArrayRef **)&value, v43, v77))
          {
            CFSetAddValue(*(CFMutableSetRef *)(*(void *)(v43 + 304) + 128), value);
            handle_response_putComplete(a1, a2, (uint64_t)value);
            CFErrorRef v76 = 0;
            if (!v77) {
              goto LABEL_98;
            }
            goto LABEL_97;
          }
          CFErrorRef v76 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, @"Error initializing putComplete", v93, v94, v95, v96, v97, v140);
          if (v76)
          {
LABEL_89:
            mmcs_container_set_complete_error_if_absent((void *)v6, v76);
            if (!mmcs_put_request_has_outstanding_async_transactions(v43))
            {
              *(void *)long long buf = 0;
              *(void *)&uint8_t buf[8] = 0;
              request_activity_marker = mmcs_request_get_request_activity_marker(v43);
              os_activity_scope_enter(request_activity_marker, (os_activity_scope_state_t)buf);
              long long v79 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
              {
                CFStringRef v80 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Uploads complete. All done (with errors)! (Put request %p)", v43);
                char v81 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)uint64_t v144 = 138543362;
                  CFStringRef v145 = v80;
                  _os_log_impl(&dword_1DC1CA000, v81, OS_LOG_TYPE_DEFAULT, "%{public}@", v144, 0xCu);
                }
                if (v80) {
                  CFRelease(v80);
                }
              }
              mmcs_put_request_all_put_completes_done((void *)v43);
              os_activity_scope_leave((os_activity_scope_state_t)buf);
            }
            if (!v77) {
              goto LABEL_98;
            }
LABEL_97:
            CFRelease(v77);
LABEL_98:
            if (v76) {
              CFRelease(v76);
            }
            if (v31) {
              os_release(v31);
            }
            uint64_t v82 = *(void *)(a3 + 16);
            if (v82)
            {
              mmcs_http_context_invalidate(v82);
              double v83 = *(const void **)(a3 + 16);
              if (v83) {
                C3BaseRelease(v83);
              }
              *(void *)(a3 + 16) = 0;
            }
            C3BaseRelease((CFTypeRef)a3);
            p_os_activity_scope_state_s state = &state;
            goto LABEL_107;
          }
LABEL_88:
          CFErrorRef v76 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Error Occured Handling Inline Put Complete", v45, v46, v47, v48, v49, v140);
          goto LABEL_89;
        }
        unint64_t v44 = (__CFError *)CFRetain(*(CFTypeRef *)(v43 + 152));
      }
      CFErrorRef v76 = v44;
      CFArrayRef v77 = 0;
      if (v44) {
        goto LABEL_89;
      }
      goto LABEL_88;
    }
    CFStringRef v50 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v50, OS_LOG_TYPE_DEFAULT, "Handling Vendor Response", buf, 2u);
    }
    if (*(void *)(a3 + 16) != a1) {
      handle_response_uploadChunks_cold_5();
    }
    CFErrorRef v51 = *(void **)(a3 + 64);
    long long v52 = (uint64_t *)v51[11];
    uint64_t v53 = *v52;
    CFStringRef v54 = (void *)v52[1];
    *(_DWORD *)(a3 + 48) = 4;
    if (a2)
    {
      if (*a2) {
        CFRelease(*a2);
      }
      *a2 = 0;
    }
    if (!v53)
    {
      uint64_t v84 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v85 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null put state backref in put container");
        uint64_t v86 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v85;
          _os_log_impl(&dword_1DC1CA000, v86, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v85) {
          CFRelease(v85);
        }
      }
      return;
    }
    uint64_t v55 = *(void **)v53;
    C3BaseRetain(*(CFTypeRef *)v53);
    if (!mmcs_http_context_get_error(a1)) {
      mmcs_http_session_pool_entry_close(v51);
    }
    int v56 = *((unsigned __int8 *)v55 + 144);
    LOBYTE(state.opaque[0]) = 1;
    uint64_t v57 = *(void *)(v55[4] + 48);
    if (mmcs_transaction_is_proxy(a3) || mmcs_http_context_is_background(a1)) {
      uint64_t v58 = 0;
    }
    else {
      uint64_t v58 = (__CFError *)mmcs_http_context_get_error(a1);
    }
    int v59 = mmcs_http_context_is_connection_reused(a1);
    double v60 = CFAbsoluteTimeGetCurrent();
    mmcs_request_queue_request_did_complete(v57, (void *)a3, v58, v59, (BOOL *)&state, v60);
    if (*((unsigned char *)v55 + 144))
    {
      CFStringRef v61 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
      {
        int v62 = "Already c";
        if (!v56) {
          int v62 = "C";
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v62;
        _os_log_impl(&dword_1DC1CA000, v61, OS_LOG_TYPE_INFO, "%{public}sancelled during container completion handler.", buf, 0xCu);
      }
      if (!mmcs_put_state_has_outstanding_async_transactions(*(void *)(v55[38] + 80))) {
        mmcs_put_request_context_cleanup((uint64_t)v55, v55[19]);
      }
      goto LABEL_196;
    }
    if (*(unsigned char *)(v55[38] + 136))
    {
LABEL_196:
      C3BaseRelease(v55);
      return;
    }
    uint64_t v87 = *(void *)(a3 + 32);
    BOOL v88 = v87 < 1;
    uint64_t v89 = v87 - 1;
    if (!v88) {
      *(void *)(a3 + 32) = v89;
    }
    uint64_t v90 = mmcs_http_context_get_error(a1);
    if (!v90)
    {
      uint64_t v98 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_INFO))
      {
        uint64_t v99 = *v54;
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v99;
        _os_log_impl(&dword_1DC1CA000, v98, OS_LOG_TYPE_INFO, "Container %{public}s successfully put", buf, 0xCu);
      }
      uint64_t v141 = 0;
      goto LABEL_176;
    }
    CFStringRef v91 = (void *)v90;
    if (v51[5])
    {
      CFErrorRef v92 = 0;
    }
    else
    {
      host_CFErrorRef error = mmcs_cferror_copy_transformed_cannot_find_host_error(a1);
      CFErrorRef v92 = host_error;
      if (host_error) {
        CFStringRef v91 = host_error;
      }
      mmcs_container_set_error(v51, v91);
    }
    if (*(uint64_t *)(a3 + 32) >= 1)
    {
      CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)v91);
      CFIndex Code = CFErrorGetCode((CFErrorRef)v91);
      if (!CFEqual(@"com.apple.mmcs", Domain))
      {
        if (CFEqual((CFTypeRef)*MEMORY[0x1E4F1D158], Domain))
        {
          BOOL v107 = Code == -9810;
        }
        else
        {
          if (!CFEqual((CFTypeRef)*MEMORY[0x1E4F18F50], Domain))
          {
            BOOL v103 = CFEqual((CFTypeRef)*MEMORY[0x1E4F1D160], Domain) != 0;
            goto LABEL_163;
          }
          BOOL v107 = Code == -1005;
        }
        BOOL v103 = v107;
        goto LABEL_163;
      }
      BOOL v103 = 1;
      if (Code > 15)
      {
        if (Code == 16)
        {
          CFDictionaryRef v108 = CFErrorCopyUserInfo((CFErrorRef)v91);
          if (!v108) {
            goto LABEL_163;
          }
          CFDictionaryRef v105 = v108;
          CFDictionaryRef v109 = (const __CFDictionary *)CFDictionaryGetValue(v108, @"kMMCSErrorSupplementalDictionaryKey");
          if (v109)
          {
            CFStringRef v110 = (const __CFString *)CFDictionaryGetValue(v109, @"Retry-After");
            if (v110) {
              BOOL v103 = CFStringGetIntValue(v110) < 6;
            }
          }
          goto LABEL_162;
        }
        if (Code == 38) {
          goto LABEL_163;
        }
      }
      else
      {
        if (Code == 3) {
          goto LABEL_163;
        }
        if (Code == 6)
        {
          CFDictionaryRef v104 = CFErrorCopyUserInfo((CFErrorRef)v91);
          if (v104)
          {
            CFDictionaryRef v105 = v104;
            CFNumberRef v106 = (const __CFNumber *)CFDictionaryGetValue(v104, @"kMMCSErrorHTTPStatusKey");
            if (v106)
            {
              *(void *)long long buf = -1;
              CFNumberGetValue(v106, kCFNumberCFIndexType, buf);
              BOOL v103 = *(void *)buf == 500;
            }
            else
            {
              BOOL v103 = 0;
            }
LABEL_162:
            CFRelease(v105);
LABEL_163:
            if (LOBYTE(state.opaque[0]) && (mmcs_transaction_is_proxy(a3) || v103))
            {
              uint64_t v111 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
              {
                CFStringRef v112 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Container %s failed and will be retried", *v54);
                CFBooleanRef v113 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138543362;
                  *(void *)&uint8_t buf[4] = v112;
                  _os_log_impl(&dword_1DC1CA000, v113, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
                }
                if (v112) {
                  CFRelease(v112);
                }
              }
              uint64_t v114 = mmcs_http_context_get_metrics(a1);
              mmcs_metrics_http_info_set_final_try_in_request(v114, 0);
              mmcs_put_container_vendor_put_retry((uint64_t)v51, a3);
LABEL_187:
              schedulePutComplete((uint64_t *)v53);
              if (!*((unsigned char *)v55 + 144))
              {
                unint64_t v134 = *(void *)(v53 + 8);
                if (v134 < mmcs_put_state_containers_done_count(v53))
                {
                  CFStringRef v135 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
                  {
                    CFAllocatorRef v136 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                    unsigned int done = mmcs_put_state_containers_done_count(v53);
                    CFStringRef v138 = CFStringCreateWithFormat(v136, 0, @"completed count (%llu) exceeds upload count (%llu).", done, *(void *)(v53 + 8));
                    uint64_t v139 = mmcs_logging_logger_default();
                    if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)long long buf = 138543362;
                      *(void *)&uint8_t buf[4] = v138;
                      _os_log_impl(&dword_1DC1CA000, v139, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
                    }
                    if (v138) {
                      CFRelease(v138);
                    }
                  }
                }
              }
              if (v92) {
                CFRelease(v92);
              }
              goto LABEL_196;
            }
            CFStringRef v115 = mmcs_logging_logger_default();
            uint64_t v141 = v92;
            if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
            {
              CFStringRef v116 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Container %s failed permanently", *v54);
              CFIndex v117 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v116;
                _os_log_impl(&dword_1DC1CA000, v117, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
              }
              if (v116) {
                CFRelease(v116);
              }
            }
LABEL_176:
            uint64_t v118 = mmcs_http_context_get_metrics(a1);
            mmcs_metrics_http_info_set_final_try_in_request(v118, 1);
            uint64_t v119 = mmcs_put_state_containers_failed_count(v53);
            uint64_t v120 = mmcs_put_state_containers_done_count(v53);
            BOOL has_http_status = mmcs_http_context_has_http_status(a1);
            char v122 = mmcs_logging_logger_default();
            BOOL v123 = os_log_type_enabled(v122, OS_LOG_TYPE_INFO);
            if (has_http_status)
            {
              if (!v123) {
                goto LABEL_182;
              }
              uint64_t v124 = *v54;
              int v125 = mmcs_http_context_http_status(a1);
              uint64_t v126 = *(void *)(v53 + 8);
              *(_DWORD *)long long buf = 136447234;
              *(void *)&uint8_t buf[4] = v124;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v125;
              *(_WORD *)&buf[18] = 2048;
              *(void *)&buf[20] = v119;
              *(_WORD *)&buf[28] = 2048;
              *(void *)&buf[30] = v120;
              *(_WORD *)&buf[38] = 2048;
              *(void *)&buf[40] = v126;
              uint64_t v127 = "Completed container %{public}s status %d (%llu failed / %llu completed / %llu count)";
              uint64_t v128 = v122;
              uint32_t v129 = 48;
            }
            else
            {
              if (!v123) {
                goto LABEL_182;
              }
              uint64_t v130 = *v54;
              uint64_t v131 = *(void *)(v53 + 8);
              *(_DWORD *)long long buf = 136446978;
              *(void *)&uint8_t buf[4] = v130;
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v119;
              *(_WORD *)&buf[22] = 2048;
              *(void *)&unsigned char buf[24] = v120;
              *(_WORD *)&buf[32] = 2048;
              *(void *)&buf[34] = v131;
              uint64_t v127 = "Completed container %{public}s status N/A (%llu failed / %llu completed / %llu count)";
              uint64_t v128 = v122;
              uint32_t v129 = 42;
            }
            _os_log_impl(&dword_1DC1CA000, v128, OS_LOG_TYPE_INFO, v127, buf, v129);
LABEL_182:
            mmcs_put_container_vendor_put_done((uint64_t)v51);
            if (*(void *)(a3 + 16))
            {
              uint64_t v132 = mmcs_put_container_create_method_completion_info(v51, a3, 0);
              mmcs_transaction_add_method_completion_info(a3, v132);
              mmcs_http_context_invalidate(*(void *)(a3 + 16));
              uint64_t v133 = *(const void **)(a3 + 16);
              CFErrorRef v92 = v141;
              if (v133) {
                C3BaseRelease(v133);
              }
              *(void *)(a3 + 16) = 0;
            }
            else
            {
              CFErrorRef v92 = v141;
            }
            goto LABEL_187;
          }
        }
      }
    }
    BOOL v103 = 0;
    goto LABEL_163;
  }
  CFStringRef v27 = @"Vendor Response Received, Inline PutCompleteAtEdge Required.";
  CFIndex v28 = 16;
LABEL_65:
  CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", v28, v27, v14, v15, v16, v17, v18, v140);
LABEL_66:
  uint64_t v63 = error;
  if (!error) {
    handle_response_uploadChunks_cold_3();
  }
  uint64_t v64 = *(void *)(*(void *)(***(void ***)(v6 + 88) + 32) + 48);
  int v65 = mmcs_http_context_is_connection_reused(a1);
  double v66 = CFAbsoluteTimeGetCurrent();
  mmcs_request_queue_request_did_complete(v64, (void *)a3, v63, v65, 0, v66);
  mmcs_put_container_vendor_put_done(v6);
  uint64_t v67 = *(void *)(a3 + 16);
  if (v67)
  {
    if (v67 != a1) {
      handle_response_uploadChunks_cold_4();
    }
    uint64_t v68 = mmcs_put_container_create_method_completion_info((void *)v6, a3, 0);
    mmcs_transaction_add_method_completion_info(a3, v68);
    mmcs_http_context_invalidate(*(void *)(a3 + 16));
    CFStringRef v69 = *(const void **)(a3 + 16);
    if (v69) {
      C3BaseRelease(v69);
    }
    *(void *)(a3 + 16) = 0;
  }
  mmcs_container_set_complete_error_if_absent((void *)v6, v63);
  if (a2)
  {
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = 0;
  }
  CFRelease(v63);
  if (!mmcs_put_request_has_outstanding_async_transactions(v8))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    BOOL v70 = mmcs_request_get_request_activity_marker(v8);
    os_activity_scope_enter(v70, (os_activity_scope_state_t)buf);
    CFErrorRef v71 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v72 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Uploads complete. All done! (Put request %p)", v8);
      uint64_t v73 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(state.opaque[0]) = 138543362;
        *(uint64_t *)((char *)state.opaque + 4) = (uint64_t)v72;
        _os_log_impl(&dword_1DC1CA000, v73, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&state, 0xCu);
      }
      if (v72) {
        CFRelease(v72);
      }
    }
    mmcs_put_request_all_put_completes_done((void *)v8);
    p_os_activity_scope_state_s state = (os_activity_scope_state_s *)buf;
LABEL_107:
    os_activity_scope_leave(p_state);
  }
}

uint64_t mmcs_put_request_has_outstanding_async_transactions(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 304);
  uint64_t v3 = *(void *)(v2 + 96);
  if (v3)
  {
    if (mmcs_http_context_is_sending(v3)) {
      return 1;
    }
    uint64_t v2 = *(void *)(a1 + 304);
  }
  if (mmcs_put_state_has_outstanding_async_transactions(*(void *)(v2 + 80))) {
    return 1;
  }
  unsigned __int8 context = 0;
  CFSetApplyFunction(*(CFSetRef *)(*(void *)(a1 + 304) + 128), (CFSetApplierFunction)mmcs_put_request_has_outstanding_put_completes, &context);
  return context;
}

void mmcs_put_request_all_put_completes_done(void *context)
{
  uint64_t v2 = context[38];
  uint64_t v3 = *(void *)(v2 + 80);
  if (*(void *)(v3 + 8))
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(v3 + 64) + 8 * v4);
      primary_CFErrorRef error = (void *)mmcs_container_get_primary_error(v5);
      if (primary_error) {
        CFSetApplyFunction(*(CFSetRef *)(*(void *)(v5 + 88) + 16), (CFSetApplierFunction)append_error, primary_error);
      }
      ++v4;
    }
    while (v4 < *(void *)(v3 + 8));
    uint64_t v2 = context[38];
  }
  CFSetApplyFunction(*(CFSetRef *)(v2 + 56), (CFSetApplierFunction)notify_item_of_put_container_errors, context);
  CFErrorRef v12 = mmcs_put_state_copy_error_for_failed_containers(*(void *)(context[38] + 80));
  if (v12
    || (CFErrorRef v12 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 7, @"There was no specific acknowledgement of success", v7, v8, v9, v10, v11, v13)) != 0)
  {
    mmcs_put_request_put_complete_failed((uint64_t)context, (uint64_t)v12);
    mmcs_put_request_context_cleanup((uint64_t)context, (uint64_t)v12);
    CFRelease(v12);
  }
  else
  {
    mmcs_put_request_context_cleanup((uint64_t)context, 0);
  }
}

void mmcs_put_request_process_put_authorization_data(uint64_t a1, CFDataRef *a2)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    char Length = CFDataGetLength(*a2);
    CFStringRef v6 = CFStringCreateWithFormat(v5, 0, @"Got %ld bytes");
    uint64_t v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v66 = v6;
      _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v6) {
      CFRelease(v6);
    }
  }
  if (mmcs_server_version_compare(*(void *)(a1 + 120), *(void *)(a1 + 128), 5, 0) == -1)
  {
    CFStringRef v22 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v28 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Server version %ld.%ld not supported. Must be at least %ld.%ld", *(void *)(a1 + 120), *(void *)(a1 + 128), 5, 0);
      CFStringRef v29 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v66 = v28;
        _os_log_impl(&dword_1DC1CA000, v29, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v28) {
        CFRelease(v28);
      }
    }
    CFErrorRef v30 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Server version %ld.%ld not supported. Must be at least %ld.%ld", v23, v24, v25, v26, v27, *(void *)(a1 + 120));
  }
  else
  {
    int v8 = *(unsigned __int8 *)(a1 + 272);
    CFIndex v9 = CFDataGetLength(*a2);
    BytePtr = (char *)CFDataGetBytePtr(*a2);
    unint64_t v11 = v9;
    if (v8)
    {
      CFErrorRef v12 = chunkserver__authorize_simulcast_response__unpack(0, v9, BytePtr);
      unint64_t v13 = v12[3];
      uint64_t v14 = (char *)v12[4];
      CFIndex v15 = v12[7];
      uint64_t v16 = (const UInt8 *)v12[8];
      *(void *)(a1 + 280) = CFDataCreate(0, (const UInt8 *)v12[6], v12[5]);
      *(void *)(a1 + 288) = CFDataCreate(0, v16, v15);
      unint64_t v11 = v13;
      BytePtr = v14;
    }
    uint64_t v17 = chunkserver__storage_container_chunk_lists__unpack(0, v11, BytePtr);
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = 0;
    if (v17)
    {
      CFTypeRef cf = 0;
      if (!mmcs_put_state_create((uint64_t **)(*(void *)(a1 + 304) + 80), a1, v17, &cf))
      {
        uint64_t v40 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v46 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to create upload state");
          uint64_t v47 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v66 = v46;
            _os_log_impl(&dword_1DC1CA000, v47, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v46) {
            CFRelease(v46);
          }
        }
        uint64_t v48 = cf;
        if (!cf)
        {
          uint64_t v48 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Failed to create upload state", v41, v42, v43, v44, v45, Length);
          CFTypeRef cf = v48;
        }
        mmcs_put_request_context_cleanup(a1, (uint64_t)v48);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = 0;
        goto LABEL_67;
      }
      if (*(void *)(*(void *)(*(void *)(a1 + 304) + 80) + 8))
      {
        if (!*(unsigned char *)(a1 + 72))
        {
          uint64_t v57 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v58 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"not using proxy locator");
            int v59 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v66 = v58;
              _os_log_impl(&dword_1DC1CA000, v59, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v58) {
              CFRelease(v58);
            }
          }
          send_request_uploadChunks(a1);
          goto LABEL_67;
        }
        CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &kC3BaseArrayCallBacks);
        uint64_t v20 = *(void *)(*(void *)(a1 + 304) + 80);
        if (*(void *)(v20 + 8))
        {
          unint64_t v21 = 0;
          do
          {
            CFArrayAppendValue(Mutable, *(const void **)(*(void *)(v20 + 64) + 8 * v21++));
            uint64_t v20 = *(void *)(*(void *)(a1 + 304) + 80);
          }
          while (v21 < *(void *)(v20 + 8));
        }
        if (mmcs_request_setup_proxy_locator_for_containers(a1, Mutable))
        {
          mmcs_proxy_locator_locate(*(void *)(a1 + 192));
          if (!Mutable) {
            goto LABEL_67;
          }
        }
        else
        {
          double v60 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v61 = CFStringCreateWithFormat(v18, 0, @"couldn't create proxy locator");
            int v62 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v66 = v61;
              _os_log_impl(&dword_1DC1CA000, v62, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
            }
            if (v61) {
              CFRelease(v61);
            }
          }
          send_request_uploadChunks(a1);
          if (!Mutable) {
            goto LABEL_67;
          }
        }
      }
      else
      {
        uint64_t v49 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v50 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"No work to do");
          CFErrorRef v51 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v66 = v50;
            _os_log_impl(&dword_1DC1CA000, v51, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v50) {
            CFRelease(v50);
          }
        }
        if (!mmcs_put_request_has_items_not_done(a1))
        {
          mmcs_put_request_context_cleanup(a1, 0);
          goto LABEL_67;
        }
        CFDictionaryRef Mutable = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Item not specifically handled by the server", v52, v53, v54, v55, v56, Length);
        mmcs_put_request_context_cleanup(a1, (uint64_t)Mutable);
        if (!Mutable) {
          goto LABEL_67;
        }
      }
      CFRelease(Mutable);
LABEL_67:
      chunkserver__storage_container_chunk_lists__free_unpacked((void **)v17, 0);
      return;
    }
    uint64_t v31 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v37 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Malformed put authorization");
      uint64_t v38 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v66 = v37;
        _os_log_impl(&dword_1DC1CA000, v38, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v37) {
        CFRelease(v37);
      }
    }
    CFErrorRef v30 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Malformed put authorization", v32, v33, v34, v35, v36, Length);
  }
  CFErrorRef v39 = v30;
  mmcs_put_request_context_cleanup(a1, (uint64_t)v30);
  if (v39) {
    CFRelease(v39);
  }
}

void __mmcs_put_request_process_put_authorization_data_block_invoke(uint64_t a1)
{
}

void send_request_uploadChunks(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  os_activity_scope_enter(request_activity_marker, &state);
  if (!*(unsigned char *)(a1 + 144))
  {
    mmcs_put_item_progress_make_state_progress(4, (uint64_t)v19, 0.0);
    mmcs_put_request_set_progress_and_notify_all_items_not_done(a1, (uint64_t)v19);
    if (!*(unsigned char *)(a1 + 144))
    {
      uint64_t v3 = *(void *)(*(void *)(a1 + 304) + 88);
      if (v3)
      {
        CFAbsoluteTimeGetCurrent();
        mmcs_perform_timer_set_next_fire_date(v3);
      }
      mmcs_engine_poll_for_preferences_update(*(void *)(a1 + 32));
      v27.opaque[0] = 0;
      v27.opaque[1] = 0;
      unint64_t v4 = mmcs_request_get_request_activity_marker(a1);
      os_activity_scope_enter(v4, &v27);
      uint64_t v5 = *(void *)(*(void *)(a1 + 304) + 80);
      if (!*(void *)(v5 + 8))
      {
LABEL_19:
        mmcs_proxy_locator_finish(*(void *)(a1 + 192));
        os_activity_scope_leave(&v27);
        schedulePutComplete(*(uint64_t **)(*(void *)(a1 + 304) + 80));
        goto LABEL_4;
      }
      uint64_t v6 = 0;
      CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      while (1)
      {
        uint64_t v7 = *(void *)(*(void *)(v5 + 64) + 8 * v6);
        int v8 = (uint64_t *)(v7 + 24);
        if (!*(void *)(v7 + 24))
        {
          int v8 = (uint64_t *)(v7 + 16);
          int v10 = 3;
          goto LABEL_18;
        }
        if (gMMCS_DebugLevel < 4) {
          goto LABEL_16;
        }
        CFIndex v9 = mmcs_logging_logger_default();
        int v10 = 2;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
          break;
        }
LABEL_18:
        uint64_t v13 = *v8;
        *(_DWORD *)(v7 + 68) = v10;
        uint64_t v14 = mmcs_http_request_options_network_behavior_type(*(void *)(*(void *)(v13 + 24) + 24));
        uint64_t v15 = mmcs_request_type_for_behavior_and_activity(v14, 0);
        long long v26 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v21 = 0u;
        mmcs_container_requirements(v7);
        *(void *)&long long buf = 0;
        *((void *)&buf + 1) = v13;
        uint64_t v16 = *(void *)(a1 + 88);
        uint64_t v29 = v15;
        uint64_t v30 = v16;
        long long v33 = v23;
        long long v34 = v24;
        long long v35 = v25;
        long long v36 = v26;
        long long v31 = v21;
        long long v32 = v22;
        CFStringRef v37 = mmcs_container_schedule_request_callback;
        uint64_t v38 = mmcs_container_cancel_request_callback;
        CFErrorRef v39 = C3BaseRetain;
        uint64_t v40 = C3BaseRelease;
        *(_DWORD *)(v13 + 48) = 2;
        double Current = CFAbsoluteTimeGetCurrent();
        *(double *)(v13 + 56) = Current;
        mmcs_request_queue_enqueue_request(*(void *)(*(void *)(a1 + 32) + 48), (uint64_t)&buf, Current);
        if ((unint64_t)++v6 >= *(void *)(v5 + 8)) {
          goto LABEL_19;
        }
      }
      CFStringRef v11 = CFStringCreateWithFormat(alloc, 0, @"using proxy transaction for container %s", **(void **)(*(void *)(v7 + 88) + 8));
      CFErrorRef v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v11) {
        CFRelease(v11);
      }
LABEL_16:
      int v10 = 2;
      goto LABEL_18;
    }
  }
  mmcs_proxy_locator_finish(*(void *)(a1 + 192));
  mmcs_metrics_request_set_error(*(void *)(a1 + 184), *(const void **)(a1 + 152));
  mmcs_put_request_context_cleanup(a1, *(void *)(a1 + 152));
LABEL_4:
  os_activity_scope_leave(&state);
}

uint64_t send_request_authorizePut(uint64_t a1, void *a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  uint64_t v5 = _os_activity_create(&dword_1DC1CA000, "mmcs-authorize-put", request_activity_marker, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v5, &state);
  CFStringRef v11 = *(uint64_t **)(a1 + 32);
  if (a2) {
    *a2 = 0;
  }
  if (*(unsigned char *)(a1 + 144))
  {
    CFErrorRef error = *(const void **)(a1 + 152);
    if (error)
    {
      CFRetain(error);
      uint64_t v13 = 0;
      CFURLRef v14 = 0;
      goto LABEL_25;
    }
    uint64_t v13 = 0;
    CFURLRef v14 = 0;
    goto LABEL_24;
  }
  uint64_t v15 = *(void *)(a1 + 304);
  if (!*(void *)(v15 + 144))
  {
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 30, @"There were no items in the put request.");
    CFURLRef v14 = 0;
LABEL_22:
    uint64_t v13 = 0;
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 272))
  {
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFURLRef v17 = *(const __CFURL **)(a1 + 160);
    CFStringRef v18 = @"authorizeSimulcast";
  }
  else
  {
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFURLRef v17 = *(const __CFURL **)(a1 + 160);
    if (*(void *)(v15 + 120)) {
      CFStringRef v18 = @"authorizeClone";
    }
    else {
      CFStringRef v18 = @"authorizePut";
    }
  }
  CFURLRef v14 = CFURLCreateCopyAppendingPathComponent(v16, v17, v18, 0);
  if (!v14)
  {
    CFBooleanRef v19 = @"authorizePut url";
LABEL_21:
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, v19);
    goto LABEL_22;
  }
  *(void *)(*(void *)(a1 + 304) + 104) = mmcs_put_request_create_AuthorizePutRequestBody(a1);
  if (!*(void *)(*(void *)(a1 + 304) + 104))
  {
    CFBooleanRef v19 = @"The auth put request could not be created.";
    goto LABEL_21;
  }
  mmcs_put_item_progress_make_state(3, v61);
  mmcs_put_request_set_progress_and_notify_all_items_not_done(a1, (uint64_t)v61);
  if (*(unsigned char *)(a1 + 144))
  {
    CFErrorRef error = *(const void **)(a1 + 152);
    if (error)
    {
      CFRetain(error);
      uint64_t v13 = 0;
      goto LABEL_25;
    }
    uint64_t v13 = 0;
    goto LABEL_24;
  }
  CFStringRef v23 = (const __CFString *)v11[8];
  CFStringRef v24 = (const __CFString *)v11[10];
  CFStringRef dataclass = (const __CFString *)mmcs_request_get_dataclass(a1);
  http_protobuf_message = create_http_protobuf_message(v23, v24, dataclass, *(const __CFString **)(a1 + 168), *(const __CFString **)(a1 + 176), v14, 0);
  if (!http_protobuf_message)
  {
    long long v31 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v32 = CFStringCreateWithFormat(v16, 0, @"unable to create auth put msg");
      long long v33 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v64 = v32;
        _os_log_impl(&dword_1DC1CA000, v33, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v32) {
        CFRelease(v32);
      }
    }
    CFBooleanRef v19 = @"auth put msg";
    goto LABEL_21;
  }
  uint64_t v13 = http_protobuf_message;
  uint64_t v27 = *(void *)(a1 + 304);
  if (*(unsigned char *)(a1 + 272))
  {
    if (!mmcs_http_msg_add_items_token_header_simulcast(http_protobuf_message, v27 + 152, *(void *)(v27 + 144)))
    {
      CFStringRef v28 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v29 = CFStringCreateWithFormat(v16, 0, @"unable to add token header for simulcast request");
        uint64_t v30 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          goto LABEL_89;
        }
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v64 = v29;
        goto LABEL_88;
      }
      goto LABEL_91;
    }
  }
  else if (!mmcs_http_msg_add_items_token_header(http_protobuf_message, *(void *)(v27 + 144), v27 + 152, 1, *(void *)(v27 + 120) == 0))
  {
    uint64_t v55 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v29 = CFStringCreateWithFormat(v16, 0, @"unable to add token header");
      uint64_t v30 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        goto LABEL_89;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v64 = v29;
LABEL_88:
      _os_log_impl(&dword_1DC1CA000, v30, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
LABEL_89:
      if (v29) {
        CFRelease(v29);
      }
    }
LABEL_91:
    CFStringRef v50 = @"A token was missing from the put reqeust";
    CFIndex v51 = 31;
LABEL_92:
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", v51, v50);
LABEL_23:
    if (error) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  mmcs_request_insert_headers(a1, v13);
  uint64_t v34 = *(void *)(a1 + 304);
  CFStringRef v35 = *(const __CFString **)(v34 + 40);
  if (v35)
  {
    CFHTTPMessageSetHeaderFieldValue(v13, @"x-apple-client-location", v35);
    uint64_t v34 = *(void *)(a1 + 304);
  }
  CFStringRef v36 = *(const __CFString **)(v34 + 24);
  if (v36
    || (CFStringRef v42 = (const __CFString *)CFPreferencesCopyAppValue(@"VendorHintValue", @"com.apple.mmcs")) != 0
    && (v36 = v42, CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v36)))
  {
    CFHTTPMessageSetHeaderFieldValue(v13, @"x-apple-mmcs-storage-bin", v36);
  }
  uint64_t v37 = *(void *)(a1 + 304);
  CFStringRef v38 = *(const __CFString **)(v37 + 32);
  if (v38)
  {
    CFHTTPMessageSetHeaderFieldValue(v13, @"StorageContainerSizeHint", v38);
    uint64_t v37 = *(void *)(a1 + 304);
  }
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(v37 + 104));
  CFStringRef v40 = CFStringCreateWithFormat(v16, 0, @"%ld", Length);
  if (v40)
  {
    CFStringRef v41 = v40;
    CFHTTPMessageSetHeaderFieldValue(v13, @"Content-Length", v40);
LABEL_58:
    CFRelease(v41);
    goto LABEL_66;
  }
  uint64_t v44 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v41 = CFStringCreateWithFormat(v16, 0, @"unable to add Content-Length header");
    uint64_t v45 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v64 = v41;
      _os_log_impl(&dword_1DC1CA000, v45, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v41) {
      goto LABEL_58;
    }
  }
LABEL_66:
  uint64_t v58 = 0;
  v57[0] = @"authPut";
  v57[1] = v13;
  v57[2] = *(void *)(a1 + 56);
  v57[3] = *(void *)(a1 + 96);
  if (mmcs_request_is_background(a1)) {
    uint64_t v46 = *(void *)(a1 + 104);
  }
  else {
    uint64_t v46 = 0;
  }
  v57[4] = v46;
  v57[5] = Length;
  v57[6] = -1;
  v57[7] = mmcs_put_req_context_auth_put_data_callback;
  v57[8] = mmcs_put_req_will_reset_request_body_stream;
  v57[9] = mmcs_put_req_will_retry_auth_put_after_background_error;
  v57[10] = handle_response_authorizePut;
  memset(&v57[11], 0, 24);
  v57[14] = a1;
  v57[15] = mmcs_engine_get_sparse_block_size();
  v57[16] = mmcs_engine_owner((uint64_t)v11);
  LOBYTE(v58) = 0;
  uint64_t v59 = 0;
  double v60 = v5;
  memset(v56, 0, sizeof(v56));
  mmcs_read_stream_pool_parameters_make_pool_timeout_max(v11[4], 100, (uint64_t)v56, 90.0);
  if (!mmcs_http_context_create((void *)(*(void *)(a1 + 304) + 96), *(_DWORD *)(a1 + 140), (uint64_t)v57))
  {
    uint64_t v47 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v48 = CFStringCreateWithFormat(v16, 0, @"unable to create http context");
      uint64_t v49 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v64 = v48;
        _os_log_impl(&dword_1DC1CA000, v49, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v48) {
        CFRelease(v48);
      }
    }
    CFStringRef v50 = @"http context";
    CFIndex v51 = 37;
    goto LABEL_92;
  }
  mmcs_put_req_context_make_auth_metrics((__CFArray *)a1, *(void *)(a1 + 56));
  if (mmcs_http_context_send(*(void *)(*(void *)(a1 + 304) + 96), (uint64_t)v56, v11[7]))
  {
    CFErrorRef error = 0;
    uint64_t v20 = 1;
LABEL_28:
    CFRelease(v13);
    uint64_t v21 = v20;
    goto LABEL_29;
  }
  uint64_t v52 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v53 = CFStringCreateWithFormat(v16, 0, @"unable to send http context");
    uint64_t v54 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v64 = v53;
      _os_log_impl(&dword_1DC1CA000, v54, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v53) {
      CFRelease(v53);
    }
  }
  if (mmcs_http_context_get_error(*(void *)(*(void *)(a1 + 304) + 96)))
  {
    CFErrorRef error = (const void *)mmcs_http_context_get_error(*(void *)(*(void *)(a1 + 304) + 96));
    CFRetain(error);
    goto LABEL_23;
  }
LABEL_24:
  CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Unknown error %s", v6, v7, v8, v9, v10, (char)"send_request_authorizePut");
LABEL_25:
  if (a2)
  {
    CFRetain(error);
    *a2 = error;
  }
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  if (v13) {
    goto LABEL_28;
  }
LABEL_29:
  if (v14) {
    CFRelease(v14);
  }
  if (error) {
    CFRelease(error);
  }
  if (v5) {
    os_release(v5);
  }
  os_activity_scope_leave(&state);
  return v21;
}

void mmcs_put_req_context_auth_put_data_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    CFStringRef v11 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"NULL mrc");
    uint64_t v10 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v23 = v9;
    goto LABEL_13;
  }
  uint64_t v4 = *(void *)(a2 + 304);
  uint64_t v5 = *(void *)(v4 + 96);
  if (!v5)
  {
    CFErrorRef v12 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"NULL hc");
    uint64_t v10 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v23 = v9;
    goto LABEL_13;
  }
  if (mmcs_http_context_is_complete(*(void *)(v4 + 96)))
  {
    uint64_t v8 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"transactionComplete");
    uint64_t v10 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v23 = v9;
LABEL_13:
    uint64_t v13 = v10;
    os_log_type_t v14 = OS_LOG_TYPE_ERROR;
LABEL_14:
    _os_log_impl(&dword_1DC1CA000, v13, v14, "%{public}@", buf, 0xCu);
LABEL_15:
    if (v9) {
      CFRelease(v9);
    }
    return;
  }
  if (mmcs_http_context_is_cancelled(v5)) {
    return;
  }
  if (v5 != a1)
  {
    uint64_t v15 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Callback for unknown context %p; Expected %p",
           a1,
           v5);
    uint64_t v10 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v23 = v9;
    goto LABEL_13;
  }
  switch((int)a3)
  {
    case 1:
      if (gMMCS_DebugLevel >= 4)
      {
        CFAllocatorRef v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"request data for context (%p) opened", a1);
          CFStringRef v18 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v23 = v17;
            _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v17) {
            CFRelease(v17);
          }
        }
      }
      *(void *)(*(void *)(a2 + 304) + 112) = 0;
      break;
    case 2:
      mmcs_put_req_context_write_put_auth_request_body(a2, a1);
      break;
    case 3:
      CFBooleanRef v19 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"request data for context had an error");
        uint64_t v10 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          goto LABEL_15;
        }
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v23 = v9;
        goto LABEL_13;
      }
      break;
    case 4:
      return;
    default:
      uint64_t v20 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"request data for context got unknown type %d", a3);
        uint64_t v21 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_15;
        }
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v23 = v9;
        uint64_t v13 = v21;
        os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_14;
      }
      break;
  }
}

void mmcs_put_req_will_retry_auth_put_after_background_error(uint64_t a1, uint64_t a2, __CFError *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    CFStringRef v6 = mmcs_request_copy_description(a2);
    uint64_t v7 = mmcs_cferror_copy_description(a3);
    uint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ retry auth put after error %@", v6, v7);
      uint64_t v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v12 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v6) {
      CFRelease(v6);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
}

void handle_response_authorizePut(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  if (mmcs_http_context_status_succeeded(a1))
  {
    if (*(unsigned char *)(a3 + 272))
    {
      if (!*(unsigned char *)(a3 + 72))
      {
        CFStringRef v22 = mmcs_http_context_copy_blocked_application_header_value(a1);
        if (v22)
        {
          CFStringRef v23 = (__CFString *)v22;
          if (a2)
          {
            if (*a2) {
              CFRelease(*a2);
            }
            *a2 = 0;
          }
          CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 51, v23);
          goto LABEL_29;
        }
      }
    }
    if (a2)
    {
      if (*a2)
      {
        if (CFDataGetLength((CFDataRef)*a2))
        {
          mmcs_http_context_validate_request_uuid_with_response(a1);
          *(void *)(a3 + 120) = mmcs_get_proto_version(a1);
          *(void *)(a3 + 128) = v11;
          http_clock_skew_metrics_with_http_unsigned __int8 context = mmcs_create_http_clock_skew_metrics_with_http_context(a1);
          if (http_clock_skew_metrics_with_http_context)
          {
            uint64_t v13 = http_clock_skew_metrics_with_http_context;
            mmcs_request_set_http_clock_skew_metrics(a3, http_clock_skew_metrics_with_http_context);
            CFRelease(v13);
          }
          mmcs_http_context_cleanup_response(a1);
          if (*(unsigned char *)(a3 + 248))
          {
            CFErrorRef authorization_error_with_format = mmcs_cferror_create_authorization_error_with_format(*a2, @"Successfully fetched put authorization", v14, v15, v16, v17, v18, v19, v26);
            mmcs_put_request_context_cleanup(a3, (uint64_t)authorization_error_with_format);
            if (authorization_error_with_format) {
              CFRelease(authorization_error_with_format);
            }
          }
          else
          {
            mmcs_put_request_process_put_authorization_data(a3, (CFDataRef *)a2);
          }
          if (*a2) {
            CFRelease(*a2);
          }
          *a2 = 0;
          return;
        }
        if (*a2) {
          CFRelease(*a2);
        }
      }
      *a2 = 0;
    }
    CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"The authorize put response had no body.", v6, v7, v8, v9, v10, v26);
LABEL_29:
    CFErrorRef v25 = error;
    mmcs_put_request_context_cleanup(a3, (uint64_t)error);
    if (v25)
    {
      CFRelease(v25);
    }
    return;
  }
  if (a2)
  {
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = 0;
  }
  uint64_t v21 = mmcs_http_context_get_error(a1);
  mmcs_put_request_context_cleanup(a3, v21);
}

__CFArray *mmcs_put_req_context_make_auth_metrics(__CFArray *result, uint64_t a2)
{
  if (*((void *)result + 23))
  {
    uint64_t v2 = result;
    mmcs_http_context_make_metrics(*(char **)(*((void *)result + 38) + 96), @"authPut", 0, a2, 0);
    uint64_t v3 = (__CFArray *)*((void *)v2 + 23);
    uint64_t metrics = (void *)mmcs_http_context_get_metrics(*(void *)(*((void *)v2 + 38) + 96));
    return mmcs_metrics_request_add_http_info_for_auth(v3, metrics);
  }
  return result;
}

CFSetRef mmcs_put_request_has_outstanding_chunk_jobs(uint64_t a1)
{
  CFSetRef result = **(const __CFSet ***)(a1 + 304);
  if (result) {
    return (const __CFSet *)(CFSetGetCount(result) > 0);
  }
  return result;
}

CFArrayRef mmcs_put_items(uint64_t a1, uint64_t a2, void *a3, const void *a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, CFErrorRef *a11)
{
  uint64_t v18 = a11;
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = _os_activity_create(&dword_1DC1CA000, "mmcs-put-items", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v19, &state);
  uint64_t v45 = 0;
  if (a11) {
    *a11 = 0;
  }
  values = 0;
  uint64_t v20 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    char v26 = v19;
    uint64_t v27 = a3;
    CFStringRef v28 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"baseurl: %@", a4);
    CFStringRef v29 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v48 = v28;
      _os_log_impl(&dword_1DC1CA000, v29, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    a3 = v27;
    uint64_t v19 = v26;
    uint64_t v18 = a11;
    if (v28) {
      CFRelease(v28);
    }
  }
  if (!a1 || !a4 || !a5 || !a7 || !a8 || !a9)
  {
    if (v18)
    {
      uint64_t v34 = @"Missing required parameters.";
      goto LABEL_29;
    }
LABEL_52:
    CFArrayRef v36 = 0;
    goto LABEL_53;
  }
  if (!a6)
  {
LABEL_35:
    CFArrayRef v36 = (const __CFArray *)1;
    goto LABEL_53;
  }
  if ((int)a6 >= 1)
  {
    uint64_t v30 = 0;
    while (*(void *)(a9 + 8 * v30))
    {
      if (a6 == ++v30) {
        goto LABEL_19;
      }
    }
    if (v18)
    {
      CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 35, @"Missing auth token for item at index %d.", v21, v22, v23, v24, v25, v30);
      goto LABEL_30;
    }
    goto LABEL_52;
  }
LABEL_19:
  if (*(unsigned char *)(a1 + 120))
  {
    long long v31 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v32 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"engine is already closed.");
      long long v33 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v48 = v32;
        _os_log_impl(&dword_1DC1CA000, v33, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v32) {
        CFRelease(v32);
      }
    }
    if (v18)
    {
      uint64_t v34 = @"engine is already closed.";
LABEL_29:
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 35, v34);
LABEL_30:
      CFArrayRef v36 = 0;
      *uint64_t v18 = error;
      goto LABEL_53;
    }
    goto LABEL_52;
  }
  if (mmcs_put_req_context_create(&v45, a1, a2, a3, a4, a5, 0, 0, a6, a7, a8, a9, a10, v19, (CFErrorRef *)&values) != -1)
  {
    mmcs_engine_add_request(a1, v45);
    mmcs_metrics_request_started(v45[23], *(void *)(v45[38] + 144));
    uint64_t v37 = voucher_copy();
    CFStringRef v38 = v45;
    v45[28] = v37;
    mmcs_put_req_context_init_items((uint64_t)v38);
    goto LABEL_35;
  }
  CFErrorRef v39 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v40 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to create authPut request");
    CFStringRef v41 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v48 = v40;
      _os_log_impl(&dword_1DC1CA000, v41, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v40) {
      CFRelease(v40);
    }
  }
  if (v18)
  {
    if (values)
    {
      CFArrayRef v36 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
      if (values) {
        CFRelease(values);
      }
      values = 0;
    }
    else
    {
      CFArrayRef v36 = 0;
    }
    *uint64_t v18 = mmcs_cferror_create_error_with_underlying_errors(@"com.apple.mmcs", 35, @"Failed to create authPut request", v36, 0);
    if (v36)
    {
      CFRelease(v36);
      goto LABEL_52;
    }
  }
  else
  {
    if (values) {
      CFRelease(values);
    }
    CFArrayRef v36 = 0;
    values = 0;
  }
LABEL_53:
  if (v45) {
    C3BaseRelease(v45);
  }
  if (v19) {
    os_release(v19);
  }
  os_activity_scope_leave(&state);
  return v36;
}

uint64_t mmcs_put_section_with_items(uint64_t a1, const void *a2, const char *a3, uint64_t a4, void *a5, const void *a6, uint64_t a7, CFIndex a8, uint64_t a9, uint64_t a10, int a11, CFErrorRef *a12)
{
  uint64_t v18 = a12;
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = _os_activity_create(&dword_1DC1CA000, "mmcs-put-section-with-items", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v19, &state);
  CFErrorRef v71 = 0;
  if (a12) {
    *a12 = 0;
  }
  values = 0;
  uint64_t v20 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v21 = v19;
    CFStringRef v22 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"baseurl: %@", a2);
    uint64_t v23 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v77 = v22;
      _os_log_impl(&dword_1DC1CA000, v23, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    uint64_t v19 = v21;
    uint64_t v18 = a12;
    if (v22) {
      CFRelease(v22);
    }
  }
  if (!a10 || !a7 || !a1 || !a2 || !a3 || !a9)
  {
    if (v18)
    {
      CFStringRef v29 = @"Missing required parameters.";
      goto LABEL_25;
    }
    goto LABEL_65;
  }
  if (!a8)
  {
    uint64_t v31 = 1;
    goto LABEL_66;
  }
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v24 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      uint64_t v25 = v18;
      char v26 = v19;
      CFStringRef v27 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"engine is already closed.");
      CFStringRef v28 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v77 = v27;
        _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      uint64_t v19 = v26;
      uint64_t v18 = v25;
      if (v27) {
        CFRelease(v27);
      }
    }
    if (v18)
    {
      CFStringRef v29 = @"engine is already closed.";
LABEL_25:
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 35, v29);
LABEL_26:
      uint64_t v31 = 0;
      *uint64_t v18 = error;
      goto LABEL_66;
    }
    goto LABEL_65;
  }
  uint64_t v75 = 666;
  uint64_t v73 = a10;
  uint64_t v74 = a7;
  int v69 = a11;
  if (mmcs_put_req_context_create(&v71, a1, a4, a5, a2, a3, a6, 1, 1, (uint64_t)&v75, (uint64_t)&v74, (uint64_t)&v73, (uint64_t)&v69, v19, (CFErrorRef *)&values) == -1)
  {
    uint64_t v43 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      uint64_t v44 = v18;
      uint64_t v45 = v19;
      CFStringRef v46 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to create authPut request");
      uint64_t v47 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v77 = v46;
        _os_log_impl(&dword_1DC1CA000, v47, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      uint64_t v19 = v45;
      uint64_t v18 = v44;
      if (v46) {
        CFRelease(v46);
      }
    }
    if (!v18)
    {
      if (values) {
        CFRelease(values);
      }
      uint64_t v31 = 0;
      values = 0;
      goto LABEL_66;
    }
    if (values)
    {
      uint64_t v31 = (uint64_t)CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
      if (values) {
        CFRelease(values);
      }
      values = 0;
    }
    else
    {
      uint64_t v31 = 0;
    }
    *uint64_t v18 = mmcs_cferror_create_error_with_underlying_errors(@"com.apple.mmcs", 35, @"Failed to create authPut request", (const __CFArray *)v31, 0);
    if (!v31) {
      goto LABEL_66;
    }
    CFRelease((CFTypeRef)v31);
LABEL_65:
    uint64_t v31 = 0;
    goto LABEL_66;
  }
  CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a8, MEMORY[0x1E4F1D548]);
  if (!Mutable)
  {
    CFStringRef v48 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      uint64_t v54 = v18;
      uint64_t v55 = v19;
      CFStringRef v56 = CFStringCreateWithFormat(v32, 0, @"Failed to allocate itemIdSet for %llu itemds.", a8);
      uint64_t v57 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v77 = v56;
        _os_log_impl(&dword_1DC1CA000, v57, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      uint64_t v19 = v55;
      uint64_t v18 = v54;
      if (v56) {
        CFRelease(v56);
      }
    }
    if (v18)
    {
      CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed to allocate itemIdSet for %llu itemds.", v49, v50, v51, v52, v53, a8);
      goto LABEL_26;
    }
    goto LABEL_65;
  }
  uint64_t v34 = Mutable;
  CFIndex v35 = a8;
  CFArrayRef v36 = v19;
  uint64_t v37 = 0;
  uint64_t v38 = v35;
  CFIndex v39 = v35;
  while (1)
  {
    CFNumberRef v40 = CFNumberCreate(v32, kCFNumberSInt64Type, (const void *)(a9 + v37));
    if (!v40) {
      break;
    }
    CFSetAddValue(v34, v40);
    v37 += 8;
    if (!--v39)
    {
      *(void *)(v71[38] + 72) = v34;
      uint64_t v41 = voucher_copy();
      CFStringRef v42 = v71;
      v71[28] = v41;
      mmcs_engine_add_request(a1, v42);
      mmcs_metrics_request_started(v71[23], *(void *)(v71[38] + 144));
      if (mmcs_put_req_context_init_items_for_section((uint64_t)v71, v38, a9, v18))
      {
        uint64_t v31 = 1;
        goto LABEL_73;
      }
      mmcs_engine_remove_request(a1, v71);
      goto LABEL_72;
    }
  }
  uint64_t v58 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v64 = CFStringCreateWithFormat(v32, 0, @"Failed to allocate itemIdWrapper for itemId %llu.", a9 + v37);
    uint64_t v65 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v77 = v64;
      _os_log_impl(&dword_1DC1CA000, v65, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v64) {
      CFRelease(v64);
    }
  }
  if (v18)
  {
    uint64_t v31 = 0;
    *uint64_t v18 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed to allocate itemIdWrapper for itemId %llu.", v59, v60, v61, v62, v63, a9 + v37);
    goto LABEL_73;
  }
LABEL_72:
  uint64_t v31 = 0;
LABEL_73:
  uint64_t v19 = v36;
LABEL_66:
  if (v71) {
    C3BaseRelease(v71);
  }
  CFErrorRef v71 = 0;
  if (v19) {
    os_release(v19);
  }
  os_activity_scope_leave(&state);
  return v31;
}

uint64_t mmcs_put_request_has_outstanding_put_completes(uint64_t result, unsigned char *a2)
{
  if (a2)
  {
    if (result)
    {
      if (!*a2)
      {
        CFSetRef result = *(void *)(result + 8);
        if (result)
        {
          CFSetRef result = mmcs_http_context_is_sending(result);
          if (result) {
            *a2 = 1;
          }
        }
      }
    }
  }
  return result;
}

void mmcs_put_req_will_retry_put_complete_after_error(uint64_t a1, uint64_t *a2, __CFError *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a2;
  uint64_t v5 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    CFStringRef v6 = mmcs_request_copy_description(v4);
    uint64_t v7 = mmcs_cferror_copy_description(a3);
    uint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ retry put complete after error %@", v6, v7);
      uint64_t v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v12 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v6) {
      CFRelease(v6);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
}

void handle_response_putComplete(uint64_t a1, CFDataRef *a2, uint64_t a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  CFStringRef v6 = *(void **)a3;
  mmcs_http_context_cleanup_response(a1);
  if (mmcs_http_context_status_succeeded(a1))
  {
    if (a2)
    {
      if (*a2)
      {
        CFIndex Length = CFDataGetLength(*a2);
        if (Length)
        {
          unint64_t v8 = Length;
          CFStringRef v9 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            char v44 = v8;
            CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Got %ld bytes");
            uint64_t v11 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
            {
              LODWORD(buf.opaque[0]) = 138543362;
              *(uint64_t *)((char *)buf.opaque + 4) = (uint64_t)v10;
              _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
            }
            if (v10) {
              CFRelease(v10);
            }
          }
          uint64_t v12 = *(void *)(v6[38] + 120);
          BytePtr = (char *)CFDataGetBytePtr(*a2);
          if (v12)
          {
            uint64_t v14 = (void **)chunkserver__clone_complete_response__unpack(0, v8, BytePtr);
            if (v14)
            {
              uint64_t v15 = v14;
              mmcs_put_state_process_clone_complete(*(uint64_t **)(v6[38] + 80), v14);
              chunkserver__clone_complete_response__free_unpacked(v15, 0);
            }
          }
          else
          {
            CFStringRef v27 = (void **)chunkserver__storage_container_error_list__unpack(0, v8, BytePtr);
            if (v27)
            {
              CFStringRef v28 = v27;
              mmcs_put_state_process_storage_container_error_list(*(uint64_t **)(v6[38] + 80), v27);
              chunkserver__storage_container_error_list__free_unpacked(v28, 0);
            }
            else
            {
              CFStringRef v29 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
              {
                CFStringRef v35 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Error parsing response from server.");
                CFArrayRef v36 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(buf.opaque[0]) = 138543362;
                  *(uint64_t *)((char *)buf.opaque + 4) = (uint64_t)v35;
                  _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&buf, 0xCu);
                }
                if (v35) {
                  CFRelease(v35);
                }
              }
              CFErrorRef v37 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 5, @"Unable to unpack protobuf response from server", v30, v31, v32, v33, v34, v44);
              mmcs_put_complete_set_error_and_push_to_containers(a3, v37);
              if (v37) {
                CFRelease(v37);
              }
            }
          }
          if (*a2) {
            CFRelease(*a2);
          }
          *a2 = 0;
          goto LABEL_36;
        }
      }
    }
    uint64_t v16 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_36;
    }
    error_with_underlying_uint64_t error = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"No body in putComplete response");
    uint64_t v18 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.opaque[0]) = 138543362;
      *(uint64_t *)((char *)buf.opaque + 4) = (uint64_t)error_with_underlying_error;
      _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&buf, 0xCu);
    }
  }
  else
  {
    if (mmcs_http_context_has_http_status(a1))
    {
      if (mmcs_http_context_http_status(a1) == 330)
      {
        uint64_t error = mmcs_http_context_get_error(a1);
        mmcs_put_request_put_complete_failed((uint64_t)v6, error);
        goto LABEL_36;
      }
      uint64_t v26 = mmcs_http_context_get_error(a1);
      char v44 = mmcs_http_context_http_status(a1);
      CFStringRef v25 = @"HTTP request failed with status: %d";
      uint64_t v20 = (void *)v26;
    }
    else
    {
      uint64_t v20 = (void *)mmcs_http_context_get_error(a1);
      CFStringRef v25 = @"HTTP request failed without status!";
    }
    error_with_underlying_uint64_t error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 5, v20, v25, v21, v22, v23, v24, v44);
    mmcs_put_complete_set_error_and_push_to_containers(a3, error_with_underlying_error);
  }
  if (error_with_underlying_error) {
    CFRelease(error_with_underlying_error);
  }
LABEL_36:
  uint64_t v38 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a3 + 24));
    LODWORD(buf.opaque[0]) = 134217984;
    *(uint64_t *)((char *)buf.opaque + 4) = Count;
    _os_log_impl(&dword_1DC1CA000, v38, OS_LOG_TYPE_INFO, "PutComplete performed for %ld containers.", (uint8_t *)&buf, 0xCu);
  }
  mmcs_put_complete_cleanup_containers(a3);
  if (!mmcs_put_request_has_outstanding_async_transactions((uint64_t)v6))
  {
    buf.opaque[0] = 0;
    buf.opaque[1] = 0;
    request_activity_marker = mmcs_request_get_request_activity_marker((uint64_t)v6);
    os_activity_scope_enter(request_activity_marker, &buf);
    uint64_t v41 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v42 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Uploads complete. All done! (Put request %p)", v6);
      uint64_t v43 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v45 = 138543362;
        CFStringRef v46 = v42;
        _os_log_impl(&dword_1DC1CA000, v43, OS_LOG_TYPE_DEFAULT, "%{public}@", v45, 0xCu);
      }
      if (v42) {
        CFRelease(v42);
      }
    }
    mmcs_put_request_all_put_completes_done(v6);
    os_activity_scope_leave(&buf);
  }
  if (a2)
  {
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = 0;
  }
}

__CFArray *mmcs_put_req_context_make_put_complete_metrics(__CFArray *result, uint64_t a2, uint64_t a3)
{
  if (*((void *)result + 23))
  {
    uint64_t v4 = result;
    mmcs_http_context_make_metrics(*(char **)(a2 + 8), @"putComplete", 0, a3, 0);
    uint64_t v5 = (__CFArray *)*((void *)v4 + 23);
    uint64_t metrics = (void *)mmcs_http_context_get_metrics(*(void *)(a2 + 8));
    return mmcs_metrics_request_add_http_info_for_completion(v5, metrics);
  }
  return result;
}

void failed_to_send_put_complete(void *a1, const void *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1[11];
  *(unsigned char *)(v3 + 33) = 0;
  if (a2) {
    mmcs_container_set_complete_error_if_absent(a1, a2);
  }
  uint64_t v4 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *(const char ***)(v3 + 8);
    if (v5) {
      CFStringRef v6 = *v5;
    }
    else {
      CFStringRef v6 = "unknown";
    }
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"failed to create putComplete for container '%s', error: %@", v6, a2);
    unint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)os_activity_scope_state_s buf = 138543362;
      CFStringRef v10 = v7;
      _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
}

void notify_item_of_put_container_errors(uint64_t a1, uint64_t a2)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  CFArrayRef v4 = *(const __CFArray **)(a1 + 184);
  if (v4 && CFArrayGetCount(v4) >= 1)
  {
    uint64_t valuePtr = 0;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 184));
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      int v7 = 0;
      uint64_t v8 = 1;
      do
      {
        CFStringRef ValueAtIndex = (__CFError *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 184), v8 - 1);
        CFErrorDomain Domain = CFErrorGetDomain(ValueAtIndex);
        if (CFEqual(@"com.apple.mmcs", Domain) && CFErrorGetCode(ValueAtIndex) == 11)
        {
          CFDictionaryRef v11 = CFErrorCopyUserInfo(ValueAtIndex);
          if (v11)
          {
            CFDictionaryRef v12 = v11;
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v11, @"kMMCSErrorItemIDKey");
            if (Value
              && (CFNumberRef v14 = Value, v15 = CFGetTypeID(Value), v15 == CFNumberGetTypeID())
              && CFNumberGetValue(v14, kCFNumberLongLongType, &valuePtr))
            {
              if (*(void *)(a1 + 40) != valuePtr) {
                CFStringRef ValueAtIndex = 0;
              }
            }
            else
            {
              CFStringRef ValueAtIndex = 0;
            }
            CFRelease(v12);
          }
          else
          {
            CFStringRef ValueAtIndex = 0;
          }
          int v7 = 1;
        }
        else
        {
          CFStringRef ValueAtIndex = 0;
        }
        if (v8 >= v6) {
          break;
        }
        ++v8;
      }
      while (!ValueAtIndex);
      if (v7 && ValueAtIndex)
      {
        CFRetain(ValueAtIndex);
        goto LABEL_31;
      }
      if (v7 && !ValueAtIndex)
      {
        keys[0] = @"kMMCSErrorRetryClientInitiatedKey";
        values = (void *)*MEMORY[0x1E4F1CFD0];
        CFDictionaryRef v17 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFStringRef ValueAtIndex = mmcs_cferror_create_with_swiss_army_knife(@"com.apple.mmcs", 16, 0, v17, 0, 0, 0, @"Item %lld in this batch failed, so this item should be retried.", valuePtr);
        if (v17) {
          CFRelease(v17);
        }
        goto LABEL_31;
      }
    }
    CFStringRef ValueAtIndex = mmcs_cferror_create_error_with_underlying_errors(@"com.apple.mmcs", 7, @"Put container(s) failed.", *(const __CFArray **)(a1 + 184), 0);
LABEL_31:
    mmcs_put_item_progress_make_done_error((uint64_t)ValueAtIndex, v19);
    mmcs_put_request_set_progress_and_notify_items_like_item(a2, (const void *)a1, v19);
    if (ValueAtIndex) {
      CFRelease(ValueAtIndex);
    }
    return;
  }
  uint64_t v16 = *(void *)(a1 + 240);
  if (v16)
  {
    mmcs_put_item_progress_make_done_error(v16, v18);
    mmcs_put_request_set_progress_and_notify_items_like_item(a2, (const void *)a1, v18);
  }
}

void mmcs_put_req_context_write_put_auth_request_body(uint64_t a1, uint64_t a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(a1 + 304) + 104))
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (1)
    {
      if (!mmcs_http_request_body_can_accept_data(a2))
      {
        if (gMMCS_DebugLevel >= 5)
        {
          uint64_t v23 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v24 = CFStringCreateWithFormat(v4, 0, @"Stream says it is full");
            CFStringRef v25 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)os_activity_scope_state_s buf = 138543362;
              CFStringRef v45 = v24;
              _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v24) {
              CFRelease(v24);
            }
          }
        }
LABEL_27:
        if (CFDataGetLength(*(CFDataRef *)(*(void *)(a1 + 304) + 104)) <= *(void *)(*(void *)(a1 + 304) + 112))
        {
          if (gMMCS_DebugLevel >= 4)
          {
            uint64_t v26 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
            {
              CFStringRef v27 = CFStringCreateWithFormat(v4, 0, @"closing request body for context (%p): all done", a2);
              CFStringRef v28 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)os_activity_scope_state_s buf = 138543362;
                CFStringRef v45 = v27;
                _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
              }
              if (v27) {
                CFRelease(v27);
              }
            }
          }
          mmcs_http_set_request_body_done(a2);
        }
        return;
      }
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(*(void *)(a1 + 304) + 104));
      uint64_t v6 = *(void *)(a1 + 304);
      uint64_t v7 = Length - *(void *)(v6 + 112);
      if (v7 < 1) {
        goto LABEL_27;
      }
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v6 + 104));
      size_t v9 = mmcs_http_write_request_body(a2, &BytePtr[*(void *)(*(void *)(a1 + 304) + 112)], v7);
      if (gMMCS_DebugLevel >= 5)
      {
        CFStringRef v10 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          char v43 = a2;
          CFStringRef v11 = CFStringCreateWithFormat(v4, 0, @"context (%p) wrote %d bytes");
          CFDictionaryRef v12 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)os_activity_scope_state_s buf = 138543362;
            CFStringRef v45 = v11;
            _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v11) {
            CFRelease(v11);
          }
        }
      }
      if ((v9 & 0x8000000000000000) != 0) {
        break;
      }
      *(void *)(*(void *)(a1 + 304) + 112) += v9;
      if (v9 != v7) {
        goto LABEL_27;
      }
    }
    CFStringRef v29 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v35 = CFStringCreateWithFormat(v4, 0, @"mmcs_http_write_request_body() failed ");
      CFArrayRef v36 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v45 = v35;
        _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v35) {
        CFRelease(v35);
      }
    }
    CFErrorRef v37 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 38, @"mmcs_http_write_request_body() failed", v30, v31, v32, v33, v34, v43);
    uint64_t v38 = *(void *)(a1 + 304);
    CFIndex v39 = *(const void **)(v38 + 104);
    if (v39)
    {
      CFRelease(v39);
      uint64_t v38 = *(void *)(a1 + 304);
    }
    *(void *)(v38 + 104) = 0;
    if (gMMCS_DebugLevel >= 4)
    {
      CFNumberRef v40 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v41 = CFStringCreateWithFormat(v4, 0, @"closing request body for context (%p) had an error %@.", a2, v37);
        CFStringRef v42 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_activity_scope_state_s buf = 138543362;
          CFStringRef v45 = v41;
          _os_log_impl(&dword_1DC1CA000, v42, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v41) {
          CFRelease(v41);
        }
      }
    }
    mmcs_http_context_should_stop_with_error(*(void *)(*(void *)(a1 + 304) + 96), v37);
    if (v37)
    {
      uint64_t v22 = v37;
      goto LABEL_50;
    }
  }
  else
  {
    uint64_t v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"There was no request body");
      uint64_t v20 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v45 = v19;
        _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v19) {
        CFRelease(v19);
      }
    }
    uint64_t v21 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"There was no request body.", v14, v15, v16, v17, v18, v43);
    mmcs_http_context_should_stop_with_error(*(void *)(*(void *)(a1 + 304) + 96), v21);
    if (v21)
    {
      uint64_t v22 = v21;
LABEL_50:
      CFRelease(v22);
    }
  }
}

char *ub_dirname_alloced(const char *a1)
{
  uint64_t v2 = (char *)malloc_type_malloc(0x400uLL, 0x93680B2CuLL);
  uint64_t v3 = v2;
  if (v2)
  {
    if (a1 && *a1)
    {
      CFAllocatorRef v4 = &a1[strlen(a1) - 1];
      while (v4 > a1)
      {
        int v5 = *(unsigned __int8 *)v4--;
        if (v5 != 47)
        {
          while (v4 > a1)
          {
            int v6 = *(unsigned __int8 *)v4--;
            if (v6 == 47)
            {
              ++v4;
              goto LABEL_13;
            }
          }
          goto LABEL_19;
        }
      }
LABEL_13:
      unint64_t v7 = v4 - a1;
      if (v4 == a1)
      {
LABEL_19:
        if (*a1 == 47) {
          char v11 = 47;
        }
        else {
          char v11 = 46;
        }
        *uint64_t v3 = v11;
        v3[1] = 0;
        return v3;
      }
      uint64_t v8 = (unsigned __int8 *)(v4 - 1);
      do
      {
        unint64_t v9 = v7;
        if (v8 <= (unsigned __int8 *)a1) {
          break;
        }
        int v10 = *v8--;
        --v7;
      }
      while (v10 == 47);
      if (v9 < 0x400)
      {
        __memcpy_chk();
        v3[v9] = 0;
      }
      else
      {
        *__error() = 63;
        free(v3);
        return 0;
      }
    }
    else
    {
      *(_WORD *)uint64_t v2 = 46;
    }
  }
  return v3;
}

uint64_t IntFromCFObject(const __CFBoolean *a1, SInt32 *a2)
{
  if (IsValidCFBoolean(a1))
  {
    SInt32 Value = CFBooleanGetValue(a1);
LABEL_3:
    *a2 = Value;
    return 1;
  }
  if (IsValidCFNumber(a1))
  {
    return CFNumberGetValue(a1, kCFNumberIntType, a2);
  }
  else
  {
    uint64_t result = (uint64_t)IsValidCFString(a1);
    if (result)
    {
      SInt32 Value = CFStringGetIntValue((CFStringRef)a1);
      goto LABEL_3;
    }
  }
  return result;
}

const void *IsValidCFArray(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFArrayGetTypeID());
  }
  return result;
}

const void *IsValidCFDictionary(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFDictionaryGetTypeID());
  }
  return result;
}

void initClientInfoHeaderTemplate()
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  memset(v17, 0, sizeof(v17));
  size_t v15 = 128;
  *(void *)uint64_t v16 = 0x200000006;
  if (sysctl(v16, 2u, v17, &v15, 0, 0) == -1) {
    *(void *)&v17[0] = 0x4E574F4E4B4E55;
  }
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFURLRef v1 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"/System/Library/CoreServices/SystemVersion.plist", kCFURLPOSIXPathStyle, 0);
  if (!v1)
  {
    char v11 = 0;
    goto LABEL_16;
  }
  CFURLRef v2 = v1;
  uint64_t v3 = CFReadStreamCreateWithFile(v0, v1);
  if (v3)
  {
    CFAllocatorRef v4 = v3;
    if (!CFReadStreamOpen(v3))
    {
      char v11 = 0;
LABEL_14:
      CFRelease(v4);
      goto LABEL_15;
    }
    CFPropertyListFormat format = 0;
    CFErrorRef error = 0;
    CFDictionaryRef v5 = (const __CFDictionary *)CFPropertyListCreateWithStream(v0, v4, 0, 0, &format, &error);
    if (v5)
    {
      CFDictionaryRef v6 = v5;
      SInt32 Value = CFDictionaryGetValue(v5, @"ProductName");
      uint64_t v8 = CFDictionaryGetValue(v6, @"ProductVersion");
      unint64_t v9 = CFDictionaryGetValue(v6, @"ProductBuildVersion");
      CFStringRef v10 = CFStringCreateWithFormat(v0, 0, @"%@;%@;%@", Value, v8, v9);
    }
    else
    {
      CFStringRef v10 = 0;
      char v11 = 0;
      CFDictionaryRef v6 = error;
      if (!error)
      {
LABEL_13:
        CFReadStreamClose(v4);
        goto LABEL_14;
      }
    }
    CFRelease(v6);
    char v11 = (__CFString *)v10;
    goto LABEL_13;
  }
  char v11 = 0;
LABEL_15:
  CFRelease(v2);
LABEL_16:
  CFDictionaryRef v12 = @"?;?;?";
  if (v11) {
    CFDictionaryRef v12 = v11;
  }
  sClientInfoHeaderTemplate = (uint64_t)CFStringCreateWithFormat(v0, 0, @"<%s> <%@>", v17, v12);
  if (v11) {
    CFRelease(v11);
  }
}

uint64_t mmcs_request_allocate(uint64_t *a1, int a2, uint64_t a3)
{
  *a1 = 0;
  if (a3 < -312) {
    return 0;
  }
  size_t v6 = a3 + 312;
  uint64_t v7 = C3TypeRegister(&mmcs_requestGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v7, v6);
  if (result)
  {
    uint64_t v8 = result;
    *(_DWORD *)(result + 16) = a2;
    *(void *)(result + 208) = 0;
    *(void *)(result + 216) = 0;
    *(void *)(result + 200) = 0;
    os_unfair_lock_lock((os_unfair_lock_t)&sMMCSRequestClassLock);
    uint64_t v9 = sMMCSRequestIndex++;
    os_unfair_lock_unlock((os_unfair_lock_t)&sMMCSRequestClassLock);
    *(void *)(v8 + 24) = v9;
    *(void *)(v8 + 304) = v8 + 312;
    *a1 = v8;
    return 1;
  }
  return result;
}

uint64_t mmcs_request_has_items_not_done(uint64_t a1)
{
  CFURLRef v1 = _requestCallbacks[5 * *(int *)(a1 + 16)];
  if (!v1) {
    mmcs_request_has_items_not_done_cold_1();
  }
  return v1();
}

CFStringRef _mmcs_request_copy_description(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v3 = *(int *)(a1 + 16);
  if (v3 > 5) {
    CFAllocatorRef v4 = @"unknown";
  }
  else {
    CFAllocatorRef v4 = *(&off_1E6C33FB8 + v3);
  }
  uint64_t v5 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 88)) {
    size_t v6 = *(__CFString **)(a1 + 88);
  }
  else {
    size_t v6 = @"0(default)";
  }
  BOOL is_background = mmcs_http_request_options_is_background(*(void *)(a1 + 56));
  uint64_t v8 = " Bg";
  if (!is_background) {
    uint64_t v8 = "";
  }
  return CFStringCreateWithFormat(v2, 0, @"<%@ req%04ld %p pri%@%s>", v4, v5, a1, v6, v8);
}

BOOL mmcs_request_is_background(uint64_t a1)
{
  return mmcs_http_request_options_is_background(*(void *)(a1 + 56));
}

uint64_t mmcs_request_index(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

CFStringRef mmcs_request_copy_description(uint64_t a1)
{
  if (!a1) {
    return @"(null)";
  }
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1) {
    return (CFStringRef)_requestCallbacks[5 * v1 + 1]();
  }
  else {
    return _mmcs_request_copy_description(a1);
  }
}

uint64_t mmcs_request_append_description(uint64_t result)
{
  if (*(void *)result)
  {
    int v1 = *(_DWORD *)(*(void *)result + 16);
    if (v1) {
      return _requestCallbacks[5 * v1 + 4]();
    }
  }
  return result;
}

uint64_t _mmcs_request_init(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, const void *a5, const char *a6, void *a7, CFErrorRef *a8)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  if (a8) {
    *a8 = 0;
  }
  *(void *)(a1 + 32) = MMCSEngineRetain(a2);
  *(void *)(a1 + 40) = a3;
  *(unsigned char *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  if (a5) {
    CFRetain(a5);
  }
  *(void *)(a1 + 160) = a5;
  if (a6) {
    CFStringRef v15 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a6, 0x8000100u);
  }
  else {
    CFStringRef v15 = 0;
  }
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 168) = v15;
  *(void *)(a1 + 96) = 0x403E000000000000;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_DWORD *)(a1 + 140) = mmcs_http_class_default_value(2);
  if (a7) {
    os_retain(a7);
  }
  *(void *)(a1 + 200) = a7;
  uint64_t v16 = (CFTypeRef *)(a1 + 56);
  uint64_t result = mmcs_http_request_options_create_with_dictionary((uint64_t *)(a1 + 56), 0);
  if (result)
  {
    *(unsigned char *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 68) = 2;
    *(_WORD *)(a1 + 296) = 0;
    *(unsigned char *)(a1 + 298) = 0;
    *(unsigned char *)(a1 + 72) = 1;
    *(_WORD *)(a1 + 248) = 0;
    *(_DWORD *)(a1 + 73) = 0;
    *(void *)(a1 + 232) = os_transaction_create();
    *(unsigned char *)(a1 + 72) = mmcs_get_BOOLean_from_cfpreferences_object_for_key(@"UseProxy", *(unsigned __int8 *)(a1 + 72));
    CFBooleanRef cfBOOLean_from_cfpreferences_object_for_key = (const __CFBoolean *)mmcs_get_cfBOOLean_from_cfpreferences_object_for_key(@"UseEdge", 0);
    *(unsigned char *)(a1 + 74) = mmcs_get_BOOLean_from_cfpreferences_object_for_key(@"UseLimp", *(unsigned __int8 *)(a1 + 74));
    *(unsigned char *)(a1 + 75) = mmcs_get_BOOLean_from_cfpreferences_object_for_key(@"UseContainerInterrupting", *(unsigned __int8 *)(a1 + 75));
    mmcs_report_tickle(*(void **)(a1 + 56));
    if (!a4) {
      goto LABEL_67;
    }
    CFStringRef v19 = mmcs_logging_logger_default();
    XCFPrint(v19, @"RequestOptions", a4);
    CFBooleanRef cfBOOLean_from_cfpreferences_object_for_key = (const __CFBoolean *)mmcs_get_cfBOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionUseEdge", (uint64_t)cfBOOLean_from_cfpreferences_object_for_key);
    *(unsigned char *)(a1 + 64) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestDisableVendorTLS", *(unsigned __int8 *)(a1 + 64));
    *(_DWORD *)(a1 + 68) = mmcs_get_cfindex_from_options(@"kMMCSRequestOptionSupportsInlinePutComplete", (const __CFDictionary *)a4, *(int *)(a1 + 68));
    *(unsigned char *)(a1 + 296) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionRequireInlineComplete", *(unsigned __int8 *)(a1 + 296));
    *(unsigned char *)(a1 + 297) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionInlineCompleteLogicInvertedMode", *(unsigned __int8 *)(a1 + 297));
    *(unsigned char *)(a1 + 298) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionCancelRequestOnVerificationQueue", *(unsigned __int8 *)(a1 + 298));
    *(unsigned char *)(a1 + 72) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionUseProxy", *(unsigned __int8 *)(a1 + 72));
    *(unsigned char *)(a1 + 73) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionProxyDown", *(unsigned __int8 *)(a1 + 73));
    *(unsigned char *)(a1 + 74) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionResumableContainerLimpMode", *(unsigned __int8 *)(a1 + 74));
    *(unsigned char *)(a1 + 76) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSChunkingLibraryCorruptionMode", *(unsigned __int8 *)(a1 + 76));
    *(unsigned char *)(a1 + 248) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestFetchAuthorizationOnly", *(unsigned __int8 *)(a1 + 248));
    *(unsigned char *)(a1 + 249) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestReturnDownloadAuthorization", *(unsigned __int8 *)(a1 + 249));
    uint64_t v20 = mmcs_network_request_options_for_options((const __CFDictionary *)a4);
    CFStringRef v110 = 0;
    if (v20)
    {
      uint64_t v21 = v20;
      if (mmcs_http_request_options_create_with_dictionary((uint64_t *)&v110, v20))
      {
        if (*v16) {
          CFRelease(*v16);
        }
        *uint64_t v16 = v110;
      }
      else
      {
        uint64_t v22 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          char v109 = (char)v21;
          CFStringRef v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unable to initialize using network request options %@");
          CFStringRef v24 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)os_activity_scope_state_s buf = 138543362;
            *(void *)&uint8_t buf[4] = v23;
            _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v23) {
            CFRelease(v23);
          }
        }
      }
      CFRelease(v21);
    }
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionMmeDataClass");
    if (Value)
    {
      CFStringRef v26 = Value;
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(v26)) {
        *(void *)(a1 + 48) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v26);
      }
    }
    CFStringRef v28 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionServerProtocolVersion");
    if (v28)
    {
      CFStringRef v29 = v28;
      CFTypeID v30 = CFStringGetTypeID();
      if (v30 == CFGetTypeID(v29))
      {
        *(void *)(a1 + 120) = mmcs_server_version_make_from_CFString(v29);
        *(void *)(a1 + 128) = v31;
      }
    }
    CFNumberRef v32 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestUrlExpiryDuration");
    if (v32)
    {
      CFNumberRef v33 = v32;
      CFTypeID v34 = CFNumberGetTypeID();
      if (v34 == CFGetTypeID(v33)) {
        CFNumberGetValue(v33, kCFNumberIntType, (void *)(a1 + 80));
      }
    }
    CFStringRef v35 = CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionContainerIdentifier");
    if (v35)
    {
      CFArrayRef v36 = v35;
      CFTypeID v37 = CFStringGetTypeID();
      if (v37 == CFGetTypeID(v36)) {
        *(void *)(a1 + 240) = v36;
      }
    }
    uint64_t v38 = CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionPriority");
    if (v38)
    {
      CFIndex v39 = v38;
      CFTypeID v40 = CFNumberGetTypeID();
      if (v40 == CFGetTypeID(v39)) {
        mmcs_request_set_priority(a1, v39);
      }
    }
    CFNumberRef v41 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestTimeoutPeriod");
    if (v41)
    {
      CFNumberRef v42 = v41;
      CFTypeID v43 = CFNumberGetTypeID();
      if (v43 == CFGetTypeID(v42))
      {
        *(void *)os_activity_scope_state_s buf = 0;
        if (CFNumberGetValue(v42, kCFNumberDoubleType, buf))
        {
          if (*(double *)buf > 0.0) {
            *(void *)(a1 + 96) = *(void *)buf;
          }
        }
      }
    }
    CFNumberRef v44 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionAuthTokenTimeout");
    if (v44)
    {
      CFNumberRef v45 = v44;
      CFTypeID v46 = CFNumberGetTypeID();
      if (v46 == CFGetTypeID(v45))
      {
        *(void *)os_activity_scope_state_s buf = 0;
        if (CFNumberGetValue(v45, kCFNumberDoubleType, buf))
        {
          if (*(double *)buf > 0.0) {
            *(void *)(a1 + 104) = *(void *)buf;
          }
        }
      }
    }
    uint64_t v47 = CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionCallerRequestUUID");
    if (v47)
    {
      uint64_t v48 = v47;
      CFTypeID v49 = CFStringGetTypeID();
      if (v49 == CFGetTypeID(v48))
      {
        CFRetain(v48);
        *(void *)(a1 + 176) = v48;
      }
    }
    uint64_t v50 = CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionHTTPClass");
    if (v50)
    {
      uint64_t v51 = v50;
      CFTypeID v52 = CFStringGetTypeID();
      if (v52 == CFGetTypeID(v51))
      {
        unsigned int v53 = mmcs_http_class_for_string(v51);
        if (v53)
        {
          *(_DWORD *)(a1 + 140) = v53;
        }
        else
        {
          uint64_t v54 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
          {
            CFAllocatorRef v55 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            char v109 = (char)v51;
            mmcs_http_class_description(*(_DWORD *)(a1 + 140));
            CFStringRef v56 = CFStringCreateWithFormat(v55, 0, @"Unknown http class %@: using %@");
            uint64_t v57 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)os_activity_scope_state_s buf = 138543362;
              *(void *)&uint8_t buf[4] = v56;
              _os_log_impl(&dword_1DC1CA000, v57, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            }
            if (v56) {
              CFRelease(v56);
            }
          }
        }
      }
    }
    uint64_t v58 = CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionPreauthorization");
    if (v58)
    {
      uint64_t v59 = v58;
      CFTypeID v60 = CFDataGetTypeID();
      if (v60 == CFGetTypeID(v59))
      {
        CFDataRef v66 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionPreauthorizationSignature");
        if (mmcs_request_validate_preauthorization_object((const __CFData *)v59, v66))
        {
          mmcs_request_set_preauthorization_object(a1, v59);
          goto LABEL_64;
        }
        if (!a8) {
          return 0;
        }
        CFStringRef v79 = @"preauthentication object is not authentic";
      }
      else
      {
        if (!a8) {
          return 0;
        }
        CFStringRef v79 = @"preauthentication object must be type CFData";
      }
      *a8 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, v79, v61, v62, v63, v64, v65, v109);
      return 0;
    }
LABEL_64:
    CFBooleanRef v67 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionSimulcast");
    if (v67)
    {
      CFBooleanRef v68 = v67;
      CFTypeID v69 = CFBooleanGetTypeID();
      if (v69 == CFGetTypeID(v68)) {
        *(unsigned char *)(a1 + 272) = CFBooleanGetValue(v68);
      }
    }
LABEL_67:
    if (cfBOOLean_from_cfpreferences_object_for_key)
    {
      CFTypeRef v70 = *v16;
      if (CFBooleanGetValue(cfBOOLean_from_cfpreferences_object_for_key)) {
        CFErrorRef v71 = @"true";
      }
      else {
        CFErrorRef v71 = @"false";
      }
      mmcs_http_request_options_add_inserted_header_if_absent((uint64_t)v70, @"x-apple-use-edge", v71);
    }
    int BOOLean_from_cfdictionary_object_for_key = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionMetaserverCheckDisabled", 0);
    if (!a5 || BOOLean_from_cfdictionary_object_for_key) {
      goto LABEL_87;
    }
    if (a4)
    {
      uint64_t v73 = CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionMetaserverAllowedHostnamesOverride");
      if (v73)
      {
        CFTypeID v74 = CFArrayGetTypeID();
        if (v74 != CFGetTypeID(v73)) {
          uint64_t v73 = 0;
        }
      }
      CFStringRef v75 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionMetaserverAllowedSchemesOverride");
      if (v75)
      {
        CFStringRef v76 = v75;
        CFTypeID v77 = CFArrayGetTypeID();
        if (v77 == CFGetTypeID(v76)) {
          CFStringRef v78 = v76;
        }
        else {
          CFStringRef v78 = 0;
        }
        goto LABEL_86;
      }
    }
    else
    {
      uint64_t v73 = 0;
    }
    CFStringRef v78 = 0;
LABEL_86:
    if (mmcs_report_is_valid_base_url_for_mobile_me((const __CFArray *)v73, v78, (const __CFURL *)a5))
    {
LABEL_87:
      if (*(unsigned char *)(a1 + 72))
      {
        if (mmcs_proxy_locator_should_disable_for_request(a1))
        {
          CFStringRef v80 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v81 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"LAN Asset Cache Disabled for this request");
            uint64_t v82 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)os_activity_scope_state_s buf = 138543362;
              *(void *)&uint8_t buf[4] = v81;
              _os_log_impl(&dword_1DC1CA000, v82, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v81) {
              CFRelease(v81);
            }
          }
          *(unsigned char *)(a1 + 72) = 0;
          goto LABEL_95;
        }
        if (*(unsigned char *)(a1 + 72))
        {
          int v95 = mmcs_proxy_locator_exists();
          *(unsigned char *)(a1 + 72) = v95;
          if (v95)
          {
            if (*(_DWORD *)(a1 + 68) == 2)
            {
              *(_DWORD *)(a1 + 68) = 0;
              uint64_t v96 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
              {
                CFStringRef v97 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Disabling inline put complete due to LAN Asset Cache.");
                uint64_t v98 = mmcs_logging_logger_default();
                if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_142;
                }
                *(_DWORD *)os_activity_scope_state_s buf = 138543362;
                *(void *)&uint8_t buf[4] = v97;
                goto LABEL_141;
              }
            }
          }
          else
          {
            CFDictionaryRef v108 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
            {
              CFStringRef v97 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to find LAN Asset Cache for eligable request.");
              uint64_t v98 = mmcs_logging_logger_default();
              if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_142;
              }
              *(_DWORD *)os_activity_scope_state_s buf = 138543362;
              *(void *)&uint8_t buf[4] = v97;
LABEL_141:
              _os_log_impl(&dword_1DC1CA000, v98, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
LABEL_142:
              if (v97) {
                CFRelease(v97);
              }
            }
          }
        }
      }
LABEL_95:
      if (*(unsigned char *)(a1 + 75))
      {
        double v83 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v84 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"********************* ENABLING TESTING MODE WHICH FAILS CONTAINER TRANSACTIONS *********************");
          CFStringRef v85 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)os_activity_scope_state_s buf = 138543362;
            *(void *)&uint8_t buf[4] = v84;
            _os_log_impl(&dword_1DC1CA000, v85, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v84) {
            CFRelease(v84);
          }
        }
      }
      if (*(unsigned char *)(a1 + 296))
      {
        uint64_t v86 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v87 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"********************* ENABLING TESTING MODE WHICH FAILS NON-INLINE UPLOAD CHUNK RESPONSES *********************");
          BOOL v88 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)os_activity_scope_state_s buf = 138543362;
            *(void *)&uint8_t buf[4] = v87;
            _os_log_impl(&dword_1DC1CA000, v88, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v87) {
            CFRelease(v87);
          }
        }
      }
      if (*(unsigned char *)(a1 + 297))
      {
        uint64_t v89 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v90 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"********************* ENABLING TESTING MODE WHICH FAILS COMPLETE TRANSACTIONS *********************");
          CFStringRef v91 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)os_activity_scope_state_s buf = 138543362;
            *(void *)&uint8_t buf[4] = v90;
            _os_log_impl(&dword_1DC1CA000, v91, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v90) {
            CFRelease(v90);
          }
        }
      }
      if (*(unsigned char *)(a1 + 298))
      {
        CFErrorRef v92 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v93 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"********************* ENABLING TESTING MODE WHICH CANCELS REQUEST ON VERIFICATION QUEUE *********************");
          uint64_t v94 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)os_activity_scope_state_s buf = 138543362;
            *(void *)&uint8_t buf[4] = v93;
            _os_log_impl(&dword_1DC1CA000, v94, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v93) {
            CFRelease(v93);
          }
        }
      }
      return 1;
    }
    uint64_t v99 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v105 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to provide valid base url %@ for mobileme request.", a5);
      CFNumberRef v106 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        *(void *)&uint8_t buf[4] = v105;
        _os_log_impl(&dword_1DC1CA000, v106, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v105) {
        CFRelease(v105);
      }
    }
    if (a8)
    {
      CFErrorRef v107 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, @"Failed to provide valid base url %@ for mobileme request.", v100, v101, v102, v103, v104, (char)a5);
      uint64_t result = 0;
      *a8 = v107;
      return result;
    }
    return 0;
  }
  return result;
}

void mmcs_request_set_priority(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 88);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 88) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

uint64_t mmcs_request_validate_preauthorization_object(const __CFData *a1, const __CFData *a2)
{
  if (!a2) {
    return 1;
  }
  CFAllocatorRef v4 = mmcs_report_auth_simulcast_response_signing_key_public_current();
  CFStringRef v5 = mmcs_report_auth_simulcast_response_signing_key_public_prior();
  uint64_t v6 = mmcs_request_validate_preauthorization_with_key(a1, a2, (const __CFData *)v4);
  if (v6)
  {
    if (!v4) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  uint64_t v6 = mmcs_request_validate_preauthorization_with_key(a1, a2, (const __CFData *)v5);
  if (v4) {
LABEL_4:
  }
    CFRelease(v4);
LABEL_5:
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

void mmcs_request_set_preauthorization_object(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 264);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 264) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 264) = cf;
  }
}

uint64_t mmcs_request_get_dataclass(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  if (!result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3) {
      mmcs_request_get_dataclass_cold_1();
    }
    uint64_t result = *(void *)(v3 + 88);
    if (!result) {
      mmcs_request_get_dataclass_cold_2();
    }
  }
  return result;
}

BOOL mmcs_request_is_cloudkit_dataclass(uint64_t a1)
{
  CFStringRef dataclass = (const __CFString *)mmcs_request_get_dataclass(a1);
  return CFStringCompare(dataclass, @"com.apple.Dataclass.CloudKit", 1uLL) == kCFCompareEqualTo;
}

uint64_t mmcs_request_get_server_version(uint64_t a1)
{
  return *(void *)(a1 + 120);
}

uint64_t mmcs_request_get_http_request_options(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

double mmcs_request_get_network_timeout_period(uint64_t a1)
{
  return *(double *)(a1 + 96);
}

uint64_t mmcs_request_get_http_class(uint64_t a1)
{
  return *(unsigned int *)(a1 + 140);
}

uint64_t mmcs_request_should_disable_vendor_tls(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t mmcs_request_is_cancelled(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 144);
}

uint64_t mmcs_request_get_proxy_down(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 73);
}

uint64_t mmcs_request_get_url_expiry_override(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

CFTypeRef mmcs_request_set_http_clock_skew_metrics(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef result = *(CFTypeRef *)(a1 + 112);
  if (result != cf)
  {
    if (result) {
      C3BaseRelease(result);
    }
    *(void *)(a1 + 112) = cf;
    return C3BaseRetain(cf);
  }
  return result;
}

uint64_t mmcs_request_get_http_clock_skew_metrics(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

__CFString *mmcs_request_copy_persistent_identifier(uint64_t a1)
{
  return XCFCreateTruncatedHash(*(void *)(a1 + 168));
}

uint64_t mmcs_request_get_container_identifier(uint64_t a1)
{
  return *(void *)(a1 + 240);
}

uint64_t mmcs_request_cancel(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 200), &state);
  int v2 = *(unsigned __int8 *)(a1 + 144);
  uint64_t v3 = mmcs_logging_logger_default();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
  if (!v2)
  {
    if (v4)
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cancelling request %p", a1);
      CFStringRef v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v20 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    int v11 = *(_DWORD *)(a1 + 16);
    if (v11 && (uint64_t v12 = ((uint64_t (*)(uint64_t))_requestCallbacks[5 * v11 + 1])(a1)) != 0)
    {
      uint64_t v13 = (const void *)v12;
      CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ %@", @"Request was cancelled.", v12);
      CFRelease(v13);
    }
    else
    {
      CFStringRef v14 = 0;
    }
    if (v14) {
      CFStringRef v15 = (__CFString *)v14;
    }
    else {
      CFStringRef v15 = @"Request was cancelled.";
    }
    CFStringRef error = (const __CFString *)mmcs_cferror_create_error(@"com.apple.mmcs", 4, v15);
    if (v14) {
      CFRelease(v14);
    }
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16) {
      uint64_t v7 = ((uint64_t (*)(uint64_t, const __CFString *))_requestCallbacks[5 * v16 + 2])(a1, error);
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v8 = v7;
    if (!error) {
      goto LABEL_27;
    }
LABEL_26:
    CFRelease(error);
    uint64_t v8 = v7;
    goto LABEL_27;
  }
  if (!v4)
  {
    uint64_t v8 = 0;
    goto LABEL_27;
  }
  CFStringRef error = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Already cancelling. Ignoring cancel of request %p.", a1);
  uint64_t v6 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)os_activity_scope_state_s buf = 138543362;
    CFStringRef v20 = error;
    _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  if (error) {
    goto LABEL_26;
  }
LABEL_27:
  os_activity_scope_leave(&state);
  return v8;
}

uint64_t mmcs_request_cancel_with_requestor(uint64_t a1, uint64_t a2)
{
  if (!a2 || *(void *)(a1 + 40) == a2) {
    return mmcs_request_cancel(a1);
  }
  return a1;
}

uint64_t mmcs_request_setup_proxy_locator_for_containers(uint64_t a1, CFArrayRef theArray)
{
  if (!*(unsigned char *)(a1 + 72)) {
    return 0;
  }
  CFStringRef v5 = (CFTypeRef *)(a1 + 192);
  uint64_t v4 = *(void *)(a1 + 192);
  if (v4)
  {
    mmcs_proxy_locator_invalidate(v4);
    if (*v5) {
      C3BaseRelease(*v5);
    }
    CFTypeRef *v5 = 0;
  }
  return mmcs_proxy_locator_create((uint64_t *)v5, theArray, (const void *)a1);
}

uint64_t mmcs_request_get_requestor(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t mmcs_request_get_reporting_level(uint64_t a1)
{
  return *(unsigned int *)(a1 + 136);
}

uint64_t mmcs_request_is_container_resumable_limp_mode(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 74);
}

uint64_t mmcs_request_is_container_interrupted_mode(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 75);
}

uint64_t mmcs_request_is_chunking_library_corruption_mode(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 76);
}

uint64_t mmcs_request_reset_chunking_library_corruption_mode(uint64_t result)
{
  *(unsigned char *)(result + 76) = 0;
  return result;
}

uint64_t mmcs_request_set_reporting_level(uint64_t result, int a2)
{
  *(_DWORD *)(result + 136) = a2;
  return result;
}

void mmcs_request_is_using_itemid(uint64_t result, uint64_t a2)
{
  switch(*(_DWORD *)(result + 16))
  {
    case 1:
      mmcs_put_req_is_using_itemid(result, a2);
      break;
    case 2:
      mmcs_get_req_is_using_itemid(result, a2);
      break;
    case 3:
      mmcs_put_section_req_is_using_itemid(result, (void *)a2);
      break;
    case 5:
      mmcs_register_request_is_using_itemid(result, a2);
      break;
    default:
      return;
  }
}

void mmcs_request_insert_headers(uint64_t a1, void *context)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(*(void *)(a1 + 56) + 64);
  if (v2) {
    CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)_insert_header, context);
  }
}

void _insert_header(const __CFString *a1, const __CFString *a2, __CFHTTPMessage *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    CFTypeID v7 = CFStringGetTypeID();
    if (v7 == CFGetTypeID(a2))
    {
      if (_case_insensitive_equals(a1, @"x-apple-mmcs-proto-version")
        || _case_insensitive_equals(a1, @"x-apple-caller-request-uuid")
        || _case_insensitive_equals(a1, @"x-mme-client-info")
        || _case_insensitive_equals(a1, @"x-apple-mme-dsid")
        || _case_insensitive_equals(a1, @"X-Apple-MMCS"))
      {
        goto LABEL_8;
      }
      if (!_case_insensitive_equals(a1, @"X-"))
      {
        _case_insensitive_equals(a1, @"x-apple-persistent-identifier");
LABEL_8:
        uint64_t v8 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          return;
        }
        CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ ignoring insertion of header %@: %@", a3, a1, a2);
        CFStringRef v10 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          goto LABEL_12;
        }
        *(_DWORD *)os_activity_scope_state_s buf = 138543362;
        CFStringRef v16 = v9;
        int v11 = v10;
        os_log_type_t v12 = OS_LOG_TYPE_ERROR;
        goto LABEL_11;
      }
      CFHTTPMessageSetHeaderFieldValue(a3, a1, a2);
      if (gMMCS_DebugLevel > 3)
      {
        uint64_t v13 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ inserting header %@: %@", a3, a1, a2);
          CFStringRef v14 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
LABEL_12:
            if (v9) {
              CFRelease(v9);
            }
            return;
          }
          *(_DWORD *)os_activity_scope_state_s buf = 138543362;
          CFStringRef v16 = v9;
          int v11 = v14;
          os_log_type_t v12 = OS_LOG_TYPE_DEBUG;
LABEL_11:
          _os_log_impl(&dword_1DC1CA000, v11, v12, "%{public}@", buf, 0xCu);
          goto LABEL_12;
        }
      }
    }
  }
}

uint64_t mmcs_request_validate_preauthorization_with_key(const __CFData *a1, const __CFData *a2, const __CFData *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v15 = 256;
    CFErrorRef error = 0;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &v15);
    CFMutableSetRef Mutable = CFDictionaryCreateMutable(v6, 2, 0, 0);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B718], (const void *)*MEMORY[0x1E4F3B740]);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B6D8], (const void *)*MEMORY[0x1E4F3B6F0]);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B708], v7);
    CFStringRef v9 = SecKeyCreateWithData(a3, Mutable, &error);
    if (error)
    {
      CFStringRef v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138412290;
        CFErrorRef v18 = error;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "public key can't be imported due to error: %@", buf, 0xCu);
      }
    }
    uint64_t v11 = SecKeyVerifySignature(v9, (SecKeyAlgorithm)*MEMORY[0x1E4F3BA70], a1, a2, &error);
    if (error)
    {
      os_log_type_t v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_activity_scope_state_s buf = 138412290;
        CFErrorRef v18 = error;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "simulcast metadata failed integrity check due to error: %@", buf, 0xCu);
      }
      if (error) {
        CFRelease(error);
      }
    }
    CFErrorRef error = 0;
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v9) {
      CFRelease(v9);
    }
  }
  else
  {
    uint64_t v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)os_activity_scope_state_s buf = 0;
      _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "unable to verify integrity of preauthorization object due to missing public key", buf, 2u);
    }
    return 0;
  }
  return v11;
}

uint64_t mmcs_request_get_request_activity_marker(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 200);
  if (!result) {
    mmcs_request_get_request_activity_marker_cold_1();
  }
  return result;
}

os_activity_t mmcs_request_get_chunking_activity_marker(uint64_t a1)
{
  int v1 = *(NSObject **)(a1 + 200);
  if (!v1) {
    mmcs_request_get_chunking_activity_marker_cold_1();
  }
  os_activity_t result = *(os_activity_t *)(a1 + 208);
  if (!result)
  {
    os_activity_t result = _os_activity_create(&dword_1DC1CA000, "mmcs-chunking", v1, OS_ACTIVITY_FLAG_DEFAULT);
    *(void *)(a1 + 208) = result;
  }
  return result;
}

os_activity_t mmcs_request_get_timing_activity_marker(uint64_t a1)
{
  int v1 = *(NSObject **)(a1 + 200);
  if (!v1) {
    mmcs_request_get_timing_activity_marker_cold_1();
  }
  os_activity_t result = *(os_activity_t *)(a1 + 216);
  if (!result)
  {
    os_activity_t result = _os_activity_create(&dword_1DC1CA000, "mmcs-timing", v1, OS_ACTIVITY_FLAG_DEFAULT);
    *(void *)(a1 + 216) = result;
  }
  return result;
}

void _mmcs_requestCFFinalize(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if (v2) {
    ((void (*)(uint64_t))_requestCallbacks[5 * v2 + 3])(a1);
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    MMCSEngineRelease(v3);
    *(void *)(a1 + 32) = 0;
  }
  *(void *)(a1 + 40) = 0;
  mmcs_proxy_locator_invalidate(*(void *)(a1 + 192));
  uint64_t v4 = *(const void **)(a1 + 112);
  if (v4) {
    C3BaseRelease(v4);
  }
  *(void *)(a1 + 112) = 0;
  CFStringRef v5 = *(const void **)(a1 + 192);
  if (v5) {
    C3BaseRelease(v5);
  }
  *(void *)(a1 + 192) = 0;
  CFAllocatorRef v6 = *(const void **)(a1 + 56);
  if (v6) {
    C3BaseRelease(v6);
  }
  *(void *)(a1 + 56) = 0;
  CFNumberRef v7 = *(const void **)(a1 + 48);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(a1 + 48) = 0;
  uint64_t v8 = *(const void **)(a1 + 160);
  if (v8) {
    CFRelease(v8);
  }
  *(void *)(a1 + 160) = 0;
  CFStringRef v9 = *(const void **)(a1 + 168);
  if (v9) {
    CFRelease(v9);
  }
  *(void *)(a1 + 168) = 0;
  CFStringRef v10 = *(const void **)(a1 + 176);
  if (v10) {
    CFRelease(v10);
  }
  *(void *)(a1 + 176) = 0;
  uint64_t v11 = *(const void **)(a1 + 152);
  if (v11) {
    CFRelease(v11);
  }
  *(void *)(a1 + 152) = 0;
  os_log_type_t v12 = *(double **)(a1 + 184);
  if (v12)
  {
    mmcs_metrics_request_release(v12);
    *(void *)(a1 + 184) = 0;
  }
  uint64_t v13 = *(const void **)(a1 + 264);
  if (v13) {
    CFRelease(v13);
  }
  *(void *)(a1 + 264) = 0;
  CFStringRef v14 = *(const void **)(a1 + 256);
  if (v14) {
    CFRelease(v14);
  }
  *(void *)(a1 + 256) = 0;
  uint64_t v15 = *(const void **)(a1 + 88);
  if (v15) {
    CFRelease(v15);
  }
  *(void *)(a1 + 88) = 0;
  CFStringRef v16 = *(void **)(a1 + 200);
  if (v16) {
    os_release(v16);
  }
  *(void *)(a1 + 200) = 0;
  uint64_t v17 = *(void **)(a1 + 208);
  if (v17) {
    os_release(v17);
  }
  *(void *)(a1 + 208) = 0;
  CFErrorRef v18 = *(void **)(a1 + 216);
  if (v18) {
    os_release(v18);
  }
  *(void *)(a1 + 216) = 0;
  uint64_t v19 = *(void **)(a1 + 224);
  if (v19) {
    os_release(v19);
  }
  *(void *)(a1 + 224) = 0;
  CFStringRef v20 = *(void **)(a1 + 232);
  if (v20) {
    os_release(v20);
  }
  *(void *)(a1 + 232) = 0;
}

BOOL _mmcs_requestCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_requestCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_requestCFCopyDebugDescription()
{
  return 0;
}

BOOL _case_insensitive_equals(const __CFString *a1, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  if (CFStringGetLength(a1) < Length) {
    return 0;
  }
  v6.CFIndex location = 0;
  v6.unsigned int length = Length;
  return CFStringCompareWithOptions(a1, theString, v6, 1uLL) == kCFCompareEqualTo;
}

void mmcs_user_info_add_description(__CFDictionary *a1, void *value)
{
  if (value)
  {
    CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E4F1D140], value);
    uint64_t v4 = (const void *)*MEMORY[0x1E4F1D170];
    CFDictionarySetValue(a1, v4, value);
  }
}

void mmcs_user_info_add_description_with_format_and_arguments(__CFDictionary *a1, CFStringRef format, va_list arguments)
{
  CFStringRef v4 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, format, arguments);
  if (v4)
  {
    CFStringRef v5 = v4;
    CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E4F1D140], v4);
    CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E4F1D170], v5);
    CFRelease(v5);
  }
}

void mmcs_user_info_add_underlying_error(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E4F1D190], value);
  }
}

void mmcs_user_info_add_itemID(__CFDictionary *a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
  if (v3)
  {
    CFNumberRef v4 = v3;
    CFDictionarySetValue(a1, @"kMMCSErrorItemIDKey", v3);
    CFRelease(v4);
  }
}

void mmcs_user_info_add_fileSignature(__CFDictionary *a1, const UInt8 *a2)
{
  if (mmcs_file_signature_is_valid((BOOL)a2))
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex v5 = mmcs_file_signature_size_with_scheme(a2);
    CFDataRef v6 = CFDataCreate(v4, a2, v5);
    if (v6)
    {
      CFDataRef v7 = v6;
      CFDictionarySetValue(a1, @"kMMCSErrorFileSignatureKey", v6);
      CFRelease(v7);
    }
  }
}

void mmcs_user_info_add_chunkSignature(__CFDictionary *a1, const UInt8 *a2)
{
  if (mmcs_chunk_signature_is_valid((BOOL)a2))
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex v5 = mmcs_chunk_signature_size_with_scheme(a2);
    CFDataRef v6 = CFDataCreate(v4, a2, v5);
    if (v6)
    {
      CFDataRef v7 = v6;
      CFDictionarySetValue(a1, @"kMMCSErrorChunkSignatureKey", v6);
      CFRelease(v7);
    }
  }
}

void mmcs_user_info_add_http_message_request(__CFDictionary *a1, __CFHTTPMessage *a2)
{
  if (a2)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFIndex v5 = Mutable;
      CFURLRef v6 = CFHTTPMessageCopyRequestURL(a2);
      if (v6)
      {
        CFURLRef v7 = v6;
        CFDictionarySetValue(v5, @"kMMCSErrorHTTPMessageURLKey", v6);
        CFRelease(v7);
      }
      CFDictionaryRef v8 = CFHTTPMessageCopyAllHeaderFields(a2);
      if (v8)
      {
        CFDictionaryRef v9 = v8;
        CFDictionarySetValue(v5, @"kMMCSErrorHTTPMessageHeaderFieldsKey", v8);
        CFRelease(v9);
      }
      CFDictionarySetValue(a1, @"kMMCSErrorHTTPMessageRequestKey", v5);
      CFRelease(v5);
    }
  }
}

void mmcs_user_info_add_http_message_response(__CFDictionary *a1, __CFHTTPMessage *a2)
{
  if (a2)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      CFURLRef v6 = Mutable;
      CFIndex valuePtr = CFHTTPMessageGetResponseStatusCode(a2);
      CFNumberRef v7 = CFNumberCreate(v4, kCFNumberCFIndexType, &valuePtr);
      CFDictionarySetValue(a1, @"kMMCSErrorHTTPStatusKey", v7);
      if (v7) {
        CFRelease(v7);
      }
      CFDictionaryRef v8 = CFHTTPMessageCopyAllHeaderFields(a2);
      if (v8)
      {
        CFDictionaryRef v9 = v8;
        CFDictionarySetValue(v6, @"kMMCSErrorHTTPMessageHeaderFieldsKey", v8);
        CFRelease(v9);
      }
      CFDictionarySetValue(a1, @"kMMCSErrorHTTPMessageResponseKey", v6);
      CFRelease(v6);
    }
  }
}

uint64_t mmcs_put_container_create(void *a1, uint64_t *a2)
{
  CFDictionaryRef v9 = 0;
  uint64_t result = mmcs_container_create((uint64_t *)&v9, 1, 64);
  if (result)
  {
    request_activity_marker = mmcs_request_get_request_activity_marker(*a2);
    os_activity_t v6 = _os_activity_create(&dword_1DC1CA000, "mmcs-put-container", request_activity_marker, OS_ACTIVITY_FLAG_DEFAULT);
    CFNumberRef v7 = v9;
    v9[10] = v6;
    uint64_t v8 = v7[11];
    if (v8)
    {
      *(void *)uint64_t v8 = a2;
      *(void *)(v8 + 8) = 0;
      *(void *)(v8 + 16) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &itemItemIDEqualitySetCallbacks);
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      C3BaseRetain(**(CFTypeRef **)v8);
      *a1 = v9;
      return 1;
    }
    else
    {
      C3BaseRelease(v7);
      return 0;
    }
  }
  return result;
}

uint64_t mmcs_put_container_get_request(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 88);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0;
  }
}

uint64_t mmcs_put_container_http_msg_add_token_header(uint64_t a1, __CFHTTPMessage *a2)
{
  uint64_t result = 0;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      uint64_t v5 = *(void *)(a1 + 88);
      uint64_t result = *(void *)(v5 + 8);
      if (result)
      {
        if (!*(void *)result) {
          return 0;
        }
        if (!*(void *)(result + 16))
        {
          CFStringRef v10 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
            return 1;
          }
          CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Missing token for container %s", **(void **)(v5 + 8));
          os_log_type_t v12 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)os_activity_scope_state_s buf = 138543362;
            CFStringRef v17 = v11;
            _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (!v11) {
            return 1;
          }
          CFStringRef v9 = v11;
LABEL_13:
          CFRelease(v9);
          return 1;
        }
        uint64_t v6 = mmcs_request_index(result);
        CFStringRef v7 = mmcs_item_copy_token_header_value(**(char ***)(v5 + 8), 0, *(const char **)(*(void *)(v5 + 8) + 16), v6, 1);
        if (v7)
        {
          CFStringRef v8 = v7;
          CFHTTPMessageSetHeaderFieldValue(a2, @"x-apple-mmcs-auth", v7);
          CFStringRef v9 = v8;
          goto LABEL_13;
        }
        uint64_t v13 = mmcs_logging_logger_default();
        uint64_t result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
        if (result)
        {
          CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to create token header for put container %s", **(void **)(v5 + 8));
          uint64_t v15 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)os_activity_scope_state_s buf = 138543362;
            CFStringRef v17 = v14;
            _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v14) {
            CFRelease(v14);
          }
          return 0;
        }
      }
    }
  }
  return result;
}

void mmcs_put_container_invalidate(uint64_t a1)
{
  int v2 = *(CFTypeRef ***)(a1 + 88);
  CFNumberRef v3 = *v2;
  if (*v2)
  {
    if (*v3)
    {
      C3BaseRelease(*v3);
      int v2 = *(CFTypeRef ***)(a1 + 88);
    }
    *int v2 = 0;
  }
  mmcs_container_invalidate_transactions(a1);
}

void mmcs_put_container_set_storage_container(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void *)(a1 + 88);
  CFNumberRef v3 = *(void ***)(v2 + 8);
  if (v3 != a2)
  {
    if (v3) {
      mmcs_storage_container_dealloc(v3);
    }
    *(void *)(v2 + 8) = a2;
  }
}

void mmcs_put_container_set_storage_container_stream(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 88);
  CFNumberRef v3 = *(void **)(v2 + 56);
  if (v3 != a2)
  {
    if (v3) {
      mmcs_storage_container_stream_dealloc(v3);
    }
    *(void *)(v2 + 56) = a2;
  }
}

void mmcs_put_container_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 88);
  *uint64_t v2 = 0;
  CFNumberRef v3 = (void **)v2[1];
  if (v3)
  {
    mmcs_storage_container_dealloc(v3);
    v2[1] = 0;
  }
  CFAllocatorRef v4 = (void *)v2[7];
  if (v4)
  {
    mmcs_storage_container_stream_dealloc(v4);
    v2[7] = 0;
  }
  mmcs_container_invalidate_transactions(a1);
  uint64_t v5 = (const void *)v2[5];
  if (v5) {
    CFRelease(v5);
  }
  v2[5] = 0;
  uint64_t v6 = (const void *)v2[2];
  if (v6) {
    CFRelease(v6);
  }
  v2[2] = 0;
  CFStringRef v7 = (const void *)v2[3];
  if (v7) {
    CFRelease(v7);
  }
  v2[3] = 0;
}

void mmcs_put_container_cancel_transaction(void *a1, unsigned int *a2, void *cf)
{
  if (a2[12] == 2)
  {
    uint64_t v6 = (uint64_t *)a1[11];
    if (*v6) {
      uint64_t v7 = *(void *)*v6;
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v8 = mmcs_chunk_instance_offset(v7);
    mmcs_transaction_cancel_enqueued(a2, *(void *)(v8 + 48), (uint64_t)cf);
    if (!mmcs_put_state_has_outstanding_async_transactions(*v6))
    {
      CFStringRef v9 = *(uint64_t **)a1[11];
      if (v9) {
        uint64_t v10 = *v9;
      }
      else {
        uint64_t v10 = 0;
      }
      mmcs_put_request_context_cleanup(v10, (uint64_t)cf);
    }
  }
  else
  {
    mmcs_container_set_error(a1, cf);
    mmcs_transaction_cancel_not_enqueued((uint64_t)a2, (__CFError *)cf);
  }
}

void mmcs_put_container_should_stop_with_error(void *a1, void *a2)
{
  mmcs_container_set_error(a1, a2);
  mmcs_transaction_should_stop_with_error(a1[2], (__CFError *)a2);
  uint64_t v4 = a1[3];
  if (v4)
  {
    mmcs_transaction_should_stop_with_error(v4, (__CFError *)a2);
  }
}

uint64_t mmcs_put_container_requirements@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6 = mmcs_http_request_options_network_behavior_type(*(void *)(*(void *)(a2 + 24) + 24));
  uint64_t v7 = mmcs_request_type_for_behavior_and_activity(v6, 0);
  *a3 = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[1] = 0u;
  mmcs_http_request_make_request_requirements(*(void *)(a2 + 24), (uint64_t)a3);
  uint64_t result = mmcs_request_index(*(void *)(*(void *)(a1 + 88) + 8));
  *((void *)a3 + v7 + 2) = result;
  return result;
}

void mmcs_put_container_vendor_put_done(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  *(unsigned char *)(v2 + 32) = 1;
  uint64_t v3 = *(void *)(a1 + 88);
  uint64_t v4 = *(void **)(v3 + 56);
  if (v4)
  {
    mmcs_storage_container_stream_dealloc(v4);
    *(void *)(v3 + 56) = 0;
  }
  uint64_t v5 = *(const void **)(v2 + 40);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(v2 + 40) = 0;
  mmcs_storage_container_cleanup_instances(*(void *)(v2 + 8));
  *(_DWORD *)(a1 + 68) = 4;
}

void mmcs_put_container_failed_to_schedule_transaction(uint64_t a1, uint64_t a2)
{
  if (mmcs_transaction_is_proxy(a2))
  {
    mmcs_put_container_vendor_put_retry(a1, a2);
  }
  else
  {
    mmcs_put_container_vendor_put_done(a1);
    uint64_t v4 = **(uint64_t ***)(a1 + 88);
    schedulePutComplete(v4);
  }
}

uint64_t mmcs_put_container_vendor_put_retry(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (mmcs_transaction_is_proxy(a2))
  {
    uint64_t v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"caching server failed; retrying with vendor");
      uint64_t v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
  }
  uint64_t v7 = *(uint64_t ***)(a1 + 88);
  uint64_t v8 = *(void *)(a1 + 16);
  mmcs_container_remember_error(a1, a2);
  mmcs_container_reset_error_for_retry(a1);
  mmcs_put_state_container_will_be_retried(*v7, (void *)a1);
  uint64_t v9 = *(void *)(a2 + 16);
  if (v9)
  {
    mmcs_http_context_invalidate(v9);
    uint64_t v10 = *(const void **)(a2 + 16);
    if (v10) {
      C3BaseRelease(v10);
    }
    *(void *)(a2 + 16) = 0;
  }
  *(_DWORD *)(a1 + 68) = 3;
  *(_DWORD *)(v8 + 48) = 2;
  *(CFAbsoluteTime *)(v8 + 56) = CFAbsoluteTimeGetCurrent();
  uint64_t v11 = mmcs_http_request_options_network_behavior_type(*(void *)(*(void *)(v8 + 24) + 24));
  uint64_t v12 = mmcs_request_type_for_behavior_and_activity(v11, 0);
  mmcs_container_requirements(a1);
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = v8;
  uint64_t v16 = v12;
  uint64_t discretionary_network_behavior = mmcs_http_request_options_get_discretionary_network_behavior(**v7);
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  CFStringRef v24 = mmcs_container_schedule_request_callback;
  CFStringRef v25 = mmcs_container_cancel_request_callback;
  CFStringRef v26 = C3BaseRetain;
  CFStringRef v27 = C3BaseRelease;
  uint64_t v13 = mmcs_chunk_instance_offset(**v7);
  mmcs_request_queue_enqueue_request(*(void *)(v13 + 48), (uint64_t)&buf, *(double *)(v8 + 56));
  return 1;
}

uint64_t mmcs_put_container_schedule(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = _os_activity_create(&dword_1DC1CA000, "mmcs-put-schedule", *(os_activity_t *)(a1 + 80), OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v4, &state);
  CFStringRef v5 = *(uint64_t ***)(a1 + 88);
  uint64_t v6 = v5[1];
  uint64_t v7 = 0;
  if (mmcs_container_check_expired((void *)a1, a2, (uint64_t)"put", *v6)) {
    goto LABEL_43;
  }
  uint64_t v8 = mmcs_chunk_instance_offset(**v5);
  uint64_t v9 = **v5;
  uint64_t copy = mmcs_http_request_options_create_copy(*(void *)(*(void *)(a2 + 24) + 24));
  uint64_t v11 = (const void *)copy;
  if (*(unsigned char *)(*(void *)(a2 + 24) + 56) && !(*v5)[7]) {
    *(unsigned char *)(copy + 152) = 1;
  }
  if (*(double *)(a2 + 56) == 0.0)
  {
    uint64_t v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"enqueueTime should be defined for put request");
      CFStringRef v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v13;
        _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v13) {
        CFRelease(v13);
      }
    }
  }
  uint64_t v41 = 0;
  uint64_t v15 = *(void *)(*(void *)(a2 + 24) + 16);
  v40[0] = @"putContainer";
  v40[1] = v15;
  v40[2] = v11;
  v40[3] = mmcs_request_get_network_timeout_period(v9);
  if (mmcs_request_is_background(v9)) {
    uint64_t v16 = *(void *)(*(void *)(a2 + 24) + 40);
  }
  else {
    uint64_t v16 = 0;
  }
  CFTypeRef v40[4] = v16;
  v40[5] = mmcs_request_index((uint64_t)v6);
  v40[6] = -1;
  v40[7] = mmcs_put_container_write_data_callback;
  v40[8] = mmcs_put_container_will_reset_request_body_stream;
  v40[9] = mmcs_put_container_will_retry_after_background_error;
  v40[11] = 0;
  v40[12] = 0;
  v40[10] = handle_response_uploadChunks;
  v40[13] = mmcs_container_xmitcallback;
  v40[14] = a2;
  v40[15] = mmcs_engine_get_sparse_block_size();
  v40[16] = mmcs_engine_owner(v8);
  LOBYTE(v41) = 1;
  uint64_t v17 = *(void *)(a2 + 16);
  uint64_t v42 = *(void *)(a2 + 56);
  CFTypeID v43 = v4;
  if (v17) {
    mmcs_put_container_schedule_cold_1();
  }
  *(_OWORD *)CFTypeRef cf = 0u;
  long long v39 = 0u;
  mmcs_read_stream_pool_parameters_make_pool(*(void *)(v8 + 40), cf);
  unsigned int http_class = mmcs_request_get_http_class(v9);
  int v19 = mmcs_http_context_create((void *)(a2 + 16), http_class, (uint64_t)v40);
  if (v19)
  {
    mmcs_http_context_set_to_mobileme(*(void *)(a2 + 16), 0);
    mmcs_http_context_set_is_container_upload(*(void *)(a2 + 16), 1);
    mmcs_http_context_extract_vendor_name_from_message_and_create_pool_parameters(*(void *)(a2 + 16), *(void *)(v8 + 40), (uint64_t)buf);
    *(_OWORD *)CFTypeRef cf = *(_OWORD *)buf;
    long long v39 = v46;
    uint64_t v20 = *(void *)(*(void *)(a2 + 24) + 24);
    uint64_t v21 = *(void *)(*(void *)(a2 + 64) + 88);
    long long v22 = *(const char ***)(v21 + 8);
    if (mmcs_get_req_context_get_current_request_metrics(**(void **)v21))
    {
      CFStringRef v23 = *v22 ? CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *v22, 0x8000100u) : 0;
      mmcs_transaction_make_req_context_metrics((__CFArray *)a2, **(void **)v21, v20, @"putContainer", v23);
      if (v23) {
        CFRelease(v23);
      }
    }
    int v24 = mmcs_http_context_send(*(void *)(a2 + 16), (uint64_t)cf, *(void *)(v8 + 56));
  }
  else
  {
    int v24 = 0;
  }
  if (cf[1]) {
    CFRelease(cf[1]);
  }
  if (v19)
  {
    if (v24 || (CFStringRef v25 = mmcs_logging_logger_default(), !os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)))
    {
      uint64_t v7 = 1;
      goto LABEL_41;
    }
    CFStringRef v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unable to send http msg");
    CFStringRef v27 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v26;
      _os_log_impl(&dword_1DC1CA000, v27, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    uint64_t v28 = 1;
    uint64_t v7 = 1;
    if (!v26) {
      goto LABEL_41;
    }
  }
  else
  {
    CFStringRef v29 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v35 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unable to create put transaction request");
      CFArrayRef v36 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v35;
        _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v35) {
        CFRelease(v35);
      }
    }
    CFStringRef v26 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"unable to create put container request", v30, v31, v32, v33, v34, (char)cf[0]);
    mmcs_container_set_error((void *)a1, v26);
    uint64_t v28 = 0;
    uint64_t v7 = 0;
    if (!v26) {
      goto LABEL_41;
    }
  }
  CFRelease(v26);
  uint64_t v7 = v28;
LABEL_41:
  if (v11) {
    CFRelease(v11);
  }
LABEL_43:
  if (v4) {
    os_release(v4);
  }
  os_activity_scope_leave(&state);
  return v7;
}

void mmcs_put_container_write_data_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void **)(a2 + 64);
  if (!v3)
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"NULL putContainer");
    uint64_t v12 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v22 = v11;
LABEL_24:
    uint64_t v16 = v12;
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
LABEL_25:
    _os_log_impl(&dword_1DC1CA000, v16, v17, "%{public}@", buf, 0xCu);
LABEL_26:
    if (v11) {
      CFRelease(v11);
    }
    return;
  }
  if (!a1)
  {
    CFStringRef v13 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"NULL hc");
    uint64_t v12 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v22 = v11;
    goto LABEL_24;
  }
  if (mmcs_http_context_is_complete(a1))
  {
    uint64_t v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"transaction already completed for (%p); http stream event %d",
             a1,
             a3);
      uint64_t v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v22 = v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v8) {
        CFRelease(v8);
      }
    }
    mmcs_http_context_invalidate(a1);
    return;
  }
  if (mmcs_http_context_is_cancelled(a1))
  {
    CFStringRef v14 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"transaction for (%p) cancelled; http stream event %d",
            a1,
            a3);
    uint64_t v12 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v22 = v11;
    goto LABEL_24;
  }
  if (*(void *)(a2 + 16) != a1)
  {
    uint64_t v15 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      return;
    }
    CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Callback for unknown http context %p; Expected %p",
            a1,
            *(void *)(a2 + 16));
    uint64_t v12 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v22 = v11;
    goto LABEL_24;
  }
  switch((int)a3)
  {
    case 1:
      mmcs_put_container_will_begin_streaming((uint64_t)v3);
      break;
    case 2:
      mmcs_put_container_write_container_data(v3, a1);
      break;
    case 3:
      long long v18 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"http context (%p) for put container (%p) had an error", a1, v3);
        uint64_t v12 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          goto LABEL_26;
        }
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v22 = v11;
        goto LABEL_24;
      }
      break;
    case 4:
      return;
    default:
      int v19 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"write stream got unknown type %d", a3);
        uint64_t v20 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_26;
        }
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v22 = v11;
        uint64_t v16 = v20;
        os_log_type_t v17 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_25;
      }
      break;
  }
}

void mmcs_put_container_will_reset_request_body_stream(uint64_t a1, uint64_t a2)
{
}

void mmcs_put_container_will_retry_after_background_error(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFStringRef v5 = *(void **)(a2 + 64);
  uint64_t v6 = v5[11];
  uint64_t v7 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"putContainer %p remembering error %@ for container '%s'", v5, a3, **(void **)(v6 + 8));
    uint64_t v9 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v11 = v8;
      _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v8) {
      CFRelease(v8);
    }
  }
  mmcs_container_set_error(v5, a3);
  mmcs_container_remember_error((uint64_t)v5, a2);
  mmcs_container_reset_error_for_retry((uint64_t)v5);
}

void mmcs_put_container_put_complete_done(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 88) + 8);
  if (v1) {
    mmcs_storage_container_cleanup_instances(v1);
  }
}

BOOL mmcs_put_container_has_storage_container_key(uint64_t a1, const char *a2)
{
  return mmcs_storage_container_has_storage_key(*(const char ***)(*(void *)(a1 + 88) + 8), a2);
}

BOOL mmcs_put_container_needs_put_complete(uint64_t a1, int a2)
{
  BOOL result = 0;
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (v4)
    {
      if (*(unsigned char *)(v4 + 33)) {
        return 0;
      }
      else {
        return a2 || *(unsigned char *)(v4 + 32) != 0;
      }
    }
  }
  return result;
}

CFIndex *mmcs_put_container_create_method_completion_info(void *a1, uint64_t a2, int a3)
{
  uint64_t v3 = 0;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    uint64_t v6 = a1[11];
    if (v6)
    {
      CFStringRef v8 = (__CFError *)a1[5];
      uint64_t v9 = *(__CFHTTPMessage **)(*(void *)(a1[2] + 24) + 16);
      uint64_t v10 = *(void *)(a2 + 16);
      uint64_t v11 = *(void *)(v6 + 8);
      if (v11) {
        uint64_t v12 = *(const char **)(v11 + 16);
      }
      else {
        uint64_t v12 = 0;
      }
      unsigned int reporting_level = mmcs_request_get_reporting_level(**(void **)v6);
      MethodCompletionInfo = (CFIndex *)Create_MethodCompletionInfo(v8, v9, v10, v12, reporting_level, 1, a3);
      uint64_t v3 = MethodCompletionInfo;
      if (MethodCompletionInfo)
      {
        uint64_t v15 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
        if ((*((_DWORD *)MethodCompletionInfo + 8) - 200) <= 0x63)
        {
          uint64_t v16 = *(void *)(v6 + 8);
          if (!v16 || !*(void *)(v16 + 8))
          {
            os_log_type_t v17 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v18 = CFStringCreateWithFormat(*v15, 0, @"the put container received a successful http response status, but there is no md5 computed on the client");
              int v19 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                CFStringRef v39 = v18;
                _os_log_impl(&dword_1DC1CA000, v19, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v18) {
                CFRelease(v18);
              }
            }
          }
        }
        uint64_t v20 = *(void *)(v6 + 8);
        if (v20)
        {
          CFDataRef v21 = *(const __CFData **)(v20 + 8);
          if (v21)
          {
            *((_DWORD *)v3 + 24) = 1;
            ProtobufCBinaryData_SetData(v3 + 13, v21);
          }
        }
        uint64_t v22 = *(void *)(a2 + 16);
        unsigned int v23 = mmcs_request_get_reporting_level(**(void **)v6);
        vendor_http_stats = mmcs_report_create_vendor_http_stats(v22, 1, v23);
        CFStringRef v25 = (uint64_t **)a1[11];
        CFAllocatorRef v26 = *v15;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(*v15, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        unsigned int v28 = mmcs_request_get_reporting_level(**v25);
        mmcs_put_req_copy_client_stats(**v25, Mutable, v28);
        if (Mutable
          && mmcs_report_property_for_config_key(@"client.kpis", @"cachingServer.bytes", 1, v28))
        {
          if (mmcs_transaction_is_proxy(a2))
          {
            CFDictionaryAddValue(Mutable, @"cachingServer.used", @"true");
            uint64_t bytes_from_caching_server = mmcs_transaction_get_bytes_from_caching_server(a2);
            if (bytes_from_caching_server)
            {
              uint64_t v30 = bytes_from_caching_server;
              CFStringRef v31 = CFStringCreateWithFormat(v26, 0, @"%llu", bytes_from_caching_server);
              CFDictionaryAddValue(Mutable, @"cachingServer.bytes", v31);
              if (v31) {
                CFRelease(v31);
              }
              if (gMMCS_DebugLevel >= 5)
              {
                uint64_t v32 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
                {
                  CFStringRef v33 = CFStringCreateWithFormat(v26, 0, @"proxy put got %llu from caching server", v30);
                  uint64_t v34 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)long long buf = 138543362;
                    CFStringRef v39 = v33;
                    _os_log_impl(&dword_1DC1CA000, v34, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                  }
                  if (v33) {
                    CFRelease(v33);
                  }
                }
              }
            }
          }
          else
          {
            CFDictionaryAddValue(Mutable, @"cachingServer.used", @"false");
          }
        }
        CFIndex Count = CFDictionaryGetCount(Mutable);
        if (Count) {
          CFDictionaryRef v36 = Mutable;
        }
        else {
          CFDictionaryRef v36 = 0;
        }
        if (Mutable && !Count)
        {
          CFRelease(Mutable);
          CFDictionaryRef v36 = 0;
        }
        MethodCompletionInfo_SetReportingProperties(v3, vendor_http_stats, v36);
        if (vendor_http_stats) {
          CFRelease(vendor_http_stats);
        }
        if (v36) {
          CFRelease(v36);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t mmcs_put_container_add_method_completion_info(void *a1, uint64_t a2)
{
  method_completion_info = mmcs_put_container_create_method_completion_info(a1, a2, 1);
  return mmcs_transaction_add_method_completion_info(a2, method_completion_info);
}

void mmcs_put_container_chunk_reference_was_put(uint64_t a1, uint64_t a2)
{
}

void mmcs_put_container_chunk_reference_was_read(uint64_t **a1, uint64_t a2, void *a3, uint64_t a4)
{
  if (mmcs_put_state_put_container_did_reserve_chunk_reference(*a1[11], a1, a3))
  {
    mmcs_chunk_reference_was_read((uint64_t)a3, a2, a4);
  }
}

int64x2_t mmcs_put_container_append_description(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 >= 10 && *(_DWORD *)(v2[2] + 48) == 2 && ((uint64_t v4 = v2[3]) == 0 || *(_DWORD *)(v4 + 48) == 2))
  {
    *(void *)(a1 + 40) = v3 + 1;
  }
  else if (mmcs_container_request_enqueued_or_inflight(*(void *)a1))
  {
    long long v6 = *(_OWORD *)(a1 + 16);
    long long v7 = *(_OWORD *)a1;
    long long v8 = v6;
    int64x2_t v9 = *(int64x2_t *)(a1 + 32);
    *((void *)&v8 + 1) = *((void *)&v6 + 1) + 1;
    mmcs_op_requestor_context_indent(a1);
    CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @"<container %p> %s\n", v2, **(void **)(v2[11] + 8), v7, v8);
    *(void *)&long long v7 = v2[2];
    mmcs_transaction_append_description((uint64_t)&v7);
    if (v2[3])
    {
      *(void *)&long long v7 = v2[3];
      mmcs_transaction_append_description((uint64_t)&v7);
    }
    int64x2_t result = vaddq_s64(*(int64x2_t *)(a1 + 32), v9);
    *(int64x2_t *)(a1 + 32) = result;
  }
  return result;
}

CFStringRef mmcs_put_container_copy_simple_description(uint64_t a1)
{
  if (a1 && (v1 = *(void *)(a1 + 88)) != 0 && (v2 = *(uint64_t **)(v1 + 8)) != 0 && (uint64_t v3 = *v2) != 0) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"PutContainer '%s'", v3);
  }
  else {
    return @"PutContainerUnKnOwN";
  }
}

uint64_t mmcs_put_container_will_begin_streaming(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 88);
  uint64_t v2 = (__CFData *)v1[5];
  if (v2) {
    CFDataSetLength(v2, 0);
  }
  v1[6] = 0;
  uint64_t v3 = v1[7];
  return mmcs_storage_container_stream_reset(v3);
}

void mmcs_put_container_write_container_data(void *a1, uint64_t a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a1[11];
  CFTypeRef cf = 0;
  char v49 = 0;
  if (*(void *)(v4 + 40)
    || (CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
        CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0x8000),
        (*(void *)(v4 + 40) = Mutable) != 0))
  {
    if (mmcs_http_request_body_can_accept_data(a2))
    {
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      while (1)
      {
        unint64_t Length = CFDataGetLength(*(CFDataRef *)(v4 + 40));
        char v8 = Length;
        if (Length > 0x8000)
        {
          unsigned int v23 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            char v48 = v8;
            CFStringRef v29 = CFStringCreateWithFormat(v5, 0, @"write stream data buffer larger (%d) than fixed buffer size (%d) ");
            uint64_t v30 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v52 = v29;
              _os_log_impl(&dword_1DC1CA000, v30, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v29) {
              CFRelease(v29);
            }
          }
          CFStringRef v31 = @"data buffer larger than fixed buffer size";
          goto LABEL_37;
        }
        if (Length != 0x8000
          && !mmcs_storage_container_stream_read(*(uint64_t **)(v4 + 56), *(CFDataRef *)(v4 + 40), 0x8000 - Length, (CFErrorRef *)&cf, &v49))
        {
          if (!cf)
          {
            uint64_t v40 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
            {
              CFStringRef v41 = CFStringCreateWithFormat(v5, 0, @"mmcs_storage_container_stream_read failed with NULL error ");
              uint64_t v42 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 138543362;
                CFStringRef v52 = v41;
                _os_log_impl(&dword_1DC1CA000, v42, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
              }
              if (v41) {
                CFRelease(v41);
              }
            }
            CFStringRef v31 = @"mmcs_storage_container_stream_read failed with NULL error";
LABEL_37:
            CFIndex v32 = 1;
LABEL_49:
            CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", v32, v31, v24, v25, v26, v27, v28, v48);
            goto LABEL_50;
          }
          goto LABEL_51;
        }
        uint64_t v9 = CFDataGetLength(*(CFDataRef *)(v4 + 40)) - *(void *)(v4 + 48);
        if (v9 < 1) {
          break;
        }
        MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(v4 + 40));
        size_t v11 = mmcs_http_write_request_body(a2, &MutableBytePtr[*(void *)(v4 + 48)], v9);
        if (gMMCS_DebugLevel >= 5)
        {
          uint64_t v12 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            char v48 = a2;
            CFStringRef v13 = CFStringCreateWithFormat(v5, 0, @"context (%p) wrote %d bytes");
            CFStringRef v14 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v52 = v13;
              _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v13) {
              CFRelease(v13);
            }
          }
        }
        if ((v11 & 0x8000000000000000) != 0)
        {
          uint64_t v34 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v35 = CFStringCreateWithFormat(v5, 0, @"mmcs_http_write_request_body() failed ");
            CFDictionaryRef v36 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v52 = v35;
              _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v35) {
              CFRelease(v35);
            }
          }
          CFStringRef v31 = @"mmcs_http_write_request_body failed";
          CFIndex v32 = 38;
          goto LABEL_49;
        }
        CFDataRef v15 = *(const __CFData **)(v4 + 40);
        unint64_t v16 = *(void *)(v4 + 48) + v11;
        *(void *)(v4 + 48) = v16;
        if (v16 >= CFDataGetLength(v15))
        {
          CFDataSetLength(*(CFMutableDataRef *)(v4 + 40), 0);
          *(void *)(v4 + 48) = 0;
        }
        if (v11 != v9) {
          goto LABEL_77;
        }
        if (!mmcs_http_request_body_can_accept_data(a2)) {
          goto LABEL_22;
        }
      }
      if (!v49)
      {
        CFTypeID v43 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
          goto LABEL_68;
        }
        CFStringRef v18 = CFStringCreateWithFormat(v5, 0, @"attempt to write but no data available");
        CFNumberRef v44 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v52 = v18;
          uint64_t v20 = v44;
          os_log_type_t v21 = OS_LOG_TYPE_ERROR;
          goto LABEL_27;
        }
        goto LABEL_28;
      }
      if (gMMCS_DebugLevel < 5) {
        goto LABEL_68;
      }
      CFStringRef v33 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_68;
      }
      CFStringRef v18 = CFStringCreateWithFormat(v5, 0, @"%p there is nothing left in the buffer and the container is empty", a2);
      int v19 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_28;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v52 = v18;
    }
    else
    {
      uint64_t v9 = 0;
LABEL_22:
      if (gMMCS_DebugLevel < 5) {
        goto LABEL_68;
      }
      os_log_type_t v17 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_68;
      }
      CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"HTTP request body says it is full");
      int v19 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
LABEL_28:
        if (v18) {
          CFRelease(v18);
        }
LABEL_68:
        if (v9 <= 0 && v49)
        {
          if (gMMCS_DebugLevel >= 4)
          {
            CFNumberRef v45 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
            {
              CFStringRef v46 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"closing http request body for context (%p): all done", a2);
              uint64_t v47 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 138543362;
                CFStringRef v52 = v46;
                _os_log_impl(&dword_1DC1CA000, v47, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
              }
              if (v46) {
                CFRelease(v46);
              }
            }
          }
          mmcs_http_set_request_body_done(a2);
        }
        goto LABEL_77;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v52 = v18;
    }
    uint64_t v20 = v19;
    os_log_type_t v21 = OS_LOG_TYPE_DEBUG;
LABEL_27:
    _os_log_impl(&dword_1DC1CA000, v20, v21, "%{public}@", buf, 0xCu);
    goto LABEL_28;
  }
  CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, @"putContainer->chunkData malloc");
LABEL_50:
  CFTypeRef cf = error;
LABEL_51:
  if (gMMCS_DebugLevel >= 4)
  {
    CFTypeID v37 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v38 = CFStringCreateWithFormat(v5, 0, @"closing http request body for context (%p) had an error %@.", a2, cf);
      CFStringRef v39 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v52 = v38;
        _os_log_impl(&dword_1DC1CA000, v39, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v38) {
        CFRelease(v38);
      }
    }
  }
  mmcs_put_container_should_stop_with_error(a1, (void *)cf);
LABEL_77:
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t mmcs_put_req_context_get_chunk_references(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 304) + 64);
}

void mmcs_put_req_copy_client_stats(uint64_t a1, __CFDictionary *a2, unsigned int a3)
{
  int v6 = mmcs_report_property_for_config_key(@"client.kpis", @"chunking.time.millis", 1, a3);
  int v7 = mmcs_report_property_for_config_key(@"client.kpis", @"authorizePut.millis", 1, a3);
  if (a2 && v6 | v7)
  {
    int v8 = v7;
    if (a1 && v6)
    {
      uint64_t v9 = *(void *)(a1 + 304);
      if (*(void *)(v9 + 144))
      {
        unint64_t v10 = 0;
        double v11 = 0.0;
        uint64_t v12 = 152;
        do
        {
          double v11 = v11 + mmcs_item_chunking_elapsed_seconds(v9 + v12);
          ++v10;
          uint64_t v9 = *(void *)(a1 + 304);
          v12 += 416;
        }
        while (v10 < *(void *)(v9 + 144));
      }
      else
      {
        double v11 = 0.0;
      }
      CFStringRef MillisStringFromAbsoluteTime = createMillisStringFromAbsoluteTime(v11);
      if (MillisStringFromAbsoluteTime)
      {
        CFStringRef v14 = MillisStringFromAbsoluteTime;
        CFDictionaryAddValue(a2, @"chunking.time.millis", MillisStringFromAbsoluteTime);
        CFRelease(v14);
      }
    }
    else if (!a1)
    {
      return;
    }
    uint64_t v15 = *(void *)(*(void *)(a1 + 304) + 96);
    if (v15) {
      BOOL v16 = v8 == 0;
    }
    else {
      BOOL v16 = 1;
    }
    if (!v16)
    {
      double v17 = mmcs_http_context_elapsed_seconds(v15);
      CFStringRef v18 = createMillisStringFromAbsoluteTime(v17);
      if (v18)
      {
        CFStringRef v19 = v18;
        CFDictionaryAddValue(a2, @"authorizePut.millis", v18);
        CFRelease(v19);
      }
    }
  }
}

uint64_t mmcs_put_req_context_create(void *a1, uint64_t a2, uint64_t a3, void *a4, const void *a5, const char *a6, CFTypeRef a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, CFErrorRef *a15)
{
  uint64_t v22 = a15;
  uint64_t v23 = a9;
  uint64_t v168 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  if (a15) {
    *a15 = 0;
  }
  CFTypeRef v139 = 0;
  uint64_t v24 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v25 = a4;
    uint64_t v26 = a8;
    CFTypeRef v27 = a7;
    LOBYTE(v127) = a9;
    CFStringRef v28 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_put_items called for %llu items");
    CFStringRef v29 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v28;
      _os_log_impl(&dword_1DC1CA000, v29, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    a7 = v27;
    a8 = v26;
    a4 = v25;
    uint64_t v22 = a15;
    if (v28) {
      CFRelease(v28);
    }
  }
  if (!mmcs_put_request_alloc(&v139, a8, a9) || !v139)
  {
    if (!v22) {
      return 0xFFFFFFFFLL;
    }
    error_with_underlying_CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, @"Cannot allocate put request", v30, v31, v32, v33, v34, v127);
LABEL_27:
    CFErrorRef *v22 = error_with_underlying_error;
    return 0xFFFFFFFFLL;
  }
  CFErrorRef v138 = 0;
  if (!_mmcs_request_init((uint64_t)v139, a2, a3, a4, a5, a6, a14, &v138))
  {
    if (v139) {
      C3BaseRelease(v139);
    }
    if (!v22) {
      return 0xFFFFFFFFLL;
    }
    error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 36, v138, @"Cannot initialize underlying mmcs_request", v35, v36, v37, v38, v127);
    goto LABEL_27;
  }
  kdebug_trace();
  CFAllocatorRef v39 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &itemsBySignatureReferenceDictionaryKeyCallbacks, MEMORY[0x1E4F1D540]);
  *(void *)(*((void *)v139 + 38) + 48) = Mutable;
  CFMutableSetRef v41 = CFSetCreateMutable(v39, 0, &itemSignatureReferenceEqualitySetCallbacks);
  uint64_t v42 = v139;
  *(void *)(*((void *)v139 + 38) + 56) = v41;
  *(void *)(v42[38] + 72) = 0;
  CFMutableSetRef v43 = CFSetCreateMutable(v39, 0, &chunkReferenceSignatureEqualitySetCallbacks);
  *(void *)(*((void *)v139 + 38) + 64) = v43;
  if (*(unsigned char *)(a2 + 175))
  {
    if (a8) {
      CFNumberRef v44 = @"putSection";
    }
    else {
      CFNumberRef v44 = @"put";
    }
    CFNumberRef v45 = mmcs_metrics_request_create(v44);
    *((void *)v139 + 23) = v45;
  }
  CFMutableSetRef v46 = CFSetCreateMutable(v39, 0, 0);
  uint64_t v47 = v139;
  *(void *)(*((void *)v139 + 38) + 128) = v46;
  *(void *)(v47[38] + 80) = 0;
  *(void *)(v47[38] + 104) = 0;
  *(void *)(v47[38] + 112) = 0;
  if (a4)
  {
    CFTypeRef v48 = a7;
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionItemOptions");
    if (Value)
    {
      CFTypeID TypeID = CFArrayGetTypeID();
      if (TypeID == CFGetTypeID(Value))
      {
        if (CFArrayGetCount(Value) != a9)
        {
          char Count = CFArrayGetCount(Value);
          CFStringRef v56 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Item options array had %d elements but request had %d elements", v51, v52, v53, v54, v55, Count);
LABEL_82:
          CFSetRef v85 = 0;
          goto LABEL_83;
        }
      }
      else
      {
        CFArrayRef Value = 0;
      }
    }
    char BOOLean_from_cfdictionary_object_for_key = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a4, @"kMMCSRequestOptionUseFORD", 0);
    uint64_t v58 = CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestVendorHintValue");
    if (v58)
    {
      uint64_t v59 = v58;
      CFTypeID v60 = CFStringGetTypeID();
      if (v60 == CFGetTypeID(v59))
      {
        CFRetain(v59);
        *(void *)(*((void *)v139 + 38) + 24) = v59;
      }
    }
    uint64_t v61 = CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestContainerSizeHintValue");
    if (v61)
    {
      uint64_t v62 = v61;
      CFTypeID v63 = CFStringGetTypeID();
      if (v63 == CFGetTypeID(v62))
      {
        CFRetain(v62);
        *(void *)(*((void *)v139 + 38) + 32) = v62;
      }
    }
    uint64_t v64 = CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionClientLocation");
    if (v64)
    {
      uint64_t v65 = v64;
      CFTypeID v66 = CFStringGetTypeID();
      if (v66 == CFGetTypeID(v65))
      {
        CFRetain(v65);
        *(void *)(*((void *)v139 + 38) + 40) = v65;
      }
    }
    CFBooleanRef v67 = CFDictionaryGetValue((CFDictionaryRef)a4, @"kMMCSRequestOptionReturnOpaqueCloneContext");
    if (v67)
    {
      CFBooleanRef v68 = v67;
      CFTypeID v69 = CFDataGetTypeID();
      if (v69 == CFGetTypeID(v68))
      {
        CFRetain(v68);
        *(void *)(*((void *)v139 + 38) + 120) = v68;
      }
    }
    a7 = v48;
  }
  else
  {
    CFArrayRef Value = 0;
    char BOOLean_from_cfdictionary_object_for_key = 0;
  }
  CFSetCallBacks callBacks = *(CFSetCallBacks *)byte_1F363C9C0;
  CFMutableSetRef v70 = CFSetCreateMutable(v39, 0, &callBacks);
  **((void **)v139 + 38) = v70;
  CFStringRef v76 = v139;
  *(void *)(*((void *)v139 + 38) + 8) = 0;
  CFTypeID v77 = (void *)v76[38];
  if (!v77[6] || !v77[7] || !v77[8] || !v76[21] || !v77[16] || !*v77)
  {
    CFStringRef v56 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Cannot allocate put request data structures", v71, v72, v73, v74, v75, v127);
    goto LABEL_82;
  }
  uint64_t v78 = *(void *)(a2 + 56);
  *(void *)long long buf = v76;
  *(void *)&uint8_t buf[8] = C3BaseRetain;
  *(void *)&long long v143 = C3BaseRelease;
  *((void *)&v143 + 1) = _mmcs_put_req_context_progress_timer_fired;
  if (!mmcs_perform_target_create_timer(v78, (uint64_t)(v77 + 11), buf, v71))
  {
    CFSetRef v85 = 0;
    goto LABEL_97;
  }
  CFMutableSetRef v79 = CFSetCreateMutable(v39, 0, &itemItemIDEqualitySetCallbacks);
  CFSetRef v85 = v79;
  if (!v79)
  {
    CFStringRef v121 = @"Cannot allocate itemSet";
    CFIndex v122 = 37;
LABEL_101:
    CFStringRef v56 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v122, v121, v80, v81, v82, v83, v84, v127);
LABEL_83:
    CFErrorRef v138 = v56;
    if (!v56) {
      goto LABEL_86;
    }
    goto LABEL_84;
  }
  if (!a9)
  {
LABEL_100:
    CFStringRef v121 = @"No items added to put request";
    CFIndex v122 = 30;
    goto LABEL_101;
  }
  uint64_t v86 = 0;
  CFIndex v87 = 0;
  unsigned int v131 = a8;
  CFSetRef v129 = v79;
  CFTypeRef cf = a7;
  while (1)
  {
    long long v166 = 0u;
    long long v167 = 0u;
    long long v164 = 0u;
    long long v165 = 0u;
    long long v162 = 0u;
    long long v163 = 0u;
    long long v160 = 0u;
    long long v161 = 0u;
    long long v158 = 0u;
    long long v159 = 0u;
    long long v156 = 0u;
    long long v157 = 0u;
    long long v154 = 0u;
    long long v155 = 0u;
    long long v152 = 0u;
    long long v153 = 0u;
    long long v150 = 0u;
    long long v151 = 0u;
    long long v148 = 0u;
    long long v149 = 0u;
    long long v146 = 0u;
    long long v147 = 0u;
    long long v144 = 0u;
    long long v145 = 0u;
    *(_OWORD *)long long buf = 0u;
    long long v143 = 0u;
    *((void *)&v144 + 1) = *(void *)(a10 + 8 * v87);
    if (!CFSetContainsValue(v85, buf)) {
      break;
    }
    uint64_t v89 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v133 = v86;
      uint64_t v90 = a8;
      CFTypeRef v91 = a7;
      uint64_t v127 = *(void *)(a10 + 8 * v87);
      CFStringRef v92 = CFStringCreateWithFormat(v39, 0, @"put request contained duplicate item IDs. Ignoring extra references to itemID %lld");
      CFStringRef v93 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)char v140 = 138543362;
        CFStringRef v141 = v92;
        _os_log_impl(&dword_1DC1CA000, v93, OS_LOG_TYPE_DEFAULT, "%{public}@", v140, 0xCu);
      }
      a7 = v91;
      if (v92) {
        CFRelease(v92);
      }
      a8 = v90;
      uint64_t v23 = a9;
      uint64_t v86 = v133;
    }
LABEL_76:
    if (v23 == ++v87)
    {
      if (!v86) {
        goto LABEL_100;
      }
      CFIndex v117 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)long long buf = v139;
        CFDictionaryApplyFunction(*(CFDictionaryRef *)(*((void *)v139 + 38) + 48), (CFDictionaryApplierFunction)mmcs_put_req_context_items_by_signature_description, buf);
      }
      *(void *)(*((void *)v139 + 38) + 144) = (int)v86;
      CFRelease(v85);
      uint64_t result = 0;
      *a1 = v139;
      return result;
    }
  }
  if (a12) {
    uint64_t v94 = *(const char **)(a12 + 8 * v87);
  }
  else {
    uint64_t v94 = 0;
  }
  uint64_t v95 = *((void *)v139 + 38);
  key = (void *)(v95 + 416 * (int)v86 + 152);
  if (mmcs_item_init((uint64_t)key, *(void *)(a10 + 8 * v87), *(unsigned __int8 **)(a11 + 8 * v87), v94, *(unsigned int *)(a13 + 4 * v87), 1, &v138, v88))
  {
    uint64_t v101 = v95 + 416 * (int)v86;
    *(unsigned char *)(v101 + 256) = BOOLean_from_cfdictionary_object_for_key;
    *(void *)(v101 + 248) = 0;
    a7 = cf;
    a8 = v131;
    uint64_t v102 = key;
    if (v131)
    {
      if (v23 != 1) {
        mmcs_put_req_context_create_cold_1();
      }
      if (cf)
      {
        mmcs_item_set_section_identifier((uint64_t)key, cf);
        uint64_t v102 = key;
      }
      if (!a4)
      {
        CFSetRef v85 = v129;
        if (v138) {
          goto LABEL_97;
        }
        CFStringRef v126 = @"Section Upload Missing Request Options";
        goto LABEL_115;
      }
    }
    int v134 = v86;
    if (Value)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(Value, v87);
      CFTypeID v104 = CFDictionaryGetTypeID();
      if (v104 != CFGetTypeID(ValueAtIndex))
      {
        CFSetRef v85 = v129;
        if (v22) {
          CFErrorRef *v22 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Invalid item option type: Expected dictionary, Got %@", v105, v106, v107, v108, v109, (char)ValueAtIndex);
        }
        goto LABEL_97;
      }
      uint64_t v102 = key;
      a8 = v131;
      if (!mmcs_put_req_context_setup_item_with_options((uint64_t)key, v131, (CFDictionaryRef)ValueAtIndex, (uint64_t)&v138))
      {
        CFSetRef v85 = v129;
        if (v138) {
          goto LABEL_97;
        }
        CFStringRef v126 = @"Failed to set item options";
        goto LABEL_115;
      }
    }
    CFStringRef v110 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(*((void *)v139 + 38) + 48), v102);
    if (!v110)
    {
      CFMutableArrayRef v111 = CFArrayCreateMutable(v39, 0, &itemArrayCallbacks);
      if (!v111)
      {
        CFErrorRef v138 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Cannot allocate itemsWithSameSignature", v112, v113, v114, v115, v116, v127);
        CFSetRef v85 = v129;
        goto LABEL_97;
      }
      CFStringRef v110 = v111;
      uint64_t v102 = key;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*((void *)v139 + 38) + 48), key, v111);
      CFSetAddValue(*(CFMutableSetRef *)(*((void *)v139 + 38) + 56), key);
      CFRelease(v110);
    }
    CFArrayAppendValue((CFMutableArrayRef)v110, v102);
    uint64_t v86 = (v134 + 1);
    CFSetRef v85 = v129;
    goto LABEL_76;
  }
  BOOL v123 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v127 = *(void *)(a10 + 8 * v87);
    CFStringRef v124 = CFStringCreateWithFormat(v39, 0, @"couldn't init item %lld. error: %@");
    int v125 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)char v140 = 138543362;
      CFStringRef v141 = v124;
      _os_log_impl(&dword_1DC1CA000, v125, OS_LOG_TYPE_DEFAULT, "%{public}@", v140, 0xCu);
    }
    if (v124) {
      CFRelease(v124);
    }
  }
  if (!v138)
  {
    CFStringRef v126 = @"Cannot init item";
LABEL_115:
    CFErrorRef v138 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, v126, v96, v97, v98, v99, v100, v127);
  }
LABEL_97:
  CFStringRef v56 = v138;
  if (!v138)
  {
LABEL_86:
    if (v85) {
      goto LABEL_87;
    }
    goto LABEL_88;
  }
LABEL_84:
  if (v22)
  {
    CFErrorRef *v22 = v56;
    goto LABEL_86;
  }
  CFRelease(v56);
  CFErrorRef v138 = 0;
  if (v85) {
LABEL_87:
  }
    CFRelease(v85);
LABEL_88:
  CFTypeRef v119 = v139;
  if (*(void *)(*((void *)v139 + 38) + 88))
  {
    mmcs_perform_timer_invalidate(*(void *)(*((void *)v139 + 38) + 88));
    CFTypeRef v119 = v139;
    uint64_t v120 = *((void *)v139 + 38);
    if (*(void *)(v120 + 88))
    {
      CFRelease(*(CFTypeRef *)(v120 + 88));
      CFTypeRef v119 = v139;
      uint64_t v120 = *((void *)v139 + 38);
    }
    *(void *)(v120 + 88) = 0;
  }
  C3BaseRelease(v119);
  return 0xFFFFFFFFLL;
}

void _mmcs_put_req_context_progress_timer_fired(uint64_t a1, void *a2)
{
  mmcs_put_request_notify_all_items_with_pending_progress(a2);
  uint64_t v3 = *(void *)(a2[38] + 88);
  if (v3)
  {
    CFAbsoluteTimeGetCurrent();
    mmcs_perform_timer_set_next_fire_date(v3);
  }
}

uint64_t mmcs_put_req_context_setup_item_with_options(uint64_t a1, int a2, CFDictionaryRef theDict, uint64_t a4)
{
  uint64_t result = mmcs_wrapping_state_init_with_option_dict(a1 + 64, theDict, @"kMMCSWrappingState", a4);
  if (result)
  {
    CFArrayRef Value = CFDictionaryGetValue(theDict, @"kMMCSMIMEType");
    if (Value)
    {
      uint64_t v9 = Value;
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(v9)) {
        mmcs_item_set_MIME_type(a1, v9);
      }
    }
    if ((**(unsigned char **)a1 & 0x7F) == 4 || (**(unsigned char **)a1 & 8) != 0)
    {
      *(unsigned char *)(a1 + 104) = 1;
      *(void *)(a1 + 96) = mmcs_get_cfindex_from_options(@"kMMCSPaddingPolicy", theDict, 2);
      uint64_t v12 = CFDictionaryGetValue(theDict, @"kMMCSBoundaryKey");
      if (v12)
      {
        CFStringRef v13 = v12;
        CFTypeID v14 = CFDataGetTypeID();
        if (v14 == CFGetTypeID(v13)) {
          mmcs_item_set_boundary_key(a1, v13);
        }
      }
      if (a2)
      {
        uint64_t v15 = CFDictionaryGetValue(theDict, @"kMMCSVerificationKey");
        if (v15)
        {
          BOOL v16 = v15;
          CFTypeID v17 = CFDataGetTypeID();
          if (v17 == CFGetTypeID(v16)) {
            mmcs_item_set_file_verification_key(a1, v16);
          }
        }
      }
    }
    *(unsigned char *)(a1 + 216) = mmcs_get_BOOLean_from_cfdictionary_object_for_key(theDict, @"kMMCSMetadataOnly", *(unsigned __int8 *)(a1 + 216));
    return 1;
  }
  return result;
}

uint64_t mmcs_put_req_context_has_items_to_put(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (!*(void *)(v1 + 144)) {
    return 0;
  }
  unint64_t v3 = 0;
  for (uint64_t i = 152; !mmcs_item_needs_put(v1 + i); i += 416)
  {
    ++v3;
    uint64_t v1 = *(void *)(a1 + 304);
    if (v3 >= *(void *)(v1 + 144)) {
      return 0;
    }
  }
  return 1;
}

void mmcs_put_req_context_init_items(uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 304);
  if (*(void *)(v2 + 144))
  {
    unint64_t v3 = 0;
    uint64_t v4 = 288;
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (1)
    {
      uint64_t v5 = v2 + v4;
      int v6 = (const void *)(v2 + v4 - 136);
      if (v6 == CFSetGetValue(*(CFSetRef *)(v2 + 56), v6)) {
        break;
      }
LABEL_40:
      ++v3;
      uint64_t v2 = *(void *)(a1 + 304);
      v4 += 416;
      if (v3 >= *(void *)(v2 + 144)) {
        goto LABEL_48;
      }
    }
    CFTypeRef v42 = 0;
    uint64_t v7 = *(void *)(a1 + 32);
    if ((CKGetRegisteredFileMetadata() & 1) == 0)
    {
      os_log_type_t v21 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v27 = CFStringCreateWithFormat(alloc, 0, @"no registered file signature for %lld", *(void *)(v5 - 96));
        CFStringRef v28 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v27;
          _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v27) {
          CFRelease(v27);
        }
      }
      CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 27, @"No file signature registered for item %lld", v22, v23, v24, v25, v26, *(void *)(v5 - 96));
      goto LABEL_35;
    }
    if (CKFileDigestResultsHasFileLength())
    {
      uint64_t v8 = CKFileDigestResultsFileLength();
      mmcs_item_set_size(v2 + v4 - 136, v8);
    }
    if (mmcs_item_is_metadata_only(v2 + v4 - 136))
    {
      if ((CKGetRegisteredChunksForItemID() & 1) == 0)
      {
        uint64_t v30 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v36 = CFStringCreateWithFormat(alloc, 0, @"get chunk list failed for item %lld", *(void *)(v5 - 96));
          uint64_t v37 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v36;
            _os_log_impl(&dword_1DC1CA000, v37, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v36) {
            CFRelease(v36);
          }
        }
        CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 27, @"get chunk list failed for item %lld", v31, v32, v33, v34, v35, *(void *)(v5 - 96));
        goto LABEL_35;
      }
      uint64_t v9 = (void *)(v2 + v4);
      *uint64_t v9 = 20000;
      *(v9 - 1) = 0;
      if (!mmcs_put_req_context_init_item_with_chunks(a1, (char **)(v2 + v4 - 136), *(void *)(v2 + v4 - 120), 0x4E20uLL, (CFErrorRef *)&v42))goto LABEL_36; {
      CFDictionaryRef cached_ranged_items = mmcs_engine_get_cached_ranged_items(v7, *(const void **)(v5 - 96));
      }
      *(v9 - 2) = cached_ranged_items;
      if (cached_ranged_items) {
        CFRetain(cached_ranged_items);
      }
    }
    if (CKFileDigestResultsCreate())
    {
      if (CKFileDigestResultsEqual())
      {
LABEL_37:
        if (v42) {
          CFRelease(v42);
        }
        CFTypeRef v42 = 0;
        goto LABEL_40;
      }
      CFStringRef v11 = CFCopyDescription(0);
      CFStringRef v12 = CFCopyDescription(0);
      CFStringRef v13 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v19 = CFStringCreateWithFormat(alloc, 0, @"file signature mismatch for %lld item has %@ != %@ for the chunk store", *(void *)(v5 - 96), v11, v12);
        uint64_t v20 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v19;
          _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v19) {
          CFRelease(v19);
        }
      }
      CFTypeRef v42 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 28, @"The file signature changed: from %@ on the item to %@ registered in the chunk store for item %lld", v14, v15, v16, v17, v18, (char)v11);
      if (v11) {
        CFRelease(v11);
      }
      if (v12) {
        CFRelease(v12);
      }
LABEL_36:
      mmcs_put_item_progress_make_done_error((uint64_t)v42, buf);
      mmcs_put_request_set_progress_and_notify_items_like_item(a1, v6, (long long *)buf);
      goto LABEL_37;
    }
    uint64_t v38 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v39 = CFStringCreateWithFormat(alloc, 0, @"no expectedFileDigestResults for %lld", *(void *)(v5 - 96));
      uint64_t v40 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v39;
        _os_log_impl(&dword_1DC1CA000, v40, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v39) {
        CFRelease(v39);
      }
    }
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, @"no expectedFileDigestResults");
LABEL_35:
    CFTypeRef v42 = error;
    goto LABEL_36;
  }
LABEL_48:
  mmcs_put_req_context_schedule_chunk_jobs(a1);
  if (!mmcs_put_request_has_outstanding_chunk_jobs(a1)) {
    mmcs_put_req_context_chunking_complete(a1);
  }
}

void mmcs_put_req_context_schedule_chunk_jobs(uint64_t a1)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  chunking_activity_marker = mmcs_request_get_chunking_activity_marker(a1);
  os_activity_scope_enter(chunking_activity_marker, &state);
  uint64_t v3 = *(void *)(a1 + 304);
  if (*(void *)(v3 + 8) < *(void *)(v3 + 144))
  {
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v4 = &dword_1DC1CA000;
    while (1)
    {
      if (CFSetGetCount(*(CFSetRef *)v3) > 0) {
        goto LABEL_80;
      }
      uint64_t v5 = *(void *)(a1 + 304);
      uint64_t v6 = *(void *)(v5 + 8);
      uint64_t v7 = (char **)(v5 + 416 * v6 + 152);
      if (CFSetGetValue(*(CFSetRef *)(v5 + 56), v7) == v7) {
        break;
      }
      uint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(v5 + 416 * v6 + 192);
        uint64_t v10 = *(void *)(a1 + 304);
        uint64_t v11 = *(void *)(v10 + 8) + 1;
        CFStringRef v12 = *(void (**)(CFTypeRef))(v10 + 144);
        *(_DWORD *)long long buf = 134218496;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v11;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v88 = v12;
        _os_log_impl(v4, v8, OS_LOG_TYPE_DEFAULT, "Skipping item (%llu) %ld of %ld, duplicate item signature", buf, 0x20u);
      }
LABEL_72:
      ++*(void *)(*(void *)(a1 + 304) + 8);
      uint64_t v3 = *(void *)(a1 + 304);
      if (*(void *)(v3 + 8) >= *(void *)(v3 + 144)) {
        goto LABEL_80;
      }
    }
    CFTypeRef cf = 0;
    v86.opaque[0] = 0;
    CFStringRef v13 = (uint64_t *)(v5 + 416 * v6 + 192);
    if (CKGetRegisteredFileMetadata())
    {
      uint64_t v14 = (const void *)CKFileDigestResultsFileVerificationKey();
      mmcs_item_set_file_verification_key((uint64_t)v7, v14);
      if (CKFileDigestResultsCreate())
      {
        if (CKFileDigestResultsEqual()) {
          goto LABEL_34;
        }
        uint64_t v15 = v4;
        CFStringRef v16 = CFCopyDescription(cf);
        CFStringRef v17 = CFCopyDescription((CFTypeRef)v86.opaque[0]);
        uint64_t v18 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v24 = CFStringCreateWithFormat(alloc, 0, @"file signature mismatch for %lld item has %@ != %@ for the chunk store", *v13, v16, v17);
          uint64_t v25 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v24;
            _os_log_impl(v15, v25, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v24) {
            CFRelease(v24);
          }
        }
        CFErrorRef v26 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 28, @"The file signature changed: from %@ on the item to %@ registered in the chunk store for item %lld", v19, v20, v21, v22, v23, (char)v16);
        if (v16) {
          CFRelease(v16);
        }
        if (v17) {
          CFRelease(v17);
        }
        uint64_t v4 = v15;
LABEL_33:
        mmcs_put_item_progress_make_done_error((uint64_t)v26, buf);
        mmcs_put_request_set_progress_and_notify_items_like_item(a1, v7, (long long *)buf);
LABEL_34:
        if (cf) {
          C3BaseRelease(cf);
        }
        CFTypeRef cf = 0;
        if (v86.opaque[0]) {
          C3BaseRelease((CFTypeRef)v86.opaque[0]);
        }
        if (mmcs_item_is_metadata_only((uint64_t)v7)) {
          goto LABEL_72;
        }
        CFStringRef v39 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v40 = *v13;
          uint64_t v41 = *(void *)(a1 + 304);
          uint64_t v42 = *(void *)(v41 + 8) + 1;
          CFMutableSetRef v43 = *(void (**)(CFTypeRef))(v41 + 144);
          *(_DWORD *)long long buf = 134218496;
          *(void *)&uint8_t buf[4] = v40;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v42;
          *(_WORD *)&buf[22] = 2048;
          uint64_t v88 = v43;
          _os_log_impl(v4, v39, OS_LOG_TYPE_DEFAULT, "Chunking item (%llu) %ld of %ld", buf, 0x20u);
        }
        uint64_t v44 = mmcs_request_get_chunking_activity_marker(a1);
        CFNumberRef v45 = v4;
        CFMutableSetRef v46 = _os_activity_create(v4, "mmcs-chunk-job", v44, OS_ACTIVITY_FLAG_DEFAULT);
        v86.opaque[0] = 0;
        v86.opaque[1] = 0;
        os_activity_scope_enter(v46, &v86);
        CFSetRef v85 = 0;
        uint64_t v84 = 0;
        uint64_t v47 = *(void *)(a1 + 32);
        CFTypeRef v48 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
        {
          char v49 = mmcs_file_signature_to_hexstring(*v7);
          uint64_t v50 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_INFO))
          {
            uint64_t v51 = *v13;
            *(_DWORD *)long long buf = 134218242;
            *(void *)&uint8_t buf[4] = v51;
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v49;
            _os_log_impl(v45, v50, OS_LOG_TYPE_INFO, "Chunking started for itemId %lld with signature %{public}s", buf, 0x16u);
          }
          if (v49) {
            free(v49);
          }
        }
        uint64_t v52 = mmcs_engine_owner(v47);
        uint64_t requestor = mmcs_request_get_requestor(a1);
        if (mmcs_engine_get_item_reader_writer_for_item_callback(v47, v52, requestor, *v13, &v84, (CFTypeRef *)&v85)&& MMCSItemReaderWriterOpen((uint64_t)v84, (CFTypeRef *)&v85))
        {
          uint64_t v54 = *(void *)(v84[3] + 16);
          uint64_t v55 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v78 = *v13;
            CFStringRef v56 = CFStringCreateWithFormat(alloc, 0, @"opened itemid %lld ");
            uint64_t v57 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v56;
              _os_log_impl(v45, v57, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v56) {
              CFRelease(v56);
            }
          }
          int is_encrypted = mmcs_item_is_encrypted(v7);
          CFTypeRef cf = (CFTypeRef)2;
          long long v82 = 0u;
          long long v83 = 0u;
          mmcs_put_request_set_progress_and_notify_items_like_item(a1, v7, (long long *)&cf);
          if (*(unsigned char *)(a1 + 144))
          {
            uint64_t v59 = (__CFError *)CFRetain(*(CFTypeRef *)(a1 + 152));
          }
          else
          {
            int v68 = mmcs_fixed_chunk_size_for_item_type_hint(v54);
            *(void *)long long buf = 0;
            *(void *)&uint8_t buf[8] = a1;
            *(void *)&uint8_t buf[16] = C3BaseRetain;
            uint64_t v88 = C3BaseRelease;
            uint64_t v89 = 0;
            uint64_t v90 = mmcs_put_req_context_did_chunk_item;
            uint64_t v69 = mmcs_chunk_job_create((long long *)buf, v47, v84, (uint64_t)v7, v68, is_encrypted != 0, v46);
            if (v69)
            {
              uint64_t v75 = (void *)v69;
              CFStringRef v76 = *(__CFArray **)(a1 + 184);
              if (v76)
              {
                CFTypeID v77 = (void *)v75[25];
                if (v77) {
                  mmcs_metrics_request_add_chunking_info(v76, v77);
                }
              }
              CFSetSetValue(**(CFMutableSetRef **)(a1 + 304), v75);
              mmcs_engine_chunk_job_dispatch_async((uint64_t)v75, *(void *)(v47 + 24));
              C3BaseRelease(v75);
              error_with_underlying_CFErrorRef error = 0;
              uint64_t v4 = v45;
              goto LABEL_65;
            }
            uint64_t v59 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"NULL chunk job", v70, v71, v72, v73, v74, v78);
          }
          error_with_underlying_CFErrorRef error = v59;
          uint64_t v4 = v45;
        }
        else
        {
          uint64_t v61 = mmcs_logging_logger_default();
          uint64_t v4 = v45;
          if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v66 = CFStringCreateWithFormat(alloc, 0, @"unable to open itemid %lld %@", *v13, v85);
            CFBooleanRef v67 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v66;
              _os_log_impl(v45, v67, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            }
            if (v66) {
              CFRelease(v66);
            }
          }
          error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 39, v85, @"Unable to open file for item %lld", v62, v63, v64, v65, *v13);
          if (v85) {
            CFRelease(v85);
          }
          CFSetRef v85 = 0;
        }
        mmcs_put_item_progress_make_done_error((uint64_t)error_with_underlying_error, buf);
        mmcs_put_request_set_progress_and_notify_items_like_item(a1, v7, (long long *)buf);
LABEL_65:
        if (v84) {
          C3BaseRelease(v84);
        }
        if (error_with_underlying_error) {
          CFRelease(error_with_underlying_error);
        }
        if (v46) {
          os_release(v46);
        }
        os_activity_scope_leave(&v86);
        goto LABEL_72;
      }
      CFStringRef v36 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        uint64_t v78 = *v13;
        CFStringRef v37 = CFStringCreateWithFormat(alloc, 0, @"no expectedFileDigestResults for %lld");
        uint64_t v38 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v37;
          _os_log_impl(v4, v38, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v37) {
          CFRelease(v37);
        }
      }
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, @"no expectedFileDigestResults");
    }
    else
    {
      CFStringRef v27 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v33 = CFStringCreateWithFormat(alloc, 0, @"no registered file signature for %lld", *v13);
        uint64_t v34 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v33;
          _os_log_impl(v4, v34, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v33) {
          CFRelease(v33);
        }
      }
      CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 27, @"No file signature registered for item %lld", v28, v29, v30, v31, v32, *v13);
    }
    CFErrorRef v26 = error;
    goto LABEL_33;
  }
LABEL_80:
  os_activity_scope_leave(&state);
}

void mmcs_put_req_context_chunking_complete(uint64_t a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  if (!mmcs_put_req_context_has_items_to_put(a1))
  {
    if (*(unsigned char *)(a1 + 144))
    {
      CFErrorRef error = CFRetain(*(CFTypeRef *)(a1 + 152));
    }
    else
    {
      CFErrorRef v26 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v27 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"There were no items that could be put.");
        uint64_t v28 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v27;
          _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v27) {
          CFRelease(v27);
        }
      }
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 17, @"There was an undefined error with chunking the item.");
    }
    goto LABEL_41;
  }
  if (gMMCS_DebugLevel >= 5)
  {
    CFStringRef v2 = CFCopyDescription(*(CFTypeRef *)(*(void *)(a1 + 304) + 64));
    if (gMMCS_DebugLevel >= 5)
    {
      uint64_t v3 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
        char v32 = (char)v2;
        CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"all chunk references for put %@");
        uint64_t v5 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v4;
          _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v4) {
          CFRelease(v4);
        }
      }
    }
    if (v2) {
      CFRelease(v2);
    }
  }
  if (!*(void *)(a1 + 264))
  {
    int v16 = send_request_authorizePut(a1, &cf);
    CFTypeRef v22 = cf;
    if (!v16)
    {
      if (!cf) {
        CFTypeRef cf = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"An unknown error caused the put authorization to fail.", v17, v18, v19, v20, v21, v32);
      }
      mmcs_metrics_request_set_error(*(void *)(a1 + 184), *(const void **)(a1 + 152));
      mmcs_put_request_context_cleanup(a1, (uint64_t)cf);
      uint64_t v23 = mmcs_logging_logger_default();
      XCFPrint(v23, @"AuthorizePutIssue", (void *)cf);
      CFTypeRef v22 = cf;
    }
    goto LABEL_42;
  }
  if (mmcs_server_version_not_a_version(*(void *)(a1 + 120), *(void *)(a1 + 128)))
  {
    uint64_t v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"client failed to provide server proto version for preauthorization data");
      CFStringRef v13 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v12) {
        CFRelease(v12);
      }
    }
    CFStringRef v14 = @"client failed to provide server proto version for preauthorization data";
LABEL_40:
    CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, v14, v7, v8, v9, v10, v11, v32);
LABEL_41:
    CFTypeRef v22 = error;
    CFTypeRef cf = error;
    mmcs_put_request_context_cleanup(a1, (uint64_t)error);
LABEL_42:
    if (!v22) {
      return;
    }
    uint64_t v25 = v22;
    goto LABEL_44;
  }
  CFTypeID v24 = CFGetTypeID(*(CFTypeRef *)(a1 + 264));
  if (v24 != CFDataGetTypeID())
  {
    uint64_t v29 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v30 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"put preauthorization data type not supported.");
      uint64_t v31 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v30;
        _os_log_impl(&dword_1DC1CA000, v31, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v30) {
        CFRelease(v30);
      }
    }
    CFStringRef v14 = @"put preauthorization data type not supported.";
    goto LABEL_40;
  }
  *(void *)long long buf = *(void *)(a1 + 264);
  CFRetain(*(CFTypeRef *)buf);
  mmcs_put_request_process_put_authorization_data(a1, (CFDataRef *)buf);
  uint64_t v25 = *(const void **)buf;
  if (*(void *)buf) {
LABEL_44:
  }
    CFRelease(v25);
}

uint64_t mmcs_put_req_context_init_items_for_section(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  uint64_t v90 = *(void *)(a1 + 304);
  if (*(void *)(v90 + 144) != 1) {
    mmcs_put_req_context_init_items_for_section_cold_1();
  }
  uint64_t v101 = 0;
  CFErrorRef v102 = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &kC3BaseArrayCallBacks);
  uint64_t v8 = CFArrayCreateMutable(v6, 0, &kAssignArrayCallBacks);
  uint64_t v9 = mmcs_logging_logger_default();
  uint64_t v10 = 0;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
    uint64_t v10 = CFStringCreateMutable(v6, 0);
  }
  if (!a2)
  {
    char v32 = 0;
    unsigned int v33 = 0;
    uint64_t v30 = 0;
    goto LABEL_33;
  }
  CFAllocatorRef v85 = v6;
  os_activity_scope_state_s v86 = a4;
  uint64_t v92 = 0;
  int v93 = 0;
  unsigned int v11 = 0;
  uint64_t v12 = 0;
  CFStringRef v13 = 0;
  unsigned int v14 = 0;
  CFTypeRef cf = v8;
  do
  {
    CFStringRef v15 = *(const __CFString **)(a3 + 8 * v12);
    *(void *)long long buf = 0;
    CFTypeRef v100 = 0;
    uint64_t v101 = 0;
    CFStringRef value = 0;
    if (*(unsigned char *)(v90 + 256)) {
      p_CFStringRef value = &value;
    }
    else {
      p_CFStringRef value = 0;
    }
    if (!mmcs_GetSortedRegisteredChunksForItemID(*(void *)(*(void *)(a1 + 32) + 16), v15, (void **)&v101, (uint64_t *)buf, p_value, (uint64_t *)&v100))
    {
      uint64_t v95 = v13;
      uint64_t v53 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 2, @"Unable to get the chunklist for item %lld was it registered and chunked?", v17, v18, v19, v20, v21, (char)v15);
      goto LABEL_70;
    }
    unsigned int v96 = v14;
    unsigned int v14 = *(_DWORD *)buf;
    int v22 = CKRegisteredChunkSize();
    int v23 = v22;
    if (v10)
    {
      int v91 = v22;
      uint64_t v94 = v13;
      uint64_t v24 = 0;
      if (v14)
      {
        unsigned int v25 = v14;
        do
        {
          v24 += CKRegisteredChunkLength();
          CKRegisteredChunkSize();
          --v25;
        }
        while (v25);
      }
      CFStringAppendFormat(v10, 0, @"\t\t%lld sectionOffset:%llu itemSize:%llu\n", v15, v92, v24);
      v92 += v24;
      uint64_t v8 = cf;
      CFStringRef v13 = v94;
      int v23 = v91;
    }
    CFTypeRef v26 = v100;
    if (!v100)
    {
      if (!mmcs_chunking_profile_create((uint64_t *)&v100, v14, 0))
      {
        uint64_t v95 = v13;
        uint64_t v58 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v98 = 0;
          _os_log_impl(&dword_1DC1CA000, v58, OS_LOG_TYPE_ERROR, "Unable to create chunking profile.", v98, 2u);
        }
        CFStringRef v64 = @"Unable to create chunking profile.";
        goto LABEL_69;
      }
      CFTypeRef v26 = v100;
    }
    CFArrayAppendValue(Mutable, v26);
    CFArrayAppendValue(v8, value);
    CFStringRef value = 0;
    if (v100) {
      CFRelease(v100);
    }
    CFTypeRef v100 = 0;
    size_t v27 = v23 * v14;
    if (!v12)
    {
      CFStringRef v13 = v101;
      int v28 = v23 * v14;
      int v93 = v27;
      goto LABEL_27;
    }
    int v28 = v27 + v11;
    if (v93 - v11 < v27)
    {
      int v93 = 2 * v28;
      uint64_t v29 = (char *)malloc_type_realloc(v13, (2 * v28), 0x5FDFF7D2uLL);
      if (v29)
      {
        CFStringRef v13 = v29;
        goto LABEL_24;
      }
      uint64_t v95 = v13;
      uint64_t v65 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v98 = 0;
        _os_log_impl(&dword_1DC1CA000, v65, OS_LOG_TYPE_ERROR, "Failed to realloc when computing package section chunk list.", v98, 2u);
      }
      CFStringRef v64 = @"Failed to realloc when computing package section chunk list.";
LABEL_69:
      uint64_t v53 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, v64, v59, v60, v61, v62, v63, v84);
LABEL_70:
      CFErrorRef v102 = v53;
      CFAllocatorRef v6 = v85;
      a4 = v86;
      uint64_t v66 = 0;
      goto LABEL_84;
    }
LABEL_24:
    memcpy(&v13[v11], v101, v27);
    v14 += v96;
    if (v101) {
      free(v101);
    }
LABEL_27:
    uint64_t v101 = 0;
    ++v12;
    unsigned int v11 = v28;
  }
  while (v12 != a2);
  if (v14)
  {
    uint64_t v30 = 0;
    unsigned int v97 = v14;
    unsigned int v31 = v14;
    char v32 = v13;
    CFAllocatorRef v6 = v85;
    a4 = v86;
    do
    {
      v30 += CKRegisteredChunkLength();
      CKRegisteredChunkSize();
      --v31;
    }
    while (v31);
    uint64_t v8 = cf;
    unsigned int v33 = v97;
  }
  else
  {
    unsigned int v33 = 0;
    uint64_t v30 = 0;
    char v32 = v13;
    CFAllocatorRef v6 = v85;
    a4 = v86;
  }
LABEL_33:
  *(void *)(v90 + 264) = Mutable;
  *(void *)(v90 + 272) = v8;
  *(void *)(v90 + 280) = v32;
  if (!mmcs_put_req_context_init_item_with_chunks(a1, (char **)(v90 + 152), v30, v33, &v102)) {
    goto LABEL_83;
  }
  if (!mmcs_put_req_context_has_items_to_put(a1))
  {
    uint64_t v54 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v55 = CFStringCreateWithFormat(v6, 0, @"There were no items that could be put.");
      CFStringRef v56 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v55;
        _os_log_impl(&dword_1DC1CA000, v56, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v55) {
        CFRelease(v55);
      }
    }
    goto LABEL_83;
  }
  if (gMMCS_DebugLevel >= 5)
  {
    CFStringRef v39 = CFCopyDescription(*(CFTypeRef *)(*(void *)(a1 + 304) + 64));
    if (gMMCS_DebugLevel >= 5)
    {
      uint64_t v40 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v41 = v10;
        char v84 = (char)v39;
        CFStringRef v42 = CFStringCreateWithFormat(v6, 0, @"all chunk references for put %@");
        CFMutableSetRef v43 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v42;
          _os_log_impl(&dword_1DC1CA000, v43, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        uint64_t v10 = v41;
        if (v42) {
          CFRelease(v42);
        }
      }
    }
    if (v39) {
      CFRelease(v39);
    }
  }
  if (*(void *)(a1 + 264))
  {
    if (mmcs_server_version_not_a_version(*(void *)(a1 + 120), *(void *)(a1 + 128)))
    {
      uint64_t v44 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v50 = CFStringCreateWithFormat(v6, 0, @"client failed to provide server proto version for preauthorization data for section");
        uint64_t v51 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v50;
          _os_log_impl(&dword_1DC1CA000, v51, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v50) {
          CFRelease(v50);
        }
      }
      CFStringRef v52 = @"client failed to provide server proto version for preauthorization data for section";
      goto LABEL_82;
    }
    CFTypeID v67 = CFGetTypeID(*(CFTypeRef *)(a1 + 264));
    if (v67 == CFDataGetTypeID())
    {
      *(void *)long long buf = *(void *)(a1 + 264);
      CFRetain(*(CFTypeRef *)buf);
      mmcs_put_request_process_put_authorization_data(a1, (CFDataRef *)buf);
      if (*(void *)buf) {
        CFRelease(*(CFTypeRef *)buf);
      }
      goto LABEL_74;
    }
    uint64_t v69 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v70 = CFStringCreateWithFormat(v6, 0, @"section-put preauthorization data type not supported.");
      uint64_t v71 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v70;
        _os_log_impl(&dword_1DC1CA000, v71, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v70) {
        CFRelease(v70);
      }
    }
    CFStringRef v52 = @"section-put preauthorization data type not supported.";
LABEL_82:
    CFErrorRef v102 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, v52, v45, v46, v47, v48, v49, v84);
    mmcs_put_request_context_cleanup(a1, (uint64_t)v102);
LABEL_83:
    uint64_t v66 = 0;
    uint64_t v95 = 0;
    CFMutableDictionaryRef Mutable = 0;
    CFTypeRef cf = 0;
LABEL_84:
    char v68 = 1;
    if (v10)
    {
LABEL_85:
      uint64_t v72 = a1;
      uint64_t v73 = v10;
      uint64_t v74 = *(void *)(v72 + 304);
      uint64_t v75 = mmcs_file_signature_to_hexstring(*(char **)(v74 + 152));
      CCFStringRef StringDescription = XCFDataCreateCStringDescription(*(const __CFData **)(v74 + 216));
      CFTypeID v77 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v78 = a4;
        CFStringRef v79 = CFStringCreateWithFormat(v6, 0, @"PUT section %@ sig:%s ref:%s items:(%@\t)", *(void *)(v74 + 488), v75, CStringDescription, v73);
        uint64_t v80 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v79;
          _os_log_impl(&dword_1DC1CA000, v80, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
        }
        a4 = v78;
        if (v79) {
          CFRelease(v79);
        }
      }
      if (v75) {
        free(v75);
      }
      if (CStringDescription) {
        free(CStringDescription);
      }
      CFRelease(v73);
    }
  }
  else
  {
    if (!send_request_authorizePut(a1, &v102))
    {
      if (!v102) {
        CFErrorRef v102 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"An unknown error caused the put authorization to fail.", v34, v35, v36, v37, v38, v84);
      }
      mmcs_metrics_request_set_error(*(void *)(a1 + 184), *(const void **)(a1 + 152));
      mmcs_put_request_context_cleanup(a1, (uint64_t)v102);
      uint64_t v57 = mmcs_logging_logger_default();
      XCFPrint(v57, @"AuthorizePut Send Error", v102);
    }
LABEL_74:
    char v68 = 0;
    uint64_t v95 = 0;
    CFMutableDictionaryRef Mutable = 0;
    CFTypeRef cf = 0;
    uint64_t v66 = 1;
    if (v10) {
      goto LABEL_85;
    }
  }
  if (v95) {
    free(v95);
  }
  if (v101) {
    free(v101);
  }
  uint64_t v101 = 0;
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (cf) {
    CFRelease(cf);
  }
  char v81 = v68 ^ 1;
  long long v82 = v102;
  if (!a4) {
    char v81 = 1;
  }
  if ((v81 & 1) == 0)
  {
    if (!v102)
    {
      long long v82 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"missing local error %s %d", v34, v35, v36, v37, v38, (char)"mmcs_put_req_context_init_items_for_section");
      CFErrorRef v102 = v82;
    }
    CFRetain(v82);
    long long v82 = v102;
    *a4 = v102;
  }
  if (v82) {
    CFRelease(v82);
  }
  return v66;
}

uint64_t mmcs_put_req_context_init_item_with_chunks(uint64_t a1, char **a2, uint64_t a3, unint64_t a4, CFErrorRef *a5)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (a5) {
    *a5 = 0;
  }
  if (a3 != -1) {
    mmcs_item_set_size((uint64_t)a2, a3);
  }
  if (!mmcs_item_set_chunk_instance_capacity((uint64_t)a2, a4))
  {
    unsigned int v25 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v31 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_item_set_chunk_instance_capacity");
      char v32 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v52 = v31;
        _os_log_impl(&dword_1DC1CA000, v32, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v31) {
        CFRelease(v31);
      }
    }
    CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Unable to set chunk instance capacity for item %lld", v26, v27, v28, v29, v30, (char)a2[5]);
LABEL_51:
    CFErrorRef v42 = error;
    if (!a5) {
      goto LABEL_53;
    }
    goto LABEL_52;
  }
  if (!a2[17])
  {
LABEL_25:
    mmcs_item_setup_chunk_references(a2);
    return 1;
  }
  uint64_t v9 = 0;
  unint64_t v10 = 0;
  uint64_t v49 = a1;
  while (1)
  {
    if (gMMCS_DebugLevel >= 4)
    {
      unsigned int v11 = (void *)CKRegisteredChunkSignatureCopyCString();
      uint64_t v12 = mmcs_logging_logger_chunk();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v13 = a2[17];
        uint64_t v14 = CKRegisteredChunkOffset();
        int v15 = CKRegisteredChunkLength();
        *(_DWORD *)long long buf = 134219010;
        CFStringRef v52 = (CFStringRef)(v10 + 1);
        a1 = v49;
        __int16 v53 = 2048;
        uint64_t v54 = v13;
        __int16 v55 = 2048;
        uint64_t v56 = v14;
        __int16 v57 = 1024;
        int v58 = v15;
        __int16 v59 = 2082;
        uint64_t v60 = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_DEFAULT, "Chunk %lu of %llu at itemOffset %llu with byteLength %u has signature %{public}s", buf, 0x30u);
      }
      if (v11) {
        free(v11);
      }
    }
    if (mmcs_item_is_encrypted(a2) && !CKRegisteredChunkIsEncrypted()
      || !mmcs_item_is_encrypted(a2) && CKRegisteredChunkIsEncrypted())
    {
      break;
    }
    CFStringRef v50 = 0;
    int v16 = CKRegisteredChunkLength();
    uint64_t v17 = (unsigned char *)CKRegisteredChunkSignature();
    uint64_t v18 = CKRegisteredChunkKey();
    if (!mmcs_chunk_reference_create(&v50, v16, v17, v18, 0))
    {
      CFMutableSetRef v43 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v44 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"nomem: mmcs_chunk_reference_create for item %lld", a2[5]);
        uint64_t v45 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v52 = v44;
          _os_log_impl(&dword_1DC1CA000, v45, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        uint64_t v46 = @"no memory to create chunk reference";
        if (v44) {
LABEL_47:
        }
          CFRelease(v44);
      }
      else
      {
        uint64_t v46 = @"no memory to create chunk reference";
      }
LABEL_50:
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, v46);
      goto LABEL_51;
    }
    uint64_t v19 = (unsigned __int8 *)mmcs_put_req_context_add_chunk_reference(a1, v50);
    if (v19 != v50)
    {
      mmcs_chunk_reference_dealloc(v50);
      CFStringRef v50 = v19;
    }
    uint64_t v20 = CKRegisteredSubchunkDigest();
    uint64_t v21 = v50;
    *((void *)v50 + 4) = v20;
    int v22 = a2[34];
    uint64_t v23 = CKRegisteredChunkOffset();
    if (!mmcs_chunk_instance_init((uint64_t)&v22[v9], (uint64_t)v21, v23, v10, (uint64_t)a2))
    {
      uint64_t v47 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v44 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_chunk_instance_init for item %lld", a2[5]);
        uint64_t v48 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v52 = v44;
          _os_log_impl(&dword_1DC1CA000, v48, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        uint64_t v46 = @"no memory to init chunk instance";
        if (v44) {
          goto LABEL_47;
        }
      }
      else
      {
        uint64_t v46 = @"no memory to init chunk instance";
      }
      goto LABEL_50;
    }
    if ((char *)CKRegisteredChunkItemID() != a2[5])
    {
      if (!mmcs_put_request_is_section(a1)) {
        mmcs_put_req_context_init_item_with_chunks_cold_1();
      }
      *(void *)&v22[v9 + 16] = CKRegisteredChunkItemID();
    }
    ++a2[18];
    mmcs_chunk_reference_add_instance((uint64_t)v50, &v22[v9]);
    CKRegisteredChunkSize();
    ++v10;
    v9 += 104;
    if (v10 >= (unint64_t)a2[17]) {
      goto LABEL_25;
    }
  }
  mmcs_item_set_does_not_need_put((uint64_t)a2);
  uint64_t v34 = (void *)CKRegisteredChunkSignatureCopyCString();
  int IsEncrypted = CKRegisteredChunkIsEncrypted();
  uint64_t v41 = "En";
  if (!IsEncrypted) {
    uint64_t v41 = "Unen";
  }
  CFErrorRef v42 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 17, @"%scrypted chunk %s was not expected for item %lld", v36, v37, v38, v39, v40, (char)v41);
  if (v34) {
    free(v34);
  }
  if (a5)
  {
LABEL_52:
    CFRetain(v42);
    *a5 = v42;
  }
LABEL_53:
  if (v42) {
    CFRelease(v42);
  }
  return 0;
}

void mmcs_put_request_context_cleanup(uint64_t a1, uint64_t a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  os_activity_scope_enter(request_activity_marker, &state);
  uint64_t v5 = *(void *)(a1 + 32);
  if (a2)
  {
    v26[0] = 7;
    v26[1] = 0xBFF0000000000000;
    v26[2] = 0;
    v26[3] = 0;
    v26[4] = a2;
    mmcs_put_request_set_progress_and_notify_all_items_not_done(a1, (uint64_t)v26);
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 304) + 88);
  if (v6)
  {
    mmcs_perform_timer_invalidate(v6);
    uint64_t v7 = *(void *)(a1 + 304);
    uint64_t v8 = *(const void **)(v7 + 88);
    if (v8)
    {
      CFRelease(v8);
      uint64_t v7 = *(void *)(a1 + 304);
    }
    *(void *)(v7 + 88) = 0;
  }
  if (mmcs_engine_contains_request(v5, (const void *)a1))
  {
    kdebug_trace();
    v28.opaque[0] = 0;
    v28.opaque[1] = 0;
    uint64_t v9 = mmcs_request_get_request_activity_marker(a1);
    os_activity_scope_enter(v9, &v28);
    if (*(void *)(a1 + 184))
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      *(void *)(*(void *)(a1 + 32) + 200) = C3BaseRetain((CFTypeRef)a1);
      uint64_t v11 = *(void *)(a1 + 184);
      if (v11)
      {
        _mmcs_metrics_request_stopped(*(void *)(a1 + 184), 0, *(const void **)(a1 + 152));
        *(double *)(v11 + 24) = mmcs_server_version_as_double(*(void *)(a1 + 120), *(void *)(a1 + 128));
        uint64_t v12 = *(void *)(*(void *)(a1 + 304) + 80);
        if (v12)
        {
          CFDictionaryRef v13 = *(const __CFDictionary **)(v12 + 16);
          if (v13)
          {
            *(void *)(v11 + 128) = CFDictionaryGetCount(v13);
            uint64_t v12 = *(void *)(*(void *)(a1 + 304) + 80);
          }
          *(void *)(v11 + 160) = *(void *)(v12 + 40);
          *(void *)(v11 + 152) = *(void *)(*(void *)(*(void *)(a1 + 304) + 80) + 32);
          *(void *)(v11 + 144) = *(void *)(*(void *)(*(void *)(a1 + 304) + 80) + 24);
        }
      }
      metric_object = mmcs_metrics_create_metric_object(*(void *)(a1 + 184));
      CFDictionaryAddValue(Mutable, @"metricObject", metric_object);
      if (metric_object) {
        CFRelease(metric_object);
      }
    }
    else
    {
      CFMutableDictionaryRef Mutable = 0;
    }
    uint64_t v19 = *(void *)(*(void *)(a1 + 304) + 80);
    if (v19 && *(void *)(v19 + 56))
    {
      if (!Mutable) {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
      uint64_t v20 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        CFIndex Length = CFDataGetLength(*(CFDataRef *)(*(void *)(*(void *)(a1 + 304) + 80) + 56));
        *(_DWORD *)long long buf = 134217984;
        CFIndex v30 = Length;
        _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_INFO, "Appending warmContainerState of length %llu to result dict", buf, 0xCu);
      }
      CFDictionaryAddValue(Mutable, @"kMMCSWarmContainerState", *(const void **)(*(void *)(*(void *)(a1 + 304) + 80) + 56));
    }
    CFStringRef v22 = mmcs_request_copy_description(a1);
    uint64_t v23 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      CFIndex v24 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 134218242;
      CFIndex v30 = v24;
      __int16 v31 = 2114;
      CFStringRef v32 = v22;
      _os_log_impl(&dword_1DC1CA000, v23, OS_LOG_TYPE_INFO, "Engine %p request will notify request %{public}@ done", buf, 0x16u);
    }
    if (v22) {
      CFRelease(v22);
    }
    MMCSEngineClientContextRequestCompleted(*(uint64_t **)(v5 + 152), *(void *)(a1 + 40), (uint64_t)Mutable);
    if (*(void *)(a1 + 184))
    {
      C3BaseRelease((CFTypeRef)a1);
      *(void *)(*(void *)(a1 + 32) + 200) = 0;
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    os_activity_scope_leave(&v28);
    mmcs_put_req_context_log_timing(a1);
    uint64_t v25 = *(void *)(*(void *)(a1 + 304) + 80);
    if (v25) {
      mmcs_put_state_invalidate(v25);
    }
    mmcs_engine_remove_request(v5, (const void *)a1);
  }
  else
  {
    CFStringRef v15 = mmcs_request_copy_description(a1);
    int v16 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"ignoring unknown put req %@", v15);
      uint64_t v18 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFIndex v30 = (CFIndex)v17;
        _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v17) {
        CFRelease(v17);
      }
    }
    if (v15) {
      CFRelease(v15);
    }
  }
  os_activity_scope_leave(&state);
}

const void *mmcs_put_request_get_distinct_item_with_signature_reference(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  uint64_t v31 = 0;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  uint64_t v8 = 0;
  long long v7 = 0u;
  long long v6 = 0u;
  long long v5 = 0u;
  uint64_t v4 = a2;
  uint64_t v9 = a3;
  return CFSetGetValue(*(CFSetRef *)(*(void *)(a1 + 304) + 56), &v4);
}

void mmcs_put_req_context_log_timing(uint64_t a1)
{
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = mmcs_logging_logger_summary();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    state.opaque[0] = 0;
    state.opaque[1] = 0;
    timing_activity_marker = mmcs_request_get_timing_activity_marker(a1);
    os_activity_scope_enter(timing_activity_marker, &state);
    uint64_t v4 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"PUT request timing==========================================");
      long long v6 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
    CFStringRef v7 = mmcs_request_copy_description(a1);
    uint64_t v8 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"engine %p request %@", *(void *)(a1 + 32), v7);
      long long v10 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v7) {
      CFRelease(v7);
    }
    if (*(unsigned char *)(a1 + 144))
    {
      long long v11 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"\trequest was cancelled.");
        long long v13 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v12;
          _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v12) {
          CFRelease(v12);
        }
      }
    }
    if (*(void *)(a1 + 264))
    {
      long long v14 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"\tmmcs was pre-authorized by client application");
        long long v16 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v15;
          _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v15) {
          CFRelease(v15);
        }
      }
    }
    if (*(void *)(*(void *)(a1 + 304) + 96))
    {
      long long v17 = mmcs_logging_logger_summary();
      BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
      CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (v18)
      {
        double v20 = mmcs_http_context_elapsed_seconds(*(void *)(*(void *)(a1 + 304) + 96));
        CFStringRef v21 = CFStringCreateWithFormat(v19, 0, @"\tmmcs put auth:     \t%0.4lf sec.", *(void *)&v20);
        long long v22 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v21;
          _os_log_impl(&dword_1DC1CA000, v22, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v21) {
          CFRelease(v21);
        }
      }
      long long v23 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        double v24 = mmcs_http_context_enqueued_seconds(*(void *)(*(void *)(a1 + 304) + 96));
        CFStringRef v25 = CFStringCreateWithFormat(v19, 0, @"\tmmcs put auth(inQ):\t%0.4lf sec.", *(void *)&v24);
        long long v26 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v25;
          _os_log_impl(&dword_1DC1CA000, v26, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v25) {
          CFRelease(v25);
        }
      }
    }
    else
    {
      CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    }
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v19, 0, &itemArrayCallbacks);
    uint64_t v28 = *(void *)(a1 + 304);
    if (*(void *)(v28 + 144))
    {
      unint64_t v29 = 0;
      uint64_t v30 = 152;
      do
      {
        CFArrayAppendValue(Mutable, (const void *)(v28 + v30));
        ++v29;
        uint64_t v28 = *(void *)(a1 + 304);
        v30 += 416;
      }
      while (v29 < *(void *)(v28 + 144));
    }
    if (CFArrayGetCount(Mutable) >= 1)
    {
      int v93 = Mutable;
      do
      {
        CFStringRef ValueAtIndex = (char **)CFArrayGetValueAtIndex(Mutable, 0);
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 304) + 48), ValueAtIndex);
        uint64_t v33 = mmcs_file_signature_to_hexstring(*ValueAtIndex);
        CFMutableStringRef v34 = CFStringCreateMutable(v19, 0);
        v99.unsigned int length = CFArrayGetCount(Value);
        CFArrayRef theArray = Value;
        v99.CFIndex location = 0;
        CFArrayApplyFunction(Value, v99, (CFArrayApplierFunction)log_item_applier, v34);
        uint64_t v35 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v36 = CFStringCreateWithFormat(v19, 0, @"\tsignature: %s", v33);
          uint64_t v37 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v36;
            _os_log_impl(&dword_1DC1CA000, v37, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v36) {
            CFRelease(v36);
          }
        }
        CCFStringRef StringDescription = XCFDataCreateCStringDescription((const __CFData *)ValueAtIndex[8]);
        uint64_t v39 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v40 = CFStringCreateWithFormat(v19, 0, @"\treference: %s", CStringDescription);
          uint64_t v41 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v40;
            _os_log_impl(&dword_1DC1CA000, v41, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v40) {
            CFRelease(v40);
          }
        }
        CFErrorRef v42 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v43 = CFStringCreateWithFormat(v19, 0, @"\tsize: %lld bytes", ValueAtIndex[2]);
          CFStringRef v44 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v43;
            _os_log_impl(&dword_1DC1CA000, v44, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v43) {
            CFRelease(v43);
          }
        }
        int v45 = *(_DWORD *)(a1 + 16);
        uint64_t v46 = mmcs_logging_logger_summary();
        BOOL v47 = os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG);
        if (v45 == 3)
        {
          if (v47)
          {
            CFStringRef v48 = CFStringCreateWithFormat(v19, 0, @"\tsection ID: %@", *(void *)(*(void *)(a1 + 304) + 488));
            uint64_t v49 = mmcs_logging_logger_summary();
            if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
            {
LABEL_64:
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v48;
              _os_log_impl(&dword_1DC1CA000, v49, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
LABEL_65:
            if (v48) {
              CFRelease(v48);
            }
          }
        }
        else if (v47)
        {
          CFStringRef v48 = CFStringCreateWithFormat(v19, 0, @"\titem(s): %@", v34);
          uint64_t v49 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_64;
          }
          goto LABEL_65;
        }
        if (v34) {
          CFRelease(v34);
        }
        uint64_t v94 = CStringDescription;
        CFStringRef v50 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
        {
          double v51 = mmcs_item_chunking_elapsed_seconds((uint64_t)ValueAtIndex);
          CFStringRef v52 = CFStringCreateWithFormat(v19, 0, @"\tmmcs item chunking:\t%0.4lf sec.", *(void *)&v51);
          __int16 v53 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v52;
            _os_log_impl(&dword_1DC1CA000, v53, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v52) {
            CFRelease(v52);
          }
        }
        uint64_t v54 = a1;
        __int16 v55 = *(void **)(*(void *)(a1 + 304) + 80);
        if (v55 && v55[1])
        {
          unint64_t v56 = 0;
          do
          {
            __int16 v57 = *(uint64_t **)(v55[8] + 8 * v56);
            uint64_t v58 = v57[11];
            if (CFSetContainsValue(*(CFSetRef *)(v58 + 16), ValueAtIndex))
            {
              __int16 v59 = mmcs_logging_logger_summary();
              if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
              {
                CFStringRef v60 = CFStringCreateWithFormat(v19, 0, @"\tmmcs put container %lu:\t%s", v56 + 1, **(void **)(v58 + 8));
                uint64_t v61 = mmcs_logging_logger_summary();
                if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)long long buf = 138543362;
                  *(void *)&uint8_t buf[4] = v60;
                  _os_log_impl(&dword_1DC1CA000, v61, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                }
                if (v60) {
                  CFRelease(v60);
                }
              }
              mmcs_transaction_log_timing(v57[2]);
              uint64_t v62 = v57[3];
              if (v62) {
                mmcs_transaction_log_timing(v62);
              }
              uint64_t v63 = (__CFError *)v57[5];
              if (v63)
              {
                CFStringRef v64 = mmcs_cferror_copy_description(v63);
                uint64_t v65 = mmcs_logging_logger_summary();
                if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
                {
                  CFStringRef v66 = CFStringCreateWithFormat(v19, 0, @"\terror:             \t%@", v64);
                  CFTypeID v67 = mmcs_logging_logger_summary();
                  if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)long long buf = 138543362;
                    *(void *)&uint8_t buf[4] = v66;
                    _os_log_impl(&dword_1DC1CA000, v67, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                  }
                  if (v66) {
                    CFRelease(v66);
                  }
                }
                if (v64) {
                  CFRelease(v64);
                }
              }
              CFArrayRef v68 = (const __CFArray *)v57[6];
              if (v68)
              {
                *(_DWORD *)long long buf = 1;
                v100.unsigned int length = CFArrayGetCount(v68);
                v100.CFIndex location = 0;
                CFArrayApplyFunction(v68, v100, (CFArrayApplierFunction)_log_error_0, buf);
              }
              *(_OWORD *)long long buf = (unint64_t)v57;
              CFSetApplyFunction(*(CFSetRef *)(*(void *)(*v55 + 304) + 128), (CFSetApplierFunction)find_put_complete, buf);
              uint64_t v69 = *(void *)&buf[8];
              if (*(void *)&buf[8] && *(void *)(*(void *)&buf[8] + 8))
              {
                CFStringRef v70 = mmcs_logging_logger_summary();
                if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
                {
                  double v71 = mmcs_http_context_elapsed_seconds(*(void *)(v69 + 8));
                  CFStringRef v72 = CFStringCreateWithFormat(v19, 0, @"\tmmcs put complete: \t%0.4lf sec.", *(void *)&v71);
                  uint64_t v73 = mmcs_logging_logger_summary();
                  if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)long long buf = 138543362;
                    *(void *)&uint8_t buf[4] = v72;
                    _os_log_impl(&dword_1DC1CA000, v73, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                  }
                  if (v72) {
                    CFRelease(v72);
                  }
                }
                uint64_t v74 = mmcs_logging_logger_summary();
                if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
                {
                  double v75 = mmcs_http_context_enqueued_seconds(*(void *)(v69 + 8));
                  CFStringRef v76 = CFStringCreateWithFormat(v19, 0, @"\tmmcs put complete(inQ):\t%0.4lf sec.", *(void *)&v75);
                  CFTypeID v77 = mmcs_logging_logger_summary();
                  if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)long long buf = 138543362;
                    *(void *)&uint8_t buf[4] = v76;
                    _os_log_impl(&dword_1DC1CA000, v77, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                  }
                  if (v76) {
                    CFRelease(v76);
                  }
                }
              }
            }
            ++v56;
          }
          while (v56 < v55[1]);
        }
        a1 = v54;
        CFMutableDictionaryRef Mutable = v93;
        if (ValueAtIndex[28])
        {
          uint64_t v78 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v79 = CFStringCreateWithFormat(v19, 0, @"\treceipt:           \t%@", ValueAtIndex[28]);
            uint64_t v80 = mmcs_logging_logger_summary();
            if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v79;
              _os_log_impl(&dword_1DC1CA000, v80, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v79) {
              CFRelease(v79);
            }
          }
        }
        char v81 = (__CFError *)ValueAtIndex[24];
        if (v81)
        {
          long long v82 = mmcs_cferror_copy_description(v81);
          long long v83 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v84 = CFStringCreateWithFormat(v19, 0, @"\terror uploading item %lld w/signature: %s reference: %s", ValueAtIndex[5], v33, v94);
            CFAllocatorRef v85 = mmcs_logging_logger_summary();
            if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v84;
              _os_log_impl(&dword_1DC1CA000, v85, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v84) {
              CFRelease(v84);
            }
          }
          os_activity_scope_state_s v86 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v87 = CFStringCreateWithFormat(v19, 0, @"\terror:             \t%@", v82);
            uint64_t v88 = mmcs_logging_logger_summary();
            if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v87;
              _os_log_impl(&dword_1DC1CA000, v88, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v87) {
              CFRelease(v87);
            }
          }
          uint64_t v89 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v90 = MMCSPutItemStateCString(*((_DWORD *)ValueAtIndex + 42));
            CFStringRef v91 = CFStringCreateWithFormat(v19, 0, @"\terror state:       \t%s", v90);
            uint64_t v92 = mmcs_logging_logger_summary();
            if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v91;
              _os_log_impl(&dword_1DC1CA000, v92, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v91) {
              CFRelease(v91);
            }
          }
          if (v82) {
            CFRelease(v82);
          }
        }
        if (v94) {
          free(v94);
        }
        if (v33) {
          free(v33);
        }
        XCFArrayRemoveAllValuesWithArray(v93, theArray);
      }
      while (CFArrayGetCount(v93) > 0);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    os_activity_scope_leave(&state);
  }
}

void log_item_applier(uint64_t a1, __CFString *theString)
{
  if (CFStringGetLength(theString)) {
    CFStringAppendFormat(theString, 0, @", %lld", *(void *)(a1 + 40));
  }
  else {
    CFStringAppendFormat(theString, 0, @"%lld", *(void *)(a1 + 40));
  }
}

void _log_error_0(__CFError *a1, unsigned int *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = mmcs_cferror_copy_description(a1);
  uint64_t v4 = mmcs_logging_logger_summary();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"\tprevious error %d:           \t%@", *a2, v3);
    long long v6 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v8 = v5;
      _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
  if (v3) {
    CFRelease(v3);
  }
  ++*a2;
}

void mmcs_put_request_finalize(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (*(void *)(v1 + 88))
  {
    CFStringRef v2 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)double v20 = 0;
      _os_log_impl(&dword_1DC1CA000, v2, OS_LOG_TYPE_FAULT, "progressTimer must always be invalidated/freed first to break retain cycle, invariant violation.", v20, 2u);
    }
  }
  uint64_t v3 = *(void *)(v1 + 96);
  if (v3)
  {
    mmcs_http_context_invalidate(v3);
    uint64_t v4 = *(const void **)(v1 + 96);
    if (v4) {
      C3BaseRelease(v4);
    }
    *(void *)(v1 + 96) = 0;
  }
  CFStringRef v5 = *(const void **)(v1 + 104);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(v1 + 104) = 0;
  long long v6 = *(const void **)(v1 + 24);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(v1 + 24) = 0;
  CFStringRef v7 = *(const void **)(v1 + 32);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(v1 + 32) = 0;
  CFStringRef v8 = *(const void **)(v1 + 40);
  if (v8) {
    CFRelease(v8);
  }
  *(void *)(v1 + 40) = 0;
  uint64_t v9 = *(const void **)(v1 + 48);
  if (v9) {
    CFRelease(v9);
  }
  *(void *)(v1 + 48) = 0;
  long long v10 = *(const void **)(v1 + 56);
  if (v10) {
    CFRelease(v10);
  }
  *(void *)(v1 + 56) = 0;
  long long v11 = *(const void **)(v1 + 72);
  if (v11) {
    CFRelease(v11);
  }
  *(void *)(v1 + 72) = 0;
  CFSetRef v12 = *(const __CFSet **)(v1 + 64);
  if (v12)
  {
    CFSetApplyFunction(v12, (CFSetApplierFunction)dealloc_chunk_references_0, 0);
    long long v13 = *(const void **)(v1 + 64);
    if (v13) {
      CFRelease(v13);
    }
    *(void *)(v1 + 64) = 0;
  }
  long long v14 = *(void **)(v1 + 80);
  if (v14)
  {
    mmcs_put_state_dealloc(v14);
    *(void *)(v1 + 80) = 0;
  }
  CFSetRef v15 = *(const __CFSet **)(v1 + 128);
  if (v15)
  {
    CFSetApplyFunction(v15, (CFSetApplierFunction)dealloc_put_completes, 0);
    long long v16 = *(const void **)(v1 + 128);
    if (v16) {
      CFRelease(v16);
    }
    *(void *)(v1 + 128) = 0;
  }
  if (*(void *)v1) {
    CFRelease(*(CFTypeRef *)v1);
  }
  *(void *)uint64_t v1 = 0;
  if (*(void *)(v1 + 144))
  {
    unint64_t v17 = 0;
    uint64_t v18 = v1 + 152;
    do
    {
      mmcs_item_finalize(v18);
      ++v17;
      v18 += 416;
    }
    while (v17 < *(void *)(v1 + 144));
  }
  *(void *)(v1 + 144) = 0;
  CFAllocatorRef v19 = *(const void **)(v1 + 120);
  if (v19) {
    CFRelease(v19);
  }
  *(void *)(v1 + 120) = 0;
}

uint64_t mmcs_put_request_stop_with_error(uint64_t a1, CFErrorRef error)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 144)) {
    return 0;
  }
  C3BaseRetain((CFTypeRef)a1);
  *(unsigned char *)(a1 + 144) = 1;
  if (error)
  {
    CFErrorRef v5 = 0;
  }
  else
  {
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 4, @"Put request was cancelled.");
    CFErrorRef v5 = error;
  }
  CFRetain(error);
  *(void *)(a1 + 152) = error;
  mmcs_http_context_should_cancel(*(unsigned char **)(*(void *)(a1 + 304) + 96), error);
  uint64_t v6 = *(void *)(a1 + 304);
  uint64_t v7 = *(void *)(v6 + 80);
  if (v7)
  {
    uint64_t v8 = *(void *)(v7 + 8);
    if (v8)
    {
      uint64_t v9 = 0;
      CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        if (gMMCS_DebugLevel >= 5)
        {
          long long v11 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v12 = CFStringCreateWithFormat(v10, 0, @"canceling put container %u", v9);
            long long v13 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v12;
              _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v12) {
              CFRelease(v12);
            }
          }
          if (gMMCS_DebugLevel >= 5)
          {
            long long v14 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              CFStringRef v15 = CFStringCreateWithFormat(v10, 0, @"request's put state ref: %p", *(void *)(*(void *)(a1 + 304) + 80));
              long long v16 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v15;
                _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
              }
              if (v15) {
                CFRelease(v15);
              }
            }
            if (gMMCS_DebugLevel >= 5)
            {
              unint64_t v17 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
              {
                CFStringRef v18 = CFStringCreateWithFormat(v10, 0, @"container's put state: %p", **(void **)(*(void *)(*(void *)(v7 + 64) + 8 * v9) + 88));
                CFAllocatorRef v19 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)long long buf = 138543362;
                  *(void *)&uint8_t buf[4] = v18;
                  _os_log_impl(&dword_1DC1CA000, v19, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                }
                if (v18) {
                  CFRelease(v18);
                }
              }
            }
          }
        }
        mmcs_container_cancel(*(void *)(*(void *)(v7 + 64) + 8 * v9++), *(void *)(a1 + 152));
      }
      while (v8 != v9);
      uint64_t v6 = *(void *)(a1 + 304);
    }
  }
  CFSetApplyFunction(*(CFSetRef *)(v6 + 128), (CFSetApplierFunction)mmcs_put_req_cancel_put_complete, *(void **)(a1 + 152));
  uint64_t v20 = *(void *)(a1 + 304);
  for (unint64_t i = *(void *)(v20 + 8); i < *(void *)(v20 + 144); unint64_t i = *(void *)(v20 + 8))
  {
    long long v22 = (const void *)(v20 + 416 * i + 152);
    if (CFSetGetValue(*(CFSetRef *)(v20 + 56), v22) == v22)
    {
      mmcs_put_item_progress_make_done_error(*(void *)(a1 + 152), buf);
      mmcs_put_request_set_progress_and_notify_items_like_item(a1, v22, (long long *)buf);
    }
    ++*(void *)(*(void *)(a1 + 304) + 8);
    uint64_t v20 = *(void *)(a1 + 304);
  }
  CFIndex Count = CFSetGetCount(*(CFSetRef *)v20);
  if (Count >= 1)
  {
    CFSetApplyFunction(**(CFSetRef **)(a1 + 304), (CFSetApplierFunction)cancel_chunk_job, (void *)a1);
    CFSetRemoveAllValues(**(CFMutableSetRef **)(a1 + 304));
  }
  uint64_t v24 = *(void *)(a1 + 192);
  if (v24 && mmcs_proxy_locator_is_locating(v24))
  {
    mmcs_proxy_locator_cancel(*(void *)(a1 + 192));
LABEL_39:
    mmcs_metrics_request_set_error(*(void *)(a1 + 184), *(const void **)(a1 + 152));
    mmcs_put_request_context_cleanup(a1, *(void *)(a1 + 152));
    goto LABEL_40;
  }
  if (Count >= 1) {
    goto LABEL_39;
  }
LABEL_40:
  if (v5) {
    CFRelease(v5);
  }
  C3BaseRelease((CFTypeRef)a1);
  return 1;
}

uint64_t cancel_chunk_job(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(const void **)(a1 + 136);
  mmcs_put_item_progress_make_done_error(*(void *)(a2 + 152), v6);
  mmcs_put_request_set_progress_and_notify_items_like_item(a2, v4, v6);
  return mmcs_chunk_job_cancel(a1);
}

void mmcs_put_request_append_description(uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  long long v2 = *(_OWORD *)(a1 + 16);
  long long context = *(_OWORD *)a1;
  *(_OWORD *)theCFStringRef String = v2;
  int64x2_t v16 = *(int64x2_t *)(a1 + 32);
  theString[1] = (CFMutableStringRef)(*((void *)&v2 + 1) + 1);
  if (*(void *)(a1 + 16))
  {
    CFStringRef v4 = _mmcs_request_copy_description(v1);
    if (v4)
    {
      CFStringRef v5 = v4;
      mmcs_op_requestor_context_indent(a1);
      CFStringAppend(*(CFMutableStringRef *)(a1 + 16), v5);
      CFStringAppend(*(CFMutableStringRef *)(a1 + 16), @"\n");
      CFRelease(v5);
      uint64_t v6 = *(void *)(v1 + 304);
      if (*(void *)v6)
      {
        CFIndex Count = CFSetGetCount(*(CFSetRef *)v6);
        uint64_t v6 = *(void *)(v1 + 304);
        if (Count >= 1)
        {
          CFSetApplyFunction(*(CFSetRef *)v6, (CFSetApplierFunction)_mmcs_chunk_job_append_description, &context);
          uint64_t v6 = *(void *)(v1 + 304);
        }
      }
      uint64_t v8 = *(void *)(v6 + 96);
      if (v8)
      {
        BOOL is_sending = mmcs_http_context_is_sending(v8);
        uint64_t v6 = *(void *)(v1 + 304);
        if (is_sending)
        {
          *(void *)&long long context = *(void *)(v6 + 96);
          mmcs_http_context_append_description((uint64_t)&context);
          uint64_t v6 = *(void *)(v1 + 304);
        }
      }
      uint64_t v10 = *(void *)(v6 + 80);
      if (v10)
      {
        if (*(void *)(v10 + 8))
        {
          unint64_t v11 = 0;
          do
          {
            *(void *)&long long context = *(void *)(*(void *)(v10 + 64) + 8 * v11);
            mmcs_put_container_append_description((uint64_t)&context);
            ++v11;
          }
          while (v11 < *(void *)(v10 + 8));
        }
        int64x2_t v12 = vaddq_s64(*(int64x2_t *)(a1 + 32), v16);
        *(int64x2_t *)(a1 + 32) = v12;
        if (v12.i64[1] >= 11)
        {
          mmcs_op_requestor_context_indent((uint64_t)&context);
          CFStringAppendFormat(theString[0], 0, @"<%ld more container(s)> enqueued\n", *(void *)(a1 + 40) - 10);
        }
      }
      CFSetRef v13 = *(const __CFSet **)(*(void *)(v1 + 304) + 128);
      if (v13) {
        CFSetApplyFunction(v13, (CFSetApplierFunction)_mmcs_put_complete_append_description, &context);
      }
    }
  }
}

void _mmcs_chunk_job_append_description(uint64_t a1, void *a2)
{
  *a2 = a1;
  mmcs_chunk_job_append_description((uint64_t)a2);
}

void _mmcs_put_complete_append_description(uint64_t a1, uint64_t *a2)
{
  *a2 = a1;
  mmcs_put_complete_append_description(a2);
}

uint64_t mmcs_put_req_is_using_itemid(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 304);
  if (*(void *)(v2 + 144))
  {
    unint64_t v3 = 0;
    int v4 = *(unsigned __int8 *)(a2 + 8);
    uint64_t v5 = 316;
    do
    {
      if (v4) {
        break;
      }
      if (*(void *)(v2 + v5 - 124) == *(void *)a2 && *(_DWORD *)(v2 + v5) != 7)
      {
        int v4 = 1;
        *(unsigned char *)(a2 + 8) = 1;
        uint64_t v2 = *(void *)(result + 304);
      }
      else
      {
        int v4 = 0;
      }
      ++v3;
      v5 += 416;
    }
    while (v3 < *(void *)(v2 + 144));
  }
  return result;
}

void mmcs_put_section_req_is_using_itemid(uint64_t a1, void *valuePtr)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 304);
  if (*(void *)(v2 + 144) != 1) {
    mmcs_put_section_req_is_using_itemid_cold_1();
  }
  if (*(_DWORD *)(v2 + 316) != 7)
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, valuePtr);
    if (v6)
    {
      CFNumberRef v7 = v6;
      if (CFSetContainsValue(*(CFSetRef *)(*(void *)(a1 + 304) + 72), v6)) {
        *((unsigned char *)valuePtr + 8) = 1;
      }
      CFRelease(v7);
    }
    else
    {
      uint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v9 = CFStringCreateWithFormat(v5, 0, @"Failed to create itemId to test conflicting use.");
        uint64_t v10 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          int v11 = 138543362;
          CFStringRef v12 = v9;
          _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v11, 0xCu);
        }
        if (v9) {
          CFRelease(v9);
        }
      }
    }
  }
}

void mmcs_put_request_set_progress_and_notify_all_items_not_done(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 304);
  if (*(void *)(v2 + 144))
  {
    unint64_t v5 = 0;
    uint64_t v6 = 316;
    do
    {
      if (*(_DWORD *)(v2 + v6) != 7)
      {
        long long v7 = *(_OWORD *)(a2 + 16);
        v8[0] = *(_OWORD *)a2;
        v8[1] = v7;
        uint64_t v9 = *(void *)(a2 + 32);
        mmcs_put_request_set_progress_and_notify_item(a1, (uint64_t *)(v2 + v6 - 164), (unsigned int *)v8);
        uint64_t v2 = *(void *)(a1 + 304);
      }
      ++v5;
      v6 += 416;
    }
    while (v5 < *(void *)(v2 + 144));
  }
}

void mmcs_put_item_progress_make_done_error(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  a2[1] = 0xBFF0000000000000;
  *(_DWORD *)a2 = 7;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = a1;
  if (!a1)
  {
    uint64_t v2 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"non-NULL error expected");
      int v4 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = 138543362;
        CFStringRef v6 = v3;
        _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v5, 0xCu);
      }
      if (v3) {
        CFRelease(v3);
      }
    }
  }
}

const void *mmcs_put_req_context_add_chunk_reference(uint64_t a1, const void *a2)
{
  uint64_t result = CFSetGetValue(*(CFSetRef *)(*(void *)(a1 + 304) + 64), a2);
  if (!result)
  {
    CFSetSetValue(*(CFMutableSetRef *)(*(void *)(a1 + 304) + 64), a2);
    return a2;
  }
  return result;
}

void **mmcs_put_req_context_get_chunk_reference_with_signature(uint64_t a1, const void *a2)
{
  uint64_t v12 = 0;
  long long v10 = 0u;
  long long v11 = 0uLL;
  v8[0] = 0;
  long long v9 = 0u;
  size_t v4 = CKChunkSchemeAndSignatureSize();
  v8[1] = malloc_type_malloc(v4, 0x3E18D6B1uLL);
  size_t v5 = CKChunkSchemeAndSignatureSize();
  memcpy(v8[1], a2, v5);
  *(void *)&long long v9 = 0;
  CFArrayRef Value = (void **)CFSetGetValue(*(CFSetRef *)(*(void *)(a1 + 304) + 64), v8);
  if (v8[1]) {
    free(v8[1]);
  }
  if (Value == v8) {
    return 0;
  }
  else {
    return Value;
  }
}

void mmcs_put_item_progress_make_state(int a1@<W0>, void *a2@<X8>)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  a2[1] = 0xBFF0000000000000;
  *(_DWORD *)a2 = a1;
  a2[3] = 0;
  a2[4] = 0;
  a2[2] = 0;
  if (a1 == 7)
  {
    uint64_t v2 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"a put item is done either with an error or a putReceipt");
      size_t v4 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = 138543362;
        CFStringRef v6 = v3;
        _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v5, 0xCu);
      }
      if (v3) {
        CFRelease(v3);
      }
    }
  }
}

uint64_t mmcs_put_item_progress_make_state_progress@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  *(void *)a2 = 0;
  *(_DWORD *)a2 = result;
  *(double *)(a2 + 8) = a3;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 16) = 0;
  return result;
}

void mmcs_put_item_progress_make_done_success(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0xBFF0000000000000;
  *(_DWORD *)a2 = 7;
  if (!a1)
  {
    CFStringRef v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"non-NULL putReceipt expected");
      uint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        int v9 = 138543362;
        CFStringRef v10 = v7;
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v9, 0xCu);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
  }
  *(void *)(a2 + 16) = a1;
  *(double *)(a2 + 24) = a3;
  *(void *)(a2 + 32) = 0;
}

void mmcs_put_request_put_complete_failed(uint64_t a1, uint64_t a2)
{
  mmcs_put_item_progress_make_done_error(a2, v3);
  mmcs_put_request_set_progress_and_notify_all_items_not_done(a1, (uint64_t)v3);
}

BOOL mmcs_put_request_has_items_not_done(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  unint64_t v2 = *(void *)(v1 + 144);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = (int *)(v1 + 316);
  unint64_t v4 = 1;
  do
  {
    int v5 = *v3;
    if (v4 >= v2) {
      break;
    }
    ++v4;
    v3 += 104;
  }
  while (v5 == 7);
  return v5 != 7;
}

void mmcs_put_request_set_progress_and_notify_item(uint64_t a1, uint64_t *a2, unsigned int *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  __int16 v23 = 0;
  long long v6 = *((_OWORD *)a3 + 1);
  *(_OWORD *)long long buf = *(_OWORD *)a3;
  long long v25 = v6;
  uint64_t v26 = *((void *)a3 + 4);
  mmcs_item_set_put_progress((uint64_t)a2, (unsigned int *)buf, (BOOL *)&v23 + 1, (char *)&v23);
  CFStringRef v7 = (__CFString *)*((void *)a3 + 4);
  if (*a3 != 7 && v7)
  {
    CFStringRef v7 = mmcs_cferror_copy_description(*((__CFError **)a3 + 4));
    uint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Notifying a put item state change %d with error %@.", *a3, v7);
      CFStringRef v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v7)
    {
      CFRelease(v7);
      CFStringRef v7 = 0;
    }
  }
  if (mmcs_engine_get_sparse_block_size()) {
    mmcs_engine_get_sparse_block_size();
  }
  if (HIBYTE(v23) | v23)
  {
    results_dictionary_for_item = mmcs_item_create_results_dictionary_for_item(a2);
    CFMutableDictionaryRef Mutable = results_dictionary_for_item;
    uint64_t v13 = (const void *)*((void *)a3 + 2);
    if (v13)
    {
      if (!results_dictionary_for_item)
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        uint64_t v13 = (const void *)*((void *)a3 + 2);
      }
      CFDictionaryAddValue(Mutable, @"kMMCSPutReceipt", v13);
      if (*((double *)a3 + 3) != 0.0)
      {
        *(void *)long long buf = *((void *)a3 + 3);
        CFNumberRef v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, buf);
        CFDictionaryAddValue(Mutable, @"kMMCSPutReceiptExpiry", v14);
        if (v14) {
          CFRelease(v14);
        }
      }
    }
    if (v7)
    {
      if (!Mutable) {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
      CFDictionaryAddValue(Mutable, @"kMMCSResultError", v7);
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
  }
  if (*a3 == 4)
  {
    if (*(unsigned char *)(a1 + 272))
    {
      CFStringRef v15 = *(const void **)(a1 + 280);
      if (v15)
      {
        CFDictionaryAddValue(Mutable, @"kMMCSAuthorizeSimulcastResponse", v15);
        CFDictionaryAddValue(Mutable, @"kMMCSAuthorizeSimulcastResponseSignature", *(const void **)(a1 + 288));
        *(void *)(a1 + 280) = 0;
      }
    }
  }
  if (HIBYTE(v23))
  {
    BOOL is_section = mmcs_put_request_is_section(a1);
    uint64_t v18 = *(void *)(a1 + 40);
    CFAllocatorRef v19 = *(void **)(*(void *)(a1 + 32) + 152);
    if (is_section)
    {
      MMCSEngineClientContextPutSectionProgress(v19, v18, *(void *)(*(void *)(a1 + 304) + 488), *a2, *a3, *((void *)a3 + 2), (uint64_t)v7);
    }
    else
    {
      v17.n128_u64[0] = *((void *)a3 + 1);
      MMCSEngineClientContextPutItemProgress(v19, v18, a2[5], *a2, *a3, Mutable, v17);
    }
  }
  if (!(_BYTE)v23)
  {
LABEL_35:
    if (!Mutable) {
      return;
    }
    goto LABEL_36;
  }
  BOOL v20 = mmcs_put_request_is_section(a1);
  uint64_t v21 = *(void *)(a1 + 40);
  long long v22 = *(void **)(*(void *)(a1 + 32) + 152);
  if (v20)
  {
    MMCSEngineClientContextPutSectionDone(v22, v21, *(void *)(*(void *)(a1 + 304) + 488), *a2, Mutable);
    goto LABEL_35;
  }
  MMCSEngineClientContextPutItemDone(v22, v21, a2[5], *a2, Mutable);
  if (!Mutable) {
    return;
  }
LABEL_36:
  CFRelease(Mutable);
}

void mmcs_put_request_notify_all_items_with_pending_progress(void *a1)
{
  uint64_t v1 = a1[38];
  if (*(void *)(v1 + 144))
  {
    unint64_t v3 = 0;
    uint64_t v4 = 316;
    do
    {
      if (*(_DWORD *)(v1 + v4) != 7)
      {
        mmcs_put_request_notify_item_with_pending_progress(a1, v1 + v4 - 164);
        uint64_t v1 = a1[38];
      }
      ++v3;
      v4 += 416;
    }
    while (v3 < *(void *)(v1 + 144));
  }
}

void mmcs_put_request_notify_item_with_pending_progress(void *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a2 + 328))
  {
    *(unsigned char *)(a2 + 328) = 0;
    if (mmcs_engine_get_sparse_block_size()) {
      mmcs_engine_get_sparse_block_size();
    }
    BOOL is_section = mmcs_put_request_is_section((uint64_t)a1);
    uint64_t v5 = *(unsigned int *)(a2 + 164);
    if (is_section)
    {
      if (v5 == 7)
      {
        long long v6 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
          return;
        }
        CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"pending progress should never notify the done state or that an error has occurred");
        uint64_t v8 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          goto LABEL_14;
        }
        int v16 = 138543362;
        CFStringRef v17 = v7;
LABEL_13:
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v16, 0xCu);
LABEL_14:
        if (v7) {
          CFRelease(v7);
        }
        return;
      }
      uint64_t v10 = a1[5];
      uint64_t v11 = *(void **)(a1[4] + 152);
      uint64_t v12 = *(void *)(a1[38] + 488);
      uint64_t v13 = *(void *)a2;
      MMCSEngineClientContextPutSectionProgress(v11, v10, v12, v13, v5, 0, 0);
    }
    else
    {
      if (v5 == 7)
      {
        CFStringRef v9 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          return;
        }
        CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"pending progress should never notify the done state or that an error has occurred");
        uint64_t v8 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          goto LABEL_14;
        }
        int v16 = 138543362;
        CFStringRef v17 = v7;
        goto LABEL_13;
      }
      results_dictionary_for_item = mmcs_item_create_results_dictionary_for_item((uint64_t *)a2);
      v15.n128_u64[0] = *(void *)(a2 + 248);
      MMCSEngineClientContextPutItemProgress(*(void **)(a1[4] + 152), a1[5], *(void *)(a2 + 40), *(void *)a2, *(unsigned int *)(a2 + 164), results_dictionary_for_item, v15);
      if (results_dictionary_for_item)
      {
        CFRelease(results_dictionary_for_item);
      }
    }
  }
}

void mmcs_put_request_set_progress_and_notify_items_like_item(uint64_t a1, const void *a2, long long *a3)
{
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 304) + 48), a2);
  if (Value)
  {
    CFArrayRef v6 = Value;
    uint64_t v8 = a1;
    long long v7 = a3[1];
    long long v9 = *a3;
    long long v10 = v7;
    uint64_t v11 = *((void *)a3 + 4);
    v12.unsigned int length = CFArrayGetCount(Value);
    v12.CFIndex location = 0;
    CFArrayApplyFunction(v6, v12, (CFArrayApplierFunction)_mmcs_item_set_progress_and_notify_0, &v8);
  }
}

void _mmcs_item_set_progress_and_notify_0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  long long v4 = *(_OWORD *)(a2 + 24);
  v5[0] = *(_OWORD *)(a2 + 8);
  v5[1] = v4;
  uint64_t v6 = *(void *)(a2 + 40);
  mmcs_put_request_set_progress_and_notify_item(v3, a1, (unsigned int *)v5);
}

void mmcs_put_request_set_progress_and_notify_items_with_signature_reference(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v33 = 0u;
  uint64_t v42 = 0;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  uint64_t v19 = 0;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  key = a2;
  uint64_t v20 = a3;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 304) + 48), &key);
  if (Value)
  {
    CFArrayRef v8 = Value;
    long long v9 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)&context[1] = *(_OWORD *)a4;
    long long v44 = v9;
    uint64_t v10 = *(void *)(a4 + 32);
    context[0] = a1;
    uint64_t v45 = v10;
    v47.unsigned int length = CFArrayGetCount(Value);
    v47.CFIndex location = 0;
    CFArrayApplyFunction(v8, v47, (CFArrayApplierFunction)_mmcs_item_set_progress_and_notify_0, context);
  }
  else
  {
    uint64_t v11 = mmcs_file_signature_to_hexstring(a2);
    CFRange v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cannot notify; No items found with signature %s",
              v11);
      CFNumberRef v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        LODWORD(context[0]) = 138543362;
        *(void *)((char *)context + 4) = v13;
        _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)context, 0xCu);
      }
      if (v13) {
        CFRelease(v13);
      }
    }
    if (v11) {
      free(v11);
    }
  }
}

void mmcs_put_request_set_progress_for_items_with_signature_reference(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v33 = 0u;
  uint64_t v42 = 0;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  uint64_t v19 = 0;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  key = a2;
  uint64_t v20 = a3;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 304) + 48), &key);
  if (Value)
  {
    CFArrayRef v8 = Value;
    long long v9 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)&context[1] = *(_OWORD *)a4;
    long long v44 = v9;
    uint64_t v10 = *(void *)(a4 + 32);
    context[0] = a1;
    uint64_t v45 = v10;
    v47.unsigned int length = CFArrayGetCount(Value);
    v47.CFIndex location = 0;
    CFArrayApplyFunction(v8, v47, (CFArrayApplierFunction)_mmcs_item_set_progress, context);
  }
  else
  {
    uint64_t v11 = mmcs_file_signature_to_hexstring(a2);
    CFRange v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cannot notify; No items found with signature %s",
              v11);
      CFNumberRef v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        LODWORD(context[0]) = 138543362;
        *(void *)((char *)context + 4) = v13;
        _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)context, 0xCu);
      }
      if (v13) {
        CFRelease(v13);
      }
    }
    if (v11) {
      free(v11);
    }
  }
}

void _mmcs_item_set_progress(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 24);
  v3[0] = *(_OWORD *)(a2 + 8);
  v3[1] = v2;
  uint64_t v4 = *(void *)(a2 + 40);
  mmcs_item_set_put_progress(a1, (unsigned int *)v3, 0, 0);
}

void mmcs_put_req_context_items_by_signature_description(uint64_t a1, const __CFArray *a2, uint64_t *a3)
{
  if (mmcs_put_request_is_section(*a3)) {
    uint64_t v5 = 2;
  }
  else {
    uint64_t v5 = 1;
  }
  mmcs_item_items_by_signature_description(a1, a2, v5);
}

void mmcs_put_req_context_did_chunk_item(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"completed chunk job %p", a2);
    uint64_t v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
  if (!*(unsigned char *)(a1 + 144))
  {
    CFSetRef v7 = **(const __CFSet ***)(a1 + 304);
    if (v7 && CFSetContainsValue(v7, (const void *)a2))
    {
      if (a2)
      {
        C3BaseRetain((CFTypeRef)a2);
        CFSetRemoveValue(**(CFMutableSetRef **)(a1 + 304), (const void *)a2);
        CFErrorRef v45 = 0;
        uint64_t v8 = *(void *)(a2 + 136);
        *(_OWORD *)(v8 + 256) = *(_OWORD *)(a2 + 224);
        long long v9 = *(const void **)(a2 + 264);
        if (v9)
        {
          *(void *)long long buf = 0;
          if (mmcs_chunking_profile_create((uint64_t *)buf, *(void *)(a2 + 256), v9))
          {
            if (*(void *)buf)
            {
              if (*(void *)(v8 + 112)) {
                mmcs_put_req_context_did_chunk_item_cold_1();
              }
              *(void *)(v8 + 112) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &kC3BaseArrayCallBacks);
              uint64_t v10 = *(const void **)buf;
            }
            else
            {
              uint64_t v10 = 0;
            }
          }
          else
          {
            if (*(void *)buf) {
              C3BaseRelease(*(CFTypeRef *)buf);
            }
            uint64_t v10 = 0;
            *(void *)long long buf = 0;
          }
          long long v16 = *(__CFArray **)(v8 + 112);
          if (v16)
          {
            CFArrayAppendValue(v16, v10);
            uint64_t v10 = *(const void **)buf;
          }
          if (v10) {
            C3BaseRelease(v10);
          }
        }
        *(void *)(v8 + 128) = *(void *)(a2 + 248);
        *(void *)(a2 + 248) = 0;
        long long v17 = *(const void **)(a2 + 280);
        if (v17)
        {
          CFRetain(v17);
          long long v18 = *(__CFError **)(a2 + 280);
LABEL_35:
          CFErrorRef v45 = v18;
          goto LABEL_36;
        }
        long long v25 = (const void *)CKFileDigestResultsFileVerificationKey();
        mmcs_item_set_file_verification_key(v8, v25);
        uint64_t v26 = CKFileDigestResultsFileLength();
        uint64_t v32 = v26;
        if (*(void *)(a2 + 256))
        {
          if (v26 < 0)
          {
            long long v18 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 17, @"Calculated item size was too large (%llu) for item %lld", v27, v28, v29, v30, v31, v26);
            goto LABEL_35;
          }
          mmcs_engine_add_bytes_chunked(*(void *)(a2 + 144), v26);
          mmcs_engine_commit_if_over_threshold(*(void **)(a2 + 144));
          long long v33 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v34 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Got %llu chunks for %lld", *(void *)(a2 + 256), *(void *)(*(void *)(a2 + 136) + 40));
            long long v35 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v34;
              _os_log_impl(&dword_1DC1CA000, v35, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v34) {
              CFRelease(v34);
            }
          }
        }
        if (mmcs_put_req_context_init_item_with_chunks(a1, (char **)v8, v32, *(void *)(a2 + 256), &v45))
        {
          *(void *)&long long v40 = 2;
          *((void *)&v40 + 1) = 0x3FF0000000000000;
          uint64_t v42 = 0;
          uint64_t v43 = 0;
          uint64_t v41 = 0;
          mmcs_put_request_set_progress_and_notify_items_like_item(a1, (const void *)v8, &v40);
          if (gMMCS_DebugLevel >= 5)
          {
            CFStringRef v36 = CFCopyDescription(*(CFTypeRef *)(v8 + 280));
            if (gMMCS_DebugLevel >= 5)
            {
              long long v37 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
              {
                CFStringRef v38 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Item %lld outstanding chunk references for put %@", *(void *)(v8 + 40), v36);
                long long v39 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)long long buf = 138543362;
                  *(void *)&uint8_t buf[4] = v38;
                  _os_log_impl(&dword_1DC1CA000, v39, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                }
                if (v38) {
                  CFRelease(v38);
                }
              }
            }
            if (v36) {
              CFRelease(v36);
            }
          }
          goto LABEL_37;
        }
        long long v18 = v45;
LABEL_36:
        mmcs_put_item_progress_make_done_error((uint64_t)v18, v44);
        mmcs_put_request_set_progress_and_notify_items_like_item(a1, (const void *)v8, v44);
LABEL_37:
        if (v45) {
          CFRelease(v45);
        }
        CFErrorRef v45 = 0;
        if (*(unsigned char *)(a1 + 144)) {
          goto LABEL_41;
        }
        mmcs_put_req_context_schedule_chunk_jobs(a1);
        if (*(unsigned char *)(a1 + 144)) {
          goto LABEL_41;
        }
        if (CFSetGetCount(**(CFSetRef **)(a1 + 304)) <= 0)
        {
          mmcs_put_req_context_chunking_complete(a1);
          goto LABEL_52;
        }
        if (*(unsigned char *)(a1 + 144))
        {
LABEL_41:
          uint64_t v19 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cancelled during notification. Notifying all remaining items of cancel");
            long long v21 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v20;
              _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v20) {
              CFRelease(v20);
            }
          }
          long long v22 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Clean up put request as last step of cancel");
            long long v24 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v23;
              _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v23) {
              CFRelease(v23);
            }
          }
          mmcs_metrics_request_set_error(*(void *)(a1 + 184), *(const void **)(a1 + 152));
          mmcs_put_request_context_cleanup(a1, *(void *)(a1 + 152));
        }
LABEL_52:
        C3BaseRelease((CFTypeRef)a2);
        CFErrorRef v14 = v45;
        if (!v45) {
          return;
        }
LABEL_53:
        CFRelease(v14);
        return;
      }
      __n128 v15 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        return;
      }
      CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"NULL job. Ignoring");
      CFStringRef v13 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
LABEL_20:
        if (!v12) {
          return;
        }
        CFErrorRef v14 = (CFErrorRef)v12;
        goto LABEL_53;
      }
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v12;
    }
    else
    {
      uint64_t v11 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        return;
      }
      CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unrecogized chunk job. Ignoring");
      CFStringRef v13 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v12;
    }
    _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    goto LABEL_20;
  }
}

uint64_t find_put_complete(uint64_t result, uint64_t a2)
{
  if (!*(void *)(a2 + 8))
  {
    uint64_t v3 = result;
    CFArrayRef v4 = *(const __CFArray **)(result + 24);
    v5.unsigned int length = CFArrayGetCount(v4);
    v5.CFIndex location = 0;
    uint64_t result = CFArrayContainsValue(v4, v5, *(const void **)a2);
    if (result) {
      *(void *)(a2 + 8) = v3;
    }
  }
  return result;
}

uint64_t mmcs_register_item_create(void *a1, const void *a2)
{
  *a1 = 0;
  uint64_t v4 = C3TypeRegister(&mmcs_register_itemGetTypeID_typeID);
  uint64_t Instance = (void *)C3TypeCreateInstance_(0, v4, 0x90uLL);
  uint64_t v6 = Instance;
  if (a2 && Instance)
  {
    Instance[2] = a2;
    CFRetain(a2);
    uint64_t result = 1;
    *((unsigned char *)v6 + 136) = 1;
    v6[10] = 0;
    v6[18] = 0;
    *a1 = v6;
  }
  else
  {
    if (Instance) {
      C3BaseRelease(Instance);
    }
    return 0;
  }
  return result;
}

uint64_t mmcs_register_item_get_itemid(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = 0;
  if (!a1 || (CFNumberRef v2 = *(const __CFNumber **)(a1 + 16)) == 0 || !CFNumberGetValue(v2, kCFNumberSInt64Type, &valuePtr))
  {
    uint64_t v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      if (a1) {
        uint64_t v4 = *(void *)(a1 + 16);
      }
      else {
        uint64_t v4 = 0;
      }
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"error getting itemID from registerItem %p with itemID %@", a1, v4);
      uint64_t v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v10 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
  }
  return valuePtr;
}

void mmcs_register_item_set_boundary_key(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 48);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 48) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 48) = cf;
  }
}

void mmcs_register_item_set_file_verification_key(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 56);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 56) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 56) = cf;
  }
}

CFStringRef mmcs_register_item_padded_length(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_register_item_padded_length RegisterItem cannot be NULL.");
      CFStringRef v10 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_34;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v20 = v3;
      goto LABEL_33;
    }
    return 0;
  }
  if (!*(void *)(a1 + 80))
  {
    CFStringRef v12 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_register_item_padded_length RegisterItem cannot have NULL chunks.");
      CFStringRef v10 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_34;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v20 = v3;
      goto LABEL_33;
    }
    return 0;
  }
  unint64_t valuePtr = 0;
  if (!CFNumberGetValue(*(CFNumberRef *)(a1 + 120), kCFNumberSInt64Type, &valuePtr))
  {
    CFStringRef v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_register_item_padded_length RegisterItem cannot parse registerItem->chunkCount value.");
      CFStringRef v10 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_34;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v20 = v3;
      goto LABEL_33;
    }
    return 0;
  }
  if (!valuePtr)
  {
    CFErrorRef v14 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_register_item_padded_length RegisterItem cannot registerItem->chunkCount has invalid value %llu.", valuePtr);
      CFStringRef v10 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_34;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v20 = v3;
      goto LABEL_33;
    }
    return 0;
  }
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
  if (!valuePtr)
  {
LABEL_12:
    long long v9 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_register_item_padded_length RegisterItem paddedFileLength cannot be zero.");
      CFStringRef v10 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_34;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v20 = v3;
LABEL_33:
      _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      goto LABEL_34;
    }
    return 0;
  }
  CFStringRef v3 = 0;
  int v4 = *(char *)BytePtr;
  uint64_t v5 = *(void *)(a1 + 80);
  unint64_t v6 = 1;
  while (1)
  {
    if (!v5)
    {
      __n128 v15 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_register_item_padded_length RegisterItem chunk %llu of %llu not returned.", v6, valuePtr);
      CFStringRef v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v20 = v3;
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    if (v4 >= 0 != (CKRegisteredChunkKey() != 0)) {
      break;
    }
    uint64_t v7 = CKRegisteredChunkLength();
    CFStringRef v3 = (CFStringRef)((char *)v3
                     + mmcs_padded_chunk_length_with_policy_and_chunk_length(*(void *)(a1 + 40), v7));
    v5 += CKRegisteredChunkSize();
    if (v6++ >= valuePtr)
    {
      if (v3) {
        return v3;
      }
      goto LABEL_12;
    }
  }
  long long v16 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
    return 0;
  }
  CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"mmcs_register_item_padded_length RegisterItem inconsistent Encryption between File and Chunks.");
  CFStringRef v10 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v20 = v3;
    goto LABEL_33;
  }
LABEL_34:
  if (v3)
  {
    CFRelease(v3);
    return 0;
  }
  return v3;
}

uint64_t mmcs_register_item_padded_chunk_length(uint64_t a1, uint64_t a2)
{
  return mmcs_padded_chunk_length_with_policy_and_chunk_length(*(void *)(a1 + 40), a2);
}

CFStringRef mmcs_register_item_copy_description(uint64_t a1)
{
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t itemid = mmcs_register_item_get_itemid(a1);
  return CFStringCreateWithFormat(v1, 0, @"<RegisterItem itemId:%llu", itemid);
}

CFStringRef mmcs_register_item_copy_short_description(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 137)) {
    CFNumberRef v2 = " chunk";
  }
  else {
    CFNumberRef v2 = "";
  }
  CFStringRef v3 = *(__CFError **)(a1 + 128);
  if (v3)
  {
    CFStringRef StringDescription = mmcs_cferror_copy_short_description(v3);
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t itemid = mmcs_register_item_get_itemid(a1);
    CFStringRef v6 = CFStringCreateWithFormat(v5, 0, @"[%llu%s==> %@]", itemid, v2, StringDescription);
  }
  else
  {
    CFDataRef v9 = *(const __CFData **)(a1 + 96);
    if (!v9)
    {
      CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v18 = mmcs_register_item_get_itemid(a1);
      return CFStringCreateWithFormat(v17, 0, @"[%llu%s]", v18, v2);
    }
    CFStringRef StringDescription = (__CFString *)XCFDataCreateStringDescription(v9);
    if (*(unsigned char *)(a1 + 137))
    {
      CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v11 = mmcs_register_item_get_itemid(a1);
      uint64_t file_size = mmcs_register_item_get_file_size(a1);
      unsigned int valuePtr = 0;
      CFNumberRef v13 = *(const __CFNumber **)(a1 + 120);
      if (!v13 || !CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr))
      {
        CFErrorRef v14 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v15 = CFStringCreateWithFormat(v10, 0, @"error getting chunkCount from registerItem %p with chunkCount %@", a1, *(void *)(a1 + 120));
          long long v16 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v27 = v15;
            _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v15) {
            CFRelease(v15);
          }
        }
      }
      CFStringRef v6 = CFStringCreateWithFormat(v10, 0, @"[%llu%s ==> %@ %llu bytes %lu chunks]", v11, v2, StringDescription, file_size, valuePtr);
    }
    else
    {
      uint64_t v19 = *(void *)(a1 + 104);
      CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v21 = mmcs_register_item_get_itemid(a1);
      uint64_t v22 = v21;
      if (v19)
      {
        uint64_t v24 = mmcs_register_item_get_file_size(a1);
        CFStringRef v6 = CFStringCreateWithFormat(v20, 0, @"[%llu ==> %@  %llu bytes]", v22, StringDescription, v24);
      }
      else
      {
        CFStringRef v6 = CFStringCreateWithFormat(v20, 0, @"[%llu ==> %@]", v21, StringDescription);
      }
    }
  }
  CFStringRef v7 = v6;
  if (StringDescription) {
    CFRelease(StringDescription);
  }
  return v7;
}

uint64_t mmcs_register_item_get_file_size(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = 0;
  if (!a1 || (CFNumberRef v2 = *(const __CFNumber **)(a1 + 104)) == 0 || !CFNumberGetValue(v2, kCFNumberSInt64Type, &valuePtr))
  {
    CFStringRef v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      if (a1) {
        uint64_t v4 = *(void *)(a1 + 104);
      }
      else {
        uint64_t v4 = 0;
      }
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"error getting fileSize from registerItem %p with fileSize %@", a1, v4);
      CFStringRef v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v10 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
  }
  return valuePtr;
}

uint64_t mmcs_register_item_signature_equals(uint64_t a1, uint64_t a2)
{
  CFDataRef v3 = *(const __CFData **)(a1 + 96);
  if (!v3) {
    mmcs_register_item_signature_equals_cold_1();
  }
  if (!*(void *)(a2 + 96)) {
    mmcs_register_item_signature_equals_cold_2();
  }
  CFDataGetBytePtr(v3);
  CFDataGetBytePtr(*(CFDataRef *)(a2 + 96));
  uint64_t result = CKFileSignaturesEqual();
  if (result)
  {
    unint64_t v6 = *(void *)(a1 + 24);
    unint64_t v7 = *(void *)(a2 + 24);
    return XCFSafelyEquals(v6, v7);
  }
  return result;
}

uint64_t mmcs_register_item_signature_hash(uint64_t a1)
{
  CFDataRef v1 = *(const __CFData **)(a1 + 96);
  if (!v1) {
    mmcs_register_item_signature_hash_cold_1();
  }
  return *(void *)CFDataGetBytePtr(v1);
}

const UInt8 *mmcs_register_item_signature(uint64_t a1)
{
  return CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
}

uint64_t mmcs_register_item_file_verification_key(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t mmcs_register_item_padding_policy(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

CFNumberRef mmcs_register_item_chunk_count(uint64_t a1)
{
  uint64_t valuePtr = 0;
  CFNumberRef result = *(const __CFNumber **)(a1 + 120);
  if (result)
  {
    if (CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr)) {
      return (const __CFNumber *)valuePtr;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t mmcs_register_item_chunk_length_at_index()
{
  CKRegisteredChunkSize();
  return CKRegisteredChunkLength();
}

uint64_t mmcs_register_item_chunk_signature_at_index()
{
  CKRegisteredChunkSize();
  return CKRegisteredChunkSignature();
}

uint64_t mmcs_register_item_chunk_key_at_index()
{
  CKRegisteredChunkSize();
  return CKRegisteredChunkKey();
}

uint64_t mmcs_register_item_chunk_subchunk_digest_at_index()
{
  CKRegisteredChunkSize();
  return CKRegisteredSubchunkDigest();
}

uint64_t mmcs_register_item_ranged_items(uint64_t a1)
{
  return *(void *)(a1 + 152);
}

void _mmcs_register_itemCFFinalize(void *a1)
{
  mmcs_wrapping_state_set_reference_signature_and_object((uint64_t)(a1 + 3), 0, 0);
  CFNumberRef v2 = (const void *)a1[6];
  if (v2)
  {
    CFRelease(v2);
    a1[6] = 0;
  }
  CFDataRef v3 = (const void *)a1[7];
  if (v3)
  {
    CFRelease(v3);
    a1[7] = 0;
  }
  uint64_t v4 = (const void *)a1[2];
  if (v4) {
    CFRelease(v4);
  }
  a1[2] = 0;
  CFStringRef v5 = (const void *)a1[12];
  if (v5) {
    CFRelease(v5);
  }
  a1[12] = 0;
  unint64_t v6 = (const void *)a1[16];
  if (v6) {
    CFRelease(v6);
  }
  a1[16] = 0;
  unint64_t v7 = (const void *)a1[13];
  if (v7) {
    CFRelease(v7);
  }
  a1[13] = 0;
  uint64_t v8 = (const void *)a1[14];
  if (v8) {
    CFRelease(v8);
  }
  a1[14] = 0;
  CFDataRef v9 = (const void *)a1[9];
  if (v9) {
    CFRelease(v9);
  }
  a1[9] = 0;
  CFStringRef v10 = (const void *)a1[15];
  if (v10) {
    CFRelease(v10);
  }
  a1[15] = 0;
  uint64_t v11 = (void *)a1[10];
  if (v11) {
    free(v11);
  }
  a1[10] = 0;
  CFStringRef v12 = (void *)a1[18];
  if (v12) {
    os_release(v12);
  }
  a1[18] = 0;
  CFNumberRef v13 = (const void *)a1[19];
  if (v13) {
    CFRelease(v13);
  }
  a1[19] = 0;
}

BOOL _mmcs_register_itemCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_register_itemCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_register_itemCFCopyDebugDescription()
{
  return 0;
}

void mmcs_put_state_invalidate(uint64_t a1)
{
  if (*(void *)(a1 + 8))
  {
    unint64_t v2 = 0;
    do
      mmcs_put_container_invalidate(*(void *)(*(void *)(a1 + 64) + 8 * v2++));
    while (v2 < *(void *)(a1 + 8));
  }
}

uint64_t mmcs_put_state_create(uint64_t **a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a4;
  CFStringRef v5 = a3;
  uint64_t v229 = *MEMORY[0x1E4F143B8];
  item_signature_chunk_signature_error_with_CFPropertyListFormat format = 0;
  *a1 = 0;
  if (a4) {
    *a4 = 0;
  }
  if (!a3)
  {
    CFStringRef v66 = 0;
    CFSetRef v67 = 0;
    goto LABEL_286;
  }
  if (a3[5])
  {
    unint64_t v6 = 0;
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      uint64_t v7 = *(void *)(v5[6] + 8 * v6);
      BOOL is_valid_n = mmcs_file_signature_is_valid_n(*(void *)(v7 + 32), *(void *)(v7 + 24));
      CFStringRef v12 = *(char **)(v7 + 32);
      if (is_valid_n)
      {
        CFNumberRef v13 = mmcs_file_signature_to_hexstring(*(char **)(v7 + 32));
      }
      else if (v12)
      {
        CFNumberRef v13 = hextostrdup(*(char **)(v7 + 32), *(void *)(v7 + 24));
        CFStringRef v12 = 0;
      }
      else
      {
        CFNumberRef v13 = 0;
      }
      if (*(_DWORD *)(v7 + 48)) {
        CFDataRef Data = ProtobufCBinaryData_CreateData((CFDataRef)(v7 + 56));
      }
      else {
        CFDataRef Data = 0;
      }
      CFErrorRef error_with_error_response_and_format = mmcs_cferror_create_error_with_error_response_and_format(1, 0, 33, *(__CFError **)(v7 + 40), @"The server returned an error for signature %s", v9, v10, v11, (char)v13);
      long long v16 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        CFStringRef v17 = CFCopyDescription(error_with_error_response_and_format);
        uint64_t v18 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          LOBYTE(v193) = (_BYTE)v17;
          CFStringRef v19 = CFStringCreateWithFormat(alloc, 0, @"file error %@");
          CFAllocatorRef v20 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            uint64_t v220 = (const char *)v19;
            _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v19) {
            CFRelease(v19);
          }
        }
        if (v17) {
          CFRelease(v17);
        }
      }
      if (v12)
      {
        mmcs_put_item_progress_make_done_error((uint64_t)error_with_error_response_and_format, v217);
        mmcs_put_request_set_progress_and_notify_items_with_signature_reference(a2, v12, (uint64_t)Data, (uint64_t)v217);
      }
      else
      {
        uint64_t v21 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          LOBYTE(v193) = (_BYTE)error_with_error_response_and_format;
          CFStringRef v22 = CFStringCreateWithFormat(alloc, 0, @"putAuth response invalid: ignoring putAuth file error %@ for invalid signature %s");
          CFStringRef v23 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            uint64_t v220 = (const char *)v22;
            _os_log_impl(&dword_1DC1CA000, v23, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v22) {
            CFRelease(v22);
          }
        }
      }
      if (Data) {
        CFRelease(Data);
      }
      if (error_with_error_response_and_format) {
        CFRelease(error_with_error_response_and_format);
      }
      if (v13) {
        free(v13);
      }
      ++v6;
    }
    while (v6 < v5[5]);
  }
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef alloca = (CFAllocatorRef)v5;
  if (v5[8])
  {
    uint64_t v206 = 0;
    CFMutableSetRef theSet = 0;
    *(void *)uint64_t v203 = 0;
    uint64_t v24 = 0;
    long long v25 = (void *)a2;
    while (1)
    {
      uint64_t v26 = *(void *)(v5[9] + 8 * v24);
      int v27 = *(_DWORD *)(v26 + 40);
      if ((v27 - 3) >= 3)
      {
        if (v27 == 2)
        {
          CFMutableSetRef theSet = (CFMutableSetRef)((char *)theSet + 1);
        }
        else if (v27 == 1)
        {
          ++*(void *)v203;
        }
      }
      else
      {
        ++v206;
      }
      BOOL v28 = mmcs_file_signature_is_valid_n(*(void *)(v26 + 32), *(void *)(v26 + 24));
      uint64_t v29 = *(char **)(v26 + 32);
      if (v28) {
        break;
      }
      if (!v29) {
        goto LABEL_49;
      }
      uint64_t v30 = hextostrdup(*(char **)(v26 + 32), *(void *)(v26 + 24));
      uint64_t v29 = 0;
      if (!v30) {
        goto LABEL_49;
      }
LABEL_50:
      if (*(_DWORD *)(v26 + 56))
      {
        CFDataRef v31 = ProtobufCBinaryData_CreateData((CFDataRef)(v26 + 64));
        CCFStringRef StringDescription = XCFDataCreateCStringDescription(v31);
        if (CStringDescription) {
          goto LABEL_55;
        }
      }
      else
      {
        CFDataRef v31 = 0;
      }
      CCFStringRef StringDescription = strdup("(null)");
LABEL_55:
      if (v31) {
        long long v33 = (__CFString *)v31;
      }
      else {
        long long v33 = @"(null)";
      }
      if (v29)
      {
        distinct_item_with_signature_reference = mmcs_put_request_get_distinct_item_with_signature_reference((uint64_t)v25, (uint64_t)v29, (uint64_t)v31);
        if (distinct_item_with_signature_reference)
        {
          long long v35 = *(const UInt8 **)(v26 + 48);
          if (v35)
          {
            CFStringRef v36 = distinct_item_with_signature_reference;
            size_t v37 = strlen(*(const char **)(v26 + 48));
            if (v37)
            {
              CFStringRef v38 = CFStringCreateWithBytes(allocator, v35, v37, 0x8000100u, 0);
              if (v38)
              {
                CFStringRef v39 = v38;
                if (*(_DWORD *)(v26 + 80))
                {
                  double v40 = mmcs_time_convert_server_time_to_cfabsolutetime(*(void *)(v26 + 88));
                  double v41 = v40;
                  if (v40 == 0.0) {
                    CFStringRef String = 0;
                  }
                  else {
                    CFStringRef String = (const char *)XCFAbsoluteTimeDateFormatterCreateString(v40);
                  }
                }
                else
                {
                  CFStringRef String = 0;
                  double v41 = 0.0;
                }
                uint64_t v62 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v63 = (const char *)v36[5];
                  uint64_t v64 = v36[2];
                  *(_DWORD *)long long buf = 134219266;
                  uint64_t v220 = v63;
                  __int16 v221 = 2114;
                  CFStringRef v222 = v39;
                  __int16 v223 = 2114;
                  uint64_t v224 = (uint64_t)String;
                  __int16 v225 = 2082;
                  *(void *)uint64_t v226 = v30;
                  *(_WORD *)&v226[8] = 2082;
                  *(void *)&v226[10] = CStringDescription;
                  __int16 v227 = 2048;
                  uint64_t v228 = v64;
                  _os_log_impl(&dword_1DC1CA000, v62, OS_LOG_TYPE_DEFAULT, "Server Receipt Received. itemId:%llu receipt:%{public}@ expiry:%{public}@ sig:%{public}s ref:%{public}s len:%llu", buf, 0x3Eu);
                }
                mmcs_item_set_put_receipt_with_expiry_time((uint64_t)v36, v39, v41);
                mmcs_put_item_progress_make_done_success((uint64_t)v39, (uint64_t)v216, v41);
                mmcs_put_request_set_progress_and_notify_items_with_signature_reference(a2, v29, (uint64_t)v31, (uint64_t)v216);
                CFStringRef v65 = v39;
                long long v25 = (void *)a2;
                CFRelease(v65);
              }
              else
              {
                uint64_t v54 = mmcs_logging_logger_default();
                long long v25 = (void *)a2;
                if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                {
                  CFStringRef v60 = CFStringCreateWithFormat(allocator, 0, @"Invalid return receipt %s file signature %s ref %@", *(void *)(v26 + 48), v30, v33);
                  uint64_t v61 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long buf = 138543362;
                    uint64_t v220 = (const char *)v60;
                    _os_log_impl(&dword_1DC1CA000, v61, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
                  }
                  if (v60) {
                    CFRelease(v60);
                  }
                }
                CFStringRef String = (const char *)mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Invalid return receipt for file signature %s ref %@", v55, v56, v57, v58, v59, (char)v30);
                mmcs_put_item_progress_make_done_error((uint64_t)String, v215);
                mmcs_put_request_set_progress_and_notify_items_like_item(a2, v36, v215);
              }
              goto LABEL_90;
            }
          }
          if ((*(_DWORD *)(v26 + 40) - 3) <= 2)
          {
            CFErrorRef v45 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v51 = CFStringCreateWithFormat(allocator, 0, @"Invalid return receipt for success_code %d file signature %s ref %@", *(unsigned int *)(v26 + 40), v30, v33);
              CFStringRef v52 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                uint64_t v220 = (const char *)v51;
                _os_log_impl(&dword_1DC1CA000, v52, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v51) {
                CFRelease(v51);
              }
            }
            CFStringRef String = (const char *)mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Invalid return receipt for file signature %s", v46, v47, v48, v49, v50, (char)v30);
            mmcs_put_item_progress_make_done_error((uint64_t)String, v214);
            mmcs_put_request_set_progress_and_notify_items_with_signature_reference((uint64_t)v25, v29, (uint64_t)v31, (uint64_t)v214);
            goto LABEL_90;
          }
        }
        else
        {
          __int16 v53 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          {
            LOBYTE(v193) = (_BYTE)v30;
            CFStringRef String = (const char *)CFStringCreateWithFormat(allocator, 0, @"putAuth response invalid: ignoring putAuth success unknown signature %s ref %@");
            long long v44 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
              goto LABEL_78;
            }
            goto LABEL_90;
          }
        }
      }
      else
      {
        uint64_t v43 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          LOBYTE(v193) = (_BYTE)v30;
          CFStringRef String = (const char *)CFStringCreateWithFormat(allocator, 0, @"putAuth response invalid: ignoring putAuth success for invalid signature %s ref %@");
          long long v44 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
          {
LABEL_78:
            *(_DWORD *)long long buf = 138543362;
            uint64_t v220 = String;
            _os_log_impl(&dword_1DC1CA000, v44, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
LABEL_90:
          if (String) {
            CFRelease(String);
          }
        }
      }
      if (v30) {
        free(v30);
      }
      CFStringRef v5 = (uint64_t *)alloca;
      if (CStringDescription) {
        free(CStringDescription);
      }
      if (v31) {
        CFRelease(v31);
      }
      if ((unint64_t)++v24 >= *((void *)alloca + 8)) {
        goto LABEL_102;
      }
    }
    uint64_t v30 = mmcs_file_signature_to_hexstring(*(char **)(v26 + 32));
    if (v30) {
      goto LABEL_50;
    }
LABEL_49:
    uint64_t v30 = strdup("(null)");
    goto LABEL_50;
  }
  CFMutableSetRef theSet = 0;
  *(void *)uint64_t v203 = 0;
  uint64_t v206 = 0;
  long long v25 = (void *)a2;
LABEL_102:
  CFArrayRef v68 = v5;
  CFStringRef v5 = (uint64_t *)malloc_type_calloc(1uLL, 0x48uLL, 0x9A4D9941uLL);
  v5[8] = (uint64_t)malloc_type_calloc(1uLL, 8 * v68[3], 0x2004093837F09uLL);
  uint64_t *v5 = (uint64_t)v25;
  v5[1] = 0;
  _OWORD v5[2] = (uint64_t)CFDictionaryCreateMutable(allocator, 0, 0, 0);
  v5[3] = v206;
  v5[4] = (uint64_t)theSet;
  v5[5] = *(void *)v203;
  if (*((_DWORD *)v68 + 14)) {
    int v69 = *((_DWORD *)v68 + 15);
  }
  else {
    int v69 = 0;
  }
  mmcs_request_set_reporting_level((uint64_t)v25, v69);
  if (*((_DWORD *)v68 + 20))
  {
    CFDataRef v70 = ProtobufCBinaryData_CreateData((CFAllocatorRef)((char *)alloca + 88));
    double v71 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
    {
      if (v70) {
        CFIndex Length = CFDataGetLength(v70);
      }
      else {
        CFIndex Length = 0;
      }
      *(_DWORD *)long long buf = 134217984;
      uint64_t v220 = (const char *)Length;
      _os_log_impl(&dword_1DC1CA000, v71, OS_LOG_TYPE_DEFAULT, "Opaque Method Completion Info List Context of Length %llu Found.", buf, 0xCu);
    }
    mmcs_put_state_set_opaque_context((uint64_t)v5, v70);
    if (v70) {
      CFRelease(v70);
    }
  }
  CFSetRef chunk_references = (const __CFSet *)mmcs_put_req_context_get_chunk_references((uint64_t)v25);
  CFMutableSetRef MutableCopy = CFSetCreateMutableCopy(allocator, 0, chunk_references);
  CFSetRef v67 = MutableCopy;
  if (!*((void *)alloca + 3))
  {
    unint64_t v76 = 0;
    CFStringRef v66 = 0;
LABEL_214:
    http_uint64_t request_options = (const void *)mmcs_request_get_http_request_options((uint64_t)v25);
    is_cloudkit_CFStringRef dataclass = mmcs_request_is_cloudkit_dataclass((uint64_t)v25);
    uint64_t v150 = mmcs_put_request_item_count((uint64_t)v25);
    if (mmcs_http_request_options_should_use_bk_sys((uint64_t)http_request_options, is_cloudkit_dataclass, v150, v76))
    {
      http_uint64_t request_options = (const void *)mmcs_http_request_options_create_override_network_service_type_to_background_system_initiated_copy((uint64_t)http_request_options);
    }
    else if (http_request_options)
    {
      CFRetain(http_request_options);
    }
    if (v5[1])
    {
      unint64_t v151 = 0;
      do
        mmcs_http_request_set_options(*(void *)(*(void *)(*(void *)(v5[8] + 8 * v151++) + 16) + 24), http_request_options);
      while (v151 < v5[1]);
    }
    if (http_request_options) {
      CFRelease(http_request_options);
    }
    if (gMMCS_DebugLevel >= 4)
    {
      CFMutableStringRef Mutable = CFStringCreateMutable(allocator, 0);
      CFSetApplyFunction(v67, (CFSetApplierFunction)append_chunk_ref_signature_and_length_description, Mutable);
      long long v153 = mmcs_logging_logger_chunk();
      if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex Count = CFSetGetCount(v67);
        *(_DWORD *)long long buf = 134218242;
        uint64_t v220 = (const char *)Count;
        __int16 v221 = 2114;
        CFStringRef v222 = Mutable;
        _os_log_impl(&dword_1DC1CA000, v153, OS_LOG_TYPE_DEFAULT, "Unneeded chunk reference count %ld (%{public}@)", buf, 0x16u);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
    CFSetApplyFunction(v67, (CFSetApplierFunction)chunk_reference_was_read, v25);
    *a1 = v5;
    uint64_t v155 = 1;
    if (v66) {
      goto LABEL_292;
    }
    goto LABEL_293;
  }
  CFStringRef v66 = 0;
  uint64_t v75 = 0;
  unint64_t v76 = 0;
  CFAllocatorRef v200 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  theSeta = MutableCopy;
LABEL_115:
  uint64_t v77 = *(void *)(*((void *)alloca + 4) + 8 * v75);
  uint64_t v213 = 0;
  if (!mmcs_put_container_create((void *)(v5[8] + 8 * v75), v5)) {
    goto LABEL_272;
  }
  ++v5[1];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(*(void *)(v5[8] + 8 * v75) + 80), &state);
  uint64_t v78 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v79 = *(const char **)(v77 + 24);
    *(_DWORD *)long long buf = 136446210;
    uint64_t v220 = v79;
    _os_log_impl(&dword_1DC1CA000, v78, OS_LOG_TYPE_DEFAULT, "Container %{public}s", buf, 0xCu);
  }
  uint64_t v80 = *(void *)(v77 + 40);
  uint64_t v81 = *(void *)(v77 + 64);
  if (v80) {
    BOOL v82 = v81 == 0;
  }
  else {
    BOOL v82 = 1;
  }
  if (!v82)
  {
    uint64_t v170 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v170, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v172 = CFStringCreateWithFormat(allocator, 0, @"Cannot have both chunk checksums and container uploade elements");
      unint64_t v173 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v173, OS_LOG_TYPE_ERROR)) {
        goto LABEL_269;
      }
      *(_DWORD *)long long buf = 138543362;
      uint64_t v220 = (const char *)v172;
      goto LABEL_268;
    }
    goto LABEL_271;
  }
  uint64_t v83 = v81 + v80;
  if (v80)
  {
    if (v83)
    {
      uint64_t v174 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v174, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC1CA000, v174, OS_LOG_TYPE_FAULT, "Cannot have chunk checksums in MMCS Protocol version 5 upload.", buf, 2u);
      }
      goto LABEL_271;
    }
    goto LABEL_262;
  }
  if (!v81)
  {
    uint64_t v176 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v176, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v172 = CFStringCreateWithFormat(allocator, 0, @"Cannot have neither chunk checksums or container upload elements");
      unint64_t v173 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v173, OS_LOG_TYPE_ERROR)) {
        goto LABEL_269;
      }
      *(_DWORD *)long long buf = 138543362;
      uint64_t v220 = (const char *)v172;
LABEL_268:
      _os_log_impl(&dword_1DC1CA000, v173, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
LABEL_269:
      if (v172) {
        CFRelease(v172);
      }
    }
LABEL_271:
    os_activity_scope_leave(&state);
LABEL_272:
    uint64_t v4 = a4;
    goto LABEL_286;
  }
  if (!v83)
  {
LABEL_262:
    uint64_t v175 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v175, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v172 = CFStringCreateWithFormat(allocator, 0, @"Cannot have zero container chunk instances");
      unint64_t v173 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v173, OS_LOG_TYPE_ERROR)) {
        goto LABEL_269;
      }
      *(_DWORD *)long long buf = 138543362;
      uint64_t v220 = (const char *)v172;
      goto LABEL_268;
    }
    goto LABEL_271;
  }
  uint64_t v84 = *(void *)(v5[8] + 8 * v75);
  if (!mmcs_storage_container_create(&v213, *(char **)(v77 + 24), *(const char **)(v77 + 56), v83)) {
    goto LABEL_271;
  }
  mmcs_put_container_set_storage_container(v84, v213);
  uint64_t v211 = 0;
  uint64_t server_version = mmcs_request_get_server_version((uint64_t)v25);
  BOOL v87 = mmcs_server_version_compare(server_version, v86, 3, 8) != 1
     || *(unsigned char *)(mmcs_chunk_instance_offset((uint64_t)v25) + 174) == 0;
  int v196 = v87;
  if (!mmcs_storage_container_stream_create((uint64_t)&v211, v84, (uint64_t)v213, v87))
  {
    uint64_t v4 = a4;
    goto LABEL_285;
  }
  uint64_t v207 = v83;
  mmcs_put_container_set_storage_container_stream(v84, v211);
  uint64_t v88 = (CFTypeRef *)(*(void *)(v84 + 16) + 24);
  uint64_t v89 = v84;
  uint64_t v90 = *(void *)(v77 + 32);
  int should_disable_vendor_tls = mmcs_request_should_disable_vendor_tls((uint64_t)v25);
  if (mmcs_http_request_create_with_host_info(v88, v90, 0, should_disable_vendor_tls, &item_signature_chunk_signature_error_with_format))
  {
    uint64_t v92 = v211;
    is_put_complete_at_edge_protocol_unint64_t v2 = mmcs_http_request_is_put_complete_at_edge_protocol_v2(*(void *)(*(void *)(v89 + 16) + 24));
    mmcs_storage_container_set_should_write_payload_trailer((uint64_t)v92, is_put_complete_at_edge_protocol_v2);
    int v94 = *(_DWORD *)(*v5 + 68);
    uint64_t v204 = (void *)v89;
    if (v94)
    {
      CFStringRef v95 = (const __CFString *)v207;
      if (v94 != 2) {
        mmcs_put_state_create_cold_1();
      }
      if (*(unsigned char *)(*v5 + 296)
        && !mmcs_http_request_is_put_complete_at_edge_protocol_v2(*(void *)(*(void *)(v89 + 16) + 24)))
      {
        CFStringRef v184 = mmcs_logging_logger_default();
        BOOL v185 = os_log_type_enabled(v184, OS_LOG_TYPE_ERROR);
        uint64_t v4 = a4;
        if (v185)
        {
          CFStringRef v191 = CFStringCreateWithFormat(allocator, 0, @"PutCompleteAtEdge Required Version 2, Content Returned Something Else.");
          v192 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            uint64_t v220 = (const char *)v191;
            _os_log_impl(&dword_1DC1CA000, v192, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v191) {
            CFRelease(v191);
          }
        }
        CFStringRef v183 = @"PutCompleteAtEdge Required Version 2, Content Returned Something Else.";
LABEL_310:
        item_signature_chunk_signature_error_with_CFPropertyListFormat format = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, v183, v186, v187, v188, v189, v190, (char)v193);
        goto LABEL_285;
      }
    }
    else
    {
      CFStringRef v95 = (const __CFString *)v207;
      if (mmcs_http_request_is_put_complete_at_edge_protocol_v2(*(void *)(*(void *)(v89 + 16) + 24)))
      {
        CFStringRef v180 = mmcs_logging_logger_default();
        uint64_t v4 = a4;
        if (os_log_type_enabled(v180, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v181 = CFStringCreateWithFormat(allocator, 0, @"PutCompleteAtEdge Disabled, Content Returned PutCompleteAtEdge.");
          CFStringRef v182 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v182, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            uint64_t v220 = (const char *)v181;
            _os_log_impl(&dword_1DC1CA000, v182, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v181) {
            CFRelease(v181);
          }
        }
        CFStringRef v183 = @"PutCompleteAtEdge Disabled, Content Returned PutCompleteAtEdge.";
        goto LABEL_310;
      }
    }
    http_clock_skew_uint64_t metrics = (const void *)mmcs_request_get_http_clock_skew_metrics((uint64_t)v25);
    if (http_clock_skew_metrics) {
      mmcs_container_set_http_clock_skew_metrics(v89, http_clock_skew_metrics);
    }
    if (mmcs_request_get_url_expiry_override((uint64_t)v25))
    {
      unsigned int v97 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v97, OS_LOG_TYPE_DEBUG))
      {
        unint64_t v193 = *(void **)(*(void *)(v77 + 32) + 120);
        CFStringRef v98 = CFStringCreateWithFormat(allocator, 0, @"overriding url expiry %llu from content server");
        CFRange v99 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          uint64_t v220 = (const char *)v98;
          _os_log_impl(&dword_1DC1CA000, v99, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v98) {
          CFRelease(v98);
        }
      }
      uint64_t v100 = *(void *)(*(void *)(v89 + 16) + 24);
      int url_expiry_override = mmcs_request_get_url_expiry_override((uint64_t)v25);
      mmcs_http_request_override_url_expiry(v100, url_expiry_override);
      CFStringRef v95 = (const __CFString *)v207;
    }
    uint64_t v194 = v75;
    unint64_t v195 = v76;
    uint64_t v102 = *(void *)(*(void *)(v77 + 32) + 128);
    if (v102)
    {
      size_t v103 = strlen(*(const char **)(v102 + 24));
      CFStringRef v104 = CFStringCreateWithBytes(allocator, *(const UInt8 **)(v102 + 24), v103, 0x8000100u, 0);
      size_t v105 = strlen(*(const char **)(v102 + 32));
      CFStringRef v106 = CFStringCreateWithBytes(allocator, *(const UInt8 **)(v102 + 32), v105, 0x8000100u, 0);
      uint64_t v107 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      v204[4] = v107;
      CFDictionaryAddValue(v107, v104, v106);
      uint64_t v108 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        uint64_t v220 = (const char *)v104;
        __int16 v221 = 2112;
        CFStringRef v222 = v106;
        _os_log_impl(&dword_1DC1CA000, v108, OS_LOG_TYPE_DEFAULT, "AcceleratorRequestHeader (%@:%@)", buf, 0x16u);
      }
      if (v104) {
        CFRelease(v104);
      }
      CFStringRef v95 = (const __CFString *)v207;
      if (v106) {
        CFRelease(v106);
      }
    }
    if (v66) {
      CFRelease(v66);
    }
    CFStringRef str = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(*(void *)(v204[2] + 24) + 16), @"Content-Length");
    uint64_t v109 = 0;
    uint64_t v110 = 0;
    uint64_t v111 = 8;
    while (1)
    {
      if (*(void *)(v77 + 40))
      {
        uint64_t v112 = (const void **)(*(void *)(v77 + 48) + v111);
      }
      else
      {
        uint64_t v119 = *(void *)(*(void *)(v77 + 72) + 8 * v110);
        uint64_t v120 = *(void *)(*((void *)alloca + 9) + 8 * *(unsigned int *)(v119 + 52));
        if (*(_DWORD *)(v120 + 56))
        {
          CFDataRef v121 = XCFDataCreateWithBytesNoCopy(allocator, *(const UInt8 **)(v120 + 72), *(void *)(v120 + 64), v200);
          CFIndex v122 = mmcs_put_request_get_distinct_item_with_signature_reference(a2, *(void *)(v120 + 32), (uint64_t)v121);
          if (v121) {
            CFRelease(v121);
          }
          if (!v122)
          {
LABEL_234:
            long long v158 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v158, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl(&dword_1DC1CA000, v158, OS_LOG_TYPE_ERROR, "AuthorizePut response referenced unknown chunk/file in chunkList.", buf, 2u);
            }
LABEL_283:
            uint64_t v4 = a4;
LABEL_284:
            CFSetRef v67 = theSeta;
            CFStringRef v66 = str;
            goto LABEL_285;
          }
        }
        else
        {
          CFIndex v122 = mmcs_put_request_get_distinct_item_with_signature_reference(a2, *(void *)(v120 + 32), 0);
          if (!v122) {
            goto LABEL_234;
          }
        }
        if (*(_DWORD *)(v119 + 48))
        {
          if (*((void *)alloca + 8) <= (unint64_t)*(unsigned int *)(v119 + 52))
          {
            long long v159 = mmcs_logging_logger_default();
            if (!os_log_type_enabled(v159, OS_LOG_TYPE_ERROR)) {
              goto LABEL_283;
            }
            CFStringRef v160 = CFStringCreateWithFormat(allocator, 0, @"FileOpaqueReferenceData requested by server is beyond the length of file_success list.");
            long long v161 = mmcs_logging_logger_default();
            uint64_t v4 = a4;
            CFSetRef v67 = theSeta;
            CFStringRef v66 = str;
            if (!os_log_type_enabled(v161, OS_LOG_TYPE_ERROR)) {
              goto LABEL_281;
            }
            *(_DWORD *)long long buf = 138543362;
            uint64_t v220 = (const char *)v160;
            goto LABEL_280;
          }
          if (!*((unsigned char *)v122 + 104))
          {
            long long v162 = mmcs_logging_logger_default();
            if (!os_log_type_enabled(v162, OS_LOG_TYPE_ERROR)) {
              goto LABEL_283;
            }
            CFStringRef v160 = CFStringCreateWithFormat(allocator, 0, @"FileOpaqueReferenceData requested by server when not requested by client.");
            long long v161 = mmcs_logging_logger_default();
            uint64_t v4 = a4;
            CFSetRef v67 = theSeta;
            CFStringRef v66 = str;
            if (!os_log_type_enabled(v161, OS_LOG_TYPE_ERROR)) {
              goto LABEL_281;
            }
            *(_DWORD *)long long buf = 138543362;
            uint64_t v220 = (const char *)v160;
            goto LABEL_280;
          }
          FileOpaqueReferenceCFDataRef Data = (const __CFData *)*((void *)v122 + 26);
          if (!FileOpaqueReferenceData)
          {
            FileOpaqueReferenceCFDataRef Data = (const __CFData *)mmcs_item_create_FileOpaqueReferenceData((uint64_t)v122);
            *((void *)v122 + 26) = FileOpaqueReferenceData;
            if (!FileOpaqueReferenceData)
            {
              uint64_t v178 = mmcs_logging_logger_default();
              if (!os_log_type_enabled(v178, OS_LOG_TYPE_ERROR)) {
                goto LABEL_283;
              }
              CFStringRef v160 = CFStringCreateWithFormat(allocator, 0, @"Failed to generate file opaque reference data.");
              long long v161 = mmcs_logging_logger_default();
              uint64_t v4 = a4;
              CFSetRef v67 = theSeta;
              CFStringRef v66 = str;
              if (!os_log_type_enabled(v161, OS_LOG_TYPE_ERROR)) {
                goto LABEL_281;
              }
              *(_DWORD *)long long buf = 138543362;
              uint64_t v220 = (const char *)v160;
LABEL_280:
              _os_log_impl(&dword_1DC1CA000, v161, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
LABEL_281:
              if (v160) {
                CFRelease(v160);
              }
              goto LABEL_285;
            }
          }
          if (!CFDataGetLength(FileOpaqueReferenceData))
          {
            long long v163 = mmcs_logging_logger_default();
            if (!os_log_type_enabled(v163, OS_LOG_TYPE_ERROR)) {
              goto LABEL_283;
            }
            CFStringRef v160 = CFStringCreateWithFormat(allocator, 0, @"Failed to generate appropriate size for reference data.");
            long long v161 = mmcs_logging_logger_default();
            uint64_t v4 = a4;
            CFSetRef v67 = theSeta;
            CFStringRef v66 = str;
            if (!os_log_type_enabled(v161, OS_LOG_TYPE_ERROR)) {
              goto LABEL_281;
            }
            *(_DWORD *)long long buf = 138543362;
            uint64_t v220 = (const char *)v160;
            goto LABEL_280;
          }
          if (v110)
          {
            CFSetRef v129 = (char *)v213[4] + v109;
            uint64_t v130 = *((void *)v129 - 9);
            uint64_t v131 = v130 + mmcs_chunk_instance_get_length((CFDataRef *)v129 - 13);
          }
          else
          {
            uint64_t v131 = 0;
          }
          CFStringRef v95 = (const __CFString *)v207;
          mmcs_chunk_instance_init_with_file_opaque_reference_data((uint64_t)v213[4] + v109, v131, v110, *((CFTypeRef *)v122 + 26));
          uint64_t v132 = (const void *)*((void *)v122 + 26);
          if (v132) {
            CFRelease(v132);
          }
          *((void *)v122 + 26) = 0;
          goto LABEL_190;
        }
        if (*((unsigned char *)v122 + 216))
        {
          long long v164 = (__CFString *)mmcs_chunk_signature_to_hexstring(*(char **)(v119 + 40));
          long long v165 = mmcs_file_signature_to_hexstring(*(char **)v122);
          long long v166 = XCFDataCreateCStringDescription(*((const __CFData **)v122 + 8));
          long long v167 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315906;
            uint64_t v220 = "Unexpected chunk reference for metadata only item.";
            __int16 v221 = 2082;
            CFStringRef v222 = v164;
            __int16 v223 = 2082;
            uint64_t v224 = (uint64_t)v165;
            __int16 v225 = 2082;
            *(void *)uint64_t v226 = v166;
            _os_log_impl(&dword_1DC1CA000, v167, OS_LOG_TYPE_ERROR, "%s: chunk:%{public}s sig:%{public}s ref:%{public}s", buf, 0x2Au);
          }
          item_signature_chunk_signature_error_with_CFPropertyListFormat format = mmcs_cferror_create_item_signature_chunk_signature_error_with_format(@"com.apple.mmcs", 25, *((void *)v122 + 5), *(const UInt8 **)v122, *(const UInt8 **)(v119 + 40), 0, @"%s", v168, (char)"Unexpected chunk reference for metadata only item.");
          CFSetRef v67 = theSeta;
          CFStringRef v66 = str;
          if (v164) {
            free(v164);
          }
          uint64_t v4 = a4;
          if (v165) {
            free(v165);
          }
          if (v166) {
            free(v166);
          }
          goto LABEL_285;
        }
        if (!*(_DWORD *)(v119 + 24))
        {
          CFStringRef v169 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v169, OS_LOG_TYPE_ERROR)) {
            goto LABEL_283;
          }
          CFStringRef v160 = CFStringCreateWithFormat(allocator, 0, @"FileOpaqueReferenceData requested by server is unknown ContainerUploadElement type.");
          long long v161 = mmcs_logging_logger_default();
          uint64_t v4 = a4;
          CFSetRef v67 = theSeta;
          CFStringRef v66 = str;
          if (!os_log_type_enabled(v161, OS_LOG_TYPE_ERROR)) {
            goto LABEL_281;
          }
          *(_DWORD *)long long buf = 138543362;
          uint64_t v220 = (const char *)v160;
          goto LABEL_280;
        }
        uint64_t v112 = (const void **)(v119 + 40);
        CFStringRef v95 = (const __CFString *)v207;
      }
      uint64_t v113 = (char *)*v112;
      if (*v112)
      {
        chunk_reference_with_signature = mmcs_put_req_context_get_chunk_reference_with_signature(a2, *v112);
        if (!chunk_reference_with_signature)
        {
          long long v156 = mmcs_chunk_signature_to_hexstring(v113);
          long long v157 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 134218498;
            uint64_t v220 = (const char *)(v110 + 1);
            __int16 v221 = 2048;
            CFStringRef v222 = v95;
            __int16 v223 = 2082;
            uint64_t v224 = (uint64_t)v156;
            _os_log_impl(&dword_1DC1CA000, v157, OS_LOG_TYPE_ERROR, "Unknown Chunk Requested in Container at position %lu of %zu with signature %{public}s", buf, 0x20u);
          }
          uint64_t v4 = a4;
          if (v156) {
            free(v156);
          }
          goto LABEL_284;
        }
        uint64_t v115 = (uint64_t)chunk_reference_with_signature;
        mmcs_chunk_reference_apply_function_to_instances((uint64_t)chunk_reference_with_signature, (void (__cdecl *)(const void *, void *))add_attributed_items, (void *)(v204[11] + 16));
        CFSetRemoveValue(theSeta, (const void *)v115);
        if (v110)
        {
          uint64_t v116 = (char *)v213[4] + v109;
          uint64_t v117 = *((void *)v116 - 9);
          uint64_t v118 = v117 + mmcs_chunk_instance_get_length((CFDataRef *)v116 - 13);
        }
        else
        {
          uint64_t v118 = 0;
        }
        mmcs_chunk_instance_init((uint64_t)v213[4] + v109, v115, v118, v110, 0);
        int v123 = mmcs_item_padded_chunk_length(*(void *)(*(void *)(v115 + 48) + 8), *(unsigned int *)(v115 + 4));
        *(_DWORD *)((char *)v213[4] + v109 + 64) = v123;
        if (gMMCS_DebugLevel >= 4)
        {
          CFStringRef v124 = mmcs_chunk_signature_to_hexstring(v113);
          int v125 = mmcs_logging_logger_chunk();
          if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v126 = (const __CFString *)(*(void *)(v77 + 64) + *(void *)(v77 + 40));
            int v127 = *(_DWORD *)(v115 + 4);
            *(_DWORD *)long long buf = 134219010;
            uint64_t v220 = (const char *)(v110 + 1);
            __int16 v221 = 2048;
            CFStringRef v222 = v126;
            __int16 v223 = 2048;
            uint64_t v224 = v118;
            __int16 v225 = 1024;
            *(_DWORD *)uint64_t v226 = v127;
            *(_WORD *)&v226[4] = 2082;
            *(void *)&v226[6] = v124;
            _os_log_impl(&dword_1DC1CA000, v125, OS_LOG_TYPE_DEFAULT, "Chunk %lu of %zu at containerOffset %llu with byteLength %u has signature %{public}s", buf, 0x30u);
          }
          CFStringRef v95 = (const __CFString *)v207;
          if (v124) {
            free(v124);
          }
        }
      }
LABEL_190:
      ++v110;
      v109 += 104;
      v111 += 16;
      if (v95 == (const __CFString *)v110)
      {
        mmcs_storage_container_compute_size((uint64_t)v213, v196);
        uint64_t v133 = mmcs_request_index((uint64_t)v213);
        CFStringRef v66 = str;
        if (str)
        {
          IntCFArrayRef Value = CFStringGetIntValue(str);
          CFSetRef v67 = theSeta;
          if ((IntValue & 0x80000000) == 0)
          {
            uint64_t v135 = mmcs_request_index((uint64_t)v213);
            CFAllocatorRef v136 = mmcs_logging_logger_default();
            unint64_t v137 = v136;
            long long v25 = (void *)a2;
            if (v135 == IntValue)
            {
              if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
              {
                unint64_t v193 = *v213;
                CFStringRef v138 = CFStringCreateWithFormat(allocator, 0, @"put container %s has expected Content-Length %llu.");
                CFTypeRef v139 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v139, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)long long buf = 138543362;
                  uint64_t v220 = (const char *)v138;
                  char v140 = v139;
                  os_log_type_t v141 = OS_LOG_TYPE_DEBUG;
                  goto LABEL_204;
                }
                goto LABEL_205;
              }
            }
            else if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT))
            {
              long long v145 = (const char *)*v213;
              uint64_t v146 = mmcs_request_index((uint64_t)v213);
              *(_DWORD *)long long buf = 136315906;
              long long v147 = "false";
              if (v196) {
                long long v147 = "true";
              }
              uint64_t v220 = v145;
              __int16 v221 = 2048;
              CFStringRef v222 = (CFStringRef)v146;
              __int16 v223 = 2048;
              uint64_t v224 = IntValue;
              __int16 v225 = 2080;
              *(void *)uint64_t v226 = v147;
              _os_log_impl(&dword_1DC1CA000, v137, OS_LOG_TYPE_FAULT, "put container size mismatch containerId=%s containerLength=%llu contentLengthHeader=%llu shouldWriteToc=%s", buf, 0x2Au);
            }
            goto LABEL_211;
          }
          long long v144 = mmcs_logging_logger_default();
          long long v25 = (void *)a2;
          if (!os_log_type_enabled(v144, OS_LOG_TYPE_ERROR)) {
            goto LABEL_211;
          }
          unint64_t v193 = *v213;
          CFStringRef v138 = CFStringCreateWithFormat(allocator, 0, @"put container %s has invalid Content-Length %d.");
          long long v143 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v143, OS_LOG_TYPE_ERROR)) {
            goto LABEL_205;
          }
        }
        else
        {
          long long v25 = (void *)a2;
          CFSetRef v67 = theSeta;
          if (mmcs_http_request_is_put_complete_at_edge_protocol_v2(*(void *)(v204[2] + 24))) {
            goto LABEL_211;
          }
          uint64_t v142 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v142, OS_LOG_TYPE_ERROR)) {
            goto LABEL_211;
          }
          unint64_t v193 = *v213;
          CFStringRef v138 = CFStringCreateWithFormat(allocator, 0, @"put container %s has no Content-Length header.");
          long long v143 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v143, OS_LOG_TYPE_ERROR)) {
            goto LABEL_205;
          }
        }
        *(_DWORD *)long long buf = 138543362;
        uint64_t v220 = (const char *)v138;
        char v140 = v143;
        os_log_type_t v141 = OS_LOG_TYPE_ERROR;
LABEL_204:
        _os_log_impl(&dword_1DC1CA000, v140, v141, "%{public}@", buf, 0xCu);
LABEL_205:
        if (v138) {
          CFRelease(v138);
        }
LABEL_211:
        unint64_t v76 = v133 + v195;
        os_activity_scope_leave(&state);
        uint64_t v75 = v194 + 1;
        if ((unint64_t)(v194 + 1) < *((void *)alloca + 3)) {
          goto LABEL_115;
        }
        goto LABEL_214;
      }
    }
  }
  uint64_t v177 = mmcs_logging_logger_default();
  uint64_t v4 = a4;
  if (os_log_type_enabled(v177, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v160 = CFStringCreateWithFormat(allocator, 0, @"Unable to create message for storage container %s", *(void *)(*(void *)(*((void *)alloca + 4) + 8 * v75) + 24));
    long long v161 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      uint64_t v220 = (const char *)v160;
      goto LABEL_280;
    }
    goto LABEL_281;
  }
LABEL_285:
  os_activity_scope_leave(&state);
LABEL_286:
  if (v4 && item_signature_chunk_signature_error_with_format)
  {
    CFRetain(item_signature_chunk_signature_error_with_format);
    *uint64_t v4 = item_signature_chunk_signature_error_with_format;
  }
  if (v5) {
    mmcs_put_state_dealloc(v5);
  }
  uint64_t v155 = 0;
  if (v66) {
LABEL_292:
  }
    CFRelease(v66);
LABEL_293:
  if (item_signature_chunk_signature_error_with_format) {
    CFRelease(item_signature_chunk_signature_error_with_format);
  }
  if (v67) {
    CFRelease(v67);
  }
  return v155;
}

void mmcs_put_state_set_opaque_context(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    CFTypeRef v4 = *(CFTypeRef *)(a1 + 48);
    if (v4 != cf)
    {
      if (v4) {
        CFRelease(v4);
      }
      *(void *)(a1 + 48) = 0;
      if (cf) {
        CFRetain(cf);
      }
      *(void *)(a1 + 48) = cf;
    }
  }
}

void add_attributed_items(uint64_t a1, CFMutableSetRef *a2)
{
}

void append_chunk_ref_signature_and_length_description(uint64_t a1, __CFString *theString)
{
  if (CFStringGetLength(theString) >= 1) {
    CFStringAppend(theString, @", ");
  }
  mmcs_chunk_reference_append_signature_length_description(a1, theString);
}

void chunk_reference_was_read(uint64_t a1, uint64_t a2)
{
}

void mmcs_put_state_dealloc(void *a1)
{
  if (!a1[1])
  {
    *a1 = 0;
    CFTypeRef v4 = (void *)a1[8];
    if (!v4) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  unint64_t v2 = 0;
  do
  {
    mmcs_put_container_invalidate(*(void *)(a1[8] + 8 * v2++));
    unint64_t v3 = a1[1];
  }
  while (v2 < v3);
  *a1 = 0;
  CFTypeRef v4 = (void *)a1[8];
  if (v4)
  {
    if (v3)
    {
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[8];
        uint64_t v7 = *(const void **)(v6 + 8 * i);
        if (v7)
        {
          C3BaseRelease(v7);
          uint64_t v6 = a1[8];
          unint64_t v3 = a1[1];
        }
        *(void *)(v6 + 8 * i) = 0;
      }
      CFTypeRef v4 = (void *)a1[8];
    }
LABEL_12:
    free(v4);
  }
LABEL_13:
  uint64_t v8 = (const void *)a1[6];
  if (v8) {
    CFRelease(v8);
  }
  a1[6] = 0;
  uint64_t v9 = (const void *)a1[2];
  if (v9) {
    CFRelease(v9);
  }
  a1[2] = 0;
  uint64_t v10 = (const void *)a1[7];
  if (v10) {
    CFRelease(v10);
  }
  free(a1);
}

BOOL mmcs_put_state_has_outstanding_async_transactions(uint64_t a1)
{
  if (!*(void *)(a1 + 8)) {
    return 0;
  }
  unint64_t v2 = 0;
  do
    BOOL result = mmcs_container_request_enqueued_or_inflight(*(void *)(*(void *)(a1 + 64) + 8 * v2++));
  while (v2 < *(void *)(a1 + 8) && !result);
  return result;
}

uint64_t mmcs_put_state_containers_done_count(uint64_t a1)
{
  if (!*(void *)(a1 + 8)) {
    return 0;
  }
  LODWORD(v2) = 0;
  unint64_t v3 = 0;
  do
  {
    if (mmcs_container_is_done(*(void *)(*(void *)(a1 + 64) + 8 * v3))) {
      uint64_t v2 = (v2 + 1);
    }
    else {
      uint64_t v2 = v2;
    }
    ++v3;
  }
  while (v3 < *(void *)(a1 + 8));
  return v2;
}

uint64_t mmcs_put_state_containers_failed_count(uint64_t a1)
{
  if (!*(void *)(a1 + 8)) {
    return 0;
  }
  LODWORD(v2) = 0;
  unint64_t v3 = 0;
  do
  {
    if (mmcs_container_is_done_and_failed(*(void *)(*(void *)(a1 + 64) + 8 * v3))) {
      uint64_t v2 = (v2 + 1);
    }
    else {
      uint64_t v2 = v2;
    }
    ++v3;
  }
  while (v3 < *(void *)(a1 + 8));
  return v2;
}

uint64_t mmcs_put_state_get_put_container_for_storage_container_key(uint64_t a1, const char *a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      uint64_t v6 = *(void *)(*(void *)(a1 + 64) + 8 * i);
      BOOL has_storage_container_key = mmcs_put_container_has_storage_container_key(v6, a2);
      unint64_t v2 = *(void *)(a1 + 8);
      if (has_storage_container_key) {
        break;
      }
    }
  }
  else
  {
    unint64_t i = 0;
    uint64_t v6 = 0;
  }
  if (i >= v2) {
    return 0;
  }
  else {
    return v6;
  }
}

BOOL mmcs_put_state_put_container_did_reserve_chunk_reference(uint64_t a1, const void *a2, void *key)
{
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
  if (Value) {
    return Value == a2;
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), key, a2);
  return 1;
}

void mmcs_put_state_container_will_be_retried(uint64_t *a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2[11];
  uint64_t v3 = *(void *)(v2 + 56);
  uint64_t v4 = *(void *)(v2 + 8);
  if (*(void *)(v3 + 64) <= *(void *)(v4 + 40))
  {
    uint64_t v10 = 0;
    unint64_t v11 = -1;
    do
    {
      if (v11 + 1 >= *(void *)(v4 + 40)) {
        break;
      }
      uint64_t v12 = *(void *)(v4 + 32);
      if (!mmcs_chunk_instance_is_ford((_DWORD *)(v12 + v10)))
      {
        if (!mmcs_chunk_instance_is_chunk_reference((_DWORD *)(v12 + v10))) {
          mmcs_put_state_container_will_be_retried_cold_1();
        }
        if (mmcs_put_state_put_container_did_reserve_chunk_reference((uint64_t)a1, a2, *(void **)(v12 + v10 + 56)))
        {
          uint64_t v13 = *(void *)(v12 + v10 + 56);
          uint64_t v14 = *(unsigned int *)(v13 + 4);
          if (v11 + 1 == *(void *)(v3 + 64) && *(void *)(v3 + 72) < v14) {
            uint64_t v14 = *(void *)(v3 + 72);
          }
          mmcs_chunk_reference_was_unread(v13, *a1, v14);
        }
      }
      ++v11;
      v10 += 104;
    }
    while (v11 < *(void *)(v3 + 64));
  }
  else
  {
    CFStringRef v5 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"storage container stream chunk index is beyond the storage container chunk count");
      uint64_t v7 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        int v15 = 138543362;
        CFStringRef v16 = v6;
        _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v15, 0xCu);
      }
      if (v6) {
        CFRelease(v6);
      }
    }
  }
}

CFErrorRef mmcs_put_state_copy_error_for_failed_containers(uint64_t a1)
{
  if (!*(void *)(a1 + 8)) {
    return 0;
  }
  unint64_t v2 = 0;
  CFMutableStringRef Mutable = 0;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v5 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  do
  {
    primary_CFErrorRef error = mmcs_container_get_primary_error(*(void *)(*(void *)(a1 + 64) + 8 * v2));
    if (primary_error)
    {
      uint64_t v7 = (const void *)primary_error;
      if (!Mutable) {
        CFMutableStringRef Mutable = CFArrayCreateMutable(v4, 0, v5);
      }
      CFArrayAppendValue(Mutable, v7);
    }
    ++v2;
  }
  while (v2 < *(void *)(a1 + 8));
  if (!Mutable) {
    return 0;
  }
  CFErrorRef error_with_underlying_errors = mmcs_cferror_create_error_with_underlying_errors(@"com.apple.mmcs", 7, @"Put container failed.", Mutable, 0);
  CFRelease(Mutable);
  return error_with_underlying_errors;
}

void mmcs_put_state_process_storage_container_error_list(uint64_t *a1, void *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (a2[3])
    {
      unint64_t v4 = 0;
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        uint64_t v6 = *(void *)(a2[4] + 8 * v4);
        uint64_t put_container_for_storage_container_key = mmcs_put_state_get_put_container_for_storage_container_key((uint64_t)a1, *(const char **)(v6 + 24));
        if (put_container_for_storage_container_key)
        {
          unint64_t v11 = *(__CFError **)(v6 + 32);
          if (v11)
          {
            uint64_t v12 = (void *)put_container_for_storage_container_key;
            CFErrorRef error_with_error_response_and_format = (__CFString *)mmcs_cferror_create_error_with_error_response_and_format(0, 1, 7, v11, @"The server returned an error for container %s", v8, v9, v10, *(void *)(v6 + 24));
            mmcs_container_set_complete_error(v12, error_with_error_response_and_format);
            uint64_t v14 = mmcs_logging_logger_default();
            XCFPrint(v14, @"ContainerCompleteIssue", error_with_error_response_and_format);
LABEL_7:
            if (error_with_error_response_and_format) {
              CFRelease(error_with_error_response_and_format);
            }
          }
        }
        else
        {
          int v15 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            CFErrorRef error_with_error_response_and_format = (__CFString *)CFStringCreateWithFormat(v5, 0, @"no storage container matching key %s", *(void *)(v6 + 24));
            CFStringRef v16 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v23 = error_with_error_response_and_format;
              _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            }
            goto LABEL_7;
          }
        }
        ++v4;
      }
      while (v4 < a2[3]);
    }
    if (a2[5])
    {
      unint64_t v17 = 0;
      do
        mmcs_put_state_process_file_error(a1, *(void *)(a2[6] + 8 * v17++));
      while (v17 < a2[5]);
    }
    if (a2[7])
    {
      unint64_t v18 = 0;
      do
        mmcs_put_state_process_file_success(a1, *(void *)(a2[8] + 8 * v18++));
      while (v18 < a2[7]);
    }
  }
  else
  {
    CFStringRef v19 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Malformed putComplete response body");
      uint64_t v21 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v23 = v20;
        _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v20) {
        CFRelease(v20);
      }
    }
  }
}

void mmcs_put_state_process_file_error(uint64_t *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  BOOL is_valid_n = mmcs_file_signature_is_valid_n(*(void *)(a2 + 32), *(void *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 32);
  if (is_valid_n)
  {
    uint64_t v6 = mmcs_file_signature_to_hexstring(*(char **)(a2 + 32));
    if (v6) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  if (!v5 || (uint64_t v6 = hextostrdup(*(char **)(a2 + 32), *(void *)(a2 + 24)), v5 = 0, !v6)) {
LABEL_6:
  }
    uint64_t v6 = strdup("(null)");
LABEL_7:
  if (*(_DWORD *)(a2 + 48))
  {
    CFDataRef Data = ProtobufCBinaryData_CreateData((CFDataRef)(a2 + 56));
    CCFStringRef StringDescription = XCFDataCreateCStringDescription(Data);
    if (CStringDescription) {
      goto LABEL_12;
    }
  }
  else
  {
    CFDataRef Data = 0;
  }
  CCFStringRef StringDescription = strdup("(null)");
LABEL_12:
  CFErrorRef error_with_error_response_and_format = mmcs_cferror_create_error_with_error_response_and_format(0, 1, 33, *(__CFError **)(a2 + 40), @"The server returned an error. sig:%s ref:%s", v8, v9, v10, (char)v6);
  uint64_t v13 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    CFStringRef v14 = CFCopyDescription(error_with_error_response_and_format);
    int v15 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"file error %@", v14, CStringDescription);
      unint64_t v17 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v24 = v16;
        _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v16) {
        CFRelease(v16);
      }
    }
    if (v14) {
      CFRelease(v14);
    }
  }
  if (!v5)
  {
    CFStringRef v19 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"PutComplete response invalid: ignoring putComplete file error %@ for invalid item. sig:%s ref:%s", error_with_error_response_and_format, v6, CStringDescription);
    uint64_t v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v24 = v20;
    goto LABEL_29;
  }
  distinct_item_with_signature_reference = mmcs_put_request_get_distinct_item_with_signature_reference(*a1, v5, (uint64_t)Data);
  if (distinct_item_with_signature_reference)
  {
    mmcs_item_set_server_error((uint64_t)distinct_item_with_signature_reference, error_with_error_response_and_format);
    goto LABEL_32;
  }
  CFStringRef v22 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"PutComplete response error: ignoring putComplete file error %@; cannot find item. sig:%s ref:%s",
            error_with_error_response_and_format,
            v6,
            CStringDescription);
    uint64_t v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v24 = v20;
LABEL_29:
    _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
LABEL_30:
    if (v20) {
      CFRelease(v20);
    }
  }
LABEL_32:
  if (error_with_error_response_and_format) {
    CFRelease(error_with_error_response_and_format);
  }
  if (Data) {
    CFRelease(Data);
  }
  if (v6) {
    free(v6);
  }
  if (CStringDescription) {
    free(CStringDescription);
  }
}

void mmcs_put_state_process_file_success(uint64_t *a1, uint64_t a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  BOOL is_valid_n = mmcs_file_signature_is_valid_n(*(void *)(a2 + 32), *(void *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 32);
  if (is_valid_n)
  {
    uint64_t v6 = mmcs_file_signature_to_hexstring(*(char **)(a2 + 32));
    if (v6) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  if (!v5 || (uint64_t v6 = hextostrdup(*(char **)(a2 + 32), *(void *)(a2 + 24)), v5 = 0, !v6)) {
LABEL_6:
  }
    uint64_t v6 = strdup("(null)");
LABEL_7:
  if (*(_DWORD *)(a2 + 56))
  {
    CFDataRef Data = ProtobufCBinaryData_CreateData((CFDataRef)(a2 + 64));
    CCFStringRef StringDescription = XCFDataCreateCStringDescription(Data);
    if (CStringDescription)
    {
      if (v5) {
        goto LABEL_10;
      }
LABEL_24:
      CFStringRef v19 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_54;
      }
      CFStringRef String = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"PutComplete response invalid: ignoring putAuth success for invalid item. sig:%s ref:%s", v6, CStringDescription);
      CFStringRef v20 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        goto LABEL_52;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v53 = String;
      goto LABEL_42;
    }
  }
  else
  {
    CFDataRef Data = 0;
  }
  CCFStringRef StringDescription = strdup("(null)");
  if (!v5) {
    goto LABEL_24;
  }
LABEL_10:
  distinct_item_with_signature_reference = mmcs_put_request_get_distinct_item_with_signature_reference(*a1, v5, (uint64_t)Data);
  if (Data) {
    CFRelease(Data);
  }
  if (!distinct_item_with_signature_reference)
  {
    uint64_t v21 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_54;
    }
    CFStringRef String = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"PutComplete response invalid: ignoring putAuth success for unknown item. sig:%s ref:%s", v6, CStringDescription);
    CFStringRef v20 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_52;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v53 = String;
LABEL_42:
    CFStringRef v34 = v20;
    os_log_type_t v35 = OS_LOG_TYPE_ERROR;
LABEL_43:
    _os_log_impl(&dword_1DC1CA000, v34, v35, "%{public}@", buf, 0xCu);
    if (!String) {
      goto LABEL_54;
    }
LABEL_53:
    CFRelease(String);
    goto LABEL_54;
  }
  int v10 = *(_DWORD *)(a2 + 40);
  if (v10 != 5)
  {
    if (v10 == 2)
    {
      uint64_t v32 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      CFStringRef String = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"One or more contributing containers. sig:%s ref:%s len:%llu", v6, CStringDescription, distinct_item_with_signature_reference[2]);
      long long v33 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v53 = String;
        CFStringRef v34 = v33;
        os_log_type_t v35 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_43;
      }
    }
    else
    {
      if (v10 == 1) {
        goto LABEL_16;
      }
      CFStringRef v36 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        goto LABEL_54;
      }
      CFStringRef String = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unknown success code %d. sig:%s ref:%s len:%llu", *(unsigned int *)(a2 + 40), v6, CStringDescription, distinct_item_with_signature_reference[2]);
      CFStringRef v20 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v53 = String;
        goto LABEL_42;
      }
    }
LABEL_52:
    if (!String) {
      goto LABEL_54;
    }
    goto LABEL_53;
  }
LABEL_16:
  unint64_t v11 = *(const UInt8 **)(a2 + 48);
  if (!v11 || (size_t v12 = strlen(*(const char **)(a2 + 48))) == 0)
  {
    CFStringRef v22 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v28 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Invalid return receipt for success_code %d. sig:%s ref:%s len:%llu", *(unsigned int *)(a2 + 40), v6, CStringDescription, distinct_item_with_signature_reference[2]);
      uint64_t v29 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v53 = v28;
        _os_log_impl(&dword_1DC1CA000, v29, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v28) {
        CFRelease(v28);
      }
    }
    CFStringRef String = (const __CFString *)mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Invalid return receipt. sig:%s ref:%s len:%llu", v23, v24, v25, v26, v27, (char)v6);
    uint64_t v30 = *a1;
    mmcs_put_item_progress_make_done_error((uint64_t)String, v49);
    CFDataRef v31 = (long long *)v49;
    goto LABEL_51;
  }
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v14 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v11, v12, 0x8000100u, 0);
  if (!v14)
  {
    size_t v37 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v43 = CFStringCreateWithFormat(v13, 0, @"Invalid receipt received. receipt:%s sig:%s ref:%s len:%llu", *(void *)(a2 + 48), v6, CStringDescription, distinct_item_with_signature_reference[2]);
      long long v44 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v53 = v43;
        _os_log_impl(&dword_1DC1CA000, v44, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v43) {
        CFRelease(v43);
      }
    }
    CFStringRef String = (const __CFString *)mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Invalid return receipt for file signature %s", v38, v39, v40, v41, v42, (char)v6);
    uint64_t v30 = *a1;
    mmcs_put_item_progress_make_done_error((uint64_t)String, v50);
    CFDataRef v31 = (long long *)v50;
LABEL_51:
    mmcs_put_request_set_progress_and_notify_items_like_item(v30, distinct_item_with_signature_reference, v31);
    goto LABEL_52;
  }
  CFStringRef v15 = v14;
  if (*(_DWORD *)(a2 + 80))
  {
    double v16 = mmcs_time_convert_server_time_to_cfabsolutetime(*(void *)(a2 + 88));
    double v17 = v16;
    if (v16 == 0.0) {
      CFStringRef String = 0;
    }
    else {
      CFStringRef String = XCFAbsoluteTimeDateFormatterCreateString(v16);
    }
  }
  else
  {
    CFStringRef String = 0;
    double v17 = 0.0;
  }
  CFErrorRef v45 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v46 = (const __CFString *)distinct_item_with_signature_reference[5];
    uint64_t v47 = distinct_item_with_signature_reference[2];
    *(_DWORD *)long long buf = 134219266;
    CFStringRef v53 = v46;
    __int16 v54 = 2114;
    CFStringRef v55 = v15;
    __int16 v56 = 2114;
    CFStringRef v57 = String;
    __int16 v58 = 2082;
    uint64_t v59 = v6;
    __int16 v60 = 2082;
    uint64_t v61 = CStringDescription;
    __int16 v62 = 2048;
    uint64_t v63 = v47;
    _os_log_impl(&dword_1DC1CA000, v45, OS_LOG_TYPE_DEFAULT, "Server Receipt Received. itemId:%llu receipt:%{public}@ expiry:%{public}@ sig:%{public}s ref:%{public}s len:%llu", buf, 0x3Eu);
  }
  mmcs_item_set_put_receipt_with_expiry_time((uint64_t)distinct_item_with_signature_reference, v15, v17);
  uint64_t v48 = *a1;
  mmcs_put_item_progress_make_done_success((uint64_t)v15, (uint64_t)v51, v17);
  mmcs_put_request_set_progress_and_notify_items_like_item(v48, distinct_item_with_signature_reference, v51);
  CFRelease(v15);
  if (String) {
    goto LABEL_53;
  }
LABEL_54:
  if (v6) {
    free(v6);
  }
  if (CStringDescription) {
    free(CStringDescription);
  }
}

void mmcs_put_state_process_clone_complete(uint64_t *a1, void *a2)
{
  if (a2[5])
  {
    unint64_t v4 = 0;
    do
      mmcs_put_state_process_file_error(a1, *(void *)(a2[6] + 8 * v4++));
    while (v4 < a2[5]);
  }
  if (a2[3])
  {
    unint64_t v5 = 0;
    do
      mmcs_put_state_process_file_success(a1, *(void *)(a2[4] + 8 * v5++));
    while (v5 < a2[3]);
  }
}

CFDataRef mmcs_put_state_create_put_complete_request_body(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  MethocCompletionInfoList = (void **)mmcs_put_state_create_MethocCompletionInfoList(a1, a2);
  if (!MethocCompletionInfoList) {
    return 0;
  }
  uint64_t v3 = MethocCompletionInfoList;
  uint64_t packed_size = chunkserver__method_completion_info_list__get_packed_size(MethocCompletionInfoList);
  unint64_t v5 = (const UInt8 *)malloc_type_malloc(packed_size, 0xDA60D2DFuLL);
  chunkserver__method_completion_info_list__pack(v3, (uint64_t)v5);
  CFDataRef v6 = XCFDataCreateWithBytesNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v5, packed_size, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
  chunkserver__method_completion_info_list__free_unpacked(v3, 0);
  return v6;
}

void *mmcs_put_state_create_MethocCompletionInfoList(uint64_t a1, uint64_t a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = malloc_type_malloc(0x40uLL, 0x10F0040790CF86CuLL);
  if (!v4) {
    return v4;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 24));
  if (Count < 1)
  {
    chunkserver__method_completion_info_list__init(v4);
    uint64_t v6 = 0;
    v4[3] = 0;
    CFAllocatorRef v13 = v4 + 3;
    goto LABEL_19;
  }
  uint64_t v6 = 0;
  CFIndex v7 = 0;
  do
  {
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 24), v7);
    uint64_t v9 = ValueAtIndex[3];
    if (v9)
    {
      if (*(void *)(v9 + 16)) {
        mmcs_put_state_create_MethocCompletionInfoList_cold_4();
      }
      CFArrayRef v10 = *(const __CFArray **)(v9 + 40);
      if (v10) {
        v6 += CFArrayGetCount(v10);
      }
    }
    uint64_t v11 = ValueAtIndex[2];
    if (v11)
    {
      if (*(void *)(v11 + 16)) {
        mmcs_put_state_create_MethocCompletionInfoList_cold_3();
      }
      CFArrayRef v12 = *(const __CFArray **)(v11 + 40);
      if (v12) {
        v6 += CFArrayGetCount(v12);
      }
    }
    if (ValueAtIndex[5]) {
      ++v6;
    }
    ++v7;
  }
  while (Count != v7);
  chunkserver__method_completion_info_list__init(v4);
  v4[3] = 0;
  CFAllocatorRef v13 = v4 + 3;
  if (v6 <= 0)
  {
LABEL_19:
    if (!v4[4])
    {
LABEL_48:
      chunkserver__method_completion_info_list__free_unpacked((void **)v4, 0);
      return v4;
    }
    goto LABEL_20;
  }
  CFStringRef v14 = malloc_type_calloc(1uLL, 8 * v6, 0x2004093837F09uLL);
  v4[4] = v14;
  if (!v14) {
    goto LABEL_48;
  }
LABEL_20:
  if (Count < 1)
  {
    int v16 = 1;
  }
  else
  {
    CFIndex v15 = 0;
    int v16 = 1;
    do
    {
      double v17 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 24), v15);
      uint64_t v18 = v17[3];
      if (v18)
      {
        if (*(void *)(v18 + 16)) {
          mmcs_put_state_create_MethocCompletionInfoList_cold_2();
        }
        CFArrayRef v19 = *(const __CFArray **)(v18 + 40);
        if (v19)
        {
          v34.unsigned int length = CFArrayGetCount(*(CFArrayRef *)(v18 + 40));
          v34.CFIndex location = 0;
          CFArrayApplyFunction(v19, v34, (CFArrayApplierFunction)_copy_methodCompletionInfoToList_0, v4);
        }
      }
      uint64_t v20 = v17[2];
      if (v20)
      {
        if (*(void *)(v20 + 16)) {
          mmcs_put_state_create_MethocCompletionInfoList_cold_1();
        }
        CFArrayRef v21 = *(const __CFArray **)(v20 + 40);
        if (v21)
        {
          v35.unsigned int length = CFArrayGetCount(*(CFArrayRef *)(v20 + 40));
          v35.CFIndex location = 0;
          CFArrayApplyFunction(v21, v35, (CFArrayApplierFunction)_copy_methodCompletionInfoToList_0, v4);
        }
      }
      if (v17[5])
      {
        method_completion_info = mmcs_put_container_create_method_completion_info(v17, v17[2], 0);
        if (method_completion_info)
        {
          uint64_t v24 = v4[3];
          uint64_t v23 = v4[4];
          v4[3] = v24 + 1;
          *(void *)(v23 + 8 * v24) = method_completion_info;
        }
        else
        {
          int v16 = 0;
        }
      }
      ++v15;
    }
    while (Count != v15);
  }
  if (*(void *)(a1 + 48))
  {
    uint64_t v25 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 48));
      *(_DWORD *)long long buf = 134217984;
      CFIndex v32 = Length;
      _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_DEFAULT, "Opaque Method Completion Info List Context of Length %llu Set.", buf, 0xCu);
    }
    *((_DWORD *)v4 + 10) = 1;
    ProtobufCBinaryData_SetData(v4 + 6, *(CFDataRef *)(a1 + 48));
  }
  if (!v16) {
    goto LABEL_48;
  }
  if (*v13 != v6)
  {
    uint64_t v27 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v28 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"error Put MethodCompletionInfoList for putComplete (%p) creating response list", a2);
      uint64_t v29 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFIndex v32 = (CFIndex)v28;
        _os_log_impl(&dword_1DC1CA000, v29, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v28) {
        CFRelease(v28);
      }
    }
    goto LABEL_48;
  }
  return v4;
}

CFDataRef mmcs_put_state_create_clone_complete_request_body(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  FileChunkLists = mmcs_put_request_create_FileChunkLists(a1);
  if (!FileChunkLists) {
    return 0;
  }
  uint64_t v6 = FileChunkLists;
  MethocCompletionInfoList = (void **)mmcs_put_state_create_MethocCompletionInfoList(a2, a3);
  if (MethocCompletionInfoList && (uint64_t v8 = (void **)malloc_type_malloc(0x28uLL, 0x1060040A76FABEDuLL)) != 0)
  {
    uint64_t v9 = v8;
    chunkserver__clone_complete_request__init((uint64_t)v8);
    v9[3] = v6;
    v9[4] = MethocCompletionInfoList;
    uint64_t packed_size = chunkserver__clone_complete_request__get_packed_size(v9);
    uint64_t v11 = (const UInt8 *)malloc_type_malloc(packed_size, 0x9CA5D51uLL);
    chunkserver__clone_complete_request__pack(v9, (uint64_t)v11);
    CFDataRef v12 = XCFDataCreateWithBytesNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v11, packed_size, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
    free(v9);
  }
  else
  {
    CFDataRef v12 = 0;
  }
  chunkserver__method_completion_info_list__free_unpacked(MethocCompletionInfoList, 0);
  mmcs_free_FileChunkLists(v6);
  return v12;
}

char *_copy_methodCompletionInfoToList_0(void **a1, uint64_t a2)
{
  BOOL result = Copy_MethodCompletionInfo(a1);
  if (result)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    uint64_t v4 = *(void *)(a2 + 32);
    *(void *)(a2 + 24) = v5 + 1;
    *(void *)(v4 + 8 * v5) = result;
  }
  return result;
}

uint64_t mmcs_storage_container_init(uint64_t a1, char *__s1, const char *a3, uint64_t a4)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)a1 = strdup(__s1);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 40) = a4;
  *(void *)(a1 + 24) = 0;
  if (!a4
    || (uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 104 * a4, 0x1060040917B5EB5uLL),
        (*(void *)(a1 + 32) = result) != 0))
  {
    if (a3) {
      *(void *)(a1 + 16) = strdup(a3);
    }
    return 1;
  }
  return result;
}

BOOL mmcs_storage_container_has_storage_key(const char **a1, const char *a2)
{
  return strcmp(*a1, a2) == 0;
}

uint64_t mmcs_storage_container_create(void *a1, char *a2, const char *a3, uint64_t a4)
{
  *a1 = 0;
  uint64_t result = (uint64_t)malloc_type_malloc(0x30uLL, 0x1070040E3208243uLL);
  if (result)
  {
    uint64_t v9 = (void *)result;
    if (mmcs_storage_container_init(result, a2, a3, a4))
    {
      *a1 = v9;
      return 1;
    }
    else
    {
      free(v9);
      return 0;
    }
  }
  return result;
}

void mmcs_storage_container_finalize(void **a1)
{
  unint64_t v2 = *a1;
  if (v2) {
    free(v2);
  }
  *a1 = 0;
  uint64_t v3 = a1[1];
  if (v3) {
    CFRelease(v3);
  }
  a1[1] = 0;
  mmcs_storage_container_cleanup_instances((uint64_t)a1);
  uint64_t v4 = a1[2];
  if (v4) {
    free(v4);
  }
  a1[2] = 0;
}

void mmcs_storage_container_cleanup_instances(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    if (!*(void *)(a1 + 40)) {
      goto LABEL_6;
    }
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    do
    {
      mmcs_chunk_instance_finalize((void *)(*(void *)(a1 + 32) + v3));
      ++v4;
      v3 += 104;
    }
    while (v4 < *(void *)(a1 + 40));
    unint64_t v2 = *(void **)(a1 + 32);
    if (v2) {
LABEL_6:
    }
      free(v2);
    *(void *)(a1 + 32) = 0;
  }
  *(void *)(a1 + 40) = 0;
}

void mmcs_storage_container_dealloc(void **a1)
{
  mmcs_storage_container_finalize(a1);
  if (a1)
  {
    free(a1);
  }
}

uint64_t mmcs_storage_container_compute_size(uint64_t result, int a2)
{
  unint64_t v2 = (void *)result;
  unint64_t v3 = *(void *)(result + 40);
  if (!a2)
  {
    uint64_t v7 = 0;
    if (!v3) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  if (v3)
  {
    unint64_t v4 = 0;
    uint64_t v5 = 4;
    uint64_t v6 = 56;
    do
    {
      uint64_t result = CKChunkSchemeAndSignatureSize();
      v5 += result + 4;
      ++v4;
      unint64_t v3 = v2[5];
      v6 += 104;
    }
    while (v4 < v3);
  }
  else
  {
    uint64_t v5 = 4;
  }
  uint64_t v7 = v2[3] + v5;
  if (v3)
  {
LABEL_10:
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      uint64_t result = mmcs_chunk_instance_get_length((CFDataRef *)(v2[4] + v8));
      v7 += result;
      ++v9;
      v8 += 104;
    }
    while (v9 < v2[5]);
  }
LABEL_12:
  v2[3] = v7;
  return result;
}

void mmcs_storage_container_set_message_digest(void *a1, CFTypeRef cf)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (gMMCS_DebugLevel >= 4)
  {
    unint64_t v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"container %s set message digest %@", *a1, cf);
      uint64_t v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v9 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
  }
  CFTypeRef v7 = (CFTypeRef)a1[1];
  if (v7 != cf)
  {
    if (v7) {
      CFRelease(v7);
    }
    a1[1] = cf;
    if (cf) {
      CFRetain(cf);
    }
  }
}

void *mmcs_epilogue_buffer_init(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = a2;
  result[1] = a3;
  result[2] = 0;
  return result;
}

uint64_t mmcs_epilogue_buffer_send(uint64_t result, uint64_t a2, unint64_t a3, void *a4, unint64_t *a5)
{
  unint64_t v5 = *(void *)(result + 8);
  uint64_t v6 = *(void *)(result + 16);
  if (v6 + a3 > v5) {
    uint64_t v7 = a3 - v5 + v6;
  }
  else {
    uint64_t v7 = 0;
  }
  BOOL v8 = a3 >= v5;
  unint64_t v9 = a3 - v5;
  if (!v8)
  {
    uint64_t v6 = v7;
    unint64_t v9 = 0;
  }
  if (a4) {
    *a4 = v6;
  }
  if (a5) {
    *a5 = v9;
  }
  return result;
}

void *mmcs_epilogue_buffer_append(uint64_t a1, uint64_t a2, size_t a3)
{
  size_t v3 = a3;
  size_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 16);
  size_t v8 = v6 - a3;
  if (v6 > a3 && v7 + a3 > v6)
  {
    memmove(*(void **)a1, (const void *)(*(void *)a1 + v7 - v8), v8);
    *(void *)(a1 + 16) = v8;
    size_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = v8;
  }
  size_t v10 = v3 - v6;
  if (v3 >= v6)
  {
    uint64_t v11 = 0;
  }
  else
  {
    size_t v10 = 0;
    uint64_t v11 = v7;
  }
  if (v6 < v3) {
    size_t v3 = v6;
  }
  uint64_t result = memcpy((void *)(*(void *)a1 + v11), (const void *)(a2 + v10), v3);
  *(void *)(a1 + 16) = v11 + v3;
  return result;
}

uint64_t mmcs_epilogue_buffer_length(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

double opaque__file_reference_data__v1__chunk__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 32) = xmmword_1E6C34008;
  *(_OWORD *)(a1 + 48) = unk_1E6C34018;
  *(_OWORD *)(a1 + 64) = xmmword_1E6C34028;
  *(void *)(a1 + 80) = 0;
  double result = *(double *)&opaque__file_reference_data__v1__chunk__init_init_value;
  *(_OWORD *)a1 = opaque__file_reference_data__v1__chunk__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C33FF8;
  return result;
}

double opaque__file_reference_data__v1__init(_OWORD *a1)
{
  *a1 = opaque__file_reference_data__v1__init_init_value;
  a1[1] = *(_OWORD *)algn_1E6C34050;
  double result = 0.0;
  a1[2] = xmmword_1E6C34060;
  a1[3] = unk_1E6C34070;
  return result;
}

double opaque__file_reference_data__v2__chunk_group__chunk__init(_OWORD *a1)
{
  *a1 = opaque__file_reference_data__v2__chunk_group__chunk__init_init_value;
  a1[1] = *(_OWORD *)algn_1E6C34090;
  double result = 0.0;
  a1[2] = xmmword_1E6C340A0;
  a1[3] = unk_1E6C340B0;
  return result;
}

double opaque__file_reference_data__v2__chunk_group__init(uint64_t a1)
{
  *(_OWORD *)a1 = opaque__file_reference_data__v2__chunk_group__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)algn_1E6C340D0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C340E0;
  *(void *)(a1 + 48) = 0;
  return result;
}

double opaque__file_reference_data__v2__init(uint64_t a1)
{
  *(_OWORD *)a1 = opaque__file_reference_data__v2__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C34108;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C34118;
  *(void *)(a1 + 48) = 0;
  return result;
}

double opaque__file_reference_data__v3__chunk__init(_OWORD *a1)
{
  *a1 = opaque__file_reference_data__v3__chunk__init_init_value;
  a1[1] = unk_1E6C34140;
  double result = 0.0;
  a1[2] = xmmword_1E6C34150;
  a1[3] = unk_1E6C34160;
  return result;
}

double opaque__file_reference_data__v3__chunk_length_index_set__index_range__init(uint64_t a1)
{
  double result = *(double *)&opaque__file_reference_data__v3__chunk_length_index_set__index_range__init_init_value;
  *(_OWORD *)a1 = opaque__file_reference_data__v3__chunk_length_index_set__index_range__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C34180;
  *(void *)(a1 + 32) = 0;
  return result;
}

double opaque__file_reference_data__v3__chunk_length_index_set__init(uint64_t a1)
{
  *(_OWORD *)a1 = opaque__file_reference_data__v3__chunk_length_index_set__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C341A8;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C341B8;
  *(void *)(a1 + 48) = 0;
  return result;
}

double opaque__file_reference_data__v3__init(uint64_t a1)
{
  *(_OWORD *)(a1 + 32) = xmmword_1E6C341F0;
  *(_OWORD *)(a1 + 48) = unk_1E6C34200;
  *(void *)(a1 + 64) = 0;
  double result = dbl_1E6C341E0[0];
  *(_OWORD *)a1 = opaque__file_reference_data__v3__init_init_value;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)dbl_1E6C341E0;
  return result;
}

double opaque__file_reference_data__ranged_item__init(uint64_t a1)
{
  *(_OWORD *)a1 = opaque__file_reference_data__ranged_item__init_init_value;
  *(_OWORD *)(a1 + 16) = unk_1E6C34228;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = xmmword_1E6C34238;
  *(void *)(a1 + 48) = 0;
  return result;
}

double opaque__file_reference_data__init(_OWORD *a1)
{
  *a1 = opaque__file_reference_data__init_init_value;
  a1[1] = unk_1E6C34260;
  double result = 0.0;
  a1[2] = xmmword_1E6C34270;
  a1[3] = unk_1E6C34280;
  return result;
}

uint64_t opaque__file_reference_data__get_packed_size(void **a1)
{
  if (*a1 != &opaque__file_reference_data__descriptor) {
    opaque__file_reference_data__get_packed_size_cold_1();
  }
  return protobuf_c_message_get_packed_size((uint64_t)a1);
}

uint64_t opaque__file_reference_data__pack(void **a1, uint64_t a2)
{
  if (*a1 != &opaque__file_reference_data__descriptor) {
    opaque__file_reference_data__pack_cold_1();
  }
  return protobuf_c_message_pack((uint64_t)a1, a2);
}

void *opaque__file_reference_data__unpack(uint64_t (**a1)(), unint64_t a2, char *a3)
{
  return protobuf_c_message_unpack((uint64_t)&opaque__file_reference_data__descriptor, a1, a2, a3);
}

void **opaque__file_reference_data__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &opaque__file_reference_data__descriptor) {
      opaque__file_reference_data__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

uint64_t mmcs_storage_container_stream_create(uint64_t result, uint64_t a2, uint64_t a3, char a4)
{
  if (result)
  {
    uint64_t v7 = (void *)result;
    *(void *)double result = 0;
    double result = (uint64_t)malloc_type_calloc(1uLL, 0x70uLL, 0x1060040E30FB482uLL);
    if (result)
    {
      size_t v8 = (void *)result;
      if (mmcs_storage_container_stream_init(result, a2, a3, a4))
      {
        *uint64_t v7 = v8;
        return 1;
      }
      else
      {
        mmcs_storage_container_stream_dealloc(v8);
        return 0;
      }
    }
  }
  return result;
}

uint64_t mmcs_storage_container_stream_init(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t result = 0;
  if (a1 && a2 && a3)
  {
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)a1 = 0u;
    *(void *)a1 = a2;
    *(void *)(a1 + 8) = a3;
    *(unsigned char *)(a1 + 48) = a4;
    *(unsigned char *)(a1 + 96) = 0;
    uint64_t result = (uint64_t)malloc_type_malloc(0x5CuLL, 0x100004034A301B9uLL);
    *(void *)(a1 + 16) = result;
    if (result)
    {
      mmcs_storage_container_stream_reset(a1);
      return 1;
    }
  }
  return result;
}

void mmcs_storage_container_stream_dealloc(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  unint64_t v2 = (void *)a1[2];
  if (v2) {
    free(v2);
  }
  a1[2] = 0;
  mmcs_storage_container_stream_clear_item_reader_cache((uint64_t)a1);
  size_t v3 = (void *)a1[5];
  if (v3) {
    free(v3);
  }
  a1[5] = 0;
  unint64_t v4 = (const void *)a1[13];
  if (v4) {
    CFRelease(v4);
  }
  a1[13] = 0;
  unint64_t v5 = (const void *)a1[10];
  if (v5) {
    C3BaseRelease(v5);
  }
  free(a1);
}

uint64_t mmcs_storage_container_stream_reset(uint64_t a1)
{
  unint64_t v2 = *(CC_MD5_CTX **)(a1 + 16);
  if (!v2) {
    mmcs_storage_container_stream_reset_cold_1();
  }
  CC_MD5_Init(v2);
  mmcs_storage_container_set_message_digest(*(void **)(a1 + 8), 0);
  mmcs_storage_container_stream_clear_item_reader_cache(a1);
  size_t v3 = *(void **)(a1 + 40);
  if (v3) {
    free(v3);
  }
  *(void *)(a1 + 40) = 0;
  if (!*(unsigned char *)(a1 + 48)) {
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 8) + 40);
  }
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  unint64_t v4 = *(const void **)(a1 + 104);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 104) = 0;
  unint64_t v5 = *(const void **)(a1 + 80);
  if (v5) {
    C3BaseRelease(v5);
  }
  *(void *)(a1 + 80) = 0;
  return 1;
}

uint64_t mmcs_storage_container_set_should_write_payload_trailer(uint64_t result, char a2)
{
  *(unsigned char *)(result + 96) = a2;
  return result;
}

void mmcs_storage_container_stream_clear_item_reader_cache(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    MMCSItemReaderWriterEnsureClosed(v2);
    size_t v3 = *(const void **)(a1 + 24);
    if (v3) {
      C3BaseRelease(v3);
    }
    *(void *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 32) = -1;
}

uint64_t mmcs_storage_container_stream_read(uint64_t *a1, CFDataRef theData, size_t a3, CFErrorRef *a4, unsigned char *a5)
{
  size_t v5 = a3;
  uint64_t v209 = *MEMORY[0x1E4F143B8];
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  uint64_t v8 = 0;
  if (!a1 || !theData || !a3) {
    return v8;
  }
  CFIndex Length = CFDataGetLength(theData);
  unint64_t v9 = a1[7];
  uint64_t v10 = a1[1];
  unint64_t v11 = *(void *)(v10 + 40);
  if (v9 >= v11)
  {
LABEL_18:
    unint64_t v14 = v9;
  }
  else
  {
    *(_DWORD *)bytes = 0;
    while (1)
    {
      uint64_t v12 = *(void *)(v10 + 32);
      uint64_t v13 = CKChunkSchemeAndSignatureSize();
      unint64_t v14 = a1[7];
      uint64_t v15 = v14 ? 4 : 8;
      unint64_t v16 = v15 + v13;
      size_t v17 = v5 - v16;
      if (v5 < v16) {
        break;
      }
      if (!v14)
      {
        *(_DWORD *)bytes = bswap32(*(_DWORD *)(a1[1] + 40));
        CFDataAppendBytes(theData, bytes, 4);
      }
      uint64_t v18 = *(const UInt8 **)(*(void *)(v12 + 104 * v9 + 56) + 8);
      CFIndex v19 = CKChunkSchemeAndSignatureSize();
      CFDataAppendBytes(theData, v18, v19);
      *(_DWORD *)bytes = 0;
      *(_DWORD *)bytes = bswap32(*(_DWORD *)(v12 + 104 * v9 + 64));
      CFDataAppendBytes(theData, bytes, 4);
      unint64_t v9 = a1[7] + 1;
      a1[7] = v9;
      uint64_t v10 = a1[1];
      unint64_t v11 = *(void *)(v10 + 40);
      size_t v5 = v17;
      if (v9 >= v11)
      {
        size_t v5 = v17;
        goto LABEL_18;
      }
    }
    unint64_t v11 = *(void *)(a1[1] + 40);
  }
  CFIndex v20 = Length;
  if (v14 < v11)
  {
    BOOL v21 = 0;
LABEL_27:
    CFErrorRef v31 = 0;
LABEL_28:
    CFIndex v33 = CFDataGetLength(theData);
    CC_LONG v34 = v33 - v20;
    if (v33 - v20 >= 1)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(theData);
      CC_MD5_Update((CC_MD5_CTX *)a1[2], &MutableBytePtr[v20], v34);
      if (v21)
      {
        CFStringRef v36 = (unsigned __int8 *)malloc_type_calloc(1uLL, 0x10uLL, 0x6F13B60BuLL);
        CC_MD5_Final(v36, (CC_MD5_CTX *)a1[2]);
        size_t v37 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
        {
          uint64_t v38 = hextostrdup((char *)v36, 0x10uLL);
          uint64_t v39 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)bytes = 136446210;
            *(void *)&bytes[4] = v38;
            _os_log_impl(&dword_1DC1CA000, v39, OS_LOG_TYPE_INFO, "client computed container md5 %{public}s", bytes, 0xCu);
          }
          if (v38) {
            free(v38);
          }
        }
        CFDataRef v40 = XCFDataCreateWithBytesNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v36, 16, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
        mmcs_storage_container_set_message_digest((void *)a1[1], v40);
        if (v40) {
          CFRelease(v40);
        }
      }
    }
    char v41 = 0;
    uint64_t v8 = 1;
    goto LABEL_38;
  }
  item_signature_chunk_signature_error_with_CFPropertyListFormat format = 0;
  BOOL v21 = a1[8] >= v11;
  if (!v5) {
    goto LABEL_27;
  }
  if (mmcs_request_is_container_interrupted_mode(***(void ***)(*a1 + 88)))
  {
    uint64_t v27 = a1[11];
    double v28 = (double)(unint64_t)(CFDataGetLength(theData) + v27);
    if ((double)(unint64_t)mmcs_request_index(*(void *)(*(void *)(*a1 + 88) + 8)) * 0.1 < v28)
    {
      CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Simulate a container failure after making around 10 percent progress.", v22, v23, v24, v25, v26, v180);
      item_signature_chunk_signature_error_with_CFPropertyListFormat format = error;
      if (!error) {
        goto LABEL_216;
      }
LABEL_26:
      CFRetain(error);
      char v30 = 1;
      CFErrorRef v31 = item_signature_chunk_signature_error_with_format;
      CFIndex v32 = item_signature_chunk_signature_error_with_format;
      goto LABEL_187;
    }
  }
  unint64_t v53 = a1[8];
  uint64_t v54 = a1[1];
  if (v53 >= *(void *)(v54 + 40))
  {
LABEL_186:
    CFErrorRef v31 = 0;
    char v30 = 0;
    BOOL v21 = (unint64_t)a1[8] >= *(void *)(a1[1] + 40);
    CFIndex v32 = item_signature_chunk_signature_error_with_format;
LABEL_187:
    if (v32) {
      CFRelease(v32);
    }
    if (v30)
    {
      uint64_t v8 = 0;
      goto LABEL_217;
    }
    CFIndex v20 = Length;
    goto LABEL_28;
  }
  BOOL v185 = a1 + 3;
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  BOOL v181 = v21;
  while (1)
  {
    uint64_t v55 = *(void *)(v54 + 32);
    __int16 v56 = (_DWORD *)(v55 + 104 * v53);
    if (mmcs_chunk_instance_is_chunk_reference(v56) && !a1[10]) {
      a1[10] = mmcs_chunk_instance_chunk_coder_create(v55 + 104 * v53, 1);
    }
    CFIndex v57 = CFDataGetLength(theData);
    uint64_t v191 = v55;
    v192 = (_DWORD *)(v55 + 104 * v53);
    if (*v56 == 2)
    {
      CFIndex v65 = v57;
      item_signature_chunk_signature_error_with_CFPropertyListFormat format = 0;
      uint64_t v66 = *(void *)(a1[1] + 32);
      uint64_t v67 = a1[8];
      if (gMMCS_DebugLevel >= 6)
      {
        CFStringRef v68 = mmcs_chunk_instance_copy_description(v66 + 104 * v67);
        if (gMMCS_DebugLevel >= 5)
        {
          int v69 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
          {
            char v180 = (char)v68;
            CFStringRef cfa = CFStringCreateWithFormat(alloc, 0, @"Reading chunk %@ beginning at chunk offset %lu");
            CFDataRef v70 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)bytes = 138543362;
              *(void *)&bytes[4] = cfa;
              _os_log_impl(&dword_1DC1CA000, v70, OS_LOG_TYPE_DEBUG, "%{public}@", bytes, 0xCu);
            }
            if (cfa) {
              CFRelease(cfa);
            }
          }
        }
        if (v68) {
          CFRelease(v68);
        }
      }
      unsigned int v71 = mmcs_chunk_instance_get_length((CFDataRef *)(v66 + 104 * v67));
      unsigned int v72 = v71;
      uint64_t v73 = a1[9];
      if ((unint64_t)v71 - v73 >= v5) {
        size_t v74 = v5;
      }
      else {
        size_t v74 = v71 - v73;
      }
      CFIndex v75 = CFDataGetLength(theData);
      CFDataSetLength(theData, v74 + v75);
      unint64_t v76 = &CFDataGetMutableBytePtr(theData)[v75];
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v66 + 104 * v67 + 80));
      memcpy(v76, &BytePtr[a1[9]], v74);
      v5 -= v74;
      size_t v78 = a1[9] + v74;
      a1[9] = v78;
      BOOL v79 = v78 == v72;
      goto LABEL_135;
    }
    CFTypeRef cf = (CFTypeRef)v57;
    if (*v56 != 1) {
      mmcs_storage_container_stream_read_cold_4();
    }
    item_signature_chunk_signature_error_with_CFPropertyListFormat format = 0;
    CFTypeRef v196 = 0;
    uint64_t v58 = *(void *)(a1[1] + 32);
    uint64_t v187 = a1[8];
    CFStringRef v183 = (void **)(v58 + 104 * v187 + 56);
    uint64_t v186 = (char *)*((void *)*v183 + 1);
    if (gMMCS_DebugLevel >= 6)
    {
      CFStringRef v59 = mmcs_chunk_instance_copy_description(v58 + 104 * v187);
      if (gMMCS_DebugLevel >= 5)
      {
        __int16 v60 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
        {
          char v180 = (char)v59;
          CFStringRef v61 = CFStringCreateWithFormat(alloc, 0, @"Reading chunk %@ beginning at chunk offset %lu");
          __int16 v62 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)bytes = 138543362;
            *(void *)&bytes[4] = v61;
            _os_log_impl(&dword_1DC1CA000, v62, OS_LOG_TYPE_DEBUG, "%{public}@", bytes, 0xCu);
          }
          if (v61) {
            CFRelease(v61);
          }
        }
      }
      if (v59) {
        CFRelease(v59);
      }
    }
    if (a1[5])
    {
      CKRegisteredChunkSignature();
      char v63 = CKChunkSignaturesEqual();
      uint64_t v64 = (void *)a1[5];
      if (v63)
      {
        if (v64) {
          goto LABEL_99;
        }
      }
      else
      {
        if (v64) {
          free(v64);
        }
        a1[5] = 0;
      }
    }
    uint64_t v80 = ***(void ***)(*a1 + 88);
    uint64_t v184 = mmcs_chunk_instance_offset(v80);
    CFTypeRef v196 = 0;
    uint64_t v81 = *(void *)(a1[1] + 32);
    uint64_t v82 = a1[8];
    if (!mmcs_chunk_instance_is_chunk_reference((_DWORD *)(v81 + 104 * v82))) {
      mmcs_storage_container_stream_read_cold_5();
    }
    uint64_t v83 = *(void *)(v81 + 104 * v82 + 56);
    uint64_t v84 = *(char **)(v83 + 8);
    if (!mmcs_chunk_reference_get_first_chunk_instance(v83)) {
      mmcs_storage_container_stream_read_cold_6();
    }
    uint64_t RegisteredChunk = mmcs_chunk_instance_create_RegisteredChunk();
    a1[5] = RegisteredChunk;
    if (!RegisteredChunk)
    {
      uint64_t v107 = mmcs_chunk_signature_to_hexstring(v84);
      uint64_t v108 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v114 = CFStringCreateWithFormat(alloc, 0, @"unable to create chunk for chunk signature %s", v107);
        uint64_t v115 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)bytes = 138543362;
          *(void *)&bytes[4] = v114;
          _os_log_impl(&dword_1DC1CA000, v115, OS_LOG_TYPE_ERROR, "%{public}@", bytes, 0xCu);
        }
        if (v114) {
          CFRelease(v114);
        }
      }
      error_with_underlying_CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, @"unable to allocate chunk signature %s", v109, v110, v111, v112, v113, (char)v107);
      if (v107) {
        free(v107);
      }
      goto LABEL_126;
    }
    CKRegisteredChunkSetLocation();
    if (*v185)
    {
      uint64_t v86 = a1[4];
      if (v86 == CKRegisteredChunkItemID()) {
        goto LABEL_99;
      }
    }
    mmcs_storage_container_stream_clear_item_reader_cache((uint64_t)a1);
    CFTypeRef v197 = 0;
    uint64_t v87 = mmcs_engine_owner(v184);
    uint64_t requestor = mmcs_request_get_requestor(v80);
    uint64_t v89 = CKRegisteredChunkItemID();
    if (!mmcs_engine_get_item_reader_writer_for_item_callback(v184, v87, requestor, v89, v185, &v197)
      || !*v185
      || !MMCSItemReaderWriterOpen(*v185, &v197))
    {
      uint64_t v117 = mmcs_chunk_signature_to_hexstring(v84);
      uint64_t v118 = (void *)v197;
      char v119 = CKRegisteredChunkItemID();
      error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 9, v118, @"Unable to open item %lld while looking for chunk %s", v120, v121, v122, v123, v119);
      if (v117) {
        free(v117);
      }
      if (v197) {
        CFRelease(v197);
      }
      CFTypeRef v197 = 0;
      CFStringRef v124 = mmcs_cferror_copy_description(error_with_underlying_error);
      int v125 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
      {
        char v180 = (char)v124;
        CFStringRef v126 = CFStringCreateWithFormat(alloc, 0, @"An error occurred: %@");
        int v127 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)bytes = 138543362;
          *(void *)&bytes[4] = v126;
          _os_log_impl(&dword_1DC1CA000, v127, OS_LOG_TYPE_ERROR, "%{public}@", bytes, 0xCu);
        }
        if (v126) {
          CFRelease(v126);
        }
      }
      if (v124) {
        CFRelease(v124);
      }
      mmcs_storage_container_stream_clear_item_reader_cache((uint64_t)a1);
LABEL_126:
      uint64_t v128 = (void *)a1[5];
      if (v128) {
        free(v128);
      }
      a1[5] = 0;
      CFRetain(error_with_underlying_error);
      CFTypeRef v196 = error_with_underlying_error;
      if (error_with_underlying_error)
      {
        CFRelease(error_with_underlying_error);
        goto LABEL_130;
      }
LABEL_131:
      CFSetRef v129 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Unknown error in mmcs_storage_container_stream_read_chunk_data", v95, v96, v97, v98, v99, v180);
      CFTypeRef v196 = v129;
LABEL_132:
      CFRetain(v129);
      BOOL v79 = 0;
      CFTypeRef v130 = v196;
      item_signature_chunk_signature_error_with_CFPropertyListFormat format = (__CFError *)v196;
      char v131 = 1;
      CFIndex v65 = (CFIndex)cf;
      if (!v196) {
        goto LABEL_134;
      }
LABEL_133:
      CFRelease(v130);
      goto LABEL_134;
    }
    if (!*v185) {
      mmcs_storage_container_stream_read_cold_7();
    }
    a1[4] = CKRegisteredChunkItemID();
LABEL_99:
    if (a1[9] < (unint64_t)CKRegisteredChunkLength())
    {
      unint64_t v90 = v5;
      if ((unint64_t)CKRegisteredChunkLength() - a1[9] < v5) {
        unint64_t v90 = CKRegisteredChunkLength() - a1[9];
      }
      CFIndex v91 = CFDataGetLength(theData);
      CFDataSetLength(theData, v91 + v90);
      uint64_t v92 = &CFDataGetMutableBytePtr(theData)[v91];
      *(void *)bytes = 0;
      uint64_t v93 = a1[3];
      uint64_t v94 = CKRegisteredChunkOffset();
      if (!MMCSItemReaderWriterRead(v93, a1[9] + v94, (uint64_t)v92, v90, (uint64_t)bytes, (CFErrorRef *)&v196))goto LABEL_130; {
      if (*(void *)bytes < v90)
      }
      {
        uint64_t v100 = mmcs_chunk_signature_to_hexstring(v186);
        char v101 = CKRegisteredChunkItemID();
        CKRegisteredChunkOffset();
        CFTypeRef v196 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 12, @"Short read of item %lld: while looking for chunk %s (read:%llu, expected:%lu, offset:%lld)", v102, v103, v104, v105, v106, v101);
        if (v100) {
          free(v100);
        }
LABEL_130:
        CFSetRef v129 = v196;
        if (!v196) {
          goto LABEL_131;
        }
        goto LABEL_132;
      }
      v5 -= v90;
      a1[9] += v90;
      uint64_t request = mmcs_put_container_get_request(*a1);
      mmcs_put_container_chunk_reference_was_read((uint64_t **)*a1, request, *v183, v90);
    }
    unsigned int v151 = CKRegisteredChunkLength();
    unint64_t v152 = a1[9];
    CFIndex v65 = (CFIndex)cf;
    if (v152 >= v151)
    {
      unint64_t v153 = *(unsigned int *)(v58 + 104 * v187 + 64) - v152;
      if (v153 >= v5) {
        size_t v154 = v5;
      }
      else {
        size_t v154 = v153;
      }
      CFIndex v155 = CFDataGetLength(theData);
      CFDataSetLength(theData, v154 + v155);
      long long v156 = CFDataGetMutableBytePtr(theData);
      bzero(&v156[v155], v154);
      v5 -= v154;
      unint64_t v152 = a1[9] + v154;
      a1[9] = v152;
    }
    char v131 = 0;
    BOOL v79 = v152 == *(_DWORD *)(v58 + 104 * v187 + 64);
    CFTypeRef v130 = v196;
    if (v196) {
      goto LABEL_133;
    }
LABEL_134:
    if (v131) {
      goto LABEL_214;
    }
LABEL_135:
    uint64_t v132 = CFDataGetLength(theData) - v65;
    if (v132 >= 1)
    {
      CFDataGetMutableBytePtr(theData);
      if (a1[10] && !CKChunkCoderUpdate())
      {
        CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 22, @"Chunk stream update error");
        item_signature_chunk_signature_error_with_CFPropertyListFormat format = error;
        goto LABEL_215;
      }
      a1[11] += v132;
    }
    if (!v79)
    {
      if (v5)
      {
        long long v165 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v166 = CFStringCreateWithFormat(alloc, 0, @"The chunk isn't done and the buffer isn't full.");
          long long v167 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)bytes = 138543362;
            *(void *)&bytes[4] = v166;
            _os_log_impl(&dword_1DC1CA000, v167, OS_LOG_TYPE_ERROR, "%{public}@", bytes, 0xCu);
          }
          if (v166) {
            CFRelease(v166);
          }
        }
      }
      goto LABEL_186;
    }
    if (a1[10]) {
      break;
    }
LABEL_144:
    a1[10] = 0;
    if (mmcs_chunk_instance_is_chunk_reference(v192))
    {
      uint64_t v139 = v191 + 104 * v53;
      uint64_t v141 = *(void *)(v139 + 56);
      uint64_t v140 = v139 + 56;
      mmcs_put_container_chunk_reference_was_put(*a1, v141);
      if (gMMCS_DebugLevel >= 4)
      {
        uint64_t v142 = mmcs_chunk_signature_to_hexstring(*(char **)(*(void *)v140 + 8));
        long long v143 = mmcs_logging_logger_chunk();
        if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v144 = a1[8] + 1;
          uint64_t v145 = a1[1];
          uint64_t v146 = *(void *)(v145 + 40);
          uint64_t v147 = v191 + 104 * v53;
          uint64_t v148 = *(void *)(v147 + 32);
          uint64_t v149 = *(void *)(v145 + 24);
          LODWORD(v147) = *(_DWORD *)(v147 + 64);
          *(_DWORD *)bytes = 134219266;
          *(void *)&bytes[4] = v144;
          __int16 v199 = 2048;
          uint64_t v200 = v146;
          __int16 v201 = 2048;
          uint64_t v202 = v148;
          __int16 v203 = 2048;
          uint64_t v204 = v149;
          __int16 v205 = 1024;
          int v206 = v147;
          __int16 v207 = 2082;
          unint64_t v208 = v142;
          _os_log_impl(&dword_1DC1CA000, v143, OS_LOG_TYPE_DEFAULT, "Chunk %lu of %zu at containerOffset %llu of %llu with byteLength %u and signature %{public}s sent.", bytes, 0x3Au);
        }
        if (v142) {
          free(v142);
        }
      }
    }
    unint64_t v53 = a1[8] + 1;
    a1[8] = v53;
    a1[9] = 0;
    uint64_t v54 = a1[1];
    if (v53 >= *(void *)(v54 + 40)) {
      goto LABEL_186;
    }
  }
  if (CKChunkCoderFinish())
  {
    CFStringRef v138 = (const void *)a1[10];
    if (v138) {
      C3BaseRelease(v138);
    }
    goto LABEL_144;
  }
  CFStringRef v169 = item_signature_chunk_signature_error_with_format;
  uint64_t v170 = (const void *)a1[10];
  if (v170) {
    C3BaseRelease(v170);
  }
  a1[10] = 0;
  if (a1[5])
  {
    v171 = (void *)CKRegisteredChunkSignatureCopyCString();
    uint64_t v172 = CKRegisteredChunkItemID();
    unint64_t v173 = (const UInt8 *)CKRegisteredChunkSignature();
    CKRegisteredChunkItemID();
    item_signature_chunk_signature_error_with_CFPropertyListFormat format = mmcs_cferror_create_item_signature_chunk_signature_error_with_format(@"com.apple.mmcs", 11, v172, 0, v173, item_signature_chunk_signature_error_with_format, @"The container content is incorrect. Any items contributing will need to be retried. The data for chunk %s provided by item %lld did not match.", v174, (char)v171);
    uint64_t v175 = mmcs_put_container_get_request(*a1);
    mmcs_chunk_instance_offset(v175);
    uint64_t v176 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v177 = CKRegisteredChunkItemID();
      CFStringRef v178 = CFStringCreateWithFormat(alloc, 0, @"Unregistering item %lld which had a bogus chunk %s", v177, v171);
      CFStringRef v179 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v179, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)bytes = 138543362;
        *(void *)&bytes[4] = v178;
        _os_log_impl(&dword_1DC1CA000, v179, OS_LOG_TYPE_DEFAULT, "%{public}@", bytes, 0xCu);
      }
      if (v178) {
        CFRelease(v178);
      }
    }
    CKRegisteredChunkItemID();
    CKUnregisterFile();
    if (v171) {
      free(v171);
    }
  }
  else
  {
    item_signature_chunk_signature_error_with_CFPropertyListFormat format = mmcs_cferror_create_with_format(@"com.apple.mmcs", 11, @"The container content is incorrect. Any items contributing will need to be retried. It is not known which chunk was responsible", v133, v134, v135, v136, v137, v180);
  }
  if (v169) {
    CFRelease(v169);
  }
LABEL_214:
  CFErrorRef error = item_signature_chunk_signature_error_with_format;
LABEL_215:
  BOOL v21 = v181;
  if (error) {
    goto LABEL_26;
  }
LABEL_216:
  uint64_t v8 = 0;
  CFErrorRef v31 = 0;
LABEL_217:
  char v41 = 1;
LABEL_38:
  uint64_t v42 = a4;
  if (!*((unsigned char *)a1 + 96))
  {
LABEL_175:
    if (!a5 || !v8 || !v21) {
      goto LABEL_194;
    }
    uint64_t v8 = 1;
    *a5 = 1;
    goto LABEL_197;
  }
  if (v21) {
    int v43 = v8;
  }
  else {
    int v43 = 0;
  }
  if (v43 != 1)
  {
    if ((v41 & 1) == 0)
    {
      CFDataRef put_complete_at_edge_payload_trailer = (CFDataRef)a1[13];
      goto LABEL_161;
    }
    uint64_t v8 = 0;
    goto LABEL_194;
  }
  CFDataRef put_complete_at_edge_payload_trailer = (CFDataRef)a1[13];
  if (put_complete_at_edge_payload_trailer)
  {
LABEL_161:
    uint64_t v8 = 1;
    if (!put_complete_at_edge_payload_trailer || !v5) {
      goto LABEL_197;
    }
    if (a1[8] != *(void *)(a1[1] + 40)) {
      mmcs_storage_container_stream_read_cold_1();
    }
    if (gMMCS_DebugLevel >= 6)
    {
      long long v157 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v157, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v158 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Reading payload trailer at offset %lu", a1[9]);
        long long v159 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v159, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)bytes = 138543362;
          *(void *)&bytes[4] = v158;
          _os_log_impl(&dword_1DC1CA000, v159, OS_LOG_TYPE_DEBUG, "%{public}@", bytes, 0xCu);
        }
        if (v158) {
          CFRelease(v158);
        }
      }
    }
    unint64_t v160 = CFDataGetLength((CFDataRef)a1[13]);
    unint64_t v161 = a1[9];
    if (v160 > v161)
    {
      if (v160 - v161 < v5) {
        size_t v5 = v160 - v161;
      }
      CFIndex v162 = CFDataGetLength(theData);
      CFDataSetLength(theData, v162 + v5);
      long long v163 = &CFDataGetMutableBytePtr(theData)[v162];
      long long v164 = CFDataGetBytePtr((CFDataRef)a1[13]);
      memcpy(v163, &v164[a1[9]], v5);
      unint64_t v161 = a1[9] + v5;
      a1[9] = v161;
      a1[11] += v5;
    }
    BOOL v21 = v161 >= CFDataGetLength((CFDataRef)a1[13]);
    uint64_t v8 = 1;
    uint64_t v42 = a4;
    goto LABEL_175;
  }
  if (a1[9]) {
    mmcs_storage_container_stream_read_cold_3();
  }
  CFErrorRef v45 = (void *)a1[1];
  if (a1[8] != v45[5]) {
    mmcs_storage_container_stream_read_cold_2();
  }
  uint64_t v8 = v45[1];
  if (v8)
  {
    CFStringRef v46 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
    {
      uint64_t v47 = *(void *)a1[1];
      *(_DWORD *)bytes = 136315138;
      *(void *)&bytes[4] = v47;
      _os_log_impl(&dword_1DC1CA000, v46, OS_LOG_TYPE_INFO, "Appending Payload Trailer for Container (%s)", bytes, 0xCu);
    }
    CFDataRef put_complete_at_edge_payload_trailer = mmcs_create_put_complete_at_edge_payload_trailer((const __CFData *)v8, *(const __CFData **)(**(void **)(*a1 + 88) + 48));
    if (put_complete_at_edge_payload_trailer)
    {
      CFErrorRef v31 = 0;
      a1[13] = (uint64_t)put_complete_at_edge_payload_trailer;
      goto LABEL_161;
    }
    CFErrorRef v31 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed produce payload trailer for container (%s)", v48, v49, v50, v51, v52, *(void *)a1[1]);
    uint64_t v8 = 0;
  }
  else
  {
    CFErrorRef v31 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Calculated MD5 Not Available for Trailer, Container (%s)", v22, v23, v24, v25, v26, *v45);
  }
  uint64_t v42 = a4;
LABEL_194:
  if (v42 && !v8)
  {
    CFErrorRef *v42 = v31;
    return v8;
  }
LABEL_197:
  if (v31) {
    CFRelease(v31);
  }
  return v8;
}

uint64_t mmcs_perform_run_loop_source_create(void *a1, _OWORD *a2, uint64_t a3, const __CFArray *a4)
{
  *a1 = 0;
  uint64_t v15 = 0;
  long long v7 = a2[1];
  v14[0] = *a2;
  v14[1] = v7;
  uint64_t v8 = mmcs_perform_source_create((uint64_t *)&v15, 1, 8, v14);
  unint64_t v9 = v15;
  if (v8 && v15)
  {
    uint64_t v10 = (CFRunLoopSourceRef *)v15[7];
    v13.version = 0;
    v13.info = v15;
    v13.retain = (const void *(__cdecl *)(const void *))C3BaseRetain;
    v13.release = (void (__cdecl *)(const void *))C3BaseRelease;
    memset(&v13.copyDescription, 0, 40);
    v13.perform = (void (__cdecl *)(void *))mmcs_perform_run_loop_source_perform_callback;
    CFRunLoopSourceRef v11 = CFRunLoopSourceCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &v13);
    CFRunLoopSourceRef *v10 = v11;
    XCFRunLoopAddSourceToModes(a3, (uint64_t)v11, a4);
    C3BaseRetain(v15);
    unint64_t v9 = v15;
    *a1 = v15;
  }
  if (v9) {
    C3BaseRelease(v9);
  }
  return v8;
}

uint64_t mmcs_perform_run_loop_source_perform_callback(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 48))(*(void *)(a1 + 24));
}

void mmcs_perform_run_loop_source_finalize(uint64_t a1)
{
  CFDataRef v1 = *(CFTypeRef **)(a1 + 56);
  if (*v1) {
    CFRelease(*v1);
  }
  CFTypeRef *v1 = 0;
}

void mmcs_perform_run_loop_source_signal(uint64_t a1)
{
}

void mmcs_perform_run_loop_source_invalidate(uint64_t a1)
{
  CFDataRef v1 = *(CFRunLoopSourceRef **)(a1 + 56);
  if (*v1)
  {
    CFRunLoopSourceInvalidate(*v1);
    if (*v1) {
      CFRelease(*v1);
    }
    CFRunLoopSourceRef *v1 = 0;
  }
}

uint64_t get_path_for_fd(int a1, char *a2)
{
  memset(&v8, 0, sizeof(v8));
  int v4 = -5;
  fsid_t v7 = 0;
  while (1)
  {
    if (fstat(a1, &v8) < 0) {
      return 0xFFFFFFFFLL;
    }
    v7.val[1] = 0;
    v7.val[0] = v8.st_dev;
    if ((fsgetpath(a2, 0x400uLL, &v7, v8.st_ino) & 0x8000000000000000) == 0) {
      break;
    }
    if (*__error() != 35 || v4++ == 0) {
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

uint64_t mkdir_recursive(uint64_t a1, mode_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  bzero(path, 0x400uLL);
  if ((unint64_t)__strlcpy_chk() <= 0x3FF)
  {
    uint64_t result = mkpath_np(path, a2);
    int v3 = result;
    if (!result) {
      return result;
    }
  }
  else
  {
    int v3 = 63;
  }
  *__error() = v3;
  return 0xFFFFFFFFLL;
}

unsigned char *hextostrdup(char *a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFFFLL) {
    hextostrdup_cold_1();
  }
  unint64_t v2 = a2;
  uint64_t result = malloc_type_malloc((2 * a2) | 1, 0x7498B422uLL);
  size_t v5 = result;
  if (v2)
  {
    uint64_t v6 = result;
    do
    {
      *uint64_t v6 = hextostr_hexdigits[(unint64_t)*a1 >> 4];
      char v7 = *a1++;
      size_t v5 = v6 + 2;
      v6[1] = hextostr_hexdigits[v7 & 0xF];
      v6 += 2;
      --v2;
    }
    while (v2);
  }
  unsigned char *v5 = 0;
  return result;
}

const char *_getCStringFromCFStringSafely(const __CFString *a1, CFStringEncoding a2, uint64_t a3)
{
  uint64_t result = CFStringGetCStringPtr(a1, a2);
  if (a3)
  {
    if (!result)
    {
      CFIndex Length = CFStringGetLength(a1);
      CFIndex v8 = CFStringGetMaximumSizeForEncoding(Length, a2) + 1;
      unint64_t v9 = (char *)malloc_type_malloc(v8, 0x6AE44FD3uLL);
      *(void *)a3 = v9;
      CFStringGetCString(a1, v9, v8, a2);
      return *(const char **)a3;
    }
  }
  return result;
}

__CFString *createCStringWithCFString(const __CFString *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  int v4 = (char *)malloc_type_malloc(v3, 0x983D037uLL);
  if (v4)
  {
    size_t v5 = (__CFString *)v4;
    if (!CFStringGetCString(a1, v4, v3, 0x8000100u))
    {
      free(v5);
      return 0;
    }
  }
  else
  {
    uint64_t v6 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    size_t v5 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"malloc");
    char v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v9 = 138543362;
      uint64_t v10 = v5;
      _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v9, 0xCu);
    }
    if (v5)
    {
      CFRelease(v5);
      return 0;
    }
  }
  return v5;
}

CFNumberRef mmcs_copy_cfnumber_from_cftype_using_description(uint64_t a1, const __CFString *a2, CFTypeRef cf)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    goto LABEL_23;
  }
  CFTypeID TypeID = CFNumberGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    CFRetain(a2);
    return (CFNumberRef)a2;
  }
  CFTypeID v8 = CFBooleanGetTypeID();
  if (v8 == CFGetTypeID(a2))
  {
    *(void *)uint64_t valuePtr = CFBooleanGetValue((CFBooleanRef)a2);
    return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, valuePtr);
  }
  CFTypeID v9 = CFStringGetTypeID();
  if (v9 != CFGetTypeID(a2))
  {
    CFTypeID v18 = CFGetTypeID(a2);
    CFStringRef v19 = CFCopyTypeIDDescription(v18);
    CFIndex v20 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v21 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unable to recognized type id '%@' for BOOLean decoding for key '%@'.", v19, a1);
      uint64_t v22 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t valuePtr = 138543362;
        *(void *)&valuePtr[4] = v21;
        _os_log_impl(&dword_1DC1CA000, v22, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
      }
      if (v21) {
        CFRelease(v21);
      }
    }
    if (!v19) {
      goto LABEL_23;
    }
    CFStringRef v17 = v19;
LABEL_22:
    CFRelease(v17);
LABEL_23:
    if (!cf) {
      return 0;
    }
    CFRetain(cf);
    return (CFNumberRef)cf;
  }
  CFLocaleRef v10 = CFLocaleCreate(0, @"en_US");
  if (!v10
    || (CFLocaleRef v11 = v10,
        CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
        CFRunLoopSourceContext v13 = CFNumberFormatterCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v10, kCFNumberFormatterNoStyle),
        CFRelease(v11),
        !v13)
    || (NumberFromCFStringRef String = CFNumberFormatterCreateNumberFromString(v12, v13, a2, 0, 1uLL),
        CFRelease(v13),
        !NumberFromString))
  {
    unint64_t v14 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Option %@ had CFStringRef \"%@\" but couldn't parse as a number.", a1, a2);
    unint64_t v16 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t valuePtr = 138543362;
      *(void *)&valuePtr[4] = v15;
      _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_ERROR, "%{public}@", valuePtr, 0xCu);
    }
    if (!v15) {
      goto LABEL_23;
    }
    CFStringRef v17 = v15;
    goto LABEL_22;
  }
  return NumberFromString;
}

CFNumberRef mmcs_copy_cfnumber_from_cfdictionary_object_for_key(const __CFDictionary *a1, void *key, const void *a3)
{
  if (!a1 || !key) {
    return (CFNumberRef)a3;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, key);
  return mmcs_copy_cfnumber_from_cftype_using_description((uint64_t)key, Value, a3);
}

uint64_t mmcs_get_cfindex_from_cftype_using_description(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  CFNumberRef v4 = mmcs_copy_cfnumber_from_cftype_using_description(a1, a2, 0);
  if (v4)
  {
    CFNumberRef v5 = v4;
    uint64_t valuePtr = 0;
    if (!CFNumberGetValue(v4, kCFNumberCFIndexType, &valuePtr)) {
      uint64_t valuePtr = a3;
    }
    CFRelease(v5);
    return valuePtr;
  }
  return a3;
}

CFStringRef mmcs_get_cfBOOLean_from_cfdictionary_object_for_key(const __CFDictionary *a1, void *key, uint64_t a3)
{
  if (!a1 || !key) {
    return (const __CFString *)a3;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, key);
  return mmcs_get_cfBOOLean_from_cftype_using_description((uint64_t)key, Value, a3);
}

uint64_t mmcs_get_BOOLean_from_cfpreferences_object_for_key(const __CFString *a1, uint64_t BOOLean_from_cftype_using_description)
{
  if (a1)
  {
    CFStringRef v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, @"com.apple.mmcs");
    if (v4)
    {
      CFStringRef v5 = v4;
      BOOLean_from_cftype_using_description = mmcs_get_BOOLean_from_cftype_using_description((uint64_t)a1, v4, BOOLean_from_cftype_using_description);
      CFRelease(v5);
    }
  }
  return BOOLean_from_cftype_using_description;
}

uint64_t mmcs_get_cfindex_from_options(const __CFString *a1, const __CFDictionary *a2, uint64_t a3)
{
  CFStringRef v5 = (const __CFString *)mmcs_copy_cftype_from_options_object_for_key(a1, a2, 0);
  uint64_t cfindex_from_cftype_using_description = mmcs_get_cfindex_from_cftype_using_description((uint64_t)a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return cfindex_from_cftype_using_description;
}

CFTypeRef mmcs_copy_cftype_from_options_object_for_key(CFStringRef key, CFDictionaryRef theDict, CFTypeRef cf)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!key) {
    goto LABEL_11;
  }
  if (theDict)
  {
    CFStringRef Value = CFDictionaryGetValue(theDict, key);
    if (Value)
    {
      CFPropertyListRef v6 = Value;
      CFRetain(Value);
      return v6;
    }
  }
  CFPropertyListRef v7 = CFPreferencesCopyAppValue(key, @"com.apple.mmcs");
  if (v7)
  {
    CFPropertyListRef v6 = v7;
    CFTypeID v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Found UserDefaults Override: %@:%@", key, v6);
      CFLocaleRef v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v13 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
  }
  else
  {
LABEL_11:
    if (cf)
    {
      CFRetain(cf);
      return cf;
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

BOOL mmcs_file_signature_is_valid_n(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a1)
  {
    if (a2 == 21) {
      return CKFileSchemeAndSignatureSize() == 21;
    }
  }
  return result;
}

BOOL mmcs_file_signature_is_valid(BOOL result)
{
  if (result) {
    return CKFileSchemeAndSignatureSize() == 21;
  }
  return result;
}

uint64_t mmcs_file_signature_size()
{
  return MEMORY[0x1F41119A8]();
}

const UInt8 *mmcs_file_digest_arguments_create_with_boudnary_key(const UInt8 *result)
{
  if (result)
  {
    CFDataRef v1 = (const __CFData *)result;
    if (CFDataGetLength((CFDataRef)result) != 32) {
      return 0;
    }
    BOOL result = CFDataGetBytePtr(v1);
    if (!result) {
      return result;
    }
    BytePtr = CFDataGetBytePtr(v1);
    if (!mmcs_zcmp((uint64_t)BytePtr, 0x20uLL))
    {
      if (CKFileDigestArgumentsV2WithBoundaryKeyCreate()) {
        return 0;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unsigned char *strtohex(unsigned char *result, unsigned char *a2)
{
  int v2 = *result;
  if (*result)
  {
    int v3 = 0;
    CFStringRef v4 = result + 2;
    do
    {
      int v5 = v2 - 48;
      unsigned int v6 = (v2 - 48);
      unsigned int v7 = (v2 - 97);
      if ((v2 - 65) < 6u) {
        int v3 = v2 - 55;
      }
      int v8 = v2 - 87;
      if (v7 <= 5) {
        int v3 = v8;
      }
      if (v6 < 0xA) {
        int v3 = v5;
      }
      int v9 = 16 * v3;
      int v10 = *(v4 - 1);
      unsigned int v11 = v10 - 48;
      unsigned int v12 = v10 - 97;
      if ((v10 - 65) <= 5) {
        int v13 = (v10 - 55) | v9;
      }
      else {
        int v13 = v9;
      }
      int v14 = (v10 - 87) | v9;
      if (v12 > 5) {
        int v14 = v13;
      }
      int v3 = v11 | v9;
      if (v11 > 9) {
        int v3 = v14;
      }
      *a2++ = v3;
      int v15 = *v4;
      v4 += 2;
      int v2 = v15;
    }
    while (v15);
  }
  return result;
}

uint64_t mmcs_buffer_create_with_hex_string(char *__s, uint64_t *a2, void *a3)
{
  if (a2) {
    *a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  if (!__s) {
    return 0;
  }
  size_t v6 = strlen(__s);
  uint64_t result = 0;
  if (v6)
  {
    if ((v6 & 1) == 0)
    {
      uint64_t result = (uint64_t)malloc_type_malloc(v6 >> 1, 0xD9419E1EuLL);
      if (result)
      {
        uint64_t v8 = result;
        strtohex(__s, (unsigned char *)result);
        if (a2) {
          *a2 = v8;
        }
        if (a3) {
          *a3 = (v6 >> 1);
        }
        return 1;
      }
    }
  }
  return result;
}

CFDataRef mmcs_cfdata_create_with_hexstring(char *a1)
{
  CFIndex v4 = 0;
  int v5 = 0;
  int v1 = mmcs_buffer_create_with_hex_string(a1, (uint64_t *)&v5, &v4);
  CFDataRef result = 0;
  if (v1)
  {
    if (v5) {
      BOOL v3 = v4 == 0;
    }
    else {
      BOOL v3 = 1;
    }
    if (!v3) {
      return CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, v4, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
    }
  }
  return result;
}

unsigned char *mmcs_file_signature_create_with_string(char *a1)
{
  if (!a1 || strlen(a1) > 0x2A) {
    return 0;
  }
  int v2 = malloc_type_malloc(0x15uLL, 0xC0920FFAuLL);
  if (v2)
  {
    strtohex(a1, v2);
    if (CKFileSchemeAndSignatureSize() != 21)
    {
      free(v2);
      return 0;
    }
  }
  return v2;
}

void *mmcs_file_signature_copy(const void *a1)
{
  if (!a1) {
    return 0;
  }
  size_t v2 = CKFileSchemeAndSignatureSize();
  if (!v2) {
    return 0;
  }
  size_t v3 = v2;
  CFIndex v4 = malloc_type_malloc(v2, 0x66A57B2BuLL);
  int v5 = v4;
  if (v4) {
    memcpy(v4, a1, v3);
  }
  return v5;
}

CFDataRef mmcs_file_signature_to_cfdata(const UInt8 *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = CKFileSchemeAndSignatureSize();
  if (!v2) {
    return 0;
  }
  CFIndex v3 = v2;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  return CFDataCreate(v4, a1, v3);
}

unsigned char *mmcs_file_signature_to_hexstring(char *a1)
{
  if (!a1) {
    return 0;
  }
  unint64_t v2 = CKFileSchemeAndSignatureSize();
  if (!v2) {
    return 0;
  }
  return hextostrdup(a1, v2);
}

uint64_t mmcs_file_signature_create_from_file_descriptor(const UInt8 *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    CKFileDigestArgumentsV1WithFileCreate();
LABEL_8:
    if (a3)
    {
      uint64_t v10 = 0;
      *a3 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"failed to create fileDigestArguments", v5, v6, v7, v8, v9, v15);
      return v10;
    }
    return 0;
  }
  CFTypeRef cf = mmcs_file_digest_arguments_create_with_boudnary_key(a1);
  if (!cf) {
    goto LABEL_8;
  }
  if (CK2CalculateFileSignatureWithFlags())
  {
    CKFileDigestResultsFileSignature();
    uint64_t v10 = CKFileSignatureCopy();
    CFRelease(cf);
    return v10;
  }
  unsigned int v11 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"MMCSGetSignatureForFileDescriptor can't calculate file signature for fd (%d)", a2);
    int v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v18 = v12;
      _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v12) {
      CFRelease(v12);
    }
  }
  if (!a3) {
    return 0;
  }
  if (*a3) {
    CFRelease(*a3);
  }
  uint64_t v10 = 0;
  *a3 = 0;
  return v10;
}

BOOL mmcs_chunk_signature_is_valid_n(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a1)
  {
    if ((unint64_t)(a2 - 22) >= 0xFFFFFFFFFFFFFFEBLL) {
      return CKChunkSchemeAndSignatureSize() == 21;
    }
  }
  return result;
}

BOOL mmcs_chunk_signature_is_valid(BOOL result)
{
  if (result) {
    return CKChunkSchemeAndSignatureSize() == 21;
  }
  return result;
}

void *mmcs_chunk_signature_copy(const void *a1)
{
  if (!a1) {
    return 0;
  }
  size_t v2 = CKChunkSchemeAndSignatureSize();
  if (!v2) {
    return 0;
  }
  size_t v3 = v2;
  CFAllocatorRef v4 = malloc_type_malloc(v2, 0x122BD871uLL);
  uint64_t v5 = v4;
  if (v4) {
    memcpy(v4, a1, v3);
  }
  return v5;
}

unsigned char *mmcs_chunk_signature_to_hexstring(char *a1)
{
  if (!a1) {
    return 0;
  }
  unint64_t v2 = CKChunkSchemeAndSignatureSize();
  if (!v2) {
    return 0;
  }
  return hextostrdup(a1, v2);
}

uint64_t mmcs_print_registered_chunk_list(uint64_t result, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    if (gMMCS_DebugLevel >= 4 && a2 != 0)
    {
      uint64_t v4 = result;
      uint64_t v5 = 0;
      do
      {
        uint64_t v6 = (void *)CKRegisteredChunkSignatureCopyCString();
        uint64_t v7 = mmcs_logging_logger_chunk();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = CKRegisteredChunkOffset();
          int v9 = CKRegisteredChunkLength();
          *(_DWORD *)long long buf = 134219010;
          uint64_t v11 = v5 + 1;
          __int16 v12 = 2048;
          uint64_t v13 = a2;
          __int16 v14 = 2048;
          uint64_t v15 = v8;
          __int16 v16 = 1024;
          int v17 = v9;
          __int16 v18 = 2082;
          uint64_t v19 = v6;
          _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEFAULT, "Chunk %llu of %llu at itemOffset %llu with byteLength %u has signature %{public}s", buf, 0x30u);
        }
        if (v6) {
          free(v6);
        }
        BOOL result = CKRegisteredChunkSize();
        v4 += result;
        ++v5;
      }
      while (a2 != v5);
    }
  }
  return result;
}

void mmcs_op_requestor_context_indent(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1 >= 1)
  {
    unint64_t v2 = *(__CFString **)(a1 + 16);
    unint64_t v3 = v1 + 1;
    do
    {
      CFStringAppend(v2, @"    ");
      --v3;
    }
    while (v3 > 1);
  }
}

__CFString *mmcs_cferror_copy_description(__CFError *a1)
{
  if (a1)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    _mmcs_cferror_append_description(Mutable, a1, 0);
    return Mutable;
  }
  else
  {
    return (__CFString *)CFRetain(@"(null)");
  }
}

void _mmcs_cferror_append_description(CFMutableStringRef theString, CFErrorRef err, int a3)
{
  if (a3)
  {
    int v6 = a3;
    do
    {
      --v6;
      CFStringAppend(theString, @"    ");
    }
    while (v6);
  }
  CFErrorDomain Domain = CFErrorGetDomain(err);
  CFIndex Code = CFErrorGetCode(err);
  CFStringAppendFormat(theString, 0, @"Error Domain=%@ Code=%ld", Domain, Code);
  CFStringRef v9 = CFErrorCopyDescription(err);
  if (v9)
  {
    CFStringRef v10 = v9;
    CFStringAppendFormat(theString, 0, @" \"%@\"", v9);
    CFRelease(v10);
  }
  CFDictionaryRef v11 = CFErrorCopyUserInfo(err);
  if (v11)
  {
    CFDictionaryRef v12 = v11;
    CFStringRef Value = CFDictionaryGetValue(v11, @"NSDebugDescription");
    if (Value) {
      CFStringAppendFormat(theString, 0, @" (%@)", Value);
    }
    CFStringAppend(theString, @"\n");
    context[0] = theString;
    context[1] = (__CFString *)(a3 + 1);
    CFDictionaryApplyFunction(v12, (CFDictionaryApplierFunction)_mmcs_cferror_append_description_userInfo, context);
    __int16 v14 = (__CFError *)CFDictionaryGetValue(v12, (const void *)*MEMORY[0x1E4F1D190]);
    _mmcs_cferror_append_underlying_error_description(v14, context);
    CFArrayRef v15 = (const __CFArray *)CFDictionaryGetValue(v12, @"kMMCSErrorUnderlyingErrorArrayKey");
    if (v15)
    {
      CFArrayRef v16 = v15;
      CFTypeID v17 = CFGetTypeID(v15);
      if (v17 == CFArrayGetTypeID())
      {
        v21.unsigned int length = CFArrayGetCount(v16);
        v21.CFIndex location = 0;
        CFArrayApplyFunction(v16, v21, (CFArrayApplierFunction)_mmcs_cferror_append_underlying_error_description, context);
      }
    }
    __int16 v18 = mmcs_cfnetwork_copy_underlying_stream_error(v12);
    if (v18)
    {
      uint64_t v19 = v18;
      _mmcs_cferror_append_underlying_error_description(v18, context);
      CFRelease(v19);
    }
    CFRelease(v12);
  }
}

__CFString *mmcs_cferror_copy_short_description(__CFError *a1)
{
  if (a1)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    _mmcs_cferror_append_short_description(Mutable, a1);
    return Mutable;
  }
  else
  {
    return (__CFString *)CFRetain(@"(null)");
  }
}

void _mmcs_cferror_append_short_description(__CFString *a1, __CFError *a2)
{
  CFErrorDomain Domain = CFErrorGetDomain(a2);
  CFIndex Code = CFErrorGetCode(a2);
  CFStringAppendFormat(a1, 0, @"%@/%ld", Domain, Code);
  CFDictionaryRef v6 = CFErrorCopyUserInfo(a2);
  CFStringRef Value = CFDictionaryGetValue(v6, (const void *)*MEMORY[0x1E4F1D190]);
  if (Value)
  {
    uint64_t v8 = Value;
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFErrorGetTypeID())
    {
      CFStringAppend(a1, @"(");
      _mmcs_cferror_append_short_description(a1, v8);
LABEL_11:
      CFStringAppend(a1, @""));
      goto LABEL_12;
    }
  }
  CFArrayRef v10 = (const __CFArray *)CFDictionaryGetValue(v6, @"kMMCSErrorUnderlyingErrorArrayKey");
  if (v10)
  {
    CFArrayRef v11 = v10;
    CFTypeID v12 = CFGetTypeID(v10);
    if (v12 == CFArrayGetTypeID())
    {
      CFStringAppend(a1, @"(");
      CFIndex Count = CFArrayGetCount(v11);
      if (Count >= 1)
      {
        CFIndex v14 = Count;
        for (CFIndex i = 0; i != v14; ++i)
        {
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v11, i);
          if (i) {
            CFStringAppend(a1, @", ");
          }
          _mmcs_cferror_append_short_description(a1, ValueAtIndex);
        }
      }
      goto LABEL_11;
    }
  }
LABEL_12:
  if (v6)
  {
    CFRelease(v6);
  }
}

char *mmcs_cfnetwork_cfstream_error_domain_copy_description(int a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  switch(a1)
  {
    case -1:
      uint64_t v1 = "_kCFStreamErrorDomainCustom";
      goto LABEL_18;
    case 0:
      uint64_t v1 = "_kCFStreamErrorDomainNoError";
      goto LABEL_18;
    case 1:
      uint64_t v1 = "_kCFStreamErrorDomainPOSIX";
      goto LABEL_18;
    case 2:
      uint64_t v1 = "_kCFStreamErrorDomainMacOSStatus";
      goto LABEL_18;
    case 3:
      uint64_t v1 = "_kCFStreamErrorDomainSSL";
      goto LABEL_18;
    case 4:
      uint64_t v1 = "_kCFStreamErrorDomainHTTP";
      goto LABEL_18;
    case 5:
      uint64_t v1 = "_kCFStreamErrorDomainSOCKS";
      goto LABEL_18;
    case 6:
      uint64_t v1 = "_kCFStreamErrorDomainFTP";
      goto LABEL_18;
    case 7:
      uint64_t v1 = "_kCFStreamErrorDomainWinSock";
      goto LABEL_18;
    case 10:
      uint64_t v1 = "_kCFStreamErrorDomainNetServices";
      goto LABEL_18;
    case 11:
      uint64_t v1 = "_kCFStreamErrorDomainMach";
      goto LABEL_18;
    case 12:
      uint64_t v1 = "_kCFStreamErrorDomainNetDB";
      goto LABEL_18;
    case 13:
      uint64_t v1 = "_kCFStreamErrorDomainSystemConfiguration";
      goto LABEL_18;
    case 15:
      uint64_t v1 = "__kCFURLErrorDomain";
      goto LABEL_18;
    case 20:
      uint64_t v1 = "_kCFStreamErrorDomainCFHTTPServer";
LABEL_18:
      BOOL result = strdup(v1);
      break;
    default:
      int v9 = 0;
      long long v7 = 0u;
      long long v8 = 0u;
      long long v5 = 0u;
      long long v6 = 0u;
      *(_OWORD *)__CFStringRef str = 0u;
      long long v4 = 0u;
      snprintf(__str, 0x64uLL, "_kCFStreamErrorDomainNumber%d", a1);
      BOOL result = strdup(__str);
      break;
  }
  return result;
}

char *mmcs_cfnetwork_cfstream_http_error_copy_description(int a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  switch(a1)
  {
    case -2104:
      uint64_t v1 = "kCFStreamErrorWatchdogTimeout";
      goto LABEL_16;
    case -2103:
      uint64_t v1 = "kCFStreamErrorResourceTimeout";
      goto LABEL_16;
    case -2102:
      uint64_t v1 = "kCFStreamErrorRequestTimeout";
      goto LABEL_16;
    case -2101:
      uint64_t v1 = "kCFStreamErrorAdaptiveReadTimeout";
      goto LABEL_16;
    case -2100:
      uint64_t v1 = "kCFStreamErrorAdaptiveWriteTimeout";
      goto LABEL_16;
    case -2099:
      uint64_t v1 = "__kCFStreamErrorHTTPLedBellyDisconnect";
      goto LABEL_16;
    case -2098:
      uint64_t v1 = "__kCFStreamErrorHTTPSProxyFailureUnexpectedResponseToCONNECTMethod";
      goto LABEL_16;
    case -2097:
      uint64_t v1 = "__kCFStreamErrorHTTPSProxyAuthRequired";
      goto LABEL_16;
    case -2096:
      uint64_t v1 = "__kCFStreamErrorHTTPSProxyFailure";
      goto LABEL_16;
    case -2095:
      uint64_t v1 = "__kCFStreamErrorHTTPStreamAtMark";
      goto LABEL_16;
    case -2094:
      uint64_t v1 = "__kCFStreamErrorHTTPProxyFailure";
      goto LABEL_16;
    case -2093:
      uint64_t v1 = "__kCFStreamErrorHTTPProxyConfigChanged";
      goto LABEL_16;
    default:
      if (a1 == -4)
      {
        uint64_t v1 = "_kCFStreamErrorHTTPConnectionLost";
LABEL_16:
        return strdup(v1);
      }
      else
      {
        int v9 = 0;
        long long v7 = 0u;
        long long v8 = 0u;
        long long v5 = 0u;
        long long v6 = 0u;
        *(_OWORD *)__CFStringRef str = 0u;
        long long v4 = 0u;
        snprintf(__str, 0x64uLL, "_CFStreamErrorHTTPErrorNumber%d", a1);
        return strdup(__str);
      }
  }
}

CFErrorRef mmcs_cfnetwork_copy_underlying_stream_error(const __CFDictionary *a1)
{
  if (!a1) {
    return 0;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"_kCFStreamErrorDomainKey");
  if (Value)
  {
    CFNumberRef v3 = Value;
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFNumberGetTypeID()) {
      CFNumberRef v5 = v3;
    }
    else {
      CFNumberRef v5 = 0;
    }
  }
  else
  {
    CFNumberRef v5 = 0;
  }
  CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue(a1, @"_kCFStreamErrorCodeKey");
  if (!v7)
  {
LABEL_20:
    CFErrorRef v6 = 0;
    goto LABEL_21;
  }
  CFNumberRef v8 = v7;
  CFTypeID v9 = CFGetTypeID(v7);
  CFTypeID TypeID = CFNumberGetTypeID();
  CFErrorRef v6 = 0;
  if (v9 != TypeID) {
    CFNumberRef v8 = 0;
  }
  if (v5 && v9 == TypeID)
  {
    uint64_t valuePtr = 0;
    if (CFNumberGetValue(v5, kCFNumberIntType, (char *)&valuePtr + 4))
    {
      if (CFNumberGetValue(v8, kCFNumberIntType, &valuePtr))
      {
        CFArrayRef v11 = mmcs_cfnetwork_cfstream_error_domain_copy_description(SHIDWORD(valuePtr));
        if (v11)
        {
          CFTypeID v12 = (UInt8 *)v11;
          size_t v13 = strlen(v11);
          CFStringRef v14 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v12, v13, 0x8000100u, 0);
          if (!v14)
          {
            CFErrorRef v6 = 0;
LABEL_37:
            free(v12);
            goto LABEL_21;
          }
          CFStringRef v20 = v14;
          if (HIDWORD(valuePtr) == 1)
          {
            char v41 = strerror(valuePtr);
            CFRange v21 = strdup(v41);
          }
          else
          {
            if (HIDWORD(valuePtr) != 4)
            {
              uint64_t v42 = 0;
LABEL_35:
              CFErrorRef v6 = mmcs_cferror_create_with_format(v20, (int)valuePtr, @"%@/%d%s%s", v15, v16, v17, v18, v19, (char)v20);
              CFRelease(v20);
              if (v42) {
                free(v42);
              }
              goto LABEL_37;
            }
            CFRange v21 = mmcs_cfnetwork_cfstream_http_error_copy_description(valuePtr);
          }
          uint64_t v42 = v21;
          goto LABEL_35;
        }
      }
    }
    goto LABEL_20;
  }
LABEL_21:
  nsurlerror_background_task_cancelled_reason_key = (const void *)mmcs_get_nsurlerror_background_task_cancelled_reason_key();
  CFNumberRef v23 = (const __CFNumber *)CFDictionaryGetValue(a1, nsurlerror_background_task_cancelled_reason_key);
  if (v23)
  {
    CFNumberRef v24 = v23;
    CFTypeID v25 = CFGetTypeID(v23);
    if (v25 == CFNumberGetTypeID())
    {
      unsigned int v43 = 0;
      if (CFNumberGetValue(v24, kCFNumberIntType, &v43))
      {
        if (v6) {
          CFRelease(v6);
        }
        uint64_t v31 = (int)v43;
        if (v43 <= 2)
        {
          CFStringRef v32 = off_1E6C34A50[v43];
          CFErrorRef v6 = mmcs_cferror_create_with_format(@"com.apple.nsurlsessiond", v43, @"%@", v26, v27, v28, v29, v30, (char)v32);
LABEL_29:
          CFRelease(v32);
          return v6;
        }
        CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v34 = mmcs_get_nsurlerror_background_task_cancelled_reason_key();
        CFStringRef v32 = CFStringCreateWithFormat(v33, 0, @"%@%d", v34, v31);
        CFErrorRef v6 = mmcs_cferror_create_with_format(@"com.apple.nsurlsessiond", (int)v43, @"%@", v35, v36, v37, v38, v39, (char)v32);
        if (v32) {
          goto LABEL_29;
        }
      }
    }
  }
  return v6;
}

const char *MMCSPutItemStateCString(unsigned int a1)
{
  if (a1 <= 7) {
    return MMCSPutItemStateCString_strings[a1];
  }
  else {
    return "(unknown put item state)";
  }
}

const char *MMCSGetItemStateCString(unsigned int a1)
{
  if (a1 <= 5) {
    return MMCSGetItemStateCString_strings[a1];
  }
  else {
    return "(unknown get item state)";
  }
}

CFURLRef XCFURLCreateWithCString(const char *a1)
{
  size_t v2 = strlen(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  return CFURLCreateWithBytes(v3, (const UInt8 *)a1, v2, 0x8000100u, 0);
}

CFHTTPMessageRef XCFHTTPMessageCopyWithNewURLAndHeaders(__CFHTTPMessage *a1, const __CFURL *a2, const __CFDictionary *a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    uint64_t v17 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      CFDataRef v11 = (const __CFData *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"cannot create new message with a null url!");
      uint64_t v18 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        int v31 = 138543362;
        CFStringRef v32 = v11;
LABEL_18:
        _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v31, 0xCu);
      }
LABEL_19:
      CFHTTPMessageRef v20 = 0;
      goto LABEL_46;
    }
    return 0;
  }
  CFStringRef v6 = CFHTTPMessageCopyRequestMethod(a1);
  if (!v6)
  {
    uint64_t v19 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      CFDataRef v11 = (const __CFData *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"failed to get request method");
      uint64_t v18 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        int v31 = 138543362;
        CFStringRef v32 = v11;
        goto LABEL_18;
      }
      goto LABEL_19;
    }
    return 0;
  }
  CFStringRef v7 = v6;
  CFStringRef v8 = CFHTTPMessageCopyVersion(a1);
  if (!v8)
  {
    CFRange v21 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v22 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"failed to get version");
      CFNumberRef v23 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        int v31 = 138543362;
        CFStringRef v32 = (void *)v22;
        _os_log_impl(&dword_1DC1CA000, v23, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v31, 0xCu);
      }
      if (v22) {
        CFRelease(v22);
      }
    }
    CFHTTPMessageRef v20 = 0;
    CFDataRef v11 = (const __CFData *)v7;
    goto LABEL_47;
  }
  CFStringRef v9 = v8;
  CFDictionaryRef v10 = CFHTTPMessageCopyAllHeaderFields(a1);
  if (v10)
  {
    CFDataRef v11 = CFHTTPMessageCopyBody(a1);
    if (v11 || gMMCS_DebugLevel <= 4)
    {
      CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    }
    else
    {
      CFTypeID v12 = mmcs_logging_logger_default();
      BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
      CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (v13)
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"failed to copy body; possibly empty");
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          int v31 = 138543362;
          CFStringRef v32 = (void *)v15;
          _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&v31, 0xCu);
        }
        if (v15) {
          CFRelease(v15);
        }
      }
    }
    CFHTTPMessageRef Request = CFHTTPMessageCreateRequest(v14, v7, a2, v9);
    if (Request)
    {
      CFHTTPMessageRef v20 = Request;
      CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)copyWithNewUrlHelper, Request);
      if (a3) {
        CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)copyWithNewUrlHelper, v20);
      }
      CFHTTPMessageSetBody(v20, v11);
      goto LABEL_44;
    }
    uint64_t v27 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v28 = CFStringCreateWithFormat(v14, 0, @"failed to create new message");
      uint64_t v29 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        int v31 = 138543362;
        CFStringRef v32 = (void *)v28;
        _os_log_impl(&dword_1DC1CA000, v29, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v31, 0xCu);
      }
      if (v28) {
        CFRelease(v28);
      }
    }
    goto LABEL_43;
  }
  CFNumberRef v24 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
LABEL_32:
    CFHTTPMessageRef v20 = 0;
    CFDataRef v11 = 0;
    goto LABEL_44;
  }
  CFDataRef v11 = (const __CFData *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"failed to copy headers");
  CFTypeID v25 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    int v31 = 138543362;
    CFStringRef v32 = v11;
    _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v31, 0xCu);
  }
  if (v11)
  {
    CFRelease(v11);
    goto LABEL_32;
  }
LABEL_43:
  CFHTTPMessageRef v20 = 0;
LABEL_44:
  CFRelease(v7);
  CFRelease(v9);
  if (v10) {
    CFRelease(v10);
  }
LABEL_46:
  if (v11) {
LABEL_47:
  }
    CFRelease(v11);
  return v20;
}

void copyWithNewUrlHelper(CFStringRef headerField, CFStringRef value, CFHTTPMessageRef message)
{
}

CFStringRef XCFStringCopyLastPathComponent(CFStringRef filePath)
{
  CFURLRef v1 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], filePath, kCFURLPOSIXPathStyle, 0);
  CFStringRef PathComponent = CFURLCopyLastPathComponent(v1);
  CFRelease(v1);
  return PathComponent;
}

BOOL XCFSafelyEquals(unint64_t cf1, unint64_t a2)
{
  if (!(cf1 | a2)) {
    return 1;
  }
  BOOL result = 0;
  if (cf1)
  {
    if (a2) {
      return CFEqual((CFTypeRef)cf1, (CFTypeRef)a2) != 0;
    }
  }
  return result;
}

CFTypeRef XCFSafelyHash(CFTypeRef cf)
{
  if (cf) {
    return (CFTypeRef)CFHash(cf);
  }
  return cf;
}

__CFString *XCFCreateTruncatedHash(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return &stru_1F363CBE8;
  }
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v2 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"com.apple.mmcs.%@", a1);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v1, 0, v2);
  CFStringNormalize(MutableCopy, kCFStringNormalizationFormD);
  CFDataRef DataUsingEncoding = XCFStringCreateDataUsingEncoding(MutableCopy, 0x8000100u);
  memset(&c, 0, sizeof(c));
  CC_SHA256_Init(&c);
  BytePtr = CFDataGetBytePtr(DataUsingEncoding);
  CC_LONG Length = CFDataGetLength(DataUsingEncoding);
  CC_SHA256_Update(&c, BytePtr, Length);
  *(_OWORD *)md = 0u;
  long long v12 = 0u;
  CC_SHA256_Final(md, &c);
  if (DataUsingEncoding) {
    CFRelease(DataUsingEncoding);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (v2) {
    CFRelease(v2);
  }
  CFStringRef v7 = hextostrdup((char *)md, 2uLL);
  CFStringRef v8 = CFStringCreateWithCString(v1, v7, 0x8000100u);
  if (v7) {
    free(v7);
  }
  return (__CFString *)v8;
}

CFDataRef XCFStringCreateDataUsingEncoding(const __CFString *a1, CFStringEncoding a2)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v5 = CFStringGetMaximumSizeForEncoding(Length, a2) + 1;
  CFStringRef v6 = (char *)malloc_type_calloc(1uLL, v5, 0xD55A397FuLL);
  if (!v6) {
    return 0;
  }
  CFStringRef v7 = v6;
  if (!CFStringGetCString(a1, v6, v5, a2))
  {
    free(v7);
    return 0;
  }
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
  return XCFDataCreateWithBytesNoCopy(v8, (const UInt8 *)v7, v5, v9);
}

void XCFSetAddValuesFromSet(void *context, CFSetRef theSet)
{
}

void XCFSetAddValuesFromSetApplier(void *value, CFMutableSetRef theSet)
{
}

void XCFSetAddValuesFromArray(void *a1, CFArrayRef theArray)
{
  v4.unsigned int length = CFArrayGetCount(theArray);
  v4.CFIndex location = 0;
  CFArrayApplyFunction(theArray, v4, (CFArrayApplierFunction)XCFSetAddValuesFromSetApplier, a1);
}

void XCFSetRemoveValuesFromArray(void *a1, CFArrayRef theArray)
{
  v4.unsigned int length = CFArrayGetCount(theArray);
  v4.CFIndex location = 0;
  CFArrayApplyFunction(theArray, v4, (CFArrayApplierFunction)XCFSetRemoveValuesFromSetApplier, a1);
}

void XCFSetRemoveValuesFromSetApplier(void *value, CFMutableSetRef theSet)
{
}

void XCFSetRemoveValuesFromSet(void *context, CFSetRef theSet)
{
}

void XCFSetSafelyRemoveValue(void *a1, const void *a2)
{
  CFRetain(a1);
  CFSetRemoveValue((CFMutableSetRef)a1, a2);
  if (a1)
  {
    CFRelease(a1);
  }
}

void mmcs_cfarray_free_callback(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

CFIndex XCFArrayRemoveAllInstancesOfValue(const __CFArray *a1, const void *a2)
{
  v6.unsigned int length = CFArrayGetCount(a1);
  v6.CFIndex location = 0;
  CFIndex result = CFArrayGetLastIndexOfValue(a1, v6, a2);
  if (result != -1)
  {
    CFIndex v5 = result;
    do
    {
      CFArrayRemoveValueAtIndex(a1, v5);
      v7.unsigned int length = CFArrayGetCount(a1);
      v7.CFIndex location = 0;
      CFIndex result = CFArrayGetLastIndexOfValue(a1, v7, a2);
      CFIndex v5 = result;
    }
    while (result != -1);
  }
  return result;
}

void XCFArrayRemoveAllValuesWithArray(void *a1, CFArrayRef theArray)
{
  v4.unsigned int length = CFArrayGetCount(theArray);
  v4.CFIndex location = 0;
  CFArrayApplyFunction(theArray, v4, (CFArrayApplierFunction)XCFArrayRemoveValuesFromArrayApplier, a1);
}

CFIndex XCFArrayRemoveValuesFromArrayApplier(const void *a1, const __CFArray *a2)
{
  return XCFArrayRemoveAllInstancesOfValue(a2, a1);
}

CFArrayRef XCFArrayCreateWithObject(const void *a1)
{
  v2[1] = *(const void **)MEMORY[0x1E4F143B8];
  v2[0] = a1;
  return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2, 1, MEMORY[0x1E4F1D510]);
}

void XCFDictionaryAppendValue(const __CFDictionary *a1, const CFArrayCallBacks *a2, void *key, const void *a4)
{
  CFNumberRef Value = (__CFArray *)CFDictionaryGetValue(a1, key);
  if (Value)
  {
    CFArrayAppendValue(Value, a4);
  }
  else
  {
    CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a2);
    CFArrayAppendValue(Mutable, a4);
    CFDictionarySetValue(a1, key, Mutable);
    if (Mutable)
    {
      CFRelease(Mutable);
    }
  }
}

CFArrayRef XCFDictionaryCopyKeys(const __CFDictionary *a1, const CFArrayCallBacks *a2)
{
  CFIndex Count = CFDictionaryGetCount(a1);
  CFIndex v5 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  CFDictionaryGetKeysAndValues(a1, v5, 0);
  CFArrayRef v6 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, Count, a2);
  if (v5) {
    free(v5);
  }
  return v6;
}

CFMutableArrayRef XCFSetMutableCopyValues(const __CFSet *a1, const CFArrayCallBacks *a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex Count = CFSetGetCount(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v4, Count, a2);
  CFSetApplyFunction(a1, (CFSetApplierFunction)_set_applier_append_array, Mutable);
  return Mutable;
}

void _set_applier_append_array(void *value, CFMutableArrayRef theArray)
{
}

CFStringRef createMillisStringFromAbsoluteTime(double a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%.0f", a1 * 1000.0);
}

CFStringRef XCFAbsoluteTimeDateFormatterCreateString(CFAbsoluteTime a1)
{
  pthread_once(&sAbsoluteTimeDateFormatter_once, _AbsoluteTimeDateFormatter_init_once);
  pthread_mutex_lock(&XCFAbsoluteTimeDateFormatterCreateString_lock);
  if (sAbsoluteTimeDateFormatter) {
    CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFDateFormatterRef)sAbsoluteTimeDateFormatter, a1);
  }
  else {
    CFStringRef StringWithAbsoluteTime = 0;
  }
  pthread_mutex_unlock(&XCFAbsoluteTimeDateFormatterCreateString_lock);
  return StringWithAbsoluteTime;
}

void _AbsoluteTimeDateFormatter_init_once()
{
  CFLocaleRef v0 = CFLocaleCreate(0, @"en_US");
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef DateFormatFromTemplate = CFDateFormatterCreateDateFormatFromTemplate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"yyyy/MM/dd kk:mm:ss.SSSS", 0, v0);
  sAbsoluteTimeDateFormatter = (uint64_t)CFDateFormatterCreate(v1, v0, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
  CFDateFormatterSetFormat((CFDateFormatterRef)sAbsoluteTimeDateFormatter, DateFormatFromTemplate);
  if (DateFormatFromTemplate) {
    CFRelease(DateFormatFromTemplate);
  }
  if (v0)
  {
    CFRelease(v0);
  }
}

uint64_t XCFReadStreamGetSocketNativeHandle(__CFReadStream *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  CFDataRef v1 = (const __CFData *)CFReadStreamCopyProperty(a1, (CFStreamPropertyKey)*MEMORY[0x1E4F1D488]);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  CFDataRef v2 = v1;
  CFTypeID TypeID = CFDataGetTypeID();
  if (TypeID == CFGetTypeID(v2) && CFDataGetLength(v2) == 4) {
    uint64_t v4 = *(unsigned int *)CFDataGetBytePtr(v2);
  }
  else {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  CFRelease(v2);
  return v4;
}

char *XCFDataCreateCStringDescription(const __CFData *a1)
{
  if (a1)
  {
    BytePtr = (char *)CFDataGetBytePtr(a1);
    CFIndex Length = CFDataGetLength(a1);
    return hextostrdup(BytePtr, Length);
  }
  else
  {
    return strdup("(null)");
  }
}

CFStringRef XCFDataCreateStringDescription(const __CFData *a1)
{
  BytePtr = (char *)CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  uint64_t v4 = hextostrdup(BytePtr, Length);
  size_t v5 = strlen(v4);
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  return XCFStringCreateWithBytesNoCopy(v7, (const UInt8 *)v4, v5, 0x8000100u, 0, v6);
}

CFStringRef XCFStringCopyPathExtension(CFStringRef filePath)
{
  CFURLRef v1 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], filePath, kCFURLPOSIXPathStyle, 0);
  CFStringRef v2 = CFURLCopyPathExtension(v1);
  if (v1) {
    CFRelease(v1);
  }
  return v2;
}

uint64_t mmcs_server_version_compare(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a1 > a3;
  if (a1 < a3) {
    uint64_t v4 = -1;
  }
  uint64_t v5 = a2 > a4;
  if (a2 < a4) {
    uint64_t v5 = -1;
  }
  if (v4) {
    return v4;
  }
  else {
    return v5;
  }
}

uint64_t mmcs_server_version_make_from_CFString(CFStringRef theString)
{
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, @".");
  if (!ArrayBySeparatingStrings) {
    return 0;
  }
  CFArrayRef v2 = ArrayBySeparatingStrings;
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  if (Count < 1)
  {
    IntCFNumberRef Value = 0;
  }
  else
  {
    CFIndex v4 = Count;
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v2, 0);
    IntCFNumberRef Value = CFStringGetIntValue(ValueAtIndex);
    if (v4 != 1)
    {
      CFStringRef v7 = (const __CFString *)CFArrayGetValueAtIndex(v2, 1);
      CFStringGetIntValue(v7);
    }
  }
  CFRelease(v2);
  return IntValue;
}

double mmcs_server_version_as_double(uint64_t a1, uint64_t a2)
{
  double v3 = (double)a2;
  double v4 = log10((double)a2);
  return v3 / __exp10(floor(v4) + 1.0) + (double)a1;
}

BOOL mmcs_server_version_not_a_version(uint64_t a1, uint64_t a2)
{
  return (a1 | a2) == 0;
}

uint64_t mmcs_is_apple_internal_install()
{
  return MEMORY[0x1F40CD648]("com.apple.mmcs");
}

void _mmcs_cferror_append_description_userInfo(const __CFString *cf, const __CFString *a2, uint64_t a3)
{
  if (!cf
    || (CFTypeID v6 = CFGetTypeID(cf), v6 != CFStringGetTypeID())
    || !CFEqual(cf, @"NSDebugDescription")
    && !CFEqual(cf, (CFTypeRef)*MEMORY[0x1E4F1D170])
    && !CFEqual(cf, (CFTypeRef)*MEMORY[0x1E4F1D140])
    && !CFEqual(cf, (CFTypeRef)*MEMORY[0x1E4F1D190])
    && !CFEqual(cf, @"kMMCSErrorUnderlyingErrorArrayKey"))
  {
    _mmcs_cferror_append_description_dict(cf, a2, a3);
  }
}

__CFError *_mmcs_cferror_append_underlying_error_description(__CFError *result, __CFString **a2)
{
  if (result)
  {
    double v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    CFIndex result = (__CFError *)CFErrorGetTypeID();
    if ((__CFError *)v4 == result)
    {
      uint64_t v5 = *a2;
      return (__CFError *)_mmcs_cferror_append_description(v5, v3);
    }
  }
  return result;
}

void _mmcs_cferror_append_description_dict(const __CFString *a1, CFStringRef StringWithNumber, uint64_t a3)
{
  if (a1)
  {
    CFStringRef v5 = a1;
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 == CFStringGetTypeID())
    {
      CFStringRef v7 = 0;
    }
    else
    {
      CFStringRef v5 = CFCopyDescription(v5);
      CFStringRef v7 = v5;
    }
  }
  else
  {
    CFStringRef v7 = 0;
    CFStringRef v5 = @"(null)";
  }
  CFAllocatorRef v8 = *(__CFString **)a3;
  int v9 = *(_DWORD *)(a3 + 8);
  if (v9)
  {
    do
    {
      --v9;
      CFStringAppend(v8, @"    ");
    }
    while (v9);
    CFAllocatorRef v8 = *(__CFString **)a3;
  }
  CFStringAppend(v8, @"\"");
  CFStringAppend(*(CFMutableStringRef *)a3, v5);
  CFStringAppend(*(CFMutableStringRef *)a3, @"\"");
  if (v7) {
    CFRelease(v7);
  }
  CFStringAppend(*(CFMutableStringRef *)a3, @" = ");
  if (!StringWithNumber)
  {
    CFStringRef v12 = @"(null)";
    goto LABEL_18;
  }
  CFTypeID v10 = CFGetTypeID(StringWithNumber);
  if (v10 == CFStringGetTypeID())
  {
    CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"\"%@\"", StringWithNumber);
LABEL_14:
    StringWithNumber = v11;
    goto LABEL_15;
  }
  CFTypeID v13 = CFGetTypeID(StringWithNumber);
  if (v13 != CFDictionaryGetTypeID())
  {
    CFTypeID v16 = CFGetTypeID(StringWithNumber);
    if (v16 == CFNumberGetTypeID())
    {
      CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFLocaleRef v18 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"en_US");
      uint64_t v19 = CFNumberFormatterCreate(v17, v18, kCFNumberFormatterDecimalStyle);
      StringWithNumber = CFNumberFormatterCreateStringWithNumber(v17, v19, (CFNumberRef)StringWithNumber);
      if (v19) {
        CFRelease(v19);
      }
      if (v18) {
        CFRelease(v18);
      }
LABEL_15:
      CFStringRef v12 = StringWithNumber;
      if (!StringWithNumber) {
        return;
      }
      goto LABEL_18;
    }
    CFTypeID v20 = CFGetTypeID(StringWithNumber);
    if (v20 != CFBooleanGetTypeID())
    {
      CFStringRef v11 = CFCopyDescription(StringWithNumber);
      goto LABEL_14;
    }
    int Value = CFBooleanGetValue((CFBooleanRef)StringWithNumber);
    StringWithNumber = 0;
    if (Value) {
      CFStringRef v12 = @"\"YES\"";
    }
    else {
      CFStringRef v12 = @"\"NO\"";
    }
LABEL_18:
    CFStringAppend(*(CFMutableStringRef *)a3, v12);
    CFStringAppend(*(CFMutableStringRef *)a3, @"\n");
    if (StringWithNumber)
    {
      CFRelease(StringWithNumber);
    }
    return;
  }
  CFStringAppend(*(CFMutableStringRef *)a3, @"{\n");
  CFMutableStringRef context = *(CFMutableStringRef *)a3;
  uint64_t v23 = 0;
  LODWORD(v23) = *(_DWORD *)(a3 + 8) + 1;
  CFDictionaryApplyFunction((CFDictionaryRef)StringWithNumber, (CFDictionaryApplierFunction)_mmcs_cferror_append_description_dict, &context);
  CFAllocatorRef v14 = *(__CFString **)a3;
  int v15 = *(_DWORD *)(a3 + 8);
  if (v15)
  {
    do
    {
      --v15;
      CFStringAppend(v14, @"    ");
    }
    while (v15);
    CFAllocatorRef v14 = *(__CFString **)a3;
  }
  CFStringAppend(v14, @"}\n");
}

uint64_t MMCSEngineSetMetricsEnabled(uint64_t result, char a2)
{
  *(unsigned char *)(result + 175) = a2;
  return result;
}

uint64_t MMCSEngineGetRequestMetrics(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 192);
    uint64_t v3 = *(void *)(a1 + 200);
    if (v2)
    {
      if (v3)
      {
        CFTypeID v4 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"This shouldn't happen: currentGetRequestContext and currentPutRequestContext are both non-NULL! I refuse to choose.");
          CFTypeID v6 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          {
            int v8 = 138543362;
            CFStringRef v9 = v5;
            _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v8, 0xCu);
          }
          if (v5) {
            CFRelease(v5);
          }
        }
        return 0;
      }
      return mmcs_get_req_context_get_current_request_metrics(v2);
    }
    if (v3)
    {
      uint64_t v2 = v3;
      return mmcs_get_req_context_get_current_request_metrics(v2);
    }
  }
  return 0;
}

void MMCSGetChunks(uint64_t a1, uint64_t a2, uint64_t a3, const __CFArray *a4, unsigned int (*a5)(uint64_t, const void *, CFTypeRef *), void (*a6)(uint64_t, void))
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  CFStringRef v11 = _os_activity_create(&dword_1DC1CA000, "mmcs-get-chunks", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v11, &state);
  CFStringRef v12 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_DEFAULT, "MMCSGetChunks - Start.", buf, 2u);
  }
  if (!a5 || !a6) {
    MMCSGetChunks_cold_1();
  }
  CFTypeRef v44 = 0;
  CFErrorRef v45 = 0;
  if (mmcs_local_chunk_satisfyer_create((uint64_t *)&v45, a1, a2, 0, (uint64_t)&v44, 0))
  {
    uint64_t v37 = a6;
    object = v11;
    uint64_t v39 = malloc_type_malloc(0x8000uLL, 0x7D010EA4uLL);
    CFIndex Count = CFArrayGetCount(a4);
    if (Count >= 1)
    {
      CFIndex v14 = Count;
      for (CFIndex i = 0; v14 != i; ++i)
      {
        CFTypeRef v42 = 0;
        CFTypeRef cf = 0;
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a4, i);
        CFTypeID v17 = CFGetTypeID(ValueAtIndex);
        if (v17 == CFDataGetTypeID())
        {
          if (a5(a2, ValueAtIndex, &v42))
          {
            if (v42)
            {
              if (MMCSItemReaderWriterOpen((uint64_t)v42, &cf))
              {
                CFLocaleRef v18 = v45;
                uint8_t v45[4] = v42;
                v18[5] = &v44;
                char v41 = 0;
                BytePtr = (UInt8 *)CFDataGetBytePtr((CFDataRef)ValueAtIndex);
                if (mmcs_chunk_reference_create(&v41, 0, BytePtr, 0, 0))
                {
                  CFDataRef v40 = 0;
                  if (mmcs_chunk_instance_create(&v40, (uint64_t)v41, 0, 0, 0))
                  {
                    uint64_t RegisteredChunk = mmcs_chunk_instance_create_RegisteredChunk();
                    if (RegisteredChunk)
                    {
                      CFRange v21 = (void *)RegisteredChunk;
                      if (!mmcs_local_chunk_satisfyer_perform(v45, (uint64_t)v40, RegisteredChunk, 1, (uint64_t)v39, 0x8000uLL, &cf))
                      {
                        CFStringRef v22 = mmcs_logging_logger_default();
                        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_1DC1CA000, v22, OS_LOG_TYPE_ERROR, "MMCSGetChunks, fatal error copying source chunk.", buf, 2u);
                        }
                      }
                      goto LABEL_34;
                    }
                    int v31 = mmcs_logging_logger_default();
                    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)long long buf = 0;
                      CFNumberRef v24 = v31;
                      CFTypeID v25 = "MMCSGetChunks, failed to created source registered chunk.";
                      goto LABEL_32;
                    }
                  }
                  else
                  {
                    uint64_t v30 = mmcs_logging_logger_default();
                    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)long long buf = 0;
                      CFNumberRef v24 = v30;
                      CFTypeID v25 = "MMCSGetChunks, failed to created source chunk instance.";
                      goto LABEL_32;
                    }
                  }
                }
                else
                {
                  uint64_t v29 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long buf = 0;
                    CFNumberRef v24 = v29;
                    CFTypeID v25 = "MMCSGetChunks, failed to created destionation chunk reference.";
                    goto LABEL_32;
                  }
                }
              }
              else
              {
                CFStringRef v28 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long buf = 0;
                  CFNumberRef v24 = v28;
                  CFTypeID v25 = "MMCSGetChunks, destination item reader did not open.";
                  goto LABEL_32;
                }
              }
            }
            else
            {
              uint64_t v27 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                CFNumberRef v24 = v27;
                CFTypeID v25 = "MMCSGetChunks, retrieval of destination item reader writer returned nil.";
                goto LABEL_32;
              }
            }
          }
          else
          {
            uint64_t v26 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              CFNumberRef v24 = v26;
              CFTypeID v25 = "MMCSGetChunks, retrieval of destination item reader writer failed.";
              goto LABEL_32;
            }
          }
        }
        else
        {
          uint64_t v23 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            CFNumberRef v24 = v23;
            CFTypeID v25 = "MMCSGetChunks, chunkSignatures array element had incorrect type.";
LABEL_32:
            _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_ERROR, v25, buf, 2u);
          }
        }
        CFRange v21 = 0;
LABEL_34:
        CFStringRef v32 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          if (v40)
          {
            uint64_t v33 = "no";
            if (*((unsigned char *)v40 + 48)) {
              uint64_t v33 = "yes";
            }
          }
          else
          {
            uint64_t v33 = "no";
          }
          *(_DWORD *)long long buf = 138412802;
          uint64_t v48 = ValueAtIndex;
          __int16 v49 = 2080;
          uint64_t v50 = v33;
          __int16 v51 = 2112;
          CFTypeRef v52 = cf;
          _os_log_impl(&dword_1DC1CA000, v32, OS_LOG_TYPE_DEFAULT, "MMCSGetChunks, chunk %@ satisfied locally %s eith error %@", buf, 0x20u);
        }
        uint8_t v45[4] = 0;
        MMCSItemReaderWriterClose((uint64_t)v42, 0);
        if (v42) {
          C3BaseRelease(v42);
        }
        CFTypeRef v42 = 0;
        if (v44) {
          C3BaseRelease(v44);
        }
        CFTypeRef v44 = 0;
        mmcs_chunk_reference_dealloc(v41);
        mmcs_chunk_instance_dealloc(v40);
        if (v21) {
          free(v21);
        }
        if (cf) {
          CFRelease(cf);
        }
      }
    }
    v37(a2, 0);
    uint64_t v34 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = (const void *)v45[9];
      *(_DWORD *)long long buf = 134217984;
      uint64_t v48 = v35;
      _os_log_impl(&dword_1DC1CA000, v34, OS_LOG_TYPE_DEFAULT, "MMCSGetChunks - Done, found %llu bytes.", buf, 0xCu);
    }
    if (v45) {
      C3BaseRelease(v45);
    }
    CFErrorRef v45 = 0;
    if (object) {
      os_release(object);
    }
    if (v39) {
      free(v39);
    }
  }
  else
  {
    uint64_t v36 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_ERROR, "MMCSGetChunks, failed to initialize local chunk satisfyer.", buf, 2u);
    }
    a6(a2, 0);
  }
  os_activity_scope_leave(&state);
}

uint64_t MMCSGetItems(uint64_t a1, const void *a2, const __CFString *a3, uint64_t a4, const __CFDictionary *a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, CFErrorRef *a10)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  CFLocaleRef v18 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v32 = a2;
    CFStringRef v19 = a3;
    CFTypeID v20 = a7;
    uint64_t v21 = a8;
    uint64_t v22 = a4;
    CFDictionaryRef v23 = a5;
    uint64_t v24 = a6;
    CFStringRef v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"get items");
    uint64_t v26 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v25;
      _os_log_impl(&dword_1DC1CA000, v26, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    a6 = v24;
    a5 = v23;
    a4 = v22;
    a8 = v21;
    a7 = v20;
    a3 = v19;
    a2 = v32;
    if (v25) {
      CFRelease(v25);
    }
  }
  if (a10) {
    *a10 = 0;
  }
  if (!a1) {
    return 0;
  }
  if (!a2 || !a3 || !a7 || !a8)
  {
    if (a10)
    {
      uint64_t v27 = @"Missing required parameters.";
      CFIndex v28 = 40;
      goto LABEL_18;
    }
    return 0;
  }
  if (*(unsigned char *)(a1 + 120))
  {
    if (a10)
    {
      uint64_t v27 = @"Engine is already closed.";
      CFIndex v28 = 26;
LABEL_18:
      uint64_t items = 0;
      *a10 = mmcs_cferror_create_error(@"com.apple.mmcs", v28, v27);
      return items;
    }
    return 0;
  }
  *(void *)long long buf = 0;
  CStringFromCFStringSafely = _getCStringFromCFStringSafely(a3, 0x8000100u, (uint64_t)buf);
  uint64_t items = mmcs_get_items(a1, a4, a5, a2, CStringFromCFStringSafely, a6, a7, a8, a9, a10);
  if (*(void *)buf) {
    free(*(void **)buf);
  }
  return items;
}

CFArrayRef MMCSPutItems(uint64_t a1, const void *a2, const __CFString *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, CFErrorRef *a11)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  CFLocaleRef v18 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v19 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"put items");
    CFTypeID v20 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v19;
      _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v19) {
      CFRelease(v19);
    }
  }
  if (a11) {
    *a11 = 0;
  }
  if (!a1) {
    return 0;
  }
  if (!a2 || !a3 || !a7 || !a8)
  {
    if (a11)
    {
      uint64_t v21 = @"Missing required parameters.";
      CFIndex v22 = 40;
      goto LABEL_18;
    }
    return 0;
  }
  if (*(unsigned char *)(a1 + 120))
  {
    if (a11)
    {
      uint64_t v21 = @"Engine is already closed.";
      CFIndex v22 = 26;
LABEL_18:
      CFArrayRef v23 = 0;
      *a11 = mmcs_cferror_create_error(@"com.apple.mmcs", v22, v21);
      return v23;
    }
    return 0;
  }
  *(void *)long long buf = 0;
  CStringFromCFStringSafely = _getCStringFromCFStringSafely(a3, 0x8000100u, (uint64_t)buf);
  CFArrayRef v23 = mmcs_put_items(a1, a4, a5, a2, CStringFromCFStringSafely, a6, a7, a8, a9, a10, a11);
  if (*(void *)buf) {
    free(*(void **)buf);
  }
  return v23;
}

void MMCSUpdateItems(uint64_t a1, const void *a2, const __CFString *a3, uint64_t a4, void *a5, void (*a6)(uint64_t, CFDictionaryRef))
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFStringRef v12 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"update items");
    CFIndex v14 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v21 = v13;
      _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v13) {
      CFRelease(v13);
    }
  }
  if (!a1 || !a2 || !a3 || !a5)
  {
    int v15 = @"Missing required parameters.";
    CFIndex v16 = 40;
LABEL_13:
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", v16, v15);
    mmcs_update_request_abort(a4, error, a6);
    if (error) {
      CFRelease(error);
    }
    return;
  }
  if (*(unsigned char *)(a1 + 120))
  {
    int v15 = @"Engine is already closed.";
    CFIndex v16 = 26;
    goto LABEL_13;
  }
  CFStringRef v19 = 0;
  CStringFromCFStringSafely = _getCStringFromCFStringSafely(a3, 0x8000100u, (uint64_t)&v19);
  mmcs_update_items(a1, a2, CStringFromCFStringSafely, a4, a5, a6);
  if (v19) {
    free(v19);
  }
}

uint64_t MMCSPutSection(uint64_t a1, const void *a2, const __CFString *a3, uint64_t a4, void *a5, const void *a6, uint64_t a7, CFIndex a8, uint64_t a9, uint64_t a10, int a11, CFErrorRef *a12)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  CFStringRef v19 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"put section");
    CFStringRef v21 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v20) {
      CFRelease(v20);
    }
  }
  if (a12) {
    *a12 = 0;
  }
  if (!a1) {
    return 0;
  }
  if (!a2 || !a3 || !a7 || !a9)
  {
    if (a12)
    {
      uint64_t v22 = @"Missing required parameters.";
      CFIndex v23 = 40;
      goto LABEL_18;
    }
    return 0;
  }
  if (*(unsigned char *)(a1 + 120))
  {
    if (a12)
    {
      uint64_t v22 = @"Engine is already closed.";
      CFIndex v23 = 26;
LABEL_18:
      uint64_t v24 = 0;
      *a12 = mmcs_cferror_create_error(@"com.apple.mmcs", v23, v22);
      return v24;
    }
    return 0;
  }
  *(void *)long long buf = 0;
  CStringFromCFStringSafely = _getCStringFromCFStringSafely(a3, 0x8000100u, (uint64_t)buf);
  uint64_t v24 = mmcs_put_section_with_items(a1, a2, CStringFromCFStringSafely, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  if (*(void *)buf) {
    free(*(void **)buf);
  }
  return v24;
}

uint64_t MMCSGetItemsWithSection(uint64_t a1, const void *a2, const __CFString *a3, uint64_t a4, const __CFDictionary *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10, char *a11, char *a12, CFErrorRef *a13)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  CFStringRef v19 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"get section");
    CFStringRef v21 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v20) {
      CFRelease(v20);
    }
  }
  if (a13) {
    *a13 = 0;
  }
  uint64_t v58 = 0;
  *(void *)long long buf = 0;
  if (!a2 || !a3 || !a9 || !a1 || !a10)
  {
    uint64_t v22 = @"Missing required parameters.";
    CFIndex v23 = 40;
    goto LABEL_16;
  }
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v22 = @"Engine is already closed.";
    CFIndex v23 = 26;
LABEL_16:
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", v23, v22);
    uint64_t items = 0;
    uint64_t v26 = 0;
LABEL_17:
    CFMutableArrayRef Mutable = 0;
    goto LABEL_18;
  }
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a5);
  uint64_t v26 = MutableCopy;
  if (!MutableCopy)
  {
    CFTypeRef v44 = @"Failed to alloc mutableRequestOptions.";
    CFIndex v45 = 36;
    goto LABEL_62;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(MutableCopy, @"kMMCSRequestOptionItemOptions");
  if (!Value || (theArray = Value, CFTypeID v33 = CFGetTypeID(Value), v33 != CFArrayGetTypeID()))
  {
    CFTypeRef v44 = @"Missing kMMCSRequestOptionItemOptions.";
LABEL_60:
    CFIndex v45 = 40;
LABEL_62:
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", v45, v44);
    uint64_t items = 0;
    goto LABEL_17;
  }
  if (CFArrayGetCount(theArray) != a8)
  {
    CFTypeRef v44 = @"kMMCSRequestOptionItemOptions had wrong type.";
    goto LABEL_60;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    CFStringRef v46 = @"Failed to alloc newItemOptionsArray.";
    CFIndex v47 = 36;
LABEL_66:
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", v47, v46);
    uint64_t items = 0;
LABEL_18:
    uint64_t v28 = 0;
LABEL_19:
    uint64_t v29 = 0;
    goto LABEL_20;
  }
  uint64_t v49 = a4;
  if (a8 >= 1)
  {
    CFIndex v34 = 0;
    uint64_t v50 = a8;
    while (1)
    {
      CFIndex v51 = v34;
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v34);
      if (!ValueAtIndex || (v36 = ValueAtIndex, CFTypeID v37 = CFGetTypeID(ValueAtIndex), v37 != CFDictionaryGetTypeID()))
      {
        CFStringRef v46 = @"kMMCSRequestOptionItemOptions element had wrong type.";
        CFIndex v47 = 40;
        goto LABEL_66;
      }
      uint64_t v28 = CFDictionaryCreateMutableCopy(allocator, 0, v36);
      if (!v28)
      {
        CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 36, @"Failed to alloc mutableItemOptionsElementDictionary.");
        uint64_t items = 0;
        goto LABEL_19;
      }
      CFNumberRef v30 = CFNumberCreate(allocator, kCFNumberSInt64Type, a11);
      if (!v30)
      {
        uint64_t v48 = @"offsets type issue.";
        goto LABEL_73;
      }
      CFDictionarySetValue(v28, @"kMMCSRequestedFileOffset", v30);
      CFRelease(v30);
      CFNumberRef v30 = CFNumberCreate(allocator, kCFNumberSInt64Type, a12);
      if (!v30)
      {
        uint64_t v48 = @"lengths type issue.";
        goto LABEL_73;
      }
      CFDictionarySetValue(v28, @"kMMCSRequestedLengthAtFileOffset", v30);
      CFRelease(v30);
      CFNumberRef v30 = mmcs_file_signature_to_cfdata(*(const UInt8 **)(a10 + 8 * v34));
      if (!v30) {
        break;
      }
      CFDictionarySetValue(v28, @"kMMCSRequestedRangeSignature", v30);
      CFRelease(v30);
      CFArrayAppendValue(Mutable, v28);
      CFRelease(v28);
      ++v34;
      a12 += 8;
      a11 += 8;
      a8 = v50;
      if (v50 == v51 + 1) {
        goto LABEL_38;
      }
    }
    uint64_t v48 = @"signatures issue.";
LABEL_73:
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 40, v48);
    uint64_t items = 0;
    uint64_t v29 = 0;
LABEL_21:
    *(void *)long long buf = error;
    if (!a13) {
      goto LABEL_44;
    }
    goto LABEL_22;
  }
LABEL_38:
  CFDictionarySetValue(v26, @"kMMCSRequestOptionItemOptions", Mutable);
  CFRelease(Mutable);
  uint64_t v29 = malloc_type_calloc(a8, 8uLL, 0x50040EE9192B6uLL);
  if (!v29)
  {
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 36, @"Failed to alloc newTokens.");
    uint64_t items = 0;
    CFMutableArrayRef Mutable = 0;
    uint64_t v28 = 0;
LABEL_20:
    CFNumberRef v30 = 0;
    goto LABEL_21;
  }
  CFNumberRef v38 = (const __CFNumber *)malloc_type_calloc(a8, 8uLL, 0x50040EE9192B6uLL);
  CFNumberRef v30 = v38;
  if (!v38)
  {
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 36, @"Failed to alloc newSignatures.");
    uint64_t items = 0;
    CFMutableArrayRef Mutable = 0;
    uint64_t v28 = 0;
    goto LABEL_21;
  }
  if (a8 >= 1)
  {
    uint64_t v39 = v29;
    CFNumberRef v40 = v38;
    uint64_t v41 = a8;
    do
    {
      *v39++ = a7;
      *(void *)CFNumberRef v40 = a6;
      CFNumberRef v40 = (const __CFNumber *)((char *)v40 + 8);
      --v41;
    }
    while (v41);
  }
  CStringFromCFStringSafely = _getCStringFromCFStringSafely(a3, 0x8000100u, (uint64_t)&v58);
  uint64_t items = mmcs_get_items(a1, v49, v26, a2, CStringFromCFStringSafely, a8, a9, (uint64_t)v30, (uint64_t)v29, (CFErrorRef *)buf);
  CFMutableArrayRef Mutable = 0;
  uint64_t v28 = 0;
  CFErrorRef error = *(CFErrorRef *)buf;
  if (!a13) {
    goto LABEL_44;
  }
LABEL_22:
  if (error)
  {
    *a13 = error;
    goto LABEL_46;
  }
LABEL_44:
  if (error) {
    CFRelease(error);
  }
LABEL_46:
  *(void *)long long buf = 0;
  if (v58) {
    free(v58);
  }
  uint64_t v58 = 0;
  if (v29) {
    free(v29);
  }
  if (v30) {
    free(v30);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v28) {
    CFRelease(v28);
  }
  return items;
}

uint64_t MMCSRegisterFile(uint64_t a1, uint64_t a2, void **a3, void *a4, CFErrorRef *a5)
{
  return MMCSRegisterFileWithOptions(a1, a2, a3, a4, a5, 0);
}

uint64_t MMCSRegisterFileWithOptions(uint64_t a1, uint64_t a2, void **a3, void *a4, CFErrorRef *a5, const __CFDictionary *a6)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CFStringRef v12 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"register file");
    CFIndex v14 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    }
    if (v13) {
      CFRelease(v13);
    }
  }
  *(void *)long long buf = 0;
  theDict[1] = 0;
  uint64_t v31 = 0;
  *(void *)&uint8_t buf[8] = a2;
  theDict[0] = a6;
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5)
  {
    *a5 = 0;
    if (!MMCSRegisterFilesWithOptions(a1, (uint64_t)buf, 1u))
    {
      uint64_t v22 = 0;
      *a5 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, @"engine argument is NULL", v15, v16, v17, v18, v19, v27);
      goto LABEL_30;
    }
    if (!(_BYTE)v31)
    {
      if (theDict[1]
        && (CFArrayRef Value = (__CFError *)CFDictionaryGetValue(theDict[1], @"kMMCSRegisterFileResultError")) != 0)
      {
        CFStringRef v21 = Value;
        CFRetain(Value);
        uint64_t v22 = 0;
        *a5 = v21;
      }
      else
      {
        uint64_t v22 = 0;
      }
      goto LABEL_30;
    }
  }
  else
  {
    int v23 = MMCSRegisterFilesWithOptions(a1, (uint64_t)buf, 1u);
    uint64_t v22 = 0;
    if (!v23 || !(_BYTE)v31) {
      goto LABEL_30;
    }
  }
  if (a3)
  {
    if (theDict[1])
    {
      CFDataRef v24 = (const __CFData *)CFDictionaryGetValue(theDict[1], @"kMMCSRegisterFileResultSignature");
      if (v24) {
        *a3 = MMCSSignatureCreateWithData(v24);
      }
    }
  }
  if (a4)
  {
    if (theDict[1])
    {
      CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(theDict[1], @"kMMCSRegisterFileResultFileSize");
      if (v25)
      {
        uint64_t valuePtr = 0;
        if (CFNumberGetValue(v25, kCFNumberSInt64Type, &valuePtr)) {
          *a4 = valuePtr;
        }
      }
    }
  }
  uint64_t v22 = 1;
LABEL_30:
  if (theDict[1]) {
    CFRelease(theDict[1]);
  }
  return v22;
}

uint64_t MMCSRegisterFilesWithOptions(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    if (a3)
    {
      uint64_t v3 = result;
      int v60 = 0;
      CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v5 = a3;
      CFTypeID v6 = (unsigned char *)(a2 + 32);
      CFStringRef v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      int v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      uint64_t v9 = a3;
      CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v4, 0, v7, v8);
        *CFTypeID v6 = 0;
        *((void *)v6 - 1) = Mutable;
        if (*(unsigned char *)(v3 + 120))
        {
          CFErrorRef v16 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 26, @"The engine is closed", v10, v11, v12, v13, v14, v58);
          if (v16)
          {
            CFErrorRef v17 = v16;
            CFDictionarySetValue(Mutable, @"kMMCSRegisterFileResultError", v16);
            CFRelease(v17);
          }
        }
        else
        {
          uint64_t v18 = v8;
          uint64_t v19 = v7;
          uint64_t v66 = 0;
          CFDictionaryRef v20 = (const __CFDictionary *)*((void *)v6 - 2);
          if (v20)
          {
            BOOL v21 = mmcs_get_BOOLean_from_cfdictionary_object_for_key(v20, @"kMMCSRegisterFileOptionPublic", 0) == 0;
            int BOOLean_from_cfdictionary_object_for_key = mmcs_get_BOOLean_from_cfdictionary_object_for_key(*((const __CFDictionary **)v6 - 2), @"kMMCSRegisterFileOptionChunk", 0);
          }
          else
          {
            int BOOLean_from_cfdictionary_object_for_key = 0;
            BOOL v21 = 1;
          }
          uint64_t v64 = 0;
          CFTypeRef v65 = 0;
          int v63 = 0;
          uint64_t v23 = *(void *)(v3 + 152);
          uint64_t v24 = mmcs_engine_owner(v3);
          int ItemReaderWriterForItem = MMCSEngineClientContextGetItemReaderWriterForItem(v23, v24, 0, *((void *)v6 - 3), 1, &v64, (CFTypeRef *)&v66);
          uint64_t v26 = v64;
          if (ItemReaderWriterForItem && v64)
          {
            if (MMCSItemReaderWriterOpen((uint64_t)v64, (CFTypeRef *)&v66))
            {
              *CFTypeID v6 = mmcs_compute_signature_and_register_item_with_item_reader_writer(*(void *)(v3 + 16), *((void *)v6 - 3), (uint64_t)v64, v21, BOOLean_from_cfdictionary_object_for_key, 0, &v65, &v63, 0, 0, (void **)&v66);
              if (!MMCSItemReaderWriterClose((uint64_t)v64, &v66))
              {
                if (v66)
                {
                  char v27 = mmcs_cferror_copy_description(v66);
                  uint64_t v28 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v29 = @"(none)";
                    if (v27) {
                      uint64_t v29 = v27;
                    }
                    CFStringRef v30 = CFStringCreateWithFormat(alloc, 0, @"Closing itemReaderWriter failed with error %@", v29);
                    uint64_t v31 = mmcs_logging_logger_default();
                    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)long long buf = 138543362;
                      *(void *)&uint8_t buf[4] = v30;
                      _os_log_impl(&dword_1DC1CA000, v31, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
                    }
                    if (v30) {
                      CFRelease(v30);
                    }
                  }
                  if (v27) {
                    CFRelease(v27);
                  }
                }
              }
            }
            uint64_t v26 = v64;
          }
          CFStringRef v7 = v19;
          if (v26) {
            C3BaseRelease(v26);
          }
          uint64_t v64 = 0;
          int v32 = *v6;
          int v8 = v18;
          if (*v6)
          {
            CFTypeID v33 = (const UInt8 *)CKFileDigestResultsFileSignature();
            CFDataRef v34 = MMCSSignatureCopyData(v33);
            CFAllocatorRef v4 = alloc;
            if (v34)
            {
              CFDataRef v35 = v34;
              CFDictionarySetValue(Mutable, @"kMMCSRegisterFileResultSignature", v34);
              CFRelease(v35);
            }
            *(void *)long long buf = 0;
            *(void *)long long buf = CKFileDigestResultsFileLength();
            CFNumberRef v36 = CFNumberCreate(alloc, kCFNumberSInt64Type, buf);
            if (v36)
            {
              CFNumberRef v37 = v36;
              CFDictionarySetValue(Mutable, @"kMMCSRegisterFileResultFileSize", v36);
              CFRelease(v37);
            }
            int valuePtr = v63;
            CFNumberRef v38 = CFNumberCreate(alloc, kCFNumberSInt32Type, &valuePtr);
            if (v38)
            {
              CFNumberRef v39 = v38;
              CFDictionarySetValue(Mutable, @"kMMCSRegisterFileResultChunkCount", v38);
              CFRelease(v39);
            }
            int v32 = *v6;
            int v60 = 1;
          }
          else
          {
            CFAllocatorRef v4 = alloc;
          }
          CFNumberRef v40 = v66;
          if (!v32 && v66)
          {
            CFDictionarySetValue(Mutable, @"kMMCSRegisterFileResultError", v66);
            CFNumberRef v40 = v66;
          }
          if (v40) {
            CFRelease(v40);
          }
          uint64_t v66 = 0;
          if (v65) {
            C3BaseRelease(v65);
          }
        }
        v6 += 40;
        --v9;
      }
      while (v9);
      if (v60) {
        mmcs_engine_force_commit((void *)v3);
      }
      uint64_t v41 = a2 + 24;
      do
      {
        CFDictionaryRef v42 = *(const __CFDictionary **)v41;
        if (!*(unsigned char *)(v41 + 8))
        {
          if (v42 && (CFArrayRef Value = (__CFError *)CFDictionaryGetValue(v42, @"kMMCSRegisterFileResultError")) != 0) {
            CFTypeRef v52 = mmcs_cferror_copy_description(Value);
          }
          else {
            CFTypeRef v52 = 0;
          }
          uint64_t v55 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v56 = *(void *)(v41 - 16);
            if (v52) {
              CFIndex v57 = v52;
            }
            else {
              CFIndex v57 = @"(no error specified)";
            }
            *(_DWORD *)long long buf = 134218242;
            *(void *)&uint8_t buf[4] = v56;
            __int16 v68 = 2114;
            int v69 = v57;
            _os_log_impl(&dword_1DC1CA000, v55, OS_LOG_TYPE_DEFAULT, "Failed to register item %lld in chunk store: %{public}@.", buf, 0x16u);
          }
          if (v52) {
            CFRelease(v52);
          }
          goto LABEL_68;
        }
        if (v42)
        {
          unsigned int v43 = (__CFString *)CFDictionaryGetValue(v42, @"kMMCSRegisterFileResultSignature");
          if (*(void *)v41)
          {
            CFTypeRef v44 = CFDictionaryGetValue(*(CFDictionaryRef *)v41, @"kMMCSRegisterFileResultChunkCount");
            if (v44)
            {
              CFIndex v45 = v44;
              CFStringRef v46 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
              {
                uint64_t v47 = *(void *)(v41 - 16);
                *(_DWORD *)long long buf = 134218498;
                *(void *)&uint8_t buf[4] = v47;
                __int16 v68 = 2114;
                int v69 = v43;
                __int16 v70 = 2114;
                unsigned int v71 = v45;
                uint64_t v48 = v46;
                uint64_t v49 = "Committed newly registered item %lld as %{public}@ to chunk store with %{public}@ chunks.";
                uint32_t v50 = 32;
LABEL_59:
                _os_log_impl(&dword_1DC1CA000, v48, OS_LOG_TYPE_INFO, v49, buf, v50);
                goto LABEL_68;
              }
              goto LABEL_68;
            }
          }
        }
        else
        {
          unsigned int v43 = 0;
        }
        uint64_t v53 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
        {
          uint64_t v54 = *(void *)(v41 - 16);
          *(_DWORD *)long long buf = 134218242;
          *(void *)&uint8_t buf[4] = v54;
          __int16 v68 = 2114;
          int v69 = v43;
          uint64_t v48 = v53;
          uint64_t v49 = "Committed newly registered item %lld as %{public}@ to chunk store.";
          uint32_t v50 = 22;
          goto LABEL_59;
        }
LABEL_68:
        v41 += 40;
        --v5;
      }
      while (v5);
    }
    return 1;
  }
  return result;
}

void *MMCSSignatureCreateWithData(const __CFData *a1)
{
  if (!a1) {
    return 0;
  }
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  if (!mmcs_file_signature_is_valid_n((uint64_t)BytePtr, Length)) {
    return 0;
  }
  CFAllocatorRef v4 = CFDataGetBytePtr(a1);
  return mmcs_file_signature_copy(v4);
}

CFDataRef MMCSSignatureCopyData(const UInt8 *a1)
{
  if (!mmcs_file_signature_is_valid((BOOL)a1)) {
    return 0;
  }
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex v3 = mmcs_file_signature_size_with_scheme(a1);
  return CFDataCreate(v2, a1, v3);
}

uint64_t MMCSDuplicateRegisteredfile(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if CKGetRegisteredFileMetadata() && (CKRegisterFile())
  {
    if (CKGetRegisteredChunksForItemID())
    {
      uint64_t v6 = 0;
      while (1)
      {
        CKRegisteredChunkSignature();
        CKRegisteredChunkKey();
        uint64_t v7 = CKCreateRegisteredChunk();
        if (!v7) {
          break;
        }
        int v8 = (void *)v7;
        CKRegisteredChunkSetItemID();
        CKRegisteredChunkLength();
        CKRegisteredChunkSetLength();
        CKRegisteredChunkOffset();
        CKRegisteredChunkSetOffset();
        int v9 = CKRegisterTemporaryChunk();
        free(v8);
        if (!v9) {
          break;
        }
        CKRegisteredChunkSize();
        if ((unint64_t)++v6 >= 0x4E20)
        {
          uint64_t v10 = CKConvertTemporaryChunks();
          goto LABEL_16;
        }
      }
    }
    uint64_t v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      CFStringRef v18 = a2;
      _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "MMCSDuplicateRegisteredfile failed to get chunk list for itemID %lld", buf, 0xCu);
    }
    uint64_t v10 = 0;
LABEL_16:
    mmcs_engine_copy_cached_ranged_items(a1, a2, a3);
    if (v10)
    {
      uint64_t v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"MMCSDuplicateRegisteredfile copied id %llu to %llu", a2, a3);
        CFErrorRef v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v18 = v15;
          _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v15) {
          CFRelease(v15);
        }
      }
    }
  }
  else
  {
    uint64_t v11 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      CFStringRef v18 = a2;
      _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_ERROR, "Unable to duplicate itemID %lld", buf, 0xCu);
    }
    return 0;
  }
  return v10;
}

uint64_t MMCSRegisterFiles(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!a3) {
    return 1;
  }
  uint64_t v6 = (char *)malloc_type_calloc(1uLL, 40 * a3, 0x10600401EFA0F88uLL);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  uint64_t v8 = 0;
  uint64_t v9 = a3;
  do
  {
    uint64_t v10 = a2 + v8;
    uint64_t v11 = *(void *)(a2 + v8);
    uint64_t v12 = &v6[v8];
    *(void *)uint64_t v12 = 0;
    *((void *)v12 + 1) = v11;
    *((void *)v12 + 2) = 0;
    *((void *)v12 + 3) = 0;
    *(unsigned char *)(v10 + 8) = 0;
    *(void *)(v10 + 24) = 0;
    *(void *)(v10 + 32) = 0;
    *(void *)(v10 + 16) = 0;
    v8 += 40;
  }
  while (40 * a3 != v8);
  uint64_t v13 = MMCSRegisterFilesWithOptions(a1, (uint64_t)v6, a3);
  if (v13)
  {
    uint64_t v14 = (CFDictionaryRef *)(v7 + 24);
    CFStringRef v15 = (void *)(a2 + 32);
    do
    {
      *((unsigned char *)v15 - 24) = *((unsigned char *)v14 + 8);
      if (*v14)
      {
        CFDataRef Value = (const __CFData *)CFDictionaryGetValue(*v14, @"kMMCSRegisterFileResultSignature");
        if (Value) {
          *(v15 - 2) = MMCSSignatureCreateWithData(Value);
        }
        CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(*v14, @"kMMCSRegisterFileResultFileSize");
        if (v17)
        {
          uint64_t valuePtr = 0;
          if (CFNumberGetValue(v17, kCFNumberSInt64Type, &valuePtr)) {
            *(v15 - 1) = valuePtr;
          }
        }
        CFStringRef v18 = CFDictionaryGetValue(*v14, @"kMMCSRegisterFileResultError");
        if (v18)
        {
          uint64_t v19 = v18;
          CFRetain(v18);
          *CFStringRef v15 = v19;
        }
        if (*v14) {
          CFRelease(*v14);
        }
        *uint64_t v14 = 0;
      }
      v14 += 5;
      v15 += 5;
      --v9;
    }
    while (v9);
  }
  free(v7);
  return v13;
}

void MMCSRegisterItems(uint64_t a1, uint64_t a2, void *a3, void (*a4)(uint64_t, CFDictionaryRef))
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"register items");
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      int v14 = 138543362;
      CFStringRef v15 = v9;
      _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&v14, 0xCu);
    }
    if (v9) {
      CFRelease(v9);
    }
  }
  if (a1 && a3)
  {
    if (!*(unsigned char *)(a1 + 120))
    {
      mmcs_register_items(a1, a2, a3, a4);
      return;
    }
    uint64_t v11 = @"Engine is already closed.";
    CFIndex v12 = 26;
  }
  else
  {
    uint64_t v11 = @"Missing required parameters.";
    CFIndex v12 = 40;
  }
  CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", v12, v11);
  mmcs_register_request_abort(a2, error, a4);
  if (error) {
    CFRelease(error);
  }
}

void MMCSUnregisterFiles(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a1 && !*(unsigned char *)(a1 + 120) && *(void *)(a1 + 16))
  {
    mmcs_library_init();
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (a3)
    {
      uint64_t v7 = 0;
      while (1)
      {
        uint64_t v8 = *(const void **)(a2 + v7);
        CFTypeRef cf = 0;
        uint64_t v22 = 0;
        if (mmcs_engine_file_path(a1, "tmpm", (uint64_t)v8, &v22, (CFErrorRef *)&cf)) {
          break;
        }
        CFStringRef v18 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v16 = CFStringCreateWithFormat(alloc, 0, @"Unable to create path for item %lld %@", v8, cf);
          CFNumberRef v17 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
            goto LABEL_21;
          }
          goto LABEL_22;
        }
LABEL_24:
        if (v22) {
          free(v22);
        }
        uint64_t v22 = 0;
        if (v7) {
          CFStringAppendFormat(Mutable, 0, @", %llu", v8);
        }
        else {
          CFStringAppendFormat(Mutable, 0, @"%llu", v8);
        }
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = 0;
        CKUnregisterFile();
        mmcs_engine_clear_cached_ranged_items(a1, v8);
        v7 += 8;
        if (8 * a3 == v7) {
          goto LABEL_32;
        }
      }
      if (gMMCS_DebugLevel >= 5)
      {
        CFStringRef v9 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v10 = CFStringCreateWithFormat(alloc, 0, @"Deleting temporary file at path %s for item %lld", v22, v8);
          uint64_t v11 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v24 = v10;
            _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v10) {
            CFRelease(v10);
          }
        }
      }
      if (!unlink(v22)) {
        goto LABEL_24;
      }
      uint64_t v12 = *__error();
      if (*__error() == 2) {
        goto LABEL_24;
      }
      uint64_t v13 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
      int v14 = v22;
      CFStringRef v15 = strerror(v12);
      CFStringRef v16 = CFStringCreateWithFormat(alloc, 0, @"Deleting temporary file at path %s for item %lld failed :%s(%d)", v14, v8, v15, v12);
      CFNumberRef v17 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
LABEL_21:
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v24 = v16;
        _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
LABEL_22:
      if (v16) {
        CFRelease(v16);
      }
      goto LABEL_24;
    }
LABEL_32:
    mmcs_engine_force_commit((void *)a1);
    uint64_t v19 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v24 = Mutable;
      _os_log_impl(&dword_1DC1CA000, v19, OS_LOG_TYPE_INFO, "Committed unregister of items with itemIDs (%{public}@)", buf, 0xCu);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
}

void MMCSUnregisterFile(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  MMCSUnregisterFiles(a1, (uint64_t)&v2, 1u);
}

uint64_t MMCSRegisteredItemCount(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 120))
    {
      return 0;
    }
    else
    {
      CFIndex result = *(void *)(result + 16);
      if (result) {
        return CKRegisteredItemCount();
      }
    }
  }
  return result;
}

uint64_t MMCSGetRegisteredItems(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 120))
    {
      return 0;
    }
    else
    {
      CFIndex result = *(void *)(result + 16);
      if (result) {
        return CKGetRegisteredItems();
      }
    }
  }
  return result;
}

BOOL MMCSGetItemStateIsDeterminant(int a1)
{
  return a1 == 3;
}

BOOL MMCSPutItemStateIsDeterminant(int a1)
{
  return a1 == 4 || a1 == 2;
}

uint64_t MMCSUpdateItemStateIsDeterminant()
{
  return 0;
}

uint64_t MMCSSignatureGeneratorCreate()
{
  return 0;
}

const UInt8 *MMCSSignatureGeneratorCreateWithBoundaryKey(const UInt8 *a1)
{
  CFIndex result = mmcs_file_digest_arguments_create_with_boudnary_key(a1);
  if (result)
  {
    uint64_t v2 = result;
    CKFileSignatureGeneratorCreate();
    C3BaseRelease(v2);
    return 0;
  }
  return result;
}

const UInt8 *MMCSSignatureGeneratorCreateWithVerificationKey(const UInt8 *result)
{
  if (result)
  {
    CFDataRef v1 = (const __CFData *)result;
    if (CFDataGetLength((CFDataRef)result) == 32)
    {
      CFIndex result = CFDataGetBytePtr(v1);
      if (!result) {
        return result;
      }
      BytePtr = CFDataGetBytePtr(v1);
      if (!mmcs_zcmp((uint64_t)BytePtr, 0x20uLL))
      {
        CKFileDigestArgumentsV2WithFileKeyCreate();
        return 0;
      }
    }
    return 0;
  }
  return result;
}

uint64_t MMCSSignatureGeneratorFinish(const void *a1)
{
  if (a1) {
    CFRelease(a1);
  }
  CKFileDigestResultsFileSignature();
  return CKFileSignatureCopy();
}

uint64_t MMCSPackageSectionSignatureGeneratorCreate()
{
  return 0;
}

uint64_t MMCSPackageSectionSignatureGeneratorCreateWithBoundaryKey()
{
  return 0;
}

uint64_t MMCSPackageSectionSignatureGeneratorCreateWithFileKey()
{
  return 0;
}

uint64_t MMCSPackageSectionSignatureGeneratorFinish(const void *a1)
{
  if (a1) {
    CFRelease(a1);
  }
  CKFileDigestResultsFileSignature();
  return CKFileSignatureCopy();
}

__CFDictionary *MMCSPackageSectionSignatureGeneratorFinishWithResults(const void *a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CKFileSignatureGeneratorFinish();
  if (a1) {
    CFRelease(a1);
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    uint64_t v2 = Mutable;
    uint64_t v6 = (const UInt8 *)CKFileDigestResultsFileSignature();
    CFDataRef v7 = MMCSSignatureCopyData(v6);
    CFDictionaryAddValue(v2, @"kMMCSSignature", v7);
    if (v7) {
      CFRelease(v7);
    }
    uint64_t v8 = (const void *)CKFileDigestResultsFileVerificationKey();
    if (v8) {
      CFDictionaryAddValue(v2, @"kMMCSVerificationKey", v8);
    }
    return v2;
  }
  CFStringRef v9 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
    return 0;
  }
  uint64_t v2 = (__CFDictionary *)CFStringCreateWithFormat(v4, 0, @"Unable to allocate results");
  CFStringRef v10 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138543362;
    uint64_t v12 = v2;
    _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
  }
  if (v2)
  {
    CFRelease(v2);
    return 0;
  }
  return v2;
}

uint64_t MMCSGetMaxChunkCountForSection()
{
  return 10000;
}

uint64_t MMCSSignatureIsValidV2(uint64_t result)
{
  if (result)
  {
    CFDataRef v1 = (unsigned __int8 *)result;
    CFIndex result = mmcs_file_signature_is_valid(result);
    if (result)
    {
      unsigned int v2 = *v1;
      int v3 = v2 & 0x7F;
      unsigned int v4 = (v2 >> 3) & 1;
      if (v3 == 4) {
        return 1;
      }
      else {
        return v4;
      }
    }
  }
  return result;
}

uint64_t MMCSSignatureCreateFromFileDescriptor(uint64_t a1, CFTypeRef *a2)
{
  return mmcs_file_signature_create_from_file_descriptor(0, a1, a2);
}

uint64_t MMCSSignatureCreateWithBoundaryKeyFromFileDescriptor(const UInt8 *a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    return mmcs_file_signature_create_from_file_descriptor(a1, a2, a3);
  }
  else
  {
    if (a3) {
      *a3 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, @"boundaryKey must not be NULL", a4, a5, a6, a7, a8, v9);
    }
    return 0;
  }
}

uint64_t MMCSComputeSignatureAndRegisterItemWithDescriptor(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char **a7, uint64_t *a8, void *a9)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!a1 || *(unsigned char *)(a1 + 120)) {
    return 0;
  }
  CFTypeRef cf = 0;
  CFStringRef v18 = MMCSItemReaderWriterCreateWithFileDescriptor(a6, 0, 0, 0, (CFErrorRef *)&cf);
  if (v18)
  {
    uint64_t v19 = v18;
    if (MMCSItemReaderWriterOpen((uint64_t)v18, &cf))
    {
      CFTypeRef v39 = 0;
      unsigned int v38 = 0;
      CFNumberRef v37 = 0;
      uint64_t v10 = mmcs_compute_signature_and_register_item_with_item_reader_writer(*(void *)(a1 + 16), a2, (uint64_t)v19, a3 == 0, a5 != 0, a5, &v39, &v38, &v37, 0, (void **)&cf);
      if (v10 || !cf)
      {
        if (v10)
        {
          if (a7)
          {
            uint64_t v25 = (const void *)CKFileDigestResultsFileSignature();
            *a7 = (char *)mmcs_file_signature_copy(v25);
          }
          if (a8) {
            *a8 = CKFileDigestResultsFileLength();
          }
          if (a9)
          {
            uint64_t v26 = 0;
            if (a5 && v38)
            {
              unint64_t v27 = 0;
              uint64_t v26 = 0;
              do
              {
                uint64_t v28 = CKRegisteredChunkLength();
                v26 += mmcs_padded_chunk_length_with_policy_and_chunk_length(a4, v28);
                CKRegisteredChunkSize();
                ++v27;
              }
              while (v27 < v38);
            }
            *a9 = v26;
          }
          mmcs_engine_force_commit((void *)a1);
          uint64_t v29 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
          {
            CFStringRef v30 = mmcs_file_signature_to_hexstring(*a7);
            uint64_t v31 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)long long buf = 134218242;
              uint64_t v42 = a2;
              __int16 v43 = 2082;
              CFTypeRef v44 = v30;
              _os_log_impl(&dword_1DC1CA000, v31, OS_LOG_TYPE_INFO, "Committed newly registered item %lld as %{public}s to chunk store.", buf, 0x16u);
            }
            if (v30) {
              free(v30);
            }
          }
        }
      }
      else
      {
        CFDictionaryRef v20 = mmcs_cferror_copy_description((__CFError *)cf);
        BOOL v21 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          uint64_t v22 = @"(none)";
          if (v20) {
            uint64_t v22 = v20;
          }
          CFStringRef v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"registering item failed with error %@", v22);
          CFStringRef v24 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            uint64_t v42 = (uint64_t)v23;
            _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v23) {
            CFRelease(v23);
          }
        }
        if (v20) {
          CFRelease(v20);
        }
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = 0;
      }
      if (!MMCSItemReaderWriterClose((uint64_t)v19, (CFErrorRef *)&cf) && cf)
      {
        int v32 = mmcs_cferror_copy_description((__CFError *)cf);
        CFTypeID v33 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          CFDataRef v34 = @"(none)";
          if (v32) {
            CFDataRef v34 = v32;
          }
          CFStringRef v35 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Closing itemReaderWriter failed with error %@", v34);
          CFNumberRef v36 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            uint64_t v42 = (uint64_t)v35;
            _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v35) {
            CFRelease(v35);
          }
        }
        if (v32) {
          CFRelease(v32);
        }
      }
      if (v39) {
        C3BaseRelease(v39);
      }
      CFTypeRef v39 = 0;
      if (v37) {
        free(v37);
      }
    }
    else
    {
      uint64_t v10 = 0;
    }
    C3BaseRelease(v19);
  }
  else
  {
    uint64_t v10 = 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

CFDataRef MMCSReferenceObjectCreateWithType(int a1, CFErrorRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 == 1)
  {
    size_t v9 = 16;
  }
  else
  {
    if (a1 != 2)
    {
      CFErrorRef v23 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, @"Unsupported asset key type requested : %llu", a4, a5, a6, a7, a8, a1);
      CFStringRef v15 = 0;
      if (a2)
      {
LABEL_16:
        CFDataRef v24 = 0;
        goto LABEL_17;
      }
LABEL_9:
      if (v23) {
        CFRelease(v23);
      }
      CFDataRef v24 = 0;
      if (v15) {
        goto LABEL_18;
      }
      return v24;
    }
    size_t v9 = 32;
  }
  CFStringRef v15 = malloc_type_malloc(v9, 0xC027B62DuLL);
  if (!v15)
  {
    CFStringRef v25 = @"Failed to allocated bytes for key generation.";
LABEL_14:
    CFErrorRef v23 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, v25, v10, v11, v12, v13, v14, v28);
LABEL_15:
    if (a2) {
      goto LABEL_16;
    }
    goto LABEL_9;
  }
  if (SecRandomCopyBytes((SecRandomRef)*MEMORY[0x1E4F3BC60], v9, v15))
  {
    int v16 = *__error();
    CFNumberRef v17 = __error();
    strerror(*v17);
    CFErrorRef v23 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"SecRandomCopyBytes failed with error code %d: %s", v18, v19, v20, v21, v22, v16);
    goto LABEL_15;
  }
  CFDataRef v27 = XCFDataCreateWithBytesNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], (const UInt8 *)v15, v9, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
  if (!v27)
  {
    CFStringRef v25 = @"Failed to allocated CFData wrapper for AssetKey.";
    goto LABEL_14;
  }
  CFDataRef v24 = v27;
  if (!a2) {
    return v24;
  }
  CFErrorRef v23 = 0;
  CFStringRef v15 = 0;
LABEL_17:
  *a2 = v23;
  if (v15) {
LABEL_18:
  }
    free(v15);
  return v24;
}

CFDataRef MMCSReferenceSignatureCreateWithReferenceObject(const __CFData *a1, CFErrorRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    CFStringRef v22 = @"ReferenceObject must not be NULL.";
    goto LABEL_9;
  }
  if (!CFDataGetLength(a1))
  {
    CFStringRef v22 = @"ReferenceObject must have non-zero size.";
LABEL_9:
    CFErrorRef v21 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 40, v22, a4, a5, a6, a7, a8, v25);
    int v16 = 0;
    if (!a2) {
      goto LABEL_17;
    }
    goto LABEL_10;
  }
  uint64_t v10 = malloc_type_calloc(1uLL, 0x15uLL, 0xF7B98C87uLL);
  int v16 = v10;
  if (v10)
  {
    unsigned char *v10 = 1;
    BytePtr = CFDataGetBytePtr(a1);
    CC_LONG Length = CFDataGetLength(a1);
    CC_SHA1(BytePtr, Length, v16 + 1);
    CFDataRef v19 = XCFDataCreateWithBytesNoCopy((const __CFAllocator *)*MEMORY[0x1E4F1CF80], v16, 21, (const __CFAllocator *)*MEMORY[0x1E4F1CF90]);
    if (v19)
    {
      CFDataRef v20 = v19;
      if (!a2) {
        return v20;
      }
      CFErrorRef v21 = 0;
      int v16 = 0;
      goto LABEL_11;
    }
    CFStringRef v24 = @"Failed to allocated CFData wrapper for ReferenceSignature.";
  }
  else
  {
    CFStringRef v24 = @"Failed to allocated bytes for ReferneceSignature generation.";
  }
  CFErrorRef v21 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, v24, v11, v12, v13, v14, v15, v25);
  if (!a2)
  {
LABEL_17:
    if (v21) {
      CFRelease(v21);
    }
    CFDataRef v20 = 0;
    if (v16) {
      goto LABEL_12;
    }
    return v20;
  }
LABEL_10:
  CFDataRef v20 = 0;
LABEL_11:
  *a2 = v21;
  if (v16) {
LABEL_12:
  }
    free(v16);
  return v20;
}

uint64_t MMCSSetLogLevel(int a1, int a2)
{
  uint64_t result = mmcs_library_init();
  if (a1 == 7)
  {
    gMMCS_DebugLevel = a2;
    gMMCS_LogTimeouts = a2 > 4;
  }
  return result;
}

CFMutableStringRef MMCSEngineCopyStatusReport(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFMutableStringRef v7 = Mutable;
  if (a1 && Mutable && !*(unsigned char *)(a1 + 120))
  {
    v9[0] = a1;
    v9[1] = a2;
    _OWORD v9[2] = (uint64_t)Mutable;
    v9[3] = a3;
    v9[4] = 0;
    v9[5] = 0;
    mmcs_engine_append_requests_description(v9);
  }
  return v7;
}

__CFArray *MMCSFlattenError(__CFError *a1)
{
  return _MMCSFlattenError(a1, 0);
}

__CFArray *_MMCSFlattenError(__CFError *a1, uint64_t a2)
{
  CFMutableStringRef Mutable = 0;
  if (!a1 || a2 == 4) {
    return Mutable;
  }
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFIndex valuePtr = CFErrorGetCode(a1);
  CFNumberRef v6 = CFNumberCreate(v5, kCFNumberCFIndexType, &valuePtr);
  CFErrorDomain Domain = CFErrorGetDomain(a1);
  CFArrayAppendValue(Mutable, Domain);
  CFArrayAppendValue(Mutable, v6);
  if (v6) {
    CFRelease(v6);
  }
  CFDictionaryRef v8 = CFErrorCopyUserInfo(a1);
  size_t v9 = (const void *)*MEMORY[0x1E4F1D190];
  if (CFDictionaryGetValue(v8, (const void *)*MEMORY[0x1E4F1D190]))
  {
    CFDataRef Value = CFDictionaryGetValue(v8, v9);
    goto LABEL_9;
  }
  if (CFDictionaryGetValue(v8, @"kMMCSErrorUnderlyingErrorArrayKey"))
  {
    CFArrayRef v11 = (const __CFArray *)CFDictionaryGetValue(v8, @"kMMCSErrorUnderlyingErrorArrayKey");
    CFDataRef Value = CFArrayGetValueAtIndex(v11, 0);
LABEL_9:
    uint64_t v12 = Value;
    if (!v8) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = 0;
  if (v8) {
LABEL_10:
  }
    CFRelease(v8);
LABEL_11:
  CFArrayRef v13 = (const __CFArray *)_MMCSFlattenError(v12, a2 + 1);
  if (v13)
  {
    CFArrayRef v14 = v13;
    v17.unsigned int length = CFArrayGetCount(v13);
    v17.CFIndex location = 0;
    CFArrayAppendArray(Mutable, v14, v17);
    CFRelease(v14);
  }
  return Mutable;
}

CFStringRef MMCSTemporaryFilePathForItem(const __CFURL *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeRef cf = 0;
  cStr = 0;
  if (mmcs_working_directory_file_path(a1, "tmpm", a2, &cStr, (CFErrorRef *)&cf)) {
    CFStringRef v2 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  }
  else {
    CFStringRef v2 = 0;
  }
  if (cStr) {
    free(cStr);
  }
  cStr = 0;
  if (cf) {
    CFRelease(cf);
  }
  return v2;
}

uint64_t mmcs_put_complete_create(CFArrayRef **a1, uint64_t a2, const void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1) {
    *a1 = 0;
  }
  uint64_t result = 0;
  if (a2)
  {
    if (a3)
    {
      uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x20uLL, 0x6004087AB86DCuLL);
      if (result)
      {
        CFMutableStringRef v7 = (CFArrayRef *)result;
        *(void *)uint64_t result = a2;
        *(void *)(result + 8) = 0;
        CFRetain(a3);
        v7[3] = (CFArrayRef)a3;
        if (gMMCS_DebugLevel >= 4)
        {
          CFDictionaryRef v8 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFIndex Count = CFArrayGetCount(v7[3]);
            CFStringRef v11 = CFStringCreateWithFormat(v9, 0, @"created mmcs_put_complete (%p) for %ld containers", v7, Count);
            uint64_t v12 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v14 = v11;
              _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v11) {
              CFRelease(v11);
            }
          }
        }
        if (a1) {
          *a1 = v7;
        }
        else {
          free(v7);
        }
        return 1;
      }
    }
  }
  return result;
}

void mmcs_put_complete_cleanup_containers(uint64_t a1)
{
  CFArrayRef v1 = *(const __CFArray **)(a1 + 24);
  if (v1)
  {
    v2.unsigned int length = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
    v2.CFIndex location = 0;
    CFArrayApplyFunction(v1, v2, (CFArrayApplierFunction)_mmcs_put_container_put_complete_done, 0);
  }
}

void mmcs_put_complete_set_error_and_push_to_containers(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 16);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 16) = 0;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 16) = cf;
    CFArrayRef v5 = *(const __CFArray **)(a1 + 24);
    v7.unsigned int length = CFArrayGetCount(v5);
    CFNumberRef v6 = *(void **)(a1 + 16);
    v7.CFIndex location = 0;
    CFArrayApplyFunction(v5, v7, (CFArrayApplierFunction)mmcs_container_set_complete_error_if_absent, v6);
  }
}

void mmcs_put_complete_cancel(uint64_t a1, void *cf)
{
  if (!*(void *)(a1 + 16)) {
    mmcs_put_complete_set_error_and_push_to_containers(a1, cf);
  }
  unsigned int v4 = *(unsigned char **)(a1 + 8);
  if (v4)
  {
    mmcs_http_context_should_cancel(v4, (__CFError *)cf);
  }
}

void mmcs_put_complete_dealloc(void *a1)
{
  if (a1)
  {
    *a1 = 0;
    uint64_t v2 = a1[1];
    if (v2)
    {
      mmcs_http_context_invalidate(v2);
      CFTypeRef v3 = (const void *)a1[1];
      if (v3) {
        C3BaseRelease(v3);
      }
      a1[1] = 0;
    }
    unsigned int v4 = (const void *)a1[3];
    if (v4) {
      CFRelease(v4);
    }
    a1[3] = 0;
    CFArrayRef v5 = (const void *)a1[2];
    if (v5) {
      CFRelease(v5);
    }
    free(a1);
  }
}

void mmcs_put_complete_append_description(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v2 = *((_OWORD *)a1 + 2);
  long long v3 = *(_OWORD *)a1;
  long long v6 = *((_OWORD *)a1 + 1);
  long long v7 = v2;
  long long v5 = v3;
  ++*((void *)&v6 + 1);
  uint64_t v4 = *(void *)(v1 + 8);
  if (v4)
  {
    *(void *)&long long v5 = v4;
    mmcs_http_context_append_description((uint64_t)&v5);
  }
}

uint64_t mmcs_perform_dispatch_source_create(void **a1, _OWORD *a2, NSObject *a3)
{
  *a1 = 0;
  CFMutableStringRef context = 0;
  long long v5 = a2[1];
  v10[0] = *a2;
  v10[1] = v5;
  uint64_t v6 = mmcs_perform_source_create((uint64_t *)&context, 2, 8, v10);
  long long v7 = context;
  if (v6 && context)
  {
    CFDictionaryRef v8 = (dispatch_object_t *)*((void *)context + 7);
    *CFDictionaryRef v8 = dispatch_source_create(MEMORY[0x1E4F14440], 0, 0, a3);
    C3BaseRetain(context);
    dispatch_set_context(*v8, context);
    dispatch_set_finalizer_f(*v8, (dispatch_function_t)mmcs_perform_source_context_finalize_callback);
    dispatch_source_set_event_handler_f(*v8, (dispatch_function_t)mmcs_perform_dispatch_source_perform_callback);
    dispatch_resume(*v8);
    C3BaseRetain(context);
    long long v7 = context;
    *a1 = context;
  }
  if (v7) {
    C3BaseRelease(v7);
  }
  return v6;
}

void mmcs_perform_source_context_finalize_callback(CFTypeRef cf)
{
  if (cf) {
    C3BaseRelease(cf);
  }
}

uint64_t mmcs_perform_dispatch_source_perform_callback(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 48))(*(void *)(a1 + 24));
}

void mmcs_perform_dispatch_source_finalize(uint64_t a1)
{
  uint64_t v1 = *(CFTypeRef **)(a1 + 56);
  if (*v1) {
    CFRelease(*v1);
  }
  CFTypeRef *v1 = 0;
}

void mmcs_perform_dispatch_source_signal(uint64_t a1)
{
}

void mmcs_perform_dispatch_source_invalidate(uint64_t a1)
{
  uint64_t v1 = *(dispatch_source_t **)(a1 + 56);
  if (*v1)
  {
    dispatch_source_cancel(*v1);
    dispatch_release(*v1);
    dispatch_source_t *v1 = 0;
  }
}

uint64_t mmcs_perform_run_loop_target_create(uint64_t *a1, const void *a2, const void *a3)
{
  uint64_t v9 = 0;
  uint64_t result = mmcs_perform_target_create(&v9, 1, 16);
  if (result)
  {
    uint64_t v7 = v9;
    if (v9)
    {
      CFDictionaryRef v8 = *(void **)(v9 + 24);
      if (a2) {
        CFRetain(a2);
      }
      *CFDictionaryRef v8 = a2;
      if (a3) {
        CFRetain(a3);
      }
      v8[1] = a3;
      *a1 = v7;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void mmcs_perform_run_loop_target_finalize(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (*(void *)v1) {
    CFRelease(*(CFTypeRef *)v1);
  }
  *(void *)uint64_t v1 = 0;
  long long v2 = *(const void **)(v1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)(v1 + 8) = 0;
}

void mmcs_perform_run_loop_target_async(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = voucher_copy();
  uint64_t v6 = *(__CFRunLoop **)v3;
  long long v5 = *(const void **)(v3 + 8);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  _OWORD v7[2] = __mmcs_perform_run_loop_target_async_block_invoke;
  v7[3] = &unk_1E6C34A70;
  v7[4] = a2;
  v7[5] = v4;
  CFRunLoopPerformBlock(v6, v5, v7);
  CFRunLoopWakeUp(*(CFRunLoopRef *)v3);
}

void __mmcs_perform_run_loop_target_async_block_invoke(uint64_t a1)
{
  long long v2 = *(void **)(a1 + 40);
  if (v2) {
    os_retain(v2);
  }
  voucher_adopt();
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v3 = (void *)voucher_adopt();
  if (v3) {
    os_release(v3);
  }
  uint64_t v4 = *(void **)(a1 + 40);
  if (v4)
  {
    os_release(v4);
  }
}

uint64_t mmcs_perform_run_loop_target_get_underlying_run_loop_and_run_modes(uint64_t result, void *a2, void *a3)
{
  uint64_t v3 = *(void **)(result + 24);
  if (a2) {
    *a2 = *v3;
  }
  if (a3) {
    *a3 = v3[1];
  }
  return result;
}

void mmcs_perform_run_loop_target_stream_schedule(uint64_t a1, void *cf)
{
  uint64_t v3 = *(CFRunLoopRef **)(a1 + 24);
  CFTypeID v4 = CFGetTypeID(cf);
  CFIndex Count = CFArrayGetCount(v3[1]);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    for (CFIndex i = 0; i != v6; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v3[1], i);
      if (v4 == CFReadStreamGetTypeID())
      {
        CFReadStreamScheduleWithRunLoop((CFReadStreamRef)cf, *v3, ValueAtIndex);
      }
      else if (v4 == CFWriteStreamGetTypeID())
      {
        CFWriteStreamScheduleWithRunLoop((CFWriteStreamRef)cf, *v3, ValueAtIndex);
      }
      else
      {
        uint64_t v9 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v10 = 0;
          _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "Unknown stream type. Failed to schedule request", v10, 2u);
        }
      }
    }
  }
}

void mmcs_perform_run_loop_target_stream_unschedule(uint64_t a1, void *cf)
{
  uint64_t v3 = *(CFRunLoopRef **)(a1 + 24);
  CFTypeID v4 = CFGetTypeID(cf);
  CFIndex Count = CFArrayGetCount(v3[1]);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    for (CFIndex i = 0; i != v6; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v3[1], i);
      if (v4 == CFReadStreamGetTypeID())
      {
        CFReadStreamUnscheduleFromRunLoop((CFReadStreamRef)cf, *v3, ValueAtIndex);
      }
      else if (v4 == CFWriteStreamGetTypeID())
      {
        CFWriteStreamUnscheduleFromRunLoop((CFWriteStreamRef)cf, *v3, ValueAtIndex);
      }
      else
      {
        uint64_t v9 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v10 = 0;
          _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "Unknown stream type. Failed to unschedule request", v10, 2u);
        }
      }
    }
  }
}

uint64_t mmcs_perform_run_loop_target_create_source(uint64_t a1, void *a2, _OWORD *a3)
{
  uint64_t v3 = *(uint64_t **)(a1 + 24);
  if (!v3) {
    mmcs_perform_run_loop_target_create_source_cold_1();
  }
  uint64_t v5 = *v3;
  CFArrayRef v4 = (const __CFArray *)v3[1];
  long long v6 = a3[1];
  v8[0] = *a3;
  v8[1] = v6;
  return mmcs_perform_run_loop_source_create(a2, v8, v5, v4);
}

uint64_t mmcs_perform_run_loop_target_create_timer(uint64_t a1, void *a2, _OWORD *a3)
{
  uint64_t v3 = *(uint64_t **)(a1 + 24);
  if (!v3) {
    mmcs_perform_run_loop_target_create_timer_cold_1();
  }
  uint64_t v5 = *v3;
  CFArrayRef v4 = (const __CFArray *)v3[1];
  long long v6 = a3[1];
  v8[0] = *a3;
  v8[1] = v6;
  return mmcs_perform_run_loop_timer_create(a2, v8, v5, v4);
}

uint64_t mmcs_job_queue_create()
{
  uint64_t v0 = C3TypeRegister(&mmcs_job_queueGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v0, 0x60uLL);
  uint64_t v2 = Instance;
  if (Instance)
  {
    int v3 = pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0);
    *(unsigned char *)(v2 + 80) = v3 == 0;
    if (v3
      || (*(unsigned char *)(v2 + 104) = 0,
          dispatch_queue_t v5 = dispatch_queue_create("com.apple.mmcs.chunking", 0),
          (*(void *)(v2 + 88) = v5) == 0)
      || (dispatch_group_t v6 = dispatch_group_create(), (*(void *)(v2 + 96) = v6) == 0))
    {
      C3BaseRelease((CFTypeRef)v2);
      return 0;
    }
  }
  return v2;
}

uint64_t mmcs_job_queue_enqueue(uint64_t a1, void *cf)
{
  if (!cf) {
    return 0;
  }
  C3BaseRetain(cf);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (*(unsigned char *)(a1 + 104))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    C3BaseRelease(cf);
    return 0;
  }
  else
  {
    dispatch_group_async_f(*(dispatch_group_t *)(a1 + 96), *(dispatch_queue_t *)(a1 + 88), cf, (dispatch_function_t)_mmcs_job_queue_execute_job);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    return 1;
  }
}

void _mmcs_job_queue_execute_job(const void *a1)
{
  mmcs_job_execute((uint64_t)a1);
  if (a1)
  {
    C3BaseRelease(a1);
  }
}

intptr_t mmcs_job_queue_sync_halt(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (!*(unsigned char *)(a1 + 104)) {
    *(unsigned char *)(a1 + 104) = 1;
  }
  pthread_mutex_unlock(v2);
  int v3 = *(NSObject **)(a1 + 96);
  return dispatch_group_wait(v3, 0xFFFFFFFFFFFFFFFFLL);
}

void _mmcs_job_queueCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 88);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(a1 + 88) = 0;
  }
  int v3 = *(NSObject **)(a1 + 96);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(a1 + 96) = 0;
  }
  if (*(unsigned char *)(a1 + 80))
  {
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
    *(unsigned char *)(a1 + 80) = 0;
  }
}

BOOL _mmcs_job_queueCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_job_queueCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_job_queueCFCopyDebugDescription()
{
  return 0;
}

void __get_home_dir_path_block_invoke()
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!ub_home_dir)
  {
    size_t v0 = sysconf(71);
    if (v0 == -1)
    {
      int v7 = *__error();
      CFDictionaryRef v8 = strerror(v7);
      syslog(3, "can't get home dir path size %s (%d)", v8, v7);
    }
    else
    {
      size_t v1 = v0;
      uint64_t v2 = (char *)&v9 - ((v0 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v2, v0);
      memset(&v11, 0, sizeof(v11));
      uint64_t v10 = 0;
      uid_t v3 = getuid();
      if (getpwuid_r(v3, &v11, v2, v1, &v10)) {
        BOOL v4 = 1;
      }
      else {
        BOOL v4 = v10 == 0;
      }
      if (v4)
      {
        int v5 = *__error();
        dispatch_group_t v6 = strerror(v5);
        syslog(3, "can't get home dir path %s (%d)", v6, v5);
      }
      else
      {
        ub_home_dir = (uint64_t)strdup(v11.pw_dir);
      }
    }
  }
}

uint64_t get_log_dir_path(void *context)
{
  if (s_cached_log_dir_path_once != -1) {
    dispatch_once_f(&s_cached_log_dir_path_once, context, (dispatch_function_t)get_log_dir_path_once);
  }
  return s_cached_log_dir_path;
}

void get_log_dir_path_once(const char *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (get_home_dir_path_onceToken != -1) {
    dispatch_once(&get_home_dir_path_onceToken, &__block_literal_global_0);
  }
  if (ub_home_dir) {
    uint64_t v2 = (const char *)ub_home_dir;
  }
  else {
    uint64_t v2 = ".";
  }
  if (a1)
  {
    asprintf((char **)&s_cached_log_dir_path, "%s/Library/Logs/Ubiquity/%s", v2, a1);
  }
  else
  {
    CFStringRef v22 = 0;
    asprintf((char **)&s_cached_log_dir_path, "%s/Library/Logs/CrashReporter/DiagnosticLogs/Ubiquity", v2);
    if (access((const char *)s_cached_log_dir_path, 0) == -1)
    {
      if (mkpath_np((const char *)s_cached_log_dir_path, 0x1C0u) < 0)
      {
        uint64_t v15 = (const char *)s_cached_log_dir_path;
        int v16 = *__error();
        CFRange v17 = __error();
        uint64_t v18 = strerror(*v17);
        syslog(3, "unable to mkpath_np(%s); error %d; %s", v15, v16, v18);
      }
      else
      {
        asprintf(&v22, "%s/Library/Logs/CrashReporter/DiagnosticLogs", v2);
        uid_t v3 = (const char *)s_cached_log_dir_path;
        BOOL v4 = v22;
        int v5 = opendir((const char *)s_cached_log_dir_path);
        if (v5)
        {
          dispatch_group_t v6 = v5;
          int v7 = readdir(v5);
          if (v7)
          {
            CFDictionaryRef v8 = v7;
            do
            {
              bzero(__str, 0x400uLL);
              bzero(&__to, 0x400uLL);
              d_name = v8->d_name;
              if (strcmp(d_name, ".") && strcmp(d_name, "..") && !strncmp(d_name, "ubiquity", 8uLL))
              {
                snprintf((char *)__str, 0x400uLL, "%s/%s", v3, d_name);
                snprintf((char *)&__to, 0x400uLL, "%s/%s", v4, d_name);
                rename(__str, &__to, v10);
                if (v11)
                {
                  int v12 = *__error();
                  CFArrayRef v13 = __error();
                  CFStringRef v14 = strerror(*v13);
                  syslog(3, "unable to rename(%s, %s); error %d; %s",
                    (const char *)__str,
                    (const char *)&__to,
                    v12,
                    v14);
                }
              }
              CFDictionaryRef v8 = readdir(v6);
            }
            while (v8);
          }
          closedir(v6);
        }
        else
        {
          int v19 = *__error();
          CFDataRef v20 = __error();
          CFErrorRef v21 = strerror(*v20);
          syslog(3, "unable to opendir(%s); error %d; %s", v3, v19, v21);
        }
        free(v22);
      }
    }
  }
}

BOOL mmcs_get_file_sparse_context_create(uint64_t **a1, uint64_t a2)
{
  *a1 = 0;
  if (!a2) {
    mmcs_get_file_sparse_context_create_cold_1();
  }
  uint64_t v4 = C3TypeRegister(&mmcs_get_file_sparse_contextGetTypeID_typeID);
  uint64_t Instance = (uint64_t *)C3TypeCreateInstance_(0, v4, 0x18uLL);
  dispatch_group_t v6 = Instance;
  if (Instance)
  {
    Instance[2] = a2;
    Instance[4] = 0;
    if (!mmcs_index_set_create(Instance + 3))
    {
      C3BaseRelease(v6);
      dispatch_group_t v6 = 0;
    }
    *a1 = v6;
  }
  return v6 != 0;
}

BOOL mmcs_get_file_sparse_context_contains_zero_filled_block(void *a1)
{
  unint64_t v1 = a1[4];
  if (!v1) {
    mmcs_get_file_sparse_context_contains_zero_filled_block_cold_1();
  }
  uint64_t v3 = a1[3];
  if (!v3) {
    mmcs_get_file_sparse_context_contains_zero_filled_block_cold_2();
  }
  unint64_t v4 = a1[2];
  if (v1 % v4) {
    unint64_t v5 = v1 / v4 + 1;
  }
  else {
    unint64_t v5 = v1 / v4;
  }
  if (v5 >= 0x7FFFFFFF) {
    mmcs_get_file_sparse_context_contains_zero_filled_block_cold_3();
  }
  return mmcs_index_set_contains_range(v3, 0, (int)v5 - 1) == 0;
}

void _mmcs_get_file_sparse_contextCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    C3BaseRelease(v2);
  }
  *(void *)(a1 + 24) = 0;
}

BOOL _mmcs_get_file_sparse_contextCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_get_file_sparse_contextCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_get_file_sparse_contextCFCopyDebugDescription()
{
  return 0;
}

uint64_t mmcs_job_create(long long *a1)
{
  uint64_t v2 = C3TypeRegister(&mmcs_jobGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v2, 0x78uLL);
  uint64_t v4 = Instance;
  if (Instance)
  {
    int v5 = pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0);
    *(unsigned char *)(v4 + 80) = v5 == 0;
    if (!a1 || v5)
    {
      C3BaseRelease((CFTypeRef)v4);
      return 0;
    }
    else
    {
      *(unsigned char *)(v4 + 81) = 1;
      long long v6 = a1[2];
      long long v7 = *a1;
      *(_OWORD *)(v4 + 104) = a1[1];
      *(_OWORD *)(v4 + 120) = v6;
      *(_OWORD *)(v4 + 88) = v7;
      CFDictionaryRef v8 = *(void (**)(void))(v4 + 104);
      if (v8) {
        v8(*(void *)(v4 + 96));
      }
    }
  }
  return v4;
}

uint64_t mmcs_job_dispatch_async(void *cf, uint64_t a2)
{
  return mmcs_job_queue_enqueue(a2, cf);
}

uint64_t mmcs_job_execute(uint64_t a1)
{
  uint64_t v2 = *(void (**)(void))(a1 + 128);
  if (v2) {
    v2(*(void *)(a1 + 96));
  }
  return mmcs_job_invalidate(a1);
}

uint64_t mmcs_job_invalidate(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  int v3 = *(unsigned __int8 *)(a1 + 81);
  *(unsigned char *)(a1 + 81) = *(unsigned char *)(a1 + 81) == 0;
  uint64_t result = pthread_mutex_unlock(v2);
  if (v3)
  {
    int v5 = *(uint64_t (**)(uint64_t))(a1 + 112);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 96);
      return v5(v6);
    }
  }
  return result;
}

uint64_t _mmcs_jobCFFinalize(uint64_t a1)
{
  uint64_t result = mmcs_job_invalidate(a1);
  if (*(unsigned char *)(a1 + 80))
  {
    return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  }
  return result;
}

BOOL _mmcs_jobCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_jobCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_jobCFCopyDebugDescription()
{
  return 0;
}

uint64_t mmcs_container_id_info_parse_container_id(const __CFString *a1)
{
  CFStringRef v14 = 0;
  if (a1)
  {
    CStringFromCFStringSafely = _getCStringFromCFStringSafely(a1, 0x600u, (uint64_t)&v14);
    if (CStringFromCFStringSafely)
    {
      CFDataRef v2 = mmcs_base64_encoded_cstring_to_cfdata(CStringFromCFStringSafely);
      CFDataRef v3 = v2;
      if (v2 && CFDataGetLength(v2) == 15)
      {
        BytePtr = CFDataGetBytePtr(v3);
        uint64_t v5 = 0;
        unint64_t v6 = 0;
        long long v7 = BytePtr + 5;
        do
          unint64_t v6 = v7[v5++] | (v6 << 8);
        while (v5 != 6);
        double v8 = mmcs_time_convert_server_time_to_cfabsolutetime(v6);
        uint64_t v9 = CFDataGetBytePtr(v3);
        uint64_t v10 = 0;
        int v11 = 0;
        do
          int v11 = v9[v10++ + 11] | (v11 << 8);
        while (v10 != 4);
        double v12 = v8;
      }
      else
      {
        double v12 = 0.0;
      }
    }
    else
    {
      double v12 = 0.0;
      CFDataRef v3 = 0;
    }
    if (v14) {
      free(v14);
    }
    CFStringRef v14 = 0;
    if (v3) {
      CFRelease(v3);
    }
  }
  else
  {
    double v12 = 0.0;
  }
  return *(void *)&v12;
}

uint64_t mmcs_chunk_instance_chunk_coder_create(uint64_t a1, int a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 56);
  if ((**(unsigned char **)(v3 + 8) & 0x7F) == 4)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v5 = *(const UInt8 **)(v3 + 16);
    CFIndex v6 = CKChunkSchemeAndEncryptionKeySize();
    CFDataRef v7 = CFDataCreate(v4, v5, v6);
    CKChunkDigestArgumentsV2WithChunkKeyCreate();
    if (v7) {
      CFRelease(v7);
    }
  }
  else
  {
    CKChunkDigestArgumentsV1Create();
  }
  if (a2 == 3 || !*(void *)(v3 + 16) || a2 == 1 || a2 == 2)
  {
    CKChunkCoderCreate();
  }
  else
  {
    uint64_t v9 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      int v11 = a2;
      _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "Unexpected chunk coder mode requested %d.", buf, 8u);
    }
  }
  return 0;
}

const char *mmcs_network_activity_type_as_c_string(uint64_t a1)
{
  unint64_t v1 = "unknown activity type";
  if (a1 == 1) {
    unint64_t v1 = "download";
  }
  if (a1) {
    return v1;
  }
  else {
    return "upload";
  }
}

uint64_t mmcs_perform_target_create(uint64_t *a1, int a2, uint64_t a3)
{
  *a1 = 0;
  size_t v5 = a3 + 32;
  uint64_t v6 = C3TypeRegister(&mmcs_perform_targetGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v6, v5);
  if (result)
  {
    *(_DWORD *)(result + 16) = a2;
    *(void *)(result + 24) = result + 32;
    *a1 = result;
    return 1;
  }
  return result;
}

uint64_t mmcs_perform_target_async(uint64_t result, uint64_t a2)
{
  if (!a2) {
    mmcs_perform_target_async_cold_1();
  }
  CFDataRef v2 = _performTargetCallbacks[7 * *(int *)(result + 16)];
  if (v2)
  {
    return v2();
  }
  return result;
}

uint64_t mmcs_perform_target_get_underlying_run_loop_and_run_modes(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 16);
  if ((v1 & 0xFFFFFFFD) != 0) {
    return _performTargetCallbacks[7 * v1 + 1]();
  }
  return result;
}

uint64_t mmcs_perform_target_stream_schedule(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 16);
  if (v1) {
    return _performTargetCallbacks[7 * v1 + 2]();
  }
  return result;
}

uint64_t mmcs_perform_target_create_source(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (!v4) {
    return 0;
  }
  size_t v5 = _performTargetCallbacks[7 * v4 + 5];
  long long v6 = a3[1];
  v8[0] = *a3;
  v8[1] = v6;
  return ((uint64_t (*)(uint64_t, uint64_t, _OWORD *, uint64_t))v5)(a1, a2, v8, a4);
}

uint64_t mmcs_perform_target_create_timer(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (!v4) {
    return 0;
  }
  size_t v5 = _performTargetCallbacks[7 * v4 + 6];
  long long v6 = a3[1];
  v8[0] = *a3;
  v8[1] = v6;
  return ((uint64_t (*)(uint64_t, uint64_t, _OWORD *, uint64_t))v5)(a1, a2, v8, a4);
}

uint64_t _mmcs_perform_targetCFFinalize(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 16);
  if (v1) {
    return _performTargetCallbacks[7 * v1 + 4]();
  }
  return result;
}

BOOL _mmcs_perform_targetCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_perform_targetCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_perform_targetCFCopyDebugDescription()
{
  return 0;
}

__CFString *metricsinfo__set_request_url_with_cfstring(uint64_t a1, const __CFString *a2)
{
  int v4 = *(void **)(a1 + 24);
  if (v4) {
    free(v4);
  }
  if (a2) {
    uint64_t result = createCStringWithCFString(a2);
  }
  else {
    uint64_t result = 0;
  }
  *(void *)(a1 + 24) = result;
  return result;
}

uint64_t metricsinfo__get_transaction_complete(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t metricsinfo__set_transaction_complete(uint64_t result, int a2)
{
  *(_DWORD *)(result + 32) = a2;
  return result;
}

uint64_t metricsinfo__get_timed_out(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 36)) {
    metricsinfo__get_timed_out_cold_1();
  }
  return *(unsigned int *)(a1 + 40);
}

uint64_t metricsinfo__set_timed_out(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = 1;
  *(_DWORD *)(result + 40) = a2;
  return result;
}

uint64_t metricsinfo__clear_timed_out(uint64_t result)
{
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  return result;
}

uint64_t metricsinfo__get_http_status(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 44)) {
    metricsinfo__get_http_status_cold_1();
  }
  return *(unsigned int *)(a1 + 48);
}

uint64_t metricsinfo__set_http_status(uint64_t result, int a2)
{
  *(_DWORD *)(result + 44) = 1;
  *(_DWORD *)(result + 48) = a2;
  return result;
}

uint64_t metricsinfo__clear_http_status(uint64_t result)
{
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  return result;
}

double metricsinfo__get_start_time(uint64_t a1)
{
  return *(double *)(a1 + 56);
}

uint64_t metricsinfo__set_start_time(uint64_t result, double a2)
{
  *(double *)(result + 56) = a2;
  return result;
}

uint64_t metricsinfo__set_connection_init_time(uint64_t result, double a2)
{
  *(double *)(result + 216) = a2;
  *(_DWORD *)(result + 208) = 1;
  return result;
}

uint64_t metricsinfo__set_enqueued_time(uint64_t result, double a2)
{
  *(double *)(result + 232) = a2;
  *(_DWORD *)(result + 224) = 1;
  return result;
}

uint64_t metricsinfo__clear_enqueued_time(uint64_t result)
{
  *(_DWORD *)(result + 224) = 0;
  *(void *)(result + 232) = 0;
  return result;
}

double metricsinfo__get_start_name_resolution(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 64)) {
    metricsinfo__get_start_name_resolution_cold_1();
  }
  return *(double *)(a1 + 72);
}

uint64_t metricsinfo__set_start_name_resolution(uint64_t result, double a2)
{
  *(double *)(result + 72) = a2;
  *(_DWORD *)(result + 64) = 1;
  return result;
}

uint64_t metricsinfo__clear_start_name_resolution(uint64_t result)
{
  *(_DWORD *)(result + 64) = 0;
  *(void *)(result + 72) = 0;
  return result;
}

double metricsinfo__get_stop_name_resolution(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 80)) {
    metricsinfo__get_stop_name_resolution_cold_1();
  }
  return *(double *)(a1 + 88);
}

uint64_t metricsinfo__set_stop_name_resolution(uint64_t result, double a2)
{
  *(double *)(result + 88) = a2;
  *(_DWORD *)(result + 80) = 1;
  return result;
}

uint64_t metricsinfo__clear_stop_name_resolution(uint64_t result)
{
  *(_DWORD *)(result + 80) = 0;
  *(void *)(result + 88) = 0;
  return result;
}

uint64_t metricsinfo__set_response_received_time(uint64_t result, double a2)
{
  *(double *)(result + 96) = a2;
  return result;
}

double metricsinfo__get_stop_time(uint64_t a1)
{
  return *(double *)(a1 + 104);
}

uint64_t metricsinfo__set_stop_time(uint64_t result, double a2)
{
  *(double *)(result + 104) = a2;
  return result;
}

uint64_t metricsinfo__set_request_size(uint64_t result, uint64_t a2)
{
  *(void *)(result + 112) = a2;
  return result;
}

uint64_t metricsinfo__clear_bytes_write_buffered(uint64_t result)
{
  *(void *)(result + 120) = 0;
  return result;
}

uint64_t metricsinfo__get_bytes_written(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 128)) {
    metricsinfo__get_bytes_written_cold_1();
  }
  return *(void *)(a1 + 136);
}

uint64_t metricsinfo__set_bytes_written(uint64_t result, uint64_t a2)
{
  *(void *)(result + 136) = a2;
  *(_DWORD *)(result + 128) = 1;
  return result;
}

uint64_t metricsinfo__clear_bytes_written(uint64_t result)
{
  *(_DWORD *)(result + 128) = 0;
  *(void *)(result + 136) = 0;
  return result;
}

uint64_t metricsinfo__clear_actual_bytes_written(uint64_t result)
{
  *(void *)(result + 144) = 0;
  return result;
}

uint64_t metricsinfo__clear_last_send_time(uint64_t result)
{
  *(_DWORD *)(result + 152) = 0;
  *(void *)(result + 160) = 0;
  return result;
}

uint64_t metricsinfo__get_response_size(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 168)) {
    metricsinfo__get_response_size_cold_1();
  }
  return *(void *)(a1 + 176);
}

uint64_t metricsinfo__set_response_size(uint64_t result, uint64_t a2)
{
  *(void *)(result + 176) = a2;
  *(_DWORD *)(result + 168) = 1;
  return result;
}

uint64_t metricsinfo__clear_response_size(uint64_t result)
{
  *(_DWORD *)(result + 168) = 0;
  *(void *)(result + 176) = 0;
  return result;
}

uint64_t metricsinfo__get_bytes_read(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 184)) {
    metricsinfo__get_bytes_read_cold_1();
  }
  return *(void *)(a1 + 192);
}

uint64_t metricsinfo__set_bytes_read(uint64_t result, uint64_t a2)
{
  *(void *)(result + 192) = a2;
  *(_DWORD *)(result + 184) = 1;
  return result;
}

uint64_t metricsinfo__clear_bytes_read(uint64_t result)
{
  *(_DWORD *)(result + 184) = 0;
  *(void *)(result + 192) = 0;
  return result;
}

CFErrorRef metricsinfo__create_cferror_with_http_error(uint64_t a1)
{
  return create_cferror_with_error_response(*(__CFError **)(a1 + 200));
}

_OWORD *metricsinfo__set_http_error_with_cferror(uint64_t a1, __CFError *a2)
{
  int v4 = *(void ***)(a1 + 200);
  if (v4) {
    chunkserver__error_response__free_unpacked(v4, 0);
  }
  if (a2) {
    uint64_t result = create_error_response_for_Error(a2);
  }
  else {
    uint64_t result = 0;
  }
  *(void *)(a1 + 200) = result;
  return result;
}

uint64_t metricsinfo__new(uint64_t result)
{
  if (result)
  {
    int v1 = (void *)result;
    uint64_t result = (uint64_t)malloc_type_malloc(0xF0uLL, 0x1070040979AF96BuLL);
    if (result)
    {
      uint64_t v2 = result;
      metricsinfo__httpmetrics_info__init((_OWORD *)result);
      void *v1 = v2;
      return 1;
    }
  }
  return result;
}

void **metricsinfo__free(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2) {
    free(v2);
  }
  *(void *)(a1 + 24) = 0;
  uint64_t v3 = *(void ***)(a1 + 200);
  if (v3) {
    chunkserver__error_response__free_unpacked(v3, 0);
  }
  *(void *)(a1 + 200) = 0;
  return metricsinfo__httpmetrics_info__free_unpacked((void **)a1, 0);
}

CFStringRef socketinfo__create_cfstring_with_interface_identifier(uint64_t a1)
{
  int v1 = *(const char **)(a1 + 24);
  if (v1) {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, 0x8000100u);
  }
  else {
    return 0;
  }
}

void socketinfo__set_interface_identifier_with_c_string(uint64_t a1, char *__s1)
{
  int v4 = *(void **)(a1 + 24);
  if (v4) {
    free(v4);
  }
  *(void *)(a1 + 24) = 0;
  if (__s1) {
    *(void *)(a1 + 24) = strdup(__s1);
  }
}

CFStringRef socketinfo__create_cfstring_with_peer_address(uint64_t a1)
{
  int v1 = *(const char **)(a1 + 32);
  if (v1) {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, 0x8000100u);
  }
  else {
    return 0;
  }
}

void socketinfo__set_peer_address_with_c_string(uint64_t a1, char *__s1)
{
  int v4 = *(void **)(a1 + 32);
  if (v4) {
    free(v4);
  }
  *(void *)(a1 + 32) = 0;
  if (__s1) {
    *(void *)(a1 + 32) = strdup(__s1);
  }
}

uint64_t socketinfo__new(uint64_t result)
{
  if (result)
  {
    int v1 = (void *)result;
    uint64_t result = (uint64_t)malloc_type_malloc(0x30uLL, 0x10700407919B52CuLL);
    if (result)
    {
      uint64_t v2 = result;
      metricsinfo__socket_info__init((_OWORD *)result);
      void *v1 = v2;
      return 1;
    }
  }
  return result;
}

void **socketinfo__free(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2) {
    free(v2);
  }
  *(void *)(a1 + 24) = 0;
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3) {
    free(v3);
  }
  *(void *)(a1 + 32) = 0;
  return metricsinfo__socket_info__free_unpacked((void **)a1, 0);
}

uint64_t socketinfo__set_peer_port(uint64_t result, int a2)
{
  *(_DWORD *)(result + 40) = a2;
  return result;
}

uint64_t socketinfo__set_is_reused(uint64_t result, int a2)
{
  *(_DWORD *)(result + 44) = a2;
  return result;
}

uint64_t C3TypeRegister(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result)
  {
    pthread_mutex_lock(&C3TypeRegister_lock);
    if (!*a1) {
      *a1 = _CFRuntimeRegisterClass();
    }
    pthread_mutex_unlock(&C3TypeRegister_lock);
    return *a1;
  }
  return result;
}

uint64_t C3TypeCreateInstance_(uint64_t a1, uint64_t a2, size_t a3)
{
  if (HIDWORD(a3)) {
    return 0;
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v3 = Instance;
  if (Instance) {
    bzero((void *)(Instance + 16), a3);
  }
  return v3;
}

CFTypeRef C3BaseRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void C3BaseRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CFTypeRef C3BaseRetainCallBack(int a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void C3BaseReleaseCallBack(int a1, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t mmcs_runloop_reply_job_create(const void *a1, long long *a2)
{
  uint64_t v4 = C3TypeRegister(&mmcs_runloop_reply_jobGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v4, 0xA0uLL);
  uint64_t v6 = Instance;
  if (Instance)
  {
    int v7 = pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0);
    *(unsigned char *)(v6 + 80) = v7 == 0;
    if (!a2 || v7)
    {
      C3BaseRelease((CFTypeRef)v6);
      return 0;
    }
    else
    {
      *(unsigned char *)(v6 + 81) = 1;
      long long v9 = a2[1];
      long long v8 = a2[2];
      long long v10 = *a2;
      *(void *)(v6 + 144) = *((void *)a2 + 6);
      *(_OWORD *)(v6 + 112) = v9;
      *(_OWORD *)(v6 + 128) = v8;
      *(_OWORD *)(v6 + 96) = v10;
      int v11 = *(void (**)(void))(v6 + 112);
      if (v11) {
        v11(*(void *)(v6 + 104));
      }
      *(void *)(v6 + 152) = a1;
      C3BaseRetain(a1);
      *(void *)(v6 + 168) = voucher_copy();
      *(void *)&long long v13 = 0;
      *((void *)&v13 + 1) = v6;
      CFStringRef v14 = C3BaseRetain;
      uint64_t v15 = C3BaseRelease;
      uint64_t v16 = 0;
      CFRange v17 = mmcs_runloop_reply_job_execute;
      *(void *)(v6 + 88) = mmcs_job_create(&v13);
    }
  }
  return v6;
}

void mmcs_runloop_reply_job_execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v5 = *(void (**)(void))(a1 + 136);
  if (v5) {
    v5(*(void *)(a1 + 104));
  }
  CFTypeRef cf = 0;
  if (!*(unsigned char *)(a1 + 82))
  {
    uint64_t v6 = *(void *)(a1 + 152);
    *(void *)&long long v10 = a1;
    *((void *)&v10 + 1) = C3BaseRetain;
    int v11 = C3BaseRelease;
    uint64_t v12 = mmcs_runloop_reply_job_completed;
    int v7 = mmcs_perform_target_create_timer(v6, (uint64_t)&cf, &v10, a4);
    if (!cf || !v7) {
      mmcs_runloop_reply_job_execute_cold_1();
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  long long v8 = *(const void **)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  int v9 = *(unsigned __int8 *)(a1 + 82);
  if (!*(unsigned char *)(a1 + 82) && cf)
  {
    C3BaseRetain(cf);
    *(void *)(a1 + 160) = cf;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  if (v8) {
    C3BaseRelease(v8);
  }
  if (cf)
  {
    if (v9) {
      mmcs_perform_timer_invalidate((uint64_t)cf);
    }
    else {
      mmcs_perform_timer_set_next_fire_date((uint64_t)cf);
    }
    if (cf) {
      C3BaseRelease(cf);
    }
    CFTypeRef cf = 0;
  }
  if (v9) {
    mmcs_runloop_reply_job_invalidate(a1);
  }
}

void mmcs_runloop_reply_job_cancel(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (*(unsigned char *)(a1 + 82))
  {
    pthread_mutex_unlock(v2);
  }
  else
  {
    *(unsigned char *)(a1 + 82) = 1;
    uint64_t v3 = *(const void **)(a1 + 160);
    if (v3) {
      *(void *)(a1 + 160) = 0;
    }
    uint64_t v4 = *(const void **)(a1 + 88);
    if (v4)
    {
      *(void *)(a1 + 88) = 0;
      pthread_mutex_unlock(v2);
      C3BaseRelease(v4);
      if (!v3) {
        return;
      }
    }
    else
    {
      pthread_mutex_unlock(v2);
      if (!v3) {
        return;
      }
    }
    mmcs_perform_timer_invalidate((uint64_t)v3);
    CFRelease(v3);
  }
}

void mmcs_runloop_reply_job_dispatch_async(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 168);
  if (v4) {
    os_retain(v4);
  }
  voucher_adopt();
  mmcs_job_dispatch_async(*(void **)(a1 + 88), a2);
  size_t v5 = (void *)voucher_adopt();
  if (v5)
  {
    os_release(v5);
  }
}

void _mmcs_runloop_reply_jobCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 88);
  if (v2) {
    C3BaseRelease(v2);
  }
  *(void *)(a1 + 88) = 0;
  uint64_t v3 = *(const void **)(a1 + 152);
  if (v3) {
    C3BaseRelease(v3);
  }
  *(void *)(a1 + 152) = 0;
  uint64_t v4 = *(void **)(a1 + 168);
  if (v4) {
    os_release(v4);
  }
  *(void *)(a1 + 168) = 0;
  mmcs_runloop_reply_job_invalidate(a1);
  if (*(unsigned char *)(a1 + 80))
  {
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  }
}

BOOL _mmcs_runloop_reply_jobCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_runloop_reply_jobCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_runloop_reply_jobCFCopyDebugDescription()
{
  return 0;
}

void mmcs_runloop_reply_job_invalidate(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  int v3 = *(unsigned __int8 *)(a1 + 81);
  *(unsigned char *)(a1 + 81) = 0;
  uint64_t v4 = *(const void **)(a1 + 160);
  if (v4) {
    *(void *)(a1 + 160) = 0;
  }
  pthread_mutex_unlock(v2);
  if (v3)
  {
    size_t v5 = *(void (**)(void))(a1 + 120);
    if (v5) {
      v5(*(void *)(a1 + 104));
    }
  }
  if (v4)
  {
    mmcs_perform_timer_invalidate((uint64_t)v4);
    CFRelease(v4);
  }
}

void mmcs_runloop_reply_job_completed(uint64_t a1, uint64_t a2)
{
  int v3 = *(void **)(a2 + 168);
  if (v3) {
    os_retain(v3);
  }
  voucher_adopt();
  if (!*(unsigned char *)(a2 + 82))
  {
    uint64_t v4 = *(void (**)(void))(a2 + 144);
    if (v4) {
      v4(*(void *)(a2 + 104));
    }
  }
  mmcs_runloop_reply_job_invalidate(a2);
  size_t v5 = (void *)voucher_adopt();
  if (v5)
  {
    os_release(v5);
  }
}

uint64_t mmcs_get_request_alloc(void *a1, uint64_t a2)
{
  *a1 = 0;
  uint64_t v5 = 0;
  if (!a2) {
    return 0;
  }
  if (!is_mul_ok(a2 - 1, 0x1A0uLL)) {
    return 0;
  }
  unint64_t v2 = 416 * (a2 - 1);
  if (v2 >= 0xFFFFFFFFFFFFFDB0) {
    return 0;
  }
  uint64_t result = mmcs_request_allocate(&v5, 2, v2 + 592);
  if (result) {
    *a1 = v5;
  }
  return result;
}

BOOL mmcs_get_request_is_validation_queue_empty(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (!v1) {
    return 0;
  }
  CFArrayRef v2 = *(const __CFArray **)(v1 + 16);
  return !v2 || CFArrayGetCount(v2) == 0;
}

uint64_t mmcs_get_request_should_error_on_preallocation_failure(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (!v1) {
    mmcs_get_request_should_error_on_preallocation_failure_cold_1();
  }
  return *(unsigned __int8 *)(v1 + 56);
}

uint64_t mmcs_get_request_is_insufficient_disk_space_mode(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (!v1) {
    mmcs_get_request_is_insufficient_disk_space_mode_cold_1();
  }
  return *(unsigned __int8 *)(v1 + 58);
}

uint64_t mmcs_get_request_get_failed_to_preallocate(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 304);
  if (!v1) {
    mmcs_get_request_get_failed_to_preallocate_cold_1();
  }
  return *(unsigned __int8 *)(v1 + 57);
}

uint64_t mmcs_get_request_set_failed_to_preallocate(uint64_t result, char a2)
{
  uint64_t v2 = *(void *)(result + 304);
  if (!v2) {
    mmcs_get_request_set_failed_to_preallocate_cold_1();
  }
  *(unsigned char *)(v2 + 57) = a2;
  return result;
}

void mmcs_engine_chunk_job_dispatch_async(uint64_t a1, uint64_t a2)
{
}

void mmcs_chunk_job_chunk_callback(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 288), &state);
  CFErrorRef err = 0;
  if (*(unsigned char *)(v1 + 84))
  {
    char v2 = 0;
    goto LABEL_61;
  }
  *(CFAbsoluteTime *)(v1 + 224) = CFAbsoluteTimeGetCurrent();
  CFStringRef FileTypeHint = (const __CFString *)MMCSItemReaderWriterGetFileTypeHint(*(void *)(v1 + 152));
  if (FileTypeHint) {
    CStringWithCFCFStringRef String = createCStringWithCFString(FileTypeHint);
  }
  else {
    CStringWithCFCFStringRef String = 0;
  }
  uint64_t v5 = *(void *)(v1 + 152);
  uint64_t v6 = *(void *)(*(void *)(v1 + 144) + 16);
  uint64_t v7 = *(void *)(v1 + 160);
  uint64_t v8 = *(void *)(v1 + 168);
  uint64_t v9 = *(unsigned int *)(v1 + 216);
  long long v10 = (void *)(v1 + 256);
  unsigned __int8 v11 = *(unsigned char *)(v1 + 220);
  uint64_t v12 = (char *)CKFileDigestResultsFileSignature();
  uint64_t v13 = v7;
  CFStringRef v14 = (void *)(v1 + 248);
  if (mmcs_RegisterChunksForItem(v6, v5, v13, v8, (uint64_t)CStringWithCFString, v9, (void **)(v1 + 248), (void *)(v1 + 256), v11, *v12, *(void *)(v1 + 184), (CFTypeRef *)(v1 + 176), (CFTypeRef *)(v1 + 264), (CFTypeRef *)&err))
  {
    if (!*v10)
    {
      CFTypeRef v52 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v58 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"No chunks for itemid %lld. The file may have been empty.", *(void *)(v1 + 160));
        CFStringRef v59 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v78 = v58;
          _os_log_impl(&dword_1DC1CA000, v59, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v58) {
          CFRelease(v58);
        }
      }
      CFErrorRef v60 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 28, @"There were no chunks in item %lld", v53, v54, v55, v56, v57, *(void *)(v1 + 160));
      goto LABEL_56;
    }
    unsigned int v71 = (void *)(v1 + 248);
    uint64_t v72 = CStringWithCFString;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFRange v17 = &gMMCS_DebugLevel;
    uint64_t v73 = (void *)(v1 + 256);
    while (1)
    {
      unsigned int v18 = CKRegisteredChunkLength();
      if (*v17 >= 5) {
        break;
      }
LABEL_23:
      v16 += v18;
      CKRegisteredChunkSize();
      if ((unint64_t)++v15 >= *v10)
      {
        uint64_t v32 = CKFileDigestResultsFileLength();
        if (v32 == v16)
        {
          char v2 = 1;
          CStringWithCFCFStringRef String = v72;
          if (!v72) {
            goto LABEL_60;
          }
LABEL_59:
          free(CStringWithCFString);
          goto LABEL_60;
        }
        uint64_t v61 = v32;
        __int16 v62 = mmcs_logging_logger_default();
        CFStringRef v14 = v71;
        CStringWithCFCFStringRef String = v72;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v68 = CFStringCreateWithFormat(alloc, 0, @"Chunk length sum %llu does not equal file length %llu for itemid %lld.", v16, v61, *(void *)(v1 + 160));
          int v69 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v78 = v68;
            _os_log_impl(&dword_1DC1CA000, v69, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v68) {
            CFRelease(v68);
          }
        }
        CFErrorRef v60 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 28, @"Chunk length sum %llu does not equal file length %llu for itemid %lld.", v63, v64, v65, v66, v67, v16);
LABEL_56:
        *(void *)(v1 + 280) = v60;
        __int16 v70 = *(void **)(v1 + 248);
        if (v70) {
          free(v70);
        }
        char v2 = 0;
        *CFStringRef v14 = 0;
        if (CStringWithCFString) {
          goto LABEL_59;
        }
        goto LABEL_60;
      }
    }
    int v19 = (void *)CKRegisteredChunkSignatureCopyCString();
    if (*(unsigned char *)(v1 + 220))
    {
      CFDataRef v20 = (char *)CKRegisteredChunkKey();
      CKRegisteredChunkKey();
      unint64_t v21 = CKSchemeAndEncryptionKeySize();
      CFStringRef v22 = mmcs_key_description_create_with_bytes(v20, v21, 1);
      CFErrorRef v23 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v24 = v1;
        uint64_t v25 = v17;
        uint64_t v26 = CKRegisteredChunkLength();
        CFStringRef v27 = CFStringCreateWithFormat(alloc, 0, @"\t%s %@ len %10d", v19, v22, v26);
        char v28 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v78 = v27;
          _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        CFRange v17 = v25;
        uint64_t v1 = v24;
        long long v10 = v73;
        if (v27) {
          CFRelease(v27);
        }
      }
    }
    else
    {
      uint64_t v29 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
LABEL_21:
        if (v19) {
          free(v19);
        }
        goto LABEL_23;
      }
      uint64_t v30 = CKRegisteredChunkLength();
      CFStringRef v22 = (__CFString *)CFStringCreateWithFormat(alloc, 0, @"\t%s len %10d", v19, v30);
      uint64_t v31 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v78 = v22;
        _os_log_impl(&dword_1DC1CA000, v31, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
    }
    if (v22) {
      CFRelease(v22);
    }
    goto LABEL_21;
  }
  CFTypeID v33 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v38 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"failed to register chunks for itemid %lld", *(void *)(v1 + 160));
    CFTypeRef v39 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v78 = v38;
      _os_log_impl(&dword_1DC1CA000, v39, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
    if (v38) {
      CFRelease(v38);
    }
  }
  if (err)
  {
    CFErrorDomain Domain = CFErrorGetDomain(err);
    int v41 = CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E4F58F90]);
    CFErrorRef v42 = err;
    if (v41)
    {
      if (CFErrorGetCode(err) == 3)
      {
        __int16 v43 = (char *)CKFileDigestResultsFileSignature();
        CFTypeRef v44 = mmcs_file_signature_to_hexstring(v43);
        uint64_t v45 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v50 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"chunked file signature changed for itemid %lld expected %s", *(void *)(v1 + 160), v44);
          CFIndex v51 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v78 = v50;
            _os_log_impl(&dword_1DC1CA000, v51, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v50) {
            CFRelease(v50);
          }
        }
        *(void *)(v1 + 280) = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 28, err, @"The file signature changed from %s before chunking for item %llu", v46, v47, v48, v49, (char)v44);
        if (v44) {
          free(v44);
        }
        char v2 = 0;
        if (CStringWithCFString) {
          goto LABEL_59;
        }
        goto LABEL_60;
      }
      CFErrorRef v42 = err;
    }
  }
  else
  {
    CFErrorRef v42 = 0;
  }
  char v2 = 0;
  *(void *)(v1 + 280) = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 29, v42, @"Unable to register chunks for item %lld", v34, v35, v36, v37, *(void *)(v1 + 160));
  if (CStringWithCFString) {
    goto LABEL_59;
  }
LABEL_60:
  *(CFAbsoluteTime *)(v1 + 232) = CFAbsoluteTimeGetCurrent();
LABEL_61:
  mmcs_chunk_job_ensure_item_reader_writer_closed(v1);
  if (err) {
    CFRelease(err);
  }
  CFErrorRef err = 0;
  *(unsigned char *)(v1 + 240) = v2;
  mmcs_metrics_harvest_chunking_info(*(void *)(v1 + 200), v1);
  os_activity_scope_leave(&state);
}

void mmcs_chunk_job_done_callback(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  v12.opaque[0] = 0;
  v12.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 288), &v12);
  char v2 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 176) ? CKFileDigestResultsFileLength() : -1;
    uint64_t v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 160);
      double v6 = *(double *)(a1 + 224);
      double v7 = -1.0;
      if (v6 != 0.0)
      {
        double v8 = *(double *)(a1 + 232);
        BOOL v9 = v8 < v6;
        double v10 = v8 - v6;
        if (v9) {
          double v10 = -1.0;
        }
        if (v8 == 0.0) {
          double v7 = -1.0;
        }
        else {
          double v7 = v10;
        }
      }
      *(_DWORD *)long long buf = 134218496;
      uint64_t v14 = v5;
      __int16 v15 = 2048;
      uint64_t v16 = v3;
      __int16 v17 = 2048;
      double v18 = v7;
      _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_DEFAULT, "Chunking finished for itemId %llu of %llu bytes in %0.4lf sec.", buf, 0x20u);
    }
  }
  if (*(unsigned char *)(a1 + 82)) {
    mmcs_print_registered_chunk_list(*(void *)(a1 + 248), *(void *)(a1 + 256));
  }
  unsigned __int8 v11 = *(void (**)(void, uint64_t))(a1 + 128);
  if (v11) {
    v11(*(void *)(a1 + 96), a1);
  }
  mmcs_chunk_job_invalidate(a1);
  os_activity_scope_leave(&v12);
}

uint64_t mmcs_chunk_job_create(long long *a1, uint64_t a2, const void *a3, uint64_t a4, int a5, char a6, void *a7)
{
  if (!a1) {
    return 0;
  }
  uint64_t v14 = C3TypeRegister(&mmcs_chunk_jobGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v14, 0x118uLL);
  uint64_t v16 = Instance;
  if (Instance)
  {
    int v17 = pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0);
    *(unsigned char *)(v16 + 80) = v17 == 0;
    if (v17)
    {
      C3BaseRelease((CFTypeRef)v16);
      return 0;
    }
    *(unsigned char *)(v16 + 83) = 1;
    long long v19 = a1[2];
    long long v20 = *a1;
    *(_OWORD *)(v16 + 104) = a1[1];
    *(_OWORD *)(v16 + 120) = v19;
    *(_OWORD *)(v16 + 88) = v20;
    unint64_t v21 = *(void (**)(void))(v16 + 104);
    if (v21) {
      v21(*(void *)(v16 + 96));
    }
    *(void *)(v16 + 144) = a2;
    if (a3)
    {
      C3BaseRetain(a3);
      *(void *)(v16 + 152) = a3;
    }
    *(void *)(v16 + 136) = a4;
    *(void *)(v16 + 160) = *(void *)(a4 + 40);
    CKFileDigestResultsCreate();
    CFStringRef v22 = *(const void **)(a4 + 80);
    if (v22) {
      *(void *)(v16 + 184) = CFRetain(v22);
    }
    *(_DWORD *)(v16 + 216) = a5;
    *(unsigned char *)(v16 + 220) = a6;
    *(void *)(v16 + 224) = 0;
    *(void *)(v16 + 232) = 0;
    if (a7) {
      os_retain(a7);
    }
    *(void *)(v16 + 288) = a7;
    *(void *)&long long v23 = 0;
    *((void *)&v23 + 1) = v16;
    uint64_t v24 = C3BaseRetain;
    uint64_t v25 = C3BaseRelease;
    uint64_t v26 = 0;
    CFStringRef v27 = mmcs_chunk_job_chunk_callback;
    char v28 = mmcs_chunk_job_done_callback;
    if (*(unsigned char *)(a2 + 175)) {
      *(void *)(v16 + 200) = mmcs_chunking_info_create();
    }
    *(void *)(v16 + 272) = mmcs_runloop_reply_job_create(*(const void **)(*(void *)(v16 + 144) + 56), &v23);
  }
  return v16;
}

uint64_t mmcs_register_and_chunk_job_create(long long *a1, uint64_t a2, const void *a3, uint64_t a4, int a5, char a6, int a7, const void *a8, CFTypeRef cf, void *object)
{
  if (!a1) {
    return 0;
  }
  uint64_t v18 = C3TypeRegister(&mmcs_chunk_jobGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v18, 0x118uLL);
  uint64_t v20 = Instance;
  if (Instance)
  {
    if (pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0))
    {
      C3BaseRelease((CFTypeRef)v20);
      return 0;
    }
    *(unsigned char *)(v20 + 83) = 1;
    *(unsigned char *)(v20 + 81) = 1;
    *(unsigned char *)(v20 + 82) = a6;
    long long v22 = a1[2];
    long long v23 = *a1;
    *(_OWORD *)(v20 + 104) = a1[1];
    *(_OWORD *)(v20 + 120) = v22;
    *(_OWORD *)(v20 + 88) = v23;
    uint64_t v24 = *(void (**)(void))(v20 + 104);
    if (v24) {
      v24(*(void *)(v20 + 96));
    }
    *(void *)(v20 + 144) = a2;
    if (a3)
    {
      C3BaseRetain(a3);
      *(void *)(v20 + 152) = a3;
    }
    *(void *)(v20 + 160) = a4;
    *(_DWORD *)(v20 + 216) = a5;
    *(unsigned char *)(v20 + 220) = a7 != 0;
    *(void *)(v20 + 224) = 0;
    *(void *)(v20 + 232) = 0;
    if (a8) {
      *(void *)(v20 + 184) = CFRetain(a8);
    }
    if (cf) {
      *(void *)(v20 + 192) = CFRetain(cf);
    }
    if (object) {
      os_retain(object);
    }
    *(void *)(v20 + 288) = object;
    *(void *)&long long v25 = 0;
    *((void *)&v25 + 1) = v20;
    uint64_t v26 = C3BaseRetain;
    CFStringRef v27 = C3BaseRelease;
    uint64_t v28 = 0;
    uint64_t v29 = mmcs_chunk_job_register_and_chunk_callback;
    uint64_t v30 = mmcs_chunk_job_done_callback;
    if (*(unsigned char *)(a2 + 175)) {
      *(void *)(v20 + 200) = mmcs_chunking_info_create();
    }
    *(void *)(v20 + 272) = mmcs_runloop_reply_job_create(*(const void **)(*(void *)(v20 + 144) + 56), &v25);
  }
  return v20;
}

void mmcs_chunk_job_register_and_chunk_callback(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(*(os_activity_t *)(a1 + 288), &state);
  CFTypeRef cf = 0;
  if (!*(unsigned char *)(a1 + 84))
  {
    *(CFAbsoluteTime *)(a1 + 224) = CFAbsoluteTimeGetCurrent();
    unsigned int v17 = 0;
    uint64_t v2 = *(void *)(a1 + 152);
    uint64_t v3 = *(void *)(*(void *)(a1 + 144) + 16);
    uint64_t v4 = *(void *)(a1 + 160);
    uint64_t v5 = *(unsigned __int8 *)(a1 + 220);
    int v6 = *(unsigned __int8 *)(a1 + 82);
    uint64_t v7 = *(void *)(a1 + 184);
    uint64_t v16 = 0;
    if (!mmcs_compute_signature_and_register_item_with_item_reader_writer(v3, v4, v2, v5, v6, v7, (void *)(a1 + 176), &v17, &v16, (void *)(a1 + 264), (void **)&cf))
    {
      double v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"failed to register chunks for itemid %lld", *(void *)(a1 + 160));
        uint64_t v14 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v21 = v13;
          _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v13) {
          CFRelease(v13);
        }
      }
      *(void *)(a1 + 280) = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 29, (void *)cf, @"Unable to register chunks for item %lld", v9, v10, v11, v12, *(void *)(a1 + 160));
    }
    uint64_t v15 = v17;
    *(void *)(a1 + 248) = v16;
    *(void *)(a1 + 256) = v15;
    *(CFAbsoluteTime *)(a1 + 232) = CFAbsoluteTimeGetCurrent();
  }
  mmcs_chunk_job_ensure_item_reader_writer_closed(a1);
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef cf = 0;
  *(unsigned char *)(a1 + 240) = 0;
  mmcs_metrics_harvest_chunking_info(*(void *)(a1 + 200), a1);
  os_activity_scope_leave(&state);
}

uint64_t mmcs_chunk_job_cancel(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (*(unsigned char *)(a1 + 84))
  {
    return pthread_mutex_unlock(v2);
  }
  else
  {
    *(unsigned char *)(a1 + 84) = 1;
    pthread_mutex_unlock(v2);
    mmcs_runloop_reply_job_cancel(*(void *)(a1 + 272));
    uint64_t v4 = *(const void **)(a1 + 272);
    if (v4) {
      C3BaseRelease(v4);
    }
    *(void *)(a1 + 272) = 0;
    return mmcs_chunk_job_invalidate(a1);
  }
}

uint64_t mmcs_chunk_job_invalidate(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  int v3 = *(unsigned __int8 *)(a1 + 83);
  *(unsigned char *)(a1 + 83) = 0;
  uint64_t result = pthread_mutex_unlock(v2);
  if (v3)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t))(a1 + 112);
    uint64_t v6 = *(void *)(a1 + 96);
    return v5(v6);
  }
  return result;
}

void mmcs_chunk_job_append_description(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  mmcs_op_requestor_context_indent(a1);
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @"Chunking item %lld\n", *(void *)(v2 + 160));
}

void mmcs_chunk_job_ensure_item_reader_writer_closed(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 152);
  if (v2)
  {
    CFTypeRef cf = 0;
    if (MMCSItemReaderWriterIsOpen(v2))
    {
      if (!MMCSItemReaderWriterClose(*(void *)(a1 + 152), (CFErrorRef *)&cf))
      {
        int v3 = mmcs_cferror_copy_description((__CFError *)cf);
        uint64_t v4 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Error closing item reader: %@", v3);
          uint64_t v6 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v9 = v5;
            _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v5) {
            CFRelease(v5);
          }
        }
        if (v3) {
          CFRelease(v3);
        }
      }
      if (cf) {
        CFRelease(cf);
      }
    }
  }
}

void _mmcs_chunk_jobCFFinalize(uint64_t a1)
{
  if (a1)
  {
    *(void *)(a1 + 144) = 0;
    mmcs_chunk_job_invalidate(a1);
    *(void *)(a1 + 136) = 0;
    uint64_t v2 = *(const void **)(a1 + 168);
    if (v2) {
      C3BaseRelease(v2);
    }
    *(void *)(a1 + 168) = 0;
    int v3 = *(const void **)(a1 + 176);
    if (v3) {
      C3BaseRelease(v3);
    }
    *(void *)(a1 + 176) = 0;
    uint64_t v4 = *(const void **)(a1 + 264);
    if (v4) {
      C3BaseRelease(v4);
    }
    *(void *)(a1 + 264) = 0;
    CFStringRef v5 = *(const void **)(a1 + 184);
    if (v5) {
      CFRelease(v5);
    }
    *(void *)(a1 + 184) = 0;
    uint64_t v6 = *(const void **)(a1 + 192);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(a1 + 192) = 0;
    mmcs_chunk_job_ensure_item_reader_writer_closed(a1);
    uint64_t v7 = *(const void **)(a1 + 152);
    if (v7) {
      C3BaseRelease(v7);
    }
    *(void *)(a1 + 152) = 0;
    double v8 = *(const void **)(a1 + 272);
    if (v8) {
      C3BaseRelease(v8);
    }
    *(void *)(a1 + 272) = 0;
    CFStringRef v9 = *(void **)(a1 + 248);
    if (v9) {
      free(v9);
    }
    *(void *)(a1 + 248) = 0;
    uint64_t v10 = *(const void **)(a1 + 280);
    if (v10) {
      CFRelease(v10);
    }
    *(void *)(a1 + 280) = 0;
    uint64_t v11 = *(void **)(a1 + 200);
    if (v11)
    {
      mmcs_metrics_chunking_info_release(v11);
      *(void *)(a1 + 200) = 0;
    }
    if (*(unsigned char *)(a1 + 80)) {
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
    }
    uint64_t v12 = *(void **)(a1 + 288);
    if (v12) {
      os_release(v12);
    }
    *(void *)(a1 + 288) = 0;
  }
}

BOOL _mmcs_chunk_jobCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_chunk_jobCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_chunk_jobCFCopyDebugDescription()
{
  return 0;
}

void mmcs_engine_file_job_dispatch_async(uint64_t a1, uint64_t a2)
{
}

void mmcs_file_job_validate_file_callback(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 82))
  {
    *(CFAbsoluteTime *)(a1 + 200) = CFAbsoluteTimeGetCurrent();
    int v2 = *(unsigned char *)(a1 + 176) & 0x7F;
    if (v2 == 4)
    {
      if (*(char *)(a1 + 176) < 0) {
        mmcs_file_job_validate_file_callback_cold_3();
      }
      if (*(void *)(a1 + 192))
      {
        CKFileDigestArgumentsV2WithFileKeyCreate();
      }
      else
      {
        if (!*(void *)(a1 + 184)) {
          mmcs_file_job_validate_file_callback_cold_2();
        }
        CKFileDigestArgumentsV2WithBoundaryKeyCreate();
      }
    }
    else
    {
      if (v2 != 1) {
        mmcs_file_job_validate_file_callback_cold_1();
      }
      CKFileDigestArgumentsV1WithFileCreate();
    }
    int v3 = CK2CalculateItemSignatureWithFlags();
    char v4 = v3;
    if (v3) {
      *(void *)(a1 + 152) = 0;
    }
    else {
      *(void *)(a1 + 232) = 0;
    }
    *(CFAbsoluteTime *)(a1 + 208) = CFAbsoluteTimeGetCurrent();
    *(unsigned char *)(a1 + 216) = v4;
  }
}

uint64_t mmcs_file_job_done_callback(void *a1)
{
  int v2 = (void *)a1[21];
  if (v2) {
    free(v2);
  }
  a1[21] = 0;
  uint64_t v3 = a1[20];
  if (v3)
  {
    MMCSItemReaderWriterEnsureClosed(v3);
    char v4 = (const void *)a1[20];
    if (v4) {
      C3BaseRelease(v4);
    }
    a1[20] = 0;
  }
  CFStringRef v5 = (void (*)(void, void *))a1[16];
  if (v5) {
    v5(a1[12], a1);
  }
  return mmcs_file_job_invalidate((uint64_t)a1);
}

uint64_t mmcs_file_job_create(long long *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v4 = 0;
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  CFTypeRef v62 = 0;
  if (!a1 || !a3) {
    return v4;
  }
  uint64_t v61 = 0;
  if (!mmcs_get_file_ensure_temp_file_is_open(a3, &v61) || v61)
  {
    if (!a4) {
      goto LABEL_71;
    }
    uint64_t v11 = @"Error opening temp reader writer";
    goto LABEL_45;
  }
  uint64_t v9 = *(void *)(a3 + 8);
  if (*(void *)(v9 + 400))
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v9 + 400));
    uint64_t v9 = *(void *)(a3 + 8);
  }
  else
  {
    BytePtr = *(const UInt8 **)v9;
  }
  char file_signature_scheme_for_derivative_validation = *BytePtr;
  if (mmcs_item_is_derivative(v9))
  {
    CFStringRef v13 = *(const void **)(*(void *)(a3 + 8) + 368);
    if (v13)
    {
      C3BaseRetain(v13);
      CFTypeRef v62 = *(CFTypeRef *)(*(void *)(a3 + 8) + 368);
      char file_signature_scheme_for_derivative_validation = mmcs_item_get_file_signature_scheme_for_derivative_validation();
      goto LABEL_14;
    }
    uint64_t v22 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"derivative digest results are null for data validation");
      uint64_t v24 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v23;
        _os_log_impl(&dword_1DC1CA000, v24, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (v23) {
        CFRelease(v23);
      }
    }
    if (!a4) {
      goto LABEL_71;
    }
    uint64_t v11 = @"Derivative digest results are null for data validation";
LABEL_45:
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 1, v11);
    uint64_t v4 = 0;
    uint64_t v29 = 0;
    goto LABEL_46;
  }
  CKFileDigestResultsCreate();
LABEL_14:
  uint64_t valuePtr = 0;
  uint64_t v19 = *(void *)(a3 + 24);
  if (!v19)
  {
    *(void *)(a3 + 24) = 0;
LABEL_43:
    if (a4)
    {
      uint64_t v11 = @"Error opening temp reader writer, found NULL";
      goto LABEL_45;
    }
LABEL_71:
    uint64_t v4 = 0;
    uint64_t v29 = 0;
    goto LABEL_72;
  }
  CFTypeRef cf = 0;
  CFDictionaryRef theDict = 0;
  if (MMCSItemReaderWriterStat(v19, (CFTypeRef *)&theDict, &cf, v14, v15, v16, v17, v18))
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kMMCSItemReaderWriterFileSize");
    LODWORD(v21) = CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
    goto LABEL_31;
  }
  long long v25 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
    goto LABEL_30;
  }
  CFStringRef v21 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"could not stat temp file in file job: %@", cf);
  uint64_t v26 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v21;
    _os_log_impl(&dword_1DC1CA000, v26, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
  }
  if (v21)
  {
    CFRelease(v21);
LABEL_30:
    LODWORD(v21) = 0;
  }
LABEL_31:
  if (theDict) {
    CFRelease(theDict);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v21)
  {
    if (CKFileDigestResultsHasFileLength())
    {
      uint64_t v27 = valuePtr;
      if (v27 > CKFileDigestResultsFileLength())
      {
        off_t v28 = CKFileDigestResultsFileLength();
        CFDictionaryRef theDict = 0;
        mmcs_get_file_close_temp_reader_writer(a3);
        if (!mmcs_get_file_ensure_temp_file_is_open_with_length_check(a3, &theDict, v28))
        {
          uint64_t v54 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v55 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"could not reopen temp reader writer for truncation in file job: %@", theDict);
            uint64_t v56 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf) = 138543362;
              *(void *)((char *)&buf + 4) = v55;
              _os_log_impl(&dword_1DC1CA000, v56, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
            }
            if (v55) {
              CFRelease(v55);
            }
          }
          if (a4) {
            *a4 = mmcs_cferror_create_error(@"com.apple.mmcs", 1, @"Error reopening temp reader writer for truncation");
          }
          if (theDict) {
            CFRelease(theDict);
          }
          goto LABEL_71;
        }
      }
    }
  }
  uint64_t v29 = *(const void **)(a3 + 24);
  *(void *)(a3 + 24) = 0;
  if (!v29) {
    goto LABEL_43;
  }
  uint64_t v30 = C3TypeRegister(&mmcs_file_jobGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v30, 0xE0uLL);
  if (Instance)
  {
    uint64_t v4 = Instance;
    int v32 = pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0);
    *(unsigned char *)(v4 + 80) = v32 == 0;
    if (!v32)
    {
      *(unsigned char *)(v4 + 81) = 1;
      long long v47 = a1[2];
      long long v48 = *a1;
      *(_OWORD *)(v4 + 104) = a1[1];
      *(_OWORD *)(v4 + 120) = v47;
      *(_OWORD *)(v4 + 88) = v48;
      uint64_t v49 = *(void (**)(void))(v4 + 104);
      if (v49) {
        v49(*(void *)(v4 + 96));
      }
      *(void *)(v4 + 160) = v29;
      *(void *)(v4 + 168) = MMCSItemReaderWriterCKItemReadContextCreate((uint64_t)v29);
      CFTypeRef v50 = v62;
      *(void *)(v4 + 136) = a3;
      *(void *)(v4 + 144) = v50;
      CFTypeRef v62 = 0;
      *(unsigned char *)(v4 + 176) = file_signature_scheme_for_derivative_validation;
      uint64_t v51 = *(void *)(a3 + 8);
      CFTypeRef v52 = *(const void **)(v51 + 80);
      if (v52)
      {
        *(void *)(v4 + 184) = CFRetain(v52);
        uint64_t v51 = *(void *)(a3 + 8);
      }
      uint64_t v53 = *(const void **)(v51 + 88);
      if (v53) {
        *(void *)(v4 + 192) = CFRetain(v53);
      }
      *(void *)(v4 + 200) = 0;
      *(void *)(v4 + 208) = 0;
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = v4;
      uint64_t v64 = C3BaseRetain;
      uint64_t v65 = C3BaseRelease;
      uint64_t v66 = 0;
      uint64_t v67 = mmcs_file_job_validate_file_callback;
      CFStringRef v68 = mmcs_file_job_done_callback;
      uint64_t v29 = 0;
      *(void *)(v4 + 224) = mmcs_runloop_reply_job_create(*(const void **)(a2 + 56), &buf);
      goto LABEL_72;
    }
    C3BaseRelease((CFTypeRef)v4);
    goto LABEL_54;
  }
  uint64_t v34 = *__error();
  uint64_t v35 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
  {
    CFAllocatorRef v36 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v37 = *(void *)(*(void *)(a3 + 8) + 40);
    CFStringRef v38 = strerror(v34);
    CFStringRef v39 = CFStringCreateWithFormat(v36, 0, @"unable to create job for data validation of %llu: %s(%d)", v37, v38, v34);
    CFNumberRef v40 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v39;
      _os_log_impl(&dword_1DC1CA000, v40, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
    }
    if (v39) {
      CFRelease(v39);
    }
  }
  if (!a4)
  {
LABEL_54:
    uint64_t v4 = 0;
    goto LABEL_72;
  }
  uint64_t v41 = *(void *)(*(void *)(a3 + 8) + 40);
  strerror(v34);
  CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, @"Unable to create job for data validation of %llu: %s(%d)", v42, v43, v44, v45, v46, v41);
  uint64_t v4 = 0;
LABEL_46:
  *a4 = error;
LABEL_72:
  if (v62) {
    C3BaseRelease(v62);
  }
  CFTypeRef v62 = 0;
  if (v29)
  {
    MMCSItemReaderWriterEnsureClosed((uint64_t)v29);
    C3BaseRelease(v29);
  }
  return v4;
}

uint64_t mmcs_file_job_cancel(uint64_t a1)
{
  int v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (*(unsigned char *)(a1 + 82))
  {
    return pthread_mutex_unlock(v2);
  }
  else
  {
    *(unsigned char *)(a1 + 82) = 1;
    pthread_mutex_unlock(v2);
    mmcs_runloop_reply_job_cancel(*(void *)(a1 + 224));
    uint64_t v4 = *(const void **)(a1 + 224);
    if (v4) {
      C3BaseRelease(v4);
    }
    *(void *)(a1 + 224) = 0;
    return mmcs_file_job_invalidate(a1);
  }
}

uint64_t mmcs_file_job_invalidate(uint64_t a1)
{
  int v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  int v3 = *(unsigned __int8 *)(a1 + 81);
  *(unsigned char *)(a1 + 81) = 0;
  uint64_t result = pthread_mutex_unlock(v2);
  if (v3)
  {
    CFStringRef v5 = *(uint64_t (**)(uint64_t))(a1 + 112);
    uint64_t v6 = *(void *)(a1 + 96);
    return v5(v6);
  }
  return result;
}

void mmcs_file_job_append_description(uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  if (*(void *)a1)
  {
    uint64_t v2 = *(void *)(v1 + 136);
    if (v2)
    {
      uint64_t v3 = *(void *)(v2 + 8);
      if (v3)
      {
        uint64_t v5 = *(void *)(v3 + 40);
        mmcs_op_requestor_context_indent(a1);
        CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @"<file_job %p> item %lld\n", v1, v5);
      }
    }
  }
}

void _mmcs_file_jobCFFinalize(uint64_t a1)
{
  if (a1)
  {
    *(void *)(a1 + 136) = 0;
    mmcs_file_job_invalidate(a1);
    uint64_t v2 = *(void **)(a1 + 168);
    if (v2) {
      free(v2);
    }
    *(void *)(a1 + 168) = 0;
    uint64_t v3 = *(void *)(a1 + 160);
    if (v3)
    {
      MMCSItemReaderWriterEnsureClosed(v3);
      uint64_t v4 = *(const void **)(a1 + 160);
      if (v4) {
        C3BaseRelease(v4);
      }
      *(void *)(a1 + 160) = 0;
    }
    uint64_t v5 = *(const void **)(a1 + 184);
    if (v5) {
      CFRelease(v5);
    }
    *(void *)(a1 + 184) = 0;
    uint64_t v6 = *(const void **)(a1 + 192);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(a1 + 192) = 0;
    uint64_t v7 = *(const void **)(a1 + 224);
    if (v7) {
      C3BaseRelease(v7);
    }
    *(void *)(a1 + 224) = 0;
    double v8 = *(const void **)(a1 + 232);
    if (v8) {
      CFRelease(v8);
    }
    *(void *)(a1 + 232) = 0;
    uint64_t v9 = *(const void **)(a1 + 144);
    if (v9) {
      C3BaseRelease(v9);
    }
    *(void *)(a1 + 144) = 0;
    uint64_t v10 = *(const void **)(a1 + 152);
    if (v10) {
      C3BaseRelease(v10);
    }
    *(void *)(a1 + 152) = 0;
    if (*(unsigned char *)(a1 + 80))
    {
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
    }
  }
}

BOOL _mmcs_file_jobCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_file_jobCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_file_jobCFCopyDebugDescription()
{
  return 0;
}

uint64_t _mmcs_metrics_http_info_retain_callback(uint64_t a1, uint64_t a2)
{
  uint64_t result = a2;
  if (a2) {
    ++*(void *)(a2 + 8);
  }
  return result;
}

void _mmcs_metrics_http_info_release_callback(uint64_t a1, void *a2)
{
}

void *mmcs_chunking_info_create()
{
  uint64_t result = malloc_type_calloc(1uLL, 0x50uLL, 0x10700403F21534CuLL);
  if (result) {
    result[1] = 1;
  }
  return result;
}

void mmcs_metrics_chunking_info_release(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[1] - 1;
    a1[1] = v2;
    if (!v2)
    {
      uint64_t v3 = (const void *)a1[5];
      if (v3) {
        CFRelease(v3);
      }
      a1[5] = 0;
      uint64_t v4 = (const void *)a1[8];
      if (v4) {
        CFRelease(v4);
      }
      a1[8] = 0;
      uint64_t v5 = (void *)a1[2];
      if (v5) {
        free(v5);
      }
      free(a1);
    }
  }
}

CFStringRef mmcs_metrics_chunking_info_copy_description(uint64_t a1)
{
  double v2 = *(double *)(a1 + 56);
  if (v2 == 0.0) {
    double v3 = 0.0;
  }
  else {
    double v3 = v2 - *(double *)(a1 + 48);
  }
  uint64_t v4 = mmcs_file_signature_to_hexstring(*(char **)(a1 + 16));
  CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<chunking_metrics %p> item_sig:%s nrBytes:%lld nrChunks:%lld start:%f elapsed:%0.4lf cancelled: %d chunkErr:%@", a1, v4, *(void *)(a1 + 24), *(void *)(a1 + 32), *(void *)(a1 + 48), *(void *)&v3, *(unsigned __int8 *)(a1 + 72), *(void *)(a1 + 64));
  if (v4) {
    free(v4);
  }
  return v5;
}

__CFArray *mmcs_metrics_request_add_chunking_info(__CFArray *result, void *a2)
{
  if (result) {
    return _addToLazyArray((__CFArray **)result + 17, a2, &_chunkingInfoArrayCallbacks);
  }
  return result;
}

__CFArray *_addToLazyArray(__CFArray **a1, void *value, const CFArrayCallBacks *a3)
{
  uint64_t result = 0;
  if (a1)
  {
    if (value)
    {
      uint64_t result = *a1;
      if (*a1 || (uint64_t result = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a3), (*a1 = result) != 0))
      {
        CFArrayAppendValue(result, value);
        return (__CFArray *)(*a1 != 0);
      }
    }
  }
  return result;
}

void mmcs_metrics_harvest_chunking_info(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    if (*(void *)(a2 + 176))
    {
      if (CKFileDigestResultsFileSignature())
      {
        uint64_t v4 = (const void *)CKFileDigestResultsFileSignature();
        *(void *)(a1 + 16) = mmcs_file_signature_copy(v4);
      }
      *(void *)(a1 + 24) = CKFileDigestResultsFileLength();
    }
    *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 224);
    uint64_t v5 = *(void *)(a2 + 264);
    *(void *)(a1 + 32) = *(void *)(a2 + 256);
    if (v5) {
      CKProfileResultsType();
    }
    uint64_t v6 = (const char *)CKProfileTypeDescription();
    *(void *)(a1 + 40) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, 0x8000100u);
    *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 84);
    uint64_t v7 = *(const void **)(a2 + 280);
    if (v7) {
      CFRetain(v7);
    }
    double v8 = *(const void **)(a1 + 64);
    if (v8) {
      CFRelease(v8);
    }
    *(void *)(a1 + 64) = *(void *)(a2 + 280);
  }
}

char *mmcs_metrics_http_info_create(const void *a1, const void *a2, uint64_t a3, char a4)
{
  if (!a3) {
    return 0;
  }
  double v8 = (char *)malloc_type_calloc(1uLL, 0x70uLL, 0x1060040495C2754uLL);
  if (!v8) {
    return v8;
  }
  if (a1)
  {
    CFRetain(a1);
    *((void *)v8 + 2) = a1;
  }
  if (a2)
  {
    CFRetain(a2);
    *((void *)v8 + 4) = a2;
  }
  if (!metricsinfo__new((uint64_t)(v8 + 24)) || !socketinfo__new((uint64_t)(v8 + 56))) {
    return 0;
  }
  *((void *)v8 + 1) = 1;
  metricsinfo__clear_response_size(*((void *)v8 + 3));
  v8[64] = *(unsigned char *)(a3 + 72);
  *(_WORD *)(v8 + 65) = *(_WORD *)(a3 + 73);
  uint64_t v9 = *(void *)(a3 + 80);
  v8[67] = *(void *)(a3 + 88) == 0;
  v8[68] = *(unsigned char *)(a3 + 76);
  *((void *)v8 + 9) = v9;
  v8[80] = a4;
  uint64_t v10 = *(const void **)(a3 + 56);
  if (v10)
  {
    CFRetain(v10);
    *((void *)v8 + 13) = *(void *)(a3 + 56);
  }
  return v8;
}

void mmcs_metrics_http_info_release(void *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = a1[1] - 1;
    a1[1] = v2;
    if (!v2)
    {
      if (metricsinfo__get_stop_time(a1[3]) == 0.0)
      {
        double v3 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"no stopTime %p !!", a1);
          uint64_t v5 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v11 = v4;
            _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
          }
          if (v4) {
            CFRelease(v4);
          }
        }
      }
      uint64_t v6 = (const void *)a1[2];
      if (v6) {
        CFRelease(v6);
      }
      a1[2] = 0;
      uint64_t v7 = (const void *)a1[4];
      if (v7) {
        CFRelease(v7);
      }
      a1[4] = 0;
      double v8 = (const void *)a1[5];
      if (v8) {
        CFRelease(v8);
      }
      a1[5] = 0;
      metricsinfo__free(a1[3]);
      a1[3] = 0;
      socketinfo__free(a1[7]);
      a1[7] = 0;
      a1[11] = 0;
      a1[12] = 0;
      uint64_t v9 = (const void *)a1[13];
      if (v9) {
        CFRelease(v9);
      }
      free(a1);
    }
  }
}

CFStringRef mmcs_metrics_http_info_copy_description(uint64_t a1)
{
  if (metricsinfo__get_stop_time(*(void *)(a1 + 24)) == 0.0)
  {
    double v3 = 0.0;
  }
  else
  {
    double stop_time = metricsinfo__get_stop_time(*(void *)(a1 + 24));
    double v3 = stop_time - metricsinfo__get_start_time(*(void *)(a1 + 24));
  }
  uint64_t v4 = *(void *)(a1 + 24);
  double v5 = *(double *)(v4 + 96);
  if (v5 != 0.0) {
    double v5 = v5 - *(double *)(v4 + 56);
  }
  cferror_with_http_CFErrorRef error = metricsinfo__create_cferror_with_http_error(v4);
  uint64_t v20 = *(void *)(a1 + 16);
  CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v7 = mmcs_request_index(*(void *)(a1 + 24));
  uint64_t v8 = mmcs_request_index(*(void *)(a1 + 56));
  uint64_t v9 = mmcs_chunk_instance_offset(*(void *)(a1 + 56));
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  double start_time = metricsinfo__get_start_time(*(void *)(a1 + 24));
  uint64_t v13 = *(void *)(a1 + 24);
  uint64_t v14 = *(void *)(v13 + 112);
  uint64_t v15 = *(void *)(v13 + 176);
  uint64_t v16 = *(unsigned int *)(v13 + 48);
  uint64_t transaction_complete = metricsinfo__get_transaction_complete(v13);
  CFStringRef v18 = CFStringCreateWithFormat(v21, 0, @"<http_metrics %p> operation:%@ url:%s interfaceIdentifier:%s destination address:%s uuid:%@ identifier:%@ start:%f respRecd:%0.4lf elapsed:%0.4lf httpStatus:%d httpErr:%@ requestBytes:%lld responseBytes:%lld completed:%d timedout:%d cancelled:%d networkServiceType:%@", a1, v20, v7, v8, v9, v10, v11, *(void *)&start_time, *(void *)&v5, *(void *)&v3, v16, cferror_with_http_error, v14, v15, transaction_complete, *(unsigned int *)(*(void *)(a1 + 24) + 40),
          *(unsigned __int8 *)(a1 + 48),
          *(void *)(a1 + 104));
  if (cferror_with_http_error) {
    CFRelease(cferror_with_http_error);
  }
  return v18;
}

uint64_t mmcs_metrics_harvest_http_info(uint64_t result, uint64_t a2)
{
  if (result && a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)(result + 56);
    int is_connection_reused = mmcs_http_context_is_connection_reused(a2);
    socketinfo__set_is_reused(v4, is_connection_reused);
    uint64_t v6 = *(void *)(v3 + 24);
    double started = mmcs_http_context_start_time(a2);
    metricsinfo__set_start_time(v6, started);
    if (mmcs_http_context_has_enqueued_time(a2))
    {
      uint64_t v8 = *(void *)(v3 + 24);
      double v9 = mmcs_http_context_enqueued_time(a2);
      metricsinfo__set_enqueued_time(v8, v9);
    }
    uint64_t v10 = *(void *)(v3 + 24);
    double v11 = mmcs_http_context_response_received_time(a2);
    metricsinfo__set_response_received_time(v10, v11);
    uint64_t v12 = *(void *)(v3 + 24);
    double v13 = mmcs_http_context_stop_time(a2);
    metricsinfo__set_stop_time(v12, v13);
    if (mmcs_http_context_has_http_status(a2))
    {
      uint64_t v14 = *(void *)(v3 + 24);
      int v15 = mmcs_http_context_http_status(a2);
      metricsinfo__set_http_status(v14, v15);
    }
    uint64_t v16 = *(void *)(v3 + 24);
    CFErrorRef error = (__CFError *)mmcs_http_context_get_error(a2);
    metricsinfo__set_http_error_with_cferror(v16, error);
    *(void *)(v3 + 40) = mmcs_http_context_copy_uuid(a2);
    uint64_t v18 = *(void *)(v3 + 56);
    interface_identifier = (char *)mmcs_http_context_get_interface_identifier(a2);
    socketinfo__set_interface_identifier_with_c_string(v18, interface_identifier);
    if (mmcs_http_context_is_to_mobile_me(a2))
    {
      uint64_t v20 = mmcs_http_context_copy_request_url(a2);
      uint64_t v21 = *(void *)(v3 + 24);
      CFStringRef v22 = CFURLGetString(v20);
      metricsinfo__set_request_url_with_cfstring(v21, v22);
      if (v20) {
        CFRelease(v20);
      }
      uint64_t v23 = *(void *)(v3 + 56);
      destination_address = (char *)mmcs_http_context_get_destination_address(a2);
      socketinfo__set_peer_address_with_c_string(v23, destination_address);
      uint64_t v25 = *(void *)(v3 + 56);
      int v26 = mmcs_http_context_destination_port(a2);
      socketinfo__set_peer_port(v25, v26);
    }
    else
    {
      uint64_t user_data = mmcs_http_context_get_user_data(a2);
      if (mmcs_transaction_is_proxy(user_data))
      {
        uint64_t user_data = *(void *)(*(void *)(user_data + 64) + 16);
      }
      else
      {
        uint64_t v28 = *(void *)(v3 + 56);
        uint64_t v29 = (char *)mmcs_http_context_get_destination_address(a2);
        socketinfo__set_peer_address_with_c_string(v28, v29);
      }
      CFURLRef v30 = CFHTTPMessageCopyRequestURL(*(CFHTTPMessageRef *)(*(void *)(user_data + 24) + 16));
      uint64_t v31 = *(void *)(v3 + 24);
      CFStringRef v32 = CFURLGetString(v30);
      metricsinfo__set_request_url_with_cfstring(v31, v32);
      SInt32 v33 = CFURLGetPortNumber(v30);
      socketinfo__set_peer_port(*(void *)(v3 + 56), v33);
      if (v30) {
        CFRelease(v30);
      }
    }
    if (mmcs_http_context_has_bytes_written(a2))
    {
      uint64_t v34 = mmcs_http_context_bytes_written(a2);
      uint64_t v35 = mmcs_http_context_request_size(a2);
      if (v34) {
        uint64_t v36 = v34;
      }
      else {
        uint64_t v36 = v35;
      }
      metricsinfo__set_request_size(*(void *)(v3 + 24), v36);
    }
    if (mmcs_http_context_has_bytes_read(a2))
    {
      if (mmcs_http_context_has_bytes_read(a2)) {
        uint64_t v37 = mmcs_http_context_bytes_read(a2);
      }
      else {
        uint64_t v37 = 0;
      }
      if (mmcs_http_context_has_response_size(a2)) {
        uint64_t v38 = mmcs_http_context_response_size(a2);
      }
      else {
        uint64_t v38 = 0;
      }
      if (v37) {
        uint64_t v39 = v37;
      }
      else {
        uint64_t v39 = v38;
      }
      metricsinfo__set_response_size(*(void *)(v3 + 24), v39);
    }
    uint64_t v40 = *(void *)(v3 + 24);
    int is_complete = mmcs_http_context_is_complete(a2);
    metricsinfo__set_transaction_complete(v40, is_complete);
    if (mmcs_http_context_has_timedout(a2))
    {
      uint64_t v42 = *(void *)(v3 + 24);
      int is_timedout = mmcs_http_context_is_timedout(a2);
      metricsinfo__set_timed_out(v42, is_timedout);
    }
    uint64_t result = mmcs_http_context_is_cancelled(a2);
    *(unsigned char *)(v3 + 48) = result;
  }
  return result;
}

__CFArray *mmcs_metrics_request_add_http_info_for_auth(__CFArray *result, void *a2)
{
  if (result) {
    return _addToLazyArray((__CFArray **)result + 9, a2, &httpInfoArrayCallbacks);
  }
  return result;
}

__CFArray *mmcs_metrics_request_add_http_info_for_transfer(__CFArray *result, void *a2)
{
  if (result) {
    return _addToLazyArray((__CFArray **)result + 10, a2, &httpInfoArrayCallbacks);
  }
  return result;
}

__CFArray *mmcs_metrics_request_add_http_info_for_completion(__CFArray *result, void *a2)
{
  if (result) {
    return _addToLazyArray((__CFArray **)result + 11, a2, &httpInfoArrayCallbacks);
  }
  return result;
}

uint64_t mmcs_metrics_http_info_set_final_try_in_request(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v2 = (void *)MEMORY[0x1E4F1CFD0];
    if (!a2) {
      uint64_t v2 = (void *)MEMORY[0x1E4F1CFC8];
    }
    *(void *)(result + 88) = *v2;
  }
  return result;
}

uint64_t mmcs_metrics_http_info_set_inline_edge_complete(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 96) = a2;
  }
  return result;
}

void *mmcs_metrics_request_create(const void *a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0xA8uLL, 0x1060040DC2DA957uLL);
  if (v2)
  {
    if (a1)
    {
      CFRetain(a1);
      v2[2] = a1;
    }
    v2[1] = 1;
  }
  return v2;
}

uint64_t mmcs_metrics_request_retain(uint64_t result)
{
  if (result) {
    ++*(void *)(result + 8);
  }
  return result;
}

void mmcs_metrics_request_release(double *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = *((void *)a1 + 1) - 1;
    *((void *)a1 + 1) = v2;
    if (!v2)
    {
      if (a1[5] == 0.0)
      {
        uint64_t v3 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"no stopTime %p !!", a1);
          double v5 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v14 = v4;
            _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
          }
          if (v4) {
            CFRelease(v4);
          }
        }
      }
      uint64_t v6 = (const void *)*((void *)a1 + 2);
      if (v6) {
        CFRelease(v6);
      }
      a1[2] = 0.0;
      uint64_t v7 = (const void *)*((void *)a1 + 6);
      if (v7) {
        CFRelease(v7);
      }
      a1[6] = 0.0;
      uint64_t v8 = (const void *)*((void *)a1 + 7);
      if (v8) {
        CFRelease(v8);
      }
      a1[7] = 0.0;
      double v9 = (const void *)*((void *)a1 + 17);
      if (v9) {
        CFRelease(v9);
      }
      a1[17] = 0.0;
      uint64_t v10 = (const void *)*((void *)a1 + 9);
      if (v10) {
        CFRelease(v10);
      }
      a1[9] = 0.0;
      double v11 = (const void *)*((void *)a1 + 10);
      if (v11) {
        CFRelease(v11);
      }
      a1[10] = 0.0;
      uint64_t v12 = (const void *)*((void *)a1 + 11);
      if (v12) {
        CFRelease(v12);
      }
      free(a1);
    }
  }
}

CFStringRef mmcs_metrics_request_copy_description(uint64_t a1)
{
  double v2 = *(double *)(a1 + 40);
  if (v2 == 0.0) {
    double v3 = 0.0;
  }
  else {
    double v3 = v2 - *(double *)(a1 + 32);
  }
  CFComparisonResult v4 = CFStringCompare(@"get", *(CFStringRef *)(a1 + 16), 0);
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v11 = *(void *)(a1 + 64);
  if (v4) {
    return CFStringCreateWithFormat(v5, 0, @"<request_metrics %p> type:%@ protoVers:%0.3lf start:%f elapsed:%0.4lf cancelErr:%@ reqErr:%@ nrItems:%ld nrChunksUploaded:%ld chunking:%@ authRequests:%@ containerRequests:%@ completionRequests:%@", a1, v6, v7, v8, *(void *)&v3, v9, v10, v11, *(void *)(a1 + 128), *(void *)(a1 + 136), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88));
  }
  else {
    return CFStringCreateWithFormat(v5, 0, @"<request_metrics %p> type:%@ protoVers:%0.3lf start:%f elapsed:%0.4lf cancelErr:%@ reqErr:%@ nrItems:%ld nrItemsNeedingChunks:%ld bytesFromPeers:%lld bytesFromLocal:%lld bytesResumed:%lld authRequests:%@ containerRequests:%@ completionRequests:%@", a1, v6, v7, v8, *(void *)&v3, v9, v10, v11, *(void *)(a1 + 96), *(void *)(a1 + 104), *(void *)(a1 + 112), *(void *)(a1 + 120), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88));
  }
}

void mmcs_metrics_request_started(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    *(CFAbsoluteTime *)(a1 + 32) = CFAbsoluteTimeGetCurrent();
    *(void *)(a1 + 64) = a2;
  }
}

void _mmcs_metrics_request_stopped(uint64_t a1, const void *a2, const void *a3)
{
  if (a1)
  {
    *(CFAbsoluteTime *)(a1 + 40) = CFAbsoluteTimeGetCurrent();
    if (a2) {
      CFRetain(a2);
    }
    uint64_t v6 = *(const void **)(a1 + 56);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(a1 + 56) = a2;
    if (a3) {
      CFRetain(a3);
    }
    uint64_t v7 = *(const void **)(a1 + 48);
    if (v7) {
      CFRelease(v7);
    }
    *(void *)(a1 + 48) = a3;
  }
}

void mmcs_metrics_request_set_error(uint64_t a1, const void *a2)
{
}

uint64_t _mmcs_metrics_chunking_info_retain_callback(uint64_t a1, uint64_t a2)
{
  uint64_t result = a2;
  if (a2) {
    ++*(void *)(a2 + 8);
  }
  return result;
}

void _mmcs_metrics_chunking_info_release_callback(int a1, void *a2)
{
}

uint64_t MMCSEngineClientContextCopy(void *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (*a1 > 0xAuLL)
  {
    CFComparisonResult v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unknown engine client version %ld\n", *a1);
      uint64_t v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v8 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
    return 0;
  }
  else
  {
    double v2 = *(&MMCSEngineClientContextClasses)[*a1];
    return v2();
  }
}

void MMCSEngineClientContextFree(void *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (*a1 > 0xAuLL)
  {
    double v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unknown engine client version %ld\n", *a1);
      CFStringRef v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v7 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  else
  {
    double v2 = (void (*)(void))(&MMCSEngineClientContextClasses)[*a1][1];
    v2();
  }
}

uint64_t MMCSEngineClientContextGetItemReaderWriterForItem(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, void *a6, CFTypeRef *a7)
{
  char v10 = a4;
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (a7) {
    *a7 = 0;
  }
  CFTypeRef cf = 0;
  CFTypeRef v54 = 0;
  uint64_t v12 = *(unsigned int (**)(uint64_t, uint64_t, int *, CFTypeRef *, CFTypeRef *))(a1 + 16);
  if (*(uint64_t *)a1 >= 3)
  {
    if (v12) {
      goto LABEL_12;
    }
    if (*(void *)a1 > 5uLL)
    {
      *(void *)CFStringRef v55 = 0;
      if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint8_t *, CFTypeRef *))(a1 + 64))(a2, a3, a4, v55, &v54)|| (uint64_t v32 = *(void *)v55) == 0)
      {
        uint64_t v49 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v40 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"getItemReaderWriterForItemCallback did not succeed");
          uint64_t v41 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_46;
          }
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v57 = v40;
LABEL_45:
          _os_log_impl(&dword_1DC1CA000, v41, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
LABEL_46:
          if (v40) {
            CFRelease(v40);
          }
        }
LABEL_48:
        CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_file_error_wrapping_error_to_release((__CFError *)v54, (char)@"Getting the item readerWriter failed. ", v34, v35, v36, v37, v38, v39);
        goto LABEL_49;
      }
    }
    else
    {
      *(void *)CFStringRef v55 = 0;
      if (!(*(unsigned int (**)(uint64_t, uint64_t, uint8_t *, CFTypeRef *))(a1 + 64))(a2, a4, v55, &v54)
        || (uint64_t v32 = *(void *)v55) == 0)
      {
        SInt32 v33 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v40 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"getItemReaderWriterForItemCallback did not succeed");
          uint64_t v41 = mmcs_logging_logger_default();
          if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_46;
          }
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v57 = v40;
          goto LABEL_45;
        }
        goto LABEL_48;
      }
    }
    *a6 = v32;
LABEL_35:
    uint64_t v31 = 1;
    goto LABEL_50;
  }
  if (!v12)
  {
    double v13 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Missing MMCSGetFileDescriptorAndContentTypeFromItemCallback.");
      uint64_t v15 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v57 = v14;
        _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v14) {
        CFRelease(v14);
      }
    }
    CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_error(@"com.apple.mmcs", 40, @"Missing MMCSGetFileDescriptorAndContentTypeFromItemCallback.");
    goto LABEL_49;
  }
LABEL_12:
  int v52 = -1;
  if (!v12(a2, a4, &v52, &cf, &v54))
  {
    if (!v54)
    {
      CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_with_format(@"com.apple.mmcs", 9, @"No client error provided for failed getFileDescriptorAndContentTypeFromItemCallback for item %lld", v17, v18, v19, v20, v21, v10);
      goto LABEL_49;
    }
    goto LABEL_16;
  }
  bzero(buf, 0x400uLL);
  if (get_path_for_fd(v52, (char *)buf))
  {
    int v22 = *__error();
    CFIndex v23 = v22;
    char v24 = v52;
    strerror(v22);
    CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_file_error_with_format(v23, @"get_path_for_fd(%d) failed: %s for item %lld ", v25, v26, v27, v28, v29, v30, v24);
LABEL_49:
    uint64_t v31 = 0;
    CFTypeRef v54 = file_error_wrapping_error_to_release;
    goto LABEL_50;
  }
  CFAllocatorRef v42 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v43 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)buf);
  CFStringRef v44 = v43;
  uint64_t v45 = cf;
  if (*(uint64_t *)a1 <= 2 && !cf)
  {
    uint64_t v45 = XCFStringCopyPathExtension(v43);
    CFTypeRef cf = v45;
  }
  uint64_t v46 = MMCSItemReaderWriterCreateWithFileDescriptor(v52, (uint64_t)v45, (uint64_t)v44, 0, (CFErrorRef *)&v54);
  if (v44) {
    CFRelease(v44);
  }
  if (v46)
  {
    if (*(uint64_t *)a1 <= 1) {
      MMCSItemReaderWriterSetNeverClose((uint64_t)v46, a5);
    }
    *a6 = v46;
    goto LABEL_35;
  }
  long long v47 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
    goto LABEL_16;
  }
  uint64_t v31 = (uint64_t)CFStringCreateWithFormat(v42, 0, @"failed MMCSItemReaderWriterCreateWithFileDescriptor");
  long long v48 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)CFStringRef v55 = 138543362;
    *(void *)&v55[4] = v31;
    _os_log_impl(&dword_1DC1CA000, v48, OS_LOG_TYPE_ERROR, "%{public}@", v55, 0xCu);
  }
  if (v31)
  {
    CFRelease((CFTypeRef)v31);
LABEL_16:
    uint64_t v31 = 0;
  }
LABEL_50:
  if (a7 && !v31)
  {
    CFErrorRef error = v54;
    if (!v54)
    {
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 39, @"MMCSEngineClientContextGetItemReaderWriterForItem missing local error");
      CFTypeRef v54 = error;
    }
    CFRetain(error);
    *a7 = v54;
  }
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef cf = 0;
  if (v54) {
    CFRelease(v54);
  }
  return v31;
}

uint64_t MMCSEngineClientContextGetItemProgress(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (result)
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(result + 24);
    if (v6) {
      return v6(a2, a3, a4, a5, a6);
    }
  }
  return result;
}

void *MMCSEngineClientContextGetItemDone(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (result)
  {
    if ((unint64_t)(*result - 5) > 5)
    {
      uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))result[4];
      if (v8) {
        return (void *)v8(a2, a3, a4, a5, a6);
      }
    }
    else
    {
      CFStringRef v7 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))result[4];
      if (v7) {
        return (void *)v7(a2, a3, a4, a5, a6, a7);
      }
    }
  }
  return result;
}

uint64_t *MMCSEngineClientContextRequestCompleted(uint64_t *result, uint64_t a2, uint64_t a3)
{
  if (*result < 7)
  {
    CFStringRef v4 = (uint64_t (*)(uint64_t))result[7];
    if (v4) {
      return (uint64_t *)v4(a2);
    }
  }
  else
  {
    double v3 = (uint64_t (*)(uint64_t, uint64_t))result[7];
    if (v3) {
      return (uint64_t *)v3(a2, a3);
    }
  }
  return result;
}

void MMCSEngineClientContextPutItemProgress(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, CFDictionaryRef theDict, __n128 a7)
{
  unint64_t v8 = a7.n128_u64[0];
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*a1 > 7uLL)
  {
    if ((unint64_t)(*a1 - 8) > 2)
    {
      uint64_t v17 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unknown engine client version %ld\n", *a1);
        uint64_t v19 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v22 = v18;
          _os_log_impl(&dword_1DC1CA000, v19, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v18) {
          CFRelease(v18);
        }
      }
    }
    else
    {
      uint64_t v16 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, CFDictionaryRef))a1[5];
      v16(a2, a3, a4, a5, theDict);
    }
  }
  else
  {
    if (theDict)
    {
      CFNumberRef Value = CFDictionaryGetValue(theDict, @"kMMCSPutReceipt");
      uint64_t v15 = CFDictionaryGetValue(theDict, @"kMMCSResultError");
    }
    else
    {
      CFNumberRef Value = 0;
      uint64_t v15 = 0;
    }
    uint64_t v20 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, const void *, const void *, __n128))a1[5];
    a7.n128_u64[0] = v8;
    v20(a2, a3, a4, a5, Value, v15, a7);
  }
}

void MMCSEngineClientContextPutItemDone(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, CFDictionaryRef theDict)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*a1 > 7uLL)
  {
    if ((unint64_t)(*a1 - 8) > 2)
    {
      double v13 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unknown engine client version %ld\n", *a1);
        uint64_t v15 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v18 = v14;
          _os_log_impl(&dword_1DC1CA000, v15, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v14) {
          CFRelease(v14);
        }
      }
    }
    else
    {
      uint64_t v12 = (void (*)(uint64_t, uint64_t, uint64_t, CFDictionaryRef))a1[6];
      v12(a2, a3, a4, theDict);
    }
  }
  else
  {
    if (theDict)
    {
      CFNumberRef Value = CFDictionaryGetValue(theDict, @"kMMCSPutReceipt");
      uint64_t v11 = CFDictionaryGetValue(theDict, @"kMMCSResultError");
    }
    else
    {
      CFNumberRef Value = 0;
      uint64_t v11 = 0;
    }
    uint64_t v16 = (void (*)(uint64_t, uint64_t, uint64_t, const void *, const void *))a1[6];
    v16(a2, a3, a4, Value, v11);
  }
}

void MMCSEngineClientContextPutSectionProgress(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if ((unint64_t)(*a1 - 4) > 6)
  {
    uint64_t v9 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unknown engine client version %ld\n", *a1);
      uint64_t v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v13 = v10;
        _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v10) {
        CFRelease(v10);
      }
    }
  }
  else
  {
    unint64_t v8 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))a1[9];
    if (v8)
    {
      v8(a2, a3, a4, a5, a6, a7);
    }
  }
}

void MMCSEngineClientContextPutSectionDone(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, CFDictionaryRef theDict)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if ((unint64_t)(*a1 - 4) > 4)
  {
    if ((unint64_t)(*a1 - 9) > 1)
    {
      uint64_t v14 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unknown engine client version %ld\n", *a1);
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v18 = v15;
          _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v15) {
          CFRelease(v15);
        }
      }
    }
    else
    {
      CFStringRef v13 = (void (*)(uint64_t, uint64_t, uint64_t, CFDictionaryRef))a1[10];
      if (v13)
      {
        v13(a2, a3, a4, theDict);
      }
    }
  }
  else
  {
    CFStringRef v10 = (void (*)(uint64_t, uint64_t, uint64_t, const void *, const void *))a1[10];
    if (v10)
    {
      if (theDict)
      {
        CFNumberRef Value = CFDictionaryGetValue(theDict, @"kMMCSPutReceipt");
        uint64_t v12 = CFDictionaryGetValue(theDict, @"kMMCSResultError");
        CFStringRef v10 = (void (*)(uint64_t, uint64_t, uint64_t, const void *, const void *))a1[10];
      }
      else
      {
        CFNumberRef Value = 0;
        uint64_t v12 = 0;
      }
      v10(a2, a3, a4, Value, v12);
    }
  }
}

uint64_t MMCSEngineClientContextGetItemReaderWriterForChunkSignature(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, CFTypeRef *a6)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (a6) {
    *a6 = 0;
  }
  CFTypeRef cf = 0;
  if (*a1 == 10)
  {
    uint64_t v25 = 0;
    uint64_t v9 = (unsigned int (*)(uint64_t, uint64_t, uint64_t, uint64_t *, CFTypeRef *))a1[11];
    if (v9)
    {
      if (v9(a2, a3, a4, &v25, &cf)) {
        BOOL v10 = v25 == 0;
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10)
      {
        *a5 = v25;
        uint64_t v22 = 1;
        goto LABEL_23;
      }
      uint64_t v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v28 = (uint64_t)cf;
        _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_INFO, "Retrieving itemReaderWriter for chunk signature unsuccessful with error %@", buf, 0xCu);
      }
      CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_file_error_wrapping_error_to_release((__CFError *)cf, (char)@"Retrieving itemReaderWriter for chunk signature unsuccessful.", v12, v13, v14, v15, v16, v17);
    }
    else
    {
      uint64_t v21 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_INFO, "Retrieving itemReaderWriter for chunk signature unsuccessful, no callback provided on engine context.", buf, 2u);
      }
      CFErrorRef file_error_wrapping_error_to_release = mmcs_cferror_create_error(@"com.apple.mmcs", 1, @"Retrieving itemReaderWriter for chunk signature unsuccessful, no callback provided on engine context.");
    }
    uint64_t v22 = 0;
    CFTypeRef cf = file_error_wrapping_error_to_release;
    goto LABEL_23;
  }
  uint64_t v19 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
LABEL_18:
    uint64_t v22 = 0;
    goto LABEL_23;
  }
  uint64_t v22 = (uint64_t)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unsupported engine client version %ld\n", *a1);
  uint64_t v20 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138543362;
    uint64_t v28 = v22;
    _os_log_impl(&dword_1DC1CA000, v20, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
  }
  if (v22)
  {
    CFRelease((CFTypeRef)v22);
    goto LABEL_18;
  }
LABEL_23:
  CFErrorRef error = cf;
  if (a6 && !v22)
  {
    if (!cf)
    {
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 39, @"MMCSEngineClientContextGetItemReaderWriterForItem missing local error");
      CFTypeRef cf = error;
    }
    CFRetain(error);
    CFErrorRef error = cf;
    *a6 = cf;
  }
  if (error) {
    CFRelease(error);
  }
  return v22;
}

__n128 MMCSEngineClientContextCopy0(uint64_t a1)
{
  double v2 = malloc_type_calloc(1uLL, 0x40uLL, 0x108004041683268uLL);
  if (v2)
  {
    __n128 result = *(__n128 *)a1;
    long long v4 = *(_OWORD *)(a1 + 16);
    long long v5 = *(_OWORD *)(a1 + 48);
    v2[2] = *(_OWORD *)(a1 + 32);
    v2[3] = v5;
    *double v2 = result;
    v2[1] = v4;
  }
  return result;
}

void mmcs_update_request_abort(uint64_t a1, CFErrorRef err, void (*a3)(uint64_t, CFDictionaryRef))
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  if (err && a3)
  {
    CFErrorDomain Domain = CFErrorGetDomain(err);
    if (!CFEqual(@"com.apple.mmcs", Domain)) {
      mmcs_update_request_abort_cold_1();
    }
    values = err;
    keys[0] = @"kMMCSResultError";
    CFDictionaryRef v7 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    a3(a1, v7);
    if (v7) {
      CFRelease(v7);
    }
  }
}

uint64_t mmcs_update_request_has_items_not_done(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 304) + 72);
}

void mmcs_update_request_append_description(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    CFStringRef v2 = _mmcs_request_copy_description(*(void *)a1);
    if (v2)
    {
      CFStringRef v3 = v2;
      CFStringAppend(*(CFMutableStringRef *)(a1 + 16), v2);
      CFRelease(v3);
    }
  }
}

void mmcs_update_request_finalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 304);
  CFStringRef v3 = *(const void **)(v2 + 16);
  if (v3)
  {
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 304);
  }
  *(void *)(v2 + 16) = 0;
  uint64_t v4 = *(void *)(a1 + 304);
  long long v5 = *(const void **)(v4 + 24);
  if (v5)
  {
    CFRelease(v5);
    uint64_t v4 = *(void *)(a1 + 304);
  }
  *(void *)(v4 + 24) = 0;
  uint64_t v6 = *(void *)(a1 + 304);
  CFDictionaryRef v7 = *(const void **)(v6 + 32);
  if (v7)
  {
    CFRelease(v7);
    uint64_t v6 = *(void *)(a1 + 304);
  }
  *(void *)(v6 + 32) = 0;
  uint64_t v8 = *(void *)(a1 + 304);
  uint64_t v9 = *(const void **)(v8 + 40);
  if (v9)
  {
    CFRelease(v9);
    uint64_t v8 = *(void *)(a1 + 304);
  }
  *(void *)(v8 + 40) = 0;
  uint64_t v10 = *(void *)(a1 + 304);
  uint64_t v11 = *(const void **)(v10 + 64);
  if (v11)
  {
    CFRelease(v11);
    uint64_t v10 = *(void *)(a1 + 304);
  }
  *(void *)(v10 + 64) = 0;
  uint64_t v12 = *(void **)(a1 + 304);
  uint64_t v13 = v12[6];
  if (v13)
  {
    mmcs_http_context_invalidate(v13);
    uint64_t v14 = *(void *)(a1 + 304);
    uint64_t v15 = *(const void **)(v14 + 48);
    if (v15)
    {
      C3BaseRelease(v15);
      uint64_t v14 = *(void *)(a1 + 304);
    }
    *(void *)(v14 + 48) = 0;
    uint64_t v12 = *(void **)(a1 + 304);
  }
  uint64_t v16 = v12[7];
  if (v16)
  {
    mmcs_http_context_invalidate(v16);
    uint64_t v17 = *(void *)(a1 + 304);
    CFStringRef v18 = *(const void **)(v17 + 56);
    if (v18)
    {
      C3BaseRelease(v18);
      uint64_t v17 = *(void *)(a1 + 304);
    }
    *(void *)(v17 + 56) = 0;
    uint64_t v12 = *(void **)(a1 + 304);
  }
  uint64_t v19 = (const void *)v12[11];
  if (v19)
  {
    CFRelease(v19);
    uint64_t v12 = *(void **)(a1 + 304);
  }
  v12[11] = 0;
}

uint64_t mmcs_update_request_stop_with_error(uint64_t a1, CFErrorRef error)
{
  if (*(unsigned char *)(a1 + 144)) {
    return 0;
  }
  C3BaseRetain((CFTypeRef)a1);
  *(unsigned char *)(a1 + 144) = 1;
  if (error)
  {
    CFErrorRef v5 = 0;
  }
  else
  {
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 4, @"Update request was cancelled.");
    CFErrorRef v5 = error;
  }
  CFRetain(error);
  *(void *)(a1 + 152) = error;
  mmcs_http_context_should_cancel(*(unsigned char **)(*(void *)(a1 + 304) + 48), error);
  mmcs_http_context_should_cancel(*(unsigned char **)(*(void *)(a1 + 304) + 56), *(__CFError **)(a1 + 152));
  if (v5) {
    CFRelease(v5);
  }
  C3BaseRelease((CFTypeRef)a1);
  return 1;
}

void mmcs_update_items(uint64_t a1, const void *a2, const char *a3, uint64_t a4, void *a5, void (*a6)(uint64_t, CFDictionaryRef))
{
  uint64_t v12 = _os_activity_create(&dword_1DC1CA000, "mmcs-update-items", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v12, &state);
  CFErrorRef v68 = 0;
  v67[0] = 0;
  if (!mmcs_request_allocate((uint64_t *)v67, 4, 96) || (CFStringRef v18 = (void **)v67[0]) == 0)
  {
    uint64_t v30 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 36, @"Cannot allocate update request", v13, v14, v15, v16, v17, v60);
    CFErrorRef v68 = v30;
    if (v30)
    {
      mmcs_update_request_abort(a4, v30, a6);
      goto LABEL_41;
    }
    goto LABEL_61;
  }
  if (!_mmcs_request_init((uint64_t)v67[0], a1, a4, a5, a2, a3, v12, &v68))
  {
    CFStringRef v29 = @"Cannot initialize update request";
    CFIndex v58 = 37;
LABEL_37:
    CFStringRef v59 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v58, v29, v19, v20, v21, v22, v23, v60);
    CFErrorRef v68 = v59;
LABEL_38:
    if (v59)
    {
      mmcs_update_request_abort(a4, v59, a6);
      goto LABEL_40;
    }
LABEL_61:
    mmcs_update_items_cold_1();
  }
  *v18[38] = mmcs_get_cfBOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a5, @"kMMCSRequestOptionReturnOpaqueCloneContext", 0);
  v18[38][1] = a6;
  CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  v18[38][2] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &_update_items_array_callbacks);
  uint64_t v25 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  v18[38][3] = CFDictionaryCreateMutable(v24, 0, &_update_items_unwrap_dictionary_key_callbacks, MEMORY[0x1E4F1D540]);
  v18[38][4] = CFDictionaryCreateMutable(v24, 0, &_update_items_wrap_dictionary_key_callbacks, v25);
  *((unsigned char *)v18[38] + 73) = mmcs_get_BOOLean_from_cfdictionary_object_for_key((const __CFDictionary *)a5, @"kMMCSRequestOptionReturnPreauthorizationRequestObject", 0);
  uint64_t v26 = CFDictionaryGetValue((CFDictionaryRef)a5, @"kMMCSRequestOptionPreauthorization");
  if (v26 && (v27 = v26, CFTypeID TypeID = CFDataGetTypeID(), TypeID == CFGetTypeID(v27)))
  {
    v18[38][10] = v27;
    if (*((unsigned char *)v18[38] + 73))
    {
      CFStringRef v29 = @"Cannot use kMMCSRequestOptionPreauthorization and kMMCSRequestOptionReturnPreauthorizationRequestObject together";
LABEL_36:
      CFIndex v58 = 40;
      goto LABEL_37;
    }
    int v31 = 0;
  }
  else
  {
    int v31 = 1;
  }
  uint64_t v32 = CFDictionaryGetValue((CFDictionaryRef)a5, @"kMMCSRequestOptionItemOptions");
  if (!v32 || (SInt32 v33 = v32, v34 = CFArrayGetTypeID(), v34 != CFGetTypeID(v33)))
  {
    char v60 = (char)a5;
    CFStringRef v29 = @"expected item options array in request options %@";
    goto LABEL_36;
  }
  v18[28] = (void *)voucher_copy();
  CFIndex Count = CFArrayGetCount((CFArrayRef)v33);
  if (!Count)
  {
    char v60 = (char)a5;
    CFStringRef v29 = @"did not expect empty item options array in request options %@";
    goto LABEL_36;
  }
  uint64_t v61 = a1;
  if (Count >= 1)
  {
    CFIndex v36 = 0;
    int v64 = v31;
    CFIndex v62 = Count;
    uint64_t v63 = v33;
    while (1)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v33, v36);
      CFTypeID v38 = CFGetTypeID(ValueAtIndex);
      if (v38 != CFDictionaryGetTypeID())
      {
        char v60 = (char)ValueAtIndex;
        CFStringRef v29 = @"expected item option to be a dictionary %@";
        goto LABEL_36;
      }
      CFDataRef v39 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"kMMCSSignature");
      if (!v39 || (CFDataRef v40 = v39, v41 = CFGetTypeID(v39), v41 != CFDataGetTypeID()))
      {
        char v60 = (char)ValueAtIndex;
        CFStringRef v29 = @"expected item option dictionary to include a signature. Got: %@";
        goto LABEL_36;
      }
      CFStringRef v42 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"kMMCSAuthorizationToken");
      if (!v42 || (v43 = v42, CFTypeID v44 = CFGetTypeID(v42), v44 != CFStringGetTypeID()))
      {
        char v60 = (char)ValueAtIndex;
        CFStringRef v29 = @"expected item option dictionary to include an authToken. Got: %@";
        goto LABEL_36;
      }
      uint64_t v45 = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"kMMCSMIMEType");
      uint64_t v46 = v45;
      if (v45)
      {
        CFIndex v47 = v36;
        CFTypeID v48 = CFGetTypeID(v45);
        BOOL v49 = v48 == CFStringGetTypeID();
        CFIndex v36 = v47;
        if (!v49)
        {
          char v60 = (char)ValueAtIndex;
          CFStringRef v29 = @"expected item option dictionary MIMEType to be a string. Got: %@";
          goto LABEL_36;
        }
      }
      v67[0] = 0;
      v67[1] = 0;
      v66[0] = 0;
      v66[1] = 0;
      if (!mmcs_wrapping_state_init_with_option_dict((uint64_t)v67, (CFDictionaryRef)ValueAtIndex, @"kMMCSWrappingState", (uint64_t)&v68))break; {
      if (!mmcs_wrapping_state_init_with_option_dict((uint64_t)v66, (CFDictionaryRef)ValueAtIndex, @"kMMCSUnwrappingState", (uint64_t)&v68))
      }
      {
        if (!v68) {
          CFErrorRef v68 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"expected specific error for kMMCSWrappingState", v50, v51, v52, v53, v54, v60);
        }
        mmcs_wrapping_state_set_reference_signature_and_object((uint64_t)v67, 0, 0);
        CFStringRef v59 = v68;
        goto LABEL_38;
      }
      CFStringRef value = 0;
      int v55 = mmcs_update_item_create((uint64_t *)&value, v40, v43, v66, v67);
      mmcs_wrapping_state_set_reference_signature_and_object((uint64_t)v67, 0, 0);
      mmcs_wrapping_state_set_reference_signature_and_object((uint64_t)v66, 0, 0);
      if (!v55)
      {
        CFStringRef v29 = @"mmcs_update_item_create";
        goto LABEL_60;
      }
      mmcs_update_item_set_MIME_type((uint64_t)value, v46);
      CFArrayAppendValue((CFMutableArrayRef)v18[38][2], value);
      LOBYTE(v31) = v64;
      uint64_t v56 = 4;
      if (v64) {
        uint64_t v56 = 3;
      }
      XCFDictionaryAppendValue((const __CFDictionary *)v18[38][v56], &_update_items_array_callbacks, value, value);
      if (value) {
        C3BaseRelease(value);
      }
      ++v36;
      SInt32 v33 = v63;
      if (v62 == v36) {
        goto LABEL_32;
      }
    }
    CFStringRef v59 = v68;
    if (v68) {
      goto LABEL_38;
    }
    CFStringRef v29 = @"expected specific error for kMMCSWrappingState";
LABEL_60:
    CFIndex v58 = 1;
    goto LABEL_37;
  }
LABEL_32:
  CFStringRef v57 = v18[38];
  if ((v31 & 1) == 0)
  {
    v18[38][5] = XCFDictionaryCopyKeys((const __CFDictionary *)v57[4], &_update_items_array_callbacks);
    if (CFArrayGetCount((CFArrayRef)v18[38][5]))
    {
      *((unsigned char *)v18[38] + 72) = 1;
      mmcs_engine_add_request(v61, v18);
      mmcs_update_request_process_authorize_put_response((uint64_t)v18, (CFDataRef)v18[38][10]);
      goto LABEL_40;
    }
    CFStringRef v29 = @"There were no distinct items from the putChunkKeys response";
    goto LABEL_60;
  }
  *((unsigned char *)v57 + 72) = 1;
  mmcs_engine_add_request(v61, v18);
  mmcs_update_items_send_get_chunk_keys((uint64_t)v18);
LABEL_40:
  C3BaseRelease(v18);
LABEL_41:
  if (v68) {
    CFRelease(v68);
  }
  if (v12) {
    os_release(v12);
  }
  os_activity_scope_leave(&state);
}

void mmcs_update_request_process_authorize_put_response(uint64_t a1, CFDataRef theData)
{
  CFIndex Length = CFDataGetLength(theData);
  BytePtr = (char *)CFDataGetBytePtr(theData);
  uint64_t v6 = chunkserver__storage_container_chunk_lists__unpack(0, Length, BytePtr);
  if (v6)
  {
    uint64_t v12 = (void **)v6;
    mmcs_update_request_process_put_file_success_and_error(a1, 0, v6[8], v6[9], v6[5], v6[6]);
    chunkserver__storage_container_chunk_lists__free_unpacked(v12, 0);
  }
  else
  {
    CFErrorRef v13 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Authorize Put Response could not be deserialized", v7, v8, v9, v10, v11, v15);
    if (!v13) {
      mmcs_update_request_process_authorize_put_response_cold_1();
    }
    CFErrorRef v14 = v13;
    mmcs_update_request_set_error(a1, v13);
    mmcs_update_request_cleanup(a1);
    CFRelease(v14);
  }
}

void mmcs_update_items_send_get_chunk_keys(uint64_t a1)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFURLRef v4 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFURLRef *)(a1 + 160), @"getChunkKeys", 0);
  if (!v4)
  {
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, @"Failed to create getChunkKeys request url");
    CFErrorRef v13 = 0;
    CStringWithCFCFStringRef String = 0;
    char v15 = 0;
    CFDataRef data = 0;
    if (error) {
      goto LABEL_48;
    }
    goto LABEL_69;
  }
  uint64_t v5 = *(void *)(a1 + 304);
  uint64_t v6 = *(const void **)(v5 + 40);
  if (v6)
  {
    CFRelease(v6);
    uint64_t v5 = *(void *)(a1 + 304);
  }
  *(void *)(*(void *)(a1 + 304) + 40) = XCFDictionaryCopyKeys(*(const __CFDictionary **)(v5 + 24), &_update_items_array_callbacks);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 40));
  uint64_t v8 = chunkserver__get_chunk_keys_request__create(Count);
  if (v8)
  {
    uint64_t v9 = v8;
    CFArrayRef v10 = *(const __CFArray **)(*(void *)(a1 + 304) + 40);
    v68.unsigned int length = CFArrayGetCount(v10);
    v68.CFIndex location = 0;
    CFArrayApplyFunction(v10, v68, (CFArrayApplierFunction)_add_items, v9);
    CFDataRef data = 0;
    if (Count == *((void *)v9 + 3))
    {
      if (**(void **)(a1 + 304))
      {
        *((_DWORD *)v9 + 10) = 1;
        *((_DWORD *)v9 + 11) = CFBooleanGetValue(**(CFBooleanRef **)(a1 + 304));
      }
      CFDataRef data = chunkserver__get_chunk_keys_request__create_data((void **)v9);
    }
    chunkserver__get_chunk_keys_request__free_unpacked((void **)v9, 0);
  }
  else
  {
    CFDataRef data = 0;
  }
  CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 40), 0);
  CFStringRef v17 = (const __CFString *)v2[8];
  CFStringRef v18 = (const __CFString *)v2[10];
  CFStringRef dataclass = (const __CFString *)mmcs_request_get_dataclass(a1);
  http_protobuf_message = create_http_protobuf_message(v17, v18, dataclass, *(const __CFString **)(a1 + 168), *(const __CFString **)(a1 + 176), v4, data);
  if (!http_protobuf_message)
  {
    uint64_t v23 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v24 = CFStringCreateWithFormat(v3, 0, @"unable to create getChunkKeys msg");
      uint64_t v25 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v66 = v24;
        _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v24) {
        CFRelease(v24);
      }
    }
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, @"Failed to create getChunkKeys msg");
    CFErrorRef v13 = 0;
    CStringWithCFCFStringRef String = 0;
    char v15 = 0;
    if (error) {
      goto LABEL_48;
    }
LABEL_69:
    mmcs_update_items_send_get_chunk_keys_cold_1();
  }
  char v15 = http_protobuf_message;
  mmcs_request_insert_headers(a1, http_protobuf_message);
  BytePtr = CFDataGetBytePtr(*((CFDataRef *)ValueAtIndex + 2));
  CFErrorRef v13 = (char *)mmcs_file_signature_copy(BytePtr);
  CStringWithCFCFStringRef String = createCStringWithCFString(*((const __CFString **)ValueAtIndex + 3));
  if (!mmcs_http_msg_add_auth_header(v15, v13, *((char **)ValueAtIndex + 8), (const char *)CStringWithCFString, 0, 0))
  {
    uint64_t v26 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v32 = CFStringCreateWithFormat(v3, 0, @"unable to add getChunkKeys token header");
      SInt32 v33 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v66 = v32;
        _os_log_impl(&dword_1DC1CA000, v33, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v32) {
        CFRelease(v32);
      }
    }
    CFStringRef v34 = @"Failed to add getChunkKeys token header";
LABEL_30:
    CFIndex v35 = 1;
    goto LABEL_47;
  }
  uint64_t v62 = 0;
  v50[0] = @"getChunkKeys";
  v50[1] = v15;
  v50[2] = *(void *)(a1 + 56);
  v50[3] = *(void *)(a1 + 96);
  if (mmcs_request_is_background(a1)) {
    uint64_t v22 = *(void *)(a1 + 104);
  }
  else {
    uint64_t v22 = 0;
  }
  v50[4] = v22;
  long long v51 = xmmword_1DC251F50;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  uint64_t v54 = mmcs_update_request_will_retry_get_chunk_keys_after_error;
  int v55 = handle_response_get_chunk_keys;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v59 = a1;
  uint64_t sparse_block_size = mmcs_engine_get_sparse_block_size();
  uint64_t v61 = mmcs_engine_owner((uint64_t)v2);
  LOBYTE(v62) = 0;
  uint64_t v63 = 0;
  uint64_t request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  memset(v49, 0, sizeof(v49));
  mmcs_read_stream_pool_parameters_make_pool_timeout_max(v2[4], 100, (uint64_t)v49, 90.0);
  if (!mmcs_http_context_create((void *)(*(void *)(a1 + 304) + 48), *(_DWORD *)(a1 + 140), (uint64_t)v50))
  {
    CFTypeID v41 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v42 = CFStringCreateWithFormat(v3, 0, @"unable to create http context");
      CFStringRef v43 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v66 = v42;
        _os_log_impl(&dword_1DC1CA000, v43, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v42) {
        CFRelease(v42);
      }
    }
    CFTypeID v48 = "mmcs_update_items_send_get_chunk_keys";
    CFStringRef v34 = @"Failed to create http context %s";
    CFIndex v35 = 37;
LABEL_47:
    CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", v35, v34, v27, v28, v29, v30, v31, (char)v48);
    if (!error) {
      goto LABEL_69;
    }
    goto LABEL_48;
  }
  mmcs_http_context_make_metrics(*(char **)(*(void *)(a1 + 304) + 48), @"getChunkKeys", 0, *(void *)(a1 + 56), 0);
  current_request_uint64_t metrics = (__CFArray *)mmcs_get_req_context_get_current_request_metrics(a1);
  uint64_t metrics = (void *)mmcs_http_context_get_metrics(*(void *)(*(void *)(a1 + 304) + 48));
  mmcs_metrics_request_add_http_info_for_transfer(current_request_metrics, metrics);
  if (!mmcs_http_context_send(*(void *)(*(void *)(a1 + 304) + 48), (uint64_t)v49, v2[7]))
  {
    CFTypeID v44 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v45 = CFStringCreateWithFormat(v3, 0, @"unable to send http msg");
      uint64_t v46 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v66 = v45;
        _os_log_impl(&dword_1DC1CA000, v46, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v45) {
        CFRelease(v45);
      }
    }
    uint64_t v47 = *(void *)(*(void *)(a1 + 304) + 48);
    if (v47 && mmcs_http_context_get_error(v47))
    {
      CFErrorRef error = (const void *)mmcs_http_context_get_error(*(void *)(*(void *)(a1 + 304) + 48));
      CFRetain(error);
      if (!error) {
        goto LABEL_69;
      }
LABEL_48:
      mmcs_update_request_set_error(a1, error);
      mmcs_update_request_cleanup(a1);
      if (!v4) {
        goto LABEL_50;
      }
      goto LABEL_49;
    }
    CFTypeID v48 = "mmcs_update_items_send_get_chunk_keys";
    CFStringRef v34 = @"Failed to send http msg %s";
    goto LABEL_30;
  }
  if (gMMCS_DebugLevel >= 4)
  {
    CFTypeID v38 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v39 = CFStringCreateWithFormat(v3, 0, @"sent mmcs_get_chunk_keys (%p) for update request: %p", *(void *)(*(void *)(a1 + 304) + 48), a1);
      CFDataRef v40 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v66 = v39;
        _os_log_impl(&dword_1DC1CA000, v40, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v39) {
        CFRelease(v39);
      }
    }
  }
  CFErrorRef error = 0;
LABEL_49:
  CFRelease(v4);
LABEL_50:
  if (v15) {
    CFRelease(v15);
  }
  if (data) {
    CFRelease(data);
  }
  if (v13) {
    free(v13);
  }
  if (CStringWithCFString) {
    free(CStringWithCFString);
  }
  if (error) {
    CFRelease(error);
  }
}

void mmcs_update_request_process_put_file_success_and_error(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  CFErrorRef v61 = 0;
  CFTypeRef v59 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v57 = 0;
  CFTypeRef v58 = 0;
  CFTypeRef v56 = 0;
  if (a3)
  {
    uint64_t v11 = 0;
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      uint64_t v12 = *(void *)(a4 + 8 * v11);
      if (!chunkserver__file_success__parse_and_validate(v12, (CFDataRef *)&cf, (CFDataRef *)&v59, (CFStringRef *)&v58, (CFNumberRef *)&v57, &v61))goto LABEL_71; {
      uint64_t v54 = 0;
      }
      key = 0;
      CFTypeRef context = v59;
      if (!mmcs_update_item_create((uint64_t *)&key, (const __CFData *)cf, @"fake", 0, &context))
      {
LABEL_72:
        CFStringRef v47 = @"mmcs_update_item_create";
        CFIndex v48 = 37;
        goto LABEL_73;
      }
      ArrayCFNumberRef Value = (const __CFArray *)XCFDictionaryGetArrayValue(*(CFDictionaryRef *)(*(void *)(a1 + 304) + 32), key);
      if (key) {
        C3BaseRelease(key);
      }
      key = 0;
      if (!ArrayValue)
      {
        uint64_t v23 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          char v50 = (char)cf;
          CFStringRef v24 = CFStringCreateWithFormat(alloc, 0, @"The server replied with FileSuccess signature %@ reference %@ which was not requested");
          uint64_t v25 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v63 = v24;
            _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v24) {
            CFRelease(v24);
          }
        }
        goto LABEL_29;
      }
      int v19 = *(_DWORD *)(v12 + 40);
      if (a2)
      {
        if (v19 != 1)
        {
          uint64_t v20 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            char v50 = (char)cf;
            CFStringRef v21 = CFStringCreateWithFormat(alloc, 0, @"FileSuccess signature %@ reference %@ with unexpected success code %d");
            uint64_t v22 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
LABEL_21:
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v63 = v21;
              _os_log_impl(&dword_1DC1CA000, v22, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
            }
LABEL_22:
            if (v21) {
              CFRelease(v21);
            }
          }
        }
      }
      else if ((v19 - 3) >= 3)
      {
        uint64_t v26 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          char v50 = (char)cf;
          CFStringRef v21 = CFStringCreateWithFormat(alloc, 0, @"FileSuccess signature %@ reference %@ with unexpected success code %d");
          uint64_t v22 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_21;
          }
          goto LABEL_22;
        }
      }
      CFIndex Count = CFArrayGetCount(ArrayValue);
      if (Count >= 1)
      {
        CFIndex v28 = Count;
        for (CFIndex i = 0; i != v28; ++i)
        {
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(ArrayValue, i);
          if (!ValueAtIndex[5]) {
            mmcs_update_item_set_put_receipt_if_not_already_done((uint64_t)ValueAtIndex, v58, v57);
          }
        }
      }
LABEL_29:
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = 0;
      if (v59) {
        CFRelease(v59);
      }
      CFTypeRef v59 = 0;
      if (v58) {
        CFRelease(v58);
      }
      CFTypeRef v58 = 0;
      if (v57) {
        CFRelease(v57);
      }
      CFTypeRef v57 = 0;
      if (v61) {
        mmcs_update_request_process_put_file_success_and_error_cold_3();
      }
      ++v11;
    }
    while (v11 != a3);
  }
  if (a5)
  {
    uint64_t v31 = 0;
    CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (chunkserver__file_error__parse_and_validate(*(void *)(a6 + 8 * v31), (CFDataRef *)&cf, (CFDataRef *)&v59, (CFErrorRef *)&v56, &v61, 33, @"The server returned an error for this item"))
    {
      uint64_t v54 = 0;
      key = 0;
      CFTypeRef context = v59;
      if (!mmcs_update_item_create((uint64_t *)&key, (const __CFData *)cf, @"fake", 0, &context)) {
        goto LABEL_72;
      }
      CFArrayRef v33 = (const __CFArray *)XCFDictionaryGetArrayValue(*(CFDictionaryRef *)(*(void *)(a1 + 304) + 32), key);
      if (key) {
        C3BaseRelease(key);
      }
      key = 0;
      if (v33)
      {
        CFIndex v34 = CFArrayGetCount(v33);
        if (v34 >= 1)
        {
          CFIndex v35 = v34;
          for (CFIndex j = 0; j != v35; ++j)
          {
            uint64_t v37 = CFArrayGetValueAtIndex(v33, j);
            if (!v37[5]) {
              mmcs_update_item_set_error_if_not_already_done((uint64_t)v37, v56);
            }
          }
        }
      }
      else
      {
        CFTypeID v38 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          char v50 = (char)cf;
          CFStringRef v39 = CFStringCreateWithFormat(v32, 0, @"The server replied with FileError signature %@ reference %@ which was not requested");
          CFDataRef v40 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v63 = v39;
            _os_log_impl(&dword_1DC1CA000, v40, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v39) {
            CFRelease(v39);
          }
        }
      }
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = 0;
      if (v59) {
        CFRelease(v59);
      }
      CFTypeRef v59 = 0;
      if (v56) {
        CFRelease(v56);
      }
      CFTypeRef v56 = 0;
      if (v61) {
        mmcs_update_request_process_put_file_success_and_error_cold_2();
      }
      if (++v31 == a5) {
        goto LABEL_65;
      }
    }
LABEL_71:
    BOOL v49 = v61;
  }
  else
  {
LABEL_65:
    LOBYTE(CFSetApplyFunction(theSet, (CFSetApplierFunction)XCFSetRemoveValuesFromSetApplier, context) = 1;
    CFIndex v41 = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 304) + 40));
    if (v41 < 1) {
      goto LABEL_69;
    }
    CFIndex v42 = v41;
    for (CFIndex k = 0; k != v42; ++k)
    {
      CFTypeID v44 = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 40), k);
      CFArrayRef v45 = (const __CFArray *)XCFDictionaryGetArrayValue(*(CFDictionaryRef *)(*(void *)(a1 + 304) + 32), v44);
      v65.unsigned int length = CFArrayGetCount(v45);
      v65.CFIndex location = 0;
      CFArrayApplyFunction(v45, v65, (CFArrayApplierFunction)_is_done, &context);
    }
    if ((_BYTE)context)
    {
LABEL_69:
      LOBYTE(CFSetApplyFunction(theSet, (CFSetApplierFunction)XCFSetRemoveValuesFromSetApplier, context) = 1;
      CFArrayRef v46 = *(const __CFArray **)(*(void *)(a1 + 304) + 16);
      v66.unsigned int length = CFArrayGetCount(v46);
      v66.CFIndex location = 0;
      CFArrayApplyFunction(v46, v66, (CFArrayApplierFunction)_set_error, &context);
      if ((_BYTE)context) {
        goto LABEL_76;
      }
      CFStringRef v47 = @"All items should have been handled";
      CFIndex v48 = 1;
    }
    else
    {
      CFStringRef v47 = @"The server failed to respond for all items in putChunkKeys";
      CFIndex v48 = 6;
    }
LABEL_73:
    BOOL v49 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v48, v47, v13, v14, v15, v16, v17, v50);
    CFErrorRef v61 = v49;
  }
  if (!v49) {
    mmcs_update_request_process_put_file_success_and_error_cold_1();
  }
  mmcs_update_request_set_error(a1, v49);
LABEL_76:
  mmcs_update_request_cleanup(a1);
  if (cf) {
    CFRelease(cf);
  }
  if (v59) {
    CFRelease(v59);
  }
  if (v56) {
    CFRelease(v56);
  }
  if (v58) {
    CFRelease(v58);
  }
  if (v57) {
    CFRelease(v57);
  }
  if (v61) {
    CFRelease(v61);
  }
}

void mmcs_update_request_set_error(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(*(void *)(a1 + 304) + 64);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(*(void *)(a1 + 304) + 64) = cf;
  }
}

uint64_t mmcs_update_request_cleanup(uint64_t a1)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(*(void *)(a1 + 304) + 72) = 0;
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  uint64_t request_activity_marker = mmcs_request_get_request_activity_marker(a1);
  os_activity_scope_enter(request_activity_marker, &state);
  CFTypeRef v3 = mmcs_logging_logger_summary();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
  uint64_t v5 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
  if (v4)
  {
    CFStringRef v6 = mmcs_request_copy_description(a1);
    CFAllocatorRef v7 = *v5;
    CFMutableStringRef Mutable = CFStringCreateMutable(v7, 0);
    CFStringAppend(Mutable, @"(");
    CFArrayRef v9 = *(const __CFArray **)(*(void *)(a1 + 304) + 16);
    if (v9)
    {
      CFIndex Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        CFIndex v11 = Count;
        for (CFIndex i = 0; i != v11; ++i)
        {
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 304) + 16), i);
          CFStringRef updated = mmcs_update_item_copy_short_description((uint64_t)ValueAtIndex);
          if (i) {
            CFStringAppend(Mutable, @", ");
          }
          CFStringAppend(Mutable, updated);
          if (updated) {
            CFRelease(updated);
          }
        }
      }
    }
    CFStringAppend(Mutable, @""));
    LOBYTE(v63) = (_BYTE)v6;
    CFStringRef v15 = CFStringCreateWithFormat(v7, 0, @"%@ %@");
    if (v6) {
      CFRelease(v6);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    uint64_t v16 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v63 = *(void *)(a1 + 32);
      CFStringRef v17 = CFStringCreateWithFormat(v7, 0, @"Engine %p completed request %@");
      CFStringRef v18 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v17;
        _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v17) {
        CFRelease(v17);
      }
    }
    if (v15) {
      CFRelease(v15);
    }
    if (*(void *)(*(void *)(a1 + 304) + 48))
    {
      int v19 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        LOBYTE(v63) = COERCE_UNSIGNED_INT64(mmcs_http_context_elapsed_seconds(*(void *)(*(void *)(a1 + 304) + 48)));
        CFStringRef v20 = CFStringCreateWithFormat(v7, 0, @"\tgetChunkKeys:     \t%0.4lf sec.");
        CFStringRef v21 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v20;
          _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v20) {
          CFRelease(v20);
        }
      }
      uint64_t v22 = (__CFError *)mmcs_http_context_copy_error(*(void *)(*(void *)(a1 + 304) + 48));
      if (v22)
      {
        uint64_t v23 = v22;
        CFStringRef v24 = mmcs_cferror_copy_description(v22);
        uint64_t v25 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          LOBYTE(v63) = (_BYTE)v24;
          CFStringRef v26 = CFStringCreateWithFormat(v7, 0, @"\terror:     \t%@");
          uint64_t v27 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v26;
            _os_log_impl(&dword_1DC1CA000, v27, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v26) {
            CFRelease(v26);
          }
        }
        if (v24) {
          CFRelease(v24);
        }
        CFRelease(v23);
      }
    }
    if (*(void *)(*(void *)(a1 + 304) + 56))
    {
      CFIndex v28 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        LOBYTE(v63) = COERCE_UNSIGNED_INT64(mmcs_http_context_elapsed_seconds(*(void *)(*(void *)(a1 + 304) + 56)));
        CFStringRef v29 = CFStringCreateWithFormat(v7, 0, @"\tputChunkKeys:     \t%0.4lf sec.");
        uint64_t v30 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v29;
          _os_log_impl(&dword_1DC1CA000, v30, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v29) {
          CFRelease(v29);
        }
      }
      uint64_t v31 = (__CFError *)mmcs_http_context_copy_error(*(void *)(*(void *)(a1 + 304) + 56));
      if (v31)
      {
        CFAllocatorRef v32 = v31;
        CFArrayRef v33 = mmcs_cferror_copy_description(v31);
        CFIndex v34 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        {
          LOBYTE(v63) = (_BYTE)v33;
          CFStringRef v35 = CFStringCreateWithFormat(v7, 0, @"\terror:     \t%@");
          CFIndex v36 = mmcs_logging_logger_summary();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v35;
            _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v35) {
            CFRelease(v35);
          }
        }
        if (v33) {
          CFRelease(v33);
        }
        CFRelease(v32);
      }
    }
  }
  else
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  }
  uint64_t v37 = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFTypeID v38 = v37;
  CFStringRef v39 = *(const void **)(*(void *)(a1 + 304) + 64);
  if (v39) {
    goto LABEL_55;
  }
  if (*(unsigned char *)(a1 + 144))
  {
    CFStringRef v39 = *(const void **)(a1 + 152);
    if (!v39) {
      mmcs_update_request_cleanup_cold_1();
    }
LABEL_55:
    CFDictionarySetValue(v37, @"kMMCSResultError", v39);
    goto LABEL_56;
  }
  CFMutableArrayRef v54 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
  *(void *)long long buf = a1;
  *(void *)&uint8_t buf[8] = v54;
  CFArrayRef v55 = *(const __CFArray **)(*(void *)(a1 + 304) + 16);
  v67.unsigned int length = CFArrayGetCount(v55);
  v67.CFIndex location = 0;
  CFArrayApplyFunction(v55, v67, (CFArrayApplierFunction)_add_item_result_0, buf);
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  CFDictionarySetValue(v38, @"kMMCSRequestOptionItemOptions", v54);
  if (v54) {
    CFRelease(v54);
  }
  if (*(unsigned char *)(*(void *)(a1 + 304) + 73))
  {
    CFDataRef AuthorizePutRequestBody = mmcs_update_request_create_AuthorizePutRequestBody(a1);
    if (AuthorizePutRequestBody)
    {
      CFErrorRef v62 = AuthorizePutRequestBody;
      CFDictionarySetValue(v38, @"kMMCSRequestOptionReturnPreauthorizationRequestObject", AuthorizePutRequestBody);
    }
    else
    {
      CFErrorRef v62 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"mmcs_update_request_create_AuthorizePutRequestBody returned NULL", v57, v58, v59, v60, v61, v63);
      CFDictionarySetValue(v38, @"kMMCSResultError", v62);
      if (!v62) {
        goto LABEL_56;
      }
    }
    CFRelease(v62);
  }
LABEL_56:
  if (*(_DWORD *)(a1 + 16) != 4)
  {
    CFStringRef v47 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      goto LABEL_74;
    }
    CFIndex v41 = (__CFArray *)CFStringCreateWithFormat(v7, 0, @"got a mmcs_update_request whose request class is not mmcs_request_class_update");
    CFIndex v48 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v41;
LABEL_71:
      _os_log_impl(&dword_1DC1CA000, v48, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    }
LABEL_72:
    if (!v41) {
      goto LABEL_74;
    }
    goto LABEL_73;
  }
  CFMutableArrayRef v40 = CFArrayCreateMutable(v7, 0, &httpInfoArrayCallbacks);
  if (!v40)
  {
    BOOL v49 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
      goto LABEL_74;
    }
    CFIndex v41 = (__CFArray *)CFStringCreateWithFormat(v7, 0, @"could not create metrics array for update");
    CFIndex v48 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v41;
      goto LABEL_71;
    }
    goto LABEL_72;
  }
  CFIndex v41 = v40;
  uint64_t v42 = *(void *)(a1 + 304);
  uint64_t v43 = *(void *)(v42 + 48);
  if (v43)
  {
    uint64_t metrics = (const void *)mmcs_http_context_get_metrics(v43);
    if (metrics) {
      CFArrayAppendValue(v41, metrics);
    }
  }
  uint64_t v45 = *(void *)(v42 + 56);
  if (v45)
  {
    CFArrayRef v46 = (const void *)mmcs_http_context_get_metrics(v45);
    if (v46) {
      CFArrayAppendValue(v41, v46);
    }
  }
  CFDictionarySetValue(v38, @"kMMCSRequestOptionMMCSMetrics", v41);
LABEL_73:
  CFRelease(v41);
LABEL_74:
  CFStringRef v50 = mmcs_request_copy_description(a1);
  long long v51 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
  {
    uint64_t v52 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 134218242;
    *(void *)&uint8_t buf[4] = v52;
    *(_WORD *)&unsigned char buf[12] = 2114;
    *(void *)&buf[14] = v50;
    _os_log_impl(&dword_1DC1CA000, v51, OS_LOG_TYPE_INFO, "Engine %p request will notify request %{public}@ done", buf, 0x16u);
  }
  if (v50) {
    CFRelease(v50);
  }
  (*(void (**)(void, __CFDictionary *))(*(void *)(a1 + 304) + 8))(*(void *)(a1 + 40), v38);
  if (v38) {
    CFRelease(v38);
  }
  os_activity_scope_leave(&state);
  return mmcs_engine_remove_request(*(void *)(a1 + 32), (const void *)a1);
}

BOOL _is_done(BOOL result, unsigned char *a2)
{
  if (a2)
  {
    __n128 result = mmcs_update_item_is_done(result);
    *a2 &= result;
  }
  return result;
}

void _add_item_result_0(void *a1, CFMutableArrayRef *a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v6 = Mutable;
  CFAllocatorRef v7 = (const void *)a1[6];
  if (!*(unsigned char *)(*((void *)*a2 + 38) + 73))
  {
    if (!v7)
    {
      if (!a1[5]) {
        _add_item_result_cold_1_0();
      }
      goto LABEL_8;
    }
LABEL_5:
    CFDictionarySetValue(Mutable, @"kMMCSPutReceipt", v7);
    uint64_t v8 = (const void *)a1[7];
    if (!v8) {
      goto LABEL_12;
    }
    CFArrayRef v9 = @"kMMCSPutReceiptExpiry";
    goto LABEL_11;
  }
  if (v7) {
    goto LABEL_5;
  }
LABEL_8:
  CFArrayRef v10 = (__CFError *)a1[5];
  if (!v10) {
    goto LABEL_12;
  }
  CFErrorDomain Domain = CFErrorGetDomain(v10);
  if (!CFEqual(@"com.apple.mmcs", Domain)) {
    _add_item_result_cold_3_0();
  }
  CFArrayRef v9 = @"kMMCSResultError";
  uint64_t v8 = (const void *)a1[5];
LABEL_11:
  CFDictionarySetValue(v6, v9, v8);
LABEL_12:
  uint64_t v12 = (const void *)a1[2];
  if (!v12) {
    _add_item_result_cold_2_0();
  }
  CFDictionarySetValue(v6, @"kMMCSSignature", v12);
  wrapping_state_dictionary = mmcs_wrapping_state_create_wrapping_state_dictionary((uint64_t)(a1 + 10));
  if (wrapping_state_dictionary)
  {
    uint64_t v14 = wrapping_state_dictionary;
    CFDictionarySetValue(v6, @"kMMCSWrappingState", wrapping_state_dictionary);
    CFRelease(v14);
  }
  CFStringRef v15 = mmcs_wrapping_state_create_wrapping_state_dictionary((uint64_t)(a1 + 8));
  if (v15)
  {
    uint64_t v16 = v15;
    CFDictionarySetValue(v6, @"kMMCSUnwrappingState", v15);
    CFRelease(v16);
  }
  if (a1[16])
  {
    CFNumberRef v17 = CFNumberCreate(v4, kCFNumberSInt64Type, a1 + 16);
    CFDictionarySetValue(v6, @"kMMCSFileSize", v17);
    if (v17) {
      CFRelease(v17);
    }
  }
  uint64_t v19 = a1[15];
  CFStringRef v18 = a1 + 15;
  if (v19)
  {
    CFNumberRef v20 = CFNumberCreate(v4, kCFNumberSInt64Type, v18);
    CFDictionarySetValue(v6, @"kMMCSPaddedFileSize", v20);
    if (v20) {
      CFRelease(v20);
    }
  }
  CFArrayAppendValue(a2[1], v6);
  if (v6)
  {
    CFRelease(v6);
  }
}

void mmcs_update_request_will_retry_get_chunk_keys_after_error(uint64_t a1, uint64_t a2, __CFError *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    CFStringRef v6 = mmcs_request_copy_description(a2);
    CFAllocatorRef v7 = mmcs_cferror_copy_description(a3);
    uint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ retry get chunk keys after error %@", v6, v7);
      CFArrayRef v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v12 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v6) {
      CFRelease(v6);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
}

void handle_response_get_chunk_keys(uint64_t a1, CFDataRef *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v184 = *MEMORY[0x1E4F143B8];
  CFTypeRef v159 = 0;
  CFTypeRef context = 0;
  CFTypeRef v157 = 0;
  CFTypeRef cf = 0;
  uint64_t v6 = *(void *)(a3 + 304);
  CFAllocatorRef v7 = *(const void **)(v6 + 40);
  if (v7)
  {
    CFRelease(v7);
    uint64_t v6 = *(void *)(v3 + 304);
  }
  *(void *)(v6 + 40) = 0;
  BOOL v8 = mmcs_http_context_status_succeeded(a1);
  if (!a2 || !v8 || !*a2)
  {
    BOOL has_http_status = mmcs_http_context_has_http_status(a1);
    unint64_t v76 = mmcs_logging_logger_default();
    if (has_http_status)
    {
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v77 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v78 = mmcs_http_context_http_status(a1);
        CFStringRef v79 = CFStringCreateWithFormat(v77, 0, @"getChunkKeys (%p) HTTP status: %d", a1, v78);
        uint64_t v80 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_92;
        }
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v79;
        uint64_t v81 = v80;
        os_log_type_t v82 = OS_LOG_TYPE_DEBUG;
        goto LABEL_91;
      }
    }
    else if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v79 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"getChunkKeys (%p) has no http status!", a1);
      uint64_t v83 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_92;
      }
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v79;
      uint64_t v81 = v83;
      os_log_type_t v82 = OS_LOG_TYPE_DEFAULT;
LABEL_91:
      _os_log_impl(&dword_1DC1CA000, v81, v82, "%{public}@", (uint8_t *)&buf, 0xCu);
LABEL_92:
      if (v79) {
        CFRelease(v79);
      }
    }
    uint64_t v84 = mmcs_http_context_copy_error(a1);
    CFMutableArrayRef v54 = 0;
    CFMutableSetRef Mutable = 0;
    CFStringRef v47 = 0;
    CFArrayRef v46 = 0;
    chunk_keys_response__unpacCFIndex k = 0;
LABEL_95:
    CFTypeRef v159 = v84;
    int v85 = 1;
    goto LABEL_96;
  }
  mmcs_http_context_validate_request_uuid_with_response(a1);
  CFIndex Length = CFDataGetLength(*a2);
  BytePtr = (char *)CFDataGetBytePtr(*a2);
  chunk_keys_response__unpacCFIndex k = chunkserver__get_chunk_keys_response__unpack(0, Length, BytePtr);
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = 0;
  if (!chunk_keys_response__unpack)
  {
    CFArrayRef v46 = 0;
    CFStringRef v47 = 0;
    CFMutableSetRef Mutable = 0;
    CFMutableArrayRef v54 = 0;
    CFTypeRef v159 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"The getChunkKeys server response could not be deserialized", v11, v12, v13, v14, v15, (char)v146);
    LOBYTE(v85) = 1;
LABEL_97:
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = 0;
    if (v85) {
      goto LABEL_100;
    }
    goto LABEL_101;
  }
  if (*((_DWORD *)chunk_keys_response__unpack + 14))
  {
    CFDataRef Data = ProtobufCBinaryData_CreateData((CFDataRef)(chunk_keys_response__unpack + 8));
    uint64_t v18 = *(void *)(v3 + 304);
    CFDataRef v19 = *(CFDataRef *)(v18 + 88);
    if (v19 != Data)
    {
      if (v19)
      {
        CFRelease(v19);
        uint64_t v18 = *(void *)(v3 + 304);
      }
      *(void *)(v18 + 88) = 0;
      if (Data) {
        CFRetain(Data);
      }
      *(void *)(*(void *)(v3 + 304) + 88) = Data;
    }
    CFRelease(Data);
  }
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &_update_items_set_callbacks);
  XCFSetAddValuesFromArray(Mutable, *(CFArrayRef *)(*(void *)(v3 + 304) + 16));
  uint64_t v150 = a2;
  uint64_t v151 = v3;
  CFSetRef theSet = Mutable;
  if (!chunk_keys_response__unpack[3])
  {
LABEL_68:
    if (chunk_keys_response__unpack[5])
    {
      uint64_t v67 = 0;
      while (chunkserver__file_error__parse_and_validate(*(void *)(chunk_keys_response__unpack[6] + 8 * v67), (CFDataRef *)&cf, (CFDataRef *)&v157, (CFErrorRef *)&context, (CFErrorRef *)&v159, 33, @"The server returned an error for this item"))
      {
        key[0] = 0;
        long long buf = (unint64_t)v157;
        if (!mmcs_update_item_create((uint64_t *)key, (const __CFData *)cf, @"fake", (CFTypeRef *)&buf, 0))
        {
          CFStringRef v87 = @"mmcs_update_item_create";
          CFIndex v88 = 37;
LABEL_131:
          CFMutableArrayRef v54 = 0;
          CFStringRef v47 = 0;
          CFArrayRef v46 = 0;
          CFTypeRef v159 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v88, v87, v68, v69, v70, v71, v72, (char)v146);
          goto LABEL_132;
        }
        ArrayCFNumberRef Value = (const __CFArray *)XCFDictionaryGetArrayValue(*(CFDictionaryRef *)(*(void *)(v3 + 304) + 24), key[0]);
        if (key[0]) {
          C3BaseRelease(key[0]);
        }
        key[0] = 0;
        if (!ArrayValue)
        {
          CFStringRef v87 = @"The server returned a getChunkKeys response with a FileError containing unknown (signature, reference)";
          CFIndex v88 = 6;
          goto LABEL_131;
        }
        v185.unsigned int length = CFArrayGetCount(ArrayValue);
        v185.CFIndex location = 0;
        CFArrayApplyFunction(ArrayValue, v185, (CFArrayApplierFunction)_set_error, context);
        XCFSetRemoveValuesFromArray(theSet, ArrayValue);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = 0;
        if (v157) {
          CFRelease(v157);
        }
        CFTypeRef v157 = 0;
        if (context) {
          CFRelease(context);
        }
        CFTypeRef context = 0;
        if ((unint64_t)++v67 >= chunk_keys_response__unpack[5]) {
          goto LABEL_82;
        }
      }
      if (!v159) {
        handle_response_get_chunk_keys_cold_2();
      }
      CFMutableArrayRef v54 = 0;
      CFStringRef v47 = 0;
      CFArrayRef v46 = 0;
LABEL_132:
      int v85 = 1;
      CFMutableSetRef Mutable = theSet;
      goto LABEL_96;
    }
LABEL_82:
    CFMutableSetRef Mutable = theSet;
    if (CFSetGetCount(theSet))
    {
      CFStringRef v74 = @"There were (file signature, reference) tuples which were not mentioned in the getChunkKeys server response";
LABEL_135:
      uint64_t v84 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, v74, v26, v27, v28, v29, v30, (char)v146);
      CFMutableArrayRef v54 = 0;
      CFStringRef v47 = 0;
      CFArrayRef v46 = 0;
      goto LABEL_95;
    }
    uint64_t v86 = *(void *)(v3 + 304);
    if (*(unsigned char *)(v86 + 73))
    {
      mmcs_update_request_cleanup(v3);
LABEL_155:
      CFMutableArrayRef v54 = 0;
      CFStringRef v47 = 0;
      CFArrayRef v46 = 0;
      int v85 = 0;
      goto LABEL_96;
    }
    *(void *)(*(void *)(v3 + 304) + 40) = XCFDictionaryCopyKeys(*(const __CFDictionary **)(v86 + 32), &_update_items_array_callbacks);
    if (CFArrayGetCount(*(CFArrayRef *)(*(void *)(v3 + 304) + 40)) < 1)
    {
      int v85 = 1;
      CFMutableArrayRef v54 = 0;
      CFStringRef v47 = 0;
      CFArrayRef v46 = 0;
      CFTypeRef v159 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"There were no distinct items from the getChunkKeys response", v90, v91, v92, v93, v94, (char)v146);
      goto LABEL_96;
    }
    uint64_t v95 = *(uint64_t **)(v3 + 32);
    CFURLRef v96 = CFURLCreateCopyAppendingPathComponent(allocator, *(CFURLRef *)(v3 + 160), @"putChunkKeys", 0);
    if (v96)
    {
      CFURLRef v97 = v96;
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)(v3 + 304) + 40));
      uint64_t v99 = chunkserver__put_chunk_keys_request__create(Count);
      if (v99)
      {
        uint64_t v100 = v99;
        CFArrayRef v101 = *(const __CFArray **)(*(void *)(v3 + 304) + 40);
        v186.unsigned int length = CFArrayGetCount(v101);
        v186.CFIndex location = 0;
        CFArrayApplyFunction(v101, v186, (CFArrayApplierFunction)_add_put_item, v100);
        CFDataRef v102 = chunkserver__put_chunk_keys_request__create_data(v100);
        chunkserver__put_chunk_keys_request__free_unpacked(v100, 0);
        if (v102)
        {
          uint64_t v149 = chunk_keys_response__unpack;
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(v3 + 304) + 40), 0);
          uint64_t v104 = CFDataGetBytePtr(*((CFDataRef *)ValueAtIndex + 2));
          uint64_t v105 = v3;
          uint64_t v106 = mmcs_file_signature_copy(v104);
          CStringWithCFCFStringRef String = createCStringWithCFString(*((const __CFString **)ValueAtIndex + 3));
          CFStringRef v108 = (const __CFString *)v95[8];
          CFStringRef v109 = (const __CFString *)v95[10];
          CFStringRef dataclass = (const __CFString *)mmcs_request_get_dataclass(v105);
          http_protobuf_message = create_http_protobuf_message(v108, v109, dataclass, *(const __CFString **)(v105 + 168), *(const __CFString **)(v105 + 176), v97, v102);
          if (!http_protobuf_message)
          {
            uint64_t v115 = mmcs_logging_logger_default();
            chunk_keys_response__unpacCFIndex k = v149;
            a2 = v150;
            CFMutableSetRef Mutable = theSet;
            if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v116 = CFStringCreateWithFormat(allocator, 0, @"unable to create putChunkKeys msg");
              uint64_t v117 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
              {
                LODWORD(buf) = 138543362;
                *(void *)((char *)&buf + 4) = v116;
                _os_log_impl(&dword_1DC1CA000, v117, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
              }
              if (v116) {
                CFRelease(v116);
              }
            }
            CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, @"Failed to create putChunkKeys msg");
            int v118 = 0;
LABEL_200:
            CFRelease(v97);
            CFRelease(v102);
            if (v106) {
              free(v106);
            }
            if (CStringWithCFString) {
              free(CStringWithCFString);
            }
            uint64_t v3 = v151;
            if (v118)
            {
              if (!error) {
                goto LABEL_155;
              }
              goto LABEL_154;
            }
LABEL_152:
            if (!error) {
              handle_response_get_chunk_keys_cold_1();
            }
            mmcs_update_request_set_error(v3, error);
            mmcs_update_request_cleanup(v3);
LABEL_154:
            CFRelease(error);
            goto LABEL_155;
          }
          uint64_t v112 = http_protobuf_message;
          if (mmcs_http_msg_add_auth_header(http_protobuf_message, (char *)v106, *((char **)ValueAtIndex + 10), (const char *)CStringWithCFString, 0, 0))
          {
            mmcs_request_insert_headers(v151, v112);
            uint64_t v181 = 0;
            *(void *)&long long buf = @"putChunkKeys";
            *((void *)&buf + 1) = v112;
            uint64_t v166 = *(void *)(v151 + 56);
            uint64_t v167 = *(void *)(v151 + 96);
            CFMutableSetRef Mutable = theSet;
            if (mmcs_request_is_background(v151)) {
              uint64_t v113 = *(void *)(v151 + 104);
            }
            else {
              uint64_t v113 = 0;
            }
            uint64_t v168 = v113;
            uint64_t v169 = -1;
            uint64_t v170 = -1;
            uint64_t v171 = 0;
            uint64_t v172 = 0;
            unint64_t v173 = mmcs_update_request_will_retry_put_chunk_keys_after_error;
            uint64_t v174 = handle_response_put_chunk_keys;
            uint64_t v175 = 0;
            uint64_t v176 = 0;
            uint64_t v177 = 0;
            uint64_t v178 = v151;
            uint64_t sparse_block_size = mmcs_engine_get_sparse_block_size();
            uint64_t v180 = mmcs_engine_owner((uint64_t)v95);
            LOBYTE(v181) = 0;
            uint64_t v182 = 0;
            uint64_t request_activity_marker = mmcs_request_get_request_activity_marker(v151);
            *(_OWORD *)key = 0u;
            long long v162 = 0u;
            mmcs_read_stream_pool_parameters_make_pool_timeout_max(v95[4], 100, (uint64_t)key, 90.0);
            if (mmcs_http_context_create((void *)(*(void *)(v151 + 304) + 56), *(_DWORD *)(v151 + 140), (uint64_t)&buf))
            {
              mmcs_http_context_make_metrics(*(char **)(*(void *)(v151 + 304) + 56), @"putChunkKeys", 0, *(void *)(v151 + 56), 0);
              current_request_uint64_t metrics = (__CFArray *)mmcs_get_req_context_get_current_request_metrics(v151);
              uint64_t metrics = (void *)mmcs_http_context_get_metrics(*(void *)(*(void *)(v151 + 304) + 56));
              mmcs_metrics_request_add_http_info_for_transfer(current_request_metrics, metrics);
              if (!mmcs_http_context_send(*(void *)(*(void *)(v151 + 304) + 56), (uint64_t)key, v95[7]))
              {
                uint64_t v137 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
                {
                  CFStringRef v143 = CFStringCreateWithFormat(allocator, 0, @"unable to send http msg");
                  uint64_t v144 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long v163 = 138543362;
                    CFStringRef v164 = v143;
                    _os_log_impl(&dword_1DC1CA000, v144, OS_LOG_TYPE_ERROR, "%{public}@", v163, 0xCu);
                  }
                  if (v143) {
                    CFRelease(v143);
                  }
                }
                uint64_t v145 = *(void *)(*(void *)(v151 + 304) + 56);
                if (v145 && mmcs_http_context_get_error(v145))
                {
                  CFErrorRef error = (const void *)mmcs_http_context_get_error(*(void *)(*(void *)(v151 + 304) + 56));
                  CFRetain(error);
                }
                else
                {
                  CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 1, @"Failed to send http msg %s", v138, v139, v140, v141, v142, (char)"mmcs_update_items_send_put_chunk_keys");
                }
                int v118 = 0;
                goto LABEL_198;
              }
              if (gMMCS_DebugLevel >= 4)
              {
                char v131 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v131, OS_LOG_TYPE_DEBUG))
                {
                  CFStringRef v132 = CFStringCreateWithFormat(allocator, 0, @"sent mmcs_get_chunk_keys (%p) for update request: %p", *(void *)(*(void *)(v151 + 304) + 56), v151);
                  uint64_t v133 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)long long v163 = 138543362;
                    CFStringRef v164 = v132;
                    _os_log_impl(&dword_1DC1CA000, v133, OS_LOG_TYPE_DEBUG, "%{public}@", v163, 0xCu);
                  }
                  if (v132) {
                    CFRelease(v132);
                  }
                }
                CFErrorRef error = 0;
                int v118 = 1;
LABEL_198:
                a2 = v150;
                CFMutableSetRef Mutable = theSet;
                goto LABEL_199;
              }
              CFErrorRef error = 0;
              int v118 = 1;
              a2 = v150;
LABEL_199:
              CFRelease(v97);
              CFURLRef v97 = v112;
              chunk_keys_response__unpacCFIndex k = v149;
              goto LABEL_200;
            }
            uint64_t v134 = mmcs_logging_logger_default();
            a2 = v150;
            if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v135 = CFStringCreateWithFormat(allocator, 0, @"unable to create http context");
              uint64_t v136 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long v163 = 138543362;
                CFStringRef v164 = v135;
                _os_log_impl(&dword_1DC1CA000, v136, OS_LOG_TYPE_ERROR, "%{public}@", v163, 0xCu);
              }
              if (v135) {
                CFRelease(v135);
              }
            }
            uint64_t v146 = "mmcs_update_items_send_put_chunk_keys";
            CFStringRef v127 = @"Failed to create http context %s";
            CFIndex v128 = 37;
          }
          else
          {
            char v119 = mmcs_logging_logger_default();
            a2 = v150;
            CFMutableSetRef Mutable = theSet;
            if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v125 = CFStringCreateWithFormat(allocator, 0, @"unable to add putChunkKeys token header");
              CFStringRef v126 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v126, OS_LOG_TYPE_ERROR))
              {
                LODWORD(buf) = 138543362;
                *(void *)((char *)&buf + 4) = v125;
                _os_log_impl(&dword_1DC1CA000, v126, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
              }
              if (v125) {
                CFRelease(v125);
              }
            }
            CFStringRef v127 = @"Failed to add putChunkKeys token header";
            CFIndex v128 = 1;
          }
          CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", v128, v127, v120, v121, v122, v123, v124, (char)v146);
          int v118 = 0;
          goto LABEL_199;
        }
      }
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, @"Failed to create putChunkKeys request body");
      CFRelease(v97);
    }
    else
    {
      CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", 37, @"Failed to create putChunkKeys request url");
    }
    a2 = v150;
    goto LABEL_152;
  }
  uint64_t v21 = 0;
  uint64_t v22 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  uint64_t v148 = chunk_keys_response__unpack;
  while (1)
  {
    uint64_t v23 = *(void *)(chunk_keys_response__unpack[4] + 8 * v21);
    uint64_t v25 = *(void *)(v23 + 24);
    CFDataRef v24 = (const __CFData *)(v23 + 24);
    uint64_t v154 = *(void *)(chunk_keys_response__unpack[4] + 8 * v21);
    if (mmcs_file_signature_is_valid_n(*(void *)(v154 + 32), v25))
    {
      uint64_t v31 = ProtobufCBinaryData_CreateData(v24);
      CFTypeRef cf = v31;
    }
    else
    {
      uint64_t v31 = cf;
    }
    if (!v31)
    {
      CFStringRef v74 = @"The server returned a getChunkKeys response with an invalid signature";
      goto LABEL_135;
    }
    if (*(_DWORD *)(v154 + 40))
    {
      CFAllocatorRef v32 = ProtobufCBinaryData_CreateData((CFDataRef)(v154 + 48));
      CFTypeRef v157 = v32;
      uint64_t v31 = cf;
    }
    else
    {
      CFAllocatorRef v32 = v157;
    }
    key[0] = 0;
    long long buf = (unint64_t)v32;
    if (!mmcs_update_item_create((uint64_t *)key, (const __CFData *)v31, @"fake", (CFTypeRef *)&buf, 0))
    {
      CFMutableArrayRef v54 = 0;
      CFStringRef v47 = 0;
      CFArrayRef v46 = 0;
      CFTypeRef v159 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"mmcs_update_item_create", v33, v34, v35, v36, v37, (char)v146);
      goto LABEL_139;
    }
    CFArrayRef v43 = (const __CFArray *)XCFDictionaryGetArrayValue(*(CFDictionaryRef *)(*(void *)(v3 + 304) + 24), key[0]);
    if (key[0]) {
      C3BaseRelease(key[0]);
    }
    key[0] = 0;
    if (!v43) {
      break;
    }
    CFIndex v44 = CFArrayGetCount(v43);
    if (v44 <= 0) {
      handle_response_get_chunk_keys_cold_3();
    }
    CFIndex v45 = v44;
    uint64_t v147 = v21;
    long long v156 = CFArrayGetValueAtIndex(v43, 0);
    CFArrayRef v46 = CFArrayCreateMutable(allocator, 0, v22);
    CFStringRef v47 = CFArrayCreateMutable(allocator, 0, v22);
    CFMutableArrayRef v48 = CFArrayCreateMutable(allocator, 0, v22);
    CFMutableArrayRef v54 = v48;
    uint64_t v55 = v154;
    if (*(void *)(v154 + 64))
    {
      uint64_t v56 = 0;
      unint64_t v57 = 0;
      unint64_t v153 = v48;
      while (1)
      {
        uint64_t v58 = *(void *)(*(void *)(v55 + 72) + 8 * v57);
        if (!*(_DWORD *)(v58 + 40) || !*(void *)(v58 + 48))
        {
          CFTypeRef v159 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"The server returned a getChunkKeys response with a FileChunkKeys missing a chunk encryption key", v49, v50, v51, v52, v53, (char)v146);
          a2 = v150;
          CFMutableSetRef Mutable = theSet;
          goto LABEL_139;
        }
        if (*((void *)v156 + 8))
        {
          if (!*((void *)v156 + 9)) {
            handle_response_get_chunk_keys_cold_4();
          }
          CFDataRef v59 = ProtobufCBinaryData_CreateData((CFDataRef)(v58 + 48));
          uint64_t v60 = mmcs_chunk_key_copy_wraptured_scheme_and_key(v59, *((const __CFData **)v156 + 9), 0, (CFErrorRef *)&v159);
          if (v59) {
            CFRelease(v59);
          }
          if (!v60)
          {
            a2 = v150;
            uint64_t v3 = v151;
            CFMutableSetRef Mutable = theSet;
            CFMutableArrayRef v54 = v153;
            goto LABEL_139;
          }
          ProtobufCBinaryData_SetData((CFIndex *)(v58 + 48), v60);
          CFRelease(v60);
          uint64_t v3 = v151;
        }
        CFDataRef v61 = ProtobufCBinaryData_CreateData((CFDataRef)(v58 + 24));
        CFArrayAppendValue(v46, v61);
        if (v61) {
          CFRelease(v61);
        }
        CFDataRef v62 = ProtobufCBinaryData_CreateData((CFDataRef)(v58 + 48));
        CFArrayAppendValue(v47, v62);
        if (v62) {
          CFRelease(v62);
        }
        CFMutableArrayRef v54 = v153;
        if (*(_DWORD *)(v58 + 64))
        {
          v56 += *(void *)(v58 + 72);
          CFNumberRef v63 = CFNumberCreate(allocator, kCFNumberSInt64Type, (const void *)(v58 + 72));
          CFArrayAppendValue(v153, v63);
          CFMutableSetRef Mutable = theSet;
          if (v63) {
            CFRelease(v63);
          }
        }
        else
        {
          CFMutableSetRef Mutable = theSet;
          if (*(unsigned char *)(*(void *)(v3 + 304) + 73))
          {
            CFErrorRef v89 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"The server returned a getChunkKeys response with a FileChunkKeys missing a chunk length when one is required", v49, v50, v51, v52, v53, (char)v146);
            goto LABEL_138;
          }
        }
        ++v57;
        uint64_t v55 = v154;
        if (v57 >= *(void *)(v154 + 64)) {
          goto LABEL_52;
        }
      }
    }
    uint64_t v56 = 0;
LABEL_52:
    for (CFIndex i = 0; i != v45; ++i)
    {
      CFRange v65 = CFArrayGetValueAtIndex(v43, i);
      mmcs_update_item_set_chunk_signatures_keys_and_lengths(v65, v46, v47, v54);
      mmcs_update_item_set_padded_file_size((uint64_t)v65, v56);
      CFDataRef v66 = (const __CFData *)v65[2];
      if (v66 && (*CFDataGetBytePtr(v66) & 0x7F) != 4) {
        mmcs_update_item_set_file_size((uint64_t)v65, v56);
      }
      XCFDictionaryAppendValue(*(const __CFDictionary **)(*(void *)(v3 + 304) + 32), &_update_items_array_callbacks, v65, v65);
      CFSetRemoveValue(Mutable, v65);
    }
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = 0;
    chunk_keys_response__unpacCFIndex k = v148;
    a2 = v150;
    if (v157) {
      CFRelease(v157);
    }
    CFTypeRef v157 = 0;
    if (v46) {
      CFRelease(v46);
    }
    if (v47) {
      CFRelease(v47);
    }
    if (v54) {
      CFRelease(v54);
    }
    uint64_t v21 = v147 + 1;
    uint64_t v22 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    if ((unint64_t)(v147 + 1) >= v148[3]) {
      goto LABEL_68;
    }
  }
  CFErrorRef v89 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"The server returned a getChunkKeys response with a FileChunkKeys containing unknown (signature, reference)", v38, v39, v40, v41, v42, (char)v146);
  CFMutableArrayRef v54 = 0;
  CFStringRef v47 = 0;
  CFArrayRef v46 = 0;
LABEL_138:
  CFTypeRef v159 = v89;
  a2 = v150;
LABEL_139:
  int v85 = 1;
  chunk_keys_response__unpacCFIndex k = v148;
LABEL_96:
  if (a2) {
    goto LABEL_97;
  }
  if (v85)
  {
LABEL_100:
    mmcs_update_request_set_error(v3, v159);
    mmcs_update_request_cleanup(v3);
  }
LABEL_101:
  if (chunk_keys_response__unpack) {
    chunkserver__get_chunk_keys_response__free_unpacked((void **)chunk_keys_response__unpack, 0);
  }
  if (v46) {
    CFRelease(v46);
  }
  if (v47) {
    CFRelease(v47);
  }
  if (v54) {
    CFRelease(v54);
  }
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef cf = 0;
  if (v157) {
    CFRelease(v157);
  }
  CFTypeRef v157 = 0;
  if (context) {
    CFRelease(context);
  }
  CFTypeRef context = 0;
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v159) {
    CFRelease(v159);
  }
}

void _add_items(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v4 = (CFIndex *)chunkserver__get_file_chunk_keys__create();
  if (v4)
  {
    uint64_t v5 = v4;
    ProtobufCBinaryData_SetData(v4 + 3, *(CFDataRef *)(a1 + 16));
    ProtobufCString_SetString((__CFString **)v5 + 8, *(const __CFString **)(a1 + 24));
    CFDataRef v6 = *(const __CFData **)(a1 + 64);
    if (v6)
    {
      *((_DWORD *)v5 + 10) = 1;
      ProtobufCBinaryData_SetData(v5 + 6, v6);
    }
    uint64_t v8 = *(void *)(a2 + 24);
    uint64_t v7 = *(void *)(a2 + 32);
    *(void *)(a2 + 24) = v8 + 1;
    *(void *)(v7 + 8 * v8) = v5;
  }
}

void mmcs_update_request_will_retry_put_chunk_keys_after_error(uint64_t a1, uint64_t a2, __CFError *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    CFStringRef v6 = mmcs_request_copy_description(a2);
    uint64_t v7 = mmcs_cferror_copy_description(a3);
    uint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ retry put chunk keys after error %@", v6, v7);
      CFArrayRef v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v12 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (v6) {
      CFRelease(v6);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
}

void handle_response_put_chunk_keys(uint64_t a1, CFDataRef *a2, CFTypeRef cf)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  C3BaseRetain(cf);
  BOOL v6 = mmcs_http_context_status_succeeded(a1);
  if (!a2 || !v6 || !*a2)
  {
    BOOL has_http_status = mmcs_http_context_has_http_status(a1);
    uint64_t v18 = mmcs_logging_logger_default();
    if (has_http_status)
    {
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_16;
      }
      CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v20 = mmcs_http_context_http_status(a1);
      CFStringRef v21 = CFStringCreateWithFormat(v19, 0, @"putChunkKeys (%p) HTTP status: %d", a1, v20);
      uint64_t v22 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_14;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v34 = v21;
      uint64_t v23 = v22;
      os_log_type_t v24 = OS_LOG_TYPE_DEBUG;
    }
    else
    {
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      CFStringRef v21 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"putChunkKeys (%p) has no HTTP status!", a1);
      uint64_t v25 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
LABEL_14:
        if (v21) {
          CFRelease(v21);
        }
LABEL_16:
        uint64_t v26 = mmcs_http_context_copy_error(a1);
        int v27 = 1;
        if (!a2) {
          goto LABEL_28;
        }
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v34 = v21;
      uint64_t v23 = v25;
      os_log_type_t v24 = OS_LOG_TYPE_DEFAULT;
    }
    _os_log_impl(&dword_1DC1CA000, v23, v24, "%{public}@", buf, 0xCu);
    goto LABEL_14;
  }
  mmcs_http_context_validate_request_uuid_with_response(a1);
  CFDataRef v7 = *a2;
  CFIndex Length = CFDataGetLength(*a2);
  BytePtr = (char *)CFDataGetBytePtr(v7);
  CFArrayRef v10 = chunkserver__put_chunk_keys_response__unpack(0, Length, BytePtr);
  if (v10)
  {
    uint64_t v16 = (void **)v10;
    mmcs_update_request_process_put_file_success_and_error((uint64_t)cf, 1, v10[3], v10[4], v10[5], v10[6]);
    chunkserver__put_chunk_keys_response__free_unpacked(v16, 0);
  }
  else
  {
    CFErrorRef v28 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"PutChunkKeysResponse could not be deserialized", v11, v12, v13, v14, v15, v32);
    if (!v28) {
      handle_response_put_chunk_keys_cold_2();
    }
    CFErrorRef v29 = v28;
    mmcs_update_request_set_error((uint64_t)cf, v28);
    mmcs_update_request_cleanup((uint64_t)cf);
    CFRelease(v29);
  }
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = 0;
  uint64_t v30 = *(void *)(*((void *)cf + 38) + 56);
  if (v30) {
    mmcs_http_context_cleanup_response(v30);
  }
  uint64_t v26 = 0;
  int v27 = 0;
LABEL_25:
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = 0;
LABEL_28:
  uint64_t v31 = *(void *)(*((void *)cf + 38) + 56);
  if (v31) {
    mmcs_http_context_cleanup_response(v31);
  }
  if (v27)
  {
    if (!v26) {
      handle_response_put_chunk_keys_cold_1();
    }
    mmcs_update_request_set_error((uint64_t)cf, v26);
    mmcs_update_request_cleanup((uint64_t)cf);
    goto LABEL_34;
  }
  if (v26) {
LABEL_34:
  }
    CFRelease(v26);
  C3BaseRelease(cf);
}

void _add_put_item(uint64_t a1, uint64_t a2)
{
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 96)) < 1
    || (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 96)), Count != CFArrayGetCount(*(CFArrayRef *)(a1 + 104))))
  {
    _add_put_item_cold_3();
  }
  CFIndex v5 = CFArrayGetCount(*(CFArrayRef *)(a1 + 96));
  BOOL v6 = (CFIndex *)chunkserver__put_file_chunk_keys__create(v5);
  if (v6)
  {
    CFDataRef v7 = v6;
    ProtobufCBinaryData_SetData(v6 + 3, *(CFDataRef *)(a1 + 16));
    ProtobufCString_SetString((__CFString **)v7 + 10, *(const __CFString **)(a1 + 24));
    CFDataRef v8 = *(const __CFData **)(a1 + 80);
    if (v8)
    {
      *((_DWORD *)v7 + 14) = 1;
      ProtobufCBinaryData_SetData(v7 + 8, v8);
    }
    CFStringRef v9 = *(const __CFString **)(a1 + 32);
    if (v9) {
      ProtobufCString_SetString((__CFString **)v7 + 11, v9);
    }
    CFIndex v10 = CFArrayGetCount(*(CFArrayRef *)(a1 + 96));
    if (v10 >= 1)
    {
      CFIndex v11 = v10;
      for (CFIndex i = 0; i != v11; ++i)
      {
        CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), i);
        CFDataRef v14 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 104), i);
        uint64_t v15 = (CFIndex *)chunkserver__chunk_key__create();
        ProtobufCBinaryData_SetData(v15 + 3, ValueAtIndex);
        *((_DWORD *)v15 + 10) = 1;
        ProtobufCBinaryData_SetData(v15 + 6, v14);
        if (*(void *)(a1 + 80))
        {
          if (!*(void *)(a1 + 88)) {
            _add_put_item_cold_1();
          }
          CFDataRef Data = ProtobufCBinaryData_CreateData((CFDataRef)(v15 + 6));
          CFTypeRef cf = 0;
          CFNumberRef v17 = mmcs_chunk_key_copy_wraptured_scheme_and_key(Data, *(const __CFData **)(a1 + 88), 1, (CFErrorRef *)&cf);
          if (!v17) {
            _add_put_item_cold_2();
          }
          uint64_t v18 = v17;
          ProtobufCBinaryData_SetData(v15 + 6, v17);
          CFRelease(v18);
          if (cf) {
            CFRelease(cf);
          }
          if (Data) {
            CFRelease(Data);
          }
        }
        CFIndex v20 = v7[5];
        CFIndex v19 = v7[6];
        v7[5] = v20 + 1;
        *(void *)(v19 + 8 * v20) = v15;
      }
    }
    uint64_t v22 = *(void *)(a2 + 24);
    uint64_t v21 = *(void *)(a2 + 32);
    *(void *)(a2 + 24) = v22 + 1;
    *(void *)(v21 + 8 * v22) = v7;
  }
}

uint64_t mmcs_get_derivative_container_create(void *a1, uint64_t a2, char a3, uint64_t *a4)
{
  uint64_t v13 = 0;
  uint64_t result = mmcs_container_create(&v13, 3, 272);
  if (result)
  {
    uint64_t request_activity_marker = mmcs_request_get_request_activity_marker(*a4);
    os_activity_t v10 = _os_activity_create(&dword_1DC1CA000, "mmcs-get-derivative-container", request_activity_marker, OS_ACTIVITY_FLAG_DEFAULT);
    uint64_t v11 = v13;
    *(void *)(v13 + 80) = v10;
    uint64_t v12 = *(void *)(v11 + 88);
    *(void *)uint64_t v12 = a4;
    *(unsigned char *)(v12 + 17) = a3;
    C3BaseRetain((CFTypeRef)*a4);
    *(unsigned char *)(v12 + 16) = 0;
    *(void *)(v12 + 8) = a2;
    mmcs_get_derivative_container_reset_stream(v11);
    *a1 = v13;
    return 1;
  }
  return result;
}

void mmcs_get_derivative_container_finalize(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 88);
  uint64_t v2 = (const void *)v1[32];
  if (v2) {
    C3BaseRelease(v2);
  }
  v1[32] = 0;
  uint64_t v3 = (const void *)v1[24];
  if (v3) {
    C3BaseRelease(v3);
  }
  v1[24] = 0;
  CFAllocatorRef v4 = (const void *)v1[33];
  if (v4) {
    C3BaseRelease(v4);
  }
  v1[33] = 0;
  void *v1 = 0;
  v1[1] = 0;
}

__CFString *mmcs_get_derivative_copy_containerID(uint64_t a1)
{
  if (a1
    && (uint64_t v1 = *(void *)(a1 + 16)) != 0
    && (uint64_t v2 = *(void *)(v1 + 24)) != 0
    && (uint64_t v3 = *(__CFHTTPMessage **)(v2 + 16)) != 0
    && (CFURLRef v4 = CFHTTPMessageCopyRequestURL(v3)) != 0)
  {
    CFURLRef v5 = v4;
    CFStringRef value_for_tag = mmcs_url_copy_query_value_for_tag(v4, @"id");
    if (value_for_tag)
    {
      CFStringRef v7 = value_for_tag;
      CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"getDerivative.%@", value_for_tag);
      CFRelease(v5);
      CFURLRef v5 = (const __CFURL *)v7;
    }
    else
    {
      CFStringRef v8 = 0;
    }
    CFRelease(v5);
  }
  else
  {
    CFStringRef v8 = 0;
  }
  if (v8) {
    return (__CFString *)v8;
  }
  else {
    return @"getDerivative";
  }
}

uint64_t mmcs_get_derivative_container_schedule(uint64_t a1, uint64_t a2)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  CFURLRef v4 = _os_activity_create(&dword_1DC1CA000, "mmcs-get-derivative-schedule", *(os_activity_t *)(a1 + 80), OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v4, &state);
  CFURLRef v5 = *(uint64_t ***)(a1 + 88);
  uint64_t v6 = 0;
  if (!mmcs_container_check_expired((void *)a1, a2, (uint64_t)"get-derivative", (uint64_t)"get-derivative-container-name-here"))
  {
    CFStringRef v7 = *v5;
    if (*v5)
    {
      uint64_t v8 = *v7;
      if (*v7)
      {
        uint64_t v9 = mmcs_chunk_instance_offset(*v7);
        if (v9)
        {
          uint64_t v10 = v9;
          if (*(double *)(a2 + 56) == 0.0)
          {
            uint64_t v11 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"enqueueTime should be defined for get request");
              uint64_t v13 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v12;
                _os_log_impl(&dword_1DC1CA000, v13, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v12) {
                CFRelease(v12);
              }
            }
          }
          uint64_t v61 = 0;
          CFIndex v45 = @"getDerivative";
          long long v46 = *(_OWORD *)(*(void *)(a2 + 24) + 16);
          double network_timeout_period = mmcs_request_get_network_timeout_period(v8);
          if (mmcs_request_is_background(v8)) {
            uint64_t v14 = *(void *)(*(void *)(a2 + 24) + 40);
          }
          else {
            uint64_t v14 = 0;
          }
          uint64_t v48 = v14;
          uint64_t v49 = -1;
          uint64_t v50 = -1;
          uint64_t v51 = 0;
          uint64_t v52 = 0;
          uint64_t v53 = handle_derivative_container_request_will_retry_after_error;
          CFMutableArrayRef v54 = handle_response_downloadGetDerivativeContainer;
          uint64_t v55 = handle_callback_downloadDerivativeDataBuffer;
          uint64_t v56 = handle_http_endOfDataCallback;
          unint64_t v57 = mmcs_container_xmitcallback;
          uint64_t v58 = a2;
          uint64_t sparse_block_size = mmcs_engine_get_sparse_block_size();
          uint64_t v60 = mmcs_engine_owner(v10);
          LOBYTE(v61) = 1;
          uint64_t v62 = *(void *)(a2 + 56);
          CFNumberRef v63 = v4;
          *(_OWORD *)CFTypeRef cf = 0u;
          long long v44 = 0u;
          mmcs_read_stream_pool_parameters_make_pool(*(void *)(v10 + 40), cf);
          uint64_t v21 = (uint64_t *)(a2 + 16);
          unsigned int http_class = mmcs_request_get_http_class(v8);
          int v23 = mmcs_http_context_create((void *)(a2 + 16), http_class, (uint64_t)&v45);
          if (v23)
          {
            mmcs_http_context_extract_vendor_name_from_message_and_create_pool_parameters(*(void *)(a2 + 16), *(void *)(v10 + 40), (uint64_t)buf);
            *(_OWORD *)CFTypeRef cf = *(_OWORD *)buf;
            long long v44 = v66;
            uint64_t v24 = *(void *)(*(void *)(a2 + 24) + 24);
            if (mmcs_get_req_context_get_current_request_metrics(v8))
            {
              uint64_t v25 = *(void *)(a2 + 64);
              uint64_t v26 = *(uint64_t ***)(v25 + 88);
              derivative_copy_containerID = mmcs_get_derivative_copy_containerID(v25);
              mmcs_transaction_make_req_context_metrics((__CFArray *)a2, **v26, v24, @"getDerivativeContainer", derivative_copy_containerID);
              CFRelease(derivative_copy_containerID);
            }
            mmcs_http_context_update_voucher(*v21);
            mmcs_http_context_uuid_hash_code(*v21);
            kdebug_trace();
            int v28 = mmcs_http_context_send(*v21, (uint64_t)cf, *(void *)(v10 + 56));
          }
          else
          {
            int v28 = 0;
          }
          if (cf[1]) {
            CFRelease(cf[1]);
          }
          if (v23)
          {
            if (v28)
            {
              uint64_t v6 = 1;
              if (!v4) {
                goto LABEL_28;
              }
              goto LABEL_27;
            }
            uint64_t v39 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v40 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unable to send http message");
              uint64_t v41 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v40;
                _os_log_impl(&dword_1DC1CA000, v41, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v40) {
                CFRelease(v40);
              }
            }
            CFStringRef v37 = @"Unable to send http request";
            CFIndex v38 = 1;
          }
          else
          {
            CFErrorRef v29 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v35 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"unable to create http context");
              uint64_t v36 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v35;
                _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v35) {
                CFRelease(v35);
              }
            }
            CFStringRef v37 = @"Unable to create http context";
            CFIndex v38 = 37;
          }
          uint64_t v16 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v38, v37, v30, v31, v32, v33, v34, v42);
          mmcs_get_derivative_container_set_error_and_fail_container(a1, v16);
          if (!v16) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }
        CFIndex v19 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
LABEL_25:
          uint64_t v6 = 0;
          goto LABEL_26;
        }
        uint64_t v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null engine backref in container %p", a1);
        CFNumberRef v17 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
LABEL_23:
          if (v16)
          {
LABEL_24:
            CFRelease(v16);
            goto LABEL_25;
          }
          goto LABEL_25;
        }
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v16;
      }
      else
      {
        uint64_t v18 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          goto LABEL_25;
        }
        uint64_t v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null get request backref in container %p", a1);
        CFNumberRef v17 = mmcs_logging_logger_default();
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          goto LABEL_23;
        }
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v16;
      }
    }
    else
    {
      uint64_t v15 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      uint64_t v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null get state backref in container %p", a1);
      CFNumberRef v17 = mmcs_logging_logger_default();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v16;
    }
    _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
    goto LABEL_23;
  }
LABEL_26:
  if (v4) {
LABEL_27:
  }
    os_release(v4);
LABEL_28:
  os_activity_scope_leave(&state);
  return v6;
}

void handle_derivative_container_request_will_retry_after_error(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t user_data = mmcs_http_context_get_user_data(a1);
  if (a3)
  {
    uint64_t v5 = user_data;
    if (user_data)
    {
      uint64_t v6 = *(void *)(user_data + 64);
      if (v6)
      {
        mmcs_container_set_error(*(void **)(user_data + 64), a3);
        _mmcs_get_derivative_container_reset_for_retry(v6, v5);
      }
    }
  }
}

void handle_response_downloadGetDerivativeContainer(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = 0;
  }
  if (!a1) {
    handle_response_downloadGetDerivativeContainer_cold_1();
  }
  if (!a3) {
    handle_response_downloadGetDerivativeContainer_cold_2();
  }
  if (*(void *)(a3 + 16) != a1) {
    handle_response_downloadGetDerivativeContainer_cold_3();
  }
  uint64_t v6 = *(void *)(a3 + 64);
  CFStringRef v7 = **(CFDictionaryRef ***)(v6 + 88);
  *(_DWORD *)(a3 + 48) = 4;
  if (v7)
  {
    mmcs_http_context_uuid_hash_code(a1);
    kdebug_trace();
    if (!mmcs_http_context_is_connection_reused(a1)) {
      kdebug_trace();
    }
    CFDictionaryRef v8 = *v7;
    state.opaque[0] = 0;
    state.opaque[1] = 0;
    uint64_t request_activity_marker = mmcs_request_get_request_activity_marker((uint64_t)v8);
    os_activity_scope_enter(request_activity_marker, &state);
    C3BaseRetain(v8);
    char v66 = 1;
    ++*(void *)(*((void *)v8 + 38) + 24);
    uint64_t v10 = *(void *)(*((void *)v8 + 4) + 48);
    CFErrorRef error = 0;
    if (!mmcs_transaction_is_proxy(a3))
    {
      if (mmcs_http_context_is_background(a1)) {
        CFErrorRef error = 0;
      }
      else {
        CFErrorRef error = (__CFError *)mmcs_http_context_get_error(a1);
      }
    }
    int is_connection_reused = mmcs_http_context_is_connection_reused(a1);
    double Current = CFAbsoluteTimeGetCurrent();
    mmcs_request_queue_request_did_complete(v10, (void *)a3, error, is_connection_reused, (BOOL *)&v66, Current);
    if (*(unsigned char *)(*((void *)v8 + 38) + 40)) {
      goto LABEL_21;
    }
    if (*((unsigned char *)v8 + 144))
    {
      int has_outstanding_asynchronous_work = mmcs_get_req_has_outstanding_asynchronous_work((uint64_t)v8);
      uint64_t v18 = mmcs_logging_logger_default();
      BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
      if (has_outstanding_asynchronous_work)
      {
        if (v19)
        {
          CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Request is cancelled but has_outstanding_asynchronous_work  (Get request %p)", v8);
          uint64_t v21 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = v20;
            _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
          }
          if (v20) {
            CFRelease(v20);
          }
        }
        goto LABEL_21;
      }
      if (v19)
      {
        CFStringRef v38 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cancelled and downloads complete. All done! (Get request %p)", v8);
        uint64_t v39 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v38;
          _os_log_impl(&dword_1DC1CA000, v39, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v38) {
          CFRelease(v38);
        }
      }
      uint64_t v40 = *((void *)v8 + 19);
      uint64_t v41 = (uint64_t)v8;
      goto LABEL_47;
    }
    uint64_t v22 = mmcs_http_context_get_error(a1);
    if (!v22)
    {
      if (*(unsigned char *)(*(void *)(v6 + 88) + 168))
      {
        int v42 = 0;
        goto LABEL_84;
      }
      CFErrorRef v44 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 11, @"There was an unspecified error processing data from container", v23, v24, v25, v26, v27, v65);
      mmcs_container_set_error((void *)v6, v44);
      if (v44) {
        CFRelease(v44);
      }
      goto LABEL_72;
    }
    int v28 = (__CFError *)v22;
    host_CFErrorRef error = mmcs_cferror_copy_transformed_cannot_find_host_error(a1);
    CFErrorRef v30 = host_error;
    if (host_error) {
      CFErrorRef v31 = host_error;
    }
    else {
      CFErrorRef v31 = v28;
    }
    mmcs_container_set_error((void *)v6, v31);
    CFErrorDomain Domain = CFErrorGetDomain(v31);
    CFIndex Code = CFErrorGetCode(v31);
    if (!CFEqual(@"com.apple.mmcs", Domain))
    {
      if (CFEqual((CFTypeRef)*MEMORY[0x1E4F1D158], Domain))
      {
        BOOL v43 = Code == -9810;
      }
      else
      {
        if (!CFEqual((CFTypeRef)*MEMORY[0x1E4F18F50], Domain))
        {
          BOOL v34 = CFEqual((CFTypeRef)*MEMORY[0x1E4F1D160], Domain) != 0;
          goto LABEL_69;
        }
        BOOL v43 = Code == -1005;
      }
      BOOL v34 = v43;
LABEL_69:
      if (v30) {
        CFRelease(v30);
      }
      if (!v34)
      {
LABEL_83:
        int v42 = 1;
LABEL_84:
        uint64_t metrics = mmcs_http_context_get_metrics(a1);
        mmcs_metrics_http_info_set_final_try_in_request(metrics, 1);
        *(_DWORD *)(v6 + 68) = 4;
        uint64_t v56 = *(void *)(a3 + 16);
        if (v56)
        {
          mmcs_http_context_invalidate(v56);
          unint64_t v57 = *(const void **)(a3 + 16);
          if (v57) {
            C3BaseRelease(v57);
          }
        }
        *(void *)(a3 + 16) = 0;
        if (v42) {
          mmcs_get_state_fail_container(v7, (void *)v6);
        }
        goto LABEL_95;
      }
LABEL_72:
      uint64_t v48 = *(void *)(a3 + 32);
      if (v48 >= 1) {
        *(void *)(a3 + 32) = --v48;
      }
      if (v48)
      {
        uint64_t v49 = mmcs_http_context_get_metrics(a1);
        mmcs_metrics_http_info_set_final_try_in_request(v49, 0);
        if (mmcs_transaction_is_proxy(a3))
        {
          uint64_t v50 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v51 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"caching server failed; retrying with vendor");
            uint64_t v52 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
            {
              LODWORD(buf) = 138543362;
              *(void *)((char *)&buf + 4) = v51;
              _os_log_impl(&dword_1DC1CA000, v52, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
            }
            if (v51) {
              CFRelease(v51);
            }
          }
        }
        uint64_t v53 = **(uint64_t ***)(v6 + 88);
        if (v53) {
          uint64_t v54 = *v53;
        }
        else {
          uint64_t v54 = 0;
        }
        uint64_t v58 = *(void *)(v6 + 16);
        uint64_t v59 = *(void *)(a3 + 16);
        if (v59) {
          mmcs_http_context_invalidate(v59);
        }
        _mmcs_get_derivative_container_reset_for_retry(v6, a3);
        uint64_t v60 = *(const void **)(a3 + 16);
        if (v60) {
          C3BaseRelease(v60);
        }
        *(void *)(a3 + 16) = 0;
        *(_DWORD *)(v6 + 68) = 3;
        *(_DWORD *)(v58 + 48) = 2;
        *(CFAbsoluteTime *)(v58 + 56) = CFAbsoluteTimeGetCurrent();
        uint64_t v61 = mmcs_http_request_options_network_behavior_type(*(void *)(*(void *)(v58 + 24) + 24));
        uint64_t v62 = mmcs_request_type_for_behavior_and_activity(v61, 1);
        long long v72 = 0u;
        long long v73 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        mmcs_container_requirements(v6);
        *(void *)&long long buf = 0;
        *((void *)&buf + 1) = v58;
        uint64_t v75 = v62;
        uint64_t discretionary_network_behavior = mmcs_http_request_options_get_discretionary_network_behavior(v54);
        long long v79 = v70;
        long long v80 = v71;
        long long v81 = v72;
        long long v82 = v73;
        long long v77 = v68;
        long long v78 = v69;
        uint64_t v83 = mmcs_container_schedule_request_callback;
        uint64_t v84 = mmcs_container_cancel_request_callback;
        int v85 = C3BaseRetain;
        uint64_t v86 = C3BaseRelease;
        uint64_t v63 = mmcs_chunk_instance_offset(v54);
        mmcs_request_queue_enqueue_request(*(void *)(v63 + 48), (uint64_t)&buf, *(double *)(v58 + 56));
LABEL_95:
        --*(void *)(*((void *)v8 + 38) + 24);
        if (mmcs_get_req_has_outstanding_asynchronous_work((uint64_t)v8)
          || *(void *)(*((void *)v8 + 38) + 24))
        {
          goto LABEL_21;
        }
        uint64_t v64 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v8;
          _os_log_impl(&dword_1DC1CA000, v64, OS_LOG_TYPE_INFO, "Derivative downloads complete. All done! (Get request %p)", (uint8_t *)&buf, 0xCu);
        }
        uint64_t v41 = (uint64_t)v8;
        uint64_t v40 = 0;
LABEL_47:
        mmcs_get_req_context_cleanup(v41, v40);
LABEL_21:
        C3BaseRelease(v8);
        os_activity_scope_leave(&state);
        return;
      }
      goto LABEL_83;
    }
    BOOL v34 = 1;
    if (Code > 15)
    {
      if (Code == 16)
      {
        CFDictionaryRef v45 = CFErrorCopyUserInfo(v31);
        if (!v45) {
          goto LABEL_69;
        }
        CFDictionaryRef v36 = v45;
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v45, @"kMMCSErrorSupplementalDictionaryKey");
        if (Value)
        {
          CFStringRef v47 = (const __CFString *)CFDictionaryGetValue(Value, @"Retry-After");
          if (v47) {
            BOOL v34 = CFStringGetIntValue(v47) < 6;
          }
        }
        goto LABEL_68;
      }
      if (Code == 38) {
        goto LABEL_69;
      }
    }
    else
    {
      if (Code == 3) {
        goto LABEL_69;
      }
      if (Code == 6)
      {
        CFDictionaryRef v35 = CFErrorCopyUserInfo(v31);
        if (v35)
        {
          CFDictionaryRef v36 = v35;
          CFNumberRef v37 = (const __CFNumber *)CFDictionaryGetValue(v35, @"kMMCSErrorHTTPStatusKey");
          if (v37)
          {
            *(void *)&long long buf = -1;
            CFNumberGetValue(v37, kCFNumberCFIndexType, &buf);
            BOOL v34 = (void)buf == 500;
          }
          else
          {
            BOOL v34 = 0;
          }
LABEL_68:
          CFRelease(v36);
          goto LABEL_69;
        }
      }
    }
    BOOL v34 = 0;
    goto LABEL_69;
  }
  CFStringRef v12 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null get state backref in get container %p context %p", v6, a1);
    uint64_t v14 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v13;
      _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
    }
    if (v13) {
      CFRelease(v13);
    }
  }
}

uint64_t handle_callback_downloadDerivativeDataBuffer(uint64_t a1, const UInt8 *a2, CFIndex a3, CFErrorRef *a4)
{
  if (a4)
  {
    *a4 = 0;
    if (!mmcs_http_context_has_http_status(a1))
    {
      uint64_t v8 = *(void *)(mmcs_http_context_get_user_data(a1) + 64);
      if (v8)
      {
        derivative_copy_containerID = mmcs_get_derivative_copy_containerID(v8);
        if (a1)
        {
          request_message = (__CFHTTPMessage *)mmcs_http_context_get_request_message(a1);
          response_message = (__CFHTTPMessage *)mmcs_http_context_get_response_message(a1);
          goto LABEL_20;
        }
      }
      else
      {
        derivative_copy_containerID = 0;
      }
      request_message = 0;
      response_message = 0;
LABEL_20:
      *a4 = mmcs_cferror_create_with_request_response_and_format(@"com.apple.mmcs", 1, request_message, response_message, 0, @"Context %p while downloading container %@ does not have a status", v9, v10, a1);
      if (derivative_copy_containerID)
      {
        uint64_t v26 = derivative_copy_containerID;
        goto LABEL_22;
      }
      return 0;
    }
  }
  else
  {
    uint64_t result = mmcs_http_context_has_http_status(a1);
    if (!result) {
      return result;
    }
  }
  if ((unint64_t)(mmcs_http_context_http_status(a1) - 300) > 0xFFFFFFFFFFFFFF9BLL)
  {
    uint64_t user_data = mmcs_http_context_get_user_data(a1);
    uint64_t v16 = *(void *)(user_data + 64);
    CFNumberRef v17 = *(uint64_t **)(v16 + 88);
    uint64_t v18 = (uint64_t *)*v17;
    if (!*v17) {
      handle_callback_downloadDerivativeDataBuffer_cold_1();
    }
    uint64_t v19 = user_data;
    if (!*v18 || mmcs_request_is_cancelled(*v18)) {
      handle_callback_downloadDerivativeDataBuffer_cold_2();
    }
    uint64_t result = mmcs_get_state_process_container_data(*v17, v19);
    if (a4 && !result)
    {
      if (!*a4)
      {
        CFStringRef v20 = mmcs_get_derivative_copy_containerID(v16);
        *a4 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 11, @"There was an unspecified error processing data from container %@", v21, v22, v23, v24, v25, (char)v20);
        uint64_t v26 = v20;
LABEL_22:
        CFRelease(v26);
      }
      return 0;
    }
  }
  else
  {
    if (a3 >= 1) {
      mmcs_http_write_response_body(a1, a2, a3);
    }
    return 1;
  }
  return result;
}

uint64_t handle_http_endOfDataCallback(uint64_t a1, CFErrorRef *a2)
{
  uint64_t user_data = mmcs_http_context_get_user_data(a1);
  uint64_t v4 = *(void *)(user_data + 64);
  state_process_container_CFDataRef data = mmcs_get_state_process_container_data(**(void **)(v4 + 88), user_data);
  uint64_t v6 = state_process_container_data;
  if (a2 && !state_process_container_data && !*a2)
  {
    derivative_copy_containerID = mmcs_get_derivative_copy_containerID(v4);
    *a2 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 11, @"There was an unspecified error processing data from container %@", v8, v9, v10, v11, v12, (char)derivative_copy_containerID);
    CFRelease(derivative_copy_containerID);
  }
  return v6;
}

void mmcs_get_derivative_container_set_error_and_fail_container(uint64_t a1, const void *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    mmcs_container_set_error((void *)a1, a2);
  }
  else
  {
    uint64_t v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"There should always be an error set here for container %p", a1);
      uint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v7 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  mmcs_get_state_fail_deriviative_container(**(void **)(a1 + 88), (void *)a1);
}

void mmcs_get_derivative_container_failed_to_schedule_transaction(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 68) = 4;
  uint64_t v1 = ***(void ***)(a1 + 88);
  if (!mmcs_get_req_has_outstanding_asynchronous_work(v1))
  {
    uint64_t v2 = *(void *)(v1 + 304);
    if (!*(void *)(v2 + 24) && !*(void *)(v2 + 32))
    {
      uint64_t v3 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        int v4 = 134217984;
        uint64_t v5 = v1;
        _os_log_impl(&dword_1DC1CA000, v3, OS_LOG_TYPE_INFO, "Downloads complete. All done! (Get request %p)", (uint8_t *)&v4, 0xCu);
      }
      mmcs_get_req_context_cleanup(v1, 0);
    }
  }
}

uint64_t mmcs_get_derivative_container_add_method_completion_info()
{
  return 1;
}

uint64_t mmcs_get_derivative_container_get_request(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 88);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0;
  }
}

void mmcs_get_derivative_container_cancel_transaction(void *a1, unsigned int *a2, __CFError *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2[12] == 2)
  {
    uint64_t v6 = mmcs_container_request_queue((uint64_t)a1);
    mmcs_transaction_cancel_enqueued(a2, v6, (uint64_t)a3);
    if (a1[5]) {
      CFStringRef v7 = (__CFError *)a1[5];
    }
    else {
      CFStringRef v7 = a3;
    }
    mmcs_get_derivative_container_set_error_and_fail_container((uint64_t)a1, v7);
    uint64_t v8 = mmcs_container_mmcs_request((uint64_t)a1);
    if (!mmcs_get_req_has_outstanding_asynchronous_work(v8))
    {
      uint64_t v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        int v10 = 134217984;
        uint64_t v11 = v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_INFO, "Downloads complete. All done! (Get request %p)", (uint8_t *)&v10, 0xCu);
      }
      mmcs_get_req_context_cleanup(v8, 0);
    }
  }
  else
  {
    mmcs_transaction_cancel_not_enqueued((uint64_t)a2, a3);
    mmcs_container_set_error(a1, a3);
  }
}

uint64_t mmcs_get_derivative_container_process_data(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, CFErrorRef *a6, uint64_t a7, uint64_t a8)
{
  int v9 = a5;
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a1[11];
  if (*(void *)(a1[2] + 32) == 6
    && *(void *)(v13 + 24)
    && *(double *)(*(void *)(v13 + 8) + 248) > 0.5
    && mmcs_request_is_container_resumable_limp_mode(**(void **)v13))
  {
    CFStringRef v14 = @"Fake network error";
    CFIndex v15 = 38;
LABEL_28:
    CFErrorRef v22 = mmcs_cferror_create_with_format(@"com.apple.mmcs", v15, v14, a4, a5, (uint64_t)a6, a7, a8, v39);
    uint64_t result = 0;
    *a6 = v22;
    return result;
  }
  if (!*(unsigned char *)(v13 + 17))
  {
    if (v9)
    {
      uint64_t v20 = *(void *)(v13 + 24);
      if (!(v20 | a4))
      {
        CFStringRef v14 = @"Short container";
        goto LABEL_27;
      }
      if (a4 > 0 || v20) {
        *(unsigned char *)(v13 + 168) = 1;
      }
      uint64_t v21 = md;
    }
    else
    {
      uint64_t v21 = 0;
    }
    *(void *)md = 0;
    _process_unencrypted_derivative_data_for_signature_generation((uint64_t)a1, (uint64_t)a3, a4, v21);
    mmcs_get_state_process_derivative_data(*(void *)v13, a1, *(void *)(v13 + 24), (uint64_t)a3, a4, v9, *(uint64_t *)md);
    if (*(void *)md) {
      C3BaseRelease(*(CFTypeRef *)md);
    }
    *(void *)(v13 + 24) += a4;
    return 1;
  }
  *(void *)uint64_t v40 = 0;
  *(void *)len = 0;
  uint64_t v16 = v13 + 144;
  mmcs_epilogue_buffer_send(v13 + 144, (uint64_t)a3, a4, len, (unint64_t *)v40);
  if (!*(void *)len
    || (CFNumberRef v17 = (void *)(v13 + 124),
        CC_MD5_Update((CC_MD5_CTX *)(a1[11] + 32), v17, len[0]),
        uint64_t result = _process_derivative_stream(a1, (char *)v17, *(unint64_t *)len, 0, a6),
        result))
  {
    mmcs_epilogue_buffer_append(v16, (uint64_t)a3, a4);
    if (v9 || *(void *)v40)
    {
      uint64_t v19 = a1[11];
      if (*(void *)v40) {
        CC_MD5_Update((CC_MD5_CTX *)(v19 + 32), a3, v40[0]);
      }
      if (!v9) {
        goto LABEL_44;
      }
      if ((unint64_t)mmcs_epilogue_buffer_length(v19 + 144) <= 0xF)
      {
        CFStringRef v14 = @"MD5 from transcoder is too short";
LABEL_27:
        CFIndex v15 = 11;
        goto LABEL_28;
      }
      *(void *)md = 0;
      uint64_t v43 = 0;
      CC_MD5_Final(md, (CC_MD5_CTX *)(v19 + 32));
      CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFDataRef v24 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], md, 16);
      CFDataRef v25 = CFDataCreate(v23, (const UInt8 *)(v19 + 124), 16);
      CFDataRef v31 = v25;
      if (v24 && v25)
      {
        if (CFEqual(v24, v25))
        {
          *(unsigned char *)(v19 + 168) = 1;
LABEL_35:
          int v37 = 1;
LABEL_40:
          C3BaseRelease(v24);
LABEL_41:
          if (v31) {
            CFRelease(v31);
          }
          if (!v37) {
            return 0;
          }
LABEL_44:
          uint64_t result = _process_derivative_stream(a1, (char *)a3, *(unint64_t *)v40, v9, a6);
          if (!result) {
            return result;
          }
          return 1;
        }
        CFErrorRef v38 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 11, @"MD5 mismatch: locally computed MD5 %@ doesn't match transcoder MD5 %@", v32, v33, v34, v35, v36, (char)v24);
      }
      else
      {
        if (!v24)
        {
          int v37 = 0;
          *a6 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"local MD5 creation failed", v26, v27, v28, v29, v30, v39);
          goto LABEL_41;
        }
        if (v25) {
          goto LABEL_35;
        }
        CFErrorRef v38 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"transcoder MD5 creation failed", v26, v27, v28, v29, v30, v39);
      }
      int v37 = 0;
      *a6 = v38;
      goto LABEL_40;
    }
    return 1;
  }
  return result;
}

uint64_t _process_derivative_stream(void *a1, char *a2, unint64_t a3, int a4, void *a5)
{
  uint64_t v10 = a1[11];
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  mmcs_epilogue_buffer_send(v10 + 232, (uint64_t)a2, a3, &v13, (unint64_t *)&v12);
  if (!v13 || (uint64_t result = _process_derivative_stream_header(a1, (char *)(v10 + 216), v13, 0, a5), result))
  {
    mmcs_epilogue_buffer_append(v10 + 232, (uint64_t)a2, a3);
    if (!a4 && !v12) {
      return 1;
    }
    uint64_t result = _process_derivative_stream_header(a1, a2, v12, a4, a5);
    if (result) {
      return 1;
    }
  }
  return result;
}

void _process_unencrypted_derivative_data_for_signature_generation(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 88);
  if (a4)
  {
    *a4 = 0;
    if (!*(void *)(v4 + 264) || CKFileSignatureGeneratorFinish()) {
      return;
    }
    uint64_t v5 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
    uint64_t v6 = *(void *)(*(void *)(v4 + 8) + 40);
    *(_DWORD *)long long buf = 134218242;
    uint64_t v14 = v6;
    __int16 v15 = 2112;
    uint64_t v16 = 0;
    CFStringRef v7 = "Error finishing signature generator for item %lld: %@";
    uint64_t v8 = v5;
    uint32_t v9 = 22;
    goto LABEL_10;
  }
  if (!*(void *)(v4 + 264) || CKFileSignatureGeneratorUpdate()) {
    return;
  }
  uint64_t v10 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    uint64_t v11 = *(void *)(*(void *)(v4 + 8) + 40);
    *(_DWORD *)long long buf = 134217984;
    uint64_t v14 = v11;
    CFStringRef v7 = "Error updating signature generator for item %lld";
    uint64_t v8 = v10;
    uint32_t v9 = 12;
LABEL_10:
    _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_ERROR, v7, buf, v9);
  }
LABEL_11:
  uint64_t v12 = *(const void **)(v4 + 264);
  if (v12) {
    C3BaseRelease(v12);
  }
  *(void *)(v4 + 264) = 0;
}

void mmcs_get_derivative_container_requirements(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t v6 = mmcs_http_request_options_network_behavior_type(*(void *)(*(void *)(a2 + 24) + 24));
  uint64_t v7 = mmcs_request_type_for_behavior_and_activity(v6, 1);
  *a3 = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[1] = 0u;
  mmcs_http_request_make_request_requirements(*(void *)(a2 + 24), (uint64_t)a3);
  *((void *)a3 + v7 + 2) = *(void *)(*(void *)(v5 + 8) + 312);
}

void mmcs_get_derivative_container_invalidate(uint64_t a1)
{
  uint64_t v2 = *(CFTypeRef ***)(a1 + 88);
  uint64_t v3 = *v2;
  if (*v2)
  {
    if (*v3) {
      C3BaseRelease(*v3);
    }
    *uint64_t v2 = 0;
  }
  mmcs_container_invalidate_transactions(a1);
}

__CFString *mmcs_get_derivative_container_copy_simple_description()
{
  return @"Deriviative Container";
}

void mmcs_get_derivative_container_reset_stream(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 88);
  *(unsigned char *)(v1 + 168) = 0;
  CC_MD5_Init((CC_MD5_CTX *)(v1 + 32));
  mmcs_epilogue_buffer_init((void *)(v1 + 144), v1 + 124, 16);
  *(void *)(v1 + 177) = 0;
  *(void *)(v1 + 169) = 0;
  *(_DWORD *)(v1 + 188) = 0;
  uint64_t v2 = *(const void **)(v1 + 192);
  if (v2) {
    C3BaseRelease(v2);
  }
  *(void *)(v1 + 216) = 0;
  *(void *)(v1 + 192) = 0;
  *(void *)(v1 + 200) = 0;
  *(void *)(v1 + 208) = 0;
  *(void *)(v1 + 224) = 0;
  mmcs_epilogue_buffer_init((void *)(v1 + 232), v1 + 216, 16);
  uint64_t v3 = *(const void **)(v1 + 256);
  if (v3) {
    C3BaseRelease(v3);
  }
  *(void *)(v1 + 256) = 0;
  *(void *)(v1 + 24) = 0;
  uint64_t v4 = *(const void **)(v1 + 264);
  if (v4) {
    C3BaseRelease(v4);
  }
  *(void *)(v1 + 264) = 0;
  arguments_for_derivative_validation_signature_generator = (const void *)mmcs_item_create_arguments_for_derivative_validation_signature_generator();
  if (arguments_for_derivative_validation_signature_generator && CKFileSignatureGeneratorCreate()) {
    goto LABEL_12;
  }
  uint64_t v6 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    uint64_t v7 = *(void *)(*(void *)(v1 + 8) + 40);
    int v8 = 134217984;
    uint64_t v9 = v7;
    _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_ERROR, "Error creating signature generator for item %llu", (uint8_t *)&v8, 0xCu);
  }
  if (arguments_for_derivative_validation_signature_generator) {
LABEL_12:
  }
    C3BaseRelease(arguments_for_derivative_validation_signature_generator);
}

void _mmcs_get_derivative_container_reset_for_retry(uint64_t a1, uint64_t a2)
{
  mmcs_container_remember_error(a1, a2);
  mmcs_container_reset_error_for_retry(a1);
  mmcs_get_derivative_container_reset_stream(a1);
  uint64_t v3 = *(void *)(*(void *)(a1 + 88) + 8);
  unint64_t v4 = *(void *)(v3 + 320);
  mmcs_item_update_unget_derivative_progress(v3, v4);
}

uint64_t _process_derivative_stream_header(void *a1, char *__src, uint64_t a3, int a4, void *a5)
{
  uint64_t v7 = a3;
  int v8 = __src;
  CFTypeRef v63 = 0;
  error_with_underlying_CFErrorRef error = 0;
  CFTypeRef cf = 0;
  if (a5) {
    *a5 = 0;
  }
  chunk_key_concatenation = 0;
  uint64_t v11 = a1[11];
  if (a3 < 1 || (uint64_t v12 = *(unsigned int *)(v11 + 188), v12 > 0xF))
  {
    CFDataRef v14 = 0;
  }
  else
  {
    if (16 - (int)v12 >= a3) {
      size_t v13 = a3;
    }
    else {
      size_t v13 = (16 - v12);
    }
    memcpy((void *)(v11 + 169 + v12), __src, v13);
    *(_DWORD *)(v11 + 188) += v13;
    v8 += v13;
    v7 -= v13;
    if (*(_DWORD *)(a1[11] + 188) == 16)
    {
      chunk_key_concatenation = mmcs_item_create_chunk_key_concatenation(*(void *)(v11 + 8));
      CFDataRef v14 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)(v11 + 169), *(unsigned int *)(v11 + 188));
      int v19 = CKStreamKeyDerivation();
      CFTypeRef v20 = cf;
      uint64_t v21 = error_with_underlying_error;
      if (v19) {
        BOOL v22 = cf == 0;
      }
      else {
        BOOL v22 = 1;
      }
      if (v22 || error_with_underlying_error != 0)
      {
        error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 1, (void *)error_with_underlying_error, @"CKStreamKeyDerivation", v15, v16, v17, v18, v59);
        if (v21)
        {
          CFRelease(v21);
          uint64_t v21 = 0;
        }
        goto LABEL_60;
      }
      if (*(void *)(v11 + 192))
      {
        CFRelease(*(CFTypeRef *)(v11 + 192));
        CFTypeRef v20 = cf;
      }
      *(void *)(v11 + 192) = 0;
      CFRetain(v20);
      *(void *)(v11 + 192) = cf;
    }
    else
    {
      chunk_key_concatenation = 0;
      CFDataRef v14 = 0;
    }
  }
  uint64_t v24 = *(unsigned int *)(v11 + 212);
  BOOL v25 = v24 > 0xB || v7 < 1;
  if (v25
    || (12 - (int)v24 >= v7 ? (size_t v26 = v7) : (size_t v26 = (12 - v24)),
        memcpy((void *)(v11 + 200 + v24), v8, v26),
        CFIndex v27 = (*(_DWORD *)(v11 + 212) + v26),
        *(_DWORD *)(v11 + 212) = v27,
        v8 += v26,
        v7 -= v26,
        *(_DWORD *)(a1[11] + 212) != 12))
  {
    uint64_t v21 = 0;
    if (a4) {
      goto LABEL_35;
    }
LABEL_45:
    if (v7 <= 0)
    {
LABEL_52:
      uint64_t v40 = 1;
      goto LABEL_66;
    }
    if (*(void *)(v11 + 256))
    {
      if (CKStreamCoderUpdate())
      {
        char v39 = 0;
LABEL_49:
        CFTypeRef v61 = 0;
        _process_unencrypted_derivative_data_for_signature_generation((uint64_t)a1, (uint64_t)v8, v7, v39);
        mmcs_get_state_process_derivative_data(*(void *)v11, a1, *(void *)(v11 + 24), (uint64_t)v8, v7, a4, (uint64_t)v61);
        if (v61) {
          C3BaseRelease(v61);
        }
        *(void *)(v11 + 24) += v7;
        goto LABEL_52;
      }
LABEL_79:
      uint64_t v49 = (void *)error_with_underlying_error;
      CFStringRef v50 = @"CKStreamCoderUpdate";
LABEL_80:
      error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 1, v49, v50, v29, v30, v31, v32, v59);
      if (v49) {
        CFRelease(v49);
      }
      goto LABEL_60;
    }
LABEL_55:
    CFStringRef v47 = @"Stream coder missing.";
    CFIndex v48 = 1;
LABEL_56:
    CFErrorRef error = mmcs_cferror_create_error(@"com.apple.mmcs", v48, v47);
    goto LABEL_59;
  }
  uint64_t v21 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)(v11 + 200), v27);
  uint64_t v28 = *(const void **)(v11 + 256);
  if (v28) {
    C3BaseRelease(v28);
  }
  *(void *)(v11 + 256) = 0;
  if (!CKStreamCoderCreate())
  {
    uint64_t v49 = (void *)error_with_underlying_error;
    CFStringRef v50 = @"Stream coder.";
    goto LABEL_80;
  }
  if (!a4) {
    goto LABEL_45;
  }
LABEL_35:
  if (mmcs_epilogue_buffer_length(a1[11] + 232) == 16)
  {
    uint64_t v38 = a1[11];
    if (*(_DWORD *)(v38 + 188) == 16)
    {
      if (*(_DWORD *)(v38 + 212) != 12)
      {
        CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 11, @"Short derivative container missing iv: iv length %u", v33, v34, v35, v36, v37, *(_DWORD *)(v11 + 212));
        goto LABEL_59;
      }
      if (*(void *)(v11 + 256))
      {
        if (v7 <= 0 || CKStreamCoderUpdate())
        {
          CFTypeRef v63 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)(v11 + 216), 16);
          if (v63)
          {
            if (!CKStreamCoderFinish())
            {
              CFTypeRef v53 = error_with_underlying_error;
              CCFStringRef StringDescription = XCFDataCreateCStringDescription((const __CFData *)v63);
              error_with_underlying_CFErrorRef error = mmcs_cferror_create_error_with_underlying_error(@"com.apple.mmcs", 11, (void *)error_with_underlying_error, @"AES GCM tag mismatch. Processed %llu bytes of derivative content. Expected tag %s", v55, v56, v57, v58, *(void *)(v11 + 24));
              if (v53) {
                CFRelease(v53);
              }
              if (CStringDescription) {
                free(CStringDescription);
              }
              goto LABEL_60;
            }
            char v39 = &v61;
            goto LABEL_49;
          }
          CFStringRef v47 = @"tagObject";
          CFIndex v48 = 37;
          goto LABEL_56;
        }
        goto LABEL_79;
      }
      goto LABEL_55;
    }
    CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 11, @"Short derivative container missing salt: salt length %u", v33, v34, v35, v36, v37, *(_DWORD *)(v11 + 188));
  }
  else
  {
    char v60 = mmcs_epilogue_buffer_length(v11 + 232);
    CFErrorRef error = mmcs_cferror_create_with_format(@"com.apple.mmcs", 11, @"Short derivative container missing tag: tag length %ld", v41, v42, v43, v44, v45, v60);
  }
LABEL_59:
  error_with_underlying_CFErrorRef error = error;
LABEL_60:
  if (a5)
  {
    if (error_with_underlying_error)
    {
      CFRetain(error_with_underlying_error);
      CFTypeRef v51 = error_with_underlying_error;
    }
    else
    {
      CFTypeRef v51 = 0;
    }
    uint64_t v40 = 0;
    *a5 = v51;
  }
  else
  {
    uint64_t v40 = 0;
  }
LABEL_66:
  if (v21) {
    CFRelease(v21);
  }
  if (v63) {
    CFRelease(v63);
  }
  if (error_with_underlying_error) {
    CFRelease(error_with_underlying_error);
  }
  if (chunk_key_concatenation) {
    CFRelease(chunk_key_concatenation);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v40;
}

__n128 MMCSEngineClientContextCopy1(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x40uLL, 0x108004041683268uLL);
  if (v2)
  {
    __n128 result = *(__n128 *)a1;
    long long v4 = *(_OWORD *)(a1 + 16);
    long long v5 = *(_OWORD *)(a1 + 48);
    v2[2] = *(_OWORD *)(a1 + 32);
    v2[3] = v5;
    *uint64_t v2 = result;
    v2[1] = v4;
  }
  return result;
}

__n128 MMCSEngineClientContextCopy3(__n128 *a1)
{
  uint64_t v2 = (__n128 *)malloc_type_calloc(1uLL, 0x48uLL, 0x1080040F19B2D45uLL);
  if (v2)
  {
    *uint64_t v2 = *a1;
    __n128 result = a1[1];
    __n128 v4 = a1[2];
    __n128 v5 = a1[3];
    v2[4].n128_u64[0] = a1[4].n128_u64[0];
    v2[2] = v4;
    v2[3] = v5;
    v2[1] = result;
  }
  return result;
}

__n128 MMCSEngineClientContextCopy4(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x58uLL, 0x10800405B6EA996uLL);
  if (v2)
  {
    long long v4 = *(_OWORD *)(a1 + 16);
    *uint64_t v2 = *(_OWORD *)a1;
    v2[1] = v4;
    __n128 result = *(__n128 *)(a1 + 32);
    long long v5 = *(_OWORD *)(a1 + 48);
    long long v6 = *(_OWORD *)(a1 + 64);
    *((void *)v2 + 10) = *(void *)(a1 + 80);
    v2[3] = v5;
    v2[4] = v6;
    v2[2] = result;
  }
  return result;
}

__n128 MMCSEngineClientContextCopy5(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x58uLL, 0x10800405B6EA996uLL);
  if (v2)
  {
    long long v4 = *(_OWORD *)(a1 + 16);
    *uint64_t v2 = *(_OWORD *)a1;
    v2[1] = v4;
    __n128 result = *(__n128 *)(a1 + 32);
    long long v5 = *(_OWORD *)(a1 + 48);
    long long v6 = *(_OWORD *)(a1 + 64);
    *((void *)v2 + 10) = *(void *)(a1 + 80);
    v2[3] = v5;
    v2[4] = v6;
    v2[2] = result;
  }
  return result;
}

__n128 MMCSEngineClientContextCopy6(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x58uLL, 0x10800405B6EA996uLL);
  if (v2)
  {
    long long v4 = *(_OWORD *)(a1 + 16);
    *uint64_t v2 = *(_OWORD *)a1;
    v2[1] = v4;
    __n128 result = *(__n128 *)(a1 + 32);
    long long v5 = *(_OWORD *)(a1 + 48);
    long long v6 = *(_OWORD *)(a1 + 64);
    *((void *)v2 + 10) = *(void *)(a1 + 80);
    v2[3] = v5;
    v2[4] = v6;
    v2[2] = result;
  }
  return result;
}

__n128 MMCSEngineClientContextCopy10(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x60uLL, 0x1080040B4ECD51FuLL);
  if (v2)
  {
    long long v4 = *(_OWORD *)(a1 + 16);
    *uint64_t v2 = *(_OWORD *)a1;
    v2[1] = v4;
    __n128 result = *(__n128 *)(a1 + 32);
    long long v5 = *(_OWORD *)(a1 + 48);
    long long v6 = *(_OWORD *)(a1 + 80);
    v2[4] = *(_OWORD *)(a1 + 64);
    v2[5] = v6;
    v2[2] = result;
    v2[3] = v5;
  }
  return result;
}

uint64_t mmcs_get_nsurlerror_background_task_cancelled_reason_key()
{
  return *MEMORY[0x1E4F28998];
}

CFStringRef XCFStringCreateWithBytesNoCopy(const __CFAllocator *a1, const UInt8 *a2, CFIndex a3, CFStringEncoding a4, Boolean a5, const __CFAllocator *a6)
{
  if ((const __CFAllocator *)*MEMORY[0x1E4F1CF90] != a6 && *MEMORY[0x1E4F1CFA0] != (void)a6) {
    XCFStringCreateWithBytesNoCopy_cold_1();
  }
  return CFStringCreateWithBytesNoCopy(a1, a2, a3, a4, a5, a6);
}

CFDataRef XCFDataCreateWithBytesNoCopy(const __CFAllocator *a1, const UInt8 *a2, CFIndex a3, const __CFAllocator *a4)
{
  if ((const __CFAllocator *)*MEMORY[0x1E4F1CF90] != a4 && *MEMORY[0x1E4F1CFA0] != (void)a4) {
    XCFDataCreateWithBytesNoCopy_cold_1();
  }
  return CFDataCreateWithBytesNoCopy(a1, a2, a3, a4);
}

uint64_t mmcs_read_stream_pool_create(void *a1, const void *a2, int a3, unsigned int a4, double a5)
{
  *a1 = 0;
  uint64_t v10 = C3TypeRegister(&mmcs_read_stream_poolGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v10, 0x68uLL);
  if (result)
  {
    uint64_t v12 = (const void *)result;
    if (mmcs_read_stream_pool_init(result, a2, a3, a4, a5))
    {
      *a1 = v12;
      return 1;
    }
    else
    {
      C3BaseRelease(v12);
      return 0;
    }
  }
  return result;
}

uint64_t mmcs_read_stream_pool_init(uint64_t a1, CFTypeRef cf, int a3, unsigned int a4, double a5)
{
  if (!a3) {
    return 0;
  }
  *(void *)(a1 + 16) = cf;
  if (cf) {
    CFRetain(cf);
  }
  *(_DWORD *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 28) = a4;
  *(double *)(a1 + 32) = a5;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  CFDictionaryValueCallBacks v11 = *(CFDictionaryValueCallBacks *)byte_1F363C9F0;
  uint64_t result = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], &v11);
  *(void *)(a1 + 104) = result;
  if (result)
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      return 1;
    }
    uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 80 * a4, 0x1000040B065FA3FuLL);
    *(void *)(a1 + 112) = result;
    if (result) {
      return 1;
    }
  }
  return result;
}

uint64_t mmcs_read_stream_pool_schedule(uint64_t a1, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  if (*(void *)(a1 + 40)) {
    return 0;
  }
  *(void *)(a1 + 40) = cf;
  C3BaseRetain(cf);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v9 = 0;
  long long v8 = (unint64_t)a1;
  uint64_t v10 = mmcs_read_stream_pool_discard_recycled_streams;
  uint64_t result = mmcs_perform_target_create_source(v4, a1 + 48, &v8, v5);
  if (result)
  {
    if (!*(void *)(a1 + 48)) {
      return 0;
    }
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v9 = 0;
    long long v8 = (unint64_t)a1;
    uint64_t v10 = mmcs_read_stream_pool_gc_timer_fired;
    uint64_t result = mmcs_perform_target_create_timer(v7, a1 + 56, &v8, v6);
    if (result)
    {
      mmcs_read_stream_pool_update_gc_fire_date(a1, 0);
      return 1;
    }
  }
  return result;
}

void mmcs_read_stream_pool_discard_recycled_streams(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (gMMCS_DebugLevel >= 4)
  {
    uint64_t v2 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Pool %@ discarding recycled entries from source", *(void *)(a1 + 16));
      uint64_t v4 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v6 = v3;
        _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v3) {
        CFRelease(v3);
      }
    }
  }
  _mmcs_read_stream_pool_discard_recycled_streams(a1);
}

void mmcs_read_stream_pool_gc_timer_fired(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (gMMCS_DebugLevel >= 4)
  {
    CFStringRef v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Pool %@: discarding expired entries, discarding recycled entries, updating next fire date", *(void *)(a2 + 16));
      uint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v9 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  if (CFDictionaryGetCount(*(CFDictionaryRef *)(a2 + 104)) >= 1)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFArrayRef v7 = Mutable;
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(a2 + 104), (CFDictionaryApplierFunction)_add_name, Mutable);
      v11.unsigned int length = CFArrayGetCount(v7);
      v11.CFIndex location = 0;
      CFArrayApplyFunction(v7, v11, (CFArrayApplierFunction)_check_expired, (void *)a2);
      CFRelease(v7);
    }
  }
  _mmcs_read_stream_pool_discard_recycled_streams(a2);
  mmcs_read_stream_pool_update_gc_fire_date(a2, 1);
}

void mmcs_read_stream_pool_update_gc_fire_date(uint64_t a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 104)) <= 0
    && ((CFArrayRef v12 = *(const __CFArray **)(a1 + 64)) == 0 || CFArrayGetCount(v12) < 1)
    || (CFStringRef v4 = (uint64_t *)(a1 + 56), !*(void *)(a1 + 56)))
  {
    CFStringRef v4 = (uint64_t *)(a1 + 56);
    if (!*(void *)(a1 + 56)) {
      return;
    }
    if (gMMCS_DebugLevel < 4) {
      goto LABEL_21;
    }
    size_t v13 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_21;
    }
    CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Pool %@ setting next fire date to the distant future since there is no potential garbage.", *(void *)(a1 + 16));
    CFRange v11 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  double v6 = Current + 30.0;
  if (a2
    || ((double next_fire_date = mmcs_perform_timer_get_next_fire_date(*v4), next_fire_date >= Current)
      ? (BOOL v8 = next_fire_date <= v6)
      : (BOOL v8 = 0),
        !v8))
  {
    if (gMMCS_DebugLevel < 4) {
      goto LABEL_21;
    }
    CFStringRef v9 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_21;
    }
    CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Pool %@ setting next fire date %lf (%.3lf sec)", *(void *)(a1 + 16), Current + 30.0, v6 - Current);
    CFRange v11 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
LABEL_19:
      if (v10) {
        CFRelease(v10);
      }
LABEL_21:
      mmcs_perform_timer_set_next_fire_date(*v4);
      return;
    }
LABEL_18:
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v15 = v10;
    _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
    goto LABEL_19;
  }
}

uint64_t mmcs_read_stream_pool_close(void *a1)
{
  uint64_t v2 = a1[6];
  if (v2)
  {
    mmcs_perform_source_invalidate(v2);
    CFStringRef v3 = (const void *)a1[6];
    if (v3) {
      C3BaseRelease(v3);
    }
    a1[6] = 0;
  }
  uint64_t v4 = a1[7];
  if (v4)
  {
    mmcs_perform_timer_invalidate(v4);
    uint64_t v5 = (const void *)a1[7];
    if (v5) {
      C3BaseRelease(v5);
    }
    a1[7] = 0;
  }
  double v6 = (const void *)a1[5];
  if (v6) {
    C3BaseRelease(v6);
  }
  a1[5] = 0;
  return 1;
}

void _mmcs_read_stream_poolCFFinalize(uint64_t a1)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  mmcs_read_stream_pool_close((void *)a1);
  uint64_t v2 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 112))
    {
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      if (Mutable)
      {
        uint64_t v5 = Mutable;
        CFStringAppendFormat(Mutable, 0, @"=== Read Stream Pool %@ stats\n", *(void *)(a1 + 16));
        CFStringAppendFormat(v5, 0, @"\ttotal connections: %llu\n", *(void *)(a1 + 80));
        CFStringAppendFormat(v5, 0, @"\t   total requests: %llu\n", *(void *)(a1 + 88));
        unint64_t v6 = *(void *)(a1 + 80);
        if (v6) {
          CFStringAppendFormat(v5, 0, @"\t  reqs/connection: %.03lf\n", (double)*(unint64_t *)(a1 + 88) / (double)v6);
        }
        CFAllocatorRef alloc = v3;
        uint64_t v7 = *(unsigned int *)(a1 + 28);
        if (v7)
        {
          unsigned int v8 = 0;
          LODWORD(v9) = 0;
          LODWORD(v10) = 0;
          LODWORD(v11) = 0;
          LODWORD(v12) = 0;
          LODWORD(v13) = 0;
          LODWORD(v14) = 0;
          LODWORD(v15) = 0;
          uint64_t v16 = *(void *)(a1 + 112) + 40;
          double v17 = 0.0;
          double v18 = 0.0;
          double v19 = 0.0;
          double v20 = 0.0;
          do
          {
            v8 += *(_DWORD *)(v16 - 40);
            uint64_t v10 = (*(_DWORD *)(v16 - 36) + v10);
            uint64_t v12 = (*(_DWORD *)(v16 - 32) + v12);
            uint64_t v14 = (*(_DWORD *)(v16 - 28) + v14);
            uint64_t v15 = (*(_DWORD *)(v16 - 24) + v15);
            double v20 = v20 + *(double *)(v16 - 16);
            uint64_t v13 = (*(_DWORD *)(v16 - 8) + v13);
            double v19 = v19 + *(double *)v16;
            uint64_t v11 = (*(_DWORD *)(v16 + 8) + v11);
            double v18 = v18 + *(double *)(v16 + 16);
            uint64_t v9 = (*(_DWORD *)(v16 + 24) + v9);
            double v17 = v17 + *(double *)(v16 + 32);
            v16 += 80;
            --v7;
          }
          while (v7);
        }
        else
        {
          uint64_t v15 = 0;
          uint64_t v14 = 0;
          uint64_t v13 = 0;
          uint64_t v12 = 0;
          uint64_t v11 = 0;
          uint64_t v10 = 0;
          uint64_t v9 = 0;
          unsigned int v8 = 0;
          double v20 = 0.0;
          double v19 = 0.0;
          double v18 = 0.0;
          double v17 = 0.0;
        }
        CFStringAppendFormat(v5, 0, @"\t     still in use: %llu\n", *(void *)(a1 + 80) - v8);
        if (v10) {
          CFStringAppendFormat(v5, 0, @"\t          timeout: %u\n", v10);
        }
        uint64_t v21 = (v13 + v9 + v15 + v11);
        if (v12) {
          CFStringAppendFormat(v5, 0, @"\t           maxout: %u\n", v12);
        }
        if (v14) {
          CFStringAppendFormat(v5, 0, @"\t       excess out: %u\n", v14);
        }
        if (v21) {
          CFStringAppendFormat(v5, 0, @"\t      error total: %u\n", v21);
        }
        if (v13) {
          CFStringAppendFormat(v5, 0, @"\t       conn reset: %u (avg %.3lf sec remaining)\n", v13, v19 / (double)v13);
        }
        if (v11) {
          CFStringAppendFormat(v5, 0, @"\t        ssl error: %u (avg %.3lf sec remaining)\n", v11, v18 / (double)v11);
        }
        if (v15) {
          CFStringAppendFormat(v5, 0, @"\t     mmcs timeout: %u (avg %.3lf sec remaining)\n", v15, v20 / (double)v15);
        }
        if (v9) {
          CFStringAppendFormat(v5, 0, @"\t      other error: %u (avg %.3lf sec remaining)\n", v9, v17 / (double)v9);
        }
        unint64_t v22 = *(unsigned int *)(a1 + 28);
        if (v22)
        {
          uint64_t v23 = 72;
          unint64_t v24 = 1;
          do
          {
            uint64_t v25 = *(void *)(a1 + 112);
            uint64_t v26 = v25 + v23;
            if (*(_DWORD *)(v25 + v23 - 72))
            {
              if (v24 == v22) {
                CFIndex v27 = "+";
              }
              else {
                CFIndex v27 = "";
              }
              CFStringAppendFormat(v5, 0, @"\n\t  times used: %u%s\n", v24, v27);
              CFStringAppendFormat(v5, 0, @"\t       total: %u\n", *(unsigned int *)(v26 - 72));
              if (*(_DWORD *)(v26 - 68)) {
                CFStringAppendFormat(v5, 0, @"\t     timeout: %u\n", *(unsigned int *)(v26 - 68));
              }
              if (*(_DWORD *)(v25 + v23 - 64)) {
                CFStringAppendFormat(v5, 0, @"\t      maxout: %u\n", *(unsigned int *)(v25 + v23 - 64));
              }
              if (*(_DWORD *)(v25 + v23 - 60)) {
                CFStringAppendFormat(v5, 0, @"\t  excess out: %u\n", *(unsigned int *)(v25 + v23 - 60));
              }
              uint64_t v28 = v25 + v23;
              uint64_t v29 = *(unsigned int *)(v25 + v23 - 40);
              if (v29) {
                CFStringAppendFormat(v5, 0, @"\t  conn reset: %u (avg %.3lf sec remaining)\n", v29, *(double *)(v28 - 32) / (double)v29);
              }
              uint64_t v30 = *(unsigned int *)(v28 - 24);
              if (v30) {
                CFStringAppendFormat(v5, 0, @"\t   ssl error: %u (avg %.3lf sec remaining)\n", v30, *(double *)(v25 + v23 - 16) / (double)v30);
              }
              uint64_t v31 = v25 + v23;
              uint64_t v32 = *(unsigned int *)(v25 + v23 - 56);
              if (v32) {
                CFStringAppendFormat(v5, 0, @"\tmmcs timeout: %u (avg %.3lf sec remaining)\n", v32, *(double *)(v31 - 48) / (double)v32);
              }
              uint64_t v33 = *(unsigned int *)(v31 - 8);
              if (v33) {
                CFStringAppendFormat(v5, 0, @"\t other error: %u (avg %.3lf sec remaining)\n", v33, *(double *)(v25 + v23) / (double)v33);
              }
            }
            unint64_t v22 = *(unsigned int *)(a1 + 28);
            v23 += 80;
          }
          while (v24++ < v22);
        }
        uint64_t v35 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v36 = CFStringCreateWithFormat(alloc, 0, @"%@", v5);
          uint64_t v37 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v44 = v36;
            _os_log_impl(&dword_1DC1CA000, v37, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
          }
          if (v36) {
            CFRelease(v36);
          }
        }
        CFRelease(v5);
      }
    }
  }
  uint64_t v38 = *(const void **)(a1 + 16);
  if (v38) {
    CFRelease(v38);
  }
  *(void *)(a1 + 16) = 0;
  CFDictionaryRef v39 = *(const __CFDictionary **)(a1 + 104);
  if (v39)
  {
    CFDictionaryApplyFunction(v39, (CFDictionaryApplierFunction)_close_http_session_entry, 0);
    uint64_t v40 = *(const void **)(a1 + 104);
    if (v40) {
      CFRelease(v40);
    }
    *(void *)(a1 + 104) = 0;
  }
  uint64_t v41 = *(void **)(a1 + 112);
  if (v41) {
    free(v41);
  }
  *(void *)(a1 + 112) = 0;
}

BOOL _mmcs_read_stream_poolCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_read_stream_poolCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_read_stream_poolCFCopyDebugDescription()
{
  return 0;
}

uint64_t _close_http_session_entry(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (gMMCS_DebugLevel >= 4)
  {
    CFAllocatorRef v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Entry with name '%@' closing because the pool is finalizing.", *(void *)(a2 + 32));
      uint64_t v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v8 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  return mmcs_http_session_pool_entry_close(a2);
}

void _mmcs_read_stream_pool_discard_recycled_streams(uint64_t a1)
{
  CFArrayRef v1 = *(const __CFArray **)(a1 + 96);
  if (v1)
  {
    v5.unsigned int length = CFArrayGetCount(*(CFArrayRef *)(a1 + 96));
    v5.CFIndex location = 0;
    CFArrayApplyFunction(v1, v5, (CFArrayApplierFunction)_close_read_stream, 0);
    CFAllocatorRef v3 = *(__CFArray **)(a1 + 96);
    CFArrayRemoveAllValues(v3);
  }
}

void _close_read_stream(CFReadStreamRef stream)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (gMMCS_DebugLevel >= 4)
  {
    uint64_t SocketNativeHandle = XCFReadStreamGetSocketNativeHandle(stream);
    CFAllocatorRef v3 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Closing read stream %p (socket %d)", stream, SocketNativeHandle);
      CFRange v5 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v7 = v4;
        _os_log_impl(&dword_1DC1CA000, v5, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  CFReadStreamClose(stream);
}

void _add_name(void *value, int a2, CFMutableArrayRef theArray)
{
}

void _check_expired(void *key, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Value = (double *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 104), key);
  if (Value)
  {
    CFStringRef v4 = Value;
    if (!*((_DWORD *)Value + 4))
    {
      CFAbsoluteTime v5 = Value[5] + 600.0;
      if (v5 < CFAbsoluteTimeGetCurrent())
      {
        if (gMMCS_DebugLevel >= 4)
        {
          unint64_t v6 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Entry with name '%@' expired.", *((void *)v4 + 4));
            uint64_t v8 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v11 = v7;
              _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v7) {
              CFRelease(v7);
            }
          }
        }
        mmcs_http_session_pool_entry_close(v4);
        if (*((void *)v4 + 4)) {
          uint64_t v9 = (const void *)*((void *)v4 + 4);
        }
        else {
          uint64_t v9 = (const void *)*MEMORY[0x1E4F1D260];
        }
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 104), v9);
      }
    }
  }
}

uint64_t mmcs_http_request_create_with_url(CFTypeRef *a1, const __CFURL *a2, const void *a3, CFErrorRef *a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (*a1)
  {
    uint64_t v8 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"stomping existing http request");
      uint64_t v10 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        int v25 = 138543362;
        CFStringRef v26 = v9;
        _os_log_impl(&dword_1DC1CA000, v10, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v25, 0xCu);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
    if (*a1) {
      C3BaseRelease(*a1);
    }
  }
  *a1 = 0;
  uint64_t v11 = C3TypeRegister(&mmcs_http_requestGetTypeID_typeID);
  uint64_t Instance = C3TypeCreateInstance_(0, v11, 0x30uLL);
  if (!Instance)
  {
    CFStringRef v21 = @"mmcs_http_request";
LABEL_14:
    CFErrorRef v22 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, v21, v12, v13, v14, v15, v16, v25);
    CFErrorRef v23 = v22;
    if (a4 && v22)
    {
      CFRetain(v22);
      *a4 = v23;
    }
    else if (!v22)
    {
      goto LABEL_19;
    }
    CFRelease(v23);
LABEL_19:
    uint64_t v20 = 0;
    uint64_t result = 0;
    if (!Instance) {
      return result;
    }
    goto LABEL_20;
  }
  CFHTTPMessageRef Request = CFHTTPMessageCreateRequest((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"GET", a2, (CFStringRef)*MEMORY[0x1E4F18F90]);
  if (!Request)
  {
    CFStringRef v21 = @"mmcs_http_request msg";
    goto LABEL_14;
  }
  CFHTTPMessageRef v19 = Request;
  *(void *)(Instance + 16) = Request;
  CFRetain(Request);
  *(void *)(Instance + 32) = @"fakeVendorName";
  CFRetain(@"fakeVendorName");
  mmcs_http_request_set_options(Instance, a3);
  *(void *)(Instance + 40) = 0;
  *(void *)(Instance + 48) = 0;
  *(unsigned char *)(Instance + 56) = 0;
  C3BaseRetain((CFTypeRef)Instance);
  *a1 = (CFTypeRef)Instance;
  CFRelease(v19);
  uint64_t v20 = 1;
LABEL_20:
  C3BaseRelease((CFTypeRef)Instance);
  return v20;
}

void mmcs_http_request_init(uint64_t a1, CFTypeRef cf, const void *a3, char a4, uint64_t a5, const void *a6, void *a7, double a8)
{
  if (a7) {
    *a7 = 0;
  }
  *(void *)(a1 + 16) = cf;
  CFRetain(cf);
  *(void *)(a1 + 32) = a6;
  if (a6) {
    CFRetain(a6);
  }
  mmcs_http_request_set_options(a1, a3);
  *(double *)(a1 + 40) = a8;
  *(void *)(a1 + 48) = a5;
  *(unsigned char *)(a1 + 56) = a4;
}

uint64_t mmcs_http_request_create_with_host_info(CFTypeRef *a1, uint64_t a2, const void *a3, int a4, CFErrorRef *a5)
{
  CFStringRef v9 = a1;
  uint64_t v201 = *MEMORY[0x1E4F143B8];
  if (*a1)
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"stomping existing http request");
      uint64_t v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        uint64_t v200 = (void *)v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
    if (*v9) {
      C3BaseRelease(*v9);
    }
  }
  *CFStringRef v9 = 0;
  uint64_t v13 = C3TypeRegister(&mmcs_http_requestGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v13, 0x30uLL);
  if (result)
  {
    uint64_t v15 = (const void *)result;
    __s = 0;
    if (a5) {
      *a5 = 0;
    }
    BOOL v16 = _validate_string(*(char **)(a2 + 24), (uint64_t)"hostInfo->hostname");
    int v17 = _validate_string(*(char **)(a2 + 40), (uint64_t)"hostInfo->method") && v16;
    BOOL v18 = _validate_string(*(char **)(a2 + 48), (uint64_t)"hostInfo->uri");
    int v19 = v17 & v18 & _validate_string(*(char **)(a2 + 56), (uint64_t)"hostInfo->transport_protocol");
    BOOL v20 = _validate_string(*(char **)(a2 + 64), (uint64_t)"hostInfo->transport_protocol_version");
    CFTypeRef v197 = a5;
    if ((v19 & v20 & _validate_string(*(char **)(a2 + 72), (uint64_t)"hostInfo->scheme")) == 0)
    {
      CFErrorRef v34 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Invalid host_info", v21, v22, v23, v24, v25, v185);
LABEL_21:
      CFErrorRef v35 = v34;
      goto LABEL_22;
    }
    if (strcmp(*(const char **)(a2 + 56), "HTTP"))
    {
      CFStringRef v26 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v32 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Expected transport protocol to be HTTP, not %s", *(void *)(a2 + 56));
        uint64_t v33 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          uint64_t v200 = (void *)v32;
          _os_log_impl(&dword_1DC1CA000, v33, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v32) {
          CFRelease(v32);
        }
      }
      CFErrorRef v34 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"Expected transport protocol to be HTTP, not %s", v27, v28, v29, v30, v31, *(void *)(a2 + 56));
      goto LABEL_21;
    }
    CFAllocatorRef v53 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    size_t v54 = strlen(*(const char **)(a2 + 40));
    CFStringRef v55 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(const UInt8 **)(a2 + 40), v54, 0x8000100u, 0);
    if (!v55)
    {
      size_t v61 = strlen(*(const char **)(a2 + 40));
      uint64_t v41 = hextostrdup(*(char **)(a2 + 40), v61);
      CFErrorRef v35 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"Method string could not be created with \"%s\" 0x%s", v62, v63, v64, v65, v66, *(void *)(a2 + 40));
      if (!v41)
      {
        CFStringRef v36 = 0;
        CFStringRef v37 = 0;
        CFURLRef v38 = 0;
        CFURLRef v39 = 0;
        CFStringRef v40 = 0;
        goto LABEL_23;
      }
      free(v41);
LABEL_22:
      CFStringRef v36 = 0;
      CFStringRef v37 = 0;
      CFURLRef v38 = 0;
      CFURLRef v39 = 0;
      CFStringRef v40 = 0;
      LODWORD(v41) = 0;
LABEL_23:
      int v42 = 1;
      goto LABEL_24;
    }
    CFStringRef v56 = v55;
    size_t v57 = strlen(*(const char **)(a2 + 48));
    CFStringRef v58 = CFStringCreateWithBytes(v53, *(const UInt8 **)(a2 + 48), v57, 0x8000100u, 0);
    if (!v58)
    {
      size_t v67 = strlen(*(const char **)(a2 + 48));
      long long v68 = hextostrdup(*(char **)(a2 + 48), v67);
      CFErrorRef v35 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"URI string could not be created with \"%s\" 0x%s", v69, v70, v71, v72, v73, *(void *)(a2 + 48));
      if (v68) {
        free(v68);
      }
      CFRelease(v56);
      goto LABEL_22;
    }
    CFStringRef v59 = v58;
    CFStringRef v193 = v58;
    CFStringRef cf = v56;
    if (a4) {
      int v60 = asprintf(&__s, "%s://%s:%u/", "http", *(const char **)(a2 + 24), 80);
    }
    else {
      int v60 = asprintf(&__s, "%s://%s:%u/", *(const char **)(a2 + 72), *(const char **)(a2 + 24), *(_DWORD *)(a2 + 32));
    }
    if (v60 < 0)
    {
      uint64_t v90 = __error();
      char v91 = strerror(*v90);
      __error();
      CFErrorRef v35 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"asprintf error %s(%d)", v92, v93, v94, v95, v96, v91);
    }
    else
    {
      size_t v74 = strlen(__s);
      CFStringRef v75 = CFStringCreateWithBytes(v53, (const UInt8 *)__s, v74, 0x8000100u, 0);
      if (v75)
      {
        CFStringRef v76 = v75;
        v192 = a3;
        if (__s)
        {
          CFStringRef v77 = v75;
          free(__s);
          CFStringRef v76 = v77;
        }
        __s = 0;
        CFStringRef v196 = v76;
        CFURLRef v78 = CFURLCreateWithString(v53, v76, 0);
        if (v78)
        {
          CFURLRef v39 = v78;
          CFURLRef v79 = CFURLCreateWithString(v53, v59, v78);
          if (!v79)
          {
            uint64_t v115 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v121 = CFStringCreateWithFormat(v53, 0, @"url could not be created with uri %@ baseURL %@", v59, v39);
              uint64_t v122 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                uint64_t v200 = (void *)v121;
                _os_log_impl(&dword_1DC1CA000, v122, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v121) {
                CFRelease(v121);
              }
            }
            CFErrorRef v35 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"url could not be created with uri %@ baseURL %@", v116, v117, v118, v119, v120, (char)v59);
            CFStringRef v36 = 0;
            CFStringRef theString2 = 0;
            CFURLRef v38 = 0;
            goto LABEL_93;
          }
          CFURLRef v38 = v79;
          if (asprintf(&__s, "%s/%s", *(const char **)(a2 + 56), *(const char **)(a2 + 64)) < 0)
          {
            uint64_t v123 = __error();
            char v124 = strerror(*v123);
            __error();
            CFErrorRef v35 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"asprintf error %s(%d)", v125, v126, v127, v128, v129, v124);
          }
          else
          {
            size_t v80 = strlen(__s);
            CFStringRef theString2 = CFStringCreateWithBytes(v53, (const UInt8 *)__s, v80, 0x8000100u, 0);
            if (theString2)
            {
              if (__s) {
                free(__s);
              }
              __s = 0;
              if (CFStringCompare((CFStringRef)*MEMORY[0x1E4F18F88], theString2, 0)
                && CFStringCompare((CFStringRef)*MEMORY[0x1E4F18F90], theString2, 0))
              {
                long long v81 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
                {
                  CFStringRef v87 = CFStringCreateWithFormat(v53, 0, @"version string invalid %@", theString2);
                  CFIndex v88 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long buf = 138543362;
                    uint64_t v200 = (void *)v87;
                    _os_log_impl(&dword_1DC1CA000, v88, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
                  }
                  if (v87) {
                    CFRelease(v87);
                  }
                }
                CFErrorRef v89 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"version string invalid %@", v82, v83, v84, v85, v86, (char)theString2);
LABEL_131:
                CFErrorRef v35 = v89;
                CFStringRef v36 = 0;
                goto LABEL_93;
              }
              CFHTTPMessageRef Request = CFHTTPMessageCreateRequest(v53, cf, v38, theString2);
              if (!Request)
              {
                unint64_t v152 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
                {
                  CFStringRef v158 = CFStringCreateWithFormat(v53, 0, @"msg could not be created with method %@ url %@ version %@", cf, v38, theString2);
                  CFTypeRef v159 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long buf = 138543362;
                    uint64_t v200 = (void *)v158;
                    _os_log_impl(&dword_1DC1CA000, v159, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
                  }
                  if (v158) {
                    CFRelease(v158);
                  }
                }
                CFErrorRef v89 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"msg could not be created with method %@ url %@ version %@", v153, v154, v155, v156, v157, (char)cf);
                goto LABEL_131;
              }
              message = Request;
              if (*(_DWORD *)(a2 + 112))
              {
                double v131 = mmcs_time_convert_server_time_to_cfabsolutetime(*(void *)(a2 + 120));
                CFStringRef String = XCFAbsoluteTimeDateFormatterCreateString(v131);
                uint64_t v133 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v186 = *(void *)(a2 + 120);
                  CFStringRef v134 = CFStringCreateWithFormat(v53, 0, @"received url expiry %lld (%@) from the server");
                  CFStringRef v135 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v135, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)long long buf = 138543362;
                    uint64_t v200 = (void *)v134;
                    _os_log_impl(&dword_1DC1CA000, v135, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                  }
                  if (v134) {
                    CFRelease(v134);
                  }
                }
                if (String) {
                  CFRelease(String);
                }
                if (v131 >= CFAbsoluteTimeGetCurrent() + 120.0)
                {
                  double v137 = v131;
                  goto LABEL_140;
                }
                uint64_t v136 = mmcs_logging_logger_default();
                double v137 = 0.0;
                if (!os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_140;
                }
                LOBYTE(v186) = LOBYTE(v131);
                CFStringRef v138 = CFStringCreateWithFormat(v53, 0, @"invalid url expiry within 2 minutes of wall clock received: %f (server value %llu). ignoring value.");
                uint64_t v139 = mmcs_logging_logger_default();
                if (!os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
                {
LABEL_137:
                  if (v138) {
                    CFRelease(v138);
                  }
LABEL_140:
                  if (*(_DWORD *)(a2 + 136))
                  {
                    unint64_t v162 = *(void *)(a2 + 144);
                    if (v162)
                    {
                      long long v165 = mmcs_logging_logger_default();
                      if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_impl(&dword_1DC1CA000, v165, OS_LOG_TYPE_ERROR, "PutCompleteAtEdge V1 Requested By Server, Not Supported by Client", buf, 2u);
                      }
                      CFErrorRef v35 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 6, @"PutCompleteAtEdge V1 Requested By Server, Not Supported by Client", v166, v167, v168, v169, v170, v186);
                      CFStringRef v36 = 0;
                      int v171 = 0;
                      int v42 = 1;
                      uint64_t v41 = message;
                      goto LABEL_174;
                    }
                    uint64_t v188 = *(void *)(a2 + 144) & 2;
                    uint64_t v190 = (v162 >> 1) & 1;
                  }
                  else
                  {
                    LODWORD(v190) = 0;
                    uint64_t v188 = 0;
                  }
                  long long v163 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
                  {
                    CFStringRef v164 = "Disabled";
                    if (v190) {
                      CFStringRef v164 = "V2";
                    }
                    *(_DWORD *)long long buf = 136446210;
                    uint64_t v200 = (void *)v164;
                    _os_log_impl(&dword_1DC1CA000, v163, OS_LOG_TYPE_DEFAULT, "PutComplete at Edge Protocol : %{public}s", buf, 0xCu);
                  }
                  CFAllocatorRef alloc = v53;
                  if (*(_DWORD *)(a2 + 136)) {
                    int v187 = (*(unsigned __int8 *)(a2 + 144) >> 3) & 1;
                  }
                  else {
                    LOBYTE(v187) = 0;
                  }
                  if (*(void *)(a2 + 80))
                  {
                    unint64_t v172 = 0;
                    do
                    {
                      uint64_t v173 = *(void *)(*(void *)(a2 + 88) + 8 * v172);
                      size_t v174 = strlen(*(const char **)(v173 + 24));
                      CFStringRef v175 = CFStringCreateWithBytes(alloc, *(const UInt8 **)(v173 + 24), v174, 0x8000100u, 0);
                      uint64_t v176 = *(const char **)(v173 + 32);
                      size_t v177 = strlen(v176);
                      CFStringRef v178 = CFStringCreateWithBytes(alloc, (const UInt8 *)v176, v177, 0x8000100u, 0);
                      if (CFStringCompare(@"Content-Length", v175, 1uLL)) {
                        char v179 = 0;
                      }
                      else {
                        char v179 = v190;
                      }
                      if ((v179 & 1) == 0) {
                        CFHTTPMessageSetHeaderFieldValue(message, v175, v178);
                      }
                      if (v175) {
                        CFRelease(v175);
                      }
                      if (v178) {
                        CFRelease(v178);
                      }
                      ++v172;
                    }
                    while (v172 < *(void *)(a2 + 80));
                  }
                  uint64_t v180 = *(const UInt8 **)(a2 + 96);
                  if (v180)
                  {
                    size_t v181 = strlen(*(const char **)(a2 + 96));
                    CFStringRef v36 = CFStringCreateWithBytes(alloc, v180, v181, 0x8000100u, 0);
                    uint64_t v182 = mmcs_logging_logger_default();
                    if (os_log_type_enabled(v182, OS_LOG_TYPE_DEBUG))
                    {
                      CFStringRef v183 = CFStringCreateWithFormat(alloc, 0, @"ContentVendor %@", v36);
                      uint64_t v184 = mmcs_logging_logger_default();
                      if (os_log_type_enabled(v184, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)long long buf = 138543362;
                        uint64_t v200 = (void *)v183;
                        _os_log_impl(&dword_1DC1CA000, v184, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
                      }
                      if (v183) {
                        CFRelease(v183);
                      }
                    }
                  }
                  else
                  {
                    CFStringRef v36 = 0;
                  }
                  uint64_t v41 = message;
                  mmcs_http_request_init((uint64_t)v15, message, v192, v187, v188, v36, a5, v137);
                  CFErrorRef v35 = 0;
                  int v42 = 0;
                  int v171 = 1;
LABEL_174:
                  CFRelease(v41);
                  LODWORD(v41) = v171;
                  goto LABEL_95;
                }
                *(_DWORD *)long long buf = 138543362;
                uint64_t v200 = (void *)v138;
                uint64_t v140 = v139;
                os_log_type_t v141 = OS_LOG_TYPE_DEFAULT;
              }
              else
              {
                unint64_t v160 = mmcs_logging_logger_default();
                double v137 = 0.0;
                if (!os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_140;
                }
                LOBYTE(v186) = CFURLGetString(v38);
                CFStringRef v138 = CFStringCreateWithFormat(v53, 0, @"url %@ does not have url expiry");
                unint64_t v161 = mmcs_logging_logger_default();
                if (!os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_137;
                }
                *(_DWORD *)long long buf = 138543362;
                uint64_t v200 = (void *)v138;
                uint64_t v140 = v161;
                os_log_type_t v141 = OS_LOG_TYPE_DEBUG;
              }
              _os_log_impl(&dword_1DC1CA000, v140, v141, "%{public}@", buf, 0xCu);
              goto LABEL_137;
            }
            CFAllocatorRef v142 = v53;
            size_t v143 = strlen(__s);
            uint64_t v41 = hextostrdup(__s, v143);
            uint64_t v144 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR))
            {
              CFStringRef v150 = CFStringCreateWithFormat(v142, 0, @"version could not be created with \"%s\" 0x%s", __s, v41);
              uint64_t v151 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                uint64_t v200 = (void *)v150;
                _os_log_impl(&dword_1DC1CA000, v151, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
              }
              if (v150) {
                CFRelease(v150);
              }
            }
            CFErrorRef v35 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"version string could not be created with \"%s\" 0x%s", v145, v146, v147, v148, v149, (char)__s);
            if (!v41)
            {
              CFStringRef v36 = 0;
              CFStringRef theString2 = 0;
              goto LABEL_94;
            }
            free(v41);
          }
          CFStringRef v36 = 0;
          CFStringRef theString2 = 0;
LABEL_93:
          LODWORD(v41) = 0;
LABEL_94:
          int v42 = 1;
LABEL_95:
          CFRelease(cf);
          CFRelease(v193);
          CFStringRef v37 = theString2;
          CFStringRef v40 = v196;
LABEL_24:
          if (__s)
          {
            uint64_t v43 = v35;
            CFStringRef v44 = v36;
            int v45 = v42;
            int v46 = (int)v41;
            uint64_t v41 = v9;
            CFStringRef v47 = v37;
            CFURLRef v48 = v38;
            uint64_t v49 = v15;
            CFURLRef v50 = v39;
            CFStringRef v51 = v40;
            free(__s);
            CFStringRef v40 = v51;
            CFURLRef v39 = v50;
            uint64_t v15 = v49;
            CFURLRef v38 = v48;
            CFStringRef v37 = v47;
            CFStringRef v9 = (CFTypeRef *)v41;
            LODWORD(v41) = v46;
            int v42 = v45;
            CFStringRef v36 = v44;
            CFErrorRef v35 = v43;
          }
          __s = 0;
          if (v40) {
            CFRelease(v40);
          }
          if (v39) {
            CFRelease(v39);
          }
          if (v38) {
            CFRelease(v38);
          }
          if (v37) {
            CFRelease(v37);
          }
          if (v36) {
            CFRelease(v36);
          }
          if (v35) {
            int v52 = v42;
          }
          else {
            int v52 = 0;
          }
          if (v197 && v52)
          {
            CFErrorRef *v197 = v35;
            CFRetain(v35);
          }
          else if (!v35)
          {
            goto LABEL_44;
          }
          CFRelease(v35);
LABEL_44:
          if (v41)
          {
            *CFStringRef v9 = v15;
            return 1;
          }
          else
          {
            C3BaseRelease(v15);
            return 0;
          }
        }
        uint64_t v107 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v113 = CFStringCreateWithFormat(v53, 0, @"baseUrl could not be created with %@", v196);
          CFStringRef v114 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            uint64_t v200 = (void *)v113;
            _os_log_impl(&dword_1DC1CA000, v114, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
          }
          if (v113) {
            CFRelease(v113);
          }
        }
        CFErrorRef v35 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"baseUrl could not be created with %@", v108, v109, v110, v111, v112, (char)v196);
        CFStringRef v36 = 0;
        CFStringRef theString2 = 0;
LABEL_92:
        CFURLRef v38 = 0;
        CFURLRef v39 = 0;
        goto LABEL_93;
      }
      CFAllocatorRef v97 = v53;
      size_t v98 = strlen(__s);
      uint64_t v41 = hextostrdup(__s, v98);
      uint64_t v99 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v105 = CFStringCreateWithFormat(v97, 0, @"urlString could not be created with  \"%s\" 0x%s ", __s, v41);
        uint64_t v106 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          uint64_t v200 = (void *)v105;
          _os_log_impl(&dword_1DC1CA000, v106, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
        }
        if (v105) {
          CFRelease(v105);
        }
      }
      CFErrorRef v35 = mmcs_cferror_create_with_format(@"com.apple.mmcs", 37, @"URL string could not be created with \"%s\" 0x%s", v100, v101, v102, v103, v104, (char)__s);
      if (!v41)
      {
        CFStringRef v36 = 0;
        CFStringRef theString2 = 0;
        CFStringRef v196 = 0;
        CFURLRef v38 = 0;
        CFURLRef v39 = 0;
        goto LABEL_94;
      }
      free(v41);
    }
    CFStringRef v36 = 0;
    CFStringRef theString2 = 0;
    CFStringRef v196 = 0;
    goto LABEL_92;
  }
  return result;
}

uint64_t mmcs_http_request_copy(void *a1, void *a2)
{
  if (!a1) {
    mmcs_http_request_copy_cold_1();
  }
  if (!a2) {
    mmcs_http_request_copy_cold_2();
  }
  *a1 = 0;
  uint64_t v4 = C3TypeRegister(&mmcs_http_requestGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v4, 0x30uLL);
  if (result)
  {
    unint64_t v6 = (void *)result;
    CFStringRef v7 = (const void *)a2[2];
    long long v6[2] = v7;
    if (v7) {
      CFRetain(v7);
    }
    uint64_t v8 = (const void *)a2[3];
    v6[3] = v8;
    if (v8) {
      C3BaseRetain(v8);
    }
    CFStringRef v9 = (const void *)a2[4];
    v6[4] = v9;
    if (v9) {
      CFRetain(v9);
    }
    v6[5] = a2[5];
    unsigned int v6[6] = a2[6];
    *a1 = v6;
    return 1;
  }
  return result;
}

CFStringRef mmcs_http_request_copy_description(uint64_t a1)
{
  CFURLRef v1 = CFHTTPMessageCopyRequestURL(*(CFHTTPMessageRef *)(a1 + 16));
  if (!v1) {
    return 0;
  }
  CFURLRef v2 = v1;
  CFStringRef v3 = CFURLGetString(v1);
  if (v3) {
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@", v3);
  }
  else {
    CFStringRef v4 = 0;
  }
  CFRelease(v2);
  return v4;
}

void mmcs_http_request_override_url_expiry(uint64_t a1, int a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  double v3 = CFAbsoluteTimeGetCurrent() + (double)a2;
  CFStringRef String = XCFAbsoluteTimeDateFormatterCreateString(v3);
  CFAbsoluteTime v5 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"overriding url expiry for http request %p with %@", a1, String);
    CFStringRef v7 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v9 = v6;
      _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
    }
    if (v6) {
      CFRelease(v6);
    }
  }
  if (String) {
    CFRelease(String);
  }
  *(double *)(a1 + 40) = v3;
}

void mmcs_http_request_make_request_requirements(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double v3 = *(__CFHTTPMessage **)(a1 + 16);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  CFStringRef v4 = CFHTTPMessageCopyHeaderFieldValue(v3, @"com.apple.mmcs.datacenter.name");
  if (v4)
  {
    CFStringRef v5 = v4;
    CFDictionaryRef v6 = (const __CFDictionary *)mmcs_report_copy_vendor_configuration_with_name(v4);
    if (v6)
    {
      CFDictionaryRef v7 = v6;
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v6, @"throughput.min");
      if (Value)
      {
        CFDictionaryRef v9 = Value;
        CFTypeID TypeID = CFDictionaryGetTypeID();
        if (TypeID == CFGetTypeID(v9))
        {
          CFStringRef v11 = CFDictionaryGetValue(v9, @"in.seconds");
          if (v11)
          {
            CFTypeID v12 = CFNumberGetTypeID();
            if (v12 != CFGetTypeID(v11)) {
              CFStringRef v11 = 0;
            }
          }
          uint64_t v13 = CFDictionaryGetValue(v9, @"num.bytes");
          if (v13)
          {
            uint64_t v14 = v13;
            CFTypeID v15 = CFNumberGetTypeID();
            CFTypeID v16 = CFGetTypeID(v14);
            if (v15 != v16) {
              uint64_t v14 = 0;
            }
            if (v11)
            {
              if (v15 == v16)
              {
                uint64_t valuePtr = 0;
                if (CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt32Type, (char *)&valuePtr + 4))
                {
                  if (CFNumberGetValue((CFNumberRef)v14, kCFNumberSInt32Type, &valuePtr))
                  {
                    *(double *)a2 = (double)SHIDWORD(valuePtr);
                    *(_DWORD *)(a2 + 8) = valuePtr;
                  }
                }
              }
            }
          }
        }
      }
      CFRelease(v7);
    }
    CFRelease(v5);
  }
}

BOOL mmcs_http_request_is_put_complete_at_edge_protocol_v2(uint64_t a1)
{
  return *(void *)(a1 + 48) == 2;
}

void mmcs_http_request_set_options(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 24);
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v3 = *(CFTypeRef *)(a1 + 24);
    }
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 24) = cf;
  }
}

void mmcs_http_request_set_msg(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 16);
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v3 = *(CFTypeRef *)(a1 + 16);
    }
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 16) = cf;
  }
}

void _mmcs_http_requestCFFinalize(void *a1)
{
  a1[5] = 0;
  CFURLRef v2 = (const void *)a1[4];
  if (v2) {
    CFRelease(v2);
  }
  a1[4] = 0;
  CFTypeRef v3 = (const void *)a1[2];
  if (v3) {
    CFRelease(v3);
  }
  a1[2] = 0;
  CFStringRef v4 = (const void *)a1[3];
  if (v4) {
    C3BaseRelease(v4);
  }
  a1[3] = 0;
}

BOOL _mmcs_http_requestCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_http_requestCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_http_requestCFCopyDebugDescription()
{
  return 0;
}

BOOL _validate_string(char *a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v10 = mmcs_logging_logger_default();
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"NULL %s", a2);
    CFTypeID v12 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v15 = v11;
    goto LABEL_19;
  }
  size_t v4 = strlen(a1);
  if (v4)
  {
    if (gMMCS_DebugLevel >= 5)
    {
      CFStringRef v5 = hextostrdup(a1, v4);
      if (gMMCS_DebugLevel >= 5)
      {
        CFDictionaryRef v6 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s is \"%s\" 0x%s", a2, a1, v5);
          uint64_t v8 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v15 = v7;
            _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v7) {
            CFRelease(v7);
          }
        }
      }
      if (v5) {
        free(v5);
      }
    }
    return 1;
  }
  uint64_t v13 = mmcs_logging_logger_default();
  BOOL result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  if (!result) {
    return result;
  }
  CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s is empty string", a2);
  CFTypeID v12 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138543362;
    CFStringRef v15 = v11;
LABEL_19:
    _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
  }
LABEL_20:
  if (v11) {
    CFRelease(v11);
  }
  return 0;
}

BOOL mmcs_zcmp(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x40)
  {
    uint64_t v2 = 0;
    while (1)
    {
      uint8x16_t v3 = (uint8x16_t)vorrq_s8(vorrq_s8(*(int8x16_t *)(a1 + v2 + 16), *(int8x16_t *)(a1 + v2)), vorrq_s8(*(int8x16_t *)(a1 + v2 + 32), *(int8x16_t *)(a1 + v2 + 48)));
      v3.i8[0] = vmaxvq_u8(v3);
      if (v3.i32[0]) {
        return 0;
      }
      unint64_t v4 = v2 + 64;
      unint64_t v5 = v2 + 127;
      v2 += 64;
      if (v5 >= a2) {
        goto LABEL_7;
      }
    }
  }
  unint64_t v4 = 0;
LABEL_7:
  if ((v4 | 0x1F) < a2)
  {
    uint8x16_t v6 = (uint8x16_t)vorrq_s8(*(int8x16_t *)(a1 + (v4 | 0x10)), *(int8x16_t *)(a1 + v4));
    v6.i8[0] = vmaxvq_u8(v6);
    if (v6.i32[0]) {
      return 0;
    }
    v4 |= 0x20uLL;
  }
  if (v4 + 15 >= a2) {
    goto LABEL_13;
  }
  uint8x16_t v7 = *(uint8x16_t *)(a1 + v4);
  v7.i8[0] = vmaxvq_u8(v7);
  if (v7.i32[0]) {
    return 0;
  }
  v4 += 16;
LABEL_13:
  if (v4 + 7 < a2)
  {
    uint8x8_t v8 = *(uint8x8_t *)(a1 + v4);
    v8.i8[0] = vmaxv_u8(v8);
    if (v8.i32[0]) {
      return 0;
    }
    v4 += 8;
  }
  if (v4 >= a2) {
    return 1;
  }
  unint64_t v10 = ~v4 + a2;
  CFStringRef v11 = (unsigned __int8 *)(a1 + v4);
  do
  {
    int v13 = *v11++;
    int v12 = v13;
    BOOL result = v13 == 0;
    BOOL v14 = v10-- != 0;
  }
  while (v14 && !v12);
  return result;
}

uint64_t mmcs_request_queue_set_test_max_requests_inflight(uint64_t a1, uint64_t a2)
{
  if (a2 < 1) {
    return 0;
  }
  *(_DWORD *)(a1 + 1480) = a2;
  return 1;
}

uint64_t mmcs_request_queue_set_test_max_consecutive_network_errors(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    return 0;
  }
  *(_DWORD *)(a1 + 1296) = a2;
  return 1;
}

uint64_t mmcs_request_queue_set_test_requests_inflight(uint64_t a1, uint64_t a2, int a3)
{
  if (a2 < 1) {
    return 0;
  }
  int v3 = a2;
  uint64_t v5 = 0;
  BOOL v6 = a3 == 0;
  do
  {
    uint64_t v7 = a1 + 4 * mmcs_request_type_for_behavior_and_activity(v5, v6);
    *(_DWORD *)(v7 + 144) = v3;
    *(_DWORD *)(v7 + 1484) = v3;
    ++v5;
  }
  while (v5 != 5);
  return 1;
}

uint64_t mmcs_request_queue_set_server_upper_bound_requests_inflight(uint64_t a1, uint64_t a2, int a3)
{
  if ((unint64_t)(a2 - 1) > 0x13) {
    return 0;
  }
  int v3 = a2;
  uint64_t v5 = 0;
  BOOL v6 = a3 == 0;
  do
    *(_DWORD *)(a1 + 4 * mmcs_request_type_for_behavior_and_activity(v5++, v6) + 1484) = v3;
  while (v5 != 5);
  return 1;
}

uint64_t mmcs_request_queue_create(void *a1)
{
  *a1 = 0;
  uint64_t v2 = C3TypeRegister(&mmcs_request_queueGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v2, 0x5F8uLL);
  if (result)
  {
    unint64_t v4 = (const void *)result;
    if (mmcs_request_queue_init(result))
    {
      *a1 = v4;
      return 1;
    }
    else
    {
      C3BaseRelease(v4);
      return 0;
    }
  }
  return result;
}

BOOL mmcs_request_queue_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 1480) = 20;
  *(void *)(a1 + 1472) = 0;
  *(_DWORD *)(a1 + 1304) = 0;
  *(void *)(a1 + 1296) = 3;
  *(_DWORD *)(a1 + 1528) = mmcs_get_cfindex_from_options(@"throughput.bytesPerPeriod", 0, 3750000);
  uint64_t v2 = 0;
  *(double *)(a1 + 1536) = (double)mmcs_get_cfindex_from_options(@"throughput.period", 0, 30);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v4 = 1392;
  long long v11 = xmmword_1F363CA28;
  long long v12 = xmmword_1F363CA18;
  uint64_t v5 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))off_1F363CA38;
  while (1)
  {
    BOOL v6 = (_DWORD *)(a1 + 4 * v2);
    v6[26] = 0;
    v6[36] = mmcs_request_queue_max_requests_inflight_for_request_type(v2);
    v6[371] = mmcs_request_queue_max_requests_inflight_for_request_type(v2);
    *(_OWORD *)&callBacks.version = v12;
    *(_OWORD *)&callBacks.release = v11;
    callBacks.compare = v5;
    uint64_t v7 = a1 + 8 * v2;
    *(void *)(v7 + 16) = CFBinaryHeapCreate(v3, 0, &callBacks, 0);
    *(void *)(a1 + v4 - 80) = malloc_type_calloc(1uLL, 0x54uLL, 0x100004052888210uLL);
    uint8x8_t v8 = malloc_type_calloc(1uLL, 0x54uLL, 0x100004052888210uLL);
    *(void *)(a1 + v4) = v8;
    if (!*(void *)(v7 + 16) || !*(void *)(a1 + v4 - 80) || !v8) {
      break;
    }
    ++v2;
    v4 += 8;
    if (v2 == 10)
    {
      CFDictionaryValueCallBacks valueCallBacks = *(CFDictionaryValueCallBacks *)byte_1F363CA40;
      CFMutableDictionaryRef v9 = CFDictionaryCreateMutable(v3, 0, 0, &valueCallBacks);
      *(void *)(a1 + 96) = v9;
      return v9 != 0;
    }
  }
  return 0;
}

uint64_t mmcs_request_queue_max_requests_inflight_for_request_type(uint64_t a1)
{
  uint64_t activity_type = mmcs_request_type_get_activity_type(a1);
  if (activity_type == 1)
  {
    unint64_t behavior_type = mmcs_request_type_get_behavior_type(a1);
    if (behavior_type >= 5) {
      mmcs_request_queue_max_requests_inflight_for_request_type_cold_3();
    }
  }
  else
  {
    if (activity_type) {
      mmcs_request_queue_max_requests_inflight_for_request_type_cold_1();
    }
    unint64_t behavior_type = mmcs_request_type_get_behavior_type(a1);
    if (behavior_type >= 5) {
      mmcs_request_queue_max_requests_inflight_for_request_type_cold_2();
    }
  }
  return dword_1DC251F70[behavior_type];
}

uint64_t mmcs_request_queue_enqueue_request(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 96), *(const void **)(a2 + 8)))
  {
    BOOL v6 = mmcs_logging_logger_default();
    uint64_t result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (result)
    {
      CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"duplicate request object %p", *(void *)(a2 + 8));
      CFMutableDictionaryRef v9 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v8;
        _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v8) {
        CFRelease(v8);
      }
      return 0;
    }
  }
  else
  {
    uint64_t v10 = *(void *)(a2 + 16);
    if (gMMCS_DebugLevel >= 4)
    {
      long long v11 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v13 = *(void *)(a2 + 8);
        uint64_t v14 = mmcs_request_queue_requests_enqueued_count_for_behavior_type(a1, v10);
        CFStringRef v15 = CFStringCreateWithFormat(v12, 0, @"Enqueued request object %p. Queue depth %ld", v13, v14 + 1);
        uint64_t v16 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v15;
          _os_log_impl(&dword_1DC1CA000, v16, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v15) {
          CFRelease(v15);
        }
      }
      if (gMMCS_DebugLevel >= 5)
      {
        CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
        mmcs_request_queue_context_append_description(a2, Mutable);
        if (Mutable)
        {
          if (gMMCS_DebugLevel >= 5)
          {
            int v19 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
            {
              CFStringRef v20 = CFStringCreateWithFormat(v17, 0, @"%@", Mutable);
              uint64_t v21 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 138543362;
                *(void *)&uint8_t buf[4] = v20;
                _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
              }
              if (v20) {
                CFRelease(v20);
              }
            }
          }
          CFRelease(Mutable);
        }
      }
    }
    *(void *)long long buf = 0;
    uint64_t result = mmcs_request_queue_entry_create(buf, a2);
    if (result)
    {
      mmcs_request_queue_entry_ensure_minimum_bytes_per_period_requirement(*(uint64_t *)buf, *(_DWORD *)(a1 + 1528), *(double *)(a1 + 1536));
      uint64_t v22 = *(const void **)buf;
      *(unsigned char *)(*(void *)buf + 24) = 1;
      CFBinaryHeapAddValue(*(CFBinaryHeapRef *)(a1 + 8 * v10 + 16), v22);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 96), *(const void **)(a2 + 8), *(const void **)buf);
      if (*(void *)buf) {
        C3BaseRelease(*(CFTypeRef *)buf);
      }
      mmcs_request_queue_schedule(a1, a3);
      return 1;
    }
  }
  return result;
}

uint64_t mmcs_request_queue_requests_enqueued_count_for_behavior_type(uint64_t a1, uint64_t a2)
{
  uint64_t behavior_type = mmcs_request_type_get_behavior_type(a2);
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  char v6 = 1;
  do
  {
    char v7 = v6;
    uint64_t v8 = mmcs_request_type_for_behavior_and_activity(behavior_type, v4);
    CFIndex Count = CFBinaryHeapGetCount(*(CFBinaryHeapRef *)(a1 + 8 * v8 + 16));
    char v6 = 0;
    v5 += Count;
    uint64_t v4 = 1;
  }
  while ((v7 & 1) != 0);
  return v5;
}

void mmcs_request_queue_schedule(uint64_t a1, double a2)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  double v4 = a2 - *(double *)(a1 + 208);
  uint64_t v5 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (v4 >= 0.05)
  {
    mmcs_request_queue_estimate_bandwidth_context_init((double *)(a1 + 200), a2);
    CFArrayRef v9 = *(const __CFArray **)(a1 + 184);
    if (v9)
    {
      v104.unsigned int length = CFArrayGetCount(*(CFArrayRef *)(a1 + 184));
      v104.CFIndex location = 0;
      CFArrayApplyFunction(v9, v104, (CFArrayApplierFunction)mmcs_network_activity_estimate_bandwidth_network_activity_applier, (void *)(a1 + 200));
    }
    *(void *)&long long context = a1 + 200;
    *((double *)&context + 1) = a2;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 96), (CFDictionaryApplierFunction)mmcs_request_queue_estimate_bandwidth_applier, &context);
    if (a2 - *(double *)(a1 + 192) >= 1.0)
    {
      uint64_t v10 = 0;
      *(double *)(a1 + 192) = a2;
      CFAllocatorRef v11 = *v5;
      char v12 = 1;
      do
      {
        char v13 = v12;
        uint64_t v14 = a1 + 40 * v10;
        int v16 = *(unsigned __int8 *)(v14 + 216);
        uint64_t v15 = v14 + 216;
        if (v16)
        {
          double v95 = 0.0;
          uint64_t v96 = 0;
          mmcs_request_queue_estimate_bandwidth_measurement_calculate_bps(v15, &v95, (double *)&v96);
          double v17 = v95;
          BOOL v18 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            int v19 = mmcs_network_activity_type_as_c_string(v10);
            *(_DWORD *)long long buf = 136315650;
            *(void *)&uint8_t buf[4] = v19;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v96;
            *(_WORD *)&unsigned char buf[22] = 2048;
            *(double *)&unsigned char buf[24] = v17 * 8.0 / 1000.0 / 1000.0;
            _os_log_impl(&dword_1DC1CA000, v18, OS_LOG_TYPE_DEFAULT, "average bandwidth for %s estimated over %.0f secs, %.03f Mbps.", buf, 0x20u);
          }
        }
        else if (gMMCS_DebugLevel >= 5)
        {
          CFStringRef v20 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v21 = mmcs_network_activity_type_as_c_string(v10);
            CFStringRef v22 = CFStringCreateWithFormat(v11, 0, @"average bandwidth for %s cannot be estimated", v21);
            uint64_t v23 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v22;
              _os_log_impl(&dword_1DC1CA000, v23, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v22) {
              CFRelease(v22);
            }
          }
        }
        char v12 = 0;
        uint64_t v10 = 1;
      }
      while ((v13 & 1) != 0);
    }
  }
  else if (gMMCS_DebugLevel >= 5)
  {
    char v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v7 = CFStringCreateWithFormat(*v5, 0, @"Perform bandwidth estimation at most every %.0f ms, it has only been %.3f ms", 0x4049000000000000, v4 * 1000.0);
      uint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
  }
  unint64_t v24 = 0;
  BOOL v25 = 0;
  CFAllocatorRef alloc = *v5;
  do
  {
    if (v25)
    {
      if (gMMCS_DebugLevel >= 5)
      {
        CFStringRef v26 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v27 = CFStringCreateWithFormat(alloc, 0, @"Deferring start of background requests in favor of queued foreground requests");
          uint64_t v28 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            *(void *)&uint8_t buf[4] = v27;
            _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v27) {
            CFRelease(v27);
          }
        }
        uint64_t v29 = mmcs_request_queue_copy_description(a1);
        if (gMMCS_DebugLevel >= 5)
        {
          uint64_t v30 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            unint64_t v31 = v24;
            CFStringRef v32 = CFStringCreateWithFormat(alloc, 0, @"%@", v29);
            uint64_t v33 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v32;
              _os_log_impl(&dword_1DC1CA000, v33, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            unint64_t v24 = v31;
            if (v32) {
              CFRelease(v32);
            }
          }
        }
        if (v29) {
          CFRelease(v29);
        }
      }
      BOOL v25 = 1;
      goto LABEL_109;
    }
    if (v24 < 3)
    {
      uint64_t v34 = 0;
      char v35 = 1;
      unint64_t v89 = v24;
      while (1)
      {
        char v90 = v35;
        uint64_t v36 = mmcs_request_type_for_behavior_and_activity(v24, v34);
        CFStringRef v37 = (_OWORD *)(a1 + 200 + 96 * v36 + 96);
        uint64_t v38 = a1 + 200 + 40 * v34;
        CFURLRef v39 = (unsigned char *)(v38 + 16);
        uint64_t v94 = (double *)(v38 + 40);
        CFStringRef v40 = (double *)(v38 + 32);
        uint64_t v41 = (uint64_t *)(v38 + 24);
        char v91 = (unsigned char *)(v38 + 16 + v24 + 32);
        uint64_t v92 = 40 * v34 + 248;
        while (_is_request_done(a1, v36))
        {
          long long v42 = *(_OWORD *)(a1 + 200 + 96 * v36 + 144);
          long long v99 = *(_OWORD *)(a1 + 200 + 96 * v36 + 128);
          long long v100 = v42;
          long long v43 = *(_OWORD *)(a1 + 200 + 96 * v36 + 176);
          long long v101 = *(_OWORD *)(a1 + 200 + 96 * v36 + 160);
          long long v102 = v43;
          long long v44 = *(_OWORD *)(a1 + 200 + 96 * v36 + 112);
          *(_OWORD *)long long buf = *v37;
          *(_OWORD *)&uint8_t buf[16] = v44;
          Minimum = CFBinaryHeapGetMinimum(*(CFBinaryHeapRef *)(a1 + 8 * v36 + 16));
          C3BaseRetain(Minimum);
          mmcs_request_requirements_add_requirement((uint64_t)buf, Minimum[4] + 32, v46, v47);
          if (*v39)
          {
            if (*v94 <= *v40) {
              double v48 = 1.0;
            }
            else {
              double v48 = *v94 - *v40;
            }
            uint64_t v49 = (uint64_t)((double)*v41 / v48);
            uint64_t v50 = 8 * *(unsigned int *)&buf[8];
            if (v50 <= v49)
            {
              uint64_t behavior_type = mmcs_request_type_get_behavior_type(v36);
              if (behavior_type < 0)
              {
LABEL_62:
                if (gMMCS_DebugLevel < 5) {
                  goto LABEL_89;
                }
                size_t v61 = mmcs_logging_logger_default();
                if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_89;
                }
                uint64_t v62 = mmcs_request_type_as_c_string(v36);
                CFStringRef v63 = CFStringCreateWithFormat(alloc, 0, @"Planning to schedule %s. Bps needed %ld avail %ld", v62, v50, v49);
                uint64_t v64 = mmcs_logging_logger_default();
                if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_87;
                }
                goto LABEL_86;
              }
              uint64_t v59 = behavior_type + 1;
              uint64_t v60 = v92;
              while (!*(unsigned char *)(a1 + v60))
              {
                ++v60;
                if (!--v59) {
                  goto LABEL_62;
                }
              }
              if (!mmcs_request_queue_total_requests_inflight_for_behavior_type(a1, v36)) {
                mmcs_request_queue_schedule_cold_1();
              }
              if (gMMCS_DebugLevel >= 5)
              {
                uint64_t v69 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v70 = mmcs_request_type_as_c_string(v36);
                  CFStringRef v53 = CFStringCreateWithFormat(alloc, 0, @"Not planning to schedule %s. Outstanding tasks below required throughput.", v70);
                  size_t v54 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG)) {
                    goto LABEL_78;
                  }
                  goto LABEL_79;
                }
              }
            }
            else
            {
              if (!mmcs_request_queue_total_requests_inflight_for_behavior_type(a1, v36))
              {
                if (gMMCS_DebugLevel < 5) {
                  goto LABEL_89;
                }
                size_t v67 = mmcs_logging_logger_default();
                if (!os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_89;
                }
                long long v68 = mmcs_request_type_as_c_string(v36);
                CFStringRef v63 = CFStringCreateWithFormat(alloc, 0, @"Planning to schedule %s. Not enough bandwidth available but no other request is in-flight", v68);
                uint64_t v64 = mmcs_logging_logger_default();
                if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_87;
                }
                goto LABEL_86;
              }
              if (gMMCS_DebugLevel >= 5)
              {
                CFStringRef v51 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                {
                  int v52 = mmcs_request_type_as_c_string(v36);
                  CFStringRef v53 = CFStringCreateWithFormat(alloc, 0, @"Not planning to schedule %s. Bps needed %ld avail %ld", v52, v50, v49);
                  size_t v54 = mmcs_logging_logger_default();
                  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG)) {
                    goto LABEL_78;
                  }
                  goto LABEL_79;
                }
              }
            }
          }
          else
          {
            if (!mmcs_request_queue_total_requests_inflight_for_behavior_type(a1, v36))
            {
              if (gMMCS_DebugLevel < 5) {
                goto LABEL_89;
              }
              uint64_t v65 = mmcs_logging_logger_default();
              if (!os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_89;
              }
              uint64_t v66 = mmcs_request_type_as_c_string(v36);
              CFStringRef v63 = CFStringCreateWithFormat(alloc, 0, @"Planning to schedule %s. No bandwidth measurement available but no other request is in-flight", v66);
              uint64_t v64 = mmcs_logging_logger_default();
              if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_87;
              }
LABEL_86:
              LODWORD(CFSetApplyFunction(theSet, (CFSetApplierFunction)XCFSetRemoveValuesFromSetApplier, context) = 138543362;
              *(void *)((char *)&context + 4) = v63;
              _os_log_impl(&dword_1DC1CA000, v64, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&context, 0xCu);
              goto LABEL_87;
            }
            if (gMMCS_DebugLevel >= 5)
            {
              CFStringRef v55 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
              {
                CFStringRef v56 = mmcs_request_type_as_c_string(v36);
                uint64_t v57 = mmcs_request_queue_total_requests_inflight_for_behavior_type(a1, v36);
                CFStringRef v53 = CFStringCreateWithFormat(alloc, 0, @"Not planning to schedule %s. No bandwidth measurement available and %d requests are in-flight", v56, v57);
                size_t v54 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
                {
LABEL_78:
                  LODWORD(CFSetApplyFunction(theSet, (CFSetApplierFunction)XCFSetRemoveValuesFromSetApplier, context) = 138543362;
                  *(void *)((char *)&context + 4) = v53;
                  _os_log_impl(&dword_1DC1CA000, v54, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&context, 0xCu);
                }
LABEL_79:
                if (v53) {
                  CFRelease(v53);
                }
              }
            }
          }
          if (*(_DWORD *)(a1 + 1304) && mmcs_request_queue_entry_is_small_request((uint64_t)Minimum))
          {
            if (gMMCS_DebugLevel >= 5)
            {
              uint64_t v71 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v72 = mmcs_request_type_as_c_string(v36);
                CFStringRef v63 = CFStringCreateWithFormat(alloc, 0, @"Planning to schedule %s. This is a small request.", v72);
                uint64_t v64 = mmcs_logging_logger_default();
                if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_86;
                }
LABEL_87:
                if (v63) {
                  CFRelease(v63);
                }
              }
            }
LABEL_89:
            LOBYTE(CFSetApplyFunction(theSet, (CFSetApplierFunction)XCFSetRemoveValuesFromSetApplier, context) = 0;
            _do_schedule(a1, (uint64_t)Minimum, v36, &context);
            int v73 = context;
            if ((_BYTE)context)
            {
              long long v74 = *(_OWORD *)&buf[16];
              _OWORD *v37 = *(_OWORD *)buf;
              *(_OWORD *)(a1 + 200 + 96 * v36 + 112) = v74;
              long long v75 = v102;
              *(_OWORD *)(a1 + 200 + 96 * v36 + 160) = v101;
              *(_OWORD *)(a1 + 200 + 96 * v36 + 176) = v75;
              long long v76 = v100;
              *(_OWORD *)(a1 + 200 + 96 * v36 + 128) = v99;
              *(_OWORD *)(a1 + 200 + 96 * v36 + 144) = v76;
              uint64_t v77 = Minimum[4];
              if (*(double *)(v77 + 32) > 0.0 && *(void *)(v77 + 8 * *(void *)(v77 + 16) + 48) > 0x10000uLL) {
                *char v91 = 1;
              }
            }
            goto LABEL_94;
          }
          int v73 = 1;
LABEL_94:
          if (Minimum) {
            C3BaseRelease(Minimum);
          }
          if (v73) {
            break;
          }
        }
        char v35 = 0;
        uint64_t v34 = 1;
        unint64_t v24 = v89;
        if ((v90 & 1) == 0) {
          goto LABEL_106;
        }
      }
    }
    uint64_t v78 = 0;
    char v79 = 1;
    do
    {
      char v80 = v79;
      uint64_t v81 = mmcs_request_type_for_behavior_and_activity(v24, v78);
      buf[0] = 0;
      do
      {
        if (!_is_request_done(a1, v81)) {
          break;
        }
        uint64_t v82 = CFBinaryHeapGetMinimum(*(CFBinaryHeapRef *)(a1 + 8 * v81 + 16));
        C3BaseRetain(v82);
        _do_schedule(a1, (uint64_t)v82, v81, buf);
        if (v82) {
          C3BaseRelease(v82);
        }
      }
      while (!buf[0]);
      char v79 = 0;
      uint64_t v78 = 1;
    }
    while ((v80 & 1) != 0);
LABEL_106:
    uint64_t v83 = 0;
    char v84 = 0;
    char v85 = 1;
    do
    {
      char v86 = v85;
      uint64_t v87 = mmcs_request_type_for_behavior_and_activity(v24, v83);
      char Count = CFBinaryHeapGetCount(*(CFBinaryHeapRef *)(a1 + 8 * v87 + 16));
      char v85 = 0;
      v84 += Count;
      uint64_t v83 = 1;
    }
    while ((v86 & 1) != 0);
    BOOL v25 = v84 != 0;
LABEL_109:
    ++v24;
  }
  while (v24 != 5);
}

uint64_t mmcs_request_queue_cancel_request(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), a2);
  if (result)
  {
    uint64_t v6 = result;
    if (*(unsigned char *)(result + 24))
    {
      if (*(unsigned char *)(result + 26) || *(unsigned char *)(result + 27))
      {
        return 0;
      }
      else
      {
        *(unsigned char *)(result + 26) = 1;
        C3BaseRetain((CFTypeRef)result);
        if (gMMCS_DebugLevel >= 4)
        {
          CFStringRef v7 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Cancelling request for object %p", *(void *)(*(void *)(v6 + 32) + 8));
            CFArrayRef v9 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v11 = v8;
              _os_log_impl(&dword_1DC1CA000, v9, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v8) {
              CFRelease(v8);
            }
          }
        }
        if (*(unsigned char *)(v6 + 24)) {
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 96), *(const void **)(*(void *)(v6 + 32) + 8));
        }
        C3BaseRelease((CFTypeRef)v6);
        return 1;
      }
    }
    else
    {
      return mmcs_request_queue_callback_cancel_request_with_entry(result, a3);
    }
  }
  return result;
}

uint64_t mmcs_request_queue_callback_cancel_request_with_entry(uint64_t cf, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    uint64_t v2 = (void *)cf;
    if (*(unsigned char *)(cf + 25) || *(unsigned char *)(cf + 26) || *(unsigned char *)(cf + 27))
    {
      return 0;
    }
    else
    {
      *(unsigned char *)(cf + 25) = 1;
      C3BaseRetain((CFTypeRef)cf);
      if (gMMCS_DebugLevel >= 4)
      {
        double v4 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Callback cancelling request for object %p", *(void *)(v2[4] + 8));
          uint64_t v6 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138543362;
            CFStringRef v8 = v5;
            _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
          }
          if (v5) {
            CFRelease(v5);
          }
        }
      }
      (*(void (**)(void, uint64_t))(v2[4] + 136))(*(void *)(v2[4] + 8), a2);
      C3BaseRelease(v2);
      return 1;
    }
  }
  return cf;
}

uint64_t mmcs_request_queue_request_did_transmit(uint64_t a1, const void *a2, uint64_t a3, double a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), a2);
  if (result)
  {
    uint64_t v9 = result;
    if (gMMCS_DebugLevel >= 5)
    {
      CFStringRef v10 = mmcs_network_activity_copy_description(a3);
      if (v10)
      {
        CFStringRef v11 = v10;
        if (gMMCS_DebugLevel >= 5)
        {
          uint64_t v12 = mmcs_logging_logger_default();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"object (%p) did %@", a2, v11);
            uint64_t v14 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138543362;
              CFStringRef v21 = v13;
              _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
            }
            if (v13) {
              CFRelease(v13);
            }
          }
        }
        CFRelease(v11);
      }
    }
    mmcs_request_queue_entry_did_transmit(v9, a3, a4 + -10.0);
    CFArrayRef v15 = *(const __CFArray **)(a1 + 184);
    if (v15)
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 184));
      if (Count >= 1)
      {
        unint64_t v17 = Count + 1;
        do
        {
          CFDataRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v15, v17 - 2);
          if (*((double *)ValueAtIndex + 1) < a4 + -10.0)
          {
            int v19 = ValueAtIndex;
            CFArrayRemoveValueAtIndex(v15, v17 - 2);
            free(v19);
          }
          --v17;
        }
        while (v17 > 1);
      }
    }
    mmcs_request_queue_schedule(a1, a4);
    return 1;
  }
  return result;
}

uint64_t mmcs_request_queue_request_did_complete(uint64_t a1, void *key, CFErrorRef err, int a4, BOOL *a5, double a6)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  if (!err)
  {
    BOOL v17 = 0;
    goto LABEL_32;
  }
  CFErrorDomain Domain = CFErrorGetDomain(err);
  CFIndex Code = CFErrorGetCode(err);
  if (!CFEqual(@"com.apple.mmcs", Domain))
  {
    if (CFEqual((CFTypeRef)*MEMORY[0x1E4F1D158], Domain))
    {
      BOOL v18 = Code == -9810;
    }
    else
    {
      if (!CFEqual((CFTypeRef)*MEMORY[0x1E4F18F50], Domain))
      {
        if (CFEqual((CFTypeRef)*MEMORY[0x1E4F1D160], Domain))
        {
          if (a4) {
            BOOL v70 = Code == 54;
          }
          else {
            BOOL v70 = 0;
          }
          int v23 = !v70;
        }
        else
        {
          int v23 = 0;
        }
        goto LABEL_31;
      }
      if (a4) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = Code == -1005;
      }
    }
    int v23 = v18;
    goto LABEL_31;
  }
  CFDictionaryRef v14 = CFErrorCopyUserInfo(err);
  CFDictionaryRef v15 = v14;
  if (v14) {
    CFDictionaryRef Value = (__CFError *)CFDictionaryGetValue(v14, (const void *)*MEMORY[0x1E4F1D190]);
  }
  else {
    CFDictionaryRef Value = 0;
  }
  if (Code != 38)
  {
    if (Code == 3)
    {
      if (!Value) {
        goto LABEL_22;
      }
      CFErrorDomain v19 = CFErrorGetDomain(Value);
      if (!CFEqual(@"NSURLErrorDomain", v19)) {
        goto LABEL_22;
      }
      CFIndex v20 = CFErrorGetCode(Value);
      if (!a4 || v20 != -1001) {
        goto LABEL_22;
      }
    }
LABEL_20:
    int v23 = 0;
    if (!v15) {
      goto LABEL_31;
    }
    goto LABEL_23;
  }
  if (Value)
  {
    CFErrorDomain v21 = CFErrorGetDomain(Value);
    if (CFEqual(@"NSURLErrorDomain", v21))
    {
      CFIndex v22 = CFErrorGetCode(Value);
      if (a4)
      {
        if (v22 == -1005) {
          goto LABEL_20;
        }
      }
    }
  }
LABEL_22:
  int v23 = 1;
  if (v15) {
LABEL_23:
  }
    CFRelease(v15);
LABEL_31:
  BOOL v17 = v23 != 0;
LABEL_32:
  unint64_t v24 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), key);
  if (!v24)
  {
    unint64_t v31 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
      goto LABEL_44;
    }
    CFStringRef v27 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Unknown request for object %p completed", key);
    CFStringRef v32 = mmcs_logging_logger_default();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_42;
    }
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v27;
    uint64_t v29 = v32;
    os_log_type_t v30 = OS_LOG_TYPE_ERROR;
    goto LABEL_41;
  }
  uint64_t v25 = (uint64_t)v24;
  if (!*((unsigned char *)v24 + 27))
  {
    CFArrayRef v36 = (const __CFArray *)*((void *)v24 + 5);
    if (v36)
    {
      CFIndex Count = CFArrayGetCount(v36);
      if (Count >= 1)
      {
        CFIndex v38 = Count;
        CFMutableArrayRef Mutable = *(__CFArray **)(a1 + 184);
        if (!Mutable)
        {
          CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
          *(void *)(a1 + 184) = Mutable;
        }
        v74.CFIndex location = 0;
        v74.unsigned int length = v38;
        CFArrayAppendArray(Mutable, *(CFArrayRef *)(v25 + 40), v74);
        CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v25 + 40));
      }
    }
    uint64_t v40 = *(void *)(*(void *)(v25 + 32) + 16);
    if (gMMCS_DebugLevel >= 4)
    {
      uint64_t v41 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v42 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        if (v17) {
          long long v43 = " with network error";
        }
        else {
          long long v43 = "";
        }
        uint64_t v44 = mmcs_request_queue_total_requests_inflight_for_behavior_type(a1, v40) - 1;
        uint64_t v45 = mmcs_request_queue_requests_enqueued_count_for_behavior_type(a1, v40);
        CFStringRef v46 = CFStringCreateWithFormat(v42, 0, @"Request for object %p completed%s. %d requests now in-flight, %ld total requests enqueued", key, v43, v44, v45);
        double v47 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v46;
          _os_log_impl(&dword_1DC1CA000, v47, OS_LOG_TYPE_DEBUG, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v46) {
          CFRelease(v46);
        }
      }
    }
    C3BaseRetain((CFTypeRef)v25);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 96), key);
    uint64_t v48 = a1 + 4 * v40;
    int v51 = *(_DWORD *)(v48 + 104);
    uint64_t v50 = (_DWORD *)(v48 + 104);
    int v49 = v51;
    if (v51)
    {
      int v52 = v49 - 1;
      *uint64_t v50 = v52;
      if (v52) {
        goto LABEL_63;
      }
    }
    else
    {
      uint64_t v65 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v66 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"requestsInflightCount underflow");
        size_t v67 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v66;
          _os_log_impl(&dword_1DC1CA000, v67, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (v66) {
          CFRelease(v66);
        }
      }
      if (*v50)
      {
LABEL_63:
        if (v17) {
          goto LABEL_64;
        }
        goto LABEL_92;
      }
    }
    uint64_t activity_type = mmcs_request_type_get_activity_type(v40);
    *(unsigned char *)(a1 + 40 * activity_type + mmcs_request_type_get_behavior_type(v40) + 248) = 0;
    if (v17)
    {
LABEL_64:
      BOOL v34 = 0;
      *(_DWORD *)(a1 + 1304) = 0;
      if (!*(unsigned char *)(a1 + 1524))
      {
        unsigned int v53 = *(_DWORD *)(a1 + 1300);
        if (v53 != -1) {
          *(_DWORD *)(a1 + 1300) = ++v53;
        }
        if (v53 <= *(_DWORD *)(a1 + 1296))
        {
          BOOL v34 = 1;
        }
        else
        {
          double v54 = *(double *)(a1 + 1472);
          if (v54 >= 16.0) {
            double v55 = v54 + v54;
          }
          else {
            double v55 = 16.0;
          }
          if (v55 > 2048.0) {
            double v55 = 2048.0;
          }
          *(double *)(a1 + 1472) = v55;
          CFStringRef v56 = mmcs_logging_logger_default();
          BOOL v57 = os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT);
          CFAllocatorRef v58 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          if (v57)
          {
            CFStringRef v59 = CFStringCreateWithFormat(v58, 0, @"There were %d failures in a row. Cancelling all requests and requesting retry in %d seconds", *(unsigned int *)(a1 + 1300), (int)*(double *)(a1 + 1472));
            uint64_t v60 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 138543362;
              *(void *)((char *)&buf + 4) = v59;
              _os_log_impl(&dword_1DC1CA000, v60, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&buf, 0xCu);
            }
            if (v59) {
              CFRelease(v59);
            }
          }
          CFStringRef v61 = CFStringCreateWithFormat(v58, 0, @"%d", (int)*(double *)(a1 + 1472));
          *(void *)&long long buf = @"Retry-After";
          *((void *)&buf + 1) = @"kMMCSErrorRetryClientInitiatedKey";
          uint64_t v62 = (void *)*MEMORY[0x1E4F1CFD0];
          values[0] = (void *)v61;
          values[1] = v62;
          CFDictionaryRef v63 = CFDictionaryCreate(v58, (const void **)&buf, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFErrorRef v64 = mmcs_cferror_create_with_swiss_army_knife(@"com.apple.mmcs", 16, 0, v63, 0, 0, 0, @"Last %u requests failed with a network error. Retry after %@ seconds", *(unsigned int *)(a1 + 1300), v61);
          if (v63) {
            CFRelease(v63);
          }
          mmcs_request_queue_callback_cancel_request_with_entry(v25, (uint64_t)v64);
          *(unsigned char *)(v25 + 27) = 1;
          mmcs_request_queue_request_cancel_all_queued_and_inflight_requests(a1, (uint64_t)v64);
          if (v64) {
            CFRelease(v64);
          }
          if (v61) {
            CFRelease(v61);
          }
          BOOL v34 = 0;
        }
      }
      goto LABEL_95;
    }
LABEL_92:
    int v69 = *(_DWORD *)(a1 + 1304);
    if (v69 != -1) {
      *(_DWORD *)(a1 + 1304) = v69 + 1;
    }
    *(_DWORD *)(a1 + 1300) = 0;
    *(void *)(a1 + 1472) = 0;
    BOOL v34 = *(unsigned char *)(a1 + 1524) == 0;
LABEL_95:
    uint64_t v33 = 1;
    *(unsigned char *)(v25 + 27) = 1;
    C3BaseRelease((CFTypeRef)v25);
    mmcs_request_queue_schedule(a1, a6);
    if (!a5) {
      return v33;
    }
    goto LABEL_45;
  }
  if (gMMCS_DebugLevel < 4) {
    goto LABEL_44;
  }
  CFStringRef v26 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
    goto LABEL_44;
  }
  CFStringRef v27 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Request for object %p already done", key);
  uint64_t v28 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v27;
    uint64_t v29 = v28;
    os_log_type_t v30 = OS_LOG_TYPE_DEBUG;
LABEL_41:
    _os_log_impl(&dword_1DC1CA000, v29, v30, "%{public}@", (uint8_t *)&buf, 0xCu);
  }
LABEL_42:
  if (v27) {
    CFRelease(v27);
  }
LABEL_44:
  uint64_t v33 = 0;
  BOOL v34 = 1;
  if (a5) {
LABEL_45:
  }
    *a5 = v34;
  return v33;
}

uint64_t mmcs_request_queue_total_requests_inflight_for_behavior_type(uint64_t a1, uint64_t a2)
{
  uint64_t behavior_type = mmcs_request_type_get_behavior_type(a2);
  if (behavior_type < 0) {
    return 0;
  }
  uint64_t v4 = behavior_type;
  uint64_t v5 = 0;
  LODWORD(v6) = 0;
  do
  {
    uint64_t v7 = 0;
    char v8 = 1;
    do
    {
      char v9 = v8;
      uint64_t v10 = mmcs_request_type_for_behavior_and_activity(v5, v7);
      char v8 = 0;
      uint64_t v6 = (*(_DWORD *)(a1 + 4 * v10 + 104) + v6);
      uint64_t v7 = 1;
    }
    while ((v9 & 1) != 0);
  }
  while (v5++ != v4);
  return v6;
}

void mmcs_request_queue_request_cancel_all_queued_and_inflight_requests(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 1524))
  {
    *(unsigned char *)(a1 + 1524) = 1;
    CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 96));
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      uint64_t v6 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
      if (v6)
      {
        uint64_t v7 = v6;
        CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 96), 0, v6);
        for (uint64_t i = 0; i != v5; ++i)
          C3BaseRetain(v7[i]);
        for (uint64_t j = 0; j != v5; ++j)
          mmcs_request_queue_callback_cancel_request_with_entry((uint64_t)v7[j], a2);
        for (uint64_t k = 0; k != v5; ++k)
        {
          CFStringRef v11 = v7[k];
          if (v11) {
            C3BaseRelease(v11);
          }
        }
        free(v7);
      }
    }
    *(unsigned char *)(a1 + 1524) = 0;
  }
}

__CFString *mmcs_request_queue_copy_description(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<request_queue %p>", a1);
  uint64_t v3 = 0;
  uint64_t v4 = a1 + 16;
  do
  {
    if (CFBinaryHeapGetCount(*(CFBinaryHeapRef *)(v4 + 8 * v3)) >= 1)
    {
      CFStringRef v5 = CFCopyDescription(*(CFTypeRef *)(v4 + 8 * v3));
      uint64_t v6 = mmcs_request_type_as_c_string(v3);
      CFStringAppendFormat(Mutable, 0, @"\n%s queue----\n%@\n", v6, v5);
      if (v5) {
        CFRelease(v5);
      }
    }
    ++v3;
  }
  while (v3 != 10);
  return Mutable;
}

void _mmcs_request_queueCFFinalize(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = mmcs_logging_logger_default();
  if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_25;
  }
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  for (uint64_t i = 0; i != 10; ++i)
  {
    CFStringRef v5 = mmcs_request_type_as_c_string(i);
    CFStringAppendFormat(Mutable, 0, @"%s statistics\n", v5);
    CFStringAppend(Mutable, @"Queue Depth Distribution\n  Depth Count\n");
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(a1 + 8 * i + 1312);
    while (1)
    {
      uint64_t v8 = *(unsigned int *)(v7 + 4 * v6);
      if (v8) {
        break;
      }
LABEL_7:
      if (++v6 == 21) {
        goto LABEL_10;
      }
    }
    if (v6 != 20)
    {
      CFStringAppendFormat(Mutable, 0, @"%6ld  %u\n", v6, v8);
      goto LABEL_7;
    }
    CFStringAppendFormat(Mutable, 0, @"%6ld+ %u\n", 20, v8);
LABEL_10:
    CFStringAppend(Mutable, @"In-flight Request Count Distribution\n  Depth Count\n");
    uint64_t v9 = 0;
    uint64_t v10 = *(void *)(a1 + 8 * i + 1392);
    while (2)
    {
      uint64_t v11 = *(unsigned int *)(v10 + 4 * v9);
      if (!v11)
      {
LABEL_14:
        if (++v9 == 21) {
          goto LABEL_17;
        }
        continue;
      }
      break;
    }
    if (v9 != 20)
    {
      CFStringAppendFormat(Mutable, 0, @"%6ld  %u\n", v9, v11);
      goto LABEL_14;
    }
    CFStringAppendFormat(Mutable, 0, @"%6ld+ %u\n", 20, v11);
LABEL_17:
    CFStringAppend(Mutable, @"\n\n");
  }
  uint64_t v12 = mmcs_logging_logger_default();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v13 = CFStringCreateWithFormat(alloc, 0, @"%@", Mutable);
    CFDictionaryRef v14 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138543362;
      CFStringRef v25 = v13;
      _os_log_impl(&dword_1DC1CA000, v14, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
    }
    if (v13) {
      CFRelease(v13);
    }
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_25:
  for (uint64_t j = 0; j != 80; j += 8)
  {
    uint64_t v16 = a1 + j;
    BOOL v17 = *(const void **)(a1 + j + 16);
    if (v17) {
      CFRelease(v17);
    }
    *(void *)(v16 + 16) = 0;
    BOOL v18 = *(void **)(v16 + 1312);
    if (v18) {
      free(v18);
    }
    *(void *)(v16 + 1312) = 0;
    CFErrorDomain v19 = *(void **)(a1 + j + 1392);
    if (v19) {
      free(v19);
    }
    *(void *)(a1 + j + 1392) = 0;
  }
  CFIndex v20 = *(const void **)(a1 + 96);
  if (v20) {
    CFRelease(v20);
  }
  *(void *)(a1 + 96) = 0;
  CFArrayRef v21 = *(const __CFArray **)(a1 + 184);
  if (v21)
  {
    v27.unsigned int length = CFArrayGetCount(*(CFArrayRef *)(a1 + 184));
    v27.CFIndex location = 0;
    CFArrayApplyFunction(v21, v27, (CFArrayApplierFunction)_CFArrayApplierFunction_Free, 0);
    CFIndex v22 = *(const void **)(a1 + 184);
    if (v22) {
      CFRelease(v22);
    }
    *(void *)(a1 + 184) = 0;
  }
}

BOOL _mmcs_request_queueCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_request_queueCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_request_queueCFCopyDebugDescription()
{
  return 0;
}

void _CFArrayApplierFunction_Free(void *a1)
{
  if (a1) {
    free(a1);
  }
}

void mmcs_request_queue_estimate_bandwidth_applier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a2 + 24)) {
    mmcs_request_queue_entry_estimate_bandwidth(a2, *(void *)a3, *(double *)(a3 + 8));
  }
}

BOOL _is_request_done(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (_DWORD *)(a1 + 4 * a2);
  unsigned int v3 = v2[26];
  return v3 < v2[36]
      && v3 < v2[371]
      && mmcs_request_queue_total_requests_inflight_for_behavior_type(a1, a2) < *(_DWORD *)(a1 + 1480)
      && CFBinaryHeapGetCount(*(CFBinaryHeapRef *)(a1 + 8 * a2 + 16)) > 0;
}

void _do_schedule(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a1 + 8 * a3;
  uint64_t v9 = (CFBinaryHeapRef *)(v8 + 16);
  CFBinaryHeapRemoveMinimumValue(*(CFBinaryHeapRef *)(v8 + 16));
  uint64_t v10 = *(uint64_t (**)(void, void))(*(void *)(a2 + 32) + 128);
  char v41 = 0;
  uint64_t v11 = a1 + 4 * a3;
  int v13 = *(_DWORD *)(v11 + 104);
  uint64_t v12 = (unsigned int *)(v11 + 104);
  unsigned int *v12 = v13 + 1;
  if (gMMCS_DebugLevel >= 5)
  {
    CFDictionaryRef v14 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      CFIndex v38 = a4;
      CFURLRef v39 = v10;
      CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v15 = *v12;
      uint64_t v16 = mmcs_request_type_as_c_string(a3);
      uint64_t v17 = *(void *)(*(void *)(a2 + 32) + 8);
      BOOL v18 = mmcs_request_type_as_c_string(a3);
      CFIndex Count = CFBinaryHeapGetCount(*v9);
      CFStringRef v20 = CFStringCreateWithFormat(alloc, 0, @"Planning to schedule in-flight request %d for %s request object %p, resulting request %s queue depth %ld", v15, v16, v17, v18, Count);
      CFArrayRef v21 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v43 = v20;
        _os_log_impl(&dword_1DC1CA000, v21, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      a4 = v38;
      uint64_t v10 = v39;
      if (v20) {
        CFRelease(v20);
      }
    }
    CFIndex v22 = mmcs_request_queue_copy_description(a1);
    if (gMMCS_DebugLevel >= 5)
    {
      int v23 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v40 = v10;
        CFStringRef v24 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@", v22);
        CFStringRef v25 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v43 = v24;
          _os_log_impl(&dword_1DC1CA000, v25, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        uint64_t v10 = v40;
        if (v24) {
          CFRelease(v24);
        }
      }
    }
    if (v22) {
      CFRelease(v22);
    }
  }
  uint64_t v26 = *(void *)(v8 + 1312);
  if (CFBinaryHeapGetCount(*v9) > 19) {
    CFIndex v27 = 20;
  }
  else {
    CFIndex v27 = CFBinaryHeapGetCount(*v9);
  }
  ++*(_DWORD *)(v26 + 4 * v27);
  unsigned int v28 = *v12;
  if (*v12 >= 0x14) {
    unsigned int v28 = 20;
  }
  ++*(_DWORD *)(*(void *)(a1 + 8 * a3 + 1392) + 4 * v28);
  *(unsigned char *)(a2 + 24) = 0;
  int v29 = v10(*(void *)(*(void *)(a2 + 32) + 8), &v41);
  if (v29 && v41)
  {
    *a4 = 1;
  }
  else
  {
    os_log_type_t v30 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      CFAllocatorRef v31 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v32 = *v12;
      uint64_t v33 = mmcs_request_type_as_c_string(a3);
      BOOL v34 = "failed";
      if (!v29) {
        BOOL v34 = "succeeded but nothing was scheduled";
      }
      CFStringRef v35 = CFStringCreateWithFormat(v31, 0, @"Scheduling of in-flight request %d for %s request object %p, %s. Attempting to schedule another.", v32, v33, *(void *)(*(void *)(a2 + 32) + 8), v34);
      CFArrayRef v36 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v43 = v35;
        _os_log_impl(&dword_1DC1CA000, v36, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v35) {
        CFRelease(v35);
      }
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 96), *(const void **)(*(void *)(a2 + 32) + 8));
    --*v12;
  }
}

uint64_t mmcs_request_queue_entry_create(void *a1, uint64_t a2)
{
  *a1 = 0;
  uint64_t v4 = C3TypeRegister(&mmcs_request_queue_entryGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v4, 0x20uLL);
  if (result)
  {
    uint64_t v6 = (const void *)result;
    if (mmcs_request_queue_entry_init(result, a2))
    {
      *a1 = v6;
      return 1;
    }
    else
    {
      C3BaseRelease(v6);
      return 0;
    }
  }
  return result;
}

uint64_t mmcs_request_queue_entry_init(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&sMMCSRequestQueueEntryClassLock);
  uint64_t v4 = sMMCSRequestQueueEntryIndex++;
  os_unfair_lock_unlock((os_unfair_lock_t)&sMMCSRequestQueueEntryClassLock);
  *(void *)(a1 + 16) = v4;
  if (!a2 || *(void *)a2) {
    return 0;
  }
  uint64_t result = (uint64_t)malloc_type_malloc(0xA0uLL, 0x10E0040E9E181E1uLL);
  *(void *)(a1 + 32) = result;
  if (result)
  {
    long long v6 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)uint64_t result = *(_OWORD *)a2;
    *(_OWORD *)(result + 16) = v6;
    long long v7 = *(_OWORD *)(a2 + 32);
    long long v8 = *(_OWORD *)(a2 + 48);
    long long v9 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(result + 64) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(result + 80) = v9;
    *(_OWORD *)(result + 32) = v7;
    *(_OWORD *)(result + 48) = v8;
    long long v10 = *(_OWORD *)(a2 + 96);
    long long v11 = *(_OWORD *)(a2 + 112);
    long long v12 = *(_OWORD *)(a2 + 144);
    *(_OWORD *)(result + 128) = *(_OWORD *)(a2 + 128);
    *(_OWORD *)(result + 144) = v12;
    *(_OWORD *)(result + 96) = v10;
    *(_OWORD *)(result + 112) = v11;
    int v13 = *(void **)(a1 + 32);
    CFDictionaryRef v14 = (void (*)(void))v13[18];
    if (v14)
    {
      v14(v13[1]);
      int v13 = *(void **)(a1 + 32);
    }
    uint64_t v15 = (const void *)v13[3];
    if (v15) {
      CFRetain(v15);
    }
    return 1;
  }
  return result;
}

uint64_t mmcs_request_queue_entry_compare_priority(uint64_t a1, uint64_t a2, void *context)
{
  zero_CFNumberRef number = *(const __CFNumber **)(*(void *)(a1 + 32) + 24);
  if (!zero_number)
  {
    if (!*(void *)(*(void *)(a2 + 32) + 24)) {
      goto LABEL_8;
    }
    zero_CFNumberRef number = (const __CFNumber *)mmcs_request_get_zero_number();
  }
  CFNumberRef v7 = *(const __CFNumber **)(*(void *)(a2 + 32) + 24);
  if (!v7) {
    CFNumberRef v7 = (const __CFNumber *)mmcs_request_get_zero_number();
  }
  CFComparisonResult v8 = CFNumberCompare(zero_number, v7, context);
  if (v8 == kCFCompareLessThan) {
    return 1;
  }
  if (v8) {
    return -1;
  }
LABEL_8:
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *(void *)(a2 + 16);
  BOOL v11 = v9 < v10;
  BOOL v12 = v9 > v10;
  if (v11) {
    return -1;
  }
  else {
    return v12;
  }
}

uint64_t mmcs_request_get_zero_number()
{
  os_unfair_lock_lock((os_unfair_lock_t)&sMMCSRequestQueueEntryClassLock);
  if (!sMMCSZeroNumber)
  {
    int valuePtr = 0;
    sMMCSZeroNumber = (uint64_t)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&sMMCSRequestQueueEntryClassLock);
  return sMMCSZeroNumber;
}

void mmcs_request_queue_context_append_description(uint64_t a1, __CFString *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  CFStringRef v5 = mmcs_request_type_as_c_string(*(void *)(a1 + 16));
  CFStringAppendFormat(a2, 0, @" object (%p) requires for %s %u bytes / %lf sec", v4, v5, *(unsigned int *)(a1 + 40), *(void *)(a1 + 32));
}

__CFString *mmcs_request_queue_entry_copy_description(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  unsigned int v3 = Mutable;
  uint64_t v4 = *(__CFString **)(*(void *)(a1 + 32) + 24);
  CFStringRef v5 = " done";
  if (!v4) {
    uint64_t v4 = @"0 (default)";
  }
  if (!*(unsigned char *)(a1 + 27)) {
    CFStringRef v5 = "";
  }
  if (*(unsigned char *)(a1 + 26)) {
    long long v6 = " cancelled";
  }
  else {
    long long v6 = "";
  }
  if (*(unsigned char *)(a1 + 25)) {
    CFNumberRef v7 = " cancelling";
  }
  else {
    CFNumberRef v7 = "";
  }
  if (*(unsigned char *)(a1 + 24)) {
    CFComparisonResult v8 = " enqueued";
  }
  else {
    CFComparisonResult v8 = "";
  }
  CFStringAppendFormat(Mutable, 0, @"<request_queue_entry %p>%s%s%s%s priority [%@, %ld]", a1, v8, v7, v6, v5, v4, *(void *)(a1 + 16));
  mmcs_request_queue_context_append_description(*(void *)(a1 + 32), v3);
  return v3;
}

void mmcs_request_queue_estimate_bandwidth_measurement_calculate_bps(uint64_t a1, double *a2, double *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a2 || !a3) {
    mmcs_request_queue_estimate_bandwidth_measurement_calculate_bps_cold_1();
  }
  double v7 = *(double *)(a1 + 16);
  double v6 = *(double *)(a1 + 24);
  if (v6 <= v7)
  {
    if (v6 == v7)
    {
      uint64_t v9 = mmcs_logging_logger_default();
      double v8 = 0.001;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Instantaneous transfer");
        BOOL v11 = mmcs_logging_logger_default();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          int v12 = 138543362;
          CFStringRef v13 = v10;
          _os_log_impl(&dword_1DC1CA000, v11, OS_LOG_TYPE_ERROR, "%{public}@", (uint8_t *)&v12, 0xCu);
        }
        if (v10) {
          CFRelease(v10);
        }
      }
    }
    else
    {
      double v8 = 1.0;
    }
  }
  else
  {
    double v8 = v6 - v7;
  }
  *a2 = (double)*(uint64_t *)(a1 + 8) / v8;
  *a3 = v8;
}

double mmcs_request_queue_estimate_bandwidth_context_init(double *a1, double a2)
{
  bzero(a1, 0x448uLL);
  *a1 = a2 + -10.0;
  a1[1] = a2;
  double result = 6.3113904e10;
  *((_OWORD *)a1 + 2) = xmmword_1DC251F90;
  *((_DWORD *)a1 + 12) = 0;
  *((unsigned char *)a1 + 52) = 0;
  *(_OWORD *)(a1 + 9) = xmmword_1DC251F90;
  *((_DWORD *)a1 + 22) = 0;
  *((unsigned char *)a1 + 92) = 0;
  return result;
}

void mmcs_network_activity_estimate_bandwidth_network_activity_applier(uint64_t a1, double *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 24) <= 1uLL)
  {
    double v17 = 6.3113904e10;
    uint64_t v18 = 0;
    double v16 = 0.0;
    if (mmcs_network_activity_bytes_for_start_end(a1, &v18, &v17, &v16, *a2, a2[1]))
    {
      if (gMMCS_DebugLevel >= 6 && v16 - v17 == 0.0)
      {
        CFStringRef v4 = mmcs_network_activity_copy_description(a1);
        if (v4)
        {
          CFStringRef v5 = v4;
          if (gMMCS_DebugLevel >= 5)
          {
            double v6 = mmcs_logging_logger_default();
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
            {
              CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"applied all of %@", v5);
              double v8 = mmcs_logging_logger_default();
              if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 138543362;
                CFStringRef v20 = v7;
                _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
              }
              if (v7) {
                CFRelease(v7);
              }
            }
          }
          CFRelease(v5);
        }
      }
      uint64_t v9 = *(void *)(a1 + 24);
      CFStringRef v10 = &a2[5 * v9];
      double v12 = v10[4];
      BOOL v11 = v10 + 4;
      *((unsigned char *)v11 - 16) = 1;
      *((void *)v11 - 1) += v18;
      if (v17 < v12) {
        double *v11 = v17;
      }
      CFStringRef v13 = &a2[5 * v9];
      double v15 = v13[5];
      uint64_t v14 = v13 + 5;
      if (v16 > v15) {
        *uint64_t v14 = v16;
      }
    }
  }
}

double mmcs_request_requirements_add_requirement(uint64_t a1, uint64_t a2, double a3, double a4)
{
  double result = *(double *)a2;
  if (*(double *)a2 > 0.0)
  {
    LODWORD(a4) = *(_DWORD *)(a2 + 8);
    double result = (double)*(unint64_t *)&a4 / result;
    *(_DWORD *)(a1 + 8) += result;
  }
  return result;
}

void mmcs_request_queue_entry_estimate_bandwidth(uint64_t a1, uint64_t a2, double a3)
{
  bzero(context, 0x448uLL);
  mmcs_request_queue_estimate_bandwidth_context_init(context, a3);
  CFArrayRef v6 = *(const __CFArray **)(a1 + 40);
  if (v6)
  {
    v27.unsigned int length = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    v27.CFIndex location = 0;
    CFArrayApplyFunction(v6, v27, (CFArrayApplierFunction)mmcs_network_activity_estimate_bandwidth_network_activity_applier, context);
  }
  uint64_t activity_type = mmcs_request_type_get_activity_type(*(void *)(*(void *)(a1 + 32) + 16));
  uint64_t v8 = activity_type;
  uint64_t v9 = *(void *)(a1 + 32);
  if (*(double *)(v9 + 32) > 0.0 && *(void *)(v9 + 8 * *(void *)(v9 + 16) + 48) > 0x10000uLL)
  {
    double v24 = 0.0;
    uint64_t v25 = 0;
    mmcs_request_queue_estimate_bandwidth_measurement_calculate_bps((uint64_t)&context[5 * activity_type + 2], &v24, (double *)&v25);
    uint64_t v10 = *(void *)(a1 + 32);
    LODWORD(v11) = *(_DWORD *)(v10 + 40);
    if (v24 < (double)v11 / *(double *)(v10 + 32)) {
      *((unsigned char *)&context[5 * v8 + 6] + mmcs_request_type_get_behavior_type(*(void *)(v10 + 16))) = 1;
    }
  }
  uint64_t v12 = a2 + 40 * v8;
  CFStringRef v13 = &context[5 * v8];
  double v14 = *(double *)(v12 + 32);
  *(unsigned char *)(v12 + 16) |= *((unsigned char *)v13 + 16);
  *(void *)(v12 + 24) += *((void *)v13 + 3);
  double v15 = v13[4];
  if (v15 < v14) {
    *(double *)(v12 + 32) = v15;
  }
  double v16 = v13[5];
  double v18 = *(double *)(v12 + 40);
  double v17 = (double *)(v12 + 40);
  HIDWORD(v19) = HIDWORD(v18);
  if (v16 > v18) {
    *double v17 = v16;
  }
  for (uint64_t i = 0; i != 5; ++i)
    *(unsigned char *)(a2 + 40 * v8 + 48 + i) |= *((unsigned char *)&context[5 * v8 + 6] + i);
  uint64_t v21 = *(void *)(a1 + 32);
  uint64_t v22 = *(void *)(v21 + 16);
  double v23 = *(double *)(v21 + 32);
  if (v23 > 0.0)
  {
    LODWORD(v19) = *(_DWORD *)(v21 + 40);
    *(_DWORD *)(a2 + 96 * v22 + 104) += ((double)v19 / v23);
  }
  if (*(void *)(v21 + 8 * v22 + 48) <= 0x10000uLL) {
    ++*(_DWORD *)(a2 + 4 * v22 + 1056);
  }
}

uint64_t mmcs_request_queue_entry_ensure_minimum_bytes_per_period_requirement(uint64_t result, unsigned int a2, double a3)
{
  if (!result || (uint64_t v3 = *(void *)(result + 32)) == 0) {
    mmcs_request_queue_entry_ensure_minimum_bytes_per_period_requirement_cold_1();
  }
  double v4 = *(double *)(v3 + 32);
  double v5 = 0.0;
  double v6 = 0.0;
  if (v4 > 0.0)
  {
    LODWORD(v6) = *(_DWORD *)(v3 + 40);
    double v6 = (double)*(unint64_t *)&v6 / v4;
  }
  if (a3 > 0.0) {
    double v5 = (double)a2 / a3;
  }
  if (v6 < v5)
  {
    *(_DWORD *)(v3 + 40) = a2;
    *(double *)(v3 + 32) = a3;
  }
  return result;
}

BOOL mmcs_request_queue_entry_is_small_request(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 32) + 8 * *(void *)(*(void *)(a1 + 32) + 16) + 48) <= 0x10000uLL;
}

uint64_t mmcs_request_queue_entry_did_transmit(uint64_t a1, uint64_t a2, double a3)
{
  CFArrayRef Mutable = *(const __CFArray **)(a1 + 40);
  if (!Mutable)
  {
    CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    *(void *)(a1 + 40) = Mutable;
  }
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    unint64_t v8 = Count + 1;
    do
    {
      CFDataRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), v8 - 2);
      if (*((double *)ValueAtIndex + 1) < a3)
      {
        uint64_t v10 = ValueAtIndex;
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 40), v8 - 2);
        free(v10);
      }
      --v8;
    }
    while (v8 > 1);
  }
  CFIndex v11 = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
  if (v11 < 1) {
    goto LABEL_17;
  }
  int v12 = 0;
  unint64_t v13 = v11 + 1;
  do
  {
    double v14 = (double *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), v13 - 2);
    double v15 = v14[1];
    double v16 = *(double *)(a2 + 8);
    if (floor(v15 / 0.1) < floor(v16 / 0.1)) {
      break;
    }
    if (*((void *)v14 + 3) == *(void *)(a2 + 24))
    {
      *((void *)v14 + 2) += *(void *)(a2 + 16);
      if (v15 <= v16) {
        double v15 = v16;
      }
      v14[1] = v15;
      int v12 = 1;
    }
    --v13;
  }
  while (v13 > 1);
  if (!v12)
  {
LABEL_17:
    mmcs_network_activity_copy(a2);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v17);
  }
  return 1;
}

void _mmcs_request_queue_entryCFFinalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if (*(void *)(v2 + 24))
    {
      CFRelease(*(CFTypeRef *)(v2 + 24));
      uint64_t v2 = *(void *)(a1 + 32);
    }
    *(void *)(v2 + 24) = 0;
    uint64_t v3 = *(void (**)(void))(v2 + 152);
    if (!v3 || (v3(*(void *)(v2 + 8)), (uint64_t v2 = *(void *)(a1 + 32)) != 0)) {
      free((void *)v2);
    }
    *(void *)(a1 + 32) = 0;
  }
  CFArrayRef v4 = *(const __CFArray **)(a1 + 40);
  if (v4)
  {
    v6.unsigned int length = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    v6.CFIndex location = 0;
    CFArrayApplyFunction(v4, v6, (CFArrayApplierFunction)_CFArrayApplierFunction_Free_0, 0);
    double v5 = *(const void **)(a1 + 40);
    if (v5) {
      CFRelease(v5);
    }
    *(void *)(a1 + 40) = 0;
  }
}

BOOL _mmcs_request_queue_entryCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_request_queue_entryCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_request_queue_entryCFCopyDebugDescription()
{
  return 0;
}

void _CFArrayApplierFunction_Free_0(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t mmcs_transaction_create(uint64_t *a1, const void *a2)
{
  *a1 = 0;
  uint64_t v4 = C3TypeRegister(&mmcs_transactionGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v4, 0x38uLL);
  if (result)
  {
    uint64_t v6 = result;
    *(void *)(result + 64) = a2;
    if (a2) {
      C3BaseRetain(a2);
    }
    uint64_t result = 1;
    *(_DWORD *)(v6 + 48) = 1;
    *(void *)(v6 + 16) = 0;
    *(void *)(v6 + 24) = 0;
    *(void *)(v6 + 32) = 6;
    *(void *)(v6 + 40) = 0;
    *a1 = v6;
  }
  return result;
}

void mmcs_transaction_invalidate(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(const void **)(a1 + 64);
    if (v2) {
      C3BaseRelease(v2);
    }
    *(void *)(a1 + 64) = 0;
  }
}

uint64_t mmcs_transaction_add_method_completion_info(uint64_t a1, void *value)
{
  CFArrayRef Mutable = *(__CFArray **)(a1 + 40);
  if (!Mutable)
  {
    CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    *(void *)(a1 + 40) = Mutable;
  }
  uint64_t v5 = 0;
  if (value && Mutable)
  {
    CFArrayAppendValue(Mutable, value);
    return 1;
  }
  return v5;
}

uint64_t mmcs_transaction_cancel_enqueued(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (gMMCS_DebugLevel >= 5)
  {
    uint64_t v6 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"transaction (%p) cancel state %d", a1, a1[12]);
      unint64_t v8 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v11 = v7;
        _os_log_impl(&dword_1DC1CA000, v8, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
  }
  if (a1[12] != 2) {
    mmcs_transaction_cancel_enqueued_cold_1();
  }
  a1[12] = 4;
  return mmcs_request_queue_cancel_request(a2, a1, a3);
}

void mmcs_transaction_cancel_not_enqueued(uint64_t a1, __CFError *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (gMMCS_DebugLevel >= 5)
  {
    uint64_t v4 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"transaction (%p) cancel state %d", a1, *(unsigned int *)(a1 + 48));
      uint64_t v6 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v8 = v5;
        _os_log_impl(&dword_1DC1CA000, v6, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
  }
  if (*(_DWORD *)(a1 + 48) == 2) {
    mmcs_transaction_cancel_not_enqueued_cold_1();
  }
  *(_DWORD *)(a1 + 48) = 4;
  mmcs_http_context_should_cancel(*(unsigned char **)(a1 + 16), a2);
}

void mmcs_transaction_should_stop_with_error(uint64_t a1, __CFError *a2)
{
}

BOOL mmcs_transaction_is_proxy(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  return v1 && *(void *)(v1 + 24) == a1;
}

void mmcs_transaction_append_description(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)a1;
  if (*(void *)a1)
  {
    long long v3 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)long long buf = *(_OWORD *)a1;
    long long v16 = v3;
    long long v17 = *(_OWORD *)(a1 + 32);
    if ((*(_DWORD *)(v2 + 48) & 0xFFFFFFFE) != 2) {
      return;
    }
    mmcs_op_requestor_context_indent(a1);
    int v4 = *(_DWORD *)(v2 + 48);
    if (v4 == 3)
    {
      ++*(void *)(a1 + 32);
      ++*((void *)&v16 + 1);
      uint64_t v13 = *(void *)(v2 + 64);
      double v14 = "cloud";
      if (v13 && *(void *)(v13 + 24) == v2) {
        double v14 = "proxy";
      }
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @"<%s transaction>", v14);
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @" in-flight\n");
      if (*(void *)(v2 + 16))
      {
        *(void *)long long buf = *(void *)(v2 + 16);
        mmcs_http_context_append_description((uint64_t)buf);
      }
    }
    else
    {
      if (v4 == 2)
      {
        uint64_t v5 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = v5 + 1;
        if (v5 > 9) {
          return;
        }
        uint64_t v6 = *(void *)(v2 + 64);
        CFStringRef v7 = "cloud";
        if (v6 && *(void *)(v6 + 24) == v2) {
          CFStringRef v7 = "proxy";
        }
        CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @"<%s transaction>", v7);
        CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @" enqueued");
        CFStringRef v8 = mmcs_http_request_copy_description(*(void *)(v2 + 24));
        if (v8)
        {
          CFStringRef v9 = v8;
          CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @" %@", v8);
          CFRelease(v9);
        }
      }
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 16), 0, @"\n");
    }
  }
  else
  {
    uint64_t v10 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"null transaction in opContext %p payload!", a1);
      uint64_t v12 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
  }
}

__CFArray *mmcs_transaction_make_req_context_metrics(__CFArray *result, uint64_t a2, uint64_t a3, const void *a4, const void *a5)
{
  if (result)
  {
    uint64_t v5 = result;
    uint64_t result = (__CFArray *)*((void *)result + 2);
    if (result)
    {
      uint64_t v7 = *((void *)v5 + 8);
      if (v7) {
        LOBYTE(v7) = *(void *)(v7 + 24) == (void)v5;
      }
      mmcs_http_context_make_metrics((char *)result, a4, a5, a3, v7);
      current_request_uint64_t metrics = (__CFArray *)mmcs_get_req_context_get_current_request_metrics(a2);
      uint64_t metrics = (void *)mmcs_http_context_get_metrics(*((void *)v5 + 2));
      return mmcs_metrics_request_add_http_info_for_transfer(current_request_metrics, metrics);
    }
  }
  return result;
}

void mmcs_transaction_log_timing(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = mmcs_logging_logger_summary();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG) && *(void *)(a1 + 16))
  {
    long long v3 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v5 = mmcs_http_context_class_description(*(void *)(a1 + 16));
      CFStringRef v6 = CFStringCreateWithFormat(v4, 0, @"\t        http class:\t%@", v5);
      uint64_t v7 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v37 = v6;
        _os_log_impl(&dword_1DC1CA000, v7, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v6) {
        CFRelease(v6);
      }
    }
    CFStringRef v8 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      double v10 = mmcs_http_context_enqueued_seconds(*(void *)(a1 + 16));
      CFStringRef v11 = CFStringCreateWithFormat(v9, 0, @"\t        queue time:\t%0.4lf sec.", *(void *)&v10);
      uint64_t v12 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v37 = v11;
        _os_log_impl(&dword_1DC1CA000, v12, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
    uint64_t v13 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      double v15 = mmcs_http_context_elapsed_seconds(*(void *)(a1 + 16));
      CFStringRef v16 = CFStringCreateWithFormat(v14, 0, @"\t     transfer time:\t%0.4lf sec.", *(void *)&v15);
      long long v17 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v37 = v16;
        _os_log_impl(&dword_1DC1CA000, v17, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v16) {
        CFRelease(v16);
      }
    }
    uint64_t v18 = mmcs_logging_logger_summary();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v20 = mmcs_http_context_actual_bytes_read(*(void *)(a1 + 16));
      CFStringRef v21 = CFStringCreateWithFormat(v19, 0, @"\t     bytes read:\t%lld bytes", v20);
      uint64_t v22 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v37 = v21;
        _os_log_impl(&dword_1DC1CA000, v22, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
      }
      if (v21) {
        CFRelease(v21);
      }
    }
    if (mmcs_http_context_elapsed_seconds(*(void *)(a1 + 16)) > 0.0)
    {
      double v23 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        double v25 = (double)mmcs_http_context_actual_bytes_read(*(void *)(a1 + 16));
        double v26 = mmcs_http_context_elapsed_seconds(*(void *)(a1 + 16));
        CFStringRef v27 = CFStringCreateWithFormat(v24, 0, @"\t        throughput:\t%.3lf bytes/sec", v25 / v26);
        unsigned int v28 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v37 = v27;
          _os_log_impl(&dword_1DC1CA000, v28, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v27) {
          CFRelease(v27);
        }
      }
    }
    if (mmcs_http_context_elapsed_seconds(*(void *)(a1 + 16)) > 0.0)
    {
      int v29 = mmcs_logging_logger_summary();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        double v31 = (double)mmcs_http_context_actual_bytes_read(*(void *)(a1 + 16));
        double v32 = mmcs_http_context_elapsed_seconds(*(void *)(a1 + 16));
        double v33 = mmcs_http_context_enqueued_seconds(*(void *)(a1 + 16));
        CFStringRef v34 = CFStringCreateWithFormat(v30, 0, @"\t effective throughput:\t%.3lf bytes/sec", v31 / (v32 + v33));
        CFStringRef v35 = mmcs_logging_logger_summary();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543362;
          CFStringRef v37 = v34;
          _os_log_impl(&dword_1DC1CA000, v35, OS_LOG_TYPE_DEBUG, "%{public}@", buf, 0xCu);
        }
        if (v34) {
          CFRelease(v34);
        }
      }
    }
  }
}

uint64_t mmcs_transaction_get_bytes_from_caching_server(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2 || !mmcs_http_context_has_bytes_read(v2)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  return mmcs_http_context_bytes_read(v3);
}

void _mmcs_transactionCFFinalize(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 48) == 2)
  {
    uint64_t v2 = mmcs_logging_logger_default();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Finalizing transaction %p while it is still enqueued", a1);
      CFAllocatorRef v4 = mmcs_logging_logger_default();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v11 = v3;
        _os_log_impl(&dword_1DC1CA000, v4, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (v3) {
        CFRelease(v3);
      }
    }
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (v5)
  {
    mmcs_http_context_invalidate(v5);
    CFStringRef v6 = *(const void **)(a1 + 16);
    if (v6) {
      C3BaseRelease(v6);
    }
  }
  *(void *)(a1 + 16) = 0;
  CFArrayRef v7 = *(const __CFArray **)(a1 + 40);
  if (v7)
  {
    v13.unsigned int length = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    v13.CFIndex location = 0;
    CFArrayApplyFunction(v7, v13, (CFArrayApplierFunction)_free_methodCompletionInfo, 0);
    CFStringRef v8 = *(const void **)(a1 + 40);
    if (v8) {
      CFRelease(v8);
    }
    *(void *)(a1 + 40) = 0;
  }
  CFAllocatorRef v9 = *(const void **)(a1 + 24);
  if (v9) {
    C3BaseRelease(v9);
  }
  *(void *)(a1 + 24) = 0;
}

BOOL _mmcs_transactionCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_transactionCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_transactionCFCopyDebugDescription()
{
  return 0;
}

void **_free_methodCompletionInfo(void **a1)
{
  return chunkserver__method_completion_info__free_unpacked(a1, 0);
}

double metricsinfo__httpmetrics_info__init(_OWORD *a1)
{
  a1[12] = xmmword_1E6C34B70;
  a1[13] = unk_1E6C34B80;
  a1[14] = xmmword_1E6C34B90;
  a1[8] = xmmword_1E6C34B30;
  a1[9] = unk_1E6C34B40;
  a1[10] = xmmword_1E6C34B50;
  a1[11] = unk_1E6C34B60;
  a1[4] = xmmword_1E6C34AF0;
  a1[5] = unk_1E6C34B00;
  a1[6] = xmmword_1E6C34B10;
  a1[7] = unk_1E6C34B20;
  *a1 = metricsinfo__httpmetrics_info__init_init_value;
  a1[1] = unk_1E6C34AC0;
  double result = dbl_1E6C34AE0[0];
  a1[2] = xmmword_1E6C34AD0;
  a1[3] = *(_OWORD *)dbl_1E6C34AE0;
  return result;
}

void **metricsinfo__httpmetrics_info__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &metricsinfo__httpmetrics_info__descriptor) {
      metricsinfo__httpmetrics_info__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

double metricsinfo__socket_info__init(_OWORD *a1)
{
  *a1 = metricsinfo__socket_info__init_init_value;
  a1[1] = *(_OWORD *)algn_1E6C34BB0;
  double result = 0.0;
  a1[2] = xmmword_1E6C34BC0;
  return result;
}

void **metricsinfo__socket_info__free_unpacked(void **result, uint64_t (**a2)())
{
  if (result)
  {
    if (*result != &metricsinfo__socket_info__descriptor) {
      metricsinfo__socket_info__free_unpacked_cold_1();
    }
    return (void **)protobuf_c_message_free_unpacked(result, a2);
  }
  return result;
}

uint64_t mmcs_update_item_create(uint64_t *a1, const __CFData *a2, const __CFString *a3, CFTypeRef *a4, CFTypeRef *a5)
{
  *a1 = 0;
  uint64_t v10 = C3TypeRegister(&mmcs_update_itemGetTypeID_typeID);
  uint64_t result = C3TypeCreateInstance_(0, v10, 0x78uLL);
  if (result)
  {
    uint64_t v12 = result;
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *(void *)(result + 16) = CFDataCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    *(void *)(v12 + 24) = CFStringCreateCopy(v13, a3);
    if (a4) {
      mmcs_wrapping_state_set_reference_signature_and_object(v12 + 64, *a4, a4[1]);
    }
    if (a5) {
      mmcs_wrapping_state_set_reference_signature_and_object(v12 + 80, *a5, a5[1]);
    }
    *a1 = v12;
    return 1;
  }
  return result;
}

void mmcs_update_item_set_chunk_signatures_keys_and_lengths(void *a1, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  if (a4) {
    CFRetain(a4);
  }
  CFStringRef v8 = (const void *)a1[12];
  if (v8) {
    CFRelease(v8);
  }
  a1[12] = 0;
  CFAllocatorRef v9 = (const void *)a1[13];
  if (v9) {
    CFRelease(v9);
  }
  a1[13] = 0;
  uint64_t v10 = (const void *)a1[14];
  if (v10) {
    CFRelease(v10);
  }
  a1[12] = cf;
  a1[13] = a3;
  a1[14] = a4;
}

uint64_t mmcs_update_item_set_padded_file_size(uint64_t result, uint64_t a2)
{
  *(void *)(result + 120) = a2;
  return result;
}

uint64_t mmcs_update_item_set_file_size(uint64_t result, uint64_t a2)
{
  *(void *)(result + 128) = a2;
  return result;
}

CFStringRef mmcs_update_item_copy_description(const __CFData **a1)
{
  CFStringRef StringDescription = XCFDataCreateStringDescription(a1[2]);
  CFDataRef v3 = a1[8];
  if (v3) {
    CFStringRef v4 = XCFDataCreateStringDescription(v3);
  }
  else {
    CFStringRef v4 = @"(null reference)";
  }
  CFDataRef v5 = a1[10];
  if (v5) {
    CFStringRef v6 = XCFDataCreateStringDescription(v5);
  }
  else {
    CFStringRef v6 = @"(null reference)";
  }
  CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<UpdateItem sig %@ unwrap %@ wrap %@>", StringDescription, v4, v6);
  if (StringDescription) {
    CFRelease(StringDescription);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v6) {
    CFRelease(v6);
  }
  return v7;
}

CFStringRef mmcs_update_item_copy_short_description(uint64_t a1)
{
  CFStringRef StringDescription = XCFDataCreateStringDescription(*(const __CFData **)(a1 + 16));
  CFDataRef v3 = *(const __CFData **)(a1 + 64);
  if (v3) {
    CFStringRef v4 = XCFDataCreateStringDescription(v3);
  }
  else {
    CFStringRef v4 = @"(null reference)";
  }
  CFDataRef v5 = *(const __CFData **)(a1 + 80);
  if (v5) {
    CFStringRef v6 = XCFDataCreateStringDescription(v5);
  }
  else {
    CFStringRef v6 = @"(null reference)";
  }
  CFStringRef v7 = *(__CFError **)(a1 + 40);
  if (v7)
  {
    CFStringRef v8 = mmcs_cferror_copy_short_description(v7);
    CFStringRef v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[%@(%@): %@ --> %@ ==> %@]", StringDescription, *(void *)(a1 + 24), v4, v6, v8);
    if (v8) {
      CFRelease(v8);
    }
    if (StringDescription) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 48);
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v13 = *(void *)(a1 + 24);
    if (v11) {
      CFStringRef v14 = CFStringCreateWithFormat(v12, 0, @"[%@(%@): %@ --> %@ ==> '%@']", StringDescription, v13, v4, v6, v11);
    }
    else {
      CFStringRef v14 = CFStringCreateWithFormat(v12, 0, @"[%@(%@): %@ --> %@]", StringDescription, v13, v4, v6);
    }
    CFStringRef v9 = v14;
    if (StringDescription) {
LABEL_11:
    }
      CFRelease(StringDescription);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v6) {
    CFRelease(v6);
  }
  return v9;
}

uint64_t mmcs_update_item_equal_file_unwrapping_reference(uint64_t a1, uint64_t a2)
{
  uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if (result) {
    return mmcs_wrapping_state_is_equal((const void **)(a1 + 64), (const void **)(a2 + 64)) != 0;
  }
  return result;
}

unint64_t mmcs_update_item_hash_file_unwrapping_reference(uint64_t a1)
{
  CFHashCode v2 = CFHash(*(CFTypeRef *)(a1 + 16));
  return (unint64_t)mmcs_wrapping_state_hash((const void **)(a1 + 64)) ^ v2;
}

uint64_t mmcs_update_item_equal_file_wrapping_reference(uint64_t a1, uint64_t a2)
{
  uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if (result) {
    return mmcs_wrapping_state_is_equal((const void **)(a1 + 80), (const void **)(a2 + 80)) != 0;
  }
  return result;
}

unint64_t mmcs_update_item_hash_file_wrapping_reference(uint64_t a1)
{
  CFHashCode v2 = CFHash(*(CFTypeRef *)(a1 + 16));
  return (unint64_t)mmcs_wrapping_state_hash((const void **)(a1 + 80)) ^ v2;
}

void mmcs_update_item_set_put_receipt(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 48);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 48) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

void mmcs_update_item_set_put_receipt_expiry(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 56);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 56) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

void mmcs_update_item_set_error(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 40);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 40) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

void mmcs_update_item_set_MIME_type(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 32);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 32) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

BOOL mmcs_update_item_is_done(uint64_t a1)
{
  return *(void *)(a1 + 40) || *(void *)(a1 + 48) != 0;
}

void mmcs_update_item_set_error_if_not_already_done(uint64_t a1, const void *a2)
{
  if (!a2) {
    mmcs_update_item_set_error_if_not_already_done_cold_1();
  }
  if (!*(void *)(a1 + 40) && !*(void *)(a1 + 48))
  {
    mmcs_update_item_set_error(a1, a2);
  }
}

void mmcs_update_item_set_put_receipt_if_not_already_done(uint64_t a1, const void *a2, const void *a3)
{
  if (!a2) {
    mmcs_update_item_set_put_receipt_if_not_already_done_cold_1();
  }
  if (!*(void *)(a1 + 40) && !*(void *)(a1 + 48))
  {
    mmcs_update_item_set_put_receipt(a1, a2);
    mmcs_update_item_set_put_receipt_expiry(a1, a3);
  }
}

void _mmcs_update_itemCFFinalize(void *a1)
{
  CFHashCode v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  a1[2] = 0;
  CFTypeRef v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  a1[3] = 0;
  CFStringRef v4 = (const void *)a1[5];
  if (v4) {
    CFRelease(v4);
  }
  a1[5] = 0;
  CFDataRef v5 = (const void *)a1[4];
  if (v5) {
    CFRelease(v5);
  }
  a1[4] = 0;
  CFStringRef v6 = (const void *)a1[6];
  if (v6) {
    CFRelease(v6);
  }
  a1[6] = 0;
  CFStringRef v7 = (const void *)a1[7];
  if (v7) {
    CFRelease(v7);
  }
  a1[7] = 0;
  CFStringRef v8 = (const void *)a1[12];
  if (v8) {
    CFRelease(v8);
  }
  a1[12] = 0;
  CFStringRef v9 = (const void *)a1[13];
  if (v9) {
    CFRelease(v9);
  }
  a1[13] = 0;
  uint64_t v10 = (const void *)a1[14];
  if (v10) {
    CFRelease(v10);
  }
  a1[14] = 0;
  mmcs_wrapping_state_set_reference_signature_and_object((uint64_t)(a1 + 8), 0, 0);
  mmcs_wrapping_state_set_reference_signature_and_object((uint64_t)(a1 + 10), 0, 0);
}

BOOL _mmcs_update_itemCFEqual(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _mmcs_update_itemCFCopyFormatDescription()
{
  return 0;
}

uint64_t _mmcs_update_itemCFCopyDebugDescription()
{
  return 0;
}

CFStringRef mmcs_network_activity_copy_description(uint64_t a1)
{
  double v2 = *(double *)(a1 + 8) - *(double *)a1;
  double v3 = (double)*(uint64_t *)(a1 + 16) / v2;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v5 = mmcs_network_activity_type_as_c_string(*(void *)(a1 + 24));
  return CFStringCreateWithFormat(v4, 0, @"%s %ld bytes in %lf (%.1lf Bps)", v5, *(void *)(a1 + 16), *(void *)&v2, *(void *)&v3);
}

__n128 mmcs_network_activity_copy(uint64_t a1)
{
  double v2 = malloc_type_calloc(1uLL, 0x20uLL, 0x1000040E0EAB150uLL);
  if (v2)
  {
    __n128 result = *(__n128 *)a1;
    long long v4 = *(_OWORD *)(a1 + 16);
    *double v2 = *(_OWORD *)a1;
    v2[1] = v4;
  }
  return result;
}

uint64_t mmcs_network_activity_make@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  *(double *)a3 = a4;
  *(double *)(a3 + 8) = a5;
  *(void *)(a3 + 16) = result;
  *(void *)(a3 + 24) = a2;
  return result;
}

uint64_t mmcs_network_activity_bytes_for_start_end(uint64_t a1, uint64_t *a2, double *a3, double *a4, double a5, double a6)
{
  if (a2) {
    *a2 = 0;
  }
  if (*(double *)a1 <= 0.0) {
    return 0;
  }
  double v6 = *(double *)(a1 + 8);
  if (v6 <= 0.0) {
    return 0;
  }
  if (*(double *)a1 >= a5) {
    a5 = *(double *)a1;
  }
  if (v6 <= a6) {
    a6 = *(double *)(a1 + 8);
  }
  *a3 = a5;
  *a4 = a6;
  if (a5 < a6)
  {
    if (!a2) {
      return 1;
    }
    uint64_t v7 = (uint64_t)((a6 - a5) / (*(double *)(a1 + 8) - *(double *)a1) * (double)*(uint64_t *)(a1 + 16));
    uint64_t v8 = 1;
    goto LABEL_17;
  }
  uint64_t v8 = 0;
  if (a2 && a5 == a6)
  {
    uint64_t v8 = 0;
    uint64_t v7 = *(void *)(a1 + 16);
LABEL_17:
    *a2 = v7;
  }
  return v8;
}

uint64_t mmcs_request_type_for_behavior_and_activity(uint64_t a1, uint64_t a2)
{
  return a2 + 2 * a1;
}

uint64_t mmcs_request_type_get_activity_type(uint64_t a1)
{
  if (a1 >= 0) {
    return a1 & 1;
  }
  else {
    return -(a1 & 1);
  }
}

uint64_t mmcs_request_type_get_behavior_type(uint64_t a1)
{
  if (a1 >= 0) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = a1 + 1;
  }
  return v1 >> 1;
}

char *mmcs_request_type_as_c_string(uint64_t a1)
{
  if (a1 >= 0) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = a1 + 1;
  }
  unint64_t v2 = a1 - (v1 & 0xFFFFFFFFFFFFFFFELL);
  if (v2 == 1)
  {
    unint64_t v4 = v1 >> 1;
    if (v4 >= 5) {
      mmcs_request_type_as_c_string_cold_3();
    }
    CFDataRef v5 = off_1E6C35270;
  }
  else
  {
    if (v2) {
      mmcs_request_type_as_c_string_cold_1();
    }
    if (a1 >= 0) {
      uint64_t v3 = a1;
    }
    else {
      uint64_t v3 = a1 + 1;
    }
    unint64_t v4 = v3 >> 1;
    if (v4 >= 5) {
      mmcs_request_type_as_c_string_cold_2();
    }
    CFDataRef v5 = off_1E6C35248;
  }
  return v5[v4];
}

uint64_t do_alloc(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t))a1)(*(void *)(a1 + 16), a2);
}

uint64_t do_free(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void, uint64_t))(result + 8))(*(void *)(result + 16), a2);
  }
  return result;
}

uint64_t protobuf_c_message_get_packed_size(uint64_t a1)
{
  uint64_t v5 = 0;
  if (**(_DWORD **)a1 != 682290937) {
    __assert_rtn("protobuf_c_message_get_packed_size", "protobuf-c.c", 715, "((message)->descriptor)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC");
  }
  for (unsigned int i = 0; i < *(_DWORD *)(*(void *)a1 + 48); ++i)
  {
    unint64_t v4 = (unsigned int *)(*(void *)(*(void *)a1 + 56) + 72 * i);
    uint64_t v3 = (int *)(a1 + v4[6]);
    unint64_t v2 = (int *)(a1 + v4[5]);
    if (v4[3])
    {
      if ((v4[3] == 1 || v4[3] == 3) && (v4[12] & 4) != 0)
      {
        v5 += oneof_field_get_packed_size((uint64_t)v4, *v2, v3);
      }
      else if (v4[3] == 1)
      {
        v5 += optional_field_get_packed_size((uint64_t)v4, *v2, v3);
      }
      else if (v4[3] == 3)
      {
        v5 += unlabeled_field_get_packed_size((uint64_t)v4, v3);
      }
      else
      {
        v5 += repeated_field_get_packed_size(v4, *(void *)v2, (uint64_t *)v3);
      }
    }
    else
    {
      v5 += required_field_get_packed_size((uint64_t)v4, v3);
    }
  }
  for (unsigned int j = 0; j < *(_DWORD *)(a1 + 8); ++j)
    v5 += unknown_field_get_packed_size(*(void *)(a1 + 16) + 24 * j);
  return v5;
}

uint64_t required_field_get_packed_size(uint64_t a1, int *a2)
{
  uint64_t tag_size = get_tag_size(*(_DWORD *)(a1 + 8));
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  if (v2)
  {
    uint64_t v4 = v2;
    char v3 = 1;
  }
  else
  {
    uint64_t v4 = *(unsigned int *)(a1 + 16);
    char v3 = 0;
  }
  if (v3) {
    __assert_rtn("required_field_get_packed_size", "protobuf-c.c", 461, "0");
  }
  switch(v4)
  {
    case 0:
    case 13:
      uint64_t v12 = tag_size + int32_size(*a2);
      break;
    case 1:
      uint64_t v12 = tag_size + sint32_size(*a2);
      break;
    case 2:
    case 7:
      uint64_t v12 = tag_size + 4;
      break;
    case 3:
    case 8:
      uint64_t v12 = tag_size + uint64_size(*(void *)a2);
      break;
    case 4:
      uint64_t v12 = tag_size + sint64_size(*(void *)a2);
      break;
    case 5:
    case 9:
      uint64_t v12 = tag_size + 8;
      break;
    case 6:
      uint64_t v12 = tag_size + uint32_size(*a2);
      break;
    case 10:
      uint64_t v12 = tag_size + 4;
      break;
    case 11:
      uint64_t v12 = tag_size + 8;
      break;
    case 12:
      uint64_t v12 = tag_size + 1;
      break;
    case 14:
      if (*(void *)a2) {
        size_t v7 = strlen(*(const char **)a2);
      }
      else {
        size_t v7 = 0;
      }
      uint64_t v12 = tag_size + uint32_size(v7) + v7;
      break;
    case 15:
      uint64_t v8 = *(void *)a2;
      uint64_t v12 = tag_size + uint32_size(*(void *)a2) + v8;
      break;
    case 16:
      if (*(void *)a2) {
        uint64_t packed_size = protobuf_c_message_get_packed_size(*(void *)a2);
      }
      else {
        uint64_t packed_size = 0;
      }
      uint64_t v12 = tag_size + uint32_size(packed_size) + packed_size;
      break;
    default:
      JUMPOUT(0);
  }
  return v12;
}

uint64_t oneof_field_get_packed_size(uint64_t a1, int a2, int *a3)
{
  if (a2 != *(_DWORD *)(a1 + 8)) {
    return 0;
  }
  if ((*(_DWORD *)(a1 + 16) == 16 || *(_DWORD *)(a1 + 16) == 14)
    && (!*(void *)a3 || *(void *)a3 == *(void *)(a1 + 40)))
  {
    return 0;
  }
  return required_field_get_packed_size(a1, a3);
}

uint64_t optional_field_get_packed_size(uint64_t a1, int a2, int *a3)
{
  if (*(_DWORD *)(a1 + 16) != 16 && *(_DWORD *)(a1 + 16) != 14)
  {
    if (!a2) {
      return 0;
    }
    return required_field_get_packed_size(a1, a3);
  }
  if (*(void *)a3 && *(void *)a3 != *(void *)(a1 + 40)) {
    return required_field_get_packed_size(a1, a3);
  }
  return 0;
}

uint64_t unlabeled_field_get_packed_size(uint64_t a1, int *a2)
{
  if (field_is_zeroish(a1, a2)) {
    return 0;
  }
  else {
    return required_field_get_packed_size(a1, a2);
  }
}

uint64_t repeated_field_get_packed_size(unsigned int *a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v19 = 0;
  uint64_t v10 = *a3;
  if (!a2) {
    return 0;
  }
  uint64_t tag_size = get_tag_size(a1[2]);
  if ((a1[12] & 1) == 0) {
    tag_size *= a2;
  }
  unsigned int v3 = a1[4];
  if (v3)
  {
    uint64_t v5 = v3;
    char v4 = 1;
  }
  else
  {
    uint64_t v5 = a1[4];
    char v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    switch(v5)
    {
      case 0:
      case 13:
        for (unsigned int i = 0; i < a2; ++i)
          v19 += int32_size(*(_DWORD *)(v10 + 4 * i));
        break;
      case 1:
        for (unsigned int j = 0; j < a2; ++j)
          v19 += sint32_size(*(_DWORD *)(v10 + 4 * j));
        break;
      case 2:
      case 7:
      case 10:
        uint64_t v19 = 4 * a2;
        break;
      case 3:
      case 8:
        for (unsigned int k = 0; k < a2; ++k)
          v19 += uint64_size(*(void *)(v10 + 8 * k));
        break;
      case 4:
        for (unsigned int m = 0; m < a2; ++m)
          v19 += sint64_size(*(void *)(v10 + 8 * m));
        break;
      case 5:
      case 9:
      case 11:
        uint64_t v19 = 8 * a2;
        break;
      case 6:
        for (unsigned int n = 0; n < a2; ++n)
          v19 += uint32_size(*(_DWORD *)(v10 + 4 * n));
        break;
      case 12:
        uint64_t v19 = a2;
        break;
      case 14:
        for (iunsigned int i = 0; ii < a2; ++ii)
        {
          size_t v9 = strlen(*(const char **)(v10 + 8 * ii));
          v19 += uint32_size(v9) + v9;
        }
        break;
      case 15:
        for (junsigned int j = 0; jj < a2; ++jj)
        {
          uint64_t v8 = *(void *)(v10 + 16 * jj);
          v19 += uint32_size(v8) + v8;
        }
        break;
      case 16:
        for (kunsigned int k = 0; kk < a2; ++kk)
        {
          uint64_t packed_size = protobuf_c_message_get_packed_size(*(void *)(v10 + 8 * kk));
          v19 += uint32_size(packed_size) + packed_size;
        }
        break;
      default:
        JUMPOUT(0);
    }
  }
  if (a1[12]) {
    tag_size += uint32_size(v19);
  }
  return tag_size + v19;
}

uint64_t unknown_field_get_packed_size(uint64_t a1)
{
  return get_tag_size(*(_DWORD *)a1) + *(void *)(a1 + 8);
}

uint64_t protobuf_c_message_pack(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if (**(_DWORD **)a1 != 682290937) {
    __assert_rtn("protobuf_c_message_pack", "protobuf-c.c", 1478, "((message)->descriptor)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC");
  }
  for (unsigned int i = 0; i < *(_DWORD *)(*(void *)a1 + 48); ++i)
  {
    uint64_t v5 = (_DWORD *)(*(void *)(*(void *)a1 + 56) + 72 * i);
    char v4 = (signed int *)(a1 + v5[6]);
    unsigned int v3 = (int *)(a1 + v5[5]);
    if (v5[3])
    {
      if ((v5[3] == 1 || v5[3] == 3) && (v5[12] & 4) != 0)
      {
        v6 += oneof_field_pack((uint64_t)v5, *v3, v4, (unsigned char *)(a2 + v6));
      }
      else if (v5[3] == 1)
      {
        v6 += optional_field_pack((uint64_t)v5, *v3, v4, (unsigned char *)(a2 + v6));
      }
      else if (v5[3] == 3)
      {
        v6 += unlabeled_field_pack((uint64_t)v5, v4, (unsigned char *)(a2 + v6));
      }
      else
      {
        v6 += repeated_field_pack(v5, *(void *)v3, (signed int **)v4, (unsigned char *)(a2 + v6));
      }
    }
    else
    {
      v6 += required_field_pack((uint64_t)v5, v4, (unsigned char *)(a2 + v6));
    }
  }
  for (unsigned int j = 0; j < *(_DWORD *)(a1 + 8); ++j)
    v6 += unknown_field_pack(*(void *)(a1 + 16) + 24 * j, (unsigned char *)(a2 + v6));
  return v6;
}

uint64_t required_field_pack(uint64_t a1, signed int *a2, unsigned char *a3)
{
  uint64_t v7 = tag_pack(*(_DWORD *)(a1 + 8), a3);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = v3;
    char v4 = 1;
  }
  else
  {
    uint64_t v5 = *(unsigned int *)(a1 + 16);
    char v4 = 0;
  }
  if (v4) {
    __assert_rtn("required_field_pack", "protobuf-c.c", 1137, "0");
  }
  switch(v5)
  {
    case 0:
    case 13:
      *a3 = *a3;
      uint64_t v11 = v7 + int32_pack(*a2, &a3[v7]);
      break;
    case 1:
      *a3 = *a3;
      uint64_t v11 = v7 + sint32_pack(*a2, &a3[v7]);
      break;
    case 2:
    case 7:
    case 10:
      *a3 |= 5u;
      uint64_t v11 = v7 + fixed32_pack();
      break;
    case 3:
    case 8:
      *a3 = *a3;
      uint64_t v11 = v7 + uint64_pack(*(void *)a2, &a3[v7]);
      break;
    case 4:
      *a3 = *a3;
      uint64_t v11 = v7 + sint64_pack(*(void *)a2, &a3[v7]);
      break;
    case 5:
    case 9:
    case 11:
      *a3 |= 1u;
      uint64_t v11 = v7 + fixed64_pack();
      break;
    case 6:
      *a3 = *a3;
      uint64_t v11 = v7 + uint32_pack(*a2, &a3[v7]);
      break;
    case 12:
      *a3 = *a3;
      uint64_t v11 = v7 + BOOLean_pack(*a2, &a3[v7]);
      break;
    case 14:
      *a3 |= 2u;
      uint64_t v11 = v7 + string_pack(*(const char **)a2, &a3[v7]);
      break;
    case 15:
      *a3 |= 2u;
      uint64_t v11 = v7 + binary_data_pack((uint64_t *)a2, &a3[v7]);
      break;
    case 16:
      *a3 |= 2u;
      uint64_t v11 = v7 + prefixed_message_pack(*(void *)a2, &a3[v7]);
      break;
    default:
      JUMPOUT(0);
  }
  return v11;
}

uint64_t oneof_field_pack(uint64_t a1, int a2, signed int *a3, unsigned char *a4)
{
  if (a2 != *(_DWORD *)(a1 + 8)) {
    return 0;
  }
  if ((*(_DWORD *)(a1 + 16) == 16 || *(_DWORD *)(a1 + 16) == 14)
    && (!*(void *)a3 || *(void *)a3 == *(void *)(a1 + 40)))
  {
    return 0;
  }
  return required_field_pack(a1, a3, a4);
}

uint64_t optional_field_pack(uint64_t a1, int a2, signed int *a3, unsigned char *a4)
{
  if (*(_DWORD *)(a1 + 16) != 16 && *(_DWORD *)(a1 + 16) != 14)
  {
    if (!a2) {
      return 0;
    }
    return required_field_pack(a1, a3, a4);
  }
  if (*(void *)a3 && *(void *)a3 != *(void *)(a1 + 40)) {
    return required_field_pack(a1, a3, a4);
  }
  return 0;
}

uint64_t unlabeled_field_pack(uint64_t a1, signed int *a2, unsigned char *a3)
{
  if (field_is_zeroish(a1, a2)) {
    return 0;
  }
  else {
    return required_field_pack(a1, a2, a3);
  }
}

uint64_t repeated_field_pack(_DWORD *a1, unint64_t a2, signed int **a3, unsigned char *a4)
{
  CFAllocatorRef v24 = *a3;
  if (a1[12])
  {
    if (a2)
    {
      int v15 = tag_pack(a1[2], a4);
      *a4 |= 2u;
      int v14 = v15;
      unsigned int v13 = get_type_min_size(a1[4]) * a2;
      int v11 = uint32_size(v13);
      int v16 = v15 + v11;
      size_t v9 = &a4[v16];
      unsigned int v4 = a1[4];
      if (v4)
      {
        uint64_t v6 = v4;
        char v5 = 1;
      }
      else
      {
        uint64_t v6 = a1[4];
        char v5 = 0;
      }
      if (v5) {
        __assert_rtn("repeated_field_pack", "protobuf-c.c", 1434, "0");
      }
      switch(v6)
      {
        case 0:
        case 13:
          for (unsigned int i = 0; i < a2; ++i)
            v9 += int32_pack(v24[i], v9);
          break;
        case 1:
          for (unsigned int j = 0; j < a2; ++j)
            v9 += sint32_pack(v24[j], v9);
          break;
        case 2:
        case 7:
        case 10:
          copy_to_little_endian_32();
          LODWORD(v9) = v9 + 4 * a2;
          break;
        case 3:
        case 8:
          for (unsigned int k = 0; k < a2; ++k)
            v9 += uint64_pack(*(void *)&v24[2 * k], v9);
          break;
        case 4:
          for (unsigned int m = 0; m < a2; ++m)
            v9 += sint64_pack(*(void *)&v24[2 * m], v9);
          break;
        case 5:
        case 9:
        case 11:
          copy_to_little_endian_64();
          LODWORD(v9) = v9 + 8 * a2;
          break;
        case 6:
          for (unsigned int n = 0; n < a2; ++n)
            v9 += uint32_pack(v24[n], v9);
          break;
        case 12:
          for (iunsigned int i = 0; ii < a2; ++ii)
            v9 += BOOLean_pack(v24[ii], v9);
          break;
        default:
          JUMPOUT(0);
      }
      unsigned int v12 = v9 - (a4 + v16);
      int v10 = uint32_size(v12);
      if (v11 != v10)
      {
        if (v10 != v11 + 1) {
          __assert_rtn("repeated_field_pack", "protobuf-c.c", 1440, "actual_length_size == length_size_min + 1");
        }
        __memmove_chk();
        ++v16;
      }
      uint32_pack(v12, &a4[v14]);
      return v16 + v12;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *(_DWORD *)&v8[8] = 0;
    *(void *)uint64_t v8 = sizeof_elt_in_repeated_array(a1[4]);
    for (junsigned int j = 0; jj < a2; ++jj)
    {
      *(void *)&v8[4] += required_field_pack((uint64_t)a1, v24, &a4[*(void *)&v8[4]]);
      CFAllocatorRef v24 = (signed int *)((char *)v24 + *(unsigned int *)v8);
    }
    return *(void *)&v8[4];
  }
}

uint64_t unknown_field_pack(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = tag_pack(*(_DWORD *)a1, a2);
  *a2 |= *(_DWORD *)(a1 + 4);
  __memcpy_chk();
  return v3 + *(void *)(a1 + 8);
}

void *protobuf_c_message_unpack(uint64_t a1, uint64_t (**a2)(), unint64_t a3, char *a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v52 = a1;
  int v51 = a2;
  unint64_t v50 = a3;
  int v49 = a4;
  uint64_t v48 = 0;
  unint64_t v47 = a3;
  CFStringRef v46 = a4;
  uint64_t v45 = 0;
  uint64_t v45 = *(_DWORD **)(a1 + 56);
  memset(__b, 0, sizeof(__b));
  unsigned int v44 = 0;
  unsigned int v43 = 0;
  uint64_t v42 = 0;
  unsigned int k = 0;
  unsigned int j = 0;
  unsigned int m = 0;
  unsigned int v38 = 0;
  unsigned int v37 = 0;
  CFArrayRef v36 = &v54;
  int v35 = 0;
  if (*(_DWORD *)v52 != 682290937) {
    __assert_rtn("protobuf_c_message_unpack", "protobuf-c.c", 3056, "(desc)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC");
  }
  if (!v51) {
    int v51 = protobuf_c__allocator;
  }
  uint64_t v48 = (void *)do_alloc((uint64_t)v51, *(void *)(v52 + 40));
  if (!v48) {
    return 0;
  }
  __b[0] = &v56;
  unsigned int v37 = (*(_DWORD *)(v52 + 48) + 7) / 8u;
  if (v37 > 0x10uLL)
  {
    CFArrayRef v36 = (char *)do_alloc((uint64_t)v51, v37);
    if (!v36)
    {
      do_free((uint64_t)v51, (uint64_t)v48);
      return 0;
    }
    int v35 = 1;
  }
  __memset_chk();
  if (*(void *)(v52 + 88)) {
    protobuf_c_message_init(v52, (uint64_t)v48);
  }
  else {
    message_init_generic(v52, v48);
  }
  while (v47)
  {
    int v34 = 0;
    unsigned __int8 v33 = 0;
    uint64_t v32 = 0;
    uint64_t v32 = parse_tag_and_wiretype(v47, v46, &v34, &v33);
    double v31 = 0;
    long long v29 = 0u;
    long long v30 = 0u;
    if (!v32) {
      goto LABEL_107;
    }
    if (v45 && v45[2] == v34)
    {
      double v31 = v45;
    }
    else
    {
      int v28 = 0;
      int v28 = int_range_lookup(*(_DWORD *)(v52 + 72), *(void *)(v52 + 80), v34);
      if (v28 >= 0)
      {
        double v31 = (_DWORD *)(*(void *)(v52 + 56) + 72 * v28);
        uint64_t v45 = v31;
        unsigned int v38 = v28;
      }
      else
      {
        double v31 = 0;
        ++v42;
      }
    }
    if (v31 && !v31[3]) {
      v36[v38 / 8] |= 1 << (v38 % 8);
    }
    v46 += v32;
    v47 -= v32;
    LODWORD(v29) = v34;
    WORD2(v29) = v33;
    *((void *)&v29 + 1) = v31;
    *((void *)&v30 + 1) = v46;
    if (v33)
    {
      uint64_t v5 = v33;
      char v4 = 1;
    }
    else
    {
      uint64_t v5 = 0;
      char v4 = 0;
    }
    if (v4) {
      goto LABEL_107;
    }
    switch(v5)
    {
      case 0:
        unsigned int v27 = 0;
        if (v47 >= 0xA) {
          int v13 = 10;
        }
        else {
          int v13 = v47;
        }
        unsigned int v27 = v13;
        for (unsigned int i = 0; i < v27 && v46[i] < 0; ++i)
          ;
        if (i == v27) {
          goto LABEL_107;
        }
        *(void *)&long long v30 = i + 1;
        break;
      case 1:
        if (v47 < 8) {
          goto LABEL_107;
        }
        *(void *)&long long v30 = 8;
        break;
      case 2:
        uint64_t v25 = 0;
        *(void *)&long long v30 = scan_length_prefixed_data(v47, (uint64_t)v46, &v25);
        if (!(void)v30) {
          goto LABEL_107;
        }
        BYTE5(v29) = v25;
        break;
      case 3:
      case 4:
        goto LABEL_107;
      case 5:
        if (v47 < 4) {
          goto LABEL_107;
        }
        *(void *)&long long v30 = 4;
        break;
      default:
        JUMPOUT(0);
    }
    if (v43 == 1 << (v44 + 4))
    {
      uint64_t v24 = 0;
      unsigned int v43 = 0;
      if (v44 == 22
        || (++v44, v24 = 32 << (v44 + 4), uint64_t v6 = do_alloc((uint64_t)v51, v24), (__b[v44] = v6) == 0))
      {
LABEL_107:
        do_free((uint64_t)v51, (uint64_t)v48);
        for (unsigned int j = 1; j <= v44; ++j)
          do_free((uint64_t)v51, __b[j]);
        if (v35) {
          do_free((uint64_t)v51, (uint64_t)v36);
        }
        return 0;
      }
    }
    uint64_t v7 = __b[v44];
    uint64_t v8 = v43++;
    size_t v9 = (_OWORD *)(v7 + 32 * v8);
    *size_t v9 = v29;
    v9[1] = v30;
    if (v31 && v31[3] == 2)
    {
      double v23 = 0;
      double v23 = (void *)((char *)v48 + v31[5]);
      if (v33 == 2 && ((v31[12] & 1) != 0 || is_packable_type(v31[4])))
      {
        uint64_t v22 = 0;
        if (!count_packed_elements(v31[4], v30 - BYTE5(v29), (unsigned char *)(*((void *)&v30 + 1) + BYTE5(v29)), &v22))goto LABEL_107; {
        *v23 += v22;
        }
      }
      else
      {
        ++*v23;
      }
    }
    v46 += v30;
    v47 -= v30;
  }
  for (unsigned int k = 0; k < *(_DWORD *)(v52 + 48); ++k)
  {
    uint64_t v19 = *(void *)(v52 + 56) + 72 * k;
    if (*(_DWORD *)(v19 + 12) == 2)
    {
      uint64_t v18 = sizeof_elt_in_repeated_array(*(_DWORD *)(v19 + 16));
      long long v17 = (void *)((char *)v48 + *(unsigned int *)(v19 + 20));
      if (*v17)
      {
        unsigned int v16 = *v17;
        *long long v17 = 0;
        if (!*v48) {
          __assert_rtn("protobuf_c_message_unpack", "protobuf-c.c", 3242, "rv->descriptor != NULL");
        }
        uint64_t v15 = do_alloc((uint64_t)v51, v18 * v16);
        if (!v15)
        {
          ++k;
          while (k < *(_DWORD *)(v52 + 48))
          {
            uint64_t v20 = *(void *)(v52 + 56) + 72 * k;
            if (*(_DWORD *)(v20 + 12) == 2) {
              *(void *)((char *)v48 + *(unsigned int *)(v20 + 20)) = 0;
            }
            ++k;
          }
          goto LABEL_101;
        }
        *(void *)((char *)v48 + *(unsigned int *)(v19 + 24)) = v15;
      }
    }
    else if (!*(_DWORD *)(v19 + 12) {
           && !*(void *)(v19 + 40)
    }
           && (v36[k / 8] & (unint64_t)(1 << (k % 8))) == 0)
    {
      ++k;
      while (k < *(_DWORD *)(v52 + 48))
      {
        uint64_t v21 = *(void *)(v52 + 56) + 72 * k;
        if (*(_DWORD *)(v21 + 12) == 2) {
          *(void *)((char *)v48 + *(unsigned int *)(v21 + 20)) = 0;
        }
        ++k;
      }
      goto LABEL_101;
    }
  }
  if (v42)
  {
    uint64_t v10 = do_alloc((uint64_t)v51, 24 * v42);
    v48[2] = v10;
    if (!v48[2])
    {
LABEL_101:
      protobuf_c_message_free_unpacked(v48, v51);
      for (unsigned int j = 1; j <= v44; ++j)
        do_free((uint64_t)v51, __b[j]);
      if (v35) {
        do_free((uint64_t)v51, (uint64_t)v36);
      }
      return 0;
    }
  }
  for (unsigned int m = 0; m <= v44; ++m)
  {
    if (m == v44) {
      LODWORD(v12) = v43;
    }
    else {
      uint64_t v12 = 1 << (m + 4);
    }
    uint64_t v14 = __b[m];
    for (unsigned int j = 0; j < v12; ++j)
    {
      if (!parse_member(v14 + 32 * j, (uint64_t)v48, v51)) {
        goto LABEL_101;
      }
    }
  }
  for (unsigned int j = 1; j <= v44; ++j)
    do_free((uint64_t)v51, __b[j]);
  if (v35) {
    do_free((uint64_t)v51, (uint64_t)v36);
  }
  return v48;
}

uint64_t protobuf_c_message_init(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 88))(a2);
}

uint64_t message_init_generic(uint64_t a1, void *a2)
{
  uint64_t result = __memset_chk();
  *a2 = a1;
  for (unsigned int i = 0; i < *(_DWORD *)(a1 + 48); ++i)
  {
    if (*(void *)(*(void *)(a1 + 56) + 72 * i + 40) && *(_DWORD *)(*(void *)(a1 + 56) + 72 * i + 12) != 2)
    {
      unsigned int v3 = *(_DWORD *)(*(void *)(a1 + 56) + 72 * i + 16);
      if (v3)
      {
        uint64_t v5 = v3;
        char v4 = 1;
      }
      else
      {
        uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 56) + 72 * i + 16);
        char v4 = 0;
      }
      if ((v4 & 1) == 0)
      {
        switch(v5)
        {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 15:
            uint64_t result = __memcpy_chk();
            break;
          case 14:
          case 16:
            *(void *)((char *)a2 + *(unsigned int *)(*(void *)(a1 + 56) + 72 * i + 24)) = *(void *)(*(void *)(a1 + 56) + 72 * i + 40);
            break;
          default:
            JUMPOUT(0);
        }
      }
    }
  }
  return result;
}

uint64_t parse_tag_and_wiretype(unint64_t a1, char *a2, int *a3, unsigned char *a4)
{
  if (a1 <= 5) {
    unsigned int v5 = a1;
  }
  else {
    unsigned int v5 = 5;
  }
  int v8 = (*a2 & 0x7F) >> 3;
  char v7 = 4;
  if ((*a2 & 0xF8) == 0) {
    return 0;
  }
  *a4 = *a2 & 7;
  if (*a2 < 0)
  {
    for (unsigned int i = 1; i < v5; ++i)
    {
      if (a2[i] >= 0)
      {
        *a3 = v8 | (a2[i] << v7);
        return i + 1;
      }
      v8 |= (a2[i] & 0x7F) << v7;
      v7 += 7;
    }
    return 0;
  }
  else
  {
    *a3 = v8;
    return 1;
  }
}

uint64_t int_range_lookup(unsigned int a1, uint64_t a2, int a3)
{
  if (a1)
  {
    unsigned int v6 = 0;
    unsigned int v7 = a1;
    while (v7 > 1)
    {
      unsigned int v5 = v6 + v7 / 2;
      if (a3 >= *(_DWORD *)(a2 + 8 * v5))
      {
        if (a3 < *(_DWORD *)(a2 + 8 * v5) + *(_DWORD *)(a2 + 8 * (v5 + 1) + 4) - *(_DWORD *)(a2 + 8 * v5 + 4)) {
          return (a3 - *(_DWORD *)(a2 + 8 * v5) + *(_DWORD *)(a2 + 8 * v5 + 4));
        }
        v7 -= v7 / 2 + 1;
        unsigned int v6 = v5 + 1;
      }
      else
      {
        v7 /= 2u;
      }
    }
    if (v7
      && (int v4 = *(_DWORD *)(a2 + 8 * v6 + 4), *(_DWORD *)(a2 + 8 * v6) <= a3)
      && a3 < *(_DWORD *)(a2 + 8 * v6) + *(_DWORD *)(a2 + 8 * (v6 + 1) + 4) - v4)
    {
      return (a3 - *(_DWORD *)(a2 + 8 * v6) + v4);
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

unint64_t scan_length_prefixed_data(unint64_t a1, uint64_t a2, void *a3)
{
  if (a1 >= 5) {
    unsigned int v4 = 5;
  }
  else {
    unsigned int v4 = a1;
  }
  unint64_t v7 = 0;
  int v5 = 0;
  for (unsigned int i = 0; i < v4; ++i)
  {
    v7 |= (unint64_t)(*(unsigned char *)(a2 + i) & 0x7F) << v5;
    v5 += 7;
    if (*(char *)(a2 + i) >= 0) {
      break;
    }
  }
  if (i == v4) {
    return 0;
  }
  unsigned int v8 = i + 1;
  *a3 = i + 1;
  if (v7 > 0x7FFFFFFF) {
    return 0;
  }
  if (v8 + v7 <= a1) {
    return v8 + v7;
  }
  return 0;
}

BOOL is_packable_type(int a1)
{
  BOOL v2 = 0;
  if (a1 != 14)
  {
    BOOL v2 = 0;
    if (a1 != 15) {
      return a1 != 16;
    }
  }
  return v2;
}

uint64_t count_packed_elements(unsigned int a1, unint64_t a2, unsigned char *a3, void *a4)
{
  if (a1)
  {
    uint64_t v5 = a1;
    char v4 = 1;
  }
  else
  {
    uint64_t v5 = 0;
    char v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    switch(v5)
    {
      case 0:
      case 1:
      case 3:
      case 4:
      case 6:
      case 8:
      case 13:
        *a4 = max_b128_numbers(a2, a3);
        return 1;
      case 2:
      case 7:
      case 10:
        if (a2 % 4)
        {
          return 0;
        }
        else
        {
          *a4 = a2 / 4;
          return 1;
        }
      case 5:
      case 9:
      case 11:
        if (a2 % 8)
        {
          return 0;
        }
        else
        {
          *a4 = a2 / 8;
          return 1;
        }
      case 12:
        *a4 = a2;
        return 1;
      case 14:
      case 15:
      case 16:
        break;
      default:
        JUMPOUT(0);
    }
  }
  return 0;
}

uint64_t sizeof_elt_in_repeated_array(unsigned int a1)
{
  if (a1)
  {
    uint64_t v2 = a1;
    char v1 = 1;
  }
  else
  {
    uint64_t v2 = 0;
    char v1 = 0;
  }
  if (v1) {
    __assert_rtn("sizeof_elt_in_repeated_array", "protobuf-c.c", 1264, "0");
  }
  switch(v2)
  {
    case 0:
    case 1:
    case 2:
    case 6:
    case 7:
    case 10:
    case 13:
      uint64_t v4 = 4;
      break;
    case 3:
    case 4:
    case 5:
    case 8:
    case 9:
    case 11:
      uint64_t v4 = 8;
      break;
    case 12:
      uint64_t v4 = 4;
      break;
    case 14:
    case 16:
      uint64_t v4 = 8;
      break;
    case 15:
      uint64_t v4 = 16;
      break;
    default:
      JUMPOUT(0);
  }
  return v4;
}

uint64_t parse_member(uint64_t a1, uint64_t a2, uint64_t (**a3)())
{
  int v11 = *(_DWORD **)(a1 + 8);
  if (v11)
  {
    uint64_t v10 = (uint64_t *)(a2 + v11[6]);
    unsigned int v5 = v11[3];
    if (v5)
    {
      uint64_t v7 = v5;
      char v6 = 1;
    }
    else
    {
      uint64_t v7 = v11[3];
      char v6 = 0;
    }
    if (v6) {
      __assert_rtn("parse_member", "protobuf-c.c", 2931, "0");
    }
    switch(v7)
    {
      case 0:
        unsigned int v15 = parse_required_member(a1, v10, a3, 1);
        break;
      case 1:
      case 3:
        if ((v11[12] & 4) != 0) {
          unsigned int v15 = parse_oneof_member(a1, v10, a2, a3);
        }
        else {
          unsigned int v15 = parse_optional_member(a1, v10, a2, a3);
        }
        break;
      case 2:
        if (*(unsigned char *)(a1 + 4) == 2 && ((v11[12] & 1) != 0 || is_packable_type(v11[4]))) {
          unsigned int v15 = parse_packed_repeated_member(a1, v10, a2);
        }
        else {
          unsigned int v15 = parse_repeated_member(a1, v10, a2, a3);
        }
        break;
      default:
        JUMPOUT(0);
    }
  }
  else
  {
    uint64_t v3 = *(void *)(a2 + 16);
    uint64_t v4 = (*(_DWORD *)(a2 + 8))++;
    uint64_t v9 = v3 + 24 * v4;
    *(_DWORD *)uint64_t v9 = *(_DWORD *)a1;
    *(_DWORD *)(v9 + 4) = *(unsigned __int8 *)(a1 + 4);
    *(void *)(v9 + 8) = *(void *)(a1 + 16);
    *(void *)(v9 + 16) = do_alloc((uint64_t)a3, *(void *)(a1 + 16));
    if (*(void *)(v9 + 16))
    {
      __memcpy_chk();
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return v15;
}

void *protobuf_c_message_free_unpacked(void *result, uint64_t (**a2)())
{
  uint64_t v15 = (uint64_t)result;
  uint64_t v14 = a2;
  if (result)
  {
    int v13 = (_DWORD *)*result;
    if (*(_DWORD *)*result != 682290937) {
      __assert_rtn("protobuf_c_message_free_unpacked", "protobuf-c.c", 3330, "((message)->descriptor)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC");
    }
    if (!a2) {
      uint64_t v14 = protobuf_c__allocator;
    }
    *uint64_t result = 0;
    for (unsigned int i = 0; i < v13[12]; ++i)
    {
      if ((*(_DWORD *)(*((void *)v13 + 7) + 72 * i + 48) & 4) == 0
        || *(_DWORD *)(*((void *)v13 + 7) + 72 * i + 8) == *(_DWORD *)(v15
                                                                         + *(unsigned int *)(*((void *)v13 + 7)
                                                                                           + 72 * i
                                                                                           + 20)))
      {
        if (*(_DWORD *)(*((void *)v13 + 7) + 72 * i + 12) == 2)
        {
          unint64_t v10 = *(void *)(v15 + *(unsigned int *)(*((void *)v13 + 7) + 72 * i + 20));
          uint64_t v9 = *(void *)(v15 + *(unsigned int *)(*((void *)v13 + 7) + 72 * i + 24));
          if (v9)
          {
            switch(*(_DWORD *)(*((void *)v13 + 7) + 72 * i + 16))
            {
              case 0xE:
                for (unsigned int j = 0; j < v10; ++j)
                  do_free((uint64_t)v14, *(void *)(v9 + 8 * j));
                break;
              case 0xF:
                for (unsigned int k = 0; k < v10; ++k)
                  do_free((uint64_t)v14, *(void *)(v9 + 16 * k + 8));
                break;
              case 0x10:
                for (unsigned int m = 0; m < v10; ++m)
                  protobuf_c_message_free_unpacked(*(void *)(v9 + 8 * m), v14);
                break;
            }
            do_free((uint64_t)v14, v9);
          }
        }
        else
        {
          switch(*(_DWORD *)(*((void *)v13 + 7) + 72 * i + 16))
          {
            case 0xE:
              uint64_t v5 = *(void *)(v15 + *(unsigned int *)(*((void *)v13 + 7) + 72 * i + 24));
              if (v5 && v5 != *(void *)(*((void *)v13 + 7) + 72 * i + 40)) {
                do_free((uint64_t)v14, v5);
              }
              break;
            case 0xF:
              uint64_t v4 = *(void *)(v15 + *(unsigned int *)(*((void *)v13 + 7) + 72 * i + 24) + 8);
              uint64_t v3 = *(void *)(*((void *)v13 + 7) + 72 * i + 40);
              if (v4 && (!v3 || *(void *)(v3 + 8) != v4)) {
                do_free((uint64_t)v14, v4);
              }
              break;
            case 0x10:
              uint64_t v2 = *(void *)(v15 + *(unsigned int *)(*((void *)v13 + 7) + 72 * i + 24));
              if (v2)
              {
                if (v2 != *(void *)(*((void *)v13 + 7) + 72 * i + 40)) {
                  protobuf_c_message_free_unpacked(v2, v14);
                }
              }
              break;
          }
        }
      }
    }
    for (unsigned int n = 0; n < *(_DWORD *)(v15 + 8); ++n)
      do_free((uint64_t)v14, *(void *)(*(void *)(v15 + 16) + 24 * n + 16));
    if (*(void *)(v15 + 16)) {
      do_free((uint64_t)v14, *(void *)(v15 + 16));
    }
    return (void *)do_free((uint64_t)v14, v15);
  }
  return result;
}

void *system_alloc(uint64_t a1, size_t a2)
{
  return malloc_type_malloc(a2, 0x3E951BD8uLL);
}

void system_free(uint64_t a1, void *a2)
{
}

uint64_t get_tag_size(unsigned int a1)
{
  if (a1 < 0x10uLL) {
    return 1;
  }
  if (a1 < 0x800uLL) {
    return 2;
  }
  if (a1 < 0x40000uLL) {
    return 3;
  }
  if (a1 >= 0x2000000uLL) {
    return 5;
  }
  return 4;
}

uint64_t sint32_size(int a1)
{
  unsigned int v1 = zigzag32(a1);
  return uint32_size(v1);
}

uint64_t int32_size(int a1)
{
  if (a1 < 0) {
    return 10;
  }
  if (a1 < 128) {
    return 1;
  }
  if (a1 < 0x4000) {
    return 2;
  }
  if (a1 < 0x200000) {
    return 3;
  }
  if (a1 >= 0x10000000) {
    return 5;
  }
  return 4;
}

uint64_t uint32_size(unsigned int a1)
{
  if (a1 < 0x80uLL) {
    return 1;
  }
  if (a1 < 0x4000uLL) {
    return 2;
  }
  if (a1 < 0x200000uLL) {
    return 3;
  }
  if (a1 >= 0x10000000uLL) {
    return 5;
  }
  return 4;
}

uint64_t sint64_size(uint64_t a1)
{
  uint64_t v1 = zigzag64(a1);
  return uint64_size(v1);
}

uint64_t uint64_size(uint64_t a1)
{
  if (!HIDWORD(a1)) {
    return uint32_size(a1);
  }
  if (HIDWORD(a1) < 8uLL) {
    return 5;
  }
  if (HIDWORD(a1) < 0x400uLL) {
    return 6;
  }
  if (HIDWORD(a1) < 0x20000uLL) {
    return 7;
  }
  if (HIDWORD(a1) < 0x1000000uLL) {
    return 8;
  }
  if (HIDWORD(a1) >= 0x80000000uLL) {
    return 10;
  }
  return 9;
}

uint64_t zigzag32(int a1)
{
  return (a1 >> 31) ^ (2 * a1);
}

uint64_t zigzag64(uint64_t a1)
{
  return (a1 >> 63) ^ (2 * a1);
}

uint64_t field_is_zeroish(uint64_t a1, _DWORD *a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  if (v2)
  {
    uint64_t v4 = v2;
    char v3 = 1;
  }
  else
  {
    uint64_t v4 = *(unsigned int *)(a1 + 16);
    char v3 = 0;
  }
  if (v3)
  {
    return 1;
  }
  else
  {
    switch(v4)
    {
      case 0:
      case 1:
      case 2:
      case 6:
      case 7:
      case 13:
        unsigned int v7 = *a2 == 0;
        break;
      case 3:
      case 4:
      case 5:
      case 8:
      case 9:
        unsigned int v7 = *(void *)a2 == 0;
        break;
      case 10:
        unsigned int v7 = *(float *)a2 == 0.0;
        break;
      case 11:
        unsigned int v7 = *(double *)a2 == 0.0;
        break;
      case 12:
        unsigned int v7 = *a2 == 0;
        break;
      case 14:
        BOOL v6 = 1;
        if (*(void *)a2) {
          BOOL v6 = **(unsigned char **)a2 == 0;
        }
        unsigned int v7 = v6;
        break;
      case 15:
      case 16:
        unsigned int v7 = *(void *)a2 == 0;
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v7;
}

uint64_t tag_pack(unsigned int a1, unsigned char *a2)
{
  if (a1 >= 0x20000000uLL) {
    return uint64_pack(8 * a1, a2);
  }
  else {
    return uint32_pack(8 * a1, a2);
  }
}

uint64_t sint32_pack(int a1, unsigned char *a2)
{
  unsigned int v2 = zigzag32(a1);
  return uint32_pack(v2, a2);
}

uint64_t int32_pack(signed int a1, unsigned char *a2)
{
  if (a1 >= 0) {
    return uint32_pack(a1, a2);
  }
  *a2 = a1 | 0x80;
  a2[1] = (a1 >> 7) | 0x80;
  a2[2] = (a1 >> 14) | 0x80;
  a2[3] = (a1 >> 21) | 0x80;
  a2[4] = (a1 >> 28) | 0x80;
  a2[8] = -1;
  a2[7] = -1;
  a2[6] = -1;
  a2[5] = -1;
  a2[9] = 1;
  return 10;
}

uint64_t uint32_pack(unsigned int a1, unsigned char *a2)
{
  LOBYTE(v4) = a1;
  unsigned int v3 = 0;
  if (a1 >= 0x80)
  {
    unsigned int v3 = 1;
    *a2 = a1 | 0x80;
    unsigned int v4 = a1 >> 7;
    if (a1 >> 7 >= 0x80)
    {
      unsigned int v3 = 2;
      a2[1] = v4 | 0x80;
      unsigned int v4 = a1 >> 14;
      if (a1 >> 14 >= 0x80)
      {
        unsigned int v3 = 3;
        a2[2] = v4 | 0x80;
        unsigned int v4 = a1 >> 21;
        if (a1 >> 21 >= 0x80)
        {
          unsigned int v3 = 4;
          a2[3] = v4 | 0x80;
          unsigned int v4 = a1 >> 28;
        }
      }
    }
  }
  a2[v3] = v4;
  return v3 + 1;
}

uint64_t sint64_pack(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = zigzag64(a1);
  return uint64_pack(v2, a2);
}

uint64_t uint64_pack(uint64_t a1, unsigned char *a2)
{
  if (!HIDWORD(a1)) {
    return uint32_pack(a1, a2);
  }
  *a2 = a1 | 0x80;
  a2[1] = (a1 >> 7) | 0x80;
  a2[2] = (a1 >> 14) | 0x80;
  a2[3] = (a1 >> 21) | 0x80;
  if (HIDWORD(a1) >= 8)
  {
    a2[4] = (a1 >> 28) | (16 * (BYTE4(a1) & 7)) | 0x80;
    unsigned int v5 = HIDWORD(a1) >> 3;
    unsigned int v4 = 5;
    while (v5 >= 0x80)
    {
      uint64_t v2 = v4++;
      a2[v2] = v5 | 0x80;
      v5 >>= 7;
    }
    a2[v4] = v5;
    return v4 + 1;
  }
  else
  {
    a2[4] = (a1 >> 28) | (16 * BYTE4(a1));
    return 5;
  }
}

uint64_t fixed32_pack()
{
  return 4;
}

uint64_t fixed64_pack()
{
  return 8;
}

uint64_t BOOLean_pack(int a1, BOOL *a2)
{
  *a2 = a1 != 0;
  return 1;
}

uint64_t string_pack(const char *a1, unsigned char *a2)
{
  if (a1)
  {
    size_t v4 = strlen(a1);
    uint64_t v3 = uint32_pack(v4, a2);
    __memcpy_chk();
    return v3 + v4;
  }
  else
  {
    *a2 = 0;
    return 1;
  }
}

uint64_t binary_data_pack(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  uint64_t v3 = uint32_pack(*a1, a2);
  __memcpy_chk();
  return v3 + v4;
}

uint64_t prefixed_message_pack(uint64_t a1, unsigned char *a2)
{
  if (a1)
  {
    uint64_t v3 = protobuf_c_message_pack(a1, a2 + 1);
    if (uint32_size(v3) != 1) {
      __memmove_chk();
    }
    return uint32_pack(v3, a2) + v3;
  }
  else
  {
    *a2 = 0;
    return 1;
  }
}

uint64_t get_type_min_size(int a1)
{
  if (a1 == 2 || a1 == 7 || a1 == 10)
  {
    return 4;
  }
  else if (a1 == 5 || a1 == 9 || a1 == 11)
  {
    return 8;
  }
  else
  {
    return 1;
  }
}

uint64_t copy_to_little_endian_32()
{
  return __memcpy_chk();
}

uint64_t copy_to_little_endian_64()
{
  return __memcpy_chk();
}

uint64_t max_b128_numbers(uint64_t a1, unsigned char *a2)
{
  uint64_t v5 = 0;
  while (a1--)
  {
    uint64_t v3 = a2++;
    if ((*v3 & 0x80) == 0) {
      ++v5;
    }
  }
  return v5;
}

uint64_t parse_required_member(uint64_t a1, uint64_t *a2, uint64_t (**a3)(), int a4)
{
  unsigned int v18 = *(void *)(a1 + 16);
  long long v17 = *(unsigned int **)(a1 + 24);
  char v16 = *(unsigned char *)(a1 + 4);
  unsigned int v4 = *(_DWORD *)(*(void *)(a1 + 8) + 16);
  if (v4)
  {
    uint64_t v6 = v4;
    char v5 = 1;
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 8) + 16);
    char v5 = 0;
  }
  if (v5)
  {
    return 0;
  }
  else
  {
    switch(v6)
    {
      case 0:
      case 13:
        if (v16)
        {
          return 0;
        }
        else
        {
          *(_DWORD *)a2 = parse_int32(v18, v17);
          return 1;
        }
      case 1:
        if (v16)
        {
          return 0;
        }
        else
        {
          unsigned int v7 = parse_uint32(v18, v17);
          *(_DWORD *)a2 = unzigzag32(v7);
          return 1;
        }
      case 2:
      case 7:
      case 10:
        if (v16 == 5)
        {
          *(_DWORD *)a2 = parse_fixed_uint32(v17);
          return 1;
        }
        else
        {
          return 0;
        }
      case 3:
      case 8:
        if (v16)
        {
          return 0;
        }
        else
        {
          *a2 = parse_uint64(v18, v17);
          return 1;
        }
      case 4:
        if (v16)
        {
          return 0;
        }
        else
        {
          unint64_t v8 = parse_uint64(v18, v17);
          *a2 = unzigzag64(v8);
          return 1;
        }
      case 5:
      case 9:
      case 11:
        if (v16 == 1)
        {
          *a2 = parse_fixed_uint64((uint64_t)v17);
          return 1;
        }
        else
        {
          return 0;
        }
      case 6:
        if (v16)
        {
          return 0;
        }
        else
        {
          *(_DWORD *)a2 = parse_uint32(v18, v17);
          return 1;
        }
      case 12:
        *(_DWORD *)a2 = parse_BOOLean(v18, (uint64_t)v17);
        return 1;
      case 14:
        int v15 = *(unsigned __int8 *)(a1 + 5);
        if (v16 == 2)
        {
          if (a4 && *a2 && *a2 != *(void *)(*(void *)(a1 + 8) + 40)) {
            do_free((uint64_t)a3, *a2);
          }
          *a2 = do_alloc((uint64_t)a3, v18 - v15 + 1);
          if (*a2)
          {
            __memcpy_chk();
            *(unsigned char *)(*a2 + v18 - v15) = 0;
            return 1;
          }
          else
          {
            return 0;
          }
        }
        else
        {
          return 0;
        }
      case 15:
        unsigned int v13 = *(unsigned __int8 *)(a1 + 5);
        if (v16 != 2) {
          return 0;
        }
        uint64_t v14 = *(void *)(*(void *)(a1 + 8) + 40);
        if (a4 && a2[1] && (!v14 || a2[1] != *(void *)(v14 + 8))) {
          do_free((uint64_t)a3, a2[1]);
        }
        if (v18 <= v13)
        {
          a2[1] = 0;
        }
        else
        {
          a2[1] = do_alloc((uint64_t)a3, v18 - v13);
          if (!a2[1]) {
            return 0;
          }
          __memcpy_chk();
        }
        *a2 = v18 - v13;
        unsigned int v22 = 1;
        break;
      case 16:
        int v10 = 1;
        if (v16 == 2)
        {
          uint64_t v11 = *(void *)(*(void *)(a1 + 8) + 40);
          uint64_t v12 = protobuf_c_message_unpack(*(void *)(*(void *)(a1 + 8) + 32), a3, v18 - *(unsigned __int8 *)(a1 + 5), (char *)v17 + *(unsigned __int8 *)(a1 + 5));
          if (a4 && *a2 && *a2 != v11)
          {
            if (v12) {
              int v10 = merge_messages(*a2, v12, (uint64_t)a3);
            }
            protobuf_c_message_free_unpacked((void *)*a2, a3);
          }
          *a2 = v12;
          return v12 && v10;
        }
        else
        {
          return 0;
        }
      default:
        JUMPOUT(0);
    }
  }
  return v22;
}

uint64_t parse_oneof_member(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t (**a4)())
{
  uint64_t v9 = (int *)(a3 + *(unsigned int *)(*(void *)(a1 + 8) + 20));
  if (*v9)
  {
    uint64_t v7 = int_range_lookup(*(_DWORD *)(*(void *)a3 + 72), *(void *)(*(void *)a3 + 80), *v9);
    if ((int)v7 < 0) {
      return 0;
    }
    uint64_t v8 = *(void *)(*(void *)a3 + 56) + 72 * (int)v7;
    sizeof_elt_in_repeated_array(*(_DWORD *)(v8 + 16));
    int v5 = *(_DWORD *)(v8 + 16);
    if (v5 == 14)
    {
      if (*a2 && *a2 != *(void *)(v8 + 40)) {
        do_free((uint64_t)a4, *a2);
      }
    }
    else if (v5 == 15)
    {
      uint64_t v6 = *(void *)(v8 + 40);
      if (a2[1] && (!v6 || a2[1] != *(void *)(v6 + 8))) {
        do_free((uint64_t)a4, a2[1]);
      }
    }
    else if (v5 == 16 && *a2 && *a2 != *(void *)(v8 + 40))
    {
      protobuf_c_message_free_unpacked((void *)*a2, a4);
    }
    __memset_chk();
  }
  if (parse_required_member(a1, a2, a4, 1))
  {
    *uint64_t v9 = *(_DWORD *)a1;
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t parse_optional_member(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t (**a4)())
{
  if (parse_required_member(a1, a2, a4, 1))
  {
    if (*(_DWORD *)(*(void *)(a1 + 8) + 20)) {
      *(_DWORD *)(a3 + *(unsigned int *)(*(void *)(a1 + 8) + 20)) = 1;
    }
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t parse_packed_repeated_member(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v33 = *(void *)(a1 + 8);
  uint64_t v32 = (void *)(a3 + *(unsigned int *)(v33 + 20));
  uint64_t v31 = *a2 + sizeof_elt_in_repeated_array(*(_DWORD *)(v33 + 16)) * *v32;
  long long v30 = (unsigned char *)(*(void *)(a1 + 24) + *(unsigned __int8 *)(a1 + 5));
  uint64_t v29 = *(void *)(a1 + 16) - *(unsigned __int8 *)(a1 + 5);
  uint64_t v27 = 0;
  unsigned int v3 = *(_DWORD *)(v33 + 16);
  if (v3)
  {
    uint64_t v5 = v3;
    char v4 = 1;
  }
  else
  {
    uint64_t v5 = *(unsigned int *)(v33 + 16);
    char v4 = 0;
  }
  if (v4) {
    __assert_rtn("parse_packed_repeated_member", "protobuf-c.c", 2860, "0");
  }
  switch(v5)
  {
    case 0:
    case 13:
      while (2)
      {
        if (!v29) {
          goto LABEL_39;
        }
        unsigned int v26 = scan_varint(v29, (uint64_t)v30);
        if (v26)
        {
          int v6 = parse_int32(v26, v30);
          uint64_t v7 = v27++;
          *(_DWORD *)(v31 + 4 * v7) = v6;
          v30 += v26;
          v29 -= v26;
          continue;
        }
        return 0;
      }
    case 1:
      while (2)
      {
        if (!v29) {
          goto LABEL_39;
        }
        unsigned int v25 = scan_varint(v29, (uint64_t)v30);
        if (v25)
        {
          unsigned int v8 = parse_uint32(v25, v30);
          int v9 = unzigzag32(v8);
          uint64_t v10 = v27++;
          *(_DWORD *)(v31 + 4 * v10) = v9;
          v30 += v25;
          v29 -= v25;
          continue;
        }
        return 0;
      }
    case 2:
    case 7:
    case 10:
      unint64_t v28 = (*(void *)(a1 + 16) - (unint64_t)*(unsigned __int8 *)(a1 + 5)) / 4;
      goto LABEL_40;
    case 3:
    case 8:
      while (2)
      {
        if (!v29) {
          goto LABEL_39;
        }
        unsigned int v22 = scan_varint(v29, (uint64_t)v30);
        if (v22)
        {
          unint64_t v16 = parse_uint64(v22, v30);
          uint64_t v17 = v27++;
          *(void *)(v31 + 8 * v17) = v16;
          v30 += v22;
          v29 -= v22;
          continue;
        }
        return 0;
      }
    case 4:
      while (2)
      {
        if (!v29) {
          goto LABEL_39;
        }
        unsigned int v23 = scan_varint(v29, (uint64_t)v30);
        if (v23)
        {
          unint64_t v13 = parse_uint64(v23, v30);
          unint64_t v14 = unzigzag64(v13);
          uint64_t v15 = v27++;
          *(void *)(v31 + 8 * v15) = v14;
          v30 += v23;
          v29 -= v23;
          continue;
        }
        return 0;
      }
    case 5:
    case 9:
    case 11:
      unint64_t v28 = (*(void *)(a1 + 16) - (unint64_t)*(unsigned __int8 *)(a1 + 5)) / 8;
LABEL_40:
      __memcpy_chk();
      *v32 += v28;
      return 1;
    case 6:
      while (2)
      {
        if (!v29) {
          goto LABEL_39;
        }
        unsigned int v24 = scan_varint(v29, (uint64_t)v30);
        if (v24)
        {
          int v11 = parse_uint32(v24, v30);
          uint64_t v12 = v27++;
          *(_DWORD *)(v31 + 4 * v12) = v11;
          v30 += v24;
          v29 -= v24;
          continue;
        }
        return 0;
      }
    case 12:
      break;
    default:
      JUMPOUT(0);
  }
  while (v29)
  {
    unsigned int v21 = scan_varint(v29, (uint64_t)v30);
    if (!v21) {
      return 0;
    }
    int v18 = parse_BOOLean(v21, (uint64_t)v30);
    uint64_t v19 = v27++;
    *(_DWORD *)(v31 + 4 * v19) = v18;
    v30 += v21;
    v29 -= v21;
  }
LABEL_39:
  *v32 += v27;
  return 1;
}

uint64_t parse_repeated_member(uint64_t a1, void *a2, uint64_t a3, uint64_t (**a4)())
{
  uint64_t v7 = *(void *)(a1 + 8);
  int v6 = (void *)(a3 + *(unsigned int *)(v7 + 20));
  uint64_t v4 = sizeof_elt_in_repeated_array(*(_DWORD *)(v7 + 16));
  if (parse_required_member(a1, (uint64_t *)(*a2 + v4 * *v6), a4, 0))
  {
    ++*v6;
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t parse_int32(unsigned int a1, unsigned char *a2)
{
  return parse_uint32(a1, a2);
}

uint64_t parse_uint32(unsigned int a1, unsigned char *a2)
{
  unsigned int v3 = *a2 & 0x7F;
  if (a1 > 1)
  {
    v3 |= (a2[1] & 0x7F) << 7;
    if (a1 > 2)
    {
      v3 |= (a2[2] & 0x7F) << 14;
      if (a1 > 3)
      {
        v3 |= (a2[3] & 0x7F) << 21;
        if (a1 > 4) {
          v3 |= a2[4] << 28;
        }
      }
    }
  }
  return v3;
}

uint64_t unzigzag32(unsigned int a1)
{
  return -(a1 & 1) ^ (a1 >> 1);
}

uint64_t parse_fixed_uint32(unsigned int *a1)
{
  return *a1;
}

unint64_t parse_uint64(unsigned int a1, unsigned char *a2)
{
  if (a1 < 5) {
    return parse_uint32(a1, a2);
  }
  unint64_t v3 = *a2 & 0x7F | ((unint64_t)(a2[1] & 0x7F) << 7) | ((unint64_t)(a2[2] & 0x7F) << 14) | ((unint64_t)(a2[3] & 0x7F) << 21);
  int v5 = 28;
  for (unsigned int i = 4; i < a1; ++i)
  {
    v3 |= (unint64_t)(a2[i] & 0x7F) << v5;
    v5 += 7;
  }
  return v3;
}

unint64_t unzigzag64(unint64_t a1)
{
  return -(uint64_t)(a1 & 1) ^ (a1 >> 1);
}

uint64_t parse_fixed_uint64(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t parse_BOOLean(unsigned int a1, uint64_t a2)
{
  for (unsigned int i = 0; i < a1; ++i)
  {
    if ((*(unsigned char *)(a2 + i) & 0x7F) != 0) {
      return 1;
    }
  }
  return 0;
}

uint64_t merge_messages(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v27 = *(void *)(*(void *)a2 + 56);
  for (unsigned int i = 0; i < *(_DWORD *)(*(void *)a2 + 48); ++i)
  {
    if (*(_DWORD *)(v27 + 72 * i + 12) == 2)
    {
      unsigned int v26 = (void *)(a1 + *(unsigned int *)(v27 + 72 * i + 20));
      unsigned int v25 = (uint64_t *)(a1 + *(unsigned int *)(v27 + 72 * i + 24));
      unsigned int v24 = (void *)(a2 + *(unsigned int *)(v27 + 72 * i + 20));
      unsigned int v23 = (uint64_t *)(a2 + *(unsigned int *)(v27 + 72 * i + 24));
      if (*v26)
      {
        if (*v24)
        {
          uint64_t v22 = sizeof_elt_in_repeated_array(*(_DWORD *)(v27 + 72 * i + 16));
          uint64_t v21 = do_alloc(a3, (*v26 + *v24) * v22);
          if (!v21) {
            return 0;
          }
          __memcpy_chk();
          __memcpy_chk();
          do_free(a3, *v23);
          do_free(a3, *v25);
          uint64_t *v23 = v21;
          *v24 += *v26;
        }
        else
        {
          *unsigned int v24 = *v26;
          uint64_t *v23 = *v25;
        }
        *unsigned int v26 = 0;
        *unsigned int v25 = 0;
      }
    }
    else if (*(_DWORD *)(v27 + 72 * i + 12) == 1 || *(_DWORD *)(v27 + 72 * i + 12) == 3)
    {
      uint64_t v19 = (int *)(a1 + *(unsigned int *)(v27 + 72 * i + 20));
      int v18 = (int *)(a2 + *(unsigned int *)(v27 + 72 * i + 20));
      int v17 = 0;
      if ((*(_DWORD *)(v27 + 72 * i + 48) & 4) != 0)
      {
        if (*v18) {
          continue;
        }
        int v13 = int_range_lookup(*(_DWORD *)(*(void *)a2 + 72), *(void *)(*(void *)a2 + 80), *v19);
        if (v13 < 0) {
          return 0;
        }
        uint64_t v20 = *(void *)(*(void *)a2 + 56) + 72 * v13;
      }
      else
      {
        uint64_t v20 = v27 + 72 * i;
      }
      unint64_t v16 = (void *)(a1 + *(unsigned int *)(v20 + 24));
      uint64_t v15 = (uint64_t *)(a2 + *(unsigned int *)(v20 + 24));
      uint64_t v14 = *(void *)(v20 + 40);
      int v9 = *(_DWORD *)(v20 + 16);
      switch(v9)
      {
        case 14:
          BOOL v5 = 0;
          if (*v16 != v14) {
            BOOL v5 = *v15 == v14;
          }
          int v17 = v5;
          break;
        case 15:
          uint64_t v11 = v16[1];
          uint64_t v10 = v15[1];
          char v8 = 0;
          if (v11)
          {
            if (!v14 || (char v8 = 0, v11 != *(void *)(v14 + 8)))
            {
              char v7 = 1;
              if (v10)
              {
                BOOL v6 = 0;
                if (v14) {
                  BOOL v6 = v10 == *(void *)(v14 + 8);
                }
                char v7 = v6;
              }
              char v8 = v7;
            }
          }
          int v17 = v8 & 1;
          break;
        case 16:
          uint64_t v12 = *v15;
          if (*v16)
          {
            if (v12)
            {
              if (!merge_messages(*v16, v12, a3)) {
                return 0;
              }
              int v17 = 0;
            }
            else
            {
              int v17 = 1;
            }
          }
          break;
        default:
          BOOL v4 = 0;
          if (*v19) {
            BOOL v4 = *v18 == 0;
          }
          int v17 = v4;
          break;
      }
      if (v17)
      {
        sizeof_elt_in_repeated_array(*(_DWORD *)(v20 + 16));
        __memcpy_chk();
        __memset_chk();
        if (*(_DWORD *)(v20 + 20))
        {
          *int v18 = *v19;
          *uint64_t v19 = 0;
        }
      }
    }
  }
  return 1;
}

uint64_t scan_varint(unsigned int a1, uint64_t a2)
{
  unsigned int v4 = a1;
  if (a1 > 0xA) {
    unsigned int v4 = 10;
  }
  for (unsigned int i = 0; i < v4 && *(char *)(a2 + i) < 0; ++i)
    ;
  if (i == v4) {
    return 0;
  }
  else {
    return i + 1;
  }
}

void mmcs_warm_cold_1()
{
}

void mmcs_warm_cold_2()
{
}

void mmcs_register_request_abort_cold_1()
{
}

void mmcs_register_request_cleanup_cold_1()
{
}

void mmcs_register_items_cold_1()
{
}

void _add_item_result_cold_1()
{
}

void _add_item_result_cold_2()
{
}

void _add_item_result_cold_3()
{
}

void mmcs_register_request_did_chunk_item_cold_1()
{
  __assert_rtn("mmcs_register_request_did_chunk_item", "mmcs_register_request.c", 358, "registerItem->chunkingProfiles == NULL");
}

void mmcs_register_request_did_chunk_item_cold_2()
{
}

void mmcs_register_request_did_chunk_item_cold_3()
{
}

void mmcs_local_chunk_satisfyer_perform_cold_1()
{
}

void mmcs_local_chunk_satisfyer_perform_cold_2()
{
}