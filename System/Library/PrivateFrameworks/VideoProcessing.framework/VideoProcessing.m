uint64_t VCPGetVersion()
{
  return 109;
}

uint64_t VCPRateControlSessionCopySupportedPropertyDictionary(uint64_t a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    BOOL v4 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v4) {
      return result;
    }
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "NULL session\n", buf, 2u);
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v11 = v2;
  if (!v2)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v8 = MEMORY[0x1E4F14500];
      v9 = "Empty session storage\n";
      goto LABEL_25;
    }
    return 4294954392;
  }
  if (!*(unsigned char *)(v2 + 232))
  {
    if (*(unsigned char *)(v2 + 244))
    {
      v10 = &v11;
      if (atomic_load_explicit((atomic_ullong *volatile)&qword_1E9F814C8, memory_order_acquire) != -1)
      {
        *(void *)buf = &v10;
        v12 = buf;
        std::__call_once(&qword_1E9F814C8, &v12, (void (__cdecl *)(void *))sub_1BB9BEFD0);
      }
      v6 = (const void *)qword_1E9F814D0;
      if (qword_1E9F814D0)
      {
        if (!a2) {
          return 0;
        }
LABEL_20:
        CFTypeRef v7 = CFRetain(v6);
        uint64_t result = 0;
        *a2 = v7;
        return result;
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v8 = MEMORY[0x1E4F14500];
        v9 = "CFDictionaryCreate failed\n";
LABEL_25:
        _os_log_error_impl(&dword_1BB9B9000, v8, OS_LOG_TYPE_ERROR, v9, buf, 2u);
        return 4294954392;
      }
      return 4294954392;
    }
    if (a2)
    {
      v6 = *(const void **)(v2 + 184);
      goto LABEL_20;
    }
    return 0;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v2 + 256;
    _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", buf, 0xCu);
  }
  return 4294954393;
}

uint64_t VCPRateControlSessionSetProperty(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(unsigned char *)(v3 + 232))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = v3 + 256;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", buf, 0xCu);
        }
        return 4294954393;
      }
      CFTypeRef v7 = (std::__shared_mutex_base *)(v3 + 2368);
      if (*(unsigned char *)(v3 + 244))
      {
        *(void *)buf = v3 + 2368;
        buf[8] = 1;
        std::__shared_mutex_base::lock(v7);
        uint64_t v4 = sub_1BB9C65F4(v3, a2, a3);
        v8 = (uint64_t *)buf;
LABEL_26:
        sub_1BB9BF000((uint64_t)v8);
        return v4;
      }
      uint64_t v19 = v3 + 2368;
      char v20 = 1;
      std::__shared_mutex_base::lock(v7);
      CFStringRef v21 = a2;
      if (!sub_1BB9C6924(*(void **)(v3 + 2544), (CFTypeRef *)&v21))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = *(void *)(v3 + 2536);
          int v11 = *(_DWORD *)(v3 + 212);
          int v12 = *(_DWORD *)(v3 + 216);
          *(_DWORD *)buf = 134218496;
          *(void *)&buf[4] = v10;
          __int16 v23 = 1024;
          int v24 = v11;
          __int16 v25 = 1024;
          int v26 = v12;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): unrecognised property key", buf, 0x18u);
        }
        uint64_t v4 = 4294966630;
        goto LABEL_25;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44AA0]))
      {
        uint64_t v9 = sub_1BB9C6390(v3, a3);
        goto LABEL_22;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44920]))
      {
        uint64_t v9 = sub_1BB9C6144(v3, a3);
        goto LABEL_22;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44898]))
      {
        if (!a3) {
          goto LABEL_23;
        }
        CFTypeID TypeID = CFArrayGetTypeID();
        if (TypeID != CFGetTypeID(a3)) {
          goto LABEL_23;
        }
        v17 = (CFTypeRef *)(v3 + 136);
        v16 = *(const void **)(v3 + 136);
        if (!v16) {
          goto LABEL_38;
        }
      }
      else
      {
        if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F447F0]))
        {
          uint64_t v9 = sub_1BB9C6A7C(v3, a2, a3);
LABEL_22:
          uint64_t v4 = v9;
          if (v9)
          {
LABEL_25:
            v8 = &v19;
            goto LABEL_26;
          }
LABEL_23:
          v13 = sub_1BB9C6924(*(void **)(v3 + 2544), (CFTypeRef *)&v21);
          if (!v13) {
            sub_1BB9C6A20("unordered_map::at: key not found");
          }
          uint64_t v4 = 0;
          *((unsigned char *)v13 + 48) = 1;
          goto LABEL_25;
        }
        if (!a3) {
          goto LABEL_23;
        }
        CFTypeID v18 = CFStringGetTypeID();
        if (v18 != CFGetTypeID(a3)) {
          goto LABEL_23;
        }
        v17 = (CFTypeRef *)(v3 + 168);
        v16 = *(const void **)(v3 + 168);
        if (!v16)
        {
LABEL_38:
          CFTypeRef *v17 = CFRetain(a3);
          goto LABEL_23;
        }
      }
      CFRelease(v16);
      goto LABEL_38;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Empty session storage\n", buf, 2u);
    }
    return 4294954392;
  }
  else
  {
    uint64_t v4 = 0;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "NULL session\n", buf, 2u);
      return 0;
    }
  }
  return v4;
}

void sub_1BB9BABF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1BB9BF000((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t VCPRateControlSessionBeforePrepareToEncodeFrames(uint64_t a1, void *a2)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v3 = 0;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      return v3;
    }
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "NULL session\n", buf, 2u);
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    if (*(unsigned char *)(v2 + 232))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v2 + 256;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", buf, 0xCu);
      }
      return 4294954393;
    }
    if (*(unsigned char *)(v2 + 244))
    {
      std::mutex::lock((std::mutex *)(v2 + 2304));
      uint64_t v85 = v2 + 2368;
      char v86 = 1;
      std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v2 + 2368));
      if (*(int *)(v2 + 100) >= 1)
      {
        uint64_t v5 = (int)(*(double *)(v2 + 40) + 0.5);
        if (*(_DWORD *)(v2 + 208) == 1752589105)
        {
          int v6 = *(_DWORD *)(v2 + 212);
          int v7 = *(_DWORD *)(v2 + 216);
          int v8 = sub_1BBA4013C();
          uint64_t v9 = 0;
          signed int v10 = (v6 + 7) & 0xFFFFFFF8;
          if (v10 <= 160) {
            unsigned int v11 = 160;
          }
          else {
            unsigned int v11 = (v6 + 7) & 0xFFFFFFF8;
          }
          if ((int)((v7 + 7) & 0xFFFFFFF8) <= 64) {
            unsigned int v12 = 64;
          }
          else {
            unsigned int v12 = (v7 + 7) & 0xFFFFFFF8;
          }
          if (v8) {
            unsigned int v13 = v12;
          }
          else {
            unsigned int v13 = (v7 + 7) & 0xFFFFFFF8;
          }
          if (v8) {
            signed int v10 = v11;
          }
          int v14 = *(_DWORD *)(v2 + 100);
          unint64_t v15 = v13 * (unint64_t)v10;
          unint64_t v16 = v15 * v5;
          int v17 = v13 * v10;
          CFTypeID v18 = &qword_1E6247DA8;
          while (1)
          {
            unint64_t v19 = *((unsigned int *)v18 - 4);
            if (v17 <= (3 * (int)v19) >> 2) {
              int v20 = 8;
            }
            else {
              int v20 = 6;
            }
            if (v17 <= (int)v19 >> 1) {
              int v20 = 12;
            }
            if (v17 <= (int)v19 >> 2) {
              int v20 = 16;
            }
            if (v15 <= v19)
            {
              if (*v18 >= v16 && v20 > v14)
              {
                v50 = &(&off_1E6247D88)[6 * v9];
                goto LABEL_97;
              }
              if (v9 == 12) {
                break;
              }
            }
            ++v9;
            v18 += 6;
            if (v9 == 13) {
              goto LABEL_43;
            }
          }
          if (v16 > 0xFF000000)
          {
LABEL_43:
            uint64_t v3 = 4294954386;
            goto LABEL_68;
          }
          v50 = &off_1E6247FC8;
LABEL_97:
          int v51 = *((_DWORD *)v50 + 4);
          if (v17 <= v51 >> 2)
          {
            int v52 = 16;
          }
          else if (v17 <= v51 >> 1)
          {
            int v52 = 12;
          }
          else if (v17 <= (3 * v51) >> 2)
          {
            int v52 = 8;
          }
          else
          {
            int v52 = 6;
          }
          int v54 = v52 - 1;
          if (v14 >= v54) {
            int v14 = v54;
          }
        }
        else
        {
          int v34 = *(_DWORD *)(v2 + 76);
          int v35 = *(_DWORD *)(v2 + 212);
          int v36 = *(_DWORD *)(v2 + 216);
          int v37 = sub_1BBA4013C();
          if ((v35 + 15) >> 4 <= 12) {
            int v38 = 12;
          }
          else {
            int v38 = (v35 + 15) >> 4;
          }
          if ((v36 + 15) >> 4 <= 6) {
            int v39 = 6;
          }
          else {
            int v39 = (v36 + 15) >> 4;
          }
          if (v37) {
            int v40 = v38;
          }
          else {
            int v40 = (v35 + 15) >> 4;
          }
          if (v37) {
            int v41 = v39;
          }
          else {
            int v41 = (v36 + 15) >> 4;
          }
          uint64_t v42 = sub_1BBAE6DEC((uint64_t)buf, v5, v34, v40, v41, *(_DWORD *)(v2 + 16), *(_DWORD *)(v2 + 20), *(_DWORD *)(v2 + 100));
          if (v42)
          {
            uint64_t v3 = v42;
LABEL_68:
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315138;
              *(void *)&buf[4] = v2 + 256;
              _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: failed to verify max reference buffer count\n", buf, 0xCu);
            }
            goto LABEL_159;
          }
          int v14 = v89;
        }
        *(_DWORD *)(v2 + 100) = v14;
      }
      if (*(unsigned char *)(v2 + 233))
      {
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        v56 = Mutable;
        if (Mutable)
        {
          int v57 = *(_DWORD *)(v2 + 236);
          if (v57 >= 2 && *(unsigned char *)(v2 + 244)) {
            sub_1BB9BFAB0(Mutable, (const void *)*MEMORY[0x1E4F44A40], v57);
          }
          int v58 = *(_DWORD *)(v2 + 240);
          if (v58 >= 2 && *(unsigned char *)(v2 + 244)) {
            sub_1BB9BFAB0(v56, @"MinNumberOfTemporalLayers", v58);
          }
          v59 = (const void *)*MEMORY[0x1E4F1CFC8];
          CFDictionarySetValue(v56, @"AllowQpModulation", (const void *)*MEMORY[0x1E4F1CFC8]);
          uint64_t valuePtr = *(void *)(v2 + 40);
          CFNumberRef v60 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
          *(void *)buf = v60;
          if (v60) {
            CFDictionarySetValue(v56, (const void *)*MEMORY[0x1E4F448F0], v60);
          }
          sub_1BB9BE1F4((const void **)buf);
          LODWORD(valuePtr) = *(_DWORD *)(v2 + 76);
          CFNumberRef v61 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
          *(void *)buf = v61;
          if (v61) {
            CFDictionarySetValue(v56, (const void *)*MEMORY[0x1E4F44810], v61);
          }
          sub_1BB9BE1F4((const void **)buf);
          int v62 = *(_DWORD *)(v2 + 208);
          if (v62 != 1718908520 && v62 != 1752589105)
          {
            v63 = *(const void **)(v2 + 24);
            if (v63) {
              CFDictionarySetValue(v56, (const void *)*MEMORY[0x1E4F44920], v63);
            }
          }
          double v64 = *(double *)(v2 + 48);
          if (v64 >= 0.0)
          {
            sub_1BB9BFB24(v56, (const void *)*MEMORY[0x1E4F44830], v64);
            if (*(double *)(v2 + 48) != 1.0) {
              sub_1BB9BFB24(v56, (const void *)*MEMORY[0x1E4F44820], *(double *)(v2 + 56));
            }
          }
          CFDictionarySetValue(v56, (const void *)*MEMORY[0x1E4F44AA0], *(const void **)v2);
          int v65 = *(_DWORD *)(v2 + 100);
          if (v65 >= 1) {
            sub_1BB9BFAB0(v56, (const void *)*MEMORY[0x1E4F44AC8], v65);
          }
          int v66 = *(_DWORD *)(v2 + 80);
          if (v66 >= 1) {
            sub_1BB9BFAB0(v56, (const void *)*MEMORY[0x1E4F449B8], v66);
          }
          if (*(unsigned char *)(v2 + 97)) {
            v67 = (const void *)*MEMORY[0x1E4F1CFD0];
          }
          else {
            v67 = v59;
          }
          CFDictionarySetValue(v56, (const void *)*MEMORY[0x1E4F44840], v67);
          uint64_t valuePtr = *(void *)(v2 + 2536);
          CFNumberRef v68 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
          *(void *)buf = v68;
          if (v68) {
            CFDictionarySetValue(v56, @"CallerID", v68);
          }
          sub_1BB9BE1F4((const void **)buf);
          uint64_t v3 = 0;
          *a2 = v56;
          goto LABEL_159;
        }
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          goto LABEL_158;
        }
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v2 + 256;
        v71 = MEMORY[0x1E4F14500];
        v72 = "%s: Failed to allocate session properties\n";
        goto LABEL_157;
      }
      if (!*(void *)(v2 + 2296) && sub_1BB9BF2EC(v2, 0))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = v2 + 256;
          v71 = MEMORY[0x1E4F14500];
          v72 = "%s: Failed to initialize sequence\n";
LABEL_157:
          _os_log_error_impl(&dword_1BB9B9000, v71, OS_LOG_TYPE_ERROR, v72, buf, 0xCu);
          goto LABEL_158;
        }
        goto LABEL_158;
      }
      if (a2 && (uint64_t v69 = *(void *)(*(void *)(v2 + 2296) + 13272)) != 0)
      {
        uint64_t v70 = (*(uint64_t (**)(uint64_t))(*(void *)v69 + 72))(v69);
        if (!v70)
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315138;
            *(void *)&buf[4] = v2 + 256;
            v71 = MEMORY[0x1E4F14500];
            v72 = "%s: Failed to create session properties\n";
            goto LABEL_157;
          }
LABEL_158:
          uint64_t v3 = 4294954392;
          goto LABEL_159;
        }
        uint64_t v3 = 0;
        *a2 = v70;
      }
      else
      {
        uint64_t v3 = 0;
      }
LABEL_159:
      sub_1BB9BF2B4((uint64_t)&v85);
      std::mutex::unlock((std::mutex *)(v2 + 2304));
      return v3;
    }
    unsigned int v22 = sub_1BB9CBAA0(*(void *)(a1 + 16), (const void *)*MEMORY[0x1E4F44810]);
    unsigned int v23 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F44898]);
    unsigned int v24 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F44878]);
    unsigned int v25 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F448F0]);
    if (v24)
    {
      if ((v22 | v23) == 1) {
        sub_1BB9CBB04("ConstantBitRate can't be set with AverageBitRate or DataRateLimits\n");
      }
      if ((v25 & 1) == 0) {
        sub_1BB9CBB04("ConstantBitRate needs ExpectedFrameRate to ensure effective CBR rate control\n");
      }
    }
    unsigned int v83 = v25;
    unsigned int v26 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F44AA0]);
    unsigned int v27 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F447E8]);
    unsigned int v84 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F447D0]);
    unsigned int v82 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F44AC8]);
    sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F44A48]);
    unsigned int v28 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F44920]);
    unsigned int v29 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F449C8]);
    unsigned int v30 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F449D0]);
    if (v26)
    {
      unsigned int v31 = v30;
      uint64_t v32 = 0;
      v33 = (CFTypeRef **)qword_1E6247528;
      while (!CFEqual(*(CFTypeRef *)v2, **v33))
      {
        ++v32;
        v33 += 5;
        if (v32 == 24) {
          goto LABEL_169;
        }
      }
      if (v28)
      {
        if (*(_DWORD *)(v2 + 32) == 1 && (unint64_t)(v32 - 14) <= 0xFFFFFFFFFFFFFFFCLL) {
          sub_1BB9CBB04("H264EntropyMode is not supported for %s\n", *(const char **)(v2 + 8));
        }
      }
      if (v27 && !*(unsigned char *)(v2 + 64))
      {
        if (v29 && *(_DWORD *)(v2 + 68) != 1) {
          sub_1BB9CBB04("MaxKeyFrameInterval (%d) must be 1 when AllowTemporalCompression is set to 0\n", *(_DWORD *)(v2 + 68));
        }
        if (v31) {
          sub_1BB9CBB04("No need to set MaxKeyFrameIntervalDuration when AllowTemporalCompression is set to 0\n");
        }
      }
      if (v84 && ((0xFFC300uLL >> v32) & 1) != 0) {
        sub_1BB9CBB04("AllowFrameReordering is not supported for %s\n", *(const char **)(v2 + 8));
      }
      if (v22)
      {
        int v44 = *(_DWORD *)(v2 + 76);
        if (1000 * LODWORD(qword_1E6247528[5 * v32 + 3]) < v44) {
          sub_1BB9CBB04("AverageBitrate (%d bps) exceeds the level limit of %d kbps for %s\n", v44, LODWORD(qword_1E6247528[5 * v32 + 3]), *(const char **)(v2 + 8));
        }
      }
      if (v24)
      {
        int v45 = *(_DWORD *)(v2 + 144);
        if (1000 * LODWORD(qword_1E6247528[5 * v32 + 3]) < v45) {
          sub_1BB9CBB04("ConstantBitrate (%d bps) exceeds the level limit of %d kbps for %s\n", v45, LODWORD(qword_1E6247528[5 * v32 + 3]), *(const char **)(v2 + 8));
        }
      }
      int v46 = *(_DWORD *)(v2 + 212);
      int v47 = *(_DWORD *)(v2 + 216);
      int v48 = ((v47 + 15) >> 4) * ((v46 + 15) >> 4);
      int v49 = HIDWORD(qword_1E6247528[5 * v32 + 3]);
      if (v48 <= v49)
      {
        if (v48 >= 1)
        {
          if (v83 && *(double *)(v2 + 40) > fmin((double)SLODWORD(qword_1E6247528[5 * v32 + 4]) / (double)v48, 300.0))
          {
            sub_1BB9CBB04("Frame rate (%.1f fps) exceeds the level limit of %.1f fps for %s\n");
          }
          else if (v82)
          {
            if ((v32 & 0xFFFFFFF8) != 0)
            {
              int v53 = SHIDWORD(qword_1E6247528[5 * v32 + 4]) / v48;
              if (v53 >= 16) {
                int v53 = 16;
              }
            }
            else
            {
              int v73 = v47 * v46;
              if (v73 <= v49 << 6)
              {
                int v53 = 16;
              }
              else if (v73 <= v49 << 7)
              {
                int v53 = 12;
              }
              else if (v73 <= (768 * v49) >> 2)
              {
                int v53 = 8;
              }
              else
              {
                int v53 = 6;
              }
            }
            if (*(_DWORD *)(v2 + 100) > v53) {
              sub_1BB9CBB04("Reference count (%d) exceeds the level limit of %d for %s\n");
            }
          }
        }
      }
      else
      {
        sub_1BB9CBB04("Frame size (%dx%d) exceeds the level limit of %d MBs for %s\n");
      }
    }
LABEL_169:
    unsigned int v74 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F44AB0]);
    unsigned int v75 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F447F0]);
    unsigned int v76 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F44A80]);
    unsigned int v77 = sub_1BB9CBAA0(v2, (const void *)*MEMORY[0x1E4F44B30]);
    if (v74)
    {
      double v78 = *(double *)(v2 + 152);
      if (v78 < 0.0 || v78 > 1.0) {
        sub_1BB9CBB04("Quality value (%f) is out of bounds (0,1)\n", *(double *)(v2 + 152));
      }
    }
    if (v76 && *(_DWORD *)(v2 + 208) != 1752589105) {
      sub_1BB9CBB04("PreserveAlphaChannel requires HEVC\n");
    }
    if (v75 && *(_DWORD *)(v2 + 208) != 1752589105) {
      sub_1BB9CBB04("AlphaChannelMode requires HEVC\n");
    }
    if (v77)
    {
      if (*(_DWORD *)(v2 + 208) == 1752589105)
      {
        double v80 = *(double *)(v2 + 176);
        if (v80 < 0.0 || v80 > 1.0) {
          sub_1BB9CBB04("Alpha quality value (%f) is out of bounds (0, 1)\n");
        }
      }
      else
      {
        sub_1BB9CBB04("TargetQualityForAlpha requires HEVC\n");
      }
    }
    if (a2)
    {
      uint64_t v3 = 0;
      *a2 = 0;
      return v3;
    }
    return 0;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Empty session storage\n", buf, 2u);
  }
  return 4294954392;
}

void sub_1BB9BB888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1BB9BF2B4((uint64_t)va);
  std::mutex::unlock(v8);
  _Unwind_Resume(a1);
}

uint64_t VCPRateControlSessionCreate(int a1, int a2, int a3, int a4, CFDictionaryRef theDict, const __CFDictionary *a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  if (!theDict) {
    goto LABEL_25;
  }
  int v17 = (const void *)*MEMORY[0x1E4F45650];
  BOOL v19 = CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F45650])
     && (CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, v17)) != 0
     && CFBooleanGetValue(Value) != 0;
  int v20 = (const void *)*MEMORY[0x1E4F45668];
  if (!CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F45668])
    || (CFBooleanRef v21 = (const __CFBoolean *)CFDictionaryGetValue(theDict, v20)) == 0)
  {
    if (!v19) {
      goto LABEL_25;
    }
    BOOL v107 = 0;
LABEL_15:
    v108 = 0;
    if (a4 != 1635148593 && a4 != 1752589105)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)&buf[4] = a4 >> 24;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = a4 << 8 >> 24;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = (__int16)a4 >> 8;
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&buf[22] = (char)a4;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPRateControlSession: codec type '%c%c%c%c' is not supported\n", buf, 0x1Au);
      }
      Instance = 0;
      uint64_t v56 = 4294954394;
      goto LABEL_70;
    }
    pthread_once(&stru_1E9F80A30, (void (*)(void))sub_1BB9BEE54);
    Instance = (void *)_CFRuntimeCreateInstance();
    if (!Instance)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to create VCPRateControlSession\n", buf, 2u);
      }
      uint64_t v56 = 4294954392;
      goto LABEL_71;
    }
    LODWORD(valuePtr) = 1;
    CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    *(void *)buf = v25;
    if (v25) {
      CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E4F44B68], v25);
    }
    sub_1BB9BE1F4((const void **)buf);
    unsigned int v26 = (char *)operator new(0x9F8uLL, MEMORY[0x1E4FBA2D0]);
    if (!v26)
    {
      Instance[2] = 0;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        int v73 = MEMORY[0x1E4F14500];
        unsigned int v74 = "Failed to create private storage\n";
        uint32_t v75 = 2;
LABEL_89:
        _os_log_error_impl(&dword_1BB9B9000, v73, OS_LOG_TYPE_ERROR, v74, buf, v75);
      }
LABEL_52:
      uint64_t v56 = 4294967188;
LABEL_69:
      CFRelease(Instance);
      Instance = 0;
LABEL_70:
      *a11 = Instance;
LABEL_71:
      sub_1BB9BEF9C(&v108);
      return v56;
    }
    uint64_t v27 = (uint64_t)v26;
    unsigned int v28 = v26 + 2304;
    bzero(v26, 0x9F8uLL);
    *(void *)(v27 + 2304) = 850045863;
    *(_OWORD *)(v28 + 8) = 0u;
    *(_OWORD *)(v28 + 24) = 0u;
    *(_OWORD *)(v28 + 40) = 0u;
    *(void *)(v27 + 2360) = 0;
    std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)(v27 + 2368));
    *(void *)(v27 + 2536) = 0;
    Instance[2] = v27;
    if (!a6)
    {
      int v31 = 0;
      goto LABEL_57;
    }
    unsigned int v29 = (const void *)*MEMORY[0x1E4F24D70];
    *(_DWORD *)buf = 0;
    CFNumberRef v30 = (const __CFNumber *)CFDictionaryGetValue(a6, v29);
    if (v30)
    {
      CFNumberGetValue(v30, kCFNumberSInt32Type, buf);
      int v31 = *(_DWORD *)buf;
      if ((*(_DWORD *)buf & 0xFFFFFFEF) == 0x34323066) {
        goto LABEL_57;
      }
    }
    else
    {
      int v31 = 0;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v57 = *(void *)(v27 + 2536);
      int v58 = *(_DWORD *)(v27 + 212);
      int v59 = *(_DWORD *)(v27 + 216);
      *(_DWORD *)buf = 134218752;
      *(void *)&buf[4] = v57;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v58;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v59;
      *(_WORD *)&uint8_t buf[24] = 1024;
      *(_DWORD *)&buf[26] = v31;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): Source image buffer attributes contain pixel format %d\n", buf, 0x1Eu);
    }
LABEL_57:
    if (a4 == 1752589105) {
      CFNumberRef v60 = (void *)MEMORY[0x1E4F452D0];
    }
    else {
      CFNumberRef v60 = (void *)MEMORY[0x1E4F45250];
    }
    *(void *)uint64_t v27 = *v60;
    *(void *)(v27 + 24) = 0;
    *(_DWORD *)(v27 + 32) = 0;
    *(void *)(v27 + 136) = 0;
    *(void *)(v27 + 168) = 0;
    *(void *)(v27 + 184) = 0;
    CFNumberRef v61 = operator new(0x88uLL, MEMORY[0x1E4FBA2D0]);
    if (v61)
    {
      int v62 = v61;
      sub_1BBAC86F0((uint64_t)v61, (uint64_t)sub_1BB9C6DC0, v27);
      *(void *)(v27 + 2256) = v62;
      *(void *)(v27 + 2536) = mach_absolute_time();
      *(_DWORD *)(v27 + 208) = a4;
      *(_DWORD *)(v27 + 212) = a2;
      *(_DWORD *)(v27 + 216) = a3;
      *(_WORD *)(v27 + 64) = 1;
      *(unsigned char *)(v27 + 66) = 1;
      *(_DWORD *)(v27 + 192) = 1;
      *(_OWORD *)(v27 + 40) = xmmword_1BBB6F3E0;
      *(void *)(v27 + 56) = 0x3FE3333333333333;
      *(void *)(v27 + 68) = 0;
      *(_DWORD *)(v27 + 76) = 7 * a2 * a3 / 10;
      *(void *)(v27 + 112) = 0;
      *(void *)(v27 + 120) = 0;
      *(void *)(v27 + 104) = 0;
      *(void *)(v27 + 2272) = a8;
      *(void *)(v27 + 2280) = a9;
      *(void *)(v27 + 2288) = a10;
      *(_DWORD *)(v27 + 232) = 256;
      *(void *)(v27 + 236) = 0x200000002;
      *(unsigned char *)(v27 + 244) = 0;
      *(_DWORD *)(v27 + 200) = 2;
      *(_DWORD *)(v27 + 204) = v31;
      *(void *)(v27 + 248) = 0x200000000;
      *(void *)(v27 + 80) = -1;
      *(_DWORD *)(v27 + 92) = -1;
      *(_WORD *)(v27 + 96) = 0;
      *(unsigned char *)(v27 + 88) = 0;
      *(_DWORD *)(v27 + 100) = -1;
      *(unsigned char *)(v27 + 128) = a4 == 1635148593;
      *(void *)(v27 + 2544) = 0;
      if (!sub_1BB9C6390(v27, *(const __CFString **)v27))
      {
        *(void *)(v27 + 224) = 0;
        v63 = operator new(0x28uLL, MEMORY[0x1E4FBA2D0]);
        if (v63)
        {
          _OWORD *v63 = 0u;
          v63[1] = 0u;
          *((unsigned char *)v63 + 24) = 1;
          *((void *)v63 + 4) = 0;
          *(void *)(v27 + 2264) = v63;
          sub_1BB9CFFA8((uint64_t *)v63, *(void *)(v27 + 2536));
        }
        else
        {
          *(void *)(v27 + 2264) = 0;
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v65 = *(void *)(v27 + 2536);
            int v66 = *(_DWORD *)(v27 + 212);
            int v67 = *(_DWORD *)(v27 + 216);
            *(_DWORD *)buf = 134218496;
            *(void *)&buf[4] = v65;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v66;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v67;
            _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): failed to create reaction listener\n", buf, 0x18u);
          }
        }
        snprintf((char *)(v27 + 256), 0x7D0uLL, "VCPRateControlSession %p (%dx%d)", Instance, a2, a3);
        *(unsigned char *)(v27 + 244) = 1;
        if (atomic_load_explicit((atomic_ullong *volatile)&qword_1E9F81F40, memory_order_acquire) != -1)
        {
          *(void *)buf = &v109;
          uint64_t valuePtr = buf;
          std::__call_once(&qword_1E9F81F40, &valuePtr, (void (__cdecl *)(void *))sub_1BBA3FF24);
        }
        *(unsigned char *)(v27 + 235) = byte_1E9F81F38;
        int v68 = sub_1BBA4013C();
        *(unsigned char *)(v27 + 234) = v68;
        if (*(unsigned char *)(v27 + 235))
        {
          uint64_t v69 = (const void *)*MEMORY[0x1E4F45648];
          if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F45648])) {
            unsigned int v70 = sub_1BB9BEF74(theDict, v69);
          }
          else {
            unsigned int v70 = 1;
          }
          if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F45620]))
          {
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
              goto LABEL_123;
            }
            goto LABEL_125;
          }
          *(unsigned char *)(v27 + 233) = 0;
          BOOL v72 = v70 != 0;
        }
        else
        {
          if (!v68)
          {
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v76 = *(void *)(v27 + 2536);
              int v77 = *(_DWORD *)(v27 + 212);
              int v78 = *(_DWORD *)(v27 + 216);
              *(_DWORD *)buf = 134218496;
              *(void *)&buf[4] = v76;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v77;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v78;
              _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): Hardware support is not available\n", buf, 0x18u);
            }
            v79 = (const void *)*MEMORY[0x1E4F45660];
            if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F45660])
              && sub_1BB9BEF74(theDict, v79))
            {
              if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
                goto LABEL_125;
              }
              *(_DWORD *)buf = 136315138;
              *(void *)&buf[4] = v27 + 256;
              double v80 = MEMORY[0x1E4F14500];
              v81 = "%s: Cannot require hardware accelerated encoder\n";
              goto LABEL_124;
            }
            unsigned int v106 = 0;
            *(unsigned char *)(v27 + 233) = 1;
LABEL_99:
            unsigned int v82 = (float *)operator new(0x28uLL, MEMORY[0x1E4FBA2D0]);
            if (v82)
            {
              unsigned int v83 = v82;
              *(_OWORD *)unsigned int v82 = 0u;
              *((_OWORD *)v82 + 1) = 0u;
              v82[8] = 1.0;
              *(void *)(v27 + 2544) = v82;
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9F81560, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1E9F81560))
              {
                qword_1E9F81558 = (uint64_t)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &unk_1BBB77CB0);
                __cxa_guard_release(&qword_1E9F81560);
              }
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9F81570, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1E9F81570))
              {
                qword_1E9F81568 = (uint64_t)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, &unk_1BBB77CB4);
                __cxa_guard_release(&qword_1E9F81570);
              }
              CFTypeID TypeID = CFNumberGetTypeID();
              *(void *)buf = *MEMORY[0x1E4F448F0];
              *(void *)&buf[8] = TypeID;
              *(void *)&buf[16] = "ExpectedFrameRate";
              *(void *)&uint8_t buf[24] = v27 + 40;
              char v112 = 0;
              uint64_t v113 = 13;
              uint64_t v114 = qword_1E9F81568;
              sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              CFTypeID v85 = CFBooleanGetTypeID();
              *(void *)buf = *MEMORY[0x1E4F44B28];
              *(void *)&buf[8] = v85;
              *(void *)&buf[16] = "SupportsBaseFrameQP";
              *(void *)&uint8_t buf[24] = v27 + 66;
              char v112 = 0;
              uint64_t v113 = 16;
              uint64_t v114 = 0;
              sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              CFTypeID v86 = CFNumberGetTypeID();
              *(void *)buf = *MEMORY[0x1E4F44810];
              *(void *)&buf[8] = v86;
              *(void *)&buf[16] = "AverageBitRate";
              *(void *)&uint8_t buf[24] = v27 + 76;
              char v112 = 0;
              uint64_t v113 = 3;
              uint64_t v114 = qword_1E9F81558;
              sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              CFTypeID v87 = CFStringGetTypeID();
              *(void *)buf = *MEMORY[0x1E4F44920];
              *(void *)&buf[8] = v87;
              *(void *)&buf[16] = "H264EntropyMode";
              *(void *)&uint8_t buf[24] = v27 + 24;
              char v112 = 0;
              uint64_t v113 = 16;
              uint64_t v114 = 0;
              sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              CFTypeID v88 = CFNumberGetTypeID();
              *(void *)buf = *MEMORY[0x1E4F44830];
              *(void *)&buf[8] = v88;
              *(void *)&buf[16] = "BaseLayerFrameRateFraction";
              *(void *)&uint8_t buf[24] = v27 + 48;
              char v112 = 0;
              uint64_t v113 = 13;
              uint64_t v114 = qword_1E9F81568;
              sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              CFTypeID v89 = CFNumberGetTypeID();
              *(void *)buf = *MEMORY[0x1E4F44820];
              *(void *)&buf[8] = v89;
              *(void *)&buf[16] = "BaseLayerBitRateFraction";
              *(void *)&uint8_t buf[24] = v27 + 56;
              char v112 = 0;
              uint64_t v113 = 13;
              uint64_t v114 = qword_1E9F81568;
              sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              CFTypeID v90 = CFNumberGetTypeID();
              *(void *)buf = *MEMORY[0x1E4F44AC8];
              *(void *)&buf[8] = v90;
              *(void *)&buf[16] = "ReferenceBufferCount";
              *(void *)&uint8_t buf[24] = v27 + 100;
              char v112 = 0;
              uint64_t v113 = 3;
              uint64_t v114 = qword_1E9F81558;
              sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              CFTypeID v91 = CFStringGetTypeID();
              *(void *)buf = *MEMORY[0x1E4F44AA0];
              *(void *)&buf[8] = v91;
              *(void *)&buf[16] = "ProfileLevel";
              *(void *)&uint8_t buf[24] = v27;
              char v112 = 0;
              uint64_t v113 = 16;
              uint64_t v114 = 0;
              sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              CFTypeID v92 = CFNumberGetTypeID();
              *(void *)buf = *MEMORY[0x1E4F449B8];
              *(void *)&buf[8] = v92;
              *(void *)&buf[16] = "MaxAllowedFrameQP";
              *(void *)&uint8_t buf[24] = v27 + 80;
              char v112 = 0;
              uint64_t v113 = 3;
              uint64_t v114 = 0;
              sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              CFTypeID v93 = CFBooleanGetTypeID();
              *(void *)buf = *MEMORY[0x1E4F447C8];
              *(void *)&buf[8] = v93;
              *(void *)&buf[16] = "AVCaptureDeviceReactionEffectsInProgress";
              *(void *)&uint8_t buf[24] = v27 + 96;
              char v112 = 0;
              uint64_t v113 = 16;
              uint64_t v114 = 0;
              sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              if (*(unsigned char *)(v27 + 234))
              {
                CFTypeID v94 = CFBooleanGetTypeID();
                *(void *)buf = *MEMORY[0x1E4F44840];
                *(void *)&buf[8] = v94;
                *(void *)&buf[16] = "CalculateMeanSquaredError";
                *(void *)&uint8_t buf[24] = v27 + 97;
                char v112 = 0;
                uint64_t v113 = 16;
                uint64_t v114 = 0;
                sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              }
              if (!*(unsigned char *)(v27 + 233))
              {
                CFTypeID v95 = CFNumberGetTypeID();
                *(void *)buf = *MEMORY[0x1E4F449C8];
                *(void *)&buf[8] = v95;
                *(void *)&buf[16] = "MaxKeyFrameInterval";
                *(void *)&uint8_t buf[24] = v27 + 68;
                char v112 = 0;
                uint64_t v113 = 3;
                uint64_t v114 = qword_1E9F81558;
                sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
                CFTypeID v96 = CFNumberGetTypeID();
                *(void *)buf = *MEMORY[0x1E4F449D0];
                *(void *)&buf[8] = v96;
                *(void *)&buf[16] = "MaxKeyFrameIntervalDuration";
                *(void *)&uint8_t buf[24] = v27 + 72;
                char v112 = 0;
                uint64_t v113 = 5;
                uint64_t v114 = qword_1E9F81568;
                sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
                CFTypeID v97 = CFNumberGetTypeID();
                *(void *)buf = *MEMORY[0x1E4F449E0];
                *(void *)&buf[8] = v97;
                *(void *)&buf[16] = "MinAllowedFrameQP";
                *(void *)&uint8_t buf[24] = v27 + 92;
                char v112 = 0;
                uint64_t v113 = 3;
                uint64_t v114 = 0;
                sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
                CFTypeID v98 = CFBooleanGetTypeID();
                *(void *)buf = *MEMORY[0x1E4F448B0];
                *(void *)&buf[8] = v98;
                *(void *)&buf[16] = "EnableLTR";
                *(void *)&uint8_t buf[24] = v27 + 128;
                char v112 = 0;
                uint64_t v113 = 16;
                uint64_t v114 = 0;
                sub_1BB9C7544(v83, (CFTypeRef *)buf, (uint64_t)buf);
              }
              if ((v107 | v106))
              {
                if (v106)
                {
                  CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E4F45660], (const void *)*MEMORY[0x1E4F1CFD0]);
                  if (!*(unsigned char *)(v27 + 233)) {
                    goto LABEL_129;
                  }
                  v99 = @"com.apple.videotoolbox.videoencoder.h264.rtvc";
                }
                else if (*(unsigned char *)(v27 + 233))
                {
                  v99 = @"com.apple.videotoolbox.videoencoder.h264.rtvc";
                }
                else
                {
                  v99 = @"com.apple.videotoolbox.videoencoder.h264.rtvc.sw";
                }
                if (a4 == 1752589105) {
                  CFStringRef v100 = @"com.apple.videotoolbox.videoencoder.hevc.rtvc";
                }
                else {
                  CFStringRef v100 = v99;
                }
                v101 = (const void *)*MEMORY[0x1E4F45620];
                if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F45620]))
                {
                  CFStringRef v102 = (const __CFString *)CFDictionaryGetValue(theDict, v101);
                  if (CFStringCompare(v100, v102, 0))
                  {
                    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
                    {
LABEL_123:
                      *(_DWORD *)buf = 136315138;
                      *(void *)&buf[4] = v27 + 256;
                      double v80 = MEMORY[0x1E4F14500];
                      v81 = "%s: encoder id is not supported\n";
                      goto LABEL_124;
                    }
LABEL_125:
                    uint64_t v56 = 4294954394;
                    goto LABEL_69;
                  }
                }
                if (qword_1EC027118 != -1) {
                  dispatch_once(&qword_1EC027118, &unk_1F14EF220);
                }
                CFDictionarySetValue(theDict, v101, v100);
LABEL_129:
                if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v103 = *(void *)(v27 + 2536);
                  int v104 = *(_DWORD *)(v27 + 212);
                  int v105 = *(_DWORD *)(v27 + 216);
                  *(_DWORD *)buf = 134218752;
                  *(void *)&buf[4] = v103;
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v104;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v105;
                  *(_WORD *)&uint8_t buf[24] = 1024;
                  *(_DWORD *)&buf[26] = v106;
                  _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): VCPRateControlSession is created, use_hw: %d\n", buf, 0x1Eu);
                }
                uint64_t v56 = 0;
                goto LABEL_70;
              }
              if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
                goto LABEL_125;
              }
              *(_DWORD *)buf = 136315138;
              *(void *)&buf[4] = v27 + 256;
              double v80 = MEMORY[0x1E4F14500];
              v81 = "%s: Low latency RC mode requires hardware encoder\n";
LABEL_124:
              _os_log_error_impl(&dword_1BB9B9000, v80, OS_LOG_TYPE_ERROR, v81, buf, 0xCu);
              goto LABEL_125;
            }
            *(void *)(v27 + 2544) = 0;
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315138;
              *(void *)&buf[4] = v27 + 256;
              int v73 = MEMORY[0x1E4F14500];
              unsigned int v74 = "%s: failed to register supported keys\n";
              uint32_t v75 = 12;
              goto LABEL_89;
            }
            goto LABEL_52;
          }
          v71 = (const void *)*MEMORY[0x1E4F45648];
          if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F45648]))
          {
            unsigned int v106 = sub_1BB9BEF74(theDict, v71);
            goto LABEL_99;
          }
          BOOL v72 = 1;
        }
        unsigned int v106 = v72;
        goto LABEL_99;
      }
    }
    else
    {
      *(void *)(v27 + 2256) = 0;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to create stats monitor\n", buf, 2u);
      }
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to initialize VCPRateControlSession\n", buf, 2u);
    }
    uint64_t v56 = 4294954392;
    goto LABEL_69;
  }
  int v22 = CFBooleanGetValue(v21);
  BOOL v107 = v22 != 0;
  if (v22) {
    char v23 = 1;
  }
  else {
    char v23 = v19;
  }
  if (v23) {
    goto LABEL_15;
  }
LABEL_25:
  pthread_once(&stru_1EC0270E8, (void (*)(void))sub_1BB9CB9C4);
  uint64_t v32 = _CFRuntimeCreateInstance();
  if (v32)
  {
    v33 = (void *)v32;
    int v34 = (char *)operator new(0x9F8uLL, MEMORY[0x1E4FBA2D0]);
    if (v34)
    {
      uint64_t v35 = (uint64_t)v34;
      int v36 = v34 + 2304;
      bzero(v34, 0x9F8uLL);
      *(void *)(v35 + 2304) = 850045863;
      *(_OWORD *)(v36 + 8) = 0u;
      *(_OWORD *)(v36 + 24) = 0u;
      *(_OWORD *)(v36 + 40) = 0u;
      *(void *)(v35 + 2360) = 0;
      std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)(v35 + 2368));
      *(void *)(v35 + 2536) = 0;
      v33[2] = v35;
      *(unsigned char *)(v35 + 244) = 0;
      *(void *)(v35 + 2536) = mach_absolute_time();
      *(_DWORD *)(v35 + 208) = a4;
      *(_DWORD *)(v35 + 212) = a2;
      *(_DWORD *)(v35 + 216) = a3;
      *(unsigned char *)(v35 + 232) = 0;
      *(void *)(v35 + 184) = 0;
      *(void *)(v35 + 224) = 0;
      snprintf((char *)(v35 + 256), 0x7D0uLL, "VCPRateControlSession(NonLowLatency) %p (%dx%d)", v33, a2, a3);
      int v37 = (float *)operator new(0x28uLL, MEMORY[0x1E4FBA2D0]);
      if (v37)
      {
        int v38 = v37;
        *(_OWORD *)int v37 = 0u;
        *((_OWORD *)v37 + 1) = 0u;
        v37[8] = 1.0;
        *(void *)(v35 + 2544) = v37;
        CFTypeID v39 = CFNumberGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F44810];
        *(void *)&buf[8] = v39;
        *(void *)&buf[16] = "AverageBitRate";
        *(void *)&uint8_t buf[24] = v35 + 76;
        char v112 = 0;
        uint64_t v113 = 3;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v40 = CFNumberGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F44898];
        *(void *)&buf[8] = v40;
        *(void *)&buf[16] = "DataRateLimits";
        *(void *)&uint8_t buf[24] = v35 + 136;
        char v112 = 0;
        uint64_t v113 = 16;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v41 = CFNumberGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F44878];
        *(void *)&buf[8] = v41;
        *(void *)&buf[16] = "ConstantBitRate";
        *(void *)&uint8_t buf[24] = v35 + 144;
        char v112 = 0;
        uint64_t v113 = 3;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v42 = CFNumberGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F448F0];
        *(void *)&buf[8] = v42;
        *(void *)&buf[16] = "ExpectedFrameRate";
        *(void *)&uint8_t buf[24] = v35 + 40;
        char v112 = 0;
        uint64_t v113 = 13;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v43 = CFStringGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F44AA0];
        *(void *)&buf[8] = v43;
        *(void *)&buf[16] = "ProfileLevel";
        *(void *)&uint8_t buf[24] = v35;
        char v112 = 0;
        uint64_t v113 = 16;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v44 = CFBooleanGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F447E8];
        *(void *)&buf[8] = v44;
        *(void *)&buf[16] = "AllowTemporalCompression";
        *(void *)&uint8_t buf[24] = v35 + 64;
        char v112 = 0;
        uint64_t v113 = 16;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v45 = CFBooleanGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F447D0];
        *(void *)&buf[8] = v45;
        *(void *)&buf[16] = "AllowFrameReordering";
        *(void *)&uint8_t buf[24] = v35 + 65;
        char v112 = 0;
        uint64_t v113 = 16;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v46 = CFNumberGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F44AC8];
        *(void *)&buf[8] = v46;
        *(void *)&buf[16] = "ReferenceBufferCount";
        *(void *)&uint8_t buf[24] = v35 + 100;
        char v112 = 0;
        uint64_t v113 = 3;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v47 = CFNumberGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F449C8];
        *(void *)&buf[8] = v47;
        *(void *)&buf[16] = "ReferenceBufferCount";
        *(void *)&uint8_t buf[24] = v35 + 68;
        char v112 = 0;
        uint64_t v113 = 3;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v48 = CFNumberGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F449D0];
        *(void *)&buf[8] = v48;
        *(void *)&buf[16] = "MaxKeyFrameIntervalDuration";
        *(void *)&uint8_t buf[24] = v35 + 72;
        char v112 = 0;
        uint64_t v113 = 5;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v49 = CFNumberGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F44A48];
        *(void *)&buf[8] = v49;
        *(void *)&buf[16] = "OutputBitDepth";
        *(void *)&uint8_t buf[24] = v35 + 148;
        char v112 = 0;
        uint64_t v113 = 3;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v50 = CFStringGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F44920];
        *(void *)&buf[8] = v50;
        *(void *)&buf[16] = "H264EntropyMode";
        *(void *)&uint8_t buf[24] = v35 + 24;
        char v112 = 0;
        uint64_t v113 = 16;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v51 = CFNumberGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F44AB0];
        *(void *)&buf[8] = v51;
        *(void *)&buf[16] = "Quality";
        *(void *)&uint8_t buf[24] = v35 + 152;
        char v112 = 0;
        uint64_t v113 = 13;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v52 = CFBooleanGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F44A80];
        *(void *)&buf[8] = v52;
        *(void *)&buf[16] = "PreserveAlphaChannel";
        *(void *)&uint8_t buf[24] = v35 + 160;
        char v112 = 0;
        uint64_t v113 = 16;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v53 = CFStringGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F447F0];
        *(void *)&buf[8] = v53;
        *(void *)&buf[16] = "AlphaChannelMode";
        *(void *)&uint8_t buf[24] = v35 + 168;
        char v112 = 0;
        uint64_t v113 = 16;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFTypeID v54 = CFNumberGetTypeID();
        *(void *)buf = *MEMORY[0x1E4F44B30];
        *(void *)&buf[8] = v54;
        *(void *)&buf[16] = "TargetQualityForAlpha";
        *(void *)&uint8_t buf[24] = v35 + 176;
        char v112 = 0;
        uint64_t v113 = 13;
        uint64_t v114 = 0;
        sub_1BB9C7544(v38, (CFTypeRef *)buf, (uint64_t)buf);
        CFDictionaryRef v55 = sub_1BB9C795C(v35);
        *(void *)(v35 + 184) = v55;
        if (v55)
        {
          uint64_t v56 = 0;
LABEL_50:
          *a11 = v33;
          return v56;
        }
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = v35 + 256;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: failed to create supported-key dictionary\n", buf, 0xCu);
        }
        uint64_t v56 = 1;
      }
      else
      {
        *(void *)(v35 + 2544) = 0;
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = v35 + 256;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: failed to register supported keys\n", buf, 0xCu);
        }
        uint64_t v56 = 4294967188;
      }
      *(unsigned char *)(v35 + 232) = 1;
      sub_1BB9C740C(v35);
      std::condition_variable::~condition_variable((std::condition_variable *)(v35 + 2480));
      std::condition_variable::~condition_variable((std::condition_variable *)(v35 + 2432));
      std::mutex::~mutex((std::mutex *)(v35 + 2368));
      std::mutex::~mutex((std::mutex *)v36);
      MEMORY[0x1C18605E0](v35, 0x10F0C40EEABCC0CLL);
    }
    else
    {
      v33[2] = 0;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to create private storage\n", buf, 2u);
      }
      uint64_t v56 = 4294967188;
    }
    CFRelease(v33);
    v33 = 0;
    goto LABEL_50;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to create VCPRateControlSession\n", buf, 2u);
  }
  return 4294954392;
}

void sub_1BB9BD058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  __cxa_guard_abort(&qword_1E9F81570);
  sub_1BB9BEF9C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t Filter8tapV_neon64(uint64_t result, void *a2, int a3, int16x8_t *a4, unsigned int a5)
{
  int16x8_t v5 = *a4;
  int v6 = (_OWORD *)*a2;
  int v7 = (uint8x16_t *)a2[1];
  int v8 = (_OWORD *)a2[2];
  uint64_t v9 = (uint8x16_t *)a2[3];
  signed int v10 = (_OWORD *)a2[4];
  unsigned int v11 = (uint8x16_t *)a2[5];
  unsigned int v12 = (_OWORD *)a2[6];
  unsigned int v13 = (uint8x16_t *)a2[7];
  int16x8_t v14 = vnegq_s16(vdupq_n_s16(a5));
  if ((a3 & 0x10000) != 0)
  {
    a3 -= 16;
    uint8x16_t v16 = *(uint8x16_t *)v6;
    unint64_t v15 = v6 + 1;
    uint8x16_t v17 = *(uint8x16_t *)v15;
    int v6 = v15 + 1;
    int16x8_t v18 = vmlaq_lane_s16(vmulq_n_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v16.i8), v5.i16[0]), (int16x8_t)vmovl_u8(*(uint8x8_t *)v17.i8), *(int16x4_t *)v5.i8, 1);
    int16x8_t v19 = vmlaq_lane_s16(vmulq_n_s16((int16x8_t)vmovl_high_u8(v16), v5.i16[0]), (int16x8_t)vmovl_high_u8(v17), *(int16x4_t *)v5.i8, 1);
    uint8x16_t v21 = *(uint8x16_t *)v8;
    int v20 = v8 + 1;
    uint8x16_t v22 = *(uint8x16_t *)v20;
    int v8 = v20 + 1;
    int16x8_t v23 = vmlaq_lane_s16(vmlaq_lane_s16(v18, (int16x8_t)vmovl_u8(*(uint8x8_t *)v21.i8), *(int16x4_t *)v5.i8, 2), (int16x8_t)vmovl_u8(*(uint8x8_t *)v22.i8), *(int16x4_t *)v5.i8, 3);
    int16x8_t v24 = vmlaq_lane_s16(vmlaq_lane_s16(v19, (int16x8_t)vmovl_high_u8(v21), *(int16x4_t *)v5.i8, 2), (int16x8_t)vmovl_high_u8(v22), *(int16x4_t *)v5.i8, 3);
    uint8x16_t v26 = *(uint8x16_t *)v10;
    CFNumberRef v25 = v10 + 1;
    uint8x16_t v27 = *(uint8x16_t *)v25;
    signed int v10 = v25 + 1;
    int16x8_t v28 = vmlaq_laneq_s16(vmlaq_laneq_s16(v23, (int16x8_t)vmovl_u8(*(uint8x8_t *)v26.i8), v5, 4), (int16x8_t)vmovl_u8(*(uint8x8_t *)v27.i8), v5, 5);
    int16x8_t v29 = vmlaq_laneq_s16(vmlaq_laneq_s16(v24, (int16x8_t)vmovl_high_u8(v26), v5, 4), (int16x8_t)vmovl_high_u8(v27), v5, 5);
    uint8x16_t v31 = *(uint8x16_t *)v12;
    CFNumberRef v30 = v12 + 1;
    uint8x16_t v32 = *(uint8x16_t *)v30;
    unsigned int v12 = v30 + 1;
    *(int8x8_t *)uint64_t result = vqmovun_s16(vrshlq_s16(vmlaq_laneq_s16(vmlaq_laneq_s16(v28, (int16x8_t)vmovl_u8(*(uint8x8_t *)v31.i8), v5, 6), (int16x8_t)vmovl_u8(*(uint8x8_t *)v32.i8), v5, 7), v14));
    *(int8x8_t *)(result + 8) = vqmovun_s16(vrshlq_s16(vmlaq_laneq_s16(vmlaq_laneq_s16(v29, (int16x8_t)vmovl_high_u8(v31), v5, 6), (int16x8_t)vmovl_high_u8(v32), v5, 7), v14));
    result += 16;
  }
  do
  {
    BOOL v33 = __OFSUB__(a3, 32);
    a3 -= 32;
    uint8x16_t v34 = *(uint8x16_t *)v6;
    uint8x16_t v35 = *((uint8x16_t *)v6 + 1);
    v6 += 2;
    int16x8_t v36 = vmulq_n_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v34.i8), v5.i16[0]);
    int16x8_t v37 = vmulq_n_s16((int16x8_t)vmovl_high_u8(v34), v5.i16[0]);
    int16x8_t v38 = vmulq_n_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v35.i8), v5.i16[0]);
    int16x8_t v39 = vmulq_n_s16((int16x8_t)vmovl_high_u8(v35), v5.i16[0]);
    uint8x16_t v40 = *v7;
    uint8x16_t v41 = v7[1];
    v7 += 2;
    int16x8_t v42 = vmlaq_lane_s16(v36, (int16x8_t)vmovl_u8(*(uint8x8_t *)v40.i8), *(int16x4_t *)v5.i8, 1);
    int16x8_t v43 = vmlaq_lane_s16(v37, (int16x8_t)vmovl_high_u8(v40), *(int16x4_t *)v5.i8, 1);
    int16x8_t v44 = vmlaq_lane_s16(v38, (int16x8_t)vmovl_u8(*(uint8x8_t *)v41.i8), *(int16x4_t *)v5.i8, 1);
    int16x8_t v45 = vmlaq_lane_s16(v39, (int16x8_t)vmovl_high_u8(v41), *(int16x4_t *)v5.i8, 1);
    uint8x16_t v46 = *(uint8x16_t *)v8;
    uint8x16_t v47 = *((uint8x16_t *)v8 + 1);
    v8 += 2;
    int16x8_t v48 = vmlaq_lane_s16(v42, (int16x8_t)vmovl_u8(*(uint8x8_t *)v46.i8), *(int16x4_t *)v5.i8, 2);
    int16x8_t v49 = vmlaq_lane_s16(v43, (int16x8_t)vmovl_high_u8(v46), *(int16x4_t *)v5.i8, 2);
    int16x8_t v50 = vmlaq_lane_s16(v44, (int16x8_t)vmovl_u8(*(uint8x8_t *)v47.i8), *(int16x4_t *)v5.i8, 2);
    int16x8_t v51 = vmlaq_lane_s16(v45, (int16x8_t)vmovl_high_u8(v47), *(int16x4_t *)v5.i8, 2);
    uint8x16_t v52 = *v9;
    uint8x16_t v53 = v9[1];
    v9 += 2;
    int16x8_t v54 = vmlaq_lane_s16(v48, (int16x8_t)vmovl_u8(*(uint8x8_t *)v52.i8), *(int16x4_t *)v5.i8, 3);
    int16x8_t v55 = vmlaq_lane_s16(v49, (int16x8_t)vmovl_high_u8(v52), *(int16x4_t *)v5.i8, 3);
    int16x8_t v56 = vmlaq_lane_s16(v50, (int16x8_t)vmovl_u8(*(uint8x8_t *)v53.i8), *(int16x4_t *)v5.i8, 3);
    int16x8_t v57 = vmlaq_lane_s16(v51, (int16x8_t)vmovl_high_u8(v53), *(int16x4_t *)v5.i8, 3);
    uint8x16_t v58 = *(uint8x16_t *)v10;
    uint8x16_t v59 = *((uint8x16_t *)v10 + 1);
    v10 += 2;
    int16x8_t v60 = vmlaq_laneq_s16(v54, (int16x8_t)vmovl_u8(*(uint8x8_t *)v58.i8), v5, 4);
    int16x8_t v61 = vmlaq_laneq_s16(v55, (int16x8_t)vmovl_high_u8(v58), v5, 4);
    int16x8_t v62 = vmlaq_laneq_s16(v56, (int16x8_t)vmovl_u8(*(uint8x8_t *)v59.i8), v5, 4);
    int16x8_t v63 = vmlaq_laneq_s16(v57, (int16x8_t)vmovl_high_u8(v59), v5, 4);
    uint8x16_t v64 = *v11;
    uint8x16_t v65 = v11[1];
    v11 += 2;
    int16x8_t v66 = vmlaq_laneq_s16(v60, (int16x8_t)vmovl_u8(*(uint8x8_t *)v64.i8), v5, 5);
    int16x8_t v67 = vmlaq_laneq_s16(v61, (int16x8_t)vmovl_high_u8(v64), v5, 5);
    int16x8_t v68 = vmlaq_laneq_s16(v62, (int16x8_t)vmovl_u8(*(uint8x8_t *)v65.i8), v5, 5);
    int16x8_t v69 = vmlaq_laneq_s16(v63, (int16x8_t)vmovl_high_u8(v65), v5, 5);
    uint8x16_t v70 = *(uint8x16_t *)v12;
    uint8x16_t v71 = *((uint8x16_t *)v12 + 1);
    v12 += 2;
    int16x8_t v72 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v70.i8);
    int16x8_t v73 = (int16x8_t)vmovl_high_u8(v70);
    int16x8_t v74 = vmlaq_laneq_s16(v68, (int16x8_t)vmovl_u8(*(uint8x8_t *)v71.i8), v5, 6);
    int16x8_t v75 = vmlaq_laneq_s16(v69, (int16x8_t)vmovl_high_u8(v71), v5, 6);
    uint8x16_t v76 = *v13;
    uint8x16_t v77 = v13[1];
    v13 += 2;
    *(int8x16_t *)uint64_t result = vqmovun_high_s16(vqmovun_s16(vrshlq_s16(vmlaq_laneq_s16(vmlaq_laneq_s16(v66, v72, v5, 6), (int16x8_t)vmovl_u8(*(uint8x8_t *)v76.i8), v5, 7), v14)), vrshlq_s16(vmlaq_laneq_s16(vmlaq_laneq_s16(v67, v73, v5, 6), (int16x8_t)vmovl_high_u8(v76), v5, 7), v14));
    *(int8x16_t *)(result + 16) = vqmovun_high_s16(vqmovun_s16(vrshlq_s16(vmlaq_laneq_s16(v74, (int16x8_t)vmovl_u8(*(uint8x8_t *)v77.i8), v5, 7), v14)), vrshlq_s16(vmlaq_laneq_s16(v75, (int16x8_t)vmovl_high_u8(v77), v5, 7), v14));
    result += 32;
  }
  while (!((a3 < 0) ^ v33 | (a3 == 0)));
  return result;
}

int8x8_t *Filter8tapH_neon64(int8x8_t *result, uint64_t a2, int a3, uint64_t a4, unsigned __int16 *a5, unsigned char *a6, unsigned int a7)
{
  int16x8_t v7 = vnegq_s16(vdupq_n_s16(a7));
  unsigned __int16 v9 = *a5;
  int v8 = a5 + 1;
  signed int v10 = (uint8x8_t *)(a2 - 3 + v9);
  do
  {
    BOOL v11 = __OFSUB__(a3, 8);
    a3 -= 8;
    unsigned int v14 = *v8;
    unsigned int v12 = v8 + 1;
    uint64_t v13 = v14;
    unsigned int v16 = *v12++;
    uint64_t v15 = v16;
    unsigned int v18 = *v12++;
    uint64_t v17 = v18;
    unsigned int v19 = *v12++;
    uint8x8_t v21 = *v10;
    int v20 = (uint8x8_t *)((char *)v10 + v13);
    uint8x8_t v23 = *v20;
    uint8x16_t v22 = (uint8x8_t *)((char *)v20 + v15);
    uint8x8_t v25 = *v22;
    int16x8_t v24 = (uint8x8_t *)((char *)v22 + v17);
    uint8x8_t v27 = *v24;
    uint8x16_t v26 = (uint8x8_t *)((char *)v24 + v19);
    LOBYTE(v19) = *a6;
    int16x8_t v28 = a6 + 1;
    LOBYTE(v13) = v19;
    LOBYTE(v19) = *v28++;
    LOBYTE(v15) = v19;
    LOBYTE(v19) = *v28++;
    LOBYTE(v17) = v19;
    LOBYTE(v19) = *v28++;
    int16x8_t v29 = vmulq_s16((int16x8_t)vmovl_u8(v21), *(int16x8_t *)(a4 + v13));
    int16x8_t v30 = vmulq_s16((int16x8_t)vmovl_u8(v23), *(int16x8_t *)(a4 + v15));
    int16x8_t v31 = vmulq_s16((int16x8_t)vmovl_u8(v25), *(int16x8_t *)(a4 + v17));
    int16x8_t v32 = vmulq_s16((int16x8_t)vmovl_u8(v27), *(int16x8_t *)(a4 + v19));
    unsigned int v34 = *v12++;
    uint64_t v33 = v34;
    unsigned int v36 = *v12++;
    uint64_t v35 = v36;
    unsigned int v38 = *v12++;
    uint64_t v37 = v38;
    unsigned int v39 = *v12;
    int v8 = v12 + 1;
    uint8x8_t v41 = *v26;
    uint8x16_t v40 = (uint8x8_t *)((char *)v26 + v33);
    uint8x8_t v43 = *v40;
    int16x8_t v42 = (uint8x8_t *)((char *)v40 + v35);
    uint8x8_t v45 = *v42;
    int16x8_t v44 = (uint8x8_t *)((char *)v42 + v37);
    uint8x8_t v46 = *v44;
    signed int v10 = (uint8x8_t *)((char *)v44 + v39);
    LOBYTE(v39) = *v28++;
    LOBYTE(v33) = v39;
    LOBYTE(v39) = *v28++;
    LOBYTE(v35) = v39;
    LOBYTE(v39) = *v28++;
    LOBYTE(v37) = v39;
    LOBYTE(v39) = *v28;
    a6 = v28 + 1;
    *result++ = vqmovun_s16(vrshlq_s16(vpaddq_s16(vpaddq_s16(vpaddq_s16(v29, v30), vpaddq_s16(v31, v32)), vpaddq_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(v41), *(int16x8_t *)(a4 + v33)), vmulq_s16((int16x8_t)vmovl_u8(v43), *(int16x8_t *)(a4 + v35))), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(v45), *(int16x8_t *)(a4 + v37)), vmulq_s16((int16x8_t)vmovl_u8(v46), *(int16x8_t *)(a4 + v39))))), v7));
  }
  while (!((a3 < 0) ^ v11 | (a3 == 0)));
  return result;
}

int8x8_t *Filter8tapH_chroma_neon64(int8x8_t *result, uint64_t a2, int a3, uint64_t a4, unsigned __int16 *a5, unsigned char *a6, unsigned int a7)
{
  int16x8_t v7 = vnegq_s16(vdupq_n_s16(a7));
  unsigned __int16 v9 = *a5;
  int v8 = a5 + 1;
  signed int v10 = (const char *)(a2 - 6 + v9);
  do
  {
    BOOL v11 = __OFSUB__(a3, 8);
    a3 -= 8;
    unsigned int v14 = *v8;
    unsigned int v12 = v8 + 1;
    uint64_t v13 = v14;
    unsigned int v16 = *v12++;
    uint64_t v15 = v16;
    unsigned int v18 = *v12++;
    uint64_t v17 = v18;
    unsigned int v20 = *v12;
    int v8 = v12 + 1;
    uint64_t v19 = v20;
    int8x8x2_t v25 = vld2_s8(v10);
    uint8x8_t v21 = &v10[v13];
    int8x8x2_t v26 = vld2_s8(v21);
    uint8x16_t v22 = &v21[v15];
    int8x8x2_t v27 = vld2_s8(v22);
    uint8x8_t v23 = &v22[v17];
    int8x8x2_t v28 = vld2_s8(v23);
    signed int v10 = &v23[v19];
    LOBYTE(v20) = *a6;
    int16x8_t v24 = a6 + 1;
    LOBYTE(v13) = v20;
    LOBYTE(v20) = *v24++;
    LOBYTE(v15) = v20;
    LOBYTE(v20) = *v24++;
    LOBYTE(v17) = v20;
    LOBYTE(v20) = *v24;
    a6 = v24 + 1;
    *result++ = vqmovun_s16(vrshlq_s16(vpaddq_s16(vpaddq_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v25.val[0]), *(int16x8_t *)(a4 + v13)), vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v25.val[1]), *(int16x8_t *)(a4 + v13))), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v26.val[0]), *(int16x8_t *)(a4 + v15)), vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v26.val[1]), *(int16x8_t *)(a4 + v15)))), vpaddq_s16(vpaddq_s16(
                          vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v27.val[0]), *(int16x8_t *)(a4 + v17)), vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v27.val[1]), *(int16x8_t *)(a4 + v17))), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v28.val[0]), *(int16x8_t *)(a4 + v20)), vmulq_s16((int16x8_t)vmovl_u8((uint8x8_t)v28.val[1]), *(int16x8_t *)(a4 + v20))))), v7));
  }
  while (!((a3 < 0) ^ v11 | (a3 == 0)));
  return result;
}

uint16x8_t *BilinearFilterV_swift_neon(uint16x8_t *result, uint8x16_t *a2, uint8x16_t *a3, int a4, unsigned int a5)
{
  int8x16_t v5 = vdupq_n_s8(a5);
  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  uint8x16_t v7 = (uint8x16_t)vsubq_s8(v6, v5);
  int v8 = a4 & 0x3F;
  signed int v9 = a4 & 0xFFFFFFC0;
  if (!v9) {
    goto LABEL_6;
  }
  do
  {
    BOOL v10 = __OFSUB__(v9, 64);
    v9 -= 64;
    uint8x16_t v12 = *a2;
    uint8x16_t v13 = a2[1];
    BOOL v11 = a2 + 2;
    uint8x16_t v15 = *a3;
    uint8x16_t v16 = a3[1];
    unsigned int v14 = a3 + 2;
    uint8x16_t v17 = *v11;
    uint8x16_t v18 = v11[1];
    a2 = v11 + 2;
    uint8x16_t v19 = *v14;
    uint8x16_t v20 = v14[1];
    a3 = v14 + 2;
    *uint64_t result = vmlal_u8(vmull_u8(*(uint8x8_t *)v12.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v15.i8, *(uint8x8_t *)v5.i8);
    result[1] = vmlal_high_u8(vmull_high_u8(v12, v7), v15, (uint8x16_t)v5);
    uint8x8_t v21 = result + 2;
    *uint8x8_t v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v13.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v16.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v13, v7), v16, (uint8x16_t)v5);
    v21 += 2;
    *uint8x8_t v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v17.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v19.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v17, v7), v19, (uint8x16_t)v5);
    v21 += 2;
    *uint8x8_t v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v20.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v18, v7), v20, (uint8x16_t)v5);
    uint64_t result = v21 + 2;
  }
  while (!((v9 < 0) ^ v10 | (v9 == 0)));
  if (v8)
  {
LABEL_6:
    do
    {
      BOOL v10 = __OFSUB__(v8, 16);
      v8 -= 16;
      uint8x16_t v22 = *a2++;
      uint8x16_t v23 = *a3++;
      *uint64_t result = vmlal_u8(vmull_u8(*(uint8x8_t *)v22.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v23.i8, *(uint8x8_t *)v5.i8);
      result[1] = vmlal_high_u8(vmull_high_u8(v22, v7), v23, (uint8x16_t)v5);
      result += 2;
    }
    while (!((v8 < 0) ^ v10 | (v8 == 0)));
  }
  return result;
}

int8x16_t *BilinearFilterH_swift_neon(int8x16_t *result, uint64_t a2, int a3, unsigned int a4, int8x16_t *a5, uint64_t a6)
{
  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  unint64_t v7 = 0;
  uint64_t v8 = 2 * a4;
  uint64_t v9 = 3 * a4;
  uint64_t v10 = 4 * a4;
  do
  {
    BOOL v11 = __OFSUB__(a3, 16);
    a3 -= 16;
    int8x16_t v12 = *a5++;
    int8x16_t v13 = vsubq_s8(v6, v12);
    uint8x16_t v14 = (uint8x16_t)vzip1q_s8(v13, v12);
    uint8x16_t v15 = (uint8x16_t)vzip2q_s8(v13, v12);
    uint8x16_t v16 = (const float *)(((v7 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint8x16_t v17 = (__int32 *)((((v7 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint8x16_t v18 = (__int32 *)((((v7 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint8x16_t v19 = (__int32 *)((((v7 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    unint64_t v20 = v7 + v10;
    v21.i32[0] = vld1q_dup_f32(v16).u32[0];
    v21.i32[1] = *v17;
    v21.i32[2] = *v18;
    v21.i32[3] = *v19;
    uint8x16_t v22 = (const float *)(((v20 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint8x16_t v23 = (__int32 *)((((v20 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    int16x8_t v24 = (__int32 *)((((v20 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    int8x8x2_t v25 = (__int32 *)((((v20 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    unint64_t v26 = v20 + v10;
    v27.i32[0] = vld1q_dup_f32(v22).u32[0];
    v27.i32[1] = *v23;
    v27.i32[2] = *v24;
    v27.i32[3] = *v25;
    int8x8x2_t v28 = (const float *)(((v26 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    int16x8_t v29 = (__int32 *)((((v26 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    int16x8_t v30 = (__int32 *)((((v26 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    int16x8_t v31 = (__int32 *)((((v26 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    unint64_t v32 = v26 + v10;
    v33.i32[0] = vld1q_dup_f32(v28).u32[0];
    v33.i32[1] = *v29;
    v33.i32[2] = *v30;
    v33.i32[3] = *v31;
    unsigned int v34 = (const float *)(((v32 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint64_t v35 = (__int32 *)((((v32 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    unsigned int v36 = (__int32 *)((((v32 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint64_t v37 = (__int32 *)((((v32 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    unint64_t v7 = v32 + v10;
    v38.i32[0] = vld1q_dup_f32(v34).u32[0];
    v38.i32[1] = *v35;
    v38.i32[2] = *v36;
    v38.i32[3] = *v37;
    *uint64_t result = vrshrn_high_n_s16(vrshrn_n_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v14.i8), v21), vmulq_s16((int16x8_t)vmovl_high_u8(v14), v27)), 8uLL), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v15.i8), v33), vmulq_s16((int16x8_t)vmovl_high_u8(v15), v38)), 8uLL);
    uint64_t result = (int8x16_t *)((char *)result + a6);
  }
  while (!((a3 < 0) ^ v11 | (a3 == 0)));
  return result;
}

int8x16_t *BilinearFilterH_swift_chroma_neon(int8x16_t *result, uint64_t a2, int a3, unsigned int a4, int8x16_t *a5, uint64_t a6)
{
  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  unint64_t v7 = 0;
  uint64_t v8 = 2 * a4;
  uint64_t v9 = 3 * a4;
  uint64_t v10 = 4 * a4;
  int v11 = a3 - 8;
  if (!v11) {
    goto LABEL_5;
  }
  do
  {
    BOOL v12 = __OFSUB__(v11, 16);
    v11 -= 16;
    int8x16_t v13 = (const float *)(((v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x16_t v14 = (__int32 *)((((v7 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x16_t v15 = (__int32 *)((((v7 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x16_t v16 = (__int32 *)((((v7 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v17 = v7 + v10;
    float32x4x2_t v49 = vld2q_dup_f32(v13);
    v49.val[0].i32[1] = *v14;
    v49.val[1].i32[1] = v14[1];
    v49.val[0].i32[2] = *v15;
    v49.val[1].i32[2] = v15[1];
    v49.val[0].i32[3] = *v16;
    v49.val[1].i32[3] = v16[1];
    uint8x16_t v18 = (const float *)(((v17 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x16_t v19 = (__int32 *)((((v17 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v20 = (__int32 *)((((v17 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    int16x8_t v21 = (__int32 *)((((v17 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v22 = v17 + v10;
    float32x4x2_t v51 = vld2q_dup_f32(v18);
    v51.val[0].i32[1] = *v19;
    v51.val[1].i32[1] = v19[1];
    v51.val[0].i32[2] = *v20;
    v51.val[1].i32[2] = v20[1];
    v51.val[0].i32[3] = *v21;
    v51.val[1].i32[3] = v21[1];
    int8x16_t v23 = *a5++;
    int8x16_t v24 = vzip1q_s8(v23, v23);
    int8x16_t v25 = vzip2q_s8(v23, v23);
    uint8x16_t v26 = (uint8x16_t)vsubq_s8(v6, v24);
    uint8x16_t v27 = (uint8x16_t)vsubq_s8(v6, v25);
    int8x8x2_t v28 = (const float *)(((v22 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    int16x8_t v29 = (__int32 *)((((v22 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    int16x8_t v30 = (__int32 *)((((v22 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    int16x8_t v31 = (__int32 *)((((v22 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v32 = v22 + v10;
    float32x4x2_t v53 = vld2q_dup_f32(v28);
    v53.val[0].i32[1] = *v29;
    v53.val[1].i32[1] = v29[1];
    v53.val[0].i32[2] = *v30;
    v53.val[1].i32[2] = v30[1];
    v53.val[0].i32[3] = *v31;
    v53.val[1].i32[3] = v31[1];
    int16x8_t v33 = (const float *)(((v32 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unsigned int v34 = (__int32 *)((((v32 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint64_t v35 = (__int32 *)((((v32 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unsigned int v36 = (__int32 *)((((v32 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v7 = v32 + v10;
    float32x4x2_t v54 = vld2q_dup_f32(v33);
    v54.val[0].i32[1] = *v34;
    v54.val[1].i32[1] = v34[1];
    v54.val[0].i32[2] = *v35;
    v54.val[1].i32[2] = v35[1];
    v54.val[0].i32[3] = *v36;
    v54.val[1].i32[3] = v36[1];
    *uint64_t result = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v49.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v26.i8)), vmulq_s16((int16x8_t)v49.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v24.i8))), vmulq_s16((int16x8_t)v51.val[0], (int16x8_t)vmovl_high_u8(v26)), vmulq_s16((int16x8_t)v51.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v24)));
    uint64_t v37 = (int8x16_t *)((char *)result + a6);
    *uint64_t v37 = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v53.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v27.i8)), vmulq_s16((int16x8_t)v53.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v25.i8))), vmulq_s16((int16x8_t)v54.val[0], (int16x8_t)vmovl_high_u8(v27)), vmulq_s16((int16x8_t)v54.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v25)));
    uint64_t result = (int8x16_t *)((char *)v37 + a6);
  }
  while (!((v11 < 0) ^ v12 | (v11 == 0)));
  if (v11 < 0 == v12)
  {
LABEL_5:
    int16x8_t v38 = (const float *)(((v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unsigned int v39 = (__int32 *)((((v7 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x16_t v40 = (__int32 *)((((v7 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x8_t v41 = (__int32 *)((((v7 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v42 = v7 + v10;
    float32x4x2_t v50 = vld2q_dup_f32(v38);
    v50.val[0].i32[1] = *v39;
    v50.val[1].i32[1] = v39[1];
    v50.val[0].i32[2] = *v40;
    v50.val[1].i32[2] = v40[1];
    v50.val[0].i32[3] = *v41;
    v50.val[1].i32[3] = v41[1];
    uint8x8_t v43 = (const float *)(((v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    int16x8_t v44 = (__int32 *)((((v42 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x8_t v45 = (__int32 *)((((v42 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x8_t v46 = (__int32 *)((((v42 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    float32x4x2_t v52 = vld2q_dup_f32(v43);
    v52.val[0].i32[1] = *v44;
    v52.val[1].i32[1] = v44[1];
    v52.val[0].i32[2] = *v45;
    v52.val[1].i32[2] = v45[1];
    v52.val[0].i32[3] = *v46;
    v52.val[1].i32[3] = v46[1];
    int8x16_t v47 = vzip1q_s8(*a5, *a5);
    uint8x16_t v48 = (uint8x16_t)vsubq_s8(v6, v47);
    *uint64_t result = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v50.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v48.i8)), vmulq_s16((int16x8_t)v50.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v47.i8))), vmulq_s16((int16x8_t)v52.val[0], (int16x8_t)vmovl_high_u8(v48)), vmulq_s16((int16x8_t)v52.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v47)));
    return (int8x16_t *)((char *)result + a6);
  }
  return result;
}

int8x16_t *BilinearFilterH_vperm2_neon64(int8x16_t *result, uint64_t a2, int a3, unsigned int *a4, int8x16_t *a5, int8x16_t *a6, uint64_t a7)
{
  v7.i64[0] = 0x1010101010101010;
  v7.i64[1] = 0x1010101010101010;
  do
  {
    BOOL v8 = __OFSUB__(a3, 16);
    a3 -= 16;
    int8x16_t v9 = *a5++;
    int8x16_t v10 = vsubq_s8(v7, v9);
    uint8x16_t v11 = (uint8x16_t)vzip1q_s8(v10, v9);
    uint8x16_t v12 = (uint8x16_t)vzip2q_s8(v10, v9);
    uint64_t v13 = a4[2];
    uint64_t v14 = a4[3];
    uint64_t v15 = *a4;
    uint64_t v16 = a4[1];
    a4 += 4;
    int8x16_t v17 = a6[3];
    int8x16_t v18 = a6[2];
    int8x16_t v19 = a6[1];
    int8x16_t v20 = *a6;
    a6 += 4;
    *uint64_t result = vrshrn_high_n_s16(vrshrn_n_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v11.i8), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v15), v20)), vmulq_s16((int16x8_t)vmovl_high_u8(v11), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v16), v19))), 8uLL), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v12.i8), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v13), v18)), vmulq_s16((int16x8_t)vmovl_high_u8(v12), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v14), v17))), 8uLL);
    uint64_t result = (int8x16_t *)((char *)result + a7);
  }
  while (!((a3 < 0) ^ v8 | (a3 == 0)));
  return result;
}

int8x16_t *BilinearFilterH_chroma_vperm2_neon64(int8x16_t *result, uint64_t a2, int a3, unsigned int *a4, int8x16_t *a5, int8x16_t *a6, uint64_t a7)
{
  v7.i64[0] = 0x1010101010101010;
  v7.i64[1] = 0x1010101010101010;
  uint64_t v8 = a2 + 16;
  do
  {
    BOOL v9 = __OFSUB__(a3, 8);
    a3 -= 8;
    int8x16_t v10 = *a5++;
    uint8x16_t v11 = (uint8x16_t)vsubq_s8(v7, v10);
    int16x8_t v12 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v11.i8);
    int16x8_t v13 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v10.i8);
    int16x8_t v14 = (int16x8_t)vmovl_high_u8(v11);
    int16x8_t v15 = (int16x8_t)vmovl_high_u8((uint8x16_t)v10);
    uint64_t v16 = *a4;
    uint64_t v17 = a4[1];
    a4 += 2;
    int8x16_t v18 = a6[3];
    int8x16_t v19 = a6[2];
    int8x16_t v20 = a6[1];
    int8x16_t v21 = *a6;
    a6 += 4;
    v22.val[0] = *(int8x16_t *)(a2 + v16);
    v22.val[1] = *(int8x16_t *)(v8 + v16);
    v23.val[0] = *(int8x16_t *)(a2 + v17);
    v23.val[1] = *(int8x16_t *)(v8 + v17);
    *uint64_t result = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)vqtbl2q_s8(v22, v21), v12), vmulq_s16((int16x8_t)vqtbl2q_s8(v22, v20), v13)), vmulq_s16((int16x8_t)vqtbl2q_s8(v23, v19), v14), vmulq_s16((int16x8_t)vqtbl2q_s8(v23, v18), v15));
    uint64_t result = (int8x16_t *)((char *)result + a7);
  }
  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

_OWORD *DetileRow_neon(_OWORD *result, long long *a2, int a3, uint64_t a4)
{
  do
  {
    BOOL v4 = __OFSUB__(a3, 16);
    a3 -= 16;
    long long v5 = *a2;
    a2 = (long long *)((char *)a2 + a4);
    *result++ = v5;
  }
  while (!((a3 < 0) ^ v4 | (a3 == 0)));
  return result;
}

_OWORD *Detile2Rows_neon(_OWORD *result, _OWORD *a2, long long *a3, int a4, uint64_t a5)
{
  do
  {
    BOOL v5 = __OFSUB__(a4, 16);
    a4 -= 16;
    long long v6 = *a3;
    long long v7 = a3[1];
    a3 = (long long *)((char *)a3 + a5);
    *result++ = v6;
    *a2++ = v7;
  }
  while (!((a4 < 0) ^ v5 | (a4 == 0)));
  return result;
}

uint16x8_t *BilinearFilterV_swift_neon_h264(uint16x8_t *result, uint8x16_t *a2, uint8x16_t *a3, int a4, unsigned int a5)
{
  int8x16_t v5 = vdupq_n_s8(a5);
  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  uint8x16_t v7 = (uint8x16_t)vsubq_s8(v6, v5);
  int v8 = a4 & 0x3F;
  signed int v9 = a4 & 0xFFFFFFC0;
  if (!v9) {
    goto LABEL_6;
  }
  do
  {
    BOOL v10 = __OFSUB__(v9, 64);
    v9 -= 64;
    uint8x16_t v12 = *a2;
    uint8x16_t v13 = a2[1];
    uint8x16_t v11 = a2 + 2;
    uint8x16_t v15 = *a3;
    uint8x16_t v16 = a3[1];
    int16x8_t v14 = a3 + 2;
    uint8x16_t v17 = *v11;
    uint8x16_t v18 = v11[1];
    a2 = v11 + 2;
    uint8x16_t v19 = *v14;
    uint8x16_t v20 = v14[1];
    a3 = v14 + 2;
    *uint64_t result = vmlal_u8(vmull_u8(*(uint8x8_t *)v12.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v15.i8, *(uint8x8_t *)v5.i8);
    result[1] = vmlal_high_u8(vmull_high_u8(v12, v7), v15, (uint8x16_t)v5);
    int8x16_t v21 = result + 2;
    *int8x16_t v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v13.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v16.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v13, v7), v16, (uint8x16_t)v5);
    v21 += 2;
    *int8x16_t v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v17.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v19.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v17, v7), v19, (uint8x16_t)v5);
    v21 += 2;
    *int8x16_t v21 = vmlal_u8(vmull_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v20.i8, *(uint8x8_t *)v5.i8);
    v21[1] = vmlal_high_u8(vmull_high_u8(v18, v7), v20, (uint8x16_t)v5);
    uint64_t result = v21 + 2;
  }
  while (!((v9 < 0) ^ v10 | (v9 == 0)));
  if (v8)
  {
LABEL_6:
    do
    {
      BOOL v10 = __OFSUB__(v8, 16);
      v8 -= 16;
      uint8x16_t v22 = *a2++;
      uint8x16_t v23 = *a3++;
      *uint64_t result = vmlal_u8(vmull_u8(*(uint8x8_t *)v22.i8, *(uint8x8_t *)v7.i8), *(uint8x8_t *)v23.i8, *(uint8x8_t *)v5.i8);
      result[1] = vmlal_high_u8(vmull_high_u8(v22, v7), v23, (uint8x16_t)v5);
      result += 2;
    }
    while (!((v8 < 0) ^ v10 | (v8 == 0)));
  }
  return result;
}

int8x16_t *BilinearFilterH_swift_neon_h264(int8x16_t *result, uint64_t a2, int a3, unsigned int a4, int8x16_t *a5, uint64_t a6)
{
  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  unint64_t v7 = 0;
  uint64_t v8 = 2 * a4;
  uint64_t v9 = 3 * a4;
  uint64_t v10 = 4 * a4;
  do
  {
    BOOL v11 = __OFSUB__(a3, 16);
    a3 -= 16;
    int8x16_t v12 = *a5++;
    int8x16_t v13 = vsubq_s8(v6, v12);
    uint8x16_t v14 = (uint8x16_t)vzip1q_s8(v13, v12);
    uint8x16_t v15 = (uint8x16_t)vzip2q_s8(v13, v12);
    uint8x16_t v16 = (const float *)(((v7 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint8x16_t v17 = (__int32 *)((((v7 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint8x16_t v18 = (__int32 *)((((v7 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint8x16_t v19 = (__int32 *)((((v7 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    unint64_t v20 = v7 + v10;
    v21.i32[0] = vld1q_dup_f32(v16).u32[0];
    v21.i32[1] = *v17;
    v21.i32[2] = *v18;
    v21.i32[3] = *v19;
    uint8x16_t v22 = (const float *)(((v20 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint8x16_t v23 = (__int32 *)((((v20 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    int8x16_t v24 = (__int32 *)((((v20 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    int8x16_t v25 = (__int32 *)((((v20 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    unint64_t v26 = v20 + v10;
    v27.i32[0] = vld1q_dup_f32(v22).u32[0];
    v27.i32[1] = *v23;
    v27.i32[2] = *v24;
    v27.i32[3] = *v25;
    int8x8x2_t v28 = (const float *)(((v26 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    int16x8_t v29 = (__int32 *)((((v26 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    int16x8_t v30 = (__int32 *)((((v26 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    int16x8_t v31 = (__int32 *)((((v26 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    unint64_t v32 = v26 + v10;
    v33.i32[0] = vld1q_dup_f32(v28).u32[0];
    v33.i32[1] = *v29;
    v33.i32[2] = *v30;
    v33.i32[3] = *v31;
    unsigned int v34 = (const float *)(((v32 >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint64_t v35 = (__int32 *)((((v32 + a4) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    unsigned int v36 = (__int32 *)((((v32 + v8) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    uint64_t v37 = (__int32 *)((((v32 + v9) >> 15) & 0xFFFFFFFFFFFFFFFELL) + a2);
    unint64_t v7 = v32 + v10;
    v38.i32[0] = vld1q_dup_f32(v34).u32[0];
    v38.i32[1] = *v35;
    v38.i32[2] = *v36;
    v38.i32[3] = *v37;
    *uint64_t result = vrshrn_high_n_s16(vrshrn_n_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v14.i8), v21), vmulq_s16((int16x8_t)vmovl_high_u8(v14), v27)), 8uLL), vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v15.i8), v33), vmulq_s16((int16x8_t)vmovl_high_u8(v15), v38)), 8uLL);
    uint64_t result = (int8x16_t *)((char *)result + a6);
  }
  while (!((a3 < 0) ^ v11 | (a3 == 0)));
  return result;
}

int8x16_t *BilinearFilterH_swift_chroma_neon_h264(int8x16_t *result, uint64_t a2, int a3, unsigned int a4, int8x16_t *a5, uint64_t a6)
{
  v6.i64[0] = 0x1010101010101010;
  v6.i64[1] = 0x1010101010101010;
  unint64_t v7 = 0;
  uint64_t v8 = 2 * a4;
  uint64_t v9 = 3 * a4;
  uint64_t v10 = 4 * a4;
  int v11 = a3 - 8;
  if (!v11) {
    goto LABEL_5;
  }
  do
  {
    BOOL v12 = __OFSUB__(v11, 16);
    v11 -= 16;
    int8x16_t v13 = (const float *)(((v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x16_t v14 = (__int32 *)((((v7 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x16_t v15 = (__int32 *)((((v7 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x16_t v16 = (__int32 *)((((v7 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v17 = v7 + v10;
    float32x4x2_t v49 = vld2q_dup_f32(v13);
    v49.val[0].i32[1] = *v14;
    v49.val[1].i32[1] = v14[1];
    v49.val[0].i32[2] = *v15;
    v49.val[1].i32[2] = v15[1];
    v49.val[0].i32[3] = *v16;
    v49.val[1].i32[3] = v16[1];
    uint8x16_t v18 = (const float *)(((v17 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x16_t v19 = (__int32 *)((((v17 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v20 = (__int32 *)((((v17 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    int16x8_t v21 = (__int32 *)((((v17 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v22 = v17 + v10;
    float32x4x2_t v51 = vld2q_dup_f32(v18);
    v51.val[0].i32[1] = *v19;
    v51.val[1].i32[1] = v19[1];
    v51.val[0].i32[2] = *v20;
    v51.val[1].i32[2] = v20[1];
    v51.val[0].i32[3] = *v21;
    v51.val[1].i32[3] = v21[1];
    int8x16_t v23 = *a5++;
    int8x16_t v24 = vzip1q_s8(v23, v23);
    int8x16_t v25 = vzip2q_s8(v23, v23);
    uint8x16_t v26 = (uint8x16_t)vsubq_s8(v6, v24);
    uint8x16_t v27 = (uint8x16_t)vsubq_s8(v6, v25);
    int8x8x2_t v28 = (const float *)(((v22 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    int16x8_t v29 = (__int32 *)((((v22 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    int16x8_t v30 = (__int32 *)((((v22 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    int16x8_t v31 = (__int32 *)((((v22 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v32 = v22 + v10;
    float32x4x2_t v53 = vld2q_dup_f32(v28);
    v53.val[0].i32[1] = *v29;
    v53.val[1].i32[1] = v29[1];
    v53.val[0].i32[2] = *v30;
    v53.val[1].i32[2] = v30[1];
    v53.val[0].i32[3] = *v31;
    v53.val[1].i32[3] = v31[1];
    int16x8_t v33 = (const float *)(((v32 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unsigned int v34 = (__int32 *)((((v32 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint64_t v35 = (__int32 *)((((v32 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unsigned int v36 = (__int32 *)((((v32 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v7 = v32 + v10;
    float32x4x2_t v54 = vld2q_dup_f32(v33);
    v54.val[0].i32[1] = *v34;
    v54.val[1].i32[1] = v34[1];
    v54.val[0].i32[2] = *v35;
    v54.val[1].i32[2] = v35[1];
    v54.val[0].i32[3] = *v36;
    v54.val[1].i32[3] = v36[1];
    *uint64_t result = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v49.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v26.i8)), vmulq_s16((int16x8_t)v49.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v24.i8))), vmulq_s16((int16x8_t)v51.val[0], (int16x8_t)vmovl_high_u8(v26)), vmulq_s16((int16x8_t)v51.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v24)));
    uint64_t v37 = (int8x16_t *)((char *)result + a6);
    *uint64_t v37 = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v53.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v27.i8)), vmulq_s16((int16x8_t)v53.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v25.i8))), vmulq_s16((int16x8_t)v54.val[0], (int16x8_t)vmovl_high_u8(v27)), vmulq_s16((int16x8_t)v54.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v25)));
    uint64_t result = (int8x16_t *)((char *)v37 + a6);
  }
  while (!((v11 < 0) ^ v12 | (v11 == 0)));
  if (v11 < 0 == v12)
  {
LABEL_5:
    int16x8_t v38 = (const float *)(((v7 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unsigned int v39 = (__int32 *)((((v7 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x16_t v40 = (__int32 *)((((v7 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x8_t v41 = (__int32 *)((((v7 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    unint64_t v42 = v7 + v10;
    float32x4x2_t v50 = vld2q_dup_f32(v38);
    v50.val[0].i32[1] = *v39;
    v50.val[1].i32[1] = v39[1];
    v50.val[0].i32[2] = *v40;
    v50.val[1].i32[2] = v40[1];
    v50.val[0].i32[3] = *v41;
    v50.val[1].i32[3] = v41[1];
    uint8x8_t v43 = (const float *)(((v42 >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    int16x8_t v44 = (__int32 *)((((v42 + a4) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x8_t v45 = (__int32 *)((((v42 + v8) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    uint8x8_t v46 = (__int32 *)((((v42 + v9) >> 14) & 0xFFFFFFFFFFFFFFFCLL) + a2);
    float32x4x2_t v52 = vld2q_dup_f32(v43);
    v52.val[0].i32[1] = *v44;
    v52.val[1].i32[1] = v44[1];
    v52.val[0].i32[2] = *v45;
    v52.val[1].i32[2] = v45[1];
    v52.val[0].i32[3] = *v46;
    v52.val[1].i32[3] = v46[1];
    int8x16_t v47 = vzip1q_s8(*a5, *a5);
    uint8x16_t v48 = (uint8x16_t)vsubq_s8(v6, v47);
    *uint64_t result = vraddhn_high_s16(vraddhn_s16(vmulq_s16((int16x8_t)v50.val[0], (int16x8_t)vmovl_u8(*(uint8x8_t *)v48.i8)), vmulq_s16((int16x8_t)v50.val[1], (int16x8_t)vmovl_u8(*(uint8x8_t *)v47.i8))), vmulq_s16((int16x8_t)v52.val[0], (int16x8_t)vmovl_high_u8(v48)), vmulq_s16((int16x8_t)v52.val[1], (int16x8_t)vmovl_high_u8((uint8x16_t)v47)));
    return (int8x16_t *)((char *)result + a6);
  }
  return result;
}

int8x8_t *BilinearFilterH_vperm2_neon64_h264(int8x8_t *result, uint64_t a2, int a3, unsigned int *a4, int8x16_t *a5, int8x16_t *a6, uint64_t a7)
{
  v7.i64[0] = 0x1010101010101010;
  v7.i64[1] = 0x1010101010101010;
  do
  {
    BOOL v8 = __OFSUB__(a3, 16);
    a3 -= 16;
    int8x16_t v9 = *a5++;
    int8x16_t v10 = vsubq_s8(v7, v9);
    uint8x16_t v11 = (uint8x16_t)vzip1q_s8(v10, v9);
    uint8x16_t v12 = (uint8x16_t)vzip2q_s8(v10, v9);
    uint64_t v13 = a4[2];
    uint64_t v14 = a4[3];
    uint64_t v15 = *a4;
    uint64_t v16 = a4[1];
    a4 += 4;
    int8x16_t v17 = a6[2];
    int8x16_t v18 = a6[3];
    int8x16_t v19 = *a6;
    int8x16_t v20 = a6[1];
    a6 += 4;
    int8x8_t v21 = vrshrn_n_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v12.i8), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v13), v17)), vmulq_s16((int16x8_t)vmovl_high_u8(v12), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v14), v18))), 8uLL);
    *uint64_t result = vrshrn_n_s16(vpaddq_s16(vmulq_s16((int16x8_t)vmovl_u8(*(uint8x8_t *)v11.i8), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v15), v19)), vmulq_s16((int16x8_t)vmovl_high_u8(v11), (int16x8_t)vqtbl1q_s8(*(int8x16_t *)(a2 + v16), v20))), 8uLL);
    result[1] = v21;
    uint64_t result = (int8x8_t *)((char *)result + a7);
  }
  while (!((a3 < 0) ^ v8 | (a3 == 0)));
  return result;
}

int8x8_t *BilinearFilterH_chroma_vperm2_neon64_h264(int8x8_t *result, uint64_t a2, int a3, unsigned int *a4, int8x16_t *a5, int8x16_t *a6, uint64_t a7)
{
  v7.i64[0] = 0x1010101010101010;
  v7.i64[1] = 0x1010101010101010;
  uint64_t v8 = a2 + 16;
  do
  {
    BOOL v9 = __OFSUB__(a3, 8);
    a3 -= 8;
    int8x16_t v10 = *a5++;
    uint8x16_t v11 = (uint8x16_t)vsubq_s8(v7, v10);
    int16x8_t v12 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v11.i8);
    int16x8_t v13 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v10.i8);
    int16x8_t v14 = (int16x8_t)vmovl_high_u8(v11);
    int16x8_t v15 = (int16x8_t)vmovl_high_u8((uint8x16_t)v10);
    uint64_t v16 = *a4;
    uint64_t v17 = a4[1];
    a4 += 2;
    int8x16_t v18 = a6[2];
    int8x16_t v19 = a6[3];
    int8x16_t v20 = *a6;
    int8x16_t v21 = a6[1];
    a6 += 4;
    v22.val[0] = *(int8x16_t *)(a2 + v16);
    v22.val[1] = *(int8x16_t *)(v8 + v16);
    v23.val[0] = *(int8x16_t *)(a2 + v17);
    v23.val[1] = *(int8x16_t *)(v8 + v17);
    *uint64_t result = vraddhn_s16(vmulq_s16((int16x8_t)vqtbl2q_s8(v22, v20), v12), vmulq_s16((int16x8_t)vqtbl2q_s8(v22, v21), v13));
    result[1] = vraddhn_s16(vmulq_s16((int16x8_t)vqtbl2q_s8(v23, v18), v14), vmulq_s16((int16x8_t)vqtbl2q_s8(v23, v19), v15));
    uint64_t result = (int8x8_t *)((char *)result + a7);
  }
  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

_OWORD *DetileRow_neon_h264(_OWORD *result, long long *a2, int a3, uint64_t a4)
{
  do
  {
    BOOL v4 = __OFSUB__(a3, 16);
    a3 -= 16;
    long long v5 = *a2;
    a2 = (long long *)((char *)a2 + a4);
    *result++ = v5;
  }
  while (!((a3 < 0) ^ v4 | (a3 == 0)));
  return result;
}

_OWORD *Detile2Rows_neon_h264(_OWORD *result, _OWORD *a2, long long *a3, int a4, uint64_t a5)
{
  do
  {
    BOOL v5 = __OFSUB__(a4, 16);
    a4 -= 16;
    long long v6 = *a3;
    long long v7 = a3[1];
    a3 = (long long *)((char *)a3 + a5);
    *result++ = v6;
    *a2++ = v7;
  }
  while (!((a4 < 0) ^ v5 | (a4 == 0)));
  return result;
}

__n128 Detile4Rows_neon_h264(__n128 **a1, __n128 *a2, int a3, uint64_t a4)
{
  BOOL v4 = *a1;
  BOOL v5 = a1[1];
  long long v6 = a1[2];
  long long v7 = a1[3];
  if ((a3 & 0xF) != 0)
  {
    a3 -= 16;
    __n128 v8 = *a2;
    __n128 v9 = a2[1];
    __n128 v10 = a2[2];
    __n128 v11 = a2[3];
    a2 = (__n128 *)((char *)a2 + a4);
    *v4++ = v8;
    *v5++ = v9;
    *v6++ = v10;
    *v7++ = v11;
  }
  do
  {
    BOOL v12 = __OFSUB__(a3, 32);
    a3 -= 32;
    __n128 result = *a2;
    __n128 v15 = a2[1];
    __n128 v16 = a2[2];
    __n128 v17 = a2[3];
    int16x8_t v13 = (__n128 *)((char *)a2 + a4);
    __n128 v18 = *v13;
    __n128 v19 = v13[1];
    __n128 v20 = v13[2];
    __n128 v21 = v13[3];
    a2 = (__n128 *)((char *)v13 + a4);
    *BOOL v4 = result;
    v4[1] = v18;
    v4 += 2;
    *BOOL v5 = v15;
    v5[1] = v19;
    v5 += 2;
    __n128 *v6 = v16;
    v6[1] = v20;
    v6 += 2;
    *long long v7 = v17;
    v7[1] = v21;
    v7 += 2;
  }
  while (!((a3 < 0) ^ v12 | (a3 == 0)));
  return result;
}

void sub_1BB9BE110(void *a1)
{
}

const void **sub_1BB9BE124(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_1BB9BE158(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_1BB9BE18C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_1BB9BE1C0(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_1BB9BE1F4(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_1BB9BE228(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_1BB9BE25C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1BB9BE290(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (qword_1EC027190 != -1) {
    dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
  }
  int v8 = dword_1EC02719C;
  int v9 = *a2;
  if ((*a2 & 0xC) == 0)
  {
    if (a3 == a4)
    {
      *a2 = v9 | 4;
      if (a3 > 96)
      {
        *(_DWORD *)(a1 + 32) = v9 | 4;
        *(unsigned char *)(a1 + 124) = v8 > 12;
        goto LABEL_25;
      }
      int v10 = 6;
    }
    else
    {
      int v10 = 8;
    }
    v9 |= v10;
    *a2 = v9;
  }
  BOOL v12 = a3 > 96 && v8 > 12;
  *(unsigned char *)(a1 + 124) = v12;
  *(_DWORD *)(a1 + 32) = v9;
  if ((v9 & 4) == 0)
  {
    if ((v9 & 8) != 0 && sub_1BBA401B4())
    {
      if (qword_1EC027190 != -1) {
        dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
      }
      if (dword_1EC02719C >= 13 && _os_feature_enabled_impl()) {
        operator new[]();
      }
    }
    return 4294954386;
  }
  if (a3 < 97) {
    goto LABEL_29;
  }
LABEL_25:
  if ((a3 == 480 || a3 == 320) && dword_1EC02719C > 12 || sub_1BBA401B4()) {
LABEL_29:
  }
    operator new[]();
  return 4294954386;
}

uint64_t sub_1BB9BEA18(uint64_t a1, CVPixelBufferRef pixelBuffer)
{
  uint64_t result = CVPixelBufferLockBaseAddress(pixelBuffer, 0);
  if (!result)
  {
    int v5 = rand();
    if (v5 <= 0) {
      int v6 = -(-v5 & 0xFFF);
    }
    else {
      int v6 = v5 & 0xFFF;
    }
    long long v7 = *(const float **)(a1 + 40);
    int BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
    BaseAddressOfPlane = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
    uint64_t v10 = *(void *)(a1 + 8);
    __n128 v11 = *(float **)(v10 + 208);
    vDSP_Length v12 = *(unsigned int *)(v10 + 288);
    int v13 = *(_DWORD *)(v10 + 296);
    float __B = 0.0;
    float __C = 255.0;
    pixelBuffera = pixelBuffer;
    if ((*(unsigned char *)(a1 + 32) & 2) != 0)
    {
      if (v13)
      {
        int v14 = 0;
        do
        {
          if (v12)
          {
            for (uint64_t i = 0; i != v12; ++i)
            {
              if (v6 + (int)i <= 0) {
                int v16 = -(-(v6 + i) & 0xFFF);
              }
              else {
                int v16 = (v6 + i) & 0xFFF;
              }
              float v17 = (float)(v7[i] * 0.3) + flt_1BBB70C68[v16] * 0.699999988;
              v7[i] = v17;
            }
            v6 += i;
          }
          vDSP_vadd(v11, 1, v7, 1, v11, 1, v12);
          vDSP_vclip(v11, 1, &__B, &__C, v11, 1, v12);
          vDSP_vfixru8(v11, 1, BaseAddressOfPlane, 1, v12);
          ++v14;
          v7 += v12;
          v11 += v12;
          BaseAddressOfPlane += BytesPerRowOfPlane;
        }
        while (v14 != v13);
      }
    }
    else
    {
      for (; v13; --v13)
      {
        vDSP_vfixru8(v11, 1, BaseAddressOfPlane, 1, v12);
        BaseAddressOfPlane += BytesPerRowOfPlane;
        v11 += v12;
      }
    }
    uint64_t v18 = *(void *)(a1 + 8);
    __n128 v19 = *(float **)(v18 + 376);
    uint64_t v20 = *(void *)(v18 + 456);
    unsigned int v21 = *(_DWORD *)(v18 + 464);
    int v22 = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
    int8x16x2_t v23 = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
    if ((*(unsigned char *)(a1 + 32) & 2) != 0)
    {
      if (v21)
      {
        unsigned int v25 = 0;
        do
        {
          if (v20)
          {
            uint64_t v26 = 0;
            do
            {
              if (v6 + (int)v26 <= 0) {
                int v27 = -(-(v6 + v26) & 0xFFF);
              }
              else {
                int v27 = (v6 + v26) & 0xFFF;
              }
              float v28 = (float)(v7[v26] * 0.3) + flt_1BBB70C68[v27] * 0.699999988;
              v7[v26++] = v28;
            }
            while (v20 != v26);
            v6 += v26;
          }
          vDSP_vadd(v19, 1, v7, 1, v19, 1, v20);
          vDSP_vclip(v19, 1, &__B, &__C, v19, 1, v20);
          vDSP_vfixru8(v19, 1, v23, 1, v20);
          v25 += 2;
          v7 += v20;
          v19 += (2 * v20);
          v23 += v22;
        }
        while (v25 < v21);
      }
    }
    else if (v21)
    {
      for (unsigned int j = 0; j < v21; j += 2)
      {
        vDSP_vfixru8(v19, 1, v23, 1, v20);
        v23 += v22;
        v19 += 2 * (v20 & 0x7FFFFFFF);
      }
    }
    return CVPixelBufferUnlockBaseAddress(pixelBuffera, 0);
  }
  return result;
}

void VCPRateControlSessionInvalidate(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 16);
    if (v1)
    {
      if (!*(unsigned char *)(v1 + 232))
      {
        *(unsigned char *)(v1 + 232) = 1;
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v2 = *(void *)(v1 + 2536);
          int v3 = *(_DWORD *)(v1 + 212);
          int v4 = *(_DWORD *)(v1 + 216);
          int v5 = 134218496;
          uint64_t v6 = v2;
          __int16 v7 = 1024;
          int v8 = v3;
          __int16 v9 = 1024;
          int v10 = v4;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): VCPRateControlSession is invalidated\n", (uint8_t *)&v5, 0x18u);
        }
      }
    }
  }
}

uint64_t sub_1BB9BEE54()
{
  qword_1E9F814D8 = 0;
  unk_1E9F814E0 = "VCPRateControlSession";
  qword_1E9F814E8 = 0;
  unk_1E9F814F0 = 0;
  qword_1E9F814F8 = (uint64_t)sub_1BB9BEEA8;
  unk_1E9F81500 = 0u;
  unk_1E9F81510 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1E9F814C0 = result;
  return result;
}

void sub_1BB9BEEA8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 16);
    VCPRateControlSessionInvalidate(a1);
    if (v2)
    {
      sub_1BB9C740C(v2);
      std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 2480));
      std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 2432));
      std::mutex::~mutex((std::mutex *)(v2 + 2368));
      std::mutex::~mutex((std::mutex *)(v2 + 2304));
      MEMORY[0x1C18605E0](v2, 0x10F0C40EEABCC0CLL);
      *(void *)(a1 + 16) = 0;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v3 = 0;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession is finalized\n", v3, 2u);
      }
    }
  }
}

CFBooleanRef sub_1BB9BEF74(const __CFDictionary *a1, const void *a2)
{
  CFBooleanRef result = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
  if (result) {
    return (const __CFBoolean *)(CFBooleanGetValue(result) != 0);
  }
  return result;
}

const void **sub_1BB9BEF9C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

CFDictionaryRef sub_1BB9BEFD0(uint64_t ****a1)
{
  CFDictionaryRef result = sub_1BB9C795C(****a1);
  qword_1E9F814D0 = (uint64_t)result;
  return result;
}

uint64_t sub_1BB9BF000(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    std::__shared_mutex_base::unlock(*(std::__shared_mutex_base **)a1);
  }
  return a1;
}

uint64_t VCPRateControlSessionCopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFNumberRef *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4)
    {
      if (*(unsigned char *)(v4 + 232))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315138;
          uint64_t v17 = v4 + 256;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", buf, 0xCu);
        }
        return 4294954393;
      }
      else if (*(unsigned char *)(v4 + 244))
      {
        uint64_t v13 = v4 + 2368;
        char v14 = 1;
        std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v4 + 2368));
        CFTypeRef v15 = a2;
        if (sub_1BB9C6924(*(void **)(v4 + 2544), &v15))
        {
          if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44920]))
          {
            int v8 = *(const void **)(v4 + 24);
            uint64_t v5 = 0;
            if (v8) {
              *a4 = (CFNumberRef)CFRetain(v8);
            }
          }
          else
          {
            uint64_t v5 = sub_1BB9C7CA8(v4, a2, a4);
          }
        }
        else
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v9 = *(void *)(v4 + 2536);
            int v10 = *(_DWORD *)(v4 + 212);
            int v11 = *(_DWORD *)(v4 + 216);
            *(_DWORD *)buf = 134218496;
            uint64_t v17 = v9;
            __int16 v18 = 1024;
            int v19 = v10;
            __int16 v20 = 1024;
            int v21 = v11;
            _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): unrecognised property key", buf, 0x18u);
          }
          uint64_t v5 = 4294966630;
        }
        sub_1BB9BF2B4((uint64_t)&v13);
      }
      else
      {
        return 4294967278;
      }
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Empty session storage\n", buf, 2u);
      }
      return 4294954392;
    }
  }
  else
  {
    uint64_t v5 = 0;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "NULL session\n", buf, 2u);
      return 0;
    }
  }
  return v5;
}

void sub_1BB9BF2A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9BF2B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9BF2B4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    std::__shared_mutex_base::unlock_shared(*(std::__shared_mutex_base **)a1);
  }
  return a1;
}

uint64_t sub_1BB9BF2EC(uint64_t a1, int a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  int IntegerCodePointForString = CVColorPrimariesGetIntegerCodePointForString(*(CFStringRef *)(a1 + 104));
  snprintf(__str, 0x20uLL, "%d", IntegerCodePointForString);
  int v5 = CVTransferFunctionGetIntegerCodePointForString(*(CFStringRef *)(a1 + 112));
  snprintf(v53, 0x20uLL, "%d", v5);
  int v6 = CVYCbCrMatrixGetIntegerCodePointForString(*(CFStringRef *)(a1 + 120));
  snprintf(v52, 0x20uLL, "%d", v6);
  bzero(v55, 0x468uLL);
  v55[12] = *(_DWORD *)(a1 + 192);
  int v7 = *(_DWORD *)(a1 + 76);
  uint64_t v58 = *(void *)(a1 + 40);
  __int16 v57 = *(_DWORD *)(a1 + 216);
  int v8 = *(_DWORD *)(a1 + 208);
  __int16 v56 = *(_DWORD *)(a1 + 212);
  BOOL v9 = v8 == 1718908520 || v8 == 1752589105;
  int v63 = 1;
  int v10 = !v9;
  int v59 = v7;
  int v60 = v10;
  char v62 = 1;
  int v61 = 2;
  int v11 = *(_DWORD **)(a1 + 2296);
  if (!v11)
  {
    vDSP_Length v12 = operator new(0x33F8uLL, MEMORY[0x1E4FBA2D0]);
    if (!v12)
    {
      *(void *)(a1 + 2296) = 0;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to allocate sequence enc\n", buf, 2u);
      }
      return 4294954392;
    }
    int v11 = v12;
    sub_1BBA577F8((uint64_t)v12);
    *(void *)(a1 + 2296) = v11;
  }
  v11[250] = a2;
  if (a2 > 1278226735)
  {
    if (a2 > 2016687155)
    {
      if (a2 == 2016687156 || a2 == 2019963956) {
        goto LABEL_23;
      }
      int v13 = 2019963440;
    }
    else
    {
      if (a2 == 1278226736 || a2 == 1496395842) {
        goto LABEL_23;
      }
      int v13 = 2016686640;
    }
    if (a2 == v13)
    {
LABEL_23:
      int v15 = 10;
      int v14 = 1;
      goto LABEL_28;
    }
LABEL_27:
    int v14 = 0;
    int v15 = 0;
    goto LABEL_28;
  }
  int v14 = 0;
  int v15 = 8;
  if (a2 <= 875836517)
  {
    if (a2 == 875704422) {
      goto LABEL_28;
    }
    int v16 = 875704438;
    goto LABEL_26;
  }
  if (a2 != 875836518 && a2 != 875836534)
  {
    int v16 = 1278226488;
LABEL_26:
    if (a2 == v16) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
LABEL_28:
  v11[251] = v15;
  int v17 = CVYCbCrMatrixGetIntegerCodePointForString(*(CFStringRef *)(a1 + 120));
  uint64_t v18 = *(void *)(a1 + 2296);
  if (v17 != 9 && *(_DWORD *)(v18 + 1004) == 10) {
    int v17 = 248;
  }
  *(_DWORD *)(v18 + 1008) = v17;
  int v20 = *(_DWORD *)(a1 + 16);
  if (v20) {
    sub_1BBA5ED34(v18, 0x8ADD349E618BA10ELL, v20);
  }
  int v21 = *(_DWORD *)(a1 + 20);
  if (v21) {
    sub_1BBA5ED34(*(void *)(a1 + 2296), 0xE8DDC90A9D7C709DLL, v21);
  }
  int v22 = *(_DWORD *)(a1 + 100);
  int v23 = v22 - 1;
  if (v22 >= 1)
  {
    if (v22 <= 2)
    {
      if (*(unsigned char *)(a1 + 128))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v24 = *(void *)(a1 + 2536);
          int v25 = *(_DWORD *)(a1 + 212);
          int v26 = *(_DWORD *)(a1 + 216);
          *(_DWORD *)buf = 134218752;
          uint64_t v44 = v24;
          __int16 v45 = 1024;
          int v46 = v25;
          __int16 v47 = 1024;
          int v48 = v26;
          __int16 v49 = 1024;
          LODWORD(v50) = v23;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): Number of LTR %d is too small. Disable LTR\n", buf, 0x1Eu);
        }
        sub_1BB9C65F4(a1, (const __CFString *)*MEMORY[0x1E4F448B0], (const __CFString *)*MEMORY[0x1E4F1CFC8]);
        int v23 = 0;
        int v22 = *(_DWORD *)(a1 + 100);
      }
      else
      {
        int v23 = 0;
      }
    }
    snprintf(__s, 0x20uLL, "%d:%d:%d:%d", v22 - v23, v23, 1, 1);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v28 = *(void *)(a1 + 2536);
      int v29 = *(_DWORD *)(a1 + 212);
      int v30 = *(_DWORD *)(a1 + 216);
      *(_DWORD *)buf = 134218754;
      uint64_t v44 = v28;
      __int16 v45 = 1024;
      int v46 = v29;
      __int16 v47 = 1024;
      int v48 = v30;
      __int16 v49 = 2080;
      float32x4x2_t v50 = __s;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): setting reference %s\n", buf, 0x22u);
    }
    uint64_t v31 = *(void *)(a1 + 2296);
    buf[0] = 0;
    sub_1BBA40F94(*(void *)(v31 + 3192), 0x89E9C01960F4C582, __s, 0, (uint64_t)buf);
  }
  if (v14)
  {
    uint64_t v32 = *(void *)(a1 + 2296);
    buf[0] = 0;
    sub_1BBA40F94(*(void *)(v32 + 3192), 0x8C49EF6ED9F28EA0, "10", 0, (uint64_t)buf);
  }
  if (*(unsigned char *)(a1 + 128)) {
    sub_1BBA5ED34(*(void *)(a1 + 2296), 0xBE39025BC18BBD08, 1);
  }
  if (sub_1BBA5EABC(*(void *)(a1 + 2296), (uint64_t)v55))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v44 = a1 + 256;
      int16x8_t v33 = MEMORY[0x1E4F14500];
      unsigned int v34 = "%s: ParseCompressParams failed\n";
LABEL_70:
      _os_log_error_impl(&dword_1BB9B9000, v33, OS_LOG_TYPE_ERROR, v34, buf, 0xCu);
      return 3;
    }
    return 3;
  }
  if (a2 == 875704422 || a2 == 2019963440 || a2 == 875836518)
  {
    uint64_t v35 = *(void *)(a1 + 2296);
    buf[0] = 0;
    sub_1BBA40F94(*(void *)(v35 + 3192), 0x3BEB44829B7A4FABLL, "true", 0, (uint64_t)buf);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v36 = *(void *)(a1 + 2536);
      int v37 = *(_DWORD *)(a1 + 212);
      int v38 = *(_DWORD *)(a1 + 216);
      *(_DWORD *)buf = 134218496;
      uint64_t v44 = v36;
      __int16 v45 = 1024;
      int v46 = v37;
      __int16 v47 = 1024;
      int v48 = v38;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): get full range pixel buffer\n", buf, 0x18u);
    }
  }
  uint64_t v39 = *(void *)(a1 + 2296);
  buf[0] = 0;
  sub_1BBA40F94(*(void *)(v39 + 3192), 0x9FFE593DC10E7CC4, __str, 0, (uint64_t)buf);
  uint64_t v40 = *(void *)(a1 + 2296);
  buf[0] = 0;
  sub_1BBA40F94(*(void *)(v40 + 3192), 0x2660BA38B42FDFB5, v53, 0, (uint64_t)buf);
  uint64_t v41 = *(void *)(a1 + 2296);
  buf[0] = 0;
  sub_1BBA40F94(*(void *)(v41 + 3192), 0xE961BACE8A163BCBLL, v52, 0, (uint64_t)buf);
  sub_1BBA5ED34(*(void *)(a1 + 2296), 0xDFF2FE5D542EA31BLL, 0);
  sub_1BBA5ED34(*(void *)(a1 + 2296), 0x70A12C1952D5628BLL, 0);
  sub_1BBA5ED34(*(void *)(a1 + 2296), 0xF890AF2C24C4A032, *(_DWORD *)(a1 + 32));
  if (*(unsigned char *)(a1 + 244))
  {
    sub_1BBA5ED34(*(void *)(a1 + 2296), 0x3B036542BE80F4D6, *(_DWORD *)(a1 + 236));
    sub_1BBA5ED34(*(void *)(a1 + 2296), 0xDE9D01B25B989E98, *(_DWORD *)(a1 + 240));
  }
  unint64_t v42 = *(void **)(a1 + 2296);
  v42[140] = sub_1BB9BFBD4;
  v42[141] = sub_1BB9BFB98;
  v42[142] = a1;
  uint64_t result = sub_1BBA5EED8(v42);
  if (result)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v44 = a1 + 256;
      int16x8_t v33 = MEMORY[0x1E4F14500];
      unsigned int v34 = "%s: Encoder initialization failed\n";
      goto LABEL_70;
    }
    return 3;
  }
  return result;
}

void sub_1BB9BFA8C(_Unwind_Exception *a1)
{
  MEMORY[0x1C18605C0](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

const void **sub_1BB9BFAB0(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v8 = v5;
  if (v5) {
    CFDictionarySetValue(a1, a2, v5);
  }
  return sub_1BB9BE1F4((const void **)&v8);
}

void sub_1BB9BFB10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9BE1F4((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1BB9BFB24(__CFDictionary *a1, const void *a2, double a3)
{
  double v7 = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberDoubleType, &v7);
  CFNumberRef v8 = v5;
  if (v5) {
    CFDictionarySetValue(a1, a2, v5);
  }
  return sub_1BB9BE1F4((const void **)&v8);
}

void sub_1BB9BFB84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9BE1F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9BFB98(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(uint64_t (**)(uint64_t, long long *))(a1 + 2280);
  uint64_t v3 = *(void *)(a1 + 2288);
  long long v5 = *a2;
  uint64_t v6 = *((void *)a2 + 2);
  return v2(v3, &v5);
}

uint64_t sub_1BB9BFBD4(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  long long v30 = *MEMORY[0x1E4F1F9F8];
  uint64_t v31 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  long long v28 = v30;
  uint64_t v29 = v31;
  if (!a1)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
LABEL_11:
      uint64_t v18 = *(uint64_t (**)(uint64_t, void, uint64_t, long long *, long long *, void, void, uint64_t *, int))(a1 + 2272);
      uint64_t v19 = *(void *)(a1 + 2288);
      long long v22 = v30;
      uint64_t v23 = v31;
      long long v20 = v28;
      uint64_t v21 = v29;
      return v18(v19, 0, a4, &v22, &v20, 0, 0, a2, 1);
    }
    *(_WORD *)buf = 0;
    vDSP_Length v12 = MEMORY[0x1E4F14500];
    int v13 = "Invalid rate control session\n";
    uint32_t v14 = 2;
LABEL_14:
    _os_log_error_impl(&dword_1BB9B9000, v12, OS_LOG_TYPE_ERROR, v13, buf, v14);
    goto LABEL_11;
  }
  if (!a2)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v33 = a1 + 256;
    vDSP_Length v12 = MEMORY[0x1E4F14500];
    int v13 = "%s: Invalid frame context\n";
    uint32_t v14 = 12;
    goto LABEL_14;
  }
  int v10 = (long long *)((char *)a2 + 36);
  uint64_t v9 = *a2;
  BOOL v11 = !a4 || (a2[1] & 2) != 0;
  a2[8] = a3;
  int v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, long long *, long long *, uint64_t, uint64_t, uint64_t *, BOOL))(a1 + 2272);
  uint64_t v16 = *(void *)(a1 + 2288);
  long long v26 = *(_OWORD *)((char *)a2 + 12);
  uint64_t v27 = *(uint64_t *)((char *)a2 + 28);
  long long v24 = *v10;
  uint64_t v25 = *(uint64_t *)((char *)a2 + 52);
  return v15(v16, v9, a4, &v26, &v24, a5, a6, a2, v11);
}

uint64_t VCPRateControlSessionBeforeEncodeFrame(uint64_t a1, uint64_t a2, __CVBuffer *a3, long long *a4, long long *a5, const __CFDictionary *a6, unsigned int *a7)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    if (v7)
    {
      if (a7)
      {
        if (*(unsigned char *)(v7 + 232))
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v7 + 256;
            _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", buf, 0xCu);
          }
          return 4294954393;
        }
        if (!*(unsigned char *)(v7 + 244)) {
          return 4294967278;
        }
        std::mutex::lock((std::mutex *)(v7 + 2304));
        uint64_t v54 = v7 + 2368;
        char v55 = 1;
        uint8x8_t v43 = (std::mutex *)(v7 + 2304);
        std::__shared_mutex_base::lock((std::__shared_mutex_base *)(v7 + 2368));
        uint64_t v15 = *(void *)(v7 + 2256);
        if (v15) {
          sub_1BBAC8868(v15, (uint64_t *)"input_frames", 1.0);
        }
        if (a6) {
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a6);
        }
        else {
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        }
        uint64_t v53 = (uint64_t)MutableCopy;
        int v17 = operator new(0x70uLL, MEMORY[0x1E4FBA2D0]);
        if (!v17)
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315138;
            *(void *)&uint8_t buf[4] = v7 + 256;
            _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: Failed to allocate frame context\n", buf, 0xCu);
          }
          uint64_t v9 = 4294954392;
          goto LABEL_82;
        }
        uint64_t v18 = (uint64_t)v17;
        v17[9] = 0;
        uint64_t v19 = (uint64_t)(v17 + 9);
        *((unsigned char *)v17 + 104) = 0;
        v17[10] = 0;
        v17[11] = 0;
        uint64_t v20 = *(void *)(v7 + 2264);
        if (v20)
        {
          if (sub_1BB9D00D0(v20, a3, *(unsigned __int8 *)(v7 + 96)))
          {
            int v21 = *(_DWORD *)(v7 + 80);
            if (v21 > 39) {
              goto LABEL_38;
            }
            *(_DWORD *)(v7 + 80) = 40;
            *(_DWORD *)(v7 + 84) = v21;
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v22 = *(void *)(v7 + 2536);
              int v23 = *(_DWORD *)(v7 + 212);
              int v24 = *(_DWORD *)(v7 + 216);
              *(_DWORD *)buf = 134219008;
              *(void *)&uint8_t buf[4] = v22;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v23;
              __int16 v58 = 1024;
              int v59 = v24;
              __int16 v60 = 1024;
              int v61 = v21;
              __int16 v62 = 1024;
              int v63 = 40;
              _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): boosting maxAllowedQp %d -> %d\n", buf, 0x24u);
            }
            *(void *)buf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (const void *)(v7 + 80));
            sub_1BB9C65F4(v7, (const __CFString *)*MEMORY[0x1E4F449B8], *(const __CFString **)buf);
            *(unsigned char *)(v7 + 88) = 1;
          }
          else
          {
            if (!*(unsigned char *)(v7 + 88)) {
              goto LABEL_38;
            }
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v25 = *(void *)(v7 + 2536);
              int v26 = *(_DWORD *)(v7 + 212);
              int v27 = *(_DWORD *)(v7 + 216);
              int v28 = *(_DWORD *)(v7 + 80);
              int v29 = *(_DWORD *)(v7 + 84);
              *(_DWORD *)buf = 134219008;
              *(void *)&uint8_t buf[4] = v25;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v26;
              __int16 v58 = 1024;
              int v59 = v27;
              __int16 v60 = 1024;
              int v61 = v28;
              __int16 v62 = 1024;
              int v63 = v29;
              _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): reset maxAllowedQp %d -> %d\n", buf, 0x24u);
            }
            *(_DWORD *)(v7 + 80) = *(_DWORD *)(v7 + 84);
            *(void *)buf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (const void *)(v7 + 80));
            sub_1BB9C65F4(v7, (const __CFString *)*MEMORY[0x1E4F449B8], *(const __CFString **)buf);
            *(unsigned char *)(v7 + 88) = 0;
          }
          sub_1BB9BE1F4((const void **)buf);
        }
LABEL_38:
        *(void *)uint64_t v18 = a2;
        *(_DWORD *)(v18 + 8) = *a7;
        *(_OWORD *)(v18 + 12) = *a4;
        *(void *)(v18 + 28) = *((void *)a4 + 2);
        *(_OWORD *)(v18 + 36) = *a5;
        *(void *)(v18 + 52) = *((void *)a5 + 2);
        sub_1BBA3F68C(v19);
        if (*(unsigned char *)(v7 + 233))
        {
          Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          *(void *)__int16 v56 = Mutable;
          if (!Mutable)
          {
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315138;
              *(void *)&uint8_t buf[4] = v7 + 256;
              _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: Failed to allocate session properties\n", buf, 0xCu);
            }
            uint64_t v9 = 4294954392;
            goto LABEL_59;
          }
          uint64_t v9 = sub_1BB9C7E58(v7, Mutable);
          if (v9)
          {
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315138;
              *(void *)&uint8_t buf[4] = v7 + 256;
              _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: Failed to set session properties\n", buf, 0xCu);
            }
LABEL_59:
            sub_1BB9BE228((const void **)v56);
LABEL_81:
            MEMORY[0x1C18605E0](v18, 0x10A0C40583E35ACLL);
LABEL_82:
            sub_1BB9C0970((uint64_t)&v54);
            goto LABEL_83;
          }
          unsigned int v37 = *a7;
          sub_1BB9C0970((uint64_t)&v54);
          int v38 = *(void (**)(uint64_t, uint64_t, __CVBuffer *, long long *, long long *, uint64_t, void, uint64_t, unsigned int, std::mutex *))(v7 + 2272);
          uint64_t v39 = *(void *)(v7 + 2288);
          long long v46 = *a4;
          uint64_t v47 = *((void *)a4 + 2);
          long long v44 = *a5;
          uint64_t v45 = *((void *)a5 + 2);
          v38(v39, a2, a3, &v46, &v44, v53, *(void *)v56, v18, (v37 >> 1) & 1, v43);
          sub_1BB9BE228((const void **)v56);
          goto LABEL_77;
        }
        *(void *)buf = 0;
        *(void *)&buf[8] = 0;
        if (a3)
        {
          uint64_t v31 = *(void *)(v7 + 2296);
          if (v31) {
            goto LABEL_45;
          }
          OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a3);
          if (!sub_1BB9BF2EC(v7, PixelFormatType))
          {
            uint64_t v31 = *(void *)(v7 + 2296);
LABEL_45:
            long long v51 = *a4;
            uint64_t v52 = *((void *)a4 + 2);
            long long v49 = *a5;
            uint64_t v50 = *((void *)a5 + 2);
            uint64_t v9 = sub_1BB9C07C4(v7, a3, &v51, &v49, v53, v31 + 120);
            if (!v9)
            {
              uint64_t v32 = *(void *)(*(void *)(v7 + 2296) + 12728);
              if (v32)
              {
                uint64_t v9 = (*(uint64_t (**)(uint64_t, unsigned char *, __CVBuffer *))(*(void *)v32 + 16))(v32, buf, a3);
                if (!v9)
                {
                  uint64_t v33 = *(void *)(v7 + 2296);
                  uint64_t v34 = *(void *)buf;
                  *(_DWORD *)(*(void *)buf + 8) = *(_DWORD *)(v7 + 196);
                  *(_OWORD *)(v34 + 16) = *(_OWORD *)(v33 + 904);
                  *(_DWORD *)(v34 + 32) = *(_DWORD *)(v33 + 920);
                  *(_OWORD *)(v34 + 256) = *(_OWORD *)(v33 + 960);
                  sub_1BB9C0970((uint64_t)&v54);
                  uint64_t v35 = *(void *)(v7 + 2296);
                  uint64_t v36 = *(std::__shared_weak_count **)&buf[8];
                  v48[0] = *(void *)buf;
                  v48[1] = *(void *)&buf[8];
                  if (*(void *)&buf[8]) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
                  }
                  uint64_t v9 = sub_1BBA623E0(v35, (uint64_t)v48, v18);
                  if (v36) {
                    sub_1BB9C09B4(v36);
                  }
                  if (v9 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)__int16 v56 = 136315138;
                    *(void *)&v56[4] = v7 + 256;
                    _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: Failed to push frame\n", v56, 0xCu);
                  }
                  char v40 = 1;
                  goto LABEL_73;
                }
              }
              else
              {
                uint64_t v9 = 4294954385;
              }
              if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int16 v56 = 136315138;
                *(void *)&v56[4] = v7 + 256;
                _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: Failed to allocate source frame\n", v56, 0xCu);
              }
            }
            char v40 = 0;
            goto LABEL_73;
          }
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int16 v56 = 136315138;
            *(void *)&v56[4] = v7 + 256;
            _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: Failed to initialize sequence\n", v56, 0xCu);
          }
          char v40 = 0;
          uint64_t v9 = 4294954392;
        }
        else
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int16 v56 = 136315138;
            *(void *)&v56[4] = v7 + 256;
            _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: empty image buffer\n", v56, 0xCu);
          }
          char v40 = 0;
          uint64_t v9 = 4294954394;
        }
LABEL_73:
        if (*(void *)&buf[8]) {
          sub_1BB9C09B4(*(std::__shared_weak_count **)&buf[8]);
        }
        if ((v40 & 1) == 0)
        {
          if (v9) {
            uint64_t v9 = v9;
          }
          else {
            uint64_t v9 = 4294949605;
          }
          goto LABEL_81;
        }
        if (v9)
        {
LABEL_83:
          sub_1BB9BE228((const void **)&v53);
          sub_1BB9BF000((uint64_t)&v54);
          std::mutex::unlock(v43);
          return v9;
        }
LABEL_77:
        uint64_t v9 = 0;
        ++*(_DWORD *)(v7 + 196);
        goto LABEL_83;
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "NULL infoFlagsOut pointer\n", buf, 2u);
      }
      return 4294954394;
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Empty session storage\n", buf, 2u);
      }
      return 4294954392;
    }
  }
  else
  {
    uint64_t v9 = 0;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "NULL session\n", buf, 2u);
      return 0;
    }
  }
  return v9;
}

void sub_1BB9C0730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,const void *a28,__int16 a29,char a30,char a31)
{
  if (v31) {
    sub_1BB9C09B4(v31);
  }
  uint64_t v34 = *(std::__shared_weak_count **)(v32 - 136);
  if (v34) {
    sub_1BB9C09B4(v34);
  }
  sub_1BB9BE228(&a28);
  sub_1BB9BF000((uint64_t)&a29);
  std::mutex::unlock(a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9C07C4(uint64_t a1, __CVBuffer *a2, long long *a3, long long *a4, uint64_t a5, uint64_t a6)
{
  double v8 = *(double *)(a1 + 48);
  if (v8 < 0.0) {
    goto LABEL_2;
  }
  if (v8 != 0.5 && v8 != 1.0)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return 4294954394;
    }
    *(_WORD *)buf = 0;
    uint64_t v15 = MEMORY[0x1E4F14500];
    uint64_t v16 = "Baselayer framerate fraction should be either 0.5 or 1";
    goto LABEL_22;
  }
  if (v8 != 1.0)
  {
    double v13 = *(double *)(a1 + 56);
    if (v13 <= 0.0 || v13 >= 1.0)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        return 4294954394;
      }
      *(_WORD *)buf = 0;
      uint64_t v15 = MEMORY[0x1E4F14500];
      uint64_t v16 = "Baselayer bitrate fraction should be between 0 (exclusive) and 1 (inclusive)";
LABEL_22:
      _os_log_error_impl(&dword_1BB9B9000, v15, OS_LOG_TYPE_ERROR, v16, buf, 2u);
      return 4294954394;
    }
  }
LABEL_2:
  *(void *)(a6 + 824) = a5;
  *(_DWORD *)a6 = *(_DWORD *)(a1 + 192);
  *(void *)(a6 + 8) = *(void *)(a1 + 40);
  *(double *)(a6 + 16) = v8;
  *(void *)(a6 + 24) = *(void *)(a1 + 56);
  int v9 = *(_DWORD *)(a1 + 76) & ~(*(int *)(a1 + 76) >> 31);
  *(_DWORD *)(a6 + 32) = v9;
  *(_DWORD *)(a6 + 864) = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a6 + 868) = *(_DWORD *)(a1 + 92);
  *(unsigned char *)(a6 + 874) = *(unsigned char *)(a1 + 97);
  if (*(int *)(a1 + 236) >= 1)
  {
    uint64_t v10 = 0;
    do
      *(_DWORD *)(a6 + 36 + 4 * v10++) = v9;
    while (v10 < *(int *)(a1 + 236));
  }
  long long v20 = *a3;
  uint64_t v21 = *((void *)a3 + 2);
  long long v18 = *a4;
  uint64_t v19 = *((void *)a4 + 2);
  sub_1BB9FB768((_DWORD *)a6, (uint64_t *)&v20, (uint64_t *)&v18, *(_DWORD *)(a1 + 196), *(_DWORD *)(a1 + 196), *(_DWORD *)(a1 + 68), 1, *(float *)(a1 + 72), 0.0);
  sub_1BB9FC53C(a6, a2);
  return 0;
}

void sub_1BB9C0970(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    std::__shared_mutex_base::unlock(*(std::__shared_mutex_base **)a1);
    *(unsigned char *)(a1 + 8) = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    sub_1BB9C09B4(v2);
  }
}

void sub_1BB9C09B4(std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

uint64_t VCPRateControlSessionBeforeEmitEncodedFrame(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, CMSampleBufferRef *a5, uint64_t a6)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v8 = 0;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v30) = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "NULL session\n", (uint8_t *)&v30, 2u);
      return 0;
    }
    return v8;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (!*(unsigned char *)(v6 + 244)) {
    return 4294967278;
  }
  if (*(unsigned char *)(v6 + 232))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v30 = 136315138;
      uint64_t v31 = v6 + 256;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", (uint8_t *)&v30, 0xCu);
    }
    uint64_t v8 = 4294954393;
    if (!a6) {
      return v8;
    }
LABEL_54:
    MEMORY[0x1C18605E0](a6, 0x10A0C40583E35ACLL);
    return v8;
  }
  uint64_t v12 = *(void *)(v6 + 2256);
  if (v12) {
    sub_1BBAC8868(v12, (uint64_t *)"encoded_frames", 1.0);
  }
  if (!a4)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    LOWORD(v30) = 0;
    uint64_t v21 = MEMORY[0x1E4F14500];
    uint64_t v22 = "NULL infoFlags pointer\n";
    goto LABEL_59;
  }
  if (!a5)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    LOWORD(v30) = 0;
    uint64_t v21 = MEMORY[0x1E4F14500];
    uint64_t v22 = "NULL sampleBuffer pointer\n";
LABEL_59:
    _os_log_error_impl(&dword_1BB9B9000, v21, OS_LOG_TYPE_ERROR, v22, (uint8_t *)&v30, 2u);
LABEL_25:
    uint64_t v8 = 4294954394;
    if (!a6) {
      return v8;
    }
    goto LABEL_54;
  }
  if (a6)
  {
    if (!*(unsigned char *)(v6 + 233))
    {
      uint64_t v23 = *(void *)(v6 + 2296);
      if (!v23)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          LOWORD(v30) = 0;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "empty sequence\n", (uint8_t *)&v30, 2u);
        }
        uint64_t v8 = 4294954394;
        goto LABEL_54;
      }
      int v24 = *(unsigned char **)(a6 + 64);
      if (v24)
      {
        uint64_t v25 = *(void *)(v23 + 13272);
        if (v25)
        {
          uint64_t v8 = (*(uint64_t (**)(uint64_t, void, uint64_t, void, CMSampleBufferRef))(*(void *)v25 + 80))(v25, *(void *)(a6 + 64), a3, *a4, *a5);
          if (v8) {
            goto LABEL_54;
          }
        }
        if (*v24) {
          *a4 |= 2u;
        }
      }
      else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v30) = 0;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "empty frame context\n", (uint8_t *)&v30, 2u);
      }
    }
    int v13 = *a4;
    double v14 = 0.0;
    if ((*a4 & 2) != 0 || !*a5)
    {
      BOOL v19 = 0;
      BOOL v20 = 0;
      BOOL v15 = 1;
    }
    else
    {
      BOOL v15 = 1;
      CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(*a5, 1u);
      if (SampleAttachmentsArray
        && (CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0)) != 0)
      {
        CFDictionaryRef v18 = ValueAtIndex;
        BOOL v19 = !sub_1BB9C0F00(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F1A8], 1);
        BOOL v20 = sub_1BB9C0F00(v18, (const void *)*MEMORY[0x1E4F453B0], 0);
        BOOL v15 = sub_1BB9C0F00(v18, (const void *)*MEMORY[0x1E4F1F1F8], 1);
      }
      else
      {
        BOOL v19 = 0;
        BOOL v20 = 0;
      }
      DataBuffer = CMSampleBufferGetDataBuffer(*a5);
      double v14 = (double)(8 * CMBlockBufferGetDataLength(DataBuffer));
    }
    sub_1BBA3F6DC(a6 + 72);
    uint64_t v8 = 0;
    if ((v13 & 2) == 0)
    {
      uint64_t v27 = *(void *)(v6 + 2256);
      if (v27)
      {
        sub_1BBAC8868(v27, (uint64_t *)"transmit_frames", 1.0);
        sub_1BBAC8868(*(void *)(v6 + 2256), (uint64_t *)"encoded_bits", v14);
        sub_1BBAC8868(*(void *)(v6 + 2256), (uint64_t *)"encoding_time", *(double *)(a6 + 72));
        if (v19) {
          sub_1BBAC8868(*(void *)(v6 + 2256), (uint64_t *)"idr_frames", 1.0);
        }
        if (v20) {
          sub_1BBAC8868(*(void *)(v6 + 2256), (uint64_t *)"refresh_frames", 1.0);
        }
        if (*(double *)(v6 + 48) > 0.0 && v15)
        {
          sub_1BBAC8868(*(void *)(v6 + 2256), (uint64_t *)"base_layer_frames", 1.0);
          sub_1BBAC8868(*(void *)(v6 + 2256), (uint64_t *)"base_layer_encoded_bits", v14);
        }
        uint64_t v8 = 0;
      }
    }
    goto LABEL_54;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    LOWORD(v30) = 0;
    _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "NULL frameRefCon pointer\n", (uint8_t *)&v30, 2u);
  }
  return 4294954394;
}

BOOL sub_1BB9C0F00(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
  if (Value) {
    return CFBooleanGetValue(Value) != 0;
  }
  return a3;
}

uint64_t VCPRateControlSessionCompleteFrames(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 16);
    if (v1)
    {
      if (*(unsigned char *)(v1 + 232))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          int v6 = 136315138;
          uint64_t v7 = v1 + 256;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: RC session is invalid\n", (uint8_t *)&v6, 0xCu);
        }
        return 4294954393;
      }
      else if (*(unsigned char *)(v1 + 244))
      {
        uint64_t v3 = (std::mutex *)(v1 + 2304);
        std::mutex::lock((std::mutex *)(v1 + 2304));
        if (*(unsigned char *)(v1 + 233))
        {
          uint64_t v2 = 0;
        }
        else
        {
          uint64_t v4 = *(void *)(v1 + 2296);
          if (v4)
          {
            uint64_t v2 = sub_1BBA59368(v4);
          }
          else
          {
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
            {
              LOWORD(v6) = 0;
              _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "empty sequence\n", (uint8_t *)&v6, 2u);
            }
            uint64_t v2 = 4294954394;
          }
        }
        std::mutex::unlock(v3);
      }
      else
      {
        return 4294967278;
      }
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        LOWORD(v6) = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Empty session storage\n", (uint8_t *)&v6, 2u);
      }
      return 4294954392;
    }
  }
  else
  {
    uint64_t v2 = 0;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6) = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "NULL session\n", (uint8_t *)&v6, 2u);
      return 0;
    }
  }
  return v2;
}

void sub_1BB9C1124(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9C1138(uint64_t a1, __CVBuffer *a2)
{
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v4 = CVPixelBufferPoolCreatePixelBuffer(0, *(CVPixelBufferPoolRef *)(a1 + 16), &pixelBufferOut);
  if (!v4)
  {
    uint64_t v4 = VTPixelTransferSessionTransferImage(*(VTPixelTransferSessionRef *)(a1 + 24), a2, pixelBufferOut);
    if (!v4)
    {
      uint64_t v4 = CVPixelBufferLockBaseAddress(pixelBufferOut, 1uLL);
      if (!v4)
      {
        int v5 = *(_DWORD *)(a1 + 12);
        if (v5 < 1)
        {
LABEL_26:
          uint64_t v4 = CVPixelBufferUnlockBaseAddress(pixelBufferOut, 1uLL);
          if (!v4)
          {
            CFDataRef v32 = CFDataCreate(0, *(const UInt8 **)(a1 + 32), 4 * *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 12));
            CFDataRef v34 = v32;
            if (v32)
            {
              CVBufferSetAttachment(a2, @"Spillmap", v32, kCVAttachmentMode_ShouldPropagate);
              uint64_t v4 = 0;
            }
            else
            {
              uint64_t v4 = 4294954392;
            }
            sub_1BB9BE124((const void **)&v34);
          }
        }
        else
        {
          int v6 = 0;
          int v7 = *(_DWORD *)(a1 + 8);
          while (v7 < 1)
          {
LABEL_25:
            v6 += 4;
            if (v6 >= 4 * v5) {
              goto LABEL_26;
            }
          }
          int v8 = 0;
          while (1)
          {
            int v9 = pixelBufferOut;
            if (CVPixelBufferGetPixelFormatType(pixelBufferOut) != 1111970369) {
              break;
            }
            int Width = CVPixelBufferGetWidth(v9);
            int v11 = *(_DWORD *)(a1 + 8);
            uint64_t v12 = *(void **)(a1 + 56);
            uint64_t v13 = *(void *)(a1 + 64) - (void)v12;
            if (v13 >= 1) {
              bzero(v12, 4 * (((unint64_t)v13 >> 2) - ((unint64_t)v13 > 3)) + 4);
            }
            BaseAddress = (char *)CVPixelBufferGetBaseAddress(v9);
            unsigned int v15 = 0;
            unsigned int v16 = 0;
            signed int v17 = v8 + 4 * v11 * (v6 >> 2);
            CFDictionaryRef v18 = &BaseAddress[4 * (v8 + v6 * Width)];
            uint64_t v19 = *(void *)(a1 + 56);
            do
            {
              unint64_t v20 = 0;
              do
              {
                unint64_t v21 = v18[v20 + 1] & 0xF0 | ((((unint64_t)v18[v20] >> 4) & 0xF) << 8) | ((unint64_t)v18[v20 + 2] >> 4);
                int v22 = *(_DWORD *)(v19 + 4 * v21);
                *(_DWORD *)(v19 + 4 * v21) = v22 + 1;
                if (v22 + 1 > v15) {
                  unsigned int v15 = v22 + 1;
                }
                BOOL v23 = v20 >= 0xC;
                v20 += 4;
              }
              while (!v23);
              v18 += (4 * Width);
              BOOL v23 = v16 >= 0xC;
              v16 += 4;
            }
            while (!v23);
            char v24 = 0;
            uint64_t v25 = 0;
            unint64_t v26 = 0;
            unint64_t v27 = 0;
            unint64_t v28 = 0;
            unint64_t v29 = 0;
            unsigned int v30 = ((double)v15 * 0.8);
            do
            {
              uint64_t v31 = *(unsigned int *)(v19 + 4 * v25);
              if (v31 >= v30)
              {
                v26 += v31;
                v27 += v31 * ((v25 >> 4) & 0xF0 | 8);
                v28 += v31 * (v25 & 0xF0 | 8);
                v29 += v31 * (v24 & 0xF0 | 8);
              }
              ++v25;
              v24 += 16;
            }
            while (v25 != 4096);
            *(unsigned char *)(*(void *)(a1 + 32) + v17) = (int)((float)((float)v27 / (float)v26) + 0.5);
            *(unsigned char *)(*(void *)(a1 + 32) + (v17 | 1)) = (int)((float)((float)v28 / (float)v26) + 0.5);
            *(unsigned char *)(*(void *)(a1 + 32) + (v17 | 2)) = (int)((float)((float)v29 / (float)v26) + 0.5);
            *(unsigned char *)(*(void *)(a1 + 32) + (v17 | 3)) = -1;
            v8 += 4;
            int v7 = *(_DWORD *)(a1 + 8);
            if (v8 >= 4 * v7)
            {
              int v5 = *(_DWORD *)(a1 + 12);
              goto LABEL_25;
            }
          }
          uint64_t v4 = 4294943593;
        }
      }
    }
  }
  sub_1BB9C14A0((const void **)&pixelBufferOut);
  return v4;
}

void sub_1BB9C1468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **sub_1BB9C14A0(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1BB9C14D4(uint64_t a1)
{
  uint64_t v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFDictionaryRef pixelBufferAttributes = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, v2, v3);
  CFMutableDictionaryRef v38 = Mutable;
  if (pixelBufferAttributes) {
    BOOL v5 = Mutable == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    uint64_t v6 = 4294954392;
    goto LABEL_43;
  }
  int v7 = *(_DWORD *)(a1 + 12);
  uint64_t valuePtr = (4 * *(_DWORD *)(a1 + 8));
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  CFNumberRef v9 = v8;
  if (v8)
  {
    CFDictionarySetValue(pixelBufferAttributes, (const void *)*MEMORY[0x1E4F24E10], v8);
    CFRelease(v9);
  }
  uint64_t valuePtr = (4 * v7);
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  if (v10)
  {
    CFDictionarySetValue(pixelBufferAttributes, (const void *)*MEMORY[0x1E4F24D08], v10);
    CFRelease(v10);
  }
  uint64_t valuePtr = 1111970369;
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  if (v11)
  {
    CFDictionarySetValue(pixelBufferAttributes, (const void *)*MEMORY[0x1E4F24D70], v11);
    CFRelease(v11);
  }
  CFMutableDictionaryRef v37 = v38;
  if (v38) {
    CFRetain(v38);
  }
  CFDictionarySetValue(pixelBufferAttributes, (const void *)*MEMORY[0x1E4F24D20], v38);
  sub_1BB9BE228((const void **)&v37);
  CFDictionaryRef v12 = pixelBufferAttributes;
  uint64_t v13 = *(const void **)(a1 + 16);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v6 = CVPixelBufferPoolCreate(0, 0, v12, (CVPixelBufferPoolRef *)(a1 + 16));
  if (!v6)
  {
    unsigned int v15 = (VTSessionRef *)(a1 + 24);
    double v14 = *(const void **)(a1 + 24);
    if (v14)
    {
      CFRelease(v14);
      *unsigned int v15 = 0;
    }
    uint64_t v6 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (VTPixelTransferSessionRef *)(a1 + 24));
    if (!v6)
    {
      uint64_t v6 = VTSessionSetProperty(*v15, (CFStringRef)*MEMORY[0x1E4F45100], (CFTypeRef)*MEMORY[0x1E4F24C48]);
      if (!v6)
      {
        uint64_t v16 = *(void *)(a1 + 32);
        unint64_t v17 = 4 * *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 12);
        unint64_t v18 = *(void *)(a1 + 40) - v16;
        if (v17 <= v18)
        {
          if (v17 < v18) {
            *(void *)(a1 + 40) = v16 + v17;
          }
        }
        else
        {
          sub_1BB9C1970((unint64_t *)(a1 + 32), v17 - v18);
        }
        uint64_t v19 = *(void *)(a1 + 56);
        uint64_t v20 = *(void *)(a1 + 64);
        uint64_t v21 = v20 - v19;
        if ((unint64_t)(v20 - v19) >> 14)
        {
          if (v21 == 0x4000)
          {
LABEL_42:
            uint64_t v6 = 0;
            goto LABEL_43;
          }
          uint64_t v6 = 0;
          uint64_t v35 = v19 + 0x4000;
        }
        else
        {
          unint64_t v22 = 4096 - (v21 >> 2);
          uint64_t v23 = *(void *)(a1 + 72);
          if (v22 > (v23 - v20) >> 2)
          {
            uint64_t v24 = v23 - v19;
            uint64_t v25 = v24 >> 1;
            if ((unint64_t)(v24 >> 1) <= 0x1000) {
              uint64_t v25 = 4096;
            }
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v25;
            }
            unint64_t v27 = (char *)sub_1BB9C1874(v26);
            uint64_t v28 = v21 >> 2;
            uint64_t v6 = *(void *)(a1 + 56);
            uint64_t v29 = *(void *)(a1 + 64);
            unsigned int v30 = &v27[4 * v28];
            CFDataRef v32 = &v27[4 * v31];
            bzero(v30, 4 * v22);
            uint64_t v33 = &v30[4 * v22];
            while (v29 != v6)
            {
              int v34 = *(_DWORD *)(v29 - 4);
              v29 -= 4;
              *((_DWORD *)v30 - 1) = v34;
              v30 -= 4;
            }
            *(void *)(a1 + 56) = v30;
            *(void *)(a1 + 64) = v33;
            *(void *)(a1 + 72) = v32;
            if (v6)
            {
              operator delete((void *)v6);
              goto LABEL_42;
            }
            goto LABEL_43;
          }
          bzero(*(void **)(a1 + 64), 4 * v22);
          uint64_t v6 = 0;
          uint64_t v35 = v20 + 4 * v22;
        }
        *(void *)(a1 + 64) = v35;
      }
    }
  }
LABEL_43:
  sub_1BB9BE228((const void **)&v38);
  sub_1BB9BE228((const void **)&pixelBufferAttributes);
  return v6;
}

void sub_1BB9C1814(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  sub_1BB9BE228((const void **)va);
  sub_1BB9BE228((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1BB9C185C()
{
}

void *sub_1BB9C1874(unint64_t a1)
{
  if (a1 >> 62) {
    sub_1BB9C18AC();
  }
  return operator new(4 * a1);
}

void sub_1BB9C18AC()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, (struct type_info *)&unk_1F14EDBE8, MEMORY[0x1E4FBA1F8]);
}

void sub_1BB9C18E0(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1BB9C193C(exception, a1);
  __cxa_throw(exception, (struct type_info *)&unk_1F14EDBB0, MEMORY[0x1E4FBA1C8]);
}

void sub_1BB9C1928(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1BB9C193C(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void sub_1BB9C1970(unint64_t *a1, size_t a2)
{
  BOOL v5 = (char *)a1[1];
  uint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    int v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      sub_1BB9C185C();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    CFDictionaryRef v12 = &v7[v11];
    uint64_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      double v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      BOOL v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_1BB9C1AA8(uint64_t a1)
{
  *(void *)a1 = &unk_1F14EE528;
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3)
  {
    *(void *)(a1 + 40) = v3;
    operator delete(v3);
  }
  sub_1BB9C1B38((const void **)(a1 + 24));
  sub_1BB9C1B6C((const void **)(a1 + 16));

  JUMPOUT(0x1C18605E0);
}

const void **sub_1BB9C1B38(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_1BB9C1B6C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1BB9C1BA0(uint64_t a1)
{
  *(void *)a1 = &unk_1F14EE528;
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3)
  {
    *(void *)(a1 + 40) = v3;
    operator delete(v3);
  }
  sub_1BB9C1B38((const void **)(a1 + 24));
  sub_1BB9C1B6C((const void **)(a1 + 16));
  return a1;
}

uint64_t sub_1BB9C1C10(unsigned int a1, int *a2, unsigned char *a3, int a4, int a5, int a6)
{
  uint64_t v6 = *a2;
  if (v6 >= 0x1000) {
    exit(1);
  }
  unsigned int v7 = (a1 >> 20) & 0x3FF;
  unint64_t v8 = (char *)&unk_1BBB74C68;
  unsigned int v9 = (a1 >> 10) & 0x3FF;
  if (v9 <= 0x43) {
    size_t v10 = (char *)&unk_1BBB74C68;
  }
  else {
    size_t v10 = (char *)&unk_1BBB75C68;
  }
  int v11 = (int)(v9 + v10[v6]) >> 2;
  if (v11 >= 255) {
    LOBYTE(v11) = -1;
  }
  if (v11 > 0x11u)
  {
    unsigned int v14 = a1 & 0x3FF;
    int v15 = 512 - v14;
    if (v14 >= 0x200) {
      int v15 = v14 - 512;
    }
    if (v15 <= 3) {
      uint64_t v16 = (char *)&unk_1BBB74C68;
    }
    else {
      uint64_t v16 = (char *)&unk_1BBB75C68;
    }
    int v17 = v16[((_WORD)v6 + 1) & 0xFFF];
    unsigned int v12 = ((v14 + v17) & ~((int)(v14 + v17) >> 31)) >> 2;
    if (v12 >= 0xFF) {
      LOBYTE(v12) = -1;
    }
    uint64_t v6 = ((_WORD)v6 + 2) & 0xFFF;
    int v18 = 512 - v7;
    if (v7 >= 0x200) {
      int v18 = v7 - 512;
    }
    if (v18 > 3) {
      unint64_t v8 = (char *)&unk_1BBB75C68;
    }
    unsigned int v19 = ((v7 + v8[v6]) & ~((int)(v7 + v8[v6]) >> 31)) >> 2;
    if (v19 >= 0xFF) {
      LOBYTE(v13) = -1;
    }
    else {
      LOBYTE(v13) = v19;
    }
  }
  else
  {
    unsigned int v12 = a1 >> 2;
    LOWORD(v6) = (v6 + 2) & 0xFFF;
    unsigned int v13 = v7 >> 2;
  }
  uint64_t v20 = 0;
  uint64_t result = 0;
  v23[0] = v12;
  v23[1] = v11;
  *a2 = ((_WORD)v6 + 1) & 0xFFF;
  v23[2] = v13;
  do
  {
    if (a4 + (int)v20 >= a5 && a4 + (int)v20 <= a6)
    {
      *a3++ = v23[v20];
      uint64_t result = (result + 1);
    }
    ++v20;
  }
  while (v20 != 3);
  dword_1E9F81538 = ((_WORD)dword_1E9F81538 + (v11 & 1)) & 0xFFF;
  return result;
}

float sub_1BB9C1D70(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, uint64_t a8, float result, float a10)
{
  v61[31] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a1[1];
  unsigned int v11 = a1[3];
  float v12 = (float)v11;
  float v13 = (float)v10 / (float)v11;
  if (a6)
  {
    unsigned int v14 = a6;
    do
    {
      a10 = v13 + a10;
      --v14;
    }
    while (v14);
  }
  if (a6 < a7)
  {
    LOWORD(v12) = *a1;
    uint64_t v15 = v10 - 2;
    uint64_t v16 = (_WORD *)(a8 + 2 * a1[4112]);
    uint64_t v17 = a4 + 2 * a5 * a6;
    uint64_t v18 = v15 * a3;
    float v19 = (float)LODWORD(v12) / (float)a1[2];
    unsigned int v20 = ((_WORD)v11 * a1[2] + (a1[2] >> 1) * (_WORD)a6 + (unsigned __int16)*((_DWORD *)a1 + 4)) & 0xFFF;
    uint64_t v21 = 2 * a3;
    int v59 = v61;
    do
    {
      uint64_t v22 = (2 * (int)a10 * a3) & ~((2 * (int)a10 * a3) >> 63);
      uint64_t v23 = a1[6];
      uint64_t v24 = &v60[8 * v23];
      *(v24 - 1) = v22;
      uint64_t v25 = v22 + v21;
      if (v18 < v25) {
        uint64_t v25 = v18;
      }
      *uint64_t v24 = v25;
      if (v23 >= 2)
      {
        uint64_t v26 = 8 * v23;
        unint64_t v27 = &v59[v23];
        do
        {
          *(void *)&v58[v26] = (*(void *)&v58[v26 + 8] - v21) & ~((*(void *)&v58[v26 + 8] - v21) >> 63);
          uint64_t v28 = *(v27 - 1) + v21;
          if (v18 < v28) {
            uint64_t v28 = v18;
          }
          *v27++ = v28;
          v26 -= 8;
        }
        while (v26 != 8);
      }
      if (*a1)
      {
        unint64_t v29 = 0;
        unsigned int v30 = &a1[32 * (uint64_t)(int)vcvts_n_s32_f32(a10 - (float)(int)a10, 7uLL)];
        do
        {
          uint64_t v31 = a1[6];
          if (a1[6])
          {
            __int16 v32 = 0;
            uint64_t v33 = a1[6];
            do
            {
              v32 += v30[v33 + 15] * *(unsigned __int8 *)(a2 + a3 + *(void *)&v60[8 * v33 - 8] + 2 * v29)
                   + v30[v31 + 16] * *(unsigned __int8 *)(a2 + a3 + *(void *)&v60[8 * v31] + 2 * v29);
              ++v31;
              --v33;
            }
            while (v33);
          }
          else
          {
            __int16 v32 = 0;
          }
          v16[v29++] = v32;
        }
        while (v29 < *a1);
        LODWORD(v23) = a1[6];
      }
      if (v23)
      {
        unint64_t v34 = 0;
        uint64_t v35 = v16 - 1;
        uint64_t v36 = 1;
        do
        {
          *(v35 - 1) = *v16;
          *uint64_t v35 = v16[1];
          v35 -= 2;
          v16[v36 - 1 + *a1] = v16[*a1 - 2];
          v16[v36 + *a1] = v16[*a1 - 1];
          ++v34;
          v36 += 2;
        }
        while (v34 < a1[6]);
      }
      if (a1[2] >= 2u)
      {
        unint64_t v37 = 0;
        float v38 = result;
        do
        {
          uint64_t v39 = a1[6];
          if (a1[6])
          {
            uint64_t v40 = 0;
            int v41 = 0;
            int v42 = 0;
            int v43 = (int)v38;
            signed int v44 = vcvts_n_s32_f32(v38 - (float)(int)v38, 7uLL);
            do
            {
              uint64_t v45 = (uint64_t)&a1[32 * (uint64_t)v44 + 16];
              int v46 = *(__int16 *)(v45 + 2 * (v39 + ~v40));
              LODWORD(v45) = *(__int16 *)(v45 + 2 * (v40 + v39));
              int v47 = 2 * (v40 + v43);
              v42 += (__int16)v16[2 * (v43 - (int)v40)] * v46 + (__int16)v16[v47 + 2] * v45;
              v41 += (__int16)v16[2 * (v43 - (int)v40++) + 1] * v46 + (__int16)v16[v47 + 3] * v45;
            }
            while (v40 != v39);
          }
          else
          {
            int v42 = 0;
            int v41 = 0;
          }
          int v48 = (unsigned __int8 *)&unk_1BBB76C68 + v20;
          int v49 = (v41 << 6) + (v48[1] << 16);
          unsigned int v20 = ((_WORD)v20 + 2) & 0xFFF;
          int v50 = (v42 << 6) + (*v48 << 16) + 0x8000;
          int v51 = v50 >> 18;
          if (v50 >> 18 >= 255) {
            LOBYTE(v51) = -1;
          }
          if (v50 >= 0) {
            char v52 = v51;
          }
          else {
            char v52 = 0;
          }
          uint64_t v53 = (unsigned char *)(v17 + 4 * v37);
          *uint64_t v53 = v52;
          uint64_t v54 = (unsigned char *)(v17 + a5 + 4 * v37);
          *uint64_t v54 = v52;
          int v55 = v49 + 0x8000;
          int v56 = v55 >> 18;
          if (v55 >> 18 >= 255) {
            LOBYTE(v56) = -1;
          }
          if (v55 >= 0) {
            char v57 = v56;
          }
          else {
            char v57 = 0;
          }
          v53[2] = v57;
          v54[2] = v57;
          float v38 = v19 + v38;
          ++v37;
        }
        while (v37 < (unint64_t)a1[2] >> 1);
      }
      a10 = v13 + a10;
      v17 += 2 * a5;
      ++a6;
    }
    while (a6 != a7);
  }
  return result;
}

float sub_1BB9C213C(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, _WORD *a8, float result, float a10, double a11, float a12)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1[1];
  LOWORD(a12) = a1[3];
  float v13 = (float)LODWORD(a12);
  float v14 = (float)v12 / v13;
  if (a6)
  {
    unsigned int v15 = a6;
    do
    {
      a10 = v14 + a10;
      --v15;
    }
    while (v15);
  }
  if (a6 < a7)
  {
    LOWORD(v13) = *a1;
    unsigned int v16 = a1[2];
    uint64_t v17 = v12 - 1;
    uint64_t v18 = a4 + a6 * a5;
    uint64_t v19 = v17 * a3;
    float v20 = (float)LODWORD(v13) / (float)v16;
    unsigned int v21 = ((unsigned __int16)*((_DWORD *)a1 + 4) + (_WORD)v16 * (_WORD)a6) & 0xFFF;
    do
    {
      uint64_t v22 = ((int)a10 * a3) & ~(((int)a10 * a3) >> 63);
      uint64_t v23 = a1[6];
      uint64_t v24 = &v47[v23];
      *(v24 - 1) = v22;
      uint64_t v25 = v22 + a3;
      if (v19 < v25) {
        uint64_t v25 = v17 * a3;
      }
      *uint64_t v24 = v25;
      if (v23 >= 2)
      {
        uint64_t v26 = v23;
        unint64_t v27 = &v47[v23 + 1];
        do
        {
          v47[v26 - 2] = (v47[v26 - 1] - a3) & ~((v47[v26 - 1] - a3) >> 63);
          uint64_t v28 = *(v27 - 1) + a3;
          if (v19 < v28) {
            uint64_t v28 = v17 * a3;
          }
          *v27++ = v28;
          --v26;
        }
        while (v26 != 1);
      }
      if (*a1)
      {
        unint64_t v29 = 0;
        unsigned int v30 = &a1[32 * (uint64_t)(int)vcvts_n_s32_f32(a10 - (float)(int)a10, 7uLL)];
        do
        {
          uint64_t v31 = a1[6];
          if (a1[6])
          {
            __int16 v32 = 0;
            uint64_t v33 = a1[6];
            do
            {
              v32 += v30[v33 + 15] * *(unsigned __int8 *)(a2 + ((2 * v29) | 1) + v47[v33 - 1])
                   + v30[v31 + 16] * *(unsigned __int8 *)(a2 + ((2 * v29) | 1) + v47[v31]);
              ++v31;
              --v33;
            }
            while (v33);
          }
          else
          {
            __int16 v32 = 0;
          }
          a8[v29++] = v32;
        }
        while (v29 < *a1);
        LODWORD(v23) = a1[6];
      }
      if (v23)
      {
        unint64_t v34 = 0;
        uint64_t v35 = 0x7FFFFFFFFFFFFFFFLL;
        do
        {
          a8[v35] = *a8;
          a8[v34 + *a1] = a8[*a1 - 1];
          ++v34;
          --v35;
        }
        while (v34 < a1[6]);
      }
      if (a1[2])
      {
        unint64_t v36 = 0;
        float v37 = result;
        do
        {
          uint64_t v38 = a1[6];
          if (a1[6])
          {
            uint64_t v39 = 0;
            uint64_t v40 = 0;
            int v41 = 0;
            uint64_t v42 = -v38;
            int v43 = &a1[32 * (uint64_t)(int)vcvts_n_s32_f32(v37 - (float)(int)v37, 7uLL) + v38];
            do
            {
              v41 += (__int16)a8[(int)v37 + v40] * (__int16)v43[v40 + 15]
                   + (__int16)a8[(int)v37 + 1 + v39] * (__int16)v43[v39 + 16];
              --v40;
              ++v39;
            }
            while (v42 != v40);
          }
          else
          {
            int v41 = 0;
          }
          int v44 = byte_1BBB76C68[v21] + ((v41 + 512) >> 10);
          unsigned int v21 = ((_WORD)v21 + 1) & 0xFFF;
          int v45 = v44 >> 2;
          if (v44 >> 2 >= 255) {
            LOBYTE(v45) = -1;
          }
          if (v44 >= 0) {
            char v46 = v45;
          }
          else {
            char v46 = 0;
          }
          *(unsigned char *)(v18 + 2 * v36 + 1) = v46;
          float v37 = v20 + v37;
          ++v36;
        }
        while (v36 < a1[2]);
      }
      a10 = v14 + a10;
      v18 += a5;
      ++a6;
    }
    while (a6 != a7);
  }
  return result;
}

void sub_1BB9C2444(uint64_t a1)
{
  uint64_t v2 = (unsigned __int16 *)(a1 + 8224);
  if (!*(void *)(a1 + 8280))
  {
    *(_WORD *)(a1 + 8226) = 0;
    goto LABEL_12;
  }
  unsigned int v3 = *(unsigned __int16 *)(a1 + 8226);
  if (!*(_WORD *)(a1 + 8226))
  {
    *(_WORD *)(a1 + 8226) = 0;
LABEL_11:
    MEMORY[0x1C18605A0]();
    goto LABEL_12;
  }
  unint64_t v4 = 0;
  uint64_t v5 = 16;
  do
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 8280) + v5);
    if (v6)
    {
      MEMORY[0x1C18605A0](v6 - 2 * *v2, 0x1000C80BDFB0063);
      unsigned int v3 = v2[1];
    }
    ++v4;
    v5 += 24;
  }
  while (v4 < v3);
  uint64_t v7 = *(void *)(a1 + 8280);
  v2[1] = 0;
  if (v7) {
    goto LABEL_11;
  }
LABEL_12:
  *(void *)(a1 + 8280) = 0;
  unint64_t v8 = *(NSObject **)(a1 + 8296);
  if (v8)
  {
    dispatch_release(v8);
    *(void *)(a1 + 8296) = 0;
  }
}

uint64_t sub_1BB9C250C(float **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void *)*a1;
  unint64_t v4 = *(void (**)(void *, void, void, void, void, void, void, float *, float, float))(v3 + 8304);
  uint64_t v5 = *(void *)(v3 + 8312);
  uint64_t v6 = (void *)(v3 + (v5 >> 1));
  if (v5) {
    unint64_t v4 = *(void (**)(void *, void, void, void, void, void, void, float *, float, float))(*v6 + v4);
  }
  v4(v6, *((void *)v2 + 1), *((void *)v2 + 2), *((void *)v2 + 3), *((void *)v2 + 4), *((unsigned __int16 *)a1 + 4), *((unsigned __int16 *)a1 + 5), a1[2], v2[10], v2[11]);
  unsigned int v9 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float *, __n128, __n128))(*(void *)v2 + 8320);
  uint64_t v10 = *(void *)(*(void *)v2 + 8328);
  unsigned int v11 = (void *)(*(void *)v2 + (v10 >> 1));
  if (v10) {
    unsigned int v9 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float *, __n128, __n128))(*v11 + v9);
  }
  uint64_t v12 = *((void *)v2 + 1);
  uint64_t v13 = *((void *)v2 + 2);
  uint64_t v14 = *((void *)v2 + 3);
  uint64_t v15 = *((void *)v2 + 4);
  v7.n128_f32[0] = v2[10];
  v8.n128_f32[0] = v2[11];
  uint64_t v16 = *((unsigned __int16 *)a1 + 4) >> 1;
  uint64_t v17 = *((unsigned __int16 *)a1 + 5) >> 1;
  uint64_t v18 = a1[2];

  return v9(v11, v12, v13, v14, v15, v16, v17, v18, v7, v8);
}

uint64_t PassthroughEncoder_CreateInstance(int a1, const __CFAllocator *a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  VTVideoEncoderGetClassID();
  uint64_t v6 = CMDerivedObjectCreate();
  if (v6)
  {
    uint64_t v7 = v6;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "PT: failed to create derived object\n", buf, 2u);
    }
  }
  else
  {
    uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
    *(_DWORD *)(DerivedStorage + 48) = a1;
    *(void *)uint64_t DerivedStorage = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    dispatch_semaphore_t v9 = dispatch_semaphore_create(1);
    *(void *)(DerivedStorage + 64) = v9;
    if (v9)
    {
      if (a2)
      {
        CFRetain(a2);
        uint64_t v7 = 0;
        *(void *)(DerivedStorage + 16) = a2;
      }
      else
      {
        uint64_t v7 = 0;
      }
      goto LABEL_13;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v11 = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "PT: Failed to create fig semaphore\n", v11, 2u);
    }
    uint64_t v7 = 4294954510;
  }
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0;
  }
LABEL_13:
  *a3 = cf;
  return v7;
}

uint64_t sub_1BB9C2740()
{
  VTVideoEncoderGetCMBaseObject();
  uint64_t v0 = *(void *)(CMBaseObjectGetDerivedStorage() + 8);
  if (!v0) {
    return 4294954514;
  }
  uint64_t v1 = *(void *)(CMBaseObjectGetVTable() + 16);
  uint64_t v2 = v1 ? (void *)v1 : 0;
  if (*v2 < 2uLL) {
    return 4294954514;
  }
  uint64_t v3 = (uint64_t (*)(uint64_t))v2[7];
  if (!v3) {
    return 4294954514;
  }

  return v3(v0);
}

uint64_t sub_1BB9C2814(uint64_t a1, uint64_t a2, uint64_t a3)
{
  VTVideoEncoderGetCMBaseObject();
  uint64_t v5 = *(void *)(CMBaseObjectGetDerivedStorage() + 8);
  if (!v5) {
    return 4294954514;
  }
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  uint64_t v7 = v6 ? v6 : 0;
  __n128 v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48);
  if (!v8) {
    return 4294954514;
  }

  return v8(v5, a2, a3);
}

uint64_t sub_1BB9C28F8(uint64_t a1, void *a2)
{
  VTVideoEncoderGetCMBaseObject();
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v4 = *(void *)(DerivedStorage + 8);
  if (v4)
  {
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    __n128 v8 = *(uint64_t (**)(uint64_t, void *))(v6 + 32);
    if (v8)
    {
      return v8(v4, a2);
    }
    else
    {
      return 4294954514;
    }
  }
  else
  {
    int context = *(_DWORD *)(DerivedStorage + 48);
    if (qword_1E9F81548 != -1) {
      dispatch_once_f(&qword_1E9F81548, &context, (dispatch_function_t)sub_1BB9C2A3C);
    }
    uint64_t result = 4294954514;
    if (a2 && qword_1E9F81540)
    {
      CFRetain((CFTypeRef)qword_1E9F81540);
      uint64_t result = 0;
      *a2 = qword_1E9F81540;
    }
  }
  return result;
}

void sub_1BB9C2A3C(int *a1)
{
  int v1 = *a1;
  CFDictionaryRef v14 = 0;
  CFDictionaryRef theDict = 0;
  CFTypeRef v13 = 0;
  if (v1 == 1684632424 || v1 == 1752589105 || v1 == 1718908520) {
    uint64_t v4 = @"com.apple.videotoolbox.videoencoder.hevc";
  }
  else {
    uint64_t v4 = @"com.apple.videotoolbox.videoencoder.h264";
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F45620], v4);
  if (sub_1BB9C2D84())
  {
    if (v1 == 1684632424 || v1 == 1752589105 || v1 == 1718908520) {
      VTVPParavirtualizedHEVCVideoEncoder_CreateInstance();
    }
    else {
      VTVPParavirtualizedH264VideoEncoder_CreateInstance();
    }
  }
  else
  {
    VTSelectAndCreateVideoEncoderInstance();
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  int v6 = 1718908515;
  if (v1 == 1684632424 || v1 == 1752589105 || v1 == 1718908520) {
    int v6 = 1718908520;
  }
  int v7 = sub_1BB9F0754(v6, 0, &v13);
  CFTypeRef v8 = v13;
  if (!v7 && v13)
  {
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 16);
    uint64_t v10 = v9 ? v9 : 0;
    unsigned int v11 = *(void (**)(CFTypeRef, CFDictionaryRef *))(v10 + 32);
    if (v11) {
      v11(v8, &theDict);
    }
  }
  if (v8) {
    CFRelease(v8);
  }
  CFMutableDictionaryRef v12 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (theDict)
  {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1BB9C2DF4, v12);
    CFRelease(theDict);
  }
  if (v14)
  {
    CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)sub_1BB9C2DF4, v12);
    CFRelease(v14);
  }
  qword_1E9F81540 = (uint64_t)v12;
}

uint64_t sub_1BB9C2D84()
{
  uint64_t result = _os_feature_enabled_impl();
  if (result)
  {
    if (qword_1EC027190 != -1) {
      dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
    }
    return dword_1EC02719C == 255;
  }
  return result;
}

void sub_1BB9C2DF4(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

uint64_t sub_1BB9C2E08(uint64_t a1, long long *a2)
{
  VTVideoEncoderGetCMBaseObject();
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(DerivedStorage + 64), 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v4 = *(void *)(DerivedStorage + 8);
  if (v4)
  {
    long long v10 = *a2;
    uint64_t v11 = *((void *)a2 + 2);
    uint64_t v5 = *(void *)(CMBaseObjectGetVTable() + 16);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0;
    }
    CFTypeRef v8 = *(uint64_t (**)(uint64_t, long long *))(v6 + 24);
    if (v8)
    {
      long long v12 = v10;
      uint64_t v13 = v11;
      uint64_t v7 = v8(v4, &v12);
    }
    else
    {
      uint64_t v7 = 4294954514;
    }
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 64));
  }
  else
  {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 64));
    return 4294954514;
  }
  return v7;
}

uint64_t sub_1BB9C2F24(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, long long *a5, uint64_t a6, uint64_t a7)
{
  VTVideoEncoderGetCMBaseObject();
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(DerivedStorage + 64), 0xFFFFFFFFFFFFFFFFLL);
  if (*(unsigned char *)(DerivedStorage + 25) || (uint64_t v14 = sub_1BB9C30EC(DerivedStorage), !v14))
  {
    uint64_t v14 = *(void *)(DerivedStorage + 8);
    if (v14)
    {
      long long v21 = *a4;
      uint64_t v22 = *((void *)a4 + 2);
      long long v19 = *a5;
      uint64_t v20 = *((void *)a5 + 2);
      uint64_t v15 = *(void *)(CMBaseObjectGetVTable() + 16);
      if (v15) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = 0;
      }
      uint64_t v17 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint8_t *, long long *, uint64_t, uint64_t))(v16 + 16);
      if (v17 && (*(_OWORD *)buf = v21, v26 = v22, long long v23 = v19, v24 = v20, !v17(v14, a2, a3, buf, &v23, a6, a7)))
      {
        uint64_t v14 = 0;
      }
      else
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "PT: No real codec!!\n", buf, 2u);
        }
        uint64_t v14 = 4294954514;
      }
    }
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 64));
  return v14;
}

uint64_t sub_1BB9C30EC(uint64_t a1)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  int v1 = (void *)(a1 + 8);
  if (*(void *)(a1 + 8)) {
    return 0;
  }
  size_t v36 = 4;
  uint64_t valuePtr = 0;
  sysctlbyname("hw.cpufamily", &valuePtr, &v36, 0, 0);
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)a1, (const void *)*MEMORY[0x1E4F44B68]);
  if (Value)
  {
    CFNumberRef v5 = Value;
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v5)) {
      CFNumberGetValue(v5, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    }
  }
  LODWORD(valuePtr) = 1176831186;
  if (HIDWORD(valuePtr) <= 0x2B)
  {
    if (((1 << SBYTE4(valuePtr)) & 0xC8000000002) != 0)
    {
      int v7 = *(_DWORD *)(a1 + 48);
      if (v7 == 1684632424 || v7 == 1752589105 || v7 == 1718908520)
      {
        uint64_t Instance = sub_1BB9F0754(1718908520, *(void *)(a1 + 16), v1);
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_34;
        }
        int v8 = HIDWORD(valuePtr);
        if (qword_1EC027190 == -1) {
          goto LABEL_13;
        }
        goto LABEL_99;
      }
      if (HIDWORD(valuePtr) == 43)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          int v39 = 43;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PT: TrafficLight usage (%d) only supported in HEVC\n", buf, 8u);
        }
        return 4294954381;
      }
      if (qword_1EC027190 != -1) {
        dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
      }
      if ((dword_1EC02719C - 7) >= 0xB)
      {
        if (dword_1EC02719C == 6)
        {
          uint64_t Instance = H264VideoEncoder_CreateInstance(1718908515, *(void *)(a1 + 16), v1);
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
          {
            int v32 = HIDWORD(valuePtr);
            if (qword_1EC027190 != -1) {
              dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
            }
            *(_DWORD *)buf = 67109376;
            int v39 = v32;
            __int16 v40 = 1024;
            *(_DWORD *)int v41 = dword_1EC02719C;
            uint64_t v9 = MEMORY[0x1E4F14500];
            long long v10 = "PT: Usage = %d, use 'ftvc' codec with VCP_H264_Legacy path,                                           "
                  "              device type = %d\n";
            goto LABEL_33;
          }
          goto LABEL_34;
        }
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PT: Unknown device type\n", buf, 2u);
        }
      }
      CFStringRef v19 = (const __CFString *)CFPreferencesCopyAppValue(@"ForceBaroloDoupi", @"com.apple.VideoProcessing");
      CFStringRef v20 = v19;
      if (v19 && CFEqual(v19, @"1"))
      {
        uint64_t Instance = H264VideoEncoder_CreateInstance(1718908515, *(void *)(a1 + 16), v1);
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          int v27 = HIDWORD(valuePtr);
          if (qword_1EC027190 != -1)
          {
            int v35 = HIDWORD(valuePtr);
            dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
            int v27 = v35;
          }
          *(_DWORD *)buf = 67109376;
          int v39 = v27;
          __int16 v40 = 1024;
          *(_DWORD *)int v41 = dword_1EC02719C;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PT: Usage = %d, use 'ftvc' codec with VCP_H264_Legacy path,                                                            device type = %d\n", buf, 0xEu);
        }
        goto LABEL_50;
      }
      uint64_t Instance = sub_1BB9F0754(1718908515, *(void *)(a1 + 16), v1);
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int v21 = HIDWORD(valuePtr);
        if (qword_1EC027190 != -1)
        {
          int v34 = HIDWORD(valuePtr);
          dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
          int v21 = v34;
        }
        *(_DWORD *)buf = 67109376;
        int v39 = v21;
        __int16 v40 = 1024;
        *(_DWORD *)int v41 = dword_1EC02719C;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PT: Usage = %d, use 'ftvc' codec with VCP_H264 path,                                                             device type = %d\n", buf, 0xEu);
      }
      if (v20) {
LABEL_50:
      }
        CFRelease(v20);
LABEL_34:
      if (Instance)
      {
LABEL_35:
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
LABEL_38:
          *int v1 = 0;
          return Instance;
        }
        *(_DWORD *)buf = 67109120;
        int v39 = Instance;
        uint64_t v15 = MEMORY[0x1E4F14500];
        uint64_t v16 = "PT: Error %d opening real codec!\n";
        uint32_t v17 = 8;
LABEL_37:
        _os_log_impl(&dword_1BB9B9000, v15, OS_LOG_TYPE_DEFAULT, v16, buf, v17);
        goto LABEL_38;
      }
      goto LABEL_93;
    }
    if (((1 << SBYTE4(valuePtr)) & 0x4000100000) != 0)
    {
      int v11 = *(_DWORD *)(a1 + 48);
      if (v11 != 1684632424 && v11 != 1752589105 && v11 != 1718908520)
      {
        uint64_t Instance = H264VideoEncoder_CreateInstance(1718908515, *(void *)(a1 + 16), v1);
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_34;
        }
        int v14 = HIDWORD(valuePtr);
        if (qword_1EC027190 != -1) {
          dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
        }
        *(_DWORD *)buf = 67109376;
        int v39 = v14;
        __int16 v40 = 1024;
        *(_DWORD *)int v41 = dword_1EC02719C;
        uint64_t v9 = MEMORY[0x1E4F14500];
        long long v10 = "PT: Usage = %d, use 'ftvc' codec with VCP_H264_Legacy path,                                               "
              "  device type = %d\n";
        goto LABEL_33;
      }
      uint64_t Instance = sub_1BB9F0754(1718908520, *(void *)(a1 + 16), v1);
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      int v8 = HIDWORD(valuePtr);
      if (qword_1EC027190 == -1) {
        goto LABEL_13;
      }
LABEL_99:
      dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
LABEL_13:
      *(_DWORD *)buf = 67109376;
      int v39 = v8;
      __int16 v40 = 1024;
      *(_DWORD *)int v41 = dword_1EC02719C;
      uint64_t v9 = MEMORY[0x1E4F14500];
      long long v10 = "PT: Usage = %d, use 'ftvh' codec with VCP_HEVC path,                                                 device type = %d\n";
LABEL_33:
      _os_log_impl(&dword_1BB9B9000, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 0xEu);
      goto LABEL_34;
    }
  }
  int v12 = *(_DWORD *)(a1 + 48);
  if (v12 == 1684632424 || v12 == 1752589105 || v12 == 1718908520) {
    uint64_t v13 = @"com.apple.videotoolbox.videoencoder.hevc";
  }
  else {
    uint64_t v13 = @"com.apple.videotoolbox.videoencoder.h264";
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    long long v23 = Mutable;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F45620], v13);
    int v24 = sub_1BB9C2D84();
    int v25 = *(_DWORD *)(a1 + 48);
    if (v24)
    {
      if (v25 == 1684632424 || v25 == 1752589105 || v25 == 1718908520) {
        VideoEncoderuint64_t Instance = VTVPParavirtualizedHEVCVideoEncoder_CreateInstance();
      }
      else {
        VideoEncoderuint64_t Instance = VTVPParavirtualizedH264VideoEncoder_CreateInstance();
      }
    }
    else
    {
      VideoEncoderuint64_t Instance = VTSelectAndCreateVideoEncoderInstance();
    }
    uint64_t Instance = VideoEncoderInstance;
    CFRelease(v23);
    if (!Instance)
    {
      if (*v1)
      {
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
LABEL_94:
          uint64_t Instance = sub_1BB9C3BD4(a1);
          if (Instance)
          {
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              int v39 = Instance;
              _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PT: Error %d starting real codec!\n", buf, 8u);
            }
          }
          else
          {
            CFDictionaryApplyFunction(*(CFDictionaryRef *)a1, (CFDictionaryApplierFunction)sub_1BB9C3CCC, (void *)a1);
          }
          return Instance;
        }
        int v30 = *(_DWORD *)(a1 + 48);
        if (v30 == 1684632424 || v30 == 1752589105 || v30 == 1718908520) {
          uint64_t v31 = "hvc1";
        }
        else {
          uint64_t v31 = "avc1";
        }
        int v33 = HIDWORD(valuePtr);
        if (qword_1EC027190 != -1) {
          dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
        }
        *(_DWORD *)buf = 67109634;
        int v39 = v33;
        __int16 v40 = 2080;
        *(void *)int v41 = v31;
        *(_WORD *)&v41[8] = 1024;
        *(_DWORD *)&v41[10] = dword_1EC02719C;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PT: Usage = %d, passthrough to '%s' codec, device type = %d\n", buf, 0x18u);
LABEL_93:
        if (!*v1)
        {
          uint64_t Instance = 4294954510;
          goto LABEL_35;
        }
        goto LABEL_94;
      }
      uint64_t Instance = 4294954510;
    }
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_38;
    }
    int v28 = *(_DWORD *)(a1 + 48);
    if (v28 == 1684632424 || v28 == 1752589105 || v28 == 1718908520) {
      unint64_t v29 = "hvc1";
    }
    else {
      unint64_t v29 = "avc1";
    }
    *(_DWORD *)buf = 67109634;
    int v39 = HIDWORD(valuePtr);
    __int16 v40 = 1024;
    *(_DWORD *)int v41 = Instance;
    *(_WORD *)&v41[4] = 2080;
    *(void *)&v41[6] = v29;
    uint64_t v15 = MEMORY[0x1E4F14500];
    uint64_t v16 = "PT: Usage = %d, Error %d opening real passthrough %s' codec!\n";
    uint32_t v17 = 24;
    goto LABEL_37;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PT: OpenActualCodec() failed to create encoderSpecification\n", buf, 2u);
  }
  return 4294954510;
}

uint64_t sub_1BB9C3BD4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 25)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 8);
  if (!v9) {
    return 4294954514;
  }
  uint64_t result = v9(v3, v4, v5, v6);
  if (!result) {
    *(unsigned char *)(a1 + 25) = 1;
  }
  return result;
}

void sub_1BB9C3CCC(const void *a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef theDict = 0;
  uint64_t v5 = *(void *)(a3 + 8);
  uint64_t v6 = *(void *)(CMBaseObjectGetVTable() + 16);
  if (v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(void (**)(uint64_t, CFDictionaryRef *))(v7 + 32);
  if (v8)
  {
    v8(v5, &theDict);
    if (theDict)
    {
      if (CFDictionaryContainsKey(theDict, a1))
      {
        uint64_t CMBaseObject = VTVideoEncoderGetCMBaseObject();
        uint64_t v10 = *(void *)(CMBaseObjectGetVTable() + 8);
        if (v10) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = 0;
        }
        int v12 = *(void (**)(uint64_t, const void *, uint64_t))(v11 + 56);
        if (v12) {
          v12(CMBaseObject, a1, a2);
        }
      }
      if (theDict) {
        CFRelease(theDict);
      }
    }
  }
}

uint64_t sub_1BB9C3E40(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  VTVideoEncoderGetCMBaseObject();
  uint64_t DerivedStorage = (void *)CMBaseObjectGetDerivedStorage();
  DerivedStorage[4] = a2;
  DerivedStorage[5] = a3;
  DerivedStorage[7] = a4;
  if (a4) {
    CFRetain(a4);
  }

  return sub_1BB9C3BD4((uint64_t)DerivedStorage);
}

uint64_t sub_1BB9C3EA4()
{
  if (!*(void *)(CMBaseObjectGetDerivedStorage() + 8)) {
    return 4294954514;
  }
  uint64_t CMBaseObject = VTVideoEncoderGetCMBaseObject();
  uint64_t v1 = *(void *)(CMBaseObjectGetVTable() + 8);
  uint64_t v2 = v1 ? (void *)v1 : 0;
  if (*v2 < 2uLL) {
    return 4294954514;
  }
  uint64_t v3 = (uint64_t (*)(uint64_t))v2[8];
  if (!v3) {
    return 4294954514;
  }

  return v3(CMBaseObject);
}

uint64_t sub_1BB9C3F78(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  sub_1BBAA99BC(Mutable, a3);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(const void **)(DerivedStorage + 8);
    int v15 = 134218498;
    uint64_t v16 = v7;
    __int16 v17 = 2112;
    uint64_t v18 = a2;
    __int16 v19 = 2114;
    CFStringRef v20 = Mutable;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PT (%p): Encoder got %@ property = %{public}@\n", (uint8_t *)&v15, 0x20u);
  }
  CFRelease(Mutable);
  if (*(void *)(DerivedStorage + 8))
  {
    uint64_t CMBaseObject = VTVideoEncoderGetCMBaseObject();
    uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    int v14 = *(uint64_t (**)(uint64_t, const void *, const void *))(v10 + 56);
    if (v14) {
      return v14(CMBaseObject, a2, a3);
    }
    return 4294954514;
  }
  if (!*(void *)DerivedStorage) {
    return 4294954514;
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)DerivedStorage, a2, a3);
  int v11 = CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44B68]);
  uint64_t result = 0;
  if (a3 && v11)
  {
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(a3))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int v15 = 138412290;
        uint64_t v16 = a3;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PT: Got usage property: %@\n", (uint8_t *)&v15, 0xCu);
      }
      sub_1BB9C30EC(DerivedStorage);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1BB9C41B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(void *)(CMBaseObjectGetDerivedStorage() + 8)) {
    return 4294954514;
  }
  uint64_t CMBaseObject = VTVideoEncoderGetCMBaseObject();
  uint64_t v8 = *(void *)(CMBaseObjectGetVTable() + 8);
  uint64_t v9 = v8 ? v8 : 0;
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 48);
  if (!v10) {
    return 4294954514;
  }

  return v10(CMBaseObject, a2, a3, a4);
}

uint64_t sub_1BB9C42A4(uint64_t a1)
{
  if (*(void *)(CMBaseObjectGetDerivedStorage() + 8)
    && ((VTVideoEncoderGetCMBaseObject(), (uint64_t v2 = *(void *)(CMBaseObjectGetVTable() + 8)) == 0) ? (v3 = 0) : (v3 = v2),
        *(void *)(v3 + 40)))
  {
    uint64_t v7 = *(uint64_t (**)(uint64_t))(v3 + 40);
    uint64_t CMBaseObject = VTVideoEncoderGetCMBaseObject();
    return v7(CMBaseObject);
  }
  else
  {
    CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    CFStringAppendFormat(Mutable, 0, @"<PassthroughEncoder %p>", a1);
    return (uint64_t)Mutable;
  }
}

uint64_t sub_1BB9C43B8(uint64_t a1)
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!DerivedStorage) {
    return 0;
  }
  uint64_t v3 = DerivedStorage;
  if (*(unsigned char *)(DerivedStorage + 24)) {
    return 0;
  }
  long long v15 = *MEMORY[0x1E4F1F9F8];
  uint64_t v16 = *(void *)(MEMORY[0x1E4F1F9F8] + 16);
  uint64_t v4 = sub_1BB9C2E08(a1, &v15);
  uint64_t v6 = *(NSObject **)(v3 + 64);
  if (v6) {
    dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
  }
  if (*(void *)(v3 + 8))
  {
    uint64_t CMBaseObject = VTVideoEncoderGetCMBaseObject();
    if (CMBaseObject)
    {
      uint64_t v8 = CMBaseObject;
      uint64_t v9 = *(void *)(CMBaseObjectGetVTable() + 8);
      if (v9) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = 0;
      }
      int v11 = *(uint64_t (**)(uint64_t))(v10 + 24);
      if (v11) {
        uint64_t v4 = v11(v8);
      }
      else {
        uint64_t v4 = 4294954514;
      }
    }
    else
    {
      uint64_t v4 = 4294954516;
    }
    CFRelease(*(CFTypeRef *)(v3 + 8));
    *(void *)(v3 + 8) = 0;
  }
  int v12 = *(const void **)(v3 + 16);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(v3 + 16) = 0;
  }
  uint64_t v13 = *(const void **)(v3 + 56);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(v3 + 56) = 0;
  }
  if (*(void *)v3)
  {
    CFRelease(*(CFTypeRef *)v3);
    *(void *)uint64_t v3 = 0;
  }
  *(unsigned char *)(v3 + 24) = 1;
  int v14 = *(NSObject **)(v3 + 64);
  if (v14)
  {
    dispatch_semaphore_signal(v14);
    dispatch_release(*(dispatch_object_t *)(v3 + 64));
  }
  return v4;
}

uint64_t sub_1BB9C4534(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(CMBaseObjectGetDerivedStorage() + 8)) {
    return 0;
  }
  VTVideoEncoderGetCMBaseObject();
  uint64_t v3 = *(void *)(CMBaseObjectGetVTable() + 8);
  uint64_t v4 = v3 ? v3 : 0;
  if (!*(void *)(v4 + 16)) {
    return 0;
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 16);
  uint64_t CMBaseObject = VTVideoEncoderGetCMBaseObject();

  return v7(CMBaseObject, a2);
}

void sub_1BB9C461C(int a1, int a2, const void *a3, int a4)
{
  int valuePtr = a2;
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (v7)
  {
    CFNumberRef v8 = v7;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (Mutable)
    {
      uint64_t v10 = Mutable;
      CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F45688], v8);
      CFDictionaryAddValue(v10, (const void *)*MEMORY[0x1E4F45678], (const void *)*MEMORY[0x1E4F1CFD0]);
      if (a3) {
        CFDictionaryAddValue(v10, @"CMClassImplementationID", a3);
      }
      if ((a1 == 1752589105 || a1 == 1635148593) && a4 != -1) {
        CFDictionaryAddValue(v10, (const void *)*MEMORY[0x1E4F45680], (const void *)*MEMORY[0x1E4F1CFC8]);
      }
      VTRegisterVideoEncoderWithInfo();
      CFRelease(v10);
    }
    CFRelease(v8);
  }
}

void VCPRegisterDecoders()
{
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1E9F81550, memory_order_acquire) != -1)
  {
    uint64_t v2 = &v0;
    uint64_t v1 = &v2;
    std::__call_once(&qword_1E9F81550, &v1, (void (__cdecl *)(void *))nullsub_1);
  }
}

const void **sub_1BB9C4888(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_1BB9C4F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1BB9C50DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9C14A0((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1BB9C5774(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1BB9BE228((const void **)va);
  sub_1BB9BE228((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_1BB9C57D0(const void **a1, const void **a2)
{
  uint64_t v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = *a2;
  *a2 = 0;
  return a1;
}

void sub_1BB9C5814(__CFDictionary *a1, const void *a2)
{
  uint64_t valuePtr = 7;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  if (v4)
  {
    CFNumberRef v5 = v4;
    CFDictionarySetValue(a1, a2, v4);
    CFRelease(v5);
  }
}

void sub_1BB9C5B4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9C5B5C(uint64_t a1, __CVBuffer *a2, CVPixelBufferRef *a3)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v7 = (void *)MEMORY[0x1C1860C30]();
    id v8 = *(id *)(a1 + 16);
    if ([v8 configureSession:CVPixelBufferGetIOSurface(a2) setWidth:*(unsigned int *)(a1 + 8) setHeight:*(unsigned int *)(a1 + 12)])
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v21 = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Unable to configure light spill session", v21, 2u);
      }

      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v21 = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Unable to initialize textures", v21, 2u);
      }
      return 4294940771;
    }

    *(unsigned char *)(a1 + 24) = 1;
    CFStringRef v15 = (const __CFString *)CFPreferencesCopyAppValue(@"EnableSpillmapLogging", @"com.apple.VideoProcessing");
    *(void *)uint64_t v21 = v15;
    if (v15)
    {
      *(unsigned char *)(a1 + 32) = CFStringGetIntValue(v15) != 0;
      CVPixelBufferGetIOSurface(a2);
      if (IOSurfaceGetProtectionOptions())
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Light spill dumping is enabled from defaults write but deactivated due to content protection", buf, 2u);
        }
        *(unsigned char *)(a1 + 32) = 0;
      }
      else if (*(unsigned char *)(a1 + 32))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Light spill dumping is enabled and activated for this unprotected content", buf, 2u);
        }
        id v16 = objc_alloc_init(MEMORY[0x1E4F28C10]);
        [v16 setDateFormat:@"yyyy-MM-dd-HH-mm-ss"];
        __int16 v17 = [MEMORY[0x1E4F1C9C8] date];
        uint64_t v18 = [v16 stringFromDate:v17];

        id v19 = [NSString stringWithFormat:@"/tmp/vcpls_dump_%dx%d_%@.bgra", *(unsigned int *)(a1 + 8), *(unsigned int *)(a1 + 12), v18];
        *(void *)(a1 + 40) = fopen((const char *)[v19 UTF8String], "wb");
      }
    }
    sub_1BB9BE158((const void **)v21);
  }
  uint64_t v6 = (void *)MEMORY[0x1C1860C30]();
  if ([*(id *)(a1 + 16) calculateDrmSpillmapMetal:a2 emitSpillmap:a3 setLayout:*(unsigned int *)(a1 + 28)])
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v21 = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Unable to compute light spill", v21, 2u);
    }
    return 4294940771;
  }
  if (*(unsigned char *)(a1 + 32))
  {
    CVPixelBufferLockBaseAddress(*a3, 1uLL);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(*a3);
    size_t Width = CVPixelBufferGetWidth(*a3);
    size_t Height = CVPixelBufferGetHeight(*a3);
    size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(*a3, 0);
    if (Height)
    {
      size_t v14 = BytesPerRowOfPlane;
      do
      {
        fwrite(BaseAddress, 4uLL, Width, *(FILE **)(a1 + 40));
        BaseAddress += v14;
        --Height;
      }
      while (Height);
    }
    fflush(*(FILE **)(a1 + 40));
    CVPixelBufferUnlockBaseAddress(*a3, 1uLL);
  }
  return 0;
}

void sub_1BB9C5EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  sub_1BB9BE158((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9C5F48(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x1C1860C30]();
  CFNumberRef v4 = (void **)(a1 + 16);
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3
    || (uint64_t v15 = objc_opt_new(),
        sub_1BB9C6038((const void **)(a1 + 16), (const void **)&v15),
        sub_1BB9C607C((const void **)&v15),
        (uint64_t v3 = *v4) != 0))
  {
    unsigned int v5 = *(_DWORD *)(a1 + 48);
    unsigned int v6 = *(_DWORD *)(a1 + 52);
    unsigned int v7 = *(_DWORD *)(a1 + 8);
    unsigned int v8 = *(_DWORD *)(a1 + 12);
    if ((int)v5 <= (int)v7) {
      uint64_t v9 = v7;
    }
    else {
      uint64_t v9 = v5;
    }
    if ((int)v6 <= (int)v8) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = v6;
    }
    double v11 = *(double *)(a1 + 56);
    *(float *)&double v11 = v11;
    uint64_t v12 = [v3 configureIntermediateTextureProcessing:v9 setHeight:v10 setSigma:v11];
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)size_t v14 = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Unable to initialize VCPSpillmap metal session", v14, 2u);
    }
    uint64_t v12 = 4294966630;
  }
  return v12;
}

const void **sub_1BB9C6038(const void **a1, const void **a2)
{
  CFNumberRef v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = *a2;
  *a2 = 0;
  return a1;
}

const void **sub_1BB9C607C(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_1BB9C60B0(uint64_t a1)
{
  sub_1BB9C60E8(a1);

  JUMPOUT(0x1C18605E0);
}

uint64_t sub_1BB9C60E8(uint64_t a1)
{
  *(void *)a1 = &unk_1F14EE1C8;
  uint64_t v2 = *(FILE **)(a1 + 40);
  if (v2)
  {
    fclose(v2);
    *(void *)(a1 + 40) = 0;
  }
  sub_1BB9C607C((const void **)(a1 + 16));
  return a1;
}

uint64_t sub_1BB9C6144(uint64_t a1, const __CFString *cf)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFStringGetTypeID())
  {
    unsigned int v5 = *(const void **)(a1 + 24);
    if (v5) {
      CFRelease(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 24) = CFRetain(cf);
    *(_DWORD *)(a1 + 32) = 0;
    unsigned int v7 = (CFTypeRef *)MEMORY[0x1E4F44F98];
    unsigned int v8 = &qword_1E62470E0;
    while (!CFEqual(cf, *v7))
    {
      ++v6;
      uint64_t v9 = (CFTypeRef *)*v8;
      v8 += 3;
      unsigned int v7 = v9;
      if (!v9)
      {
        if (*(_DWORD *)(a1 + 32)) {
          return 0;
        }
        goto LABEL_19;
      }
    }
    double v11 = (char *)&unk_1E62470C8 + 24 * v6;
    int v12 = *((_DWORD *)v11 + 4);
    *(_DWORD *)(a1 + 32) = v12;
    if (!v12)
    {
LABEL_19:
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = *(void *)(a1 + 2536);
        int v20 = *(_DWORD *)(a1 + 212);
        int v19 = *(_DWORD *)(a1 + 216);
        int v21 = 134218754;
        uint64_t v22 = v18;
        __int16 v23 = 1024;
        int v24 = v20;
        __int16 v25 = 1024;
        int v26 = v19;
        __int16 v27 = 2080;
        CStringPtr = CFStringGetCStringPtr(cf, 0x8000100u);
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): Unsupported entropy coding mode %s\n", (uint8_t *)&v21, 0x22u);
      }
      return 4294954394;
    }
    uint64_t v13 = (const char *)*((void *)v11 + 1);
    if (!v13) {
      return 0;
    }
    BOOL v14 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v14)
    {
      uint64_t v15 = *(void *)(a1 + 2536);
      int v16 = *(_DWORD *)(a1 + 212);
      int v17 = *(_DWORD *)(a1 + 216);
      int v21 = 134218754;
      uint64_t v22 = v15;
      __int16 v23 = 1024;
      int v24 = v16;
      __int16 v25 = 1024;
      int v26 = v17;
      __int16 v27 = 2080;
      CStringPtr = v13;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): entropy mode: %s\n", (uint8_t *)&v21, 0x22u);
      return 0;
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Entropy coding argument not a string\n", (uint8_t *)&v21, 2u);
    }
    return 4294954394;
  }
  return result;
}

uint64_t sub_1BB9C6390(uint64_t a1, const __CFString *cf)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID())
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Profile argument not a string\n", (uint8_t *)&v19, 2u);
    }
    return 4294954394;
  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
  *(void *)a1 = CFRetain(cf);
  if (*(_DWORD *)(a1 + 208) == 1752589105) {
    unsigned int v5 = (CFTypeRef **)&unk_1E62470F8;
  }
  else {
    unsigned int v5 = (CFTypeRef **)&unk_1E62471D0;
  }
  uint64_t v6 = *v5;
  if (*v5)
  {
    uint64_t v7 = 0;
    unsigned int v8 = v5 + 3;
    while (!CFEqual(cf, *v6))
    {
      ++v7;
      uint64_t v9 = *v8;
      v8 += 3;
      uint64_t v6 = v9;
      if (!v9) {
        goto LABEL_17;
      }
    }
    double v11 = &v5[3 * v7];
    *(void *)(a1 + 16) = v11[2];
    *(void *)(a1 + 8) = v11[1];
  }
LABEL_17:
  if (!*(_DWORD *)(a1 + 16))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(void *)(a1 + 2536);
      int v18 = *(_DWORD *)(a1 + 212);
      int v17 = *(_DWORD *)(a1 + 216);
      int v19 = 134218754;
      uint64_t v20 = v16;
      __int16 v21 = 1024;
      int v22 = v18;
      __int16 v23 = 1024;
      int v24 = v17;
      __int16 v25 = 2080;
      CStringPtr = CFStringGetCStringPtr(cf, 0x8000100u);
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): Unsupported profile %s\n", (uint8_t *)&v19, 0x22u);
    }
    return 4294954394;
  }
  int v12 = *(const char **)(a1 + 8);
  if (v12)
  {
    uint64_t result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    uint64_t v13 = *(void *)(a1 + 2536);
    int v14 = *(_DWORD *)(a1 + 212);
    int v15 = *(_DWORD *)(a1 + 216);
    int v19 = 134218754;
    uint64_t v20 = v13;
    __int16 v21 = 1024;
    int v22 = v14;
    __int16 v23 = 1024;
    int v24 = v15;
    __int16 v25 = 2080;
    CStringPtr = v12;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "VCPRateControlSession (0x%llx) (%dx%d): profile level: %s\n", (uint8_t *)&v19, 0x22u);
  }
  return 0;
}

uint64_t sub_1BB9C65F4(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  CFStringRef v28 = a2;
  uint64_t v6 = sub_1BB9C6924(*(void **)(a1 + 2544), (CFTypeRef *)&v28);
  BOOL v7 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
  if (!v6)
  {
    if (v7)
    {
      uint64_t v19 = *(void *)(a1 + 2536);
      int v20 = *(_DWORD *)(a1 + 212);
      int v21 = *(_DWORD *)(a1 + 216);
      *(_DWORD *)buf = 134218496;
      uint64_t v30 = v19;
      __int16 v31 = 1024;
      int v32 = v20;
      __int16 v33 = 1024;
      int v34 = v21;
      uint64_t v16 = MEMORY[0x1E4F14500];
      int v17 = "VCPRateControlSession (0x%llx) (%dx%d): unrecognised property key";
      uint32_t v18 = 24;
      goto LABEL_10;
    }
    return 4294966630;
  }
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 2536);
    int v10 = *(_DWORD *)(a1 + 212);
    int v9 = *(_DWORD *)(a1 + 216);
    double v11 = sub_1BB9C6924(*(void **)(a1 + 2544), (CFTypeRef *)&v28);
    if (!v11) {
      goto LABEL_28;
    }
    int v12 = v11[4];
    *(_DWORD *)buf = 134219010;
    uint64_t v30 = v8;
    __int16 v31 = 1024;
    int v32 = v10;
    __int16 v33 = 1024;
    int v34 = v9;
    __int16 v35 = 2080;
    CFStringRef v36 = (const __CFString *)v12;
    __int16 v37 = 2112;
    CFStringRef v38 = a3;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): %s property = %@\n", buf, 0x2Cu);
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44B28]))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(a1 + 2536);
      int v14 = *(_DWORD *)(a1 + 212);
      int v15 = *(_DWORD *)(a1 + 216);
      *(_DWORD *)buf = 134218754;
      uint64_t v30 = v13;
      __int16 v31 = 1024;
      int v32 = v14;
      __int16 v33 = 1024;
      int v34 = v15;
      __int16 v35 = 2112;
      CFStringRef v36 = a2;
      uint64_t v16 = MEMORY[0x1E4F14500];
      int v17 = "VCPRateControlSession (0x%llx) (%dx%d): %@ is read-only";
      uint32_t v18 = 34;
LABEL_10:
      _os_log_impl(&dword_1BB9B9000, v16, OS_LOG_TYPE_DEFAULT, v17, buf, v18);
      return 4294966630;
    }
    return 4294966630;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44AA0]))
  {
    uint64_t v24 = sub_1BB9C6390(a1, a3);
  }
  else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44920]))
  {
    uint64_t v24 = sub_1BB9C6144(a1, a3);
  }
  else
  {
    uint64_t v24 = sub_1BB9C6A7C(a1, a2, a3);
  }
  uint64_t v22 = v24;
  if (!v24)
  {
    __int16 v25 = sub_1BB9C6924(*(void **)(a1 + 2544), (CFTypeRef *)&v28);
    if (v25)
    {
      *((unsigned char *)v25 + 48) = 1;
      goto LABEL_21;
    }
LABEL_28:
    sub_1BB9C6A20("unordered_map::at: key not found");
  }
LABEL_21:
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44810])
    || CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44830])
    || CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44820]))
  {
    uint64_t v26 = *(void *)(a1 + 2256);
    if (v26)
    {
      sub_1BBAC89D8(v26, (uint64_t *)"target_bitrate", (double)*(int *)(a1 + 76));
      double v27 = *(double *)(a1 + 48);
      if (v27 > 0.0 && v27 < 1.0) {
        sub_1BBAC89D8(*(void *)(a1 + 2256), (uint64_t *)"base_layer_target_bitrate", *(double *)(a1 + 56) * (double)*(int *)(a1 + 76));
      }
    }
  }
  return v22;
}

uint64_t **sub_1BB9C6924(void *a1, CFTypeRef *a2)
{
  CFHashCode v4 = CFHash(*a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  CFHashCode v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    CFHashCode v9 = v4;
    if (v4 >= *(void *)&v5) {
      CFHashCode v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    CFHashCode v9 = (*(void *)&v5 - 1) & v4;
  }
  int v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (uint64_t i = *v10; i; uint64_t i = (uint64_t **)*i)
  {
    unint64_t v12 = (unint64_t)i[1];
    if (v12 == v6)
    {
      if (CFEqual(i[2], *a2)) {
        return i;
      }
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
      }
      else
      {
        v12 &= *(void *)&v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

void sub_1BB9C6A20(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1BB9C6D8C(exception, a1);
  __cxa_throw(exception, (struct type_info *)&unk_1F14EDBC8, MEMORY[0x1E4FBA1D0]);
}

void sub_1BB9C6A68(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9C6A7C(uint64_t a1, CFStringRef theString, const void *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  CFTypeRef v24 = theString;
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  CFHashCode v6 = sub_1BB9C6924(*(void **)(a1 + 2544), &v24);
  if (!v6) {
    goto LABEL_35;
  }
  uint8x8_t v7 = v6[3];
  unint64_t v8 = sub_1BB9C6924(*(void **)(a1 + 2544), &v24);
  if (!v8) {
    goto LABEL_35;
  }
  if (!a3 || (CFHashCode v9 = (BOOL *)v8[5], (uint64_t *)CFGetTypeID(a3) != v7))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v26 = CStringPtr;
      uint32_t v18 = MEMORY[0x1E4F14500];
      uint64_t v19 = "(key '%s'): bad\n";
      goto LABEL_27;
    }
    return 4294967246;
  }
  if (v7 == (uint64_t *)CFNumberGetTypeID())
  {
    int v10 = sub_1BB9C6924(*(void **)(a1 + 2544), &v24);
    if (!v10) {
      goto LABEL_35;
    }
    CFNumberType v11 = (CFNumberType)v10[7];
    CFTypeID v12 = CFGetTypeID(a3);
    if (v12 == CFNumberGetTypeID() && CFNumberGetValue((CFNumberRef)a3, v11, v9))
    {
      uint64_t v13 = sub_1BB9C6924(*(void **)(a1 + 2544), &v24);
      if (v13)
      {
        CFNumberRef v14 = (const __CFNumber *)v13[8];
        if (!v14 || CFNumberCompare((CFNumberRef)a3, v14, 0) != kCFCompareLessThan) {
          return 0;
        }
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          return 4294967246;
        }
        *(_DWORD *)buf = 136315138;
        uint64_t v26 = CStringPtr;
        uint32_t v18 = MEMORY[0x1E4F14500];
        uint64_t v19 = "bad (key '%s') (out of range)\n";
        goto LABEL_27;
      }
LABEL_35:
      sub_1BB9C6A20("unordered_map::at: key not found");
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v26 = CStringPtr;
      uint32_t v18 = MEMORY[0x1E4F14500];
      uint64_t v19 = "(key '%s'): bad\n";
LABEL_27:
      _os_log_error_impl(&dword_1BB9B9000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0xCu);
      return 4294967246;
    }
    return 4294967246;
  }
  if (v7 == (uint64_t *)CFBooleanGetTypeID())
  {
    CFTypeID v16 = CFGetTypeID(a3);
    BOOL v17 = v16 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a3) != 0;
    uint64_t result = 0;
    BOOL *v9 = v17;
  }
  else if (v7 == (uint64_t *)CFStringGetTypeID() || v7 == (uint64_t *)CFDataGetTypeID())
  {
    if (*(void *)v9) {
      CFRelease(*(CFTypeRef *)v9);
    }
    CFTypeRef v20 = CFRetain(a3);
    uint64_t result = 0;
    *(void *)CFHashCode v9 = v20;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      int v21 = *(const char **)(a1 + 2536);
      int v22 = *(_DWORD *)(a1 + 212);
      int v23 = *(_DWORD *)(a1 + 216);
      *(_DWORD *)buf = 134218496;
      uint64_t v26 = v21;
      __int16 v27 = 1024;
      int v28 = v22;
      __int16 v29 = 1024;
      int v30 = v23;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): unsupported CFTypeID for SetCommonProperty()\n", buf, 0x18u);
    }
    return 4294940771;
  }
  return result;
}

std::logic_error *sub_1BB9C6D8C(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
  return result;
}

void sub_1BB9C6DC0(uint64_t a1, double a2)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  if (a2 <= 0.0) {
    return;
  }
  if (!a1)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
    uint8x16_t v65 = MEMORY[0x1E4F14500];
    int16x8_t v66 = "Empty callback refcon in VCPRateControlSessionStatsMonitorCallback()\n";
    uint32_t v67 = 2;
    goto LABEL_136;
  }
  uint64_t v4 = *(void *)(a1 + 2256);
  double v5 = *(double *)(a1 + 48);
  BOOL v6 = v5 < 1.0 && v5 > 0.0;
  CFHashCode v9 = *(void **)(v4 + 32);
  uint8x8_t v7 = (double *)(v4 + 32);
  unint64_t v8 = v9;
  if (!v9)
  {
    unint64_t v64 = 0;
    double v58 = 0.0;
    double v87 = 0.0;
    double v88 = 0.0;
    double v21 = 0.0;
    double v15 = 0.0;
LABEL_111:
    double v27 = 0.0;
    double v89 = 0.0;
    uint64_t v86 = 0;
    double v68 = 0.0;
    goto LABEL_114;
  }
  int v10 = v7;
  CFNumberType v11 = v8;
  do
  {
    unint64_t v12 = v11[4];
    BOOL v13 = v12 >= (unint64_t)"input_frames";
    if (v12 >= (unint64_t)"input_frames") {
      CFNumberRef v14 = v11;
    }
    else {
      CFNumberRef v14 = v11 + 1;
    }
    if (v13) {
      int v10 = (double *)v11;
    }
    CFNumberType v11 = (void *)*v14;
  }
  while (*v14);
  double v15 = 0.0;
  if (v10 != v7 && *((void *)v10 + 4) <= (unint64_t)"input_frames") {
    double v15 = v10[5];
  }
  if (!v8)
  {
    double v58 = 0.0;
    unint64_t v64 = 0;
    double v87 = 0.0;
    double v88 = 0.0;
    double v21 = 0.0;
    goto LABEL_111;
  }
  CFTypeID v16 = v7;
  BOOL v17 = v8;
  do
  {
    unint64_t v18 = v17[4];
    BOOL v19 = v18 >= (unint64_t)"encoded_frames";
    if (v18 >= (unint64_t)"encoded_frames") {
      CFTypeRef v20 = v17;
    }
    else {
      CFTypeRef v20 = v17 + 1;
    }
    if (v19) {
      CFTypeID v16 = (double *)v17;
    }
    BOOL v17 = (void *)*v20;
  }
  while (*v20);
  double v21 = 0.0;
  if (v16 != v7 && *((void *)v16 + 4) <= (unint64_t)"encoded_frames") {
    double v21 = v16[5];
  }
  int v22 = v7;
  int v23 = v8;
  do
  {
    unint64_t v24 = v23[4];
    BOOL v25 = v24 >= (unint64_t)"transmit_frames";
    if (v24 >= (unint64_t)"transmit_frames") {
      uint64_t v26 = v23;
    }
    else {
      uint64_t v26 = v23 + 1;
    }
    if (v25) {
      int v22 = (double *)v23;
    }
    int v23 = (void *)*v26;
  }
  while (*v26);
  double v27 = 0.0;
  if (v22 != v7 && *((void *)v22 + 4) <= (unint64_t)"transmit_frames") {
    double v27 = v22[5];
  }
  int v28 = v7;
  __int16 v29 = v8;
  do
  {
    unint64_t v30 = v29[4];
    BOOL v31 = v30 >= (unint64_t)"idr_frames";
    if (v30 >= (unint64_t)"idr_frames") {
      int v32 = v29;
    }
    else {
      int v32 = v29 + 1;
    }
    if (v31) {
      int v28 = (double *)v29;
    }
    __int16 v29 = (void *)*v32;
  }
  while (*v32);
  double v33 = 0.0;
  if (v28 != v7 && *((void *)v28 + 4) <= (unint64_t)"idr_frames") {
    double v33 = v28[5];
  }
  double v87 = v33;
  int v34 = v7;
  __int16 v35 = v8;
  do
  {
    unint64_t v36 = v35[4];
    BOOL v37 = v36 >= (unint64_t)"refresh_frames";
    if (v36 >= (unint64_t)"refresh_frames") {
      CFStringRef v38 = v35;
    }
    else {
      CFStringRef v38 = v35 + 1;
    }
    if (v37) {
      int v34 = (double *)v35;
    }
    __int16 v35 = (void *)*v38;
  }
  while (*v38);
  double v39 = 0.0;
  if (v34 != v7 && *((void *)v34 + 4) <= (unint64_t)"refresh_frames") {
    double v39 = v34[5];
  }
  double v89 = v39;
  __int16 v40 = v7;
  int v41 = v8;
  do
  {
    unint64_t v42 = v41[4];
    BOOL v43 = v42 >= (unint64_t)"encoded_bits";
    if (v42 >= (unint64_t)"encoded_bits") {
      int v44 = v41;
    }
    else {
      int v44 = v41 + 1;
    }
    if (v43) {
      __int16 v40 = (double *)v41;
    }
    int v41 = (void *)*v44;
  }
  while (*v44);
  double v45 = 0.0;
  if (v40 != v7 && *((void *)v40 + 4) <= (unint64_t)"encoded_bits") {
    double v45 = v40[5];
  }
  double v88 = v45;
  char v46 = v7;
  int v47 = v8;
  do
  {
    unint64_t v48 = v47[4];
    BOOL v49 = v48 >= (unint64_t)"target_bitrate";
    if (v48 >= (unint64_t)"target_bitrate") {
      int v50 = v47;
    }
    else {
      int v50 = v47 + 1;
    }
    if (v49) {
      char v46 = (double *)v47;
    }
    int v47 = (void *)*v50;
  }
  while (*v50);
  uint64_t v51 = 0;
  if (v46 != v7 && *((void *)v46 + 4) <= (unint64_t)"target_bitrate") {
    uint64_t v51 = *((void *)v46 + 5);
  }
  uint64_t v86 = v51;
  char v52 = v7;
  uint64_t v53 = v8;
  do
  {
    unint64_t v54 = v53[4];
    BOOL v55 = v54 >= (unint64_t)"base_layer_encoded_bits";
    if (v54 >= (unint64_t)"base_layer_encoded_bits") {
      int v56 = v53;
    }
    else {
      int v56 = v53 + 1;
    }
    if (v55) {
      char v52 = (double *)v53;
    }
    uint64_t v53 = (void *)*v56;
  }
  while (*v56);
  double v57 = 0.0;
  double v58 = 0.0;
  if (v52 != v7 && *((void *)v52 + 4) <= (unint64_t)"base_layer_encoded_bits") {
    double v58 = v52[5];
  }
  int v59 = v7;
  __int16 v60 = v8;
  do
  {
    unint64_t v61 = v60[4];
    BOOL v62 = v61 >= (unint64_t)"base_layer_target_bitrate";
    if (v61 >= (unint64_t)"base_layer_target_bitrate") {
      int v63 = v60;
    }
    else {
      int v63 = v60 + 1;
    }
    if (v62) {
      int v59 = (double *)v60;
    }
    __int16 v60 = (void *)*v63;
  }
  while (*v63);
  if (v59 == v7 || *((void *)v59 + 4) > (unint64_t)"base_layer_target_bitrate") {
    unint64_t v64 = 0;
  }
  else {
    unint64_t v64 = *((void *)v59 + 5);
  }
  v81 = v7;
  unsigned int v82 = v8;
  do
  {
    unint64_t v83 = v82[4];
    BOOL v84 = v83 >= (unint64_t)"encoding_time";
    if (v83 >= (unint64_t)"encoding_time") {
      CFTypeID v85 = v82;
    }
    else {
      CFTypeID v85 = v82 + 1;
    }
    if (v84) {
      v81 = (double *)v82;
    }
    unsigned int v82 = (void *)*v85;
  }
  while (*v85);
  if (v81 != v7 && *((void *)v81 + 4) <= (unint64_t)"encoding_time") {
    double v57 = v81[5];
  }
  double v68 = 0.0;
  if (v21 > 0.0) {
    double v68 = v57 / v21 * 1000.0;
  }
LABEL_114:
  double v69 = -1.0;
  if (v5 > 0.0 && v27 != 0.0)
  {
    double v70 = 0.0;
    if (v8)
    {
      uint8x16_t v71 = v7;
      do
      {
        unint64_t v72 = v8[4];
        BOOL v73 = v72 >= (unint64_t)"base_layer_frames";
        if (v72 >= (unint64_t)"base_layer_frames") {
          int16x8_t v74 = v8;
        }
        else {
          int16x8_t v74 = v8 + 1;
        }
        if (v73) {
          uint8x16_t v71 = (double *)v8;
        }
        unint64_t v8 = (void *)*v74;
      }
      while (*v74);
      if (v71 != v7 && *((void *)v71 + 4) <= (unint64_t)"base_layer_frames") {
        double v70 = v71[5];
      }
    }
    double v69 = v70 / v27;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v75 = *(void *)(a1 + 2536);
    int v76 = *(_DWORD *)(a1 + 212);
    int v77 = *(_DWORD *)(a1 + 216);
    double v78 = -1.0;
    if (v5 > 0.0) {
      double v78 = v69;
    }
    double v79 = v58 / a2;
    unint64_t v80 = 0xBFF0000000000000;
    if (v6) {
      unint64_t v80 = v64;
    }
    else {
      double v79 = -1.0;
    }
    *(_DWORD *)buf = 134221312;
    uint64_t v91 = v75;
    __int16 v92 = 1024;
    int v93 = v76;
    __int16 v94 = 1024;
    int v95 = v77;
    __int16 v96 = 2048;
    double v97 = v15 / a2;
    __int16 v98 = 2048;
    double v99 = v21 / a2;
    __int16 v100 = 2048;
    double v101 = v27 / a2;
    __int16 v102 = 2048;
    double v103 = v87 / a2;
    __int16 v104 = 2048;
    double v105 = v89 / a2;
    __int16 v106 = 2048;
    double v107 = v78;
    __int16 v108 = 2048;
    double v109 = v79;
    __int16 v110 = 2048;
    unint64_t v111 = v80;
    __int16 v112 = 2048;
    double v113 = v88 / a2;
    __int16 v114 = 2048;
    uint64_t v115 = v86;
    __int16 v116 = 2048;
    double v117 = v68;
    uint8x16_t v65 = MEMORY[0x1E4F14500];
    int16x8_t v66 = "VCPRateControlSession (0x%llx) (%dx%d): input_fps=%.2f, enc_fps=%.2f, tx_fps=%.2f, idr_fps=%.2f, refresh_fps=%"
          ".2f, baselayer_fraction=%.1f, bit_rate (video/target)=%.0f/%.0f, %.0f/%.0f, enc_time=%.2f ms";
    uint32_t v67 = 134;
LABEL_136:
    _os_log_impl(&dword_1BB9B9000, v65, OS_LOG_TYPE_DEFAULT, v66, buf, v67);
  }
}

void *sub_1BB9C740C(uint64_t a1)
{
  uint64_t v2 = *(const void **)a1;
  if (v2)
  {
    CFRelease(v2);
    *(void *)a1 = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 136);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 136) = 0;
  }
  double v5 = *(const void **)(a1 + 168);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 168) = 0;
  }
  BOOL v6 = *(const void **)(a1 + 184);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 184) = 0;
  }
  uint64_t v7 = *(void *)(a1 + 2544);
  if (v7)
  {
    unint64_t v8 = *(void **)(v7 + 16);
    if (v8)
    {
      do
      {
        CFHashCode v9 = (void *)*v8;
        operator delete(v8);
        unint64_t v8 = v9;
      }
      while (v9);
    }
    int v10 = *(void **)v7;
    *(void *)uint64_t v7 = 0;
    if (v10) {
      operator delete(v10);
    }
    MEMORY[0x1C18605E0](v7, 0x10A0C408EF24B1CLL);
    *(void *)(a1 + 2544) = 0;
  }
  uint64_t v11 = *(void *)(a1 + 2256);
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    *(void *)(a1 + 2256) = 0;
  }
  uint64_t v12 = *(void *)(a1 + 2264);
  if (v12)
  {
    MEMORY[0x1C18605E0](v12, 0x1060C405A861112);
    *(void *)(a1 + 2264) = 0;
  }
  uint64_t result = *(void **)(a1 + 2296);
  if (result)
  {
    CFNumberRef v14 = sub_1BBA5DC2C(result);
    uint64_t result = (void *)MEMORY[0x1C18605E0](v14, 0x10F0C407B2AA9F2);
    *(void *)(a1 + 2296) = 0;
  }
  return result;
}

void sub_1BB9C7544(float *a1, CFTypeRef *a2, uint64_t a3)
{
  CFHashCode v7 = CFHash(*a2);
  CFHashCode v8 = v7;
  unint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      CFHashCode v3 = v7;
      if (v7 >= v9) {
        CFHashCode v3 = v7 % v9;
      }
    }
    else
    {
      CFHashCode v3 = (v9 - 1) & v7;
    }
    uint64_t v12 = *(uint64_t ****)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v14 = (unint64_t)i[1];
        if (v14 == v8)
        {
          if (CFEqual(i[2], *a2)) {
            return;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  double v15 = operator new(0x48uLL);
  *double v15 = 0;
  v15[1] = v8;
  long long v16 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v15 + 1) = *(_OWORD *)a3;
  *((_OWORD *)v15 + 2) = v16;
  *((_OWORD *)v15 + 3) = *(_OWORD *)(a3 + 32);
  v15[8] = *(void *)(a3 + 48);
  float v17 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v18 = a1[8];
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      int8x8_t prime = (int8x8_t)v21;
    }
    else {
      int8x8_t prime = (int8x8_t)v20;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v9 = *((void *)a1 + 1);
    if (*(void *)&prime > v9) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v29 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v30.i16[0] = vaddlv_u8(v30), v30.u32[0] > 1uLL))
      {
        unint64_t v29 = std::__next_prime(v29);
      }
      else
      {
        uint64_t v31 = 1 << -(char)__clz(v29 - 1);
        if (v29 >= 2) {
          unint64_t v29 = v31;
        }
      }
      if (*(void *)&prime <= v29) {
        int8x8_t prime = (int8x8_t)v29;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            sub_1BB9C18AC();
          }
          int v23 = operator new(8 * *(void *)&prime);
          unint64_t v24 = *(void **)a1;
          *(void *)a1 = v23;
          if (v24) {
            operator delete(v24);
          }
          uint64_t v25 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v25++) = 0;
          while (*(void *)&prime != v25);
          uint64_t v26 = (void *)*((void *)a1 + 2);
          if (v26)
          {
            unint64_t v27 = v26[1];
            uint8x8_t v28 = (uint8x8_t)vcnt_s8(prime);
            v28.i16[0] = vaddlv_u8(v28);
            if (v28.u32[0] > 1uLL)
            {
              if (v27 >= *(void *)&prime) {
                v27 %= *(void *)&prime;
              }
            }
            else
            {
              v27 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v27) = a1 + 4;
            int v32 = (void *)*v26;
            if (*v26)
            {
              do
              {
                unint64_t v33 = v32[1];
                if (v28.u32[0] > 1uLL)
                {
                  if (v33 >= *(void *)&prime) {
                    v33 %= *(void *)&prime;
                  }
                }
                else
                {
                  v33 &= *(void *)&prime - 1;
                }
                if (v33 != v27)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v33))
                  {
                    *(void *)(*(void *)a1 + 8 * v33) = v26;
                    goto LABEL_55;
                  }
                  *uint64_t v26 = *v32;
                  *int v32 = **(void **)(*(void *)a1 + 8 * v33);
                  **(void **)(*(void *)a1 + 8 * v33) = v32;
                  int v32 = v26;
                }
                unint64_t v33 = v27;
LABEL_55:
                uint64_t v26 = v32;
                int v32 = (void *)*v32;
                unint64_t v27 = v33;
              }
              while (v32);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        BOOL v37 = *(void **)a1;
        *(void *)a1 = 0;
        if (v37) {
          operator delete(v37);
        }
        unint64_t v9 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        CFHashCode v3 = v8 % v9;
      }
      else {
        CFHashCode v3 = v8;
      }
    }
    else
    {
      CFHashCode v3 = (v9 - 1) & v8;
    }
  }
  int v34 = *(void **)a1;
  __int16 v35 = *(void **)(*(void *)a1 + 8 * v3);
  if (v35)
  {
    *double v15 = *v35;
LABEL_72:
    *__int16 v35 = v15;
    goto LABEL_73;
  }
  *double v15 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v15;
  v34[v3] = a1 + 4;
  if (*v15)
  {
    unint64_t v36 = *(void *)(*v15 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v36 >= v9) {
        v36 %= v9;
      }
    }
    else
    {
      v36 &= v9 - 1;
    }
    __int16 v35 = (void *)(*(void *)a1 + 8 * v36);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
}

void sub_1BB9C7948(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

CFDictionaryRef sub_1BB9C795C(uint64_t a1)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef v3 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v3)
  {
    CFDictionaryRef v4 = v3;
    int v5 = *(_DWORD *)(a1 + 208);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (!Mutable)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        LOWORD(keys[0]) = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "CFArrayCreate (CreateProfileLevelDict) failed!", (uint8_t *)keys, 2u);
      }
      CFDictionaryRef v11 = 0;
      goto LABEL_21;
    }
    CFHashCode v7 = Mutable;
    if (v5 == 1752589105)
    {
      uint64_t v12 = (const void **)MEMORY[0x1E4F452D0];
      uint64_t v13 = 0x18u;
      do
      {
        CFArrayAppendValue(v7, *v12);
        uint64_t v12 = *(const void ***)((char *)&unk_1E62470F8 + v13);
        v13 += 24;
      }
      while (v13 != 216);
    }
    else
    {
      if (v5 != 1635148593) {
        goto LABEL_19;
      }
      CFHashCode v8 = (const void **)MEMORY[0x1E4F45190];
      uint64_t v9 = 0x18u;
      do
      {
        CFArrayAppendValue(v7, *v8);
        CFHashCode v8 = *(const void ***)((char *)&unk_1E62471D0 + v9);
        v9 += 24;
      }
      while (v9 != 816);
    }
    unint64_t v14 = (void *)*MEMORY[0x1E4F45310];
    values = v7;
    keys[0] = v14;
    CFDictionaryRef v11 = CFDictionaryCreate(v2, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v11)
    {
LABEL_20:
      CFRelease(v7);
LABEL_21:
      double v15 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v15)
      {
        if (v11)
        {
          long long v16 = *(uint64_t ***)(*(void *)(a1 + 2544) + 16);
          if (v16)
          {
            float v17 = (const void *)*MEMORY[0x1E4F44AA0];
            do
            {
              if (CFEqual(v16[2], v17)) {
                CFDictionaryRef v18 = v11;
              }
              else {
                CFDictionaryRef v18 = v4;
              }
              CFDictionaryAddValue(v15, v16[2], v18);
              long long v16 = (uint64_t **)*v16;
            }
            while (v16);
          }
        }
        CFDictionaryRef Copy = CFDictionaryCreateCopy(v2, v15);
      }
      else
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          LOWORD(keys[0]) = 0;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "CFDictionaryCreate failed", (uint8_t *)keys, 2u);
        }
        CFDictionaryRef Copy = 0;
      }
      CFRelease(v4);
      if (v11) {
        CFRelease(v11);
      }
      if (v15) {
        CFRelease(v15);
      }
      return Copy;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(keys[0]) = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "CFDictionaryCreate (CreateProfileLevelDict) failed!", (uint8_t *)keys, 2u);
    }
LABEL_19:
    CFDictionaryRef v11 = 0;
    goto LABEL_20;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    LOWORD(keys[0]) = 0;
    _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "CFDictionaryCreate failed", (uint8_t *)keys, 2u);
  }
  return 0;
}

uint64_t sub_1BB9C7CA8(uint64_t a1, const void *a2, CFNumberRef *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  CFTypeRef v16 = a2;
  int v5 = sub_1BB9C6924(*(void **)(a1 + 2544), &v16);
  if (!v5) {
    goto LABEL_22;
  }
  BOOL v6 = v5[3];
  CFHashCode v7 = sub_1BB9C6924(*(void **)(a1 + 2544), &v16);
  if (!v7) {
    goto LABEL_22;
  }
  CFHashCode v8 = v7[5];
  *a3 = 0;
  if (v6 == (uint64_t *)CFNumberGetTypeID())
  {
    uint64_t v9 = sub_1BB9C6924(*(void **)(a1 + 2544), &v16);
    if (v9)
    {
      CFNumberRef v10 = CFNumberCreate(0, (CFNumberType)v9[7], v8);
LABEL_15:
      uint64_t result = 0;
LABEL_16:
      *a3 = v10;
      return result;
    }
LABEL_22:
    sub_1BB9C6A20("unordered_map::at: key not found");
  }
  if (v6 == (uint64_t *)CFBooleanGetTypeID())
  {
    uint64_t result = 0;
    if (*(unsigned char *)v8) {
      uint64_t v12 = (CFNumberRef *)MEMORY[0x1E4F1CFD0];
    }
    else {
      uint64_t v12 = (CFNumberRef *)MEMORY[0x1E4F1CFC8];
    }
    CFNumberRef v10 = *v12;
    goto LABEL_16;
  }
  if (v6 == (uint64_t *)CFStringGetTypeID()
    || v6 == (uint64_t *)CFDataGetTypeID()
    || v6 == (uint64_t *)CFDictionaryGetTypeID())
  {
    CFNumberRef v10 = (CFNumberRef)*v8;
    if (!*v8) {
      return 0;
    }
    goto LABEL_15;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = *(void *)(a1 + 2536);
    int v14 = *(_DWORD *)(a1 + 212);
    int v15 = *(_DWORD *)(a1 + 216);
    *(_DWORD *)buf = 134218496;
    uint64_t v18 = v13;
    __int16 v19 = 1024;
    int v20 = v14;
    __int16 v21 = 1024;
    int v22 = v15;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): unsupported CFTypeID for CopyCommonProperty()", buf, 0x18u);
  }
  return 4294940771;
}

uint64_t sub_1BB9C7E58(uint64_t a1, __CFDictionary *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 2544);
  if (v3)
  {
    CFDictionaryRef v4 = *(uint64_t **)(v3 + 16);
    if (v4)
    {
      BOOL v6 = (const void *)*MEMORY[0x1E4F44B28];
      CFHashCode v7 = MEMORY[0x1E4F14500];
      do
      {
        if (!CFEqual((CFTypeRef)v4[2], v6) && *((unsigned char *)v4 + 48))
        {
          CFHashCode v8 = (const void *)v4[2];
          value = 0;
          if (sub_1BB9C7CA8(a1, v8, (CFNumberRef *)&value)) {
            BOOL v9 = 1;
          }
          else {
            BOOL v9 = value == 0;
          }
          if (v9)
          {
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v10 = *(void *)(a1 + 2536);
              int v11 = *(_DWORD *)(a1 + 212);
              int v12 = *(_DWORD *)(a1 + 216);
              *(_DWORD *)buf = 134218754;
              uint64_t v16 = v10;
              __int16 v17 = 1024;
              int v18 = v11;
              __int16 v19 = 1024;
              int v20 = v12;
              __int16 v21 = 2112;
              int v22 = v8;
              _os_log_impl(&dword_1BB9B9000, v7, OS_LOG_TYPE_DEFAULT, "VCPRateControlSession (0x%llx) (%dx%d): failed to set property %@\n", buf, 0x22u);
            }
          }
          else
          {
            CFDictionarySetValue(a2, v8, value);
            *((unsigned char *)v4 + 48) = 0;
          }
        }
        CFDictionaryRef v4 = (uint64_t *)*v4;
      }
      while (v4);
    }
    return 0;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v16 = a1 + 256;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: empty property attributes\n", buf, 0xCu);
    }
    return 4294954392;
  }
}

BOOL sub_1BB9C8034(uint64_t a1, int a2, int a3, char a4, int a5, CMTime *a6, CMTime *a7)
{
  int v29 = a2;
  int v14 = (std::mutex *)(a1 + 208);
  std::mutex::lock((std::mutex *)(a1 + 208));
  int v15 = sub_1BB9C8230((uint64_t **)(a1 + 184), a2, &v29);
  uint64_t v16 = v15;
  if (!a3 || !a5 || (__int16 v17 = v15[9]) == 0 || (int)(*((double *)v17 + 1) + 0.5) > 16)
  {
    if (a3)
    {
      __int16 v19 = v15[9];
      if (v19)
      {
        BOOL v20 = (int)(*((double *)v19 + 1) + 0.5) > 16 || *((_DWORD *)v15 + 30) < 4;
        char v21 = v20;
        if (v20 || (a4 & 1) != 0)
        {
          if ((v21 & 1) == 0) {
            goto LABEL_20;
          }
        }
        else if (*((unsigned char *)v15 + 64))
        {
LABEL_20:
          int v22 = *((_DWORD *)v15 + 31);
          BOOL v18 = v22 < 1000;
          if (v22 < 1000) {
            int v23 = v22 + 1;
          }
          else {
            int v23 = 0;
          }
          *((_DWORD *)v15 + 31) = v23;
          goto LABEL_26;
        }
      }
    }
    BOOL v18 = 0;
    goto LABEL_26;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9F81590, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9F81590))
  {
    CMTimeMake((CMTime *)byte_1E9F81578, 1000, 1000);
    __cxa_guard_release(&qword_1E9F81590);
  }
  CMTime lhs = *a6;
  CMTime rhs = *a7;
  CMTimeSubtract(&time1, &lhs, &rhs);
  CMTime v25 = *(CMTime *)byte_1E9F81578;
  if (CMTimeCompare(&time1, &v25) > 0 || *((unsigned char *)v16 + 128))
  {
    BOOL v18 = 0;
    *((unsigned char *)v16 + 128) = 1;
  }
  else
  {
    *((unsigned char *)v16 + 128) = 0;
    BOOL v18 = 1;
  }
LABEL_26:
  std::mutex::unlock(v14);
  return v18;
}

void sub_1BB9C8204(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1E9F81590);
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t **sub_1BB9C8230(uint64_t **a1, int a2, _DWORD *a3)
{
  BOOL v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        CFHashCode v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        BOOL v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        BOOL v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    CFHashCode v7 = a1 + 1;
LABEL_9:
    BOOL v9 = (uint64_t *)v7;
    CFHashCode v7 = (uint64_t **)operator new(0x88uLL);
    *((_DWORD *)v7 + 8) = *a3;
    *((_OWORD *)v7 + 4) = 0u;
    *((_OWORD *)v7 + 5) = 0u;
    *((_OWORD *)v7 + 7) = 0u;
    *((_OWORD *)v7 + 6) = 0u;
    v7[16] = 0;
    v7[5] = (uint64_t *)(v7 + 5);
    v7[6] = (uint64_t *)(v7 + 5);
    v7[7] = 0;
    v7[9] = 0;
    v7[10] = 0;
    v7[11] = 0;
    v7[12] = (uint64_t *)(v7 + 12);
    v7[13] = (uint64_t *)(v7 + 12);
    *((_DWORD *)v7 + 30) = -1;
    *CFHashCode v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    const void *v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)v7;
    int v11 = (uint64_t *)**a1;
    if (v11)
    {
      *a1 = v11;
      uint64_t v10 = *v6;
    }
    sub_1BB9C8438(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_1BB9C8338(void *a1)
{
  if (a1[10])
  {
    CFAllocatorRef v2 = a1 + 8;
    uint64_t v3 = a1[8];
    CFDictionaryRef v4 = (uint64_t *)a1[9];
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = *(void *)(v3 + 8);
    **(void **)(v3 + 8) = v5;
    a1[10] = 0;
    if (v4 != a1 + 8)
    {
      do
      {
        BOOL v6 = (uint64_t *)v4[1];
        CFHashCode v7 = (std::__shared_weak_count *)v4[3];
        if (v7) {
          sub_1BB9C09B4(v7);
        }
        operator delete(v4);
        CFDictionaryRef v4 = v6;
      }
      while (v6 != v2);
    }
  }
  int v8 = (std::__shared_weak_count *)a1[6];
  if (v8) {
    sub_1BB9C09B4(v8);
  }

  return sub_1BB9C83D4(a1 + 1);
}

void *sub_1BB9C83D4(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        CFDictionaryRef v4 = (void *)result[1];
        operator delete(result);
        uint64_t result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

uint64_t *sub_1BB9C8438(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      CFDictionaryRef v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), uint64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            BOOL v9 = (uint64_t **)a2[2];
          }
          else
          {
            BOOL v9 = (uint64_t **)v2[1];
            uint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            uint64_t *v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), uint64_t v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *uint64_t v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void sub_1BB9C85D0(uint64_t a1, int a2, int a3, char a4, uint64_t a5, int a6, int a7, int a8)
{
  int v15 = (void *)a1;
  int v82 = a2;
  unint64_t v80 = (std::mutex *)(a1 + 208);
  std::mutex::lock((std::mutex *)(a1 + 208));
  uint64_t v16 = sub_1BB9C8230((uint64_t **)v15 + 23, a2, &v82);
  __int16 v17 = (char *)operator new(0x60uLL);
  *((void *)v17 + 1) = 0;
  *((void *)v17 + 2) = 0;
  *(_OWORD *)(v17 + 24) = 0u;
  double v79 = v17 + 24;
  *(void *)__int16 v17 = &unk_1F14EEC10;
  BOOL v18 = v17 + 40;
  *(_OWORD *)(v17 + 56) = 0u;
  __int16 v19 = (_OWORD *)MEMORY[0x1E4F1FA48];
  *((void *)v17 + 7) = *(void *)(MEMORY[0x1E4F1FA48] + 16);
  *(_OWORD *)(v17 + 40) = *v19;
  *((void *)v17 + 10) = 0;
  *((void *)v17 + 11) = 0;
  *((void *)v17 + 9) = 0;
  if ((a4 & 1) == 0)
  {
    BOOL v20 = v17;
    *((_DWORD *)v16 + 30) = -1;
    sub_1BB9C83D4(v16 + 5);
    __int16 v17 = v20;
    *((unsigned char *)v16 + 64) = 0;
  }
  *((_DWORD *)v17 + 6) = a3;
  v17[28] = a4;
  *(_OWORD *)BOOL v18 = *(_OWORD *)a5;
  *((void *)v18 + 2) = *(void *)(a5 + 16);
  unint64_t v21 = v15[15];
  uint64_t v22 = v15[12];
  if (v15[13] == v22)
  {
    uint64_t v28 = 0;
    uint64_t v26 = v15[16];
  }
  else
  {
    int v23 = (int **)(v22 + 8 * (v21 >> 10));
    unint64_t v24 = *v23;
    CMTime v25 = &(*v23)[v15[15] & 0x3FFLL];
    uint64_t v26 = v15[16];
    uint64_t v27 = *(void *)(v22 + (((v26 + v21) >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * ((v26 + v21) & 0x3FF);
    if (v25 == (int *)v27)
    {
      uint64_t v28 = 0;
    }
    else
    {
      LODWORD(v28) = 0;
      do
      {
        uint64_t v30 = *v25++;
        uint64_t v29 = v30;
        if ((char *)v25 - (char *)v24 == 4096)
        {
          uint64_t v31 = v23[1];
          ++v23;
          unint64_t v24 = v31;
          CMTime v25 = v31;
        }
        uint64_t v28 = v29 + (int)v28;
      }
      while (v25 != (int *)v27);
    }
  }
  uint64_t v32 = a7;
  if (v26) {
    uint64_t v32 = v28
  }
        + a7
        - *(int *)(*(void *)(v22 + (((v21 + v26 - 1) >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * ((v21 + v26 - 1) & 0x3FF));
  double v33 = *((double *)v15 + 4);
  uint64_t v34 = v15[6];
  double v35 = 0.0;
  if (v15[7] != v34)
  {
    unint64_t v36 = v15[9];
    BOOL v37 = (char **)(v34 + 8 * (v36 >> 10));
    CFStringRef v38 = *v37;
    double v39 = &(*v37)[4 * (v36 & 0x3FF)];
    uint64_t v40 = *(void *)(v34 + (((v15[10] + v36) >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * ((v15[10] + v36) & 0x3FF);
    if (v39 != (char *)v40)
    {
      int v41 = 0;
      do
      {
        int v43 = *(_DWORD *)v39;
        v39 += 4;
        int v42 = v43;
        if (v39 - v38 == 4096)
        {
          int v44 = v37[1];
          ++v37;
          CFStringRef v38 = v44;
          double v39 = v44;
        }
        v41 += v42;
      }
      while (v39 != (char *)v40);
      if (v41 >= 1) {
        double v35 = (double)v32 / (double)v41;
      }
    }
  }
  double v45 = v35 + 1.0;
  int v46 = a8 + a6;
  double v47 = (double)(a8 + a6);
  BOOL v48 = v35 < 3.3;
  double v49 = 4.3;
  if (v48) {
    double v49 = v45;
  }
  double v50 = v33 * 0.5 / (v49 + 0.5);
  if (v50 >= v47) {
    double v50 = (double)v46;
  }
  double v51 = (v33 - v50) / v49;
  double v52 = (double)a8;
  if (a8 && v46 && v50 != v47) {
    double v52 = v50 * v52 / v47;
  }
  int v53 = *((_DWORD *)v15 + 6);
  int v54 = *((_DWORD *)v15 + 7);
  *((_DWORD *)v17 + 16) = (int)fmax(v50 - v52, 0.0);
  *((_DWORD *)v17 + 17) = a7;
  *((_DWORD *)v17 + 18) = (int)v52;
  *((void *)v17 + 4) = (unint64_t)v51;
  unint64_t v56 = v15[17];
  uint64_t v55 = v15[18];
  int v57 = *((_DWORD *)v15 + 38);
  CMTimeValue v58 = *(void *)((char *)v15 + 156);
  long long v84 = *(_OWORD *)((char *)v15 + 164);
  int v59 = (void *)v15[1];
  if (v59 != v15)
  {
    int v77 = v57;
    double v78 = v17;
    double v60 = (double)v53;
    double v61 = (double)v54;
    v81 = v15;
    do
    {
      uint64_t v62 = v59[2];
      int v63 = (std::__shared_weak_count *)v59[3];
      if (v63) {
        atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      long long v83 = *(_OWORD *)(v62 + 24);
      uint64_t v64 = *(void *)(v62 + 8);
      CMTimeValue v65 = *(void *)(v62 + 16);
      uint64_t v66 = *(int *)(v62 + 40);
      uint64_t v67 = *(int *)(v62 + 44);
      uint64_t v68 = *(int *)(v62 + 48);
      memset(&v89, 0, sizeof(v89));
      lhs.value = v65;
      *(_OWORD *)&lhs.timescale = *(_OWORD *)(v62 + 24);
      rhs.value = v58;
      *(_OWORD *)&rhs.timescale = v84;
      CMTimeSubtract(&v89, &lhs, &rhs);
      double v69 = v61 / v60;
      if (v65 >= 1)
      {
        double v69 = v61 / v60;
        if (v58 >= 1)
        {
          double v69 = v61 / v60;
          if (v89.value >= 1)
          {
            CMTime time1 = v89;
            CMTimeMake(&time2, 20, 1);
            int32_t v70 = CMTimeCompare(&time1, &time2);
            double v69 = v61 / v60;
            if (v70 == -1) {
              double v69 = (double)v89.value * v61 / (double)v89.timescale;
            }
          }
        }
      }
      unint64_t v71 = v64 + v56 + v66 + v67 + v68;
      if (v71 >= (unint64_t)v69) {
        unint64_t v56 = v71 - (unint64_t)v69;
      }
      else {
        unint64_t v56 = 0;
      }
      long long v84 = v83;
      if (v63) {
        sub_1BB9C09B4(v63);
      }
      int v59 = (void *)v59[1];
      CMTimeValue v58 = v65;
      int v15 = v81;
    }
    while (v59 != v81);
    int v72 = (int)(3000.0 / v60);
    if (v77 < v72) {
      int v72 = v77;
    }
    double v73 = (double)v72 * v61 / 1000.0;
    if ((unint64_t)v73 >= v56) {
      uint64_t v55 = (unint64_t)v73 - v56;
    }
    else {
      uint64_t v55 = 0;
    }
    __int16 v17 = v78;
  }
  *((void *)v17 + 10) = v56;
  *((void *)v17 + 11) = v55;
  int16x8_t v74 = (std::__shared_weak_count *)v17;
  uint64_t v75 = operator new(0x20uLL);
  v75[2] = v79;
  v75[3] = v74;
  atomic_fetch_add_explicit(&v74->__shared_owners_, 1uLL, memory_order_relaxed);
  int v76 = (uint64_t *)*v15;
  *uint64_t v75 = *v15;
  v75[1] = v15;
  v76[1] = (uint64_t)v75;
  *int v15 = v75;
  ++v15[2];
  sub_1BB9C09B4(v74);
  std::mutex::unlock(v80);
}

void sub_1BB9C8ACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::mutex *a12)
{
  sub_1BB9C09B4(v12);
  std::mutex::unlock(a12);
  _Unwind_Resume(a1);
}

void sub_1BB9C8B14(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14EEC10;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9C8B68(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14EEC10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1BB9C8B88(void *a1, _DWORD *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 7) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_1BB9C8CDC(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(_DWORD *)(*(void *)(v5 + ((v8 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v8 & 0x3FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_1BB9C8C10(uint64_t a1)
{
  if (*(void *)(a1 + 32) >= 0x800uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 1024;
  }
}

void sub_1BB9C8C68(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14EEBD8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9C8CBC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14EEBD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1BB9C8CDC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x400;
  unint64_t v4 = v2 - 1024;
  if (v3)
  {
    a1[4] = v4;
    uint64_t v5 = (void *)a1[1];
    uint64_t v6 = (char *)a1[2];
    uint64_t v9 = *v5;
    uint64_t v7 = (char *)(v5 + 1);
    uint64_t v8 = v9;
    a1[1] = v7;
    if (v6 != (char *)a1[3]) {
      goto LABEL_41;
    }
    uint64_t v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v40 = 1;
      }
      else {
        unint64_t v40 = (uint64_t)&v6[-*a1] >> 2;
      }
      int v41 = (char *)sub_1BB9C91CC(v40);
      int v42 = &v41[8 * (v40 >> 2)];
      int v44 = &v41[8 * v43];
      double v45 = (uint64_t *)a1[1];
      uint64_t v6 = v42;
      uint64_t v46 = a1[2] - (void)v45;
      if (v46)
      {
        uint64_t v6 = &v42[v46 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v47 = 8 * (v46 >> 3);
        BOOL v48 = &v41[8 * (v40 >> 2)];
        do
        {
          uint64_t v49 = *v45++;
          *(void *)BOOL v48 = v49;
          v48 += 8;
          v47 -= 8;
        }
        while (v47);
      }
      goto LABEL_29;
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    BOOL v12 = v10 >> 3 < -1;
    uint64_t v13 = (v10 >> 3) + 2;
    if (v12) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = v11 + 1;
    }
    uint64_t v15 = -(v14 >> 1);
    uint64_t v16 = v14 >> 1;
    __int16 v17 = &v7[-8 * v16];
    int64_t v18 = v6 - v7;
    if (v6 != v7)
    {
      memmove(&v7[-8 * v16], v7, v6 - v7);
      uint64_t v7 = (char *)a1[1];
    }
    uint64_t v6 = &v17[v18];
    a1[1] = &v7[8 * v15];
    a1[2] = &v17[v18];
    goto LABEL_41;
  }
  BOOL v20 = (char *)a1[2];
  __int16 v19 = (char *)a1[3];
  unint64_t v21 = (char *)*a1;
  uint64_t v22 = (char *)a1[1];
  unint64_t v23 = (v20 - v22) >> 3;
  uint64_t v24 = (uint64_t)&v19[-*a1];
  if (v23 < v24 >> 3)
  {
    CMTime v25 = operator new(0x1000uLL);
    uint64_t v26 = v25;
    if (v19 != v20)
    {
      *(void *)BOOL v20 = v25;
LABEL_42:
      a1[2] += 8;
      return;
    }
    if (v22 == v21)
    {
      if (v20 == v22) {
        unint64_t v51 = 1;
      }
      else {
        unint64_t v51 = (v19 - v22) >> 2;
      }
      uint64_t v52 = 2 * v51;
      int v53 = (char *)sub_1BB9C91CC(v51);
      uint64_t v22 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v55 = (uint64_t *)a1[1];
      unint64_t v56 = v22;
      uint64_t v57 = a1[2] - (void)v55;
      if (v57)
      {
        unint64_t v56 = &v22[v57 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v58 = 8 * (v57 >> 3);
        int v59 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
        do
        {
          uint64_t v60 = *v55++;
          *(void *)int v59 = v60;
          v59 += 8;
          v58 -= 8;
        }
        while (v58);
      }
      double v61 = (char *)*a1;
      *a1 = v53;
      a1[1] = v22;
      a1[2] = v56;
      a1[3] = &v53[8 * v54];
      if (v61)
      {
        operator delete(v61);
        uint64_t v22 = (char *)a1[1];
      }
    }
    *((void *)v22 - 1) = v26;
    uint64_t v7 = (char *)a1[1];
    uint64_t v6 = (char *)a1[2];
    a1[1] = v7 - 8;
    uint64_t v8 = *((void *)v7 - 1);
    a1[1] = v7;
    if (v6 != (char *)a1[3])
    {
LABEL_41:
      *(void *)uint64_t v6 = v8;
      goto LABEL_42;
    }
    uint64_t v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v85 = 1;
      }
      else {
        unint64_t v85 = (uint64_t)&v6[-*a1] >> 2;
      }
      int v41 = (char *)sub_1BB9C91CC(v85);
      int v42 = &v41[8 * (v85 >> 2)];
      int v44 = &v41[8 * v86];
      double v87 = (uint64_t *)a1[1];
      uint64_t v6 = v42;
      uint64_t v88 = a1[2] - (void)v87;
      if (v88)
      {
        uint64_t v6 = &v42[v88 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v89 = 8 * (v88 >> 3);
        CFTypeID v90 = &v41[8 * (v85 >> 2)];
        do
        {
          uint64_t v91 = *v87++;
          *(void *)CFTypeID v90 = v91;
          v90 += 8;
          v89 -= 8;
        }
        while (v89);
      }
LABEL_29:
      double v50 = (char *)*a1;
      *a1 = v41;
      a1[1] = v42;
      a1[2] = v6;
      a1[3] = v44;
      if (v50)
      {
        operator delete(v50);
        uint64_t v6 = (char *)a1[2];
      }
      goto LABEL_41;
    }
    goto LABEL_5;
  }
  uint64_t v27 = v24 >> 2;
  if (v19 == v21) {
    unint64_t v28 = 1;
  }
  else {
    unint64_t v28 = v27;
  }
  uint64_t v29 = (char *)sub_1BB9C91CC(v28);
  uint64_t v31 = v30;
  uint64_t v32 = &v29[8 * v23];
  *(void *)&long long v33 = v29;
  *((void *)&v33 + 1) = v32;
  long long v95 = v33;
  uint64_t v34 = operator new(0x1000uLL);
  *(void *)&long long v35 = v32;
  *((void *)&v35 + 1) = &v29[8 * v31];
  if (v23 == v31)
  {
    uint64_t v36 = 8 * v23;
    *(void *)&long long v37 = v95;
    if (v20 - v22 >= 1)
    {
      uint64_t v38 = v36 >> 3;
      if (v38 >= -1) {
        unint64_t v39 = v38 + 1;
      }
      else {
        unint64_t v39 = v38 + 2;
      }
      v32 -= 8 * (v39 >> 1);
      *(void *)&long long v35 = v32;
      *((void *)&v37 + 1) = v32;
      goto LABEL_50;
    }
    uint64_t v62 = v36 >> 2;
    if (v20 == v22) {
      unint64_t v63 = 1;
    }
    else {
      unint64_t v63 = v62;
    }
    uint64_t v64 = (char *)sub_1BB9C91CC(v63);
    uint64_t v32 = &v64[8 * (v63 >> 2)];
    *(void *)&long long v37 = v64;
    *((void *)&v37 + 1) = v32;
    *(void *)&long long v35 = v32;
    *((void *)&v35 + 1) = &v64[8 * v65];
    if (!v29) {
      goto LABEL_50;
    }
    long long v92 = v35;
    long long v95 = v37;
    operator delete(v29);
    long long v35 = v92;
  }
  long long v37 = v95;
LABEL_50:
  *(void *)uint64_t v32 = v34;
  *(void *)&long long v35 = v35 + 8;
  for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
  {
    uint64_t v67 = (void *)*((void *)&v37 + 1);
    if (*((void *)&v37 + 1) == (void)v37)
    {
      double v69 = (unsigned char *)v35;
      if ((unint64_t)v35 >= *((void *)&v35 + 1))
      {
        if (*((void *)&v35 + 1) == *((void *)&v37 + 1)) {
          unint64_t v74 = 1;
        }
        else {
          unint64_t v74 = (uint64_t)(*((void *)&v35 + 1) - *((void *)&v37 + 1)) >> 2;
        }
        uint64_t v75 = (char *)sub_1BB9C91CC(v74);
        uint64_t v68 = &v75[(2 * v74 + 6) & 0xFFFFFFFFFFFFFFF8];
        int v77 = v68;
        uint64_t v78 = v69 - (unsigned char *)v67;
        if (v69 != (unsigned char *)v67)
        {
          int v77 = &v68[v78 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v79 = 8 * (v78 >> 3);
          unint64_t v80 = v68;
          v81 = v67;
          do
          {
            uint64_t v82 = *v81++;
            *(void *)unint64_t v80 = v82;
            v80 += 8;
            v79 -= 8;
          }
          while (v79);
        }
        *(void *)&long long v37 = v75;
        *((void *)&v37 + 1) = v68;
        *(void *)&long long v35 = v77;
        *((void *)&v35 + 1) = &v75[8 * v76];
        if (v67)
        {
          long long v93 = v35;
          long long v97 = v37;
          operator delete(v67);
          long long v35 = v93;
          long long v37 = v97;
        }
      }
      else
      {
        uint64_t v70 = (uint64_t)(*((void *)&v35 + 1) - v35) >> 3;
        if (v70 >= -1) {
          uint64_t v71 = v70 + 1;
        }
        else {
          uint64_t v71 = v70 + 2;
        }
        uint64_t v72 = v71 >> 1;
        uint64_t v73 = v35 + 8 * (v71 >> 1);
        uint64_t v68 = (char *)(v73 - (v35 - *((void *)&v37 + 1)));
        if ((void)v35 == *((void *)&v37 + 1))
        {
          double v69 = (unsigned char *)*((void *)&v37 + 1);
        }
        else
        {
          uint64_t v94 = *((void *)&v35 + 1);
          uint64_t v96 = v37;
          memmove((void *)(v73 - (v35 - *((void *)&v37 + 1))), *((const void **)&v37 + 1), v35 - *((void *)&v37 + 1));
          *((void *)&v35 + 1) = v94;
          *(void *)&long long v37 = v96;
        }
        *((void *)&v37 + 1) = v68;
        *(void *)&long long v35 = &v69[8 * v72];
      }
    }
    else
    {
      uint64_t v68 = (char *)*((void *)&v37 + 1);
    }
    uint64_t v83 = *(void *)(i - 8);
    *((void *)v68 - 1) = v83;
    *((void *)&v37 + 1) -= 8;
  }
  long long v84 = (char *)*a1;
  *(_OWORD *)a1 = v37;
  *((_OWORD *)a1 + 1) = v35;
  if (v84)
  {
    operator delete(v84);
  }
}

void sub_1BB9C919C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11)
{
  operator delete(v11);
  if ((void)a11) {
    operator delete((void *)a11);
  }
  _Unwind_Resume(a1);
}

void *sub_1BB9C91CC(unint64_t a1)
{
  if (a1 >> 61) {
    sub_1BB9C18AC();
  }
  return operator new(8 * a1);
}

void *sub_1BB9C9204(void *result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a2 >= 1)
  {
    int v9 = (int)result;
    uint64_t v10 = 0;
    uint64_t v11 = (int)(result & 0xFFFFFFC0);
    size_t v12 = ((~(result & 0xFFFFFFC0) + result) & 0xFFFFFFF0) + 16;
    uint64_t v13 = a2;
    uint64_t v14 = a3;
    uint64_t v15 = a5;
    do
    {
      if ((int)v11 >= 1)
      {
        for (uint64_t i = 0; i < v11; i += 64)
        {
          long long v17 = *(_OWORD *)(v14 + i + 16);
          long long v18 = *(_OWORD *)(v14 + i + 32);
          long long v19 = *(_OWORD *)(v14 + i + 48);
          BOOL v20 = (_OWORD *)(v15 + i);
          *BOOL v20 = *(_OWORD *)(v14 + i);
          v20[1] = v17;
          v20[2] = v18;
          v20[3] = v19;
        }
      }
      if ((int)v11 < v9) {
        uint64_t result = memcpy((void *)(a5 + v11 + v10 * a6), (const void *)(a3 + v11 + v10 * a4), v12);
      }
      ++v10;
      v14 += a4;
      v15 += a6;
    }
    while (v10 != v13);
  }
  return result;
}

void *sub_1BB9C92F4(unint64_t a1)
{
  if (a1 >> 59) {
    sub_1BB9C18AC();
  }
  return operator new(32 * a1);
}

void sub_1BB9C932C(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (__CVBuffer **)**a1;
  if (v2)
  {
    unint64_t v4 = (__CVBuffer **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        unint64_t v4 = sub_1BB9C940C(v4 - 3);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1BB9C93B0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 144);
  if (v2) {
    MEMORY[0x1C18605A0](v2, 0x1000C8077774924);
  }
  uint64_t v3 = *(void *)(a1 + 152);
  if (v3) {
    MEMORY[0x1C18605A0](v3, 0x1000C8077774924);
  }
  return a1;
}

__CVBuffer **sub_1BB9C940C(__CVBuffer **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    CVPixelBufferRelease(v2);
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_1BB9C9444(uint64_t a1, int a2, __CVBuffer *a3)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 184) - *(void *)(a1 + 176)) >> 3) > a2)
  {
    unint64_t v5 = a2;
    id v6 = *(id *)a1;
    uint64_t v7 = v6;
    if (!v6
      || !*(unsigned char *)(a1 + 248)
      || (uint64_t v8 = (uint64_t *)(*(void *)(a1 + 176) + 24 * (int)v5),
          uint64_t v9 = *v8,
          uint64_t v10 = v8[1],
          *(void *)&long long v11 = (int)v10,
          *((void *)&v11 + 1) = SHIDWORD(v10),
          long long v37 = v11,
          uint64_t v38 = 0,
          [v6 copySubframe:v9 toFrame:a3 atOffset:&v37]))
    {
      if (!a3)
      {
        uint64_t v19 = 4294954394;
        goto LABEL_19;
      }
      uint64_t v12 = *(void *)(a1 + 176) + 24 * (int)v5;
      uint64_t v13 = *(__CVBuffer **)v12;
      uint64_t v15 = *(int *)(v12 + 8);
      uint64_t v14 = *(int *)(v12 + 12);
      size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(a3, 1uLL);
      char v36 = WidthOfPlane < CVPixelBufferGetWidth(a3);
      size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a3, 1uLL);
      char v18 = HeightOfPlane < CVPixelBufferGetHeight(a3);
      uint64_t v19 = CVPixelBufferLockBaseAddress(v13, 1uLL);
      if (v19)
      {
LABEL_19:

        return v19;
      }
      uint64_t v19 = CVPixelBufferLockBaseAddress(a3, 0);
      if (v19)
      {
        CVPixelBufferUnlockBaseAddress(v13, 1uLL);
        goto LABEL_19;
      }
      int Width = CVPixelBufferGetWidth(a3);
      int Height = CVPixelBufferGetHeight(a3);
      size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a3, 0);
      size_t v33 = CVPixelBufferGetBytesPerRowOfPlane(a3, 1uLL);
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a3, 0);
      uint64_t v30 = CVPixelBufferGetBaseAddressOfPlane(a3, 1uLL);
      uint64_t v29 = CVPixelBufferGetBaseAddressOfPlane(v13, 0);
      unint64_t v28 = CVPixelBufferGetBaseAddressOfPlane(v13, 1uLL);
      size_t v27 = CVPixelBufferGetBytesPerRowOfPlane(v13, 0);
      size_t v26 = CVPixelBufferGetBytesPerRowOfPlane(v13, 1uLL);
      LODWORD(v21) = CVPixelBufferGetWidth(v13);
      int v22 = CVPixelBufferGetHeight(v13);
      uint64_t v23 = (uint64_t)BaseAddressOfPlane + v15 + BytesPerRowOfPlane * v14;
      uint64_t v32 = (uint64_t)v30 + v15 + v33 * ((int)v14 >> v18);
      if (Width - (int)v15 >= (int)v21) {
        unint64_t v21 = v21;
      }
      else {
        unint64_t v21 = (Width - v15);
      }
      if (Height - (int)v14 >= v22) {
        int v24 = v22;
      }
      else {
        int v24 = Height - v14;
      }
      sub_1BB9C9204((void *)v21, v24, (uint64_t)v29, v27, v23, BytesPerRowOfPlane);
      sub_1BB9C9204((void *)((2 * (int)v21) >> v36), v24 >> v18, (uint64_t)v28, v26, v32, v33);
      CVPixelBufferUnlockBaseAddress(v13, 1uLL);
      CVPixelBufferUnlockBaseAddress(a3, 0);
    }
    uint64_t v19 = 0;
    *(void *)(*(void *)(a1 + 200) + ((v5 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v5;
    goto LABEL_19;
  }
  return 4294954385;
}

void sub_1BB9C9710(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9C9724(void *a1, CVPixelBufferRef pixelBuffer)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[23] - a1[22]) >> 3) != a1[26]) {
    return 4294954385;
  }
  uint64_t v2 = pixelBuffer;
  uint64_t v3 = a1;
  int Width = CVPixelBufferGetWidth(pixelBuffer);
  int Height = CVPixelBufferGetHeight(v2);
  if (!*((unsigned char *)v3 + 168))
  {
    v3[11] = sub_1BBAD5A3C;
    v3[12] = sub_1BBAD560C;
    v3[13] = sub_1BBAD54D0;
    v3[14] = sub_1BBAD5444;
    v3[15] = sub_1BBAD4C5C;
    uint8_t v3[16] = sub_1BBAD3198;
    if (Width <= Height) {
      int v6 = Height;
    }
    else {
      int v6 = Width;
    }
    *((_DWORD *)v3 + 36) = v6 >> 3;
    *((_DWORD *)v3 + 37) = v6 >> 2;
    size_t v7 = (uint64_t)v6 >> 3;
    uint64_t v8 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    uint64_t v9 = operator new[](v7, MEMORY[0x1E4FBA2D0]);
    v3[19] = v9;
    size_t v10 = (uint64_t)v6 >> 2;
    long long v11 = operator new[](v10, v8);
    v3[20] = v11;
    if (!v9 || (uint64_t v12 = v11) == 0)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Decoder failed to initialize stitching filter", buf, 2u);
      }
      return 4294954392;
    }
    memset(v9, 52, v7);
    memset(v12, 13, v10);
    *((unsigned char *)v3 + 168) = 1;
  }
  id v13 = (id)*v3;
  id v48 = v13;
  if (!v13 || !*((unsigned char *)v3 + 248)) {
    goto LABEL_44;
  }
  uint64_t v14 = (char *)v3[28];
  v3[29] = v14;
  unint64_t v15 = v3[26];
  if (v15 >= 2)
  {
    unint64_t v16 = 1;
    while (1)
    {
      if ((*(void *)(v3[25] + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v16))
      {
        uint64_t v17 = v3[22];
        if (*(_DWORD *)(v17 + 24 * v16 + 8))
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)unint64_t v56 = 0;
            _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "X offset not yet supported in Metal", v56, 2u);
          }
          goto LABEL_44;
        }
        int v18 = *(_DWORD *)(v17 + 24 * v16 + 12);
        if (v18)
        {
          unint64_t v19 = v3[30];
          if ((unint64_t)v14 >= v19)
          {
            unint64_t v21 = (char *)v3[28];
            uint64_t v22 = (v14 - v21) >> 2;
            unint64_t v23 = v22 + 1;
            if ((unint64_t)(v22 + 1) >> 62) {
              sub_1BB9C185C();
            }
            uint64_t v24 = v19 - (void)v21;
            if (v24 >> 1 > v23) {
              unint64_t v23 = v24 >> 1;
            }
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v23;
            }
            if (v25)
            {
              unint64_t v25 = (unint64_t)sub_1BB9C1874(v25);
              unint64_t v21 = (char *)v3[28];
              uint64_t v14 = (char *)v3[29];
            }
            else
            {
              uint64_t v26 = 0;
            }
            size_t v27 = (_DWORD *)(v25 + 4 * v22);
            *size_t v27 = v18;
            BOOL v20 = (char *)(v27 + 1);
            while (v14 != v21)
            {
              int v28 = *((_DWORD *)v14 - 1);
              v14 -= 4;
              *--size_t v27 = v28;
            }
            v3[28] = v27;
            v3[29] = v20;
            v3[30] = v25 + 4 * v26;
            if (v21) {
              operator delete(v21);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v14 = v18;
            BOOL v20 = v14 + 4;
          }
          v3[29] = v20;
          unint64_t v15 = v3[26];
          uint64_t v14 = v20;
        }
      }
      if (v15 <= ++v16)
      {
        uint64_t v29 = v48;
        goto LABEL_40;
      }
    }
  }
  uint64_t v29 = v13;
LABEL_40:
  if (objc_msgSend(v29, "subframeDeblock:withOffsetsY:numEdges:", v2))
  {
LABEL_44:
    CVPixelBufferLockBaseAddress(v2, 0);
    if (v3[26] >= 2uLL)
    {
      uint64_t v31 = 0;
      uint64_t v32 = v3[25];
      unint64_t v33 = 1;
      do
      {
        unint64_t v34 = v33 >> 6;
        uint64_t v35 = 1 << v33;
        uint64_t v36 = *(void *)(v32 + 8 * (v33 >> 6));
        if ((v36 & (1 << v33)) != 0)
        {
          uint64_t v37 = v3[22] + v31;
          uint64_t v38 = *(unsigned int *)(v37 + 32);
          uint64_t v54 = (unsigned __int8 *)v3[19];
          unint64_t v39 = v3;
          uint64_t v52 = *(unsigned int *)(v37 + 36);
          int v53 = (unsigned __int8 *)v3[20];
          unint64_t v40 = v2;
          BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(v2, 0);
          double v50 = (char *)CVPixelBufferGetBaseAddressOfPlane(v2, 1uLL);
          size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v2, 0);
          size_t v42 = CVPixelBufferGetBytesPerRowOfPlane(v40, 1uLL);
          size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(v40, 0);
          size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(v40, 0);
          size_t v44 = CVPixelBufferGetWidthOfPlane(v40, 1uLL);
          char v45 = v44 < CVPixelBufferGetWidth(v40);
          size_t v46 = CVPixelBufferGetHeightOfPlane(v40, 1uLL);
          char v47 = v46 < CVPixelBufferGetHeight(v40);
          if ((int)v38 >= 1)
          {
            ((void (*)(char *, size_t, unsigned __int8 *, unsigned __int8 *, size_t))v39[11])(&BaseAddressOfPlane[v38], BytesPerRowOfPlane, v54, v53, HeightOfPlane);
            ((void (*)(char *, size_t, void, void, void))v39[15])(&v50[(2 * v38) >> v45], v42, *v54, *v53, ((int)HeightOfPlane >> v47));
          }
          if ((int)v52 >= 1)
          {
            ((void (*)(char *, size_t, unsigned __int8 *, unsigned __int8 *, size_t))v39[12])(&BaseAddressOfPlane[BytesPerRowOfPlane * v52], BytesPerRowOfPlane, v54, v53, WidthOfPlane);
            ((void (*)(char *, size_t, void, void, void))v39[16])(&v50[v42 * (v52 >> v47)], v42, *v54, *v53, ((int)WidthOfPlane >> v45));
          }
          uint64_t v3 = v39;
          uint64_t v32 = v39[25];
          uint64_t v35 = 1 << v33;
          unint64_t v34 = v33 >> 6;
          uint64_t v36 = *(void *)(v32 + 8 * (v33 >> 6));
          uint64_t v2 = v40;
        }
        *(void *)(v32 + 8 * v34) = v36 & ~v35;
        ++v33;
        v31 += 24;
      }
      while (v3[26] > v33);
    }
    uint64_t v29 = v48;
    CVPixelBufferUnlockBaseAddress(v2, 0);
  }

  return 0;
}

void sub_1BB9C9C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9C9C98()
{
  if ((byte_1E9F8159D & 1) == 0)
  {
    size_t v1 = 4;
    if (sysctlbyname("hw.physicalcpu", &dword_1E9F80A40, &v1, 0, 0)) {
      dword_1E9F80A40 = 1;
    }
    byte_1E9F8159D = 1;
  }
  return dword_1E9F80A40;
}

void sub_1BB9C9D0C(void *a1)
{
  uint64_t v2 = (void *)a1[112];
  if (v2)
  {
    free(v2);
    a1[112] = 0;
  }
  uint64_t v3 = (void *)a1[113];
  if (v3)
  {
    free(v3);
    a1[113] = 0;
  }
  unint64_t v4 = (void *)a1[118];
  if (v4)
  {
    free(v4);
    a1[118] = 0;
  }
}

void sub_1BB9C9D5C(uint64_t a1, char *a2, uint64_t a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, float a8)
{
  float v9 = a8;
  uint64_t v300 = *MEMORY[0x1E4F143B8];
  uint64_t v255 = a5;
  if (*(void *)(a1 + 912) != a4 || *(void *)(a1 + 920) != a5)
  {
    sub_1BB9C9D0C((void *)a1);
    float v9 = a8;
    a5 = v255;
    if (a4)
    {
      if (v255)
      {
        *(void *)(a1 + 896) = malloc_type_malloc(2 * v255 * a4, 0xAF7B4C98uLL);
        *(void *)(a1 + 904) = malloc_type_malloc(2 * v255 * a4, 0xA2B192A7uLL);
        uint64_t v14 = malloc_type_malloc(v255 * a4, 0x822FC793uLL);
        float v9 = a8;
        a5 = v255;
        *(void *)(a1 + 944) = v14;
        if (!*(void *)(a1 + 896) || !*(void *)(a1 + 904)) {
          goto LABEL_21;
        }
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        LODWORD(v17) = 0;
        do
        {
          uint64_t v18 = 0;
          uint64_t v17 = (int)v17;
          uint64_t v19 = v15;
          do
          {
            *(_WORD *)(a1 + 2 * v17++ + 128) = v19;
            ++v18;
            v19 += a3 + 1;
          }
          while (v18 != 8);
          ++v16;
          v15 += a3 - 1;
        }
        while (v16 != 8);
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        LODWORD(v22) = 0;
        do
        {
          uint64_t v23 = 0;
          uint64_t v22 = (int)v22;
          uint64_t v24 = v20;
          do
          {
            *(_WORD *)(a1 + 2 * v22++ + 256) = v24;
            ++v23;
            v24 += a4 + 1;
          }
          while (v23 != 8);
          ++v21;
          v20 += a4 - 1;
        }
        while (v21 != 8);
        for (uint64_t i = 1; i != 64; ++i)
          *(_WORD *)(a1 + 2 * i) = 0x10u / i;
        uint64_t v26 = 0;
        *(_WORD *)a1 = 16;
        size_t v27 = &xmmword_1BBB77CB8;
        do
        {
          float32x4_t v28 = (float32x4_t)*v27++;
          *(int16x4_t *)(a1 + 768 + v26) = vmovn_s32(vcvtq_s32_f32(vrndaq_f32(vmulq_n_f32(v28, a8))));
          v26 += 8;
        }
        while (v26 != 128);
        *(void *)(a1 + 928) = a3;
        *(float *)(a1 + 936) = a8;
        *(void *)(a1 + 912) = a4;
        *(void *)(a1 + 920) = v255;
      }
    }
  }
  if (!a5)
  {
    char v253 = 1;
    goto LABEL_25;
  }
LABEL_21:
  uint64_t v29 = 0;
  uint64_t v30 = a5;
  do
  {
    memcpy((void *)(*(void *)(a1 + 944) + v29), a2, a4);
    a2 += a3;
    v29 += a4;
    --v30;
  }
  while (v30);
  char v253 = 0;
  a5 = v255;
  float v9 = a8;
LABEL_25:
  uint64_t v31 = *(void *)(a1 + 944);
  if (*(void *)(a1 + 928) != a4)
  {
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    int v34 = 0;
    *(void *)(a1 + 928) = a4;
    do
    {
      uint64_t v35 = 0;
      int v36 = v34;
      uint64_t v37 = v32;
      uint64_t v38 = a1 + 128 + 2 * v34;
      do
      {
        *(_WORD *)(v38 + 2 * v35++) = v37;
        v37 += a4 + 1;
      }
      while (v35 != 8);
      int v34 = v36 + 8;
      ++v33;
      v32 += a4 - 1;
    }
    while (v33 != 8);
  }
  if (vabds_f32(*(float *)(a1 + 936), v9) > 1.0e-10)
  {
    uint64_t v39 = 0;
    *(float *)(a1 + 936) = v9;
    unint64_t v40 = &xmmword_1BBB77CB8;
    do
    {
      float32x4_t v41 = (float32x4_t)*v40++;
      *(int16x4_t *)(a1 + 768 + v39) = vmovn_s32(vcvtq_s32_f32(vrndaq_f32(vmulq_n_f32(v41, v9))));
      v39 += 8;
    }
    while (v39 != 128);
  }
  size_t v42 = *(void **)(a1 + 904);
  uint64_t v43 = *(void **)(a1 + 896);
  size_t v44 = a5 * a4;
  uint64_t v45 = a5;
  bzero(v43, 2 * a5 * a4);
  bzero(v42, v44);
  unint64_t v256 = v45 - 15;
  if (v45 != 15)
  {
    unint64_t v257 = 0;
    unint64_t v46 = a4 - 8;
    uint64_t v47 = a1 + 526;
    int8x16_t v48 = (int8x16_t)xmmword_1BBB6F3F0;
    int8x16_t v49 = (int8x16_t)xmmword_1BBB6F400;
    int8x16_t v50 = (int8x16_t)xmmword_1BBB6F410;
    int8x16_t v51 = (int8x16_t)xmmword_1BBB6F420;
    do
    {
      if (v46 >= 8)
      {
        unint64_t v52 = 7;
        do
        {
          uint64_t v53 = 0;
          unint64_t v54 = v52 + v257 * a4;
          do
          {
            *(_WORD *)(a1 + v53 + 384) = *(unsigned __int8 *)(v31 + v54 + *(__int16 *)(a1 + v53 + 128));
            v53 += 2;
          }
          while (v53 != 128);
          uint64_t v55 = -32;
          unint64_t v56 = (int16x4_t *)(a1 + 384);
          do
          {
            int8x16x2_t v301 = *(int8x16x2_t *)v56->i8;
            int8x16x2_t v302 = *(int8x16x2_t *)v56[4].i8;
            int8x8_t v57 = (int8x8_t)vzip1_s16(*(int16x4_t *)v302.val[0].i8, *(int16x4_t *)v302.val[1].i8);
            v58.i32[0] = vzip1_s16(*v56, *(int16x4_t *)v301.val[1].i8).u32[0];
            v58.i32[1] = vext_s8(*(int8x8_t *)&v302, v57, 4uLL).i32[1];
            v59.i32[0] = vtrn2_s16(*v56, *(int16x4_t *)v301.val[1].i8).u32[0];
            v59.i32[1] = v57.i32[1];
            v57.i16[2] = WORD2(*(void *)&v56[4]);
            v57.i16[3] = WORD2(*(void *)&v56[6]);
            v60.i32[0] = vzip2_s16(*v56, *(int16x4_t *)v301.val[1].i8).u32[0];
            v60.i32[1] = v57.i32[1];
            v61.i32[0] = vuzp2_s16(vuzp2_s16(*v56, *(int16x4_t *)v301.val[1].i8), *v56).u32[0];
            v61.i32[1] = vzip2_s16(*(int16x4_t *)&v302, *(int16x4_t *)(&v302 + 16)).i32[1];
            v62.i32[0] = vzip2q_s16(*(int16x8_t *)v56->i8, (int16x8_t)v301.val[1]).u32[0];
            v62.i32[1] = vqtbl2q_s8(v302, v48).i32[1];
            v63.i32[0] = vqtbl2q_s8(*(int8x16x2_t *)v56->i8, v49).u32[0];
            v63.i32[1] = vzip2q_s16(*(int16x8_t *)&v302, *(int16x8_t *)(&v302 + 16)).i32[1];
            v64.i32[0] = vqtbl2q_s8(*(int8x16x2_t *)v56->i8, v51).u32[0];
            v64.i32[1] = vqtbl2q_s8(v302, v50).i32[1];
            v301.val[0].i32[0] = vqtbl2q_s8(*(int8x16x2_t *)v56->i8, (int8x16_t)xmmword_1BBB6F440).u32[0];
            v301.val[0].i32[1] = vqtbl2q_s8(v302, (int8x16_t)xmmword_1BBB6F430).i32[1];
            v301.val[1] = (int8x16_t)vaddl_s16(*(int16x4_t *)v301.val[0].i8, v58);
            v302.val[0] = (int8x16_t)vaddl_s16(v64, v59);
            v302.val[1] = (int8x16_t)vaddl_s16(v63, v60);
            int32x4_t v65 = vaddl_s16(v62, v61);
            v301.val[0] = (int8x16_t)vsubl_s16(v58, *(int16x4_t *)v301.val[0].i8);
            int32x4_t v66 = vsubl_s16(v59, v64);
            int32x4_t v67 = vsubl_s16(v60, v63);
            int32x4_t v68 = vsubl_s16(v61, v62);
            int32x4_t v69 = vaddq_s32((int32x4_t)v301.val[1], v65);
            int32x4_t v70 = vaddq_s32((int32x4_t)v302.val[0], (int32x4_t)v302.val[1]);
            v301.val[1] = (int8x16_t)vsubq_s32((int32x4_t)v301.val[1], v65);
            v302.val[0] = (int8x16_t)vsubq_s32((int32x4_t)v302.val[0], (int32x4_t)v302.val[1]);
            v302.val[1] = (int8x16_t)vsraq_n_s32(vaddq_s32(vaddq_s32(v66, (int32x4_t)v301.val[0]), v67), (int32x4_t)v301.val[0], 1uLL);
            int32x4_t v71 = vsubq_s32((int32x4_t)v301.val[0], vsraq_n_s32(vaddq_s32(v67, v68), v67, 1uLL));
            v301.val[0] = (int8x16_t)vsubq_s32(vaddq_s32(v68, (int32x4_t)v301.val[0]), vsraq_n_s32(v66, v66, 1uLL));
            int32x4_t v72 = vaddq_s32(vsraq_n_s32(v68, v68, 1uLL), vsubq_s32(v66, v67));
            uint64_t v73 = (int32x4_t *)&v260.i8[v55];
            v73[2] = vaddq_s32(v69, v70);
            v73[6] = vsraq_n_s32((int32x4_t)v301.val[1], (int32x4_t)v302.val[0], 1uLL);
            v73[10] = vsubq_s32(v69, v70);
            v73[14] = vsubq_s32(vshrq_n_s32((int32x4_t)v301.val[1], 1uLL), (int32x4_t)v302.val[0]);
            v73[4] = vsraq_n_s32((int32x4_t)v302.val[1], v72, 2uLL);
            v73[8] = vsraq_n_s32(v71, (int32x4_t)v301.val[0], 2uLL);
            v73[12] = vsubq_s32((int32x4_t)v301.val[0], vshrq_n_s32(v71, 2uLL));
            v73[16] = vsubq_s32(vshrq_n_s32((int32x4_t)v302.val[1], 2uLL), v72);
            v56 += 8;
            v55 += 16;
          }
          while (v55);
          v74.i64[0] = __PAIR64__(v262.u32[0], v260.u32[0]);
          v74.i64[1] = __PAIR64__(v266.u32[0], v264.u32[0]);
          v75.i64[0] = __PAIR64__(v276, v268);
          v76.i64[0] = __PAIR64__(v277, v269);
          v75.i64[1] = __PAIR64__(v292, v284);
          v77.i64[0] = __PAIR64__(v263.u32[3], v261.u32[3]);
          v77.i64[1] = __PAIR64__(v267.u32[3], v265.u32[3]);
          v78.i64[0] = __PAIR64__(v283, v275);
          v79.i64[0] = __PAIR64__(v282, v274);
          v78.i64[1] = __PAIR64__(v299, v291);
          int32x4_t v80 = vaddq_s32(v78, v75);
          int32x4_t v81 = vaddq_s32(v77, v74);
          v82.i64[0] = __PAIR64__(v262.u32[1], v260.u32[1]);
          v82.i64[1] = __PAIR64__(v266.u32[1], v264.u32[1]);
          v76.i64[1] = __PAIR64__(v293, v285);
          v83.i64[0] = __PAIR64__(v263.u32[2], v261.u32[2]);
          v83.i64[1] = __PAIR64__(v267.u32[2], v265.u32[2]);
          v79.i64[1] = __PAIR64__(v298, v290);
          int32x4_t v84 = vaddq_s32(v79, v76);
          v85.i64[0] = __PAIR64__(v278, v270);
          v86.i64[0] = __PAIR64__(v279, v271);
          v85.i64[1] = __PAIR64__(v294, v286);
          int32x4_t v87 = vaddq_s32(v83, v82);
          v88.i64[0] = __PAIR64__(v281, v273);
          v89.i64[0] = __PAIR64__(v280, v272);
          v88.i64[1] = __PAIR64__(v297, v289);
          int32x4_t v90 = vaddq_s32(v88, v85);
          v91.i64[0] = __PAIR64__(v262.u32[2], v260.u32[2]);
          v91.i64[1] = __PAIR64__(v266.u32[2], v264.u32[2]);
          v92.i64[0] = __PAIR64__(v263.u32[1], v261.u32[1]);
          v92.i64[1] = __PAIR64__(v267.u32[1], v265.u32[1]);
          int32x4_t v93 = vaddq_s32(v92, v91);
          v94.i64[0] = __PAIR64__(v262.u32[3], v260.u32[3]);
          v94.i64[1] = __PAIR64__(v266.u32[3], v264.u32[3]);
          v86.i64[1] = __PAIR64__(v295, v287);
          v95.i64[0] = __PAIR64__(v263.u32[0], v261.u32[0]);
          v95.i64[1] = __PAIR64__(v267.u32[0], v265.u32[0]);
          v89.i64[1] = __PAIR64__(v296, v288);
          int32x4_t v96 = vaddq_s32(v89, v86);
          int32x4_t v97 = vaddq_s32(v95, v94);
          int32x4_t v98 = vsubq_s32(v75, v78);
          int32x4_t v99 = vsubq_s32(v74, v77);
          int32x4_t v100 = vsubq_s32(v82, v83);
          int32x4_t v101 = vsubq_s32(v76, v79);
          int32x4_t v102 = vsubq_s32(v85, v88);
          int32x4_t v103 = vsubq_s32(v91, v92);
          int32x4_t v104 = vsubq_s32(v94, v95);
          int32x4_t v105 = vsubq_s32(v86, v89);
          int32x4_t v106 = vaddq_s32(v97, v81);
          int32x4_t v107 = vaddq_s32(v96, v80);
          int32x4_t v108 = vaddq_s32(v93, v87);
          int32x4_t v109 = vaddq_s32(v90, v84);
          uint32x4_t v110 = (uint32x4_t)vsubq_s32(v81, v97);
          uint32x4_t v111 = (uint32x4_t)vsubq_s32(v80, v96);
          int32x4_t v112 = vsubq_s32(v87, v93);
          int32x4_t v113 = vsubq_s32(v84, v90);
          int32x4_t v114 = vaddq_s32(v100, v103);
          int32x4_t v115 = vsubq_s32(v100, v103);
          uint32x4_t v116 = (uint32x4_t)vsubq_s32(v99, vaddq_s32(vsraq_n_s32(v103, v103, 1uLL), v104));
          int32x4_t v117 = vaddq_s32(v101, v102);
          int32x4_t v118 = vsubq_s32(v101, v102);
          uint32x4_t v119 = (uint32x4_t)vsubq_s32(v98, vaddq_s32(vsraq_n_s32(v102, v102, 1uLL), v105));
          uint32x4_t v120 = (uint32x4_t)vaddq_s32(vsraq_n_s32(v99, v99, 1uLL), v114);
          uint32x4_t v121 = (uint32x4_t)vaddq_s32(vsraq_n_s32(v98, v98, 1uLL), v117);
          int32x4_t v122 = vaddq_s32(vsubq_s32(v99, vsraq_n_s32(v100, v100, 1uLL)), v104);
          int32x4_t v123 = vaddq_s32(vsubq_s32(v98, vsraq_n_s32(v101, v101, 1uLL)), v105);
          int32x4_t v124 = vsraq_n_s32(vaddq_s32(v115, v104), v104, 1uLL);
          int32x4_t v125 = vsraq_n_s32(vaddq_s32(v118, v105), v105, 1uLL);
          int32x4_t v126 = vaddq_s32(v107, v109);
          int32x4_t v127 = vaddq_s32(v106, v108);
          int16x8_t v128 = vuzp1q_s16((int16x8_t)v127, (int16x8_t)v126);
          *(int16x4_t *)v115.i8 = vmovn_s32(v126);
          *(int16x4_t *)v117.i8 = vmovn_s32(v127);
          int32x4_t v129 = (int32x4_t)vshrq_n_u32(v111, 1uLL);
          int32x4_t v130 = (int32x4_t)vsraq_n_u32(v111, (uint32x4_t)v113, 1uLL);
          int32x4_t v131 = (int32x4_t)vshrq_n_u32(v110, 1uLL);
          int32x4_t v132 = (int32x4_t)vsraq_n_u32(v110, (uint32x4_t)v112, 1uLL);
          int16x8_t v133 = vuzp1q_s16((int16x8_t)v132, (int16x8_t)v130);
          int8x8_t v134 = (int8x8_t)vmovn_s32(v130);
          int32x4_t v135 = vsubq_s32(v107, v109);
          int32x4_t v136 = vsubq_s32(v106, v108);
          int32x4_t v137 = vsubq_s32(v129, v113);
          int32x4_t v138 = vsubq_s32(v131, v112);
          int16x8_t v139 = vuzp1q_s16((int16x8_t)v138, (int16x8_t)v137);
          int8x8_t v259 = (int8x8_t)vmovn_s32(v137);
          int32x4_t v140 = (int32x4_t)vshrq_n_u32(v121, 2uLL);
          int32x4_t v141 = (int32x4_t)vsraq_n_u32(v121, (uint32x4_t)v125, 2uLL);
          int32x4_t v142 = (int32x4_t)vshrq_n_u32(v120, 2uLL);
          int32x4_t v143 = (int32x4_t)vsraq_n_u32(v120, (uint32x4_t)v124, 2uLL);
          int16x8_t v144 = vuzp1q_s16((int16x8_t)v143, (int16x8_t)v141);
          *(int16x4_t *)v137.i8 = vmovn_s32(v143);
          int32x4_t v145 = (int32x4_t)vshrq_n_u32(v119, 2uLL);
          int32x4_t v146 = (int32x4_t)vsraq_n_u32(v119, (uint32x4_t)v123, 2uLL);
          int32x4_t v147 = (int32x4_t)vshrq_n_u32(v116, 2uLL);
          int32x4_t v148 = (int32x4_t)vsraq_n_u32(v116, (uint32x4_t)v122, 2uLL);
          int16x8_t v149 = vuzp1q_s16((int16x8_t)v148, (int16x8_t)v146);
          *(int16x4_t *)v112.i8 = vmovn_s32(v146);
          *(int16x4_t *)v118.i8 = vmovn_s32(v148);
          int32x4_t v150 = vsubq_s32(v123, v145);
          int32x4_t v151 = vsubq_s32(v122, v147);
          int16x8_t v152 = vuzp1q_s16((int16x8_t)v151, (int16x8_t)v150);
          *(int16x4_t *)v147.i8 = vmovn_s32(v150);
          *(int16x4_t *)v145.i8 = vmovn_s32(v151);
          int32x4_t v153 = vsubq_s32(v140, v125);
          int32x4_t v154 = vsubq_s32(v142, v124);
          int16x8_t v155 = vcgtq_s16(vabsq_s16(v128), *(int16x8_t *)(a1 + 768));
          int16x8_t v156 = vcgtq_s16(vabsq_s16(v144), *(int16x8_t *)(a1 + 784));
          int16x8_t v157 = vcgtq_s16(vabsq_s16(v133), *(int16x8_t *)(a1 + 800));
          int16x8_t v158 = vcgtq_s16(vabsq_s16(v149), *(int16x8_t *)(a1 + 816));
          int16x8_t v159 = vcgtq_s16(vabsq_s16(vuzp1q_s16((int16x8_t)v136, (int16x8_t)v135)), *(int16x8_t *)(a1 + 832));
          int16x8_t v160 = vcgtq_s16(vabsq_s16(v152), *(int16x8_t *)(a1 + 848));
          int16x8_t v161 = vcgtq_s16(vabsq_s16(v139), *(int16x8_t *)(a1 + 864));
          int16x8_t v162 = vcgtq_s16(vabsq_s16(vuzp1q_s16((int16x8_t)v154, (int16x8_t)v153)), *(int16x8_t *)(a1 + 880));
          *(int16x8_t *)(a1 + 512) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v117.i8, *(int8x8_t *)v155.i8), (int16x4_t)0x39006600390040), 6uLL), vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v115.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v155, (int8x16_t)v155, 8uLL)), (int16x4_t)0x39006600390040), 6uLL);
          *(int16x8_t *)(a1 + 528) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v137.i8, *(int8x8_t *)v156.i8), (int16x4_t)0x32005B00320039), 6uLL), vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v141), (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v156, (int8x16_t)v156, 8uLL)), (int16x4_t)0x32005B00320039), 6uLL);
          *(int16x8_t *)(a1 + 544) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v132), *(int8x8_t *)v157.i8), (int16x4_t)0x5B00A4005B0066), 6uLL), vmull_s16((int16x4_t)vand_s8(v134, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v157, (int8x16_t)v157, 8uLL)), (int16x4_t)0x5B00A4005B0066), 6uLL);
          *(int16x8_t *)(a1 + 560) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v118.i8, *(int8x8_t *)v158.i8), (int16x4_t)0x32005B00320039), 6uLL), vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v112.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v158, (int8x16_t)v158, 8uLL)), (int16x4_t)0x32005B00320039), 6uLL);
          *(int16x8_t *)(a1 + 576) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v136), *(int8x8_t *)v159.i8), (int16x4_t)0x39006600390040), 6uLL), vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v135), (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v159, (int8x16_t)v159, 8uLL)), (int16x4_t)0x39006600390040), 6uLL);
          *(int16x8_t *)(a1 + 592) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v145.i8, *(int8x8_t *)v160.i8), (int16x4_t)0x32005B00320039), 6uLL), vmull_s16((int16x4_t)vand_s8(*(int8x8_t *)v147.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v160, (int8x16_t)v160, 8uLL)), (int16x4_t)0x32005B00320039), 6uLL);
          *(int16x8_t *)(a1 + 608) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v138), *(int8x8_t *)v161.i8), (int16x4_t)0x5B00A4005B0066), 6uLL), vmull_s16((int16x4_t)vand_s8(v259, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v161, (int8x16_t)v161, 8uLL)), (int16x4_t)0x5B00A4005B0066), 6uLL);
          *(int16x8_t *)(a1 + 624) = vqrshrn_high_n_s32(vqrshrn_n_s32(vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v154), *(int8x8_t *)v162.i8), (int16x4_t)0x32005B00320039), 6uLL), vmull_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32(v153), (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v162, (int8x16_t)v162, 8uLL)), (int16x4_t)0x32005B00320039), 6uLL);
          int16x8_t v163 = vaddq_s16(vaddq_s16(vaddq_s16(v156, vaddq_s16(v155, v157)), vaddq_s16(v158, v159)), vaddq_s16(vaddq_s16(v160, v161), v162));
          do
          {
            __int16 v164 = *(_WORD *)(v47 + v55 - 14);
            __int16 v165 = *(_WORD *)(v47 + v55 - 6);
            __int16 v166 = v165 + v164;
            __int16 v167 = v164 - v165;
            int v168 = *(__int16 *)(v47 + v55 - 10);
            int v169 = *(__int16 *)(v47 + v55 - 2);
            int v170 = (v168 >> 1) - v169;
            int v171 = v168 + (v169 >> 1);
            int v172 = *(__int16 *)(v47 + v55 - 4);
            int v173 = *(__int16 *)(v47 + v55 - 8);
            int v174 = *(__int16 *)(v47 + v55);
            int v175 = v172 - (v173 + v174 + (v174 >> 1));
            int v176 = *(__int16 *)(v47 + v55 - 12);
            int v177 = v174 - (v173 + (v173 >> 1)) + v176;
            int v178 = v172 + (v172 >> 1) + v174 - v176;
            int v179 = v173 + v172 + v176 + (v176 >> 1);
            int v180 = (__int16)v178;
            LOWORD(v173) = v171 + v166;
            LOWORD(v171) = v166 - v171;
            __int16 v181 = v170 + v167;
            __int16 v182 = v167 - v170;
            int v183 = v175 + ((__int16)v179 >> 2);
            int v184 = v179 - ((__int16)v175 >> 2);
            int v185 = ((__int16)v177 >> 2) - v178;
            v186 = &v260.i16[(unint64_t)v55 / 2];
            __int16 *v186 = v184 + v173;
            v186[1] = v185 + v181;
            LOWORD(v177) = v177 + (v180 >> 2);
            v186[2] = v177 + v182;
            v186[3] = v183 + v171;
            v186[4] = v171 - v183;
            v186[5] = v182 - v177;
            v186[6] = v181 - v185;
            v186[7] = v173 - v184;
            v55 += 16;
          }
          while (v55 != 128);
          uint64_t v187 = 0;
          int v188 = vaddlvq_s16(v163);
          int16x8_t v189 = vaddq_s16(v264, v260);
          int16x8_t v190 = vsubq_s16(v265, vsraq_n_s16(vaddq_s16(v263, v267), v267, 1uLL));
          int16x8_t v191 = vsubq_s16(v260, v264);
          int16x8_t v192 = vaddq_s16(vsubq_s16(v267, vsraq_n_s16(v263, v263, 1uLL)), v261);
          int16x8_t v193 = vsubq_s16(vshrq_n_s16(v262, 1uLL), v266);
          int16x8_t v194 = vsubq_s16(vaddq_s16(vsraq_n_s16(v265, v265, 1uLL), v267), v261);
          int16x8_t v195 = vsraq_n_s16(v262, v266, 1uLL);
          int16x8_t v196 = vsraq_n_s16(vaddq_s16(vaddq_s16(v263, v265), v261), v261, 1uLL);
          int16x8_t v197 = vaddq_s16(v193, v191);
          int16x8_t v198 = vsubq_s16(v191, v193);
          int16x8_t v199 = vaddq_s16(v195, v189);
          int16x8_t v200 = vsubq_s16(v189, v195);
          int16x8_t v201 = vshrq_n_s16(v190, 2uLL);
          int16x8_t v202 = vsraq_n_s16(v190, v196, 2uLL);
          int16x8_t v203 = vsubq_s16(v196, v201);
          int16x8_t v204 = vshrq_n_s16(v192, 2uLL);
          int16x8_t v205 = vsraq_n_s16(v192, v194, 2uLL);
          int16x8_t v206 = vsubq_s16(v204, v194);
          int16x8_t v207 = vaddq_s16(v199, v203);
          int16x8_t v208 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v207.i8), 6uLL), vmovl_high_s16(v207), 6uLL);
          int16x8_t v209 = vaddq_s16(v197, v206);
          int16x8_t v210 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v209.i8), 6uLL), vmovl_high_s16(v209), 6uLL);
          *(int16x8_t *)(a1 + 640) = v208;
          *(int16x8_t *)(a1 + 656) = v210;
          int16x8_t v211 = vaddq_s16(v198, v205);
          int16x8_t v212 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v211.i8), 6uLL), vmovl_high_s16(v211), 6uLL);
          int16x8_t v213 = vaddq_s16(v200, v202);
          int16x8_t v214 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v213.i8), 6uLL), vmovl_high_s16(v213), 6uLL);
          *(int16x8_t *)(a1 + 672) = v212;
          *(int16x8_t *)(a1 + 688) = v214;
          int16x8_t v215 = vsubq_s16(v200, v202);
          int16x8_t v216 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v215.i8), 6uLL), vmovl_high_s16(v215), 6uLL);
          int16x8_t v217 = vsubq_s16(v198, v205);
          int16x8_t v218 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v217.i8), 6uLL), vmovl_high_s16(v217), 6uLL);
          *(int16x8_t *)(a1 + 704) = v216;
          *(int16x8_t *)(a1 + 720) = v218;
          int16x8_t v219 = vsubq_s16(v197, v206);
          int16x8_t v220 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v219.i8), 6uLL), vmovl_high_s16(v219), 6uLL);
          int16x8_t v221 = vsubq_s16(v199, v203);
          int16x8_t v222 = vrshrn_high_n_s32(vrshrn_n_s32(vmovl_s16(*(int16x4_t *)v221.i8), 6uLL), vmovl_high_s16(v221), 6uLL);
          *(int16x8_t *)(a1 + 736) = v220;
          *(int16x8_t *)(a1 + 752) = v222;
          unsigned int v223 = *(unsigned __int16 *)(a1 - 2 * v188);
          int16x8_t v224 = vdupq_n_s16(v223);
          *(int16x8_t *)(a1 + 640) = vmulq_s16(v224, v208);
          *(int16x8_t *)(a1 + 656) = vmulq_s16(v224, v210);
          *(int16x8_t *)(a1 + 672) = vmulq_s16(v224, v212);
          *(int16x8_t *)(a1 + 688) = vmulq_s16(v224, v214);
          *(int16x8_t *)(a1 + 704) = vmulq_s16(v224, v216);
          *(int16x8_t *)(a1 + 720) = vmulq_s16(v224, v218);
          *(int16x8_t *)(a1 + 736) = vmulq_s16(v224, v220);
          *(int16x8_t *)(a1 + 752) = vmulq_s16(v224, v222);
          do
          {
            int v225 = v54 + *(__int16 *)(a1 + v187 + 256);
            *((_WORD *)v43 + v225) += *(_WORD *)(a1 + v187 + 640);
            *((unsigned char *)v42 + v225) += v223;
            v187 += 2;
          }
          while (v187 != 128);
          v52 += 5;
          int8x16_t v49 = (int8x16_t)xmmword_1BBB6F400;
          int8x16_t v48 = (int8x16_t)xmmword_1BBB6F3F0;
          int8x16_t v51 = (int8x16_t)xmmword_1BBB6F420;
          int8x16_t v50 = (int8x16_t)xmmword_1BBB6F410;
        }
        while (v46 > v52);
      }
      v257 += 5;
    }
    while (v256 > v257);
  }
  if ((v253 & 1) == 0)
  {
    uint64_t v226 = 0;
    uint64_t v227 = *(void *)(a1 + 904);
    uint64_t v228 = *(void *)(a1 + 896) + 16;
    v229.i64[0] = 0x1111111111111111;
    v229.i64[1] = 0x1111111111111111;
    long long v230 = xmmword_1BBB6F490;
    long long v231 = xmmword_1BBB6F4A0;
    long long v232 = xmmword_1BBB6F4B0;
    long long v233 = xmmword_1BBB6F4C0;
    v234.i64[0] = 0xECECECECECECECECLL;
    v234.i64[1] = 0xECECECECECECECECLL;
    v235.i64[0] = 0xF1F1F1F1F1F1F1F1;
    v235.i64[1] = 0xF1F1F1F1F1F1F1F1;
    v236.i64[0] = -1;
    v236.i64[1] = -1;
    v237.i64[0] = 0xFEFEFEFEFEFEFEFELL;
    v237.i64[1] = 0xFEFEFEFEFEFEFEFELL;
    do
    {
      if (a4)
      {
        size_t v238 = 0;
        v239 = (int16x8_t *)v228;
        do
        {
          int8x16_t v240 = *(int8x16_t *)(v227 + v238);
          int8x16_t v241 = vbslq_s8((int8x16_t)vcgtq_u8(v229, (uint8x16_t)v240), v235, v234);
          int16x8_t v242 = vmovl_s8(*(int8x8_t *)v241.i8);
          int16x8_t v243 = vmovl_high_s8(v241);
          int8x16_t v244 = vaddq_s8(v240, v240);
          int8x16_t v245 = vaddq_s8(v244, v237);
          int8x16_t v246 = vaddq_s8(v244, v236);
          int8x16_t v247 = vzip1q_s8(v245, v246);
          int8x16_t v248 = vzip2q_s8(v245, v246);
          uint16x8_t v249 = (uint16x8_t)vqtbx4q_s8(*(int8x16x4_t *)&v233, v247);
          uint16x8_t v250 = (uint16x8_t)vqtbx4q_s8(*(int8x16x4_t *)&v233, v248);
          uint16x8_t v251 = (uint16x8_t)vmaxq_s16(v239[-1], (int16x8_t)0);
          uint16x8_t v252 = (uint16x8_t)vmaxq_s16(*v239, (int16x8_t)0);
          *(int8x16_t *)(a6 + v238) = vbslq_s8(vceqzq_s8(v240), *(int8x16_t *)(v31 + v238), (int8x16_t)vqmovn_high_u16(vqmovn_u16(vqmovn_high_u32(vqmovn_u32(vshlq_u32(vmull_u16(*(uint16x4_t *)v251.i8, *(uint16x4_t *)v249.i8), (uint32x4_t)vmovl_s16(*(int16x4_t *)v242.i8))), vshlq_u32(vmull_high_u16(v251, v249), (uint32x4_t)vmovl_high_s16(v242)))), vqmovn_high_u32(vqmovn_u32(vshlq_u32(vmull_u16(*(uint16x4_t *)v252.i8, *(uint16x4_t *)v250.i8), (uint32x4_t)vmovl_s16(*(int16x4_t *)v243.i8))), vshlq_u32(vmull_high_u16(v252, v250),
                                                         (uint32x4_t)vmovl_high_s16(v243)))));
          v238 += 16;
          v239 += 2;
        }
        while (v238 < a4);
      }
      v227 += a4;
      a6 += a7;
      v31 += a4;
      ++v226;
      v228 += 2 * a4;
    }
    while (v226 != v255);
  }
}

void sub_1BB9CAD38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CAE90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CB02C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CB230(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CB39C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  a9.super_class = (Class)VCPReactionAVCaptureDeviceObserver;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1BB9CB5A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CB5E8(uint64_t a1, void *a2)
{
  id v6 = [a2 object];
  if ([v6 hasMediaType:*MEMORY[0x1E4F15C18]])
  {
    uint64_t v3 = (id *)(a1 + 32);
    id WeakRetained = objc_loadWeakRetained(v3);

    if (WeakRetained)
    {
      id v5 = objc_loadWeakRetained(v3);
      [v5 addDevice:v6];
    }
  }
}

void sub_1BB9CB678(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CB698(uint64_t a1, void *a2)
{
  id v6 = [a2 object];
  if ([v6 hasMediaType:*MEMORY[0x1E4F15C18]])
  {
    uint64_t v3 = (id *)(a1 + 32);
    id WeakRetained = objc_loadWeakRetained(v3);

    if (WeakRetained)
    {
      id v5 = objc_loadWeakRetained(v3);
      [v5 removeDevice:v6];
    }
  }
}

void sub_1BB9CB728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CB870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CB9A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9CB9C4()
{
  qword_1EC027128 = 0;
  unk_1EC027130 = "VCPRateControlSession_NonLowLatency";
  qword_1EC027138 = 0;
  unk_1EC027140 = 0;
  qword_1EC027148 = (uint64_t)sub_1BB9CBA18;
  unk_1EC027150 = 0u;
  unk_1EC027160 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EC027120 = result;
  return result;
}

uint64_t sub_1BB9CBA18(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 16);
    if (v2)
    {
      *(unsigned char *)(v2 + 232) = 1;
      sub_1BB9C740C(v2);
      std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 2480));
      std::condition_variable::~condition_variable((std::condition_variable *)(v2 + 2432));
      std::mutex::~mutex((std::mutex *)(v2 + 2368));
      std::mutex::~mutex((std::mutex *)(v2 + 2304));
      uint64_t result = MEMORY[0x1C18605E0](v2, 0x10F0C40EEABCC0CLL);
      *(void *)(v1 + 16) = 0;
    }
  }
  return result;
}

uint64_t **sub_1BB9CBAA0(uint64_t a1, const void *a2)
{
  CFTypeRef v5 = a2;
  uint64_t result = sub_1BB9C6924(*(void **)(a1 + 2544), &v5);
  if (result)
  {
    unint64_t v4 = sub_1BB9C6924(*(void **)(a1 + 2544), &v5);
    if (!v4) {
      sub_1BB9C6A20("unordered_map::at: key not found");
    }
    return (uint64_t **)(*((unsigned char *)v4 + 48) != 0);
  }
  return result;
}

void sub_1BB9CBB04(char *__format, ...)
{
  va_start(va, __format);
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  vsnprintf(__str, 0x400uLL, __format, va);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    uint64_t v2 = __str;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "(Encoder Configuration) %s", buf, 0xCu);
  }
}

void sub_1BB9CC40C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,const void *a42,const void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,const void *a57)
{
  sub_1BB9C14A0(v59);
  sub_1BB9BE1C0(v58);

  sub_1BB9BE1C0(&a42);
  sub_1BB9C14A0(&a43);

  for (uint64_t i = 8; i != -8; i -= 8)
  sub_1BB9BE124(&a57);
  _Unwind_Resume(a1);
}

id sub_1BB9CC530(uint64_t a1, void *a2)
{
  id v4 = *(id *)a1;
  if (!*(void *)a1)
  {
    uint64_t v5 = objc_opt_new();
    id v6 = *(id *)a1;
    *(void *)a1 = v5;

    id v4 = *(id *)a1;
  }
  id v7 = v4;
  objc_sync_enter(v7);
  if ((unint64_t)[*(id *)a1 count] < 2)
  {
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = [*(id *)a1 lastObject];
    [*(id *)a1 removeLastObject];
  }
  objc_sync_exit(v7);

  if (!v8) {
    uint64_t v8 = (void *)[*(id *)(a1 + 8) newBufferWithLength:*(void *)(a1 + 16) options:*(void *)(a1 + 24)];
  }
  objc_initWeak(&location, *(id *)a1);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  v15[2] = sub_1BB9CD15C;
  v15[3] = &unk_1E6247978;
  objc_copyWeak(&v17, &location);
  id v9 = v8;
  id v16 = v9;
  size_t v10 = (void *)MEMORY[0x1C1860DE0](v15);
  id v11 = objc_alloc(MEMORY[0x1E4F1C9B8]);
  id v12 = v9;
  *a2 = objc_msgSend(v11, "initWithBytesNoCopy:length:deallocator:", objc_msgSend(v12, "contents"), objc_msgSend(v12, "length"), v10);
  id v13 = v12;

  objc_destroyWeak(&v17);
  objc_destroyWeak(&location);

  return v13;
}

void sub_1BB9CC6F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_sync_exit(v17);

  _Unwind_Resume(a1);
}

void sub_1BB9CC738(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  int v3 = *(_DWORD *)(a1 + 136);
  if ((v3 & 2) != 0) {
    sub_1BB9CC800(1u);
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 8), 1uLL, memory_order_relaxed);
  *(_DWORD *)(a1 + 136) = v3 | 2;
  std::mutex::unlock(v2);
}

void sub_1BB9CC7A0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9CC7B4(uint64_t a1)
{
  sub_1BB9C14A0((const void **)(a1 + 128));
  sub_1BB9BE1C0((const void **)(a1 + 120));

  return a1;
}

void sub_1BB9CC800(unsigned int a1)
{
  exception = __cxa_allocate_exception(0x20uLL);
  int v3 = std::future_category();
  MEMORY[0x1C18603A0](exception, a1, v3);
  __cxa_throw(exception, (struct type_info *)&unk_1F14EDB80, MEMORY[0x1E4FBA218]);
}

void sub_1BB9CC854(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const void **sub_1BB9CC868(uint64_t a1)
{
  error[1] = *(CFErrorRef *)MEMORY[0x1E4F143B8];
  [*(id *)(a1 + 152) waitUntilCompleted];
  int v2 = *(_DWORD *)(a1 + 160);
  int v3 = *(_DWORD *)(a1 + 164);
  int v4 = *(_DWORD *)(a1 + 168);
  unsigned int v5 = *(_DWORD *)(a1 + 208);
  long long v43 = *(_OWORD *)(a1 + 224);
  uint64_t v44 = *(void *)(a1 + 240);
  long long v41 = *(_OWORD *)(a1 + 248);
  CFDictionaryRef MutableCopy = *(const __CFDictionary **)(a1 + 272);
  uint64_t v42 = *(void *)(a1 + 264);
  id v7 = *(__CVBuffer **)(a1 + 280);
  uint64_t v8 = *(void *)(a1 + 288);
  BytePtr = (UInt8 *)CFDataGetBytePtr(*(CFDataRef *)(a1 + 296));
  if (!MutableCopy)
  {
    CFTypeRef cf = 0;
    CFPropertyListRef propertyList = 0;
    goto LABEL_14;
  }
  if (CFDictionaryContainsKey(MutableCopy, @"DirtyRegionArray"))
  {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, MutableCopy);
    CFDictionaryRemoveValue(MutableCopy, @"DirtyRegionArray");
    CFTypeRef cf = 0;
    CFPropertyListRef propertyList = MutableCopy;
    if (!MutableCopy) {
      goto LABEL_14;
    }
  }
  else
  {
    CFRetain(MutableCopy);
    CFTypeRef cf = 0;
    CFPropertyListRef propertyList = MutableCopy;
  }
  if (!CFDictionaryGetCount(MutableCopy))
  {
LABEL_14:
    unint64_t v14 = 120;
    goto LABEL_15;
  }
  error[0] = 0;
  CFDataRef Data = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, error);
  if (!Data)
  {
    CFTypeID v10 = CFGetTypeID(propertyList);
    CFStringRef v11 = CFCopyTypeIDDescription(v10);
    CFStringRef v48 = v11;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      CStringPtr = CFStringGetCStringPtr(v11, 0x8000100u);
      CFStringRef v13 = CFErrorCopyFailureReason(error[0]);
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = CStringPtr;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = CFStringGetCStringPtr(v13, 0x8000100u);
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to serialize %s (%s)", buf, 0x16u);
    }
    sub_1BB9BE158((const void **)&v48);
  }
  sub_1BB9BE18C((const void **)error);
  theCFDataRef Data = 0;
  CFTypeRef cf = Data;
  sub_1BB9BE124((const void **)&theData);
  if (!cf)
  {
    int v36 = -50;
    goto LABEL_53;
  }
  unint64_t v14 = CFDataGetLength((CFDataRef)cf) + 120;
LABEL_15:
  CFStringRef v48 = 0;
  theCFDataRef Data = 0;
  *(_DWORD *)buf = v4;
  *(_OWORD *)&uint8_t buf[4] = v43;
  *(void *)&buf[20] = v44;
  *(_OWORD *)&buf[28] = v41;
  *(void *)&buf[44] = v42;
  signed int PixelFormatType = CVPixelBufferGetPixelFormatType(v7);
  *(_DWORD *)&buf[52] = PixelFormatType;
  int Length = (int)cf;
  if (cf) {
    int Length = CFDataGetLength((CFDataRef)cf);
  }
  *(_DWORD *)&buf[56] = Length;
  int v17 = (int)theData;
  if (theData) {
    int v17 = CFDataGetLength(theData);
  }
  *(_DWORD *)&buf[60] = v17;
  if (PixelFormatType > 875704949)
  {
    if (PixelFormatType == 875836534 || PixelFormatType == 875836518) {
      goto LABEL_27;
    }
    unsigned __int16 v19 = 12918;
  }
  else
  {
    char v18 = 1;
    if (PixelFormatType == 875704422 || PixelFormatType == 875704438) {
      goto LABEL_28;
    }
    unsigned __int16 v19 = 12902;
  }
  if (PixelFormatType == (v19 | 0x34320000))
  {
LABEL_27:
    char v18 = 0;
LABEL_28:
    uint64_t v20 = 0;
    size_t v21 = 0;
    uint64_t v22 = v8 + 224;
    while (1)
    {
      if (CVPixelBufferGetPlaneCount(v7) <= v21)
      {
        int v29 = 0;
        uint64_t v30 = (_DWORD *)((char *)v50 + v20);
        *uint64_t v30 = 0;
        v30[8] = 0;
      }
      else
      {
        unsigned int HeightOfPlane = CVPixelBufferGetHeightOfPlane(v7, v21);
        unint64_t v24 = *(unsigned int *)(v22 + v20);
        if (v14 > v24)
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            LODWORD(error[0]) = 67109120;
            HIDWORD(error[0]) = v21;
            _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Header is larger than offset to plane %d", (uint8_t *)error, 8u);
          }
          int v36 = -50;
          goto LABEL_52;
        }
        if (v20) {
          char v25 = v18;
        }
        else {
          char v25 = 0;
        }
        unsigned int v26 = v5 >> v25;
        if (v26 >= HeightOfPlane) {
          unsigned int v26 = HeightOfPlane;
        }
        size_t v27 = (_DWORD *)((char *)v50 + v20);
        *size_t v27 = v24;
        int v28 = *(_DWORD *)(v22 + v20 + 16);
        v27[8] = v28;
        int v29 = v28 * v26;
      }
      *(_DWORD *)((char *)&v50[1] + v20) = v29;
      ++v21;
      v20 += 4;
      if (v21 == 4)
      {
        *(_WORD *)BytePtr = 8;
        *((_WORD *)BytePtr + 1) = v2;
        *((_DWORD *)BytePtr + 1) = v3;
        *(_OWORD *)(BytePtr + 56) = *(_OWORD *)&buf[48];
        *(_OWORD *)(BytePtr + 72) = v50[0];
        *(_OWORD *)(BytePtr + 88) = v50[1];
        *(_OWORD *)(BytePtr + 104) = v50[2];
        *(_OWORD *)(BytePtr + 8) = *(_OWORD *)buf;
        *(_OWORD *)(BytePtr + 24) = *(_OWORD *)&buf[16];
        *(_OWORD *)(BytePtr + 40) = *(_OWORD *)&buf[32];
        uint64_t v31 = (char *)(BytePtr + 120);
        if (cf)
        {
          uint64_t v32 = CFDataGetBytePtr((CFDataRef)cf);
          size_t v33 = CFDataGetLength((CFDataRef)cf);
          memcpy(v31, v32, v33);
          v31 += v33;
        }
        if (theData)
        {
          int v34 = CFDataGetBytePtr(theData);
          size_t v35 = CFDataGetLength(theData);
          memcpy(v31, v34, v35);
        }
        int v36 = 0;
        goto LABEL_52;
      }
    }
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    LODWORD(error[0]) = 67109120;
    HIDWORD(error[0]) = PixelFormatType;
    _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "pixel format (%d) is not supported\n", (uint8_t *)error, 8u);
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    LOWORD(error[0]) = 0;
    _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to get chroma subsampling shift\n", (uint8_t *)error, 2u);
  }
  int v36 = -666;
LABEL_52:
  sub_1BB9BE124((const void **)&theData);
  sub_1BB9BE1C0((const void **)&v48);
LABEL_53:
  sub_1BB9BE124(&cf);
  sub_1BB9BE1C0(&propertyList);
  if (v36)
  {
    unint64_t v40 = 0;
  }
  else
  {
    uint64_t v37 = *(const void **)(a1 + 296);
    unint64_t v40 = v37;
    if (v37) {
      CFRetain(v37);
    }
  }
  sub_1BB9CCEE4(a1, &v40);
  return sub_1BB9BE124(&v40);
}

void sub_1BB9CCDF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::exception_ptr a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,int a22,const void *a23,const void *a24,const void *a25)
{
  if (a2)
  {
    sub_1BB9BE158(&a25);
    sub_1BB9BE18C((const void **)(v26 - 112));
    sub_1BB9BE124(&a23);
    sub_1BB9BE1C0(&a24);
    __cxa_begin_catch(exception_object);
    std::current_exception();
    v28.__ptr_ = &a11;
    std::__assoc_sub_state::set_exception(v25, v28);
    std::exception_ptr::~exception_ptr(&a11);
    __cxa_end_catch();
    JUMPOUT(0x1BB9CCD08);
  }
  _Unwind_Resume(exception_object);
}

void sub_1BB9CCEC4()
{
}

void sub_1BB9CCECC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::exception_ptr a11)
{
}

void sub_1BB9CCEE4(uint64_t a1, void *a2)
{
  int v4 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  if ((*(unsigned char *)(a1 + 136) & 1) != 0
    || (v6.__ptr_ = 0, uint64_t v5 = *(void *)(a1 + 16), std::exception_ptr::~exception_ptr(&v6), v5))
  {
    sub_1BB9CC800(2u);
  }
  *(void *)(a1 + 144) = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 88));
  std::mutex::unlock(v4);
}

void sub_1BB9CCF78(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9CCF8C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136)) {
    sub_1BB9BE124((const void **)(a1 + 144));
  }
  int v2 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 8);

  return v2(a1);
}

void sub_1BB9CCFF0(uint64_t a1)
{
  *(void *)a1 = &unk_1F14EEEE8;
  sub_1BB9BE124((const void **)(a1 + 296));

  sub_1BB9C14A0((const void **)(a1 + 280));
  sub_1BB9BE1C0((const void **)(a1 + 272));

  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9CD0B0(uint64_t a1)
{
  *(void *)a1 = &unk_1F14EEEE8;
  sub_1BB9BE124((const void **)(a1 + 296));

  sub_1BB9C14A0((const void **)(a1 + 280));
  sub_1BB9BE1C0((const void **)(a1 + 272));

  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1BB9CD15C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v4 = WeakRetained;
    id v3 = WeakRetained;
    objc_sync_enter(v3);
    [v3 addObject:*(void *)(a1 + 32)];
    objc_sync_exit(v3);

    id WeakRetained = v4;
  }
}

void sub_1BB9CD1CC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1BB9CD5A0(_Unwind_Exception *a1)
{
  for (uint64_t i = 8; i != -8; i -= 8)
  for (uint64_t j = 8; j != -8; j -= 8)

  _Unwind_Resume(a1);
}

void sub_1BB9CDC74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  for (uint64_t i = 8; i != -8; i -= 8)
  for (uint64_t j = 8; j != -8; j -= 8)

  _Unwind_Resume(a1);
}

void sub_1BB9CDD0C(uint64_t a1, void *a2)
{
  *a2 = 0;
  operator new();
}

void sub_1BB9CDE10(_Unwind_Exception *a1)
{
  if (!atomic_fetch_add(v2, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }

  _Unwind_Resume(a1);
}

void sub_1BB9CDE60(std::__assoc_sub_state *a1)
{
}

void sub_1BB9CDE98(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  __cxa_begin_catch(a1);
  std::current_exception();
  v11.__ptr_ = &a10;
  std::__assoc_sub_state::set_exception(v10, v11);
  std::exception_ptr::~exception_ptr(&a10);
  __cxa_end_catch();
  JUMPOUT(0x1BB9CDE88);
}

void sub_1BB9CDEC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
}

void sub_1BB9CDEDC(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9CDF60(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1BB9CE2EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CE8D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,const void *a29)
{
  sub_1BB9BE124(&a29);
  _Unwind_Resume(a1);
}

void sub_1BB9CE9D0(uint64_t a1)
{
  [*(id *)(a1 + 152) waitUntilCompleted];
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 160));
  unint64_t v3 = *(void *)(a1 + 176) * *(void *)(a1 + 168);
  uint64x2_t v4 = 0uLL;
  if (v3 < 0x11)
  {
    if (!v3)
    {
      int64x2_t v17 = 0u;
      int64x2_t v18 = 0u;
      uint64_t v11 = 0;
      int64x2_t v15 = 0u;
      int64x2_t v16 = 0u;
      goto LABEL_10;
    }
    uint64x2_t v5 = 0uLL;
    uint64x2_t v6 = 0uLL;
    uint64x2_t v7 = 0uLL;
  }
  else
  {
    uint64x2_t v5 = 0uLL;
    uint64x2_t v6 = 0uLL;
    uint64x2_t v7 = 0uLL;
    do
    {
      uint32x4_t v8 = *((uint32x4_t *)BytePtr + 1);
      uint32x4_t v10 = *((uint32x4_t *)BytePtr + 2);
      uint32x4_t v9 = *((uint32x4_t *)BytePtr + 3);
      uint64x2_t v5 = vaddw_high_u32(vaddw_high_u32(v5, *(uint32x4_t *)BytePtr), v10);
      uint64x2_t v6 = vaddw_u32(vaddw_u32(v6, *(uint32x2_t *)v8.i8), *(uint32x2_t *)v9.i8);
      uint64x2_t v4 = vaddw_u32(vaddw_u32(v4, *(uint32x2_t *)BytePtr), *(uint32x2_t *)v10.i8);
      uint64x2_t v7 = vaddw_high_u32(vaddw_high_u32(v7, v8), v9);
      BytePtr += 64;
      v3 -= 16;
    }
    while (v3 > 0x10);
  }
  uint64_t v11 = 0;
  do
  {
    unsigned int v12 = *(_DWORD *)BytePtr;
    BytePtr += 4;
    v11 += v12;
    --v3;
  }
  while (v3);
  int64x2_t v15 = (int64x2_t)v7;
  int64x2_t v16 = (int64x2_t)v6;
  int64x2_t v17 = (int64x2_t)v5;
  int64x2_t v18 = (int64x2_t)v4;
LABEL_10:
  std::mutex::lock((std::mutex *)(a1 + 24));
  if ((*(unsigned char *)(a1 + 136) & 1) != 0
    || (v19.__ptr_ = 0, uint64_t v13 = *(void *)(a1 + 16), std::exception_ptr::~exception_ptr(&v19), v13))
  {
    sub_1BB9CC800(2u);
  }
  int64x2_t v14 = vaddq_s64(vaddq_s64(v18, v16), vaddq_s64(v17, v15));
  *(void *)(a1 + 144) = v14.i64[1] + v11 + v14.i64[0];
  *(_DWORD *)(a1 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 88));
  std::mutex::unlock((std::mutex *)(a1 + 24));
}

void sub_1BB9CEB2C(void *a1)
{
  std::mutex::unlock(v2);
  __cxa_begin_catch(a1);
  std::current_exception();
  v5.__ptr_ = (void *)(v3 - 48);
  std::__assoc_sub_state::set_exception(v1, v5);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(v3 - 48));
  __cxa_end_catch();
  JUMPOUT(0x1BB9CEAF8);
}

void sub_1BB9CEB6C(_Unwind_Exception *a1)
{
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(v1 - 48));
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9CEB88(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

void sub_1BB9CEBAC(uint64_t a1)
{
  *(void *)a1 = &unk_1F14EEFE8;
  sub_1BB9BE124((const void **)(a1 + 160));

  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9CEC50(uint64_t a1)
{
  *(void *)a1 = &unk_1F14EEFE8;
  sub_1BB9BE124((const void **)(a1 + 160));

  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1BB9CEDE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9C14A0((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1BB9CEEFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9C14A0((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1BB9CF018(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9C14A0((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1BB9CF164(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CF370(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CF4AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CF768(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CFD74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CFDC8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (*(id *)(a1 + 8) != v3)
  {
    std::exception_ptr v5 = *(void **)a1;
    *(void *)a1 = 0;

    id v3 = *(id *)(a1 + 8);
  }
  *(void *)(a1 + 8) = v4;
}

void sub_1BB9CFF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BB9CFFA8(uint64_t *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  *a1 = a2;
  id v3 = dlopen("/System/Library/PrivateFrameworks/Portrait.framework/Portrait", 1);
  if (!v3)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v6 = *a1;
    int v10 = 134217984;
    uint64_t v11 = v6;
    uint64x2_t v7 = MEMORY[0x1E4F14500];
    uint32x4_t v8 = "VCPReactionObserverSession (0x%llx): portrait framework does not exist\n";
    goto LABEL_10;
  }
  id v4 = (uint64_t *)dlsym(v3, "kPTEffectAttachmentKey_ReactionEffectComplexity");
  if (v4)
  {
    uint64_t v5 = *v4;
    a1[4] = *v4;
    if (v5) {
      return;
    }
  }
  else if (a1[4])
  {
    return;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *a1;
    int v10 = 134217984;
    uint64_t v11 = v9;
    uint64x2_t v7 = MEMORY[0x1E4F14500];
    uint32x4_t v8 = "VCPReactionObserverSession (0x%llx): ReactionEffectComplexity does not exist";
LABEL_10:
    _os_log_impl(&dword_1BB9B9000, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v10, 0xCu);
  }
}

uint64_t sub_1BB9D00D0(uint64_t a1, CVBufferRef buffer, unsigned int a3)
{
  if (buffer)
  {
    CFDictionaryRef v5 = CVBufferCopyAttachments(buffer, kCVAttachmentMode_ShouldPropagate);
    CFDictionaryRef theDict = v5;
    if (v5
      && (uint64_t v6 = *(const void **)(a1 + 32)) != 0
      && CFDictionaryContainsKey(v5, v6)
      && (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, *(const void **)(a1 + 32))) != 0)
    {
      *(unsigned char *)(a1 + 24) = 0;
      int valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      BOOL v8 = valuePtr > 0;
      if (valuePtr >= 1)
      {
        uint64_t v11 = a1;
        if (atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire) != -1)
        {
          p_CFDictionaryRef theDict = (CFDictionaryRef *)&v11;
          p_p_CFDictionaryRef theDict = &p_theDict;
          std::__call_once((std::once_flag::_State_type *)(a1 + 8), &p_p_theDict, (void (__cdecl *)(void *))sub_1BB9D02DC);
        }
      }
    }
    else
    {
      BOOL v8 = 0;
    }
    sub_1BB9BE1C0((const void **)&theDict);
  }
  else
  {
    BOOL v8 = 0;
  }
  if (*(unsigned char *)(a1 + 24)) {
    uint64_t result = a3;
  }
  else {
    uint64_t result = v8;
  }
  if (*(unsigned char *)(a1 + 24)) {
    BOOL v10 = a3 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    CFDictionaryRef theDict = (CFDictionaryRef)a1;
    if (atomic_load_explicit((atomic_ullong *volatile)(a1 + 16), memory_order_acquire) != -1)
    {
      p_CFDictionaryRef theDict = &theDict;
      p_p_CFDictionaryRef theDict = &p_theDict;
      std::__call_once((std::once_flag::_State_type *)(a1 + 16), &p_p_theDict, (void (__cdecl *)(void *))sub_1BB9D022C);
    }
    return 1;
  }
  return result;
}

void sub_1BB9D020C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1BB9BE1C0((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1BB9D022C(uint64_t ****a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v2 = ****a1;
    int v3 = 134217984;
    uint64_t v4 = v2;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPReactionObserverSession (0x%llx): observer sees ReactionEffectsInProgress in avcapture device\n", (uint8_t *)&v3, 0xCu);
  }
}

void sub_1BB9D02DC(uint64_t ****a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v2 = ****a1;
    int v3 = 134217984;
    uint64_t v4 = v2;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPReactionObserverSession (0x%llx): observer sees ReactionEffectComplexity in image buffer attachment\n", (uint8_t *)&v3, 0xCu);
  }
}

uint64_t sub_1BB9D038C(uint64_t a1, const char *a2, uint64_t a3)
{
  memset(&v33[32], 0, 24);
  uint64_t v6 = (std::mutex *)(a1 + 544);
  std::mutex::lock((std::mutex *)(a1 + 544));
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.VideoProcessing");
  if (!BundleWithIdentifier || (CFURLRef v8 = CFBundleCopyResourcesDirectoryURL(BundleWithIdentifier)) == 0)
  {
    uint64_t v18 = 4294954385;
    goto LABEL_54;
  }
  size_t v9 = strlen(a2);
  CFURLRef v10 = CFURLCreateAbsoluteURLWithBytes(0, (const UInt8 *)a2, v9, 0x8000100u, v8, 0);
  CFURLRef v11 = v10;
  if (!v10)
  {
    CFStringRef v13 = 0;
    goto LABEL_12;
  }
  CFStringRef v12 = CFURLCopyPath(v10);
  CFStringRef v13 = v12;
  if (!v12)
  {
LABEL_12:
    uint64_t v18 = 4294954385;
    goto LABEL_50;
  }
  if (CFStringGetLength(v12))
  {
    CFIndex Length = CFStringGetLength(v13);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0);
    std::string::size_type v16 = MaximumSizeForEncoding + 1;
    if ((unint64_t)(MaximumSizeForEncoding + 1) >= 0x7FFFFFFFFFFFFFF8) {
      sub_1BB9D0968();
    }
    if (v16 >= 0x17)
    {
      uint64_t v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v19 = v16 | 7;
      }
      uint64_t v20 = v19 + 1;
      int64x2_t v17 = operator new(v19 + 1);
      v34.__r_.__value_.__l.__size_ = v16;
      v34.__r_.__value_.__r.__words[2] = v20 | 0x8000000000000000;
      v34.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
    }
    else
    {
      *((unsigned char *)&v34.__r_.__value_.__s + 23) = MaximumSizeForEncoding + 1;
      int64x2_t v17 = &v34;
      if (MaximumSizeForEncoding == -1) {
        goto LABEL_18;
      }
    }
    bzero(v17, v16);
LABEL_18:
    *((unsigned char *)v17 + v16) = 0;
    if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v21 = &v34;
    }
    else {
      size_t v21 = (std::string *)v34.__r_.__value_.__r.__words[0];
    }
    if (CFStringGetCString(v13, (char *)v21, v16, 0))
    {
      std::string::size_type size = HIBYTE(v34.__r_.__value_.__r.__words[2]);
      uint64_t v23 = &v34;
      if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        std::string::size_type size = v34.__r_.__value_.__l.__size_;
        uint64_t v23 = (std::string *)v34.__r_.__value_.__r.__words[0];
      }
      while (size)
      {
        if (v23->__r_.__value_.__s.__data_[--size])
        {
          if (size != -1) {
            std::string::resize(&v34, size + 1, 0);
          }
          break;
        }
      }
      *(std::string *)size_t v33 = v34;
    }
    else
    {
      sub_1BB9D08B8(v33, "");
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v34.__r_.__value_.__l.__data_);
      }
    }
    if ((v33[55] & 0x80000000) != 0) {
      operator delete(*(void **)&v33[32]);
    }
    goto LABEL_33;
  }
  sub_1BB9D08B8(v33, "");
LABEL_33:
  *(std::string *)&v33[32] = *(std::string *)v33;
  if (!*(void *)a1)
  {
    char v25 = operator new(0x28uLL);
    v25[1] = 0;
    v25[2] = 0;
    *char v25 = &unk_1F14EEB68;
    v25[3] = 0;
    uint64_t v26 = v25 + 3;
    *((_DWORD *)v25 + 8) = 10007;
    uint64_t context = espresso_create_context();
    v25[3] = context;
    if (!context)
    {
      *((_DWORD *)v25 + 8) = 5;
      uint64_t v28 = espresso_create_context();
      *uint64_t v26 = v28;
      if (!v28)
      {
        *((_DWORD *)v25 + 8) = 0;
        *uint64_t v26 = espresso_create_context();
      }
    }
    *(void *)&long long v29 = v25 + 3;
    *((void *)&v29 + 1) = v25;
    uint64_t v30 = *(std::__shared_weak_count **)(a1 + 8);
    *(_OWORD *)a1 = v29;
    if (v30 && (sub_1BB9C09B4(v30), !*(void *)a1)
      || (uint64_t plan = espresso_create_plan(), (*(void *)(a1 + 16) = plan) == 0))
    {
      uint64_t v18 = 4294954392;
      goto LABEL_50;
    }
    uint64_t v18 = espresso_plan_add_network();
    if (v18) {
      goto LABEL_50;
    }
    if (a3)
    {
      uint64_t v18 = espresso_network_select_configuration();
      if (v18) {
        goto LABEL_50;
      }
    }
    uint64_t v18 = espresso_plan_build();
    if (v18) {
      goto LABEL_50;
    }
    if (!*(unsigned char *)(a1 + 608))
    {
      uint64_t v18 = espresso_network_bind_buffer();
      if (!v18)
      {
        uint64_t v18 = espresso_network_bind_buffer();
        if (!v18) {
          uint64_t v18 = espresso_network_bind_buffer();
        }
      }
      goto LABEL_50;
    }
  }
  uint64_t v18 = 0;
LABEL_50:
  CFRelease(v8);
  if (v11) {
    CFRelease(v11);
  }
  if (v13) {
    CFRelease(v13);
  }
LABEL_54:
  std::mutex::unlock(v6);
  if ((v33[55] & 0x80000000) != 0) {
    operator delete(*(void **)&v33[32]);
  }
  return v18;
}

void sub_1BB9D079C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  std::mutex::unlock(v24);
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9D0810(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    uint64_t result = espresso_context_destroy();
    *(void *)(a1 + 24) = 0;
  }
  return result;
}

void sub_1BB9D0844(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14EEB68;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9D0898(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14EEB68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *sub_1BB9D08B8(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_1BB9D0968();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void sub_1BB9D0968()
{
}

uint64_t VCPSessionGetTypeID()
{
  return qword_1E9F815A8;
}

uint64_t sub_1BB9D09B8()
{
  qword_1E9F815B0 = 0;
  *(void *)algn_1E9F815B8 = "VCPSession";
  qword_1E9F815C0 = (uint64_t)nullsub_4;
  unk_1E9F815C8 = 0;
  qword_1E9F815D0 = (uint64_t)sub_1BB9D0A18;
  unk_1E9F815D8 = 0u;
  unk_1E9F815E8 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1E9F815A8 = result;
  return result;
}

void *sub_1BB9D0A18(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (void *)result[3];
    if (v2 && sub_1BB9C9C98() != 1)
    {
      sub_1BB9C9D0C(v2);
      free(v2);
    }
    v1[3] = 0;
    uint64_t v3 = v1[4];
    if (v3)
    {
      sub_1BB9C2444(v1[4]);
      MEMORY[0x1C18605E0](v3, 0x10B0C40E486B3C3);
    }
    v1[4] = 0;
    uint64_t result = (void *)v1[5];
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
    v1[5] = 0;
  }
  return result;
}

uint64_t VCPSessionPrewarm(int a1, const __CFDictionary *a2)
{
  if (a1 == 1936548208)
  {
    uint64_t v2 = (const void *)VCPSessionCreate(0, 1936548208, a2);
    if (v2)
    {
      CFRelease(v2);
      return 0;
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCP light spill session creation failed during session pre-warm", buf, 2u);
      }
      return 4294943592;
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)size_t v4 = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Unsupported type parameter for session pre-warm", v4, 2u);
    }
    return 4294943593;
  }
}

uint64_t VCPSessionCreate(uint64_t a1, int a2, const __CFDictionary *a3)
{
  pthread_once(&stru_1E9F80A48, (void (*)(void))sub_1BB9D09B8);
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v6 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 32) = 0;
    *(void *)(Instance + 40) = 0;
    *(_DWORD *)(Instance + 16) = a2;
    if (a2 <= 1634889062)
    {
      if (a2 != 1634889062)
      {
LABEL_49:
        CFRelease((CFTypeRef)Instance);
        return 0;
      }
      if (sub_1BB9C9C98() != 1) {
        *(void *)(v6 + 24) = malloc_type_calloc(0x3C0uLL, 1uLL, 0x55E39E3uLL);
      }
    }
    else
    {
      if (a2 == 1634889063) {
        operator new();
      }
      if (a2 != 1684632680)
      {
        if (a2 == 1936548208)
        {
          if (a3)
          {
            if (CFDictionaryContainsKey(a3, @"SpillmapWidth"))
            {
              LODWORD(valuePtr) = 0;
              CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, @"SpillmapWidth");
              if (Value) {
                CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
              }
            }
            if (CFDictionaryContainsKey(a3, @"SpillmapHeight"))
            {
              LODWORD(valuePtr) = 0;
              CFNumberRef v9 = (const __CFNumber *)CFDictionaryGetValue(a3, @"SpillmapHeight");
              if (v9) {
                CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr);
              }
            }
            BOOL v8 = CFDictionaryContainsKey(a3, @"SpillmapUseAttachment")
              && (CFBooleanRef v10 = (const __CFBoolean *)CFDictionaryGetValue(a3, @"SpillmapUseAttachment")) != 0
              && CFBooleanGetValue(v10) != 0;
            if (CFDictionaryContainsKey(a3, @"SpillmapLayout"))
            {
              LODWORD(valuePtr) = 0;
              CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(a3, @"SpillmapLayout");
              if (v11) {
                CFNumberGetValue(v11, kCFNumberSInt32Type, &valuePtr);
              }
            }
            if (CFDictionaryContainsKey(a3, @"SpillmapIntermediateWidth"))
            {
              LODWORD(valuePtr) = 0;
              CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(a3, @"SpillmapIntermediateWidth");
              if (v12) {
                CFNumberGetValue(v12, kCFNumberSInt32Type, &valuePtr);
              }
            }
            if (CFDictionaryContainsKey(a3, @"SpillmapIntermediateHeight"))
            {
              LODWORD(valuePtr) = 0;
              CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(a3, @"SpillmapIntermediateHeight");
              if (v13) {
                CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr);
              }
            }
            if (CFDictionaryContainsKey(a3, @"SpillmapIntermediateBlurSigma"))
            {
              CFStringRef valuePtr = 0;
              CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(a3, @"SpillmapIntermediateBlurSigma");
              if (v14) {
                CFNumberGetValue(v14, kCFNumberDoubleType, &valuePtr);
              }
            }
          }
          else
          {
            BOOL v8 = 0;
          }
          CFStringRef v15 = (const __CFString *)CFPreferencesCopyAppValue(@"SpillmapWidth", @"com.apple.VideoProcessing");
          CFStringRef valuePtr = v15;
          if (v15) {
            CFStringGetIntValue(v15);
          }
          CFStringRef v16 = (const __CFString *)CFPreferencesCopyAppValue(@"SpillmapHeight", @"com.apple.VideoProcessing");
          if (v16) {
            CFStringGetIntValue(v16);
          }
          CFStringRef v17 = (const __CFString *)CFPreferencesCopyAppValue(@"SpillmapLayout", @"com.apple.VideoProcessing");
          if (v17) {
            CFStringGetIntValue(v17);
          }
          CFStringRef v18 = (const __CFString *)CFPreferencesCopyAppValue(@"SpillmapIntermediateTextureWidth", @"com.apple.VideoProcessing");
          if (v18) {
            CFStringGetIntValue(v18);
          }
          CFStringRef v19 = (const __CFString *)CFPreferencesCopyAppValue(@"SpillmapIntermediateTextureHeight", @"com.apple.VideoProcessing");
          if (v19) {
            CFStringGetIntValue(v19);
          }
          CFStringRef v20 = (const __CFString *)CFPreferencesCopyAppValue(@"SpillmapIntermediateGaussianSigma", @"com.apple.VideoProcessing");
          if (v20) {
            CFStringGetDoubleValue(v20);
          }
          if (v8) {
            operator new();
          }
          operator new();
        }
        goto LABEL_49;
      }
    }
  }
  return v6;
}

void sub_1BB9D1148(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  size_t v5 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v7 = va_arg(va3, const void *);
  va_copy(va4, va3);
  CFNumberRef v9 = va_arg(va4, const void *);
  sub_1BB9BE158((const void **)va);
  sub_1BB9BE158((const void **)va1);
  sub_1BB9BE158((const void **)va2);
  sub_1BB9BE158((const void **)va3);
  sub_1BB9BE158((const void **)va4);
  _Unwind_Resume(a1);
}

uint64_t VCPSessionExecute(uint64_t a1, CFDictionaryRef theDict, CVPixelBufferRef *a3, uint64_t a4, CVPixelBufferRef *a5)
{
  value[16] = *(void **)MEMORY[0x1E4F143B8];
  if (!a1) {
    return 4294943593;
  }
  uint64_t v8 = 0;
  int v9 = *(_DWORD *)(a1 + 16);
  if (v9 <= 1684632679)
  {
    if (v9 == 1634889062)
    {
      uint64_t v245 = 0;
      if (theDict)
      {
        value[0] = 0;
        if (CFDictionaryGetValueIfPresent(theDict, @"used_width", (const void **)value)) {
          CFNumberGetValue((CFNumberRef)value[0], kCFNumberSInt32Type, (char *)&v245 + 4);
        }
        if (CFDictionaryGetValueIfPresent(theDict, @"used_height", (const void **)value))
        {
          CFNumberGetValue((CFNumberRef)value[0], kCFNumberSInt32Type, &v245);
          int v14 = v245;
        }
        else
        {
          int v14 = 0;
        }
        int v24 = HIDWORD(v245);
      }
      else
      {
        int v14 = 0;
        int v24 = 0;
      }
      uint64_t v25 = *(void *)(a1 + 24);
      uint64_t v26 = *a3;
      size_t v27 = *a5;
      if (sub_1BB9C9C98() != 1)
      {
        size_t Width = CVPixelBufferGetWidth(v26);
        size_t Height = CVPixelBufferGetHeight(v26);
        size_t v30 = CVPixelBufferGetWidth(v27);
        size_t v31 = CVPixelBufferGetHeight(v27);
        uint64_t v8 = 4294943593;
        if (!v25 || (Width & 0xF) != 0 || Width != v30 || Height != v31) {
          return v8;
        }
        if (byte_1E9F8159C == 1)
        {
          int v32 = dword_1E9F81598;
        }
        else
        {
          CFNumberRef number = (CFNumberRef)100;
          if (sysctlbyname("hw.machine", value, (size_t *)&number, 0, 0))
          {
            int v32 = 0;
          }
          else if (strstr((char *)value, "iPhone"))
          {
            int v32 = 1;
          }
          else if (strstr((char *)value, "iPad"))
          {
            int v32 = 2;
          }
          else if (strstr((char *)value, "x86_64"))
          {
            int v32 = 3;
          }
          else
          {
            int v32 = 0;
          }
          dword_1E9F81598 = v32;
          byte_1E9F8159C = 1;
        }
        float v212 = 0.0;
        if (v24 && v14 && v32)
        {
          if (v32 == 2)
          {
            float v212 = 2.0;
          }
          else if (v32 == 1)
          {
            if (v14 < 192 || v24 < 256) {
              float v212 = 2.5;
            }
            else {
              float v212 = 3.0;
            }
          }
        }
        size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v26, 0);
        if (v26 == v27)
        {
          CVPixelBufferLockBaseAddress(v26, 0);
          BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(v26, 0);
          sub_1BB9C9D5C(v25, BaseAddressOfPlane, BytesPerRowOfPlane, Width, Height, (uint64_t)BaseAddressOfPlane, BytesPerRowOfPlane, v212);
        }
        else
        {
          size_t v215 = CVPixelBufferGetBytesPerRowOfPlane(v27, 0);
          CVPixelBufferLockBaseAddress(v26, 0);
          CVPixelBufferLockBaseAddress(v27, 0);
          int16x8_t v216 = (char *)CVPixelBufferGetBaseAddressOfPlane(v26, 0);
          int16x8_t v217 = CVPixelBufferGetBaseAddressOfPlane(v27, 0);
          sub_1BB9C9D5C(v25, v216, BytesPerRowOfPlane, Width, Height, (uint64_t)v217, v215, v212);
          CVPixelBufferUnlockBaseAddress(v26, 0);
          uint64_t v26 = v27;
        }
        CVPixelBufferUnlockBaseAddress(v26, 0);
      }
      return 0;
    }
    else if (v9 == 1634889063)
    {
      if (CVPixelBufferGetPixelFormatType(*a3) == 846624121 && CVPixelBufferGetPixelFormatType(*a5) == 846624121)
      {
        float v239 = 0.0;
        float valuePtr = 0.0;
        if (theDict)
        {
          value[0] = 0;
          if (CFDictionaryGetValueIfPresent(theDict, @"phase_x", (const void **)value)) {
            CFNumberGetValue((CFNumberRef)value[0], kCFNumberFloatType, &valuePtr);
          }
          if (CFDictionaryGetValueIfPresent(theDict, @"phase_y", (const void **)value))
          {
            CFNumberGetValue((CFNumberRef)value[0], kCFNumberFloatType, &v239);
            float v11 = v239;
          }
          else
          {
            float v11 = 0.0;
          }
          float v33 = valuePtr;
        }
        else
        {
          float v11 = 0.0;
          float v33 = 0.0;
        }
        uint64_t v8 = 4294943593;
        if (v11 < -0.5 || v33 > 0.5 || v33 < -0.5 || v11 > 0.5) {
          return v8;
        }
        int32x4_t v137 = *(unsigned __int16 **)(a1 + 32);
        int32x4_t v138 = *a3;
        int16x8_t v139 = *a5;
        unsigned int v244 = 0;
        LODWORD(v245) = 0;
        int v243 = CVPixelBufferGetWidth(v138);
        unsigned int v140 = CVPixelBufferGetHeight(v138);
        unsigned int v241 = v140;
        int v141 = CVPixelBufferGetWidth(v139);
        int v142 = CVPixelBufferGetHeight(v139);
        CFNumberRef v143 = (const __CFNumber *)CVBufferCopyAttachment(v138, (CFStringRef)*MEMORY[0x1E4F24A78], 0);
        CFNumberRef number = v143;
        float v230 = v33;
        if (v143)
        {
          value[0] = 0;
          if (CFDictionaryGetValueIfPresent(v143, (const void *)*MEMORY[0x1E4F24A70], (const void **)value)) {
            CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &v245);
          }
          if (CFDictionaryGetValueIfPresent(number, (const void *)*MEMORY[0x1E4F24A80], (const void **)value)) {
            CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &v244);
          }
          if (CFDictionaryGetValueIfPresent(number, (const void *)*MEMORY[0x1E4F24A88], (const void **)value))
          {
            CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &v243);
            size_t v144 = CVPixelBufferGetWidth(v138);
            LODWORD(v245) = v245 + ((v144 - v243) >> 1);
          }
          if (CFDictionaryGetValueIfPresent(number, (const void *)*MEMORY[0x1E4F24A68], (const void **)value))
          {
            CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &v241);
            size_t v145 = CVPixelBufferGetHeight(v138);
            unsigned int v140 = v241;
            v244 += (v145 - v241) >> 1;
          }
          if (v245)
          {
            uint64_t v8 = 4294943593;
LABEL_253:
            p_CFNumberRef number = (const void **)&number;
            goto LABEL_254;
          }
        }
        float v226 = v11;
        uint64_t v228 = v138;
        long long v232 = v137 + 4112;
        unsigned __int16 v146 = v243;
        if (v243 != *v137 || v140 != v137[1] || v137[2] != v141 || v137[3] != v142)
        {
          int16x8_t v224 = v139;
          sub_1BB9C2444((uint64_t)v137);
          *int32x4_t v137 = v146;
          v137[1] = v140;
          v137[2] = v141;
          v137[3] = v142;
          float v147 = (float)(unsigned __int16)v141 / (float)v146;
          if (v147 >= 1.0) {
            float v147 = 1.0;
          }
          unsigned int v148 = vcvtps_s32_f32(3.0 / v147);
          *((float *)v137 + 2) = v147;
          if (v148 >= 0x10) {
            LOWORD(v148) = 16;
          }
          v137[6] = v148;
          *long long v232 = ((_BYTE)v148 + 7) & 0x38;
          HIDWORD(v245) = 1;
          value[0] = (void *)4;
          if (sysctlbyname("hw.logicalcpu", (char *)&v245 + 4, (size_t *)value, 0, 0)) {
            fwrite("Failed to query number of CPUs\n", 0x1FuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
          }
          unsigned int v149 = v137[3];
          unsigned int v150 = ((HIDWORD(v245) - 1 + v149) / HIDWORD(v245) + 1) & 0xFFFFFFFE;
          unsigned __int16 v151 = WORD2(v245) - (v150 * (HIDWORD(v245) - 1) > v149);
          v137[4113] = v151;
          uint64_t v152 = v151;
          int32x4_t v153 = operator new[](24 * v152, MEMORY[0x1E4FBA2D0]);
          if (!v153)
          {
            *((void *)v137 + 1035) = 0;
LABEL_252:
            uint64_t v8 = 4294943590;
            goto LABEL_253;
          }
          if (v152)
          {
            int32x4_t v154 = v153;
            do
            {
              *int32x4_t v154 = 0;
              v154[2] = 0;
              v154 += 3;
            }
            while (v154 != &v153[3 * v152]);
            __int16 v155 = 0;
            *((void *)v137 + 1035) = v153;
            uint64_t v156 = (unsigned __int16)*v232;
            size_t v157 = 8 * v156 + 4 * ((unsigned __int16)((*v137 >> 1) + 7) & 0xFFF8) + 14;
            int16x8_t v158 = v153 + 2;
            int16x8_t v159 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
            while (1)
            {
              *(v158 - 2) = v137 + 4116;
              *((_WORD *)v158 - 4) = v150 * v155++;
              __int16 v160 = v149 >= (unsigned __int16)(v150 * v155) ? v150 * v155 : v149;
              *((_WORD *)v158 - 3) = v160;
              int16x8_t v161 = (char *)operator new[](v157, v159);
              *int16x8_t v158 = v161;
              if (!v161) {
                goto LABEL_252;
              }
              *int16x8_t v158 = &v161[2 * v156];
              v158 += 3;
              if (!--v152) {
                goto LABEL_225;
              }
            }
          }
          *((void *)v137 + 1035) = v153;
LABEL_225:
          dispatch_group_t v162 = dispatch_group_create();
          *((void *)v137 + 1037) = v162;
          if (!v162) {
            goto LABEL_252;
          }
          uint64_t v163 = 0;
          __int16 v164 = v137 + 16;
          double v165 = 3.0;
          int16x8_t v139 = v224;
          do
          {
            float v166 = (float)(int)v163 * -0.0078125;
            if (fabsf(v166) >= 0.00001)
            {
              double v170 = v166 * 3.14159265;
              float v236 = *((float *)v137 + 2);
              double v168 = v236;
              double v171 = v170 * v236;
              float v172 = v171;
              double v173 = sinf(v172) / v171;
              double v174 = v170 / v165 * v236;
              float v175 = v174;
              float v169 = v173 * (sinf(v175) / v174);
              uint64_t v167 = v137[6];
              *((float *)value + v167 - 1) = v169;
            }
            else
            {
              uint64_t v167 = v137[6];
              *((_DWORD *)value + v167 - 1) = 1065353216;
              float v236 = *((float *)v137 + 2);
              double v168 = v236;
              float v169 = 1.0;
            }
            float v176 = v166 + 1.0;
            double v177 = (float)(v166 + 1.0) * 3.14159265;
            float v178 = v177 * v168;
            double v179 = sinf(v178) / (v177 * v168);
            double v180 = v177 / 3.0 * v168;
            float v181 = v180;
            float v182 = v179 * (sinf(v181) / v180);
            float v183 = v169 + v182;
            *((float *)value + v167) = v182;
            if (v167 >= 2)
            {
              uint64_t v184 = 4 * v167;
              int v185 = (float *)((char *)value + v184 + 4);
              do
              {
                float v166 = v166 + -1.0;
                float v186 = 0.0;
                float v187 = 0.0;
                if (v166 > (float)(-3.0 / v236))
                {
                  double v188 = v166 * 3.14159265;
                  float v189 = v188 * v168;
                  double v190 = sinf(v189) / (v188 * v168);
                  double v191 = v188 / 3.0 * v168;
                  float v192 = v191;
                  float v187 = v190 * (sinf(v192) / v191);
                }
                float v176 = v176 + 1.0;
                *(float *)((char *)&value[-1] + v184) = v187;
                if (v176 < (float)(3.0 / v236))
                {
                  double v193 = v176 * 3.14159265;
                  float v194 = v193 * v168;
                  double v195 = sinf(v194) / (v193 * v168);
                  double v196 = v193 / 3.0 * v168;
                  float v197 = v196;
                  float v186 = v195 * (sinf(v197) / v196);
                }
                *v185++ = v186;
                float v183 = v183 + (float)(v187 + v186);
                v184 -= 4;
              }
              while (v184 != 4);
            }
            unsigned int v198 = 2 * v167;
            __int16 v199 = 0;
            if (v167)
            {
              if (v198 <= 1) {
                uint64_t v200 = 1;
              }
              else {
                uint64_t v200 = v198;
              }
              int16x8_t v201 = value;
              int16x8_t v202 = v164;
              double v165 = 3.0;
              do
              {
                float v203 = *(float *)v201 / v183;
                *(float *)int16x8_t v201 = v203;
                int16x8_t v201 = (void **)((char *)v201 + 4);
                unsigned __int16 v204 = llroundf(v203 * 64.0);
                *v202++ = v204;
                v199 += v204;
                --v200;
              }
              while (v200);
            }
            else
            {
              double v165 = 3.0;
            }
            uint64_t v205 = (uint64_t)&v137[32 * v163 + 16];
            uint64_t v206 = v205 + 2 * v167;
            int v209 = *(__int16 *)(v206 - 2);
            int16x8_t v207 = (_WORD *)(v206 - 2);
            __int16 v208 = v209;
            if (v209 <= *(__int16 *)(v205 + 2 * v167))
            {
              __int16 v208 = *(_WORD *)(v205 + 2 * v167);
              int16x8_t v207 = (_WORD *)(v205 + 2 * v167);
            }
            *int16x8_t v207 = v208 - v199 + 64;
            bzero((void *)(v205 + 2 * v198), 2 * (int)(32 - v198));
            ++v163;
            v164 += 32;
          }
          while (v163 != 128);
        }
        CVPixelBufferLockBaseAddress(v228, 1uLL);
        CVPixelBufferLockBaseAddress(v139, 0);
        *((void *)v137 + 1030) = CVPixelBufferGetBaseAddress(v228);
        *((void *)v137 + 1031) = CVPixelBufferGetBytesPerRow(v228);
        *((void *)v137 + 1032) = CVPixelBufferGetBaseAddress(v139);
        *((void *)v137 + 1033) = CVPixelBufferGetBytesPerRow(v139);
        *((float *)v137 + 2068) = v230;
        *((float *)v137 + 2069) = v226;
        *((void *)v137 + 1030) += (2 * v245) + *((void *)v137 + 1031) * v244;
        if (v137[4113])
        {
          uint64_t v210 = 0;
          unint64_t v211 = 0;
          do
          {
            dispatch_group_async_f(*((dispatch_group_t *)v137 + 1037), *((dispatch_queue_t *)v137 + 1036), (void *)(*((void *)v137 + 1035) + v210), (dispatch_function_t)sub_1BB9C250C);
            ++v211;
            v210 += 24;
          }
          while (v211 < v137[4113]);
        }
        dispatch_group_wait(*((dispatch_group_t *)v137 + 1037), 0xFFFFFFFFFFFFFFFFLL);
        *((_DWORD *)v137 + 4) = ((unsigned __int16)*((_DWORD *)v137 + 4)
                               + (unsigned __int16)((3 * v137[2] * v137[3]) >> 1)
                               + (**((unsigned char **)v137 + 1030) & 1)) & 0xFFF;
        CVPixelBufferUnlockBaseAddress(v228, 0);
        CVPixelBufferUnlockBaseAddress(v139, 0);
        uint64_t v8 = 0;
        goto LABEL_253;
      }
      return 4294943593;
    }
    return v8;
  }
  if (v9 == 1684632680)
  {
    if (CVPixelBufferGetPixelFormatType(*a3) != 1983000880 || CVPixelBufferGetPixelFormatType(*a5) != 846624121) {
      return 4294943593;
    }
    CFStringRef v15 = *a3;
    CFStringRef v16 = *a5;
    CVPixelBufferLockBaseAddress(v15, 0);
    CVPixelBufferLockBaseAddress(v16, 0);
    unsigned int v17 = CVPixelBufferGetWidth(v15);
    int v18 = CVPixelBufferGetHeight(v15);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(v15);
    int BytesPerRow = CVPixelBufferGetBytesPerRow(v15);
    size_t v21 = (__CVBuffer *)CVPixelBufferGetBaseAddress(v16);
    int v229 = CVPixelBufferGetBytesPerRow(v16);
    int v231 = v18;
    uint64_t v245 = 0;
    int v243 = v18;
    unsigned int v244 = v17;
    CFTypeRef v22 = CVBufferCopyAttachment(v15, (CFStringRef)*MEMORY[0x1E4F24A78], 0);
    value[0] = (void *)v22;
    if (v22)
    {
      CFNumberRef number = 0;
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v22, (const void *)*MEMORY[0x1E4F24A70], (const void **)&number))
      {
        CFNumberGetValue(number, kCFNumberIntType, (char *)&v245 + 4);
      }
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value[0], (const void *)*MEMORY[0x1E4F24A80], (const void **)&number))
      {
        CFNumberGetValue(number, kCFNumberIntType, &v245);
      }
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value[0], (const void *)*MEMORY[0x1E4F24A88], (const void **)&number))
      {
        CFNumberGetValue(number, kCFNumberIntType, &v244);
        HIDWORD(v245) += (v17 - v244) >> 1;
      }
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)value[0], (const void *)*MEMORY[0x1E4F24A68], (const void **)&number))
      {
        CFNumberGetValue(number, kCFNumberIntType, &v243);
        LODWORD(v245) = v245 + ((v18 - v243) >> 1);
        int v231 = v243;
      }
      int v23 = HIDWORD(v245);
      if ((v245 & 0x100000000) != 0) {
        goto LABEL_179;
      }
      unsigned int v17 = v244;
    }
    else
    {
      int v23 = 0;
    }
    if (((v17 | v231) & 1) == 0)
    {
      CVPixelBufferRef v227 = v21;
      int v225 = v23 + v17;
      int v34 = 2 * (v23 + v17);
      if (v34 + 10 >= BytesPerRow) {
        goto LABEL_278;
      }
      LODWORD(number) = 0;
      int v35 = dword_1E9F81538;
      if (v231 >= 1)
      {
        int v36 = 0;
        unsigned int v37 = 0;
        int v38 = BytesPerRow >> 2;
        int v39 = 2 * v23;
        int v238 = v34 - 1;
        int v40 = v23 / 6;
        int v219 = v38;
        int v41 = v38 * v245;
        unsigned int v223 = &BaseAddress[16 * v40];
        int v237 = v225 - 7;
        int v220 = 6 * v40 + 6;
        int v221 = (12 * v40) | 3;
        int v222 = 12 * v40;
        while (1)
        {
          int v235 = v36;
          LODWORD(number) = ((_WORD)number + (_WORD)v36 + (_WORD)v35) & 0xFFF;
          int v233 = v41;
          uint64_t v42 = (unsigned int *)&v223[4 * v41];
          unsigned int v234 = v37;
          long long v43 = (char *)v227 + v37;
          char v44 = 1;
          int v45 = v221;
          int v46 = v222;
          do
          {
            char v47 = v44;
            int v48 = v46;
            int v49 = sub_1BB9C1C10(*v42, (int *)&number, v43, v46, v39, v238);
            if (number > 0xFFF) {
              goto LABEL_278;
            }
            unsigned int v50 = v42[1];
            unsigned int v51 = (v50 >> 10) & 0x3FF;
            unsigned int v52 = (v50 >> 20) & 0x3FF;
            if (v52 <= 0x43) {
              uint64_t v53 = byte_1BBB74C68;
            }
            else {
              uint64_t v53 = (char *)&unk_1BBB75C68;
            }
            unsigned int v54 = v42[1] & 0x3FF;
            int v55 = (int)(v52 + v53[number]) >> 2;
            if (v55 >= 255) {
              LOBYTE(v55) = -1;
            }
            if (v54 <= 0x43) {
              unint64_t v56 = byte_1BBB74C68;
            }
            else {
              unint64_t v56 = (char *)&unk_1BBB75C68;
            }
            int v57 = (int)(v54 + v56[((_WORD)number + 1) & 0xFFF]) >> 2;
            if (v57 >= 255) {
              LOBYTE(v57) = -1;
            }
            LOBYTE(v241) = v57;
            if (v55 > 0x11u)
            {
              int v59 = 512 - v51;
              if (v51 >= 0x200) {
                int v59 = v51 - 512;
              }
              if (v59 <= 3) {
                int16x4_t v60 = byte_1BBB74C68;
              }
              else {
                int16x4_t v60 = (char *)&unk_1BBB75C68;
              }
              int v61 = v60[((_WORD)number + 2) & 0xFFF];
              unsigned int v62 = ((v51 + v61) & ~((int)(v51 + v61) >> 31)) >> 2;
              if (v62 >= 0xFF) {
                LOBYTE(v58) = -1;
              }
              else {
                LOBYTE(v58) = v62;
              }
            }
            else
            {
              unsigned int v58 = v51 >> 2;
            }
            uint64_t v63 = 0;
            int v64 = 0;
            LODWORD(number) = ((_WORD)number + 3) & 0xFFF;
            BYTE1(v241) = v58;
            BYTE2(v241) = v55;
            int32x4_t v65 = &v43[v49];
            do
            {
              if (v45 + (int)v63 >= v39 && v45 + (int)v63 < v34)
              {
                *v65++ = *((unsigned char *)&v241 + v63);
                ++v64;
              }
              ++v63;
            }
            while (v63 != 3);
            char v44 = 0;
            int v35 = ((_WORD)dword_1E9F81538 + (v55 & 1)) & 0xFFF;
            dword_1E9F81538 = v35;
            v42 += 2;
            int v46 = v48 + 6;
            v43 += v49 + (uint64_t)v64;
            v45 += 6;
          }
          while ((v47 & 1) != 0);
          int v67 = v220;
          if (v220 <= v237)
          {
            unint64_t v68 = number;
            do
            {
              v46 += 12;
              char v69 = 1;
              do
              {
                if (v68 > 0xFFF) {
                  goto LABEL_278;
                }
                char v70 = v69;
                unsigned int v71 = *v42;
                unsigned int v72 = *v42 & 0x3FF;
                unsigned int v73 = (*v42 >> 10) & 0x3FF;
                if (v73 <= 0x43) {
                  int32x4_t v74 = byte_1BBB74C68;
                }
                else {
                  int32x4_t v74 = (char *)&unk_1BBB75C68;
                }
                int v75 = (int)(v73 + v74[v68]) >> 2;
                if (v75 >= 255) {
                  LOBYTE(v75) = -1;
                }
                if (v75 > 0x11u)
                {
                  int v77 = 512 - v72;
                  if (v72 >= 0x200) {
                    int v77 = v72 - 512;
                  }
                  if (v77 <= 3) {
                    int32x4_t v78 = byte_1BBB74C68;
                  }
                  else {
                    int32x4_t v78 = (char *)&unk_1BBB75C68;
                  }
                  int v79 = v78[((_WORD)v68 + 1) & 0xFFF];
                  unsigned int v76 = ((v72 + v79) & ~((int)(v72 + v79) >> 31)) >> 2;
                  if (v76 >= 0xFF) {
                    LOBYTE(v76) = -1;
                  }
                }
                else
                {
                  unsigned int v76 = v72 >> 2;
                }
                LODWORD(number) = ((_WORD)v68 + 2) & 0xFFF;
                *long long v43 = v76;
                v43[1] = v75;
                if (number > 0xFFF) {
                  goto LABEL_278;
                }
                unsigned int v80 = (v71 >> 20) & 0x3FF;
                if (v75 > 0x11u)
                {
                  int v82 = 512 - v80;
                  if (v80 >= 0x200) {
                    int v82 = v80 - 512;
                  }
                  if (v82 <= 3) {
                    int32x4_t v83 = byte_1BBB74C68;
                  }
                  else {
                    int32x4_t v83 = (char *)&unk_1BBB75C68;
                  }
                  unsigned int v81 = ((v80 + v83[number]) & ~((int)(v80 + v83[number]) >> 31)) >> 2;
                  if (v81 >= 0xFF) {
                    LOBYTE(v81) = -1;
                  }
                }
                else
                {
                  unsigned int v81 = v80 >> 2;
                }
                LODWORD(number) = ((_WORD)number + 1) & 0xFFF;
                v43[2] = v81;
                __int16 v84 = v35 + (v75 & 1);
                dword_1E9F81538 = v84 & 0xFFF;
                if (number > 0xFFF) {
                  goto LABEL_278;
                }
                unsigned int v85 = v42[1];
                unsigned int v86 = (v85 >> 20) & 0x3FF;
                unsigned int v87 = v85 & 0x3FF;
                if (v86 <= 0x43) {
                  int32x4_t v88 = byte_1BBB74C68;
                }
                else {
                  int32x4_t v88 = (char *)&unk_1BBB75C68;
                }
                int v89 = (int)(v86 + v88[number]) >> 2;
                if (v89 >= 255) {
                  LOBYTE(v89) = -1;
                }
                if (v87 <= 0x43) {
                  int32x4_t v90 = byte_1BBB74C68;
                }
                else {
                  int32x4_t v90 = (char *)&unk_1BBB75C68;
                }
                int v91 = (int)(v87 + v90[((_WORD)number + 1) & 0xFFF]) >> 2;
                if (v91 >= 255) {
                  LOBYTE(v91) = -1;
                }
                LODWORD(number) = ((_WORD)number + 2) & 0xFFF;
                v43[3] = v91;
                if (number > 0xFFF) {
                  goto LABEL_278;
                }
                unsigned int v92 = (v85 >> 10) & 0x3FF;
                if (v89 > 0x11u)
                {
                  int v94 = 512 - v92;
                  if (v92 >= 0x200) {
                    int v94 = v92 - 512;
                  }
                  if (v94 <= 3) {
                    int32x4_t v95 = byte_1BBB74C68;
                  }
                  else {
                    int32x4_t v95 = (char *)&unk_1BBB75C68;
                  }
                  unsigned int v96 = ((v92 + v95[number]) & ~((int)(v92 + v95[number]) >> 31)) >> 2;
                  if (v96 >= 0xFF) {
                    LOBYTE(v93) = -1;
                  }
                  else {
                    LOBYTE(v93) = v96;
                  }
                }
                else
                {
                  unsigned int v93 = v92 >> 2;
                }
                char v69 = 0;
                unint64_t v68 = ((_WORD)number + 1) & 0xFFF;
                LODWORD(number) = ((_WORD)number + 1) & 0xFFF;
                v43[4] = v93;
                v43[5] = v89;
                int v35 = (v84 + (v89 & 1)) & 0xFFF;
                dword_1E9F81538 = v35;
                v42 += 2;
                v43 += 6;
              }
              while ((v70 & 1) != 0);
              v67 += 6;
            }
            while (v67 <= v237);
          }
          if (v67 < v225) {
            break;
          }
LABEL_169:
          int v41 = v233 + v219;
          unsigned int v37 = v234 + v229;
          int v36 = v235 + 1;
          if (v235 + 1 == v231) {
            goto LABEL_170;
          }
        }
        int v97 = v46 + 3;
        char v98 = 1;
        while (1)
        {
          char v99 = v98;
          int v100 = v46;
          int v101 = sub_1BB9C1C10(*v42, (int *)&number, v43, v46, v39, v238);
          if (number > 0xFFF) {
            break;
          }
          unsigned int v102 = v42[1];
          unsigned int v103 = (v102 >> 10) & 0x3FF;
          unsigned int v104 = (v102 >> 20) & 0x3FF;
          if (v104 <= 0x43) {
            int32x4_t v105 = byte_1BBB74C68;
          }
          else {
            int32x4_t v105 = (char *)&unk_1BBB75C68;
          }
          unsigned int v106 = v42[1] & 0x3FF;
          int v107 = (int)(v104 + v105[number]) >> 2;
          if (v107 >= 255) {
            LOBYTE(v107) = -1;
          }
          if (v106 <= 0x43) {
            int32x4_t v108 = byte_1BBB74C68;
          }
          else {
            int32x4_t v108 = (char *)&unk_1BBB75C68;
          }
          int v109 = (int)(v106 + v108[((_WORD)number + 1) & 0xFFF]) >> 2;
          if (v109 >= 255) {
            LOBYTE(v109) = -1;
          }
          LOBYTE(v241) = v109;
          if (v107 > 0x11u)
          {
            int v111 = 512 - v103;
            if (v103 >= 0x200) {
              int v111 = v103 - 512;
            }
            if (v111 <= 3) {
              int32x4_t v112 = byte_1BBB74C68;
            }
            else {
              int32x4_t v112 = (char *)&unk_1BBB75C68;
            }
            int v113 = v112[((_WORD)number + 2) & 0xFFF];
            unsigned int v114 = ((v103 + v113) & ~((int)(v103 + v113) >> 31)) >> 2;
            if (v114 >= 0xFF) {
              LOBYTE(v110) = -1;
            }
            else {
              LOBYTE(v110) = v114;
            }
          }
          else
          {
            unsigned int v110 = v103 >> 2;
          }
          uint64_t v115 = 0;
          int v116 = 0;
          LODWORD(number) = ((_WORD)number + 3) & 0xFFF;
          BYTE1(v241) = v110;
          BYTE2(v241) = v107;
          int32x4_t v117 = &v43[v101];
          do
          {
            if (v97 + (int)v115 >= v39 && v97 + (int)v115 < v34)
            {
              *v117++ = *((unsigned char *)&v241 + v115);
              ++v116;
            }
            ++v115;
          }
          while (v115 != 3);
          char v98 = 0;
          int v35 = ((_WORD)dword_1E9F81538 + (v107 & 1)) & 0xFFF;
          dword_1E9F81538 = v35;
          v42 += 2;
          int v46 = v100 + 6;
          v43 += v101 + (uint64_t)v116;
          v97 += 6;
          if ((v99 & 1) == 0) {
            goto LABEL_169;
          }
        }
LABEL_278:
        exit(1);
      }
LABEL_170:
      int v119 = v243;
      if (v243 >= 1)
      {
        int v120 = 0;
        LOWORD(v121) = 0;
        CVPixelBufferRef v122 = v227;
        int32x4_t v123 = (char *)v227 + v229;
        uint64_t v124 = 2 * v229;
        uint64_t v125 = (int)((v244 + 15) & 0xFFFFFFF0);
        do
        {
          __int16 v126 = v120 + v121 + v35;
          unsigned int v121 = v126 & 0xFFF;
          if ((int)v125 >= 1)
          {
            uint64_t v127 = 0;
            for (uint64_t i = 0; i < v125; i += 2)
            {
              int32x4_t v129 = (char *)v122 + v127;
              int32x4_t v130 = &v123[v127];
              uint64_t v131 = (v126 + 1) & 0xFFF;
              unsigned __int16 v132 = byte_1BBB74C68[v121] + 2 * (*((unsigned __int8 *)v122 + v127) + v123[v127]);
              unsigned int v133 = v132 & 0xFFFC;
              LOBYTE(v132) = v132 >> 2;
              unsigned __int16 v134 = byte_1BBB74C68[v131]
                   + 2 * (v123[v127 + 2] + *((unsigned __int8 *)v122 + v127 + 2));
              unsigned int v135 = v134 & 0xFFFC;
              v134 >>= 2;
              __int16 v126 = v131 + 1;
              int v35 = ((_WORD)v35 + ((v133 >> 2) & 1) + ((v135 >> 2) & 1)) & 0xFFF;
              *int32x4_t v129 = v132;
              *int32x4_t v130 = v132;
              v129[2] = v134;
              v130[2] = v134;
              unsigned int v121 = v126 & 0xFFF;
              v127 += 4;
            }
            dword_1E9F81538 = v35;
          }
          CVPixelBufferRef v122 = (CVPixelBufferRef)((char *)v122 + v124);
          v123 += v124;
          v120 += 2;
        }
        while (v120 < v119);
      }
      if (v35 >= 4096) {
        goto LABEL_278;
      }
      CVPixelBufferUnlockBaseAddress(v15, 0);
      CVPixelBufferUnlockBaseAddress(v16, 0);
      uint64_t v8 = 0;
LABEL_180:
      p_CFNumberRef number = (const void **)value;
LABEL_254:
      sub_1BB9BE1C0(p_number);
      return v8;
    }
LABEL_179:
    uint64_t v8 = 4294943593;
    goto LABEL_180;
  }
  if (v9 != 1936548208) {
    return v8;
  }
  if (a4 != 1) {
    return 4294943593;
  }
  CFNumberRef v12 = *(uint64_t (**)(void))(**(void **)(a1 + 40) + 24);

  return v12();
}

void sub_1BB9D2730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,const void *a26)
{
}

uint64_t VCPSessionSetProperty(uint64_t a1, CFTypeRef cf1, const __CFData *a3)
{
  if (a1)
  {
    if (!*(_DWORD *)(a1 + 16))
    {
      if (CFEqual(cf1, @"SCN_UUID"))
      {
        CFTypeID TypeID = CFDataGetTypeID();
        if (TypeID == CFGetTypeID(a3))
        {
          CFDataGetBytePtr(a3);
          CFDataGetLength(a3);
        }
      }
    }
  }
  return 0;
}

uint64_t VCPSessionCopyProperty()
{
  return 0;
}

CFDictionaryRef VCPSessionCreateDefaultBufferProperties(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (!a1 || *(_DWORD *)(a1 + 16)) {
    return 0;
  }
  uint64_t v27 = 0;
  uint64_t v25 = 0;
  int valuePtr = 875704438;
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  values[0] = v7;
  keys[0] = *(void **)MEMORY[0x1E4F24D70];
  uint64_t v21 = a3;
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberSInt32Type, &v21);
  values[1] = v8;
  keys[1] = *(void **)MEMORY[0x1E4F24E10];
  uint64_t v20 = a4;
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &v20);
  values[2] = v9;
  keys[2] = *(void **)MEMORY[0x1E4F24D08];
  int v18 = 16;
  int v19 = 64;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &v19);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v18);
  CFNumberRef v12 = (void *)*MEMORY[0x1E4F24D78];
  values[3] = v10;
  values[4] = v11;
  CFNumberRef v13 = (void *)*MEMORY[0x1E4F24C98];
  keys[3] = v12;
  keys[4] = v13;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v23 = 1024;
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberIntType, &v23);
  if (v15)
  {
    CFNumberRef v16 = v15;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F2EFE8], v15);
    CFRelease(v16);
  }
  uint64_t v25 = Mutable;
  uint64_t v27 = *MEMORY[0x1E4F24D20];
  CFDictionaryRef v4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 6, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(v9);
  CFRelease(v10);
  CFRelease(v11);
  CFRelease(Mutable);
  return v4;
}

CFStringRef VCPCreateNegotiatedFLS(const __CFString *a1, const __CFString *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  BOOL v4 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
  if (a1 && a2)
  {
    if (v4)
    {
      int v6 = 138543618;
      CFStringRef v7 = a1;
      __int16 v8 = 2114;
      CFStringRef v9 = a2;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPCreateNegotiatedFLS remote_FLB %{public}@  local_FLS %{public}@", (uint8_t *)&v6, 0x16u);
    }
    return sub_1BBAB0EEC(a2, a1);
  }
  else
  {
    if (v4)
    {
      int v6 = 134218240;
      CFStringRef v7 = a1;
      __int16 v8 = 2048;
      CFStringRef v9 = a2;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPCreateNegotiatedFLS remote_FLB_ptr %p local_FLS %p", (uint8_t *)&v6, 0x16u);
    }
    return 0;
  }
}

CFDataRef VCPCreateCompressedFLS(const __CFString *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  BOOL v2 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
  if (a1)
  {
    if (v2)
    {
      int v4 = 138543362;
      CFStringRef v5 = a1;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPCreateCompressedFLS FLS %{public}@ ", (uint8_t *)&v4, 0xCu);
    }
    return sub_1BBAB1440(a1);
  }
  else
  {
    if (v2)
    {
      LOWORD(v4) = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPCreateCompressedFLS FLS NULL", (uint8_t *)&v4, 2u);
    }
    return 0;
  }
}

CFStringRef VCPCreateDecompressedFLS(const __CFData *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  BOOL v2 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
  if (a1)
  {
    if (v2)
    {
      int v4 = 138543362;
      CFDataRef v5 = a1;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPCreateDecompressedFLS compressed_FLS %{public}@ ", (uint8_t *)&v4, 0xCu);
    }
    return sub_1BBAB15F4(a1);
  }
  else
  {
    if (v2)
    {
      LOWORD(v4) = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPCreateDecompressedFLS compressed_FLS NULL", (uint8_t *)&v4, 2u);
    }
    return 0;
  }
}

uint64_t VCPReactionObserverCreate(void *a1, uint64_t a2, VCPReactionAVCaptureDeviceObserver **a3)
{
  int v4 = [[VCPReactionAVCaptureDeviceObserver alloc] initWithCallerID:*a1 listener:a1 callback:a2];
  CFDataRef v5 = v4;
  if (v4)
  {
    uint64_t v6 = v4;
    uint64_t v7 = 0;
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      v9[0] = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to create VCPReactionAVCaptureDeviceObserver", (uint8_t *)v9, 2u);
    }
    uint64_t v6 = 0;
    uint64_t v7 = 4294967188;
  }

  *a3 = v6;
  return v7;
}

uint64_t VCPCodecCopyProperties(int a1, CFDictionaryRef *a2, int a3)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  keys = 0;
  unsigned int v50 = 0;
  values = 0;
  CFStringRef v48 = 0;
  switch(a1)
  {
    case 0:
      LODWORD(valuePtr) = 1;
      int v46 = 0;
      if (qword_1EC027190 != -1) {
        dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
      }
      if (dword_1EC02719C >= 8) {
        goto LABEL_17;
      }
      goto LABEL_18;
    case 1:
      if (a3 <= 41)
      {
        if (a3 != 1)
        {
          if (a3 == 20)
          {
            dword_1E9F81410 = 0;
            long long v7 = xmmword_1BBB77F4B;
            long long v8 = unk_1BBB77F5B;
            xmmword_1E9F813D0 = xmmword_1BBB77F4B;
            unk_1E9F813E0 = unk_1BBB77F5B;
            long long v9 = xmmword_1BBB77F6B;
            long long v10 = unk_1BBB77F7B;
            xmmword_1E9F813F0 = xmmword_1BBB77F6B;
            unk_1E9F81400 = unk_1BBB77F7B;
            long long v11 = *(_OWORD *)"FLS;SW:1;";
            long long v12 = unk_1BBB77F3B;
            xmmword_1E9F813B0 = *(_OWORD *)"FLS;SW:1;";
            unk_1E9F813C0 = unk_1BBB77F3B;
            if (qword_1EC027190 != -1)
            {
              dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
              long long v12 = unk_1BBB77F3B;
              long long v11 = *(_OWORD *)"FLS;SW:1;";
              long long v10 = unk_1BBB77F7B;
              long long v9 = xmmword_1BBB77F6B;
              long long v8 = unk_1BBB77F5B;
              long long v7 = xmmword_1BBB77F4B;
            }
            if (dword_1EC02719C == 255)
            {
              dword_1E9F81474 = 0;
              xmmword_1E9F81434 = v7;
              unk_1E9F81444 = v8;
              xmmword_1E9F81454 = v9;
              unk_1E9F81464 = v10;
              xmmword_1E9F81414 = v11;
              unk_1E9F81424 = v12;
              goto LABEL_47;
            }
            dword_1E9F81474 = 0;
            CFNumberRef v16 = (long long *)"FLS;VRAE:0;SW:1;";
            goto LABEL_46;
          }
LABEL_35:
          dword_1E9F81410 = 0;
          xmmword_1E9F813D0 = xmmword_1BBB77E1C;
          unk_1E9F813E0 = unk_1BBB77E2C;
          xmmword_1E9F813F0 = xmmword_1BBB77E3C;
          unk_1E9F81400 = unk_1BBB77E4C;
          xmmword_1E9F813B0 = *(_OWORD *)"FLS;";
          unk_1E9F813C0 = unk_1BBB77E0C;
          dword_1E9F81474 = 0;
          xmmword_1E9F81414 = *(_OWORD *)"FLS;";
          unk_1E9F81424 = unk_1BBB77E0C;
          xmmword_1E9F81434 = xmmword_1BBB77E1C;
          unk_1E9F81444 = unk_1BBB77E2C;
          xmmword_1E9F81454 = xmmword_1BBB77E3C;
          unk_1E9F81464 = unk_1BBB77E4C;
          goto LABEL_47;
        }
        dword_1E9F81410 = 0;
        xmmword_1E9F813F0 = xmmword_1BBB7809A;
        unk_1E9F81400 = unk_1BBB780AA;
        strcpy((char *)&xmmword_1E9F813B0, "FLS;RVRA1:1;AS:2;MS:-1;LTR;CABAC;CR:3;LF:-1;PR;CH1:4;CH:4;FA:5;");
        dword_1E9F81474 = 0;
        unsigned int v17 = (long long *)"FLS;RVRA1:0;PR;LF:-1;CR:1;CF:2;CH1:3;FA:4;";
LABEL_34:
        long long v22 = v17[1];
        xmmword_1E9F81414 = *v17;
        unk_1E9F81424 = v22;
        long long v23 = v17[2];
        long long v24 = v17[3];
        long long v25 = v17[5];
        xmmword_1E9F81454 = v17[4];
        unk_1E9F81464 = v25;
        xmmword_1E9F81434 = v23;
        unk_1E9F81444 = v24;
        goto LABEL_47;
      }
      if (a3 == 42)
      {
        dword_1E9F81410 = 0;
        unk_1E9F813E2 = 0;
        unk_1E9F813E4 = 0;
        unk_1E9F813E8 = 0;
        xmmword_1E9F813F0 = xmmword_1BBB77FD0;
        unk_1E9F81400 = unk_1BBB77FE0;
        strcpy((char *)&xmmword_1E9F813B0, "FLS;MS:-1;LF:-1;LTR;CABAC;POS:0;EOD:1;HTS:2;RR:3;");
        dword_1E9F81474 = 0;
        unsigned int v17 = (long long *)"FLS;LF:-1;POS:5;EOD:1;HTS:2;RR:3;POSE:4;";
        goto LABEL_34;
      }
      if (a3 != 43) {
        goto LABEL_35;
      }
      dword_1E9F81474 = 0;
      CFNumberRef v16 = (long long *)"FLS;RVRA1:0;";
LABEL_46:
      long long v37 = v16[3];
      xmmword_1E9F81434 = v16[2];
      unk_1E9F81444 = v37;
      long long v38 = v16[5];
      xmmword_1E9F81454 = v16[4];
      unk_1E9F81464 = v38;
      long long v39 = v16[1];
      xmmword_1E9F81414 = *v16;
      unk_1E9F81424 = v39;
LABEL_47:
      keys = @"VCPCodec_AVC1";
      CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      values = (void *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)&xmmword_1E9F813B0, 0);
      unsigned int v50 = @"VCPCodec_LRP";
      CFStringRef v14 = CFStringCreateWithCString(v13, (const char *)&xmmword_1E9F81414, 0);
LABEL_48:
      CFStringRef v48 = v14;
      int v34 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      int v35 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      CFAllocatorRef v36 = v13;
LABEL_49:
      CFDictionaryRef v5 = CFDictionaryCreate(v36, (const void **)&keys, (const void **)&values, 2, v34, v35);
LABEL_50:
      if (v5) {
        uint64_t v6 = 0;
      }
      else {
        uint64_t v6 = 4294954392;
      }
LABEL_53:
      uint64_t v40 = 0;
      *a2 = v5;
      char v41 = 1;
      do
      {
        char v42 = v41;
        long long v43 = *(&values + v40);
        if (v43) {
          CFRelease(v43);
        }
        char v41 = 0;
        uint64_t v40 = 1;
      }
      while ((v42 & 1) != 0);
      return v6;
    case 2:
      LODWORD(valuePtr) = 1;
      int v46 = 0;
      if (qword_1EC027190 != -1) {
        dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
      }
      if (dword_1EC02719C >= 9) {
LABEL_17:
      }
        int v46 = 1;
LABEL_18:
      keys = @"VCPCodec_AVC1";
      CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
      unsigned int v50 = @"VCPCodec_LRP";
      CFStringRef v14 = (const __CFString *)CFNumberCreate(v13, kCFNumberIntType, &v46);
      goto LABEL_48;
    case 3:
      int valuePtr = 0;
      sub_1BBA3D4C4(&valuePtr, a3);
      CFDictionaryRef v5 = sub_1BBAB0E24(valuePtr);
      goto LABEL_50;
    case 4:
      strncpy(byte_1E9F810E6, "FLS2;", 0xFAuLL);
      strncpy(byte_1E9F80FE0, "FLS2;", 0xFAuLL);
      if (a3 > 41)
      {
        if (a3 == 42)
        {
          dword_1E9F81392 = 0;
          xmmword_1E9F81352 = xmmword_1BBB792D5;
          unk_1E9F81362 = unk_1BBB792E5;
          xmmword_1E9F81372 = xmmword_1BBB792F5;
          unk_1E9F81382 = unk_1BBB79305;
          strcpy((char *)&xmmword_1E9F81332, "POS;EOD;HTS;RR;");
          unk_1E9F81342 = unk_1BBB792C5;
          dword_1E9F81326 = 0;
          strcpy((char *)&xmmword_1E9F812C6, "POS;EOD;HTS;RR;");
          unk_1E9F812D6 = unk_1BBB792C5;
          xmmword_1E9F812E6 = xmmword_1BBB792D5;
          unk_1E9F812F6 = unk_1BBB792E5;
          xmmword_1E9F81306 = xmmword_1BBB792F5;
          unk_1E9F81316 = unk_1BBB79305;
          goto LABEL_38;
        }
        if (a3 == 43)
        {
          dword_1E9F81392 = 0;
          xmmword_1E9F81352 = xmmword_1BBB791A6;
          unk_1E9F81362 = unk_1BBB791B6;
          xmmword_1E9F81372 = xmmword_1BBB791C6;
          unk_1E9F81382 = unk_1BBB791D6;
          xmmword_1E9F81332 = *(_OWORD *)"RVRA1;";
          unk_1E9F81342 = unk_1BBB79196;
          goto LABEL_38;
        }
      }
      else
      {
        if (a3 == 1)
        {
          dword_1E9F81392 = 0;
          xmmword_1E9F81352 = xmmword_1BBB7933A;
          unk_1E9F81362 = unk_1BBB7934A;
          xmmword_1E9F81372 = xmmword_1BBB7935A;
          unk_1E9F81382 = unk_1BBB7936A;
          strcpy((char *)&xmmword_1E9F81332, "RVRA1;CH1;CR;CF;FA;");
          unk_1E9F81346 = unk_1BBB7932E;
          unk_1E9F8134A = unk_1BBB79332;
          dword_1E9F81326 = 0;
          CFNumberRef v15 = (long long *)"RVRA1;CH1;CR;FA;";
          goto LABEL_32;
        }
        if (a3 == 20)
        {
          dword_1E9F81392 = 0;
          xmmword_1E9F81352 = xmmword_1BBB7920B;
          unk_1E9F81362 = unk_1BBB7921B;
          xmmword_1E9F81372 = xmmword_1BBB7922B;
          unk_1E9F81382 = unk_1BBB7923B;
          xmmword_1E9F81332 = *(_OWORD *)"VRAE;SW;";
          unk_1E9F81342 = unk_1BBB791FB;
          dword_1E9F81326 = 0;
          CFNumberRef v15 = (long long *)"SW;";
LABEL_32:
          long long v18 = v15[1];
          xmmword_1E9F812C6 = *v15;
          unk_1E9F812D6 = v18;
          long long v19 = v15[2];
          long long v20 = v15[3];
          long long v21 = v15[5];
          xmmword_1E9F81306 = v15[4];
          unk_1E9F81316 = v21;
          xmmword_1E9F812E6 = v19;
          unk_1E9F812F6 = v20;
          goto LABEL_38;
        }
      }
      dword_1E9F81392 = 0;
      xmmword_1E9F81372 = 0u;
      unk_1E9F81382 = 0u;
      xmmword_1E9F81352 = 0u;
      unk_1E9F81362 = 0u;
      xmmword_1E9F81332 = 0u;
      unk_1E9F81342 = 0u;
      xmmword_1E9F812C6 = 0u;
      unk_1E9F812D6 = 0u;
      xmmword_1E9F812E6 = 0u;
      unk_1E9F812F6 = 0u;
      xmmword_1E9F81306 = 0u;
      unk_1E9F81316 = 0u;
      dword_1E9F81326 = 0;
LABEL_38:
      uint64_t v26 = strcat(byte_1E9F810E6, (const char *)&xmmword_1E9F81332);
      *(_WORD *)&byte_1E9F810E6[strlen(v26)] = 124;
      uint64_t v27 = strcat(byte_1E9F80FE0, (const char *)&xmmword_1E9F812C6);
      *(_WORD *)&byte_1E9F80FE0[strlen(v27)] = 124;
      if (!sub_1BBA401B4()) {
        goto LABEL_43;
      }
      if (qword_1EC027190 != -1) {
        dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
      }
      if (dword_1EC02719C >= 13)
      {
        dword_1E9F812BA = 0;
        unk_1E9F8128C = unk_1BBB794E0;
        unk_1E9F8128E = unk_1BBB794E2;
        unk_1E9F81292 = unk_1BBB794E6;
        xmmword_1E9F8129A = xmmword_1BBB794EE;
        unk_1E9F812AA = unk_1BBB794FE;
        strcpy((char *)&xmmword_1E9F8125A, "RVRA1;VRAE;CH1;CR;CF;FA;POS;HTS;EOD;RR;QP;SW;MLS;");
        dword_1E9F8124E = 0;
        uint64_t v28 = (long long *)"RVRA1;CH1;CR;FA;POS;HTS;EOD;RR;QP;SW;MLS;";
      }
      else
      {
LABEL_43:
        dword_1E9F812BA = 0;
        HIWORD(xmmword_1E9F8127A) = 0;
        unk_1E9F8128A = unk_1BBB79414;
        xmmword_1E9F8129A = xmmword_1BBB79424;
        unk_1E9F812AA = unk_1BBB79434;
        strcpy((char *)&xmmword_1E9F8125A, "RVRA1;VRAE;CH1;CR;CF;FA;POS;HTS;EOD;RR;QP;SW;");
        dword_1E9F8124E = 0;
        uint64_t v28 = (long long *)"RVRA1;CH1;CR;FA;POS;HTS;EOD;RR;QP;SW;;";
      }
      long long v29 = v28[1];
      xmmword_1E9F811EE = *v28;
      unk_1E9F811FE = v29;
      long long v30 = v28[2];
      long long v31 = v28[3];
      long long v32 = v28[5];
      xmmword_1E9F8122E = v28[4];
      unk_1E9F8123E = v32;
      xmmword_1E9F8120E = v30;
      unk_1E9F8121E = v31;
      strcat(byte_1E9F810E6, (const char *)&xmmword_1E9F8125A);
      strcat(byte_1E9F80FE0, (const char *)&xmmword_1E9F811EE);
      keys = @"VCPCodec_AVC1";
      CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      values = (void *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], byte_1E9F80FE0, 0);
      unsigned int v50 = @"VCPCodec_LRP";
      CFStringRef v48 = CFStringCreateWithCString(v33, byte_1E9F810E6, 0);
      int v34 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      int v35 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      CFAllocatorRef v36 = v33;
      goto LABEL_49;
    default:
      CFDictionaryRef v5 = 0;
      uint64_t v6 = 4294954396;
      goto LABEL_53;
  }
}

uint64_t VCPCodecGetProperty(int a1, CFDictionaryRef *a2)
{
  return VCPCodecCopyProperties(a1, a2, 1);
}

uint64_t VCPCreateUserDataPrefixSEINALU(int a1, char *a2, size_t a3, char *a4, unint64_t *a5)
{
  int v5 = 1;
  if (a1 > 1718908519)
  {
    if (a1 == 1718908520) {
      return sub_1BBAD9098(a2, a3, a4, *a5, a5, v5);
    }
    int v6 = 1752589105;
  }
  else
  {
    if (a1 == 1684632424) {
      return sub_1BBAD9098(a2, a3, a4, *a5, a5, v5);
    }
    int v6 = 1685481521;
  }
  if (a1 != v6) {
    int v5 = 0;
  }
  return sub_1BBAD9098(a2, a3, a4, *a5, a5, v5);
}

uint64_t sub_1BB9D3628(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, long long a17, long long a18, long long a19, long long a20,long long a21,long long a22,long long a23,long long a24,long long a25,long long a26,long long a27,long long a28,long long a29,long long a30,long long a31,long long a32,long long a33,long long a34,long long a35,long long a36,long long a37,long long a38,uint64_t a39,uint64_t a40,char a41,__int16 a42,char a43,int a44,char a45,long long a46,long long a47,long long a48,long long a49,long long a50)
{
  uint64_t v50 = MEMORY[0x1F4188790](a1, a2, a3, a4, a5, a6);
  unsigned int v52 = v51;
  unint64_t v54 = v53;
  int v55 = (unsigned __int8 *)v50;
  STACK[0x13638] = *MEMORY[0x1E4F143B8];
  a16 = 0;
  a17 = 0u;
  a18 = 0u;
  a19 = 0u;
  a20 = 0u;
  a21 = 0u;
  a22 = 0u;
  a23 = 0u;
  a24 = 0u;
  a25 = 0u;
  LOWORD(a26) = 0;
  *(void *)&long long v56 = -1;
  *((void *)&v56 + 1) = -1;
  *(long long *)((char *)&a26 + 2) = v56;
  *(long long *)((char *)&a27 + 2) = v56;
  *(long long *)((char *)&a28 + 2) = v56;
  *(long long *)((char *)&a29 + 2) = v56;
  a39 = 0;
  *(long long *)((char *)&a33 + 2) = 0u;
  *(long long *)((char *)&a34 + 2) = 0u;
  *(long long *)((char *)&a35 + 2) = 0u;
  *(long long *)((char *)&a36 + 2) = 0u;
  *(long long *)((char *)&a37 + 2) = 0u;
  *(long long *)((char *)&a30 + 2) = 0u;
  *(long long *)((char *)&a31 + 2) = 0u;
  *(long long *)((char *)&a32 + 2) = 0u;
  BYTE2(a38) = 0;
  WORD6(a38) = 0;
  *(void *)((char *)&a38 + 4) = 0;
  *(void *)buf = &unk_1F14EEAA8;
  uint64_t vars8 = 2;
  off_1EC59CAB8 = (uint64_t (*)(void, void, void, void, void))sub_1BB9FD21C;
  *(_OWORD *)&STACK[0x2B1] = 0uLL;
  *(_OWORD *)&STACK[0x2A8] = 0uLL;
  *(_OWORD *)&STACK[0x298] = 0uLL;
  *(_OWORD *)&STACK[0x288] = 0uLL;
  *(_OWORD *)&STACK[0x278] = 0uLL;
  *(_OWORD *)&STACK[0x268] = 0uLL;
  a50 = 0uLL;
  a49 = 0uLL;
  a48 = 0uLL;
  a47 = 0uLL;
  a46 = 0uLL;
  *(_OWORD *)&STACK[0x2C2] = 0uLL;
  *(_OWORD *)&STACK[0x2D2] = 0uLL;
  *(_OWORD *)&STACK[0x2E2] = 0uLL;
  *(_OWORD *)&STACK[0x2F2] = 0uLL;
  *(_OWORD *)&STACK[0x2FE] = 0uLL;
  STACK[0x314] = 0;
  LODWORD(STACK[0x3EC]) = 0;
  *(_OWORD *)&STACK[0x448] = 0uLL;
  *(_OWORD *)&STACK[0x430] = 0uLL;
  *(_OWORD *)&STACK[0x600] = 0uLL;
  *(_OWORD *)&STACK[0x750] = 0uLL;
  *(_OWORD *)&STACK[0x760] = 0uLL;
  STACK[0x770] = 0;
  LODWORD(STACK[0x930]) = 8;
  LOBYTE(STACK[0x934]) = 0;
  *(_OWORD *)&STACK[0xFB8] = 0uLL;
  STACK[0xFC8] = 0;
  bzero(&STACK[0xFD8], 0x210uLL);
  *(_OWORD *)&STACK[0x1258] = 0u;
  *(_OWORD *)&STACK[0x1248] = 0u;
  *(_OWORD *)&STACK[0xF88] = 0u;
  *(_OWORD *)&STACK[0xF98] = 0u;
  STACK[0xFA8] = 0;
  LOBYTE(STACK[0x473]) = 1;
  LOWORD(a40) = 1;
  BYTE2(a40) = 0;
  HIDWORD(a40) = 0;
  a41 = 0;
  a42 = 258;
  a43 = 0;
  a44 = 0;
  a45 = 0;
  LODWORD(STACK[0x310]) = 0;
  STACK[0x41E] = 0;
  *(_OWORD *)&STACK[0x3F0] = 0u;
  *(_OWORD *)&STACK[0x400] = 0u;
  *(_OWORD *)&STACK[0x410] = 0u;
  LOBYTE(STACK[0x426]) = 1;
  LODWORD(STACK[0x428]) = 0;
  LOBYTE(STACK[0x42C]) = 0;
  LOWORD(STACK[0x440]) = 0;
  STACK[0x788] = 0;
  *(_OWORD *)&STACK[0x13348] = 0u;
  LOBYTE(STACK[0x13378]) = 0;
  *(_OWORD *)&STACK[0x13364] = 0u;
  *(_OWORD *)&STACK[0x13380] = 0u;
  *(_OWORD *)&STACK[0x13390] = 0u;
  *(_OWORD *)&STACK[0x133A0] = 0u;
  STACK[0x1351C] = 0;
  LODWORD(STACK[0x13524]) = 0;
  *(_OWORD *)&STACK[0x1350C] = 0u;
  sub_1BBA065AC((uint64_t)buf, v55, v54);
  sub_1BBA3A730(&a40);
  uint64_t result = 0;
  if (v52) {
    *unsigned int v52 = 0;
  }
  return result;
}

void sub_1BB9D43AC(_Unwind_Exception *a1)
{
}

void sub_1BB9D43F8()
{
  if (!*v0) {
    JUMPOUT(0x1BB9D43E8);
  }
  JUMPOUT(0x1BB9D43E4);
}

uint64_t VCPReadHEVCSliceHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, long long a17, long long a18, long long a19, long long a20,long long a21,long long a22,long long a23,long long a24,long long a25,long long a26,long long a27,long long a28,long long a29,long long a30,long long a31,long long a32,long long a33,long long a34,long long a35,long long a36,long long a37,long long a38,uint64_t a39,uint64_t a40,char a41,__int16 a42,char a43,int a44,char a45,long long a46,long long a47,long long a48,long long a49,long long a50)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9F81A58, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9F81A58))
  {
    int v55 = word_1E9F81610;
    *(void *)&long long v56 = -1;
    *((void *)&v56 + 1) = -1;
    do
    {
      *int v55 = 0;
      *(_OWORD *)(v55 + 2) = 0uLL;
      *(_OWORD *)(v55 + 10) = 0uLL;
      *(_OWORD *)(v55 + 18) = 0uLL;
      *(_OWORD *)(v55 + 26) = 0uLL;
      *(_OWORD *)(v55 + 34) = 0uLL;
      *(_OWORD *)(v55 + 42) = 0uLL;
      *(_OWORD *)(v55 + 50) = 0uLL;
      *(_OWORD *)(v55 + 58) = 0uLL;
      *(_OWORD *)(v55 + 66) = 0uLL;
      v55[74] = 0;
      *(_OWORD *)(v55 + 75) = v56;
      *(_OWORD *)(v55 + 83) = v56;
      *(_OWORD *)(v55 + 91) = v56;
      *(_OWORD *)(v55 + 99) = v56;
      *(void *)(v55 + 178) = 0;
      *((unsigned char *)v55 + 342) = 0;
      *(_OWORD *)(v55 + 123) = 0uLL;
      *(_OWORD *)(v55 + 115) = 0uLL;
      *(_OWORD *)(v55 + 107) = 0uLL;
      int v57 = v55 + 107;
      *(_OWORD *)(v55 + 155) = 0uLL;
      *(_OWORD *)(v55 + 163) = 0uLL;
      *(_OWORD *)(v55 + 139) = 0uLL;
      *(_OWORD *)(v55 + 147) = 0uLL;
      v55[176] = 0;
      *((void *)v55 + 43) = 0;
      v55 += 182;
      *((_OWORD *)v57 + 3) = 0uLL;
    }
    while (v55 != (__int16 *)&unk_1E9F81A54);
    __cxa_guard_release(&qword_1E9F81A58);
  }
  if (qword_1E9F81A60 != -1) {
    dispatch_once(&qword_1E9F81A60, &unk_1F14EF090);
  }

  return sub_1BB9D3628(a2, a3, a4, (uint64_t)&word_1E9F81610[182 * a5], 0, 0, a4 != 0, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42,
           a43,
           a44,
           a45,
           a46,
           a47,
           a48,
           a49,
           a50);
}

#error "1BB9D4658: call analysis failed (funcsize=101)"

uint64_t VCPReadCodecConfigParams(int a1, const void *a2, size_t a3, CFDictionaryRef *a4, uint64_t a5, uint64_t a6)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  if (a1 > 1718908519)
  {
    if (a1 == 1752589105) {
      goto LABEL_7;
    }
    int v7 = 1718908520;
  }
  else
  {
    if (a1 == 1684632424) {
      goto LABEL_7;
    }
    int v7 = 1685481521;
  }
  if (a1 != v7)
  {
    sub_1BBAE8AF4((uint64_t)a2, a3, (uint64_t)&v15, 0, a5, a6);
    goto LABEL_8;
  }
LABEL_7:
  sub_1BBAE859C(a2, a3);
LABEL_8:
  keys[0] = @"Width";
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v16);
  keys[1] = @"Height";
  values[1] = CFNumberCreate(v8, kCFNumberIntType, (char *)&v16 + 4);
  CFDictionaryRef v9 = CFDictionaryCreate(v8, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v10 = 0;
  *a4 = v9;
  char v11 = 1;
  do
  {
    char v12 = v11;
    CFAllocatorRef v13 = values[v10];
    if (v13) {
      CFRelease(v13);
    }
    char v11 = 0;
    uint64_t v10 = 1;
  }
  while ((v12 & 1) != 0);
  return 0;
}

uint64_t VCPParseParameterSetsAndCreateConfigurationRecord(int a1, uint64_t a2, unint64_t *a3, void *a4, size_t *a5)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  if (a1 <= 1718908519)
  {
    if (a1 != 1684632424)
    {
      int v7 = 1685481521;
      goto LABEL_6;
    }
LABEL_7:
    CFAllocatorRef v8 = 0;
    CFDictionaryRef v9 = 0;
    uint64_t v10 = 0;
    int v11 = 0;
    int v12 = 0;
    CFAllocatorRef v13 = 0;
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    int v16 = 0;
    unsigned int v17 = 0;
    while (v15 < *a3)
    {
      uint64_t v18 = a2 + v15;
      long long v19 = (const opaqueCMFormatDescription *)bswap32(*(_DWORD *)(a2 + v15));
      int v20 = (*(unsigned __int8 *)(a2 + v15 + 4) >> 1) & 0x3F;
      if (v20 == 34)
      {
        ++v12;
        if (!v14)
        {
          uint64_t v10 = v19;
          uint64_t v14 = v18 + 4;
        }
      }
      else
      {
        long long v21 = (uint8_t *)(v18 + 4);
        if (v13) {
          long long v22 = v9;
        }
        else {
          long long v22 = v19;
        }
        if (v13) {
          long long v23 = v13;
        }
        else {
          long long v23 = v21;
        }
        if (v17) {
          long long v24 = v8;
        }
        else {
          long long v24 = v19;
        }
        if (v17) {
          long long v21 = v17;
        }
        if (v20 == 32)
        {
          int v25 = v16 + 1;
        }
        else
        {
          long long v24 = v8;
          int v25 = v16;
        }
        if (v20 != 32) {
          long long v21 = v17;
        }
        if (v20 == 33) {
          CFDictionaryRef v9 = v22;
        }
        else {
          CFAllocatorRef v8 = v24;
        }
        if (v20 == 33)
        {
          ++v11;
          CFAllocatorRef v13 = v23;
        }
        else
        {
          int v16 = v25;
        }
        if (v20 != 33) {
          unsigned int v17 = v21;
        }
      }
      v15 += (v19 + 4);
      if (v16)
      {
        if (v11 && v12) {
          break;
        }
      }
    }
    uint64_t v51 = v10;
    CMFormatDescriptionRef formatDescriptionOut = v9;
    uint64_t v50 = v8;
    uint64_t v26 = (void)v9 * (void)v8 * (void)v10;
    if (v11 * v11 * v12) {
      BOOL v27 = v26 == 0;
    }
    else {
      BOOL v27 = 1;
    }
    if (!v27)
    {
      *a3 = v15;
      parameterSetPointers = v17;
      uint64_t v59 = (uint64_t)v13;
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      uint64_t v60 = v14;
      size_t parameterSetSizes = (size_t)&v50;
      p_CMFormatDescriptionRef formatDescriptionOut = &formatDescriptionOut;
      uint64_t v56 = 0;
      uint64_t v57 = 0;
      int v55 = &v51;
      return sub_1BBAE748C(&parameterSetPointers, (unint64_t **)&parameterSetSizes, byte_1BBB78124, a4, a5);
    }
    return 4294954394;
  }
  if (a1 == 1718908520) {
    goto LABEL_7;
  }
  int v7 = 1752589105;
LABEL_6:
  if (a1 == v7) {
    goto LABEL_7;
  }
  size_t v29 = 0;
  long long v30 = 0;
  int v31 = 0;
  int v32 = 0;
  CFAllocatorRef v33 = 0;
  uint64_t v34 = 0;
  unint64_t v35 = 0;
  while (v35 < *a3)
  {
    size_t v36 = bswap32(*(_DWORD *)(a2 + v35));
    long long v37 = (uint8_t *)(a2 + v35 + 4);
    int v38 = *v37 & 0x1F;
    if (v34) {
      long long v39 = v30;
    }
    else {
      long long v39 = (CMFormatDescriptionRef *)v36;
    }
    if (v34) {
      uint64_t v40 = v34;
    }
    else {
      uint64_t v40 = a2 + v35 + 4;
    }
    if (v33) {
      size_t v41 = v29;
    }
    else {
      size_t v41 = v36;
    }
    if (v33) {
      long long v37 = v33;
    }
    if (v38 == 7)
    {
      int v42 = v31 + 1;
    }
    else
    {
      size_t v41 = v29;
      int v42 = v31;
    }
    if (v38 != 7) {
      long long v37 = v33;
    }
    if (v38 == 8) {
      long long v30 = v39;
    }
    else {
      size_t v29 = v41;
    }
    if (v38 == 8) {
      ++v32;
    }
    else {
      int v31 = v42;
    }
    if (v38 == 8) {
      uint64_t v34 = v40;
    }
    else {
      CFAllocatorRef v33 = v37;
    }
    v35 += (v36 + 4);
    if (v31)
    {
      if (v32) {
        break;
      }
    }
  }
  if (v32 * v31) {
    BOOL v43 = (void)v30 * v29 == 0;
  }
  else {
    BOOL v43 = 1;
  }
  if (v43) {
    return 4294954394;
  }
  *a3 = v35;
  parameterSetPointers = v33;
  uint64_t v59 = v34;
  size_t parameterSetSizes = v29;
  p_CMFormatDescriptionRef formatDescriptionOut = v30;
  CMFormatDescriptionRef formatDescriptionOut = 0;
  CMVideoFormatDescriptionCreateFromH264ParameterSets((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2uLL, (const uint8_t *const *)&parameterSetPointers, &parameterSetSizes, 4, &formatDescriptionOut);
  if (formatDescriptionOut)
  {
    CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(formatDescriptionOut, (CFStringRef)*MEMORY[0x1E4F1EE20]);
    if (Extension)
    {
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue(Extension, @"avcC");
      if (Value)
      {
        CFDataRef v46 = Value;
        unint64_t v47 = *a5;
        if (v47 >= CFDataGetLength(Value)) {
          CFIndex Length = CFDataGetLength(v46);
        }
        else {
          CFIndex Length = *a5;
        }
        *a5 = Length;
        BytePtr = CFDataGetBytePtr(v46);
        memcpy(a4, BytePtr, *a5);
      }
    }
    CFRelease(formatDescriptionOut);
  }
  return 0;
}

uint64_t VCPParseConfigurationRecordAndCreateParameterSets(int a1)
{
  if (a1 > 1718908519)
  {
    if (a1 == 1752589105) {
      goto LABEL_7;
    }
    int v1 = 1718908520;
  }
  else
  {
    if (a1 == 1684632424) {
      goto LABEL_7;
    }
    int v1 = 1685481521;
  }
  if (a1 == v1) {
LABEL_7:
  }
    operator new[]();
  return 4294954394;
}

void sub_1BB9D4E84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9)
{
  if (a9) {
    free(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t VCPCompressionSessionGetTypeID()
{
  return qword_1E9F81A68;
}

uint64_t sub_1BB9D4ED4()
{
  qword_1E9F81A88 = 0;
  unk_1E9F81A90 = "VCPCompressionSession";
  qword_1E9F81A98 = 0;
  unk_1E9F81AA0 = 0;
  qword_1E9F81AA8 = (uint64_t)sub_1BB9D4F28;
  unk_1E9F81AB0 = 0u;
  unk_1E9F81AC0 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1E9F81A68 = result;
  return result;
}

std::mutex *sub_1BB9D4F28(std::mutex *result)
{
  if (result)
  {
    int v1 = result;
    VCPCompressionSessionInvalidate((uint64_t)result);
    BOOL v2 = *(std::mutex **)&v1[33].__m_.__opaque[32];
    if (v2)
    {
      std::mutex::~mutex(v2);
      MEMORY[0x1C18605E0]();
      *(void *)&v1[33].__m_.__opaque[32] = 0;
    }
    uint64_t result = *(std::mutex **)&v1[36].__m_.__opaque[24];
    if (result)
    {
      std::mutex::~mutex(result);
      uint64_t result = (std::mutex *)MEMORY[0x1C18605E0]();
      *(void *)&v1[36].__m_.__opaque[24] = 0;
    }
  }
  return result;
}

void VCPCompressionSessionInvalidate(uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v40) = 0;
    CFAllocatorRef v8 = MEMORY[0x1E4F14500];
    CFDictionaryRef v9 = "VCPCompressionSessionInvalidate got NULL vcpSession\n";
    uint32_t v10 = 2;
    goto LABEL_55;
  }
  BOOL v2 = *(std::mutex **)(a1 + 2152);
  if (!v2)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v12 = *(_DWORD *)(a1 + 60);
    int v11 = *(_DWORD *)(a1 + 64);
    int v13 = *(_DWORD *)(a1 + 24);
    uint64_t v14 = "H.264";
    if (v13 > 1718908519)
    {
      if (v13 == 1752589105) {
        goto LABEL_53;
      }
      int v15 = 1718908520;
    }
    else
    {
      if (v13 == 1684632424) {
        goto LABEL_53;
      }
      int v15 = 1685481521;
    }
    if (v13 != v15)
    {
LABEL_54:
      int v40 = 134218754;
      uint64_t v41 = a1;
      __int16 v42 = 1024;
      int v43 = v12;
      __int16 v44 = 1024;
      int v45 = v11;
      __int16 v46 = 2080;
      unint64_t v47 = v14;
      CFAllocatorRef v8 = MEMORY[0x1E4F14500];
      CFDictionaryRef v9 = "VCPEnc %p (%dx%d, %s): VCPCompressionSessionInvalidate got NULL session mutex\n";
      uint32_t v10 = 34;
LABEL_55:
      _os_log_impl(&dword_1BB9B9000, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v40, v10);
      return;
    }
LABEL_53:
    uint64_t v14 = "HEVC";
    goto LABEL_54;
  }
  std::mutex::lock(*(std::mutex **)(a1 + 2152));
  if (!*(unsigned char *)(a1 + 2160))
  {
    *(unsigned char *)(a1 + 2160) = 1;
    int v16 = *(void **)(a1 + 2176);
    if (v16)
    {
      [v16 invalidate];
      CFRelease(*(CFTypeRef *)(a1 + 2176));
      *(void *)(a1 + 2176) = 0;
    }
    unsigned int v17 = *(NSObject **)(a1 + 2168);
    if (v17)
    {
      dispatch_semaphore_wait(v17, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(*(dispatch_object_t *)(a1 + 2168));
      *(void *)(a1 + 2168) = 0;
    }
    uint64_t v18 = *(OpaqueVTCompressionSession **)(a1 + 16);
    if (v18)
    {
      VTCompressionSessionInvalidate(v18);
      CFRelease(*(CFTypeRef *)(a1 + 16));
      *(void *)(a1 + 16) = 0;
    }
    long long v19 = *(uint64_t **)(a1 + 2184);
    if (v19)
    {
      std::mutex::~mutex((std::mutex *)(v19 + 26));
      sub_1BB9D54A4((void *)v19[24]);
      sub_1BB9D54F8((uint64_t)(v19 + 11));
      sub_1BB9D54F8((uint64_t)(v19 + 5));
      if (v19[2])
      {
        uint64_t v20 = *v19;
        long long v21 = (uint64_t *)v19[1];
        uint64_t v22 = *v21;
        *(void *)(v22 + 8) = *(void *)(*v19 + 8);
        **(void **)(v20 + 8) = v22;
        v19[2] = 0;
        if (v21 != v19)
        {
          do
          {
            long long v23 = (uint64_t *)v21[1];
            long long v24 = (std::__shared_weak_count *)v21[3];
            if (v24) {
              sub_1BB9C09B4(v24);
            }
            operator delete(v21);
            long long v21 = v23;
          }
          while (v23 != v19);
        }
      }
      MEMORY[0x1C18605E0](v19, 0x10A0C403C4C3B74);
      *(void *)(a1 + 2184) = 0;
    }
    int v25 = *(const void ***)(a1 + 96);
    if (v25)
    {
      uint64_t v26 = sub_1BB9C607C(v25);
      MEMORY[0x1C18605E0](v26, 0xC0C40B8AA526DLL);
      *(void *)(a1 + 96) = 0;
    }
    BOOL v27 = *(__CVBuffer **)(a1 + 112);
    if (v27)
    {
      CVPixelBufferRelease(v27);
      *(void *)(a1 + 112) = 0;
    }
    uint64_t v28 = *(void *)(a1 + 2192);
    if (v28)
    {
      (*(void (**)(uint64_t))(*(void *)v28 + 272))(v28);
      *(void *)(a1 + 2192) = 0;
    }
    size_t v29 = *(void **)(a1 + 120);
    if (v29)
    {
      free(v29);
      *(void *)(a1 + 120) = 0;
    }
    uint64_t v30 = *(void *)(a1 + 2312);
    if (v30)
    {
      (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
      *(void *)(a1 + 2312) = 0;
    }
    int v31 = *(const void **)(a1 + 2320);
    if (v31)
    {
      CFRelease(v31);
      *(void *)(a1 + 2320) = 0;
    }
    uint64_t v32 = *(void *)(a1 + 136);
    if (v32)
    {
      MEMORY[0x1C18605E0](v32, 0x1060C405A861112);
      *(void *)(a1 + 136) = 0;
    }
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_62;
    }
    int v34 = *(_DWORD *)(a1 + 60);
    int v33 = *(_DWORD *)(a1 + 64);
    int v35 = *(_DWORD *)(a1 + 24);
    size_t v36 = "H.264";
    if (v35 > 1718908519)
    {
      if (v35 == 1752589105) {
        goto LABEL_59;
      }
      int v37 = 1718908520;
    }
    else
    {
      if (v35 == 1684632424) {
        goto LABEL_59;
      }
      int v37 = 1685481521;
    }
    if (v35 != v37)
    {
LABEL_60:
      int v40 = 134218754;
      uint64_t v41 = a1;
      __int16 v42 = 1024;
      int v43 = v34;
      __int16 v44 = 1024;
      int v45 = v33;
      __int16 v46 = 2080;
      unint64_t v47 = v36;
      int v38 = MEMORY[0x1E4F14500];
      long long v39 = "VCPEnc %p (%dx%d, %s): Video compression session invalidated\n";
      goto LABEL_61;
    }
LABEL_59:
    size_t v36 = "HEVC";
    goto LABEL_60;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 60);
    int v3 = *(_DWORD *)(a1 + 64);
    int v5 = *(_DWORD *)(a1 + 24);
    int v6 = "H.264";
    if (v5 > 1718908519)
    {
      if (v5 == 1752589105) {
        goto LABEL_48;
      }
      int v7 = 1718908520;
    }
    else
    {
      if (v5 == 1684632424) {
        goto LABEL_48;
      }
      int v7 = 1685481521;
    }
    if (v5 != v7)
    {
LABEL_49:
      int v40 = 134218754;
      uint64_t v41 = a1;
      __int16 v42 = 1024;
      int v43 = v4;
      __int16 v44 = 1024;
      int v45 = v3;
      __int16 v46 = 2080;
      unint64_t v47 = v6;
      int v38 = MEMORY[0x1E4F14500];
      long long v39 = "VCPEnc %p (%dx%d, %s): Video compression session invalidated already\n";
LABEL_61:
      _os_log_impl(&dword_1BB9B9000, v38, OS_LOG_TYPE_DEFAULT, v39, (uint8_t *)&v40, 0x22u);
      goto LABEL_62;
    }
LABEL_48:
    int v6 = "HEVC";
    goto LABEL_49;
  }
LABEL_62:
  std::mutex::unlock(v2);
}

void sub_1BB9D5490(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1BB9D54A4(void *a1)
{
  if (a1)
  {
    sub_1BB9D54A4(*a1);
    sub_1BB9D54A4(a1[1]);
    sub_1BB9C8338(a1 + 4);
    operator delete(a1);
  }
}

uint64_t sub_1BB9D54F8(uint64_t a1)
{
  BOOL v2 = *(void ***)(a1 + 8);
  int v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      int v3 = *(void ***)(a1 + 16);
      BOOL v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 512;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 1024;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      int v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1BB9D55C0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = 0;
  *a4 = 0;
  operator new[]();
}

uint64_t sub_1BB9D5950(CMSampleBufferRef *a1, CMBlockBufferRef theBuffer)
{
  size_t sampleSizeArray = CMBlockBufferGetDataLength(theBuffer);
  FormatDescription = CMSampleBufferGetFormatDescription(*a1);
  CMSampleBufferRef v15 = 0;
  if (CMSampleBufferGetSampleTimingInfo(*a1, 0, &timingInfoOut))
  {
    timingInfoOut.presentationTimeStamp = *(CMTime *)*(void *)&MEMORY[0x1E4F1FA48];
    timingInfoOut.decodeTimeStamp = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
    CMTimeMake(&v13, 1, 1);
    timingInfoOut.duration = v13;
  }
  CMSampleBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theBuffer, 1u, 0, 0, FormatDescription, 1, 1, &timingInfoOut, 1, &sampleSizeArray, &v15);
  if (!v15) {
    return 4294954392;
  }
  CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(*a1, 1u);
  if (!SampleAttachmentsArray) {
    goto LABEL_9;
  }
  CFArrayRef v6 = SampleAttachmentsArray;
  if (!CFArrayGetCount(SampleAttachmentsArray)) {
    goto LABEL_9;
  }
  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, 0);
  CFArrayRef v8 = CMSampleBufferGetSampleAttachmentsArray(v15, 1u);
  if (v8)
  {
    uint64_t v9 = (void *)CFArrayGetValueAtIndex(v8, 0);
    if (v9)
    {
      CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)sub_1BB9D5AF0, v9);
LABEL_9:
      CFRelease(*a1);
      CMSampleBufferRef v10 = v15;
      CFRetain(v15);
      uint64_t v11 = 0;
      *a1 = v10;
      goto LABEL_12;
    }
  }
  uint64_t v11 = 4294954385;
LABEL_12:
  if (v15) {
    CFRelease(v15);
  }
  return v11;
}

void sub_1BB9D5AF0(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

uint64_t VCPCompressionSessionCreate(uint64_t a1, int a2, int a3, int a4, const __CFDictionary *a5, const __CFDictionary *a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  *a10 = 0;
  pthread_once(&stru_1E9F80A58, (void (*)(void))sub_1BB9D4ED4);
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v16 = Instance;
    if (qword_1EC027118 != -1) {
      dispatch_once(&qword_1EC027118, &unk_1F14EF220);
    }
    bzero((void *)(v16 + 16), 0x920uLL);
    if (a5) {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a5);
    }
    else {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    CFDictionaryRef v20 = MutableCopy;
    if (a6) {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutableCopy(0, 0, a6);
    }
    else {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    uint64_t v22 = Mutable;
    CFDictionaryRef theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (CFDictionaryContainsKey(v20, @"Alpha"))
    {
      CFDataRef Value = CFDictionaryGetValue(v20, @"Alpha");
      if (Value)
      {
        long long v24 = Value;
        if (CFGetTypeID(Value))
        {
          if (CFBooleanGetTypeID())
          {
            if (CFEqual(v24, (CFTypeRef)*MEMORY[0x1E4F1CFD0]))
            {
              int valuePtr = 1982882104;
              CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
              if (v25)
              {
                CFDictionarySetValue(v22, (const void *)*MEMORY[0x1E4F24D70], v25);
                CFRelease(v25);
              }
            }
          }
        }
      }
    }
    if (CFDictionaryContainsKey(v20, @"HistCorrMode"))
    {
      int valuePtr = 0;
      CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(v20, @"HistCorrMode");
      CFNumberRef v27 = v26;
      if (v26)
      {
        CFTypeID v28 = CFGetTypeID(v26);
        if (v28 == CFNumberGetTypeID()) {
          CFNumberGetValue(v27, kCFNumberSInt32Type, &valuePtr);
        }
      }
      *(_DWORD *)(v16 + 2164) = valuePtr;
      if (!v22)
      {
LABEL_34:
        *(_DWORD *)(v16 + 72) = 1;
        int v33 = (unsigned int *)(v16 + 72);
        *(_DWORD *)(v16 + 48) = 0;
        *(_WORD *)(v16 + 52) = 256;
        *(unsigned char *)(v16 + 104) = 1;
        *(void *)(v16 + 32) = a8;
        *(void *)(v16 + 40) = a9;
        *(_WORD *)(v16 + 128) = -1;
        *(_DWORD *)(v16 + 144) = a2 & 0xFFFFFFFE;
        *(_DWORD *)(v16 + 148) = a3 & 0xFFFFFFFE;
        *(unsigned char *)(v16 + 2160) = 0;
        *(void *)(v16 + 2328) = 1;
        CFStringRef v34 = (const __CFString *)CFPreferencesCopyAppValue(@"SerializationMode", @"com.apple.VideoProcessing");
        CFStringRef v35 = v34;
        if (v34)
        {
          *(_DWORD *)(v16 + 2328) = CFStringGetIntValue(v34);
          CFRelease(v35);
        }
        size_t v36 = (id *)(v16 + 2176);
        if (!sub_1BBA12890((void *)(v16 + 2176)))
        {
          int v37 = dispatch_semaphore_create(0);
          *(void *)(v16 + 2168) = v37;
          dispatch_semaphore_signal(v37);
          if (!*(void *)(v16 + 2168))
          {
            if (*v36)
            {
              [*v36 invalidate];
              CFRelease(*v36);
              *size_t v36 = 0;
            }
          }
        }
        if (a5)
        {
          int v38 = (const void *)*MEMORY[0x1E4F45660];
          BOOL v41 = CFDictionaryContainsKey(a5, (const void *)*MEMORY[0x1E4F45660])
             && (long long v39 = CFDictionaryGetValue(a5, v38), (v40 = v39) != 0)
             && CFGetTypeID(v39)
             && CFBooleanGetTypeID()
             && CFEqual(v40, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
          __int16 v42 = (const void *)*MEMORY[0x1E4F44B68];
          if (CFDictionaryContainsKey(a5, (const void *)*MEMORY[0x1E4F44B68]))
          {
            CFNumberRef v43 = (const __CFNumber *)CFDictionaryGetValue(a5, v42);
            CFNumberRef v44 = v43;
            if (v43)
            {
              CFTypeID v45 = CFGetTypeID(v43);
              if (v45 == CFNumberGetTypeID()) {
                CFNumberGetValue(v44, kCFNumberSInt32Type, (void *)(v16 + 68));
              }
            }
          }
          if (CFDictionaryContainsKey(a5, @"NumberOfTiles"))
          {
            CFNumberRef v46 = (const __CFNumber *)CFDictionaryGetValue(a5, @"NumberOfTiles");
            CFNumberRef v47 = v46;
            if (v46)
            {
              CFTypeID v48 = CFGetTypeID(v46);
              if (v48 == CFNumberGetTypeID()) {
                CFNumberGetValue(v47, kCFNumberSInt32Type, (void *)(v16 + 72));
              }
            }
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
            {
              int v49 = *(_DWORD *)(v16 + 72);
              int valuePtr = 134218240;
              *(void *)valuePtr_4 = v16;
              *(_WORD *)&valuePtr_4[8] = 1024;
              *(_DWORD *)unint64_t v68 = v49;
              _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p: Encoder got number of tiles video specification: %d\n", (uint8_t *)&valuePtr, 0x12u);
            }
            unsigned int v50 = *v33;
            if ((int)*v33 <= 1) {
              unsigned int v50 = 1;
            }
            if (v50 >= 4) {
              unsigned int v50 = 4;
            }
            unsigned int *v33 = v50;
          }
          uint64_t v51 = (const void *)*MEMORY[0x1E4F44AA0];
          if (CFDictionaryContainsKey(v20, (const void *)*MEMORY[0x1E4F44AA0]))
          {
            unsigned int v52 = (__CFString *)CFDictionaryGetValue(v20, v51);
            CFRetain(v52);
          }
          else
          {
            unsigned int v52 = 0;
          }
          if (CFDictionaryContainsKey(a5, @"decodingOrderBase"))
          {
            CFNumberRef v53 = (const __CFNumber *)CFDictionaryGetValue(a5, @"decodingOrderBase");
            CFNumberRef v54 = v53;
            if (v53)
            {
              CFTypeID v55 = CFGetTypeID(v53);
              if (v55 == CFNumberGetTypeID()) {
                CFNumberGetValue(v54, kCFNumberSInt32Type, (void *)(v16 + 84));
              }
            }
          }
          uint64_t v56 = (const void *)*MEMORY[0x1E4F44BD0];
          if (CFDictionaryContainsKey(a5, (const void *)*MEMORY[0x1E4F44BD0]))
          {
            uint64_t v57 = CFDictionaryGetValue(v20, v56);
            if (v57)
            {
              unsigned int v58 = (const void *)*MEMORY[0x1E4F1CFD0];
              if (CFEqual(v57, (CFTypeRef)*MEMORY[0x1E4F1CFD0])) {
                CFDictionaryAddValue(theDict, v56, v58);
              }
            }
          }
        }
        else
        {
          BOOL v41 = 0;
          unsigned int v52 = 0;
        }
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
LABEL_86:
          if (v52) {
            CFRelease(v52);
          }
          operator new();
        }
        uint64_t v59 = "H.264";
        if (a4 > 1718908519)
        {
          if (a4 == 1752589105) {
            goto LABEL_82;
          }
          int v60 = 1718908520;
        }
        else
        {
          if (a4 == 1684632424) {
            goto LABEL_82;
          }
          int v60 = 1685481521;
        }
        if (a4 != v60)
        {
LABEL_83:
          int v61 = *(_DWORD *)(v16 + 68);
          uint64_t v62 = @"N/A";
          if (v52) {
            uint64_t v62 = v52;
          }
          int valuePtr = 134219778;
          *(void *)valuePtr_4 = v16;
          *(_WORD *)&valuePtr_4[8] = 1024;
          *(_DWORD *)unint64_t v68 = a2;
          *(_WORD *)&v68[4] = 1024;
          *(_DWORD *)&v68[6] = a3;
          __int16 v69 = 2080;
          char v70 = v59;
          __int16 v71 = 1024;
          BOOL v72 = v41;
          __int16 v73 = 1024;
          int v74 = v61;
          __int16 v75 = 2112;
          unsigned int v76 = v62;
          __int16 v77 = 2080;
          int32x4_t v78 = "iOS";
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Got video encoder specification: request_hw = %d, usage = %d, profile_level = %@, target = %s\n", (uint8_t *)&valuePtr, 0x42u);
          goto LABEL_86;
        }
LABEL_82:
        uint64_t v59 = "HEVC";
        goto LABEL_83;
      }
    }
    else
    {
      *(_DWORD *)(v16 + 2164) = 0;
      if (!v22) {
        goto LABEL_34;
      }
    }
    size_t v29 = (const void *)*MEMORY[0x1E4F24D70];
    if (CFDictionaryContainsKey(v22, (const void *)*MEMORY[0x1E4F24D70]))
    {
      int valuePtr = 0;
      CFNumberRef v30 = (const __CFNumber *)CFDictionaryGetValue(v22, v29);
      CFNumberRef v31 = v30;
      if (v30)
      {
        CFTypeID v32 = CFGetTypeID(v30);
        if (v32 == CFNumberGetTypeID()) {
          CFNumberGetValue(v31, kCFNumberSInt32Type, &valuePtr);
        }
      }
      if (valuePtr == 1751411059) {
        a4 = 1684632424;
      }
    }
    goto LABEL_34;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = "H.264";
    if (a4 > 1718908519)
    {
      if (a4 == 1752589105) {
        goto LABEL_92;
      }
      int v19 = 1718908520;
    }
    else
    {
      if (a4 == 1684632424) {
        goto LABEL_92;
      }
      int v19 = 1685481521;
    }
    if (a4 != v19)
    {
LABEL_93:
      int valuePtr = 67109890;
      *(_DWORD *)valuePtr_4 = a2;
      *(_WORD *)&valuePtr_4[4] = 1024;
      *(_DWORD *)&valuePtr_4[6] = a3;
      *(_WORD *)unint64_t v68 = 2080;
      *(void *)&v68[2] = v18;
      __int16 v69 = 1024;
      LODWORD(v70) = -12904;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc (%dx%d, %s): Failed to create video compression session, err = %d\n", (uint8_t *)&valuePtr, 0x1Eu);
      return 4294954392;
    }
LABEL_92:
    uint64_t v18 = "HEVC";
    goto LABEL_93;
  }
  return 4294954392;
}

void sub_1BB9D7234(_Unwind_Exception *a1)
{
  MEMORY[0x1C18605C0](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

void sub_1BB9D7294(char **a1, unint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = 0xFF00FF00FF00FF01 * ((v5 - *a1) >> 5);
  unint64_t v7 = a2 - v6;
  if (a2 <= v6)
  {
    if (a2 < v6) {
      a1[1] = &v4[8224 * a2];
    }
  }
  else
  {
    CFArrayRef v8 = a1[2];
    if (0xFF00FF00FF00FF01 * ((v8 - v5) >> 5) >= v7)
    {
      uint64_t v18 = &v5[8224 * v7];
      do
      {
        bzero(v5, 0x2020uLL);
        *((_DWORD *)v5 + 2053) = 1;
        v5 += 8224;
      }
      while (v5 != v18);
      a1[1] = v18;
    }
    else
    {
      if (a2 > 0x7F807F807F807) {
        sub_1BB9C185C();
      }
      unint64_t v9 = 0xFF00FF00FF00FF01 * ((v8 - v4) >> 5);
      uint64_t v10 = 2 * v9;
      if (2 * v9 <= a2) {
        uint64_t v10 = a2;
      }
      if (v9 >= 0x3FC03FC03FC03) {
        unint64_t v11 = 0x7F807F807F807;
      }
      else {
        unint64_t v11 = v10;
      }
      if (v11 > 0x7F807F807F807) {
        sub_1BB9C18AC();
      }
      int v12 = (char *)operator new(8224 * v11, (std::align_val_t)0x20uLL);
      CMTime v13 = &v12[8224 * v6];
      uint64_t v14 = &v12[8224 * a2];
      CMSampleBufferRef v15 = v13;
      do
      {
        bzero(v15, 0x2020uLL);
        *((_DWORD *)v15 + 2053) = 1;
        v15 += 8224;
      }
      while (v15 != v14);
      uint64_t v16 = &v12[8224 * v11];
      unsigned int v17 = *a1;
      if (v5 != *a1)
      {
        do
        {
          v5 -= 8224;
          v13 -= 8224;
          memcpy(v13, v5, 0x2018uLL);
        }
        while (v5 != v17);
        uint64_t v5 = *a1;
      }
      *a1 = v13;
      a1[1] = v14;
      a1[2] = v16;
      if (v5)
      {
        JUMPOUT(0x1C18605D0);
      }
    }
  }
}

uint64_t VCPCompressionSessionSetProperty(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  sub_1BBAA99BC(Mutable, a3);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *(_DWORD *)(a1 + 60);
    int v8 = *(_DWORD *)(a1 + 64);
    int v10 = *(_DWORD *)(a1 + 24);
    unint64_t v11 = "H.264";
    if (v10 > 1718908519)
    {
      if (v10 == 1752589105) {
        goto LABEL_8;
      }
      int v12 = 1718908520;
    }
    else
    {
      if (v10 == 1684632424) {
        goto LABEL_8;
      }
      int v12 = 1685481521;
    }
    if (v10 != v12)
    {
LABEL_9:
      *(_DWORD *)buf = 134219266;
      uint64_t v69 = a1;
      __int16 v70 = 1024;
      int v71 = v9;
      __int16 v72 = 1024;
      int v73 = v8;
      __int16 v74 = 2080;
      __int16 v75 = v11;
      __int16 v76 = 2112;
      *(void *)__int16 v77 = a2;
      *(_WORD *)&v77[8] = 2114;
      int32x4_t v78 = Mutable;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder got %@ property = %{public}@\n", buf, 0x36u);
      goto LABEL_10;
    }
LABEL_8:
    unint64_t v11 = "HEVC";
    goto LABEL_9;
  }
LABEL_10:
  CFRelease(Mutable);
  uint64_t v13 = *MEMORY[0x1E4F447D0];
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F447D0])) {
    *(unsigned char *)(a1 + 2348) = 1;
  }
  int v14 = CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F448F0]);
  if (!a3 || !v14 || (CFTypeID v15 = CFNumberGetTypeID(), v15 != CFGetTypeID(a3)))
  {
    int v21 = CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A18]);
    if (a3)
    {
      if (v21)
      {
        CFTypeID TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(a3))
        {
          long long v23 = *(void **)(a1 + 120);
          if (v23)
          {
            free(v23);
            *(void *)(a1 + 120) = 0;
          }
          long long v24 = (char *)malloc_type_calloc(0x3E9uLL, 1uLL, 0x100004077774924uLL);
          *(void *)(a1 + 120) = v24;
          CFStringGetCString(a3, v24, 1001, 0);
        }
      }
    }
    if (CFEqual(a2, @"NegotiationDetailsBitField"))
    {
      if (!a3) {
        goto LABEL_38;
      }
    }
    else
    {
      int v25 = CFEqual(a2, @"NegotiatedFLB");
      if (!a3 || !v25) {
        goto LABEL_38;
      }
    }
    CFTypeID v26 = CFDataGetTypeID();
    if (v26 == CFGetTypeID(a3))
    {
      CFNumberRef v27 = *(void **)(a1 + 120);
      if (v27)
      {
        free(v27);
        *(void *)(a1 + 120) = 0;
      }
      *(void *)(a1 + 120) = malloc_type_calloc(0x3E9uLL, 1uLL, 0x100004077774924uLL);
      if (CFEqual(a2, @"NegotiationDetailsBitField")) {
        CFTypeID v28 = "FLBA;";
      }
      else {
        CFTypeID v28 = "FLBN;";
      }
      sub_1BBAB0D58((const __CFData *)a3, v28, *(char **)(a1 + 120), 1000);
    }
LABEL_38:
    if (CFEqual(a2, @"CompressionMode"))
    {
      LOWORD(valuePtr) = 0;
      CFTypeID v29 = CFGetTypeID(a3);
      unsigned int v30 = 0;
      if (v29 == CFNumberGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt16Type, &valuePtr);
        unsigned int v30 = LOWORD(valuePtr);
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v69) = (__int16)v30;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VideoProminence: kVCPCompressionPropertyKey_CompressionMode (set by AVC) = %d", buf, 8u);
        unsigned int v30 = LOWORD(valuePtr);
      }
      if (v30 >= 3)
      {
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
          return 4294943593;
        }
        int v32 = *(_DWORD *)(a1 + 60);
        int v31 = *(_DWORD *)(a1 + 64);
        int v33 = *(_DWORD *)(a1 + 24);
        CFStringRef v34 = "H.264";
        if (v33 > 1718908519)
        {
          if (v33 == 1752589105) {
            goto LABEL_64;
          }
          int v35 = 1718908520;
        }
        else
        {
          if (v33 == 1684632424) {
            goto LABEL_64;
          }
          int v35 = 1685481521;
        }
        if (v33 != v35)
        {
LABEL_65:
          *(_DWORD *)buf = 134219010;
          uint64_t v69 = a1;
          __int16 v70 = 1024;
          int v71 = v32;
          __int16 v72 = 1024;
          int v73 = v31;
          __int16 v74 = 2080;
          __int16 v75 = v34;
          __int16 v76 = 1024;
          *(_DWORD *)__int16 v77 = (__int16)v30;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Unexpected compression mode: %d!\n", buf, 0x28u);
          return 4294943593;
        }
LABEL_64:
        CFStringRef v34 = "HEVC";
        goto LABEL_65;
      }
      *(_WORD *)(a1 + 50) = v30;
      uint64_t v41 = 0;
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        return v41;
      }
      int v43 = *(_DWORD *)(a1 + 60);
      int v42 = *(_DWORD *)(a1 + 64);
      int v44 = *(_DWORD *)(a1 + 24);
      CFTypeID v45 = "H.264";
      if (v44 > 1718908519)
      {
        if (v44 == 1752589105) {
          goto LABEL_70;
        }
        int v46 = 1718908520;
      }
      else
      {
        if (v44 == 1684632424) {
          goto LABEL_70;
        }
        int v46 = 1685481521;
      }
      if (v44 != v46)
      {
LABEL_71:
        *(_DWORD *)buf = 134219266;
        uint64_t v69 = a1;
        __int16 v70 = 1024;
        int v71 = v43;
        __int16 v72 = 1024;
        int v73 = v42;
        __int16 v74 = 2080;
        __int16 v75 = v45;
        __int16 v76 = 1024;
        *(_DWORD *)__int16 v77 = v30;
        *(_WORD *)&v77[4] = 1024;
        *(_DWORD *)&v77[6] = 0;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder got compression mode property: %d, but forced to %d\n", buf, 0x2Eu);
        return 0;
      }
LABEL_70:
      CFTypeID v45 = "HEVC";
      goto LABEL_71;
    }
    int v36 = CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44B68]);
    if (!a3) {
      goto LABEL_91;
    }
    if (!v36) {
      goto LABEL_91;
    }
    CFTypeID v37 = CFNumberGetTypeID();
    if (v37 != CFGetTypeID(a3)) {
      goto LABEL_91;
    }
    CFTypeID v38 = CFGetTypeID(a3);
    if (v38 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, (void *)(a1 + 68));
    }
    if (*(_DWORD *)(a1 + 68) != 1)
    {
LABEL_91:
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44810]))
      {
        *(_DWORD *)buf = 0;
        if (a3)
        {
          CFTypeID v53 = CFNumberGetTypeID();
          if (v53 == CFGetTypeID(a3))
          {
            CFTypeID v54 = CFGetTypeID(a3);
            if (v54 == CFNumberGetTypeID()) {
              CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, buf);
            }
            uint64_t v55 = *(void *)(a1 + 2312);
            if (v55) {
              sub_1BBAC89D8(v55, (uint64_t *)"target_bitrate", (double)*(int *)buf);
            }
            uint64_t v56 = *(void *)(a1 + 2184);
            if (v56)
            {
              int v57 = *(_DWORD *)buf;
              *(_DWORD *)(v56 + 28) = *(_DWORD *)buf;
              int v58 = *(_DWORD *)(v56 + 24);
              if (v58 < 1) {
                double v59 = 0.0;
              }
              else {
                double v59 = (double)v57 / (double)v58;
              }
              *(double *)(v56 + 32) = v59;
            }
          }
        }
        int v60 = *(_DWORD *)(a1 + 68);
        if (v60 == 42 || v60 == 20)
        {
          float v61 = 0.05;
          if (v60 == 20) {
            float v61 = 0.5;
          }
          float valuePtr = v61;
          int v66 = (int)(float)((float)(v61 * (float)*(int *)buf) * 0.125);
          uint64_t v62 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
          CFNumberRef v63 = CFNumberCreate(v6, kCFNumberSInt32Type, &v66);
          CFArrayAppendValue(v62, v63);
          CFRelease(v63);
          CFNumberRef v64 = CFNumberCreate(v6, kCFNumberFloat32Type, &valuePtr);
          CFArrayAppendValue(v62, v64);
          CFRelease(v64);
          VTSessionSetProperty(*(VTSessionRef *)(a1 + 16), (CFStringRef)*MEMORY[0x1E4F44898], v62);
          CFRelease(v62);
        }
      }
      if (!CFEqual(a2, @"ThermalLevel") || *(_DWORD *)(a1 + 24) != 1635148593) {
        return VTSessionSetProperty(*(VTSessionRef *)(a1 + 16), a2, a3);
      }
      return 0;
    }
    int v39 = *(_DWORD *)(a1 + 24);
    if (v39 > 1718908519)
    {
      if (v39 != 1752589105)
      {
        int v40 = 1718908520;
LABEL_87:
        if (v39 != v40) {
          goto LABEL_91;
        }
      }
    }
    else if (v39 != 1684632424)
    {
      int v40 = 1685481521;
      goto LABEL_87;
    }
    if (!*(unsigned char *)(a1 + 2348) && (sub_1BB9EB584() & 1) == 0) {
      VCPCompressionSessionSetProperty(a1, v13, *MEMORY[0x1E4F1CFD0]);
    }
    goto LABEL_91;
  }
  CFTypeID v16 = CFGetTypeID(a3);
  if (v16 == CFNumberGetTypeID()) {
    CFNumberGetValue((CFNumberRef)a3, kCFNumberDoubleType, (void *)(a1 + 88));
  }
  *(double *)(a1 + 88) = *(double *)(a1 + 88) * (double)*(int *)(a1 + 72);
  CFNumberRef v17 = CFNumberCreate(v6, kCFNumberDoubleType, (const void *)(a1 + 88));
  uint64_t v18 = *(void *)(a1 + 2184);
  if (v18)
  {
    int v19 = (int)*(double *)(a1 + 88);
    *(_DWORD *)(v18 + 24) = v19;
    if (v19 < 1) {
      double v20 = 0.0;
    }
    else {
      double v20 = (double)*(int *)(v18 + 28) / (double)v19;
    }
    *(double *)(v18 + 32) = v20;
  }
  if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_83;
  }
  int v48 = *(_DWORD *)(a1 + 60);
  int v47 = *(_DWORD *)(a1 + 64);
  int v49 = *(_DWORD *)(a1 + 24);
  unsigned int v50 = "H.264";
  if (v49 <= 1718908519)
  {
    if (v49 != 1684632424)
    {
      int v51 = 1685481521;
      goto LABEL_80;
    }
LABEL_81:
    unsigned int v50 = "HEVC";
    goto LABEL_82;
  }
  if (v49 == 1752589105) {
    goto LABEL_81;
  }
  int v51 = 1718908520;
LABEL_80:
  if (v49 == v51) {
    goto LABEL_81;
  }
LABEL_82:
  int v52 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)buf = 134219522;
  uint64_t v69 = a1;
  __int16 v70 = 1024;
  int v71 = v48;
  __int16 v72 = 1024;
  int v73 = v47;
  __int16 v74 = 2080;
  __int16 v75 = v50;
  __int16 v76 = 2112;
  *(void *)__int16 v77 = a3;
  *(_WORD *)&v77[8] = 2112;
  int32x4_t v78 = v17;
  __int16 v79 = 1024;
  int v80 = v52;
  _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder got ExpectedFrameRate property: %@, will be set to %@ to support %d-tile encoding\n", buf, 0x3Cu);
LABEL_83:
  uint64_t v41 = VTSessionSetProperty(*(VTSessionRef *)(a1 + 16), a2, v17);
  if (v17) {
    CFRelease(v17);
  }
  return v41;
}

void sub_1BB9D7E2C(uint64_t a1, double a2)
{
  uint64_t v158 = *MEMORY[0x1E4F143B8];
  if (a2 > 0.0)
  {
    if (!a1)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_WORD *)buf = 0;
      unsigned int v106 = MEMORY[0x1E4F14500];
      int v107 = "Empty callback refcon in VCPEncStatsMonitorCallback()\n";
      uint32_t v108 = 2;
      goto LABEL_193;
    }
    uint64_t v3 = *(void *)(a1 + 2312);
    CFAllocatorRef v6 = *(void **)(v3 + 32);
    uint64_t v4 = (double *)(v3 + 32);
    uint64_t v5 = v6;
    double v7 = 0.0;
    double v8 = 0.0;
    if (!v6) {
      goto LABEL_181;
    }
    int v9 = v4;
    int v10 = v5;
    do
    {
      unint64_t v11 = v10[4];
      BOOL v12 = v11 >= (unint64_t)"input_frames";
      if (v11 >= (unint64_t)"input_frames") {
        uint64_t v13 = v10;
      }
      else {
        uint64_t v13 = v10 + 1;
      }
      if (v12) {
        int v9 = (double *)v10;
      }
      int v10 = (void *)*v13;
    }
    while (*v13);
    double v8 = 0.0;
    if (v9 != v4 && *((void *)v9 + 4) <= (unint64_t)"input_frames") {
      double v8 = v9[5];
    }
    if (v5)
    {
      int v14 = v4;
      CFTypeID v15 = v5;
      do
      {
        unint64_t v16 = v15[4];
        BOOL v17 = v16 >= (unint64_t)"encoded_frames";
        if (v16 >= (unint64_t)"encoded_frames") {
          uint64_t v18 = v15;
        }
        else {
          uint64_t v18 = v15 + 1;
        }
        if (v17) {
          int v14 = (double *)v15;
        }
        CFTypeID v15 = (void *)*v18;
      }
      while (*v18);
      double v19 = 0.0;
      if (v14 != v4 && *((void *)v14 + 4) <= (unint64_t)"encoded_frames") {
        double v19 = v14[5];
      }
      double v20 = v4;
      int v21 = v5;
      do
      {
        unint64_t v22 = v21[4];
        BOOL v23 = v22 >= (unint64_t)"transmit_frames";
        if (v22 >= (unint64_t)"transmit_frames") {
          long long v24 = v21;
        }
        else {
          long long v24 = v21 + 1;
        }
        if (v23) {
          double v20 = (double *)v21;
        }
        int v21 = (void *)*v24;
      }
      while (*v24);
      double v25 = 0.0;
      if (v20 != v4 && *((void *)v20 + 4) <= (unint64_t)"transmit_frames") {
        double v25 = v20[5];
      }
      CFTypeID v26 = v4;
      CFNumberRef v27 = v5;
      do
      {
        unint64_t v28 = v27[4];
        BOOL v29 = v28 >= (unint64_t)"frame_qp";
        if (v28 >= (unint64_t)"frame_qp") {
          unsigned int v30 = v27;
        }
        else {
          unsigned int v30 = v27 + 1;
        }
        if (v29) {
          CFTypeID v26 = (double *)v27;
        }
        CFNumberRef v27 = (void *)*v30;
      }
      while (*v30);
      double v31 = 0.0;
      if (v26 != v4 && *((void *)v26 + 4) <= (unint64_t)"frame_qp") {
        double v31 = v26[5];
      }
      int v32 = v4;
      int v33 = v5;
      do
      {
        unint64_t v34 = v33[4];
        BOOL v35 = v34 >= (unint64_t)"encoded_bits";
        if (v34 >= (unint64_t)"encoded_bits") {
          int v36 = v33;
        }
        else {
          int v36 = v33 + 1;
        }
        if (v35) {
          int v32 = (double *)v33;
        }
        int v33 = (void *)*v36;
      }
      while (*v36);
      double v37 = 0.0;
      if (v32 != v4 && *((void *)v32 + 4) <= (unint64_t)"encoded_bits") {
        double v37 = v32[5];
      }
      CFTypeID v38 = v4;
      int v39 = v5;
      do
      {
        unint64_t v40 = v39[4];
        BOOL v41 = v40 >= (unint64_t)"header_bits";
        if (v40 >= (unint64_t)"header_bits") {
          int v42 = v39;
        }
        else {
          int v42 = v39 + 1;
        }
        if (v41) {
          CFTypeID v38 = (double *)v39;
        }
        int v39 = (void *)*v42;
      }
      while (*v42);
      double v43 = 0.0;
      if (v38 != v4 && *((void *)v38 + 4) <= (unint64_t)"header_bits") {
        double v43 = v38[5];
      }
      int v44 = v4;
      CFTypeID v45 = v5;
      do
      {
        unint64_t v46 = v45[4];
        BOOL v47 = v46 >= (unint64_t)"rtx_bits";
        if (v46 >= (unint64_t)"rtx_bits") {
          int v48 = v45;
        }
        else {
          int v48 = v45 + 1;
        }
        if (v47) {
          int v44 = (double *)v45;
        }
        CFTypeID v45 = (void *)*v48;
      }
      while (*v48);
      double v49 = 0.0;
      if (v44 != v4 && *((void *)v44 + 4) <= (unint64_t)"rtx_bits") {
        double v49 = v44[5];
      }
      unsigned int v50 = v4;
      int v51 = v5;
      do
      {
        unint64_t v52 = v51[4];
        BOOL v53 = v52 >= (unint64_t)"fec_bits";
        if (v52 >= (unint64_t)"fec_bits") {
          CFTypeID v54 = v51;
        }
        else {
          CFTypeID v54 = v51 + 1;
        }
        if (v53) {
          unsigned int v50 = (double *)v51;
        }
        int v51 = (void *)*v54;
      }
      while (*v54);
      double v55 = 0.0;
      if (v50 != v4 && *((void *)v50 + 4) <= (unint64_t)"fec_bits") {
        double v55 = v50[5];
      }
      uint64_t v56 = v4;
      int v57 = v5;
      do
      {
        unint64_t v58 = v57[4];
        BOOL v59 = v58 >= (unint64_t)"encoding_time";
        if (v58 >= (unint64_t)"encoding_time") {
          int v60 = v57;
        }
        else {
          int v60 = v57 + 1;
        }
        if (v59) {
          uint64_t v56 = (double *)v57;
        }
        int v57 = (void *)*v60;
      }
      while (*v60);
      double v61 = 0.0;
      if (v56 != v4 && *((void *)v56 + 4) <= (unint64_t)"encoding_time") {
        double v61 = v56[5];
      }
      uint64_t v62 = v4;
      CFNumberRef v63 = v5;
      do
      {
        unint64_t v64 = v63[4];
        BOOL v65 = v64 >= (unint64_t)"target_bitrate";
        if (v64 >= (unint64_t)"target_bitrate") {
          int v66 = v63;
        }
        else {
          int v66 = v63 + 1;
        }
        if (v65) {
          uint64_t v62 = (double *)v63;
        }
        CFNumberRef v63 = (void *)*v66;
      }
      while (*v66);
      uint64_t v67 = 0;
      if (v62 != v4 && *((void *)v62 + 4) <= (unint64_t)"target_bitrate") {
        uint64_t v67 = *((void *)v62 + 5);
      }
      unint64_t v68 = v4;
      uint64_t v69 = v5;
      do
      {
        unint64_t v70 = v69[4];
        BOOL v71 = v70 >= (unint64_t)"sei_bits";
        if (v70 >= (unint64_t)"sei_bits") {
          __int16 v72 = v69;
        }
        else {
          __int16 v72 = v69 + 1;
        }
        if (v71) {
          unint64_t v68 = (double *)v69;
        }
        uint64_t v69 = (void *)*v72;
      }
      while (*v72);
      double v73 = 0.0;
      if (v68 != v4 && *((void *)v68 + 4) <= (unint64_t)"sei_bits") {
        double v73 = v68[5];
      }
      __int16 v74 = v4;
      __int16 v75 = v5;
      do
      {
        unint64_t v76 = v75[4];
        BOOL v77 = v76 >= (unint64_t)"min_frame_size";
        if (v76 >= (unint64_t)"min_frame_size") {
          int32x4_t v78 = v75;
        }
        else {
          int32x4_t v78 = v75 + 1;
        }
        if (v77) {
          __int16 v74 = (double *)v75;
        }
        __int16 v75 = (void *)*v78;
      }
      while (*v78);
      double v79 = 0.0;
      if (v74 != v4 && *((void *)v74 + 4) <= (unint64_t)"min_frame_size") {
        double v79 = v74[5];
      }
      int v80 = v4;
      uint64_t v81 = v5;
      do
      {
        unint64_t v82 = v81[4];
        BOOL v83 = v82 >= (unint64_t)"dropped_frames";
        if (v82 >= (unint64_t)"dropped_frames") {
          __int16 v84 = v81;
        }
        else {
          __int16 v84 = v81 + 1;
        }
        if (v83) {
          int v80 = (double *)v81;
        }
        uint64_t v81 = (void *)*v84;
      }
      while (*v84);
      double v85 = 0.0;
      if (v80 != v4 && *((void *)v80 + 4) <= (unint64_t)"dropped_frames") {
        double v85 = v80[5];
      }
      unsigned int v86 = v4;
      unsigned int v87 = v5;
      do
      {
        unint64_t v88 = v87[4];
        BOOL v89 = v88 >= (unint64_t)"idr_frames";
        if (v88 >= (unint64_t)"idr_frames") {
          int32x4_t v90 = v87;
        }
        else {
          int32x4_t v90 = v87 + 1;
        }
        if (v89) {
          unsigned int v86 = (double *)v87;
        }
        unsigned int v87 = (void *)*v90;
      }
      while (*v90);
      double v91 = 0.0;
      if (v86 != v4 && *((void *)v86 + 4) <= (unint64_t)"idr_frames") {
        double v91 = v86[5];
      }
      unsigned int v92 = v4;
      unsigned int v93 = v5;
      do
      {
        unint64_t v94 = v93[4];
        BOOL v95 = v94 >= (unint64_t)"repeated_frames";
        if (v94 >= (unint64_t)"repeated_frames") {
          unsigned int v96 = v93;
        }
        else {
          unsigned int v96 = v93 + 1;
        }
        if (v95) {
          unsigned int v92 = (double *)v93;
        }
        unsigned int v93 = (void *)*v96;
      }
      while (*v96);
      double v97 = 0.0;
      double v98 = 0.0;
      if (v92 != v4 && *((void *)v92 + 4) <= (unint64_t)"repeated_frames") {
        double v98 = v92[5];
      }
      char v99 = v4;
      do
      {
        unint64_t v100 = v5[4];
        BOOL v101 = v100 >= (unint64_t)"refresh_frames";
        if (v100 >= (unint64_t)"refresh_frames") {
          unsigned int v102 = v5;
        }
        else {
          unsigned int v102 = v5 + 1;
        }
        if (v101) {
          char v99 = (double *)v5;
        }
        uint64_t v5 = (void *)*v102;
      }
      while (*v102);
      if (v99 != v4 && *((void *)v99 + 4) <= (unint64_t)"refresh_frames") {
        double v97 = v99[5];
      }
      BOOL v103 = v19 > 0.0;
      double v105 = 0.0;
      double v7 = 0.0;
      if (v19 > 0.0) {
        double v7 = v61 / v19 * 1000.0;
      }
      double v110 = v19 / a2;
      double v111 = v25 / a2;
      double v112 = v8 / a2;
      double v104 = v37 / a2;
      if (v25 > 0.000001) {
        double v105 = v31 / v25;
      }
    }
    else
    {
LABEL_181:
      BOOL v103 = 0;
      double v104 = 0.0 / a2;
      double v98 = 0.0;
      double v85 = 0.0;
      double v73 = 0.0;
      double v49 = 0.0;
      double v25 = 0.0;
      double v43 = 0.0;
      double v111 = 0.0 / a2;
      double v112 = v8 / a2;
      double v110 = 0.0 / a2;
      double v55 = 0.0;
      uint64_t v67 = 0;
      double v79 = 0.0;
      double v91 = 0.0;
      double v97 = 0.0;
      double v105 = 0.0;
    }
    double v113 = v105;
    double v114 = v7;
    double v115 = v97;
    uint64_t v116 = v67;
    double v117 = v73;
    __int16 v157 = 0;
    long long v155 = 0u;
    long long v156 = 0u;
    *(_OWORD *)__str = 0u;
    if (v103 && v79 / v25 > 2.22044605e-16) {
      snprintf(__str, 0x32uLL, "Min_frame_size=%.0f bytes, ", v79 / v25);
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136450562;
      uint64_t v119 = a1 + 152;
      __int16 v120 = 2048;
      double v121 = v112;
      __int16 v122 = 2048;
      double v123 = v110;
      __int16 v124 = 2048;
      double v125 = v85 / a2;
      __int16 v126 = 2048;
      double v127 = v98 / a2;
      __int16 v128 = 2048;
      double v129 = v91 / a2;
      __int16 v130 = 2048;
      double v131 = v115 / a2;
      __int16 v132 = 2048;
      double v133 = v111;
      __int16 v134 = 2048;
      double v135 = v113;
      __int16 v136 = 2048;
      double v137 = v49 / a2 + v104 + v43 / a2 + v55 / a2;
      __int16 v138 = 2048;
      uint64_t v139 = v116;
      __int16 v140 = 2048;
      double v141 = v104 - v117 / a2;
      __int16 v142 = 2048;
      double v143 = v55 / a2;
      __int16 v144 = 2048;
      double v145 = v43 / a2;
      __int16 v146 = 2048;
      double v147 = v117 / a2;
      __int16 v148 = 2048;
      double v149 = v49 / a2;
      __int16 v150 = 2082;
      unsigned __int16 v151 = __str;
      __int16 v152 = 2048;
      double v153 = v114;
      unsigned int v106 = MEMORY[0x1E4F14500];
      int v107 = "[VCPEncStatsMonitor] %{public}s: Input_fps=%.2f, Enc_fps=%.2f, drop_fps=%.2f, repeat_fps=%.2f, idr_fps=%.2f"
             ", refresh_fps=%.2f, Tx_fps=%.2f, Avg_QP=%.2f, Bit_rate (Total/Target/Video/FEC/Header/SEI/RTX)=%.0f/%.0f/%."
             "0f/%.0f/%.0f/%.0f/%0.f, %{public}sEnc_time=%.2f ms\n";
      uint32_t v108 = 182;
LABEL_193:
      _os_log_impl(&dword_1BB9B9000, v106, OS_LOG_TYPE_DEFAULT, v107, buf, v108);
    }
  }
}

void sub_1BB9D86FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CMSampleBufferRef sbuf)
{
  uint64_t v5 = sbuf;
  error[2] = *(CFErrorRef *)MEMORY[0x1E4F143B8];
  CMSampleBufferRef sbufa = sbuf;
  if (sbuf) {
    CFRetain(sbuf);
  }
  unsigned int v10 = a4 & 2;
  double valuePtr = -1.0;
  int v11 = *(_DWORD *)(a1 + 60);
  int v119 = *(_DWORD *)(a1 + 64);
  int v120 = v11;
  uint64_t v118 = 0;
  if (a1 && a2)
  {
    if ((a4 & 2) == 0 && !v5)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Invalid sample buffer\n", buf, 2u);
      }
      goto LABEL_198;
    }
    if ((a4 & 2) != 0)
    {
      BOOL v14 = 0;
    }
    else
    {
      FormatDescription = CMSampleBufferGetFormatDescription(v5);
      BOOL v14 = CMFormatDescriptionGetMediaSubType(FormatDescription) == 1685481521;
    }
    if (*(_WORD *)(a1 + 50)
      && *(unsigned char *)(a1 + 52)
      && !v5
      && CMSampleBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, &sbufa))
    {
      CMSampleBufferRef sbufa = 0;
    }
    if ((a4 & 2) != 0)
    {
      if (!sbufa)
      {
        DataCFIndex Length = 0;
LABEL_122:
        CFDictionaryRef theDict = 0;
        uint64_t v115 = 0;
        char v67 = 1;
        goto LABEL_131;
      }
      uint64_t v16 = 0;
      goto LABEL_99;
    }
    int v17 = *(_DWORD *)(a2 + 8);
    if (v17 < (unint64_t)((uint64_t)(*(void *)(a2 + 280) - *(void *)(a2 + 272)) >> 3))
    {
      uint64_t v18 = v17 + 1;
      int v19 = *(_DWORD *)(a1 + 72);
      if ((int)v18 >= v19)
      {
        int v22 = *(_DWORD *)(a2 + 8);
      }
      else
      {
        do
        {
          double v20 = *(std::__assoc_sub_state **)(*(void *)(a2 + 272) + 8 * v18);
          if (v20)
          {
            sub_1BB9D9848(v20);
            if (!*v21) {
              int v17 = v18;
            }
            int v19 = *(_DWORD *)(a1 + 72);
          }
          ++v18;
        }
        while (v18 < v19);
        int v22 = *(_DWORD *)(a2 + 8);
      }
      *(unsigned char *)(a2 + 80) = v22 == v17;
    }
    if (!v14)
    {
      int v23 = *(_DWORD *)(a1 + 68);
      if (v23 == 42 || v23 == 20)
      {
        uint64_t v24 = *(void *)(a1 + 2192);
        if (v24)
        {
          if (*(unsigned char *)(v24 + 33)) {
            sub_1BB9D9908(a1, &sbufa, a2);
          }
        }
      }
    }
    if (!sbufa)
    {
      DataCFIndex Length = 0;
LABEL_119:
      if ((a4 & 2) == 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "no sample attachment found\n", buf, 2u);
      }
      goto LABEL_122;
    }
    if (*(_DWORD *)(a1 + 72) != 1 && !*(unsigned char *)(a2 + 80)
      || (CFDictionaryRef v25 = *(const __CFDictionary **)(a2 + 264)) == 0
      || (int v26 = *(_DWORD *)(a1 + 2328),
          !CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 264), @"PropagatableAttachments"))
      || (CFNumberRef v27 = CFDictionaryGetValue(v25, @"PropagatableAttachments")) == 0)
    {
LABEL_74:
      uint64_t v16 = v118;
      if (!v118) {
        goto LABEL_99;
      }
      int v42 = *(std::mutex **)(a1 + 2336);
      if (v42)
      {
        *(void *)buf = *(void *)(a1 + 2336);
        uint8_t buf[8] = 1;
        std::mutex::lock(v42);
        *(_DWORD *)(a1 + 2332) += 8 * v118;
        sub_1BB9D9FD4((uint64_t)buf);
        if (buf[8]) {
          std::mutex::unlock(*(std::mutex **)buf);
        }
LABEL_87:
        uint64_t v48 = *(void *)(a1 + 2184);
        if (!v48) {
          goto LABEL_99;
        }
        double v49 = *(double *)(v48 + 32);
        if (v49 <= 0.0
          || v49 > (double)(unint64_t)(8 * v16)
          || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          goto LABEL_99;
        }
        int v51 = *(_DWORD *)(a1 + 60);
        int v50 = *(_DWORD *)(a1 + 64);
        int v52 = *(_DWORD *)(a1 + 24);
        BOOL v53 = "H.264";
        if (v52 > 1718908519)
        {
          if (v52 == 1752589105) {
            goto LABEL_97;
          }
          int v54 = 1718908520;
        }
        else
        {
          if (v52 == 1684632424) {
            goto LABEL_97;
          }
          int v54 = 1685481521;
        }
        if (v52 != v54)
        {
LABEL_98:
          *(_DWORD *)buf = 134219266;
          *(void *)&uint8_t buf[4] = a1;
          __int16 v126 = 1024;
          *(_DWORD *)double v127 = v51;
          *(_WORD *)&v127[4] = 1024;
          *(_DWORD *)&v127[6] = v50;
          __int16 v128 = 2080;
          double v129 = v53;
          __int16 v130 = 2048;
          double v131 = (double)(unint64_t)(8 * v16);
          __int16 v132 = 2048;
          *(double *)double v133 = v49;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): VCPCompressionSessionCallback SEI size=%.0f larger than target frame size=%.0f\n", buf, 0x36u);
LABEL_99:
          CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbufa, 1u);
          if (SampleAttachmentsArray) {
            CFDictionaryRef theDict = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
          }
          else {
            CFDictionaryRef theDict = 0;
          }
          DataBuffer = CMSampleBufferGetDataBuffer(sbufa);
          DataCFIndex Length = CMBlockBufferGetDataLength(DataBuffer);
          if (theDict)
          {
            if (*(unsigned char *)(a1 + 52))
            {
              CFNumberRef v57 = CFNumberCreate(0, kCFNumberSInt16Type, (const void *)(a1 + 48));
              if (v57)
              {
                CFDictionarySetValue(theDict, @"PriorityScore", v57);
                CFRelease(v57);
              }
            }
            unint64_t v58 = (const void **)MEMORY[0x1E4F1F1A8];
            if (*(int *)(a1 + 72) >= 2)
            {
              *(_DWORD *)buf = *(_DWORD *)(a2 + 8);
              CFNumberRef v59 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
              if (v59)
              {
                CFDictionarySetValue(theDict, @"TileID", v59);
                CFRelease(v59);
              }
              *(_WORD *)buf = *(_DWORD *)(a1 + 76);
              CFNumberRef v60 = CFNumberCreate(0, kCFNumberSInt16Type, buf);
              if (v60)
              {
                CFDictionarySetValue(theDict, @"TileOrder", v60);
                CFRelease(v60);
              }
              if (*(unsigned char *)(a2 + 44))
              {
                double v61 = (const void *)*MEMORY[0x1E4F1CFC8];
                CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E4F1F200], (const void *)*MEMORY[0x1E4F1CFC8]);
                CFDictionarySetValue(theDict, *v58, v61);
              }
            }
            uint64_t v62 = (const void *)*MEMORY[0x1E4F45370];
            if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F45370]))
            {
              CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, v62);
              CFNumberRef v64 = Value;
              if (Value)
              {
                CFTypeID v65 = CFGetTypeID(Value);
                if (v65 == CFNumberGetTypeID()) {
                  CFNumberGetValue(v64, kCFNumberDoubleType, &valuePtr);
                }
              }
            }
            int v66 = CFDictionaryGetValue(theDict, *v58);
            if (v66) {
              HIDWORD(v115) = CFEqual(v66, (CFTypeRef)*MEMORY[0x1E4F1CFC8]) != 0;
            }
            else {
              HIDWORD(v115) = 0;
            }
            unint64_t v68 = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F453B0]);
            if (v68)
            {
              LODWORD(v115) = CFEqual(v68, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
              if (!v16) {
                goto LABEL_130;
              }
            }
            else
            {
              LODWORD(v115) = 0;
              if (!v16)
              {
LABEL_130:
                char v67 = 0;
LABEL_131:
                unsigned int v116 = v10 >> 1;
                if (*(void *)(a1 + 2184))
                {
                  LODWORD(v124) = 0;
                  if ((a4 & 2) != 0) {
                    char v67 = 1;
                  }
                  if ((v67 & 1) == 0)
                  {
                    if (CFDictionaryContainsKey(theDict, @"TemporalID"))
                    {
                      CFNumberRef v70 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"TemporalID");
                      if (v70)
                      {
                        CFTypeID TypeID = CFNumberGetTypeID();
                        if (TypeID == CFGetTypeID(v70)) {
                          CFNumberGetValue(v70, kCFNumberSInt32Type, &v124);
                        }
                      }
                    }
                  }
                  uint64_t v72 = *(void *)(a1 + 2184);
                  int v74 = *(_DWORD *)(a2 + 24);
                  int v111 = *(unsigned __int8 *)(a2 + 45);
                  double v75 = valuePtr;
                  int v76 = (int)v124;
                  *(_DWORD *)buf = *(_DWORD *)(a2 + 8);
                  int v73 = *(_DWORD *)buf;
                  std::mutex::lock((std::mutex *)(v72 + 208));
                  unsigned int v112 = a3;
                  unsigned int v113 = a4;
                  BOOL v77 = sub_1BB9C8230((uint64_t **)(v72 + 184), v73, buf);
                  int32x4_t v78 = v77;
                  double v79 = (uint64_t *)v72;
                  while (1)
                  {
                    double v79 = (uint64_t *)v79[1];
                    if (v79 == (uint64_t *)v72) {
                      break;
                    }
                    int v80 = (_DWORD *)v79[2];
                    if (*v80 == v74)
                    {
                      double v110 = v77 + 5;
                      if (!v10)
                      {
                        sub_1BB9C8B88((void *)(v72 + 88), v80 + 11);
                        unint64_t v81 = *(void *)(v72 + 128);
                        if (v81 >= 0x11)
                        {
                          ++*(void *)(v72 + 120);
                          *(void *)(v72 + 128) = v81 - 1;
                          sub_1BB9C8C10(v72 + 88);
                        }
                        LODWORD(error[0]) = 8 * DataLength;
                        sub_1BB9C8B88((void *)(v72 + 40), error);
                        unint64_t v82 = *(void *)(v72 + 80);
                        if (v82 >= 0x11)
                        {
                          ++*(void *)(v72 + 72);
                          *(void *)(v72 + 80) = v82 - 1;
                          sub_1BB9C8C10(v72 + 40);
                        }
                        if (!v76) {
                          *((unsigned char *)v78 + 128) = 0;
                        }
                      }
                      if (v111)
                      {
                        BOOL v83 = v78[9];
                        if (v83 && !*(unsigned char *)v83) {
                          *((_DWORD *)v78 + 30) = 0;
                        }
                        if (!v10)
                        {
                          int v84 = *((_DWORD *)v78 + 30);
                          if ((v84 & 0x80000000) == 0) {
                            *((_DWORD *)v78 + 30) = v84 + 1;
                          }
                        }
                        if (v75 < 17.0)
                        {
                          double v85 = operator new(0x18uLL);
                          v85[4] = v74;
                          *((void *)v85 + 1) = v110;
                          unsigned int v86 = v78[5];
                          *(void *)double v85 = v86;
                          v86[1] = (uint64_t)v85;
                          v78[5] = (uint64_t *)v85;
                          v78[7] = (uint64_t *)((char *)v78[7] + 1);
                        }
                      }
                      unsigned int v87 = (std::__shared_weak_count *)operator new(0x28uLL);
                      unint64_t v88 = v87;
                      v87->__shared_owners_ = 0;
                      v87->__shared_weak_owners_ = 0;
                      v87->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14EEBD8;
                      LOBYTE(v87[1].__vftable) = v111;
                      BOOL v89 = (uint64_t *)&v87[1];
                      BYTE1(v87[1].__vftable) = v116;
                      *(double *)&v87[1].__shared_owners_ = v75;
                      if (!v116)
                      {
                        atomic_fetch_add_explicit(&v87->__shared_owners_, 1uLL, memory_order_relaxed);
                        int32x4_t v90 = (std::__shared_weak_count *)v78[10];
                        v78[9] = v89;
                        v78[10] = (uint64_t *)v88;
                        if (v90) {
                          sub_1BB9C09B4(v90);
                        }
                      }
                      sub_1BB9C09B4(v88);
                      uint64_t v91 = *v79;
                      *(void *)(v91 + 8) = v79[1];
                      *(void *)v79[1] = v91;
                      --*(void *)(v72 + 16);
                      unsigned int v92 = (std::__shared_weak_count *)v79[3];
                      if (v92) {
                        sub_1BB9C09B4(v92);
                      }
                      operator delete(v79);
                      break;
                    }
                  }
                  std::mutex::unlock((std::mutex *)(v72 + 208));
                  a3 = v112;
                  a4 = v113;
                }
                sub_1BBA3F6DC(a2 + 176);
                double v93 = *(double *)(a2 + 176);
                if (*(int *)(a1 + 72) > 1) {
                  goto LABEL_177;
                }
                double v94 = *(double *)(a1 + 88);
                if (v94 <= 0.0
                  || v93 * 1000.0 <= 1.0 / v94 * 3000.0
                  || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
                {
                  goto LABEL_177;
                }
                int v96 = *(_DWORD *)(a1 + 60);
                int v95 = *(_DWORD *)(a1 + 64);
                int v97 = *(_DWORD *)(a1 + 24);
                double v98 = "H.264";
                if (v97 > 1718908519)
                {
                  if (v97 == 1752589105) {
                    goto LABEL_175;
                  }
                  int v99 = 1718908520;
                }
                else
                {
                  if (v97 == 1684632424) {
                    goto LABEL_175;
                  }
                  int v99 = 1685481521;
                }
                if (v97 != v99)
                {
LABEL_176:
                  int v100 = *(_DWORD *)(a2 + 24);
                  *(_DWORD *)buf = 134219778;
                  *(void *)&uint8_t buf[4] = a1;
                  __int16 v126 = 1024;
                  *(_DWORD *)double v127 = v96;
                  *(_WORD *)&v127[4] = 1024;
                  *(_DWORD *)&v127[6] = v95;
                  __int16 v128 = 2080;
                  double v129 = v98;
                  __int16 v130 = 2048;
                  double v131 = v93 * 1000.0;
                  __int16 v132 = 1024;
                  *(_DWORD *)double v133 = v100;
                  *(_WORD *)&v133[4] = 2048;
                  *(double *)&v133[6] = 1.0 / v94 * 1000.0;
                  __int16 v134 = 2048;
                  double v135 = v94;
                  _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Delay Warning: Encoding time=%.2f ms of frame=%d is greater than 3 times the expected input frame interval=%.2f ms with input frame rate=%.2f\n", buf, 0x46u);
LABEL_177:
                  uint64_t v101 = *(void *)(a1 + 2312);
                  if (v101)
                  {
                    sub_1BBAC8868(v101, (uint64_t *)"encoded_frames", 1.0);
                    sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"header_bits", (double)*(int *)(a2 + 28));
                    sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"rtx_bits", (double)*(int *)(a2 + 32));
                    sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"fec_bits", (double)*(int *)(a2 + 36));
                    sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"sei_bits", (double)*(int *)(a2 + 40));
                    uint64_t v102 = *(void *)(a1 + 2312);
                    if (v10)
                    {
                      sub_1BBAC8868(v102, (uint64_t *)"dropped_frames", 1.0);
                    }
                    else
                    {
                      sub_1BBAC8868(v102, (uint64_t *)"transmit_frames", 1.0);
                      sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"encoded_bits", (double)(8 * DataLength));
                      sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"encoding_time", v93);
                      sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"frame_qp", valuePtr);
                      sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"min_frame_size", (double)*(int *)(a2 + 168));
                    }
                    if (*(unsigned char *)(a2 + 45)) {
                      sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"repeated_frames", 1.0);
                    }
                    if (HIDWORD(v115)) {
                      sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"idr_frames", 1.0);
                    }
                    if (v115) {
                      sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"refresh_frames", 1.0);
                    }
                  }
                  if (!v10
                    && sbufa
                    && CFDictionaryContainsKey(theDict, @"VRAWidth")
                    && CFDictionaryContainsKey(theDict, @"VRAHeight"))
                  {
                    CFNumberRef v103 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"VRAWidth");
                    CFNumberRef v104 = v103;
                    if (v103)
                    {
                      CFTypeID v105 = CFGetTypeID(v103);
                      if (v105 == CFNumberGetTypeID()) {
                        CFNumberGetValue(v104, kCFNumberSInt32Type, &v120);
                      }
                    }
                    CFNumberRef v106 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"VRAHeight");
                    CFNumberRef v107 = v106;
                    if (v106)
                    {
                      CFTypeID v108 = CFGetTypeID(v106);
                      if (v108 == CFNumberGetTypeID()) {
                        CFNumberGetValue(v107, kCFNumberSInt32Type, &v119);
                      }
                    }
                  }
                  kdebug_trace();
                  kdebug_trace();
LABEL_198:
                  (*(void (**)(void, void, uint64_t, uint64_t, CMSampleBufferRef))(a1 + 32))(*(void *)(a1 + 40), *(void *)a2, a3, a4, sbufa);
                  *(_DWORD *)(a1 + 76) += (sbufa != 0) & ~(v10 != 0);
                  uint64_t v109 = sub_1BB9DA018(a2);
                  MEMORY[0x1C18605E0](v109, 0x10A0C40973F72EDLL);
                  uint64_t v5 = sbufa;
                  if (!sbufa) {
                    return;
                  }
                  goto LABEL_199;
                }
LABEL_175:
                double v98 = "HEVC";
                goto LABEL_176;
              }
            }
            *(_DWORD *)buf = v16;
            CFNumberRef v69 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
            if (v69)
            {
              CFDictionarySetValue(theDict, @"PropagatableAttachmentsNALSize", v69);
              CFRelease(v69);
            }
            goto LABEL_130;
          }
          goto LABEL_119;
        }
LABEL_97:
        BOOL v53 = "HEVC";
        goto LABEL_98;
      }
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_87;
      }
      int v44 = *(_DWORD *)(a1 + 60);
      int v43 = *(_DWORD *)(a1 + 64);
      int v45 = *(_DWORD *)(a1 + 24);
      unint64_t v46 = "H.264";
      if (v45 > 1718908519)
      {
        if (v45 == 1752589105) {
          goto LABEL_85;
        }
        int v47 = 1718908520;
      }
      else
      {
        if (v45 == 1684632424) {
          goto LABEL_85;
        }
        int v47 = 1685481521;
      }
      if (v45 != v47)
      {
LABEL_86:
        *(_DWORD *)buf = 134218754;
        *(void *)&uint8_t buf[4] = a1;
        __int16 v126 = 1024;
        *(_DWORD *)double v127 = v44;
        *(_WORD *)&v127[4] = 1024;
        *(_DWORD *)&v127[6] = v43;
        __int16 v128 = 2080;
        double v129 = v46;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): VCPCompressionSessionCallback got NULL callback mutex\n", buf, 0x22u);
        goto LABEL_87;
      }
LABEL_85:
      unint64_t v46 = "HEVC";
      goto LABEL_86;
    }
    if (v26 == 1)
    {
      error[0] = 0;
      CFDataRef Data = CFPropertyListCreateData(0, v27, kCFPropertyListBinaryFormat_v1_0, 0, error);
      if (Data)
      {
        sub_1BB9BE18C((const void **)error);
        theCFDataRef Data = Data;
        BytePtr = CFDataGetBytePtr(Data);
        CFIndex Length = CFDataGetLength(theData);
        sub_1BB9D55C0((uint64_t)&sbufa, (uint64_t)BytePtr, Length, &v118);
      }
      CFTypeID v33 = CFGetTypeID(v27);
      CFStringRef v34 = CFCopyTypeIDDescription(v33);
      __int16 v124 = (void *)v34;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        CStringPtr = CFStringGetCStringPtr(v34, 0x8000100u);
        CFStringRef v36 = CFErrorCopyFailureReason(error[0]);
        double v37 = CFStringGetCStringPtr(v36, 0x8000100u);
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = CStringPtr;
        __int16 v126 = 2080;
        *(void *)double v127 = v37;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to serialize %s (%s)", buf, 0x16u);
      }
      sub_1BB9BE158((const void **)&v124);
      sub_1BB9BE18C((const void **)error);
      theCFDataRef Data = 0;
      sub_1BB9BE124((const void **)&theData);
      goto LABEL_74;
    }
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    __int16 v124 = Mutable;
    if (!Mutable)
    {
LABEL_73:
      sub_1BB9BE228((const void **)&v124);
      goto LABEL_74;
    }
    CFDictionaryAddValue(Mutable, @"PropagatableAttachments", v27);
    *(void *)buf = 0;
    if (v26 == 2) {
      int SerializedAtomDataBlockBufferWithFlagsForCFType = FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForCFType();
    }
    else {
      int SerializedAtomDataBlockBufferWithFlagsForCFType = FigRemote_CreateSerializedAtomDataBlockBufferForCFType();
    }
    int v38 = SerializedAtomDataBlockBufferWithFlagsForCFType;
    int v39 = *(OpaqueCMBlockBuffer **)buf;
    if (*(void *)buf)
    {
      theCFDataRef Data = *(CFDataRef *)buf;
LABEL_64:
      size_t v40 = CMBlockBufferGetDataLength(v39);
      BOOL v41 = operator new[](v40, MEMORY[0x1E4FBA2D0]);
      if (v41)
      {
        *(void *)buf = 0;
        CMBlockBufferAccessDataBytes(theData, 0, v40, v41, (char **)buf);
        sub_1BB9D55C0((uint64_t)&sbufa, *(uint64_t *)buf, v40, &v118);
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "addAttachmentSEI unable to create temp buffer\n", buf, 2u);
      }
      goto LABEL_72;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(error[0]) = 67109120;
      HIDWORD(error[0]) = v38;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "CFPropertyList SerializeAtomData failed at SerializedAtomDataBlockBufferForCFType (%d)\n", (uint8_t *)error, 8u);
      int v39 = *(OpaqueCMBlockBuffer **)buf;
      theCFDataRef Data = *(CFDataRef *)buf;
      if (*(void *)buf) {
        goto LABEL_64;
      }
    }
    else
    {
      theCFDataRef Data = 0;
    }
LABEL_72:
    sub_1BB9BE25C((const void **)&theData);
    goto LABEL_73;
  }
  if (a2) {
    goto LABEL_198;
  }
  BOOL v12 = (a4 & 2) != 0 || v5 == 0;
  int v13 = *(_DWORD *)(a1 + 76);
  if (!v12) {
    ++v13;
  }
  *(_DWORD *)(a1 + 76) = v13;
  if (v5) {
LABEL_199:
  }
    CFRelease(v5);
}

void sub_1BB9D97B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26,std::mutex *a27,char a28)
{
}

void sub_1BB9D9848(std::__assoc_sub_state *a1)
{
  __lk.__m_ = &a1->__mut_;
  __lk.__owns_ = 1;
  std::mutex::lock(&a1->__mut_);
  std::__assoc_sub_state::__sub_wait(a1, &__lk);
  ptr = a1->__exception_.__ptr_;
  v5.__ptr_ = 0;
  std::exception_ptr::~exception_ptr(&v5);
  if (ptr)
  {
    std::exception_ptr::exception_ptr(&v4, &a1->__exception_);
    v3.__ptr_ = &v4;
    std::rethrow_exception(v3);
    __break(1u);
  }
  else if (__lk.__owns_)
  {
    std::mutex::unlock(__lk.__m_);
  }
}

void sub_1BB9D98DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, char a12)
{
  if (a12) {
    std::mutex::unlock(a11);
  }
  _Unwind_Resume(a1);
}

char *sub_1BB9D9908(uint64_t a1, CMSampleBufferRef *a2, uint64_t a3)
{
  v26[1] = *MEMORY[0x1E4F143B8];
  DataBuffer = CMSampleBufferGetDataBuffer(*a2);
  size_t v25 = 0;
  v26[0] = 0;
  size_t v24 = 0;
  uint64_t result = sub_1BBAB1784(*(char **)(a1 + 2192));
  if (result)
  {
    uint64_t v7 = (uint64_t)result;
    int v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 2192) + 312))(*(void *)(a1 + 2192));
    int v9 = 0;
    if (v8)
    {
      int v10 = *(_DWORD *)(a1 + 24);
      if (v10 > 1718908519)
      {
        if (v10 == 1718908520) {
          goto LABEL_13;
        }
        int v11 = 1752589105;
      }
      else
      {
        if (v10 == 1684632424) {
          goto LABEL_13;
        }
        int v11 = 1685481521;
      }
      if (v10 != v11) {
        int v9 = 1;
      }
LABEL_13:
      if (sub_1BBAB19BC(v7, *(void *)(a1 + 2192), v9, DataBuffer, v26, &v24, &v25, 0)) {
        return (char *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 8))(v7);
      }
      goto LABEL_21;
    }
    int v12 = *(_DWORD *)(a1 + 24);
    if (v12 > 1718908519)
    {
      if (v12 != 1718908520)
      {
        int v13 = 1752589105;
LABEL_17:
        if (v12 != v13) {
          int v9 = 1;
        }
      }
    }
    else if (v12 != 1684632424)
    {
      int v13 = 1685481521;
      goto LABEL_17;
    }
    if (sub_1BBAB1D3C(DataBuffer, 4u, v9, &v24, &v25, 0)) {
      return (char *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    v26[0] = 0;
LABEL_21:
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 2192) + 88))(*(void *)(a1 + 2192))
      && *(void *)(a3 + 96))
    {
      int v14 = 1 << (*(uint64_t (**)(void))(**(void **)(a1 + 2192) + 216))(*(void *)(a1 + 2192));
      char v15 = *(unsigned char *)(v7 + 186);
      if (*(unsigned char *)(a3 + 80))
      {
        char v16 = v15 | v14;
        uint64_t v17 = *(void *)(a3 + 96);
      }
      else
      {
        uint64_t v17 = 0;
        char v16 = v15 & ~(_BYTE)v14;
      }
      *(unsigned char *)(v7 + 186) = v16;
      *(void *)(v7 + 88) = v17;
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 2192) + 96))(*(void *)(a1 + 2192))) {
      *(unsigned char *)(v7 + 96) = *(unsigned char *)(a3 + 80);
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 2192) + 104))(*(void *)(a1 + 2192)))
    {
      int v18 = 1 << (*(uint64_t (**)(void))(**(void **)(a1 + 2192) + 232))(*(void *)(a1 + 2192));
      if (*(int *)(a1 + 72) >= 2 && *(unsigned char *)(a3 + 44))
      {
        *(_WORD *)(v7 + 98) = *(_DWORD *)(a1 + 144);
        *(_WORD *)(v7 + 100) = *(_DWORD *)(a1 + 148);
        char v19 = *(unsigned char *)(v7 + 186) | v18;
      }
      else
      {
        *(_DWORD *)(v7 + 98) = 0;
        char v19 = *(unsigned char *)(v7 + 186) & ~(_BYTE)v18;
      }
      *(unsigned char *)(v7 + 186) = v19;
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 2192) + 120))(*(void *)(a1 + 2192)))
    {
      int v20 = 1 << (*(uint64_t (**)(void))(**(void **)(a1 + 2192) + 248))(*(void *)(a1 + 2192));
      int v21 = *(_DWORD *)(a3 + 160);
      if (v21 < 1 || (int v22 = *(_DWORD *)(a3 + 164), v22 < 1))
      {
        char v23 = *(unsigned char *)(v7 + 186) & ~(_BYTE)v20;
      }
      else
      {
        *(_WORD *)(v7 + 104) = *(_DWORD *)(a3 + 152);
        *(_WORD *)(v7 + 106) = *(_DWORD *)(a3 + 156);
        *(_WORD *)(v7 + 108) = v21;
        *(_WORD *)(v7 + 110) = v22;
        char v23 = *(unsigned char *)(v7 + 186) | v20;
      }
      *(unsigned char *)(v7 + 186) = v23;
    }
    operator new[]();
  }
  return result;
}

void sub_1BB9D9FD4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    std::mutex::unlock(*(std::mutex **)a1);
    *(unsigned char *)(a1 + 8) = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    sub_1BB9DA018();
  }
}

uint64_t sub_1BB9DA018(uint64_t a1)
{
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 216));
  BOOL v2 = *(__CVBuffer **)(a1 + 224);
  if (v2)
  {
    CVPixelBufferRelease(v2);
    *(void *)(a1 + 224) = 0;
  }
  std::exception_ptr v3 = *(const void **)(a1 + 264);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v7 = (void **)(a1 + 272);
  sub_1BB9DA0FC(&v7);
  std::exception_ptr v4 = *(atomic_ullong **)(a1 + 248);
  if (v4 && !atomic_fetch_add(v4 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v4 + 16))(v4);
  }
  std::exception_ptr v5 = *(atomic_ullong **)(a1 + 240);
  if (v5 && !atomic_fetch_add(v5 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v5 + 16))(v5);
  }
  std::future<void>::~future((std::future<void> *)(a1 + 232));
  return a1;
}

void sub_1BB9DA0FC(void ***a1)
{
  BOOL v2 = *a1;
  if (*v2)
  {
    sub_1BB9DA150((atomic_ullong *)v2, (atomic_ullong)*v2);
    std::exception_ptr v3 = **a1;
    operator delete(v3);
  }
}

atomic_ullong *sub_1BB9DA150(atomic_ullong *result, atomic_ullong a2)
{
  std::exception_ptr v3 = result;
  for (atomic_ullong i = result[1]; i != a2; i -= 8)
  {
    std::exception_ptr v5 = *(atomic_ullong **)(i - 8);
    uint64_t result = v5;
    if (v5 && !atomic_fetch_add(result + 1, 0xFFFFFFFFFFFFFFFFLL)) {
      uint64_t result = (atomic_ullong *)(*(uint64_t (**)(atomic_ullong *))(*result + 16))(result);
    }
  }
  v3[1] = a2;
  return result;
}

CVPixelBufferPoolRef VCPCompressionSessionGetPixelBufferPool(uint64_t a1)
{
  return VTCompressionSessionGetPixelBufferPool(*(VTCompressionSessionRef *)(a1 + 16));
}

uint64_t VCPCompressionSessionCopyProperty(uint64_t a1, const __CFString *a2, const __CFAllocator *a3, void *a4)
{
  return VTSessionCopyProperty(*(VTSessionRef *)(a1 + 16), a2, a3, a4);
}

uint64_t VCPCompressionSessionCopySupportedPropertyDictionary(uint64_t a1, CFDictionaryRef *a2)
{
  return VTSessionCopySupportedPropertyDictionary(*(VTSessionRef *)(a1 + 16), a2);
}

__CFArray *VCPCompressionAllocateDPB(const __CFDictionary *a1, int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  CFNumberRef Value = CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F44BE0]);
  int v9 = CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F44BD8]);
  int v10 = CFDictionaryGetValue(a1, @"DPBPixelFormat");
  if (!Value
    || ((int v11 = v10, TypeID = CFNumberGetTypeID(), TypeID == CFGetTypeID(Value)) ? (v13 = v9 == 0) : (v13 = 1),
        v13
     || ((CFTypeID v14 = CFBooleanGetTypeID(), v14 == CFGetTypeID(v9)) ? (v15 = v11 == 0) : (v15 = 1),
         v15 || (CFTypeID v16 = CFNumberGetTypeID(), v16 != CFGetTypeID(v11)))))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPCompressionAllocateDPB: invalid desc %@\n", buf, 0xCu);
    }
    return 0;
  }
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t valuePtr = 0;
  uint64_t v50 = 0;
  CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  CFNumberGetValue((CFNumberRef)v11, kCFNumberSInt32Type, &valuePtr);
  int v47 = CFBooleanGetValue((CFBooleanRef)v9);
  uint64_t v17 = valuePtr;
  if (qword_1EC027190 != -1) {
    dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
  }
  int v18 = dword_1EC02719C;
  AppBooleanCFNumberRef Value = CFPreferencesGetAppBooleanValue(@"corevideo_dpb_alloc", @"com.apple.VideoProcessing", 0);
  BOOL v22 = v18 > 12 && v47 == 0 || AppBooleanValue != 0;
  int v23 = sub_1BBA13A1C(v17);
  if (a2 == 1752589105)
  {
    int v25 = 0;
    int32x2_t v24 = vmax_s32((int32x2_t)(*(void *)&vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)0x1F0000001FLL) & 0xFFFFFFE0FFFFFFE0), (int32x2_t)0x40000000A0);
    if (v22) {
      goto LABEL_33;
    }
    goto LABEL_31;
  }
  if (a2 != 1635148593)
  {
    int v25 = 0;
    int32x2_t v24 = 0;
    if (v22) {
      goto LABEL_33;
    }
LABEL_31:
    CFDictionaryRef v28 = 0;
    OSType pixelFormatType = 0;
    goto LABEL_40;
  }
  int32x2_t v24 = vmax_s32((int32x2_t)(*(void *)&vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)0xF0000000FLL) & 0xFFFFFFF0FFFFFFF0), (int32x2_t)0x60000000C0);
  int v25 = 1;
  if (!v22) {
    goto LABEL_31;
  }
LABEL_33:
  int32x2_t v45 = v24;
  OSType v29 = sub_1BBA7C090(v17);
  unsigned int v30 = v45.i32[0];
  unsigned int v31 = v45.u32[1];
  int v32 = sub_1BBA7C514(v45.i32[0], v45.i32[1], v25);
  CFDictionaryRef v28 = v32;
  OSType pixelFormatType = v29;
  if (v29 && v32)
  {
    CFTypeID v33 = 0;
    int v34 = 1;
    goto LABEL_47;
  }
  if (dword_1E9F80A90 >= 3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v17;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Not using CoreVideo to allocate DPB for pixfmt %d", buf, 8u);
  }
  int32x2_t v24 = v45;
LABEL_40:
  if (qword_1EC027190 != -1)
  {
    int32x2_t v46 = v24;
    dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
    int32x2_t v24 = v46;
  }
  unsigned int v30 = v24.i32[0];
  unsigned int v31 = v24.u32[1];
  int v35 = sub_1BBA7BA1C(v24.i32[0], v24.i32[1], dword_1EC02719C, v25, v17, (signed int *)buf, &v56, (_DWORD *)&v52 + 1, &v52, (unsigned int *)&v51 + 1, (unsigned int *)&v51, (_DWORD *)&v50 + 1, (unsigned int *)&v50);
  if (!v35)
  {
    *(_DWORD *)int v54 = HIDWORD(v52);
    int v55 = v52;
    v53[0] = HIDWORD(v51);
    v53[1] = v51;
    CFTypeID v33 = sub_1BBA7C89C(v30, v31, v25, v23, v17, (uint64_t)v54, (uint64_t)v53, 0);
    int v34 = 0;
LABEL_47:
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    char v37 = 0;
    CFStringRef v38 = (const __CFString *)*MEMORY[0x1E4F2F128];
    int v39 = HIDWORD(valuePtr);
    while (v39 < 1)
    {
LABEL_62:
      unsigned __int8 v44 = v37 ^ 1;
      char v37 = 1;
      if (((v47 != 0) & v44) == 0)
      {
        int v36 = 0;
        goto LABEL_65;
      }
    }
    int v40 = 0;
    while (1)
    {
      if (v34)
      {
        *(void *)buf = 0;
        if (CVPixelBufferCreate(0, v30, v31, pixelFormatType, v28, (CVPixelBufferRef *)buf)) {
          goto LABEL_64;
        }
        IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)buf);
        int v42 = IOSurface;
        if (IOSurface) {
          CFRetain(IOSurface);
        }
        CFRelease(*(CFTypeRef *)buf);
      }
      else
      {
        int v43 = IOSurfaceCreate(v33);
        if (!v43)
        {
LABEL_64:
          int v36 = 1;
          goto LABEL_65;
        }
        int v42 = v43;
        IOSurfaceSetValue(v43, v38, @"dpb");
        if (v37)
        {
          if (qword_1EC027190 != -1) {
            dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
          }
          if (dword_1EC02719C <= 12) {
            sub_1BBA7DF24(v42, v50, SBYTE4(v50));
          }
        }
      }
      CFArrayAppendValue(Mutable, v42);
      CFRelease(v42);
      ++v40;
      int v39 = HIDWORD(valuePtr);
      if (v40 >= SHIDWORD(valuePtr)) {
        goto LABEL_62;
      }
    }
  }
  int v36 = v35;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v54 = 0;
    _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to calculate recon buffer size\n", v54, 2u);
  }
  CFMutableDictionaryRef Mutable = 0;
  CFTypeID v33 = 0;
LABEL_65:
  if (v28) {
    CFRelease(v28);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v36 && Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

void VCPAVEContextCreate()
{
}

uint64_t VCPAVEContextRelease(uint64_t result)
{
  if (result)
  {
    sub_1BB9C1B6C((const void **)(result + 48));
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

uint64_t VCPAVEScaleReferenceFrames(_DWORD *a1, CFDictionaryRef theDict)
{
  v93[4] = *MEMORY[0x1E4F143B8];
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F44E18]);
  CFIndex v4 = 0;
  double v79 = (const void *)*MEMORY[0x1E4F44E40];
  int32x4_t v78 = (const void *)*MEMORY[0x1E4F44E48];
  BOOL v77 = (const void *)*MEMORY[0x1E4F44E70];
  key = (void *)*MEMORY[0x1E4F44E60];
  double v75 = (void *)*MEMORY[0x1E4F44E58];
  int v74 = (void *)*MEMORY[0x1E4F44E78];
  int v73 = (void *)*MEMORY[0x1E4F44E80];
  uint64_t v72 = (void *)*MEMORY[0x1E4F44EA0];
  BOOL v71 = (void *)*MEMORY[0x1E4F44E90];
  CFNumberRef v70 = (void *)*MEMORY[0x1E4F44E88];
  CFNumberRef v69 = (void *)*MEMORY[0x1E4F44E98];
  unint64_t v68 = (void *)*MEMORY[0x1E4F44E50];
  std::exception_ptr v5 = (const void *)*MEMORY[0x1E4F44E38];
  CFAllocatorRef v6 = (const void *)*MEMORY[0x1E4F44E20];
  uint64_t v7 = (const void *)*MEMORY[0x1E4F44E30];
  int v66 = (void *)*MEMORY[0x1E4F44E28];
  char v67 = (void *)*MEMORY[0x1E4F44E68];
  while (CFArrayGetCount(Value) > v4)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v4);
    CFBooleanRef v9 = (const __CFBoolean *)CFDictionaryGetValue(ValueAtIndex, @"DelayedRVRAScale");
    if (!CFBooleanGetValue(v9)) {
      goto LABEL_63;
    }
    CFNumberRef v10 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v79);
    CFNumberRef v11 = v10;
    if (v10)
    {
      CFTypeID v12 = CFGetTypeID(v10);
      if (v12 == CFNumberGetTypeID()) {
        CFNumberGetValue(v11, kCFNumberSInt32Type, &v82);
      }
    }
    CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v78);
    CFNumberRef v14 = v13;
    if (v13)
    {
      CFTypeID v15 = CFGetTypeID(v13);
      if (v15 == CFNumberGetTypeID()) {
        CFNumberGetValue(v14, kCFNumberSInt32Type, (char *)&v82 + 4);
      }
    }
    int v92 = 0;
    CFNumberRef v16 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v77);
    CFNumberRef v17 = v16;
    if (v16 && (CFTypeID v18 = CFGetTypeID(v16), v18 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v17, kCFNumberSInt32Type, &v92);
      int v19 = v92;
    }
    else
    {
      int v19 = 0;
    }
    v81[3] = v19;
    CFNumberRef v20 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, key);
    CFNumberRef v21 = v20;
    if (v20)
    {
      CFTypeID v22 = CFGetTypeID(v20);
      if (v22 == CFNumberGetTypeID()) {
        CFNumberGetValue(v21, kCFNumberSInt64Type, &v84);
      }
    }
    CFNumberRef v23 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v75);
    CFNumberRef v24 = v23;
    if (v23)
    {
      CFTypeID v25 = CFGetTypeID(v23);
      if (v25 == CFNumberGetTypeID()) {
        CFNumberGetValue(v24, kCFNumberSInt32Type, &v83);
      }
    }
    CFDictionaryRef v26 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, v74);
    CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue(v26, v73);
    CFNumberRef v28 = v27;
    if (v27)
    {
      CFTypeID v29 = CFGetTypeID(v27);
      if (v29 == CFNumberGetTypeID()) {
        CFNumberGetValue(v28, kCFNumberSInt32Type, &v89);
      }
    }
    CFNumberRef v30 = (const __CFNumber *)CFDictionaryGetValue(v26, v72);
    CFNumberRef v31 = v30;
    if (v30)
    {
      CFTypeID v32 = CFGetTypeID(v30);
      if (v32 == CFNumberGetTypeID()) {
        CFNumberGetValue(v31, kCFNumberSInt32Type, (char *)&v89 + 4);
      }
    }
    CFNumberRef v33 = (const __CFNumber *)CFDictionaryGetValue(v26, v71);
    CFNumberRef v34 = v33;
    if (v33)
    {
      CFTypeID v35 = CFGetTypeID(v33);
      if (v35 == CFNumberGetTypeID()) {
        CFNumberGetValue(v34, kCFNumberSInt32Type, &v90);
      }
    }
    CFNumberRef v36 = (const __CFNumber *)CFDictionaryGetValue(v26, v70);
    CFNumberRef v37 = v36;
    if (v36)
    {
      CFTypeID v38 = CFGetTypeID(v36);
      if (v38 == CFNumberGetTypeID()) {
        CFNumberGetValue(v37, kCFNumberSInt32Type, (char *)&v90 + 4);
      }
    }
    CFNumberRef v39 = (const __CFNumber *)CFDictionaryGetValue(v26, v69);
    CFNumberRef v40 = v39;
    if (v39)
    {
      CFTypeID v41 = CFGetTypeID(v39);
      if (v41 == CFNumberGetTypeID()) {
        CFNumberGetValue(v40, kCFNumberSInt32Type, &v91);
      }
    }
    CFDictionaryRef v42 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, v68);
    CFNumberRef v43 = (const __CFNumber *)CFDictionaryGetValue(v42, v5);
    CFNumberRef v44 = v43;
    if (v43)
    {
      CFTypeID v45 = CFGetTypeID(v43);
      if (v45 == CFNumberGetTypeID()) {
        CFNumberGetValue(v44, kCFNumberSInt16Type, &v85);
      }
    }
    CFNumberRef v46 = (const __CFNumber *)CFDictionaryGetValue(v42, v6);
    CFNumberRef v47 = v46;
    if (v46)
    {
      CFTypeID v48 = CFGetTypeID(v46);
      if (v48 == CFNumberGetTypeID()) {
        CFNumberGetValue(v47, kCFNumberSInt16Type, &v87);
      }
    }
    if (CFDictionaryContainsKey(v42, v7))
    {
      CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue(v42, v7);
      CFNumberRef v50 = v49;
      if (!v49) {
        goto LABEL_47;
      }
    }
    else
    {
      CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue(v42, v66);
      CFNumberRef v50 = v49;
      if (!v49) {
        goto LABEL_47;
      }
    }
    CFTypeID v51 = CFGetTypeID(v49);
    if (v51 == CFNumberGetTypeID()) {
      CFNumberGetValue(v50, kCFNumberSInt32Type, &v80);
    }
LABEL_47:
    CFDictionaryRef v52 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, v67);
    CFNumberRef v53 = (const __CFNumber *)CFDictionaryGetValue(v52, v5);
    CFNumberRef v54 = v53;
    if (v53)
    {
      CFTypeID v55 = CFGetTypeID(v53);
      if (v55 == CFNumberGetTypeID()) {
        CFNumberGetValue(v54, kCFNumberSInt16Type, &v86);
      }
    }
    CFNumberRef v56 = (const __CFNumber *)CFDictionaryGetValue(v52, v6);
    CFNumberRef v57 = v56;
    if (v56)
    {
      CFTypeID v58 = CFGetTypeID(v56);
      if (v58 == CFNumberGetTypeID()) {
        CFNumberGetValue(v57, kCFNumberSInt16Type, &v88);
      }
    }
    if (CFDictionaryContainsKey(v52, v7))
    {
      CFNumberRef v59 = (const __CFNumber *)CFDictionaryGetValue(v52, v7);
      CFNumberRef v60 = v59;
      if (v59) {
        goto LABEL_57;
      }
    }
    else
    {
      CFNumberRef v59 = (const __CFNumber *)CFDictionaryGetValue(v52, v66);
      CFNumberRef v60 = v59;
      if (v59)
      {
LABEL_57:
        CFTypeID v61 = CFGetTypeID(v59);
        if (v61 == CFNumberGetTypeID()) {
          CFNumberGetValue(v60, kCFNumberSInt32Type, v81);
        }
      }
    }
    sub_1BBA7E8E8((uint64_t)a1, v80);
    if (*a1 == 1752589105) {
      int v62 = 1752589105;
    }
    else {
      int v62 = 1635148593;
    }
    unsigned int v63 = a1[3];
    unsigned int v64 = a1[4];
    v93[0] = &off_1F14ED6B8;
    v93[1] = a1;
    v93[3] = v93;
    sub_1BBA78EE8(&v80, v62, (uint64_t)(a1 + 5), (uint64_t)(a1 + 7), (uint64_t)(a1 + 9), v63, v64, (uint64_t)v93, a1[1], v85, v87, v86, v88);
    sub_1BBA7944C(v93);
LABEL_63:
    ++v4;
  }
  return 0;
}

void sub_1BB9DAFD0(_Unwind_Exception *a1)
{
  sub_1BBA7944C((void *)(v1 - 128));
  _Unwind_Resume(a1);
}

uint64_t VCPAVEExtraInloopChromaFilter(int a1, CFDictionaryRef theDict, int a3, int a4)
{
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F44E18]);
  CFIndex v7 = 0;
  int v8 = (const void *)*MEMORY[0x1E4F44E40];
  while (CFArrayGetCount(Value) > v7)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v7);
    CFNumberRef v10 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v8);
    if (v10)
    {
      CFNumberRef v11 = v10;
      CFTypeID v12 = CFGetTypeID(v10);
      if (v12 == CFNumberGetTypeID()) {
        CFNumberGetValue(v11, kCFNumberSInt32Type, v40);
      }
    }
    if (v40[0] == a3)
    {
      CFDictionaryRef v13 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F44E50]);
      CFNumberRef v14 = (const void *)*MEMORY[0x1E4F44E30];
      if (CFDictionaryContainsKey(v13, (const void *)*MEMORY[0x1E4F44E30]))
      {
        CFDictionaryRef v15 = v13;
        CFNumberRef v16 = v14;
      }
      else
      {
        CFNumberRef v16 = (const void *)*MEMORY[0x1E4F44E28];
        CFDictionaryRef v15 = v13;
      }
      CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(v15, v16);
      if (v17)
      {
        CFNumberRef v18 = v17;
        CFTypeID v19 = CFGetTypeID(v17);
        if (v19 == CFNumberGetTypeID()) {
          CFNumberGetValue(v18, kCFNumberSInt32Type, valuePtr);
        }
      }
      CFTypeRef cf = 0;
      CFNumberRef v37 = IOSurfaceLookup(valuePtr[0]);
      CVPixelBufferCreateWithIOSurface(0, v37, 0, (CVPixelBufferRef *)&cf);
      CFNumberRef v20 = (__CVBuffer *)cf;
      int Width = CVPixelBufferGetWidth((CVPixelBufferRef)cf);
      int Height = CVPixelBufferGetHeight(v20);
      size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v20, 1uLL);
      if (a4 >= 51) {
        int v23 = 51;
      }
      else {
        int v23 = a4;
      }
      if (v23 <= 15) {
        int v23 = 15;
      }
      int v24 = v23 - 15;
      unsigned __int8 v25 = byte_1BBB83515[v24];
      int v26 = byte_1BBB83546[v24];
      CVPixelBufferLockBaseAddress(v20, 0);
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(v20, 1uLL);
      if (v26)
      {
        pixelBuffer = v20;
        if (Width >= 2)
        {
          uint64_t v27 = 0;
          int v34 = Height >> 1;
          uint64_t v28 = Width >> 1;
          CFTypeID v29 = &BaseAddressOfPlane[4 * BytesPerRowOfPlane];
          do
          {
            if ((v27 | 4) < v28) {
              sub_1BBA47A68(&BaseAddressOfPlane[2 * (v27 | 4)], BytesPerRowOfPlane, v25, v26, v34);
            }
            v27 += 8;
            if (v27 < v28) {
              sub_1BBA47A68(&BaseAddressOfPlane[2 * v27], BytesPerRowOfPlane, v25, v26, v34);
            }
            if (Height >= 10)
            {
              CFNumberRef v30 = v29;
              uint64_t v31 = 4;
              do
              {
                sub_1BBA47528(v30, BytesPerRowOfPlane, v25, v26, 8);
                v31 += 4;
                v30 += 4 * BytesPerRowOfPlane;
              }
              while (v31 < v34);
            }
            v29 += 16;
          }
          while (v27 < v28);
        }
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
      }
      sub_1BBA7ECB0((const void **)&v37);
      sub_1BB9C14A0(&cf);
      return 0;
    }
    ++v7;
  }
  return 0;
}

void sub_1BB9DB2E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1BB9C14A0((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t VCPAVECalculateFrameChecksum(_DWORD *a1, CFDictionaryRef theDict, int a3, int a4, __CFDictionary *a5)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F44E18]);
    CFIndex v9 = 0;
    CFNumberRef v10 = (const void *)*MEMORY[0x1E4F44E40];
    while (1)
    {
      if (CFArrayGetCount(Value) <= v9) {
        return 0;
      }
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v9);
      CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v10);
      CFNumberRef v13 = v12;
      if (v12)
      {
        CFTypeID v14 = CFGetTypeID(v12);
        if (v14 == CFNumberGetTypeID()) {
          CFNumberGetValue(v13, kCFNumberSInt32Type, v28);
        }
      }
      if (v28[0] == a3) {
        break;
      }
      ++v9;
    }
    CFDictionaryRef v15 = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F44E50]);
    CFNumberRef v16 = (const void *)*MEMORY[0x1E4F44E30];
    if (CFDictionaryContainsKey(v15, (const void *)*MEMORY[0x1E4F44E30]))
    {
      CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(v15, v16);
      CFNumberRef v18 = v17;
      if (v17)
      {
LABEL_13:
        CFTypeID v19 = CFGetTypeID(v17);
        if (v19 == CFNumberGetTypeID()) {
          CFNumberGetValue(v18, kCFNumberSInt32Type, valuePtr);
        }
      }
    }
    else
    {
      CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(v15, (const void *)*MEMORY[0x1E4F44E28]);
      CFNumberRef v18 = v17;
      if (v17) {
        goto LABEL_13;
      }
    }
    CFTypeRef cf = 0;
    unsigned __int8 v25 = IOSurfaceLookup(valuePtr[0]);
    CVPixelBufferCreateWithIOSurface(0, v25, 0, (CVPixelBufferRef *)&cf);
    sub_1BBA7E8E8((uint64_t)a1, valuePtr[0]);
    unsigned __int16 v24 = 0;
    char v20 = a1[11];
    int v21 = a1[2];
    v32[0] = a1[1];
    v32[1] = 2 * (v32[0] >> v20);
    v31[0] = v21;
    v31[1] = v21 >> v20;
    sub_1BBA704C4(valuePtr[0], &v24, (uint64_t)v32, (uint64_t)v31, (uint64_t)(a1 + 5), a1[3], a1[4]);
    int v29 = v24;
    CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &v29);
    CFNumberRef v30 = v22;
    if (v22) {
      CFDictionaryAddValue(a5, (const void *)*MEMORY[0x1E4F45398], v22);
    }
    sub_1BB9BE1F4((const void **)&v30);
    sub_1BBA7ECB0((const void **)&v25);
    sub_1BB9C14A0(&cf);
  }
  return 0;
}

void sub_1BB9DB59C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  std::exception_ptr v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  std::exception_ptr v5 = va_arg(va2, const void *);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  sub_1BB9BE1F4((const void **)va2);
  sub_1BBA7ECB0((const void **)va);
  sub_1BB9C14A0((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9DB5DC(uint64_t a1, CFDictionaryRef theDict, int a3, uint64_t a4)
{
  if (!theDict) {
    return 4294954394;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"DirtyRegionArray");
  CFArrayRef v8 = Value;
  if (!Value) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(Value);
  if (Count < 1) {
    return 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  unint64_t v12 = 0;
  CFIndex v13 = 0;
  for (i = 0; i < Count; CFIndex v13 = ++i)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v13);
    if (!ValueAtIndex || !CGRectMakeWithDictionaryRepresentation(ValueAtIndex, &v35))
    {
      uint64_t v33 = 4294954394;
      if (!v10) {
        return v33;
      }
      goto LABEL_44;
    }
    if ((unint64_t)v11 >= v12)
    {
      uint64_t v17 = ((char *)v11 - (char *)v10) >> 5;
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 59) {
        sub_1BB9C185C();
      }
      if ((uint64_t)(v12 - (void)v10) >> 4 > v18) {
        unint64_t v18 = (uint64_t)(v12 - (void)v10) >> 4;
      }
      if (v12 - (unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v19 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v18;
      }
      if (v19) {
        unint64_t v19 = (unint64_t)sub_1BB9C92F4(v19);
      }
      else {
        uint64_t v20 = 0;
      }
      CGSize size = v35.size;
      unint64_t v22 = v19 + 32 * v17;
      *(CGPoint *)unint64_t v22 = v35.origin;
      *(CGSize *)(v22 + 16) = size;
      if (v11 == v10)
      {
        unsigned __int8 v25 = (CGSize *)(v19 + 32 * v17);
      }
      else
      {
        unint64_t v23 = v19 + 32 * v17;
        do
        {
          CGSize v24 = v11[-1];
          unsigned __int8 v25 = (CGSize *)(v23 - 32);
          *(CGSize *)(v23 - 32) = v11[-2];
          *(CGSize *)(v23 - 16) = v24;
          v11 -= 2;
          v23 -= 32;
        }
        while (v11 != v10);
      }
      unint64_t v12 = v19 + 32 * v20;
      uint64_t v11 = (CGSize *)(v22 + 32);
      if (v10) {
        operator delete(v10);
      }
      uint64_t v10 = v25;
    }
    else
    {
      CGSize v16 = v35.size;
      *uint64_t v11 = (CGSize)v35.origin;
      v11[1] = v16;
      v11 += 2;
    }
  }
  if (v11 != v10 && *(int *)(a1 + 72) >= 1)
  {
    uint64_t v26 = 0;
    do
    {
      int v27 = *(_DWORD *)(a1 + 64);
      int v28 = v27 * v26;
      if (a3 - v27 * (int)v26 < v27) {
        int v27 = a3 - v27 * v26;
      }
      int v29 = v27 + v28;
      CFNumberRef v30 = v10;
      while (1)
      {
        double height = v30->height;
        if (v29 >= (int)height && v28 <= (int)(height + v30[1].height)) {
          break;
        }
        v30 += 2;
        if (v30 == v11)
        {
          char v32 = 0;
          goto LABEL_38;
        }
      }
      char v32 = 1;
LABEL_38:
      *(unsigned char *)(a4 + v26++) = v32;
    }
    while (v26 < *(int *)(a1 + 72));
  }
  uint64_t v33 = 0;
  if (v10) {
LABEL_44:
  }
    operator delete(v10);
  return v33;
}

void sub_1BB9DB810(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1BB9DB82C(const void **result, __CFDictionary *a2)
{
  if (result && a2)
  {
    CFDictionaryRef v3 = CVBufferCopyAttachments((CVBufferRef)result, kCVAttachmentMode_ShouldPropagate);
    CFDictionaryRef theDict = v3;
    if (v3 && CFDictionaryContainsKey(v3, @"PropagatableAttachments"))
    {
      CFArrayRef Value = CFDictionaryGetValue(theDict, @"PropagatableAttachments");
      if (Value)
      {
        CFDictionaryAddValue(a2, @"PropagatableAttachments", Value);
      }
      else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::exception_ptr v5 = 0;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc: PropagatableAttachments exist but NULL - no SEI created\n", v5, 2u);
      }
    }
    return sub_1BB9BE1C0((const void **)&theDict);
  }
  return result;
}

void sub_1BB9DB8F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9BE1C0((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9DB908(uint64_t a1, uint64_t a2, __CVBuffer *a3)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v6 = (VTSessionRef *)(a1 + 2320);
  if (*(void *)(a1 + 2320)
    || (uint64_t v10 = VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)v6), !v10))
  {
    PixelBufferPool = VTCompressionSessionGetPixelBufferPool(*(VTCompressionSessionRef *)(a1 + 16));
    CFArrayRef v8 = (CVPixelBufferRef *)(a2 + 224);
    if (CVPixelBufferPoolCreatePixelBuffer(0, PixelBufferPool, (CVPixelBufferRef *)(a2 + 224)))
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        return 4294954394;
      }
      int v44 = *(_DWORD *)(a1 + 60);
      int v43 = *(_DWORD *)(a1 + 64);
      int v45 = *(_DWORD *)(a1 + 24);
      CFNumberRef v46 = "H.264";
      if (v45 > 1718908519)
      {
        if (v45 == 1752589105) {
          goto LABEL_45;
        }
        int v47 = 1718908520;
      }
      else
      {
        if (v45 == 1684632424) {
          goto LABEL_45;
        }
        int v47 = 1685481521;
      }
      if (v45 != v47)
      {
LABEL_46:
        int v49 = 134218754;
        uint64_t v50 = a1;
        __int16 v51 = 1024;
        int v52 = v44;
        __int16 v53 = 1024;
        int v54 = v43;
        __int16 v55 = 2080;
        CFNumberRef v56 = v46;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPEnc %p (%dx%d, %s): Encoder failed to create copied_image_buffer_\n", (uint8_t *)&v49, 0x22u);
        return 4294954394;
      }
LABEL_45:
      CFNumberRef v46 = "HEVC";
      goto LABEL_46;
    }
    int Width = CVPixelBufferGetWidth(a3);
    int Height = CVPixelBufferGetHeight(a3);
    if (*(int *)(a2 + 160) <= 0) {
      int v18 = Width;
    }
    else {
      int v18 = *(_DWORD *)(a2 + 160);
    }
    if (*(int *)(a2 + 164) <= 0) {
      int v19 = Height;
    }
    else {
      int v19 = *(_DWORD *)(a2 + 164);
    }
    double v20 = (double)v18;
    double v21 = (double)v19;
    BOOL v22 = v18 <= Width && v19 <= Height;
    float v23 = (float)v18;
    double v24 = (double)v18;
    double v25 = (double)v19;
    if (!v22)
    {
      float v26 = (float)Width;
      float v27 = (float)Width / v23;
      float v28 = (float)Height / (float)v19;
      if (v27 >= v28) {
        float v26 = v28 * v23;
      }
      double v24 = v26;
      float v29 = v27 * (float)v19;
      if (v27 >= v28) {
        float v29 = (float)Height;
      }
      double v25 = v29;
    }
    int v30 = CVPixelBufferGetWidth(*v8);
    int v31 = CVPixelBufferGetHeight(*v8);
    if (v18 > v30 || v19 > v31)
    {
      float v32 = (float)v30;
      float v33 = (float)v30 / v23;
      float v34 = (float)v31 / (float)v19;
      if (v33 >= v34) {
        float v32 = v34 * v23;
      }
      double v20 = v32;
      float v35 = v33 * (float)v19;
      if (v33 >= v34) {
        float v35 = (float)v31;
      }
      double v21 = v35;
    }
    v58.origin.x = 0.0;
    v58.origin.y = 0.0;
    v58.size.width = v24;
    v58.size.double height = v25;
    CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v58);
    uint64_t v9 = VTSessionSetProperty(*v6, (CFStringRef)*MEMORY[0x1E4F45170], DictionaryRepresentation);
    if (v9) {
      return v9;
    }
    CFRelease(DictionaryRepresentation);
    v59.origin.x = 0.0;
    v59.origin.y = 0.0;
    v59.size.width = v20;
    v59.size.double height = v21;
    CFDictionaryRef v37 = CGRectCreateDictionaryRepresentation(v59);
    uint64_t v9 = VTSessionSetProperty(*v6, (CFStringRef)*MEMORY[0x1E4F450F0], v37);
    if (v9) {
      return v9;
    }
    CFRelease(v37);
    if (!VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)*v6, a3, *v8)) {
      return 0;
    }
    CVPixelBufferRelease(*v8);
    CVPixelBufferRef *v8 = 0;
    uint64_t v9 = 0;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      return v9;
    }
    int v39 = *(_DWORD *)(a1 + 60);
    int v38 = *(_DWORD *)(a1 + 64);
    int v40 = *(_DWORD *)(a1 + 24);
    CFTypeID v41 = "H.264";
    if (v40 > 1718908519)
    {
      if (v40 == 1752589105) {
        goto LABEL_55;
      }
      int v42 = 1718908520;
    }
    else
    {
      if (v40 == 1684632424) {
        goto LABEL_55;
      }
      int v42 = 1685481521;
    }
    if (v40 != v42)
    {
LABEL_56:
      int v49 = 134218754;
      uint64_t v50 = a1;
      __int16 v51 = 1024;
      int v52 = v39;
      __int16 v53 = 1024;
      int v54 = v38;
      __int16 v55 = 2080;
      CFNumberRef v56 = v41;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder failed to copy input source to copied_image_buffer_\n", (uint8_t *)&v49, 0x22u);
      return 0;
    }
LABEL_55:
    CFTypeID v41 = "HEVC";
    goto LABEL_56;
  }
  uint64_t v9 = v10;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    int v12 = *(_DWORD *)(a1 + 60);
    int v11 = *(_DWORD *)(a1 + 64);
    int v13 = *(_DWORD *)(a1 + 24);
    uint64_t v14 = "H.264";
    if (v13 > 1718908519)
    {
      if (v13 == 1752589105) {
        goto LABEL_50;
      }
      int v15 = 1718908520;
    }
    else
    {
      if (v13 == 1684632424) {
        goto LABEL_50;
      }
      int v15 = 1685481521;
    }
    if (v13 != v15)
    {
LABEL_51:
      int v49 = 134218754;
      uint64_t v50 = a1;
      __int16 v51 = 1024;
      int v52 = v12;
      __int16 v53 = 1024;
      int v54 = v11;
      __int16 v55 = 2080;
      CFNumberRef v56 = v14;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPEnc %p (%dx%d, %s): Failed to create buffer_copy_session\n", (uint8_t *)&v49, 0x22u);
      return v9;
    }
LABEL_50:
    uint64_t v14 = "HEVC";
    goto LABEL_51;
  }
  return v9;
}

uint64_t VCPCompressionSessionEncodeFrame(uint64_t a1, __CVBuffer *a2, CMTime *a3, uint64_t a4, const __CFDictionary *a5, uint64_t a6, VTEncodeInfoFlags *a7)
{
  uint64_t v282 = *MEMORY[0x1E4F143B8];
  CFArrayRef v8 = *(std::mutex **)(a1 + 2152);
  if (v8)
  {
    int v243 = v8;
    std::mutex::lock(v8);
    if (*(unsigned char *)(a1 + 2160))
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
LABEL_28:
        uint64_t v33 = 4294954393;
LABEL_340:
        std::mutex::unlock(v243);
        return v33;
      }
      int v12 = *(_DWORD *)(a1 + 60);
      int v11 = *(_DWORD *)(a1 + 64);
      int v13 = *(_DWORD *)(a1 + 24);
      uint64_t v14 = "H.264";
      if (v13 > 1718908519)
      {
        if (v13 == 1752589105) {
          goto LABEL_26;
        }
        int v15 = 1718908520;
      }
      else
      {
        if (v13 == 1684632424) {
          goto LABEL_26;
        }
        int v15 = 1685481521;
      }
      if (v13 != v15)
      {
LABEL_27:
        *(_DWORD *)propertyValueOut = 134218754;
        *(void *)&propertyValueOut[4] = a1;
        *(_WORD *)&propertyValueOut[12] = 1024;
        *(_DWORD *)&propertyValueOut[14] = v12;
        *(_WORD *)&propertyValueOut[18] = 1024;
        *(_DWORD *)&propertyValueOut[20] = v11;
        *(_WORD *)&propertyValueOut[24] = 2080;
        *(void *)&propertyValueOut[26] = v14;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Video compression session invalidated already!\n", propertyValueOut, 0x22u);
        goto LABEL_28;
      }
LABEL_26:
      uint64_t v14 = "HEVC";
      goto LABEL_27;
    }
    infoFlagsOut = a7;
    if (*(void *)(a1 + 2312) && *(int *)(a1 + 72) >= 1)
    {
      int v21 = 0;
      do
      {
        sub_1BBAC8868(*(void *)(a1 + 2312), (uint64_t *)"input_frames", 1.0);
        ++v21;
      }
      while (v21 < *(_DWORD *)(a1 + 72));
    }
    BOOL v22 = a3;
    CMTimeScale v23 = *(_DWORD *)(a4 + 8);
    int32_t timescale = a3->timescale;
    if (v23 != timescale)
    {
      CMTime time = *(CMTime *)a4;
      CMTimeConvertScale((CMTime *)propertyValueOut, &time, timescale, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      *(_OWORD *)a4 = *(_OWORD *)propertyValueOut;
      *(void *)(a4 + 16) = *(void *)&propertyValueOut[16];
      BOOL v22 = a3;
      CMTimeScale v23 = a3->timescale;
    }
    CFDictionaryRef theDict = a5;
    CMTimeValue v25 = v22->value;
    p_flags = &v22->flags;
    uint64_t v274 = *(void *)&v22->flags;
    CMTimeFlags epoch_high = HIDWORD(v22->epoch);
    if (v23 <= 999)
    {
      v281.value = v25;
      *(void *)&v281.flags = *(void *)p_flags;
      int v27 = HIDWORD(v22->epoch);
      v281.int32_t timescale = v23;
      HIDWORD(v281.epoch) = v27;
      CMTimeConvertScale((CMTime *)propertyValueOut, &v281, 1000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      CMTimeValue v25 = *(void *)propertyValueOut;
      uint64_t v274 = *(void *)&propertyValueOut[12];
      CMTimeScale v23 = *(_DWORD *)&propertyValueOut[8];
      CMTimeFlags epoch_high = *(_DWORD *)&propertyValueOut[20];
    }
    a3->value = v25;
    a3->int32_t timescale = v23;
    *(void *)p_flags = v274;
    p_flags[2] = epoch_high;
    CMTimeValue v28 = *(void *)a4;
    CMTimeScale v29 = *(_DWORD *)(a4 + 8);
    uint64_t v30 = a4 + 12;
    uint64_t v272 = *(void *)(a4 + 12);
    int v273 = *(_DWORD *)(a4 + 20);
    if (v29 <= 999)
    {
      v281.value = v28;
      *(void *)&v281.flags = *(void *)v30;
      int v31 = *(_DWORD *)(a4 + 20);
      v281.int32_t timescale = v29;
      HIDWORD(v281.epoch) = v31;
      CMTimeConvertScale((CMTime *)propertyValueOut, &v281, 1000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      CMTimeValue v28 = *(void *)propertyValueOut;
      uint64_t v272 = *(void *)&propertyValueOut[12];
      CMTimeScale v29 = *(_DWORD *)&propertyValueOut[8];
      int v273 = *(_DWORD *)&propertyValueOut[20];
      uint64_t v30 = a4 + 12;
    }
    *(void *)a4 = v28;
    *(_DWORD *)(a4 + 8) = v29;
    *(void *)uint64_t v30 = v272;
    *(_DWORD *)(v30 + 8) = v273;
    IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(a2);
    if (IOSurface) {
      IOSurfaceGetID(IOSurface);
    }
    *(_OWORD *)propertyValueOut = *(_OWORD *)&a3->value;
    *(void *)&propertyValueOut[16] = a3->epoch;
    CMTimeGetSeconds((CMTime *)propertyValueOut);
    int v253 = *(_DWORD *)(a1 + 72);
    uint64_t valuePtr = 0;
    int v262 = 0;
    uint64_t v261 = 0;
    if (a5) {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a5);
    }
    else {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    CFDictionaryRef v35 = MutableCopy;
    kdebug_trace();
    CFDictionaryRef v245 = v35;
    BOOL v36 = *(_DWORD *)(a1 + 68) != 43;
    if (*(unsigned char *)(a1 + 53)) {
      BOOL v37 = *(_DWORD *)(a1 + 68) != 43;
    }
    else {
      BOOL v37 = 0;
    }
    *(unsigned char *)(a1 + 53) = v37;
    if (!*(unsigned char *)(a1 + 52)) {
      BOOL v36 = 0;
    }
    *(unsigned char *)(a1 + 52) = v36;
    if (*(unsigned __int16 *)(a1 + 50) - 1 > 1 || !v37)
    {
LABEL_66:
      if (theDict
        && (CFArrayRef v49 = (const __CFArray *)CFDictionaryGetValue(theDict, @"RegionOfInterestArray"), (v50 = v49) != 0)
        && (CFIndex Count = CFArrayGetCount(v49), Count >= 1))
      {
        __p = 0;
        int v52 = 0;
        unint64_t v53 = 0;
        CFIndex v54 = 0;
        unsigned int v55 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v50, v54);
          if (!ValueAtIndex || !CGRectMakeWithDictionaryRepresentation(ValueAtIndex, (CGRect *)propertyValueOut)) {
            break;
          }
          if ((unint64_t)v52 >= v53)
          {
            uint64_t v58 = (v52 - __p) >> 5;
            unint64_t v59 = v58 + 1;
            if ((unint64_t)(v58 + 1) >> 59) {
              sub_1BB9C185C();
            }
            if ((uint64_t)(v53 - (void)__p) >> 4 > v59) {
              unint64_t v59 = (uint64_t)(v53 - (void)__p) >> 4;
            }
            if (v53 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v60 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v60 = v59;
            }
            if (v60) {
              unint64_t v60 = (unint64_t)sub_1BB9C92F4(v60);
            }
            else {
              uint64_t v61 = 0;
            }
            long long v62 = *(_OWORD *)&propertyValueOut[16];
            unsigned int v63 = (_OWORD *)(v60 + 32 * v58);
            _OWORD *v63 = *(_OWORD *)propertyValueOut;
            v63[1] = v62;
            if (v52 == __p)
            {
              char v67 = (char *)(v60 + 32 * v58);
              CFTypeID v65 = __p;
            }
            else
            {
              unint64_t v64 = v60 + 32 * v58;
              CFTypeID v65 = __p;
              do
              {
                long long v66 = *((_OWORD *)v52 - 1);
                char v67 = (char *)(v64 - 32);
                *(_OWORD *)(v64 - 32) = *((_OWORD *)v52 - 2);
                *(_OWORD *)(v64 - 16) = v66;
                v52 -= 32;
                v64 -= 32;
              }
              while (v52 != __p);
            }
            unint64_t v53 = v60 + 32 * v61;
            int v52 = (char *)(v63 + 2);
            if (v65) {
              operator delete(v65);
            }
            __p = v67;
          }
          else
          {
            long long v57 = *(_OWORD *)&propertyValueOut[16];
            *(_OWORD *)int v52 = *(_OWORD *)propertyValueOut;
            *((_OWORD *)v52 + 1) = v57;
            v52 += 32;
          }
          CFIndex v54 = ++v55;
          if (Count <= v55) {
            goto LABEL_94;
          }
        }
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)propertyValueOut = 0;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to get ROI metadata\n", propertyValueOut, 2u);
        }
      }
      else
      {
        __p = 0;
      }
LABEL_94:
      if (*(void *)(a1 + 2192)) {
        goto LABEL_105;
      }
      uint64_t v68 = 0;
      int v69 = *(_DWORD *)(a1 + 24);
      if (v69 > 1718908519)
      {
        if (v69 != 1718908520)
        {
          int v70 = 1752589105;
LABEL_100:
          if (v69 != v70) {
            uint64_t v68 = 1;
          }
        }
      }
      else if (v69 != 1684632424)
      {
        int v70 = 1685481521;
        goto LABEL_100;
      }
      BOOL v71 = sub_1BBAB06D8(*(char **)(a1 + 120), 1, *(unsigned int *)(a1 + 68), v68);
      *(void *)(a1 + 2192) = v71;
      if ((*(unsigned int (**)(void *))(*v71 + 128))(v71) && !*(_DWORD *)(a1 + 2344)) {
        VCPCompressionSessionSetProperty(a1, @"RemoteMLScale", (const __CFString *)*MEMORY[0x1E4F1CFD0]);
      }
LABEL_105:
      if (!*(unsigned char *)(a1 + 104) || CVPixelBufferGetPixelFormatType(a2) != 1111970369)
      {
        uint64_t v33 = 0;
        goto LABEL_114;
      }
      v281.value = (CMTimeValue)CVBufferCopyAttachment(a2, (CFStringRef)*MEMORY[0x1E4F24A90], 0);
      values = (void *)CVBufferCopyAttachment(a2, (CFStringRef)*MEMORY[0x1E4F24BC8], 0);
      if (!v281.value
        || CFStringCompare((CFStringRef)v281.value, (CFStringRef)*MEMORY[0x1E4F24AC0], 0)
        || !values
        || CFStringCompare((CFStringRef)values, (CFStringRef)*MEMORY[0x1E4F24BE0], 0))
      {
        goto LABEL_109;
      }
      CFStringRef StringForIntegerCodePoint = CVColorPrimariesGetStringForIntegerCodePoint(12);
      if (VCPCompressionSessionSetProperty(a1, (const __CFString *)*MEMORY[0x1E4F44868], StringForIntegerCodePoint))
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          int v83 = *(_DWORD *)(a1 + 60);
          int v82 = *(_DWORD *)(a1 + 64);
          int v84 = *(_DWORD *)(a1 + 24);
          unsigned __int16 v85 = "H.264";
          if (v84 > 1718908519)
          {
            if (v84 == 1752589105) {
              goto LABEL_376;
            }
            int v86 = 1718908520;
          }
          else
          {
            if (v84 == 1684632424) {
              goto LABEL_376;
            }
            int v86 = 1685481521;
          }
          if (v84 != v86)
          {
LABEL_377:
            *(_DWORD *)propertyValueOut = 134218754;
            *(void *)&propertyValueOut[4] = a1;
            *(_WORD *)&propertyValueOut[12] = 1024;
            *(_DWORD *)&propertyValueOut[14] = v83;
            *(_WORD *)&propertyValueOut[18] = 1024;
            *(_DWORD *)&propertyValueOut[20] = v82;
            *(_WORD *)&propertyValueOut[24] = 2080;
            *(void *)&propertyValueOut[26] = v85;
            int16x8_t v216 = MEMORY[0x1E4F14500];
            int16x8_t v217 = "VCPEnc %p (%dx%d, %s): Failed to set ColorPrimaries as SMPTE_EG_432_1!\n";
LABEL_393:
            _os_log_error_impl(&dword_1BB9B9000, v216, OS_LOG_TYPE_ERROR, v217, propertyValueOut, 0x22u);
            goto LABEL_394;
          }
LABEL_376:
          unsigned __int16 v85 = "HEVC";
          goto LABEL_377;
        }
LABEL_394:
        char v73 = 0;
        uint64_t v33 = 4294954394;
        int v72 = 7;
        goto LABEL_110;
      }
      CFStringRef v190 = CVTransferFunctionGetStringForIntegerCodePoint(1);
      if (VCPCompressionSessionSetProperty(a1, (const __CFString *)*MEMORY[0x1E4F44B58], v190))
      {
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          goto LABEL_394;
        }
        int v192 = *(_DWORD *)(a1 + 60);
        int v191 = *(_DWORD *)(a1 + 64);
        int v193 = *(_DWORD *)(a1 + 24);
        float v194 = "H.264";
        if (v193 > 1718908519)
        {
          if (v193 == 1752589105) {
            goto LABEL_386;
          }
          int v195 = 1718908520;
        }
        else
        {
          if (v193 == 1684632424) {
            goto LABEL_386;
          }
          int v195 = 1685481521;
        }
        if (v193 != v195)
        {
LABEL_387:
          *(_DWORD *)propertyValueOut = 134218754;
          *(void *)&propertyValueOut[4] = a1;
          *(_WORD *)&propertyValueOut[12] = 1024;
          *(_DWORD *)&propertyValueOut[14] = v192;
          *(_WORD *)&propertyValueOut[18] = 1024;
          *(_DWORD *)&propertyValueOut[20] = v191;
          *(_WORD *)&propertyValueOut[24] = 2080;
          *(void *)&propertyValueOut[26] = v194;
          int16x8_t v216 = MEMORY[0x1E4F14500];
          int16x8_t v217 = "VCPEnc %p (%dx%d, %s): Failed to set TransferFunction as BT_709!\n";
          goto LABEL_393;
        }
LABEL_386:
        float v194 = "HEVC";
        goto LABEL_387;
      }
      CFStringRef v205 = CVYCbCrMatrixGetStringForIntegerCodePoint(9);
      if (VCPCompressionSessionSetProperty(a1, (const __CFString *)*MEMORY[0x1E4F44BB0], v205))
      {
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          goto LABEL_394;
        }
        int v207 = *(_DWORD *)(a1 + 60);
        int v206 = *(_DWORD *)(a1 + 64);
        int v208 = *(_DWORD *)(a1 + 24);
        int v209 = "H.264";
        if (v208 > 1718908519)
        {
          if (v208 == 1752589105) {
            goto LABEL_391;
          }
          int v210 = 1718908520;
        }
        else
        {
          if (v208 == 1684632424) {
            goto LABEL_391;
          }
          int v210 = 1685481521;
        }
        if (v208 != v210)
        {
LABEL_392:
          *(_DWORD *)propertyValueOut = 134218754;
          *(void *)&propertyValueOut[4] = a1;
          *(_WORD *)&propertyValueOut[12] = 1024;
          *(_DWORD *)&propertyValueOut[14] = v207;
          *(_WORD *)&propertyValueOut[18] = 1024;
          *(_DWORD *)&propertyValueOut[20] = v206;
          *(_WORD *)&propertyValueOut[24] = 2080;
          *(void *)&propertyValueOut[26] = v209;
          int16x8_t v216 = MEMORY[0x1E4F14500];
          int16x8_t v217 = "VCPEnc %p (%dx%d, %s): Failed to set YCbCrMatrix as BT_2020_nonconstant!\n";
          goto LABEL_393;
        }
LABEL_391:
        int v209 = "HEVC";
        goto LABEL_392;
      }
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
LABEL_109:
        int v72 = 0;
        uint64_t v33 = 0;
        char v73 = 1;
LABEL_110:
        sub_1BB9BE158((const void **)&values);
        sub_1BB9BE158((const void **)&v281);
        if ((v73 & 1) == 0 && v72 == 7)
        {
LABEL_329:
          if (v253 >= 1) {
            operator new();
          }
          if (v245) {
            CFRelease(v245);
          }
          int16x8_t v201 = *(const void **)(a1 + 112);
          if (v201)
          {
            CFRelease(v201);
            *(void *)(a1 + 112) = 0;
          }
          if (*(int *)(a1 + 72) >= 2) {
            *(void *)(a1 + 112) = CVPixelBufferRetain(a2);
          }
          kdebug_trace();
          goto LABEL_338;
        }
LABEL_114:
        if (*(_WORD *)(a1 + 50) == 2)
        {
          if (v253 >= 1) {
            operator new();
          }
LABEL_338:
          if (__p) {
            operator delete(__p);
          }
          goto LABEL_340;
        }
        int v74 = *(std::mutex **)(a1 + 2336);
        if (v74)
        {
          *(void *)propertyValueOut = *(void *)(a1 + 2336);
          propertyValueOut[8] = 1;
          std::mutex::lock(v74);
          CFDictionaryRef v75 = v245;
          int v237 = *(_DWORD *)(a1 + 2332);
          *(_DWORD *)(a1 + 2332) = 0;
          sub_1BB9D9FD4((uint64_t)propertyValueOut);
          if (propertyValueOut[8]) {
            std::mutex::unlock(*(std::mutex **)propertyValueOut);
          }
LABEL_139:
          if (v75)
          {
            unsigned __int16 v87 = CFDictionaryGetValue(v75, (const void *)*MEMORY[0x1E4F44F40]);
            unsigned __int16 v88 = v87;
            BOOL v89 = v87 && CFGetTypeID(v87) && CFBooleanGetTypeID() && CFEqual(v88, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
            uint64_t v90 = CFDictionaryGetValue(v245, (const void *)*MEMORY[0x1E4F44ED8]);
            uint64_t v91 = v90;
            BOOL v92 = v90 && CFGetTypeID(v90) && CFBooleanGetTypeID() && CFEqual(v91, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
            double v93 = CFDictionaryGetValue(v245, (const void *)*MEMORY[0x1E4F44EE8]);
            double v94 = v93;
            BOOL v95 = v93 && CFGetTypeID(v93) && CFBooleanGetTypeID() && CFEqual(v94, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
            CFNumberRef v96 = (const __CFNumber *)CFDictionaryGetValue(v245, (const void *)*MEMORY[0x1E4F44EB0]);
            CFNumberRef v97 = v96;
            if (v96)
            {
              CFTypeID v98 = CFGetTypeID(v96);
              if (v98 == CFNumberGetTypeID()) {
                CFNumberGetValue(v97, kCFNumberSInt32Type, &valuePtr);
              }
            }
            int v99 = (const void *)*MEMORY[0x1E4F44F10];
            CFNumberRef v100 = (const __CFNumber *)CFDictionaryGetValue(v245, (const void *)*MEMORY[0x1E4F44F10]);
            CFNumberRef v101 = v100;
            if (v100)
            {
              CFTypeID v102 = CFGetTypeID(v100);
              if (v102 == CFNumberGetTypeID()) {
                CFNumberGetValue(v101, kCFNumberSInt32Type, (char *)&valuePtr + 4);
              }
            }
            CFNumberRef v103 = (const __CFNumber *)CFDictionaryGetValue(v245, (const void *)*MEMORY[0x1E4F44F28]);
            CFNumberRef v104 = v103;
            if (v103)
            {
              CFTypeID v105 = CFGetTypeID(v103);
              if (v105 == CFNumberGetTypeID()) {
                CFNumberGetValue(v104, kCFNumberSInt32Type, &v262);
              }
            }
            CFNumberRef v106 = (const __CFNumber *)CFDictionaryGetValue(v245, @"HIDTimeStamp");
            CFNumberRef v107 = v106;
            if (v106)
            {
              CFTypeID v108 = CFGetTypeID(v106);
              if (v108 == CFNumberGetTypeID()) {
                CFNumberGetValue(v107, kCFNumberSInt64Type, &v261);
              }
            }
            if (v237 >= 1)
            {
              *(_DWORD *)propertyValueOut = HIDWORD(valuePtr) + v237;
              CFNumberRef v109 = CFNumberCreate(0, kCFNumberSInt32Type, propertyValueOut);
              if (v109)
              {
                CFDictionarySetValue(v245, v99, v109);
                CFRelease(v109);
              }
            }
            double v110 = CFDictionaryGetValue(v245, (const void *)*MEMORY[0x1E4F44EC8]);
            if (v110)
            {
              CFTypeID TypeID = CFDataGetTypeID();
              if (TypeID == CFGetTypeID(v110))
              {
                BOOL v95 = 1;
                BOOL v92 = 0;
              }
            }
            CFArrayRef v112 = (const __CFArray *)CFDictionaryGetValue(v245, (const void *)*MEMORY[0x1E4F44DC0]);
            if (v112)
            {
              CFTypeID v113 = CFArrayGetTypeID();
              if (v113 == CFGetTypeID(v112))
              {
                BOOL v250 = v89;
                BOOL v235 = v95;
                int v114 = v33;
                unsigned int v115 = CFArrayGetCount(v112);
                if (v115 >= 0x10) {
                  uint64_t v116 = 16;
                }
                else {
                  uint64_t v116 = v115;
                }
                if (v116)
                {
                  for (CFIndex i = 0; i != v116; ++i)
                  {
                    LODWORD(v281.CFDictionaryAddValue(theDict, key, value) = 0;
                    CFNumberRef v118 = (const __CFNumber *)CFArrayGetValueAtIndex(v112, i);
                    CFNumberGetValue(v118, kCFNumberIntType, &v281);
                    int v119 = *(_DWORD *)(a1 + 72);
                    if (v119 >= 1)
                    {
                      for (int j = 0; j < v119; ++j)
                      {
                        uint64_t v121 = *(void *)(a1 + 2184);
                        if (v121)
                        {
                          int v122 = v281.value;
                          *(_DWORD *)propertyValueOut = j;
                          double v123 = sub_1BB9C8230((uint64_t **)(v121 + 184), j, propertyValueOut);
                          __int16 v124 = v123 + 5;
                          for (k = v123[6]; k != (uint64_t *)v124; k = (uint64_t *)k[1])
                          {
                            if (*((_DWORD *)k + 4) == v122)
                            {
                              if (k != (uint64_t *)v124) {
                                *((unsigned char *)v123 + 64) = 1;
                              }
                              break;
                            }
                          }
                          int v119 = *(_DWORD *)(a1 + 72);
                        }
                      }
                    }
                  }
                }
                LODWORD(v33) = v114;
                BOOL v95 = v235;
                BOOL v89 = v250;
              }
            }
          }
          else
          {
            BOOL v95 = 0;
            BOOL v92 = 0;
            BOOL v89 = 0;
          }
          unsigned __int8 v126 = *(unsigned char *)(a1 + 104) | v92;
          BOOL v236 = v95;
          if (v126 | v95) {
            BOOL v127 = 0;
          }
          else {
            BOOL v127 = v89;
          }
          BOOL v251 = v127;
          uint64_t v128 = *(void *)(a1 + 136);
          if (v128)
          {
LABEL_198:
            int v129 = sub_1BB9D00D0(v128, a2, 0);
            v281.value = 0;
            VTSessionCopySupportedPropertyDictionary(*(VTSessionRef *)(a1 + 16), (CFDictionaryRef *)&v281);
            if (!v281.value) {
              goto LABEL_215;
            }
            CFStringRef v130 = (const __CFString *)*MEMORY[0x1E4F449B8];
            if (!CFDictionaryContainsKey((CFDictionaryRef)v281.value, (const void *)*MEMORY[0x1E4F449B8])) {
              goto LABEL_215;
            }
            LODWORD(v270) = -1;
            *(void *)propertyValueOut = 0;
            CFAllocatorRef v131 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            VTSessionCopyProperty(*(VTSessionRef *)(a1 + 16), v130, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], propertyValueOut);
            if (*(void *)propertyValueOut) {
              CFNumberGetValue(*(CFNumberRef *)propertyValueOut, kCFNumberIntType, &v270);
            }
            sub_1BB9BE1F4((const void **)propertyValueOut);
            if (v129)
            {
              if ((int)v270 <= 39)
              {
                values = CFNumberCreate(v131, kCFNumberSInt32Type, &unk_1BBB77DB8);
                VCPCompressionSessionSetProperty(a1, v130, (const __CFString *)values);
                if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)propertyValueOut = 67109376;
                  *(_DWORD *)&propertyValueOut[4] = v270;
                  *(_WORD *)&propertyValueOut[8] = 1024;
                  *(_DWORD *)&propertyValueOut[10] = 40;
                  __int16 v132 = MEMORY[0x1E4F14500];
                  double v133 = "boosting maxAllowedQp %d -> %d\n";
LABEL_213:
                  _os_log_impl(&dword_1BB9B9000, v132, OS_LOG_TYPE_DEFAULT, v133, propertyValueOut, 0xEu);
                  goto LABEL_214;
                }
                goto LABEL_214;
              }
            }
            else if ((int)v270 >= 40)
            {
              values = CFNumberCreate(v131, kCFNumberSInt32Type, &unk_1BBB77DBC);
              VCPCompressionSessionSetProperty(a1, v130, (const __CFString *)values);
              if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)propertyValueOut = 67109376;
                *(_DWORD *)&propertyValueOut[4] = v270;
                *(_WORD *)&propertyValueOut[8] = 1024;
                *(_DWORD *)&propertyValueOut[10] = -1;
                __int16 v132 = MEMORY[0x1E4F14500];
                double v133 = "reset maxAllowedQp %d -> %d\n";
                goto LABEL_213;
              }
LABEL_214:
              sub_1BB9BE1F4((const void **)&values);
            }
LABEL_215:
            sub_1BB9BE1C0((const void **)&v281);
            goto LABEL_216;
          }
          int v134 = *(_DWORD *)(a1 + 68);
          if (v134 == 20 || v134 == 1)
          {
            double v135 = operator new(0x28uLL, MEMORY[0x1E4FBA2D0]);
            if (v135)
            {
              *double v135 = 0u;
              v135[1] = 0u;
              *((unsigned char *)v135 + 24) = 1;
              *((void *)v135 + 4) = 0;
              *(void *)(a1 + 136) = v135;
              sub_1BB9CFFA8((uint64_t *)v135, a1);
            }
            else
            {
              *(void *)(a1 + 136) = 0;
              if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_216;
              }
              *(_WORD *)propertyValueOut = 0;
              _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "failed to create reaction listener\n", propertyValueOut, 2u);
            }
            uint64_t v128 = *(void *)(a1 + 136);
            if (v128) {
              goto LABEL_198;
            }
          }
LABEL_216:
          unsigned __int8 v242 = v126;
          if (*(int *)(a1 + 72) < 2) {
            operator new();
          }
          int HeightOfPlane = CVPixelBufferGetHeightOfPlane(a2, 0);
          unint64_t v136 = *(int *)(a1 + 72);
          int v244 = *(_DWORD *)(a1 + 76);
          unsigned int v277 = 0;
          unsigned int v278 = 0;
          values = 0;
          *(void *)propertyValueOut = &values;
          propertyValueOut[8] = 0;
          if (v136)
          {
            sub_1BB9DFE08(&values, v136);
            double v137 = v277;
            bzero(v277, 8 * v136);
            unsigned int v277 = (__CFString *)((char *)v137 + 8 * v136);
            size_t v138 = *(int *)(a1 + 72);
            long long v270 = 0uLL;
            uint64_t v271 = 0;
            if (v138)
            {
              if ((v138 & 0x80000000) != 0) {
                sub_1BB9C185C();
              }
              uint64_t v139 = (char *)operator new(v138);
              __int16 v140 = v139;
              uint64_t v141 = 0;
              __int16 v142 = &v139[v138];
              do
                v139[v141++] = 1;
              while (v138 != v141);
            }
            else
            {
              __int16 v140 = 0;
              __int16 v142 = 0;
            }
          }
          else
          {
            __int16 v140 = 0;
            __int16 v142 = 0;
            long long v270 = 0uLL;
            uint64_t v271 = 0;
          }
          unsigned int v241 = v140;
          if (!v251)
          {
            if (!(v126 | v95)
              && sub_1BB9DB5DC(a1, theDict, HeightOfPlane, (uint64_t)v140)
              && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)propertyValueOut = 0;
              _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "error in ComputeDirtyTiles\n", propertyValueOut, 2u);
            }
          }
          else if (v142 - (unsigned char *)v140 >= 1)
          {
            bzero(v140, v142 - (unsigned char *)v140);
          }
          unsigned int v230 = v33;
          int v143 = *(_DWORD *)(a1 + 72);
          if (v143 >= 1) {
            operator new();
          }
          CMTime v281 = *a3;
          memset(&pixelBufferOut, 0, sizeof(pixelBufferOut));
          double v144 = *(double *)(a1 + 88);
          BOOL v145 = v95;
          int32_t v146 = *(_DWORD *)(a4 + 8);
          if (v144 <= 0.0) {
            int64_t v147 = *(void *)a4 / v143;
          }
          else {
            int64_t v147 = (uint64_t)((double)v146 / v144);
          }
          uint64_t v33 = v230;
          CMTimeMake(&pixelBufferOut, v147, v146);
          int v148 = valuePtr;
          int theDicta = HIDWORD(valuePtr);
          int v238 = v262;
          if (*(int *)(a1 + 72) < 1)
          {
            int v189 = 0;
LABEL_316:
            if (v241) {
              operator delete(v241);
            }
            *(void *)propertyValueOut = &v270;
            sub_1BB9DFB90((void ***)propertyValueOut);
            *(void *)propertyValueOut = &values;
            sub_1BB9DA0FC((void ***)propertyValueOut);
            if (!v189) {
              *(unsigned char *)(a1 + 104) = 0;
            }
            goto LABEL_329;
          }
          uint64_t v149 = 0;
          key = (void *)*MEMORY[0x1E4F44F58];
          int v229 = (const void *)*MEMORY[0x1E4F44ED8];
          int v231 = (const void *)*MEMORY[0x1E4F1CFD0];
          uint64_t v228 = (void *)*MEMORY[0x1E4F44EE8];
          int v219 = (void *)*MEMORY[0x1E4F44EC8];
          int v221 = (void *)*MEMORY[0x1E4F44EB0];
          BOOL v151 = SHIDWORD(valuePtr) > 0 || v237 != 0;
          BOOL v227 = v151;
          int16x8_t v218 = (void *)*MEMORY[0x1E4F44F10];
          int v220 = (void *)*MEMORY[0x1E4F44F28];
          float v226 = (const void *)*MEMORY[0x1E4F44F40];
          int v225 = (const void *)*MEMORY[0x1E4F1CFC8];
          CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          int v222 = (void *)*MEMORY[0x1E4F44F60];
          uint64_t v152 = v33;
          int v233 = valuePtr;
          while (1)
          {
            uint64_t v248 = v270;
            uint64_t v153 = *(void *)(v270 + 8 * v149);
            *(_DWORD *)(v153 + 256) = 2139095039;
            if (*(_DWORD *)(a1 + 2164) && *(void *)(v153 + 248))
            {
              uint64_t v154 = *(void *)(a1 + 2288);
              sub_1BB9DFA24((std::__assoc_sub_state_vtbl **)&theData, (std::__assoc_sub_state **)(v153 + 248));
              sub_1BB9ECFC0((const UInt8 *)(v154 + 8224 * v149), theData, *(_DWORD *)(a1 + 132));
              *(_DWORD *)(*(void *)(v248 + 8 * v149) + 256) = v155;
              sub_1BB9BE124((const void **)&theData);
              *(_DWORD *)propertyValueOut = *(_DWORD *)(*(void *)(v248 + 8 * v149) + 256);
              CFNumberRef v156 = CFNumberCreate(0, kCFNumberFloatType, propertyValueOut);
              if (v156)
              {
                CFDictionarySetValue(v245, @"HistCorr", v156);
                CFRelease(v156);
              }
              uint64_t v153 = *(void *)(v248 + 8 * v149);
            }
            __int16 v157 = (void **)(v153 + 272);
            if ((void **)(v153 + 272) != &values)
            {
              int16x8_t v159 = (atomic_ullong **)values;
              uint64_t v158 = (uint64_t *)v277;
              unint64_t v160 = ((char *)v277 - (unsigned char *)values) >> 3;
              uint64_t v161 = v153 + 288;
              uint64_t v162 = *(void *)(v153 + 288);
              uint64_t v163 = *(atomic_ullong ***)(v153 + 272);
              if (v160 <= (v162 - (uint64_t)v163) >> 3)
              {
                float v166 = *(atomic_ullong ***)(v153 + 280);
                unint64_t v167 = v166 - v163;
                if (v167 >= v160)
                {
                  BOOL v145 = v236;
                  if (values != v277)
                  {
                    do
                      sub_1BB9DFD50(v163++, v159++);
                    while (v159 != (atomic_ullong **)v158);
                  }
                  sub_1BB9DA150((atomic_ullong *)(v153 + 272), (atomic_ullong)v163);
                }
                else
                {
                  if (v166 != v163)
                  {
                    uint64_t v168 = 8 * v167;
                    float v169 = (atomic_ullong **)values;
                    do
                    {
                      sub_1BB9DFD50(v163++, v169++);
                      v168 -= 8;
                    }
                    while (v168);
                    uint64_t v163 = *(atomic_ullong ***)(v153 + 280);
                    uint64_t v161 = v153 + 288;
                  }
                  *(void *)(v153 + 280) = sub_1BB9DFDD0(v161, (uint64_t *)&v159[v167], v158, (uint64_t *)v163);
                  BOOL v145 = v236;
                }
                int v148 = v233;
              }
              else
              {
                if (v163)
                {
                  sub_1BB9DA150((atomic_ullong *)(v153 + 272), (atomic_ullong)v163);
                  operator delete(*v157);
                  uint64_t v162 = 0;
                  *__int16 v157 = 0;
                  *(void *)(v153 + 280) = 0;
                  *(void *)(v153 + 288) = 0;
                }
                int v148 = v233;
                if ((char *)v158 - (char *)v159 < 0) {
                  sub_1BB9C185C();
                }
                uint64_t v164 = v162 >> 2;
                if (v162 >> 2 <= v160) {
                  uint64_t v164 = ((char *)v158 - (char *)v159) >> 3;
                }
                if ((unint64_t)v162 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v165 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v165 = v164;
                }
                sub_1BB9DFE08((void *)(v153 + 272), v165);
                BOOL v145 = v236;
                *(void *)(v153 + 280) = sub_1BB9DFDD0(v153 + 288, (uint64_t *)v159, v158, *(uint64_t **)(v153 + 280));
              }
            }
            sub_1BB9D9848(*((std::__assoc_sub_state **)values + v149));
            if (*v170)
            {
              uint64_t v171 = *(void *)(v248 + 8 * v149);
              *(void *)(v248 + 8 * v149) = 0;
              sub_1BB9D86FC(a1, v171, v152, 2, 0);
            }
            else
            {
              int v172 = *(_DWORD *)(a1 + 80);
              uint64_t v173 = *(void *)(v248 + 8 * v149);
              *(_DWORD *)(v173 + 24) = v172;
              *(_DWORD *)(v173 + 28) = theDicta;
              *(_DWORD *)(v173 + 36) = v148;
              *(_DWORD *)(v173 + 40) = v237;
              *(void *)(v173 + 96) = v261;
              *(_DWORD *)(a1 + 80) = v172 + 1;
              uint64_t v174 = *(void *)(a1 + 2184);
              if (v174)
              {
                char v175 = *(unsigned char *)(v173 + 45);
                CMTime v258 = v281;
                sub_1BB9C85D0(v174, v149, v172, v175, (uint64_t)&v258, theDicta, v148, v237);
              }
              *(CMTime *)propertyValueOut = v281;
              *(Float64 *)(*(void *)(v248 + 8 * v149) + 72) = CMTimeGetSeconds((CMTime *)propertyValueOut);
              float v176 = CFDictionaryCreateMutableCopy(0, 0, v245);
              *(_DWORD *)propertyValueOut = *(_DWORD *)(*(void *)(v248 + 8 * v149) + 8);
              CFNumberRef v177 = CFNumberCreate(0, kCFNumberSInt32Type, propertyValueOut);
              if (v177)
              {
                CFDictionarySetValue(v176, key, v177);
                CFRelease(v177);
              }
              if (v242) {
                CFDictionarySetValue(v176, v229, v231);
              }
              else {
                CFDictionaryRemoveValue(v176, v229);
              }
              if (v145)
              {
                CFDictionarySetValue(v176, v228, v231);
              }
              else
              {
                CFDictionaryRemoveValue(v176, v228);
                CFDictionaryRemoveValue(v176, v219);
              }
              if (v148 >= 1)
              {
                *(_DWORD *)propertyValueOut = v148;
                CFNumberRef v178 = CFNumberCreate(0, kCFNumberSInt32Type, propertyValueOut);
                if (v178)
                {
                  CFDictionarySetValue(v176, v221, v178);
                  CFRelease(v178);
                }
              }
              if (v227)
              {
                *(_DWORD *)propertyValueOut = theDicta + v237;
                CFNumberRef v179 = CFNumberCreate(0, kCFNumberSInt32Type, propertyValueOut);
                if (v179)
                {
                  CFDictionarySetValue(v176, v218, v179);
                  CFRelease(v179);
                }
              }
              if (v238 >= 1)
              {
                *(_DWORD *)propertyValueOut = v238;
                CFNumberRef v180 = CFNumberCreate(0, kCFNumberSInt32Type, propertyValueOut);
                if (v180)
                {
                  CFDictionarySetValue(v176, v220, v180);
                  CFRelease(v180);
                }
              }
              if (*(unsigned char *)(*(void *)(v248 + 8 * v149) + 45)) {
                float v181 = v231;
              }
              else {
                float v181 = v225;
              }
              CFDictionarySetValue(v176, v226, v181);
              memset(propertyValueOut, 0, 24);
              *(void *)propertyValueOut = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(*(void *)(v248 + 8 * v149) + 12));
              *(void *)&propertyValueOut[8] = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(*(void *)(v248 + 8 * v149) + 16));
              *(void *)&propertyValueOut[16] = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(*(void *)(v248 + 8 * v149) + 20));
              CFArrayRef v182 = CFArrayCreate(allocator, (const void **)propertyValueOut, 3, MEMORY[0x1E4F1D510]);
              if (v182)
              {
                CFDictionarySetValue(v176, v222, v182);
                CFRelease(v182);
              }
              CFRelease(*(CFTypeRef *)propertyValueOut);
              CFRelease(*(CFTypeRef *)&propertyValueOut[8]);
              CFRelease(*(CFTypeRef *)&propertyValueOut[16]);
              unsigned int v280 = *(void **)(*(void *)(v248 + 8 * v149) + 48);
              CFNumberRef v183 = CFNumberCreate(0, kCFNumberSInt64Type, &v280);
              if (v183)
              {
                CFDictionarySetValue(v176, @"SignpostTimeStamp", v183);
                CFRelease(v183);
              }
              unsigned int v280 = *(void **)(*(void *)(v248 + 8 * v149) + 64);
              CFNumberRef v184 = CFNumberCreate(0, kCFNumberSInt64Type, &v280);
              if (v184)
              {
                CFDictionarySetValue(v176, @"SignpostID", v184);
                CFRelease(v184);
              }
              int v185 = *(std::__assoc_sub_state **)(*(void *)(v248 + 8 * v149) + 232);
              if (v185) {
                std::__assoc_sub_state::wait(v185);
              }
              kdebug_trace();
              float v186 = *(OpaqueVTCompressionSession **)(a1 + 16);
              float v187 = *(__CVBuffer **)(*(void *)(v248 + 8 * v149) + 216);
              CMTime presentationTimeStamp = v281;
              CMTime duration = pixelBufferOut;
              double v188 = *(void **)(v248 + 8 * v149);
              *(void *)(v248 + 8 * v149) = 0;
              LODWORD(v152) = VTCompressionSessionEncodeFrame(v186, v187, &presentationTimeStamp, &duration, v176, v188, infoFlagsOut);
              kdebug_trace();
              if (v176) {
                CFRelease(v176);
              }
            }
            --v253;
            if (v152) {
              break;
            }
            CMTime lhs = v281;
            CMTime rhs = pixelBufferOut;
            CMTimeAdd((CMTime *)propertyValueOut, &lhs, &rhs);
            uint64_t v152 = 0;
            uint64_t v33 = 0;
            int v189 = 0;
            ++v149;
            CMTime v281 = *(CMTime *)propertyValueOut;
            if (v149 >= *(int *)(a1 + 72)) {
              goto LABEL_316;
            }
          }
          if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
LABEL_311:
            int v189 = 7;
            uint64_t v33 = 4294954394;
            goto LABEL_316;
          }
          int v197 = *(_DWORD *)(a1 + 60);
          int v196 = *(_DWORD *)(a1 + 64);
          int v198 = *(_DWORD *)(a1 + 24);
          __int16 v199 = "H.264";
          if (v198 > 1718908519)
          {
            if (v198 == 1752589105) {
              goto LABEL_363;
            }
            int v200 = 1718908520;
          }
          else
          {
            if (v198 == 1684632424) {
              goto LABEL_363;
            }
            int v200 = 1685481521;
          }
          if (v198 != v200)
          {
LABEL_364:
            *(_DWORD *)propertyValueOut = 134219522;
            *(void *)&propertyValueOut[4] = a1;
            *(_WORD *)&propertyValueOut[12] = 1024;
            *(_DWORD *)&propertyValueOut[14] = v197;
            *(_WORD *)&propertyValueOut[18] = 1024;
            *(_DWORD *)&propertyValueOut[20] = v196;
            *(_WORD *)&propertyValueOut[24] = 2080;
            *(void *)&propertyValueOut[26] = v199;
            *(_WORD *)&propertyValueOut[34] = 1024;
            *(_DWORD *)&propertyValueOut[36] = v152;
            __int16 v266 = 1024;
            int v267 = v149;
            __int16 v268 = 1024;
            int v269 = v244;
            _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPEnc %p (%dx%d, %s): Encoder fails with err = %d, tile id %d order %d\n", propertyValueOut, 0x34u);
            goto LABEL_311;
          }
LABEL_363:
          __int16 v199 = "HEVC";
          goto LABEL_364;
        }
        int v237 = 0;
        CFDictionaryRef v75 = v245;
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_139;
        }
        int v77 = *(_DWORD *)(a1 + 60);
        int v76 = *(_DWORD *)(a1 + 64);
        int v78 = *(_DWORD *)(a1 + 24);
        double v79 = "H.264";
        if (v78 > 1718908519)
        {
          if (v78 == 1752589105) {
            goto LABEL_137;
          }
          int v80 = 1718908520;
        }
        else
        {
          if (v78 == 1684632424) {
            goto LABEL_137;
          }
          int v80 = 1685481521;
        }
        if (v78 != v80)
        {
LABEL_138:
          *(_DWORD *)propertyValueOut = 134218754;
          *(void *)&propertyValueOut[4] = a1;
          *(_WORD *)&propertyValueOut[12] = 1024;
          *(_DWORD *)&propertyValueOut[14] = v77;
          *(_WORD *)&propertyValueOut[18] = 1024;
          *(_DWORD *)&propertyValueOut[20] = v76;
          *(_WORD *)&propertyValueOut[24] = 2080;
          *(void *)&propertyValueOut[26] = v79;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): VCPCompressionSessionEncodeFrame got NULL callback mutex\n", propertyValueOut, 0x22u);
          int v237 = 0;
          goto LABEL_139;
        }
LABEL_137:
        double v79 = "HEVC";
        goto LABEL_138;
      }
      int v212 = *(_DWORD *)(a1 + 60);
      int v211 = *(_DWORD *)(a1 + 64);
      int v213 = *(_DWORD *)(a1 + 24);
      int16x8_t v214 = "H.264";
      if (v213 > 1718908519)
      {
        if (v213 == 1752589105) {
          goto LABEL_381;
        }
        int v215 = 1718908520;
      }
      else
      {
        if (v213 == 1684632424) {
          goto LABEL_381;
        }
        int v215 = 1685481521;
      }
      if (v213 != v215)
      {
LABEL_382:
        *(_DWORD *)propertyValueOut = 134218754;
        *(void *)&propertyValueOut[4] = a1;
        *(_WORD *)&propertyValueOut[12] = 1024;
        *(_DWORD *)&propertyValueOut[14] = v212;
        *(_WORD *)&propertyValueOut[18] = 1024;
        *(_DWORD *)&propertyValueOut[20] = v211;
        *(_WORD *)&propertyValueOut[24] = 2080;
        *(void *)&propertyValueOut[26] = v214;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): Encoder set color primaries as SMPTE_EG_432_1, transferfunction as BT_709, YCbCrMatrix as BT_2020_nonconstant\n", propertyValueOut, 0x22u);
        goto LABEL_109;
      }
LABEL_381:
      int16x8_t v214 = "HEVC";
      goto LABEL_382;
    }
    CFDictionaryRef v38 = CVBufferCopyAttachments(a2, kCVAttachmentMode_ShouldPropagate);
    *(void *)&long long v270 = v38;
    if (!v38) {
      goto LABEL_61;
    }
    int v39 = (const void *)*MEMORY[0x1E4F51480];
    if (!CFDictionaryContainsKey(v38, (const void *)*MEMORY[0x1E4F51480])) {
      goto LABEL_61;
    }
    CFDictionaryRef v40 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v270, v39);
    CFDictionaryRef v41 = v40;
    if (!v40) {
      goto LABEL_61;
    }
    int v42 = CFDictionaryGetValue(v40, (const void *)*MEMORY[0x1E4F52700]);
    pixelBufferOut.value = (CMTimeValue)v42;
    if (!v42)
    {
      if (qword_1E9F81AE8 != -1) {
        dispatch_once(&qword_1E9F81AE8, &unk_1F14EF1E0);
      }
      if (byte_1E9F81AF0) {
        goto LABEL_61;
      }
      CFDictionaryRef v47 = (const __CFDictionary *)CFDictionaryGetValue(v41, @"MetadataCVA");
      if (!v47) {
        goto LABEL_61;
      }
      int v42 = CFDictionaryGetValue(v47, (const void *)*MEMORY[0x1E4F4D730]);
      pixelBufferOut.value = (CMTimeValue)v42;
      if (!v42) {
        goto LABEL_62;
      }
    }
    if (CFArrayGetCount((CFArrayRef)v42) == 1)
    {
      CFTypeID v43 = CFGetTypeID(v42);
      if (v43 == CFArrayGetTypeID())
      {
        unsigned int v280 = 0;
        int v44 = CFArrayGetValueAtIndex((CFArrayRef)v42, 0);
        int v42 = v44;
        if (!v44)
        {
LABEL_62:
          sub_1BB9BE1C0((const void **)&v270);
          if (!dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 2168), 0))
          {
            CFTypeID v48 = *(void **)(a1 + 2176);
            *(void *)propertyValueOut = MEMORY[0x1E4F143A8];
            *(void *)&propertyValueOut[8] = 0x40000000;
            *(void *)&propertyValueOut[16] = sub_1BB9DF7BC;
            *(void *)&propertyValueOut[24] = &unk_1E62478F0;
            *(void *)&propertyValueOut[32] = a1;
            sub_1BBA12900(v48, (uint64_t)a2, 4u, (uint64_t)v42, propertyValueOut);
          }
          if (v42) {
            CFRelease(v42);
          }
          goto LABEL_66;
        }
        CFTypeID v45 = CFGetTypeID(v44);
        if (v45 == CFDictionaryGetTypeID())
        {
          unsigned int v278 = 0;
          value = 0;
          memset(&v281, 0, sizeof(v281));
          values = 0;
          unsigned int v277 = 0;
          if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v42, (const void *)*MEMORY[0x1E4F52718], (const void **)&value))
          {
            v281.value = *MEMORY[0x1E4F74528];
            CFNumberRef v46 = value;
            values = value;
          }
          else
          {
            CFNumberRef v46 = 0;
          }
          if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v42, (const void *)*MEMORY[0x1E4F52710], (const void **)&value)&& CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)value, (CGRect *)propertyValueOut))
          {
            *(void *)&v281.int32_t timescale = *MEMORY[0x1E4F74520];
            CFStringRef v203 = sub_1BB9DF768(*(double *)propertyValueOut, *(double *)&propertyValueOut[8], *(double *)&propertyValueOut[16], *(double *)&propertyValueOut[24]);
            unsigned int v277 = (__CFString *)v203;
          }
          else
          {
            CFStringRef v203 = 0;
          }
          if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v42, (const void *)*MEMORY[0x1E4F52720], (const void **)&value))
          {
            int v42 = 0;
            v281.epoch = *MEMORY[0x1E4F74530];
            unsigned int v278 = value;
            if (!v46 || !v203 || !value) {
              goto LABEL_371;
            }
            CFAllocatorRef v204 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            unsigned int v280 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&v281, (const void **)&values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (v280)
            {
              pixelBufferOut.value = (CMTimeValue)CFArrayCreate(v204, (const void **)&v280, 1, MEMORY[0x1E4F1D510]);
              if (pixelBufferOut.value)
              {
                int v42 = CFDictionaryCreate(v204, MEMORY[0x1E4F74518], (const void **)&pixelBufferOut, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                CFRelease((CFTypeRef)pixelBufferOut.value);
              }
              else
              {
                int v42 = 0;
              }
              CFRelease(v280);
LABEL_371:
              if (v277) {
                CFRelease(v277);
              }
              goto LABEL_62;
            }
          }
          int v42 = 0;
          goto LABEL_371;
        }
      }
    }
LABEL_61:
    int v42 = 0;
    goto LABEL_62;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v17 = *(_DWORD *)(a1 + 60);
    int v16 = *(_DWORD *)(a1 + 64);
    int v18 = *(_DWORD *)(a1 + 24);
    int v19 = "H.264";
    if (v18 > 1718908519)
    {
      if (v18 == 1752589105) {
        goto LABEL_32;
      }
      int v20 = 1718908520;
    }
    else
    {
      if (v18 == 1684632424) {
        goto LABEL_32;
      }
      int v20 = 1685481521;
    }
    if (v18 != v20)
    {
LABEL_33:
      *(_DWORD *)propertyValueOut = 134218754;
      *(void *)&propertyValueOut[4] = a1;
      *(_WORD *)&propertyValueOut[12] = 1024;
      *(_DWORD *)&propertyValueOut[14] = v17;
      *(_WORD *)&propertyValueOut[18] = 1024;
      *(_DWORD *)&propertyValueOut[20] = v16;
      *(_WORD *)&propertyValueOut[24] = 2080;
      *(void *)&propertyValueOut[26] = v19;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPEnc %p (%dx%d, %s): VCPCompressionSessionEncodeFrame got NULL session mutex\n", propertyValueOut, 0x22u);
      return 4294954384;
    }
LABEL_32:
    int v19 = "HEVC";
    goto LABEL_33;
  }
  return 4294954384;
}

void sub_1BB9DF4A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,std::mutex *a34)
{
  sub_1BB9BE1C0((const void **)(v34 - 240));
  std::mutex::unlock(a34);
  _Unwind_Resume(a1);
}

CFStringRef sub_1BB9DF768(double a1, double a2, double a3, double a4)
{
  return CFStringCreateWithFormat(0, 0, @"{{%.*g, %.*g}, {%.*g, %.*g}}", 17, *(void *)&a1, 17, *(void *)&a2, 17, *(void *)&a3, 17, *(void *)&a4);
}

intptr_t sub_1BB9DF7BC(uint64_t a1, int a2, CFDictionaryRef theDict)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    *(_WORD *)(v4 + 48) = 0;
  }
  else
  {
    float valuePtr = 0.0;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F74598]);
    CFNumberGetValue(Value, kCFNumberFloatType, &valuePtr);
    uint64_t v4 = *(void *)(a1 + 32);
    *(_WORD *)(v4 + 48) = (int)fmax(fmin(valuePtr * 255.0, 255.0), 1.0);
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v4 + 2168));
}

uint64_t sub_1BB9DF84C(uint64_t a1, uint64_t a2, int a3, int a4, char a5, char a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = a4;
  *(void *)(a1 + 20) = 0;
  *(void *)(a1 + 36) = 0;
  *(void *)(a1 + 28) = 0;
  *(unsigned char *)(a1 + 44) = a6;
  *(unsigned char *)(a1 + 45) = a5;
  *(unsigned char *)(a1 + 46) = 0;
  *(void *)(a1 + 48) = a8;
  *(_DWORD *)(a1 + 56) = a9;
  *(void *)(a1 + 64) = a7;
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = a10;
  *(_OWORD *)(a1 + 88) = xmmword_1BBB6F4E0;
  CMTimeMake((CMTime *)(a1 + 104), 0, 1000);
  CMTimeMake((CMTime *)(a1 + 128), 0, 1000);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = 2139095039;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 264) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  return a1;
}

void sub_1BB9DF938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  int v12 = v11;
  a10 = v12;
  sub_1BB9DA0FC(&a10);
  state = (atomic_ullong *)v10[31].__state_;
  if (state && !atomic_fetch_add(state + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*state + 16))(state);
  }
  int v15 = (atomic_ullong *)v10[30].__state_;
  if (v15)
  {
    if (!atomic_fetch_add(v15 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
      (*(void (**)(atomic_ullong *))(*v15 + 16))(v15);
    }
  }
  std::future<void>::~future(v10 + 29);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9DF9D4(uint64_t *a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1BB9DA018(result);
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

void sub_1BB9DFA24(std::__assoc_sub_state_vtbl **a1, std::__assoc_sub_state **a2)
{
  CFDictionaryRef v3 = *a2;
  *a2 = 0;
  __lk.__m_ = &v3->__mut_;
  __lk.__owns_ = 1;
  std::mutex::lock(&v3->__mut_);
  std::__assoc_sub_state::__sub_wait(v3, &__lk);
  ptr = v3->__exception_.__ptr_;
  v7.__ptr_ = 0;
  std::exception_ptr::~exception_ptr(&v7);
  if (ptr)
  {
    std::exception_ptr::exception_ptr(&v7, &v3->__exception_);
    v6.__ptr_ = &v7;
    std::rethrow_exception(v6);
    __break(1u);
  }
  else
  {
    *a1 = v3[1].__vftable;
    v3[1].__vftable = 0;
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      on_zero_shared = v3->__on_zero_shared;
      ((void (*)(std::__assoc_sub_state *))on_zero_shared)(v3);
    }
  }
}

void sub_1BB9DFB20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10, std::mutex *a11, char a12)
{
  std::exception_ptr::~exception_ptr(&a10);
  if (a12) {
    std::mutex::unlock(a11);
  }
  if (v12)
  {
    if (!atomic_fetch_add(v12 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
      (*(void (**)(atomic_ullong *))(*v12 + 16))(v12);
    }
  }
  _Unwind_Resume(a1);
}

void sub_1BB9DFB90(void ***a1)
{
  uint64_t v1 = *a1;
  BOOL v2 = (uint64_t *)**a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t *)v1[1];
    std::exception_ptr v5 = **a1;
    if (v4 != v2)
    {
      do
        sub_1BB9DF9D4(--v4);
      while (v4 != v2);
      std::exception_ptr v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

CFNumberRef sub_1BB9DFC14(const __CFDictionary *a1, const void *a2, void *a3)
{
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (result)
  {
    CFNumberRef v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    CFNumberRef result = (const __CFNumber *)CFNumberGetTypeID();
    if ((const __CFNumber *)v6 == result)
    {
      return (const __CFNumber *)CFNumberGetValue(v5, kCFNumberSInt32Type, a3);
    }
  }
  return result;
}

void sub_1BB9DFC88(__CFDictionary *a1, float a2)
{
  float valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  if (v3)
  {
    CFNumberRef v4 = v3;
    CFDictionarySetValue(a1, @"HistCorr", v3);
    CFRelease(v4);
  }
}

void sub_1BB9DFCE8(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

atomic_ullong **sub_1BB9DFD50(atomic_ullong **a1, atomic_ullong **a2)
{
  if (*a2) {
    atomic_fetch_add_explicit(*a2 + 1, 1uLL, memory_order_relaxed);
  }
  CFNumberRef v4 = *a1;
  if (*a1 && !atomic_fetch_add(v4 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v4 + 16))(v4);
  }
  *a1 = *a2;
  return a1;
}

uint64_t *sub_1BB9DFDD0(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  for (CFNumberRef result = a4; a2 != a3; ++result)
  {
    uint64_t v5 = *a2;
    *CFNumberRef result = *a2;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
    ++a2;
  }
  return result;
}

char *sub_1BB9DFE08(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_1BB9C185C();
  }
  CFNumberRef result = (char *)operator new(8 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * a2];
  return result;
}

void sub_1BB9DFE4C(uint64_t a1)
{
  char v1 = 0;
  sub_1BB9DFEC4(a1, &v1);
}

void sub_1BB9DFE80(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
  __cxa_begin_catch(a1);
  std::current_exception();
  v10.__ptr_ = &a9;
  std::__assoc_sub_state::set_exception(v9, v10);
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  JUMPOUT(0x1BB9DFE70);
}

void sub_1BB9DFEA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
}

void sub_1BB9DFEC4(uint64_t a1, unsigned char *a2)
{
  CFNumberRef v4 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  if ((*(unsigned char *)(a1 + 136) & 1) != 0
    || (v6.__ptr_ = 0, uint64_t v5 = *(void *)(a1 + 16), std::exception_ptr::~exception_ptr(&v6), v5))
  {
    sub_1BB9CC800(2u);
  }
  *(unsigned char *)(a1 + 140) = *a2;
  *(_DWORD *)(a1 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 88));
  std::mutex::unlock(v4);
}

void sub_1BB9DFF54(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9DFF68(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

void sub_1BB9DFF8C(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  BOOL v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9E000C(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  BOOL v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1BB9E0078(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 152);
  if (!*(void *)(*(void *)(a1 + 144) + 2184) || (CFNumberRef v3 = *(std::__assoc_sub_state **)(v2 + 240)) == 0)
  {
LABEL_10:
    char v11 = *(unsigned char *)(v2 + 46);
    sub_1BB9DFEC4(a1, &v11);
    return;
  }
  *(void *)(v2 + 240) = 0;
  __lk.value = (CMTimeValue)&v3->__mut_;
  LOBYTE(__lk.timescale) = 1;
  std::mutex::lock(&v3->__mut_);
  std::__assoc_sub_state::__sub_wait(v3, (std::unique_lock<std::mutex> *)&__lk);
  ptr = v3->__exception_.__ptr_;
  v12.value = 0;
  std::exception_ptr::~exception_ptr((std::exception_ptr *)&v12);
  if (!ptr)
  {
    uint64_t v5 = v3[1].__vftable;
    if (LOBYTE(__lk.timescale)) {
      std::mutex::unlock((std::mutex *)__lk.value);
    }
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      ((void (*)(std::__assoc_sub_state *))v3->__on_zero_shared)(v3);
    }
    uint64_t v2 = *(void *)(a1 + 152);
    *(void *)(v2 + 88) = v5;
    if (!v5)
    {
      *(unsigned char *)(v2 + 45) = 1;
      uint64_t v6 = *(void *)(*(void *)(a1 + 144) + 2184);
      int v7 = *(_DWORD *)(a1 + 160);
      char v8 = *(unsigned char *)(a1 + 164) == 0;
      CMTime __lk = *(CMTime *)*(void *)&MEMORY[0x1E4F1F9F8];
      CMTime v12 = __lk;
      BOOL v9 = sub_1BB9C8034(v6, v7, 1, v8, 0, &__lk, &v12);
      uint64_t v2 = *(void *)(a1 + 152);
      *(unsigned char *)(v2 + 46) = v9;
    }
    goto LABEL_10;
  }
  std::exception_ptr::exception_ptr((std::exception_ptr *)&v12, &v3->__exception_);
  v10.__ptr_ = &v12;
  std::rethrow_exception(v10);
  __break(1u);
}

void sub_1BB9E01D8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::exception_ptr a11, uint64_t a12, uint64_t a13, uint64_t a14, std::mutex *a15, char a16)
{
  std::exception_ptr::~exception_ptr(&a11);
  if (a16) {
    std::mutex::unlock(a15);
  }
  if (!atomic_fetch_add(v17 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v17 + 16))(v17);
  }
  __cxa_begin_catch(a1);
  std::current_exception();
  v19.__ptr_ = &a9;
  std::__assoc_sub_state::set_exception(v16, v19);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x1BB9E01ACLL);
}

void sub_1BB9E0270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
}

void sub_1BB9E028C(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9E030C(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1BB9E0378(uint64_t a1)
{
  char v1 = 1;
  sub_1BB9DFEC4(a1, &v1);
}

void sub_1BB9E03B0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
  __cxa_begin_catch(a1);
  std::current_exception();
  v10.__ptr_ = &a9;
  std::__assoc_sub_state::set_exception(v9, v10);
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  JUMPOUT(0x1BB9E03A0);
}

void sub_1BB9E03D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
}

void sub_1BB9E03F4(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9E0474(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1BB9E04E0()
{
  if (!*MEMORY[0x1E4F4D730]) {
    byte_1E9F81AF0 = 1;
  }
}

uint64_t VCPCompressionSessionCompleteFrames(uint64_t a1, CMTime *a2)
{
  uint64_t v2 = *(OpaqueVTCompressionSession **)(a1 + 16);
  CMTime v4 = *a2;
  return VTCompressionSessionCompleteFrames(v2, &v4);
}

uint64_t VCPDecompressionSessionGetTypeID()
{
  return qword_1E9F81A70;
}

uint64_t sub_1BB9E0584()
{
  qword_1E9F81AF8 = 0;
  unk_1E9F81B00 = "VCPDecompressionSession";
  qword_1E9F81B08 = 0;
  unk_1E9F81B10 = 0;
  qword_1E9F81B18 = (uint64_t)sub_1BB9E05D8;
  unk_1E9F81B20 = 0u;
  unk_1E9F81B30 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1E9F81A70 = result;
  return result;
}

void sub_1BB9E05D8(uint64_t a1)
{
  if (a1) {
    VCPDecompressionSessionInvalidate(a1);
  }
}

void VCPDecompressionSessionInvalidate(uint64_t a1)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = *(OpaqueVTDecompressionSession **)(a1 + 16);
    if (v2)
    {
      VTDecompressionSessionInvalidate(v2);
      CFRelease(*(CFTypeRef *)(a1 + 16));
      *(void *)(a1 + 16) = 0;
    }
    CFNumberRef v3 = *(const void **)(a1 + 48);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 48) = 0;
    }
    CMTime v4 = *(const void **)(a1 + 56);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(a1 + 56) = 0;
    }
    uint64_t v5 = *(const void **)(a1 + 64);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a1 + 64) = 0;
    }
    uint64_t v6 = *(const void **)(a1 + 72);
    if (v6)
    {
      CFRelease(v6);
      *(void *)(a1 + 72) = 0;
    }
    int v7 = *(__CVPixelBufferPool **)(a1 + 184);
    if (v7)
    {
      CVPixelBufferPoolRelease(v7);
      *(void *)(a1 + 184) = 0;
    }
    char v8 = *(__CVBuffer **)(a1 + 192);
    if (v8)
    {
      CVPixelBufferRelease(v8);
      *(void *)(a1 + 192) = 0;
    }
    uint64_t v9 = *(void *)(a1 + 2280);
    if (v9)
    {
      std::exception_ptr v10 = *(void **)(v9 + 224);
      if (v10)
      {
        *(void *)(v9 + 232) = v10;
        operator delete(v10);
      }
      char v11 = *(void **)(v9 + 200);
      if (v11) {
        operator delete(v11);
      }
      *(void *)CFDictionaryRef v47 = v9 + 176;
      sub_1BB9C932C((void ***)v47);
      sub_1BB9C93B0(v9 + 8);
      CMTime v12 = sub_1BB9C607C((const void **)v9);
      MEMORY[0x1C18605E0](v12, 0x10F0C40E9E3E2ADLL);
      *(void *)(a1 + 2280) = 0;
    }
    int v13 = *(__CVPixelBufferPool **)(a1 + 2240);
    if (v13)
    {
      CVPixelBufferPoolRelease(v13);
      *(void *)(a1 + 2240) = 0;
    }
    uint64_t v14 = *(__CVPixelBufferPool **)(a1 + 2248);
    if (v14)
    {
      CVPixelBufferPoolRelease(v14);
      *(void *)(a1 + 2248) = 0;
    }
    uint64_t v15 = *(void *)(a1 + 2288);
    if (v15)
    {
      (*(void (**)(uint64_t))(*(void *)v15 + 272))(v15);
      *(void *)(a1 + 2288) = 0;
    }
    int v16 = *(void **)(a1 + 2256);
    if (v16)
    {
      [v16 invalidate];
      CFRelease(*(CFTypeRef *)(a1 + 2256));
      *(void *)(a1 + 2256) = 0;
    }
    int v17 = *(uint64_t **)(a1 + 2304);
    if (v17)
    {
      std::mutex::lock((std::mutex *)(v17 + 6));
      int v18 = (__CVPixelBufferPool *)v17[3];
      if (v18)
      {
        CVPixelBufferPoolRelease(v18);
        v17[3] = 0;
      }
      uint64_t v19 = *v17;
      if (*v17)
      {
        uint64_t v20 = *(void *)(v19 - 8);
        if (v20)
        {
          uint64_t v21 = 616 * v20;
          do
          {
            std::mutex::lock((std::mutex *)(v19 + v21 - 72));
            BOOL v22 = (void *)(v19 + v21 - 600);
            if (*v22)
            {
              espresso_plan_destroy();
              *BOOL v22 = 0;
            }
            std::mutex::unlock((std::mutex *)(v19 + v21 - 72));
            std::mutex::~mutex((std::mutex *)(v19 + v21 - 72));
            CMTimeScale v23 = *(std::__shared_weak_count **)(v19 + v21 - 608);
            if (v23) {
              sub_1BB9C09B4(v23);
            }
            v21 -= 616;
          }
          while (v21);
        }
        MEMORY[0x1C18605A0](v19 - 16, 0x10A0C803A5D1B82);
        uint64_t *v17 = 0;
      }
      uint64_t v24 = v17[5];
      if (v24)
      {
        MEMORY[0x1C18605A0](v24, 0x1000C8052888210);
        v17[5] = 0;
      }
      std::mutex::unlock((std::mutex *)(v17 + 6));
      std::mutex::~mutex((std::mutex *)(v17 + 6));
      MEMORY[0x1C18605E0](v17, 0x10A0C40F3D614E7);
      *(void *)(a1 + 2304) = 0;
    }
    CMTimeValue v25 = *(const void **)(a1 + 96);
    if (v25)
    {
      CFRelease(v25);
      *(void *)(a1 + 96) = 0;
    }
    float v26 = *(const void **)(a1 + 104);
    if (v26)
    {
      CFRelease(v26);
      *(void *)(a1 + 104) = 0;
    }
    uint64_t v27 = *(void *)(a1 + 2224);
    if (v27)
    {
      (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
      *(void *)(a1 + 2224) = 0;
    }
    CMTimeValue v28 = *(void **)(a1 + 2352);
    if (v28)
    {
      CMTimeScale v29 = (std::__shared_weak_count *)v28[197];
      if (v29) {
        sub_1BB9C09B4(v29);
      }
      uint64_t v30 = (std::__shared_weak_count *)v28[195];
      if (v30) {
        sub_1BB9C09B4(v30);
      }
      int v31 = (std::__shared_weak_count *)v28[193];
      if (v31) {
        sub_1BB9C09B4(v31);
      }
      for (uint64_t i = 191; i != 63; i -= 2)
      {
        uint64_t v33 = (std::__shared_weak_count *)v28[i];
        if (v33) {
          sub_1BB9C09B4(v33);
        }
      }
      do
      {
        uint64_t v34 = (std::__shared_weak_count *)v28[i];
        if (v34) {
          sub_1BB9C09B4(v34);
        }
        i -= 2;
      }
      while (i != 31);
      do
      {
        CFDictionaryRef v35 = (std::__shared_weak_count *)v28[i];
        if (v35) {
          sub_1BB9C09B4(v35);
        }
        i -= 2;
      }
      while (i != -1);
      MEMORY[0x1C18605E0](v28, 0x20C40F81735CALL);
      *(void *)(a1 + 2352) = 0;
    }
    uint64_t v36 = *(void *)(a1 + 2360);
    if (v36)
    {
      BOOL v37 = *(std::__shared_weak_count **)(v36 + 4632);
      if (v37) {
        sub_1BB9C09B4(v37);
      }
      CFDictionaryRef v38 = *(std::__shared_weak_count **)(v36 + 4616);
      if (v38) {
        sub_1BB9C09B4(v38);
      }
      for (uint64_t j = 4600; j != 504; j -= 16)
      {
        CFDictionaryRef v40 = *(std::__shared_weak_count **)(v36 + j);
        if (v40) {
          sub_1BB9C09B4(v40);
        }
      }
      do
      {
        CFDictionaryRef v41 = *(std::__shared_weak_count **)(v36 + j);
        if (v41) {
          sub_1BB9C09B4(v41);
        }
        j -= 16;
      }
      while (j != -8);
      MEMORY[0x1C18605E0](v36, 0x20C408F2BB087);
      *(void *)(a1 + 2360) = 0;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      int v43 = *(_DWORD *)(a1 + 112);
      int v42 = *(_DWORD *)(a1 + 116);
      int v44 = *(_DWORD *)(a1 + 24);
      CFTypeID v45 = "H.264";
      if (v44 > 1718908519)
      {
        if (v44 == 1752589105) {
          goto LABEL_89;
        }
        int v46 = 1718908520;
      }
      else
      {
        if (v44 == 1684632424) {
          goto LABEL_89;
        }
        int v46 = 1685481521;
      }
      if (v44 != v46)
      {
LABEL_90:
        *(_DWORD *)CFDictionaryRef v47 = 134218754;
        *(void *)&v47[4] = a1;
        __int16 v48 = 1024;
        int v49 = v43;
        __int16 v50 = 1024;
        int v51 = v42;
        __int16 v52 = 2080;
        unint64_t v53 = v45;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Video decompression session invalidated\n", v47, 0x22u);
        return;
      }
LABEL_89:
      CFTypeID v45 = "HEVC";
      goto LABEL_90;
    }
  }
}

void sub_1BB9E0AB0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_1BB9BE110(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t VCPDecompressionSessionCreate(const void *a1, const opaqueCMFormatDescription *a2, const __CFDictionary *a3, const void *a4, _OWORD *a5, uint64_t *a6)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  CFStringRef v12 = (const __CFString *)CFPreferencesCopyAppValue(@"EnableVideoChatAnalysis", @"com.apple.VideoProcessing");
  pthread_once(&stru_1E9F80A68, (void (*)(void))sub_1BB9E0584);
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    uint64_t v16 = 4294954392;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = -12904;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPDec: Failed to create video decompression session, err = %d\n", buf, 8u);
    }
    goto LABEL_19;
  }
  uint64_t v14 = Instance;
  bzero((void *)(Instance + 16), 0x938uLL);
  *(_OWORD *)(v14 + 28) = *a5;
  *(_OWORD *)(v14 + 48) = 0u;
  *(_OWORD *)(v14 + 64) = 0u;
  *(_OWORD *)(v14 + 2256) = 0u;
  *(unsigned char *)(v14 + 2272) = 0;
  *(_DWORD *)(v14 + 144) = 0;
  *(void *)(v14 + 136) = 1;
  *(void *)(v14 + 156) = 0x8000000000000000;
  *(_WORD *)(v14 + 164) = 0;
  *(_DWORD *)(v14 + 168) = 0;
  *(unsigned char *)(v14 + 172) = 0;
  *(void *)(v14 + 200) = -1;
  *(unsigned char *)(v14 + 208) = 64;
  if (v12 && CFEqual(v12, @"1")) {
    *(unsigned char *)(v14 + 2272) = 1;
  }
  sub_1BBA12890((void *)(v14 + 2256));
  uint64_t v15 = sub_1BB9E1494(a1, a2, a3, a4, (_DWORD *)v14);
  if (v15)
  {
    uint64_t v16 = v15;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v18 = *(_DWORD *)(v14 + 112);
      int v17 = *(_DWORD *)(v14 + 116);
      int v19 = *(_DWORD *)(v14 + 24);
      uint64_t v20 = "H.264";
      if (v19 > 1718908519)
      {
        if (v19 == 1752589105) {
          goto LABEL_44;
        }
        int v21 = 1718908520;
      }
      else
      {
        if (v19 == 1684632424) {
          goto LABEL_44;
        }
        int v21 = 1685481521;
      }
      if (v19 != v21)
      {
LABEL_45:
        *(_DWORD *)buf = 134219010;
        *(void *)&uint8_t buf[4] = v14;
        __int16 v63 = 1024;
        int v64 = v18;
        __int16 v65 = 1024;
        int v66 = v17;
        __int16 v67 = 2080;
        uint64_t v68 = v20;
        __int16 v69 = 1024;
        int v70 = v16;
        CFDictionaryRef v38 = MEMORY[0x1E4F14500];
        int v39 = "VCPDec %p (%dx%d, %s): Failed to create video decoder, err = %d\n";
LABEL_61:
        uint32_t v50 = 40;
LABEL_62:
        _os_log_error_impl(&dword_1BB9B9000, v38, OS_LOG_TYPE_ERROR, v39, buf, v50);
        goto LABEL_14;
      }
LABEL_44:
      uint64_t v20 = "HEVC";
      goto LABEL_45;
    }
LABEL_14:
    CMTimeScale v23 = *(const void **)(v14 + 104);
    if (v23)
    {
      CFRelease(v23);
      *(void *)(v14 + 104) = 0;
    }
    uint64_t v24 = *(__CVPixelBufferPool **)(v14 + 2248);
    if (v24)
    {
      CVPixelBufferPoolRelease(v24);
      *(void *)(v14 + 2248) = 0;
    }
    CFRelease((CFTypeRef)v14);
LABEL_19:
    uint64_t v14 = 0;
    goto LABEL_20;
  }
  uint64_t v22 = VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)(v14 + 96));
  if (v22)
  {
    uint64_t v16 = v22;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    int v41 = *(_DWORD *)(v14 + 112);
    int v40 = *(_DWORD *)(v14 + 116);
    int v42 = *(_DWORD *)(v14 + 24);
    int v43 = "H.264";
    if (v42 > 1718908519)
    {
      if (v42 == 1752589105) {
        goto LABEL_59;
      }
      int v44 = 1718908520;
    }
    else
    {
      if (v42 == 1684632424) {
        goto LABEL_59;
      }
      int v44 = 1685481521;
    }
    if (v42 != v44)
    {
LABEL_60:
      *(_DWORD *)buf = 134219010;
      *(void *)&uint8_t buf[4] = v14;
      __int16 v63 = 1024;
      int v64 = v41;
      __int16 v65 = 1024;
      int v66 = v40;
      __int16 v67 = 2080;
      uint64_t v68 = v43;
      __int16 v69 = 1024;
      int v70 = v16;
      CFDictionaryRef v38 = MEMORY[0x1E4F14500];
      int v39 = "VCPDec %p (%dx%d, %s): Decoder failed to create up_scaling_session, err = %d\n";
      goto LABEL_61;
    }
LABEL_59:
    int v43 = "HEVC";
    goto LABEL_60;
  }
  if (*(_DWORD *)(v14 + 152) != 1111970369) {
    goto LABEL_71;
  }
  float v26 = (VTSessionRef *)(v14 + 104);
  if (!*(void *)(v14 + 104))
  {
    uint64_t v32 = VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)(v14 + 104));
    if (v32)
    {
      uint64_t v16 = v32;
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      int v34 = *(_DWORD *)(v14 + 112);
      int v33 = *(_DWORD *)(v14 + 116);
      int v35 = *(_DWORD *)(v14 + 24);
      uint64_t v36 = "H.264";
      if (v35 > 1718908519)
      {
        if (v35 == 1752589105) {
          goto LABEL_86;
        }
        int v37 = 1718908520;
      }
      else
      {
        if (v35 == 1684632424) {
          goto LABEL_86;
        }
        int v37 = 1685481521;
      }
      if (v35 != v37)
      {
LABEL_87:
        *(_DWORD *)buf = 134219010;
        *(void *)&uint8_t buf[4] = v14;
        __int16 v63 = 1024;
        int v64 = v34;
        __int16 v65 = 1024;
        int v66 = v33;
        __int16 v67 = 2080;
        uint64_t v68 = v36;
        __int16 v69 = 1024;
        int v70 = v16;
        CFDictionaryRef v38 = MEMORY[0x1E4F14500];
        int v39 = "VCPDec %p (%dx%d, %s): Decoder failed to create data_format_transfer_session, err = %d\n";
        goto LABEL_61;
      }
LABEL_86:
      uint64_t v36 = "HEVC";
      goto LABEL_87;
    }
  }
  if (!*(void *)(v14 + 2248))
  {
    *(void *)buf = 0;
    uint64_t v16 = sub_1BBAA9C20(*(_DWORD *)(v14 + 112), *(_DWORD *)(v14 + 116), (CFMutableDictionaryRef *)buf);
    if (v16)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v61 = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to create source pixel attributes\n", v61, 2u);
      }
    }
    else
    {
      CVPixelBufferPoolCreate(0, 0, *(CFDictionaryRef *)buf, (CVPixelBufferPoolRef *)(v14 + 2248));
      if (*(void *)(v14 + 2248))
      {
        sub_1BB9BE228((const void **)buf);
        goto LABEL_26;
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v61 = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "failed to create pixelBufferPool\n", v61, 2u);
      }
      uint64_t v16 = 4294954392;
    }
    sub_1BB9BE228((const void **)buf);
    goto LABEL_14;
  }
LABEL_26:
  if (*(_DWORD *)(v14 + 148) == 1)
  {
    uint64_t v16 = VTSessionSetProperty(*v26, (CFStringRef)*MEMORY[0x1E4F450E0], (CFTypeRef)*MEMORY[0x1E4F24AC0]);
    if (v16)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      int v28 = *(_DWORD *)(v14 + 112);
      int v27 = *(_DWORD *)(v14 + 116);
      int v29 = *(_DWORD *)(v14 + 24);
      uint64_t v30 = "H.264";
      if (v29 > 1718908519)
      {
        if (v29 == 1752589105) {
          goto LABEL_91;
        }
        int v31 = 1718908520;
      }
      else
      {
        if (v29 == 1684632424) {
          goto LABEL_91;
        }
        int v31 = 1685481521;
      }
      if (v29 != v31)
      {
LABEL_92:
        *(_DWORD *)buf = 134218754;
        *(void *)&uint8_t buf[4] = v14;
        __int16 v63 = 1024;
        int v64 = v28;
        __int16 v65 = 1024;
        int v66 = v27;
        __int16 v67 = 2080;
        uint64_t v68 = v30;
        CFDictionaryRef v38 = MEMORY[0x1E4F14500];
        int v39 = "VCPDec %p (%dx%d, %s): Decoder failed to set DestinationColorPrimaries for color transfer\n";
LABEL_103:
        uint32_t v50 = 34;
        goto LABEL_62;
      }
LABEL_91:
      uint64_t v30 = "HEVC";
      goto LABEL_92;
    }
    uint64_t v16 = VTSessionSetProperty(*v26, (CFStringRef)*MEMORY[0x1E4F450F8], (CFTypeRef)*MEMORY[0x1E4F24BE0]);
    if (v16)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      int v46 = *(_DWORD *)(v14 + 112);
      int v45 = *(_DWORD *)(v14 + 116);
      int v47 = *(_DWORD *)(v14 + 24);
      __int16 v48 = "H.264";
      if (v47 > 1718908519)
      {
        if (v47 == 1752589105) {
          goto LABEL_96;
        }
        int v49 = 1718908520;
      }
      else
      {
        if (v47 == 1684632424) {
          goto LABEL_96;
        }
        int v49 = 1685481521;
      }
      if (v47 != v49)
      {
LABEL_97:
        *(_DWORD *)buf = 134218754;
        *(void *)&uint8_t buf[4] = v14;
        __int16 v63 = 1024;
        int v64 = v46;
        __int16 v65 = 1024;
        int v66 = v45;
        __int16 v67 = 2080;
        uint64_t v68 = v48;
        CFDictionaryRef v38 = MEMORY[0x1E4F14500];
        int v39 = "VCPDec %p (%dx%d, %s): Decoder failed to set DestinationTransferFunction for color transfer\n";
        goto LABEL_103;
      }
LABEL_96:
      __int16 v48 = "HEVC";
      goto LABEL_97;
    }
    uint64_t v16 = VTSessionSetProperty(*v26, (CFStringRef)*MEMORY[0x1E4F45100], (CFTypeRef)*MEMORY[0x1E4F24C30]);
    if (v16)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_14;
      }
      int v52 = *(_DWORD *)(v14 + 112);
      int v51 = *(_DWORD *)(v14 + 116);
      int v53 = *(_DWORD *)(v14 + 24);
      uint64_t v54 = "H.264";
      if (v53 > 1718908519)
      {
        if (v53 == 1752589105) {
          goto LABEL_101;
        }
        int v55 = 1718908520;
      }
      else
      {
        if (v53 == 1684632424) {
          goto LABEL_101;
        }
        int v55 = 1685481521;
      }
      if (v53 != v55)
      {
LABEL_102:
        *(_DWORD *)buf = 134218754;
        *(void *)&uint8_t buf[4] = v14;
        __int16 v63 = 1024;
        int v64 = v52;
        __int16 v65 = 1024;
        int v66 = v51;
        __int16 v67 = 2080;
        uint64_t v68 = v54;
        CFDictionaryRef v38 = MEMORY[0x1E4F14500];
        int v39 = "VCPDec %p (%dx%d, %s): Decoder failed to set DestinationYCbCrMatrix for color transfer\n";
        goto LABEL_103;
      }
LABEL_101:
      uint64_t v54 = "HEVC";
      goto LABEL_102;
    }
  }
LABEL_71:
  int v56 = *(_DWORD *)(v14 + 24);
  long long v57 = "H.264";
  if (v56 > 1718908519)
  {
    if (v56 != 1752589105)
    {
      int v58 = 1718908520;
LABEL_76:
      if (v56 != v58) {
        goto LABEL_78;
      }
    }
  }
  else if (v56 != 1684632424)
  {
    int v58 = 1685481521;
    goto LABEL_76;
  }
  long long v57 = "HEVC";
LABEL_78:
  snprintf((char *)(v14 + 220), 0x7D0uLL, "VCPDec %p (%dx%d, %s)", (const void *)v14, *(_DWORD *)(v14 + 112), *(_DWORD *)(v14 + 116), v57);
  unint64_t v59 = operator new(0x88uLL, MEMORY[0x1E4FBA2D0]);
  if (!v59)
  {
    *(void *)(v14 + 2224) = 0;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to create stats monitor\n", buf, 2u);
    }
    uint64_t v16 = 4294954392;
    goto LABEL_14;
  }
  unint64_t v60 = v59;
  sub_1BBAC86F0((uint64_t)v59, (uint64_t)sub_1BB9E3830, v14);
  uint64_t v16 = 0;
  *(void *)(v14 + 2224) = v60;
LABEL_20:
  *a6 = v14;
  if (v12) {
    CFRelease(v12);
  }
  return v16;
}

void sub_1BB9E145C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1BB9BE228((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9E1494(const void *a1, CMVideoFormatDescriptionRef videoDesc, const __CFDictionary *a3, const void *a4, _DWORD *a5)
{
  uint64_t v190 = *MEMORY[0x1E4F143B8];
  uint64_t v178 = 0;
  CMVideoDimensions Dimensions = CMVideoFormatDescriptionGetDimensions(videoDesc);
  CFNumberRef v179 = sub_1BB9E4B84;
  CFNumberRef v180 = a5;
  if (a3) {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a3);
  }
  else {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  CFDictionaryRef v10 = MutableCopy;
  CFDictionaryRef theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v10)
  {
    CFTypeRef v173 = a4;
    if (CFDictionaryContainsKey(v10, @"NumberOfTiles"))
    {
      char v11 = a5 + 34;
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v10, @"NumberOfTiles");
      if (Value)
      {
        CFNumberRef v13 = Value;
        CFTypeID v14 = CFGetTypeID(Value);
        if (v14 == CFNumberGetTypeID()) {
          CFNumberGetValue(v13, kCFNumberSInt32Type, a5 + 34);
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int32_t v15 = a5[34];
        buf[0] = 134218240;
        *(void *)&buf[1] = a5;
        __int16 v182 = 1024;
        int32_t width = v15;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got number of tiles video specification: %d\n", (uint8_t *)buf, 0x12u);
      }
      int v16 = *v11;
      if (*v11 <= 1) {
        int v16 = 1;
      }
      *char v11 = v16;
    }
    int v17 = (const void *)*MEMORY[0x1E4F44C58];
    if (CFDictionaryContainsKey(v10, (const void *)*MEMORY[0x1E4F44C58]))
    {
      int v18 = CFDictionaryGetValue(v10, v17);
      int v19 = v18;
      BOOL v20 = v18 && CFGetTypeID(v18) && CFBooleanGetTypeID() && CFEqual(v19, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        buf[0] = 134218240;
        *(void *)&buf[1] = a5;
        __int16 v182 = 1024;
        int32_t width = v20;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got kVTDecompressionPropertyKey_MachThreadPriorityOfConsistentThreadCallingDecodeFrame : %d\n", (uint8_t *)buf, 0x12u);
      }
    }
    CMTimeScale v23 = (const void *)*MEMORY[0x1E4F44C50];
    if (CFDictionaryContainsKey(v10, (const void *)*MEMORY[0x1E4F44C50]))
    {
      LODWORD(valuePtr) = 0;
      CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(v10, v23);
      CFNumberRef v25 = v24;
      if (v24)
      {
        CFTypeID v26 = CFGetTypeID(v24);
        if (v26 == CFNumberGetTypeID()) {
          CFNumberGetValue(v25, kCFNumberSInt32Type, &valuePtr);
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        buf[0] = 134218240;
        *(void *)&buf[1] = a5;
        __int16 v182 = 1024;
        int32_t width = (int)valuePtr;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got kVTDecompressionPropertyKey_MachThreadPriorityForThreadEmittingFrames : %d\n", (uint8_t *)buf, 0x12u);
      }
    }
    if (CFDictionaryContainsKey(v10, @"FrameBufferWidth"))
    {
      CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue(v10, @"FrameBufferWidth");
      CFNumberRef v28 = v27;
      if (v27)
      {
        CFTypeID v29 = CFGetTypeID(v27);
        if (v29 == CFNumberGetTypeID()) {
          CFNumberGetValue(v28, kCFNumberSInt32Type, a5 + 35);
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int32_t v30 = a5[35];
        buf[0] = 134218240;
        *(void *)&buf[1] = a5;
        __int16 v182 = 1024;
        int32_t width = v30;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got buffer width video specification: %d\n", (uint8_t *)buf, 0x12u);
      }
    }
    if (CFDictionaryContainsKey(v10, @"FrameBufferHeight"))
    {
      CFNumberRef v31 = (const __CFNumber *)CFDictionaryGetValue(v10, @"FrameBufferHeight");
      CFNumberRef v32 = v31;
      if (v31)
      {
        CFTypeID v33 = CFGetTypeID(v31);
        if (v33 == CFNumberGetTypeID()) {
          CFNumberGetValue(v32, kCFNumberSInt32Type, a5 + 36);
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int32_t v34 = a5[36];
        buf[0] = 134218240;
        *(void *)&buf[1] = a5;
        __int16 v182 = 1024;
        int32_t width = v34;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got buffer height video specification: %d\n", (uint8_t *)buf, 0x12u);
      }
    }
    int v35 = (const void *)*MEMORY[0x1E4F455D0];
    if (CFDictionaryContainsKey(v10, (const void *)*MEMORY[0x1E4F455D0]))
    {
      uint64_t v36 = CFDictionaryGetValue(v10, v35);
      int v37 = v36;
      BOOL v38 = !v36 || !CFGetTypeID(v36) || !CFBooleanGetTypeID() || CFEqual(v37, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        buf[0] = 134218240;
        *(void *)&buf[1] = a5;
        __int16 v182 = 1024;
        int32_t width = v38;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p: Decoder got enable hardware decoder: %d\n", (uint8_t *)buf, 0x12u);
      }
      int v39 = v38 - 1;
    }
    else
    {
      int v39 = 0;
    }
    int v40 = (const void *)*MEMORY[0x1E4F44D78];
    if (CFDictionaryContainsKey(v10, (const void *)*MEMORY[0x1E4F44D78]))
    {
      int v41 = CFDictionaryGetValue(v10, v40);
      if (v41)
      {
        int v42 = (const void *)*MEMORY[0x1E4F1CFD0];
        if (CFEqual(v41, (CFTypeRef)*MEMORY[0x1E4F1CFD0])) {
          CFDictionaryAddValue(theDict, v40, v42);
        }
      }
    }
    int v43 = a5[34];
    if (v43 >= 2)
    {
      a5[35] = Dimensions.width;
      a5[36] = v43 * Dimensions.height;
      operator new();
    }
    a5[6] = CMFormatDescriptionGetMediaSubType(videoDesc);
    buf[0] = 1;
    CFNumberRef v44 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v44)
    {
      CFDictionaryAddValue(v10, (const void *)*MEMORY[0x1E4F455F8], v44);
      CFRelease(v44);
    }
    int v45 = a5[6];
    if (v45 > 1718908519)
    {
      if (v45 != 1752589105)
      {
        int v46 = 1718908520;
LABEL_65:
        if (v45 != v46) {
          goto LABEL_72;
        }
      }
    }
    else if (v45 != 1684632424)
    {
      int v46 = 1685481521;
      goto LABEL_65;
    }
    CFStringRef v47 = (const __CFString *)CFPreferencesCopyAppValue(@"FaceTimeDecoder", @"com.apple.VideoConference");
    CFStringRef v48 = v47;
    if (v47)
    {
      if (CFStringCompare(v47, @"hw", 0))
      {
        if (CFEqual(v48, @"sw")) {
          int v39 = -1;
        }
      }
      else
      {
        int v39 = 1;
      }
      CFRelease(v48);
    }
LABEL_72:
    if (!CFDictionaryContainsKey(v10, @"DecPixelFormat")) {
      goto LABEL_91;
    }
    CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue(v10, @"DecPixelFormat");
    CFNumberRef v50 = v49;
    if (v49)
    {
      CFTypeID v51 = CFGetTypeID(v49);
      if (v51 == CFNumberGetTypeID()) {
        CFNumberGetValue(v50, kCFNumberSInt32Type, a5 + 38);
      }
    }
    unsigned int v52 = a5[38];
    if (!v52) {
      goto LABEL_91;
    }
    if (v52 == 1111970369)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int v53 = a5[6];
        uint64_t v54 = "H.264";
        if (v53 > 1718908519)
        {
          if (v53 == 1752589105) {
            goto LABEL_89;
          }
          int v55 = 1718908520;
        }
        else
        {
          if (v53 == 1684632424) {
            goto LABEL_89;
          }
          int v55 = 1685481521;
        }
        if (v53 != v55)
        {
LABEL_90:
          buf[0] = 134219778;
          *(void *)&buf[1] = a5;
          __int16 v182 = 1024;
          int32_t width = Dimensions.width;
          __int16 v184 = 1024;
          int32_t height = Dimensions.height;
          __int16 v186 = 2080;
          float v187 = v54;
          __int16 v188 = 1024;
          *(_DWORD *)int v189 = 66;
          *(_WORD *)&v189[4] = 1024;
          *(_DWORD *)&v189[6] = 71;
          *(_WORD *)&v189[10] = 1024;
          *(_DWORD *)&v189[12] = 82;
          *(_WORD *)&v189[16] = 1024;
          *(_DWORD *)&v189[18] = 65;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder got output pixel format: %c%c%c%c\n", (uint8_t *)buf, 0x3Au);
          goto LABEL_91;
        }
LABEL_89:
        uint64_t v54 = "HEVC";
        goto LABEL_90;
      }
LABEL_91:
      if (!CFDictionaryContainsKey(v10, @"DecColorSpace")) {
        goto LABEL_108;
      }
      CFNumberRef v59 = (const __CFNumber *)CFDictionaryGetValue(v10, @"DecColorSpace");
      CFNumberRef v60 = v59;
      if (v59)
      {
        CFTypeID v61 = CFGetTypeID(v59);
        if (v61 == CFNumberGetTypeID()) {
          CFNumberGetValue(v60, kCFNumberSInt32Type, a5 + 37);
        }
      }
      int v62 = a5[37];
      if (!v62) {
        goto LABEL_108;
      }
      if (v62 == 1)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          int v63 = a5[6];
          int v64 = "H.264";
          if (v63 > 1718908519)
          {
            if (v63 == 1752589105) {
              goto LABEL_106;
            }
            int v65 = 1718908520;
          }
          else
          {
            if (v63 == 1684632424) {
              goto LABEL_106;
            }
            int v65 = 1685481521;
          }
          if (v63 != v65)
          {
LABEL_107:
            buf[0] = 134218754;
            *(void *)&buf[1] = a5;
            __int16 v182 = 1024;
            int32_t width = Dimensions.width;
            __int16 v184 = 1024;
            int32_t height = Dimensions.height;
            __int16 v186 = 2080;
            float v187 = v64;
            _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder got color space format P3_D65\n", (uint8_t *)buf, 0x22u);
            goto LABEL_108;
          }
LABEL_106:
          int v64 = "HEVC";
          goto LABEL_107;
        }
LABEL_108:
        CFStringRef v66 = (const __CFString *)CFDictionaryGetValue(a3, @"NegotiationDetails");
        CFDataRef v67 = (const __CFData *)CFDictionaryGetValue(a3, @"NegotiationDetailsBitField");
        CFDataRef v68 = (const __CFData *)CFDictionaryGetValue(a3, @"NegotiatedFLB");
        CFDataRef v69 = v68;
        if (!v66 && !v67 && !v68)
        {
          *((unsigned char *)a5 + 80) = 0;
          if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
          {
LABEL_180:
            int v21 = 0;
            goto LABEL_181;
          }
          int v70 = a5[6];
          uint64_t v71 = "H.264";
          if (v70 > 1718908519)
          {
            if (v70 == 1752589105) {
              goto LABEL_123;
            }
            int v72 = 1718908520;
          }
          else
          {
            if (v70 == 1684632424) {
              goto LABEL_123;
            }
            int v72 = 1685481521;
          }
          if (v70 != v72)
          {
LABEL_124:
            buf[0] = 134218754;
            *(void *)&buf[1] = a5;
            __int16 v182 = 1024;
            int32_t width = Dimensions.width;
            __int16 v184 = 1024;
            int32_t height = Dimensions.height;
            __int16 v186 = 2080;
            float v187 = v71;
            _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder FLS doesn't exist\n", (uint8_t *)buf, 0x22u);
            goto LABEL_180;
          }
LABEL_123:
          uint64_t v71 = "HEVC";
          goto LABEL_124;
        }
        int v21 = (char *)malloc_type_calloc(0x3E9uLL, 1uLL, 0x100004077774924uLL);
        if (v21)
        {
          if (v67)
          {
            sub_1BBAB0D58(v67, "FLBA;", v21, 1000);
            goto LABEL_167;
          }
          if (v69)
          {
            sub_1BBAB0D58(v69, "FLBN;", v21, 1000);
            goto LABEL_167;
          }
          if (CFStringGetCString(v66, v21, 1001, 0)
            || (*((unsigned char *)a5 + 80) = 0, !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)))
          {
LABEL_167:
            if (strcmp(v21, "FLS;") && strcmp(v21, "FLBA;") && strcmp(v21, "FLBN;"))
            {
LABEL_181:
              CFStringRef v92 = (const __CFString *)CFPreferencesCopyAppValue(@"SerializationMode", @"com.apple.VideoProcessing");
              CFStringRef v93 = v92;
              a5[558] = 1;
              if (v92)
              {
                a5[558] = CFStringGetIntValue(v92);
                CFRelease(v93);
              }
              *((CMVideoDimensions *)a5 + 14) = Dimensions;
              *((void *)a5 + 15) = 0;
              *((CMVideoDimensions *)a5 + 16) = Dimensions;
              if (!videoDesc) {
                goto LABEL_216;
              }
              CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(videoDesc, (CFStringRef)*MEMORY[0x1E4F1EE20]);
              if (!Extension) {
                goto LABEL_216;
              }
              int v95 = a5[6];
              if (v95 > 1718908519)
              {
                if (v95 == 1752589105) {
                  goto LABEL_191;
                }
                int v96 = 1718908520;
              }
              else
              {
                if (v95 == 1684632424) {
                  goto LABEL_191;
                }
                int v96 = 1685481521;
              }
              if (v95 == v96)
              {
LABEL_191:
                CFDataRef v97 = (const __CFData *)CFDictionaryGetValue(Extension, @"hvcC");
                if (*((void *)a5 + 294))
                {
LABEL_194:
                  if (v97)
                  {
                    BytePtr = CFDataGetBytePtr(v97);
                    size_t Length = CFDataGetLength(v97);
                    if (sub_1BBAE859C(BytePtr, Length))
                    {
                      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
                      {
                        int v102 = a5[6];
                        CFNumberRef v103 = "H.264";
                        if (v102 > 1718908519)
                        {
                          if (v102 == 1752589105) {
                            goto LABEL_214;
                          }
                          int v104 = 1718908520;
                        }
                        else
                        {
                          if (v102 == 1684632424) {
                            goto LABEL_214;
                          }
                          int v104 = 1685481521;
                        }
                        if (v102 != v104)
                        {
LABEL_215:
                          buf[0] = 134218754;
                          *(void *)&buf[1] = a5;
                          __int16 v182 = 1024;
                          int32_t width = Dimensions.width;
                          __int16 v184 = 1024;
                          int32_t height = Dimensions.height;
                          __int16 v186 = 2080;
                          float v187 = v103;
                          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder could not parse config info!\n", (uint8_t *)buf, 0x22u);
                          goto LABEL_216;
                        }
LABEL_214:
                        CFNumberRef v103 = "HEVC";
                        goto LABEL_215;
                      }
                    }
                  }
LABEL_216:
                  if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
                  {
LABEL_225:
                    if (v39 != -1 || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
                    {
LABEL_235:
                      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_253;
                      }
                      int v120 = a5[6];
                      uint64_t v121 = "H.264";
                      if (v120 > 1718908519)
                      {
                        if (v120 == 1752589105) {
                          goto LABEL_242;
                        }
                        int v122 = 1718908520;
                      }
                      else
                      {
                        if (v120 == 1684632424) {
                          goto LABEL_242;
                        }
                        int v122 = 1685481521;
                      }
                      if (v120 != v122)
                      {
LABEL_243:
                        double v123 = "HW decoder only";
                        buf[0] = 134219522;
                        *(void *)&buf[1] = a5;
                        __int16 v182 = 1024;
                        int32_t width = Dimensions.width;
                        if (v21) {
                          __int16 v124 = v21;
                        }
                        else {
                          __int16 v124 = "";
                        }
                        __int16 v184 = 1024;
                        double v125 = "; forced: HW";
                        int32_t height = Dimensions.height;
                        if (v39 != 1) {
                          double v125 = "";
                        }
                        if (v39 == -1) {
                          double v123 = "no decoder";
                        }
                        __int16 v186 = 2080;
                        float v187 = v121;
                        unsigned __int8 v126 = "; forced: SW";
                        __int16 v188 = 2080;
                        if (v39 != -1) {
                          unsigned __int8 v126 = v125;
                        }
                        *(void *)int v189 = v123;
                        *(_WORD *)&v189[8] = 2082;
                        *(void *)&v189[10] = v124;
                        *(_WORD *)&v189[18] = 2082;
                        *(void *)&v189[20] = v126;
                        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Creating %s; FLS = \"%{public}s\"%{public}s\n",
                          (uint8_t *)buf,
                          0x40u);
LABEL_253:
                        if (v39 != -1)
                        {
                          unsigned int v127 = VTDecompressionSessionCreateWithOptions();
                          unsigned int v128 = v127;
                          uint64_t v129 = v178;
                          if (v178 && !v127 || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_270;
                          }
                          int v130 = a5[6];
                          CFAllocatorRef v131 = "H.264";
                          if (v130 > 1718908519)
                          {
                            if (v130 == 1752589105) {
                              goto LABEL_268;
                            }
                            int v132 = 1718908520;
                          }
                          else
                          {
                            if (v130 == 1684632424) {
                              goto LABEL_268;
                            }
                            int v132 = 1685481521;
                          }
                          if (v130 != v132)
                          {
LABEL_269:
                            buf[0] = 134218754;
                            *(void *)&buf[1] = a5;
                            __int16 v182 = 1024;
                            int32_t width = Dimensions.width;
                            __int16 v184 = 1024;
                            int32_t height = Dimensions.height;
                            __int16 v186 = 2080;
                            float v187 = v131;
                            _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Creating HW decoder was unsuccesful\n", (uint8_t *)buf, 0x22u);
                            uint64_t v129 = v178;
LABEL_270:
                            *((unsigned char *)a5 + 2368) = 0;
                            if (v129 && !v128)
                            {
LABEL_272:
                              uint64_t valuePtr = 0;
                              VTDecompressionSessionCopySupportedPropertyDictionary();
                              if (valuePtr)
                              {
                                CFTypeID v137 = CFGetTypeID(valuePtr);
                                if (v137 == CFDictionaryGetTypeID())
                                {
                                  size_t v138 = (const void *)*MEMORY[0x1E4F44BF8];
                                  if (CFDictionaryContainsKey((CFDictionaryRef)valuePtr, (const void *)*MEMORY[0x1E4F44BF8]))
                                  {
                                    CFDictionaryRef v139 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)valuePtr, v138);
                                    CFDictionaryRef v140 = v139;
                                    if (v139)
                                    {
                                      CFTypeID v141 = CFGetTypeID(v139);
                                      if (v141 == CFDictionaryGetTypeID())
                                      {
                                        if (CFDictionaryContainsKey(v140, (const void *)*MEMORY[0x1E4F45308]))
                                        {
                                          *((unsigned char *)a5 + 2368) = 1;
                                          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
                                          {
                                            buf[0] = 134217984;
                                            *(void *)&buf[1] = a5;
                                            _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p kVTPropertySupportedInPerFrameOptionsKey set\n", (uint8_t *)buf, 0xCu);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_294;
                              }
                              int v142 = a5[6];
                              int v143 = "H.264";
                              if (v142 > 1718908519)
                              {
                                if (v142 == 1752589105) {
                                  goto LABEL_290;
                                }
                                int v144 = 1718908520;
                              }
                              else
                              {
                                if (v142 == 1684632424) {
                                  goto LABEL_290;
                                }
                                int v144 = 1685481521;
                              }
                              if (v142 != v144)
                              {
LABEL_291:
                                BOOL v145 = "";
                                buf[0] = 134219778;
                                if (v21) {
                                  BOOL v145 = v21;
                                }
                                *(void *)&buf[1] = a5;
                                __int16 v182 = 1024;
                                int32_t width = Dimensions.width;
                                __int16 v184 = 1024;
                                int32_t height = Dimensions.height;
                                __int16 v186 = 2080;
                                float v187 = v143;
                                __int16 v188 = 2080;
                                *(void *)int v189 = &unk_1BBB77DF4;
                                *(_WORD *)&v189[8] = 1024;
                                *(_DWORD *)&v189[10] = 1;
                                *(_WORD *)&v189[14] = 2080;
                                *(void *)&v189[16] = "iOS";
                                *(_WORD *)&v189[24] = 2082;
                                *(void *)&v189[26] = v145;
                                _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Created %s video decoder, usage = %d, on %s; FLS = \"%{public}s\"\n",
                                  (uint8_t *)buf,
                                  0x46u);
LABEL_294:
                                sub_1BB9BE1C0(&valuePtr);
                                *((void *)a5 + 2) = v178;
                                *((_WORD *)a5 + 87) = 0;
                                if ((int)a5[34] > 1)
                                {
                                  uint64_t valuePtr = 0;
                                  uint64_t v22 = VTDecompressionSessionCopyProperty();
                                  if (v22)
                                  {
                                    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
                                    {
                                      int v146 = a5[6];
                                      int64_t v147 = "H.264";
                                      if (v146 > 1718908519)
                                      {
                                        if (v146 == 1752589105) {
                                          goto LABEL_363;
                                        }
                                        int v148 = 1718908520;
                                      }
                                      else
                                      {
                                        if (v146 == 1684632424) {
                                          goto LABEL_363;
                                        }
                                        int v148 = 1685481521;
                                      }
                                      if (v146 != v148)
                                      {
LABEL_364:
                                        buf[0] = 134218754;
                                        *(void *)&buf[1] = a5;
                                        __int16 v182 = 1024;
                                        int32_t width = Dimensions.width;
                                        __int16 v184 = 1024;
                                        int32_t height = Dimensions.height;
                                        __int16 v186 = 2080;
                                        float v187 = v147;
                                        uint64_t v163 = MEMORY[0x1E4F14500];
                                        uint64_t v164 = "VCPDec %p (%dx%d, %s): Failed to copy decoder pixel buffer pool\n";
LABEL_373:
                                        uint32_t v165 = 34;
LABEL_374:
                                        _os_log_error_impl(&dword_1BB9B9000, v163, OS_LOG_TYPE_ERROR, v164, (uint8_t *)buf, v165);
                                        goto LABEL_334;
                                      }
LABEL_363:
                                      int64_t v147 = "HEVC";
                                      goto LABEL_364;
                                    }
LABEL_334:
                                    CFRelease(v10);
                                    goto LABEL_335;
                                  }
                                  uint64_t v22 = CVPixelBufferPoolSetMaxBufferAge();
                                  if (valuePtr) {
                                    CFRelease(valuePtr);
                                  }
                                  if (v22)
                                  {
                                    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
                                      goto LABEL_334;
                                    }
                                    int v149 = a5[6];
                                    __int16 v150 = "H.264";
                                    if (v149 > 1718908519)
                                    {
                                      if (v149 == 1752589105) {
                                        goto LABEL_371;
                                      }
                                      int v151 = 1718908520;
                                    }
                                    else
                                    {
                                      if (v149 == 1684632424) {
                                        goto LABEL_371;
                                      }
                                      int v151 = 1685481521;
                                    }
                                    if (v149 != v151)
                                    {
LABEL_372:
                                      buf[0] = 134218754;
                                      *(void *)&buf[1] = a5;
                                      __int16 v182 = 1024;
                                      int32_t width = Dimensions.width;
                                      __int16 v184 = 1024;
                                      int32_t height = Dimensions.height;
                                      __int16 v186 = 2080;
                                      float v187 = v150;
                                      uint64_t v163 = MEMORY[0x1E4F14500];
                                      uint64_t v164 = "VCPDec %p (%dx%d, %s): Failed to set max buffer age of decoder pixel buffer pool\n";
                                      goto LABEL_373;
                                    }
LABEL_371:
                                    __int16 v150 = "HEVC";
                                    goto LABEL_372;
                                  }
                                }
                                if (a1)
                                {
                                  CFRetain(a1);
                                  *((void *)a5 + 6) = a1;
                                }
                                if (videoDesc)
                                {
                                  CFRetain(videoDesc);
                                  *((void *)a5 + 7) = videoDesc;
                                }
                                if (a3)
                                {
                                  CFRetain(a3);
                                  *((void *)a5 + 8) = a3;
                                }
                                if (v173)
                                {
                                  CFRetain(v173);
                                  *((void *)a5 + 9) = v173;
                                }
                                uint64_t v152 = 0;
                                *((unsigned char *)a5 + 94) = 1;
                                int v153 = a5[6];
                                if (v153 > 1718908519)
                                {
                                  if (v153 != 1718908520)
                                  {
                                    int v154 = 1752589105;
LABEL_320:
                                    if (v153 != v154) {
                                      uint64_t v152 = 1;
                                    }
                                  }
                                }
                                else if (v153 != 1684632424)
                                {
                                  int v154 = 1685481521;
                                  goto LABEL_320;
                                }
                                int v155 = sub_1BBAB06D8(v21, 0, 0xFFFFFFFFLL, v152);
                                *((void *)a5 + 286) = v155;
                                *((unsigned char *)a5 + 80) = v155[33];
                                if (v21)
                                {
                                  CFStringRef v156 = (const __CFString *)(*(uint64_t (**)(unsigned char *))(*(void *)v155 + 280))(v155);
                                  CFMutableStringRef v157 = CFStringCreateMutableCopy(0, 0, v156);
                                  v191.length = CFStringGetLength(v157);
                                  v191.id location = 0;
                                  CFStringFindAndReplace(v157, @"VRAE:", @"RVRA1:", v191, 0);
                                  VCPDecompressionSessionSetProperty((uint64_t)a5, @"NegotiationDetails", v157);
                                  CFRelease(v157);
                                  CFRelease(v156);
                                }
                                if (a5[574]) {
                                  sub_1BB9E43A0((uint64_t)a5);
                                }
                                uint64_t v22 = 0;
                                goto LABEL_334;
                              }
LABEL_290:
                              int v143 = "HEVC";
                              goto LABEL_291;
                            }
                            if (v128) {
                              uint64_t v22 = v128;
                            }
                            else {
                              uint64_t v22 = 4294954392;
                            }
LABEL_333:
                            if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
                              goto LABEL_334;
                            }
                            int v159 = a5[6];
                            unint64_t v160 = "H.264";
                            if (v159 > 1718908519)
                            {
                              if (v159 == 1752589105) {
                                goto LABEL_347;
                              }
                              int v161 = 1718908520;
                            }
                            else
                            {
                              if (v159 == 1684632424) {
                                goto LABEL_347;
                              }
                              int v161 = 1685481521;
                            }
                            if (v159 != v161)
                            {
LABEL_348:
                              uint64_t v162 = "";
                              buf[0] = 134219778;
                              if (v21) {
                                uint64_t v162 = v21;
                              }
                              *(void *)&buf[1] = a5;
                              __int16 v182 = 1024;
                              int32_t width = Dimensions.width;
                              __int16 v184 = 1024;
                              int32_t height = Dimensions.height;
                              __int16 v186 = 2080;
                              float v187 = v160;
                              __int16 v188 = 1024;
                              *(_DWORD *)int v189 = 1;
                              *(_WORD *)&v189[4] = 2080;
                              *(void *)&v189[6] = "iOS";
                              *(_WORD *)&v189[14] = 1024;
                              *(_DWORD *)&v189[16] = v128;
                              *(_WORD *)&v189[20] = 2082;
                              *(void *)&v189[22] = v162;
                              uint64_t v163 = MEMORY[0x1E4F14500];
                              uint64_t v164 = "VCPDec %p (%dx%d, %s): Failed to create video decoder - check dec creation matrix f"
                                     "or root cause, usage = %d, on %s, err = %d; FLS = \"%{public}s\"\n";
                              uint32_t v165 = 66;
                              goto LABEL_374;
                            }
LABEL_347:
                            unint64_t v160 = "HEVC";
                            goto LABEL_348;
                          }
LABEL_268:
                          CFAllocatorRef v131 = "HEVC";
                          goto LABEL_269;
                        }
                        uint64_t v133 = v178;
                        *((unsigned char *)a5 + 2368) = 0;
                        if (v133) {
                          goto LABEL_272;
                        }
                        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
                        {
LABEL_332:
                          unsigned int v128 = 0;
                          uint64_t v22 = 4294954392;
                          goto LABEL_333;
                        }
                        int v134 = a5[6];
                        double v135 = "H.264";
                        if (v134 > 1718908519)
                        {
                          if (v134 == 1752589105) {
                            goto LABEL_330;
                          }
                          int v136 = 1718908520;
                        }
                        else
                        {
                          if (v134 == 1684632424) {
                            goto LABEL_330;
                          }
                          int v136 = 1685481521;
                        }
                        if (v134 != v136)
                        {
LABEL_331:
                          buf[0] = 134218754;
                          *(void *)&buf[1] = a5;
                          __int16 v182 = 1024;
                          int32_t width = Dimensions.width;
                          __int16 v184 = 1024;
                          int32_t height = Dimensions.height;
                          __int16 v186 = 2080;
                          float v187 = v135;
                          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): No forced SW decoder allowed\n", (uint8_t *)buf, 0x22u);
                          goto LABEL_332;
                        }
LABEL_330:
                        double v135 = "HEVC";
                        goto LABEL_331;
                      }
LABEL_242:
                      uint64_t v121 = "HEVC";
                      goto LABEL_243;
                    }
                    int v117 = a5[6];
                    CFNumberRef v118 = "H.264";
                    if (v117 > 1718908519)
                    {
                      if (v117 == 1752589105) {
                        goto LABEL_233;
                      }
                      int v119 = 1718908520;
                    }
                    else
                    {
                      if (v117 == 1684632424) {
                        goto LABEL_233;
                      }
                      int v119 = 1685481521;
                    }
                    if (v117 != v119)
                    {
LABEL_234:
                      buf[0] = 134218754;
                      *(void *)&buf[1] = a5;
                      __int16 v182 = 1024;
                      int32_t width = Dimensions.width;
                      __int16 v184 = 1024;
                      int32_t height = Dimensions.height;
                      __int16 v186 = 2080;
                      float v187 = v118;
                      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Disabling HW dec because of forced SW request\n", (uint8_t *)buf, 0x22u);
                      goto LABEL_235;
                    }
LABEL_233:
                    CFNumberRef v118 = "HEVC";
                    goto LABEL_234;
                  }
                  int v114 = a5[6];
                  unsigned int v115 = "H.264";
                  if (v114 > 1718908519)
                  {
                    if (v114 == 1752589105) {
                      goto LABEL_223;
                    }
                    int v116 = 1718908520;
                  }
                  else
                  {
                    if (v114 == 1684632424) {
                      goto LABEL_223;
                    }
                    int v116 = 1685481521;
                  }
                  if (v114 != v116)
                  {
LABEL_224:
                    buf[0] = 134218754;
                    *(void *)&buf[1] = a5;
                    __int16 v182 = 1024;
                    int32_t width = Dimensions.width;
                    __int16 v184 = 1024;
                    int32_t height = Dimensions.height;
                    __int16 v186 = 2080;
                    float v187 = v115;
                    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Detected embedded system capable of HW AVD decoding\n", (uint8_t *)buf, 0x22u);
                    goto LABEL_225;
                  }
LABEL_223:
                  unsigned int v115 = "HEVC";
                  goto LABEL_224;
                }
                CFTypeID v98 = operator new(0x630uLL, MEMORY[0x1E4FBA2D0]);
                if (v98)
                {
                  int v99 = v98;
                  bzero(v98, 0x630uLL);
                  *((void *)a5 + 294) = v99;
                  goto LABEL_194;
                }
                *((void *)a5 + 294) = 0;
                if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
                {
LABEL_210:
                  uint64_t v22 = 4294967188;
                  goto LABEL_334;
                }
                int32_t v167 = a5[28];
                int32_t v166 = a5[29];
                int v171 = a5[6];
                float v169 = "H.264";
                if (v171 > 1718908519)
                {
                  if (v171 == 1752589105) {
                    goto LABEL_378;
                  }
                  int v172 = 1718908520;
                }
                else
                {
                  if (v171 == 1684632424) {
                    goto LABEL_378;
                  }
                  int v172 = 1685481521;
                }
                if (v171 != v172)
                {
LABEL_379:
                  buf[0] = 134219010;
                  *(void *)&buf[1] = a5;
                  __int16 v182 = 1024;
                  int32_t width = v167;
                  __int16 v184 = 1024;
                  int32_t height = v166;
                  __int16 v186 = 2080;
                  float v187 = v169;
                  __int16 v188 = 1024;
                  uint64_t v22 = 4294967188;
                  *(_DWORD *)int v189 = -108;
                  uint64_t v163 = MEMORY[0x1E4F14500];
                  uint64_t v164 = "VCPDec %p (%dx%d, %s): Decoder failed to create the parameter_sets, err = %d\n";
                  uint32_t v165 = 40;
                  goto LABEL_374;
                }
LABEL_378:
                float v169 = "HEVC";
                goto LABEL_379;
              }
              CFDataRef v105 = (const __CFData *)CFDictionaryGetValue(Extension, @"avcC");
              if (*((void *)a5 + 295))
              {
LABEL_203:
                if (!v105) {
                  goto LABEL_216;
                }
                CFTypeID v108 = CFDataGetBytePtr(v105);
                CFIndex v109 = CFDataGetLength(v105);
                if (!sub_1BBAE8AF4((uint64_t)v108, v109, (uint64_t)(a5 + 28), *((void *)a5 + 295), v110, v111)|| !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
                {
                  goto LABEL_216;
                }
                int v112 = a5[6];
                CFNumberRef v103 = "H.264";
                if (v112 > 1718908519)
                {
                  if (v112 == 1752589105) {
                    goto LABEL_358;
                  }
                  int v113 = 1718908520;
                }
                else
                {
                  if (v112 == 1684632424) {
                    goto LABEL_358;
                  }
                  int v113 = 1685481521;
                }
                if (v112 != v113) {
                  goto LABEL_215;
                }
LABEL_358:
                CFNumberRef v103 = "HEVC";
                goto LABEL_215;
              }
              CFNumberRef v106 = operator new(0x1220uLL, MEMORY[0x1E4FBA2D0]);
              if (v106)
              {
                CFNumberRef v107 = v106;
                bzero(v106, 0x1220uLL);
                *((void *)a5 + 295) = v107;
                goto LABEL_203;
              }
              *((void *)a5 + 295) = 0;
              if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
                goto LABEL_210;
              }
              int32_t v167 = a5[28];
              int32_t v166 = a5[29];
              int v168 = a5[6];
              float v169 = "H.264";
              if (v168 > 1718908519)
              {
                if (v168 == 1752589105) {
                  goto LABEL_383;
                }
                int v170 = 1718908520;
              }
              else
              {
                if (v168 == 1684632424) {
                  goto LABEL_383;
                }
                int v170 = 1685481521;
              }
              if (v168 != v170) {
                goto LABEL_379;
              }
LABEL_383:
              float v169 = "HEVC";
              goto LABEL_379;
            }
            if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_179;
            }
            int v89 = a5[6];
            uint64_t v90 = "H.264";
            if (v89 > 1718908519)
            {
              if (v89 == 1752589105) {
                goto LABEL_177;
              }
              int v91 = 1718908520;
            }
            else
            {
              if (v89 == 1684632424) {
                goto LABEL_177;
              }
              int v91 = 1685481521;
            }
            if (v89 != v91)
            {
LABEL_178:
              buf[0] = 134219010;
              *(void *)&buf[1] = a5;
              __int16 v182 = 1024;
              int32_t width = Dimensions.width;
              __int16 v184 = 1024;
              int32_t height = Dimensions.height;
              __int16 v186 = 2080;
              float v187 = v90;
              __int16 v188 = 2082;
              *(void *)int v189 = v21;
              _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Changing empty decoder FLS = \"%{public}s\" to FLS = \"\"\n", (uint8_t *)buf, 0x2Cu);
LABEL_179:
              *((unsigned char *)a5 + 80) = 0;
              free(v21);
              goto LABEL_180;
            }
LABEL_177:
            uint64_t v90 = "HEVC";
            goto LABEL_178;
          }
          int v77 = a5[6];
          int v78 = "H.264";
          if (v77 > 1718908519)
          {
            if (v77 == 1752589105) {
              goto LABEL_165;
            }
            int v79 = 1718908520;
          }
          else
          {
            if (v77 == 1684632424) {
              goto LABEL_165;
            }
            int v79 = 1685481521;
          }
          if (v77 != v79)
          {
LABEL_166:
            buf[0] = 134218754;
            *(void *)&buf[1] = a5;
            __int16 v182 = 1024;
            int32_t width = Dimensions.width;
            __int16 v184 = 1024;
            int32_t height = Dimensions.height;
            __int16 v186 = 2080;
            float v187 = v78;
            _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder could not get FLS!\n", (uint8_t *)buf, 0x22u);
            goto LABEL_167;
          }
LABEL_165:
          int v78 = "HEVC";
          goto LABEL_166;
        }
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          int v21 = 0;
          uint64_t v22 = 4294954392;
          goto LABEL_334;
        }
        int v83 = a5[6];
        int v84 = "H.264";
        if (v83 > 1718908519)
        {
          if (v83 == 1752589105) {
            goto LABEL_160;
          }
          int v85 = 1718908520;
        }
        else
        {
          if (v83 == 1684632424) {
            goto LABEL_160;
          }
          int v85 = 1685481521;
        }
        if (v83 != v85)
        {
LABEL_161:
          buf[0] = 134219010;
          *(void *)&buf[1] = a5;
          __int16 v182 = 1024;
          int32_t width = Dimensions.width;
          __int16 v184 = 1024;
          int32_t height = Dimensions.height;
          __int16 v186 = 2080;
          float v187 = v84;
          __int16 v188 = 1024;
          uint64_t v22 = 4294954392;
          *(_DWORD *)int v189 = -12904;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Decoder failed to create an FLS, err = %d", (uint8_t *)buf, 0x28u);
          int v21 = 0;
          goto LABEL_334;
        }
LABEL_160:
        int v84 = "HEVC";
        goto LABEL_161;
      }
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
LABEL_102:
        int v21 = 0;
        uint64_t v22 = 4294954394;
        goto LABEL_334;
      }
      int v80 = a5[6];
      unint64_t v81 = "H.264";
      if (v80 > 1718908519)
      {
        if (v80 == 1752589105) {
          goto LABEL_154;
        }
        int v82 = 1718908520;
      }
      else
      {
        if (v80 == 1684632424) {
          goto LABEL_154;
        }
        int v82 = 1685481521;
      }
      if (v80 != v82)
      {
LABEL_155:
        buf[0] = 134219010;
        *(void *)&buf[1] = a5;
        __int16 v182 = 1024;
        int32_t width = Dimensions.width;
        __int16 v184 = 1024;
        int32_t height = Dimensions.height;
        __int16 v186 = 2080;
        float v187 = v81;
        __int16 v188 = 1024;
        *(_DWORD *)int v189 = v62;
        int v86 = MEMORY[0x1E4F14500];
        unsigned __int16 v87 = "VCPDec %p (%dx%d, %s): Decoder failed to support color space, which is %d\n";
        uint32_t v88 = 40;
        goto LABEL_156;
      }
LABEL_154:
      unint64_t v81 = "HEVC";
      goto LABEL_155;
    }
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_102;
    }
    int v56 = a5[6];
    long long v57 = "H.264";
    if (v56 > 1718908519)
    {
      if (v56 == 1752589105) {
        goto LABEL_149;
      }
      int v58 = 1718908520;
    }
    else
    {
      if (v56 == 1684632424) {
        goto LABEL_149;
      }
      int v58 = 1685481521;
    }
    if (v56 != v58)
    {
LABEL_150:
      buf[0] = 134219778;
      *(void *)&buf[1] = a5;
      __int16 v182 = 1024;
      int32_t width = Dimensions.width;
      __int16 v184 = 1024;
      int32_t height = Dimensions.height;
      __int16 v186 = 2080;
      float v187 = v57;
      __int16 v188 = 1024;
      *(_DWORD *)int v189 = HIBYTE(v52);
      *(_WORD *)&v189[4] = 1024;
      *(_DWORD *)&v189[6] = BYTE2(v52);
      *(_WORD *)&v189[10] = 1024;
      *(_DWORD *)&v189[12] = BYTE1(v52);
      *(_WORD *)&v189[16] = 1024;
      *(_DWORD *)&v189[18] = v52;
      int v86 = MEMORY[0x1E4F14500];
      unsigned __int16 v87 = "VCPDec %p (%dx%d, %s): Decoder failed to support pixel format, which is %c%c%c%c\n";
      uint32_t v88 = 58;
LABEL_156:
      _os_log_error_impl(&dword_1BB9B9000, v86, OS_LOG_TYPE_ERROR, v87, (uint8_t *)buf, v88);
      goto LABEL_102;
    }
LABEL_149:
    long long v57 = "HEVC";
    goto LABEL_150;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    int v73 = a5[6];
    int v74 = "H.264";
    if (v73 > 1718908519)
    {
      CFDictionaryRef v75 = theDict;
      if (v73 == 1752589105) {
        goto LABEL_138;
      }
      int v76 = 1718908520;
    }
    else
    {
      CFDictionaryRef v75 = theDict;
      if (v73 == 1684632424) {
        goto LABEL_138;
      }
      int v76 = 1685481521;
    }
    if (v73 != v76)
    {
LABEL_139:
      buf[0] = 134219010;
      *(void *)&buf[1] = a5;
      __int16 v182 = 1024;
      int32_t width = Dimensions.width;
      __int16 v184 = 1024;
      int32_t height = Dimensions.height;
      __int16 v186 = 2080;
      float v187 = v74;
      __int16 v188 = 1024;
      uint64_t v22 = 4294954392;
      *(_DWORD *)int v189 = -12904;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Failed to create decoder specification copy, err = %d\n", (uint8_t *)buf, 0x28u);
      int v21 = 0;
      goto LABEL_336;
    }
LABEL_138:
    int v74 = "HEVC";
    goto LABEL_139;
  }
  int v21 = 0;
  uint64_t v22 = 4294954392;
LABEL_335:
  CFDictionaryRef v75 = theDict;
LABEL_336:
  if (v75) {
    CFRelease(v75);
  }
  if (v21) {
    free(v21);
  }
  return v22;
}

void sub_1BB9E37AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1BB9BE1C0((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1BB9E3830(uint64_t a1, double a2)
{
  uint64_t v160 = *MEMORY[0x1E4F143B8];
  if (a2 > 0.0)
  {
    if (!a1)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_WORD *)__str = 0;
      CFNumberRef v49 = MEMORY[0x1E4F14500];
      CFNumberRef v50 = "Empty callback refcon in VCPDecStatsMonitorCallback()\n";
      CFTypeID v51 = (uint8_t *)__str;
      uint32_t v52 = 2;
      goto LABEL_213;
    }
    uint64_t v4 = *(void *)(a1 + 2224);
    int v7 = *(void **)(v4 + 32);
    uint64_t v6 = (double *)(v4 + 32);
    uint64_t v5 = v7;
    double v8 = 0.0;
    double v9 = 0.0;
    if (!v7) {
      goto LABEL_72;
    }
    CFDictionaryRef v10 = v6;
    char v11 = v5;
    do
    {
      unint64_t v12 = v11[4];
      BOOL v13 = v12 >= (unint64_t)"input_frames";
      if (v12 >= (unint64_t)"input_frames") {
        CFTypeID v14 = v11;
      }
      else {
        CFTypeID v14 = v11 + 1;
      }
      if (v13) {
        CFDictionaryRef v10 = (double *)v11;
      }
      char v11 = (void *)*v14;
    }
    while (*v14);
    double v9 = 0.0;
    if (v10 != v6 && *((void *)v10 + 4) <= (unint64_t)"input_frames") {
      double v9 = v10[5];
    }
    if (v5)
    {
      int32_t v15 = v6;
      int v16 = v5;
      do
      {
        unint64_t v17 = v16[4];
        BOOL v18 = v17 >= (unint64_t)"decoded_frames";
        if (v17 >= (unint64_t)"decoded_frames") {
          int v19 = v16;
        }
        else {
          int v19 = v16 + 1;
        }
        if (v18) {
          int32_t v15 = (double *)v16;
        }
        int v16 = (void *)*v19;
      }
      while (*v19);
      double v20 = 0.0;
      if (v15 != v6 && *((void *)v15 + 4) <= (unint64_t)"decoded_frames") {
        double v20 = v15[5];
      }
      int v21 = v6;
      uint64_t v22 = v5;
      do
      {
        unint64_t v23 = v22[4];
        BOOL v24 = v23 >= (unint64_t)"transmit_frames";
        if (v23 >= (unint64_t)"transmit_frames") {
          CFNumberRef v25 = v22;
        }
        else {
          CFNumberRef v25 = v22 + 1;
        }
        if (v24) {
          int v21 = (double *)v22;
        }
        uint64_t v22 = (void *)*v25;
      }
      while (*v25);
      double v26 = 0.0;
      double v27 = 0.0;
      if (v21 != v6 && *((void *)v21 + 4) <= (unint64_t)"transmit_frames") {
        double v27 = v21[5];
      }
      CFNumberRef v28 = v6;
      CFTypeID v29 = v5;
      do
      {
        unint64_t v30 = v29[4];
        BOOL v31 = v30 >= (unint64_t)"decoding_time";
        if (v30 >= (unint64_t)"decoding_time") {
          CFNumberRef v32 = v29;
        }
        else {
          CFNumberRef v32 = v29 + 1;
        }
        if (v31) {
          CFNumberRef v28 = (double *)v29;
        }
        CFTypeID v29 = (void *)*v32;
      }
      while (*v32);
      if (v28 != v6 && *((void *)v28 + 4) <= (unint64_t)"decoding_time") {
        double v26 = v28[5];
      }
      BOOL v33 = v20 > 0.0;
      double v34 = 0.0;
      double v35 = 0.0;
      double v8 = 0.0;
      if (v20 > 0.0)
      {
        uint64_t v36 = v6;
        int v37 = v5;
        do
        {
          unint64_t v38 = v37[4];
          BOOL v39 = v38 >= (unint64_t)"vra_width";
          if (v38 >= (unint64_t)"vra_width") {
            int v40 = v37;
          }
          else {
            int v40 = v37 + 1;
          }
          if (v39) {
            uint64_t v36 = (double *)v37;
          }
          int v37 = (void *)*v40;
        }
        while (*v40);
        double v41 = 0.0;
        double v42 = 0.0;
        if (v36 != v6 && *((void *)v36 + 4) <= (unint64_t)"vra_width") {
          double v42 = v36[5];
        }
        double v35 = v42 / v20;
        int v43 = v6;
        CFNumberRef v44 = v5;
        do
        {
          unint64_t v45 = v44[4];
          BOOL v46 = v45 >= (unint64_t)"vra_height";
          if (v45 >= (unint64_t)"vra_height") {
            CFStringRef v47 = v44;
          }
          else {
            CFStringRef v47 = v44 + 1;
          }
          if (v46) {
            int v43 = (double *)v44;
          }
          CFNumberRef v44 = (void *)*v47;
        }
        while (*v47);
        if (v43 != v6 && *((void *)v43 + 4) <= (unint64_t)"vra_height") {
          double v41 = v43[5];
        }
        double v34 = v41 / v20;
        double v8 = v26 / v20 * 1000.0;
      }
      double v129 = v20 / a2;
      double v130 = v9 / a2;
      double v48 = v27 / a2;
      int v53 = v6;
      uint64_t v54 = v5;
      do
      {
        unint64_t v55 = v54[4];
        BOOL v56 = v55 >= (unint64_t)"sei";
        if (v55 >= (unint64_t)"sei") {
          long long v57 = v54;
        }
        else {
          long long v57 = v54 + 1;
        }
        if (v56) {
          int v53 = (double *)v54;
        }
        uint64_t v54 = (void *)*v57;
      }
      while (*v57);
      double v58 = 0.0;
      if (v53 != v6 && *((void *)v53 + 4) <= (unint64_t)"sei") {
        double v58 = v53[5];
      }
      if (v20 > 0.0)
      {
        double v59 = v58 * 8.0 / a2;
        CFNumberRef v60 = v6;
        CFTypeID v61 = v5;
        do
        {
          unint64_t v62 = v61[4];
          BOOL v63 = v62 >= (unint64_t)"slice_qp0";
          if (v62 >= (unint64_t)"slice_qp0") {
            int v64 = v61;
          }
          else {
            int v64 = v61 + 1;
          }
          if (v63) {
            CFNumberRef v60 = (double *)v61;
          }
          CFTypeID v61 = (void *)*v64;
        }
        while (*v64);
        double v65 = 0.0;
        if (v60 != v6 && *((void *)v60 + 4) <= (unint64_t)"slice_qp0") {
          double v65 = v60[5];
        }
        CFStringRef v66 = v6;
        CFDataRef v67 = v5;
        do
        {
          unint64_t v68 = v67[4];
          BOOL v69 = v68 >= (unint64_t)"slice_qp1";
          if (v68 >= (unint64_t)"slice_qp1") {
            int v70 = v67;
          }
          else {
            int v70 = v67 + 1;
          }
          if (v69) {
            CFStringRef v66 = (double *)v67;
          }
          CFDataRef v67 = (void *)*v70;
        }
        while (*v70);
        uint64_t v71 = 0;
        if (v66 != v6 && *((void *)v66 + 4) <= (unint64_t)"slice_qp1") {
          uint64_t v71 = *((void *)v66 + 5);
        }
        uint64_t v156 = v71;
        int v72 = v6;
        int v73 = v5;
        do
        {
          unint64_t v74 = v73[4];
          BOOL v75 = v74 >= (unint64_t)"slice_qp2";
          if (v74 >= (unint64_t)"slice_qp2") {
            int v76 = v73;
          }
          else {
            int v76 = v73 + 1;
          }
          if (v75) {
            int v72 = (double *)v73;
          }
          int v73 = (void *)*v76;
        }
        while (*v76);
        uint64_t v77 = 0;
        if (v72 != v6 && *((void *)v72 + 4) <= (unint64_t)"slice_qp2") {
          uint64_t v77 = *((void *)v72 + 5);
        }
        uint64_t v157 = v77;
        int v78 = v6;
        int v79 = v5;
        do
        {
          unint64_t v80 = v79[4];
          BOOL v81 = v80 >= (unint64_t)"slice_qp3";
          if (v80 >= (unint64_t)"slice_qp3") {
            int v82 = v79;
          }
          else {
            int v82 = v79 + 1;
          }
          if (v81) {
            int v78 = (double *)v79;
          }
          int v79 = (void *)*v82;
        }
        while (*v82);
        uint64_t v83 = 0;
        if (v78 != v6 && *((void *)v78 + 4) <= (unint64_t)"slice_qp3") {
          uint64_t v83 = *((void *)v78 + 5);
        }
        uint64_t v158 = v83;
        int v84 = v6;
        int v85 = v5;
        do
        {
          unint64_t v86 = v85[4];
          BOOL v87 = v86 >= (unint64_t)"slice_size0";
          if (v86 >= (unint64_t)"slice_size0") {
            uint32_t v88 = v85;
          }
          else {
            uint32_t v88 = v85 + 1;
          }
          if (v87) {
            int v84 = (double *)v85;
          }
          int v85 = (void *)*v88;
        }
        while (*v88);
        double v89 = 0.0;
        if (v84 != v6 && *((void *)v84 + 4) <= (unint64_t)"slice_size0") {
          double v89 = v84[5];
        }
        uint64_t v90 = v6;
        int v91 = v5;
        do
        {
          unint64_t v92 = v91[4];
          BOOL v93 = v92 >= (unint64_t)"slice_size1";
          if (v92 >= (unint64_t)"slice_size1") {
            double v94 = v91;
          }
          else {
            double v94 = v91 + 1;
          }
          if (v93) {
            uint64_t v90 = (double *)v91;
          }
          int v91 = (void *)*v94;
        }
        while (*v94);
        uint64_t v95 = 0;
        if (v90 != v6 && *((void *)v90 + 4) <= (unint64_t)"slice_size1") {
          uint64_t v95 = *((void *)v90 + 5);
        }
        uint64_t v152 = v95;
        int v96 = v6;
        CFDataRef v97 = v5;
        do
        {
          unint64_t v98 = v97[4];
          BOOL v99 = v98 >= (unint64_t)"slice_size2";
          if (v98 >= (unint64_t)"slice_size2") {
            CFNumberRef v100 = v97;
          }
          else {
            CFNumberRef v100 = v97 + 1;
          }
          if (v99) {
            int v96 = (double *)v97;
          }
          CFDataRef v97 = (void *)*v100;
        }
        while (*v100);
        uint64_t v101 = 0;
        uint64_t v102 = 0;
        if (v96 != v6 && *((void *)v96 + 4) <= (unint64_t)"slice_size2") {
          uint64_t v102 = *((void *)v96 + 5);
        }
        uint64_t v153 = v102;
        CFNumberRef v103 = v6;
        do
        {
          unint64_t v104 = v5[4];
          BOOL v105 = v104 >= (unint64_t)"slice_size3";
          if (v104 >= (unint64_t)"slice_size3") {
            CFNumberRef v106 = v5;
          }
          else {
            CFNumberRef v106 = v5 + 1;
          }
          if (v105) {
            CFNumberRef v103 = (double *)v5;
          }
          uint64_t v5 = (void *)*v106;
        }
        while (*v106);
        if (v103 != v6 && *((void *)v103 + 4) <= (unint64_t)"slice_size3") {
          uint64_t v101 = *((void *)v103 + 5);
        }
        uint64_t v154 = v101;
        if (v65 <= 0.0) {
          int v107 = 0;
        }
        else {
          int v107 = snprintf(__str, 0x7D0uLL, ", slice_qp = %.2f", v65 / v20);
        }
        for (uint64_t i = 8; i != 32; i += 8)
        {
          double v109 = *(double *)&v155[i];
          if (v109 > 0.0) {
            v107 += snprintf(&__str[v107], 2000 - v107, "/%.2f", v109 / v20);
          }
        }
        double v110 = 0.0;
        if (v89 > 0.0)
        {
          v107 += snprintf(&__str[v107], 2000 - v107, ", slice_bps = %.0f", v89 * 8.0 / a2);
          double v110 = v89 * 8.0 / a2 + 0.0;
        }
        for (uint64_t j = 8; j != 32; j += 8)
        {
          double v112 = *(double *)&v151[j];
          if (v112 > 0.0)
          {
            double v113 = v112 * 8.0 / a2;
            v107 += snprintf(&__str[v107], 2000 - v107, "/%.0f", v113);
            double v110 = v110 + v113;
          }
        }
        if (v59 > 0.0)
        {
          v107 += snprintf(&__str[v107], 2000 - v107, ", SEI_bps = %.0f", v59);
          double v110 = v59 + v110;
        }
        snprintf(&__str[v107], 2000 - v107, ", total_bps = %.0f", v110);
      }
    }
    else
    {
LABEL_72:
      BOOL v33 = 0;
      double v48 = 0.0 / a2;
      double v129 = 0.0 / a2;
      double v130 = v9 / a2;
      double v35 = 0.0;
      double v34 = 0.0;
    }
    if ((*(unsigned char *)(a1 + 2296) & 1) == 0)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 136448002;
      uint64_t v132 = a1 + 220;
      int v114 = __str;
      __int16 v133 = 2048;
      if (!v33) {
        int v114 = "";
      }
      double v134 = v130;
      __int16 v135 = 2048;
      double v136 = v129;
      __int16 v137 = 2048;
      double v138 = v48;
      __int16 v139 = 2048;
      double v140 = v8;
      __int16 v141 = 2048;
      double v142 = v35;
      __int16 v143 = 2048;
      double v144 = v34;
      __int16 v145 = 2080;
      double v146 = *(double *)&v114;
      CFNumberRef v49 = MEMORY[0x1E4F14500];
      CFNumberRef v50 = "[VCPDecStatsMonitor] %{public}s: Input_fps=%.2f, Dec_fps=%.2f, Tx_fps=%.2f, Dec_time=%.2f ms, VRA=%.0fx%.0f%s\n";
      CFTypeID v51 = buf;
      uint32_t v52 = 82;
      goto LABEL_213;
    }
    unsigned int v115 = *(void **)v6;
    double v116 = 0.0;
    if (!*(void *)v6) {
      goto LABEL_208;
    }
    int v117 = v6;
    CFNumberRef v118 = *(void **)v6;
    do
    {
      unint64_t v119 = v118[4];
      BOOL v120 = v119 >= (unint64_t)"ml_enhanced_frames";
      if (v119 >= (unint64_t)"ml_enhanced_frames") {
        uint64_t v121 = v118;
      }
      else {
        uint64_t v121 = v118 + 1;
      }
      if (v120) {
        int v117 = (double *)v118;
      }
      CFNumberRef v118 = (void *)*v121;
    }
    while (*v121);
    if (v117 != v6 && *((void *)v117 + 4) <= (unint64_t)"ml_enhanced_frames")
    {
      double v122 = v117[5];
      if (v122 > 0.0)
      {
        __int16 v124 = v6;
        do
        {
          unint64_t v125 = v115[4];
          BOOL v126 = v125 >= (unint64_t)"ml_enhance_time";
          if (v125 >= (unint64_t)"ml_enhance_time") {
            unsigned int v127 = v115;
          }
          else {
            unsigned int v127 = v115 + 1;
          }
          if (v126) {
            __int16 v124 = (double *)v115;
          }
          unsigned int v115 = (void *)*v127;
        }
        while (*v127);
        double v128 = 0.0;
        if (v124 != v6 && *((void *)v124 + 4) <= (unint64_t)"ml_enhance_time") {
          double v128 = v124[5];
        }
        double v116 = v128 / v122 * 1000.0;
      }
    }
    else
    {
LABEL_208:
      double v122 = 0.0;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136448514;
      uint64_t v132 = a1 + 220;
      __int16 v133 = 2048;
      double v134 = v130;
      __int16 v135 = 2048;
      double v136 = v129;
      __int16 v137 = 2048;
      double v138 = v48;
      __int16 v139 = 2048;
      double v140 = v122 / a2;
      __int16 v141 = 2048;
      double v142 = v8;
      __int16 v143 = 2048;
      double v144 = v116;
      double v123 = "";
      __int16 v145 = 2048;
      double v146 = v35;
      if (v33) {
        double v123 = __str;
      }
      __int16 v147 = 2048;
      double v148 = v34;
      __int16 v149 = 2080;
      __int16 v150 = v123;
      CFNumberRef v49 = MEMORY[0x1E4F14500];
      CFNumberRef v50 = "[VCPDecStatsMonitor] %{public}s: Input_fps=%.2f, Dec_fps=%.2f, Tx_fps=%.2f, ML_fps=%.2f, Dec_time=%.2f ms, M"
            "L_time=%.2f ms, VRA=%.0fx%.0f%s\n";
      CFTypeID v51 = buf;
      uint32_t v52 = 102;
LABEL_213:
      _os_log_impl(&dword_1BB9B9000, v49, OS_LOG_TYPE_DEFAULT, v50, v51, v52);
    }
  }
}

uint64_t VCPDecompressionSessionSetProperty(uint64_t a1, CFStringRef theString1, const void *a3)
{
  if (a1)
  {
    if (CFStringCompare(theString1, @"FaceZoom", 0))
    {
      if (CFStringCompare(theString1, @"MLEnhance", 0))
      {
        return VTDecompressionSessionSetProperty();
      }
      else
      {
        CFTypeID v9 = CFGetTypeID(a3);
        if (v9 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a3))
        {
          return sub_1BB9E43A0(a1);
        }
        else
        {
          sub_1BB9E4A5C((_DWORD *)a1);
          return 0;
        }
      }
    }
    else
    {
      CFTypeID v7 = CFGetTypeID(a3);
      BOOL v8 = v7 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a3) != 0;
      uint64_t result = 0;
      *(unsigned char *)(a1 + 93) = v8;
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFDictionaryRef v10 = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDecompressionSessionSetProperty: vcpSession is NULL", v10, 2u);
    }
    return 4294954394;
  }
  return result;
}

uint64_t sub_1BB9E43A0(uint64_t a1)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(_DWORD **)(a1 + 2288);
  if (v2[10] == 1 && !(*(unsigned int (**)(_DWORD *))(*(void *)v2 + 128))(v2)) {
    return 4294954386;
  }
  if (qword_1E9F813A0 != -1) {
    dispatch_once(&qword_1E9F813A0, &unk_1F14EF280);
  }
  if (!byte_1E9F81398)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    int v29 = *(_DWORD *)(a1 + 112);
    int v28 = *(_DWORD *)(a1 + 116);
    int v30 = *(_DWORD *)(a1 + 24);
    BOOL v31 = "H.264";
    if (v30 > 1718908519)
    {
      if (v30 == 1752589105) {
        goto LABEL_60;
      }
      int v32 = 1718908520;
    }
    else
    {
      if (v30 == 1684632424) {
        goto LABEL_60;
      }
      int v32 = 1685481521;
    }
    if (v30 != v32)
    {
LABEL_61:
      *(_DWORD *)buf = 134218754;
      uint64_t v46 = a1;
      __int16 v47 = 1024;
      int v48 = v29;
      __int16 v49 = 1024;
      int v50 = v28;
      __int16 v51 = 2080;
      uint32_t v52 = v31;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Frame enhancer is only supported on ANE devices\n", buf, 0x22u);
      goto LABEL_14;
    }
LABEL_60:
    BOOL v31 = "HEVC";
    goto LABEL_61;
  }
  if (*(void *)(a1 + 2304))
  {
LABEL_14:
    uint64_t v4 = 0;
    goto LABEL_15;
  }
  CFNumberRef v3 = (char *)operator new(0x80uLL, MEMORY[0x1E4FBA2D0]);
  if (!v3)
  {
    *(void *)(a1 + 2304) = 0;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = 4294967188;
      goto LABEL_15;
    }
    int v35 = *(_DWORD *)(a1 + 112);
    int v34 = *(_DWORD *)(a1 + 116);
    int v36 = *(_DWORD *)(a1 + 24);
    int v37 = "H.264";
    if (v36 > 1718908519)
    {
      if (v36 == 1752589105) {
        goto LABEL_73;
      }
      int v38 = 1718908520;
    }
    else
    {
      if (v36 == 1684632424) {
        goto LABEL_73;
      }
      int v38 = 1685481521;
    }
    if (v36 != v38)
    {
LABEL_74:
      *(_DWORD *)buf = 134219010;
      uint64_t v46 = a1;
      __int16 v47 = 1024;
      int v48 = v35;
      __int16 v49 = 1024;
      int v50 = v34;
      __int16 v51 = 2080;
      uint32_t v52 = v37;
      __int16 v53 = 1024;
      uint64_t v4 = 4294967188;
      int v54 = -108;
      BOOL v39 = MEMORY[0x1E4F14500];
      int v40 = "VCPDec %p (%dx%d, %s): Decoder failed to create the frame enhancer, err = %d\n";
      uint32_t v41 = 40;
      goto LABEL_75;
    }
LABEL_73:
    int v37 = "HEVC";
    goto LABEL_74;
  }
  *((void *)v3 + 3) = 0;
  *((_DWORD *)v3 + 8) = 0;
  *(void *)CFNumberRef v3 = 0;
  *((void *)v3 + 1) = 0;
  uint8_t v3[16] = 0;
  *((void *)v3 + 5) = 0;
  *((void *)v3 + 6) = 850045863;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_OWORD *)(v3 + 104) = 0u;
  *(void *)(v3 + 117) = 0;
  *(void *)(a1 + 2304) = v3;
  int v43 = 0;
  int v44 = 875704438;
  int v42 = 0;
  uint64_t v4 = VTDecompressionSessionCopyProperty();
  if (!v4)
  {
    CFDictionaryRef PixelBufferAttributes = CVPixelBufferPoolGetPixelBufferAttributes(0);
    if (PixelBufferAttributes)
    {
      CFDictionaryRef v18 = PixelBufferAttributes;
      int v19 = (const void *)*MEMORY[0x1E4F24D70];
      if (CFDictionaryContainsKey(PixelBufferAttributes, (const void *)*MEMORY[0x1E4F24D70])) {
        sub_1BB9DFC14(v18, v19, &v44);
      }
      double v20 = (const void *)*MEMORY[0x1E4F24E10];
      if (CFDictionaryContainsKey(v18, (const void *)*MEMORY[0x1E4F24E10])) {
        sub_1BB9DFC14(v18, v20, &v43);
      }
      int v21 = (const void *)*MEMORY[0x1E4F24D08];
      if (CFDictionaryContainsKey(v18, (const void *)*MEMORY[0x1E4F24D08])) {
        sub_1BB9DFC14(v18, v21, &v42);
      }
    }
    if (v43 && v42 && !sub_1BB9BE290(*(void *)(a1 + 2304), (int *)(a1 + 2296), v43, v42)
      || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_15;
    }
    int v23 = *(_DWORD *)(a1 + 112);
    int v22 = *(_DWORD *)(a1 + 116);
    int v24 = *(_DWORD *)(a1 + 24);
    CFNumberRef v25 = "H.264";
    if (v24 > 1718908519)
    {
      if (v24 == 1752589105) {
        goto LABEL_55;
      }
      int v26 = 1718908520;
    }
    else
    {
      if (v24 == 1684632424) {
        goto LABEL_55;
      }
      int v26 = 1685481521;
    }
    if (v24 != v26)
    {
LABEL_56:
      int v33 = *(_DWORD *)(a1 + 2296);
      *(_DWORD *)buf = 134219010;
      uint64_t v46 = a1;
      __int16 v47 = 1024;
      int v48 = v23;
      __int16 v49 = 1024;
      int v50 = v22;
      __int16 v51 = 2080;
      uint32_t v52 = v25;
      __int16 v53 = 1024;
      int v54 = v33;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder failed to initialize the frame enhancer with mode %d!\n", buf, 0x28u);
      goto LABEL_15;
    }
LABEL_55:
    CFNumberRef v25 = "HEVC";
    goto LABEL_56;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    int v6 = *(_DWORD *)(a1 + 112);
    int v5 = *(_DWORD *)(a1 + 116);
    int v7 = *(_DWORD *)(a1 + 24);
    BOOL v8 = "H.264";
    if (v7 > 1718908519)
    {
      if (v7 == 1752589105) {
        goto LABEL_68;
      }
      int v9 = 1718908520;
    }
    else
    {
      if (v7 == 1684632424) {
        goto LABEL_68;
      }
      int v9 = 1685481521;
    }
    if (v7 != v9)
    {
LABEL_69:
      *(_DWORD *)buf = 134218754;
      uint64_t v46 = a1;
      __int16 v47 = 1024;
      int v48 = v6;
      __int16 v49 = 1024;
      int v50 = v5;
      __int16 v51 = 2080;
      uint32_t v52 = v8;
      BOOL v39 = MEMORY[0x1E4F14500];
      int v40 = "VCPDec %p (%dx%d, %s): Failed to copy decoder pixel buffer pool\n";
      uint32_t v41 = 34;
LABEL_75:
      _os_log_error_impl(&dword_1BB9B9000, v39, OS_LOG_TYPE_ERROR, v40, buf, v41);
      goto LABEL_15;
    }
LABEL_68:
    BOOL v8 = "HEVC";
    goto LABEL_69;
  }
LABEL_15:
  uint64_t v10 = *(void *)(a1 + 2304);
  if (!v10 || !*(unsigned char *)(v10 + 16)) {
    sub_1BB9E4A5C((_DWORD *)a1);
  }
  if (!v4)
  {
    uint64_t v11 = *(void *)(a1 + 2304);
    if (v11 && *(unsigned char *)(v11 + 16))
    {
      *(_DWORD *)(a1 + 2296) |= 1u;
      uint64_t v4 = 0;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *(_DWORD *)(a1 + 112);
        int v12 = *(_DWORD *)(a1 + 116);
        int v14 = *(_DWORD *)(a1 + 24);
        int32_t v15 = "H.264";
        if (v14 > 1718908519)
        {
          if (v14 == 1752589105) {
            goto LABEL_46;
          }
          int v16 = 1718908520;
        }
        else
        {
          if (v14 == 1684632424) {
            goto LABEL_46;
          }
          int v16 = 1685481521;
        }
        if (v14 != v16)
        {
LABEL_47:
          *(_DWORD *)buf = 134218754;
          uint64_t v46 = a1;
          __int16 v47 = 1024;
          int v48 = v13;
          __int16 v49 = 1024;
          int v50 = v12;
          __int16 v51 = 2080;
          uint32_t v52 = v15;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Frame enhancer is enabled\n", buf, 0x22u);
          return 0;
        }
LABEL_46:
        int32_t v15 = "HEVC";
        goto LABEL_47;
      }
    }
    else
    {
      sub_1BB9E4A5C((_DWORD *)a1);
      return 4294954394;
    }
  }
  return v4;
}

void sub_1BB9E4A5C(_DWORD *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  a1[574] &= ~1u;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v3 = a1[28];
    int v2 = a1[29];
    int v4 = a1[6];
    int v5 = "H.264";
    if (v4 > 1718908519)
    {
      BOOL v6 = v4 == 1752589105;
      int v7 = 1718908520;
    }
    else
    {
      BOOL v6 = v4 == 1684632424;
      int v7 = 1685481521;
    }
    if (v6 || v4 == v7) {
      int v5 = "HEVC";
    }
    int v9 = 134218754;
    uint64_t v10 = a1;
    __int16 v11 = 1024;
    int v12 = v3;
    __int16 v13 = 1024;
    int v14 = v2;
    __int16 v15 = 2080;
    int v16 = v5;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Frame enhancer is disabled\n", (uint8_t *)&v9, 0x22u);
  }
}

uint64_t sub_1BB9E4B84(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, CVPixelBufferRef pixelBuffer, long long *a6, long long *a7)
{
  uint64_t v272 = *MEMORY[0x1E4F143B8];
  int16x8_t v263 = 0;
  int valuePtr = 0;
  IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(pixelBuffer);
  if (IOSurface) {
    IOSurfaceGetID(IOSurface);
  }
  v15.n128_f64[0] = sub_1BBA3F6DC((uint64_t)(a2 + 6));
  uint64_t v16 = *(void *)(a1 + 2224);
  if (v16)
  {
    double v17 = *((double *)a2 + 3);
    sub_1BBAC8868(v16, (uint64_t *)"decoded_frames", 1.0);
    sub_1BBAC8868(*(void *)(a1 + 2224), (uint64_t *)"decoding_time", v17);
  }
  if (a3 || !pixelBuffer)
  {
    int v33 = 0;
    int v34 = *(_DWORD *)(a1 + 24);
    if (v34 > 1718908519)
    {
      if (v34 == 1752589105) {
        goto LABEL_33;
      }
      int v35 = 1718908520;
    }
    else
    {
      if (v34 == 1684632424) {
        goto LABEL_33;
      }
      int v35 = 1685481521;
    }
    if (v34 != v35) {
      goto LABEL_147;
    }
LABEL_33:
    if (*(_DWORD *)(a1 + 168) == 2) {
      goto LABEL_34;
    }
    CFStringRef v36 = (const __CFString *)CFPreferencesCopyAppValue(@"TempSVCER", @"com.apple.VideoProcessing");
    if (v36)
    {
      CFStringRef v37 = v36;
      BOOL v38 = CFStringGetIntValue(v36) != 0;
      CFRelease(v37);
    }
    else
    {
      BOOL v38 = 1;
    }
    if (a3 != -17694 || pixelBuffer)
    {
      if (a3)
      {
        int v33 = 0;
LABEL_145:
        int v46 = 2;
        goto LABEL_146;
      }
LABEL_34:
      int v33 = 0;
      goto LABEL_147;
    }
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
LABEL_53:
      if (!v38 || *((unsigned __int8 *)a2 + 84) < 2u || (int v45 = *(_DWORD *)(a1 + 204), a2[5] > v45) && v45 > 0)
      {
        a3 = 4294949602;
LABEL_58:
        int v33 = 0;
        int v46 = 1;
LABEL_146:
        *(_DWORD *)(a1 + 168) = v46;
        goto LABEL_147;
      }
      a3 = 0;
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_58;
      }
      int v52 = *(_DWORD *)(a1 + 112);
      int v51 = *(_DWORD *)(a1 + 116);
      int v53 = *(_DWORD *)(a1 + 24);
      int v54 = "H.264";
      if (v53 > 1718908519)
      {
        if (v53 == 1752589105) {
          goto LABEL_349;
        }
        int v55 = 1718908520;
      }
      else
      {
        if (v53 == 1684632424) {
          goto LABEL_349;
        }
        int v55 = 1685481521;
      }
      if (v53 != v55)
      {
LABEL_350:
        *(_DWORD *)buf = 134218754;
        uint64_t v265 = a1;
        __int16 v266 = 1024;
        *(_DWORD *)int v267 = v52;
        *(_WORD *)&v267[4] = 1024;
        *(_DWORD *)&v267[6] = v51;
        *(_WORD *)__int16 v268 = 2080;
        *(void *)&v268[2] = v54;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): VCP error resilience updated kVTVideoDecoderReferenceMissingErr to noErr\n", buf, 0x22u);
        a3 = 0;
        goto LABEL_58;
      }
LABEL_349:
      int v54 = "HEVC";
      goto LABEL_350;
    }
    int v41 = *(_DWORD *)(a1 + 112);
    int v40 = *(_DWORD *)(a1 + 116);
    int v42 = *(_DWORD *)(a1 + 24);
    int v43 = "H.264";
    if (v42 > 1718908519)
    {
      if (v42 == 1752589105) {
        goto LABEL_51;
      }
      int v44 = 1718908520;
    }
    else
    {
      if (v42 == 1684632424) {
        goto LABEL_51;
      }
      int v44 = 1685481521;
    }
    if (v42 != v44)
    {
LABEL_52:
      *(_DWORD *)buf = 134218754;
      uint64_t v265 = a1;
      __int16 v266 = 1024;
      *(_DWORD *)int v267 = v41;
      *(_WORD *)&v267[4] = 1024;
      *(_DWORD *)&v267[6] = v40;
      *(_WORD *)__int16 v268 = 2080;
      *(void *)&v268[2] = v43;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): VCP decoder got kVTVideoDecoderReferenceMissingErr error\n", buf, 0x22u);
      goto LABEL_53;
    }
LABEL_51:
    int v43 = "HEVC";
    goto LABEL_52;
  }
  uint64_t v18 = *(void *)(a1 + 2224);
  if (v18) {
    sub_1BBAC8868(v18, (uint64_t *)"transmit_frames", 1.0);
  }
  if (*(unsigned char *)(a1 + 2272))
  {
    unint64_t v19 = *(void *)(a1 + 2264);
    if (v19 <= 0x12B && !(v19 % 0x1E))
    {
      CVPixelBufferRef v20 = CVPixelBufferRetain(pixelBuffer);
      sub_1BBA12900(*(void **)(a1 + 2256), (uint64_t)v20, 2u, 0, &unk_1F14EF200);
      unint64_t v19 = *(void *)(a1 + 2264);
    }
    if (v19 < 0x12C) {
      ++v19;
    }
    *(void *)(a1 + 2264) = v19;
  }
  uint64_t v248 = a7;
  uint16x8_t v249 = a6;
  if (*(unsigned char *)(a1 + 80))
  {
    if (!(*(unsigned int (**)(void, __n128))(**((void **)a2 + 15) + 24))(*((void *)a2 + 15), v15)
      || !*(_WORD *)(*((void *)a2 + 15) + 16))
    {
      goto LABEL_90;
    }
    int v21 = CVPixelBufferGetIOSurface(pixelBuffer);
    CFNumberRef v22 = (const __CFNumber *)IOSurfaceCopyValue(v21, @"FrameYUVChecksum");
    if (v22)
    {
      CFNumberGetValue(v22, kCFNumberSInt32Type, &valuePtr);
      int v23 = valuePtr;
      if (valuePtr) {
        goto LABEL_70;
      }
    }
    int v24 = CVPixelBufferRetain(pixelBuffer);
    size_t extraColumnsOnLeft = 0;
    size_t extraRowsOnTop = 0;
    size_t extraColumnsOnRight = 0;
    size_t extraRowsOnBottom = 0;
    CVPixelBufferGetExtendedPixels(v24, &extraColumnsOnLeft, &extraColumnsOnRight, &extraRowsOnTop, &extraRowsOnBottom);
    size_t Width = CVPixelBufferGetWidth(v24);
    size_t Height = CVPixelBufferGetHeight(v24);
    size_t v27 = extraColumnsOnLeft + Width + extraColumnsOnRight;
    size_t v28 = extraRowsOnTop + Height + extraRowsOnBottom;
    size_t v29 = *(unsigned int *)(a1 + 112);
    if (v27 >= v29 && v28 >= *(unsigned int *)(a1 + 116))
    {
      CVPixelBufferLockBaseAddress(v24, 1uLL);
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(v24, 0);
      int v48 = CVPixelBufferGetBaseAddressOfPlane(v24, 1uLL);
      int BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v24, 0);
      int v50 = CVPixelBufferGetBytesPerRowOfPlane(v24, 1uLL);
      int valuePtr = sub_1BBB02744((uint64_t)BaseAddressOfPlane, (uint64_t)v48, BytesPerRowOfPlane, v50, *(_DWORD *)(a1 + 112), *(_DWORD *)(a1 + 116));
      CVPixelBufferUnlockBaseAddress(v24, 1uLL);
      goto LABEL_69;
    }
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_69;
    }
    int v30 = *(_DWORD *)(a1 + 24);
    BOOL v31 = "H.264";
    if (v30 > 1718908519)
    {
      if (v30 == 1752589105) {
        goto LABEL_67;
      }
      int v32 = 1718908520;
    }
    else
    {
      if (v30 == 1684632424) {
        goto LABEL_67;
      }
      int v32 = 1685481521;
    }
    if (v30 != v32)
    {
LABEL_68:
      int v56 = *(_DWORD *)(a1 + 116);
      *(_DWORD *)buf = 134219266;
      uint64_t v265 = a1;
      __int16 v266 = 2080;
      *(void *)int v267 = v31;
      *(_WORD *)&v267[8] = 1024;
      *(_DWORD *)__int16 v268 = v29;
      *(_WORD *)&v268[4] = 1024;
      *(_DWORD *)&v268[6] = v56;
      __int16 v269 = 2048;
      *(void *)long long v270 = v27;
      *(_WORD *)&v270[8] = 2048;
      size_t v271 = v28;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%s): Decoder cannot calculate checksum. Target resolution (%d, %d) is bigger than pixel buffer resolution (%ld, %ld)\n", buf, 0x36u);
LABEL_69:
      CVPixelBufferRelease(v24);
      int v23 = valuePtr;
      if (valuePtr)
      {
LABEL_70:
        int v57 = *(unsigned __int16 *)(*((void *)a2 + 15) + 16);
        if (v23 != v57)
        {
          if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
          {
LABEL_84:
            int v68 = 0;
            a3 = 4294954387;
LABEL_91:
            BOOL v69 = (int *)*((void *)a2 + 15);
            if (v69[5] >= 1 && v69[6] >= 1)
            {
              CFAllocatorRef v70 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              BOOL v69 = (int *)*((void *)a2 + 15);
              if (Mutable)
              {
                CFNumberRef v72 = CFNumberCreate(v70, kCFNumberIntType, v69 + 7);
                CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24A70], v72);
                CFRelease(v72);
                CFNumberRef v73 = CFNumberCreate(v70, kCFNumberIntType, (const void *)(*((void *)a2 + 15) + 32));
                CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24A80], v73);
                CFRelease(v73);
                CFNumberRef v74 = CFNumberCreate(v70, kCFNumberIntType, (const void *)(*((void *)a2 + 15) + 20));
                CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24A88], v74);
                CFRelease(v74);
                CFNumberRef v75 = CFNumberCreate(v70, kCFNumberIntType, (const void *)(*((void *)a2 + 15) + 24));
                CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24A68], v75);
                CFRelease(v75);
                CVBufferSetAttachment(pixelBuffer, (CFStringRef)*MEMORY[0x1E4F44FE8], Mutable, kCVAttachmentMode_ShouldPropagate);
                CFRelease(Mutable);
                BOOL v69 = (int *)*((void *)a2 + 15);
              }
            }
            if ((*(unsigned int (**)(int *))(*(void *)v69 + 120))(v69))
            {
              CFAllocatorRef v76 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
              CFMutableDictionaryRef v77 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              if (v77)
              {
                int v78 = v77;
                uint64_t v79 = *((void *)a2 + 15);
                *(_DWORD *)buf = *(__int16 *)(v79 + 104);
                LODWORD(extraColumnsOnLeft) = *(__int16 *)(v79 + 106);
                LODWORD(extraColumnsOnRight) = *(unsigned __int16 *)(v79 + 108);
                LODWORD(extraRowsOnTop) = *(unsigned __int16 *)(v79 + 110);
                CFNumberRef v80 = CFNumberCreate(v76, kCFNumberIntType, buf);
                CFDictionarySetValue(v78, (const void *)*MEMORY[0x1E4F24A70], v80);
                CFRelease(v80);
                CFNumberRef v81 = CFNumberCreate(v76, kCFNumberIntType, &extraColumnsOnLeft);
                CFDictionarySetValue(v78, (const void *)*MEMORY[0x1E4F24A80], v81);
                CFRelease(v81);
                CFNumberRef v82 = CFNumberCreate(v76, kCFNumberIntType, &extraColumnsOnRight);
                CFDictionarySetValue(v78, (const void *)*MEMORY[0x1E4F24A88], v82);
                CFRelease(v82);
                CFNumberRef v83 = CFNumberCreate(v76, kCFNumberIntType, &extraRowsOnTop);
                CFDictionarySetValue(v78, (const void *)*MEMORY[0x1E4F24A68], v83);
                CFRelease(v83);
                CVBufferSetAttachment(pixelBuffer, (CFStringRef)*MEMORY[0x1E4F44FE8], v78, kCVAttachmentMode_ShouldPropagate);
                CFRelease(v78);
              }
            }
            int v84 = a2 + 24;
            if (a2[24] >= 1 && a2[25] >= 1)
            {
              CFNumberRef v85 = CFNumberCreate(0, kCFNumberIntType, a2 + 24);
              CVBufferSetAttachment(pixelBuffer, @"VraWidth", v85, kCVAttachmentMode_ShouldPropagate);
              CFRelease(v85);
              CFNumberRef v86 = CFNumberCreate(0, kCFNumberIntType, a2 + 25);
              CVBufferSetAttachment(pixelBuffer, @"VraHeight", v86, kCVAttachmentMode_ShouldPropagate);
              CFRelease(v86);
            }
            a2[22] = 0;
            CFNumberRef v87 = CFNumberCreate(0, kCFNumberIntType, a2 + 22);
            CVBufferSetAttachment(pixelBuffer, @"RotationFlags", v87, kCVAttachmentMode_ShouldPropagate);
            CFRelease(v87);
            uint32_t v88 = CVPixelBufferRetain(pixelBuffer);
            int16x8_t v263 = v88;
            int v89 = *(unsigned __int8 *)(a1 + 93);
            *((void *)a2 + 13) = 0;
            if (v89)
            {
              uint64_t v90 = *((void *)a2 + 15);
              float v91 = *(float *)(v90 + 60);
              if (v91 < 1.0 && v91 > 0.0)
              {
                float v92 = *(float *)(v90 + 64);
                if (v92 < 1.0 && v92 > 0.0)
                {
                  BOOL v93 = v88;
                  unsigned int v94 = CVPixelBufferGetWidth(v88);
                  unsigned int v95 = CVPixelBufferGetHeight(v93);
                  int32x2_t v96 = (int32x2_t)__PAIR64__(v95, v94);
                  if (*v84 >= 1) {
                    int32x2_t v96 = (int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(a2[25] > 0), 0x1FuLL)), *(int8x8_t *)(a2 + 24), (int8x8_t)__PAIR64__(v95, v94));
                  }
                  uint64_t v97 = *((void *)a2 + 15);
                  float32x2_t v98 = vcvt_f32_s32(v96);
                  int32x2_t v99 = vcvt_s32_f32(vmul_f32(*(float32x2_t *)(v97 + 60), v98));
                  *((int32x2_t *)a2 + 12) = v99;
                  *((int32x2_t *)a2 + 13) = vmin_s32(vsub_s32(v96, v99), vcvt_s32_f32(vmul_f32(*(float32x2_t *)(v97 + 52), v98)));
                }
              }
            }
            if (v68)
            {
              if (a2[25] < 1 || *v84 < 1)
              {
                a3 = 0;
              }
              else
              {
                uint64_t v100 = *(void *)(a1 + 2224);
                if (v100)
                {
                  sub_1BBAC8868(v100, (uint64_t *)"vra_width", (double)*v84);
                  sub_1BBAC8868(*(void *)(a1 + 2224), (uint64_t *)"vra_height", (double)a2[25]);
                }
                if (*(void *)(a1 + 2304) && (*(unsigned char *)(a1 + 2296) & 1) != 0)
                {
                  a3 = sub_1BB9E6C6C(a1, a2, &v263);
                }
                else if (sub_1BB9E729C(a1, a2, &v263, 0, 0))
                {
                  a3 = 4294954385;
                }
                else
                {
                  a3 = 0;
                }
              }
            }
            BOOL v39 = v263;
            a6 = v249;
            if (!v263) {
              goto LABEL_136;
            }
            goto LABEL_121;
          }
          int v59 = *(_DWORD *)(a1 + 112);
          int v58 = *(_DWORD *)(a1 + 116);
          int v60 = *(_DWORD *)(a1 + 24);
          CFTypeID v61 = "H.264";
          if (v60 > 1718908519)
          {
            if (v60 == 1752589105) {
              goto LABEL_82;
            }
            int v62 = 1718908520;
          }
          else
          {
            if (v60 == 1684632424) {
              goto LABEL_82;
            }
            int v62 = 1685481521;
          }
          if (v60 != v62)
          {
LABEL_83:
            *(_DWORD *)buf = 134219266;
            uint64_t v265 = a1;
            __int16 v266 = 1024;
            *(_DWORD *)int v267 = v59;
            *(_WORD *)&v267[4] = 1024;
            *(_DWORD *)&v267[6] = v58;
            *(_WORD *)__int16 v268 = 2080;
            *(void *)&v268[2] = v61;
            __int16 v269 = 1024;
            *(_DWORD *)long long v270 = v23;
            *(_WORD *)&v270[4] = 1024;
            *(_DWORD *)&v270[6] = v57;
            _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder checksum mismatch local %x <-> received %x\n", buf, 0x2Eu);
            goto LABEL_84;
          }
LABEL_82:
          CFTypeID v61 = "HEVC";
          goto LABEL_83;
        }
LABEL_90:
        a3 = 0;
        int v68 = 1;
        goto LABEL_91;
      }
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_90;
      }
      int v64 = *(_DWORD *)(a1 + 112);
      int v63 = *(_DWORD *)(a1 + 116);
      int v65 = *(_DWORD *)(a1 + 24);
      CFStringRef v66 = "H.264";
      if (v65 > 1718908519)
      {
        if (v65 == 1752589105) {
          goto LABEL_88;
        }
        int v67 = 1718908520;
      }
      else
      {
        if (v65 == 1684632424) {
          goto LABEL_88;
        }
        int v67 = 1685481521;
      }
      if (v65 != v67)
      {
LABEL_89:
        *(_DWORD *)buf = 134218754;
        uint64_t v265 = a1;
        __int16 v266 = 1024;
        *(_DWORD *)int v267 = v64;
        *(_WORD *)&v267[4] = 1024;
        *(_DWORD *)&v267[6] = v63;
        *(_WORD *)__int16 v268 = 2080;
        *(void *)&v268[2] = v66;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder checksum is N/A", buf, 0x22u);
        goto LABEL_90;
      }
LABEL_88:
      CFStringRef v66 = "HEVC";
      goto LABEL_89;
    }
LABEL_67:
    BOOL v31 = "HEVC";
    goto LABEL_68;
  }
  BOOL v39 = CVPixelBufferRetain(pixelBuffer);
  a3 = 0;
  int16x8_t v263 = v39;
  if (!v39) {
    goto LABEL_136;
  }
LABEL_121:
  if (*(int *)(a1 + 136) < 2)
  {
LABEL_136:
    int v33 = 0;
LABEL_137:
    a7 = v248;
    goto LABEL_138;
  }
  unsigned int v247 = a4;
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 2288) + 104))(*(void *)(a1 + 2288)))
  {
    if (*(_WORD *)(a1 + 176))
    {
      int v101 = *(unsigned __int16 *)(a1 + 178);
      if (*(_WORD *)(a1 + 178))
      {
        *(_DWORD *)(a1 + 140) = *(unsigned __int16 *)(a1 + 176);
        *(_DWORD *)(a1 + 144) = v101;
      }
    }
  }
  uint64_t v102 = (CVPixelBufferPoolRef *)(a1 + 184);
  if (!*(void *)(a1 + 184)) {
    goto LABEL_367;
  }
  int v103 = (*(uint64_t (**)(void))(**((void **)a2 + 15) + 104))(*((void *)a2 + 15));
  unint64_t v104 = *v102;
  if (v103)
  {
    CFDictionaryRef PixelBufferAttributes = CVPixelBufferPoolGetPixelBufferAttributes(*v102);
    *(_DWORD *)buf = 0;
    LODWORD(extraColumnsOnLeft) = 0;
    if (PixelBufferAttributes)
    {
      CFDictionaryRef v106 = PixelBufferAttributes;
      int v107 = (const void *)*MEMORY[0x1E4F24E10];
      if (CFDictionaryContainsKey(PixelBufferAttributes, (const void *)*MEMORY[0x1E4F24E10])) {
        sub_1BB9DFC14(v106, v107, buf);
      }
      CFTypeID v108 = (const void *)*MEMORY[0x1E4F24D08];
      if (CFDictionaryContainsKey(v106, (const void *)*MEMORY[0x1E4F24D08])) {
        sub_1BB9DFC14(v106, v108, &extraColumnsOnLeft);
      }
    }
    if (*(_DWORD *)(a1 + 140) == *(_DWORD *)buf && *(_DWORD *)(a1 + 144) == extraColumnsOnLeft)
    {
      unint64_t v104 = *v102;
    }
    else
    {
      CVPixelBufferPoolRelease(*v102);
      unint64_t v104 = 0;
      *uint64_t v102 = 0;
    }
  }
  if (!v104)
  {
LABEL_367:
    poolOut = (CVPixelBufferPoolRef *)(a1 + 184);
    int v141 = *(_DWORD *)(a1 + 140);
    int v246 = *(_DWORD *)(a1 + 144);
    signed int PixelFormatType = CVPixelBufferGetPixelFormatType(v39);
    __int16 v143 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    double v144 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    __int16 v145 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFMutableDictionaryRef v146 = CFDictionaryCreateMutable(0, 0, v143, v144);
    if (PixelFormatType > 1885745711)
    {
      if (PixelFormatType == 1885746228)
      {
        signed int PixelFormatType = 2019963956;
      }
      else if (PixelFormatType == 1885745712)
      {
        signed int PixelFormatType = 2019963440;
      }
    }
    else if (PixelFormatType == 1882468912)
    {
      signed int PixelFormatType = 2016686640;
    }
    else if (PixelFormatType == 1882469428)
    {
      signed int PixelFormatType = 2016687156;
    }
    *(_DWORD *)buf = v141;
    CFNumberRef v147 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v147)
    {
      CFNumberRef v148 = v147;
      CFDictionaryAddValue(v145, (const void *)*MEMORY[0x1E4F24E10], v147);
      CFRelease(v148);
    }
    *(_DWORD *)buf = v246;
    CFNumberRef v149 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v149)
    {
      CFNumberRef v150 = v149;
      CFDictionaryAddValue(v145, (const void *)*MEMORY[0x1E4F24D08], v149);
      CFRelease(v150);
    }
    *(_DWORD *)buf = PixelFormatType;
    CFNumberRef v151 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v151)
    {
      CFNumberRef v152 = v151;
      CFDictionaryAddValue(v145, (const void *)*MEMORY[0x1E4F24D70], v151);
      CFRelease(v152);
    }
    *(_DWORD *)buf = 2;
    CFNumberRef v153 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v153)
    {
      CFNumberRef v154 = v153;
      CFDictionaryAddValue(v145, (const void *)*MEMORY[0x1E4F24D90], v153);
      CFRelease(v154);
    }
    *(_DWORD *)buf = 64;
    CFNumberRef v155 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v155)
    {
      CFNumberRef v156 = v155;
      CFDictionaryAddValue(v145, (const void *)*MEMORY[0x1E4F24C98], v155);
      CFRelease(v156);
    }
    *(_DWORD *)buf = 64;
    CFNumberRef v157 = CFNumberCreate(0, kCFNumberSInt32Type, buf);
    if (v157)
    {
      CFNumberRef v158 = v157;
      CFDictionaryAddValue(v145, (const void *)*MEMORY[0x1E4F24D78], v157);
      CFRelease(v158);
    }
    CFDictionarySetValue(v145, (const void *)*MEMORY[0x1E4F24D20], v146);
    CVPixelBufferPoolCreate(0, 0, v145, poolOut);
    if (v145) {
      CFRelease(v145);
    }
    if (v146) {
      CFRelease(v146);
    }
    unint64_t v104 = *poolOut;
    if (!*poolOut)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_190;
      }
      int v173 = *(_DWORD *)(a1 + 140);
      int v172 = *(_DWORD *)(a1 + 144);
      int v174 = *(_DWORD *)(a1 + 24);
      char v175 = "H.264";
      if (v174 > 1718908519)
      {
        if (v174 == 1752589105) {
          goto LABEL_299;
        }
        int v176 = 1718908520;
      }
      else
      {
        if (v174 == 1684632424) {
          goto LABEL_299;
        }
        int v176 = 1685481521;
      }
      if (v174 != v176)
      {
LABEL_300:
        OSType v217 = CVPixelBufferGetPixelFormatType(v39);
        *(_DWORD *)buf = 134219010;
        uint64_t v265 = a1;
        __int16 v266 = 1024;
        *(_DWORD *)int v267 = v173;
        *(_WORD *)&v267[4] = 1024;
        *(_DWORD *)&v267[6] = v172;
        *(_WORD *)__int16 v268 = 2080;
        *(void *)&v268[2] = v175;
        __int16 v269 = 1024;
        *(_DWORD *)long long v270 = v217;
        int16x8_t v218 = MEMORY[0x1E4F14500];
        int v219 = "VCPDec %p (%dx%d, %s): Decoder failed to create stitched pixel buffer pool for subframe decoding! (pixfmt %d)\n";
        uint32_t v220 = 40;
LABEL_310:
        _os_log_impl(&dword_1BB9B9000, v218, OS_LOG_TYPE_DEFAULT, v219, buf, v220);
        goto LABEL_190;
      }
LABEL_299:
      char v175 = "HEVC";
      goto LABEL_300;
    }
  }
  int v159 = (CVBufferRef *)(a1 + 192);
  if (*(void *)(a1 + 192)) {
    goto LABEL_229;
  }
  if (CVPixelBufferPoolCreatePixelBuffer(0, v104, (CVPixelBufferRef *)(a1 + 192)))
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_190;
    }
    int v168 = *(_DWORD *)(a1 + 112);
    int v167 = *(_DWORD *)(a1 + 116);
    int v169 = *(_DWORD *)(a1 + 24);
    int v170 = "H.264";
    if (v169 > 1718908519)
    {
      if (v169 == 1752589105) {
        goto LABEL_308;
      }
      int v171 = 1718908520;
    }
    else
    {
      if (v169 == 1684632424) {
        goto LABEL_308;
      }
      int v171 = 1685481521;
    }
    if (v169 != v171)
    {
LABEL_309:
      *(_DWORD *)buf = 134218754;
      uint64_t v265 = a1;
      __int16 v266 = 1024;
      *(_DWORD *)int v267 = v168;
      *(_WORD *)&v267[4] = 1024;
      *(_DWORD *)&v267[6] = v167;
      *(_WORD *)__int16 v268 = 2080;
      *(void *)&v268[2] = v170;
      int16x8_t v218 = MEMORY[0x1E4F14500];
      int v219 = "VCPDec %p (%dx%d, %s): Decoder failed to create stitched pixel buffer for subframe decoding!\n";
      uint32_t v220 = 34;
      goto LABEL_310;
    }
LABEL_308:
    int v170 = "HEVC";
    goto LABEL_309;
  }
  CVBufferPropagateAttachments(v263, *v159);
LABEL_229:
  int v160 = *((unsigned __int16 *)a2 + 6);
  int v161 = *(unsigned __int16 *)(a1 + 156);
  if (v160 == v161) {
    goto LABEL_263;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v163 = *(_DWORD *)(a1 + 112);
    int v162 = *(_DWORD *)(a1 + 116);
    int v164 = *(_DWORD *)(a1 + 24);
    uint32_t v165 = "H.264";
    if (v164 > 1718908519)
    {
      if (v164 == 1752589105) {
        goto LABEL_256;
      }
      int v166 = 1718908520;
    }
    else
    {
      if (v164 == 1684632424) {
        goto LABEL_256;
      }
      int v166 = 1685481521;
    }
    if (v164 != v166)
    {
LABEL_257:
      *(_DWORD *)buf = 134219266;
      uint64_t v265 = a1;
      __int16 v266 = 1024;
      *(_DWORD *)int v267 = v163;
      *(_WORD *)&v267[4] = 1024;
      *(_DWORD *)&v267[6] = v162;
      *(_WORD *)__int16 v268 = 2080;
      *(void *)&v268[2] = v165;
      __int16 v269 = 1024;
      *(_DWORD *)long long v270 = v161;
      *(_WORD *)&v270[4] = 1024;
      *(_DWORD *)&v270[6] = v160;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Tile order does not match, expected: %d, actual: %d\n", buf, 0x2Eu);
      goto LABEL_258;
    }
LABEL_256:
    uint32_t v165 = "HEVC";
    goto LABEL_257;
  }
LABEL_258:
  *(unsigned char *)(a1 + 165) = 1;
  uint64_t v178 = *(void *)(a1 + 2280);
  uint64_t v180 = *(void *)(v178 + 176);
  uint64_t v179 = *(void *)(v178 + 184);
  if (v179 != v180)
  {
    uint64_t v181 = 0;
    unint64_t v182 = 0;
    do
    {
      CFNumberRef v183 = *(__CVBuffer **)(v180 + v181);
      if (v183)
      {
        CVPixelBufferRelease(v183);
        *(void *)(v180 + v181) = 0;
        uint64_t v180 = *(void *)(v178 + 176);
        uint64_t v179 = *(void *)(v178 + 184);
      }
      ++v182;
      v181 += 24;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((v179 - v180) >> 3) > v182);
  }
LABEL_263:
  int v184 = a2[4];
  int v185 = *(_DWORD *)(a1 + 160);
  if (v184 > v185 || v184 < 0 && v185 >= 1)
  {
    *(_DWORD *)(a1 + 160) = v184;
    *(_DWORD *)(a1 + 156) = *((unsigned __int16 *)a2 + 6);
    *(unsigned char *)(a1 + 164) = 0;
    a6 = v249;
LABEL_267:
    kdebug_trace();
    uint64_t v186 = *(void *)(a1 + 2280);
    int v187 = a2[2];
    uint64_t v188 = *(void *)(v186 + 176);
    if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v186 + 184) - v188) >> 3) > v187)
    {
      uint64_t v189 = *((void *)a2 + 15);
      uint64_t v190 = *(void *)(v189 + 68);
      int v191 = *(_DWORD *)(v189 + 76);
      int v192 = a2[2];
      int v193 = (CVPixelBufferRef *)(v188 + 24 * v187);
      if (*v193)
      {
        CVPixelBufferRelease(*v193);
        *int v193 = 0;
      }
      *int v193 = CVPixelBufferRetain(pixelBuffer);
      uint64_t v194 = v188 + 24 * v192;
      *(void *)(v194 + 8) = v190;
      *(_DWORD *)(v194 + 16) = v191;
      uint64_t v186 = *(void *)(a1 + 2280);
      int v187 = a2[2];
      a6 = v249;
    }
    int v195 = sub_1BB9C9444(v186, v187, *v159);
    kdebug_trace();
    if (v195)
    {
      a4 = v247;
      a7 = v248;
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
LABEL_295:
        int v33 = 0;
        *(unsigned char *)(a1 + 164) = 1;
        *(_WORD *)(a1 + 158) = 0;
        goto LABEL_138;
      }
      int v197 = *(_DWORD *)(a1 + 112);
      int v196 = *(_DWORD *)(a1 + 116);
      int v198 = *(_DWORD *)(a1 + 24);
      __int16 v199 = "H.264";
      if (v198 > 1718908519)
      {
        if (v198 == 1752589105) {
          goto LABEL_293;
        }
        int v200 = 1718908520;
      }
      else
      {
        if (v198 == 1684632424) {
          goto LABEL_293;
        }
        int v200 = 1685481521;
      }
      if (v198 != v200)
      {
LABEL_294:
        int v215 = a2[2];
        int v216 = *((unsigned __int16 *)a2 + 6);
        *(_DWORD *)buf = 134219266;
        uint64_t v265 = a1;
        __int16 v266 = 1024;
        *(_DWORD *)int v267 = v197;
        *(_WORD *)&v267[4] = 1024;
        *(_DWORD *)&v267[6] = v196;
        *(_WORD *)__int16 v268 = 2080;
        *(void *)&v268[2] = v199;
        __int16 v269 = 1024;
        *(_DWORD *)long long v270 = v215;
        *(_WORD *)&v270[4] = 1024;
        *(_DWORD *)&v270[6] = v216;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Failed to stitch tile (id %d, order %d)\n", buf, 0x2Eu);
        goto LABEL_295;
      }
LABEL_293:
      __int16 v199 = "HEVC";
      goto LABEL_294;
    }
    ++*(_WORD *)(a1 + 156);
    int v201 = a2[2];
    int v202 = (unsigned __int16)(*(_WORD *)(a1 + 158) | (1 << v201));
    *(_WORD *)(a1 + 158) |= 1 << v201;
    int v203 = *(_DWORD *)(a1 + 136);
    int v204 = ~(-1 << v203);
    if (v202 == v204)
    {
      *(unsigned char *)(a1 + 165) = 0;
      a7 = v248;
      goto LABEL_278;
    }
    if (*(unsigned char *)(a1 + 165))
    {
      int v33 = 0;
LABEL_304:
      a4 = v247;
      goto LABEL_137;
    }
    BOOL v221 = __OFSUB__(v203, 1);
    int v222 = v203 - 1;
    if (v222 < 0 != v221)
    {
LABEL_343:
      a7 = v248;
      if (v202 != v204 || !*((unsigned char *)a2 + 14))
      {
        int v33 = 0;
LABEL_357:
        a4 = v247;
        goto LABEL_138;
      }
LABEL_278:
      kdebug_trace();
      if (!sub_1BB9C9724(*(void **)(a1 + 2280), *(CVPixelBufferRef *)(a1 + 192))
        || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_356;
      }
      int v206 = *(_DWORD *)(a1 + 112);
      int v205 = *(_DWORD *)(a1 + 116);
      int v207 = *(_DWORD *)(a1 + 24);
      int v208 = "H.264";
      if (v207 > 1718908519)
      {
        if (v207 == 1752589105) {
          goto LABEL_354;
        }
        int v209 = 1718908520;
      }
      else
      {
        if (v207 == 1684632424) {
          goto LABEL_354;
        }
        int v209 = 1685481521;
      }
      if (v207 != v209)
      {
LABEL_355:
        *(_DWORD *)buf = 134218754;
        uint64_t v265 = a1;
        __int16 v266 = 1024;
        *(_DWORD *)int v267 = v206;
        *(_WORD *)&v267[4] = 1024;
        *(_DWORD *)&v267[6] = v205;
        *(_WORD *)__int16 v268 = 2080;
        *(void *)&v268[2] = v208;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Failed to filter the frame\n", buf, 0x22u);
LABEL_356:
        kdebug_trace();
        int v33 = 1;
        goto LABEL_357;
      }
LABEL_354:
      int v208 = "HEVC";
      goto LABEL_355;
    }
    uint64_t v223 = 0;
    unint64_t v224 = 0;
    if (*((unsigned char *)a2 + 14)) {
      LOBYTE(v201) = v222;
    }
    int v225 = ~(-1 << (v201 + 1)) - v202;
    while (1)
    {
      uint64_t v226 = *(void *)(a1 + 2280);
      uint64_t v227 = *(void *)(v226 + 176);
      if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v226 + 184) - v227) >> 3) <= v224) {
        goto LABEL_326;
      }
      if (!*(void *)(v227 + v223) || (v225 & 1) == 0) {
        goto LABEL_326;
      }
      if (!sub_1BB9C9444(v226, v224, *v159)) {
        break;
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int v229 = *(_DWORD *)(a1 + 24);
        if (v229 <= 1718908519)
        {
          if (v229 != 1684632424)
          {
            unsigned int v230 = "H.264";
            int v231 = 1685481521;
            goto LABEL_331;
          }
          goto LABEL_332;
        }
        if (v229 == 1752589105) {
          goto LABEL_332;
        }
        unsigned int v230 = "H.264";
        int v231 = 1718908520;
LABEL_331:
        if (v229 == v231) {
LABEL_332:
        }
          unsigned int v230 = "HEVC";
        int v233 = *(_DWORD *)(a1 + 112);
        int v234 = *(_DWORD *)(a1 + 116);
        int v235 = *((unsigned __int16 *)a2 + 6);
        *(_DWORD *)buf = 134219266;
        uint64_t v265 = a1;
        __int16 v266 = 1024;
        *(_DWORD *)int v267 = v233;
        *(_WORD *)&v267[4] = 1024;
        *(_DWORD *)&v267[6] = v234;
        *(_WORD *)__int16 v268 = 2080;
        *(void *)&v268[2] = v230;
        __int16 v269 = 1024;
        *(_DWORD *)long long v270 = v224;
        *(_WORD *)&v270[4] = 1024;
        *(_DWORD *)&v270[6] = v235;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Failed to stitch non-dirty tile (id %d, order %d)\n", buf, 0x2Eu);
      }
LABEL_327:
      ++v224;
      int64_t v232 = *(int *)(a1 + 136);
      v223 += 24;
      if ((uint64_t)v224 >= v232)
      {
        int v202 = *(unsigned __int16 *)(a1 + 158);
        int v204 = ~(-1 << v232);
        a6 = v249;
        goto LABEL_343;
      }
    }
    *(_WORD *)(a1 + 158) |= 1 << v224;
LABEL_326:
    LOWORD(v225) = (unsigned __int16)v225 >> 1;
    goto LABEL_327;
  }
  a6 = v249;
  if (!*(unsigned char *)(a1 + 164))
  {
    if (v184 == v185)
    {
      if (*((unsigned __int16 *)a2 + 6) != *(unsigned __int16 *)(a1 + 156))
      {
        int v33 = 0;
        *(unsigned char *)(a1 + 164) = 1;
        *(_WORD *)(a1 + 158) = 0;
        goto LABEL_304;
      }
      goto LABEL_267;
    }
    int v33 = 0;
    a4 = v247;
    a7 = v248;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_138;
    }
    int v237 = *(_DWORD *)(a1 + 112);
    int v236 = *(_DWORD *)(a1 + 116);
    int v238 = *(_DWORD *)(a1 + 24);
    float v239 = "H.264";
    if (v238 > 1718908519)
    {
      if (v238 == 1752589105) {
        goto LABEL_361;
      }
      int v240 = 1718908520;
    }
    else
    {
      if (v238 == 1684632424) {
        goto LABEL_361;
      }
      int v240 = 1685481521;
    }
    if (v238 != v240)
    {
LABEL_362:
      *(_DWORD *)buf = 134219266;
      uint64_t v265 = a1;
      __int16 v266 = 1024;
      *(_DWORD *)int v267 = v237;
      *(_WORD *)&v267[4] = 1024;
      *(_DWORD *)&v267[6] = v236;
      *(_WORD *)__int16 v268 = 2080;
      *(void *)&v268[2] = v239;
      __int16 v269 = 1024;
      *(_DWORD *)long long v270 = v185;
      *(_WORD *)&v270[4] = 1024;
      *(_DWORD *)&v270[6] = v184;
      unsigned int v241 = MEMORY[0x1E4F14500];
      unsigned __int8 v242 = "VCPDec %p (%dx%d, %s): Timestamp does not match, expected: %d, actual: %d\n";
      os_log_type_t v243 = OS_LOG_TYPE_DEFAULT;
      uint32_t v244 = 46;
      goto LABEL_363;
    }
LABEL_361:
    float v239 = "HEVC";
    goto LABEL_362;
  }
  a4 = v247;
  a7 = v248;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
  {
    int v211 = *(_DWORD *)(a1 + 112);
    int v210 = *(_DWORD *)(a1 + 116);
    int v212 = *(_DWORD *)(a1 + 24);
    int v213 = "H.264";
    if (v212 > 1718908519)
    {
      if (v212 == 1752589105) {
        goto LABEL_341;
      }
      int v214 = 1718908520;
    }
    else
    {
      if (v212 == 1684632424) {
        goto LABEL_341;
      }
      int v214 = 1685481521;
    }
    if (v212 != v214)
    {
LABEL_342:
      *(_DWORD *)buf = 134218754;
      uint64_t v265 = a1;
      __int16 v266 = 1024;
      *(_DWORD *)int v267 = v211;
      *(_WORD *)&v267[4] = 1024;
      *(_DWORD *)&v267[6] = v210;
      *(_WORD *)__int16 v268 = 2080;
      *(void *)&v268[2] = v213;
      unsigned int v241 = MEMORY[0x1E4F14500];
      unsigned __int8 v242 = "VCPDec %p (%dx%d, %s): Do not process this subframe because it should be dropped\n";
      os_log_type_t v243 = OS_LOG_TYPE_DEBUG;
      uint32_t v244 = 34;
LABEL_363:
      _os_log_impl(&dword_1BB9B9000, v241, v243, v242, buf, v244);
      goto LABEL_364;
    }
LABEL_341:
    int v213 = "HEVC";
    goto LABEL_342;
  }
LABEL_364:
  int v33 = 0;
LABEL_138:
  int v109 = *(_DWORD *)(a1 + 24);
  if (v109 > 1718908519)
  {
    if (v109 == 1752589105) {
      goto LABEL_144;
    }
    int v110 = 1718908520;
  }
  else
  {
    if (v109 == 1684632424) {
      goto LABEL_144;
    }
    int v110 = 1685481521;
  }
  if (v109 != v110) {
    goto LABEL_147;
  }
LABEL_144:
  if (a3) {
    goto LABEL_145;
  }
  a3 = *(unsigned int *)(a1 + 168);
  if (a3)
  {
    if (a3 == 1 || (int v136 = *((unsigned __int8 *)a2 + 85), v136 == 32) || v136 == 20)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
LABEL_250:
        a3 = 0;
        *(_DWORD *)(a1 + 168) = 0;
        *(unsigned char *)(a1 + 172) = 0;
        goto LABEL_147;
      }
      int v138 = *(_DWORD *)(a1 + 112);
      int v137 = *(_DWORD *)(a1 + 116);
      __int16 v139 = "H.264";
      if (v109 > 1718908519)
      {
        if (v109 == 1752589105) {
          goto LABEL_246;
        }
        int v140 = 1718908520;
      }
      else
      {
        if (v109 == 1684632424) {
          goto LABEL_246;
        }
        int v140 = 1685481521;
      }
      if (v109 != v140)
      {
LABEL_247:
        CFNumberRef v177 = "Decoder recovered by IDR frame";
        *(_DWORD *)buf = 134219010;
        uint64_t v265 = a1;
        __int16 v266 = 1024;
        if (a3 == 1) {
          CFNumberRef v177 = "Decoder recovered from recoverable error";
        }
        *(_DWORD *)int v267 = v138;
        *(_WORD *)&v267[4] = 1024;
        *(_DWORD *)&v267[6] = v137;
        *(_WORD *)__int16 v268 = 2080;
        *(void *)&v268[2] = v139;
        __int16 v269 = 2080;
        *(void *)long long v270 = v177;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): %s\n", buf, 0x2Cu);
        goto LABEL_250;
      }
LABEL_246:
      __int16 v139 = "HEVC";
      goto LABEL_247;
    }
    a3 = 0;
  }
LABEL_147:
  int v111 = *(_DWORD *)(a1 + 24);
  if (v111 > 1718908519)
  {
    if (v111 != 1752589105)
    {
      int v112 = 1718908520;
LABEL_152:
      if (v111 != v112) {
        goto LABEL_161;
      }
    }
  }
  else if (v111 != 1684632424)
  {
    int v112 = 1685481521;
    goto LABEL_152;
  }
  if (*(_DWORD *)(a1 + 168) == 2)
  {
    if (v263)
    {
      CVPixelBufferRelease(v263);
      int16x8_t v263 = 0;
    }
    if (*(unsigned char *)(a1 + 172))
    {
      a3 = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 172) = 0;
      CFStringRef v113 = (const __CFString *)CFPreferencesCopyAppValue(@"ForceOneKeyRequest", @"com.apple.VideoProcessing");
      if (v113)
      {
        CFStringRef v114 = v113;
        *(unsigned char *)(a1 + 172) = CFStringGetIntValue(v113) != 0;
        CFRelease(v114);
      }
      a3 = 4294954387;
    }
  }
LABEL_161:
  CFDictionaryRef v115 = (const __CFDictionary *)*((void *)a2 + 19);
  if (v115 && (v263 || *(void *)(a1 + 192)))
  {
    double v116 = &v263;
    if (*(_DWORD *)(a1 + 136) != 1) {
      double v116 = (__CVBuffer **)(a1 + 192);
    }
    int v117 = *v116;
    if (CFDictionaryContainsKey(v115, @"PropagatableAttachmentsNALSize"))
    {
      CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 19), @"PropagatableAttachmentsNALSize");
      if (Value)
      {
        unint64_t v119 = Value;
        CVBufferSetAttachment(v117, @"PropagatableAttachmentsNALSize", Value, kCVAttachmentMode_ShouldPropagate);
        CFRelease(v119);
      }
    }
    if (CFDictionaryContainsKey(*((CFDictionaryRef *)a2 + 19), @"PropagatableAttachments"))
    {
      BOOL v120 = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 19), @"PropagatableAttachments");
      if (v120) {
        CVBufferSetAttachment(v117, @"PropagatableAttachments", v120, kCVAttachmentMode_ShouldPropagate);
      }
    }
  }
  if (*(unsigned char *)(a1 + 80))
  {
    if ((*(unsigned int (**)(void))(**((void **)a2 + 15) + 88))(*((void *)a2 + 15)))
    {
      CFNumberRef v121 = CFNumberCreate(0, kCFNumberSInt64Type, (const void *)(*((void *)a2 + 15) + 88));
      if (v121)
      {
        CFNumberRef v122 = v121;
        if (v263) {
          CVBufferSetAttachment(v263, @"HIDTimeStamp", v121, kCVAttachmentMode_ShouldPropagate);
        }
        double v123 = *(__CVBuffer **)(a1 + 192);
        if (v123) {
          CVBufferSetAttachment(v123, @"HIDTimeStamp", v122, kCVAttachmentMode_ShouldPropagate);
        }
        CFRelease(v122);
      }
    }
  }
  __int16 v124 = v263;
  if (*((unsigned char *)a2 + 112) && v263) {
    CVBufferSetAttachment(v263, @"FrameMLEnahnced", (CFTypeRef)*MEMORY[0x1E4F1CFD0], kCVAttachmentMode_ShouldPropagate);
  }
  kdebug_trace();
  unint64_t v125 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, __CVBuffer *, long long *, long long *))(a1 + 28);
  uint64_t v126 = *(void *)(a1 + 36);
  uint64_t v127 = *(void *)a2;
  if (*(int *)(a1 + 136) < 2)
  {
    long long v252 = *a6;
    uint64_t v253 = *((void *)a6 + 2);
    long long v250 = *a7;
    uint64_t v251 = *((void *)a7 + 2);
    double v129 = &v252;
    double v130 = &v250;
    uint64_t v131 = a3;
    uint64_t v132 = a4;
    __int16 v133 = v124;
LABEL_188:
    v125(v126, v127, v131, v132, v133, v129, v130);
    goto LABEL_189;
  }
  if (!v33)
  {
    long long v256 = *a6;
    uint64_t v257 = *((void *)a6 + 2);
    long long v254 = *a7;
    uint64_t v255 = *((void *)a7 + 2);
    double v129 = &v256;
    double v130 = &v254;
    uint64_t v131 = a3;
    uint64_t v132 = a4;
    __int16 v133 = 0;
    goto LABEL_188;
  }
  double v128 = *(__CVBuffer **)(a1 + 192);
  long long v256 = *a6;
  uint64_t v257 = *((void *)a6 + 2);
  long long v254 = *a7;
  uint64_t v255 = *((void *)a7 + 2);
  v125(v126, v127, a3, a4, v128, &v256, &v254);
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 192));
  *(void *)(a1 + 192) = 0;
LABEL_189:
  CVPixelBufferRelease(v124);
LABEL_190:
  uint64_t v134 = sub_1BB9E78BC((uint64_t)a2);
  return MEMORY[0x1C18605E0](v134, 0x10A0C40B5D84229);
}

uint64_t sub_1BB9E6C6C(uint64_t a1, _DWORD *a2, __CVBuffer **a3)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 2296) & 0xC) == 0) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 2304);
  uint64_t v8 = *(unsigned int *)(v7 + 120);
  if ((int)v8 < 1) {
    goto LABEL_10;
  }
  uint64_t v9 = 0;
  uint64_t v10 = (__int16 *)&qword_1E9F81490 + 2;
  while (a2[24] > *(v10 - 1) && a2[25] > *v10)
  {
    ++v9;
    v10 += 3;
    if (v8 == v9) {
      goto LABEL_10;
    }
  }
  if (v9 == 1 || (*(_DWORD *)(v7 + 32) & 8) == 0)
  {
    uint64_t v12 = (unsigned __int16)*(v10 - 1);
    int v14 = (unsigned __int8 *)&qword_1E9F81490 + 6 * v9;
    int v13 = *v14;
    unsigned __int8 v3 = v14[1];
    uint64_t v11 = *((unsigned __int16 *)v14 + 2);
  }
  else
  {
LABEL_10:
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    int v13 = 0;
  }
  int v15 = v12 << 16;
  int v16 = (__int16)v12;
  unint64_t v17 = ((v12 << 16) | (unint64_t)(v11 << 32)) >> 16;
  uint64_t result = sub_1BB9E729C(a1, a2, a3, (__int16)v12, (int)v17 >> 16);
  if (result) {
    return 4294954385;
  }
  if ((v13 & 0xFFFF00FF | (v3 << 8) | v15) >= 0x10000 && v17 >= 0x10000)
  {
    *(unsigned char *)(a1 + 2344) = 0;
    *(void *)(a1 + 2312) = 0;
    sub_1BBA3F68C(a1 + 2312);
    uint64_t v19 = *(void *)(a1 + 2304);
    CVPixelBufferRef v20 = *a3;
    *(void *)CMTime pixelBufferOut = 0;
    int v51 = (std::mutex *)(v19 + 48);
    std::mutex::lock((std::mutex *)(v19 + 48));
    if (!*(unsigned char *)(v19 + 16) || !*(void *)v19) {
      goto LABEL_27;
    }
    uint64_t v21 = *(unsigned int *)(v19 + 120);
    if ((int)v21 >= 1)
    {
      uint64_t v22 = 0;
      int v23 = (__int16 *)&qword_1E9F81490 + 2;
      while (v16 != *(v23 - 1) || (int)v17 >> 16 != *v23)
      {
        ++v22;
        v23 += 3;
        if (v21 == v22) {
          goto LABEL_25;
        }
      }
      *(void *)(v19 + 8) = *(void *)v19 + 616 * v22;
    }
LABEL_25:
    if (!*(void *)(v19 + 8)
      || CVPixelBufferPoolCreatePixelBuffer(0, *(CVPixelBufferPoolRef *)(v19 + 24), (CVPixelBufferRef *)pixelBufferOut))
    {
      goto LABEL_27;
    }
    if (*(unsigned char *)(v19 + 124)) {
      goto LABEL_61;
    }
    pixelBuffer = v20;
    if (!CVPixelBufferLockBaseAddress(v20, 1uLL))
    {
      int BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v20, 0);
      BaseAddressOfPlane = (const unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(v20, 0);
      uint64_t v31 = *(void *)(v19 + 8);
      int v32 = *(float **)(v31 + 40);
      uint64_t v33 = *(void *)(v31 + 120);
      vDSP_Length v34 = v33;
      int v35 = *(_DWORD *)(v31 + 128);
      float __B = 0.0039216;
      float v52 = -0.5;
      uint64_t v50 = 4 * v33;
      float __C = v32;
      int v44 = v35 * v33;
      vDSP_Length __N = (2 * v35 * v33);
      if (v35)
      {
        CFStringRef v36 = BaseAddressOfPlane;
        uint64_t v47 = 2 * BytesPerRowOfPlane;
        uint64_t v48 = BytesPerRowOfPlane;
        CFStringRef v37 = v32;
        int v38 = v35;
        do
        {
          vDSP_vfltu8(v36, 2, v37, 1, v34);
          vDSP_vfltu8(v36 + 1, 2, &v37[v44], 1, v34);
          vDSP_vfltu8(&v36[v48], 2, &v37[(int)__N], 1, v34);
          vDSP_vfltu8(&v36[v48 + 1], 2, &v37[3 * v44], 1, v34);
          v36 += v47;
          CFStringRef v37 = (float *)((char *)v37 + v50);
          --v38;
        }
        while (v38);
      }
      vDSP_vsmul(__C, 1, &__B, __C, 1, (4 * v44));
      int v39 = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
      int v40 = (const unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
      __A = &__C[4 * v44];
      if (v35)
      {
        int v41 = v40;
        int v42 = &__C[4 * v44];
        do
        {
          vDSP_vfltu8(v41, 2, v42, 1, v34);
          vDSP_vfltu8(v41 + 1, 2, &v42[v44], 1, v34);
          v41 += v39;
          int v42 = (float *)((char *)v42 + v50);
          --v35;
        }
        while (v35);
      }
      vDSP_vsmul(__A, 1, &__B, __A, 1, __N);
      vDSP_vsadd(__A, 1, &v52, __A, 1, __N);
      CVPixelBufferRef v20 = pixelBuffer;
      if (!CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL))
      {
LABEL_61:
        if (*(unsigned char *)(*(void *)(v19 + 8) + 608)
          && (espresso_network_bind_direct_cvpixelbuffer()
           || espresso_network_bind_direct_cvpixelbuffer())
          || espresso_plan_execute_sync())
        {
LABEL_27:
          CVPixelBufferRelease(*(CVPixelBufferRef *)pixelBufferOut);
          goto LABEL_28;
        }
        if (*(unsigned char *)(v19 + 124) || !sub_1BB9BEA18(v19, *(CVPixelBufferRef *)pixelBufferOut))
        {
          CVBufferPropagateAttachments(v20, *(CVBufferRef *)pixelBufferOut);
          *a3 = *(__CVBuffer **)pixelBufferOut;
          CVPixelBufferRelease(v20);
          std::mutex::unlock(v51);
          *((unsigned char *)a2 + 112) = 1;
          goto LABEL_37;
        }
      }
    }
LABEL_28:
    std::mutex::unlock(v51);
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
LABEL_37:
      sub_1BBA3F6DC(a1 + 2312);
      uint64_t result = *(void *)(a1 + 2224);
      if (!result) {
        return result;
      }
      sub_1BBAC8868(result, (uint64_t *)"ml_enhanced_frames", 1.0);
      sub_1BBAC8868(*(void *)(a1 + 2224), (uint64_t *)"ml_enhance_time", *(double *)(a1 + 2312));
      return 0;
    }
    int v25 = *(_DWORD *)(a1 + 112);
    int v24 = *(_DWORD *)(a1 + 116);
    int v26 = *(_DWORD *)(a1 + 24);
    size_t v27 = "H.264";
    if (v26 > 1718908519)
    {
      if (v26 == 1752589105) {
        goto LABEL_35;
      }
      int v28 = 1718908520;
    }
    else
    {
      if (v26 == 1684632424) {
        goto LABEL_35;
      }
      int v28 = 1685481521;
    }
    if (v26 != v28)
    {
LABEL_36:
      *(_DWORD *)CMTime pixelBufferOut = 134218754;
      *(void *)&pixelBufferOut[4] = a1;
      __int16 v55 = 1024;
      int v56 = v25;
      __int16 v57 = 1024;
      int v58 = v24;
      __int16 v59 = 2080;
      int v60 = v27;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder failed to enhance the frame!\n", pixelBufferOut, 0x22u);
      goto LABEL_37;
    }
LABEL_35:
    size_t v27 = "HEVC";
    goto LABEL_36;
  }
  return result;
}

void sub_1BB9E7268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::mutex *a21)
{
}

uint64_t sub_1BB9E729C(uint64_t a1, _DWORD *a2, __CVBuffer **a3, int a4, int a5)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a3;
  CVPixelBufferRef pixelBufferOut = 0;
  int v12 = *(_DWORD *)(a1 + 112);
  int v11 = *(_DWORD *)(a1 + 116);
  int Width = CVPixelBufferGetWidth(v10);
  int Height = CVPixelBufferGetHeight(v10);
  int v15 = Height;
  int v16 = a2[24];
  if (v16 == v12 && a2[25] == v11 || v16 == Width && a2[25] == Height) {
    return 0;
  }
  __int16 v17 = CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CVPixelBufferPoolRef *)(a1 + 2240), &pixelBufferOut);
  if (v17)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
LABEL_8:
      CVPixelBufferRelease(pixelBufferOut);
      return v17;
    }
    int v33 = *(_DWORD *)(a1 + 112);
    int v32 = *(_DWORD *)(a1 + 116);
    int v34 = *(_DWORD *)(a1 + 24);
    int v35 = "H.264";
    if (v34 > 1718908519)
    {
      if (v34 == 1752589105) {
        goto LABEL_46;
      }
      int v36 = 1718908520;
    }
    else
    {
      if (v34 == 1684632424) {
        goto LABEL_46;
      }
      int v36 = 1685481521;
    }
    if (v34 != v36)
    {
LABEL_47:
      *(_DWORD *)buf = 134218754;
      uint64_t v55 = a1;
      __int16 v56 = 1024;
      int v57 = v33;
      __int16 v58 = 1024;
      int v59 = v32;
      __int16 v60 = 2080;
      uint64_t v61 = v35;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Decoder failed to create dst buffer for up scaling!\n", buf, 0x22u);
      goto LABEL_8;
    }
LABEL_46:
    int v35 = "HEVC";
    goto LABEL_47;
  }
  v63.origin.x = (double)(int)a2[26];
  v63.origin.y = (double)(int)a2[27];
  v63.size.int32_t width = (double)(int)a2[24];
  v63.size.int32_t height = (double)(int)a2[25];
  CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v63);
  if (Width >= a4) {
    int v19 = a4;
  }
  else {
    int v19 = Width;
  }
  if (a4 <= 0) {
    int v19 = Width;
  }
  double v20 = (double)v19;
  if (v15 >= a5) {
    int v21 = a5;
  }
  else {
    int v21 = v15;
  }
  if (a5 <= 0) {
    int v21 = v15;
  }
  double v22 = (double)v21;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  CFDictionaryRef v25 = CGRectCreateDictionaryRepresentation(*(CGRect *)(&v20 - 2));
  int v26 = *(const void **)(a1 + 96);
  if (v26 && DictionaryRepresentation)
  {
    if (!VTSessionSetProperty(v26, @"SourceCropRectangle", DictionaryRepresentation)
      || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
LABEL_37:
      if (!v25
        || !VTSessionSetProperty(*(VTSessionRef *)(a1 + 96), @"DestinationRectangle", v25)
        || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
LABEL_53:
        __int16 v17 = VTPixelTransferSessionTransferImage(*(VTPixelTransferSessionRef *)(a1 + 96), v10, pixelBufferOut);
        if (!v17)
        {
          CVBufferPropagateAttachments(v10, pixelBufferOut);
          *a3 = pixelBufferOut;
          goto LABEL_57;
        }
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
LABEL_55:
          uint64_t v10 = pixelBufferOut;
LABEL_57:
          CVPixelBufferRelease(v10);
          goto LABEL_58;
        }
        int v49 = *(_DWORD *)(a1 + 112);
        int v48 = *(_DWORD *)(a1 + 116);
        int v50 = *(_DWORD *)(a1 + 24);
        int v51 = "H.264";
        if (v50 > 1718908519)
        {
          if (v50 == 1752589105) {
            goto LABEL_76;
          }
          int v52 = 1718908520;
        }
        else
        {
          if (v50 == 1684632424) {
            goto LABEL_76;
          }
          int v52 = 1685481521;
        }
        if (v50 != v52)
        {
LABEL_77:
          *(_DWORD *)buf = 134218754;
          uint64_t v55 = a1;
          __int16 v56 = 1024;
          int v57 = v49;
          __int16 v58 = 1024;
          int v59 = v48;
          __int16 v60 = 2080;
          uint64_t v61 = v51;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Decoder failed to do up scaling!\n", buf, 0x22u);
          goto LABEL_55;
        }
LABEL_76:
        int v51 = "HEVC";
        goto LABEL_77;
      }
      int v38 = *(_DWORD *)(a1 + 112);
      int v37 = *(_DWORD *)(a1 + 116);
      int v39 = *(_DWORD *)(a1 + 24);
      int v40 = "H.264";
      if (v39 > 1718908519)
      {
        if (v39 == 1752589105) {
          goto LABEL_51;
        }
        int v41 = 1718908520;
      }
      else
      {
        if (v39 == 1684632424) {
          goto LABEL_51;
        }
        int v41 = 1685481521;
      }
      if (v39 != v41)
      {
LABEL_52:
        *(_DWORD *)buf = 134218754;
        uint64_t v55 = a1;
        __int16 v56 = 1024;
        int v57 = v38;
        __int16 v58 = 1024;
        int v59 = v37;
        __int16 v60 = 2080;
        uint64_t v61 = v40;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder failed to set DestinationRectangle for up_scaling_session\n", buf, 0x22u);
        goto LABEL_53;
      }
LABEL_51:
      int v40 = "HEVC";
      goto LABEL_52;
    }
    int v28 = *(_DWORD *)(a1 + 112);
    int v27 = *(_DWORD *)(a1 + 116);
    int v29 = *(_DWORD *)(a1 + 24);
    int v30 = "H.264";
    if (v29 > 1718908519)
    {
      if (v29 == 1752589105) {
        goto LABEL_35;
      }
      int v31 = 1718908520;
    }
    else
    {
      if (v29 == 1684632424) {
        goto LABEL_35;
      }
      int v31 = 1685481521;
    }
    if (v29 != v31)
    {
LABEL_36:
      *(_DWORD *)buf = 134218754;
      uint64_t v55 = a1;
      __int16 v56 = 1024;
      int v57 = v28;
      __int16 v58 = 1024;
      int v59 = v27;
      __int16 v60 = 2080;
      uint64_t v61 = v30;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): Decoder failed to set SourceCropRectangle for up_scaling_session\n", buf, 0x22u);
      goto LABEL_37;
    }
LABEL_35:
    int v30 = "HEVC";
    goto LABEL_36;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    int v44 = *(_DWORD *)(a1 + 112);
    int v43 = *(_DWORD *)(a1 + 116);
    int v45 = *(_DWORD *)(a1 + 24);
    int v46 = "H.264";
    if (v45 > 1718908519)
    {
      if (v45 == 1752589105) {
        goto LABEL_71;
      }
      int v47 = 1718908520;
    }
    else
    {
      if (v45 == 1684632424) {
        goto LABEL_71;
      }
      int v47 = 1685481521;
    }
    if (v45 != v47)
    {
LABEL_72:
      *(_DWORD *)buf = 134218754;
      uint64_t v55 = a1;
      __int16 v56 = 1024;
      int v57 = v44;
      __int16 v58 = 1024;
      int v59 = v43;
      __int16 v60 = 2080;
      uint64_t v61 = v46;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPDec %p (%dx%d, %s): Decoder failed to do up scaling!\n", buf, 0x22u);
      goto LABEL_27;
    }
LABEL_71:
    int v46 = "HEVC";
    goto LABEL_72;
  }
LABEL_27:
  CVPixelBufferRelease(pixelBufferOut);
  __int16 v17 = -12911;
  if (DictionaryRepresentation) {
LABEL_58:
  }
    CFRelease(DictionaryRepresentation);
  if (v25) {
    CFRelease(v25);
  }
  return v17;
}

uint64_t sub_1BB9E78BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)(a1 + 120) = 0;
  sub_1BB9BE228((const void **)(a1 + 152));
  return a1;
}

uint64_t sub_1BB9E791C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 4632);
  if (v2) {
    sub_1BB9C09B4(v2);
  }
  unsigned __int8 v3 = *(std::__shared_weak_count **)(a1 + 4616);
  if (v3) {
    sub_1BB9C09B4(v3);
  }
  for (uint64_t i = 4600; i != 504; i -= 16)
  {
    int v5 = *(std::__shared_weak_count **)(a1 + i);
    if (v5) {
      sub_1BB9C09B4(v5);
    }
  }
  do
  {
    BOOL v6 = *(std::__shared_weak_count **)(a1 + i);
    if (v6) {
      sub_1BB9C09B4(v6);
    }
    i -= 16;
  }
  while (i != -8);
  return a1;
}

uint64_t sub_1BB9E798C(const void *a1, size_t blockLength, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CMBlockBufferRef destinationBuffer = 0;
  if (!blockLength)
  {
    a3 = 0;
    *a4 = 0;
    return a3;
  }
  if (CMBlockBufferCreateWithMemoryBlock(0, 0, blockLength, 0, 0, 0, blockLength, 1u, &destinationBuffer))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      uint64_t v8 = MEMORY[0x1E4F14500];
      uint64_t v9 = "CFPropertyList_DeserializeAtomData failed at BlockBufferCreateWithMemoryBlock";
LABEL_9:
      uint32_t v10 = 2;
LABEL_10:
      _os_log_error_impl(&dword_1BB9B9000, v8, OS_LOG_TYPE_ERROR, v9, buf, v10);
      goto LABEL_13;
    }
    goto LABEL_13;
  }
  if (CMBlockBufferReplaceDataBytes(a1, destinationBuffer, 0, blockLength))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      uint64_t v8 = MEMORY[0x1E4F14500];
      uint64_t v9 = "CFPropertyList_DeserializeAtomData failed at BlockBufferReplaceDataBytes";
      goto LABEL_9;
    }
LABEL_13:
    if (*a4)
    {
      CFRelease(a4);
      *a4 = 0;
    }
    a3 = 4294967246;
    goto LABEL_16;
  }
  int CFTypeFromSerializedAtomDataBlockBuffer = FigRemote_CreateCFTypeFromSerializedAtomDataBlockBuffer();
  if (CFTypeFromSerializedAtomDataBlockBuffer)
  {
    int v12 = CFTypeFromSerializedAtomDataBlockBuffer;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_13;
    }
    *(_DWORD *)buf = 67109120;
    int v16 = v12;
    uint64_t v8 = MEMORY[0x1E4F14500];
    uint64_t v9 = "CFPropertyList_DeserializeAtomData failed at TypeFromSerializedAtomDataBlockBuffer (%d)";
    goto LABEL_25;
  }
  if (a3)
  {
    if (CFGetTypeID(*a4) != a3)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_13;
      }
      *(_DWORD *)buf = 67109120;
      int v16 = 0;
      uint64_t v8 = MEMORY[0x1E4F14500];
      uint64_t v9 = "CFPropertyList DeserializeAtomData wrong type ID(%d)";
LABEL_25:
      uint32_t v10 = 8;
      goto LABEL_10;
    }
    a3 = 0;
  }
LABEL_16:
  if (destinationBuffer) {
    CFRelease(destinationBuffer);
  }
  return a3;
}

uint64_t sub_1BB9E7BBC(UInt8 *bytes, CFIndex length, CFTypeID a3, CFTypeRef *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (length)
  {
    CFDataRef v6 = CFDataCreateWithBytesNoCopy(0, bytes, length, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CFErrorRef error = 0;
    CFDataRef v18 = v6;
    CFPropertyListRef v7 = CFPropertyListCreateWithData(0, v6, 0, 0, &error);
    *a4 = v7;
    if (error)
    {
      CFStringRef v8 = CFCopyTypeIDDescription(a3);
      CFStringRef v16 = v8;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        CStringPtr = CFStringGetCStringPtr(v8, 0x8000100u);
        CFStringRef v13 = CFErrorCopyFailureReason(error);
        int v14 = CFStringGetCStringPtr(v13, 0x8000100u);
        *(_DWORD *)buf = 136315394;
        double v20 = CStringPtr;
        __int16 v21 = 2080;
        double v22 = v14;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to deserialize %s (%s)", buf, 0x16u);
      }
LABEL_5:
      sub_1BB9BE158((const void **)&v16);
      sub_1BB9BE18C((const void **)&error);
      sub_1BB9BE124((const void **)&v18);
      return 4294967246;
    }
    if (a3 && CFGetTypeID(v7) != a3)
    {
      CFTypeID v10 = CFGetTypeID(*a4);
      CFStringRef v11 = CFCopyTypeIDDescription(v10);
      CFStringRef v16 = v11;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v15 = CFStringGetCStringPtr(v11, 0x8000100u);
        *(_DWORD *)buf = 136315138;
        double v20 = v15;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Deserialized unexpected type (%s)", buf, 0xCu);
      }
      CFRelease(*a4);
      *a4 = 0;
      goto LABEL_5;
    }
    sub_1BB9BE18C((const void **)&error);
    sub_1BB9BE124((const void **)&v18);
    return 0;
  }
  else
  {
    uint64_t result = 0;
    *a4 = 0;
  }
  return result;
}

void sub_1BB9E7DC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  unsigned __int8 v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v5 = va_arg(va2, const void *);
  sub_1BB9BE158((const void **)va);
  sub_1BB9BE18C((const void **)va1);
  sub_1BB9BE124((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9E7E00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  char *returnedPointerOut;
  int temporaryBlock;
  uint8_t v264[4616];
  std::__shared_weak_count *v265;
  std::__shared_weak_count *v266;
  char *v267;
  char v268[24];
  uint8_t buf[4];
  int v270;
  __int16 v271;
  int v272;
  uint64_t v273;

  CFDataRef v6 = (opaqueCMSampleBuffer *)MEMORY[0x1F4188790](a1, a2, a3, a4, a5, a6);
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  CFStringRef v11 = v6;
  int v273 = *MEMORY[0x1E4F143B8];
  long long v226 = 0uLL;
  int v227 = -1;
  char v228 = 0;
  int v12 = *(uint8_t **)(v9 + 2360);
  DataBuffer = CMSampleBufferGetDataBuffer(v6);
  DataCFIndex Length = CMBlockBufferGetDataLength(DataBuffer);
  int v267 = 0;
  bzero(v264, 0x1220uLL);
  uint64_t v225 = v8;
  if (v12) {
    goto LABEL_2;
  }
  FormatDescription = CMSampleBufferGetFormatDescription(v11);
  if (!FormatDescription)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_280;
    }
    LOWORD(v239[0]) = 0;
    int v198 = MEMORY[0x1E4F14500];
    __int16 v199 = "Warning: VCPReadH264SliceHeader() parameter_sets_h264 = NULL and no videoFormatDescription in sample_buffer!";
LABEL_279:
    _os_log_error_impl(&dword_1BB9B9000, v198, OS_LOG_TYPE_ERROR, v199, (uint8_t *)v239, 2u);
    goto LABEL_280;
  }
  CFDictionaryRef Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(FormatDescription, (CFStringRef)*MEMORY[0x1E4F1EE20]);
  if (!Extension)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_280;
    }
    LOWORD(v239[0]) = 0;
    int v198 = MEMORY[0x1E4F14500];
    __int16 v199 = "Warning: VCPReadH264SliceHeader() parameter_sets_h264 = NULL and no videoFormatDescription extensions in sample_buffer!";
    goto LABEL_279;
  }
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(Extension, @"avcC");
  CFDataRef v193 = Value;
  if (!Value)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v239[0]) = 0;
      int v198 = MEMORY[0x1E4F14500];
      __int16 v199 = "Warning: VCPReadH264SliceHeader() parameter_sets_h264 = NULL and no avcC_data in sample_buffer!";
      goto LABEL_279;
    }
LABEL_280:
    uint64_t v16 = 4294954394;
    goto LABEL_281;
  }
  BytePtr = CFDataGetBytePtr(Value);
  CFIndex Length = CFDataGetLength(v193);
  uint64_t v16 = sub_1BBAE8AF4((uint64_t)BytePtr, Length, 0, (uint64_t)v264, v196, v197);
  if (v16)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v239[0]) = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Warning: VCPReadH264SliceHeader() LRPConfigInfo_avcc parsing error!", (uint8_t *)v239, 2u);
    }
    goto LABEL_281;
  }
  int v12 = v264;
LABEL_2:
  if (DataLength >= 5)
  {
    unint64_t v223 = 0;
    size_t v15 = 0;
    uint64_t v16 = 0;
    uint32_t v220 = v12 + 4624;
    int v219 = v12 + 4632;
    OSType v217 = v12 + 4608;
    int v216 = v12 + 4616;
    int v222 = v12;
    size_t v17 = 4;
    size_t v224 = DataLength;
    while (1)
    {
      temporaryBlocuint64_t k = 0;
      returnedPointerOut = 0;
      CMBlockBufferAccessDataBytes(DataBuffer, v15, 4uLL, &temporaryBlock, &returnedPointerOut);
      int v18 = bswap32(*(_DWORD *)returnedPointerOut);
      if (v18 >= 24) {
        int v19 = 24;
      }
      else {
        int v19 = v18;
      }
      uint64_t v20 = v19;
      CMBlockBufferAccessDataBytes(DataBuffer, v17, v19, v268, &v267);
      int v21 = *v267;
      if (v21 < 0) {
        goto LABEL_19;
      }
      int v22 = v21 & 0x1F;
      if ((v22 - 1) > 4) {
        goto LABEL_19;
      }
      v246[4] = 0;
      char v247 = 0;
      unsigned int v248 = 0;
      char v250 = 0;
      *(_OWORD *)float v239 = 0u;
      long long v240 = 0u;
      __int16 v241 = 0;
      uint64_t v243 = 0;
      uint64_t v244 = 0;
      uint64_t v242 = 0;
      __int16 v245 = 0;
      memset(v246, 0, 13);
      uint64_t v251 = 0;
      v252[0] = 0;
      *(void *)((char *)v252 + 7) = 0;
      v258[0] = 0;
      v258[1] = 0;
      int16x8_t v260 = 0;
      uint64_t v261 = 0;
      int8x8_t v259 = 0;
      *(void *)&long long v235 = 1;
      *((void *)&v235 + 1) = v267;
      *(void *)&long long v237 = sub_1BB9FD104;
      *((void *)&v237 + 1) = 0;
      off_1EC59CAB8 = (uint64_t (*)(void, void, void, void, void))sub_1BB9FD21C;
      int v238 = 0;
      int v234 = &unk_1F14EDC80;
      *((void *)&v236 + 1) = v20;
      LOWORD(v236) = -192;
      if (v20)
      {
        if ((*v267 & 0x80000000) == 0)
        {
          int v23 = *v267 >> 5;
          int v238 = v23;
          char v24 = *v267;
          LOBYTE(v236) = *v267 & 0x1F;
          if (v20 > 1 || (v24 & 0x1E) == 0xA) {
            break;
          }
        }
      }
      CFDictionaryRef v25 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, v25, OS_LOG_TYPE_ERROR, "failed to init nalu from buffer", buf, 2u);
      }
      char v26 = 0;
      uint64_t v16 = 4294954387;
LABEL_16:
      if (v258[0]) {
        free(v258[0]);
      }
      if ((v26 & 1) == 0) {
        goto LABEL_281;
      }
LABEL_19:
      size_t v15 = v17 + v18;
      size_t v17 = v15 + 4;
      if (v15 + 4 >= DataLength) {
        goto LABEL_281;
      }
    }
    if (v223 >= 4)
    {
      if (dword_1E9F80A90 >= 3)
      {
        int v27 = MEMORY[0x1E4F14500];
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1BB9B9000, v27, OS_LOG_TYPE_DEFAULT, "Warning: only 4 slices supported by VCPReadH264SliceHeader(), ignored the rest!", buf, 2u);
        }
      }
LABEL_264:
      char v26 = 0;
      goto LABEL_16;
    }
    char v228 = v22;
    *((_DWORD *)&v226 + v223) = v18 + 4;
    long long v231 = v236;
    long long v232 = v237;
    long long v230 = v235;
    int v229 = &unk_1F14EDC80;
    int v233 = v23;
    v239[0] = v23;
    v239[1] = v236;
    sub_1BBA194F8(v258, &v229);
    int v28 = MEMORY[0x1E4F14500];
    if (!v222)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, v28, OS_LOG_TYPE_ERROR, "SliceHeaderH264::Parse() parameter_sets should not be NULL", buf, 2u);
      }
      uint64_t v16 = 4294954387;
LABEL_262:
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Warning: VCPReadH264SliceHeader() slice header parsing error!", buf, 2u);
      }
      goto LABEL_264;
    }
    v239[2] = sub_1BBA19824((uint64_t)v258);
    LODWORD(v240) = sub_1BBA1979C((uint64_t)v258);
    unsigned int v29 = sub_1BBA1979C((uint64_t)v258);
    DWORD1(v240) = v29;
    int v30 = &v222[16 * v29];
    int v31 = v30 + 512;
    if (v29 > 0xFF) {
      int v31 = v220;
    }
    uint64_t v32 = *(void *)v31;
    int v33 = (std::__shared_weak_count **)(v30 + 520);
    if (v29 > 0xFF) {
      int v33 = (std::__shared_weak_count **)v219;
    }
    int v34 = *v33;
    if (*v33) {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v32)
    {
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        long long v270 = DWORD1(v240);
        _os_log_error_impl(&dword_1BB9B9000, v28, OS_LOG_TYPE_ERROR, "SliceHeaderH264::Parse() pps with pic_parameter_set_id = %d is not available", buf, 8u);
      }
      int v47 = 0;
      char v48 = 0;
      uint64_t v16 = 4294954387;
      if (!v34)
      {
LABEL_258:
        if (v47) {
          sub_1BB9C09B4(v47);
        }
        if (v48)
        {
          uint64_t v16 = 0;
          *((unsigned char *)&v226 + v223++ + 16) = v249;
          char v26 = 1;
          goto LABEL_16;
        }
        goto LABEL_262;
      }
LABEL_257:
      uint64_t v188 = v34;
      uint64_t v189 = v47;
      sub_1BB9C09B4(v188);
      int v47 = v189;
      goto LABEL_258;
    }
    uint64_t v35 = *(unsigned int *)(v32 + 4);
    int v36 = &v222[16 * v35];
    BOOL v37 = v35 > 0x1F;
    int v38 = v217;
    if (!v37) {
      int v38 = v36;
    }
    uint64_t v39 = *(void *)v38;
    int v40 = v36 + 8;
    if (v37) {
      int v40 = v216;
    }
    int v41 = *(std::__shared_weak_count **)v40;
    if (*(void *)v40) {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v218 = v32;
    int v214 = v41;
    int v215 = v34;
    if (!v39)
    {
      int v49 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v50 = *(_DWORD *)(v218 + 4);
        *(_DWORD *)buf = 67109120;
        long long v270 = v50;
        int v51 = v49;
        int v52 = "SliceHeaderH264::Parse() sps with seq_parameter_set_id = %d is not available";
        goto LABEL_252;
      }
      goto LABEL_255;
    }
    unsigned int v42 = v261;
    int v43 = HIDWORD(v261);
    int v44 = v259;
    if (*(unsigned char *)(v39 + 19))
    {
      unint64_t v45 = SHIDWORD(v261) + 2;
      int v43 = v45 & 7;
      HIDWORD(v261) = v43;
      int v44 = (unsigned int *)((char *)v259 + (v45 >> 3));
      int8x8_t v259 = v44;
      if (v44 >= v260)
      {
        if (v44 > v260) {
          int v44 = v260;
        }
        unsigned int v46 = v261;
      }
      else
      {
        unsigned int v46 = bswap32(*v44);
      }
      unsigned int v53 = v261 >> 30;
      unsigned int v42 = v46 << v43;
      LODWORD(v261) = v46 << v43;
      DWORD2(v240) = v53;
    }
    int v54 = *(_DWORD *)(v39 + 272);
    unint64_t v55 = v43 + (uint64_t)(v54 + 4);
    char v56 = v55 & 7;
    HIDWORD(v261) = v55 & 7;
    int v57 = (unsigned int *)((char *)v44 + (v55 >> 3));
    int8x8_t v259 = v57;
    if (v57 >= v260)
    {
      unsigned int v58 = v42;
      if (v57 > v260)
      {
        int8x8_t v259 = v260;
        int v57 = v260;
        unsigned int v58 = v42;
      }
    }
    else
    {
      unsigned int v58 = bswap32(*v57);
    }
    unsigned int v59 = v42 >> (28 - v54);
    int v60 = v58 << v56;
    LODWORD(v261) = v58 << v56;
    HIDWORD(v240) = v59;
    if (!*(unsigned char *)(v39 + 1336))
    {
      unint64_t v61 = (v55 & 7) + 1;
      HIDWORD(v261) = v61 & 7;
      uint64_t v62 = (unsigned int *)((char *)v57 + (v61 >> 3));
      int8x8_t v259 = v62;
      if (v62 >= v260)
      {
        unsigned int v63 = v58 << v56;
        if (v62 > v260)
        {
          int8x8_t v259 = v260;
          uint64_t v62 = v260;
          unsigned int v63 = v58 << v56;
        }
      }
      else
      {
        unsigned int v63 = bswap32(*v62);
      }
      int v64 = v63 << (v61 & 7);
      LODWORD(v261) = v64;
      LOBYTE(v241) = v60 < 0;
      if (v60 < 0)
      {
        unint64_t v65 = (v61 & 7) + 1;
        char v66 = v65 & 7;
        HIDWORD(v261) = v65 & 7;
        int v67 = (unsigned int *)((char *)v62 + (v65 >> 3));
        int8x8_t v259 = v67;
        if (v67 >= v260)
        {
          if (v67 > v260) {
            int8x8_t v259 = v260;
          }
          unsigned int v68 = v64;
        }
        else
        {
          unsigned int v68 = bswap32(*v67);
        }
        LODWORD(v261) = v68 << v66;
        HIBYTE(v241) = v64 < 0;
      }
    }
    if (v239[1] == 5) {
      LODWORD(v242) = sub_1BBA19824((uint64_t)v258);
    }
    if (*(unsigned char *)(v39 + 276) == 1)
    {
      uint64_t v69 = v218;
      if (!*(unsigned char *)(v39 + 284))
      {
        int v76 = sub_1BBA19824((uint64_t)v258);
        uint64_t v69 = v218;
        HIDWORD(v243) = (-((v76 + 1) & 1) ^ ((v76 + 1) >> 1)) + ((v76 + 1) & 1);
        if (*(unsigned char *)(v218 + 9))
        {
          if (!(_BYTE)v241)
          {
            int v77 = sub_1BBA19824((uint64_t)v258);
            int v78 = &v244;
LABEL_89:
            *(_DWORD *)int v78 = (-((v77 + 1) & 1) ^ ((v77 + 1) >> 1)) + ((v77 + 1) & 1);
            uint64_t v69 = v218;
          }
        }
      }
    }
    else
    {
      uint64_t v69 = v218;
      if (!*(unsigned char *)(v39 + 276))
      {
        int v70 = *(_DWORD *)(v39 + 280);
        unsigned int v71 = v261;
        unint64_t v72 = SHIDWORD(v261) + (uint64_t)(v70 + 4);
        char v73 = v72 & 7;
        HIDWORD(v261) = v72 & 7;
        CFNumberRef v74 = (unsigned int *)((char *)v259 + (v72 >> 3));
        int8x8_t v259 = v74;
        if (v74 >= v260)
        {
          if (v74 > v260) {
            int8x8_t v259 = v260;
          }
          unsigned int v75 = v261;
        }
        else
        {
          unsigned int v75 = bswap32(*v74);
        }
        LODWORD(v261) = v75 << v73;
        HIDWORD(v242) = v71 >> (28 - v70);
        uint64_t v69 = v218;
        if (*(unsigned char *)(v218 + 9) == 1 && !(_BYTE)v241)
        {
          int v77 = sub_1BBA1979C((uint64_t)v258);
          int v78 = &v243;
          goto LABEL_89;
        }
      }
    }
    if (*(unsigned char *)(v69 + 86)) {
      HIDWORD(v244) = sub_1BBA1979C((uint64_t)v258);
    }
    int v79 = v240;
    if (v240 <= 8)
    {
      if (((1 << v240) & 0x129) != 0)
      {
        int v80 = v261;
      }
      else
      {
        if (((1 << v240) & 0x42) == 0) {
          goto LABEL_113;
        }
        int v81 = v261;
        unint64_t v82 = SHIDWORD(v261) + 1;
        char v83 = v82 & 7;
        HIDWORD(v261) = v82 & 7;
        int v84 = (unsigned int *)((char *)v259 + (v82 >> 3));
        int8x8_t v259 = v84;
        if (v84 >= v260)
        {
          if (v84 > v260) {
            int8x8_t v259 = v260;
          }
          unsigned int v85 = v261;
        }
        else
        {
          unsigned int v85 = bswap32(*v84);
        }
        int v80 = v85 << v83;
        LODWORD(v261) = v80;
        LOBYTE(v245) = v81 < 0;
        if (((1 << v240) & 0x16B) == 0) {
          goto LABEL_113;
        }
      }
      unint64_t v86 = SHIDWORD(v261) + 1;
      HIDWORD(v261) = v86 & 7;
      CFNumberRef v87 = (unsigned int *)((char *)v259 + (v86 >> 3));
      int8x8_t v259 = v87;
      BOOL v88 = v87 > v260;
      if (v87 >= v260)
      {
        unsigned int v89 = v80;
        if (v88)
        {
          int8x8_t v259 = v260;
          unsigned int v89 = v80;
        }
      }
      else
      {
        unsigned int v89 = bswap32(*v87);
      }
      LODWORD(v261) = v89 << (v86 & 7);
      HIBYTE(v245) = v80 < 0;
      if ((v80 & 0x80000000) == 0)
      {
        v246[0] = *(_DWORD *)(v218 + 56);
        int v90 = *(_DWORD *)(v218 + 60);
LABEL_112:
        v246[1] = v90;
        goto LABEL_113;
      }
      v246[0] = sub_1BBA1979C((uint64_t)v258);
      int v79 = v240;
      if (v240 == 6 || v240 == 1)
      {
        int v90 = sub_1BBA1979C((uint64_t)v258);
        int v79 = v240;
        goto LABEL_112;
      }
    }
LABEL_113:
    int v91 = v79 - 2;
    if (v79 - 2) < 8 && ((0xA5u >> v91))
    {
      int v79 = dword_1BBB95880[v91];
    }
    else
    {
      int v92 = v261;
      unint64_t v93 = SHIDWORD(v261) + 1;
      HIDWORD(v261) = v93 & 7;
      unsigned int v94 = (unsigned int *)((char *)v259 + (v93 >> 3));
      int8x8_t v259 = v94;
      BOOL v95 = v94 > v260;
      if (v94 >= v260)
      {
        unsigned int v96 = v261;
        if (v95)
        {
          int8x8_t v259 = v260;
          unsigned int v96 = v261;
        }
      }
      else
      {
        unsigned int v96 = bswap32(*v94);
      }
      LODWORD(v261) = v96 << (v93 & 7);
      LOBYTE(v246[2]) = v92 < 0;
      if (v92 < 0)
      {
        for (unsigned int i = 0; ; ++i)
        {
          unsigned int v98 = sub_1BBA1979C((uint64_t)v258);
          *((_DWORD *)&v252[2] + i) = v98;
          if (v98 == 3)
          {
            int v79 = v240;
            goto LABEL_130;
          }
          unsigned int v99 = v98;
          uint64_t v100 = &v253;
          if (v98 >= 2)
          {
            uint64_t v100 = &v254;
            if (v98 != 2) {
              break;
            }
          }
          v100[i] = sub_1BBA1979C((uint64_t)v258);
          int v101 = v246[0];
          if (i > v246[0])
          {
            int v170 = MEMORY[0x1E4F14500];
            if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
              goto LABEL_247;
            }
            *(_DWORD *)buf = 67109376;
            long long v270 = i;
            size_t v271 = 1024;
            uint64_t v272 = v101;
            int v171 = v170;
            int v172 = "SliceHeaderH264::Parse() get too many(%d) ref reorderings arrived, expected <= num_ref_idx_l0_active_minus1(%d)";
            goto LABEL_243;
          }
          DataCFIndex Length = v224;
        }
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          long long v270 = v99;
          int v171 = MEMORY[0x1E4F14500];
          int v172 = "SliceHeaderH264::Parse() get unknown value %d for reordering_of_pic_nums_idc0";
          uint32_t v184 = 8;
          goto LABEL_246;
        }
        goto LABEL_247;
      }
    }
LABEL_130:
    if (v79 == 6 || v79 == 1)
    {
      int v103 = v261;
      unint64_t v104 = SHIDWORD(v261) + 1;
      HIDWORD(v261) = v104 & 7;
      BOOL v105 = (unsigned int *)((char *)v259 + (v104 >> 3));
      int8x8_t v259 = v105;
      BOOL v106 = v105 > v260;
      if (v105 >= v260)
      {
        unsigned int v107 = v261;
        if (v106)
        {
          int8x8_t v259 = v260;
          unsigned int v107 = v261;
        }
      }
      else
      {
        unsigned int v107 = bswap32(*v105);
      }
      LODWORD(v261) = v107 << (v104 & 7);
      BYTE1(v246[2]) = v103 < 0;
      if (v103 < 0)
      {
        for (unsigned int j = 0; ; ++j)
        {
          unsigned int v161 = sub_1BBA1979C((uint64_t)v258);
          unsigned int v162 = v161;
          if (v161 >= 4)
          {
            if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
              goto LABEL_255;
            }
            *(_DWORD *)buf = 67109120;
            long long v270 = v162;
            int v51 = MEMORY[0x1E4F14500];
            int v52 = "SliceHeaderH264::Parse() ref_pic_list_reordering  L1: val(%d) > 3";
            goto LABEL_252;
          }
          *((_DWORD *)&v252[18] + j + 1) = v161;
          if (v161 == 3) {
            goto LABEL_141;
          }
          int v163 = sub_1BBA1979C((uint64_t)v258);
          int v164 = &v239[j];
          uint32_t v165 = v164 + 196;
          int v166 = v164 + 130;
          if (v162 >= 2) {
            int v166 = v165;
          }
          *int v166 = v163;
          int v167 = v246[1];
          if (j > v246[1]) {
            break;
          }
          DataCFIndex Length = v224;
        }
        CFNumberRef v183 = MEMORY[0x1E4F14500];
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          goto LABEL_247;
        }
        *(_DWORD *)buf = 67109376;
        long long v270 = j;
        size_t v271 = 1024;
        uint64_t v272 = v167;
        int v171 = v183;
        int v172 = "SliceHeaderH264::Parse() get too many(%d) ref reorderings arrived, expected <= num_ref_idx_l1_active_minus1(%d)";
LABEL_243:
        uint32_t v184 = 14;
LABEL_246:
        _os_log_error_impl(&dword_1BB9B9000, v171, OS_LOG_TYPE_ERROR, v172, buf, v184);
LABEL_247:
        char v48 = 0;
        uint64_t v16 = 4294954387;
        DataCFIndex Length = v224;
        goto LABEL_256;
      }
    }
LABEL_141:
    uint64_t v108 = v218;
    if ((!*(unsigned char *)(v218 + 64) || v240 && v240 != 5)
      && (*(_DWORD *)(v218 + 68) != 1 || v240 != 6 && v240 != 1))
    {
      goto LABEL_192;
    }
    int v255 = sub_1BBA1979C((uint64_t)v258);
    int v256 = sub_1BBA1979C((uint64_t)v258);
    int v109 = v246[0];
    if ((v246[0] + 1) > 0x20)
    {
      int v159 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        long long v270 = v109;
        int v51 = v159;
        int v52 = "SliceHeaderH264::Parse() num_ref_idx_l0_active_minus1(%d) + 1 > kBufMgtDecoMaxNumberOfRefPics_is32(32)";
        goto LABEL_252;
      }
    }
    else
    {
      unsigned int v110 = 0;
      uint64_t v221 = v10;
      do
      {
        int v111 = v261;
        unint64_t v112 = SHIDWORD(v261) + 1;
        HIDWORD(v261) = v112 & 7;
        CFStringRef v113 = (unsigned int *)((char *)v259 + (v112 >> 3));
        int8x8_t v259 = v113;
        BOOL v114 = v113 > v260;
        if (v113 >= v260)
        {
          unsigned int v115 = v261;
          if (v114)
          {
            int8x8_t v259 = v260;
            unsigned int v115 = v261;
          }
        }
        else
        {
          unsigned int v115 = bswap32(*v113);
        }
        LODWORD(v261) = v115 << (v112 & 7);
        v257[v110] = v111 < 0;
        if (v111 < 0)
        {
          int v117 = sub_1BBA1979C((uint64_t)v258);
          *(_DWORD *)&v257[12 * v110 + 128] = (-((v117 + 1) & 1) ^ ((v117 + 1) >> 1)) + ((v117 + 1) & 1);
          int v118 = sub_1BBA1979C((uint64_t)v258);
          unsigned int v116 = (-((v118 + 1) & 1) ^ ((v118 + 1) >> 1)) + ((v118 + 1) & 1);
        }
        else
        {
          unsigned int v116 = 0;
          *(_DWORD *)&v257[12 * v110 + 128] = 1 << v255;
        }
        *(_DWORD *)&v257[12 * v110 + 896] = v116;
        int v119 = v261;
        unint64_t v120 = SHIDWORD(v261) + 1;
        char v121 = v120 & 7;
        HIDWORD(v261) = v120 & 7;
        CFNumberRef v122 = (unsigned int *)((char *)v259 + (v120 >> 3));
        int8x8_t v259 = v122;
        BOOL v123 = v122 > v260;
        if (v122 >= v260)
        {
          unsigned int v124 = v261;
          if (v123)
          {
            int8x8_t v259 = v260;
            unsigned int v124 = v261;
          }
        }
        else
        {
          unsigned int v124 = bswap32(*v122);
        }
        char v125 = 0;
        LODWORD(v261) = v124 << v121;
        v257[v110 + 64] = v119 < 0;
        uint64_t v126 = 1;
        do
        {
          char v127 = v125;
          if (v119 < 0)
          {
            int v129 = sub_1BBA1979C((uint64_t)v258);
            *(_DWORD *)&v257[12 * v110 + 128 + 4 * v126] = (-((v129 + 1) & 1) ^ ((v129 + 1) >> 1))
                                                         + ((v129 + 1) & 1);
            int v130 = sub_1BBA1979C((uint64_t)v258);
            unsigned int v128 = (-((v130 + 1) & 1) ^ ((v130 + 1) >> 1)) + ((v130 + 1) & 1);
          }
          else
          {
            unsigned int v128 = 0;
            *(_DWORD *)&v257[12 * v110 + 128 + 4 * v126] = 1 << v256;
          }
          *(_DWORD *)&v257[12 * v110 + 896 + 4 * v126] = v128;
          char v125 = 1;
          uint64_t v126 = 2;
        }
        while ((v127 & 1) == 0);
        ++v110;
        uint64_t v10 = v221;
        DataCFIndex Length = v224;
      }
      while (v110 <= v246[0]);
      uint64_t v108 = v218;
      if (v240 != 6 && v240 != 1 || *(_DWORD *)(v218 + 68) != 1) {
        goto LABEL_192;
      }
      int v131 = v246[1];
      if ((v246[1] + 1) <= 0x20)
      {
        unsigned int v132 = 0;
        do
        {
          int v133 = v261;
          unint64_t v134 = SHIDWORD(v261) + 1;
          HIDWORD(v261) = v134 & 7;
          __int16 v135 = (unsigned int *)((char *)v259 + (v134 >> 3));
          int8x8_t v259 = v135;
          BOOL v136 = v135 > v260;
          if (v135 >= v260)
          {
            unsigned int v137 = v261;
            if (v136)
            {
              int8x8_t v259 = v260;
              unsigned int v137 = v261;
            }
          }
          else
          {
            unsigned int v137 = bswap32(*v135);
          }
          LODWORD(v261) = v137 << (v134 & 7);
          uint64_t v138 = v132;
          v257[v132 + 32] = v133 < 0;
          unsigned int v213 = v132;
          if (v133 < 0)
          {
            int v140 = sub_1BBA1979C((uint64_t)v258);
            *(_DWORD *)&v257[12 * v138 + 512] = (-((v140 + 1) & 1) ^ ((v140 + 1) >> 1))
                                                            + ((v140 + 1) & 1);
            int v141 = sub_1BBA1979C((uint64_t)v258);
            unsigned int v139 = (-((v141 + 1) & 1) ^ ((v141 + 1) >> 1)) + ((v141 + 1) & 1);
          }
          else
          {
            unsigned int v139 = 0;
            *(_DWORD *)&v257[12 * v132 + 512] = 1 << v255;
          }
          *(_DWORD *)&v257[12 * v138 + 1280] = v139;
          int v142 = v261;
          unint64_t v143 = SHIDWORD(v261) + 1;
          char v144 = v143 & 7;
          HIDWORD(v261) = v143 & 7;
          __int16 v145 = (unsigned int *)((char *)v259 + (v143 >> 3));
          int8x8_t v259 = v145;
          BOOL v146 = v145 > v260;
          if (v145 >= v260)
          {
            unsigned int v147 = v261;
            if (v146)
            {
              int8x8_t v259 = v260;
              unsigned int v147 = v261;
            }
          }
          else
          {
            unsigned int v147 = bswap32(*v145);
          }
          char v148 = 0;
          LODWORD(v261) = v147 << v144;
          v257[v138 + 64] = v142 < 0;
          uint64_t v149 = 1;
          do
          {
            char v150 = v148;
            if (v142 < 0)
            {
              int v152 = sub_1BBA1979C((uint64_t)v258);
              v239[3 * v138 + 360 + v149] = (-((v152 + 1) & 1) ^ ((v152 + 1) >> 1))
                                                        + ((v152 + 1) & 1);
              int v153 = sub_1BBA1979C((uint64_t)v258);
              unsigned int v151 = (-((v153 + 1) & 1) ^ ((v153 + 1) >> 1)) + ((v153 + 1) & 1);
            }
            else
            {
              unsigned int v151 = 0;
              v239[3 * v138 + 360 + v149] = 1 << v256;
            }
            v239[3 * v138 + 552 + v149] = v151;
            char v148 = 1;
            uint64_t v149 = 2;
          }
          while ((v150 & 1) == 0);
          unsigned int v132 = v213 + 1;
          DataCFIndex Length = v224;
          uint64_t v10 = v221;
          uint64_t v108 = v218;
        }
        while (v213 + 1 <= v246[1]);
LABEL_192:
        if (v239[0])
        {
          unsigned int v154 = v261;
          unint64_t v155 = SHIDWORD(v261) + 1;
          char v156 = v155 & 7;
          HIDWORD(v261) = v155 & 7;
          CFNumberRef v157 = (unsigned int *)((char *)v259 + (v155 >> 3));
          int8x8_t v259 = v157;
          unsigned int v158 = v261 >> 31;
          if (v239[1] == 5)
          {
            if (v157 >= v260)
            {
              if (v157 > v260) {
                CFNumberRef v157 = v260;
              }
            }
            else
            {
              unsigned int v154 = bswap32(*v157);
            }
            int v173 = v154 << v156;
            LODWORD(v261) = v173;
            HIBYTE(v246[2]) = v158;
            unint64_t v174 = (v155 & 7) + 1;
            char v175 = v174 & 7;
            HIDWORD(v261) = v174 & 7;
            int v176 = (unsigned int *)((char *)v157 + (v174 >> 3));
            int8x8_t v259 = v176;
            if (v176 >= v260)
            {
              if (v176 > v260) {
                int8x8_t v259 = v260;
              }
              unsigned int v177 = v173;
            }
            else
            {
              unsigned int v177 = bswap32(*v176);
            }
            LODWORD(v261) = v177 << v175;
            LOBYTE(v246[3]) = v173 < 0;
            uint64_t v108 = v218;
          }
          else
          {
            BOOL v168 = v157 > v260;
            if (v157 >= v260)
            {
              unsigned int v169 = v261;
              if (v168)
              {
                int8x8_t v259 = v260;
                unsigned int v169 = v261;
              }
            }
            else
            {
              unsigned int v169 = bswap32(*v157);
            }
            LODWORD(v261) = v169 << v156;
            BYTE2(v246[2]) = v158;
            uint64_t v108 = v218;
            if ((v154 & 0x80000000) != 0)
            {
              for (uint64_t k = -32; ; k += 4)
              {
                unsigned int v179 = sub_1BBA1979C((uint64_t)v258);
                *(_DWORD *)&v257[k + 1696] = v179;
                uint64_t v108 = v218;
                if (!v179) {
                  break;
                }
                unsigned int v180 = v179;
                if (v179 >= 7)
                {
                  if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
                    goto LABEL_255;
                  }
                  *(_DWORD *)buf = 67109120;
                  long long v270 = v180;
                  int v51 = MEMORY[0x1E4F14500];
                  int v52 = "SliceHeaderH264::Parse() unknown MMCO(%d) received, expected in range [1,6]";
                  goto LABEL_252;
                }
                if (!k)
                {
                  if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
                    goto LABEL_255;
                  }
                  *(_DWORD *)buf = 67109376;
                  long long v270 = 8;
                  size_t v271 = 1024;
                  uint64_t v272 = 8;
                  int v51 = MEMORY[0x1E4F14500];
                  int v52 = "SliceHeaderH264::Parse() too many MMCOs(%d) received, expected < %d";
                  uint32_t v187 = 14;
                  goto LABEL_253;
                }
                switch(v179)
                {
                  case 1u:
                  case 3u:
                    *(_DWORD *)&v257[k + 1728] = sub_1BBA1979C((uint64_t)v258);
                    if (v180 == 3) {
                      goto LABEL_227;
                    }
                    if (v180 == 2) {
                      goto LABEL_226;
                    }
                    break;
                  case 2u:
LABEL_226:
                    *(_DWORD *)&v257[k + 1760] = sub_1BBA1979C((uint64_t)v258);
                    break;
                  case 4u:
                    *(_DWORD *)&v257[k + 1824] = sub_1BBA1979C((uint64_t)v258);
                    break;
                  case 6u:
LABEL_227:
                    *(_DWORD *)&v257[k + 1792] = sub_1BBA1979C((uint64_t)v258);
                    break;
                  default:
                    continue;
                }
              }
            }
          }
        }
        if (*(unsigned char *)(v108 + 8) == 1 && (v240 > 9 || ((1 << v240) & 0x294) == 0)) {
          char v247 = sub_1BBA1979C((uint64_t)v258);
        }
        int v182 = sub_1BBA1979C((uint64_t)v258);
        uint64_t v16 = 0;
        unsigned int v248 = (-((v182 + 1) & 1) ^ ((v182 + 1) >> 1)) + ((v182 + 1) & 1);
        int v249 = v248 + *(_DWORD *)(v218 + 72) + 26;
        char v48 = 1;
LABEL_256:
        int v47 = v214;
        int v34 = v215;
        if (!v215) {
          goto LABEL_258;
        }
        goto LABEL_257;
      }
      uint64_t v186 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        long long v270 = v131;
        int v51 = v186;
        int v52 = "SliceHeaderH264::Parse() num_ref_idx_l1_active_minus1(%d) + 1 > kBufMgtDecoMaxNumberOfRefPics_is32(32)";
LABEL_252:
        uint32_t v187 = 8;
LABEL_253:
        _os_log_error_impl(&dword_1BB9B9000, v51, OS_LOG_TYPE_ERROR, v52, buf, v187);
      }
    }
LABEL_255:
    char v48 = 0;
    uint64_t v16 = 4294954387;
    goto LABEL_256;
  }
  uint64_t v16 = 0;
LABEL_281:
  if (v266) {
    sub_1BB9C09B4(v266);
  }
  if (v265) {
    sub_1BB9C09B4(v265);
  }
  for (uint64_t m = 4600; m != 504; m -= 16)
  {
    int v201 = *(std::__shared_weak_count **)&v264[m];
    if (v201) {
      sub_1BB9C09B4(v201);
    }
  }
  do
  {
    int v202 = *(std::__shared_weak_count **)&v264[m];
    if (v202) {
      sub_1BB9C09B4(v202);
    }
    m -= 16;
  }
  while (m != -8);
  if (v16)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int16x8_t v264 = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Warning, VCPReadH264SliceHeader() parsing error\n", v264, 2u);
    }
  }
  else
  {
    *(_OWORD *)(v225 + 128) = v226;
    *(_DWORD *)(v225 + 144) = v227;
    *(unsigned char *)(v225 + 85) = v228;
    uint64_t v204 = *(void *)(v10 + 2224);
    if (v204)
    {
      int v205 = *(_DWORD *)(v225 + 128);
      if (v205) {
        sub_1BBAC8868(v204, (uint64_t *)"slice_size0", (double)v205);
      }
      int v206 = *(_DWORD *)(v225 + 132);
      if (v206) {
        sub_1BBAC8868(*(void *)(v10 + 2224), (uint64_t *)"slice_size1", (double)v206);
      }
      int v207 = *(_DWORD *)(v225 + 136);
      if (v207) {
        sub_1BBAC8868(*(void *)(v10 + 2224), (uint64_t *)"slice_size2", (double)v207);
      }
      int v208 = *(_DWORD *)(v225 + 140);
      if (v208) {
        sub_1BBAC8868(*(void *)(v10 + 2224), (uint64_t *)"slice_size3", (double)v208);
      }
      int v209 = *(char *)(v225 + 144);
      if (v209 >= 1) {
        sub_1BBAC8868(*(void *)(v10 + 2224), (uint64_t *)"slice_qp0", (double)v209);
      }
      int v210 = *(char *)(v225 + 145);
      if (v210 >= 1) {
        sub_1BBAC8868(*(void *)(v10 + 2224), (uint64_t *)"slice_qp1", (double)v210);
      }
      int v211 = *(char *)(v225 + 146);
      if (v211 >= 1) {
        sub_1BBAC8868(*(void *)(v10 + 2224), (uint64_t *)"slice_qp2", (double)v211);
      }
      int v212 = *(char *)(v225 + 147);
      if (v212 >= 1) {
        sub_1BBAC8868(*(void *)(v10 + 2224), (uint64_t *)"slice_qp3", (double)v212);
      }
    }
  }
  return v16;
}

void sub_1BB9E963C(_Unwind_Exception *a1)
{
}

uint64_t VCPDecompressionSessionDecodeFrame(uint64_t a1, CFTypeRef cf, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = (void *)cf;
  uint64_t v161 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v144 = cf;
  *(void *)&long long v143 = *(unsigned __int16 *)(a1 + 174);
  int v10 = *(_DWORD *)(a1 + 112);
  DWORD2(v143) = *(_DWORD *)(a1 + 116);
  HIDWORD(v143) = v10;
  uint64_t v11 = *(void *)(a1 + 2224);
  if (v11) {
    sub_1BBAC8868(v11, (uint64_t *)"input_frames", 1.0);
  }
  if (!v8 || (CFRetain(v8), !CMSampleBufferGetDataBuffer((CMSampleBufferRef)v8)))
  {
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v15 = 0;
    uint64_t v28 = 4294954387;
    goto LABEL_234;
  }
  FormatDescription = CMSampleBufferGetFormatDescription((CMSampleBufferRef)v8);
  if (*(const opaqueCMFormatDescription **)(a1 + 56) != FormatDescription)
  {
    CFStringRef v13 = FormatDescription;
    if (!VTDecompressionSessionCanAcceptFormatDescription(*(VTDecompressionSessionRef *)(a1 + 16), FormatDescription))
    {
      VTDecompressionSessionInvalidate(*(VTDecompressionSessionRef *)(a1 + 16));
      CFRelease(*(CFTypeRef *)(a1 + 16));
      *(void *)(a1 + 16) = 0;
      uint64_t v29 = sub_1BB9E1494(*(const void **)(a1 + 48), v13, *(const __CFDictionary **)(a1 + 64), *(const void **)(a1 + 72), (_DWORD *)a1);
      if (v29)
      {
        uint64_t v28 = v29;
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
LABEL_17:
          CFMutableDictionaryRef Mutable = 0;
          uint64_t v15 = 0;
          goto LABEL_234;
        }
        *(_DWORD *)&v154[8] = 67109120;
        *(_DWORD *)&v154[12] = v28;
        unint64_t v112 = MEMORY[0x1E4F14500];
        CFStringRef v113 = "Failed to recreate DecompressionSession, err = %d\n";
        uint32_t v114 = 8;
LABEL_187:
        _os_log_error_impl(&dword_1BB9B9000, v112, OS_LOG_TYPE_ERROR, v113, &v154[8], v114);
        goto LABEL_17;
      }
    }
  }
  ++*(_WORD *)(a1 + 174);
  int v14 = (char *)operator new(0xA0uLL, MEMORY[0x1E4FBA2D0]);
  if (!v14)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      CFMutableDictionaryRef Mutable = 0;
      uint64_t v15 = 0;
LABEL_22:
      uint64_t v28 = 4294954392;
      goto LABEL_234;
    }
    int v96 = *(_DWORD *)(a1 + 24);
    uint64_t v97 = "H.264";
    if (v96 > 1718908519)
    {
      if (v96 == 1752589105) {
        goto LABEL_184;
      }
      int v98 = 1718908520;
    }
    else
    {
      if (v96 == 1684632424) {
        goto LABEL_184;
      }
      int v98 = 1685481521;
    }
    if (v96 != v98)
    {
LABEL_185:
      *(_DWORD *)&v154[8] = 134218498;
      *(void *)&v154[12] = a1;
      *(_WORD *)&v154[20] = 2080;
      *(void *)&v154[22] = v97;
      *(_WORD *)&v154[30] = 1024;
      uint64_t v28 = 4294954392;
      *(_DWORD *)&v154[32] = -12904;
      unint64_t v112 = MEMORY[0x1E4F14500];
      CFStringRef v113 = "VCPDec %p (%s): Decoder failed to create vcpFrameContext, err = %d\n";
      uint32_t v114 = 28;
      goto LABEL_187;
    }
LABEL_184:
    uint64_t v97 = "HEVC";
    goto LABEL_185;
  }
  uint64_t v15 = (uint64_t)v14;
  *(void *)int v14 = a4;
  *((_DWORD *)v14 + 2) = 0;
  *(void *)&long long v138 = v14 + 8;
  *((_WORD *)v14 + 6) = 0;
  *((void *)&v137 + 1) = v14 + 12;
  v14[14] = 0;
  *((void *)v14 + 2) = 0x80000000;
  *(void *)&long long v139 = v14 + 16;
  *((void *)v14 + 3) = 0;
  uint64_t v16 = (uint64_t)(v14 + 24);
  v14[56] = 0;
  *((void *)v14 + 4) = 0;
  *((void *)v14 + 5) = 0;
  *((_DWORD *)v14 + 16) = 0;
  *((void *)v14 + 9) = 0;
  *((_DWORD *)v14 + 20) = 0;
  *((_DWORD *)v14 + 21) = 1077952512;
  *((void *)v14 + 11) = 0xFFFFFFFF00000000;
  size_t v17 = v14 + 88;
  *((void *)v14 + 12) = 0;
  int v18 = (int *)(v14 + 96);
  *((void *)v14 + 15) = 0;
  int v19 = (char **)(v14 + 120);
  *((void *)v14 + 13) = 0;
  v14[112] = 0;
  *((void *)v14 + 16) = 0;
  *((void *)v14 + 17) = 0;
  *((void *)v14 + 19) = 0;
  uint64_t v20 = (const void **)(v14 + 152);
  *((_DWORD *)v14 + 36) = -1;
  *(void *)&v154[8] = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  sub_1BB9C57D0(v20, (const void **)&v154[8]);
  sub_1BB9BE228((const void **)&v154[8]);
  int v21 = sub_1BBAB1784(*(char **)(a1 + 2288));
  *int v19 = v21;
  if (!v21)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)&v154[8] = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "control_byte memory allocate failed!", &v154[8], 2u);
    }
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      CFMutableDictionaryRef Mutable = 0;
      goto LABEL_22;
    }
    int v99 = *(_DWORD *)(a1 + 24);
    uint64_t v100 = "H.264";
    if (v99 > 1718908519)
    {
      if (v99 == 1752589105) {
        goto LABEL_192;
      }
      int v101 = 1718908520;
    }
    else
    {
      if (v99 == 1684632424) {
        goto LABEL_192;
      }
      int v101 = 1685481521;
    }
    if (v99 != v101)
    {
LABEL_193:
      *(_DWORD *)&v154[8] = 134218498;
      *(void *)&v154[12] = a1;
      *(_WORD *)&v154[20] = 2080;
      *(void *)&v154[22] = v100;
      *(_WORD *)&v154[30] = 1024;
      uint64_t v28 = 4294954392;
      *(_DWORD *)&v154[32] = -12904;
      unint64_t v104 = MEMORY[0x1E4F14500];
      BOOL v105 = "VCPDec %p (%s): Decoder failed to initialize vcpFrameContext, err = %d\n";
      uint32_t v106 = 28;
      goto LABEL_194;
    }
LABEL_192:
    uint64_t v100 = "HEVC";
    goto LABEL_193;
  }
  sub_1BBA3F68C(v16);
  int v25 = *(_DWORD *)(a1 + 24);
  DWORD1(v136) = a3;
  uint64_t v132 = a5;
  uint64_t v133 = (uint64_t)v19;
  int v131 = v18;
  unint64_t v134 = v17;
  if (v25 <= 1718908519)
  {
    if (v25 != 1684632424)
    {
      int v26 = 1685481521;
      goto LABEL_25;
    }
LABEL_26:
    *((void *)&v138 + 1) = v20;
    *((void *)&v142 + 1) = CMSampleBufferGetDataBuffer((CMSampleBufferRef)v8);
    *(void *)&long long v141 = 0;
    *((void *)&v141 + 1) = CMBlockBufferGetDataLength(*((CMBlockBufferRef *)&v142 + 1));
    uint64_t v28 = 0;
    size_t v30 = 0;
    *(void *)&long long v140 = &v157;
    *((void *)&v140 + 1) = v156;
    *((void *)&v139 + 1) = v160;
    *(void *)&long long v137 = v153;
    *(void *)&long long v31 = 134219010;
    *(_OWORD *)__int16 v135 = v31;
    while (1)
    {
      size_t v32 = v30 + 4;
      if (v30 + 4 >= *((void *)&v141 + 1))
      {
LABEL_99:
        uint64_t v70 = *(void *)(a1 + 2224);
        if (v70)
        {
          int v71 = *(_DWORD *)(v15 + 128);
          if (v71) {
            sub_1BBAC8868(v70, (uint64_t *)"slice_size0", (double)v71);
          }
          int v72 = *(_DWORD *)(v15 + 132);
          if (v72) {
            sub_1BBAC8868(*(void *)(a1 + 2224), (uint64_t *)"slice_size1", (double)v72);
          }
          int v73 = *(_DWORD *)(v15 + 136);
          if (v73) {
            sub_1BBAC8868(*(void *)(a1 + 2224), (uint64_t *)"slice_size2", (double)v73);
          }
          int v74 = *(_DWORD *)(v15 + 140);
          if (v74) {
            sub_1BBAC8868(*(void *)(a1 + 2224), (uint64_t *)"slice_size3", (double)v74);
          }
          int v75 = *(char *)(v15 + 144);
          if (v75 >= 1) {
            sub_1BBAC8868(*(void *)(a1 + 2224), (uint64_t *)"slice_qp0", (double)v75);
          }
          int v76 = *(char *)(v15 + 145);
          if (v76 >= 1) {
            sub_1BBAC8868(*(void *)(a1 + 2224), (uint64_t *)"slice_qp1", (double)v76);
          }
          int v77 = *(char *)(v15 + 146);
          if (v77 >= 1) {
            sub_1BBAC8868(*(void *)(a1 + 2224), (uint64_t *)"slice_qp2", (double)v77);
          }
          int v78 = *(char *)(v15 + 147);
          if (v78 >= 1) {
            sub_1BBAC8868(*(void *)(a1 + 2224), (uint64_t *)"slice_qp3", (double)v78);
          }
        }
LABEL_116:
        if (!v28) {
          goto LABEL_121;
        }
LABEL_149:
        if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
LABEL_150:
          CFMutableDictionaryRef Mutable = 0;
          goto LABEL_234;
        }
        int v102 = *(_DWORD *)(a1 + 112);
        int v103 = *(_DWORD *)(a1 + 116);
        *(_DWORD *)&v154[8] = 134218496;
        *(void *)&v154[12] = a1;
        *(_WORD *)&v154[20] = 1024;
        *(_DWORD *)&v154[22] = v102;
        *(_WORD *)&v154[26] = 1024;
        *(_DWORD *)&v154[28] = v103;
        unint64_t v104 = MEMORY[0x1E4F14500];
        BOOL v105 = "VCPDec %p (%dx%d, HEVC): VCPDecHEVCNaluParser() err!\n";
        uint32_t v106 = 24;
LABEL_194:
        _os_log_error_impl(&dword_1BB9B9000, v104, OS_LOG_TYPE_ERROR, v105, &v154[8], v106);
        goto LABEL_150;
      }
      *(_DWORD *)&v152[4] = 0;
      *((void *)&v151 + 1) = 0;
      CMBlockBufferAccessDataBytes(*((CMBlockBufferRef *)&v142 + 1), v30, 4uLL, &v152[4], (char **)&v151 + 1);
      uint64_t v33 = bswap32(**((_DWORD **)&v151 + 1));
      *(void *)&long long v151 = 0;
      *(void *)&long long v142 = v33;
      size_t v34 = (int)v33;
      uint64_t v35 = operator new[]((int)v33, MEMORY[0x1E4FBA2D0]);
      if (!v35)
      {
        unsigned int v42 = MEMORY[0x1E4F14500];
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)&v154[8] = 0;
          _os_log_impl(&dword_1BB9B9000, v42, OS_LOG_TYPE_DEFAULT, "Unable to allocate NALU buffer for SEI and slice(s) parsing!\n", &v154[8], 2u);
        }
        goto LABEL_96;
      }
      int v36 = v35;
      if (CMBlockBufferAccessDataBytes(*((CMBlockBufferRef *)&v142 + 1), v32, v34, v35, (char **)&v151))
      {
        MEMORY[0x1C18605A0](v36, 0x1000C8077774924);
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)&v154[8] = 67109120;
          *(_DWORD *)&v154[12] = v142;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "SEI UserDataUnregistered Nal error unable to get data of size %uz", &v154[8], 8u);
        }
        uint64_t v28 = 4294954394;
        goto LABEL_149;
      }
      *(_WORD *)&v154[8] = 0;
      memset(&v154[12], 0, 144);
      __int16 v155 = 0;
      *(void *)&long long v38 = -1;
      *((void *)&v38 + 1) = -1;
      **((_OWORD **)&v140 + 1) = v38;
      *(_OWORD *)(*((void *)&v140 + 1) + 16) = v38;
      *(_OWORD *)(*((void *)&v140 + 1) + 32) = v38;
      *(_OWORD *)(*((void *)&v140 + 1) + 48) = v38;
      **((void **)&v139 + 1) = 0;
      memset(&v156[64], 0, 129);
      *(_WORD *)(v140 + 8) = 0;
      *(void *)long long v140 = 0;
      int v39 = sub_1BB9D3628(v151, v34, 0, (uint64_t)&v154[8], *(void *)(a1 + 2352), v141 == 0, 2, v37, v129, (uint64_t)bytes, (uint64_t)v131, v132, v133, (uint64_t)v134, *(int *)v135, *(__int16 *)&v135[4], *(long long *)&v135[8], v136, v137,
              v138,
              v139,
              v140,
              v141,
              v142,
              v143,
              v144,
              v145,
              v146,
              v147,
              v148,
              v149,
              v150,
              v151,
              *(long long *)v152,
              *(long long *)&v152[16],
              v153[0],
              v153[1],
              *(long long *)v154,
              *(uint64_t *)&v154[16],
              *(uint64_t *)&v154[24],
              v154[32],
              *(__int16 *)&v154[34],
              v154[36],
              *(int *)&v154[40],
              v154[44],
              *(long long *)&v154[48],
              *(long long *)&v154[64],
              *(long long *)&v154[80],
              *(long long *)&v154[96],
              *(long long *)&v154[112]);
      if (v39 != 1)
      {
        if (v39 != 7)
        {
          uint64_t v28 = 0;
          goto LABEL_95;
        }
        int v40 = (__CFDictionary *)**((void **)&v138 + 1);
        *(_DWORD *)&v152[8] = v142;
        CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, &v152[8]);
        if (v41)
        {
          CFDictionarySetValue(v40, @"PropagatableAttachmentsNALSize", v41);
          CFRelease(v41);
        }
        else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)&v152[8] = 0;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Unable to set SEI NAL Size\n", &v152[8], 2u);
        }
        uint64_t v28 = 0;
        if (!v160[0] || !v160[1]) {
          goto LABEL_93;
        }
        *(void *)&v152[8] = 0;
        *(void *)&v152[16] = 0;
        *(void *)(v137 + 8) = 0;
        *(void *)(v137 + 16) = 0;
        *(void *)long long v137 = 0;
        *(void *)&long long v147 = &unk_1F14EEAA8;
        *((void *)&v147 + 1) = 2;
        *(void *)&long long v148 = 0;
        WORD4(v148) = -192;
        *(void *)&long long v149 = 0;
        *((void *)&v149 + 1) = sub_1BB9FD104;
        *(void *)&long long v150 = 0;
        off_1EC59CAB8 = (uint64_t (*)(void, void, void, void, void))sub_1BB9FD21C;
        sub_1BBA065AC((uint64_t)&v147, (unsigned __int8 *)v151, v34);
        long long v146 = 0uLL;
        *((void *)&v136 + 1) = v8;
        if (sub_1BBA194F8((void **)&v152[8], &v147))
        {
          MEMORY[0x1C18605A0](v36, 0x1000C8077774924);
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            WORD4(v145) = 0;
            _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "SEI UserDataUnregistered Nal error emulation prevention", (uint8_t *)&v145 + 8, 2u);
          }
          char v50 = 0;
          int v51 = 6;
          uint64_t v28 = 4294954394;
LABEL_90:
          if (*(void *)&v152[8])
          {
            uint64_t v67 = v15;
            char v68 = v50;
            free(*(void **)&v152[8]);
            char v50 = v68;
            uint64_t v15 = v67;
          }
          uint64_t v8 = (void *)*((void *)&v136 + 1);
          if ((v50 & 1) == 0) {
            goto LABEL_97;
          }
LABEL_93:
          uint64_t v69 = *(void *)(a1 + 2224);
          if (v69) {
            sub_1BBAC8868(v69, (uint64_t *)"sei", (double)(int)v142);
          }
LABEL_95:
          MEMORY[0x1C18605A0](v36, 0x1000C8077774924);
LABEL_96:
          int v51 = 0;
          v32 += v34;
          goto LABEL_97;
        }
        uint64_t v52 = *(void *)&v152[24];
        uint64_t v53 = sub_1BBAD8F78((_DWORD *)&v150 + 3, *(uint64_t *)&v152[24], *((void *)&v153[0] + 1) - *(void *)&v152[24], (unint64_t *)&v146 + 1, (uint64_t *)&v146, 0);
        if (v53)
        {
          uint64_t v28 = v53;
          MEMORY[0x1C18605A0](v36, 0x1000C8077774924);
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            WORD4(v145) = 0;
            _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "SEI UserDataUnregistered Nal parsing error", (uint8_t *)&v145 + 8, 2u);
          }
          char v50 = 0;
          int v51 = 6;
          goto LABEL_90;
        }
        size_t v56 = *((void *)&v146 + 1);
        bytes = (UInt8 *)(v52 + v146);
        *((void *)&v145 + 1) = 0;
        if (*(_DWORD *)(a1 + 2232) == 1)
        {
          CFTypeID TypeID = CFDictionaryGetTypeID();
          if (sub_1BB9E7BBC(bytes, v56, TypeID, (CFTypeRef *)&v145 + 1))
          {
            size_t v58 = *((void *)&v146 + 1);
            CFTypeID v59 = CFDictionaryGetTypeID();
            if (!sub_1BB9E798C(bytes, v58, v59, (CFTypeRef *)&v145 + 1))
            {
              BOOL v60 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
              int v61 = 0;
              if (v60)
              {
                WORD4(v144) = 0;
                _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Switching to SEI deserialization mode=0 to match detected data\n", (uint8_t *)&v144 + 8, 2u);
                int v61 = 0;
              }
              goto LABEL_82;
            }
          }
        }
        else
        {
          CFTypeID v62 = CFDictionaryGetTypeID();
          if (sub_1BB9E798C(bytes, v56, v62, (CFTypeRef *)&v145 + 1))
          {
            CFIndex v63 = *((void *)&v146 + 1);
            CFTypeID v64 = CFDictionaryGetTypeID();
            if (!sub_1BB9E7BBC(bytes, v63, v64, (CFTypeRef *)&v145 + 1))
            {
              unint64_t v65 = MEMORY[0x1E4F14500];
              if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
              {
                WORD4(v144) = 0;
                _os_log_impl(&dword_1BB9B9000, v65, OS_LOG_TYPE_DEFAULT, "Switching to SEI deserialization mode=1 to match detected data\n", (uint8_t *)&v144 + 8, 2u);
              }
              int v61 = 1;
LABEL_82:
              *(_DWORD *)(a1 + 2232) = v61;
            }
          }
        }
        if (*((void *)&v145 + 1))
        {
          if (CFDictionaryContainsKey(*((CFDictionaryRef *)&v145 + 1), @"PropagatableAttachments"))
          {
            CFDataRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)&v145 + 1), @"PropagatableAttachments");
            if (Value) {
              CFDictionaryAddValue(**((CFMutableDictionaryRef **)&v138 + 1), @"PropagatableAttachments", Value);
            }
          }
          else
          {
            CFDictionaryAddValue(**((CFMutableDictionaryRef **)&v138 + 1), @"PropagatableAttachments", *((const void **)&v145 + 1));
          }
          CFRelease(*((CFTypeRef *)&v145 + 1));
        }
        uint64_t v28 = 0;
        int v51 = 0;
        char v50 = 1;
        goto LABEL_90;
      }
      if ((unint64_t)v141 < 4)
      {
        if (!(void)v141)
        {
          int v46 = v154[9];
          *(unsigned char *)(v15 + 84) = v154[9];
          *(unsigned char *)(v15 + 85) = v154[8];
          char v47 = v158;
          *(unsigned char *)(v15 + 86) = v158;
          int v48 = *(_DWORD *)(a1 + 200);
          if (!v46)
          {
            int v49 = *(_DWORD *)v139;
            if (v48 != -1) {
              *(_DWORD *)(a1 + 204) = v49 - v48;
            }
            *(_DWORD *)(a1 + 200) = v49;
            int v48 = v49;
          }
          if (v48 != -1) {
            *(_DWORD *)(v15 + 20) = *(_DWORD *)(v15 + 16) - v48;
          }
          if (v46) {
            char v47 = *(unsigned char *)(a1 + 208);
          }
          else {
            *(unsigned char *)(a1 + 208) = v47;
          }
          *(unsigned char *)(v15 + 87) = v47;
        }
        uint64_t v28 = 0;
        *(unsigned char *)(v15 + v141 + 144) = v159;
        *(_DWORD *)(v15 + 4 * v141 + 128) = v142 + 4;
        *(void *)&long long v141 = v141 + 1;
        goto LABEL_95;
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
        break;
      }
LABEL_68:
      uint64_t v28 = 0;
      int v51 = 3;
LABEL_97:
      size_t v30 = v32;
      if (v51)
      {
        if (v51 != 3) {
          goto LABEL_116;
        }
        goto LABEL_99;
      }
    }
    int v43 = *(_DWORD *)(a1 + 24);
    if (v43 > 1718908519)
    {
      if (v43 == 1752589105) {
        goto LABEL_66;
      }
      int v44 = "H.264";
      int v45 = 1718908520;
    }
    else
    {
      if (v43 == 1684632424) {
        goto LABEL_66;
      }
      int v44 = "H.264";
      int v45 = 1685481521;
    }
    if (v43 != v45)
    {
LABEL_67:
      int v54 = *(_DWORD *)(a1 + 112);
      int v55 = *(_DWORD *)(a1 + 116);
      *(_DWORD *)&v152[8] = *(_DWORD *)v135;
      *(void *)&v152[12] = a1;
      *(_WORD *)&v152[20] = 1024;
      *(_DWORD *)&v152[22] = v54;
      *(_WORD *)&v152[26] = 1024;
      *(_DWORD *)&v152[28] = v55;
      LOWORD(v153[0]) = 2080;
      *(void *)((char *)v153 + 2) = v44;
      WORD5(v153[0]) = 1024;
      HIDWORD(v153[0]) = 4;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): warning, got more than %d slices, ignored!\n", &v152[8], 0x28u);
      goto LABEL_68;
    }
LABEL_66:
    int v44 = "HEVC";
    goto LABEL_67;
  }
  if (v25 == 1752589105) {
    goto LABEL_26;
  }
  int v26 = 1718908520;
LABEL_25:
  if (v25 == v26) {
    goto LABEL_26;
  }
  if (sub_1BB9E7E00((uint64_t)v8, a1, v15, v22, v23, v24)
    && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v79 = *(_DWORD *)(a1 + 112);
    int v80 = *(_DWORD *)(a1 + 116);
    *(_DWORD *)&v154[8] = 134218496;
    *(void *)&v154[12] = a1;
    *(_WORD *)&v154[20] = 1024;
    *(_DWORD *)&v154[22] = v79;
    *(_WORD *)&v154[26] = 1024;
    *(_DWORD *)&v154[28] = v80;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, H.264): Warning, VCPDecH264NaluParser() failed!\n", &v154[8], 0x18u);
  }
LABEL_121:
  CFNumberRef v81 = (const __CFNumber *)CMGetAttachment(v8, @"rtpTimestsamp", 0);
  if (v81) {
    CFNumberGetValue(v81, kCFNumberSInt32Type, (void *)v139);
  }
  CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray((CMSampleBufferRef)v8, 1u);
  if (SampleAttachmentsArray)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
    CFDictionaryRef v84 = ValueAtIndex;
    if (ValueAtIndex)
    {
      if (CFDictionaryContainsKey(ValueAtIndex, @"RequestedRotationFlags")) {
        sub_1BB9DFC14(v84, @"RequestedRotationFlags", v134);
      }
      if (CFDictionaryContainsKey(v84, @"TileID")) {
        sub_1BB9DFC14(v84, @"TileID", (void *)v138);
      }
      if (CFDictionaryContainsKey(v84, @"TileOrder")) {
        sub_1BB9EAD34(v84, *((void **)&v137 + 1));
      }
      if (*(int *)(a1 + 136) >= 2) {
        *(void *)&long long v143 = (unsigned __int16)**((_WORD **)&v137 + 1) | ((unint64_t)*(unsigned int *)v138 << 32);
      }
    }
  }
  int v85 = *(unsigned __int8 *)(v15 + 86);
  int v86 = *(unsigned __int8 *)(v15 + 87);
  if (v85 != v86 || *(_DWORD *)(a1 + 168) == 2 && *(unsigned char *)(v15 + 85) != 20)
  {
    *(_DWORD *)(a1 + 168) = 2;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
LABEL_158:
      sub_1BB9E4B84(a1, (int *)v15, 4294954387, 1, 0, &xmmword_1BBB77DC0, &xmmword_1BBB77DD8);
      CFMutableDictionaryRef Mutable = 0;
      uint64_t v28 = 0;
      goto LABEL_234;
    }
    int v89 = *(_DWORD *)(a1 + 112);
    int v88 = *(_DWORD *)(a1 + 116);
    int v90 = *(_DWORD *)(a1 + 24);
    int v91 = "H.264";
    if (v90 > 1718908519)
    {
      if (v90 == 1752589105) {
        goto LABEL_154;
      }
      int v92 = 1718908520;
    }
    else
    {
      if (v90 == 1684632424) {
        goto LABEL_154;
      }
      int v92 = 1685481521;
    }
    if (v90 != v92)
    {
LABEL_155:
      unint64_t v93 = "Detected base layer missing";
      int v94 = *(unsigned __int8 *)(v15 + 85);
      *(_DWORD *)&v154[8] = 134219266;
      if (v85 == v86) {
        unint64_t v93 = "Decoder has non-recoverable error";
      }
      *(void *)&v154[12] = a1;
      *(_WORD *)&v154[20] = 1024;
      *(_DWORD *)&v154[22] = v89;
      *(_WORD *)&v154[26] = 1024;
      *(_DWORD *)&v154[28] = v88;
      *(_WORD *)&v154[32] = 2080;
      *(void *)&v154[34] = v91;
      *(_WORD *)&v154[42] = 2080;
      *(void *)&v154[44] = v93;
      *(_WORD *)&v154[52] = 1024;
      *(_DWORD *)&v154[54] = v94;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "VCPDec %p (%dx%d, %s): %s for nal_type=%d, skip decoding until receive IDR to recover\n", &v154[8], 0x32u);
      goto LABEL_158;
    }
LABEL_154:
    int v91 = "HEVC";
    goto LABEL_155;
  }
  kdebug_trace();
  *(void *)(v15 + 72) = v143;
  char v87 = BYTE4(v136);
  *(_DWORD *)(v15 + 80) = DWORD1(v136);
  if (!*(unsigned char *)(a1 + 80))
  {
    BOOL v95 = 0;
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_228;
  }
  LODWORD(v147) = 0;
  if (*(unsigned char *)(a1 + 2368))
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!Mutable)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)&v154[8] = 0;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "failed to create decode frame properties dictionary\n", &v154[8], 2u);
      }
      CFMutableDictionaryRef Mutable = 0;
      uint64_t v28 = 1;
      goto LABEL_234;
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
  }
  uint64_t v28 = sub_1BB9EADB0(a1, v15, (CMSampleBufferRef *)&v144);
  if (v28)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)&v154[8] = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPDecompressionSessionDecodeFrame: VCPDecompressionControlByteProcessing failed\n", &v154[8], 2u);
    }
    goto LABEL_234;
  }
  int v107 = *v131;
  if (*v131 && (int v108 = *(_DWORD *)(v15 + 100)) != 0)
  {
    int v109 = *(_DWORD *)(a1 + 212);
    BOOL v95 = v109 && (v110 = *(_DWORD *)(a1 + 216)) != 0 && (v109 != v107 || v110 != v108);
    *(_DWORD *)(a1 + 212) = v107;
    *(_DWORD *)(a1 + 216) = v108;
  }
  else
  {
    BOOL v95 = 0;
  }
  uint64_t v115 = *(void *)v133;
  LODWORD(v147) = *(unsigned __int8 *)(*(void *)v133 + 80);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v115 + 24))(v115))
  {
    if (*(unsigned char *)(a1 + 2368))
    {
      sub_1BB9EB008(Mutable, *(_WORD *)(*(void *)v133 + 16));
    }
    else
    {
      CFNumberRef v116 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt16Type, (const void *)(*(void *)v133 + 16));
      if (v116)
      {
        VTDecompressionSessionSetProperty();
        CFRelease(v116);
      }
    }
  }
  if (*(_DWORD *)(v15 + 92) != -1)
  {
    if (*(unsigned char *)(a1 + 2368) && *(_WORD *)(a1 + 174) != 1) {
      goto LABEL_208;
    }
    CFNumberRef v117 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(v15 + 92));
    if (v117)
    {
      VTDecompressionSessionSetProperty();
      CFRelease(v117);
    }
  }
  if (*(unsigned char *)(a1 + 2368))
  {
LABEL_208:
    sub_1BB9BFAB0(Mutable, (const void *)*MEMORY[0x1E4F44C28], v147);
    goto LABEL_211;
  }
  CFNumberRef v118 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v147);
  if (v118)
  {
    VTDecompressionSessionSetProperty();
    CFRelease(v118);
  }
LABEL_211:
  if ((*(_DWORD *)(v15 + 92) - 1) <= 2)
  {
    unsigned int v120 = *(_DWORD *)(v15 + 96);
    unsigned int v119 = *(_DWORD *)(v15 + 100);
    *((void *)&v143 + 1) = __PAIR64__(v120, v119);
    if (!v120 || !v119)
    {
      int v121 = *(_DWORD *)(a1 + 112);
      DWORD2(v143) = *(_DWORD *)(a1 + 116);
      HIDWORD(v143) = v121;
    }
    uint64_t v122 = *MEMORY[0x1E4F44D58];
    *(void *)&v154[8] = *MEMORY[0x1E4F44D60];
    *(void *)&v154[16] = v122;
    CFAllocatorRef v123 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v124 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (char *)&v143 + 12);
    *(void *)&v152[8] = v124;
    CFNumberRef v125 = CFNumberCreate(v123, kCFNumberIntType, (char *)&v143 + 8);
    *(void *)&v152[16] = v125;
    if (v124)
    {
      if (v125)
      {
        CFDictionaryRef v126 = CFDictionaryCreate(v123, (const void **)&v154[8], (const void **)&v152[8], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (v126)
        {
          if (*(unsigned char *)(a1 + 2368)) {
            CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F44BF8], v126);
          }
          else {
            VTDecompressionSessionSetProperty();
          }
          CFRelease(v126);
        }
      }
    }
    if (*(void *)&v152[8]) {
      CFRelease(*(CFTypeRef *)&v152[8]);
    }
    if (*(void *)&v152[16]) {
      CFRelease(*(CFTypeRef *)&v152[16]);
    }
  }
  if (*(void *)(a1 + 2240) || (uint64_t v28 = VTDecompressionSessionCopyProperty(), !v28))
  {
    char v87 = BYTE4(v136);
LABEL_228:
    if (v87)
    {
      if (!*(unsigned char *)(*(void *)v133 + 80))
      {
        kdebug_trace();
        if (v95) {
          VTDecompressionSessionWaitForAsynchronousFrames(*(VTDecompressionSessionRef *)(a1 + 16));
        }
        goto LABEL_233;
      }
      if (qword_1E9F81A78[0] != -1) {
        dispatch_once_f(qword_1E9F81A78, 0, (dispatch_function_t)nullsub_7);
      }
    }
    kdebug_trace();
LABEL_233:
    uint64_t v28 = VTDecompressionSessionDecodeFrameWithOptions();
    kdebug_trace();
  }
LABEL_234:
  if ((void)v144) {
    CFRelease((CFTypeRef)v144);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  kdebug_trace();
  if (v15 && v28)
  {
    uint64_t v127 = sub_1BB9E78BC(v15);
    MEMORY[0x1C18605E0](v127, 0x10A0C40B5D84229);
  }
  return v28;
}

void sub_1BB9EACEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51)
{
  if (a51) {
    free(a51);
  }
  _Unwind_Resume(exception_object);
}

CFNumberRef sub_1BB9EAD34(const __CFDictionary *a1, void *a2)
{
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue(a1, @"TileOrder");
  if (result)
  {
    CFNumberRef v4 = result;
    CFTypeID v5 = CFGetTypeID(result);
    CFNumberRef result = (const __CFNumber *)CFNumberGetTypeID();
    if ((const __CFNumber *)v5 == result)
    {
      return (const __CFNumber *)CFNumberGetValue(v4, kCFNumberSInt16Type, a2);
    }
  }
  return result;
}

uint64_t sub_1BB9EADB0(uint64_t a1, uint64_t a2, CMSampleBufferRef *a3)
{
  uint64_t v23 = 0;
  CMBlockBufferRef blockBufferOut = 0;
  offsetToCFDataRef Data = 0;
  size_t v22 = 0;
  DataBuffer = CMSampleBufferGetDataBuffer(*a3);
  int v7 = 0;
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8 > 1718908519)
  {
    BOOL v9 = v8 == 1718908520;
    int v10 = 1752589105;
  }
  else
  {
    BOOL v9 = v8 == 1684632424;
    int v10 = 1685481521;
  }
  if (!v9 && v8 != v10) {
    int v7 = 1;
  }
  uint64_t v12 = sub_1BBAB19BC(*(void *)(a2 + 120), *(void *)(a1 + 2288), v7, DataBuffer, &v23, &v22, &offsetToData, 1);
  if (v12)
  {
    uint64_t appended = v12;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v20 = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPDecompressionControlByteProcessing: ParseControlByteFromBuffer failed ", v20, 2u);
    }
  }
  else
  {
    if (!v23
      || (appended = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E4F1CF80], DataBuffer, 0, offsetToData - v23, 0, &blockBufferOut), !appended)&& ((size_t v14 = offsetToData, v14 >= CMBlockBufferGetDataLength(DataBuffer))|| (appended = CMBlockBufferAppendBufferReference(blockBufferOut, DataBuffer, offsetToData, 0, 0), !appended))&& (appended = sub_1BB9D5950(a3, blockBufferOut), !appended))
    {
      int v15 = (*(uint64_t (**)(void))(**(void **)(a2 + 120) + 16))(*(void *)(a2 + 120));
      uint64_t v16 = *(void **)(a2 + 120);
      if (v15)
      {
        *(void *)(a2 + 96) = v16[1];
        *(_DWORD *)(a2 + 92) = 3;
      }
      int v17 = (*(uint64_t (**)(void *))(*v16 + 96))(v16);
      int v18 = *(unsigned char **)(a2 + 120);
      if (v17) {
        *(unsigned char *)(a2 + 14) = v18[96];
      }
      uint64_t appended = 0;
      if ((*(unsigned int (**)(unsigned char *))(*(void *)v18 + 104))(v18)) {
        *(_DWORD *)(a1 + 176) = *(_DWORD *)(*(void *)(a2 + 120) + 98);
      }
    }
    if (blockBufferOut) {
      CFRelease(blockBufferOut);
    }
  }
  return appended;
}

const void **sub_1BB9EB008(__CFDictionary *a1, __int16 a2)
{
  __int16 valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFNumberRef v6 = v3;
  if (v3) {
    CFDictionarySetValue(a1, @"FrameChecksum", v3);
  }
  return sub_1BB9BE1F4((const void **)&v6);
}

void sub_1BB9EB068(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9BE1F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t VCPDecompressionSessionCopyProperty(uint64_t a1)
{
  if (a1) {
    return VTDecompressionSessionCopyProperty();
  }
  else {
    return 4294954394;
  }
}

uint64_t VCPDecompressionSessionWaitForAsynchronousFrames(uint64_t a1)
{
  return VTDecompressionSessionWaitForAsynchronousFrames(*(VTDecompressionSessionRef *)(a1 + 16));
}

uint64_t VCPDecompressionSessionFinishDelayedFrames(uint64_t a1)
{
  return VTDecompressionSessionFinishDelayedFrames(*(VTDecompressionSessionRef *)(a1 + 16));
}

uint64_t VCPDecompressionSessionCopyBlackPixelBuffer(uint64_t a1, CVPixelBufferRef *a2)
{
  return VTDecompressionSessionCopyBlackPixelBuffer(*(VTDecompressionSessionRef *)(a1 + 16), a2);
}

uint64_t VCPDecompressionSessionCopySupportedPropertyDictionary()
{
  return VTDecompressionSessionCopySupportedPropertyDictionary();
}

uint64_t VCPDecompressionSessionSetProperties(uint64_t a1)
{
  return MEMORY[0x1F4103240](*(void *)(a1 + 16));
}

uint64_t VCPDecompressionSessionCopySerializableProperties(uint64_t a1)
{
  return MEMORY[0x1F41031D8](*(void *)(a1 + 16));
}

uint64_t VCPDecompressionSessionCheckIfLastSubFrame(uint64_t a1, OpaqueCMBlockBuffer *a2, unsigned char *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = 0;
  if (!a1)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return 4294954394;
    }
    size_t v14 = "NA";
    goto LABEL_37;
  }
  uint64_t v4 = *(void *)(a1 + 2288);
  if (!v4 || (int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 96))(v4), !a3) || !a2 || !v7)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      return 4294954394;
    }
    int v13 = *(_DWORD *)(a1 + 24);
    size_t v14 = "H.264";
    if (v13 > 1718908519)
    {
      if (v13 != 1752589105)
      {
        int v15 = 1718908520;
LABEL_35:
        if (v13 == v15) {
          goto LABEL_36;
        }
LABEL_37:
        *(_DWORD *)buf = 134218242;
        uint64_t v28 = a1;
        __int16 v29 = 2080;
        size_t v30 = v14;
        uint64_t v24 = MEMORY[0x1E4F14500];
        int v25 = "VCPDec %p (%s) VCPDecompressionSessionCheckIfLastSubFrame incorrect parameter";
LABEL_38:
        _os_log_error_impl(&dword_1BB9B9000, v24, OS_LOG_TYPE_ERROR, v25, buf, 0x16u);
        return 4294954394;
      }
    }
    else if (v13 != 1684632424)
    {
      int v15 = 1685481521;
      goto LABEL_35;
    }
LABEL_36:
    size_t v14 = "HEVC";
    goto LABEL_37;
  }
  int v8 = sub_1BBAB1784(*(char **)(a1 + 2288));
  if (v8)
  {
    BOOL v9 = v8;
    int v10 = 0;
    int v11 = *(_DWORD *)(a1 + 24);
    if (v11 > 1718908519)
    {
      if (v11 == 1718908520) {
        goto LABEL_25;
      }
      int v12 = 1752589105;
    }
    else
    {
      if (v11 == 1684632424) {
        goto LABEL_25;
      }
      int v12 = 1685481521;
    }
    if (v11 != v12) {
      int v10 = 1;
    }
LABEL_25:
    uint64_t v16 = sub_1BBAB19BC((uint64_t)v8, *(void *)(a1 + 2288), v10, a2, &v26, 0, 0, 0);
    if (v16)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v21 = *(_DWORD *)(a1 + 24);
        size_t v22 = "H.264";
        if (v21 > 1718908519)
        {
          if (v21 == 1752589105) {
            goto LABEL_42;
          }
          int v23 = 1718908520;
        }
        else
        {
          if (v21 == 1684632424) {
            goto LABEL_42;
          }
          int v23 = 1685481521;
        }
        if (v21 != v23)
        {
LABEL_43:
          *(_DWORD *)buf = 134218242;
          uint64_t v28 = a1;
          __int16 v29 = 2080;
          size_t v30 = v22;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VCPDec %p (%s) VCPDecompressionSessionCheckIfLastSubFrame ParseControlByteFromBuffer failed", buf, 0x16u);
          goto LABEL_31;
        }
LABEL_42:
        size_t v22 = "HEVC";
        goto LABEL_43;
      }
    }
    else
    {
      *a3 = v9[96];
    }
LABEL_31:
    (*(void (**)(char *))(*(void *)v9 + 8))(v9);
    return v16;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    int v18 = *(_DWORD *)(a1 + 24);
    int v19 = "H.264";
    if (v18 > 1718908519)
    {
      if (v18 == 1752589105) {
        goto LABEL_47;
      }
      int v20 = 1718908520;
    }
    else
    {
      if (v18 == 1684632424) {
        goto LABEL_47;
      }
      int v20 = 1685481521;
    }
    if (v18 != v20)
    {
LABEL_48:
      *(_DWORD *)buf = 134218242;
      uint64_t v28 = a1;
      __int16 v29 = 2080;
      size_t v30 = v19;
      uint64_t v24 = MEMORY[0x1E4F14500];
      int v25 = "VCPDec %p (%s) Failed to create ControlByte";
      goto LABEL_38;
    }
LABEL_47:
    int v19 = "HEVC";
    goto LABEL_48;
  }
  return 4294954394;
}

void VPModuleInitialize()
{
  if (qword_1EC027118 != -1) {
    dispatch_once(&qword_1EC027118, &unk_1F14EF220);
  }
}

void sub_1BB9EB4A0()
{
  sub_1BB9C461C(1718908515, 1000, 0, -1);
  sub_1BB9C461C(1635148593, -1, @"com.apple.videotoolbox.videoencoder.h264.rtvc", 0);
  sub_1BB9C461C(1752589105, -1, @"com.apple.videotoolbox.videoencoder.hevc.rtvc", 0);
  if (qword_1EC027190 != -1) {
    dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
  }
  if (dword_1EC02719C >= 9)
  {
    sub_1BB9C461C(1718908520, 1000, 0, -1);
  }
}

uint64_t sub_1BB9EB584()
{
  char v0 = [MEMORY[0x1E4F61768] sharedInstance];
  if ([v0 isLoaded])
  {
    char v1 = [v0 objectForKey:@"vc-disable-lowdelayB"];
    uint64_t v2 = v1;
    if (v1) {
      uint64_t v3 = [v1 BOOLValue];
    }
    else {
      uint64_t v3 = 0;
    }
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v2 = 0;
  }

  return v3;
}

void sub_1BB9EB618(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EBAD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EBC7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EBF34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  int v13 = v11;

  _Unwind_Resume(a1);
}

void sub_1BB9EC0B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EC2C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EC4F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EC82C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EC8C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EC8D8(int a1, VTPixelTransferSessionRef *a2, CVPixelBufferRef pixelBuffer, int *a4, int *a5)
{
  propertyValueOut[0] = 0;
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  size_t Height = CVPixelBufferGetHeight(pixelBuffer);
  int v12 = *a4;
  v28.origin.x = (double)*a4;
  double v13 = (double)a4[1];
  int v14 = *a5;
  double v15 = (double)a5[1];
  v28.origin.y = v13;
  v28.size.int32_t width = (double)*a5;
  v28.size.int32_t height = v15;
  propertyCFDataRef Value = CGRectCreateDictionaryRepresentation(v28);
  if (!*a2 && VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2)) {
    goto LABEL_29;
  }
  int v17 = (CFTypeRef *)(a2 + 1);
  uint64_t v16 = a2[1];
  if (v16)
  {
    if (Width == CVPixelBufferGetWidth(v16) && Height == CVPixelBufferGetHeight((CVPixelBufferRef)*v17))
    {
      if (*v17)
      {
        CFMutableDictionaryRef value = 0;
        CFMutableDictionaryRef Mutable = 0;
        goto LABEL_12;
      }
    }
    else
    {
      CFRelease(*v17);
      CFTypeRef *v17 = 0;
    }
  }
  CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef value = CFDictionaryCreateMutable(v19, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F24D20], value);
  if (CVPixelBufferCreate(v19, Width, Height, PixelFormatType, Mutable, a2 + 1))
  {
    CFDictionaryRef DictionaryRepresentation = 0;
    CFDictionaryRef v21 = 0;
LABEL_21:
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (value) {
      CFRelease(value);
    }
    if (v21) {
      CFRelease(v21);
    }
    if (DictionaryRepresentation) {
      CFRelease(DictionaryRepresentation);
    }
LABEL_29:
    CFTypeRef v23 = propertyValueOut[0];
    if (propertyValueOut[0]) {
      CFRetain(propertyValueOut[0]);
    }
    propertyValueOut[1] = 0;
    *(void *)buf = v23;
    operator new();
  }
LABEL_12:
  if (PixelFormatType == 1882468912 && (int v22 = v12 % 6, v12 % 6 >= 1))
  {
    v29.origin.x = (double)(v12 - v22);
    v29.size.int32_t width = (double)(v14 + v22);
    v29.origin.y = v13;
    v29.size.int32_t height = v15;
    propertyCFDataRef Value = CGRectCreateDictionaryRepresentation(v29);
    v30.origin.x = (double)v22;
    v30.origin.y = 0.0;
    v30.size.int32_t width = (double)v14;
    v30.size.int32_t height = v15;
    CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v30);
    CFDictionaryRef v21 = propertyValue;
  }
  else
  {
    CFDictionaryRef DictionaryRepresentation = 0;
    CFDictionaryRef v21 = 0;
  }
  VTSessionSetProperty(*a2, (CFStringRef)*MEMORY[0x1E4F45170], propertyValue);
  VTSessionSetProperty(*a2, (CFStringRef)*MEMORY[0x1E4F450F0], propertyValue);
  VTSessionSetProperty(*a2, (CFStringRef)*MEMORY[0x1E4F45130], (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
  VTSessionSetProperty(*a2, (CFStringRef)*MEMORY[0x1E4F45140], DictionaryRepresentation);
  CVBufferPropagateAttachments(pixelBuffer, (CVBufferRef)*v17);
  if (!VTPixelTransferSessionTransferImage(*a2, pixelBuffer, a2[1]))
  {
    VTSessionCopyProperty(*a2, (CFStringRef)*MEMORY[0x1E4F45138], (CFAllocatorRef)*MEMORY[0x1E4F1CF80], propertyValueOut);
    if (propertyValueOut[0])
    {
      CVBufferSetAttachment((CVBufferRef)*v17, @"histogram", propertyValueOut[0], kCVAttachmentMode_ShouldPropagate);
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Error: Empty histogram data\n", buf, 2u);
    }
  }
  goto LABEL_21;
}

void sub_1BB9ECD44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1BB9BE124((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1BB9ECDCC(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 152);
  uint64_t v4 = v2;
  if (v2) {
    CFRetain(v2);
  }
  sub_1BB9CCEE4(a1, &v4);
  return sub_1BB9BE124(&v4);
}

void sub_1BB9ECE18(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_begin_catch(a1);
  std::current_exception();
  v11.__ptr_ = &a9;
  std::__assoc_sub_state::set_exception(v10, v11);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)&a9);
  __cxa_end_catch();
  JUMPOUT(0x1BB9ECE08);
}

void sub_1BB9ECE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
}

void sub_1BB9ECE74(uint64_t a1)
{
  *(void *)a1 = &unk_1F14ED790;
  uint64_t v2 = (std::mutex *)(a1 + 24);
  sub_1BB9BE124((const void **)(a1 + 152));
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex(v2);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9ECF24(uint64_t a1)
{
  *(void *)a1 = &unk_1F14ED790;
  uint64_t v2 = (std::mutex *)(a1 + 24);
  sub_1BB9BE124((const void **)(a1 + 152));
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex(v2);
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

const UInt8 *sub_1BB9ECFC0(const UInt8 *result, CFDataRef theData, unsigned int a3)
{
  if (theData)
  {
    uint64_t v4 = result;
    unsigned int v5 = 1 << a3;
    CFNumberRef v6 = &result[4 * *((unsigned int *)result + 2052)];
    *((_DWORD *)v6 + 2048) = 0;
    *((_DWORD *)v6 + 2050) = 0;
    CFNumberRef result = CFDataGetBytePtr(theData);
    uint64_t v7 = *((unsigned int *)v4 + 2052);
    if (a3 >= 3)
    {
      int v8 = (float32x4_t *)&v4[4096 * v7];
      BOOL v9 = (float32x4_t *)&v4[4096 * (unint64_t)*((unsigned int *)v4 + 2053)];
      LODWORD(v10) = v5 >> 3;
      if (v5 >> 3 <= 1) {
        uint64_t v10 = 1;
      }
      else {
        uint64_t v10 = v10;
      }
      float v11 = 0.0;
      do
      {
        uint32x4_t v13 = *(uint32x4_t *)result;
        uint32x4_t v12 = *((uint32x4_t *)result + 1);
        result += 32;
        float32x4_t v14 = vcvtq_f32_u32(v13);
        float32x4_t v15 = vcvtq_f32_u32(v12);
        float32x4_t *v8 = v14;
        v8[1] = v15;
        int8x16_t v16 = (int8x16_t)vaddq_f32(v14, v15);
        uint64_t v7 = *((unsigned int *)v4 + 2052);
        int v17 = &v4[4 * v7];
        *((float *)v17 + 2048) = *((float *)v17 + 2048)
                               + vaddv_f32(vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL)));
        int8x16_t v18 = (int8x16_t)vaddq_f32(vmulq_f32(*v8, *v8), vmulq_f32(v8[1], v8[1]));
        *((float *)v17 + 2050) = *((float *)v17 + 2050)
                               + vaddv_f32(vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL)));
        float32x4_t v19 = *v8;
        float32x4_t v20 = v8[1];
        v8 += 2;
        float32x4_t v21 = *v9;
        float32x4_t v22 = v9[1];
        v9 += 2;
        int8x16_t v23 = (int8x16_t)vaddq_f32(vmulq_f32(v19, v21), vmulq_f32(v20, v22));
        float v11 = v11 + vaddv_f32(vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL)));
        --v10;
      }
      while (v10);
    }
    *((_DWORD *)v4 + 2053) = v7;
    *((_DWORD *)v4 + 2052) = v7 ^ 1;
  }
  return result;
}

void sub_1BB9ED494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);

  sub_1BB9BE124((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9ED530(uint64_t a1)
{
  return a1;
}

const void **sub_1BB9ED56C(uint64_t a1)
{
  [*(id *)(a1 + 152) waitUntilCompleted];
  uint64_t v2 = [*(id *)(a1 + 160) contents];
  unint64_t v3 = *(unsigned int *)(a1 + 168);
  if (v3 >= 8)
  {
    uint64_t v4 = 0;
    unint64_t v5 = v3 >> 3;
    uint64_t v6 = 32 * (v3 >> 3);
    uint64_t v7 = v2 + 96 * v5;
    uint64_t v8 = v2 + (v5 << 6);
    uint64_t v9 = v2 + 32 * v5;
    do
    {
      uint64_t v10 = (int32x4_t *)(v2 + v4);
      int32x4_t v11 = vaddq_s32(*(int32x4_t *)(v2 + v4 + 16), *(int32x4_t *)(v9 + v4 + 16));
      int32x4_t v12 = vaddq_s32(*(int32x4_t *)(v2 + v4), *(int32x4_t *)(v9 + v4));
      int32x4_t *v10 = v12;
      v10[1] = v11;
      int32x4_t v13 = vaddq_s32(*(int32x4_t *)(v8 + v4), v12);
      int32x4_t v14 = vaddq_s32(*(int32x4_t *)(v8 + v4 + 16), v11);
      int32x4_t *v10 = v13;
      v10[1] = v14;
      int32x4_t v15 = vaddq_s32(*(int32x4_t *)(v7 + v4 + 16), v14);
      int32x4_t *v10 = vaddq_s32(*(int32x4_t *)(v7 + v4), v13);
      v10[1] = v15;
      v4 += 32;
    }
    while (v6 != v4);
  }
  int8x16_t v16 = *(const void **)(a1 + 176);
  int8x16_t v18 = v16;
  if (v16) {
    CFRetain(v16);
  }
  sub_1BB9CCEE4(a1, &v18);
  return sub_1BB9BE124(&v18);
}

void sub_1BB9ED644(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9, const void *a10)
{
  sub_1BB9BE124(&a10);
  __cxa_begin_catch(a1);
  std::current_exception();
  v12.__ptr_ = &a9;
  std::__assoc_sub_state::set_exception(v10, v12);
  std::exception_ptr::~exception_ptr(&a9);
  __cxa_end_catch();
  JUMPOUT(0x1BB9ED634);
}

void sub_1BB9ED684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception_ptr a9)
{
}

void sub_1BB9ED6A0(uint64_t a1)
{
  *(void *)a1 = &unk_1F14ED760;
  sub_1BB9BE124((const void **)(a1 + 176));

  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  JUMPOUT(0x1C18605E0);
}

void sub_1BB9ED74C(uint64_t a1)
{
  *(void *)a1 = &unk_1F14ED760;
  sub_1BB9BE124((const void **)(a1 + 176));

  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_1BB9ED8F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9C14A0((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1BB9EDAF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EDB08(void *a1, id *a2, uint64_t a3, void *a4, void *a5)
{
  uint64_t v10 = (void *)MEMORY[0x1C1860C30]();
  id v11 = *a2;
  std::exception_ptr v12 = v11;
  *(void *)&long long v13 = (int)*a4;
  *((void *)&v13 + 1) = (int)HIDWORD(*a4);
  long long v14 = v13;
  uint64_t v15 = 0;
  *(void *)&long long v13 = (int)*a5;
  *((void *)&v13 + 1) = (int)HIDWORD(*a5);
  long long v16 = v13;
  uint64_t v17 = 1;
  if (v11) {
    [v11 generateHistogramMetal:a3 forRegion:&v14];
  }
  else {
    *a1 = 0;
  }
}

void sub_1BB9EDBB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EDED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EE478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EE664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EE864(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EEA90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EED6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EEE08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EF270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1BB9EFA88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,uint64_t a21,void *a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,const void *a32)
{
  sub_1BB9BE124(&a32);
  sub_1BB9BE124((const void **)(v37 - 136));
  sub_1BB9BE124((const void **)(v37 - 128));

  _Unwind_Resume(a1);
}

uint64_t sub_1BB9EFB3C(uint32x4_t *a1, unint64_t a2)
{
  int64x2_t v2 = 0uLL;
  if (a2 < 0x11)
  {
    if (!a2)
    {
      uint64_t v11 = 0;
      int64x2_t v3 = 0uLL;
      int64x2_t v4 = 0uLL;
      int64x2_t v5 = 0uLL;
      return vaddvq_s64(vaddq_s64(vaddq_s64(v2, v4), vaddq_s64(v3, v5))) + v11;
    }
    int64x2_t v3 = 0uLL;
    int64x2_t v4 = 0uLL;
    int64x2_t v5 = 0uLL;
  }
  else
  {
    int64x2_t v3 = 0uLL;
    int64x2_t v4 = 0uLL;
    int64x2_t v5 = 0uLL;
    do
    {
      uint32x4_t v6 = a1[1];
      uint64x2_t v7 = vaddw_high_u32((uint64x2_t)v5, v6);
      uint64x2_t v8 = vaddw_u32((uint64x2_t)v4, *(uint32x2_t *)v6.i8);
      uint32x4_t v10 = a1[2];
      uint32x4_t v9 = a1[3];
      int64x2_t v3 = (int64x2_t)vaddw_high_u32(vaddw_high_u32((uint64x2_t)v3, *a1), v10);
      int64x2_t v4 = (int64x2_t)vaddw_u32(v8, *(uint32x2_t *)v9.i8);
      int64x2_t v2 = (int64x2_t)vaddw_u32(vaddw_u32((uint64x2_t)v2, *(uint32x2_t *)a1->i8), *(uint32x2_t *)v10.i8);
      int64x2_t v5 = (int64x2_t)vaddw_high_u32(v7, v9);
      a1 += 4;
      a2 -= 16;
    }
    while (a2 > 0x10);
  }
  uint64_t v11 = 0;
  do
  {
    unsigned __int32 v12 = a1->i32[0];
    a1 = (uint32x4_t *)((char *)a1 + 4);
    v11 += v12;
    --a2;
  }
  while (a2);
  return vaddvq_s64(vaddq_s64(vaddq_s64(v2, v4), vaddq_s64(v3, v5))) + v11;
}

void sub_1BB9EFE30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BB9C14A0((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1BB9F0038(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9F0264(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9F06A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BB9F0744(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1BB9F0754(int a1, uint64_t a2, void *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  VTVideoEncoderGetClassID();
  uint64_t v5 = CMDerivedObjectCreate();
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    if (a1 == 1684632424 || a1 == 1752589105 || a1 == 1718908520) {
      uint32x4_t v6 = "HEVC";
    }
    else {
      uint32x4_t v6 = "H.264";
    }
    *(_DWORD *)buf = 136315394;
    uint32x4_t v9 = v6;
    __int16 v10 = 1024;
    int v11 = v5;
    _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: failed to create video encoder instance, err = %d\n", buf, 0x12u);
  }
  *a3 = 0;
  return v5;
}

uint64_t sub_1BB9F0ABC()
{
  VTVideoEncoderGetCMBaseObject();
  uint64_t DerivedStorage = (int *)CMBaseObjectGetDerivedStorage();
  if (DerivedStorage)
  {
    uint64_t v1 = sub_1BBA15714(DerivedStorage[85], DerivedStorage[86], DerivedStorage[58], DerivedStorage[12]);
    if (v1 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Error setting requested profile in HEVCVideoEncoder_PrepareToEncodeFrames\n", buf, 2u);
    }
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int64x2_t v3 = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Error NULL encoder object recieved at HEVCVideoEncoder_PrepareToEncodeFrames\n", v3, 2u);
    }
    return 4294954385;
  }
  return v1;
}

uint64_t sub_1BB9F0BA0(uint64_t a1, uint64_t *a2)
{
  pthread_once(&stru_1E9F80A78, sub_1BB9F0C38);
  if (a2 && (uint64_t v3 = qword_1E9F81B60) != 0)
  {
    CFRetain((CFTypeRef)qword_1E9F81B60);
    *a2 = v3;
    return 0;
  }
  else
  {
    return FigSignalErrorAt();
  }
}

void sub_1BB9F0C38()
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9F81D18, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9F81D18))
  {
    uint64_t v14 = *MEMORY[0x1E4F447E8];
    qword_1E9F81B68 = *MEMORY[0x1E4F44B68];
    unk_1E9F81B70 = v14;
    uint64_t v15 = *MEMORY[0x1E4F449C8];
    qword_1E9F81B78 = *MEMORY[0x1E4F447D0];
    unk_1E9F81B80 = v15;
    uint64_t v16 = *MEMORY[0x1E4F449D0];
    qword_1E9F81B88 = v15;
    unk_1E9F81B90 = v16;
    uint64_t v17 = *MEMORY[0x1E4F44810];
    qword_1E9F81B98 = *MEMORY[0x1E4F44A40];
    unk_1E9F81BA0 = v17;
    uint64_t v18 = *MEMORY[0x1E4F44840];
    qword_1E9F81BA8 = *MEMORY[0x1E4F44920];
    unk_1E9F81BB0 = v18;
    qword_1E9F81BB8 = @"CommandLineParametersExtraOptions";
    unk_1E9F81BC0 = @"BPictures";
    qword_1E9F81BC8 = @"NegotiationDetailsBitField";
    unk_1E9F81BD0 = @"NegotiatedFLB";
    qword_1E9F81BD8 = @"AverageTemporalBitRates";
    unk_1E9F81BE0 = @"MaxRefreshFrameIntervalDuration";
    uint64_t v19 = *MEMORY[0x1E4F44870];
    qword_1E9F81BE8 = @"ThermalLevel";
    unk_1E9F81BF0 = v19;
    uint64_t v20 = *MEMORY[0x1E4F44898];
    qword_1E9F81BF8 = @"AverageBitRateIntraLayer";
    unk_1E9F81C00 = v20;
    uint64_t v21 = *MEMORY[0x1E4F44830];
    qword_1E9F81C08 = *MEMORY[0x1E4F448F0];
    unk_1E9F81C10 = v21;
    uint64_t v22 = *MEMORY[0x1E4F449B8];
    qword_1E9F81C18 = *MEMORY[0x1E4F44820];
    unk_1E9F81C20 = v22;
    uint64_t v23 = *MEMORY[0x1E4F44AC8];
    qword_1E9F81C28 = *MEMORY[0x1E4F449E0];
    unk_1E9F81C30 = v23;
    uint64_t v24 = *MEMORY[0x1E4F44AA0];
    qword_1E9F81C38 = *MEMORY[0x1E4F448A0];
    unk_1E9F81C40 = v24;
    uint64_t v25 = *MEMORY[0x1E4F44A60];
    qword_1E9F81C48 = *MEMORY[0x1E4F44B18];
    unk_1E9F81C50 = v25;
    uint64_t v26 = *MEMORY[0x1E4F44B58];
    qword_1E9F81C58 = *MEMORY[0x1E4F44868];
    unk_1E9F81C60 = v26;
    uint64_t v27 = *MEMORY[0x1E4F44A18];
    qword_1E9F81C68 = *MEMORY[0x1E4F44BB0];
    unk_1E9F81C70 = v27;
    qword_1E9F81C78 = *MEMORY[0x1E4F44900];
    unk_1E9F81C80 = @"UsingCellular";
    qword_1E9F81C88 = @"FaceRect";
    unk_1E9F81C90 = @"RemoteMLScale";
    uint64_t v28 = *MEMORY[0x1E4F44A38];
    qword_1E9F81C98 = @"Foveation";
    unk_1E9F81CA0 = v28;
    uint64_t v29 = *MEMORY[0x1E4F44990];
    qword_1E9F81CA8 = *MEMORY[0x1E4F44AD8];
    unk_1E9F81CB0 = v29;
    qword_1E9F81CB8 = @"EnableFrameDropping";
    unk_1E9F81CC0 = @"AllowQpModulation";
    uint64_t v30 = *MEMORY[0x1E4F448B0];
    qword_1E9F81CC8 = @"MinNumberOfTemporalLayers";
    unk_1E9F81CD0 = v30;
    uint64_t v31 = *MEMORY[0x1E4F44A30];
    qword_1E9F81CD8 = *MEMORY[0x1E4F447F0];
    unk_1E9F81CE0 = v31;
    qword_1E9F81CE8 = @"SliceQP";
    unk_1E9F81CF0 = @"SliceDeltaQP";
    uint64_t v32 = *MEMORY[0x1E4F448D8];
    qword_1E9F81CF8 = @"SliceMaxQP";
    unk_1E9F81D00 = v32;
    qword_1E9F81D08 = *MEMORY[0x1E4F449E8];
    unk_1E9F81D10 = @"CallerID";
    __cxa_guard_release(&qword_1E9F81D18);
  }
  memset(v33, 0, sizeof(v33));
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    uint64_t v1 = Mutable;
    int64x2_t v2 = (const void **)MEMORY[0x1E4F452D0];
    uint64_t v3 = 0x10u;
    do
    {
      CFArrayAppendValue(v1, *v2);
      int64x2_t v2 = *(const void ***)((char *)&off_1E62479C0 + v3);
      v3 += 16;
    }
    while (v3 != 112);
    int64x2_t v4 = (const void **)MEMORY[0x1E4F45190];
    uint64_t v5 = 0x10u;
    do
    {
      CFArrayAppendValue(v1, *v4);
      int64x2_t v4 = *(const void ***)((char *)&off_1E6247A30 + v5);
      v5 += 16;
    }
    while (v5 != 544);
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64x2_t v7 = (void *)*MEMORY[0x1E4F45310];
    values = v1;
    keys[0] = v7;
    CFDictionaryRef v8 = CFDictionaryCreate(v6, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFRelease(v1);
  }
  else
  {
    CFDictionaryRef v8 = 0;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  }
  CFDictionaryRef v9 = CFDictionaryCreate(v6, 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryRef v10 = v9;
  if (v9) {
    BOOL v11 = v8 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11) {
    goto LABEL_16;
  }
  uint64_t v12 = 0;
  int64x2_t v13 = vdupq_n_s64((unint64_t)v9);
  do
    v33[v12++] = v13;
  while (v12 != 27);
  qword_1E9F81B60 = (uint64_t)CFDictionaryCreate(v6, (const void **)&qword_1E9F81B68, (const void **)v33, 54, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!qword_1E9F81B60) {
LABEL_16:
  }
    FigSignalErrorAt();
  if (v10) {
    CFRelease(v10);
  }
  if (v8) {
    CFRelease(v8);
  }
}

uint64_t sub_1BB9F113C()
{
  VTVideoEncoderGetCMBaseObject();
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (!DerivedStorage) {
    return 0;
  }
  uint64_t v1 = DerivedStorage;
  int64x2_t v2 = *(NSObject **)(DerivedStorage + 1392);
  if (v2) {
    dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  }
  uint64_t v3 = *(void *)(v1 + 16);
  if (v3)
  {
    if (*(int *)(v3 + 3692) >= 1)
    {
      uint64_t v4 = *(void *)(v3 + 13272);
      if (v4)
      {
        uint64_t v5 = (*(uint64_t (**)(void))(*(void *)v4 + 56))(*(void *)(v3 + 13272));
        if (v5) {
          goto LABEL_12;
        }
        uint64_t v3 = *(void *)(v1 + 16);
      }
    }
    uint64_t v5 = sub_1BBA59368(v3);
  }
  else
  {
    uint64_t v5 = 0;
  }
LABEL_12:
  CFAllocatorRef v6 = *(NSObject **)(v1 + 1392);
  if (v6) {
    dispatch_semaphore_signal(v6);
  }
  return v5;
}

uint64_t sub_1BB9F11F0(uint64_t a1, uint64_t a2, __CVBuffer *a3, CMTime *a4, long long *a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v232 = *MEMORY[0x1E4F143B8];
  VTVideoEncoderGetCMBaseObject();
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  uint64_t v196 = 0;
  uint64_t v197 = 0;
  CMTime time = *a4;
  CMTimeGetSeconds(&time);
  IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface(a3);
  if (IOSurface) {
    IOSurfaceGetID(IOSurface);
  }
  kdebug_trace();
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(DerivedStorage + 1392), 0xFFFFFFFFFFFFFFFFLL);
  if (*(unsigned char *)(DerivedStorage + 356))
  {
    if (dword_1E9F80A90 < 1) {
      return 4294954393;
    }
    int v15 = *(_DWORD *)(DerivedStorage + 48);
    if (v15 == 1684632424 || v15 == 1752589105 || v15 == 1718908520) {
      uint64_t v16 = "HEVC";
    }
    else {
      uint64_t v16 = "H.264";
    }
    uint64_t v18 = 4294954393;
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s: video encoder is invalid, err = %d\n", v16, -12903);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      int v24 = *(_DWORD *)(DerivedStorage + 48);
      if (v24 == 1684632424 || v24 == 1752589105 || v24 == 1718908520) {
        uint64_t v25 = "HEVC";
      }
      else {
        uint64_t v25 = "H.264";
      }
      LODWORD(time.CFDictionaryAddValue(theDict, key, value) = 136315394;
      *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)v25;
      LOWORD(time.flags) = 1024;
      uint64_t v18 = 4294954393;
      *(CMTimeFlags *)((char *)&time.flags + 2) = -12903;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%s: video encoder is invalid, err = %d\n", (uint8_t *)&time, 0x12u);
    }
    return v18;
  }
  uint64_t v188 = (int32x2_t *)(DerivedStorage + 348);
  if (*(void *)(DerivedStorage + 1416))
  {
    if (*(int *)(DerivedStorage + 52) > 40000000)
    {
      *(_DWORD *)(DerivedStorage + 1400) = 0;
    }
    else if (v188->i32[0] >= 1 {
           && (v188->i32[0] & 0x7F) == 0
    }
           && !dispatch_semaphore_wait(*(dispatch_semaphore_t *)(DerivedStorage + 1408), 0))
    {
      uint64_t v17 = *(void **)(DerivedStorage + 1416);
      time.CFMutableDictionaryRef value = MEMORY[0x1E4F143A8];
      *(void *)&time.int32_t timescale = 0x40000000;
      time.CMTimeEpoch epoch = (CMTimeEpoch)sub_1BB9F3534;
      int v219 = &unk_1E6247C50;
      *(void *)uint32_t v220 = DerivedStorage;
      sub_1BBA12900(v17, (uint64_t)a3, 1u, 0, &time);
    }
  }
  uint64_t v185 = a2;
  uint64_t v186 = a7;
  uint32_t v187 = (char *)operator new(0x40uLL, MEMORY[0x1E4FBA2D0]);
  if (!v187)
  {
    CMTimeFlags v21 = -12904;
    goto LABEL_329;
  }
  if (!a3) {
    goto LABEL_328;
  }
  uint32_t v184 = a5;
  uint64_t v19 = *(void *)(DerivedStorage + 16);
  if (v19)
  {
    if (*(int *)(v19 + 3692) >= 1)
    {
      uint64_t v20 = *(void *)(v19 + 13272);
      if (v20)
      {
        CMTimeFlags v21 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 56))(v20);
        if (v21)
        {
          if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
            goto LABEL_329;
          }
          int v22 = *(_DWORD *)(DerivedStorage + 48);
          if (v22 == 1684632424 || v22 == 1752589105 || v22 == 1718908520) {
            uint64_t v23 = "HEVC";
          }
          else {
            uint64_t v23 = "H.264";
          }
          LODWORD(time.CFDictionaryAddValue(theDict, key, value) = 136315394;
          *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)v23;
          LOWORD(time.flags) = 1024;
          *(CMTimeFlags *)((char *)&time.flags + 2) = v21;
          unint64_t v93 = MEMORY[0x1E4F14500];
          int v94 = "%s: video encoder is busy, err = %d\n";
LABEL_203:
          _os_log_error_impl(&dword_1BB9B9000, v93, OS_LOG_TYPE_ERROR, v94, (uint8_t *)&time, 0x12u);
          goto LABEL_329;
        }
      }
    }
    goto LABEL_299;
  }
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a3);
  CFTypeRef v26 = CVBufferCopyAttachment(a3, (CFStringRef)*MEMORY[0x1E4F24A10], 0);
  CFTypeRef v27 = CVBufferCopyAttachment(a3, (CFStringRef)*MEMORY[0x1E4F24A08], 0);
  uint64_t v28 = v27;
  if (!v26)
  {
    int v35 = 0;
    if (!v27) {
      goto LABEL_53;
    }
LABEL_52:
    CFRelease(v28);
    goto LABEL_53;
  }
  if (v27) {
    CFEqual(v26, v27);
  }
  CFEqual(v26, (CFTypeRef)*MEMORY[0x1E4F24A38]);
  int v29 = CFEqual(v26, (CFTypeRef)*MEMORY[0x1E4F24A28]);
  int v30 = CFEqual(v26, (CFTypeRef)*MEMORY[0x1E4F24A48]);
  int v31 = CFEqual(v26, (CFTypeRef)*MEMORY[0x1E4F24A40]);
  int v32 = CFEqual(v26, (CFTypeRef)*MEMORY[0x1E4F24A20]);
  int v33 = CFEqual(v26, (CFTypeRef)*MEMORY[0x1E4F24A18]);
  int v34 = v29 != 0;
  if (v30) {
    int v34 = 2;
  }
  if (v31) {
    int v34 = 3;
  }
  if (v32) {
    int v34 = 4;
  }
  if (v33) {
    int v35 = 5;
  }
  else {
    int v35 = v34;
  }
  CFRelease(v26);
  if (v28) {
    goto LABEL_52;
  }
LABEL_53:
  snprintf(__str, 0x20uLL, "%d", v35);
  int IntegerCodePointForString = CVColorPrimariesGetIntegerCodePointForString(*(CFStringRef *)(DerivedStorage + 288));
  snprintf(v217, 0x20uLL, "%d", IntegerCodePointForString);
  int v37 = CVTransferFunctionGetIntegerCodePointForString(*(CFStringRef *)(DerivedStorage + 296));
  snprintf(v216, 0x20uLL, "%d", v37);
  int v38 = CVYCbCrMatrixGetIntegerCodePointForString(*(CFStringRef *)(DerivedStorage + 304));
  snprintf(v215, 0x20uLL, "%d", v38);
  snprintf(v214, 0x40uLL, "%d:%d", *(_DWORD *)(DerivedStorage + 332), *(_DWORD *)(DerivedStorage + 336));
  int v39 = *(_DWORD *)(DerivedStorage + 48);
  unsigned int v40 = *(_DWORD *)(DerivedStorage + 240);
  if (v39 == 1718908520 && (v40 > 0x2B || ((1 << v40) & 0xC4000100002) == 0))
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_185;
    }
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)__int16 v199 = -12910;
    int v45 = MEMORY[0x1E4F14500];
    int v46 = "HEVC: unsupported codec type or usage, err = %d\n";
LABEL_128:
    uint32_t v47 = 8;
    goto LABEL_184;
  }
  if (v40 == 43 && v39 != 1684632424 && v39 != 1718908520 && v39 != 1752589105)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_185;
    }
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)__int16 v199 = -12910;
    int v45 = MEMORY[0x1E4F14500];
    int v46 = "TrafficLight usage only supported in HEVC, err = %d\n";
    goto LABEL_128;
  }
  unsigned int v41 = *(_DWORD *)(DerivedStorage + 1488);
  if (v41 - 5 < 0xFFFFFFFC) {
    goto LABEL_61;
  }
  if (v41 < 2)
  {
    if (v40 != 43)
    {
      int v44 = *(_DWORD *)(DerivedStorage + 344);
      unsigned int v41 = 1;
      goto LABEL_85;
    }
LABEL_74:
    if (dword_1E9F80A90 >= 2)
    {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Warning: Got number_slices = %d for TrafficLight usage, forced number_slices = 3!\n", *(_DWORD *)(DerivedStorage + 1488));
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int v43 = *(_DWORD *)(DerivedStorage + 1488);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)__int16 v199 = v43;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Warning: Got number_slices = %d for TrafficLight usage, forced number_slices = 3!\n", buf, 8u);
      }
    }
    unsigned int v41 = 3;
    *(_DWORD *)(DerivedStorage + 1488) = 3;
    goto LABEL_78;
  }
  if (v39 != 1684632424 && v39 != 1718908520 && v39 != 1752589105)
  {
LABEL_61:
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      if (v39 == 1684632424 || v39 == 1752589105 || v39 == 1718908520) {
        unsigned int v42 = "HEVC";
      }
      else {
        unsigned int v42 = "H264";
      }
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)__int16 v199 = v41;
      *(_WORD *)&v199[4] = 2080;
      *(void *)&v199[6] = v42;
      *(_WORD *)&v199[14] = 1024;
      *(_DWORD *)&v199[16] = -12910;
      int v45 = MEMORY[0x1E4F14500];
      int v46 = "Got numberOfSlices = %d doesn't supported by %s encoder, err = %d\n";
      uint32_t v47 = 24;
      goto LABEL_184;
    }
LABEL_185:
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_186;
    }
    int v91 = *(_DWORD *)(DerivedStorage + 48);
    if (v91 == 1684632424 || v91 == 1752589105 || v91 == 1718908520) {
      int v92 = "HEVC";
    }
    else {
      int v92 = "H.264";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)__int16 v199 = v92;
    int v74 = MEMORY[0x1E4F14500];
    int v75 = "%s: CompressParamsSetup failed\n";
    uint32_t v76 = 12;
    goto LABEL_200;
  }
  if (v40 != 43) {
    goto LABEL_78;
  }
  if (v41 != 3) {
    goto LABEL_74;
  }
  unsigned int v41 = 3;
LABEL_78:
  int v44 = *(_DWORD *)(DerivedStorage + 344);
  if (v44 % (int)(v41 << 6))
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_185;
    }
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)__int16 v199 = v41;
    *(_WORD *)&v199[4] = 1024;
    *(_DWORD *)&v199[6] = v44;
    int v45 = MEMORY[0x1E4F14500];
    int v46 = "Error: number of slice = %d and picture height = %d don't meet AVE requirement!\n";
    uint32_t v47 = 14;
LABEL_184:
    _os_log_error_impl(&dword_1BB9B9000, v45, OS_LOG_TYPE_ERROR, v46, buf, v47);
    goto LABEL_185;
  }
  unsigned int v40 = *(_DWORD *)(DerivedStorage + 240);
  int v39 = *(_DWORD *)(DerivedStorage + 48);
LABEL_85:
  int v48 = (const float *)(DerivedStorage + 228);
  int32x2_t v49 = (int32x2_t)vld1_dup_f32(v48);
  CMTimeValue v50 = (CMTimeValue)vsub_s32(v49, (int32x2_t)vand_s8((int8x8_t)vadd_s32(v49, (int32x2_t)vshl_u32((uint32x2_t)vcltz_s32(v49), (uint32x2_t)0xFFFFFFE6FFFFFFE4)), (int8x8_t)0xFFFFFFC0FFFFFFF0));
  LODWORD(time.CFDictionaryAddValue(theDict, key, value) = v50;
  *(CMTimeValue *)((char *)&time.value + 4) = v50;
  LOBYTE(time.flags) = v40;
  *(_DWORD *)uint32_t v220 = *(_DWORD *)(DerivedStorage + 52);
  int v219 = *(void **)(DerivedStorage + 24);
  LOWORD(time.epoch) = v44;
  HIWORD(time.flags) = *(_DWORD *)(DerivedStorage + 340);
  int v51 = *(_DWORD *)(DerivedStorage + 1380);
  BOOL v53 = v39 != 1752589105 && v39 != 1718908520;
  *(_DWORD *)&v220[4] = v53;
  *(_DWORD *)&v220[8] = 0;
  char v221 = 1;
  int v225 = v51;
  LODWORD(v222) = 0;
  char v231 = *(unsigned char *)(DerivedStorage + 1455);
  int v226 = 1;
  uint64_t v227 = -1;
  uint64_t v228 = -1;
  memset_pattern16(&v229, &unk_1BBB701A0, 0x10uLL);
  v230[1] = -1;
  v230[0] = -1;
  if (v41 >= 2)
  {
    int v226 = v41;
    uint64_t v54 = v41;
    int v55 = v230;
    size_t v56 = (int *)(DerivedStorage + 1524);
    do
    {
      *(v55 - 8) = *(v56 - 8);
      *(v55 - 4) = *(v56 - 4);
      int v57 = *v56++;
      *v55++ = v57;
      --v54;
    }
    while (v54);
  }
  strlcpy(v224, (const char *)(DerivedStorage + 368), 0x3E8uLL);
  if (qword_1EC027190 != -1) {
    dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
  }
  if (dword_1EC02719C > 0x11) {
    goto LABEL_144;
  }
  if (((1 << dword_1EC02719C) & 0x3FE00) != 0)
  {
LABEL_98:
    *(_DWORD *)&v220[8] = 2;
    *(unsigned char *)(DerivedStorage + 1384) = 1;
    goto LABEL_99;
  }
  if (((1 << dword_1EC02719C) & 0x7C) == 0)
  {
    if (((1 << dword_1EC02719C) & 0x180) != 0)
    {
      if (*(_DWORD *)&v220[4] == 1) {
        goto LABEL_98;
      }
      *(_DWORD *)&v220[8] = 1;
      *(unsigned char *)(DerivedStorage + 1384) = 0;
      goto LABEL_140;
    }
LABEL_144:
    if (dword_1E9F80A90 >= 2)
    {
      fwrite("Unknown device type.\n", 0x15uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Unknown device type.\n", buf, 2u);
      }
    }
    goto LABEL_98;
  }
  if (dword_1E9F80A90 >= 2)
  {
    fwrite("H6 or lower is not supported.\n", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "H6 or lower is not supported.\n", buf, 2u);
    }
  }
  if (*(_DWORD *)&v220[8] == 1)
  {
LABEL_140:
    if (*(int *)(DerivedStorage + 340) >= 321)
    {
      uint64_t v222 = 1;
      int v223 = 4;
    }
  }
LABEL_99:
  size_t v58 = operator new(0x33F8uLL, MEMORY[0x1E4FBA2D0]);
  if (!v58)
  {
    *(void *)(DerivedStorage + 16) = 0;
    __int16 v71 = -12904;
    goto LABEL_187;
  }
  CFTypeID v59 = v58;
  sub_1BBA577F8((uint64_t)v58);
  *(void *)(DerivedStorage + 16) = v59;
  v59[250] = PixelFormatType;
  int v60 = sub_1BBA13A1C(PixelFormatType);
  v59[251] = v60;
  int v61 = CVYCbCrMatrixGetIntegerCodePointForString(*(CFStringRef *)(DerivedStorage + 304));
  uint64_t v62 = *(void *)(DerivedStorage + 16);
  if (v61 != 9 && *(_DWORD *)(v62 + 1004) == 10) {
    int v64 = 248;
  }
  else {
    int v64 = v61;
  }
  *(_DWORD *)(v62 + 1008) = v64;
  sub_1BBA5EDC0(v62, 0x456BDD095F7DB261, *(_DWORD *)(DerivedStorage + 248));
  sub_1BBA5ED34(*(void *)(DerivedStorage + 16), 0x9A91BC7C819464BDLL, *(_DWORD *)(DerivedStorage + 252));
  int v65 = *(_DWORD *)(DerivedStorage + 232);
  if (v65) {
    sub_1BBA5EDC0(*(void *)(DerivedStorage + 16), 0x8ADD349E618BA10ELL, v65);
  }
  int v66 = *(_DWORD *)(DerivedStorage + 236);
  if (v66) {
    sub_1BBA5EDC0(*(void *)(DerivedStorage + 16), 0xE8DDC90A9D7C709DLL, v66);
  }
  if (v60 == 10)
  {
    uint64_t v67 = *(void *)(DerivedStorage + 16);
    buf[0] = 0;
    sub_1BBA40F94(*(void *)(v67 + 3192), 0x8C49EF6ED9F28EA0, "10", 0, (uint64_t)buf);
  }
  if (!sub_1BBA13EC4(PixelFormatType))
  {
    if (qword_1EC027190 != -1) {
      dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
    }
    int v72 = dword_1EC02719C;
    unsigned int v73 = *(_DWORD *)(DerivedStorage + 48);
    if (v73 != 1684632424 && v73 != 1752589105 && v73 != 1718908520 || dword_1EC02719C <= 10)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
LABEL_186:
        __int16 v71 = -12910;
        goto LABEL_187;
      }
      *(_DWORD *)buf = 67110144;
      *(_DWORD *)__int16 v199 = HIBYTE(v73);
      *(_WORD *)&v199[4] = 1024;
      *(_DWORD *)&v199[6] = BYTE2(v73);
      *(_WORD *)&v199[10] = 1024;
      *(_DWORD *)&v199[12] = BYTE1(v73);
      *(_WORD *)&v199[16] = 1024;
      *(_DWORD *)&v199[18] = v73;
      *(_WORD *)&v199[22] = 1024;
      *(_DWORD *)&v199[24] = v72;
      int v74 = MEMORY[0x1E4F14500];
      int v75 = "mono chrome encoding only support HEVC on H11 and newer. Got %c%c%c%c on device %d\n";
      uint32_t v76 = 32;
LABEL_200:
      _os_log_error_impl(&dword_1BB9B9000, v74, OS_LOG_TYPE_ERROR, v75, buf, v76);
      goto LABEL_186;
    }
    sub_1BBA5ED34(*(void *)(DerivedStorage + 16), 0x9D4699E02AD040AELL, 0);
  }
  sub_1BBA5ED34(*(void *)(DerivedStorage + 16), 0x3B036542BE80F4D6, *(_DWORD *)(DerivedStorage + 56));
  sub_1BBA5ED34(*(void *)(DerivedStorage + 16), 0xDE9D01B25B989E98, *(_DWORD *)(DerivedStorage + 60));
  sub_1BBA5ED34(*(void *)(DerivedStorage + 16), 0xE86133FFF2272F7BLL, *(unsigned __int8 *)(DerivedStorage + 1454));
  uint64_t v68 = *(void *)(DerivedStorage + 16);
  *(unsigned char *)(v68 + 1144) = *(_DWORD *)(DerivedStorage + 56) > 2;
  int v69 = *(_DWORD *)(DerivedStorage + 1468);
  int v70 = v69 - 1;
  if (v69 >= 1)
  {
    if (v69 <= 2)
    {
      if (*(_DWORD *)(DerivedStorage + 1456))
      {
        if (dword_1E9F80A90 >= 2)
        {
          fprintf((FILE *)*MEMORY[0x1E4F143C8], "Number of LTR %d is too small. Disable LTR\n", v70);
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)__int16 v199 = v70;
            _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Number of LTR %d is too small. Disable LTR\n", buf, 8u);
          }
        }
        int v70 = 0;
        *(_DWORD *)(DerivedStorage + 1456) = 0;
        int v69 = *(_DWORD *)(DerivedStorage + 1468);
        uint64_t v68 = *(void *)(DerivedStorage + 16);
      }
      else
      {
        int v70 = 0;
      }
    }
    if (v69 + 1 < *(char *)(v68 + 3332)) {
      int v77 = v69 + 1;
    }
    else {
      int v77 = *(char *)(v68 + 3332);
    }
    snprintf(__s, 0x20uLL, "%d:%d:%d:%d", v69 - v70, v70, 1, 1);
    if (dword_1E9F80A90 >= 2)
    {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "setting reference %s\n", __s);
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)__int16 v199 = __s;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "setting reference %s\n", buf, 0xCu);
      }
    }
    uint64_t v78 = *(void *)(DerivedStorage + 16);
    buf[0] = 0;
    sub_1BBA40F94(*(void *)(v78 + 3192), 0x89E9C01960F4C582, __s, 0, (uint64_t)buf);
    sub_1BBA5ED34(*(void *)(DerivedStorage + 16), 0x38D9AFB7AB26693ALL, v77);
    uint64_t v68 = *(void *)(DerivedStorage + 16);
  }
  sub_1BBA5EDC0(v68, 0xBE39025BC18BBD08, *(_DWORD *)(DerivedStorage + 1456));
  __int16 v71 = sub_1BBA5EABC(*(void *)(DerivedStorage + 16), (uint64_t)&time);
  if (v71)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v79 = *(_DWORD *)(DerivedStorage + 48);
      if (v79 == 1684632424 || v79 == 1752589105 || v79 == 1718908520) {
        int v80 = "HEVC";
      }
      else {
        int v80 = "H.264";
      }
      *(_DWORD *)buf = 136315138;
      *(void *)__int16 v199 = v80;
      CFNumberRef v124 = MEMORY[0x1E4F14500];
      CFNumberRef v125 = "%s: ParseCompressParams failed\n";
      goto LABEL_369;
    }
LABEL_187:
    CMTimeFlags v21 = v71;
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_329;
    }
    int v89 = *(_DWORD *)(DerivedStorage + 48);
    if (v89 == 1684632424 || v89 == 1752589105 || v89 == 1718908520) {
      int v90 = "HEVC";
    }
    else {
      int v90 = "H.264";
    }
    LODWORD(time.CFDictionaryAddValue(theDict, key, value) = 136315394;
    *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)v90;
    LOWORD(time.flags) = 1024;
    *(CMTimeFlags *)((char *)&time.flags + 2) = v71;
    unint64_t v93 = MEMORY[0x1E4F14500];
    int v94 = "%s: failed to init video encoder, err = %d\n";
    goto LABEL_203;
  }
  sub_1BBA5E54C(*(void *)(DerivedStorage + 16), *(CFStringRef *)(DerivedStorage + 1480));
  int v81 = *(_DWORD *)(DerivedStorage + 1448);
  if (v81 != -1) {
    sub_1BBA5ED34(*(void *)(DerivedStorage + 16), 0xDA7CA283D396F91BLL, v81 != 0);
  }
  int v82 = *(_DWORD *)(DerivedStorage + 1424);
  if (v82 == 8)
  {
    char v83 = "low";
  }
  else
  {
    if (v82) {
      goto LABEL_168;
    }
    char v83 = "medium";
  }
  uint64_t v84 = *(void *)(DerivedStorage + 16);
  buf[0] = 0;
  sub_1BBA40F94(*(void *)(v84 + 3192), 0xF5B6EA8C35AC1E89, v83, 0, (uint64_t)buf);
LABEL_168:
  if ((int)PixelFormatType > 1278226735)
  {
    if (PixelFormatType != 1278226736 && PixelFormatType != 2019963440)
    {
      int v85 = 1751411059;
LABEL_175:
      if (PixelFormatType != v85) {
        goto LABEL_206;
      }
    }
  }
  else if (PixelFormatType != 875704422 && PixelFormatType != 875836518)
  {
    int v85 = 1278226488;
    goto LABEL_175;
  }
  uint64_t v86 = *(void *)(DerivedStorage + 16);
  buf[0] = 0;
  sub_1BBA40F94(*(void *)(v86 + 3192), 0x3BEB44829B7A4FABLL, "true", 0, (uint64_t)buf);
  if (dword_1E9F80A90 >= 3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v87 = *(_DWORD *)(DerivedStorage + 48);
    if (v87 == 1684632424 || v87 == 1752589105 || v87 == 1718908520) {
      int v88 = "HEVC";
    }
    else {
      int v88 = "H.264";
    }
    *(_DWORD *)buf = 136316162;
    *(void *)__int16 v199 = v88;
    *(_WORD *)&v199[8] = 1024;
    *(_DWORD *)&v199[10] = HIBYTE(PixelFormatType);
    *(_WORD *)&v199[14] = 1024;
    *(_DWORD *)&v199[16] = BYTE2(PixelFormatType);
    *(_WORD *)&v199[20] = 1024;
    *(_DWORD *)&v199[22] = BYTE1(PixelFormatType);
    *(_WORD *)&v199[26] = 1024;
    *(_DWORD *)&v199[28] = PixelFormatType;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%s: get full range pixel buffer %c%c%c%c and set vui-full-range to true\n", buf, 0x24u);
  }
LABEL_206:
  uint64_t v95 = *(void *)(DerivedStorage + 16);
  buf[0] = 0;
  sub_1BBA40F94(*(void *)(v95 + 3192), 0xEADA4767E797268BLL, __str, 0, (uint64_t)buf);
  uint64_t v96 = *(void *)(DerivedStorage + 16);
  buf[0] = 0;
  sub_1BBA40F94(*(void *)(v96 + 3192), 0x9FFE593DC10E7CC4, v217, 0, (uint64_t)buf);
  uint64_t v97 = *(void *)(DerivedStorage + 16);
  buf[0] = 0;
  sub_1BBA40F94(*(void *)(v97 + 3192), 0x2660BA38B42FDFB5, v216, 0, (uint64_t)buf);
  uint64_t v98 = *(void *)(DerivedStorage + 16);
  buf[0] = 0;
  sub_1BBA40F94(*(void *)(v98 + 3192), 0xE961BACE8A163BCBLL, v215, 0, (uint64_t)buf);
  uint64_t v99 = *(void *)(DerivedStorage + 16);
  buf[0] = 0;
  sub_1BBA40F94(*(void *)(v99 + 3192), 0x4179B3C137C3CEB0, v214, 0, (uint64_t)buf);
  int v100 = *(_DWORD *)(DerivedStorage + 48);
  if (v100 != 1684632424 && v100 != 1718908520 && v100 != 1752589105) {
    sub_1BBA5EDC0(*(void *)(DerivedStorage + 16), 0xF890AF2C24C4A032, *(_DWORD *)(DerivedStorage + 328));
  }
  uint64_t v101 = *(void *)(DerivedStorage + 1440);
  if (v101)
  {
    CFRetain(*(CFTypeRef *)(DerivedStorage + 1440));
    *(void *)(*(void *)(DerivedStorage + 16) + 1112) = v101;
  }
  if (PixelFormatType == 1982882104)
  {
    uint64_t v102 = *(void *)(DerivedStorage + 16);
    *(unsigned char *)(v102 + 1016) = 1;
    sub_1BBA5ED34(v102, 0x8ADD349E618BA10ELL, 1);
    int v103 = CFEqual(*(CFTypeRef *)(DerivedStorage + 1472), (CFTypeRef)*MEMORY[0x1E4F447A8]);
    uint64_t v104 = *(void *)(DerivedStorage + 16);
    BOOL v105 = v103 ? "straight" : "premultiplied";
    buf[0] = 0;
    sub_1BBA40F94(*(void *)(v104 + 3192), 0xDA3A876E9663D9D3, v105, 0, (uint64_t)buf);
    BOOL v106 = v103 != 0;
    uint64_t v107 = *(void *)(DerivedStorage + 16);
    *(_DWORD *)(v107 + 1020) = v106;
    if (dword_1E9F80A90 >= 3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      if (*(_DWORD *)(v107 + 11004)) {
        int v108 = "Straight";
      }
      else {
        int v108 = "Premultiplied";
      }
      *(_DWORD *)buf = 136315138;
      *(void *)__int16 v199 = v108;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "InitEncoder: Alpha encoding for input format v0a8 and forced main profile, alpha channel mode = %s\n", buf, 0xCu);
    }
  }
  if (*(unsigned char *)(DerivedStorage + 1540))
  {
    if (PixelFormatType != 1751411059)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v126 = *(_DWORD *)(DerivedStorage + 48);
        if (v126 == 1684632424 || v126 == 1752589105 || v126 == 1718908520) {
          uint64_t v127 = "HEVC";
        }
        else {
          uint64_t v127 = "H.264";
        }
        *(_DWORD *)buf = 136316162;
        *(void *)__int16 v199 = v127;
        *(_WORD *)&v199[8] = 1024;
        *(_DWORD *)&v199[10] = HIBYTE(PixelFormatType);
        *(_WORD *)&v199[14] = 1024;
        *(_DWORD *)&v199[16] = BYTE2(PixelFormatType);
        *(_WORD *)&v199[20] = 1024;
        *(_DWORD *)&v199[22] = BYTE1(PixelFormatType);
        *(_WORD *)&v199[26] = 1024;
        *(_DWORD *)&v199[28] = PixelFormatType;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: Disparity encoder expected input format 'hdis' but got '%c%c%c%c'\n", buf, 0x24u);
      }
      __int16 v71 = -12902;
      goto LABEL_187;
    }
    sub_1BBA5ED34(*(void *)(DerivedStorage + 16), 0xC86457BBA942E4AALL, 1);
    sub_1BBA5ED34(*(void *)(DerivedStorage + 16), 0x9D4699E02AD040AELL, 0);
    float v109 = *(float *)(DerivedStorage + 1544);
    if (v109 >= 0.0 && *(float *)(DerivedStorage + 1548) >= 0.0)
    {
      sub_1BBA5EE4C(*(void *)(DerivedStorage + 16), 0xDE0ED602D6B626A9, v109);
      sub_1BBA5EE4C(*(void *)(DerivedStorage + 16), 0xDDF3C802D69F4727, *(float *)(DerivedStorage + 1548));
    }
  }
  uint64_t v110 = *(void *)(DerivedStorage + 1552);
  uint64_t v111 = *(void *)(DerivedStorage + 16);
  *(void *)(v111 + 1176) = v110;
  unint64_t v112 = (char *)(v111 + 1184);
  int v113 = *(_DWORD *)(DerivedStorage + 48);
  if (v113 == 1684632424 || v113 == 1752589105 || v113 == 1718908520) {
    uint32_t v114 = "HEVC";
  }
  else {
    uint32_t v114 = "H.264";
  }
  if (*(_DWORD *)(v111 + 1004) == 8) {
    uint64_t v115 = "SDR";
  }
  else {
    uint64_t v115 = "HDR";
  }
  snprintf(v112, 0x7D0uLL, "CallerID 0x%llx (%dx%d, %s, %s)", v110, *(_DWORD *)(DerivedStorage + 340), *(_DWORD *)(DerivedStorage + 344), v114, v115);
  __int16 v71 = sub_1BBA5EED8(*(void **)(DerivedStorage + 16));
  if (v71)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_187;
    }
    int v116 = *(_DWORD *)(DerivedStorage + 48);
    if (v116 == 1684632424 || v116 == 1752589105 || v116 == 1718908520) {
      CFNumberRef v117 = "HEVC";
    }
    else {
      CFNumberRef v117 = "H.264";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)__int16 v199 = v117;
    CFNumberRef v124 = MEMORY[0x1E4F14500];
    CFNumberRef v125 = "%s: Encoder initialization failed\n";
LABEL_369:
    _os_log_error_impl(&dword_1BB9B9000, v124, OS_LOG_TYPE_ERROR, v125, buf, 0xCu);
    goto LABEL_187;
  }
  uint64_t v118 = *(void *)(DerivedStorage + 16);
  *(void *)(v118 + 13288) = sub_1BB9F7D10;
  *(void *)(v118 + 13296) = DerivedStorage;
  if (!*(unsigned char *)(DerivedStorage + 1384))
  {
    int v121 = sub_1BB9F35A0(DerivedStorage);
    __int16 v71 = v121;
    if (v121)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        goto LABEL_187;
      }
      int v122 = *(_DWORD *)(DerivedStorage + 48);
      if (v122 == 1684632424 || v122 == 1752589105 || v122 == 1718908520) {
        CFAllocatorRef v123 = "HEVC";
      }
      else {
        CFAllocatorRef v123 = "H.264";
      }
      *(_DWORD *)buf = 136315138;
      *(void *)__int16 v199 = v123;
      CFNumberRef v124 = MEMORY[0x1E4F14500];
      CFNumberRef v125 = "%s: CreateAndSetHeaders failed\n";
      goto LABEL_369;
    }
  }
  if (dword_1E9F80A90 >= 3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v119 = *(_DWORD *)(DerivedStorage + 48);
    if (v119 == 1684632424 || v119 == 1752589105 || v119 == 1718908520) {
      unsigned int v120 = "HEVC";
    }
    else {
      unsigned int v120 = "H.264";
    }
    unsigned int v128 = "sw";
    int v129 = *(_DWORD *)(DerivedStorage + 340);
    int v130 = *(_DWORD *)(DerivedStorage + 344);
    if (*(_DWORD *)&v220[8] == 2) {
      unsigned int v128 = "hw";
    }
    int v131 = *(_DWORD *)(*(void *)(DerivedStorage + 16) + 1004);
    int v132 = *(_DWORD *)(DerivedStorage + 240);
    int v133 = *(_DWORD *)(DerivedStorage + 1488);
    *(_DWORD *)buf = 136317698;
    *(void *)__int16 v199 = v120;
    *(_WORD *)&v199[8] = 2080;
    *(void *)&v199[10] = v128;
    *(_WORD *)&v199[18] = 1024;
    *(_DWORD *)&v199[20] = v129;
    *(_WORD *)&v199[24] = 1024;
    *(_DWORD *)&v199[26] = v130;
    *(_WORD *)&v199[30] = 1024;
    *(_DWORD *)int v200 = HIBYTE(PixelFormatType);
    *(_WORD *)&v200[4] = 1024;
    int v201 = BYTE2(PixelFormatType);
    __int16 v202 = 1024;
    int v203 = BYTE1(PixelFormatType);
    __int16 v204 = 1024;
    int v205 = PixelFormatType;
    __int16 v206 = 1024;
    int v207 = v131;
    __int16 v208 = 1024;
    int v209 = v132;
    __int16 v210 = 1024;
    int v211 = v133;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%s: Init %s video encoder: dimension = %d x %d, pixfmt = %c%c%c%c, bit_depth = %d, usage = %d, number_slices = %d\n", buf, 0x4Cu);
  }
  unsigned int v134 = *(_DWORD *)(DerivedStorage + 240);
  if (v134 <= 0x2A && ((1 << v134) & 0x44000100000) != 0)
  {
    uint64_t v135 = 0;
    int v136 = 0x7FFFFFFF;
    do
    {
      double v137 = *(double *)(DerivedStorage + v135 + 96);
      if (v137 != 0.0)
      {
        double v138 = *(double *)(DerivedStorage + v135 + 160);
        if (v138 != 0.0 && v136 >= (int)(v137 * 8.0 / v138)) {
          int v136 = (int)(v137 * 8.0 / v138);
        }
      }
      v135 += 8;
    }
    while (v135 != 64);
    if (v136 != 0x7FFFFFFF)
    {
      if (v134 == 38)
      {
        int v139 = *(_DWORD *)(DerivedStorage + 48);
        double v140 = *(double *)(DerivedStorage + 24);
        unsigned int v180 = *(_DWORD *)(DerivedStorage + 340);
        unsigned int v181 = *(_DWORD *)(DerivedStorage + 344);
        int v183 = sub_1BBA564B0(v139, v136, *(_DWORD *)(DerivedStorage + 232), v180, v181, v140);
        *(_DWORD *)(DerivedStorage + 52) = v183;
        if (!*(unsigned char *)(DerivedStorage + 224)
          || (v183 != v136 ? (BOOL v141 = dword_1E9F80A90 < 3) : (BOOL v141 = 1),
              v141 || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)))
        {
          *(unsigned char *)(DerivedStorage + 224) = 0;
          goto LABEL_299;
        }
        if (v139 == 1684632424 || v139 == 1752589105 || v139 == 1718908520) {
          long long v142 = "HEVC";
        }
        else {
          long long v142 = "H.264";
        }
        *(_DWORD *)buf = 136316418;
        *(void *)__int16 v199 = v142;
        *(_WORD *)&v199[8] = 1024;
        *(_DWORD *)&v199[10] = v180;
        *(_WORD *)&v199[14] = 1024;
        *(_DWORD *)&v199[16] = v181;
        *(_WORD *)&v199[20] = 1024;
        *(_DWORD *)&v199[22] = (int)v140;
        *(_WORD *)&v199[26] = 1024;
        *(_DWORD *)&v199[28] = v136;
        *(_WORD *)int v200 = 1024;
        *(_DWORD *)&v200[2] = v183;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Carplay %s: dimension = %d x %d, framerate = %d, bitrate setting was clipped from %d to %d\n", buf, 0x2Au);
        unsigned int v134 = *(_DWORD *)(DerivedStorage + 240);
      }
      else
      {
        *(_DWORD *)(DerivedStorage + 52) = v136;
      }
    }
  }
  *(unsigned char *)(DerivedStorage + 224) = 0;
  if (v134 == 20 && *(_DWORD *)(*(void *)(DerivedStorage + 16) + 1004) == 8)
  {
    if (qword_1EC027190 != -1) {
      dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
    }
    if (dword_1EC02719C >= 7
      && *(unsigned char *)(*(void *)(DerivedStorage + 16) + 3308) == 1
      && *(_DWORD *)(DerivedStorage + 56) == 1)
    {
      long long v143 = (id *)(DerivedStorage + 1416);
      if (!sub_1BBA12890((void *)(DerivedStorage + 1416)))
      {
        long long v144 = dispatch_semaphore_create(0);
        *(void *)(DerivedStorage + 1408) = v144;
        dispatch_semaphore_signal(v144);
        if (!*(void *)(DerivedStorage + 1408))
        {
          if (*v143)
          {
            [*v143 invalidate];
            CFRelease(*v143);
          }
        }
      }
    }
  }
LABEL_299:
  uint64_t v145 = *(void *)(*(void *)(DerivedStorage + 16) + 1168);
  long long v146 = v184;
  if (v145) {
    sub_1BBAC8868(v145, (uint64_t *)"input_frames", 1.0);
  }
  unsigned int v147 = *(_DWORD *)(DerivedStorage + 240);
  if (v147 <= 0x2A && ((1 << v147) & 0x44000100000) != 0)
  {
    uint64_t v148 = 0;
    int v149 = 0x7FFFFFFF;
    do
    {
      double v150 = *(double *)(DerivedStorage + v148 + 96);
      if (v150 != 0.0)
      {
        double v151 = *(double *)(DerivedStorage + v148 + 160);
        if (v151 != 0.0 && v149 >= (int)(v150 * 8.0 / v151)) {
          int v149 = (int)(v150 * 8.0 / v151);
        }
      }
      v148 += 8;
    }
    while (v148 != 64);
    if (v149 != 0x7FFFFFFF)
    {
      if (v147 == 38)
      {
        int v152 = *(_DWORD *)(DerivedStorage + 48);
        unsigned int v153 = *(_DWORD *)(DerivedStorage + 340);
        unsigned int v154 = *(_DWORD *)(DerivedStorage + 344);
        double v155 = *(double *)(DerivedStorage + 24);
        int v156 = sub_1BBA564B0(v152, v149, *(_DWORD *)(DerivedStorage + 232), v153, v154, v155);
        *(_DWORD *)(DerivedStorage + 52) = v156;
        if (*(unsigned char *)(DerivedStorage + 224)
          && ((int v157 = v156, v156 != v149) ? (v158 = dword_1E9F80A90 < 3) : (v158 = 1),
              !v158 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)))
        {
          if (v152 == 1684632424 || v152 == 1752589105 || v152 == 1718908520) {
            char v159 = "HEVC";
          }
          else {
            char v159 = "H.264";
          }
          LODWORD(time.CFDictionaryAddValue(theDict, key, value) = 136316418;
          *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)v159;
          LOWORD(time.flags) = 1024;
          *(CMTimeFlags *)((char *)&time.flags + 2) = v153;
          WORD1(time.epoch) = 1024;
          HIDWORD(time.epoch) = v154;
          LOWORD(v219) = 1024;
          *(_DWORD *)((char *)&v219 + 2) = (int)v155;
          HIWORD(v219) = 1024;
          *(_DWORD *)uint32_t v220 = v149;
          *(_WORD *)&v220[4] = 1024;
          *(_DWORD *)&v220[6] = v157;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Carplay %s: dimension = %d x %d, framerate = %d, bitrate setting was clipped from %d to %d\n", (uint8_t *)&time, 0x2Au);
          unsigned int v147 = *(_DWORD *)(DerivedStorage + 240);
        }
        else
        {
          unsigned int v147 = 38;
        }
      }
      else
      {
        *(_DWORD *)(DerivedStorage + 52) = v149;
      }
    }
    long long v146 = v184;
  }
  *(unsigned char *)(DerivedStorage + 224) = 0;
  uint64_t v160 = *(void *)(DerivedStorage + 16);
  *(void *)(v160 + 944) = a6;
  int v161 = *(_DWORD *)(DerivedStorage + 1372);
  *(_DWORD *)(v160 + 120) = v147;
  *(_DWORD *)(v160 + 832) = v161;
  *(void *)(v160 + 128) = *(void *)(DerivedStorage + 24);
  double v162 = *(double *)(DerivedStorage + 32);
  *(double *)(v160 + 136) = v162;
  double v163 = *(double *)(DerivedStorage + 40);
  *(double *)(v160 + 144) = v163;
  *(void *)(v160 + 984) = *(void *)(DerivedStorage + 1460);
  *(unsigned char *)(v160 + 992) &= *(unsigned char *)(DerivedStorage + 1452);
  *(unsigned char *)(v160 + 993) = *(unsigned char *)(DerivedStorage + 1453);
  *(unsigned char *)(v160 + 124) = *(unsigned char *)(DerivedStorage + 1455);
  if (v162 < 0.0) {
    goto LABEL_325;
  }
  if (v162 != 0.5 && v162 != 1.0)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(time.CFDictionaryAddValue(theDict, key, value) = 0;
      int v167 = MEMORY[0x1E4F14500];
      BOOL v168 = "Baselayer framerate fraction should be either 0.5 or 1";
LABEL_362:
      _os_log_error_impl(&dword_1BB9B9000, v167, OS_LOG_TYPE_ERROR, v168, (uint8_t *)&time, 2u);
      goto LABEL_363;
    }
    goto LABEL_363;
  }
  if (v162 != 1.0 && (v163 <= 0.0 || v163 >= 1.0))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(time.CFDictionaryAddValue(theDict, key, value) = 0;
      int v167 = MEMORY[0x1E4F14500];
      BOOL v168 = "Baselayer bitrate fraction should be between 0 (exclusive) and 1 (exclusive)";
      goto LABEL_362;
    }
LABEL_363:
    CMTimeFlags v21 = -12910;
    goto LABEL_329;
  }
LABEL_325:
  int v164 = *(_DWORD *)(DerivedStorage + 56);
  int v165 = *(_DWORD *)(DerivedStorage + 60);
  if (v165 > v164)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LODWORD(time.CFDictionaryAddValue(theDict, key, value) = 67109376;
      HIDWORD(time.CFDictionaryAddValue(theDict, key, value) = v165;
      LOWORD(time.timescale) = 1024;
      *(CMTimeScale *)((char *)&time.timescale + 2) = v164;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "min sublayer number (%d) cannot exceed max sublayer number (%d)\n", (uint8_t *)&time, 0xEu);
    }
LABEL_328:
    CMTimeFlags v21 = -12902;
    goto LABEL_329;
  }
  *(_DWORD *)(v160 + 256) = *(_DWORD *)(DerivedStorage + 1400);
  *(_DWORD *)(v160 + 476) = *(_DWORD *)(DerivedStorage + 1428);
  *(unsigned char *)(v160 + 952) = *(unsigned char *)(DerivedStorage + 1385) != 0;
  int v169 = *(_DWORD *)(DerivedStorage + 52);
  if (v169 >= 1) {
    *(_DWORD *)(v160 + 152) = v169;
  }
  if (v164 >= 1)
  {
    uint64_t v170 = 0;
    do
    {
      int v171 = *(_DWORD *)(DerivedStorage + 64 + 4 * v170);
      if (v171 <= 0) {
        int v171 = *(_DWORD *)(v160 + 152);
      }
      *(_DWORD *)(v160 + 156 + 4 * v170++) = v171;
    }
    while (v170 < *(int *)(DerivedStorage + 56));
  }
  int v172 = *(_DWORD *)(DerivedStorage + 92);
  if (v172 > 0) {
    *(_DWORD *)(v160 + 184) = v172;
  }
  long long v194 = *(_OWORD *)&a4->value;
  CMTimeEpoch epoch = a4->epoch;
  long long v192 = *v146;
  uint64_t v193 = *((void *)v146 + 2);
  sub_1BB9FB768((_DWORD *)(v160 + 120), (uint64_t *)&v194, (uint64_t *)&v192, *(_DWORD *)(DerivedStorage + 348), *(_DWORD *)(DerivedStorage + 352), *(_DWORD *)(DerivedStorage + 256), *(_DWORD *)(DerivedStorage + 1380), *(double *)(DerivedStorage + 264), *(double *)(DerivedStorage + 272));
  sub_1BB9FC53C(*(void *)(DerivedStorage + 16) + 120, a3);
  uint64_t v173 = *(void *)(*(void *)(DerivedStorage + 16) + 12728);
  if (v173)
  {
    CMTimeFlags v21 = (*(uint64_t (**)(uint64_t, uint64_t *, __CVBuffer *))(*(void *)v173 + 16))(v173, &v196, a3);
    if (!v21)
    {
      uint64_t v174 = v196;
      *(_DWORD *)(v196 + 8) = *(_DWORD *)(DerivedStorage + 348);
      uint64_t v175 = *(void *)(DerivedStorage + 16);
      *(_OWORD *)(v174 + 16) = *(_OWORD *)(v175 + 904);
      *(_DWORD *)(v174 + 32) = *(_DWORD *)(v175 + 920);
      *(_OWORD *)(v174 + 256) = *(_OWORD *)(v175 + 960);
      *((void *)v187 + 1) = v185;
      long long v176 = *(_OWORD *)&a4->value;
      *((_OWORD *)v187 + 1) = *(_OWORD *)&a4->value;
      CMTimeEpoch v177 = a4->epoch;
      *((void *)v187 + 4) = v177;
      *(_OWORD *)(v187 + 40) = *v184;
      *((void *)v187 + 7) = *((void *)v184 + 2);
      *(_DWORD *)uint32_t v187 = *v186;
      CMTimeEpoch v191 = v177;
      long long v190 = v176;
      VTEncoderSessionEnqueuePresentationTimeStamp();
      uint64_t v178 = *(void *)(DerivedStorage + 16);
      unsigned int v179 = v197;
      v189[0] = v196;
      v189[1] = v197;
      if (v197) {
        atomic_fetch_add_explicit(&v197->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v18 = sub_1BBA623E0(v178, (uint64_t)v189, (uint64_t)v187);
      if (v179) {
        sub_1BB9C09B4(v179);
      }
      *uint64_t v188 = vadd_s32(*v188, (int32x2_t)0x100000001);
      goto LABEL_334;
    }
  }
  else
  {
    CMTimeFlags v21 = -12911;
  }
LABEL_329:
  *uint64_t v188 = vadd_s32(*v188, (int32x2_t)0x100000001);
  if (v21) {
    uint64_t v18 = v21;
  }
  else {
    uint64_t v18 = 4294954385;
  }
  VTEncoderSessionEmitEncodedFrame();
  if (v187) {
    MEMORY[0x1C18605E0](v187, 0x1020C40C238D3BALL);
  }
LABEL_334:
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 1392));
  if (v197) {
    sub_1BB9C09B4(v197);
  }
  return v18;
}

void sub_1BB9F34E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (v36) {
    sub_1BB9C09B4(v36);
  }
  if (a36) {
    sub_1BB9C09B4(a36);
  }
  _Unwind_Resume(exception_object);
}

intptr_t sub_1BB9F3534(uint64_t a1, int a2, CFDictionaryRef theDict)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    *(_DWORD *)(v4 + 1400) = 0;
  }
  else
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F74510]);
    CFNumberGetValue(Value, kCFNumberSInt32Type, (void *)(*(void *)(a1 + 32) + 1400));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  CFAllocatorRef v6 = *(NSObject **)(v4 + 1408);

  return dispatch_semaphore_signal(v6);
}

uint64_t sub_1BB9F35A0(uint64_t a1)
{
  *(void *)&v767[497] = *MEMORY[0x1E4F143B8];
  size_t v751 = 0;
  size_t v752 = 0;
  size_t v750 = 0;
  int64x2_t v2 = (const void *)(a1 + 368);
  size_t v3 = strnlen((const char *)(a1 + 368), 0x3E9uLL);
  v761[0] = v767;
  v761[1] = v765;
  v761[3] = 0;
  v761[4] = 0;
  v761[2] = (unsigned __int8 *)&v763;
  v760[0] = &v752;
  v760[1] = &v751;
  v760[3] = 0;
  v760[4] = 0;
  v760[2] = &v750;
  if (*(unsigned char *)(a1 + 1384))
  {
LABEL_2:
    FigSignalErrorAt();
    uint64_t v4 = 0;
    __int16 VideoFormatDescription = 0;
LABEL_3:
    free(v4);
    return VideoFormatDescription;
  }
  size_t v7 = v3;
  uint64_t v8 = *(void *)(a1 + 16);
  v753 = 0;
  uint64_t v754 = 0;
  v757 = 0;
  unint64_t v758 = 0;
  v756 = 0;
  if (sub_1BBA195B4(&v753, 1024))
  {
    size_t v9 = 0;
  }
  else
  {
    uint64_t v10 = *(void *)(v8 + 12672);
    _DWORD *v756 = bswap32(v758);
    unint64_t v11 = SHIDWORD(v758) + 1;
    int v12 = v758 << (v11 & 0xF8);
    int64x2_t v13 = (_DWORD *)((char *)v756 + (v11 >> 3));
    v756 = v13;
    int v14 = v11 & 7;
    HIDWORD(v758) = v14;
    if (v13 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int64x2_t v13 = v757;
    }
    LODWORD(v758) = (32 << (26 - v14)) | v12;
    *int64x2_t v13 = bswap32(v758);
    unint64_t v15 = SHIDWORD(v758) + 6;
    unsigned int v16 = v758 << (v15 & 0xF8);
    uint64_t v17 = (_DWORD *)((char *)v756 + (v15 >> 3));
    v756 = v17;
    LODWORD(v758) = v16;
    HIDWORD(v758) = v15 & 7;
    if (v17 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      uint64_t v17 = v757;
    }
    _DWORD *v17 = bswap32(v16);
    unint64_t v18 = SHIDWORD(v758) + 6;
    uint64_t v19 = (_DWORD *)((char *)v756 + (v18 >> 3));
    v756 = v19;
    HIDWORD(v758) = v18 & 7;
    if (v19 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      uint64_t v19 = v757;
    }
    LODWORD(v758) = (1 << (29 - (v18 & 7))) | (v758 << (v18 & 0xF8));
    *uint64_t v19 = bswap32(v758);
    unint64_t v20 = SHIDWORD(v758) + 3;
    int v21 = v758 << (v20 & 0xF8);
    int v22 = (_DWORD *)((char *)v756 + (v20 >> 3));
    v756 = v22;
    int v23 = v20 & 7;
    HIDWORD(v758) = v23;
    if (v22 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int v22 = v757;
    }
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 168) << (28 - v23)) | v21;
    *int v22 = bswap32(v758);
    unint64_t v24 = SHIDWORD(v758) + 4;
    int v25 = v758 << (v24 & 0xF8);
    CFTypeRef v26 = (_DWORD *)((char *)v756 + (v24 >> 3));
    v756 = v26;
    int v27 = v24 & 7;
    HIDWORD(v758) = v27;
    if (v26 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      CFTypeRef v26 = v757;
    }
    LODWORD(v758) = (3 << (30 - v27)) | v25;
    *CFTypeRef v26 = bswap32(v758);
    unint64_t v28 = SHIDWORD(v758) + 2;
    unsigned int v29 = v758 << (v28 & 0xF8);
    int v30 = (_DWORD *)((char *)v756 + (v28 >> 3));
    v756 = v30;
    LODWORD(v758) = v29;
    HIDWORD(v758) = v28 & 7;
    if (v30 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int v30 = v757;
    }
    *int v30 = bswap32(v29);
    unint64_t v31 = SHIDWORD(v758) + 6;
    int v32 = v758 << (v31 & 0xF8);
    int v33 = (_DWORD *)((char *)v756 + (v31 >> 3));
    v756 = v33;
    int v34 = v31 & 7;
    HIDWORD(v758) = v34;
    if (v33 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int v33 = v757;
    }
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 169) << (29 - v34)) | v32;
    _DWORD *v33 = bswap32(v758);
    unint64_t v35 = SHIDWORD(v758) + 3;
    int v36 = v758 << (v35 & 0xF8);
    int v37 = (_DWORD *)((char *)v756 + (v35 >> 3));
    v756 = v37;
    int v38 = v35 & 7;
    HIDWORD(v758) = v38;
    if (v37 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int v37 = v757;
    }
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 170) << (v38 ^ 0x1F)) | v36;
    *int v37 = bswap32(v758);
    unint64_t v39 = SHIDWORD(v758) + 1;
    int v40 = v758 << (v39 & 0xF8);
    unsigned int v41 = (_DWORD *)((char *)v756 + (v39 >> 3));
    v756 = v41;
    int v42 = v39 & 7;
    HIDWORD(v758) = v42;
    if (v41 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      unsigned int v41 = v757;
    }
    LODWORD(v758) = (0xFFFF << (16 - v42)) | v40;
    *unsigned int v41 = bswap32(v758);
    unint64_t v43 = SHIDWORD(v758) + 16;
    v756 = (_DWORD *)((char *)v756 + (v43 >> 3));
    unint64_t v758 = __PAIR64__(HIDWORD(v758), v758 << (v43 & 0xF8)) & 0x7FFFFFFFFLL;
    if (v756 >= v757)
    {
      char v759 = 1;
      v756 = v757;
    }
    sub_1BBA55CE0((unsigned __int8 *)v10, *(unsigned __int8 *)(v10 + 169), (uint64_t)&v753);
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 171) << ~BYTE4(v758)) | v758;
    _DWORD *v756 = bswap32(v758);
    unint64_t v44 = SHIDWORD(v758) + 1;
    unsigned int v45 = v758 << (v44 & 0xF8);
    int v46 = (_DWORD *)((char *)v756 + (v44 >> 3));
    v756 = v46;
    LOBYTE(v47) = v44 & 7;
    LODWORD(v758) = v45;
    HIDWORD(v758) = v44 & 7;
    if (v46 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int v46 = v757;
    }
    if (*(unsigned char *)(v10 + 171)) {
      unsigned __int8 v48 = 0;
    }
    else {
      unsigned __int8 v48 = *(unsigned char *)(v10 + 169);
    }
    unint64_t v49 = v48;
    do
    {
      unsigned int v50 = *(unsigned __int8 *)(v10 + v49 + 172) + 1;
      unsigned int v51 = __clz(v50);
      unsigned int v52 = 0x80000000 >> v51;
      uint64_t v53 = (2 * v51) ^ 0x3F;
      LODWORD(v758) = (((v50 - v52) | v52) << (-(char)v47 - v53)) | v45;
      *int v46 = bswap32(v758);
      unint64_t v54 = SHIDWORD(v758) + v53;
      unsigned int v55 = v758 << (v54 & 0xF8);
      size_t v56 = (_DWORD *)((char *)v756 + (v54 >> 3));
      v756 = v56;
      unsigned int v57 = v54 & 7;
      unint64_t v758 = __PAIR64__(v57, v55);
      if (v56 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        size_t v56 = v757;
      }
      unsigned int v58 = *(unsigned __int8 *)(v10 + v49 + 179) + 1;
      unsigned int v59 = __clz(v58);
      unsigned int v60 = (v58 - (0x80000000 >> v59)) | (0x80000000 >> v59);
      uint64_t v61 = (2 * v59) ^ 0x3F;
      LODWORD(v758) = (v60 << (-(char)v61 - v57)) | v55;
      _DWORD *v56 = bswap32(v758);
      unint64_t v62 = SHIDWORD(v758) + v61;
      unsigned int v63 = v758 << (v62 & 0xF8);
      int v64 = (_DWORD *)((char *)v756 + (v62 >> 3));
      v756 = v64;
      unsigned int v65 = v62 & 7;
      unint64_t v758 = __PAIR64__(v65, v63);
      if (v64 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        int v64 = v757;
      }
      unsigned int v66 = *(_DWORD *)(v10 + 4 * v49 + 188) + 1;
      unsigned int v67 = __clz(v66);
      unsigned int v68 = (v66 - (0x80000000 >> v67)) | (0x80000000 >> v67);
      uint64_t v69 = 63 - 2 * v67;
      LODWORD(v758) = (v68 << (-(char)v69 - v65)) | v63;
      *int v64 = bswap32(v758);
      unint64_t v70 = SHIDWORD(v758) + v69;
      unsigned int v45 = v758 << (v70 & 0xF8);
      int v46 = (_DWORD *)((char *)v756 + (v70 >> 3));
      v756 = v46;
      unsigned int v47 = v70 & 7;
      unint64_t v758 = __PAIR64__(v47, v45);
      if (v46 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        int v46 = v757;
      }
      BOOL v71 = v49++ >= *(unsigned __int8 *)(v10 + 169);
    }
    while (!v71);
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 216) << (26 - v47)) | v45;
    *int v46 = bswap32(v758);
    unint64_t v72 = SHIDWORD(v758) + 6;
    int v73 = v758 << (v72 & 0xF8);
    int v74 = (_DWORD *)((char *)v756 + (v72 >> 3));
    v756 = v74;
    int v75 = v72 & 7;
    HIDWORD(v758) = v75;
    if (v74 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int v74 = v757;
    }
    unsigned int v76 = *(unsigned __int16 *)(v10 + 218) + 1;
    unsigned int v77 = __clz(v76);
    unsigned int v78 = 0x80000000 >> v77;
    uint64_t v79 = (2 * v77) ^ 0x3F;
    LODWORD(v758) = (((v76 - v78) | v78) << (-(char)v75 - v79)) | v73;
    *int v74 = bswap32(v758);
    unint64_t v80 = SHIDWORD(v758) + v79;
    unsigned int v81 = v758 << (v80 & 0xF8);
    int v82 = (_DWORD *)((char *)v756 + (v80 >> 3));
    v756 = v82;
    unsigned int v83 = v80 & 7;
    HIDWORD(v758) = v83;
    if (v82 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int v82 = v757;
    }
    if (*(_WORD *)(v10 + 218))
    {
      unint64_t v84 = 1;
      do
      {
        unint64_t v85 = -1;
        do
        {
          LODWORD(v758) = (((*(void *)(*(void *)(v10 + 224) + 8 * v84) >> ++v85) & 1) << ~(_BYTE)v83) | v81;
          *int v82 = bswap32(v758);
          unint64_t v86 = SHIDWORD(v758) + 1;
          unsigned int v81 = v758 << (v86 & 0xF8);
          int v82 = (_DWORD *)((char *)v756 + (v86 >> 3));
          v756 = v82;
          unsigned int v83 = v86 & 7;
          unint64_t v758 = __PAIR64__(v83, v81);
          if (v82 >= v757)
          {
            char v759 = 1;
            v756 = v757;
            int v82 = v757;
          }
        }
        while (v85 < *(unsigned __int8 *)(v10 + 216));
        BOOL v71 = v84++ >= *(unsigned __int16 *)(v10 + 218);
      }
      while (!v71);
    }
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 240) << (v83 ^ 0x1F)) | v81;
    *int v82 = bswap32(v758);
    unint64_t v87 = SHIDWORD(v758) + 1;
    char v88 = v87 & 0xF8;
    int v89 = (_DWORD *)((char *)v756 + (v87 >> 3));
    v756 = v89;
    int v90 = v87 & 7;
    HIDWORD(v758) = v90;
    if (v89 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int v89 = v757;
    }
    int v91 = v758 << v88;
    if (*(unsigned char *)(v10 + 240))
    {
      unsigned int v92 = *(_DWORD *)(v10 + 244);
      LODWORD(v758) = (HIWORD(v92) << (16 - v90)) | v91;
      *int v89 = bswap32(v758);
      unint64_t v93 = SHIDWORD(v758) + 16;
      int v94 = v758 << (v93 & 0xF8);
      uint64_t v95 = (_DWORD *)((char *)v756 + (v93 >> 3));
      v756 = v95;
      char v96 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v95 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        uint64_t v95 = v757;
      }
      LODWORD(v758) = ((unsigned __int16)v92 << (16 - v96)) | v94;
      *uint64_t v95 = bswap32(v758);
      unint64_t v97 = SHIDWORD(v758) + 16;
      int v98 = v758 << (v97 & 0xF8);
      uint64_t v99 = (_DWORD *)((char *)v756 + (v97 >> 3));
      v756 = v99;
      char v100 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v99 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        uint64_t v99 = v757;
      }
      unsigned int v101 = *(_DWORD *)(v10 + 248);
      LODWORD(v758) = (HIWORD(v101) << (16 - v100)) | v98;
      _DWORD *v99 = bswap32(v758);
      unint64_t v102 = SHIDWORD(v758) + 16;
      int v103 = v758 << (v102 & 0xF8);
      uint64_t v104 = (_DWORD *)((char *)v756 + (v102 >> 3));
      v756 = v104;
      char v105 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v104 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        uint64_t v104 = v757;
      }
      LODWORD(v758) = ((unsigned __int16)v101 << (16 - v105)) | v103;
      *uint64_t v104 = bswap32(v758);
      unint64_t v106 = SHIDWORD(v758) + 16;
      int v107 = v758 << (v106 & 0xF8);
      int v108 = (_DWORD *)((char *)v756 + (v106 >> 3));
      v756 = v108;
      char v109 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v108 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        int v108 = v757;
      }
      LODWORD(v758) = (*(unsigned __int8 *)(v10 + 252) << (v109 ^ 0x1F)) | v107;
      _DWORD *v108 = bswap32(v758);
      unint64_t v110 = SHIDWORD(v758) + 1;
      char v111 = v110 & 0xF8;
      unint64_t v112 = (_DWORD *)((char *)v756 + (v110 >> 3));
      v756 = v112;
      int v113 = v110 & 7;
      HIDWORD(v758) = v113;
      if (v112 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        unint64_t v112 = v757;
      }
      int v114 = v758 << v111;
      if (*(unsigned char *)(v10 + 252))
      {
        unsigned int v115 = *(_DWORD *)(v10 + 256) + 1;
        unsigned int v116 = __clz(v115);
        unsigned int v117 = (v115 - (0x80000000 >> v116)) | (0x80000000 >> v116);
        uint64_t v118 = 63 - 2 * v116;
        LODWORD(v758) = (v117 << (-(char)v113 - v118)) | v114;
        *unint64_t v112 = bswap32(v758);
        unint64_t v119 = SHIDWORD(v758) + v118;
        int v114 = v758 << (v119 & 0xF8);
        unint64_t v112 = (_DWORD *)((char *)v756 + (v119 >> 3));
        v756 = v112;
        int v113 = v119 & 7;
        HIDWORD(v758) = v113;
        if (v112 >= v757)
        {
          char v759 = 1;
          v756 = v757;
          unint64_t v112 = v757;
        }
      }
      unsigned int v120 = *(unsigned __int16 *)(v10 + 260) + 1;
      unsigned int v121 = __clz(v120);
      unsigned int v122 = 0x80000000 >> v121;
      uint64_t v123 = (2 * v121) ^ 0x3F;
      LODWORD(v758) = (((v120 - v122) | v122) << (-(char)v113 - v123)) | v114;
      *unint64_t v112 = bswap32(v758);
      unint64_t v124 = SHIDWORD(v758) + v123;
      int v91 = v758 << (v124 & 0xF8);
      int v89 = (_DWORD *)((char *)v756 + (v124 >> 3));
      v756 = v89;
      int v90 = v124 & 7;
      HIDWORD(v758) = v90;
      if (v89 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        int v89 = v757;
      }
    }
    LODWORD(v758) = (*(unsigned __int8 *)(v10 + 262) << (v90 ^ 0x1F)) | v91;
    *int v89 = bswap32(v758);
    unint64_t v125 = SHIDWORD(v758) + 1;
    v756 = (_DWORD *)((char *)v756 + (v125 >> 3));
    LODWORD(v758) = v758 << (v125 & 0xF8);
    HIDWORD(v758) = v125 & 7;
    if (v756 >= v757)
    {
      char v759 = 1;
      v756 = v757;
    }
    sub_1BBA19A20((uint64_t)&v753);
    size_t v9 = off_1EC59CAB8(__ptr, 0, v755, (char *)v756 - v755, 2);
    *(_DWORD *)(v8 + 12720) += v9;
    int v126 = *(FILE **)(v8 + 88);
    if (v126) {
      fwrite(__ptr, 1uLL, v9, v126);
    }
  }
  if (v753) {
    free(v753);
  }
  size_t v752 = v9;
  v753 = 0;
  uint64_t v127 = *(void *)(a1 + 16);
  uint64_t v754 = 0;
  v757 = 0;
  unint64_t v758 = 0;
  v756 = 0;
  if (sub_1BBA195B4(&v753, 1024)) {
    goto LABEL_78;
  }
  int v133 = *(unsigned __int8 **)(v127 + 12688);
  _DWORD *v756 = bswap32(v758);
  unint64_t v134 = SHIDWORD(v758) + 1;
  int v135 = v758 << (v134 & 0xF8);
  int v136 = (_DWORD *)((char *)v756 + (v134 >> 3));
  v756 = v136;
  int v137 = v134 & 7;
  HIDWORD(v758) = v137;
  if (v136 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    int v136 = v757;
  }
  LODWORD(v758) = (33 << (26 - v137)) | v135;
  *int v136 = bswap32(v758);
  unint64_t v138 = SHIDWORD(v758) + 6;
  unsigned int v139 = v758 << (v138 & 0xF8);
  double v140 = (_DWORD *)((char *)v756 + (v138 >> 3));
  v756 = v140;
  LODWORD(v758) = v139;
  HIDWORD(v758) = v138 & 7;
  if (v140 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    double v140 = v757;
  }
  *double v140 = bswap32(v139);
  unint64_t v141 = SHIDWORD(v758) + 6;
  long long v142 = (_DWORD *)((char *)v756 + (v141 >> 3));
  v756 = v142;
  HIDWORD(v758) = v141 & 7;
  if (v142 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    long long v142 = v757;
  }
  LODWORD(v758) = (1 << (29 - (v141 & 7))) | (v758 << (v141 & 0xF8));
  *long long v142 = bswap32(v758);
  unint64_t v143 = SHIDWORD(v758) + 3;
  int v144 = v758 << (v143 & 0xF8);
  uint64_t v145 = (_DWORD *)((char *)v756 + (v143 >> 3));
  v756 = v145;
  int v146 = v143 & 7;
  HIDWORD(v758) = v146;
  if (v145 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    uint64_t v145 = v757;
  }
  LODWORD(v758) = (*v133 << (28 - v146)) | v144;
  *uint64_t v145 = bswap32(v758);
  unint64_t v147 = SHIDWORD(v758) + 4;
  int v148 = v758 << (v147 & 0xF8);
  int v149 = (_DWORD *)((char *)v756 + (v147 >> 3));
  v756 = v149;
  int v150 = v147 & 7;
  HIDWORD(v758) = v150;
  if (v149 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    int v149 = v757;
  }
  LODWORD(v758) = (v133[1] << (29 - v150)) | v148;
  *int v149 = bswap32(v758);
  unint64_t v151 = SHIDWORD(v758) + 3;
  int v152 = v758 << (v151 & 0xF8);
  unsigned int v153 = (_DWORD *)((char *)v756 + (v151 >> 3));
  v756 = v153;
  int v154 = v151 & 7;
  HIDWORD(v758) = v154;
  if (v153 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    unsigned int v153 = v757;
  }
  LODWORD(v758) = (v133[2] << (v154 ^ 0x1F)) | v152;
  *unsigned int v153 = bswap32(v758);
  unint64_t v155 = SHIDWORD(v758) + 1;
  v756 = (_DWORD *)((char *)v756 + (v155 >> 3));
  LODWORD(v758) = v758 << (v155 & 0xF8);
  HIDWORD(v758) = v155 & 7;
  if (v756 >= v757)
  {
    char v759 = 1;
    v756 = v757;
  }
  sub_1BBA55CE0(v133 + 4, v133[1], (uint64_t)&v753);
  unsigned int v156 = v133[172] + 1;
  unsigned int v157 = __clz(v156);
  unsigned int v158 = (v156 - (0x80000000 >> v157)) | (0x80000000 >> v157);
  uint64_t v159 = (2 * v157) ^ 0x3F;
  LODWORD(v758) = (v158 << (-BYTE4(v758) - v159)) | v758;
  _DWORD *v756 = bswap32(v758);
  unint64_t v160 = SHIDWORD(v758) + v159;
  int v161 = v758 << (v160 & 0xF8);
  double v162 = (_DWORD *)((char *)v756 + (v160 >> 3));
  v756 = v162;
  char v163 = v160 & 7;
  HIDWORD(v758) = v160 & 7;
  if (v162 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    double v162 = v757;
  }
  unsigned int v164 = v133[173] + 1;
  unsigned int v165 = __clz(v164);
  LODWORD(v758) = (((v164 - (0x80000000 >> v165)) | (0x80000000 >> v165)) << (-((2 * v165) ^ 0x3F) - v163)) | v161;
  *double v162 = bswap32(v758);
  int v166 = v758 << ((BYTE4(v758) + ((2 * v165) ^ 0x3F)) & 0xF8);
  int v167 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v165) ^ 0x3FuLL)) >> 3));
  v756 = v167;
  char v168 = (BYTE4(v758) + ((2 * v165) ^ 0x3F)) & 7;
  LODWORD(v758) = v166;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v165) ^ 0x3F)) & 7;
  if (v167 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    int v167 = v757;
  }
  if (v133[173] == 3)
  {
    LODWORD(v758) = (v133[174] << (v168 ^ 0x1F)) | v166;
    *int v167 = bswap32(v758);
    unint64_t v169 = SHIDWORD(v758) + 1;
    v756 = (_DWORD *)((char *)v756 + (v169 >> 3));
    LODWORD(v758) = v758 << (v169 & 0xF8);
    HIDWORD(v758) = v169 & 7;
    if (v756 >= v757)
    {
      char v759 = 1;
      v756 = v757;
    }
  }
  sub_1BBA198B8((uint64_t)&v753, *((_DWORD *)v133 + 44));
  sub_1BBA198B8((uint64_t)&v753, *((_DWORD *)v133 + 45));
  LODWORD(v758) = (v133[184] << ~BYTE4(v758)) | v758;
  _DWORD *v756 = bswap32(v758);
  unint64_t v170 = SHIDWORD(v758) + 1;
  int v171 = v758 << (v170 & 0xF8);
  int v172 = (_DWORD *)((char *)v756 + (v170 >> 3));
  v756 = v172;
  char v173 = v170 & 7;
  LODWORD(v758) = v171;
  HIDWORD(v758) = v170 & 7;
  if (v172 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    int v172 = v757;
  }
  if (v133[184])
  {
    sub_1BBA198B8((uint64_t)&v753, *((unsigned __int16 *)v133 + 93));
    sub_1BBA198B8((uint64_t)&v753, *((unsigned __int16 *)v133 + 94));
    sub_1BBA198B8((uint64_t)&v753, *((unsigned __int16 *)v133 + 95));
    sub_1BBA198B8((uint64_t)&v753, *((unsigned __int16 *)v133 + 96));
    int v171 = v758;
    char v173 = BYTE4(v758);
    int v172 = v756;
  }
  unsigned int v174 = v133[194] + 1;
  unsigned int v175 = __clz(v174);
  unsigned int v176 = 0x80000000 >> v175;
  uint64_t v177 = (2 * v175) ^ 0x3F;
  LODWORD(v758) = (((v174 - v176) | v176) << (-v173 - v177)) | v171;
  *int v172 = bswap32(v758);
  unint64_t v178 = SHIDWORD(v758) + v177;
  int v179 = v758 << (v178 & 0xF8);
  unsigned int v180 = (_DWORD *)((char *)v756 + (v178 >> 3));
  v756 = v180;
  int v181 = v178 & 7;
  HIDWORD(v758) = v181;
  if (v180 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    unsigned int v180 = v757;
  }
  unsigned int v182 = v133[195] + 1;
  unsigned int v183 = __clz(v182);
  LODWORD(v758) = (((v182 - (0x80000000 >> v183)) | (0x80000000 >> v183)) << (-((2 * v183) ^ 0x3F) - v181)) | v179;
  *unsigned int v180 = bswap32(v758);
  int v184 = v758 << ((BYTE4(v758) + ((2 * v183) ^ 0x3F)) & 0xF8);
  uint64_t v185 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v183) ^ 0x3FuLL)) >> 3));
  v756 = v185;
  char v186 = (BYTE4(v758) + ((2 * v183) ^ 0x3F)) & 7;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v183) ^ 0x3F)) & 7;
  if (v185 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    uint64_t v185 = v757;
  }
  unsigned int v187 = v133[196] + 1;
  unsigned int v188 = __clz(v187);
  unsigned int v189 = (v187 - (0x80000000 >> v188)) | (0x80000000 >> v188);
  uint64_t v190 = (2 * v188) ^ 0x3F;
  LODWORD(v758) = (v189 << (-(char)v190 - v186)) | v184;
  *uint64_t v185 = bswap32(v758);
  unint64_t v191 = SHIDWORD(v758) + v190;
  int v192 = v758 << (v191 & 0xF8);
  uint64_t v193 = (_DWORD *)((char *)v756 + (v191 >> 3));
  v756 = v193;
  int v194 = v191 & 7;
  HIDWORD(v758) = v194;
  if (v193 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    uint64_t v193 = v757;
  }
  LODWORD(v758) = (v133[197] << (v194 ^ 0x1F)) | v192;
  *uint64_t v193 = bswap32(v758);
  unint64_t v195 = SHIDWORD(v758) + 1;
  unsigned int v196 = v758 << (v195 & 0xF8);
  uint64_t v197 = (_DWORD *)((char *)v756 + (v195 >> 3));
  v756 = v197;
  LOBYTE(v198) = v195 & 7;
  LODWORD(v758) = v196;
  HIDWORD(v758) = v195 & 7;
  if (v197 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    uint64_t v197 = v757;
  }
  if (v133[197]) {
    unsigned __int8 v199 = 0;
  }
  else {
    unsigned __int8 v199 = v133[1];
  }
  unint64_t v200 = v199;
  do
  {
    unsigned int v201 = v133[v200 + 198] + 1;
    unsigned int v202 = __clz(v201);
    unsigned int v203 = 0x80000000 >> v202;
    uint64_t v204 = (2 * v202) ^ 0x3F;
    LODWORD(v758) = (((v201 - v203) | v203) << (-(char)v198 - v204)) | v196;
    *uint64_t v197 = bswap32(v758);
    unint64_t v205 = SHIDWORD(v758) + v204;
    unsigned int v206 = v758 << (v205 & 0xF8);
    int v207 = (_DWORD *)((char *)v756 + (v205 >> 3));
    v756 = v207;
    unsigned int v208 = v205 & 7;
    unint64_t v758 = __PAIR64__(v208, v206);
    if (v207 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int v207 = v757;
    }
    unsigned int v209 = v133[v200 + 205] + 1;
    unsigned int v210 = __clz(v209);
    unsigned int v211 = (v209 - (0x80000000 >> v210)) | (0x80000000 >> v210);
    uint64_t v212 = (2 * v210) ^ 0x3F;
    LODWORD(v758) = (v211 << (-(char)v212 - v208)) | v206;
    *int v207 = bswap32(v758);
    unint64_t v213 = SHIDWORD(v758) + v212;
    unsigned int v214 = v758 << (v213 & 0xF8);
    int v215 = (_DWORD *)((char *)v756 + (v213 >> 3));
    v756 = v215;
    unsigned int v216 = v213 & 7;
    unint64_t v758 = __PAIR64__(v216, v214);
    if (v215 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int v215 = v757;
    }
    unsigned int v217 = *(_DWORD *)&v133[4 * v200 + 212] + 1;
    unsigned int v218 = __clz(v217);
    unsigned int v219 = (v217 - (0x80000000 >> v218)) | (0x80000000 >> v218);
    uint64_t v220 = 63 - 2 * v218;
    LODWORD(v758) = (v219 << (-(char)v220 - v216)) | v214;
    *int v215 = bswap32(v758);
    unint64_t v221 = SHIDWORD(v758) + v220;
    unsigned int v196 = v758 << (v221 & 0xF8);
    uint64_t v197 = (_DWORD *)((char *)v756 + (v221 >> 3));
    v756 = v197;
    unsigned int v198 = v221 & 7;
    unint64_t v758 = __PAIR64__(v198, v196);
    if (v197 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      uint64_t v197 = v757;
    }
    BOOL v71 = v200++ >= v133[1];
  }
  while (!v71);
  unsigned int v222 = v133[240] + 1;
  unsigned int v223 = __clz(v222);
  unsigned int v224 = (v222 - (0x80000000 >> v223)) | (0x80000000 >> v223);
  uint64_t v225 = (2 * v223) ^ 0x3F;
  LODWORD(v758) = (v224 << (-(char)v225 - v198)) | v196;
  *uint64_t v197 = bswap32(v758);
  unint64_t v226 = SHIDWORD(v758) + v225;
  int v227 = v758 << (v226 & 0xF8);
  uint64_t v228 = (_DWORD *)((char *)v756 + (v226 >> 3));
  v756 = v228;
  char v229 = v226 & 7;
  HIDWORD(v758) = v226 & 7;
  if (v228 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    uint64_t v228 = v757;
  }
  unsigned int v230 = v133[241] + 1;
  unsigned int v231 = __clz(v230);
  LODWORD(v758) = (((v230 - (0x80000000 >> v231)) | (0x80000000 >> v231)) << (-((2 * v231) ^ 0x3F) - v229)) | v227;
  *uint64_t v228 = bswap32(v758);
  int v232 = v758 << ((BYTE4(v758) + ((2 * v231) ^ 0x3F)) & 0xF8);
  int v233 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v231) ^ 0x3FuLL)) >> 3));
  v756 = v233;
  char v234 = (BYTE4(v758) + ((2 * v231) ^ 0x3F)) & 7;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v231) ^ 0x3F)) & 7;
  if (v233 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    int v233 = v757;
  }
  unsigned int v235 = v133[242] + 1;
  unsigned int v236 = __clz(v235);
  unsigned int v237 = (v235 - (0x80000000 >> v236)) | (0x80000000 >> v236);
  uint64_t v238 = (2 * v236) ^ 0x3F;
  LODWORD(v758) = (v237 << (-(char)v238 - v234)) | v232;
  *int v233 = bswap32(v758);
  unint64_t v239 = SHIDWORD(v758) + v238;
  int v240 = v758 << (v239 & 0xF8);
  __int16 v241 = (_DWORD *)((char *)v756 + (v239 >> 3));
  v756 = v241;
  int v242 = v239 & 7;
  HIDWORD(v758) = v242;
  if (v241 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    __int16 v241 = v757;
  }
  unsigned int v243 = v133[243] + 1;
  unsigned int v244 = __clz(v243);
  LODWORD(v758) = (((v243 - (0x80000000 >> v244)) | (0x80000000 >> v244)) << (-((2 * v244) ^ 0x3F) - v242)) | v240;
  *__int16 v241 = bswap32(v758);
  int v245 = v758 << ((BYTE4(v758) + ((2 * v244) ^ 0x3F)) & 0xF8);
  int v246 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v244) ^ 0x3FuLL)) >> 3));
  v756 = v246;
  char v247 = (BYTE4(v758) + ((2 * v244) ^ 0x3F)) & 7;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v244) ^ 0x3F)) & 7;
  if (v246 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    int v246 = v757;
  }
  unsigned int v248 = v133[244] + 1;
  unsigned int v249 = __clz(v248);
  unsigned int v250 = (v248 - (0x80000000 >> v249)) | (0x80000000 >> v249);
  uint64_t v251 = (2 * v249) ^ 0x3F;
  LODWORD(v758) = (v250 << (-(char)v251 - v247)) | v245;
  *int v246 = bswap32(v758);
  unint64_t v252 = SHIDWORD(v758) + v251;
  int v253 = v758 << (v252 & 0xF8);
  int v254 = (_DWORD *)((char *)v756 + (v252 >> 3));
  v756 = v254;
  int v255 = v252 & 7;
  HIDWORD(v758) = v255;
  if (v254 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    int v254 = v757;
  }
  unsigned int v256 = v133[245] + 1;
  unsigned int v257 = __clz(v256);
  LODWORD(v758) = (((v256 - (0x80000000 >> v257)) | (0x80000000 >> v257)) << (-((2 * v257) ^ 0x3F) - v255)) | v253;
  *int v254 = bswap32(v758);
  int v258 = v758 << ((BYTE4(v758) + ((2 * v257) ^ 0x3F)) & 0xF8);
  int8x8_t v259 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v257) ^ 0x3FuLL)) >> 3));
  v756 = v259;
  char v260 = (BYTE4(v758) + ((2 * v257) ^ 0x3F)) & 7;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v257) ^ 0x3F)) & 7;
  if (v259 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    int8x8_t v259 = v757;
  }
  LODWORD(v758) = (v133[246] << (v260 ^ 0x1F)) | v258;
  *int8x8_t v259 = bswap32(v758);
  unint64_t v261 = SHIDWORD(v758) + 1;
  char v262 = v261 & 0xF8;
  int16x8_t v263 = (_DWORD *)((char *)v756 + (v261 >> 3));
  v756 = v263;
  int v264 = v261 & 7;
  HIDWORD(v758) = v264;
  if (v263 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    int16x8_t v263 = v757;
  }
  int v265 = v758 << v262;
  if (v133[246])
  {
    LODWORD(v758) = (v133[247] << (v264 ^ 0x1F)) | v265;
    *int16x8_t v263 = bswap32(v758);
    unint64_t v266 = SHIDWORD(v758) + 1;
    int v265 = v758 << (v266 & 0xF8);
    int16x8_t v263 = (_DWORD *)((char *)v756 + (v266 >> 3));
    v756 = v263;
    int v264 = v266 & 7;
    HIDWORD(v758) = v264;
    if (v263 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      int16x8_t v263 = v757;
    }
  }
  LODWORD(v758) = (v133[248] << (v264 ^ 0x1F)) | v265;
  *int16x8_t v263 = bswap32(v758);
  unint64_t v267 = SHIDWORD(v758) + 1;
  int v268 = v758 << (v267 & 0xF8);
  __int16 v269 = (_DWORD *)((char *)v756 + (v267 >> 3));
  v756 = v269;
  int v270 = v267 & 7;
  HIDWORD(v758) = v270;
  if (v269 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    __int16 v269 = v757;
  }
  LODWORD(v758) = (v133[249] << (v270 ^ 0x1F)) | v268;
  *__int16 v269 = bswap32(v758);
  unint64_t v271 = SHIDWORD(v758) + 1;
  int v272 = v758 << (v271 & 0xF8);
  int v273 = (_DWORD *)((char *)v756 + (v271 >> 3));
  v756 = v273;
  int v274 = v271 & 7;
  HIDWORD(v758) = v274;
  if (v273 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    int v273 = v757;
  }
  LODWORD(v758) = (v133[250] << (v274 ^ 0x1F)) | v272;
  *int v273 = bswap32(v758);
  unint64_t v275 = SHIDWORD(v758) + 1;
  char v276 = v275 & 0xF8;
  unsigned int v277 = (_DWORD *)((char *)v756 + (v275 >> 3));
  v756 = v277;
  int v278 = v275 & 7;
  HIDWORD(v758) = v278;
  if (v277 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    unsigned int v277 = v757;
  }
  int v279 = v758 << v276;
  if (v133[250])
  {
    LODWORD(v758) = (v133[251] << (28 - v278)) | v279;
    *unsigned int v277 = bswap32(v758);
    unint64_t v280 = SHIDWORD(v758) + 4;
    int v281 = v758 << (v280 & 0xF8);
    uint64_t v282 = (_DWORD *)((char *)v756 + (v280 >> 3));
    v756 = v282;
    int v283 = v280 & 7;
    HIDWORD(v758) = v283;
    if (v282 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      uint64_t v282 = v757;
    }
    LODWORD(v758) = (v133[252] << (28 - v283)) | v281;
    *uint64_t v282 = bswap32(v758);
    unint64_t v284 = SHIDWORD(v758) + 4;
    int v285 = v758 << (v284 & 0xF8);
    unsigned int v286 = (_DWORD *)((char *)v756 + (v284 >> 3));
    v756 = v286;
    int v287 = v284 & 7;
    HIDWORD(v758) = v287;
    if (v286 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      unsigned int v286 = v757;
    }
    unsigned int v288 = v133[253] + 1;
    unsigned int v289 = __clz(v288);
    unsigned int v290 = 0x80000000 >> v289;
    uint64_t v291 = (2 * v289) ^ 0x3F;
    LODWORD(v758) = (((v288 - v290) | v290) << (-(char)v287 - v291)) | v285;
    *unsigned int v286 = bswap32(v758);
    unint64_t v292 = SHIDWORD(v758) + v291;
    int v293 = v758 << (v292 & 0xF8);
    unsigned int v294 = (_DWORD *)((char *)v756 + (v292 >> 3));
    v756 = v294;
    int v295 = v292 & 7;
    HIDWORD(v758) = v295;
    if (v294 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      unsigned int v294 = v757;
    }
    unsigned int v296 = v133[254] + 1;
    unsigned int v297 = __clz(v296);
    LODWORD(v758) = (((v296 - (0x80000000 >> v297)) | (0x80000000 >> v297)) << (-((2 * v297) ^ 0x3F) - v295)) | v293;
    *unsigned int v294 = bswap32(v758);
    int v298 = v758 << ((BYTE4(v758) + ((2 * v297) ^ 0x3F)) & 0xF8);
    unsigned int v299 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v297) ^ 0x3FuLL)) >> 3));
    v756 = v299;
    char v300 = (BYTE4(v758) + ((2 * v297) ^ 0x3F)) & 7;
    HIDWORD(v758) = (HIDWORD(v758) + ((2 * v297) ^ 0x3F)) & 7;
    if (v299 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      unsigned int v299 = v757;
    }
    LODWORD(v758) = (v133[255] << (v300 ^ 0x1F)) | v298;
    *unsigned int v299 = bswap32(v758);
    unint64_t v301 = SHIDWORD(v758) + 1;
    int v279 = v758 << (v301 & 0xF8);
    unsigned int v277 = (_DWORD *)((char *)v756 + (v301 >> 3));
    v756 = v277;
    int v278 = v301 & 7;
    HIDWORD(v758) = v278;
    if (v277 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      unsigned int v277 = v757;
    }
  }
  unsigned int v302 = *((_DWORD *)v133 + 65) + 1;
  unsigned int v303 = __clz(v302);
  unsigned int v304 = (v302 - (0x80000000 >> v303)) | (0x80000000 >> v303);
  uint64_t v305 = 63 - 2 * v303;
  LODWORD(v758) = (v304 << (-(char)v278 - v305)) | v279;
  *unsigned int v277 = bswap32(v758);
  unint64_t v306 = SHIDWORD(v758) + v305;
  int v307 = v758 << (v306 & 0xF8);
  v308 = (_DWORD *)((char *)v756 + (v306 >> 3));
  v756 = v308;
  char v309 = v306 & 7;
  LODWORD(v758) = v307;
  HIDWORD(v758) = v306 & 7;
  if (v308 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v308 = v757;
  }
  if (*((_DWORD *)v133 + 65))
  {
    uint64_t v310 = 0;
    unint64_t v311 = 0;
    while (!sub_1BBAE53A4(*((void *)v133 + 33) + v310, (uint64_t)&v753, (uint64_t)v133, v311))
    {
      ++v311;
      v310 += 248;
      if (v311 >= *((unsigned int *)v133 + 65))
      {
        int v307 = v758;
        char v309 = BYTE4(v758);
        v308 = v756;
        goto LABEL_177;
      }
    }
    goto LABEL_78;
  }
LABEL_177:
  LODWORD(v758) = (v133[280] << ~v309) | v307;
  _DWORD *v308 = bswap32(v758);
  unint64_t v312 = SHIDWORD(v758) + 1;
  char v313 = v312 & 0xF8;
  v314 = (_DWORD *)((char *)v756 + (v312 >> 3));
  v756 = v314;
  unsigned int v315 = v312 & 7;
  HIDWORD(v758) = v315;
  if (v314 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v314 = v757;
  }
  unsigned int v316 = v758 << v313;
  if (v133[280])
  {
    unsigned int v317 = *((_DWORD *)v133 + 71) + 1;
    unsigned int v318 = __clz(v317);
    unsigned int v319 = (v317 - (0x80000000 >> v318)) | (0x80000000 >> v318);
    uint64_t v320 = 63 - 2 * v318;
    LODWORD(v758) = (v319 << (-(char)v315 - v320)) | v316;
    _DWORD *v314 = bswap32(v758);
    unint64_t v321 = SHIDWORD(v758) + v320;
    unsigned int v316 = v758 << (v321 & 0xF8);
    v314 = (_DWORD *)((char *)v756 + (v321 >> 3));
    v756 = v314;
    unsigned int v315 = v321 & 7;
    HIDWORD(v758) = v315;
    if (v314 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v314 = v757;
    }
    if (*((_DWORD *)v133 + 71))
    {
      unint64_t v322 = 0;
      do
      {
        unsigned int v323 = *(unsigned __int16 *)&v133[2 * v322 + 288] + 1;
        unsigned int v324 = __clz(v323);
        unsigned int v325 = 0x80000000 >> v324;
        uint64_t v326 = (2 * v324) ^ 0x3F;
        LODWORD(v758) = (((v323 - v325) | v325) << (-(char)v315 - v326)) | v316;
        _DWORD *v314 = bswap32(v758);
        unint64_t v327 = SHIDWORD(v758) + v326;
        v328 = (_DWORD *)((char *)v756 + (v327 >> 3));
        v756 = v328;
        HIDWORD(v758) = v327 & 7;
        if (v328 >= v757)
        {
          char v759 = 1;
          v756 = v757;
          v328 = v757;
        }
        LODWORD(v758) = (((*((unsigned __int16 *)v133 + 160) >> v322) & 1) << (v327 & 7 ^ 0x1F)) | (v758 << (v327 & 0xF8));
        _DWORD *v328 = bswap32(v758);
        unint64_t v329 = SHIDWORD(v758) + 1;
        unsigned int v316 = v758 << (v329 & 0xF8);
        v314 = (_DWORD *)((char *)v756 + (v329 >> 3));
        v756 = v314;
        unsigned int v315 = v329 & 7;
        unint64_t v758 = __PAIR64__(v315, v316);
        if (v314 >= v757)
        {
          char v759 = 1;
          v756 = v757;
          v314 = v757;
        }
        ++v322;
      }
      while (v322 < *((unsigned int *)v133 + 71));
    }
  }
  LODWORD(v758) = (v133[322] << (v315 ^ 0x1F)) | v316;
  _DWORD *v314 = bswap32(v758);
  unint64_t v330 = SHIDWORD(v758) + 1;
  int v331 = v758 << (v330 & 0xF8);
  v332 = (_DWORD *)((char *)v756 + (v330 >> 3));
  v756 = v332;
  int v333 = v330 & 7;
  HIDWORD(v758) = v333;
  if (v332 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v332 = v757;
  }
  LODWORD(v758) = (v133[323] << (v333 ^ 0x1F)) | v331;
  _DWORD *v332 = bswap32(v758);
  unint64_t v334 = SHIDWORD(v758) + 1;
  int v335 = v758 << (v334 & 0xF8);
  v336 = (_DWORD *)((char *)v756 + (v334 >> 3));
  v756 = v336;
  int v337 = v334 & 7;
  HIDWORD(v758) = v337;
  if (v336 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v336 = v757;
  }
  LODWORD(v758) = (v133[324] << (v337 ^ 0x1F)) | v335;
  _DWORD *v336 = bswap32(v758);
  unint64_t v338 = SHIDWORD(v758) + 1;
  v339 = (_DWORD *)((char *)v756 + (v338 >> 3));
  v756 = v339;
  char v340 = v338 & 7;
  HIDWORD(v758) = v338 & 7;
  if (v339 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v339 = v757;
  }
  int v341 = v758 << (v338 & 0xF8);
  if (v133[324])
  {
    if (*((_WORD *)v133 + 948)) {
      int v342 = 1;
    }
    else {
      int v342 = *((_WORD *)v133 + 949) != 0;
    }
    if (v133[1904] == 2 && v133[1905] == 2)
    {
      int v567 = v133[1906];
      int v568 = v567 != 2;
      v569 = v133 + 1903;
      int v570 = 1;
      if (!v133[1903] && v567 == 2)
      {
        int v568 = 0;
        int v570 = v133[1902] != 5;
      }
    }
    else
    {
      v569 = v133 + 1903;
      int v568 = 1;
      int v570 = 1;
    }
    if (v133[1907]) {
      int v571 = 1;
    }
    else {
      int v571 = v133[1908] != 0;
    }
    int v572 = *((_WORD *)v133 + 956) || *((_WORD *)v133 + 957) || *((_WORD *)v133 + 958) || *((_WORD *)v133 + 959) != 0;
    LODWORD(v758) = (v342 << (v340 ^ 0x1F)) | v341;
    _DWORD *v339 = bswap32(v758);
    unint64_t v575 = SHIDWORD(v758) + 1;
    char v573 = v575 & 0xF8;
    v574 = (_DWORD *)((char *)v756 + (v575 >> 3));
    v756 = v574;
    LODWORD(v575) = v575 & 7;
    HIDWORD(v758) = v575;
    if (v574 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v574 = v757;
    }
    int v576 = v758 << v573;
    if (v342)
    {
      LODWORD(v758) = (255 << (24 - v575)) | v576;
      _DWORD *v574 = bswap32(v758);
      unint64_t v577 = SHIDWORD(v758) + 8;
      int v578 = v758 << (v577 & 0xF8);
      v579 = (_DWORD *)((char *)v756 + (v577 >> 3));
      v756 = v579;
      char v580 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v579 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v579 = v757;
      }
      LODWORD(v758) = (*((unsigned __int16 *)v133 + 948) << (16 - v580)) | v578;
      _DWORD *v579 = bswap32(v758);
      unint64_t v581 = SHIDWORD(v758) + 16;
      int v582 = v758 << (v581 & 0xF8);
      unint64_t v575 = (unint64_t)v756 + (v581 >> 3);
      v756 = (_DWORD *)v575;
      char v583 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v575 >= (unint64_t)v757)
      {
        char v759 = 1;
        v756 = v757;
        unint64_t v575 = (unint64_t)v757;
      }
      LODWORD(v758) = (*((unsigned __int16 *)v133 + 949) << (16 - v583)) | v582;
      *(_DWORD *)unint64_t v575 = bswap32(v758);
      unint64_t v584 = SHIDWORD(v758) + 16;
      int v576 = v758 << (v584 & 0xF8);
      v574 = (_DWORD *)((char *)v756 + (v584 >> 3));
      v756 = v574;
      LOBYTE(v575) = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v574 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v574 = v757;
      }
    }
    LODWORD(v758) = (v133[1900] << (v575 ^ 0x1F)) | v576;
    _DWORD *v574 = bswap32(v758);
    unint64_t v585 = SHIDWORD(v758) + 1;
    char v586 = v585 & 0xF8;
    v587 = (_DWORD *)((char *)v756 + (v585 >> 3));
    v756 = v587;
    int v588 = v585 & 7;
    HIDWORD(v758) = v588;
    if (v587 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v587 = v757;
    }
    int v589 = v758 << v586;
    if (v133[1900])
    {
      LODWORD(v758) = (v133[1901] << (v588 ^ 0x1F)) | v589;
      _DWORD *v587 = bswap32(v758);
      unint64_t v590 = SHIDWORD(v758) + 1;
      int v589 = v758 << (v590 & 0xF8);
      v587 = (_DWORD *)((char *)v756 + (v590 >> 3));
      v756 = v587;
      int v588 = v590 & 7;
      HIDWORD(v758) = v588;
      if (v587 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v587 = v757;
      }
    }
    LODWORD(v758) = (v570 << (v588 ^ 0x1F)) | v589;
    _DWORD *v587 = bswap32(v758);
    unint64_t v591 = SHIDWORD(v758) + 1;
    char v592 = v591 & 0xF8;
    v593 = (_DWORD *)((char *)v756 + (v591 >> 3));
    v756 = v593;
    int v594 = v591 & 7;
    HIDWORD(v758) = v594;
    if (v593 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v593 = v757;
    }
    int v595 = v758 << v592;
    if (v570)
    {
      LODWORD(v758) = (v133[1902] << (29 - v594)) | v595;
      _DWORD *v593 = bswap32(v758);
      unint64_t v596 = SHIDWORD(v758) + 3;
      int v597 = v758 << (v596 & 0xF8);
      v598 = (_DWORD *)((char *)v756 + (v596 >> 3));
      v756 = v598;
      int v599 = v596 & 7;
      HIDWORD(v758) = v599;
      if (v598 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v598 = v757;
      }
      LODWORD(v758) = (*v569 << (v599 ^ 0x1F)) | v597;
      _DWORD *v598 = bswap32(v758);
      unint64_t v600 = SHIDWORD(v758) + 1;
      int v601 = v758 << (v600 & 0xF8);
      v602 = (_DWORD *)((char *)v756 + (v600 >> 3));
      v756 = v602;
      int v603 = v600 & 7;
      HIDWORD(v758) = v603;
      if (v602 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v602 = v757;
      }
      LODWORD(v758) = (v568 << (v603 ^ 0x1F)) | v601;
      _DWORD *v602 = bswap32(v758);
      unint64_t v604 = SHIDWORD(v758) + 1;
      char v605 = v604 & 0xF8;
      v593 = (_DWORD *)((char *)v756 + (v604 >> 3));
      v756 = v593;
      int v594 = v604 & 7;
      HIDWORD(v758) = v594;
      if (v593 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v593 = v757;
      }
      int v595 = v758 << v605;
      if (v568)
      {
        LODWORD(v758) = (v133[1904] << (24 - v594)) | v595;
        _DWORD *v593 = bswap32(v758);
        unint64_t v606 = SHIDWORD(v758) + 8;
        int v607 = v758 << (v606 & 0xF8);
        v608 = (_DWORD *)((char *)v756 + (v606 >> 3));
        v756 = v608;
        char v609 = BYTE4(v758) & 7;
        HIDWORD(v758) = BYTE4(v758) & 7;
        if (v608 >= v757)
        {
          char v759 = 1;
          v756 = v757;
          v608 = v757;
        }
        LODWORD(v758) = (v133[1905] << (24 - v609)) | v607;
        _DWORD *v608 = bswap32(v758);
        unint64_t v610 = SHIDWORD(v758) + 8;
        int v611 = v758 << (v610 & 0xF8);
        v612 = (_DWORD *)((char *)v756 + (v610 >> 3));
        v756 = v612;
        char v613 = BYTE4(v758) & 7;
        HIDWORD(v758) = BYTE4(v758) & 7;
        if (v612 >= v757)
        {
          char v759 = 1;
          v756 = v757;
          v612 = v757;
        }
        LODWORD(v758) = (v133[1906] << (24 - v613)) | v611;
        _DWORD *v612 = bswap32(v758);
        unint64_t v614 = SHIDWORD(v758) + 8;
        int v595 = v758 << (v614 & 0xF8);
        v593 = (_DWORD *)((char *)v756 + (v614 >> 3));
        v756 = v593;
        LOBYTE(v594) = BYTE4(v758) & 7;
        HIDWORD(v758) = BYTE4(v758) & 7;
        if (v593 >= v757)
        {
          char v759 = 1;
          v756 = v757;
          v593 = v757;
        }
      }
    }
    LODWORD(v758) = (v571 << (v594 ^ 0x1F)) | v595;
    _DWORD *v593 = bswap32(v758);
    unint64_t v615 = SHIDWORD(v758) + 1;
    char v616 = v615 & 0xF8;
    v617 = (_DWORD *)((char *)v756 + (v615 >> 3));
    v756 = v617;
    int v618 = v615 & 7;
    HIDWORD(v758) = v618;
    if (v617 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v617 = v757;
    }
    int v619 = v758 << v616;
    if (v571)
    {
      unsigned int v620 = v133[1907] + 1;
      unsigned int v621 = __clz(v620);
      unsigned int v622 = 0x80000000 >> v621;
      uint64_t v623 = (2 * v621) ^ 0x3F;
      LODWORD(v758) = (((v620 - v622) | v622) << (-(char)v618 - v623)) | v619;
      _DWORD *v617 = bswap32(v758);
      unint64_t v624 = SHIDWORD(v758) + v623;
      int v625 = v758 << (v624 & 0xF8);
      v626 = (_DWORD *)((char *)v756 + (v624 >> 3));
      v756 = v626;
      int v618 = v624 & 7;
      HIDWORD(v758) = v618;
      if (v626 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v626 = v757;
      }
      unsigned int v627 = v133[1908] + 1;
      unsigned int v628 = __clz(v627);
      LODWORD(v758) = (((v627 - (0x80000000 >> v628)) | (0x80000000 >> v628)) << (-((2 * v628) ^ 0x3F) - v618)) | v625;
      _DWORD *v626 = bswap32(v758);
      int v619 = v758 << ((BYTE4(v758) + ((2 * v628) ^ 0x3F)) & 0xF8);
      v617 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v628) ^ 0x3FuLL)) >> 3));
      v756 = v617;
      LOBYTE(v618) = (BYTE4(v758) + ((2 * v628) ^ 0x3F)) & 7;
      HIDWORD(v758) = (HIDWORD(v758) + ((2 * v628) ^ 0x3F)) & 7;
      if (v617 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v617 = v757;
      }
    }
    LODWORD(v758) = (v133[1909] << (v618 ^ 0x1F)) | v619;
    _DWORD *v617 = bswap32(v758);
    unint64_t v629 = SHIDWORD(v758) + 1;
    int v630 = v758 << (v629 & 0xF8);
    v631 = (_DWORD *)((char *)v756 + (v629 >> 3));
    v756 = v631;
    int v632 = v629 & 7;
    HIDWORD(v758) = v632;
    if (v631 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v631 = v757;
    }
    LODWORD(v758) = (v133[1910] << (v632 ^ 0x1F)) | v630;
    _DWORD *v631 = bswap32(v758);
    unint64_t v633 = SHIDWORD(v758) + 1;
    int v634 = v758 << (v633 & 0xF8);
    v635 = (_DWORD *)((char *)v756 + (v633 >> 3));
    v756 = v635;
    int v636 = v633 & 7;
    HIDWORD(v758) = v636;
    if (v635 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v635 = v757;
    }
    LODWORD(v758) = (v133[1911] << (v636 ^ 0x1F)) | v634;
    _DWORD *v635 = bswap32(v758);
    unint64_t v637 = SHIDWORD(v758) + 1;
    int v638 = v758 << (v637 & 0xF8);
    v639 = (_DWORD *)((char *)v756 + (v637 >> 3));
    v756 = v639;
    int v640 = v637 & 7;
    HIDWORD(v758) = v640;
    if (v639 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v639 = v757;
    }
    LODWORD(v758) = (v572 << (v640 ^ 0x1F)) | v638;
    _DWORD *v639 = bswap32(v758);
    unint64_t v641 = SHIDWORD(v758) + 1;
    char v642 = v641 & 0xF8;
    v643 = (_DWORD *)((char *)v756 + (v641 >> 3));
    v756 = v643;
    int v644 = v641 & 7;
    HIDWORD(v758) = v644;
    if (v643 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v643 = v757;
    }
    int v645 = v758 << v642;
    if (v572)
    {
      unsigned int v646 = *((unsigned __int16 *)v133 + 956) + 1;
      unsigned int v647 = __clz(v646);
      unsigned int v648 = 0x80000000 >> v647;
      uint64_t v649 = (2 * v647) ^ 0x3F;
      LODWORD(v758) = (((v646 - v648) | v648) << (-(char)v644 - v649)) | v645;
      _DWORD *v643 = bswap32(v758);
      unint64_t v650 = SHIDWORD(v758) + v649;
      int v651 = v758 << (v650 & 0xF8);
      v652 = (_DWORD *)((char *)v756 + (v650 >> 3));
      v756 = v652;
      int v653 = v650 & 7;
      HIDWORD(v758) = v653;
      if (v652 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v652 = v757;
      }
      unsigned int v654 = *((unsigned __int16 *)v133 + 957) + 1;
      unsigned int v655 = __clz(v654);
      LODWORD(v758) = (((v654 - (0x80000000 >> v655)) | (0x80000000 >> v655)) << (-((2 * v655) ^ 0x3F) - v653)) | v651;
      _DWORD *v652 = bswap32(v758);
      int v656 = v758 << ((BYTE4(v758) + ((2 * v655) ^ 0x3F)) & 0xF8);
      v657 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v655) ^ 0x3FuLL)) >> 3));
      v756 = v657;
      char v658 = (BYTE4(v758) + ((2 * v655) ^ 0x3F)) & 7;
      HIDWORD(v758) = (HIDWORD(v758) + ((2 * v655) ^ 0x3F)) & 7;
      if (v657 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v657 = v757;
      }
      unsigned int v659 = *((unsigned __int16 *)v133 + 958) + 1;
      unsigned int v660 = __clz(v659);
      unsigned int v661 = (v659 - (0x80000000 >> v660)) | (0x80000000 >> v660);
      uint64_t v662 = (2 * v660) ^ 0x3F;
      LODWORD(v758) = (v661 << (-(char)v662 - v658)) | v656;
      _DWORD *v657 = bswap32(v758);
      unint64_t v663 = SHIDWORD(v758) + v662;
      int v664 = v758 << (v663 & 0xF8);
      v665 = (_DWORD *)((char *)v756 + (v663 >> 3));
      v756 = v665;
      int v644 = v663 & 7;
      HIDWORD(v758) = v644;
      if (v665 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v665 = v757;
      }
      unsigned int v666 = *((unsigned __int16 *)v133 + 959) + 1;
      unsigned int v667 = __clz(v666);
      LODWORD(v758) = (((v666 - (0x80000000 >> v667)) | (0x80000000 >> v667)) << (-((2 * v667) ^ 0x3F) - v644)) | v664;
      _DWORD *v665 = bswap32(v758);
      int v645 = v758 << ((BYTE4(v758) + ((2 * v667) ^ 0x3F)) & 0xF8);
      v643 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v667) ^ 0x3FuLL)) >> 3));
      v756 = v643;
      LOBYTE(v644) = (BYTE4(v758) + ((2 * v667) ^ 0x3F)) & 7;
      HIDWORD(v758) = (HIDWORD(v758) + ((2 * v667) ^ 0x3F)) & 7;
      if (v643 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v643 = v757;
      }
    }
    LODWORD(v758) = (v133[1920] << (v644 ^ 0x1F)) | v645;
    _DWORD *v643 = bswap32(v758);
    unint64_t v668 = SHIDWORD(v758) + 1;
    char v669 = v668 & 0xF8;
    v670 = (_DWORD *)((char *)v756 + (v668 >> 3));
    v756 = v670;
    unsigned int v671 = v668 & 7;
    HIDWORD(v758) = v671;
    if (v670 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v670 = v757;
    }
    unsigned int v672 = v758 << v669;
    if (v133[1920])
    {
      unsigned int v673 = *((_DWORD *)v133 + 481);
      LODWORD(v758) = (HIWORD(v673) << (16 - v671)) | v672;
      _DWORD *v670 = bswap32(v758);
      unint64_t v674 = SHIDWORD(v758) + 16;
      int v675 = v758 << (v674 & 0xF8);
      v676 = (_DWORD *)((char *)v756 + (v674 >> 3));
      v756 = v676;
      char v677 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v676 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v676 = v757;
      }
      LODWORD(v758) = ((unsigned __int16)v673 << (16 - v677)) | v675;
      _DWORD *v676 = bswap32(v758);
      unint64_t v678 = SHIDWORD(v758) + 16;
      int v679 = v758 << (v678 & 0xF8);
      v680 = (_DWORD *)((char *)v756 + (v678 >> 3));
      v756 = v680;
      char v681 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v680 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v680 = v757;
      }
      unsigned int v682 = *((_DWORD *)v133 + 482);
      LODWORD(v758) = (HIWORD(v682) << (16 - v681)) | v679;
      _DWORD *v680 = bswap32(v758);
      unint64_t v683 = SHIDWORD(v758) + 16;
      int v684 = v758 << (v683 & 0xF8);
      v685 = (_DWORD *)((char *)v756 + (v683 >> 3));
      v756 = v685;
      char v686 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v685 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v685 = v757;
      }
      LODWORD(v758) = ((unsigned __int16)v682 << (16 - v686)) | v684;
      _DWORD *v685 = bswap32(v758);
      unint64_t v687 = SHIDWORD(v758) + 16;
      int v688 = v758 << (v687 & 0xF8);
      v689 = (_DWORD *)((char *)v756 + (v687 >> 3));
      v756 = v689;
      char v690 = BYTE4(v758) & 7;
      HIDWORD(v758) = BYTE4(v758) & 7;
      if (v689 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v689 = v757;
      }
      LODWORD(v758) = (v133[1932] << (v690 ^ 0x1F)) | v688;
      _DWORD *v689 = bswap32(v758);
      unint64_t v691 = SHIDWORD(v758) + 1;
      char v692 = v691 & 0xF8;
      v693 = (_DWORD *)((char *)v756 + (v691 >> 3));
      v756 = v693;
      int v694 = v691 & 7;
      HIDWORD(v758) = v694;
      if (v693 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v693 = v757;
      }
      int v695 = v758 << v692;
      if (v133[1932])
      {
        unsigned int v696 = *((_DWORD *)v133 + 484) + 1;
        unsigned int v697 = __clz(v696);
        unsigned int v698 = (v696 - (0x80000000 >> v697)) | (0x80000000 >> v697);
        uint64_t v699 = 63 - 2 * v697;
        LODWORD(v758) = (v698 << (-(char)v694 - v699)) | v695;
        _DWORD *v693 = bswap32(v758);
        unint64_t v700 = SHIDWORD(v758) + v699;
        int v695 = v758 << (v700 & 0xF8);
        v693 = (_DWORD *)((char *)v756 + (v700 >> 3));
        v756 = v693;
        int v694 = v700 & 7;
        HIDWORD(v758) = v694;
        if (v693 >= v757)
        {
          char v759 = 1;
          v756 = v757;
          v693 = v757;
        }
      }
      LODWORD(v758) = (v133[1940] << (v694 ^ 0x1F)) | v695;
      _DWORD *v693 = bswap32(v758);
      unint64_t v701 = SHIDWORD(v758) + 1;
      unsigned int v672 = v758 << (v701 & 0xF8);
      v670 = (_DWORD *)((char *)v756 + (v701 >> 3));
      v756 = v670;
      unsigned int v671 = v701 & 7;
      unint64_t v758 = __PAIR64__(v671, v672);
      if (v670 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v670 = v757;
      }
      if (v133[1940]) {
        goto LABEL_78;
      }
    }
    LODWORD(v758) = (v133[1976] << (v671 ^ 0x1F)) | v672;
    _DWORD *v670 = bswap32(v758);
    unint64_t v702 = SHIDWORD(v758) + 1;
    v339 = (_DWORD *)((char *)v756 + (v702 >> 3));
    v756 = v339;
    char v340 = v702 & 7;
    HIDWORD(v758) = v702 & 7;
    if (v339 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v339 = v757;
    }
    int v341 = v758 << (v702 & 0xF8);
    if (v133[1976])
    {
      LODWORD(v758) = (v133[1977] << (v340 ^ 0x1F)) | v341;
      _DWORD *v339 = bswap32(v758);
      unint64_t v703 = SHIDWORD(v758) + 1;
      int v704 = v758 << (v703 & 0xF8);
      v705 = (_DWORD *)((char *)v756 + (v703 >> 3));
      v756 = v705;
      int v706 = v703 & 7;
      HIDWORD(v758) = v706;
      if (v705 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v705 = v757;
      }
      LODWORD(v758) = (v133[1978] << (v706 ^ 0x1F)) | v704;
      _DWORD *v705 = bswap32(v758);
      unint64_t v707 = SHIDWORD(v758) + 1;
      int v708 = v758 << (v707 & 0xF8);
      v709 = (_DWORD *)((char *)v756 + (v707 >> 3));
      v756 = v709;
      int v710 = v707 & 7;
      HIDWORD(v758) = v710;
      if (v709 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v709 = v757;
      }
      LODWORD(v758) = (v133[1979] << (v710 ^ 0x1F)) | v708;
      _DWORD *v709 = bswap32(v758);
      unint64_t v711 = SHIDWORD(v758) + 1;
      int v712 = v758 << (v711 & 0xF8);
      v713 = (_DWORD *)((char *)v756 + (v711 >> 3));
      v756 = v713;
      int v714 = v711 & 7;
      HIDWORD(v758) = v714;
      if (v713 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v713 = v757;
      }
      unsigned int v715 = *((_DWORD *)v133 + 495) + 1;
      unsigned int v716 = __clz(v715);
      unsigned int v717 = (v715 - (0x80000000 >> v716)) | (0x80000000 >> v716);
      uint64_t v718 = 63 - 2 * v716;
      LODWORD(v758) = (v717 << (-(char)v714 - v718)) | v712;
      _DWORD *v713 = bswap32(v758);
      unint64_t v719 = SHIDWORD(v758) + v718;
      int v720 = v758 << (v719 & 0xF8);
      v721 = (_DWORD *)((char *)v756 + (v719 >> 3));
      v756 = v721;
      int v722 = v719 & 7;
      HIDWORD(v758) = v722;
      if (v721 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v721 = v757;
      }
      unsigned int v723 = *((_DWORD *)v133 + 496) + 1;
      unsigned int v724 = __clz(v723);
      LODWORD(v758) = (((v723 - (0x80000000 >> v724)) | (0x80000000 >> v724)) << (2 * v724 - 63 - v722)) | v720;
      _DWORD *v721 = bswap32(v758);
      unint64_t v725 = SHIDWORD(v758) + 63 - 2 * v724;
      int v726 = v758 << (v725 & 0xF8);
      v727 = (_DWORD *)((char *)v756 + (v725 >> 3));
      v756 = v727;
      int v728 = v725 & 7;
      HIDWORD(v758) = v728;
      if (v727 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v727 = v757;
      }
      unsigned int v729 = *((_DWORD *)v133 + 497) + 1;
      unsigned int v730 = __clz(v729);
      unsigned int v731 = (v729 - (0x80000000 >> v730)) | (0x80000000 >> v730);
      uint64_t v732 = 63 - 2 * v730;
      LODWORD(v758) = (v731 << (-(char)v732 - v728)) | v726;
      _DWORD *v727 = bswap32(v758);
      unint64_t v733 = SHIDWORD(v758) + v732;
      int v734 = v758 << (v733 & 0xF8);
      v735 = (_DWORD *)((char *)v756 + (v733 >> 3));
      v756 = v735;
      int v736 = v733 & 7;
      HIDWORD(v758) = v736;
      if (v735 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v735 = v757;
      }
      unsigned int v737 = *((_DWORD *)v133 + 498) + 1;
      unsigned int v738 = __clz(v737);
      LODWORD(v758) = (((v737 - (0x80000000 >> v738)) | (0x80000000 >> v738)) << (2 * v738 - 63 - v736)) | v734;
      _DWORD *v735 = bswap32(v758);
      unint64_t v739 = SHIDWORD(v758) + 63 - 2 * v738;
      int v740 = v758 << (v739 & 0xF8);
      v741 = (_DWORD *)((char *)v756 + (v739 >> 3));
      v756 = v741;
      int v742 = v739 & 7;
      HIDWORD(v758) = v742;
      if (v741 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v741 = v757;
      }
      unsigned int v743 = *((_DWORD *)v133 + 499) + 1;
      unsigned int v744 = __clz(v743);
      unsigned int v745 = (v743 - (0x80000000 >> v744)) | (0x80000000 >> v744);
      uint64_t v746 = 63 - 2 * v744;
      LODWORD(v758) = (v745 << (-(char)v746 - v742)) | v740;
      _DWORD *v741 = bswap32(v758);
      unint64_t v747 = SHIDWORD(v758) + v746;
      int v341 = v758 << (v747 & 0xF8);
      v339 = (_DWORD *)((char *)v756 + (v747 >> 3));
      v756 = v339;
      char v340 = v747 & 7;
      HIDWORD(v758) = v747 & 7;
      if (v339 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v339 = v757;
      }
    }
  }
  LODWORD(v758) = (v133[325] << (v340 ^ 0x1F)) | v341;
  _DWORD *v339 = bswap32(v758);
  unint64_t v748 = SHIDWORD(v758) + 1;
  v756 = (_DWORD *)((char *)v756 + (v748 >> 3));
  LODWORD(v758) = v758 << (v748 & 0xF8);
  HIDWORD(v758) = v748 & 7;
  if (v756 >= v757)
  {
    char v759 = 1;
    v756 = v757;
  }
  if (v133[325])
  {
LABEL_78:
    size_t v128 = 0;
    goto LABEL_79;
  }
  sub_1BBA19A20((uint64_t)&v753);
  size_t v128 = off_1EC59CAB8(v764, 0, v755, (char *)v756 - v755, 2);
  *(_DWORD *)(v127 + 12720) += v128;
  v749 = *(FILE **)(v127 + 88);
  if (v749) {
    fwrite(v764, 1uLL, v128, v749);
  }
LABEL_79:
  if (v753) {
    free(v753);
  }
  size_t v751 = v128;
  uint64_t v129 = *(void *)(a1 + 16);
  v753 = 0;
  uint64_t v754 = 0;
  v757 = 0;
  unint64_t v758 = 0;
  v756 = 0;
  if (sub_1BBA195B4(&v753, 1024)) {
    goto LABEL_82;
  }
  v343 = *(unsigned __int8 **)(v129 + 12704);
  _DWORD *v756 = bswap32(v758);
  unint64_t v344 = SHIDWORD(v758) + 1;
  int v345 = v758 << (v344 & 0xF8);
  v346 = (_DWORD *)((char *)v756 + (v344 >> 3));
  v756 = v346;
  int v347 = v344 & 7;
  HIDWORD(v758) = v347;
  if (v346 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v346 = v757;
  }
  LODWORD(v758) = (34 << (26 - v347)) | v345;
  _DWORD *v346 = bswap32(v758);
  unint64_t v348 = SHIDWORD(v758) + 6;
  unsigned int v349 = v758 << (v348 & 0xF8);
  v350 = (_DWORD *)((char *)v756 + (v348 >> 3));
  v756 = v350;
  LODWORD(v758) = v349;
  HIDWORD(v758) = v348 & 7;
  if (v350 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v350 = v757;
  }
  _DWORD *v350 = bswap32(v349);
  unint64_t v351 = SHIDWORD(v758) + 6;
  int v352 = v758 << (v351 & 0xF8);
  v353 = (_DWORD *)((char *)v756 + (v351 >> 3));
  v756 = v353;
  int v354 = v351 & 7;
  HIDWORD(v758) = v354;
  if (v353 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v353 = v757;
  }
  LODWORD(v758) = (1 << (29 - v354)) | v352;
  _DWORD *v353 = bswap32(v758);
  unint64_t v355 = SHIDWORD(v758) + 3;
  int v356 = v758 << (v355 & 0xF8);
  v357 = (_DWORD *)((char *)v756 + (v355 >> 3));
  v756 = v357;
  int v358 = v355 & 7;
  HIDWORD(v758) = v358;
  if (v357 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v357 = v757;
  }
  unsigned int v359 = *v343 + 1;
  unsigned int v360 = __clz(v359);
  unsigned int v361 = 0x80000000 >> v360;
  uint64_t v362 = (2 * v360) ^ 0x3F;
  LODWORD(v758) = (((v359 - v361) | v361) << (-(char)v358 - v362)) | v356;
  _DWORD *v357 = bswap32(v758);
  unint64_t v363 = SHIDWORD(v758) + v362;
  int v364 = v758 << (v363 & 0xF8);
  v365 = (_DWORD *)((char *)v756 + (v363 >> 3));
  v756 = v365;
  int v366 = v363 & 7;
  HIDWORD(v758) = v366;
  if (v365 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v365 = v757;
  }
  unsigned int v367 = v343[1] + 1;
  unsigned int v368 = __clz(v367);
  LODWORD(v758) = (((v367 - (0x80000000 >> v368)) | (0x80000000 >> v368)) << (-((2 * v368) ^ 0x3F) - v366)) | v364;
  _DWORD *v365 = bswap32(v758);
  int v369 = v758 << ((BYTE4(v758) + ((2 * v368) ^ 0x3F)) & 0xF8);
  v370 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v368) ^ 0x3FuLL)) >> 3));
  v756 = v370;
  char v371 = (BYTE4(v758) + ((2 * v368) ^ 0x3F)) & 7;
  LODWORD(v758) = v369;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v368) ^ 0x3F)) & 7;
  if (v370 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v370 = v757;
  }
  uint64_t v372 = *((void *)v343 + 214);
  uint64_t v373 = v343[1];
  v374 = (void *)(v372 + 1552);
  v375 = (void *)(v372 + 16 * v373 + 256);
  if (v373 > 0xF) {
    v375 = v374;
  }
  if (!*v375) {
    goto LABEL_82;
  }
  LODWORD(v758) = (v343[2] << (v371 ^ 0x1F)) | v369;
  _DWORD *v370 = bswap32(v758);
  unint64_t v376 = SHIDWORD(v758) + 1;
  int v377 = v758 << (v376 & 0xF8);
  v378 = (_DWORD *)((char *)v756 + (v376 >> 3));
  v756 = v378;
  int v379 = v376 & 7;
  HIDWORD(v758) = v379;
  if (v378 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v378 = v757;
  }
  LODWORD(v758) = (v343[3] << (v379 ^ 0x1F)) | v377;
  _DWORD *v378 = bswap32(v758);
  unint64_t v380 = SHIDWORD(v758) + 1;
  int v381 = v758 << (v380 & 0xF8);
  v382 = (_DWORD *)((char *)v756 + (v380 >> 3));
  v756 = v382;
  int v383 = v380 & 7;
  HIDWORD(v758) = v383;
  if (v382 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v382 = v757;
  }
  LODWORD(v758) = (v343[4] << (29 - v383)) | v381;
  _DWORD *v382 = bswap32(v758);
  unint64_t v384 = SHIDWORD(v758) + 3;
  int v385 = v758 << (v384 & 0xF8);
  v386 = (_DWORD *)((char *)v756 + (v384 >> 3));
  v756 = v386;
  int v387 = v384 & 7;
  HIDWORD(v758) = v387;
  if (v386 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v386 = v757;
  }
  LODWORD(v758) = (v343[5] << (v387 ^ 0x1F)) | v385;
  _DWORD *v386 = bswap32(v758);
  unint64_t v388 = SHIDWORD(v758) + 1;
  int v389 = v758 << (v388 & 0xF8);
  v390 = (_DWORD *)((char *)v756 + (v388 >> 3));
  v756 = v390;
  int v391 = v388 & 7;
  HIDWORD(v758) = v391;
  if (v390 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v390 = v757;
  }
  LODWORD(v758) = (v343[6] << (v391 ^ 0x1F)) | v389;
  _DWORD *v390 = bswap32(v758);
  unint64_t v392 = SHIDWORD(v758) + 1;
  int v393 = v758 << (v392 & 0xF8);
  v394 = (_DWORD *)((char *)v756 + (v392 >> 3));
  v756 = v394;
  int v395 = v392 & 7;
  HIDWORD(v758) = v395;
  if (v394 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v394 = v757;
  }
  unsigned int v396 = v343[7] + 1;
  unsigned int v397 = __clz(v396);
  unsigned int v398 = 0x80000000 >> v397;
  uint64_t v399 = (2 * v397) ^ 0x3F;
  LODWORD(v758) = (((v396 - v398) | v398) << (-(char)v395 - v399)) | v393;
  _DWORD *v394 = bswap32(v758);
  unint64_t v400 = SHIDWORD(v758) + v399;
  int v401 = v758 << (v400 & 0xF8);
  v402 = (_DWORD *)((char *)v756 + (v400 >> 3));
  v756 = v402;
  int v403 = v400 & 7;
  HIDWORD(v758) = v403;
  if (v402 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v402 = v757;
  }
  unsigned int v404 = v343[8] + 1;
  unsigned int v405 = __clz(v404);
  LODWORD(v758) = (((v404 - (0x80000000 >> v405)) | (0x80000000 >> v405)) << (-((2 * v405) ^ 0x3F) - v403)) | v401;
  _DWORD *v402 = bswap32(v758);
  int v406 = v758 << ((BYTE4(v758) + ((2 * v405) ^ 0x3F)) & 0xF8);
  v407 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v405) ^ 0x3FuLL)) >> 3));
  v756 = v407;
  char v408 = (BYTE4(v758) + ((2 * v405) ^ 0x3F)) & 7;
  HIDWORD(v758) = (HIDWORD(v758) + ((2 * v405) ^ 0x3F)) & 7;
  if (v407 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v407 = v757;
  }
  int v409 = (char)v343[9];
  if (v409 <= 0) {
    int v410 = -2 * v409;
  }
  else {
    int v410 = 2 * v409 - 1;
  }
  unsigned int v411 = v410 + 1;
  unsigned int v412 = __clz(v411);
  unsigned int v413 = (v411 - (0x80000000 >> v412)) | (0x80000000 >> v412);
  uint64_t v414 = 63 - 2 * v412;
  LODWORD(v758) = (v413 << (-v408 - v414)) | v406;
  _DWORD *v407 = bswap32(v758);
  unint64_t v415 = SHIDWORD(v758) + v414;
  int v416 = v758 << (v415 & 0xF8);
  v417 = (_DWORD *)((char *)v756 + (v415 >> 3));
  v756 = v417;
  int v418 = v415 & 7;
  HIDWORD(v758) = v418;
  if (v417 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v417 = v757;
  }
  LODWORD(v758) = (v343[10] << (v418 ^ 0x1F)) | v416;
  _DWORD *v417 = bswap32(v758);
  unint64_t v419 = SHIDWORD(v758) + 1;
  int v420 = v758 << (v419 & 0xF8);
  v421 = (_DWORD *)((char *)v756 + (v419 >> 3));
  v756 = v421;
  int v422 = v419 & 7;
  HIDWORD(v758) = v422;
  if (v421 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v421 = v757;
  }
  LODWORD(v758) = (v343[11] << (v422 ^ 0x1F)) | v420;
  _DWORD *v421 = bswap32(v758);
  unint64_t v423 = SHIDWORD(v758) + 1;
  int v424 = v758 << (v423 & 0xF8);
  v425 = (_DWORD *)((char *)v756 + (v423 >> 3));
  v756 = v425;
  int v426 = v423 & 7;
  HIDWORD(v758) = v426;
  if (v425 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v425 = v757;
  }
  LODWORD(v758) = (v343[12] << (v426 ^ 0x1F)) | v424;
  _DWORD *v425 = bswap32(v758);
  unint64_t v427 = SHIDWORD(v758) + 1;
  char v428 = v427 & 0xF8;
  v429 = (_DWORD *)((char *)v756 + (v427 >> 3));
  v756 = v429;
  int v430 = v427 & 7;
  HIDWORD(v758) = v430;
  if (v429 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v429 = v757;
  }
  int v431 = v758 << v428;
  if (v343[12])
  {
    unsigned int v432 = v343[13] + 1;
    unsigned int v433 = __clz(v432);
    unsigned int v434 = 0x80000000 >> v433;
    uint64_t v435 = (2 * v433) ^ 0x3F;
    LODWORD(v758) = (((v432 - v434) | v434) << (-(char)v430 - v435)) | v431;
    _DWORD *v429 = bswap32(v758);
    unint64_t v436 = SHIDWORD(v758) + v435;
    int v431 = v758 << (v436 & 0xF8);
    v429 = (_DWORD *)((char *)v756 + (v436 >> 3));
    v756 = v429;
    int v430 = v436 & 7;
    HIDWORD(v758) = v430;
    if (v429 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v429 = v757;
    }
  }
  int v437 = (char)v343[14];
  if (v437 <= 0) {
    int v438 = -2 * v437;
  }
  else {
    int v438 = 2 * v437 - 1;
  }
  unsigned int v439 = __clz(v438 + 1);
  unsigned int v440 = (v438 + 1 - (0x80000000 >> v439)) | (0x80000000 >> v439);
  uint64_t v441 = 63 - 2 * v439;
  LODWORD(v758) = (v440 << (-(char)v430 - v441)) | v431;
  _DWORD *v429 = bswap32(v758);
  unint64_t v442 = SHIDWORD(v758) + v441;
  int v443 = v758 << (v442 & 0xF8);
  v444 = (_DWORD *)((char *)v756 + (v442 >> 3));
  v756 = v444;
  int v445 = v442 & 7;
  HIDWORD(v758) = v445;
  if (v444 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v444 = v757;
  }
  int v446 = (char)v343[15];
  if (v446 <= 0) {
    int v447 = -2 * v446;
  }
  else {
    int v447 = 2 * v446 - 1;
  }
  unsigned int v448 = v447 + 1;
  unsigned int v449 = __clz(v448);
  LODWORD(v758) = (((v448 - (0x80000000 >> v449)) | (0x80000000 >> v449)) << (2 * v449 - 63 - v445)) | v443;
  _DWORD *v444 = bswap32(v758);
  unint64_t v450 = SHIDWORD(v758) + 63 - 2 * v449;
  int v451 = v758 << (v450 & 0xF8);
  v452 = (_DWORD *)((char *)v756 + (v450 >> 3));
  v756 = v452;
  int v453 = v450 & 7;
  HIDWORD(v758) = v453;
  if (v452 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v452 = v757;
  }
  LODWORD(v758) = (v343[16] << (v453 ^ 0x1F)) | v451;
  _DWORD *v452 = bswap32(v758);
  unint64_t v454 = SHIDWORD(v758) + 1;
  int v455 = v758 << (v454 & 0xF8);
  v456 = (_DWORD *)((char *)v756 + (v454 >> 3));
  v756 = v456;
  int v457 = v454 & 7;
  HIDWORD(v758) = v457;
  if (v456 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v456 = v757;
  }
  LODWORD(v758) = (v343[17] << (v457 ^ 0x1F)) | v455;
  _DWORD *v456 = bswap32(v758);
  unint64_t v458 = SHIDWORD(v758) + 1;
  int v459 = v758 << (v458 & 0xF8);
  v460 = (_DWORD *)((char *)v756 + (v458 >> 3));
  v756 = v460;
  int v461 = v458 & 7;
  HIDWORD(v758) = v461;
  if (v460 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v460 = v757;
  }
  LODWORD(v758) = (v343[18] << (v461 ^ 0x1F)) | v459;
  _DWORD *v460 = bswap32(v758);
  unint64_t v462 = SHIDWORD(v758) + 1;
  int v463 = v758 << (v462 & 0xF8);
  v464 = (_DWORD *)((char *)v756 + (v462 >> 3));
  v756 = v464;
  int v465 = v462 & 7;
  HIDWORD(v758) = v465;
  if (v464 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v464 = v757;
  }
  LODWORD(v758) = (v343[19] << (v465 ^ 0x1F)) | v463;
  _DWORD *v464 = bswap32(v758);
  unint64_t v466 = SHIDWORD(v758) + 1;
  int v467 = v758 << (v466 & 0xF8);
  v468 = (_DWORD *)((char *)v756 + (v466 >> 3));
  v756 = v468;
  int v469 = v466 & 7;
  HIDWORD(v758) = v469;
  if (v468 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v468 = v757;
  }
  LODWORD(v758) = (v343[20] << (v469 ^ 0x1F)) | v467;
  _DWORD *v468 = bswap32(v758);
  unint64_t v470 = SHIDWORD(v758) + 1;
  int v471 = v758 << (v470 & 0xF8);
  v472 = (_DWORD *)((char *)v756 + (v470 >> 3));
  v756 = v472;
  int v473 = v470 & 7;
  HIDWORD(v758) = v473;
  if (v472 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v472 = v757;
  }
  LODWORD(v758) = (v343[21] << (v473 ^ 0x1F)) | v471;
  _DWORD *v472 = bswap32(v758);
  unint64_t v474 = SHIDWORD(v758) + 1;
  char v475 = v474 & 0xF8;
  v476 = (_DWORD *)((char *)v756 + (v474 >> 3));
  v756 = v476;
  int v477 = v474 & 7;
  HIDWORD(v758) = v477;
  if (v476 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v476 = v757;
  }
  int v478 = v758 << v475;
  if (v343[20])
  {
    unsigned int v479 = *((unsigned __int16 *)v343 + 11) + 1;
    unsigned int v480 = __clz(v479);
    unsigned int v481 = 0x80000000 >> v480;
    uint64_t v482 = (2 * v480) ^ 0x3F;
    LODWORD(v758) = (((v479 - v481) | v481) << (-(char)v477 - v482)) | v478;
    _DWORD *v476 = bswap32(v758);
    unint64_t v483 = SHIDWORD(v758) + v482;
    int v484 = v758 << (v483 & 0xF8);
    v485 = (_DWORD *)((char *)v756 + (v483 >> 3));
    v756 = v485;
    int v486 = v483 & 7;
    HIDWORD(v758) = v486;
    if (v485 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v485 = v757;
    }
    unsigned int v487 = *((unsigned __int16 *)v343 + 12) + 1;
    unsigned int v488 = __clz(v487);
    LODWORD(v758) = (((v487 - (0x80000000 >> v488)) | (0x80000000 >> v488)) << (-((2 * v488) ^ 0x3F) - v486)) | v484;
    _DWORD *v485 = bswap32(v758);
    int v489 = v758 << ((BYTE4(v758) + ((2 * v488) ^ 0x3F)) & 0xF8);
    v490 = (_DWORD *)((char *)v756 + ((SHIDWORD(v758) + ((2 * v488) ^ 0x3FuLL)) >> 3));
    v756 = v490;
    char v491 = (BYTE4(v758) + ((2 * v488) ^ 0x3F)) & 7;
    HIDWORD(v758) = (HIDWORD(v758) + ((2 * v488) ^ 0x3F)) & 7;
    if (v490 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v490 = v757;
    }
    LODWORD(v758) = (v343[26] << (v491 ^ 0x1F)) | v489;
    _DWORD *v490 = bswap32(v758);
    unint64_t v492 = SHIDWORD(v758) + 1;
    unsigned int v493 = v758 << (v492 & 0xF8);
    v494 = (_DWORD *)((char *)v756 + (v492 >> 3));
    v756 = v494;
    unsigned int v495 = v492 & 7;
    HIDWORD(v758) = v495;
    if (v494 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v494 = v757;
    }
    if (!v343[26])
    {
      if (*((_WORD *)v343 + 11))
      {
        unint64_t v496 = 0;
        do
        {
          unsigned int v497 = *(unsigned __int16 *)(*((void *)v343 + 203) + 2 * v496) + 1;
          unsigned int v498 = __clz(v497);
          unsigned int v499 = 0x80000000 >> v498;
          uint64_t v500 = (2 * v498) ^ 0x3F;
          LODWORD(v758) = (((v497 - v499) | v499) << (-(char)v495 - v500)) | v493;
          _DWORD *v494 = bswap32(v758);
          unint64_t v501 = SHIDWORD(v758) + v500;
          unsigned int v493 = v758 << (v501 & 0xF8);
          v494 = (_DWORD *)((char *)v756 + (v501 >> 3));
          v756 = v494;
          unsigned int v495 = v501 & 7;
          unint64_t v758 = __PAIR64__(v495, v493);
          if (v494 >= v757)
          {
            char v759 = 1;
            v756 = v757;
            v494 = v757;
          }
          ++v496;
        }
        while (v496 < *((unsigned __int16 *)v343 + 11));
      }
      if (*((_WORD *)v343 + 12))
      {
        unint64_t v502 = 0;
        do
        {
          unsigned int v503 = *(unsigned __int16 *)(*((void *)v343 + 205) + 2 * v502) + 1;
          unsigned int v504 = __clz(v503);
          unsigned int v505 = 0x80000000 >> v504;
          uint64_t v506 = (2 * v504) ^ 0x3F;
          LODWORD(v758) = (((v503 - v505) | v505) << (-(char)v495 - v506)) | v493;
          _DWORD *v494 = bswap32(v758);
          unint64_t v507 = SHIDWORD(v758) + v506;
          unsigned int v493 = v758 << (v507 & 0xF8);
          v494 = (_DWORD *)((char *)v756 + (v507 >> 3));
          v756 = v494;
          unsigned int v495 = v507 & 7;
          unint64_t v758 = __PAIR64__(v495, v493);
          if (v494 >= v757)
          {
            char v759 = 1;
            v756 = v757;
            v494 = v757;
          }
          ++v502;
        }
        while (v502 < *((unsigned __int16 *)v343 + 12));
      }
    }
    LODWORD(v758) = (v343[27] << (v495 ^ 0x1F)) | v493;
    _DWORD *v494 = bswap32(v758);
    unint64_t v508 = SHIDWORD(v758) + 1;
    int v478 = v758 << (v508 & 0xF8);
    v476 = (_DWORD *)((char *)v756 + (v508 >> 3));
    v756 = v476;
    int v477 = v508 & 7;
    HIDWORD(v758) = v477;
    if (v476 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v476 = v757;
    }
  }
  LODWORD(v758) = (v343[28] << (v477 ^ 0x1F)) | v478;
  _DWORD *v476 = bswap32(v758);
  unint64_t v509 = SHIDWORD(v758) + 1;
  int v510 = v758 << (v509 & 0xF8);
  v511 = (_DWORD *)((char *)v756 + (v509 >> 3));
  v756 = v511;
  int v512 = v509 & 7;
  HIDWORD(v758) = v512;
  if (v511 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v511 = v757;
  }
  LODWORD(v758) = (v343[29] << (v512 ^ 0x1F)) | v510;
  _DWORD *v511 = bswap32(v758);
  unint64_t v515 = SHIDWORD(v758) + 1;
  char v513 = v515 & 0xF8;
  v514 = (_DWORD *)((char *)v756 + (v515 >> 3));
  v756 = v514;
  LODWORD(v515) = v515 & 7;
  HIDWORD(v758) = v515;
  if (v514 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v514 = v757;
  }
  int v516 = v758 << v513;
  if (v343[29])
  {
    LODWORD(v758) = (v343[30] << (v515 ^ 0x1F)) | v516;
    _DWORD *v514 = bswap32(v758);
    unint64_t v517 = SHIDWORD(v758) + 1;
    int v518 = v758 << (v517 & 0xF8);
    v519 = (_DWORD *)((char *)v756 + (v517 >> 3));
    v756 = v519;
    int v520 = v517 & 7;
    HIDWORD(v758) = v520;
    if (v519 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v519 = v757;
    }
    LODWORD(v758) = (v343[31] << (v520 ^ 0x1F)) | v518;
    _DWORD *v519 = bswap32(v758);
    unint64_t v515 = SHIDWORD(v758) + 1;
    char v521 = v515 & 0xF8;
    v514 = (_DWORD *)((char *)v756 + (v515 >> 3));
    v756 = v514;
    LODWORD(v515) = v515 & 7;
    HIDWORD(v758) = v515;
    if (v514 >= v757)
    {
      char v759 = 1;
      v756 = v757;
      v514 = v757;
    }
    int v516 = v758 << v521;
    if (!v343[31])
    {
      int v522 = (char)v343[32];
      if (v522 <= 0) {
        int v523 = -2 * v522;
      }
      else {
        int v523 = 2 * v522 - 1;
      }
      unsigned int v524 = __clz(v523 + 1);
      unsigned int v525 = (v523 + 1 - (0x80000000 >> v524)) | (0x80000000 >> v524);
      uint64_t v526 = 63 - 2 * v524;
      LODWORD(v758) = (v525 << (-(char)v515 - v526)) | v516;
      _DWORD *v514 = bswap32(v758);
      unint64_t v527 = SHIDWORD(v758) + v526;
      int v528 = v758 << (v527 & 0xF8);
      unint64_t v515 = (unint64_t)v756 + (v527 >> 3);
      v756 = (_DWORD *)v515;
      int v529 = v527 & 7;
      HIDWORD(v758) = v529;
      if (v515 >= (unint64_t)v757)
      {
        char v759 = 1;
        v756 = v757;
        unint64_t v515 = (unint64_t)v757;
      }
      int v530 = (char)v343[33];
      if (v530 <= 0) {
        int v531 = -2 * v530;
      }
      else {
        int v531 = 2 * v530 - 1;
      }
      unsigned int v532 = v531 + 1;
      unsigned int v533 = __clz(v532);
      LODWORD(v758) = (((v532 - (0x80000000 >> v533)) | (0x80000000 >> v533)) << (2 * v533 - 63 - v529)) | v528;
      *(_DWORD *)unint64_t v515 = bswap32(v758);
      unint64_t v534 = SHIDWORD(v758) + 63 - 2 * v533;
      int v516 = v758 << (v534 & 0xF8);
      v514 = (_DWORD *)((char *)v756 + (v534 >> 3));
      v756 = v514;
      LOBYTE(v515) = v534 & 7;
      HIDWORD(v758) = v534 & 7;
      if (v514 >= v757)
      {
        char v759 = 1;
        v756 = v757;
        v514 = v757;
      }
    }
  }
  LODWORD(v758) = (v343[34] << (v515 ^ 0x1F)) | v516;
  _DWORD *v514 = bswap32(v758);
  unint64_t v535 = SHIDWORD(v758) + 1;
  unsigned int v536 = v758 << (v535 & 0xF8);
  v537 = (_DWORD *)((char *)v756 + (v535 >> 3));
  v756 = v537;
  unsigned int v538 = v535 & 7;
  unint64_t v758 = __PAIR64__(v538, v536);
  if (v537 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v537 = v757;
  }
  if (v343[34]) {
    goto LABEL_82;
  }
  LODWORD(v758) = (v343[1595] << (v538 ^ 0x1F)) | v536;
  _DWORD *v537 = bswap32(v758);
  unint64_t v539 = SHIDWORD(v758) + 1;
  int v540 = v758 << (v539 & 0xF8);
  v541 = (_DWORD *)((char *)v756 + (v539 >> 3));
  v756 = v541;
  int v542 = v539 & 7;
  HIDWORD(v758) = v542;
  if (v541 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v541 = v757;
  }
  if (*((_WORD *)v343 + 798)) {
    unsigned int v543 = 2 * *((unsigned __int16 *)v343 + 798);
  }
  else {
    unsigned int v543 = 1;
  }
  unsigned int v544 = __clz(v543);
  unsigned int v545 = (v543 - (0x80000000 >> v544)) | (0x80000000 >> v544);
  uint64_t v546 = 63 - 2 * v544;
  LODWORD(v758) = (v545 << (-(char)v542 - v546)) | v540;
  _DWORD *v541 = bswap32(v758);
  unint64_t v547 = SHIDWORD(v758) + v546;
  int v548 = v758 << (v547 & 0xF8);
  v549 = (_DWORD *)((char *)v756 + (v547 >> 3));
  v756 = v549;
  int v550 = v547 & 7;
  HIDWORD(v758) = v550;
  if (v549 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v549 = v757;
  }
  LODWORD(v758) = (v343[1598] << (v550 ^ 0x1F)) | v548;
  _DWORD *v549 = bswap32(v758);
  unint64_t v551 = SHIDWORD(v758) + 1;
  int v552 = v758 << (v551 & 0xF8);
  v553 = (_DWORD *)((char *)v756 + (v551 >> 3));
  v756 = v553;
  int v554 = v551 & 7;
  HIDWORD(v758) = v554;
  if (v553 >= v757)
  {
    char v759 = 1;
    v756 = v757;
    v553 = v757;
  }
  LODWORD(v758) = (v343[1599] << (v554 ^ 0x1F)) | v552;
  _DWORD *v553 = bswap32(v758);
  unint64_t v555 = SHIDWORD(v758) + 1;
  v756 = (_DWORD *)((char *)v756 + (v555 >> 3));
  LODWORD(v758) = v758 << (v555 & 0xF8);
  HIDWORD(v758) = v555 & 7;
  if (v756 >= v757)
  {
    char v759 = 1;
    v756 = v757;
  }
  if (v343[1599])
  {
LABEL_82:
    size_t v130 = 0;
  }
  else
  {
    sub_1BBA19A20((uint64_t)&v753);
    size_t v130 = off_1EC59CAB8(v762, 0, v755, (char *)v756 - v755, 2);
    *(_DWORD *)(v129 + 12720) += v130;
    v556 = *(FILE **)(v129 + 88);
    if (v556) {
      fwrite(v762, 1uLL, v130, v556);
    }
  }
  if (v753) {
    free(v753);
  }
  size_t v750 = v130;
  size_t v131 = v752;
  if (!v752) {
    goto LABEL_2;
  }
  size_t v132 = v751;
  if (!v751 || !v130) {
    goto LABEL_2;
  }
  v751 -= 3;
  v752 -= 3;
  size_t v750 = v130 - 3;
  v753 = (void *)(v7 + v131 - 3 + v132 - 3 + v130 - 3 + 64);
  uint64_t v4 = malloc_type_calloc((size_t)v753, 1uLL, 0x100004077774924uLL);
  if (!v4)
  {
    __int16 VideoFormatDescription = FigSignalErrorAt();
    uint64_t v4 = 0;
    goto LABEL_3;
  }
  __int16 VideoFormatDescription = sub_1BBAE748C(v761, v760, byte_1BBB78124, v4, (size_t *)&v753);
  if (VideoFormatDescription)
  {
    FigSignalErrorAt();
    goto LABEL_3;
  }
  v557 = v753;
  size_t v558 = v7 + 1;
  memcpy((char *)v753 + (void)v4, v2, v558);
  CFIndex v559 = (CFIndex)v557 + v558;
  CFAllocatorRef v560 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v561 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v4, v559);
  if (!v561)
  {
    __int16 VideoFormatDescription = FigSignalErrorAt();
    goto LABEL_3;
  }
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v560, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable && (v563 = CFDictionaryCreateMutable(v560, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) != 0)
  {
    CFDictionaryAddValue(Mutable, @"ftvH", v561);
    CFDictionaryAddValue(Mutable, @"hvcC", v561);
    CFDictionaryAddValue(v563, (const void *)*MEMORY[0x1E4F1EE20], Mutable);
    CFDictionaryAddValue(v563, (const void *)*MEMORY[0x1E4F1EDA8], @"LRP");
    v564 = *(const void **)(a1 + 288);
    if (v564) {
      CFDictionaryAddValue(v563, (const void *)*MEMORY[0x1E4F24A90], v564);
    }
    v565 = *(const void **)(a1 + 296);
    if (v565) {
      CFDictionaryAddValue(v563, (const void *)*MEMORY[0x1E4F24BC8], v565);
    }
    v566 = *(const void **)(a1 + 304);
    if (v566) {
      CFDictionaryAddValue(v563, (const void *)*MEMORY[0x1E4F24C18], v566);
    }
    __int16 VideoFormatDescription = VTEncoderSessionCreateVideoFormatDescription();
    if (VideoFormatDescription) {
      FigSignalErrorAt();
    }
  }
  else
  {
    __int16 VideoFormatDescription = FigSignalErrorAt();
    v563 = 0;
  }
  free(v4);
  CFRelease(v561);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v563) {
    CFRelease(v563);
  }
  return VideoFormatDescription;
}

void sub_1BB9F7CDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  if (a13) {
    free(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BB9F7D10(uint64_t a1, uint64_t a2, int a3, const opaqueCMFormatDescription *a4, uint64_t a5, OpaqueCMBlockBuffer *a6, uint64_t *a7, uint64_t *a8)
{
  dataPointerOut[1] = *(char **)MEMORY[0x1E4F143B8];
  double v84 = -1.0;
  uint64_t v96 = 0;
  uint64_t v97 = 0;
  uint64_t v98 = 0;
  __asm { FMOV            V0.4S, #-1.0 }
  long long v95 = _Q0;
  uint64_t v15 = *(void *)(a1 + 16);
  if (!*(unsigned char *)(v15 + 3786))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.duration.CFDictionaryAddValue(theDict, key, value) = 0;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Wrong output bitstream format", (uint8_t *)&buf, 2u);
    }
    goto LABEL_18;
  }
  uint64_t v21 = *(void *)(v15 + 1168);
  if (!v21)
  {
LABEL_15:
    uint64_t v25 = *a8;
    if (*a8) {
      goto LABEL_16;
    }
LABEL_20:
    int v28 = 0;
    unsigned int v27 = 0;
    unint64_t v26 = 0;
    goto LABEL_21;
  }
  sub_1BBAC8868(*(void *)(v15 + 1168), (uint64_t *)"encoded_frames", 1.0);
  if (!*a8) {
    goto LABEL_20;
  }
  LODWORD(v22) = *(_DWORD *)(*a8 + 272);
  sub_1BBAC89D8(v21, (uint64_t *)"target_bitrate", (double)v22);
  if (*(unsigned char *)(*a8 + 111))
  {
    int v23 = "dropped_frames";
    double v24 = 1.0;
  }
  else
  {
    sub_1BBAC8868(v21, (uint64_t *)"transmit_frames", 1.0);
    sub_1BBAC8868(v21, (uint64_t *)"encoded_bits", (double)(unint64_t)(8 * *(void *)(*a8 + 40)));
    sub_1BBAC8868(v21, (uint64_t *)"header_bits", (double)*(int *)(*a8 + 12));
    sub_1BBAC8868(v21, (uint64_t *)"fec_bits", (double)*(int *)(*a8 + 8));
    sub_1BBAC8868(v21, (uint64_t *)"rtx_bits", (double)*(int *)(*a8 + 20));
    sub_1BBAC8868(v21, (uint64_t *)"encoding_time", *(double *)(*a8 + 280));
    sub_1BBAC8868(v21, (uint64_t *)"frame_qp", *(float *)(*a8 + 116));
    double v24 = (double)*(unint64_t *)(*a8 + 48);
    int v23 = "min_frame_size";
  }
  sub_1BBAC8868(v21, (uint64_t *)v23, v24);
  uint64_t v25 = *a8;
  if (*(unsigned char *)(*a8 + 276))
  {
    sub_1BBAC8868(v21, (uint64_t *)"repeated_frames", 1.0);
    uint64_t v25 = *a8;
  }
  if (*(unsigned char *)(v25 + 109))
  {
    sub_1BBAC8868(v21, (uint64_t *)"idr_frames", 1.0);
    uint64_t v25 = *a8;
  }
  if (*(unsigned char *)(v25 + 108))
  {
    sub_1BBAC8868(v21, (uint64_t *)"refresh_frames", 1.0);
    goto LABEL_15;
  }
LABEL_16:
  unint64_t v26 = *(void *)(v25 + 40);
  unsigned int v27 = *(char *)(v25 + 32);
  int v28 = *(_DWORD *)(v25 + 132);
  double v84 = *(float *)(v25 + 116);
  if (HIDWORD(v26))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      int v75 = *(_DWORD *)(a1 + 48);
      if (v75 == 1684632424 || v75 == 1752589105 || v75 == 1718908520) {
        unsigned int v76 = "HEVC";
      }
      else {
        unsigned int v76 = "H.264";
      }
      LODWORD(buf.duration.CFDictionaryAddValue(theDict, key, value) = 136315650;
      *(CMTimeValue *)((char *)&buf.duration.value + 4) = (CMTimeValue)v76;
      LOWORD(buf.duration.flags) = 2048;
      *(void *)((char *)&buf.duration.flags + 2) = v26;
      HIWORD(buf.duration.epoch) = 1024;
      LODWORD(buf.presentationTimeStamp.CFDictionaryAddValue(theDict, key, value) = -12911;
      _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s: compressed NALU is too large, CGSize size = %zu, err = %d\n", (uint8_t *)&buf, 0x1Cu);
    }
    goto LABEL_18;
  }
LABEL_21:
  *(_OWORD *)&buf.duration.CFMutableDictionaryRef value = *(_OWORD *)(a2 + 40);
  CMTimeEpoch v30 = *(void *)(a2 + 56);
  *(_OWORD *)&buf.presentationTimeStamp.CFMutableDictionaryRef value = *(_OWORD *)(a2 + 16);
  CMTimeEpoch v31 = *(void *)(a2 + 32);
  buf.duration.CMTimeEpoch epoch = v30;
  buf.presentationTimeStamp.CMTimeEpoch epoch = v31;
  VTEncoderSessionDequeueDecodeTimeStamp();
  if (a3 || !a6 || !v26)
  {
LABEL_18:
    VTEncoderSessionEmitEncodedFrame();
    return MEMORY[0x1C18605E0](a2, 0x1020C40C238D3BALL);
  }
  if (*(unsigned char *)(a1 + 1384))
  {
    if (!*(void *)(a1 + 8))
    {
      CMFormatDescriptionGetExtensions(a4);
      if (VTEncoderSessionCreateVideoFormatDescription())
      {
        CFRetain(a4);
        *(void *)(a1 + 8) = a4;
      }
    }
  }
  if (v27 > 1)
  {
    uint64_t v32 = *a7;
    BOOL v33 = (v27 & 0xFFFFFFFE) == 2 && *(_DWORD *)(v32 + 36) != 0;
  }
  else
  {
    uint64_t v32 = *a7;
    BOOL v33 = 1;
  }
  uint64_t v34 = 0;
  BOOL v80 = v33;
  BOOL v77 = v27 == 0;
  BOOL v78 = v27 == 1;
  BOOL v79 = v27 == 0;
  BOOL v82 = *(_DWORD *)(v32 + 40) == 1;
  char v83 = *(unsigned char *)(v32 + 44);
  v85[0] = *(_DWORD *)(v32 + 8);
  uint64_t v89 = *(void *)(v32 + 240);
  unsigned int v90 = *(_DWORD *)(v32 + 12);
  uint64_t v35 = *a8;
  long long v87 = *(_OWORD *)(*a8 + 288);
  v88[0] = *(double *)(v35 + 304);
  uint64_t v36 = *(void *)(a1 + 16);
  int v37 = *(unsigned __int8 *)(v36 + 1016);
  if (!*(unsigned char *)(v36 + 1016)) {
    goto LABEL_33;
  }
LABEL_32:
  unsigned int v38 = 5;
  while (v38 > v34)
  {
    v86[v34] = *((float *)&v95 + v34);
    ++v34;
    if (v37) {
      goto LABEL_32;
    }
LABEL_33:
    if (*(_DWORD *)(v36 + 3248) == 43) {
      unsigned int v38 = 10;
    }
    else {
      unsigned int v38 = 4;
    }
  }
  CMSampleBufferRef sbuf = 0;
  CMBlockBufferRef theBuffer = 0;
  size_t v39 = CMBlockBufferGetDataLength(a6);
  dataCFIndex Length = v39;
  CFAllocatorRef v40 = *(const __CFAllocator **)(a1 + 360);
  if (!v40)
  {
    CFRetain(a6);
    CMBlockBufferRef theBuffer = a6;
    CFAllocatorRef v41 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    goto LABEL_44;
  }
  dataPointerOut[0] = 0;
  CFAllocatorRef v41 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  OSStatus v42 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v39, v40, 0, 0, v39, 1u, &theBuffer);
  if (v42)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int16 valuePtr = 67109120;
      *(_DWORD *)&valuePtr[4] = v42;
      unint64_t v43 = MEMORY[0x1E4F14500];
      unint64_t v44 = "Block buffer creation failed, err = %d";
LABEL_78:
      int v46 = valuePtr;
      goto LABEL_79;
    }
    goto LABEL_116;
  }
  OSStatus DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, dataPointerOut);
  if (!DataPointer)
  {
    OSStatus v59 = CMBlockBufferCopyDataBytes(a6, 0, dataLength, dataPointerOut[0]);
    if (v59)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int16 valuePtr = 67109120;
        *(_DWORD *)&valuePtr[4] = v59;
        unint64_t v43 = MEMORY[0x1E4F14500];
        unint64_t v44 = "Block buffer CopyDataBytes failed, err = %d";
        goto LABEL_78;
      }
      goto LABEL_116;
    }
    a6 = theBuffer;
LABEL_44:
    OSStatus v45 = CMSampleBufferCreate(v41, a6, 1u, 0, 0, *(CMFormatDescriptionRef *)(a1 + 8), 1, 1, &buf, 1, &dataLength, &sbuf);
    if (!v45)
    {
      CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbuf, 1u);
      CFDictionaryRef ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
      if (v82)
      {
        CFNumberRef v50 = CFNumberCreate(v41, kCFNumberIntType, v85);
        unsigned int v51 = (const void **)MEMORY[0x1E4F453C0];
        if (!*(_DWORD *)(a1 + 1456)) {
          unsigned int v51 = (const void **)MEMORY[0x1E4F453B8];
        }
        CFDictionarySetValue(ValueAtIndex, *v51, v50);
        CFRelease(v50);
      }
      if (v83 && v27) {
        CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F453B0], (const void *)*MEMORY[0x1E4F1CFD0]);
      }
      if (*(int *)(a1 + 56) >= 2 && v90 <= 6)
      {
        CFNumberRef v52 = CFNumberCreate(v41, kCFNumberSInt32Type, &v90);
        CFDictionarySetValue(ValueAtIndex, @"TemporalID", v52);
        CFRelease(v52);
      }
      if (v86[0] > 0.0 || v86[1] > 0.0 || v86[2] > 0.0)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
        if (Mutable)
        {
          unint64_t v54 = 0;
          for (unsigned int i = v86; ; ++i)
          {
            uint64_t v56 = *(void *)(a1 + 16);
            if (*(unsigned char *)(v56 + 1016)) {
              unint64_t v57 = 5;
            }
            else {
              unint64_t v57 = *(_DWORD *)(v56 + 3248) == 43 ? 10 : 4;
            }
            if (v54 >= v57) {
              break;
            }
            CFNumberRef v58 = CFNumberCreate(0, kCFNumberFloat32Type, i);
            if (v58)
            {
              CFArrayAppendValue(Mutable, v58);
              CFRelease(v58);
            }
            ++v54;
          }
          CFDictionarySetValue(ValueAtIndex, @"PSNRArray", Mutable);
          CFRelease(Mutable);
        }
      }
      unsigned int v60 = (const void **)MEMORY[0x1E4F1CFC8];
      if (v28 <= 0)
      {
        unint64_t v62 = (const void *)*MEMORY[0x1E4F1CFD0];
      }
      else
      {
        LODWORD(dataPointerOut[0]) = v28;
        *(_DWORD *)__int16 valuePtr = 0;
        CFNumberRef v61 = CFNumberCreate(v41, kCFNumberSInt32Type, valuePtr);
        if (v61)
        {
          CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F45380], v61);
          CFRelease(v61);
        }
        unint64_t v62 = (const void *)*MEMORY[0x1E4F1CFD0];
        CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F45388], (const void *)*MEMORY[0x1E4F1CFD0]);
        CFNumberRef v63 = CFNumberCreate(v41, kCFNumberSInt32Type, dataPointerOut);
        if (v63)
        {
          CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F45390], v63);
          CFRelease(v63);
        }
      }
      if (!v79) {
        CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F200], v62);
      }
      int v64 = *v60;
      if (v80) {
        unsigned int v65 = v62;
      }
      else {
        unsigned int v65 = v64;
      }
      CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F1F8], v65);
      if (v77 || v78) {
        unsigned int v66 = v64;
      }
      else {
        unsigned int v66 = v62;
      }
      CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F1A8], v66);
      if (v84 > 0.0)
      {
        dataPointerOut[0] = *(char **)&v84;
        CFNumberRef v67 = CFNumberCreate(0, kCFNumberDoubleType, dataPointerOut);
        if (v67)
        {
          CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F45370], v67);
          CFRelease(v67);
        }
      }
      if (*(double *)&v87 >= 0.0 && *((double *)&v87 + 1) >= 0.0 && v88[0] >= 0.0)
      {
        dataPointerOut[0] = (char *)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        *(void *)__int16 valuePtr = 0;
        CFNumberRef v68 = CFNumberCreate(0, kCFNumberDoubleType, &v87);
        CFNumberRef v91 = v68;
        if (*(void *)valuePtr) {
          CFRelease(*(CFTypeRef *)valuePtr);
        }
        *(void *)__int16 valuePtr = v68;
        CFNumberRef v91 = 0;
        sub_1BB9BE1F4((const void **)&v91);
        CFDictionarySetValue((CFMutableDictionaryRef)dataPointerOut[0], (const void *)*MEMORY[0x1E4F45410], *(const void **)valuePtr);
        CFNumberRef v69 = CFNumberCreate(0, kCFNumberDoubleType, (char *)&v87 + 8);
        CFNumberRef v91 = v69;
        if (*(void *)valuePtr) {
          CFRelease(*(CFTypeRef *)valuePtr);
        }
        *(void *)__int16 valuePtr = v69;
        CFNumberRef v91 = 0;
        sub_1BB9BE1F4((const void **)&v91);
        CFDictionarySetValue((CFMutableDictionaryRef)dataPointerOut[0], (const void *)*MEMORY[0x1E4F453E0], *(const void **)valuePtr);
        CFNumberRef v70 = CFNumberCreate(0, kCFNumberDoubleType, v88);
        CFNumberRef v91 = v70;
        if (*(void *)valuePtr) {
          CFRelease(*(CFTypeRef *)valuePtr);
        }
        *(void *)__int16 valuePtr = v70;
        CFNumberRef v91 = 0;
        sub_1BB9BE1F4((const void **)&v91);
        CFDictionarySetValue((CFMutableDictionaryRef)dataPointerOut[0], (const void *)*MEMORY[0x1E4F453E8], *(const void **)valuePtr);
        CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F453A8], dataPointerOut[0]);
        sub_1BB9BE1F4((const void **)valuePtr);
        sub_1BB9BE228((const void **)dataPointerOut);
      }
      if (v81) {
        BOOL v71 = v62;
      }
      else {
        BOOL v71 = v64;
      }
      CFDictionarySetValue(ValueAtIndex, (const void *)*MEMORY[0x1E4F1F1C0], v71);
      if ((int)v89 >= 1 && SHIDWORD(v89) >= 1)
      {
        CFNumberRef v72 = CFNumberCreate(v41, kCFNumberSInt32Type, &v89);
        CFNumberRef v73 = CFNumberCreate(v41, kCFNumberSInt32Type, (char *)&v89 + 4);
        if (v72)
        {
          CFNumberRef v74 = v73;
          if (v73)
          {
            CFDictionarySetValue(ValueAtIndex, @"VRAWidth", v72);
            CFDictionarySetValue(ValueAtIndex, @"VRAHeight", v74);
            CFRelease(v72);
            CFRelease(v74);
          }
        }
      }
      goto LABEL_116;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      LODWORD(dataPointerOut[0]) = 67109120;
      HIDWORD(dataPointerOut[0]) = v45;
      unint64_t v43 = MEMORY[0x1E4F14500];
      unint64_t v44 = "Sample buffer creation failed, err = %d";
      int v46 = (uint8_t *)dataPointerOut;
LABEL_79:
      _os_log_error_impl(&dword_1BB9B9000, v43, OS_LOG_TYPE_ERROR, v44, v46, 8u);
      goto LABEL_116;
    }
    goto LABEL_116;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int16 valuePtr = 67109120;
    *(_DWORD *)&valuePtr[4] = DataPointer;
    unint64_t v43 = MEMORY[0x1E4F14500];
    unint64_t v44 = "Block buffer GetDataPointer failed, err = %d";
    goto LABEL_78;
  }
LABEL_116:
  VTEncoderSessionEmitEncodedFrame();
  if (theBuffer)
  {
    CFRelease(theBuffer);
    CMBlockBufferRef theBuffer = 0;
  }
  if (sbuf) {
    CFRelease(sbuf);
  }
  return MEMORY[0x1C18605E0](a2, 0x1020C40C238D3BALL);
}

void sub_1BB9F8A38(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_1BB9BE110(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BB9F8A80(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4)
{
  int v5 = a3;
  unint64_t v7 = HIDWORD(a3);
  VTVideoEncoderGetCMBaseObject();
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *(void *)uint64_t DerivedStorage = a2;
  *(_DWORD *)(DerivedStorage + 340) = v5;
  *(_DWORD *)(DerivedStorage + 344) = v7;
  size_t v9 = *(const void **)(DerivedStorage + 360);
  if (v9) {
    CFRelease(v9);
  }
  *(void *)(DerivedStorage + 360) = a4;
  if (a4) {
    CFRetain(a4);
  }
  FigFormatDescriptionRelease();
  *(void *)(DerivedStorage + 8) = 0;
  *(_DWORD *)(DerivedStorage + 1372) = 0;
  int v10 = *(_DWORD *)(DerivedStorage + 48);

  return sub_1BBA15714(v5, v7, 0, v10);
}

uint64_t sub_1BB9F8B24(uint64_t a1, const void *a2, const __CFString *a3)
{
  uint64_t v138 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44B68]))
  {
    if (a3)
    {
      CFTypeID TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(a3))
      {
        CFTypeID v7 = CFGetTypeID(a3);
        if (v7 == CFNumberGetTypeID()) {
          CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, (void *)(DerivedStorage + 240));
        }
        if (*(_DWORD *)(DerivedStorage + 240) == 43)
        {
          uint64_t result = 0;
          *(_DWORD *)(DerivedStorage + 1488) = 3;
          return result;
        }
        return 0;
      }
    }
    goto LABEL_321;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F447E8]))
  {
    if (a3)
    {
      CFTypeID v9 = CFBooleanGetTypeID();
      if (v9 == CFGetTypeID(a3))
      {
        CFTypeID v10 = CFGetTypeID(a3);
        BOOL v11 = v10 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a3) != 0;
        uint64_t result = 0;
        *(_DWORD *)(DerivedStorage + 244) = v11;
        return result;
      }
    }
    goto LABEL_321;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F447D0]))
  {
    if (a3)
    {
      CFTypeID v12 = CFBooleanGetTypeID();
      if (v12 == CFGetTypeID(a3))
      {
        CFTypeID v13 = CFGetTypeID(a3);
        BOOL v14 = v13 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a3) != 0;
        uint64_t result = 0;
        *(_DWORD *)(DerivedStorage + 248) = v14;
        return result;
      }
    }
    goto LABEL_321;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F449C8]))
  {
    if (a3)
    {
      CFTypeID v15 = CFNumberGetTypeID();
      if (v15 == CFGetTypeID(a3))
      {
        unsigned int v16 = (void *)(DerivedStorage + 256);
LABEL_22:
        CFStringRef v17 = a3;
        CFNumberType v18 = kCFNumberSInt32Type;
LABEL_30:
        sub_1BB9FA7B0(v17, v18, v16);
        return 0;
      }
    }
    goto LABEL_321;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F449D0]))
  {
    if (!a3) {
      goto LABEL_321;
    }
    CFTypeID v19 = CFNumberGetTypeID();
    if (v19 != CFGetTypeID(a3)) {
      goto LABEL_321;
    }
    unsigned int v16 = (void *)(DerivedStorage + 264);
LABEL_29:
    CFStringRef v17 = a3;
    CFNumberType v18 = kCFNumberDoubleType;
    goto LABEL_30;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A40]))
  {
    if (a3)
    {
      CFTypeID v20 = CFNumberGetTypeID();
      if (v20 == CFGetTypeID(a3))
      {
        unsigned int v16 = (void *)(DerivedStorage + 56);
        goto LABEL_22;
      }
    }
LABEL_321:
    return FigSignalErrorAt();
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44810]))
  {
    if (!a3) {
      goto LABEL_321;
    }
    CFTypeID v21 = CFNumberGetTypeID();
    if (v21 != CFGetTypeID(a3)) {
      goto LABEL_321;
    }
    *(_DWORD *)CMSampleTimingInfo buf = 0;
    sub_1BB9FA7B0(a3, kCFNumberSInt32Type, buf);
    uint64_t result = 0;
    int v22 = *(_DWORD *)buf;
    *(double *)(DerivedStorage + 96) = (double)*(int *)buf * 0.125;
    *(void *)(DerivedStorage + 160) = 0x3FF0000000000000;
    *(_DWORD *)(DerivedStorage + 52) = v22;
LABEL_43:
    *(unsigned char *)(DerivedStorage + 224) = 1;
    return result;
  }
  if (CFEqual(a2, @"BPictures"))
  {
    if (a3)
    {
      CFTypeID v23 = CFNumberGetTypeID();
      if (v23 == CFGetTypeID(a3))
      {
        unsigned int v16 = (void *)(DerivedStorage + 252);
        goto LABEL_22;
      }
    }
    goto LABEL_321;
  }
  if (CFEqual(a2, @"NegotiationDetailsBitField"))
  {
    *(unsigned char *)(DerivedStorage + 368) = 0;
    if (!a3) {
      return 0;
    }
    CFTypeID v24 = CFDataGetTypeID();
    if (v24 != CFGetTypeID(a3)) {
      return 0;
    }
    uint64_t v25 = (char *)(DerivedStorage + 368);
    unint64_t v26 = "FLBA;";
    goto LABEL_56;
  }
  if (CFEqual(a2, @"NegotiatedFLB"))
  {
    *(unsigned char *)(DerivedStorage + 368) = 0;
    if (!a3) {
      return 0;
    }
    CFTypeID v27 = CFDataGetTypeID();
    if (v27 != CFGetTypeID(a3)) {
      return 0;
    }
    uint64_t v25 = (char *)(DerivedStorage + 368);
    unint64_t v26 = "FLBN;";
LABEL_56:
    sub_1BBAB0D58((const __CFData *)a3, v26, v25, 1000);
    return 0;
  }
  if (!CFEqual(a2, @"AverageTemporalBitRates"))
  {
    if (CFEqual(a2, @"MaxRefreshFrameIntervalDuration"))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v33 = CFNumberGetTypeID();
      if (v33 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      unsigned int v16 = (void *)(DerivedStorage + 272);
      goto LABEL_29;
    }
    if (CFEqual(a2, @"ThermalLevel"))
    {
      if (a3)
      {
        CFTypeID v34 = CFNumberGetTypeID();
        if (v34 == CFGetTypeID(a3))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 0;
          sub_1BB9FA7B0(a3, kCFNumberSInt32Type, buf);
          uint64_t result = 0;
          *(_DWORD *)(DerivedStorage + 1372) = *(_DWORD *)buf;
          return result;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44870]))
    {
      if (a3)
      {
        CFTypeID v35 = CFNumberGetTypeID();
        if (v35 == CFGetTypeID(a3))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 0;
          sub_1BB9FA7B0(a3, kCFNumberSInt32Type, buf);
          uint64_t result = 0;
          *(_DWORD *)(DerivedStorage + 228) = *(_DWORD *)buf;
          return result;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, @"AverageBitRateIntraLayer"))
    {
      if (a3)
      {
        CFTypeID v36 = CFNumberGetTypeID();
        if (v36 == CFGetTypeID(a3))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 0;
          sub_1BB9FA7B0(a3, kCFNumberSInt32Type, buf);
          uint64_t result = 0;
          *(_DWORD *)(DerivedStorage + 92) = *(_DWORD *)buf;
          return result;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, @"Foveation"))
    {
      if (a3)
      {
        CFTypeID v37 = CFBooleanGetTypeID();
        if (v37 == CFGetTypeID(a3))
        {
          BOOL v38 = sub_1BB9FA820(a3);
          uint64_t result = 0;
          *(unsigned char *)(DerivedStorage + 1455) = v38;
          return result;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A38]))
    {
      if (!a3) {
        return 0;
      }
      CFTypeID v39 = CFNumberGetTypeID();
      if (v39 != CFGetTypeID(a3)) {
        return 0;
      }
      *(_DWORD *)CMSampleTimingInfo buf = 1;
      sub_1BB9FA7B0(a3, kCFNumberSInt32Type, buf);
      uint64_t result = 0;
      int v40 = *(_DWORD *)buf;
      if (*(int *)buf <= 1) {
        int v40 = 1;
      }
      *(_DWORD *)(DerivedStorage + 1380) = v40;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44898]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v41 = CFArrayGetTypeID();
      if (v41 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      CFIndex Count = CFArrayGetCount((CFArrayRef)a3);
      uint64_t v43 = Count >> 1;
      if (Count < 18)
      {
        uint64_t v44 = Count >> 1;
        if (Count < 2)
        {
LABEL_139:
          uint64_t result = 0;
          goto LABEL_43;
        }
      }
      else if (dword_1E9F80A90 < 2)
      {
        uint64_t v44 = 8;
      }
      else
      {
        uint64_t v44 = 8;
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "DataRateLimitsCFIndex Count = %d -> we are able to read only %d", v43, 8);
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v43;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = 8;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "DataRateLimitsCFIndex Count = %d -> we are able to read only %d", buf, 0xEu);
        }
      }
      unsigned __int8 v48 = (double *)(DerivedStorage + 160);
      CFIndex v49 = 1;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, v49 - 1);
        if (!ValueAtIndex) {
          FigSignalErrorAt();
        }
        CFTypeID v51 = CFNumberGetTypeID();
        if (v51 != CFGetTypeID(ValueAtIndex)) {
          FigSignalErrorAt();
        }
        CFNumberType Type = CFNumberGetType((CFNumberRef)ValueAtIndex);
        if (Type == kCFNumberSInt64Type) {
          break;
        }
        if (Type == kCFNumberFloat64Type)
        {
          *(void *)CMSampleTimingInfo buf = 0;
          CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberFloat64Type, buf);
          double v53 = *(double *)buf;
LABEL_126:
          *(v48 - 8) = v53;
          goto LABEL_128;
        }
        FigSignalErrorAt();
LABEL_128:
        unint64_t v54 = CFArrayGetValueAtIndex((CFArrayRef)a3, v49);
        if (!v54) {
          FigSignalErrorAt();
        }
        CFTypeID v55 = CFNumberGetTypeID();
        if (v55 != CFGetTypeID(v54)) {
          FigSignalErrorAt();
        }
        CFNumberType v56 = CFNumberGetType((CFNumberRef)v54);
        if (v56 == kCFNumberSInt64Type)
        {
          *(void *)CMSampleTimingInfo buf = 0;
          CFNumberGetValue((CFNumberRef)v54, kCFNumberSInt64Type, buf);
          double v57 = (double)*(uint64_t *)buf;
        }
        else
        {
          if (v56 != kCFNumberFloat64Type)
          {
            FigSignalErrorAt();
            goto LABEL_138;
          }
          *(void *)CMSampleTimingInfo buf = 0;
          CFNumberGetValue((CFNumberRef)v54, kCFNumberFloat64Type, buf);
          double v57 = *(double *)buf;
        }
        *unsigned __int8 v48 = v57;
LABEL_138:
        ++v48;
        v49 += 2;
        if (!--v44) {
          goto LABEL_139;
        }
      }
      *(void *)CMSampleTimingInfo buf = 0;
      CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberSInt64Type, buf);
      double v53 = (double)*(uint64_t *)buf;
      goto LABEL_126;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F448F0]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v45 = CFNumberGetTypeID();
      if (v45 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      unsigned int v16 = (void *)(DerivedStorage + 24);
      goto LABEL_29;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44920]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v46 = CFStringGetTypeID();
      if (v46 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      return sub_1BB9FA86C(DerivedStorage, a3);
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44830]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v47 = CFNumberGetTypeID();
      if (v47 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      unsigned int v16 = (void *)(DerivedStorage + 32);
      goto LABEL_29;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44820]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v58 = CFNumberGetTypeID();
      if (v58 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      unsigned int v16 = (void *)(DerivedStorage + 40);
      goto LABEL_29;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F449B8]))
    {
      if (a3)
      {
        CFTypeID v59 = CFNumberGetTypeID();
        if (v59 == CFGetTypeID(a3))
        {
          unsigned int v16 = (void *)(DerivedStorage + 1460);
          goto LABEL_22;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F449E0]))
    {
      if (a3)
      {
        CFTypeID v60 = CFNumberGetTypeID();
        if (v60 == CFGetTypeID(a3))
        {
          unsigned int v16 = (void *)(DerivedStorage + 1464);
          goto LABEL_22;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44AC8]))
    {
      if (a3)
      {
        CFTypeID v61 = CFNumberGetTypeID();
        if (v61 == CFGetTypeID(a3))
        {
          unsigned int v16 = (void *)(DerivedStorage + 1468);
          goto LABEL_22;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44840]))
    {
      if (a3)
      {
        CFTypeID v62 = CFBooleanGetTypeID();
        if (v62 == CFGetTypeID(a3))
        {
          BOOL v63 = sub_1BB9FA820(a3);
          uint64_t result = 0;
          *(unsigned char *)(DerivedStorage + 1454) = v63;
          return result;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F448A0]))
    {
      if (a3)
      {
        CFNumberGetTypeID();
        CFGetTypeID(a3);
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44AA0]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v64 = CFStringGetTypeID();
      if (v64 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      uint64_t v65 = DerivedStorage;
      CFStringRef v66 = a3;
      goto LABEL_168;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44B18]))
    {
      if (a3)
      {
        CFTypeID v67 = CFNumberGetTypeID();
        if (v67 == CFGetTypeID(a3))
        {
          unsigned int v16 = (void *)(DerivedStorage + 280);
          goto LABEL_22;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A60]))
    {
      if (!a3)
      {
        uint64_t result = 0;
        *(void *)(DerivedStorage + 332) = 0x100000001;
        return result;
      }
      CFTypeID v68 = CFDictionaryGetTypeID();
      if (v68 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      CFNumberRef v69 = CFDictionaryGetValue((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E4F24B90]);
      CFNumberRef v70 = CFDictionaryGetValue((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E4F24BA0]);
      if (!v69) {
        goto LABEL_321;
      }
      BOOL v71 = v70;
      CFTypeID v72 = CFNumberGetTypeID();
      if (v72 != CFGetTypeID(v69)) {
        goto LABEL_321;
      }
      if (!v71) {
        goto LABEL_321;
      }
      CFTypeID v73 = CFNumberGetTypeID();
      if (v73 != CFGetTypeID(v71)) {
        goto LABEL_321;
      }
      *(_DWORD *)CMSampleTimingInfo buf = 0;
      LODWORD(CFDictionaryAddValue(theDict, key, value) = 0;
      sub_1BB9FA7B0(v69, kCFNumberIntType, buf);
      sub_1BB9FA7B0(v71, kCFNumberIntType, &value);
      if (*(int *)buf > 0)
      {
        int v74 = (int)value;
        if ((int)value >= 1)
        {
          unsigned int v75 = *(_DWORD *)buf;
          unsigned int v76 = value;
          do
          {
            if ((int)v75 <= (int)v76) {
              v76 %= v75;
            }
            else {
              v75 %= v76;
            }
          }
          while (v75 && v76);
          uint64_t result = 0;
          if (!v75) {
            unsigned int v75 = v76;
          }
          *(_DWORD *)(DerivedStorage + 332) = *(_DWORD *)buf / v75;
          *(_DWORD *)(DerivedStorage + 336) = v74 / (int)v75;
          return result;
        }
      }
      return FigSignalErrorAt();
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44868]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v77 = CFStringGetTypeID();
      if (v77 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      BOOL v78 = *(const void **)(DerivedStorage + 288);
      if (v78) {
        CFRelease(v78);
      }
      CFRetain(a3);
      uint64_t result = 0;
      *(void *)(DerivedStorage + 288) = a3;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44B58]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v79 = CFStringGetTypeID();
      if (v79 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      BOOL v80 = *(const void **)(DerivedStorage + 296);
      if (v80) {
        CFRelease(v80);
      }
      CFRetain(a3);
      uint64_t result = 0;
      *(void *)(DerivedStorage + 296) = a3;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44BB0]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v81 = CFStringGetTypeID();
      if (v81 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      BOOL v82 = *(const void **)(DerivedStorage + 304);
      if (v82) {
        CFRelease(v82);
      }
      CFRetain(a3);
      uint64_t result = 0;
      *(void *)(DerivedStorage + 304) = a3;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A18]))
    {
      *(unsigned char *)(DerivedStorage + 368) = 0;
      if (a3)
      {
        CFTypeID v83 = CFStringGetTypeID();
        if (v83 == CFGetTypeID(a3)) {
          CFStringGetCString(a3, (char *)(DerivedStorage + 368), 1001, 0);
        }
      }
      return 0;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44900]))
    {
      if (a3)
      {
        CFTypeID v84 = CFNumberGetTypeID();
        if (v84 == CFGetTypeID(a3))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 0;
          sub_1BB9FA7B0(a3, kCFNumberSInt32Type, buf);
          uint64_t result = 0;
          *(_DWORD *)(DerivedStorage + 1424) = *(_DWORD *)buf;
          return result;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A98])) {
      return 0;
    }
    if (CFEqual(a2, @"UsingCellular"))
    {
      *(_DWORD *)CMSampleTimingInfo buf = 0;
      sub_1BB9FA7B0(a3, kCFNumberSInt32Type, buf);
      uint64_t result = 0;
      *(_DWORD *)(DerivedStorage + 1376) = *(_DWORD *)buf;
      return result;
    }
    if (CFEqual(a2, @"FaceRect"))
    {
      if (a3)
      {
        CFTypeID v85 = CFBooleanGetTypeID();
        if (v85 == CFGetTypeID(a3))
        {
          BOOL v86 = sub_1BB9FA820(a3);
          uint64_t result = 0;
          *(unsigned char *)(DerivedStorage + 1385) = v86;
          return result;
        }
      }
      return 0;
    }
    if (CFEqual(a2, @"RemoteMLScale"))
    {
      if (a3)
      {
        CFTypeID v87 = CFBooleanGetTypeID();
        if (v87 == CFGetTypeID(a3))
        {
          BOOL v88 = sub_1BB9FA820(a3);
          uint64_t result = 0;
          *(unsigned char *)(DerivedStorage + 1453) = v88;
          return result;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44AD8]))
    {
      if (!a3) {
        return 0;
      }
      CFTypeID v89 = CFNumberGetTypeID();
      if (v89 != CFGetTypeID(a3)) {
        return 0;
      }
      LODWORD(CFDictionaryAddValue(theDict, key, value) = 0;
      sub_1BB9FA7B0(a3, kCFNumberSInt32Type, &value);
      if ((int)value >= 5000) {
        int v90 = 5000;
      }
      else {
        int v90 = (int)value;
      }
      if (v90 <= 50) {
        int v91 = 50;
      }
      else {
        int v91 = v90;
      }
      if (value != v91 && dword_1E9F80A90 >= 2)
      {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Requested max encoder latency %d. Clamped to %d\n", value, v91);
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = value;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v91;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Requested max encoder latency %d. Clamped to %d\n", buf, 0xEu);
        }
      }
      uint64_t result = 0;
      *(_DWORD *)(DerivedStorage + 1428) = v91;
      *(unsigned char *)(DerivedStorage + 1432) = 1;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44990]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v92 = CFDataGetTypeID();
      if (v92 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      unint64_t v93 = *(const void **)(DerivedStorage + 1440);
      if (v93) {
        CFRelease(v93);
      }
      CFRetain(a3);
      uint64_t result = 0;
      *(void *)(DerivedStorage + 1440) = a3;
      return result;
    }
    if (CFEqual(a2, @"EnableFrameDropping"))
    {
      if (a3)
      {
        CFTypeID v94 = CFNumberGetTypeID();
        if (v94 == CFGetTypeID(a3))
        {
          unsigned int v16 = (void *)(DerivedStorage + 1448);
          goto LABEL_22;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, @"AllowQpModulation"))
    {
      if (a3)
      {
        CFTypeID v95 = CFBooleanGetTypeID();
        if (v95 == CFGetTypeID(a3))
        {
          BOOL v96 = sub_1BB9FA820(a3);
          uint64_t result = 0;
          *(unsigned char *)(DerivedStorage + 1452) = v96;
          return result;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, @"MinNumberOfTemporalLayers"))
    {
      if (a3)
      {
        CFTypeID v97 = CFNumberGetTypeID();
        if (v97 == CFGetTypeID(a3))
        {
          unsigned int v16 = (void *)(DerivedStorage + 60);
          goto LABEL_22;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, @"CommandLineParametersExtraOptions"))
    {
      if (a3)
      {
        CFTypeID v98 = CFStringGetTypeID();
        if (v98 == CFGetTypeID(a3))
        {
          *(void *)CMSampleTimingInfo buf = CFRetain(a3);
          sub_1BB9FAA60((const void **)(DerivedStorage + 1480), (const void **)buf);
          sub_1BB9BE158((const void **)buf);
          return 0;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F448B0]))
    {
      if (a3)
      {
        CFTypeID v99 = CFBooleanGetTypeID();
        if (v99 == CFGetTypeID(a3))
        {
          BOOL v100 = sub_1BB9FA820(a3);
          uint64_t result = 0;
          *(_DWORD *)(DerivedStorage + 1456) = v100;
          return result;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F447F0]))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v101 = CFStringGetTypeID();
      if (v101 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      unint64_t v102 = *(const void **)(DerivedStorage + 1472);
      if (v102) {
        CFRelease(v102);
      }
      CFRetain(a3);
      uint64_t result = 0;
      *(void *)(DerivedStorage + 1472) = a3;
      return result;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A30]))
    {
      if (a3)
      {
        CFTypeID v103 = CFNumberGetTypeID();
        if (v103 == CFGetTypeID(a3))
        {
          unsigned int v16 = (void *)(DerivedStorage + 1488);
          goto LABEL_22;
        }
      }
      goto LABEL_321;
    }
    if (CFEqual(a2, @"SliceQP"))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v104 = CFArrayGetTypeID();
      if (v104 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      CFIndex v105 = CFArrayGetCount((CFArrayRef)a3);
      CFIndex v106 = v105;
      if (v105 < 5)
      {
        uint64_t v107 = v105;
        if (v105 < 1) {
          goto LABEL_337;
        }
      }
      else if (dword_1E9F80A90 < 2)
      {
        uint64_t v107 = 4;
      }
      else
      {
        uint64_t v107 = 4;
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "SliceQPCFIndex Count = %d > kMaxSliceNum(%d)", v105, 4);
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v106;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = 4;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "SliceQPCFIndex Count = %d > kMaxSliceNum(%d)", buf, 0xEu);
        }
      }
      CFIndex v121 = 0;
      do
      {
        unsigned int v122 = CFArrayGetValueAtIndex((CFArrayRef)a3, v121);
        if (!v122) {
          FigSignalErrorAt();
        }
        CFTypeID v123 = CFNumberGetTypeID();
        if (v123 != CFGetTypeID(v122)) {
          FigSignalErrorAt();
        }
        if (CFNumberGetType((CFNumberRef)v122) == kCFNumberSInt64Type)
        {
          *(_DWORD *)CMSampleTimingInfo buf = 0;
          CFNumberGetValue((CFNumberRef)v122, kCFNumberSInt64Type, buf);
          *(_DWORD *)(DerivedStorage + 1492 + 4 * v121) = *(_DWORD *)buf;
        }
        else
        {
          FigSignalErrorAt();
        }
        ++v121;
      }
      while (v107 != v121);
      CFIndex v106 = v107;
LABEL_337:
      if ((int)v106 <= 3)
      {
        uint64_t v124 = (int)v106;
        do
        {
          uint64_t result = 0;
          *(_DWORD *)(DerivedStorage + 1492 + 4 * v124++) = *(_DWORD *)(DerivedStorage + 1492 + 4 * v106 - 4);
        }
        while (v124 != 4);
        return result;
      }
      return 0;
    }
    if (CFEqual(a2, @"SliceDeltaQP"))
    {
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v108 = CFArrayGetTypeID();
      if (v108 != CFGetTypeID(a3)) {
        goto LABEL_321;
      }
      CFIndex v109 = CFArrayGetCount((CFArrayRef)a3);
      CFIndex v110 = v109;
      if (v109 < 5)
      {
        uint64_t v111 = v109;
        if (v109 < 1) {
          goto LABEL_354;
        }
      }
      else if (dword_1E9F80A90 < 2)
      {
        uint64_t v111 = 4;
      }
      else
      {
        uint64_t v111 = 4;
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "SliceDeltaQPCFIndex Count = %d > kMaxSliceNum(%d)", v109, 4);
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v110;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = 4;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "SliceDeltaQPCFIndex Count = %d > kMaxSliceNum(%d)", buf, 0xEu);
        }
      }
      CFIndex v125 = 0;
      do
      {
        int v126 = CFArrayGetValueAtIndex((CFArrayRef)a3, v125);
        if (!v126) {
          FigSignalErrorAt();
        }
        CFTypeID v127 = CFNumberGetTypeID();
        if (v127 != CFGetTypeID(v126)) {
          FigSignalErrorAt();
        }
        if (CFNumberGetType((CFNumberRef)v126) == kCFNumberSInt64Type)
        {
          *(_DWORD *)CMSampleTimingInfo buf = 0;
          CFNumberGetValue((CFNumberRef)v126, kCFNumberSInt64Type, buf);
          *(_DWORD *)(DerivedStorage + 1508 + 4 * v125) = *(_DWORD *)buf;
        }
        else
        {
          FigSignalErrorAt();
        }
        ++v125;
      }
      while (v111 != v125);
      CFIndex v110 = v111;
LABEL_354:
      if ((int)v110 <= 3)
      {
        uint64_t v128 = (int)v110;
        do
        {
          uint64_t result = 0;
          *(_DWORD *)(DerivedStorage + 1508 + 4 * v128++) = *(_DWORD *)(DerivedStorage + 1508 + 4 * v110 - 4);
        }
        while (v128 != 4);
        return result;
      }
      return 0;
    }
    if (!CFEqual(a2, @"SliceMaxQP"))
    {
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F448D8]))
      {
        if (a3 && (CFTypeID v116 = CFBooleanGetTypeID(), v116 == CFGetTypeID(a3)))
        {
          int v117 = sub_1BB9FA820(a3);
          uint64_t result = 0;
          *(unsigned char *)(DerivedStorage + 1540) = v117;
        }
        else
        {
          uint64_t result = FigSignalErrorAt();
          int v117 = *(unsigned __int8 *)(DerivedStorage + 1540);
        }
        if (!v117) {
          return result;
        }
        CFStringRef v66 = (const __CFString *)*MEMORY[0x1E4F452D8];
        uint64_t v65 = DerivedStorage;
LABEL_168:
        return sub_1BB9FA92C(v65, v66);
      }
      if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F449E8]))
      {
        if (CFEqual(a2, @"CallerID"))
        {
          if (a3)
          {
            CFTypeID v120 = CFNumberGetTypeID();
            if (v120 == CFGetTypeID(a3))
            {
              unsigned int v16 = (void *)(DerivedStorage + 1552);
              CFStringRef v17 = a3;
              CFNumberType v18 = kCFNumberSInt64Type;
              goto LABEL_30;
            }
          }
        }
        goto LABEL_321;
      }
      if (!a3) {
        goto LABEL_321;
      }
      CFTypeID v118 = CFGetTypeID(a3);
      if (v118 != CFDictionaryGetTypeID()) {
        goto LABEL_321;
      }
      CFMutableDictionaryRef value = 0;
      float v133 = -1.0;
      float valuePtr = -1.0;
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E4F45018], (const void **)&value)) {
        CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &valuePtr);
      }
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)a3, (const void *)*MEMORY[0x1E4F45010], (const void **)&value)) {
        CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v133);
      }
      if (valuePtr >= 0.0)
      {
        float v119 = v133;
        if (v133 >= 0.0 && valuePtr <= v133)
        {
          uint64_t result = 0;
          *(float *)(DerivedStorage + 1544) = valuePtr;
          *(float *)(DerivedStorage + 1548) = v119;
          return result;
        }
      }
      if (dword_1E9F80A90 >= 2)
      {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "bad min and max disparity [%f, %f], ignored", valuePtr, v133);
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CMSampleTimingInfo buf = 134218240;
          *(double *)&uint8_t buf[4] = valuePtr;
          *(_WORD *)&unsigned char buf[12] = 2048;
          double v137 = v133;
          _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "bad min and max disparity [%f, %f], ignored", buf, 0x16u);
        }
      }
      return FigSignalErrorAt();
    }
    if (!a3) {
      goto LABEL_321;
    }
    CFTypeID v112 = CFArrayGetTypeID();
    if (v112 != CFGetTypeID(a3)) {
      goto LABEL_321;
    }
    CFIndex v113 = CFArrayGetCount((CFArrayRef)a3);
    CFIndex v114 = v113;
    if (v113 < 5)
    {
      uint64_t v115 = v113;
      if (v113 < 1) {
        goto LABEL_371;
      }
    }
    else if (dword_1E9F80A90 < 2)
    {
      uint64_t v115 = 4;
    }
    else
    {
      uint64_t v115 = 4;
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "SliceMaxQPCFIndex Count = %d > kMaxSliceNum(%d)", v113, 4);
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v114;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = 4;
        _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "SliceMaxQPCFIndex Count = %d > kMaxSliceNum(%d)", buf, 0xEu);
      }
    }
    CFIndex v129 = 0;
    do
    {
      size_t v130 = CFArrayGetValueAtIndex((CFArrayRef)a3, v129);
      if (!v130) {
        FigSignalErrorAt();
      }
      CFTypeID v131 = CFNumberGetTypeID();
      if (v131 != CFGetTypeID(v130)) {
        FigSignalErrorAt();
      }
      if (CFNumberGetType((CFNumberRef)v130) == kCFNumberSInt64Type)
      {
        *(_DWORD *)CMSampleTimingInfo buf = 0;
        CFNumberGetValue((CFNumberRef)v130, kCFNumberSInt64Type, buf);
        *(_DWORD *)(DerivedStorage + 1524 + 4 * v129) = *(_DWORD *)buf;
      }
      else
      {
        FigSignalErrorAt();
      }
      ++v129;
    }
    while (v115 != v129);
    CFIndex v114 = v115;
LABEL_371:
    if ((int)v114 <= 3)
    {
      uint64_t v132 = (int)v114;
      do
      {
        uint64_t result = 0;
        *(_DWORD *)(DerivedStorage + 1524 + 4 * v132++) = *(_DWORD *)(DerivedStorage + 1524 + 4 * v114 - 4);
      }
      while (v132 != 4);
      return result;
    }
    return 0;
  }
  if (!a3) {
    goto LABEL_321;
  }
  CFTypeID v28 = CFArrayGetTypeID();
  if (v28 != CFGetTypeID(a3)) {
    goto LABEL_321;
  }
  CFIndex v29 = CFArrayGetCount((CFArrayRef)a3);
  if ((unint64_t)(v29 - 8) <= 0xFFFFFFFFFFFFFFF8)
  {
    FigSignalErrorAt();
    if (v29 < 1) {
      return 0;
    }
  }
  CFIndex v30 = 0;
  CMTimeEpoch v31 = (char *)(DerivedStorage + 64);
  do
  {
    CFNumberRef v32 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a3, v30);
    if (!v32)
    {
      FigSignalErrorAt();
      CFNumberRef v32 = 0;
    }
    CFNumberGetValue(v32, kCFNumberSInt32Type, v31);
    uint64_t result = 0;
    ++v30;
    v31 += 4;
  }
  while (v29 != v30);
  return result;
}

CFTypeID sub_1BB9FA7B0(const void *a1, CFNumberType a2, void *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  CFTypeID result = CFNumberGetTypeID();
  if (v6 == result)
  {
    return CFNumberGetValue((CFNumberRef)a1, a2, a3);
  }
  return result;
}

BOOL sub_1BB9FA820(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  return v2 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a1) != 0;
}

uint64_t sub_1BB9FA86C(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID()) {
    return 4294954394;
  }
  int v5 = *(const void **)(a1 + 320);
  if (v5) {
    CFRelease(v5);
  }
  CFRetain(cf);
  uint64_t v6 = 0;
  *(void *)(a1 + 320) = cf;
  *(_DWORD *)(a1 + 328) = 0;
  CFTypeID v7 = &qword_1E62479B0;
  uint64_t v8 = (CFTypeRef *)MEMORY[0x1E4F44F98];
  while (!CFEqual(cf, *v8))
  {
    ++v6;
    CFTypeID v9 = (CFTypeRef *)*v7;
    v7 += 2;
    uint64_t v8 = v9;
    if (!v9) {
      goto LABEL_10;
    }
  }
  *(_DWORD *)(a1 + 328) = dword_1E62479A0[4 * v6 + 2];
LABEL_10:
  if (*(_DWORD *)(a1 + 232)) {
    return 0;
  }
  else {
    return 4294954394;
  }
}

uint64_t sub_1BB9FA92C(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFStringGetTypeID()) {
      return 4294954394;
    }
    int v5 = *(const void **)(a1 + 312);
    if (v5) {
      CFRelease(v5);
    }
    CFRetain(cf);
    *(void *)(a1 + 312) = cf;
    int v6 = *(_DWORD *)(a1 + 48);
    if (v6 == 1684632424 || v6 == 1752589105 || v6 == 1718908520) {
      CFTypeID v7 = (CFTypeRef **)&off_1E62479C0;
    }
    else {
      CFTypeID v7 = (CFTypeRef **)&off_1E6247A30;
    }
    CFTypeID v9 = *v7;
    if (*v7)
    {
      uint64_t v10 = 0;
      BOOL v11 = v7 + 2;
      while (!CFEqual(cf, *v9))
      {
        ++v10;
        CFTypeID v12 = *v11;
        v11 += 2;
        CFTypeID v9 = v12;
        if (!v12) {
          goto LABEL_17;
        }
      }
      *(void *)(a1 + 232) = v7[2 * v10 + 1];
    }
LABEL_17:
    int v8 = *(_DWORD *)(a1 + 232);
    if (!v8) {
      return 4294954394;
    }
  }
  else
  {
    int v8 = *(_DWORD *)(a1 + 232);
  }
  int v13 = *(_DWORD *)(a1 + 340);
  int v14 = *(_DWORD *)(a1 + 344);
  int v15 = *(_DWORD *)(a1 + 48);

  return sub_1BBA15714(v13, v14, v8, v15);
}

const void **sub_1BB9FAA60(const void **a1, const void **a2)
{
  CFTypeID v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = *a2;
  *a2 = 0;
  return a1;
}

uint64_t sub_1BB9FAAA4(uint64_t a1, const void *a2, uint64_t a3, CFNumberRef *a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  *a4 = 0;
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44B68]))
  {
    CFTypeID v7 = (const void *)(DerivedStorage + 240);
LABEL_3:
    CFNumberType v8 = kCFNumberSInt32Type;
LABEL_4:
    CFNumberRef v9 = CFNumberCreate(0, v8, v7);
LABEL_5:
    *a4 = v9;
    return 0;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F447E8]))
  {
    uint64_t v10 = (const void **)MEMORY[0x1E4F1CFD0];
    int v11 = *(_DWORD *)(DerivedStorage + 244);
LABEL_10:
    if (!v11) {
      uint64_t v10 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    CFTypeID v12 = *v10;
LABEL_13:
    CFRetain(v12);
    *a4 = (CFNumberRef)v12;
    return 0;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F447D0]))
  {
    uint64_t v10 = (const void **)MEMORY[0x1E4F1CFD0];
    int v11 = *(_DWORD *)(DerivedStorage + 248);
    goto LABEL_10;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F449C8]))
  {
    CFTypeID v7 = (const void *)(DerivedStorage + 256);
    goto LABEL_3;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F449D0]))
  {
    CFTypeID v7 = (const void *)(DerivedStorage + 264);
LABEL_19:
    CFNumberType v8 = kCFNumberDoubleType;
    goto LABEL_4;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A40]))
  {
    CFTypeID v7 = (const void *)(DerivedStorage + 56);
    goto LABEL_3;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44810]))
  {
    LODWORD(valuePtr) = *(_DWORD *)(DerivedStorage + 52);
    CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  if (CFEqual(a2, @"BPictures"))
  {
    CFTypeID v7 = (const void *)(DerivedStorage + 252);
    goto LABEL_3;
  }
  if (CFEqual(a2, @"NegotiationDetailsBitField") || CFEqual(a2, @"NegotiatedFLB"))
  {
    CFNumberRef v9 = sub_1BBAB0E24((char *)(DerivedStorage + 368));
    goto LABEL_5;
  }
  if (CFEqual(a2, @"AverageTemporalBitRates"))
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    uint64_t v15 = 0;
    uint64_t v16 = DerivedStorage + 64;
    do
    {
      if ((*(_DWORD *)(v16 + v15) & 0x80000000) != 0) {
        break;
      }
      CFNumberRef v17 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)(v16 + v15));
      CFArrayAppendValue(Mutable, v17);
      CFRelease(v17);
      v15 += 4;
    }
    while (v15 != 28);
LABEL_33:
    *a4 = Mutable;
    return 0;
  }
  if (CFEqual(a2, @"MaxRefreshFrameIntervalDuration"))
  {
    CFTypeID v7 = (const void *)(DerivedStorage + 272);
    goto LABEL_19;
  }
  if (CFEqual(a2, @"ThermalLevel"))
  {
    LODWORD(valuePtr) = *(_DWORD *)(DerivedStorage + 1372);
    CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44870]))
  {
    LODWORD(valuePtr) = *(_DWORD *)(DerivedStorage + 228);
    CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  if (CFEqual(a2, @"AverageBitRateIntraLayer"))
  {
    LODWORD(valuePtr) = *(_DWORD *)(DerivedStorage + 92);
    CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  if (CFEqual(a2, @"FaceRect"))
  {
    uint64_t v10 = (const void **)MEMORY[0x1E4F1CFD0];
    int v11 = *(unsigned __int8 *)(DerivedStorage + 1385);
    goto LABEL_10;
  }
  if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A38]))
  {
    LODWORD(valuePtr) = *(_DWORD *)(DerivedStorage + 1380);
    CFNumberRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44898]))
  {
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F448F0]))
    {
      CFTypeID v7 = (const void *)(DerivedStorage + 24);
      goto LABEL_19;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44830]))
    {
      CFTypeID v7 = (const void *)(DerivedStorage + 32);
      goto LABEL_19;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44820]))
    {
      CFTypeID v7 = (const void *)(DerivedStorage + 40);
      goto LABEL_19;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F449B8]))
    {
      CFTypeID v7 = (const void *)(DerivedStorage + 1460);
      goto LABEL_3;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F449E0]))
    {
      CFTypeID v7 = (const void *)(DerivedStorage + 1464);
      goto LABEL_3;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44AC8]))
    {
      CFTypeID v7 = (const void *)(DerivedStorage + 1468);
      goto LABEL_3;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44840]))
    {
      uint64_t v10 = (const void **)MEMORY[0x1E4F1CFD0];
      int v11 = *(unsigned __int8 *)(DerivedStorage + 1454);
      goto LABEL_10;
    }
    if (!CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F448A0]))
    {
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44AA0]))
      {
        CFTypeID v12 = *(const void **)(DerivedStorage + 312);
        if (!v12) {
          return 0;
        }
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44920]))
      {
        CFTypeID v12 = *(const void **)(DerivedStorage + 320);
        if (!v12) {
          return 0;
        }
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44B18]))
      {
        CFTypeID v7 = (const void *)(DerivedStorage + 280);
        goto LABEL_3;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A60]))
      {
        int v18 = *(_DWORD *)(DerivedStorage + 332);
        if (v18)
        {
          if (v18 == 1)
          {
            int v19 = *(_DWORD *)(DerivedStorage + 336);
            if (v19 == 1) {
              goto LABEL_84;
            }
          }
          else
          {
            int v19 = *(_DWORD *)(DerivedStorage + 336);
          }
          if (v19)
          {
            uint64_t v20 = *MEMORY[0x1E4F24BA0];
            float valuePtr = (const void *)*MEMORY[0x1E4F24B90];
            uint64_t v38 = v20;
            CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (const void *)(DerivedStorage + 332));
            CFNumberRef v36 = CFNumberCreate(v21, kCFNumberSInt32Type, (const void *)(DerivedStorage + 336));
            *a4 = CFDictionaryCreate(v21, &valuePtr, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CFRelease(values);
            CFRelease(v36);
            return 0;
          }
        }
LABEL_84:
        *a4 = 0;
        return 0;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44868]))
      {
        CFTypeID v12 = *(const void **)(DerivedStorage + 288);
        if (!v12) {
          return 0;
        }
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44B58]))
      {
        CFTypeID v12 = *(const void **)(DerivedStorage + 296);
        if (!v12) {
          return 0;
        }
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44BB0]))
      {
        CFTypeID v12 = *(const void **)(DerivedStorage + 304);
        if (!v12) {
          return 0;
        }
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44990]))
      {
        CFTypeID v12 = *(const void **)(DerivedStorage + 1440);
        if (!v12) {
          return 0;
        }
        goto LABEL_13;
      }
      if (CFEqual(a2, @"EnableFrameDropping"))
      {
        CFTypeID v7 = (const void *)(DerivedStorage + 1448);
        goto LABEL_3;
      }
      if (CFEqual(a2, @"AllowQpModulation"))
      {
        uint64_t v10 = (const void **)MEMORY[0x1E4F1CFD0];
        int v11 = *(unsigned __int8 *)(DerivedStorage + 1452);
        goto LABEL_10;
      }
      if (CFEqual(a2, @"RemoteMLScale"))
      {
        uint64_t v10 = (const void **)MEMORY[0x1E4F1CFD0];
        int v11 = *(unsigned __int8 *)(DerivedStorage + 1453);
        goto LABEL_10;
      }
      if (CFEqual(a2, @"MinNumberOfTemporalLayers"))
      {
        CFTypeID v7 = (const void *)(DerivedStorage + 60);
        goto LABEL_3;
      }
      if (CFEqual(a2, @"CommandLineParametersExtraOptions"))
      {
        int v22 = *(const void **)(DerivedStorage + 1480);
        if (v22)
        {
          CFRetain(v22);
          CFRetain(v22);
          float valuePtr = v22;
          CFTypeID v34 = 0;
          *a4 = (CFNumberRef)v22;
          sub_1BB9BE158(&valuePtr);
          sub_1BB9BE158(&v34);
        }
        return 0;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F448B0]))
      {
        uint64_t v10 = (const void **)MEMORY[0x1E4F1CFD0];
        int v11 = *(_DWORD *)(DerivedStorage + 1456);
        goto LABEL_10;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F447F0]))
      {
        CFTypeID v12 = *(const void **)(DerivedStorage + 1472);
        if (!v12) {
          return 0;
        }
        goto LABEL_13;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F44A30]))
      {
        CFTypeID v7 = (const void *)(DerivedStorage + 1488);
        goto LABEL_3;
      }
      if (CFEqual(a2, @"SliceQP"))
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        if (*(int *)(DerivedStorage + 1488) >= 1)
        {
          uint64_t v23 = 0;
          CFTypeID v24 = (_DWORD *)(DerivedStorage + 1492);
          do
          {
            if ((*v24 & 0x80000000) != 0) {
              break;
            }
            CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, v24);
            CFArrayAppendValue(Mutable, v25);
            CFRelease(v25);
            ++v23;
            ++v24;
          }
          while (v23 < *(int *)(DerivedStorage + 1488));
        }
        goto LABEL_33;
      }
      if (CFEqual(a2, @"SliceDeltaQP"))
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        if (*(int *)(DerivedStorage + 1488) >= 1)
        {
          uint64_t v26 = 0;
          CFTypeID v27 = (_DWORD *)(DerivedStorage + 1508);
          do
          {
            if ((*v27 & 0x80000000) != 0) {
              break;
            }
            CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, v27);
            CFArrayAppendValue(Mutable, v28);
            CFRelease(v28);
            ++v26;
            ++v27;
          }
          while (v26 < *(int *)(DerivedStorage + 1488));
        }
        goto LABEL_33;
      }
      if (CFEqual(a2, @"SliceMaxQP"))
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        if (*(int *)(DerivedStorage + 1488) >= 1)
        {
          uint64_t v29 = 0;
          CFIndex v30 = (_DWORD *)(DerivedStorage + 1524);
          do
          {
            if ((*v30 & 0x80000000) != 0) {
              break;
            }
            CFNumberRef v31 = CFNumberCreate(0, kCFNumberSInt32Type, v30);
            CFArrayAppendValue(Mutable, v31);
            CFRelease(v31);
            ++v29;
            ++v30;
          }
          while (v29 < *(int *)(DerivedStorage + 1488));
        }
        goto LABEL_33;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F448D8]))
      {
        uint64_t v10 = (const void **)MEMORY[0x1E4F1CFD0];
        int v11 = *(unsigned __int8 *)(DerivedStorage + 1540);
        goto LABEL_10;
      }
      if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F449E8]))
      {
        uint64_t v32 = *MEMORY[0x1E4F45010];
        float valuePtr = (const void *)*MEMORY[0x1E4F45018];
        uint64_t v38 = v32;
        CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, (const void *)(DerivedStorage + 1544));
        CFNumberRef v36 = CFNumberCreate(v33, kCFNumberFloat32Type, (const void *)(DerivedStorage + 1548));
        *a4 = CFDictionaryCreate(v33, &valuePtr, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFRelease(values);
        CFRelease(v36);
        return 0;
      }
      if (CFEqual(a2, @"CallerID"))
      {
        CFTypeID v7 = (const void *)(DerivedStorage + 1552);
        CFNumberType v8 = kCFNumberSInt64Type;
        goto LABEL_4;
      }
    }
  }

  return FigSignalErrorAt();
}

void sub_1BB9FB564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

__CFString *sub_1BB9FB580(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"<LRPVideoEncoder %p>", a1);
  return Mutable;
}

uint64_t sub_1BB9FB5D8()
{
  uint64_t result = CMBaseObjectGetDerivedStorage();
  if (result && !*(unsigned char *)(result + 356))
  {
    return sub_1BB9FB628();
  }
  return result;
}

uint64_t sub_1BB9FB628()
{
  uint64_t DerivedStorage = CMBaseObjectGetDerivedStorage();
  if (DerivedStorage)
  {
    uint64_t v1 = DerivedStorage;
    if (!*(unsigned char *)(DerivedStorage + 356))
    {
      CFTypeID v2 = *(NSObject **)(DerivedStorage + 1392);
      if (v2) {
        dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
      }
      size_t v3 = *(void **)(v1 + 16);
      if (v3)
      {
        CFTypeID v4 = sub_1BBA5DC2C(v3);
        MEMORY[0x1C18605E0](v4, 0x10F0C407B2AA9F2);
      }
      *(unsigned char *)(v1 + 356) = 1;
      *(void *)uint64_t v1 = 0;
      int v5 = *(const void **)(v1 + 360);
      if (v5)
      {
        CFRelease(v5);
        *(void *)(v1 + 360) = 0;
      }
      FigFormatDescriptionRelease();
      *(void *)(v1 + 8) = 0;
      int v6 = *(const void **)(v1 + 288);
      if (v6)
      {
        CFRelease(v6);
        *(void *)(v1 + 288) = 0;
      }
      CFTypeID v7 = *(const void **)(v1 + 296);
      if (v7)
      {
        CFRelease(v7);
        *(void *)(v1 + 296) = 0;
      }
      CFNumberType v8 = *(const void **)(v1 + 304);
      if (v8)
      {
        CFRelease(v8);
        *(void *)(v1 + 304) = 0;
      }
      CFNumberRef v9 = *(const void **)(v1 + 312);
      if (v9)
      {
        CFRelease(v9);
        *(void *)(v1 + 312) = 0;
      }
      uint64_t v10 = *(const void **)(v1 + 320);
      if (v10)
      {
        CFRelease(v10);
        *(void *)(v1 + 320) = 0;
      }
      int v11 = *(NSObject **)(v1 + 1392);
      if (v11)
      {
        dispatch_semaphore_signal(v11);
        dispatch_release(*(dispatch_object_t *)(v1 + 1392));
      }
      CFTypeID v12 = *(const void **)(v1 + 1440);
      if (v12)
      {
        CFRelease(v12);
        *(void *)(v1 + 1440) = 0;
      }
      int v13 = *(const void **)(v1 + 1472);
      if (v13)
      {
        CFRelease(v13);
        *(void *)(v1 + 1472) = 0;
      }
      int v14 = *(void **)(v1 + 1416);
      if (v14)
      {
        [v14 invalidate];
        CFRelease(*(CFTypeRef *)(v1 + 1416));
      }
      uint64_t v15 = *(NSObject **)(v1 + 1408);
      if (v15)
      {
        dispatch_semaphore_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(*(dispatch_object_t *)(v1 + 1408));
        *(void *)(v1 + 1408) = 0;
      }
    }
  }
  return 0;
}

CFTypeID sub_1BB9FB768(_DWORD *a1, uint64_t *a2, uint64_t *a3, int a4, int a5, int a6, int a7, double a8, double a9)
{
  BOOL v15 = 0;
  uint64_t v159 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = *a2;
  *((void *)a1 + 98) = *a2;
  a1[200] = *((_DWORD *)a2 + 2);
  *((unsigned char *)a1 + 204) = 0;
  a1[54] = 0;
  a1[71] = 0;
  CFNumberRef v17 = a1 + 74;
  a1[174] = 0;
  int v18 = a1 + 85;
  *((_WORD *)a1 + 70) = 0;
  int v19 = a1 + 210;
  a1[49] = 0;
  *(_OWORD *)(a1 + 45) = 0u;
  *(void *)(a1 + 43) = 0;
  *((void *)a1 + 41) = 0;
  *(_OWORD *)(a1 + 74) = 0u;
  *(_OWORD *)(a1 + 78) = 0u;
  *(_OWORD *)(a1 + 85) = 0u;
  *(_OWORD *)(a1 + 210) = 0u;
  if (!a4)
  {
    *((void *)a1 + 19) = v16;
    a1[40] = 0;
    BOOL v15 = 1;
    *((void *)a1 + 26) = v16;
  }
  *((_WORD *)a1 + 101) = 0;
  *((unsigned char *)a1 + 200) = 0;
  CFTypeID result = *((void *)a1 + 103);
  if (result)
  {
    int v154 = a6;
    int v156 = a7;
    int v157 = a5;
    CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)result, (const void *)*MEMORY[0x1E4F44ED8]);
    unint64_t v155 = v19;
    if (Value)
    {
      int v22 = Value;
      if (CFGetTypeID(Value))
      {
        if (CFBooleanGetTypeID()) {
          BOOL v15 = CFEqual(v22, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
        }
      }
    }
    if (v15 && dword_1E9F80A90 >= 3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CMSampleTimingInfo buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a4;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "frame %d: key frame requested\n", buf, 8u);
    }
    uint64_t v23 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44EE0]);
    if (v23)
    {
      CFTypeID v24 = v23;
      if (CFGetTypeID(v23))
      {
        if (CFBooleanGetTypeID()) {
          *((unsigned char *)a1 + 204) = CFEqual(v24, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
        }
      }
    }
    CFNumberRef v25 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44EC8]);
    if (v25)
    {
      uint64_t v26 = v25;
      CFTypeID TypeID = CFDataGetTypeID();
      if (TypeID == CFGetTypeID(v26)) {
        *((unsigned char *)a1 + 204) = 1;
      }
    }
    if (*((unsigned char *)a1 + 204) && dword_1E9F80A90 >= 3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CMSampleTimingInfo buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a4;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "frame %d: refresh frame requested\n", buf, 8u);
    }
    CFNumberRef v28 = (const void **)MEMORY[0x1E4F44DB8];
    if (!a1[214]) {
      CFNumberRef v28 = (const void **)MEMORY[0x1E4F44DC0];
    }
    CFArrayRef v29 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), *v28);
    if (v29)
    {
      CFArrayRef v30 = v29;
      CFTypeID v31 = CFArrayGetTypeID();
      if (v31 == CFGetTypeID(v30))
      {
        unsigned int Count = CFArrayGetCount(v30);
        int v33 = Count >= 0x10 ? 16 : Count;
        a1[54] = v33;
        if (v33)
        {
          unint64_t v34 = 0;
          CFTypeID v35 = (char *)(a1 + 55);
          do
          {
            CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v30, v34);
            CFNumberGetValue(ValueAtIndex, kCFNumberIntType, v35);
            ++v34;
            v35 += 4;
          }
          while (v34 < a1[54]);
        }
      }
    }
    CFNumberRef v37 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), @"PadFrameToMinimumSize");
    if (v37)
    {
      CFNumberRef v38 = v37;
      CFTypeID v39 = CFGetTypeID(v37);
      if (v39 == CFNumberGetTypeID()) {
        CFNumberGetValue(v38, kCFNumberSInt32Type, a1 + 84);
      }
    }
    CFNumberRef v40 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44F50]);
    if (v40)
    {
      CFNumberRef v41 = v40;
      CFTypeID v42 = CFGetTypeID(v40);
      if (v42 == CFNumberGetTypeID()) {
        CFNumberGetValue(v41, kCFNumberSInt32Type, a1 + 71);
      }
    }
    CFNumberRef v43 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44F08]);
    if (v43)
    {
      CFNumberRef v44 = v43;
      CFTypeID v45 = CFGetTypeID(v43);
      if (v45 == CFNumberGetTypeID()) {
        CFNumberGetValue(v44, kCFNumberDoubleType, v17);
      }
    }
    CFNumberRef v46 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44DD8]);
    if (v46)
    {
      CFNumberRef v47 = v46;
      CFTypeID v48 = CFGetTypeID(v46);
      if (v48 == CFNumberGetTypeID()) {
        CFNumberGetValue(v47, kCFNumberSInt32Type, a1 + 76);
      }
    }
    CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44EB0]);
    if (v49)
    {
      CFNumberRef v50 = v49;
      CFTypeID v51 = CFGetTypeID(v49);
      if (v51 == CFNumberGetTypeID()) {
        CFNumberGetValue(v50, kCFNumberSInt32Type, a1 + 77);
      }
    }
    CFNumberRef v52 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44F10]);
    if (v52)
    {
      CFNumberRef v53 = v52;
      CFTypeID v54 = CFGetTypeID(v52);
      if (v54 == CFNumberGetTypeID()) {
        CFNumberGetValue(v53, kCFNumberSInt32Type, a1 + 78);
      }
    }
    CFTypeID v55 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44F40]);
    if (v55)
    {
      CFNumberType v56 = v55;
      if (CFGetTypeID(v55))
      {
        if (CFBooleanGetTypeID()) {
          *((unsigned char *)a1 + 200) = CFEqual(v56, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
        }
      }
    }
    CFNumberRef v57 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), @"MediaQueueDelayLimit");
    if (v57)
    {
      CFNumberRef v58 = v57;
      CFTypeID v59 = CFGetTypeID(v57);
      if (v59 == CFNumberGetTypeID()) {
        CFNumberGetValue(v58, kCFNumberSInt32Type, a1 + 181);
      }
    }
    CFNumberRef v60 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), @"MediaQueueDelay");
    if (v60)
    {
      CFNumberRef v61 = v60;
      CFTypeID v62 = CFGetTypeID(v60);
      if (v62 == CFNumberGetTypeID()) {
        CFNumberGetValue(v61, kCFNumberSInt32Type, a1 + 180);
      }
    }
    CFNumberRef v63 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44F28]);
    if (v63)
    {
      CFNumberRef v64 = v63;
      CFTypeID v65 = CFGetTypeID(v63);
      if (v65 == CFNumberGetTypeID()) {
        CFNumberGetValue(v64, kCFNumberSInt32Type, a1 + 79);
      }
    }
    CFDictionaryRef v66 = (const __CFDictionary *)*((void *)a1 + 103);
    CFTypeID v67 = (const void *)*MEMORY[0x1E4F44DE0];
    int v68 = -1;
    *(_DWORD *)CMSampleTimingInfo buf = -1;
    CFNumberRef v69 = (const __CFNumber *)CFDictionaryGetValue(v66, v67);
    if (v69)
    {
      CFNumberRef v70 = v69;
      CFTypeID v71 = CFGetTypeID(v69);
      if (v71 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v70, kCFNumberSInt32Type, buf);
        int v68 = *(_DWORD *)buf;
      }
      else
      {
        int v68 = -1;
      }
    }
    a1[215] = v68;
    if (CFDictionaryContainsKey(*((CFDictionaryRef *)a1 + 103), @"HistCorr"))
    {
      CFNumberRef v72 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), @"HistCorr");
      if (v72)
      {
        CFNumberRef v73 = v72;
        CFTypeID v74 = CFGetTypeID(v72);
        if (v74 == CFNumberGetTypeID()) {
          CFNumberGetValue(v73, kCFNumberFloatType, a1 + 179);
        }
      }
    }
    else
    {
      a1[179] = 2139095039;
    }
    CFArrayRef v75 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), @"ResilienceNumBitsAddedArray");
    if (v75)
    {
      CFArrayRef v76 = v75;
      CFTypeID v77 = CFArrayGetTypeID();
      if (v77 == CFGetTypeID(v76))
      {
        CFIndex v78 = CFArrayGetCount(v76);
        if (v78 >= 1)
        {
          CFIndex v79 = v78;
          CFIndex v80 = 0;
          CFTypeID v81 = (char *)(a1 + 43);
          do
          {
            CFNumberRef v82 = (const __CFNumber *)CFArrayGetValueAtIndex(v76, v80);
            CFNumberGetValue(v82, kCFNumberSInt32Type, v81);
            ++v80;
            v81 += 4;
          }
          while (v79 != v80);
        }
      }
    }
    CFDictionaryRef v83 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44F90]);
    int v19 = v155;
    if (v83)
    {
      CFDictionaryRef v84 = v83;
      CFTypeID v85 = CFGetTypeID(v83);
      if (v85 == CFDictionaryGetTypeID())
      {
        CFNumberRef v86 = (const __CFNumber *)CFDictionaryGetValue(v84, (const void *)*MEMORY[0x1E4F24A88]);
        if (v86)
        {
          CFNumberRef v87 = v86;
          CFTypeID v88 = CFGetTypeID(v86);
          if (v88 == CFNumberGetTypeID()) {
            CFNumberGetValue(v87, kCFNumberSInt32Type, v18);
          }
        }
        CFNumberRef v89 = (const __CFNumber *)CFDictionaryGetValue(v84, (const void *)*MEMORY[0x1E4F24A68]);
        if (v89)
        {
          CFNumberRef v90 = v89;
          CFTypeID v91 = CFGetTypeID(v89);
          if (v91 == CFNumberGetTypeID()) {
            CFNumberGetValue(v90, kCFNumberSInt32Type, a1 + 86);
          }
        }
        CFNumberRef v92 = (const __CFNumber *)CFDictionaryGetValue(v84, (const void *)*MEMORY[0x1E4F24A70]);
        if (v92)
        {
          CFNumberRef v93 = v92;
          CFTypeID v94 = CFGetTypeID(v92);
          if (v94 == CFNumberGetTypeID()) {
            CFNumberGetValue(v93, kCFNumberSInt32Type, a1 + 87);
          }
        }
        CFNumberRef v95 = (const __CFNumber *)CFDictionaryGetValue(v84, (const void *)*MEMORY[0x1E4F24A80]);
        if (v95)
        {
          CFNumberRef v96 = v95;
          CFTypeID v97 = CFGetTypeID(v95);
          if (v97 == CFNumberGetTypeID()) {
            CFNumberGetValue(v96, kCFNumberSInt32Type, a1 + 88);
          }
        }
      }
    }
    CFDictionaryRef v98 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), @"FECPercentage");
    if (v98)
    {
      CFDictionaryRef v99 = v98;
      CFTypeID v100 = CFGetTypeID(v98);
      if (v100 == CFDictionaryGetTypeID())
      {
        CFNumberRef v101 = (const __CFNumber *)CFDictionaryGetValue(v99, @"FECPercentageIFrame");
        if (v101)
        {
          CFNumberRef v102 = v101;
          CFTypeID v103 = CFGetTypeID(v101);
          BOOL v104 = v103 == CFNumberGetTypeID();
          int v19 = v155;
          if (v104) {
            CFNumberGetValue(v102, kCFNumberFloat64Type, a1 + 80);
          }
        }
        CFNumberRef v105 = (const __CFNumber *)CFDictionaryGetValue(v99, @"FECPercentagePFrame");
        if (v105)
        {
          CFNumberRef v106 = v105;
          CFTypeID v107 = CFGetTypeID(v105);
          if (v107 == CFNumberGetTypeID()) {
            CFNumberGetValue(v106, kCFNumberFloat64Type, a1 + 82);
          }
        }
      }
    }
    CFNumberRef v108 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), @"CameraFacingType");
    if (v108)
    {
      CFNumberRef v109 = v108;
      CFTypeID v110 = CFGetTypeID(v108);
      if (v110 == CFNumberGetTypeID()) {
        CFNumberGetValue(v109, kCFNumberSInt32Type, a1 + 174);
      }
    }
    CFNumberRef v111 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44F58]);
    if (v111)
    {
      CFNumberRef v112 = v111;
      CFTypeID v113 = CFGetTypeID(v111);
      if (v113 == CFNumberGetTypeID()) {
        CFNumberGetValue(v112, kCFNumberSInt32Type, v19);
      }
    }
    CFTypeID result = (CFTypeID)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 103), (const void *)*MEMORY[0x1E4F44F60]);
    if (result)
    {
      CFArrayRef v114 = (const __CFArray *)result;
      CFTypeID v115 = CFGetTypeID((CFTypeRef)result);
      CFTypeID result = CFArrayGetTypeID();
      if (v115 == result)
      {
        CFNumberRef v116 = (const __CFNumber *)CFArrayGetValueAtIndex(v114, 0);
        if (v116)
        {
          CFNumberRef v117 = v116;
          CFTypeID v118 = CFGetTypeID(v116);
          if (v118 == CFNumberGetTypeID()) {
            CFNumberGetValue(v117, kCFNumberIntType, a1 + 211);
          }
        }
        CFNumberRef v119 = (const __CFNumber *)CFArrayGetValueAtIndex(v114, 1);
        if (v119)
        {
          CFNumberRef v120 = v119;
          CFTypeID v121 = CFGetTypeID(v119);
          if (v121 == CFNumberGetTypeID()) {
            CFNumberGetValue(v120, kCFNumberIntType, a1 + 212);
          }
        }
        CFTypeID result = (CFTypeID)CFArrayGetValueAtIndex(v114, 2);
        if (result)
        {
          CFNumberRef v122 = (const __CFNumber *)result;
          CFTypeID v123 = CFGetTypeID((CFTypeRef)result);
          CFTypeID result = CFNumberGetTypeID();
          if (v123 == result) {
            CFTypeID result = CFNumberGetValue(v122, kCFNumberIntType, a1 + 213);
          }
        }
      }
    }
    a7 = v156;
    a5 = v157;
    a6 = v154;
  }
  uint64_t v124 = *a2;
  if (*a2) {
    int v125 = *((_DWORD *)a2 + 2);
  }
  else {
    int v125 = 3000;
  }
  double v126 = (double)v125;
  double v127 = *((double *)a1 + 1);
  double v128 = 30.0;
  if (v127 > 0.0) {
    double v128 = *((double *)a1 + 1);
  }
  double v129 = v126 / v128;
  uint64_t v130 = *a3;
  if (!*a3 || *a1 == 42 && *((unsigned char *)a1 + 4))
  {
    uint64_t v131 = v124 - *((void *)a1 + 101);
    BOOL v133 = v131 <= 0;
    uint64_t v132 = v131 & ~(v131 >> 63);
    BOOL v133 = v133 || a4 <= 0;
    if (v133) {
      uint64_t v132 = (uint64_t)v129;
    }
    *a3 = v132;
    if (v127 <= 0.0) {
      double v134 = v126 / 240.0;
    }
    else {
      double v134 = v126 / v127;
    }
    *(void *)CMSampleTimingInfo buf = (uint64_t)(v134 * (double)a7);
    if (v132 <= *(uint64_t *)buf) {
      int v135 = (uint8_t *)a3;
    }
    else {
      int v135 = buf;
    }
    uint64_t v130 = *(void *)v135;
    *a3 = *(void *)v135;
    uint64_t v124 = *a2;
    *((void *)a1 + 101) = *a2;
    *((void *)a1 + 102) = v130;
  }
  if ((*((_DWORD *)a2 + 3) & 0x1D) == 1 && v130 >= 1)
  {
    *((void *)a1 + 98) = v124;
    int v136 = *((_DWORD *)a2 + 2);
    a1[200] = v136;
    *((void *)a1 + 99) = v130;
  }
  else if (v127 <= 0.0)
  {
    uint64_t v130 = *((void *)a1 + 99);
    int v136 = a1[200];
  }
  else
  {
    int v136 = (int)((double)(uint64_t)(v129 + 0.5) * v127 + 0.5);
    uint64_t v137 = (uint64_t)(v129 * (double)a4);
    *((void *)a1 + 98) = v137;
    uint64_t v130 = (uint64_t)(v129 * (double)(a4 + 1)) - v137;
    *((void *)a1 + 99) = v130;
    a1[200] = v136;
  }
  if (v136 < 2 * v130)
  {
    double v138 = (double)v136 / v127;
LABEL_149:
    float v139 = v127;
    *((float *)a1 + 22) = v139;
    uint64_t v130 = (uint64_t)v138;
LABEL_150:
    *(void *)&a1[2 * (a4 % 5) + 24] = v130;
    goto LABEL_151;
  }
  double v138 = (double)v136 / v127;
  if (v138 > (double)v130) {
    goto LABEL_149;
  }
  if (v130 >= 1)
  {
    float v139 = (float)v136 / (float)v130;
    *((float *)a1 + 22) = v139;
    goto LABEL_150;
  }
  float v139 = v127;
  *((float *)a1 + 22) = v139;
  if (v127 > 0.0)
  {
    uint64_t v130 = (uint64_t)(3000.0 / v127);
    goto LABEL_150;
  }
LABEL_151:
  if (a4 >= 4) {
    int v140 = 4;
  }
  else {
    int v140 = a4;
  }
  BOOL v141 = __CFADD__(v140, 1);
  unsigned int v142 = v140 + 1;
  if (!v141)
  {
    unint64_t v143 = 0;
    uint64_t v144 = 0;
    uint64_t v145 = a1 + 24;
    unsigned int v146 = v142;
    do
    {
      v144 += *(void *)&v145[-10 * (v143 / 5)];
      v145 += 2;
      ++v143;
      --v146;
    }
    while (v146);
    if (v144 > 0) {
      float v139 = (float)((float)v142 * (float)v136) / (float)v144;
    }
  }
  *((float *)a1 + 23) = v139;
  *((unsigned char *)a1 + 140) = v15;
  a1[36] = 0;
  a1[41] = a6;
  float v147 = a8;
  *((float *)a1 + 42) = v147;
  if (a8 > 2.22044605e-16 && (double)((*((void *)a1 + 98) - *((void *)a1 + 19)) / v136) >= a8
    || a6 >= 1 && a5 - a1[40] >= a6)
  {
    BOOL v15 = 1;
    *((unsigned char *)a1 + 140) = 1;
  }
  int v148 = *a1;
  if (*a1 == 20 || v148 == 42)
  {
    if (a4 < 1 || a7 < 2) {
      goto LABEL_178;
    }
  }
  else if (a4 < 1 || a7 < 2 || v148 != 38)
  {
    goto LABEL_178;
  }
  if (v15)
  {
    if (*v19 < 1)
    {
      BOOL v15 = 1;
    }
    else
    {
      BOOL v15 = 0;
      *((_WORD *)a1 + 70) = 256;
    }
  }
LABEL_178:
  if (a9 > 2.22044605e-16 && (uint64_t v149 = *((void *)a1 + 98), (double)(v149 - *((void *)a1 + 26)) / (double)v136 >= a9))
  {
    *((unsigned char *)a1 + 204) = 1;
  }
  else
  {
    if (!*((unsigned char *)a1 + 204)) {
      goto LABEL_184;
    }
    uint64_t v149 = *((void *)a1 + 98);
  }
  *((void *)a1 + 26) = v149;
LABEL_184:
  if (v15)
  {
    uint64_t v150 = *((void *)a1 + 98);
    *((void *)a1 + 19) = v150;
    *((void *)a1 + 26) = v150;
    a1[40] = a5;
  }
  double v151 = *((double *)a1 + 2);
  if (v151 > 0.0)
  {
    int v152 = a1[8];
    if (v151 == 1.0)
    {
      unsigned int v153 = a1 + 9;
      a1[10] = v152;
    }
    else
    {
      a1[9] = (int)(*((double *)a1 + 3) * (double)v152);
      unsigned int v153 = a1 + 10;
    }
    *unsigned int v153 = v152;
  }
  return result;
}

void sub_1BB9FC53C(uint64_t a1, CVBufferRef buffer)
{
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 652) = 0u;
  *(_OWORD *)(a1 + 668) = 0u;
  *(_OWORD *)(a1 + 680) = 0u;
  *(void *)(a1 + 664) = 0x3FF0000000000000;
  CFMutableDictionaryRef value = 0;
  CFDictionaryRef v4 = CVBufferCopyAttachments(buffer, kCVAttachmentMode_ShouldPropagate);
  if (v4)
  {
    CFDictionaryRef v5 = v4;
    int v6 = (const void *)*MEMORY[0x1E4F51480];
    if (!CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E4F51480]))
    {
LABEL_121:
      CFRelease(v5);
      return;
    }
    CFDictionaryRef v143 = v5;
    CFDictionaryRef v7 = (const __CFDictionary *)CFDictionaryGetValue(v5, v6);
    if (!v7) {
      goto LABEL_30;
    }
    CFDictionaryRef v8 = v7;
    CFNumberRef v9 = CFDictionaryGetValue(v7, (const void *)*MEMORY[0x1E4F52700]);
    if (!v9)
    {
      if (qword_1E9F81D20 != -1) {
        dispatch_once(&qword_1E9F81D20, &unk_1F14EF240);
      }
      if (byte_1E9F81D28) {
        goto LABEL_30;
      }
      CFDictionaryRef v22 = (const __CFDictionary *)CFDictionaryGetValue(v8, @"MetadataCVA");
      if (!v22) {
        goto LABEL_30;
      }
      CFNumberRef v9 = CFDictionaryGetValue(v22, (const void *)*MEMORY[0x1E4F4D730]);
      if (!v9) {
        goto LABEL_30;
      }
    }
    CFTypeID v10 = CFGetTypeID(v9);
    if (v10 == CFArrayGetTypeID())
    {
      unsigned int Count = CFArrayGetCount((CFArrayRef)v9);
      if (Count >= 5) {
        int v12 = 5;
      }
      else {
        int v12 = Count;
      }
      *(_DWORD *)(a1 + 500) = v12;
      if (!v12)
      {
        if (*(float *)(a1 + 88) <= 30.0) {
          goto LABEL_120;
        }
        goto LABEL_37;
      }
      unint64_t v13 = 0;
      int v14 = (const void *)*MEMORY[0x1E4F52708];
      key = (const void *)*MEMORY[0x1E4F52718];
      BOOL v15 = (const void *)*MEMORY[0x1E4F52720];
      uint64_t v16 = (const void *)*MEMORY[0x1E4F52710];
      CFNumberRef v17 = (float32x4_t *)(a1 + 364);
      do
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v9, v13);
        if (ValueAtIndex)
        {
          CFDictionaryRef v19 = ValueAtIndex;
          CFTypeID v20 = CFGetTypeID(ValueAtIndex);
          if (v20 == CFDictionaryGetTypeID())
          {
            if (CFDictionaryGetValueIfPresent(v19, v14, (const void **)&value)) {
              CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, (char *)&v17[-1].u64[1] + 4);
            }
            if (!v13)
            {
              if (CFDictionaryGetValueIfPresent(v19, key, (const void **)&value)) {
                CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, (void *)(a1 + 380));
              }
              if (CFDictionaryGetValueIfPresent(v19, v15, (const void **)&value)) {
                CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, (void *)(a1 + 384));
              }
            }
            if (CFDictionaryGetValueIfPresent(v19, v16, (const void **)&value)
              && CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)value, &rect))
            {
              float32x4_t *v17 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)rect.origin), (float64x2_t)rect.size);
            }
          }
        }
        ++v13;
        unint64_t v21 = *(unsigned int *)(a1 + 500);
        CFNumberRef v17 = (float32x4_t *)((char *)v17 + 28);
      }
      while (v13 < v21);
    }
    else
    {
LABEL_30:
      LODWORD(v21) = *(_DWORD *)(a1 + 500);
    }
    if (*(float *)(a1 + 88) <= 30.0)
    {
LABEL_41:
      if (v21) {
        goto LABEL_42;
      }
LABEL_120:
      CFDictionaryRef v5 = v143;
      goto LABEL_121;
    }
    if (v21)
    {
      *(_DWORD *)(a1 + 644) = v21;
      unint64_t v21 = v21;
      uint64_t v23 = (_OWORD *)(a1 + 504);
      do
      {
        *uint64_t v23 = *(v23 - 9);
        *(_OWORD *)((char *)v23 + 12) = *(_OWORD *)((char *)v23 - 132);
        uint64_t v23 = (_OWORD *)((char *)v23 + 28);
        --v21;
      }
      while (v21);
LABEL_42:
      if (*(_DWORD *)(a1 + 836))
      {
        uint64_t v27 = 0;
        uint64_t v144 = (void *)*MEMORY[0x1E4F24E20];
        __asm { FMOV            V0.2D, #-1.0 }
        *(_OWORD *)keya = _Q0;
        while (1)
        {
          CGSize v33 = (CGSize)vcvtq_f64_f32(*(float32x2_t *)(a1 + 28 * v27 + 372));
          rect.origin = (CGPoint)vcvtq_f64_f32(*(float32x2_t *)(a1 + 28 * v27 + 364));
          rect.CGSize size = v33;
          if (CVPixelBufferLockBaseAddress(buffer, 0)) {
            goto LABEL_45;
          }
          OSType PixelFormatType = CVPixelBufferGetPixelFormatType(buffer);
          DescriptionWithOSType PixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
          if (!DescriptionWithPixelFormatType) {
            goto LABEL_45;
          }
          CFNumberRef v36 = (const __CFNumber *)CFDictionaryGetValue(DescriptionWithPixelFormatType, v144);
          if (!v36) {
            goto LABEL_45;
          }
          v156[0] = 0;
          CFNumberGetValue(v36, kCFNumberSInt32Type, v156);
          int IsSubsampled = CVPixelFormatTypeIsSubsampled();
          size_t Width = CVPixelBufferGetWidth(buffer);
          size_t Height = CVPixelBufferGetHeight(buffer);
          float valuePtr = (char *)CVPixelBufferGetBaseAddressOfPlane(buffer, 0);
          BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(buffer, 1uLL);
          int BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(buffer, 0);
          int v41 = CVPixelBufferGetBytesPerRowOfPlane(buffer, 1uLL);
          unint64_t v42 = Width;
          int v43 = IsSubsampled;
          unint64_t v44 = Width << (IsSubsampled == 0);
          unint64_t v45 = Height >> (IsSubsampled != 0);
          if (IsSubsampled) {
            unsigned int v46 = 1;
          }
          else {
            unsigned int v46 = 2;
          }
          if ((PixelFormatType & 0xFFFFFFEF) == 0x34323066)
          {
            int v47 = 0;
            v48.f64[0] = (double)v44 * 0.5;
            v48.f64[1] = (double)v45;
            CGSize size = rect.size;
            int32x2_t v50 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v48))), 0);
            v51.i64[0] = v50.u32[0];
            v51.i64[1] = v50.u32[1];
            float64x2_t v52 = vcvtq_f64_s64(v51);
            int32x2_t v53 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v48, v52), (int8x16_t)v52, (int8x16_t)vaddq_f64(v48, *(float64x2_t *)keya))));
            *(int32x2_t *)&v52.f64[0] = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.size, v48))), 0);
            int32x2_t v54 = vadd_s32(*(int32x2_t *)&v52.f64[0], v53);
            v51.i64[0] = v54.i32[0];
            v51.i64[1] = v54.i32[1];
            int8x16_t v55 = (int8x16_t)vcgeq_f64(v48, vcvtq_f64_s64(v51));
            v51.i64[0] = LODWORD(v52.f64[0]);
            v51.i64[1] = HIDWORD(v52.f64[0]);
            int8x16_t v56 = (int8x16_t)vcvtq_f64_s64(v51);
            v51.i64[0] = v53.i32[0];
            v51.i64[1] = v53.i32[1];
            int32x2_t v57 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v55, v56, (int8x16_t)vsubq_f64(v48, vcvtq_f64_s64(v51)))));
            __int32 v58 = 2 * v53.i32[0];
            CFTypeID v59 = &BaseAddressOfPlane[(v53.i32[1] * v41 + 2 * v53.i32[0]) & 0x1FFFFFFF];
            __int32 v60 = v57.i32[0];
            do
            {
              if (v57.i32[0] >= 1)
              {
                uint64_t v61 = 0;
                do
                  *(_WORD *)&v59[2 * v61++] = -32640;
                while (v57.i32[0] != v61);
              }
              ++v47;
              v59 += v41;
            }
            while (v47 != v46);
            if ((int)(v57.i32[1] - 2 * v46) > 0)
            {
              int v62 = 0;
              do
              {
                uint64_t v63 = 0;
                do
                  *(_WORD *)&v59[2 * v63++] = -32640;
                while (v46 != v63);
                CFNumberRef v64 = &v59[2 * v57.i32[0] + -2 * v46];
                unsigned int v65 = v46;
                do
                {
                  *(_WORD *)CFNumberRef v64 = -32640;
                  v64 += 2;
                  --v65;
                }
                while (v65);
                ++v62;
                v59 += v41;
              }
              while (v62 != v57.i32[1] - 2 * v46);
            }
            for (int i = 0; i != v46; ++i)
            {
              if (v57.i32[0] >= 1)
              {
                uint64_t v67 = 0;
                do
                  *(_WORD *)&v59[2 * v67++] = -32640;
                while (v57.i32[0] != v67);
              }
              v59 += v41;
            }
            int v68 = 0;
            v69.i64[0] = Width;
            v69.i64[1] = Height;
            float64x2_t v78 = vcvtq_f64_u64(v69);
            int32x2_t v70 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v78))), 0);
            v71.i64[0] = v70.u32[0];
            v71.i64[1] = v70.u32[1];
            float64x2_t v72 = vcvtq_f64_s64(v71);
            double v73 = COERCE_DOUBLE(vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v78, v72), (int8x16_t)v72, (int8x16_t)vaddq_f64(v78, *(float64x2_t *)keya)))));
            int32x2_t v74 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)size, v78))), 0);
            int32x2_t v75 = vadd_s32(v74, *(int32x2_t *)&v73);
            v71.i64[0] = v75.i32[0];
            v71.i64[1] = v75.i32[1];
            int8x16_t v79 = (int8x16_t)vcgeq_f64(v78, vcvtq_f64_s64(v71));
            v71.i64[0] = v74.u32[0];
            v71.i64[1] = v74.u32[1];
            int8x16_t v76 = (int8x16_t)vcvtq_f64_s64(v71);
            v71.i64[0] = SLODWORD(v73);
            v71.i64[1] = SHIDWORD(v73);
            double v77 = COERCE_DOUBLE(vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v79, v76, (int8x16_t)vsubq_f64(v78, vcvtq_f64_s64(v71))))));
            HIDWORD(v78.f64[0]) = HIDWORD(v73);
            v79.i32[1] = HIDWORD(v77);
            if (IsSubsampled)
            {
              v79.i32[0] = 2 * v60;
              double v77 = *(double *)v79.i64;
            }
            else
            {
              v78.f64[0] = v73;
              __int32 v58 = LODWORD(v73);
            }
            CFIndex v80 = &valuePtr[(v58 + HIDWORD(v78.f64[0]) * BytesPerRowOfPlane) & 0x1FFFFFFF];
            if (SLODWORD(v77) <= 1) {
              int v81 = 1;
            }
            else {
              int v81 = LODWORD(v77);
            }
            do
            {
              if (SLODWORD(v77) >= 1)
              {
                uint64_t v82 = 0;
                do
                  v80[v82++] = -21;
                while (v81 != v82);
              }
              ++v68;
              v80 += BytesPerRowOfPlane;
            }
            while (v68 != 2);
            if (SHIDWORD(v77) >= 5)
            {
              int v83 = HIDWORD(v77) - 4;
              do
              {
                *(_WORD *)CFIndex v80 = -5141;
                *(_WORD *)&v80[SLODWORD(v77) - 2] = -5141;
                v80 += BytesPerRowOfPlane;
                --v83;
              }
              while (v83);
            }
            for (int j = 0; j != 2; ++j)
            {
              if (SLODWORD(v77) >= 1)
              {
                uint64_t v85 = 0;
                do
                  v80[v85++] = -21;
                while (v81 != v85);
              }
              v80 += BytesPerRowOfPlane;
            }
            goto LABEL_45;
          }
          if (PixelFormatType == 1882468912) {
            break;
          }
          if (PixelFormatType == 2016686640)
          {
            int v86 = 0;
            v87.i64[0] = Width;
            v87.i64[1] = Height;
            float64x2_t v88 = vcvtq_f64_u64(v87);
            CGSize v89 = rect.size;
            int32x2_t v90 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v88))), 0);
            v91.i64[0] = v90.u32[0];
            v91.i64[1] = v90.u32[1];
            float64x2_t v92 = vcvtq_f64_s64(v91);
            *(int32x2_t *)&v92.f64[0] = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v88, v92), (int8x16_t)v92, (int8x16_t)vaddq_f64(v88, *(float64x2_t *)keya))));
            int32x2_t v93 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.size, v88))), 0);
            int32x2_t v94 = vadd_s32(v93, *(int32x2_t *)&v92.f64[0]);
            v91.i64[0] = SLODWORD(v92.f64[0]);
            v91.i64[1] = SHIDWORD(v92.f64[0]);
            int64x2_t v95 = v91;
            int v96 = HIDWORD(v92.f64[0]) * BytesPerRowOfPlane + 2 * LODWORD(v92.f64[0]);
            v91.i64[0] = v94.i32[0];
            v91.i64[1] = v94.i32[1];
            int8x16_t v97 = (int8x16_t)vcgeq_f64(v88, vcvtq_f64_s64(v91));
            v91.i64[0] = v93.u32[0];
            v91.i64[1] = v93.u32[1];
            int32x2_t v98 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v97, (int8x16_t)vcvtq_f64_s64(v91), (int8x16_t)vsubq_f64(v88, vcvtq_f64_s64(v95)))));
            int v154 = 0;
            CFDictionaryRef v99 = &valuePtr[v96 & 0x1FFFFFFF];
            do
            {
              if (v98.i32[0] >= 1)
              {
                uint64_t v100 = 0;
                do
                  *(_WORD *)&v99[2 * v100++] = 235;
                while (v98.i32[0] != v100);
              }
              ++v86;
              v99 += BytesPerRowOfPlane;
            }
            while (v86 != 2);
            if (v98.i32[1] >= 5)
            {
              int v101 = v98.i32[1] - 4;
              do
              {
                *(_DWORD *)CFDictionaryRef v99 = 15401195;
                *(_DWORD *)&v99[2 * v98.i32[0] - 4] = 15401195;
                v99 += BytesPerRowOfPlane;
                --v101;
              }
              while (v101);
            }
            for (int k = 0; k != 2; ++k)
            {
              if (v98.i32[0] >= 1)
              {
                uint64_t v103 = 0;
                do
                  *(_WORD *)&v99[2 * v103++] = 235;
                while (v98.i32[0] != v103);
              }
              v99 += BytesPerRowOfPlane;
            }
            v104.f64[0] = (double)v44 * 0.5;
            v104.f64[1] = (double)v45;
            int32x2_t v105 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v104))), 0);
            v106.i64[0] = v105.u32[0];
            v106.i64[1] = v105.u32[1];
            float64x2_t v107 = vcvtq_f64_s64(v106);
            *(int32x2_t *)&v107.f64[0] = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v104, v107), (int8x16_t)v107, (int8x16_t)vaddq_f64(v104, *(float64x2_t *)keya))));
            int32x2_t v108 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)v89, v104))), 0);
            int32x2_t v109 = vadd_s32(v108, *(int32x2_t *)&v107.f64[0]);
            v106.i64[0] = v109.i32[0];
            v106.i64[1] = v109.i32[1];
            int8x16_t v110 = (int8x16_t)vcgeq_f64(v104, vcvtq_f64_s64(v106));
            v106.i64[0] = v108.u32[0];
            v106.i64[1] = v108.u32[1];
            int8x16_t v111 = (int8x16_t)vcvtq_f64_s64(v106);
            v106.i64[0] = SLODWORD(v107.f64[0]);
            v106.i64[1] = SHIDWORD(v107.f64[0]);
            int32x2_t v151 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v110, v111, (int8x16_t)vsubq_f64(v104, vcvtq_f64_s64(v106)))));
            int32x2_t v152 = *(int32x2_t *)&v107.f64[0];
            unsigned int v153 = &BaseAddressOfPlane[(HIDWORD(v107.f64[0]) * v41 + 4 * LODWORD(v107.f64[0])) & 0x1FFFFFFF];
            int v155 = v41;
            int v112 = 8388736;
LABEL_118:
            sub_1BBA268EC((uint64_t *)&v153, (int *)&v151, v112, v46);
          }
LABEL_45:
          CVPixelBufferUnlockBaseAddress(buffer, 1uLL);
          if (++v27 >= (unint64_t)*(unsigned int *)(a1 + 500)) {
            goto LABEL_120;
          }
        }
        v113.f64[0] = (double)v44 / 6.0;
        v113.f64[1] = (double)v45;
        CGSize v114 = rect.size;
        int32x2_t v115 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v113))), 0);
        v116.i64[0] = v115.u32[0];
        v116.i64[1] = v115.u32[1];
        float64x2_t v117 = vcvtq_f64_s64(v116);
        int32x2_t v118 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v113, v117), (int8x16_t)v117, (int8x16_t)vaddq_f64(v113, *(float64x2_t *)keya))));
        int32x2_t v119 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.size, v113))), 0);
        int32x2_t v120 = vadd_s32(v119, v118);
        v116.i64[0] = v120.i32[0];
        v116.i64[1] = v120.i32[1];
        int8x16_t v121 = (int8x16_t)vcgeq_f64(v113, vcvtq_f64_s64(v116));
        v116.i64[0] = v119.u32[0];
        v116.i64[1] = v119.u32[1];
        int8x16_t v122 = (int8x16_t)vcvtq_f64_s64(v116);
        v116.i64[0] = v118.i32[0];
        v116.i64[1] = v118.i32[1];
        int32x2_t v123 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v121, v122, (int8x16_t)vsubq_f64(v113, vcvtq_f64_s64(v116)))));
        __int32 v124 = v118.i32[0];
        int v154 = 0;
        int v155 = v41;
        __int32 v125 = v123.i32[0];
        __int32 v126 = v123.i32[0];
        double v127 = &BaseAddressOfPlane[(v118.i32[1] * v41 + 8 * v118.i32[0]) & 0x1FFFFFFF];
        if (v123.i32[0] >= 1)
        {
          do
          {
            *(void *)double v127 = 0x802008008020080;
            v127 += 8;
            --v126;
          }
          while (v126);
        }
        double v128 = &BaseAddressOfPlane[((v118.i32[1] * v41 + 8 * v118.i32[0]) & 0x1FFFFFFF) + v41];
        unsigned int v153 = v128;
        int v129 = v123.i32[1] - 2;
        if (v123.i32[1] <= 2)
        {
          int v131 = BytesPerRowOfPlane;
          uint64_t v130 = valuePtr;
        }
        else
        {
          int v131 = BytesPerRowOfPlane;
          uint64_t v130 = valuePtr;
          do
          {
            *(void *)double v128 = 0x802008008020080;
            *(void *)&v128[8 * v123.i32[0] - 8] = 0x802008008020080;
            v128 += v41;
            --v129;
          }
          while (v129);
        }
        __int32 v132 = v123.i32[0];
        if (v123.i32[0] >= 1)
        {
          do
          {
            *(void *)double v128 = 0x802008008020080;
            v128 += 8;
            --v132;
          }
          while (v132);
        }
        v133.f64[0] = (double)v42 / 3.0;
        v133.f64[1] = (double)Height;
        int32x2_t v134 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)rect.origin, v133))), 0);
        v135.i64[0] = v134.u32[0];
        v135.i64[1] = v134.u32[1];
        float64x2_t v136 = vcvtq_f64_s64(v135);
        int32x2_t v137 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v133, v136), (int8x16_t)v136, (int8x16_t)vaddq_f64(v133, *(float64x2_t *)keya))));
        int32x2_t v138 = vmax_s32(vmovn_s64(vcvtq_s64_f64(vmulq_f64((float64x2_t)v114, v133))), 0);
        int32x2_t v139 = vadd_s32(v138, v137);
        v135.i64[0] = v139.i32[0];
        v135.i64[1] = v139.i32[1];
        int8x16_t v140 = (int8x16_t)vcgeq_f64(v133, vcvtq_f64_s64(v135));
        v135.i64[0] = v138.u32[0];
        v135.i64[1] = v138.u32[1];
        int8x16_t v141 = (int8x16_t)vcvtq_f64_s64(v135);
        v135.i64[0] = v137.i32[0];
        v135.i64[1] = v137.i32[1];
        int32x2_t v151 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8(v140, v141, (int8x16_t)vsubq_f64(v133, vcvtq_f64_s64(v135)))));
        int32x2_t v152 = v137;
        if (v43)
        {
          int v142 = 2 * v124;
          v152.i32[0] = v142;
          v151.i32[0] = 2 * v125;
        }
        else
        {
          int v142 = v137.i32[0];
        }
        unsigned int v153 = &v130[(v137.i32[1] * v131 + 4 * v142) & 0x1FFFFFFF];
        int v155 = v131;
        int v112 = 246656235;
        unsigned int v46 = 2;
        goto LABEL_118;
      }
      goto LABEL_120;
    }
LABEL_37:
    int v24 = *(_DWORD *)(a1 + 644);
    *(_DWORD *)(a1 + 500) = v24;
    *(_DWORD *)(a1 + 644) = 0;
    if (!v24) {
      goto LABEL_120;
    }
    unint64_t v25 = 0;
    uint64_t v26 = (_OWORD *)(a1 + 360);
    do
    {
      *uint64_t v26 = v26[9];
      *(_OWORD *)((char *)v26 + 12) = *(_OWORD *)((char *)v26 + 156);
      ++v25;
      uint64_t v26 = (_OWORD *)((char *)v26 + 28);
    }
    while (v25 < *(unsigned int *)(a1 + 500));
    LODWORD(v21) = *(_DWORD *)(a1 + 500);
    goto LABEL_41;
  }
}

void sub_1BB9FD0D0()
{
  if (!*MEMORY[0x1E4F4D730]) {
    byte_1E9F81D28 = 1;
  }
}

uint64_t sub_1BB9FD104(void *a1, uint64_t a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a1[4];
  if (v2 + 15 >= v3)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    do
    {
      int8x16_t v5 = *(int8x16_t *)(a1[2] + v2);
      *(int8x16_t *)(a2 + v4) = v5;
      int64x2_t v6 = (int64x2_t)vceqzq_s8(v5);
      if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).u64[0])
      {
        uint64_t v7 = a1[2];
        do
        {
          unint64_t v8 = v2;
          uint64_t v9 = v4++;
          ++v2;
        }
        while (*(unsigned char *)(v7 + v8));
        if (v8 + 2 < a1[4])
        {
          int v10 = *(unsigned __int8 *)(v7 + v2);
          if ((*(unsigned __int8 *)(v7 + v8 + 2) | (v10 << 8)) == 3)
          {
            *(unsigned char *)(a2 + v4) = v10;
            unint64_t v2 = v8 + 3;
            uint64_t v4 = v9 + 2;
          }
        }
      }
      else
      {
        v2 += 16;
        v4 += 16;
      }
      unint64_t v3 = a1[4];
    }
    while (v2 + 15 < v3);
  }
  while (v2 < v3)
  {
    int v11 = (unsigned __int8 *)(a1[2] + v2);
    int v12 = *v11;
    if (v2 + 2 < v3 && ((v12 << 16) | (v11[1] << 8) | v11[2]) == 3)
    {
      *(unsigned char *)(a2 + v4++) = v12;
      LOBYTE(v12) = *(unsigned char *)(v2 + a1[2] + 1);
      v2 += 2;
    }
    *(unsigned char *)(a2 + v4++) = v12;
    ++v2;
    unint64_t v3 = a1[4];
  }
  return v4;
}

uint64_t sub_1BB9FD21C(char *a1, int a2, int8x16_t *a3, uint64_t a4, uint64_t a5)
{
  size_t v9 = (a2 + 2);
  bzero(a1, v9);
  a1[v9] = 1;
  int v10 = (int8x16_t *)&a1[v9 + 1];
  if (a5)
  {
    uint64_t v11 = a5;
    do
    {
      __int8 v12 = a3->i8[0];
      a3 = (int8x16_t *)((char *)a3 + 1);
      v10->i8[0] = v12;
      int v10 = (int8x16_t *)((char *)v10 + 1);
      --v11;
    }
    while (v11);
  }
  unint64_t v13 = a4 - a5;
  if ((unint64_t)(a4 - a5) < 0x10) {
    goto LABEL_22;
  }
  while (1)
  {
    int8x16_t v14 = *a3;
    int8x16_t *v10 = *a3;
    if (!vaddvq_s32((int32x4_t)vceqzq_s8(v14)))
    {
      ++v10;
      ++a3;
      v13 -= 16;
      goto LABEL_21;
    }
    uint64_t v15 = 0;
    while (v10->u8[v15++])
      ;
    int v10 = (int8x16_t *)((char *)v10 + v15);
    unint64_t v17 = v13 - v15;
    if (!v17) {
      return (char *)v10 - a1;
    }
    int v18 = &a3->u8[v15];
    int v19 = 1;
    while (v19 != 2)
    {
      int v19 = 2;
LABEL_14:
      int v21 = *v18;
      v10->i8[0] = v21;
      int v10 = (int8x16_t *)((char *)v10 + 1);
      if (v21)
      {
        a3 = (int8x16_t *)(v18 + 1);
        goto LABEL_20;
      }
      ++v18;
      if (!--v17) {
        return (char *)v10 - a1;
      }
    }
    unsigned int v20 = *v18;
    if (v20 < 4)
    {
      v10->i8[0] = 3;
      int v10 = (int8x16_t *)((char *)v10 + 1);
      int v19 = 1;
      goto LABEL_14;
    }
    a3 = (int8x16_t *)(v18 + 1);
    v10->i8[0] = v20;
    int v10 = (int8x16_t *)((char *)v10 + 1);
LABEL_20:
    unint64_t v13 = v17 - 1;
LABEL_21:
    if (v13 <= 0xF)
    {
LABEL_22:
      if (v13)
      {
        int v22 = 0;
        do
        {
          unsigned int v23 = a3->u8[0];
          if (v22 == 2)
          {
            if (v23 > 3)
            {
              int v22 = 2;
            }
            else
            {
              int v22 = 0;
              v10->i8[0] = 3;
              int v10 = (int8x16_t *)((char *)v10 + 1);
              unsigned int v23 = a3->u8[0];
            }
          }
          if (v23) {
            int v22 = 0;
          }
          else {
            ++v22;
          }
          a3 = (int8x16_t *)((char *)a3 + 1);
          v10->i8[0] = v23;
          int v10 = (int8x16_t *)((char *)v10 + 1);
          --v13;
        }
        while (v13);
      }
      return (char *)v10 - a1;
    }
  }
}

unint64_t sub_1BB9FD398(uint64_t *a1)
{
  unint64_t v2 = *((unsigned int *)a1 + 70);
  int v3 = *((_DWORD *)a1 + 69);
  if (*((unsigned char *)a1 + 284) == 8) {
    char v4 = 3;
  }
  else {
    char v4 = 2;
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t *, void))(*a1 + 32))(a1, 0);
  int v6 = v3 / 16;
  if ((int)v2 < 8)
  {
    unint64_t v7 = 0;
  }
  else
  {
    unint64_t v7 = 0;
    uint64_t v8 = a1[14] >> v4;
    uint64_t v9 = v5 + 56 * v8 + 16;
    for (unint64_t i = 7; i < v2; i += 16)
    {
      int8x16_t v11 = 0uLL;
      int8x16_t v12 = 0uLL;
      if (v3 >= 32)
      {
        unint64_t v13 = (int8x16_t *)v9;
        uint64_t v14 = v6 >> 1;
        do
        {
          int8x16_t v12 = veorq_s8(v13[-1], v12);
          int8x16_t v11 = veorq_s8(*v13, v11);
          v13 += 2;
          --v14;
        }
        while (v14);
      }
      if (v6) {
        int8x16_t v12 = veorq_s8(*(int8x16_t *)(v5 + 8 * v8 * i + 8 * (2 * v6 - 2)), v12);
      }
      int8x16_t v15 = veorq_s8(v12, v11);
      v7 ^= *(void *)&veor_s8(*(int8x8_t *)v15.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
      v9 += v8 << 7;
    }
  }
  uint64_t v16 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 32))(a1, 1);
  if ((int)v2 < 16)
  {
    unint64_t v17 = 0;
  }
  else
  {
    unint64_t v17 = 0;
    uint64_t v18 = a1[15] >> v4;
    uint64_t v19 = v16 + 56 * v18 + 16;
    unint64_t v20 = 7;
    do
    {
      int8x16_t v21 = 0uLL;
      int8x16_t v22 = 0uLL;
      if (v3 >= 32)
      {
        unsigned int v23 = (int8x16_t *)v19;
        uint64_t v24 = v6 >> 1;
        do
        {
          int8x16_t v22 = veorq_s8(v23[-1], v22);
          int8x16_t v21 = veorq_s8(*v23, v21);
          v23 += 2;
          --v24;
        }
        while (v24);
      }
      if (v6) {
        int8x16_t v22 = veorq_s8(*(int8x16_t *)(v16 + 8 * v18 * v20 + 8 * (2 * v6 - 2)), v22);
      }
      int8x16_t v25 = veorq_s8(v22, v21);
      v17 ^= *(void *)&veor_s8(*(int8x8_t *)v25.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL));
      v20 += 8;
      v19 += v18 << 6;
    }
    while (v20 < v2 >> 1);
  }
  unint64_t v26 = v17 ^ HIDWORD(v17);
  return ((unsigned __int16)(WORD1(v26) ^ v26) ^ (unsigned __int16)((WORD1(v26) ^ (unsigned __int16)v26) << 8)) & 0xFF00 | (((v7 ^ HIDWORD(v7)) >> 16) ^ v7 ^ BYTE4(v7)) ^ ((((v7 ^ HIDWORD(v7)) >> 16) ^ (unsigned __int16)(v7 ^ WORD2(v7))) >> 8);
}

uint64_t sub_1BB9FD5E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v35 = a5;
  uint64_t v36 = a7;
  uint64_t v34 = a4;
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  unsigned __int16 v7 = (unsigned __int16)off_1E9F81F90;
  if (off_1E9F81F90)
  {
    v29[1] = v29;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    MEMORY[0x1F4188790]();
    unint64_t v13 = (char *)v29 - v12;
    char v14 = 0;
    uint64_t v15 = 0;
    CFTypeID v31 = (char *)&v29[2] - v12;
    int v16 = 1;
    do
    {
      int v30 = v16;
      if (*(int *)(a3 + 4 * v15) >= 8)
      {
        int v17 = *(_DWORD *)(a2 + 4 * v15);
        uint64_t v18 = (*(_DWORD *)(a6 + 4 * v15) + 7);
        uint64_t v32 = 2 * (v17 >> 4) - 2;
        uint64_t v33 = (v17 >> 4) >> 1;
        do
        {
          off_1E9F81F90(v13, *(void *)(a1 + 8 * v15), v18, *(unsigned int *)(a2 + 4 * v15), *(unsigned int *)(v34 + 4 * v15), v36, v14 & 1);
          uint64_t v19 = *(int *)(v35 + 4 * v15);
          int8x16_t v20 = 0uLL;
          int8x16_t v21 = 0uLL;
          if (v17 >= 32)
          {
            int8x16_t v22 = (int8x16_t *)&v31[v19];
            uint64_t v23 = v33;
            do
            {
              int8x16_t v21 = veorq_s8(v22[-1], v21);
              int8x16_t v20 = veorq_s8(*v22, v20);
              v22 += 2;
              --v23;
            }
            while (v23);
          }
          if ((v17 & 0x10) != 0) {
            int8x16_t v21 = veorq_s8(*(int8x16_t *)&v13[8 * v32 + v19], v21);
          }
          int8x16_t v24 = veorq_s8(v21, v20);
          *(&v37 + v15) ^= *(void *)&veor_s8(*(int8x8_t *)v24.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
          uint64_t v18 = (dword_1BBB7812C[v15] + v18);
        }
        while ((int)v18 < *(_DWORD *)(a6 + 4 * v15) + *(_DWORD *)(a3 + 4 * v15));
      }
      int v16 = 0;
      char v14 = 1;
      uint64_t v15 = 1;
    }
    while ((v30 & 1) != 0);
    uint64_t v25 = 0;
    char v26 = 1;
    do
    {
      char v27 = v26;
      *(&v37 + v25) = (*(&v37 + v25) ^ HIDWORD(*(&v37 + v25)) ^ ((*(&v37 + v25) ^ HIDWORD(*(&v37 + v25))) >> 16)) ^ (((unsigned __int16)(*(&v37 + v25) ^ HIDWORD(*(&v37 + v25))) ^ ((*(&v37 + v25) ^ HIDWORD(*(&v37 + v25))) >> 16)) >> 8);
      uint64_t v25 = 1;
      char v26 = 0;
    }
    while ((v27 & 1) != 0);
    return (unsigned __int16)(v37 | ((_WORD)v38 << 8));
  }
  return v7;
}

uint64_t sub_1BB9FD828(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v54 = a1;
  uint64_t v55 = a4;
  v49[1] = v49;
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  MEMORY[0x1F4188790]();
  uint64_t v9 = (int8x16_t *)((char *)v49 - v8);
  uint64_t v10 = 0;
  int64x2_t v51 = (char *)&v49[2] - v8;
  int v11 = 1;
  do
  {
    int v50 = v11;
    if (*(int *)(v5 + 4 * v10) >= 8)
    {
      int v12 = *(_DWORD *)(v7 + 4 * v10) + 7;
      int v13 = *(_DWORD *)(v4 + 4 * v10);
      uint64_t v52 = 2 * (v13 >> 4) - 2;
      uint64_t v53 = (v13 >> 4) >> 1;
      uint64_t v14 = 264;
      if (v50) {
        uint64_t v14 = 0;
      }
      uint64_t v15 = (_DWORD *)((char *)&unk_1BBB82F60 + v14);
      int v16 = v15[1];
      int v17 = v15[2];
      int v18 = v15[3] / (v17 * v16);
      int v19 = v18 * v16;
      int v20 = 8 * v18;
      int8x16_t v56 = v15 + 5;
      int v21 = v16 / 8;
      int v22 = dword_1BBB7812C[v10];
      while (1)
      {
        int v23 = *(_DWORD *)(v4 + 4 * v10);
        if (v23 >= 1) {
          break;
        }
LABEL_26:
        uint64_t v39 = *(int *)(v6 + 4 * v10);
        int8x16_t v40 = 0uLL;
        int8x16_t v41 = 0uLL;
        if (v13 >= 32)
        {
          unint64_t v42 = (int8x16_t *)&v51[v39];
          uint64_t v43 = v53;
          do
          {
            int8x16_t v41 = veorq_s8(v42[-1], v41);
            int8x16_t v40 = veorq_s8(*v42, v40);
            v42 += 2;
            --v43;
          }
          while (v43);
        }
        if ((v13 & 0x10) != 0) {
          int8x16_t v41 = veorq_s8(*(int8x16_t *)((char *)v9 + 8 * v52 + v39), v41);
        }
        int8x16_t v44 = veorq_s8(v41, v40);
        *(&v57 + v10) ^= *(void *)&veor_s8(*(int8x8_t *)v44.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL));
        v12 += v22;
        if (v12 >= *(_DWORD *)(v7 + 4 * v10) + *(_DWORD *)(v5 + 4 * v10)) {
          goto LABEL_32;
        }
      }
      int v24 = 0;
      uint64_t v25 = *v56;
      int v26 = v25 * v21;
      int v27 = v12 % v17;
      if (v12 % v17 >= 0) {
        int v28 = v12 % v17;
      }
      else {
        int v28 = v12 % v17 + 3;
      }
      CFArrayRef v29 = (int8x16x4_t *)(*(void *)(v54 + 8 * v10)
                          + v17 * *(_DWORD *)(v55 + 4 * v10) * (v12 / v17)
                          + v26 * (v28 >> 2));
      uint64_t v30 = v26 * (v17 / 4 - 1);
      uint64_t v31 = (int)(v27 - (v28 & 0xFFFFFFFC));
      uint64_t v32 = v9;
      while (1)
      {
        int v33 = 8 * v18;
        if (v19 >= 1) {
          break;
        }
LABEL_25:
        CFArrayRef v29 = (int8x16x4_t *)((char *)v29 + v30);
        v24 += v19;
        if (v24 >= v23) {
          goto LABEL_26;
        }
      }
      while (1)
      {
        if (v18 == 2)
        {
          uint64_t v37 = (int8x16_t *)&xmmword_1E9F82030;
          if (v31 <= 2) {
            uint64_t v37 = (int8x16_t *)*((void *)&off_1E62485E8 + v31);
          }
          *uint64_t v32 = vqtbl4q_s8(*v29, *v37);
          goto LABEL_23;
        }
        if (v18 == 1) {
          break;
        }
LABEL_23:
        CFArrayRef v29 = (int8x16x4_t *)((char *)v29 + v25);
        uint64_t v32 = (int8x16_t *)((char *)v32 + v20);
        if (v33 < v19)
        {
          int v38 = v24 + v33;
          v33 += v20;
          if (v38 < v23) {
            continue;
          }
        }
        goto LABEL_25;
      }
      int8x16_t v34 = v29->val[0];
      int8x16_t v35 = v29->val[1];
      if ((int)v31 > 1)
      {
        int8x16_t v36 = vqtbl2q_s8(*(int8x16x2_t *)v34.i8, (int8x16_t)xmmword_1BBB6F520);
        if ((v27 & 1) == 0)
        {
LABEL_22:
          v32->i64[0] = v36.i64[0];
          goto LABEL_23;
        }
      }
      else
      {
        int8x16_t v36 = vqtbl2q_s8(*(int8x16x2_t *)v34.i8, (int8x16_t)xmmword_1BBB6F530);
        if ((v27 & 1) == 0) {
          goto LABEL_22;
        }
      }
      v36.i64[0] = vextq_s8(v36, v36, 8uLL).u64[0];
      goto LABEL_22;
    }
LABEL_32:
    int v11 = 0;
    uint64_t v10 = 1;
  }
  while ((v50 & 1) != 0);
  uint64_t v45 = 0;
  char v46 = 1;
  do
  {
    char v47 = v46;
    *(&v57 + v45) = (*(&v57 + v45) ^ HIDWORD(*(&v57 + v45)) ^ ((*(&v57 + v45) ^ HIDWORD(*(&v57 + v45))) >> 16)) ^ (((unsigned __int16)(*(&v57 + v45) ^ HIDWORD(*(&v57 + v45))) ^ ((*(&v57 + v45) ^ HIDWORD(*(&v57 + v45))) >> 16)) >> 8);
    uint64_t v45 = 1;
    char v46 = 0;
  }
  while ((v47 & 1) != 0);
  return (v58 << 8) | (unsigned __int16)v57;
}

char *sub_1BB9FDBA4(char *result, uint64_t a2, long long *a3, uint64_t a4, unsigned char *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  long long v9 = a3[2];
  long long v10 = a3[3];
  int v12 = a7 + 2;
  do
  {
    int v13 = result;
    int8x16x2_t v23 = vld2q_s8(v13);
    _X10 = (char *)&v13[a2];
    uint64_t v15 = result + 32;
    int8x16x2_t v24 = vld2q_s8(v15);
    __asm { PRFM            #0, [X0,#0x40] }
    int v21 = _X10;
    int8x16x2_t v25 = vld2q_s8(v21);
    v21 += 32;
    int8x16x2_t v26 = vld2q_s8(v21);
    __asm { PRFM            #0, [X10,#0x40] }
    *a5 = v24.val[0].i8[15];
    a5[1] = v24.val[1].i8[15];
    a5[2] = v26.val[0].i8[15];
    a5[3] = v26.val[1].i8[15];
    v23.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v23.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v23.val[0], 3uLL)));
    v23.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v23.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v23.val[1], 3uLL)));
    v24.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v24.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v24.val[0], 3uLL)));
    v24.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v24.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v24.val[1], 3uLL)));
    v25.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v25.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v25.val[0], 3uLL)));
    v25.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v25.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v25.val[1], 3uLL)));
    vst2q_s8(result, v23);
    uint64_t v11 = 2 * a2;
    result += v11;
    vst2q_s8(v15, v24);
    v26.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v26.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v26.val[0], 3uLL)));
    vst2q_s8(_X10, v25);
    v26.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v26.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v26.val[1], 3uLL)));
    vst2q_s8(v21, v26);
    v12 -= 2;
    a5 += 4;
  }
  while (v12 > 2);
  return result;
}

__int16 *sub_1BB9FDC78(__int16 *result, uint64_t a2, long long *a3, uint64_t a4, void *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  long long v9 = a3[2];
  long long v10 = a3[3];
  int v12 = a7 + 2;
  v14.i64[0] = 0xFC00FC00FC00FC00;
  v14.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    uint64_t v15 = result;
    int16x8x2_t v42 = vld2q_s16(v15);
    uint64_t v11 = a2;
    _X11 = (__int16 *)&v15[v11];
    int v17 = result + 16;
    int16x8x2_t v36 = vld2q_s16(v17);
    int v18 = result + 32;
    int16x8x2_t v45 = vld2q_s16(v18);
    int v19 = result + 48;
    int8x16x2_t v44 = (int8x16x2_t)vld2q_s16(v19);
    __asm
    {
      PRFM            #0, [X0,#0x80]
      PRFM            #0, [X0,#0xC0]
    }
    int8x16x2_t v26 = _X11;
    int16x8x2_t v41 = vld2q_s16(v26);
    v26 += 16;
    int16x8x2_t v40 = vld2q_s16(v26);
    int v27 = _X11 + 32;
    int16x8x2_t v38 = vld2q_s16(v27);
    int v28 = _X11 + 48;
    int8x16x2_t v39 = (int8x16x2_t)vld2q_s16(v28);
    LODWORD(v29) = vqtbl2q_s8(v44, (int8x16_t)xmmword_1BBB6F440).u32[0];
    HIDWORD(v29) = vqtbl2q_s8(v39, (int8x16_t)xmmword_1BBB6F430).i32[1];
    int8x16_t v30 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v42.val[0], 5uLL), v36.val[0], 5uLL));
    int8x16_t v31 = vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v42.val[1], 5uLL), v36.val[1], 5uLL));
    v42.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v42.val[0], *(int8x8_t *)v30.i8), (int16x8_t)0), v14);
    __asm
    {
      PRFM            #0, [X11,#0x80]
      PRFM            #0, [X11,#0xC0]
    }
    v42.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v42.val[1], *(int8x8_t *)v31.i8), (int16x8_t)0), v14);
    *a5++ = v29;
    v43.val[0] = vminq_s16(vmaxq_s16(vaddw_high_s8(v36.val[0], v30), (int16x8_t)0), v14);
    v43.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v36.val[1], v31), (int16x8_t)0), v14);
    v36.val[0] = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v45.val[0], 5uLL), (int16x8_t)v44.val[0], 5uLL));
    int16x8_t v34 = vaddw_high_s8((int16x8_t)v44.val[0], (int8x16_t)v36.val[0]);
    v36.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v45.val[0], *(int8x8_t *)v36.val[0].i8), (int16x8_t)0), v14);
    int8x16_t v35 = vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v45.val[1], 5uLL), (int16x8_t)v44.val[1], 5uLL));
    v36.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v45.val[1], *(int8x8_t *)v35.i8), (int16x8_t)0), v14);
    v45.val[0] = vminq_s16(vmaxq_s16(v34, (int16x8_t)0), v14);
    v45.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v44.val[1], v35), (int16x8_t)0), v14);
    v44.val[0] = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v41.val[0], 5uLL), v40.val[0], 5uLL));
    v37.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v41.val[0], *(int8x8_t *)v44.val[0].i8), (int16x8_t)0), v14);
    v44.val[1] = vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v41.val[1], 5uLL), v40.val[1], 5uLL));
    v37.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v41.val[1], *(int8x8_t *)v44.val[1].i8), (int16x8_t)0), v14);
    v41.val[0] = vminq_s16(vmaxq_s16(vaddw_high_s8(v40.val[0], v44.val[0]), (int16x8_t)0), v14);
    v41.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v40.val[1], v44.val[1]), (int16x8_t)0), v14);
    v40.val[0] = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v38.val[0], 5uLL), (int16x8_t)v39.val[0], 5uLL));
    vst2q_s16(result, v42);
    uint64_t v13 = 4 * a2;
    CFTypeID result = (__int16 *)((char *)result + v13);
    v42.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v38.val[0], *(int8x8_t *)v40.val[0].i8), (int16x8_t)0), v14);
    vst2q_s16(v17, v43);
    v40.val[1] = (int16x8_t)vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v38.val[1], 5uLL), (int16x8_t)v39.val[1], 5uLL));
    vst2q_s16(v18, v36);
    vst2q_s16(v19, v45);
    v42.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v38.val[1], *(int8x8_t *)v40.val[1].i8), (int16x8_t)0), v14);
    vst2q_s16(_X11, v37);
    v38.val[0] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v39.val[0], (int8x16_t)v40.val[0]), (int16x8_t)0), v14);
    vst2q_s16(v26, v41);
    v38.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v39.val[1], (int8x16_t)v40.val[1]), (int16x8_t)0), v14);
    vst2q_s16(v27, v42);
    vst2q_s16(v28, v38);
    v12 -= 2;
  }
  while (v12 > 2);
  return result;
}

char *sub_1BB9FDE68(char *result, uint64_t a2, long long *a3, uint64_t a4, unsigned char *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  long long v9 = a3[2];
  long long v10 = a3[3];
  int v12 = a7 + 2;
  do
  {
    uint64_t v13 = result;
    int8x16x2_t v22 = vld2q_s8(v13);
    int16x8_t v14 = (char *)&v13[a2];
    __asm { PRFM            #0, [X0,#0x20] }
    _X11 = v14;
    int8x16x2_t v23 = vld2q_s8(_X11);
    _X11 += 32;
    __asm { PRFM            #0, [X11] }
    *a5 = v22.val[0].i8[15];
    a5[1] = v22.val[1].i8[15];
    a5[2] = v23.val[0].i8[15];
    a5[3] = v23.val[1].i8[15];
    v22.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v22.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v22.val[0], 3uLL)));
    v22.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v22.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v22.val[1], 3uLL)));
    v23.val[0] = (int8x16_t)vsqaddq_u8((uint8x16_t)v23.val[0], vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8((uint8x16_t)v23.val[0], 3uLL)));
    vst2q_s8(result, v22);
    uint64_t v11 = 2 * a2;
    result += v11;
    v23.val[1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v23.val[1], vqtbl2q_s8(*(int8x16x2_t *)&v9, (int8x16_t)vshrq_n_u8((uint8x16_t)v23.val[1], 3uLL)));
    vst2q_s8(v14, v23);
    v12 -= 2;
    a5 += 4;
  }
  while (v12 > 2);
  return result;
}

__int16 *sub_1BB9FDEF8(__int16 *result, uint64_t a2, long long *a3, uint64_t a4, void *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  long long v9 = a3[2];
  long long v10 = a3[3];
  int v12 = a7 + 2;
  v14.i64[0] = 0xFC00FC00FC00FC00;
  v14.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    uint64_t v15 = result;
    int16x8x2_t v32 = vld2q_s16(v15);
    uint64_t v11 = a2;
    _X11 = (__int16 *)&v15[v11];
    int v17 = result + 16;
    int8x16x2_t v33 = (int8x16x2_t)vld2q_s16(v17);
    __asm { PRFM            #0, [X0,#0x40] }
    int8x16x2_t v23 = _X11;
    int16x8x2_t v31 = vld2q_s16(v23);
    v23 += 16;
    int8x16x2_t v30 = (int8x16x2_t)vld2q_s16(v23);
    __asm { PRFM            #0, [X11,#0x40] }
    LODWORD(v25) = vqtbl2q_s8(v33, (int8x16_t)xmmword_1BBB6F440).u32[0];
    HIDWORD(v25) = vqtbl2q_s8(v30, (int8x16_t)xmmword_1BBB6F430).i32[1];
    *a5++ = v25;
    int8x16_t v26 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v32.val[0], 5uLL), (int16x8_t)v33.val[0], 5uLL));
    v34.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v32.val[0], *(int8x8_t *)v26.i8), (int16x8_t)0), v14);
    int8x16_t v27 = vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v32.val[1], 5uLL), (int16x8_t)v33.val[1], 5uLL));
    v34.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v32.val[1], *(int8x8_t *)v27.i8), (int16x8_t)0), v14);
    v32.val[0] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v33.val[0], v26), (int16x8_t)0), v14);
    v32.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v33.val[1], v27), (int16x8_t)0), v14);
    v33.val[0] = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v31.val[0], 5uLL), (int16x8_t)v30.val[0], 5uLL));
    v33.val[1] = (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v31.val[0], *(int8x8_t *)v33.val[0].i8), (int16x8_t)0), v14);
    int8x16_t v28 = vqtbl2q_s8(*(int8x16x2_t *)&v9, vshrn_high_n_s16(vshrn_n_s16(v31.val[1], 5uLL), (int16x8_t)v30.val[1], 5uLL));
    int16x8_t v29 = vminq_s16(vmaxq_s16(vaddw_s8(v31.val[1], *(int8x8_t *)v28.i8), (int16x8_t)0), v14);
    vst2q_s16(result, v34);
    uint64_t v13 = 4 * a2;
    CFTypeID result = (__int16 *)((char *)result + v13);
    v31.val[0] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v30.val[0], v33.val[0]), (int16x8_t)0), v14);
    vst2q_s16(v17, v32);
    v31.val[1] = vminq_s16(vmaxq_s16(vaddw_high_s8((int16x8_t)v30.val[1], v28), (int16x8_t)0), v14);
    vst2q_s16(_X11, *(int16x8x2_t *)((char *)&v33 + 16));
    vst2q_s16(v23, v31);
    v12 -= 2;
  }
  while (v12 > 2);
  return result;
}

char *sub_1BB9FE008(char *result, uint64_t a2, long long *a3, uint64_t a4, unsigned char *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  long long v9 = a3[2];
  long long v10 = a3[3];
  int v12 = a7 + 2;
  do
  {
    uint64_t v13 = result;
    int8x8x2_t v22 = vld2_s8(v13);
    int16x8_t v14 = (char *)&v13[a2];
    __asm { PRFM            #0, [X0,#0x10] }
    _X11 = v14;
    int8x8x2_t v23 = vld2_s8(_X11);
    _X11 += 16;
    __asm { PRFM            #0, [X11] }
    *a5 = v22.val[0].i8[7];
    a5[1] = v22.val[1].i8[7];
    a5[2] = v23.val[0].i8[7];
    a5[3] = v23.val[1].i8[7];
    v22.val[0] = (int8x8_t)vsqadd_u8((uint8x8_t)v22.val[0], vqtbl2_s8(*(int8x16x2_t *)&v7, (int8x8_t)vshr_n_u8((uint8x8_t)v22.val[0], 3uLL)));
    v22.val[1] = (int8x8_t)vsqadd_u8((uint8x8_t)v22.val[1], vqtbl2_s8(*(int8x16x2_t *)&v9, (int8x8_t)vshr_n_u8((uint8x8_t)v22.val[1], 3uLL)));
    v23.val[0] = (int8x8_t)vsqadd_u8((uint8x8_t)v23.val[0], vqtbl2_s8(*(int8x16x2_t *)&v7, (int8x8_t)vshr_n_u8((uint8x8_t)v23.val[0], 3uLL)));
    vst2_s8(result, v22);
    uint64_t v11 = 2 * a2;
    result += v11;
    v23.val[1] = (int8x8_t)vsqadd_u8((uint8x8_t)v23.val[1], vqtbl2_s8(*(int8x16x2_t *)&v9, (int8x8_t)vshr_n_u8((uint8x8_t)v23.val[1], 3uLL)));
    vst2_s8(v14, v23);
    v12 -= 2;
    a5 += 4;
  }
  while (v12 > 2);
  return result;
}

__int16 *sub_1BB9FE098(__int16 *result, uint64_t a2, long long *a3, uint64_t a4, void *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  long long v9 = a3[2];
  long long v10 = a3[3];
  int v13 = a7 + 2;
  v14.i64[0] = 0xFC00FC00FC00FC00;
  v14.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    uint64_t v15 = result;
    int16x8x2_t v25 = vld2q_s16(v15);
    uint64_t v11 = a2;
    int v16 = (__int16 *)&v15[v11];
    __asm { PRFM            #0, [X0,#0x20] }
    _X12 = v16;
    int8x16x2_t v26 = (int8x16x2_t)vld2q_s16(_X12);
    _X12 += 16;
    __asm { PRFM            #0, [X12] }
    LODWORD(v24) = vqtbl2q_s8((int8x16x2_t)v25, (int8x16_t)xmmword_1BBB6F440).u32[0];
    HIDWORD(v24) = vqtbl2q_s8(v26, (int8x16_t)xmmword_1BBB6F430).i32[1];
    *a5++ = v24;
    v27.val[0] = vminq_s16(vmaxq_s16(vaddw_s8(v25.val[0], vqtbl2_s8(*(int8x16x2_t *)&v7, vshrn_n_s16(v25.val[0], 5uLL))), (int16x8_t)0), v14);
    v27.val[1] = vminq_s16(vmaxq_s16(vaddw_s8(v25.val[1], vqtbl2_s8(*(int8x16x2_t *)&v9, vshrn_n_s16(v25.val[1], 5uLL))), (int16x8_t)0), v14);
    v25.val[0] = vminq_s16(vmaxq_s16(vaddw_s8((int16x8_t)v26.val[0], vqtbl2_s8(*(int8x16x2_t *)&v7, vshrn_n_s16((int16x8_t)v26.val[0], 5uLL))), (int16x8_t)0), v14);
    v25.val[1] = vminq_s16(vmaxq_s16(vaddw_s8((int16x8_t)v26.val[1], vqtbl2_s8(*(int8x16x2_t *)&v9, vshrn_n_s16((int16x8_t)v26.val[1], 5uLL))), (int16x8_t)0), v14);
    vst2q_s16(result, v27);
    uint64_t v12 = 4 * a2;
    CFTypeID result = (__int16 *)((char *)result + v12);
    vst2q_s16(v16, v25);
    v13 -= 2;
  }
  while (v13 > 2);
  return result;
}

int8x16_t *sub_1BB9FE154(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, int8x16_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  a5[a7] = *(__int16 *)((char *)&result->i16[-1] + a7 * a2);
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i16[7];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  int8x16_t v9 = vdupq_n_s8(~a4);
  int8x16_t v10 = vandq_s8(v9, (int8x16_t)xmmword_1BBB6F540);
  int8x16_t v11 = vandq_s8(v9, (int8x16_t)xmmword_1BBB6F550);
  int8x16_t v13 = *_X5;
  int8x16_t v12 = _X5[1];
  int8x16_t v14 = _X5[2];
  int8x16_t v15 = _X5[3];
  i16 = _X5[4].i16;
  __asm { PRFM            #0, [X5,#0x40] }
  int8x16_t v22 = *result;
  int8x16_t v23 = result[1];
  int8x16_t v24 = result[2];
  int8x16_t v25 = result[3];
  int8x16x2_t v26 = result[4].i16;
  __asm { PRFM            #0, [X0,#0x40] }
  int8x16_t v28 = (int8x16_t)vld1q_dup_s16(i16);
  *a5 = v25.i16[7];
  int16x8_t v29 = a5 + 1;
  signed int v30 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  int8x16_t v31 = vceqzq_s8(v11);
  int8x16_t v32 = vceqzq_s8(v10);
  int8x16x2_t v33 = v29;
  do
  {
    uint8x16_t v34 = (uint8x16_t)vextq_s8(v14, v15, 2uLL);
    int8x16_t v35 = v25;
    uint8x16_t v36 = (uint8x16_t)v24;
    uint8x16_t v37 = (uint8x16_t)v23;
    uint8x16_t v38 = (uint8x16_t)vextq_s8(v13, v12, 2uLL);
    int8x16_t v13 = v22;
    _X11 = (char *)v26 + a2;
    int8x16_t v22 = *(int8x16_t *)((char *)v26 + a2 - 64);
    int8x16_t v23 = *(int8x16_t *)((char *)v26 + a2 - 48);
    int8x16_t v24 = *(int8x16_t *)((char *)v26 + a2 - 32);
    int8x16_t v25 = *(int8x16_t *)((char *)v26 + a2 - 16);
    __asm { PRFM            #0, [X11] }
    int8x16_t v41 = (int8x16_t)vld1q_dup_s16(v33++);
    *int16x8_t v29 = v25.i16[7];
    uint8x16_t v42 = (uint8x16_t)vextq_s8(v15, v28, 2uLL);
    uint8x16_t v43 = (uint8x16_t)vextq_s8(v12, v14, 2uLL);
    uint8x16_t v44 = (uint8x16_t)vextq_s8(v41, v22, 0xEuLL);
    uint8x16_t v45 = (uint8x16_t)vextq_s8(v22, v23, 0xEuLL);
    uint8x16_t v46 = (uint8x16_t)vextq_s8(v23, v24, 0xEuLL);
    uint8x16_t v47 = (uint8x16_t)vextq_s8(v24, v25, 0xEuLL);
    int8x16_t v48 = (int8x16_t)vsqaddq_u8((uint8x16_t)v13, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v13, v38), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v38, (uint8x16_t)v13)), (int8x16_t)vcgtq_u8((uint8x16_t)v13, v44)), (int8x16_t)vcgtq_u8(v44, (uint8x16_t)v13))));
    int8x16_t v49 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v37, v43), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v43, v37)), (int8x16_t)vcgtq_u8(v37, v45)), (int8x16_t)vcgtq_u8(v45, v37)));
    int8x16_t v12 = (int8x16_t)v37;
    uint8x16_t v50 = vsqaddq_u8(v37, v49);
    int8x16_t v14 = (int8x16_t)v36;
    int8x16_t v51 = vbslq_s8(v31, (int8x16_t)vsqaddq_u8((uint8x16_t)v35, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v35, v42), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v42, (uint8x16_t)v35)), (int8x16_t)vcgtq_u8((uint8x16_t)v35, v47)), (int8x16_t)vcgtq_u8(v47, (uint8x16_t)v35)))), v35);
    *((int8x16_t *)v26 - 4) = vbslq_s8(v32, v48, v13);
    *((uint8x16_t *)v26 - 3) = v50;
    int8x16_t v28 = (int8x16_t)vld1q_dup_s16(v26);
    --v30;
    *((uint8x16_t *)v26 - 2) = vsqaddq_u8(v36, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v36, v34), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v34, v36)), (int8x16_t)vcgtq_u8(v36, v46)), (int8x16_t)vcgtq_u8(v46, v36))));
    *((int8x16_t *)v26 - 1) = v51;
    int8x16x2_t v26 = (const __int16 *)((char *)v26 + a2);
    int16x8_t v29 = (__int16 *)v33;
    int8x16_t v15 = v35;
  }
  while (v30 > 1);
  return result;
}

uint64_t sub_1BB9FE328(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, _OWORD *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  a5[a7] = *(_DWORD *)(result + 2 * a7 * a2 - 4);
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_DWORD *)(result + 124);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  v7.i64[1] = v8;
  int16x8_t v9 = vdupq_n_s16(~a4);
  int16x8_t v10 = (int16x8_t)vandq_s8((int8x16_t)v9, (int8x16_t)xmmword_1BBB6F580);
  int8x16_t v11 = (int8x16_t)vtstq_s16(v9, (int16x8_t)xmmword_1BBB6F590);
  int16x8_t v13 = *(int16x8_t *)_X5;
  int16x8_t v12 = *((int16x8_t *)_X5 + 1);
  int16x8_t v15 = *((int16x8_t *)_X5 + 2);
  int16x8_t v14 = *((int16x8_t *)_X5 + 3);
  int16x8_t v17 = *((int16x8_t *)_X5 + 4);
  int16x8_t v16 = *((int16x8_t *)_X5 + 5);
  int16x8_t v18 = *((int16x8_t *)_X5 + 6);
  int8x16_t v19 = *((int8x16_t *)_X5 + 7);
  int v20 = (const float *)(_X5 + 8);
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  int8x16_t v27 = *(int8x16_t *)result;
  int8x16_t v28 = *(int8x16_t *)(result + 16);
  int8x16_t v29 = *(int8x16_t *)(result + 32);
  int8x16_t v30 = *(int8x16_t *)(result + 48);
  uint64_t v31 = result + 96;
  int8x16_t v32 = *(int8x16_t *)(result + 96);
  int8x16_t v33 = *(int8x16_t *)(result + 64);
  int8x16_t v34 = *(int8x16_t *)(result + 80);
  int8x16_t v35 = *(int8x16_t *)(result + 112);
  __asm { PRFM            #0, [X0,#0x80] }
  uint64_t v37 = 2 * a2;
  signed int v38 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  __asm { PRFM            #0, [X0,#0xC0] }
  int8x16_t v40 = (int8x16_t)vld1q_dup_f32(v20);
  *a5 = v35.i32[3];
  int8x16_t v41 = (float *)(a5 + 1);
  int8x16_t v42 = (int8x16_t)vceqzq_s16(v10);
  v43.i64[0] = 0xFC00FC00FC00FC00;
  v43.i64[1] = 0xFC00FC00FC00FC00;
  uint8x16_t v44 = v41;
  do
  {
    uint16x8_t v45 = (uint16x8_t)vextq_s8((int8x16_t)v18, v19, 4uLL);
    int16x8_t v46 = (int16x8_t)v35;
    uint16x8_t v47 = (uint16x8_t)vextq_s8((int8x16_t)v16, (int8x16_t)v18, 4uLL);
    int16x8_t v18 = (int16x8_t)v32;
    uint16x8_t v48 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v16, 4uLL);
    int16x8_t v16 = (int16x8_t)v34;
    uint16x8_t v49 = (uint16x8_t)vextq_s8((int8x16_t)v14, (int8x16_t)v17, 4uLL);
    int16x8_t v17 = (int16x8_t)v33;
    uint16x8_t v50 = (uint16x8_t)vextq_s8((int8x16_t)v15, (int8x16_t)v14, 4uLL);
    int16x8_t v14 = (int16x8_t)v30;
    uint16x8_t v51 = (uint16x8_t)vextq_s8((int8x16_t)v12, (int8x16_t)v15, 4uLL);
    int16x8_t v15 = (int16x8_t)v29;
    uint16x8_t v52 = (uint16x8_t)vextq_s8((int8x16_t)v13, (int8x16_t)v12, 4uLL);
    int16x8_t v12 = (int16x8_t)v28;
    int16x8_t v13 = (int16x8_t)v27;
    _X12 = v31 + v37;
    int8x16_t v27 = *(int8x16_t *)(v31 + v37 - 96);
    int8x16_t v28 = *(int8x16_t *)(v31 + v37 - 80);
    int8x16_t v29 = *(int8x16_t *)(v31 + v37 - 64);
    int8x16_t v30 = *(int8x16_t *)(v31 + v37 - 48);
    int8x16_t v33 = *(int8x16_t *)(v31 + v37 - 32);
    int8x16_t v34 = *(int8x16_t *)(v31 + v37 - 16);
    int8x16_t v32 = *(int8x16_t *)(v31 + 2 * a2);
    int8x16_t v35 = *(int8x16_t *)(v31 + v37 + 16);
    __asm
    {
      PRFM            #0, [X12,#0x20]
      PRFM            #0, [X12,#0x60]
    }
    int8x16_t v56 = (int8x16_t)vld1q_dup_f32(v44++);
    uint16x8_t v57 = (uint16x8_t)vextq_s8(v19, v40, 4uLL);
    uint16x8_t v58 = (uint16x8_t)vextq_s8(v56, v27, 0xCuLL);
    uint16x8_t v59 = (uint16x8_t)vextq_s8(v27, v28, 0xCuLL);
    int16x8_t v60 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v52, (uint16x8_t)v13), (int16x8_t)vcgtq_u16((uint16x8_t)v13, v52)), (int16x8_t)vcgtq_u16((uint16x8_t)v13, v58)), (int16x8_t)vcgtq_u16(v58, (uint16x8_t)v13));
    uint16x8_t v61 = (uint16x8_t)vextq_s8(v28, v29, 0xCuLL);
    int8x16_t v62 = vqmovn_high_s16(vqmovn_s16(v60), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v51, (uint16x8_t)v12), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v51)), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v59)), (int16x8_t)vcgtq_u16(v59, (uint16x8_t)v12)));
    uint16x8_t v63 = (uint16x8_t)vextq_s8(v29, v30, 0xCuLL);
    int16x8_t v64 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v50, (uint16x8_t)v15), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v50)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v61)), (int16x8_t)vcgtq_u16(v61, (uint16x8_t)v15));
    uint16x8_t v65 = (uint16x8_t)vextq_s8(v30, v33, 0xCuLL);
    int8x16_t v66 = vqmovn_high_s16(vqmovn_s16(v64), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v49, (uint16x8_t)v14), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v49)), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v63)), (int16x8_t)vcgtq_u16(v63, (uint16x8_t)v14)));
    uint16x8_t v67 = (uint16x8_t)vextq_s8(v33, v34, 0xCuLL);
    int16x8_t v68 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v47, (uint16x8_t)v16), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v47)), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v67)), (int16x8_t)vcgtq_u16(v67, (uint16x8_t)v16));
    uint16x8_t v69 = (uint16x8_t)vextq_s8(v34, v32, 0xCuLL);
    int8x16_t v70 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v48, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v48)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v65)), (int16x8_t)vcgtq_u16(v65, (uint16x8_t)v17))), v68);
    uint16x8_t v71 = (uint16x8_t)vextq_s8(v32, v35, 0xCuLL);
    *int8x16_t v41 = *(float *)&v35.i32[3];
    int8x16_t v72 = vqtbl1q_s8(v7, vaddq_s8(v62, (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v73 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v45, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v45)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v69)), (int16x8_t)vcgtq_u16(v69, (uint16x8_t)v18))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v57, (uint16x8_t)v46), (int16x8_t)vcgtq_u16((uint16x8_t)v46, v57)), (int16x8_t)vcgtq_u16((uint16x8_t)v46, v71)), (int16x8_t)vcgtq_u16(v71, (uint16x8_t)v46)));
    *(int8x16_t *)(v31 - 96) = vbslq_s8(v42, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v13, *(int8x8_t *)v72.i8), (int16x8_t)0), v43), (int8x16_t)v13);
    *(int16x8_t *)(v31 - 80) = vminq_s16(vmaxq_s16(vaddw_high_s8(v12, v72), (int16x8_t)0), v43);
    int8x16_t v74 = vqtbl1q_s8(v7, vaddq_s8(v66, (int8x16_t)xmmword_1BBB6F560));
    *(int16x8_t *)(v31 - 64) = vminq_s16(vmaxq_s16(vaddw_s8(v15, *(int8x8_t *)v74.i8), (int16x8_t)0), v43);
    *(int16x8_t *)(v31 - 48) = vminq_s16(vmaxq_s16(vaddw_high_s8(v14, v74), (int16x8_t)0), v43);
    int8x16_t v75 = vqtbl1q_s8(v7, vaddq_s8(v70, (int8x16_t)xmmword_1BBB6F560));
    *(int16x8_t *)(v31 - 32) = vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v75.i8), (int16x8_t)0), v43);
    *(int16x8_t *)(v31 - 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v16, v75), (int16x8_t)0), v43);
    int8x16_t v76 = vqtbl1q_s8(v7, vaddq_s8(v73, (int8x16_t)xmmword_1BBB6F560));
    *(int16x8_t *)uint64_t v31 = vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v76.i8), (int16x8_t)0), v43);
    *(int8x16_t *)(v31 + 16) = vbslq_s8(v11, (int8x16_t)v46, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v46, v76), (int16x8_t)0), v43));
    double v77 = (const float *)(v31 + 32);
    --v38;
    v31 += v37;
    int8x16_t v41 = (float *)v44;
    int8x16_t v19 = (int8x16_t)v46;
    int8x16_t v40 = (int8x16_t)vld1q_dup_f32(v77);
  }
  while (v38 > 1);
  return result;
}

int8x16_t *sub_1BB9FE658(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, __int16 *a5, int8x16_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  if ((a4 & 4) != 0)
  {
    int8x16_t v11 = &_X5[-1].i16[7];
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v11);
  }
  else
  {
    int16x8_t v9 = a5;
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v9++);
    *a5 = result[3].i16[7];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (__int16 *)v9;
  }
  v7.i64[1] = v8;
  int v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(__int16 *)((char *)&result[3].i16[7] + (v12 + 1) * a2);
  int8x16_t v13 = vdupq_n_s8(~a4);
  int8x16_t v14 = vandq_s8(v13, (int8x16_t)xmmword_1BBB6F540);
  int8x16_t v15 = vandq_s8(v13, (int8x16_t)xmmword_1BBB6F550);
  int8x16_t v16 = *_X5;
  int8x16_t v17 = _X5[1];
  int8x16_t v19 = _X5[2];
  int8x16_t v18 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  int8x16_t v25 = *result;
  int8x16_t v26 = result[1];
  int8x16_t v27 = result[2];
  int8x16_t v28 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  int v30 = v12 + 2;
  int8x16_t v31 = vceqzq_s8(v15);
  int8x16_t v32 = vceqzq_s8(v14);
  int8x16_t v33 = a5;
  do
  {
    uint8x16_t v34 = (uint8x16_t)vextq_s8(v19, v18, 0xEuLL);
    int8x16_t v18 = v28;
    uint8x16_t v35 = (uint8x16_t)v27;
    uint8x16_t v36 = (uint8x16_t)v26;
    uint8x16_t v37 = (uint8x16_t)vextq_s8(v10, v16, 0xEuLL);
    uint8x16_t v38 = (uint8x16_t)vextq_s8(v16, v17, 0xEuLL);
    int8x16_t v16 = v25;
    _X10 = (uint64_t)result->i64 + a2;
    int8x16_t v25 = *(int8x16_t *)((char *)result + a2);
    int8x16_t v26 = *(int8x16_t *)((char *)&result[1] + a2);
    int8x16_t v27 = *(int8x16_t *)((char *)&result[2] + a2);
    int8x16_t v28 = *(int8x16_t *)((char *)&result[3] + a2);
    __asm { PRFM            #0, [X10,#0x40] }
    v10.i16[0] = *(__int16 *)((char *)result[4].i16 + a2);
    uint8x16_t v41 = (uint8x16_t)vextq_s8(v17, v19, 0xEuLL);
    uint8x16_t v42 = (uint8x16_t)vextq_s8(v25, v26, 2uLL);
    uint8x16_t v43 = (uint8x16_t)vextq_s8(v26, v27, 2uLL);
    uint8x16_t v44 = (uint8x16_t)vextq_s8(v27, v28, 2uLL);
    uint8x16_t v45 = (uint8x16_t)vextq_s8(v28, v10, 2uLL);
    int8x16_t v46 = (int8x16_t)vsqaddq_u8((uint8x16_t)v16, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v16, v37), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v37, (uint8x16_t)v16)), (int8x16_t)vcgtq_u8((uint8x16_t)v16, v42)), (int8x16_t)vcgtq_u8(v42, (uint8x16_t)v16))));
    int8x16_t v17 = (int8x16_t)v36;
    uint8x16_t v47 = vsqaddq_u8(v36, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v36, v38), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v38, v36)), (int8x16_t)vcgtq_u8(v36, v43)), (int8x16_t)vcgtq_u8(v43, v36))));
    int8x16_t v48 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v35, v41), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v41, v35)), (int8x16_t)vcgtq_u8(v35, v44)), (int8x16_t)vcgtq_u8(v44, v35)));
    int8x16_t v19 = (int8x16_t)v35;
    *CFTypeID result = vbslq_s8(v32, v46, v16);
    result[1] = (int8x16_t)v47;
    result[2] = (int8x16_t)vsqaddq_u8(v35, v48);
    result[3] = vbslq_s8(v31, (int8x16_t)vsqaddq_u8((uint8x16_t)v18, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v18, v34), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v34, (uint8x16_t)v18)), (int8x16_t)vcgtq_u8((uint8x16_t)v18, v45)), (int8x16_t)vcgtq_u8(v45, (uint8x16_t)v18)))), v18);
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v33++);
    --v30;
    *a5 = v18.i16[7];
    a5 = (__int16 *)v33;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
  }
  while (v30 > 1);
  return result;
}

uint64_t sub_1BB9FE834(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, float *a5, int16x8_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  if ((a4 & 4) != 0)
  {
    int8x16_t v11 = (const float *)&_X5[-1].i32[3];
    int8x16_t v10 = (int8x16_t)vld1q_dup_f32(v11);
  }
  else
  {
    int16x8_t v9 = a5;
    int8x16_t v10 = (int8x16_t)vld1q_dup_f32(v9++);
    *a5 = *(float *)(result + 124);
    _X5 = (int16x8_t *)result;
    result += 2 * a2;
    --a7;
    a5 = (float *)v9;
  }
  v7.i64[1] = v8;
  int v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(float *)(result + 2 * (v12 + 1) * a2 + 124);
  int16x8_t v13 = vdupq_n_s16(~a4);
  int16x8_t v15 = *_X5;
  int16x8_t v14 = _X5[1];
  int16x8_t v16 = (int16x8_t)vandq_s8((int8x16_t)v13, (int8x16_t)xmmword_1BBB6F580);
  int8x16_t v17 = (int8x16_t)vtstq_s16(v13, (int16x8_t)xmmword_1BBB6F590);
  int16x8_t v19 = _X5[2];
  int16x8_t v18 = _X5[3];
  int16x8_t v21 = _X5[4];
  int16x8_t v20 = _X5[5];
  int16x8_t v23 = _X5[6];
  int16x8_t v22 = _X5[7];
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  int8x16_t v30 = *(int8x16_t *)result;
  int8x16_t v31 = *(int8x16_t *)(result + 16);
  int8x16_t v32 = *(int8x16_t *)(result + 32);
  int8x16_t v33 = *(int8x16_t *)(result + 48);
  uint64_t v34 = result + 96;
  int8x16_t v35 = *(int8x16_t *)(result + 96);
  int8x16_t v36 = *(int8x16_t *)(result + 64);
  int8x16_t v37 = *(int8x16_t *)(result + 80);
  int8x16_t v38 = *(int8x16_t *)(result + 112);
  __asm
  {
    PRFM            #0, [X0,#0x80]
    PRFM            #0, [X0,#0xC0]
  }
  uint64_t v41 = 2 * a2;
  int v42 = v12 + 2;
  int8x16_t v43 = (int8x16_t)vceqzq_s16(v16);
  v44.i64[0] = 0xFC00FC00FC00FC00;
  v44.i64[1] = 0xFC00FC00FC00FC00;
  uint8x16_t v45 = a5;
  do
  {
    uint16x8_t v46 = (uint16x8_t)vextq_s8((int8x16_t)v23, (int8x16_t)v22, 0xCuLL);
    int16x8_t v22 = (int16x8_t)v38;
    uint16x8_t v47 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v23, 0xCuLL);
    int16x8_t v23 = (int16x8_t)v35;
    uint16x8_t v48 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v20, 0xCuLL);
    int16x8_t v20 = (int16x8_t)v37;
    uint16x8_t v49 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v21, 0xCuLL);
    int16x8_t v21 = (int16x8_t)v36;
    uint16x8_t v50 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v18, 0xCuLL);
    int16x8_t v18 = (int16x8_t)v33;
    uint16x8_t v51 = (uint16x8_t)vextq_s8((int8x16_t)v14, (int8x16_t)v19, 0xCuLL);
    int16x8_t v19 = (int16x8_t)v32;
    uint16x8_t v52 = (uint16x8_t)vextq_s8((int8x16_t)v15, (int8x16_t)v14, 0xCuLL);
    int16x8_t v14 = (int16x8_t)v31;
    uint16x8_t v53 = (uint16x8_t)vextq_s8(v10, (int8x16_t)v15, 0xCuLL);
    int16x8_t v15 = (int16x8_t)v30;
    _X12 = v34 + v41;
    int8x16_t v30 = *(int8x16_t *)(v34 + v41 - 96);
    int8x16_t v31 = *(int8x16_t *)(v34 + v41 - 80);
    int8x16_t v32 = *(int8x16_t *)(v34 + v41 - 64);
    int8x16_t v33 = *(int8x16_t *)(v34 + v41 - 48);
    int8x16_t v36 = *(int8x16_t *)(v34 + v41 - 32);
    int8x16_t v37 = *(int8x16_t *)(v34 + v41 - 16);
    uint16x8_t v55 = (uint16x8_t)vextq_s8(v30, v31, 4uLL);
    uint16x8_t v56 = (uint16x8_t)vextq_s8(v31, v32, 4uLL);
    int16x8_t v57 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v53, (uint16x8_t)v15), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v53)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v55)), (int16x8_t)vcgtq_u16(v55, (uint16x8_t)v15));
    uint16x8_t v58 = (uint16x8_t)vextq_s8(v32, v33, 4uLL);
    int16x8_t v59 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v52, (uint16x8_t)v14), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v52)), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v56)), (int16x8_t)vcgtq_u16(v56, (uint16x8_t)v14));
    uint16x8_t v60 = (uint16x8_t)vextq_s8(v33, v36, 4uLL);
    int8x16_t v61 = vqmovn_high_s16(vqmovn_s16(v57), v59);
    int16x8_t v62 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v51, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v51)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v58)), (int16x8_t)vcgtq_u16(v58, (uint16x8_t)v19));
    int16x8_t v63 = vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v50, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v50)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v60));
    int8x16_t v35 = *(int8x16_t *)(v34 + 2 * a2);
    int8x16_t v38 = *(int8x16_t *)(v34 + v41 + 16);
    int16x8_t v64 = vaddq_s16(v63, (int16x8_t)vcgtq_u16(v60, (uint16x8_t)v18));
    uint16x8_t v65 = (uint16x8_t)vextq_s8(v36, v37, 4uLL);
    int8x16_t v66 = vqmovn_high_s16(vqmovn_s16(v62), v64);
    uint16x8_t v67 = (uint16x8_t)vextq_s8(v37, v35, 4uLL);
    __asm
    {
      PRFM            #0, [X12,#0x20]
      PRFM            #0, [X12,#0x60]
    }
    int16x8_t v70 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v48, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v48)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v67)), (int16x8_t)vcgtq_u16(v67, (uint16x8_t)v20));
    uint16x8_t v71 = (uint16x8_t)vextq_s8(v35, v38, 4uLL);
    int8x16_t v72 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v49, (uint16x8_t)v21), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v49)), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v65)), (int16x8_t)vcgtq_u16(v65, (uint16x8_t)v21))), v70);
    int16x8_t v73 = (int16x8_t)vcgtq_u16((uint16x8_t)v23, v71);
    int16x8_t v74 = vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v47, (uint16x8_t)v23), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v47)), v73);
    v73.i32[0] = *(_DWORD *)(v34 + v41 + 32);
    uint16x8_t v75 = (uint16x8_t)vextq_s8(v38, (int8x16_t)v73, 4uLL);
    int8x16_t v76 = vqtbl1q_s8(v7, vaddq_s8(v61, (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v77 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(v74, (int16x8_t)vcgtq_u16(v71, (uint16x8_t)v23))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v46, (uint16x8_t)v22), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v46)), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v75)), (int16x8_t)vcgtq_u16(v75, (uint16x8_t)v22)));
    *(int8x16_t *)(v34 - 96) = vbslq_s8(v43, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v15, *(int8x8_t *)v76.i8), (int16x8_t)0), v44), (int8x16_t)v15);
    *(int16x8_t *)(v34 - 80) = vminq_s16(vmaxq_s16(vaddw_high_s8(v14, v76), (int16x8_t)0), v44);
    int8x16_t v78 = vqtbl1q_s8(v7, vaddq_s8(v66, (int8x16_t)xmmword_1BBB6F560));
    *(int16x8_t *)(v34 - 64) = vminq_s16(vmaxq_s16(vaddw_s8(v19, *(int8x8_t *)v78.i8), (int16x8_t)0), v44);
    *(int16x8_t *)(v34 - 48) = vminq_s16(vmaxq_s16(vaddw_high_s8(v18, v78), (int16x8_t)0), v44);
    int8x16_t v79 = vqtbl1q_s8(v7, vaddq_s8(v72, (int8x16_t)xmmword_1BBB6F560));
    *(int16x8_t *)(v34 - 32) = vminq_s16(vmaxq_s16(vaddw_s8(v21, *(int8x8_t *)v79.i8), (int16x8_t)0), v44);
    *(int16x8_t *)(v34 - 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v20, v79), (int16x8_t)0), v44);
    int8x16_t v80 = vqtbl1q_s8(v7, vaddq_s8(v77, (int8x16_t)xmmword_1BBB6F560));
    *(int16x8_t *)uint64_t v34 = vminq_s16(vmaxq_s16(vaddw_s8(v23, *(int8x8_t *)v80.i8), (int16x8_t)0), v44);
    *(int8x16_t *)(v34 + 16) = vbslq_s8(v17, (int8x16_t)v22, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v22, v80), (int16x8_t)0), v44));
    int8x16_t v10 = (int8x16_t)vld1q_dup_f32(v45++);
    --v42;
    v34 += v41;
    *a5 = *(float *)&v22.i32[3];
    a5 = (float *)v45;
  }
  while (v42 > 1);
  return result;
}

uint8x16_t *sub_1BB9FEB64(uint8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, uint8x16_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i16[7];
    _X5 = result;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  int v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int16 *)((char *)&result[3].i16[7] + (v9 + 1) * a2);
  uint8x16_t v11 = *_X5;
  uint8x16_t v10 = _X5[1];
  uint8x16_t v12 = _X5[2];
  uint8x16_t v13 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  uint8x16_t v19 = *result;
  uint8x16_t v20 = result[1];
  uint8x16_t v21 = result[2];
  uint8x16_t v22 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  int v24 = v9 + 2;
  do
  {
    uint8x16_t v25 = v19;
    uint8x16_t v26 = v20;
    uint8x16_t v27 = v21;
    uint8x16_t v28 = v22;
    _X9 = (uint64_t)result->i64 + a2;
    uint8x16_t v19 = *(uint8x16_t *)((char *)result + a2);
    uint8x16_t v20 = *(uint8x16_t *)((char *)&result[1] + a2);
    uint8x16_t v21 = *(uint8x16_t *)((char *)&result[2] + a2);
    uint8x16_t v22 = *(uint8x16_t *)((char *)&result[3] + a2);
    __asm { PRFM            #0, [X9,#0x40] }
    *a5++ = v28.i16[7];
    int8x16_t v31 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v25, v11), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v11, v25)), (int8x16_t)vcgtq_u8(v25, v19)), (int8x16_t)vcgtq_u8(v19, v25)));
    uint8x16_t v11 = v25;
    uint8x16_t v32 = vsqaddq_u8(v25, v31);
    int8x16_t v33 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v26, v10), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v10, v26)), (int8x16_t)vcgtq_u8(v26, v20)), (int8x16_t)vcgtq_u8(v20, v26)));
    uint8x16_t v10 = v26;
    uint8x16_t v34 = vsqaddq_u8(v26, v33);
    int8x16_t v35 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v27, v12), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v12, v27)), (int8x16_t)vcgtq_u8(v27, v21)), (int8x16_t)vcgtq_u8(v21, v27)));
    uint8x16_t v12 = v27;
    uint8x16_t v36 = vsqaddq_u8(v27, v35);
    int8x16_t v37 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v28, v13), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v13, v28)), (int8x16_t)vcgtq_u8(v28, v22)), (int8x16_t)vcgtq_u8(v22, v28)));
    uint8x16_t v13 = v28;
    *CFTypeID result = v32;
    result[1] = v34;
    result[2] = v36;
    result[3] = vsqaddq_u8(v28, v37);
    --v24;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
  }
  while (v24 > 1);
  return result;
}

uint64_t sub_1BB9FECC4(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, uint16x8_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_DWORD *)(result + 124);
    _X5 = (uint16x8_t *)result;
    result += 2 * a2;
    --a7;
  }
  v7.i64[1] = v8;
  int v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(_DWORD *)(result + 2 * (v9 + 1) * a2 + 124);
  uint16x8_t v11 = *_X5;
  uint16x8_t v10 = _X5[1];
  uint16x8_t v13 = _X5[2];
  uint16x8_t v12 = _X5[3];
  uint16x8_t v15 = _X5[4];
  uint16x8_t v14 = _X5[5];
  uint16x8_t v17 = _X5[6];
  uint16x8_t v16 = _X5[7];
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  uint16x8_t v24 = *(uint16x8_t *)result;
  uint16x8_t v25 = *(uint16x8_t *)(result + 16);
  uint16x8_t v26 = *(uint16x8_t *)(result + 32);
  uint16x8_t v27 = *(uint16x8_t *)(result + 48);
  uint16x8_t v28 = *(uint16x8_t *)(result + 64);
  uint16x8_t v29 = *(uint16x8_t *)(result + 80);
  int8x16_t v30 = (int16x8_t *)(result + 96);
  uint16x8_t v31 = *(uint16x8_t *)(result + 96);
  uint16x8_t v32 = *(uint16x8_t *)(result + 112);
  __asm
  {
    PRFM            #0, [X0,#0x80]
    PRFM            #0, [X0,#0xC0]
  }
  int v35 = v9 + 2;
  uint64_t v36 = 2 * a2;
  v37.i64[0] = 0xFC00FC00FC00FC00;
  v37.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v38 = (int16x8_t)v32;
    int16x8_t v39 = (int16x8_t)v31;
    int16x8_t v40 = (int16x8_t)v29;
    int16x8_t v41 = (int16x8_t)v28;
    int16x8_t v42 = (int16x8_t)v27;
    int16x8_t v43 = (int16x8_t)v26;
    int16x8_t v44 = (int16x8_t)v25;
    int16x8_t v45 = (int16x8_t)v24;
    _X11 = &v30->i8[v36];
    uint16x8_t v24 = *(uint16x8_t *)((char *)&v30[-6] + v36);
    uint16x8_t v25 = *(uint16x8_t *)((char *)&v30[-5] + v36);
    uint16x8_t v26 = *(uint16x8_t *)((char *)&v30[-4] + v36);
    uint16x8_t v27 = *(uint16x8_t *)((char *)&v30[-3] + v36);
    uint16x8_t v28 = *(uint16x8_t *)((char *)&v30[-2] + v36);
    uint16x8_t v29 = *(uint16x8_t *)((char *)&v30[-1] + v36);
    uint16x8_t v31 = *(uint16x8_t *)((char *)v30 + 2 * a2);
    uint16x8_t v32 = *(uint16x8_t *)((char *)&v30[1] + v36);
    __asm
    {
      PRFM            #0, [X11,#0x20]
      PRFM            #0, [X11,#0x60]
    }
    *a5++ = v38.i32[3];
    int8x16_t v49 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v11, (uint16x8_t)v45), (int16x8_t)vcgtq_u16((uint16x8_t)v45, v11)), (int16x8_t)vcgtq_u16((uint16x8_t)v45, v24)), (int16x8_t)vcgtq_u16(v24, (uint16x8_t)v45))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v44), (int16x8_t)vcgtq_u16((uint16x8_t)v44, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v44, v25)), (int16x8_t)vcgtq_u16(v25, (uint16x8_t)v44))), (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v50 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v13, (uint16x8_t)v43), (int16x8_t)vcgtq_u16((uint16x8_t)v43, v13)), (int16x8_t)vcgtq_u16((uint16x8_t)v43, v26)), (int16x8_t)vcgtq_u16(v26, (uint16x8_t)v43))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v12, (uint16x8_t)v42), (int16x8_t)vcgtq_u16((uint16x8_t)v42, v12)), (int16x8_t)vcgtq_u16((uint16x8_t)v42, v27)), (int16x8_t)vcgtq_u16(v27, (uint16x8_t)v42))), (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v51 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v15, (uint16x8_t)v41), (int16x8_t)vcgtq_u16((uint16x8_t)v41, v15)), (int16x8_t)vcgtq_u16((uint16x8_t)v41, v28)), (int16x8_t)vcgtq_u16(v28, (uint16x8_t)v41))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v14, (uint16x8_t)v40), (int16x8_t)vcgtq_u16((uint16x8_t)v40, v14)), (int16x8_t)vcgtq_u16((uint16x8_t)v40, v29)), (int16x8_t)vcgtq_u16(v29, (uint16x8_t)v40))), (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v52 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v17, (uint16x8_t)v39), (int16x8_t)vcgtq_u16((uint16x8_t)v39, v17)), (int16x8_t)vcgtq_u16((uint16x8_t)v39, v31)), (int16x8_t)vcgtq_u16(v31, (uint16x8_t)v39))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v16, (uint16x8_t)v38), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v16)), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v32)), (int16x8_t)vcgtq_u16(v32, (uint16x8_t)v38))), (int8x16_t)xmmword_1BBB6F560));
    v30[-6] = vminq_s16(vmaxq_s16(vaddw_s8(v45, *(int8x8_t *)v49.i8), (int16x8_t)0), v37);
    v30[-5] = vminq_s16(vmaxq_s16(vaddw_high_s8(v44, v49), (int16x8_t)0), v37);
    v30[-4] = vminq_s16(vmaxq_s16(vaddw_s8(v43, *(int8x8_t *)v50.i8), (int16x8_t)0), v37);
    v30[-3] = vminq_s16(vmaxq_s16(vaddw_high_s8(v42, v50), (int16x8_t)0), v37);
    v30[-2] = vminq_s16(vmaxq_s16(vaddw_s8(v41, *(int8x8_t *)v51.i8), (int16x8_t)0), v37);
    v30[-1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v40, v51), (int16x8_t)0), v37);
    --v35;
    *int8x16_t v30 = vminq_s16(vmaxq_s16(vaddw_s8(v39, *(int8x8_t *)v52.i8), (int16x8_t)0), v37);
    v30[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v38, v52), (int16x8_t)0), v37);
    int8x16_t v30 = (int16x8_t *)((char *)v30 + v36);
    uint16x8_t v11 = (uint16x8_t)v45;
    uint16x8_t v10 = (uint16x8_t)v44;
    uint16x8_t v13 = (uint16x8_t)v43;
    uint16x8_t v12 = (uint16x8_t)v42;
    uint16x8_t v15 = (uint16x8_t)v41;
    uint16x8_t v14 = (uint16x8_t)v40;
    uint16x8_t v17 = (uint16x8_t)v39;
    uint16x8_t v16 = (uint16x8_t)v38;
  }
  while (v35 > 1);
  return result;
}

int8x16_t *sub_1BB9FEF88(int8x16_t *result, uint64_t a2, uint64_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  v8.i64[0] = *a3;
  v8.i64[1] = a3[4];
  int8x16_t v9 = vdupq_n_s8(~a4);
  int8x16_t v10 = vandq_s8(v9, (int8x16_t)xmmword_1BBB6F540);
  _X8 = result + 2;
  int v12 = a7 + 1;
  int8x16_t v13 = vceqzq_s8(vandq_s8(v9, (int8x16_t)xmmword_1BBB6F550));
  int8x16_t v14 = vceqzq_s8(v10);
  uint16x8_t v15 = a5;
  do
  {
    int8x16_t v17 = _X8[-2];
    int8x16_t v16 = _X8[-1];
    int8x16_t v18 = *_X8;
    int8x16_t v19 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    int8x16_t v25 = (int8x16_t)vld1q_dup_s16(v15++);
    *a5 = v19.i16[7];
    v7.i16[0] = _X8[2].i16[0];
    uint8x16_t v26 = (uint8x16_t)vextq_s8(v25, v17, 0xEuLL);
    uint8x16_t v27 = (uint8x16_t)vextq_s8(v17, v16, 0xEuLL);
    uint8x16_t v28 = (uint8x16_t)vextq_s8(v16, v18, 0xEuLL);
    uint8x16_t v29 = (uint8x16_t)vextq_s8(v18, v19, 0xEuLL);
    uint8x16_t v30 = (uint8x16_t)vextq_s8(v17, v16, 2uLL);
    uint8x16_t v31 = (uint8x16_t)vextq_s8(v16, v18, 2uLL);
    uint8x16_t v32 = (uint8x16_t)vextq_s8(v18, v19, 2uLL);
    uint8x16_t v33 = (uint8x16_t)vextq_s8(v19, v7, 2uLL);
    int8x16_t v7 = (int8x16_t)vsqaddq_u8((uint8x16_t)v19, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v19, v29), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v19)), (int8x16_t)vcgtq_u8((uint8x16_t)v19, v33)), (int8x16_t)vcgtq_u8(v33, (uint8x16_t)v19))));
    _X8[-2] = vbslq_s8(v14, (int8x16_t)vsqaddq_u8((uint8x16_t)v17, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v17, v30), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v30, (uint8x16_t)v17)), (int8x16_t)vcgtq_u8((uint8x16_t)v17, v26)), (int8x16_t)vcgtq_u8(v26, (uint8x16_t)v17)))), v17);
    _X8[-1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v16, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v16, v27), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v16)), (int8x16_t)vcgtq_u8((uint8x16_t)v16, v31)), (int8x16_t)vcgtq_u8(v31, (uint8x16_t)v16))));
    *(uint8x16_t *)_X8 = vsqaddq_u8((uint8x16_t)v18, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v18, v28), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v28, (uint8x16_t)v18)), (int8x16_t)vcgtq_u8((uint8x16_t)v18, v32)), (int8x16_t)vcgtq_u8(v32, (uint8x16_t)v18))));
    _X8[1] = vbslq_s8(v13, v7, v19);
    _X8 = (int8x16_t *)((char *)_X8 + a2);
    --v12;
    a5 = (__int16 *)v15;
  }
  while (v12 > 1);
  return result;
}

int16x8_t *sub_1BB9FF0E0(int16x8_t *result, uint64_t a2, uint64_t *a3, int a4, float *a5, uint64_t a6, int a7)
{
  v8.i64[0] = *a3;
  v8.i64[1] = a3[4];
  int16x8_t v9 = vdupq_n_s16(~a4);
  int8x16_t v10 = (int8x16_t)vtstq_s16(v9, (int16x8_t)xmmword_1BBB6F580);
  int8x16_t v11 = (int8x16_t)vtstq_s16(v9, (int16x8_t)xmmword_1BBB6F590);
  _X8 = result + 6;
  int v13 = a7 + 1;
  v14.i64[0] = 0xFC00FC00FC00FC00;
  v14.i64[1] = 0xFC00FC00FC00FC00;
  uint16x8_t v15 = a5;
  do
  {
    int16x8_t v16 = _X8[-6];
    int16x8_t v17 = _X8[-5];
    int16x8_t v18 = _X8[-4];
    int16x8_t v19 = _X8[-3];
    int16x8_t v20 = _X8[-2];
    int16x8_t v21 = _X8[-1];
    int16x8_t v23 = *_X8;
    int16x8_t v22 = _X8[1];
    __asm
    {
      PRFM            #0, [X8,#0x20]
      PRFM            #0, [X8,#0x60]
    }
    int8x16_t v30 = (int8x16_t)vld1q_dup_f32(v15++);
    *a5 = *(float *)&v22.i32[3];
    uint16x8_t v31 = (uint16x8_t)vextq_s8(v30, (int8x16_t)v16, 0xCuLL);
    uint16x8_t v32 = (uint16x8_t)vextq_s8((int8x16_t)v16, (int8x16_t)v17, 0xCuLL);
    uint16x8_t v33 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 0xCuLL);
    uint16x8_t v34 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 0xCuLL);
    uint16x8_t v35 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v20, 0xCuLL);
    uint16x8_t v36 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v21, 0xCuLL);
    uint16x8_t v37 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v23, 0xCuLL);
    uint16x8_t v38 = (uint16x8_t)vextq_s8((int8x16_t)v23, (int8x16_t)v22, 0xCuLL);
    uint16x8_t v39 = (uint16x8_t)vextq_s8((int8x16_t)v16, (int8x16_t)v17, 4uLL);
    uint16x8_t v40 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 4uLL);
    uint16x8_t v41 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 4uLL);
    uint16x8_t v42 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v20, 4uLL);
    uint16x8_t v43 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v21, 4uLL);
    uint16x8_t v44 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v23, 4uLL);
    uint16x8_t v45 = (uint16x8_t)vextq_s8((int8x16_t)v23, (int8x16_t)v22, 4uLL);
    v7.i32[0] = _X8[2].i32[0];
    uint16x8_t v46 = (uint16x8_t)vextq_s8((int8x16_t)v22, (int8x16_t)v7, 4uLL);
    int8x16_t v47 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v39, (uint16x8_t)v16), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v39)), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v31)), (int16x8_t)vcgtq_u16(v31, (uint16x8_t)v16))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v32, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v32)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v40)), (int16x8_t)vcgtq_u16(v40, (uint16x8_t)v17))), (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v48 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v33, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v33)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v41)), (int16x8_t)vcgtq_u16(v41, (uint16x8_t)v18))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v34, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v34)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v42)), (int16x8_t)vcgtq_u16(v42, (uint16x8_t)v19))), (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v49 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v35, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v35)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v43)), (int16x8_t)vcgtq_u16(v43, (uint16x8_t)v20))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v36, (uint16x8_t)v21), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v36)), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v44)), (int16x8_t)vcgtq_u16(v44, (uint16x8_t)v21))), (int8x16_t)xmmword_1BBB6F560));
    int16x8_t v50 = vminq_s16(vmaxq_s16(vaddw_s8(v20, *(int8x8_t *)v49.i8), (int16x8_t)0), v14);
    int16x8_t v51 = vminq_s16(vmaxq_s16(vaddw_high_s8(v21, v49), (int16x8_t)0), v14);
    int16x8_t v52 = (int16x8_t)vcgtq_u16((uint16x8_t)v22, v46);
    int16x8_t v7 = (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v22);
    int8x16_t v53 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v37, (uint16x8_t)v23), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v37)), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v23))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v38, (uint16x8_t)v22), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v38)), v52), v7)), (int8x16_t)xmmword_1BBB6F560));
    _X8[-6] = (int16x8_t)vbslq_s8(v10, (int8x16_t)v16, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v16, *(int8x8_t *)v47.i8), (int16x8_t)0), v14));
    _X8[-5] = vminq_s16(vmaxq_s16(vaddw_high_s8(v17, v47), (int16x8_t)0), v14);
    _X8[-4] = vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v48.i8), (int16x8_t)0), v14);
    _X8[-3] = vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v48), (int16x8_t)0), v14);
    _X8[-2] = v50;
    _X8[-1] = v51;
    *_X8 = vminq_s16(vmaxq_s16(vaddw_s8(v23, *(int8x8_t *)v53.i8), (int16x8_t)0), v14);
    _X8[1] = (int16x8_t)vbslq_s8(v11, (int8x16_t)v22, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v22, v53), (int16x8_t)0), v14));
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v13;
    a5 = (float *)v15;
  }
  while (v13 > 1);
  return result;
}

int8x16_t *sub_1BB9FF360(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, int8x16_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  a5[a7] = *(__int16 *)((char *)&result->i16[-1] + a7 * a2);
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i16[7];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  int8x16_t v9 = vdupq_n_s8(~a4);
  int8x16_t v10 = vandq_s8(v9, (int8x16_t)xmmword_1BBB6F540);
  int8x16_t v11 = vandq_s8(v9, (int8x16_t)xmmword_1BBB6F550);
  int8x16_t v12 = *_X5;
  int8x16_t v13 = _X5[1];
  i16 = _X5[2].i16;
  __asm { PRFM            #0, [X5,#0x20] }
  int8x16_t v20 = *result;
  int8x16_t v21 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  int8x16_t v23 = (int8x16_t)vld1q_dup_s16(i16);
  *a5 = v21.i16[7];
  uint16x8_t v24 = a5 + 1;
  signed int v25 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  int8x16_t v26 = vceqzq_s8(v11);
  int8x16_t v27 = vceqzq_s8(v10);
  uint8x16_t v28 = v24;
  do
  {
    uint8x16_t v29 = (uint8x16_t)vextq_s8(v12, v13, 2uLL);
    uint8x16_t v30 = (uint8x16_t)vextq_s8(v13, v23, 2uLL);
    int8x16_t v31 = v21;
    int8x16_t v32 = v20;
    _X10 = (uint64_t)result->i64 + a2;
    int8x16_t v20 = *(int8x16_t *)((char *)result + a2);
    int8x16_t v21 = *(int8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X10,#0x20] }
    int8x16_t v35 = (int8x16_t)vld1q_dup_s16(v28++);
    *uint16x8_t v24 = v21.i16[7];
    uint8x16_t v36 = (uint8x16_t)vextq_s8(v35, v20, 0xEuLL);
    uint8x16_t v37 = (uint8x16_t)vextq_s8(v20, v21, 0xEuLL);
    *CFTypeID result = vbslq_s8(v27, (int8x16_t)vsqaddq_u8((uint8x16_t)v32, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v32, v29), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v32)), (int8x16_t)vcgtq_u8((uint8x16_t)v32, v36)), (int8x16_t)vcgtq_u8(v36, (uint8x16_t)v32)))), v32);
    result[1] = vbslq_s8(v26, (int8x16_t)vsqaddq_u8((uint8x16_t)v31, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v31, v30), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v30, (uint8x16_t)v31)), (int8x16_t)vcgtq_u8((uint8x16_t)v31, v37)), (int8x16_t)vcgtq_u8(v37, (uint8x16_t)v31)))), v31);
    uint16x8_t v38 = result[2].i16;
    --v25;
    uint16x8_t v24 = (__int16 *)v28;
    int8x16_t v23 = (int8x16_t)vld1q_dup_s16(v38);
    int8x16_t v12 = v32;
    int8x16_t v13 = v31;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
  }
  while (v25 > 1);
  return result;
}

uint64_t sub_1BB9FF4B8(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, _OWORD *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  a5[a7] = *(_DWORD *)(result + 2 * a7 * a2 - 4);
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_DWORD *)(result + 60);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  v7.i64[1] = v8;
  int8x16_t v9 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F580);
  int16x8_t v12 = *(int16x8_t *)_X5;
  int16x8_t v11 = *((int16x8_t *)_X5 + 1);
  int8x16_t v13 = *((int8x16_t *)_X5 + 2);
  int8x16_t v14 = *((int8x16_t *)_X5 + 3);
  uint16x8_t v15 = (const float *)(_X5 + 4);
  __asm { PRFM            #0, [X5,#0x40] }
  int8x16_t v21 = *(int8x16_t *)result;
  int8x16_t v22 = *(int8x16_t *)(result + 16);
  int8x16_t v23 = *(int8x16_t *)(result + 32);
  int8x16_t v24 = *(int8x16_t *)(result + 48);
  __asm { PRFM            #0, [X0,#0x40] }
  int8x16_t v26 = (int8x16_t)vld1q_dup_f32(v15);
  *a5 = v24.i32[3];
  int8x16_t v27 = (float *)(a5 + 1);
  uint8x16_t v28 = (const float *)(result + 64);
  uint64_t v29 = 2 * a2;
  signed int v30 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  int8x16_t v31 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F590));
  int8x16_t v32 = (int8x16_t)vceqzq_s16(v10);
  v33.i64[0] = 0xFC00FC00FC00FC00;
  v33.i64[1] = 0xFC00FC00FC00FC00;
  uint16x8_t v34 = v27;
  do
  {
    int16x8_t v35 = (int16x8_t)v24;
    uint16x8_t v36 = (uint16x8_t)vextq_s8((int8x16_t)v11, v13, 4uLL);
    int16x8_t v37 = (int16x8_t)v23;
    uint16x8_t v38 = (uint16x8_t)vextq_s8((int8x16_t)v12, (int8x16_t)v11, 4uLL);
    int16x8_t v11 = (int16x8_t)v22;
    int16x8_t v12 = (int16x8_t)v21;
    _X12 = (char *)v28 + v29;
    int8x16_t v21 = *(int8x16_t *)((char *)v28 + v29 - 64);
    int8x16_t v22 = *(int8x16_t *)((char *)v28 + v29 - 48);
    int8x16_t v23 = *(int8x16_t *)((char *)v28 + v29 - 32);
    int8x16_t v24 = *(int8x16_t *)((char *)v28 + v29 - 16);
    __asm { PRFM            #0, [X12] }
    int8x16_t v41 = (int8x16_t)vld1q_dup_f32(v34++);
    uint16x8_t v42 = (uint16x8_t)vextq_s8(v13, v14, 4uLL);
    uint16x8_t v43 = (uint16x8_t)vextq_s8(v14, v26, 4uLL);
    *int8x16_t v27 = *(float *)&v24.i32[3];
    uint16x8_t v44 = (uint16x8_t)vextq_s8(v41, v21, 0xCuLL);
    uint16x8_t v45 = (uint16x8_t)vextq_s8(v21, v22, 0xCuLL);
    uint16x8_t v46 = (uint16x8_t)vextq_s8(v22, v23, 0xCuLL);
    uint16x8_t v47 = (uint16x8_t)vextq_s8(v23, v24, 0xCuLL);
    int8x16_t v48 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v38, (uint16x8_t)v12), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v38)), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v44)), (int16x8_t)vcgtq_u16(v44, (uint16x8_t)v12))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v36, (uint16x8_t)v11), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v36)), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v11))), (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v49 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v42, (uint16x8_t)v37), (int16x8_t)vcgtq_u16((uint16x8_t)v37, v42)), (int16x8_t)vcgtq_u16((uint16x8_t)v37, v46)), (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v37))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v43, (uint16x8_t)v35), (int16x8_t)vcgtq_u16((uint16x8_t)v35, v43)), (int16x8_t)vcgtq_u16((uint16x8_t)v35, v47)), (int16x8_t)vcgtq_u16(v47, (uint16x8_t)v35))), (int8x16_t)xmmword_1BBB6F560));
    *((int8x16_t *)v28 - 4) = vbslq_s8(v32, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v48.i8), (int16x8_t)0), v33), (int8x16_t)v12);
    *((int16x8_t *)v28 - 3) = vminq_s16(vmaxq_s16(vaddw_high_s8(v11, v48), (int16x8_t)0), v33);
    *((int16x8_t *)v28 - 2) = vminq_s16(vmaxq_s16(vaddw_s8(v37, *(int8x8_t *)v49.i8), (int16x8_t)0), v33);
    *((int8x16_t *)v28 - 1) = vbslq_s8(v31, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v35, v49), (int16x8_t)0), v33), (int8x16_t)v35);
    int8x16_t v26 = (int8x16_t)vld1q_dup_f32(v28);
    --v30;
    uint8x16_t v28 = (const float *)((char *)v28 + v29);
    int8x16_t v27 = (float *)v34;
    int8x16_t v13 = (int8x16_t)v37;
    int8x16_t v14 = (int8x16_t)v35;
  }
  while (v30 > 1);
  return result;
}

int8x16_t *sub_1BB9FF6AC(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, __int16 *a5, int8x16_t *_X5, int a7)
{
  v8.i64[0] = *a3;
  uint64_t v9 = a3[4];
  if ((a4 & 4) != 0)
  {
    int16x8_t v12 = &_X5[-1].i16[7];
    int8x16_t v11 = (int8x16_t)vld1q_dup_s16(v12);
  }
  else
  {
    int16x8_t v10 = a5;
    int8x16_t v11 = (int8x16_t)vld1q_dup_s16(v10++);
    *a5 = result[1].i16[7];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (__int16 *)v10;
  }
  v8.i64[1] = v9;
  int v13 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v13 + 1] = *(__int16 *)((char *)&result[1].i16[7] + (v13 + 1) * a2);
  int8x16_t v14 = vdupq_n_s8(~a4);
  int8x16_t v15 = vandq_s8(v14, (int8x16_t)xmmword_1BBB6F540);
  int8x16_t v16 = vandq_s8(v14, (int8x16_t)xmmword_1BBB6F550);
  int8x16_t v17 = *_X5;
  int8x16_t v18 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  int8x16_t v24 = *result;
  int8x16_t v25 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  int v27 = v13 + 2;
  int8x16_t v28 = vceqzq_s8(v16);
  int8x16_t v29 = vceqzq_s8(v15);
  signed int v30 = a5;
  do
  {
    uint8x16_t v31 = (uint8x16_t)vextq_s8(v17, v18, 0xEuLL);
    int8x16_t v32 = v25;
    uint8x16_t v33 = (uint8x16_t)vextq_s8(v11, v17, 0xEuLL);
    int8x16_t v17 = v24;
    _X10 = (uint64_t)result->i64 + a2;
    int8x16_t v24 = *(int8x16_t *)((char *)result + a2);
    int8x16_t v25 = *(int8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X10,#0x20] }
    v7.i16[0] = *(__int16 *)((char *)result[2].i16 + a2);
    uint8x16_t v36 = (uint8x16_t)vextq_s8(v24, v25, 2uLL);
    uint8x16_t v37 = (uint8x16_t)vextq_s8(v25, v7, 2uLL);
    int8x16_t v38 = (int8x16_t)vcgtq_u8((uint8x16_t)v32, v37);
    int8x16_t v7 = (int8x16_t)vcgtq_u8(v37, (uint8x16_t)v32);
    *CFTypeID result = vbslq_s8(v29, (int8x16_t)vsqaddq_u8((uint8x16_t)v17, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v17, v33), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v33, (uint8x16_t)v17)), (int8x16_t)vcgtq_u8((uint8x16_t)v17, v36)), (int8x16_t)vcgtq_u8(v36, (uint8x16_t)v17)))), v17);
    result[1] = vbslq_s8(v28, (int8x16_t)vsqaddq_u8((uint8x16_t)v32, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v32, v31), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v31, (uint8x16_t)v32)), v38), v7))), v32);
    int8x16_t v11 = (int8x16_t)vld1q_dup_s16(v30++);
    --v27;
    *a5 = v32.i16[7];
    int8x16_t v18 = v32;
    a5 = (__int16 *)v30;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
  }
  while (v27 > 1);
  return result;
}

uint64_t sub_1BB9FF80C(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, float *a5, int16x8_t *_X5, int a7)
{
  v8.i64[0] = *a3;
  uint64_t v9 = a3[4];
  if ((a4 & 4) != 0)
  {
    int16x8_t v12 = (const float *)&_X5[-1].i32[3];
    int8x16_t v11 = (int8x16_t)vld1q_dup_f32(v12);
  }
  else
  {
    int16x8_t v10 = a5;
    int8x16_t v11 = (int8x16_t)vld1q_dup_f32(v10++);
    *a5 = *(float *)(result + 60);
    _X5 = (int16x8_t *)result;
    result += 2 * a2;
    --a7;
    a5 = (float *)v10;
  }
  v8.i64[1] = v9;
  int v13 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v13 + 1] = *(float *)(result + 2 * (v13 + 1) * a2 + 60);
  int8x16_t v14 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v15 = (int16x8_t)vandq_s8(v14, (int8x16_t)xmmword_1BBB6F580);
  int16x8_t v16 = (int16x8_t)vandq_s8(v14, (int8x16_t)xmmword_1BBB6F590);
  int16x8_t v18 = *_X5;
  int16x8_t v17 = _X5[1];
  int16x8_t v20 = _X5[2];
  int16x8_t v19 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  int8x16_t v26 = *(int8x16_t *)result;
  int8x16_t v27 = *(int8x16_t *)(result + 16);
  int8x16_t v28 = *(int8x16_t *)(result + 32);
  int8x16_t v29 = *(int8x16_t *)(result + 48);
  __asm { PRFM            #0, [X0,#0x40] }
  int v31 = v13 + 2;
  uint64_t v32 = 2 * a2;
  int8x16_t v33 = (int8x16_t)vceqzq_s16(v16);
  int8x16_t v34 = (int8x16_t)vceqzq_s16(v15);
  v35.i64[0] = 0xFC00FC00FC00FC00;
  v35.i64[1] = 0xFC00FC00FC00FC00;
  uint8x16_t v36 = a5;
  do
  {
    uint16x8_t v37 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v19, 0xCuLL);
    int16x8_t v19 = (int16x8_t)v29;
    uint16x8_t v38 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v20, 0xCuLL);
    int16x8_t v20 = (int16x8_t)v28;
    uint16x8_t v39 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v17, 0xCuLL);
    int16x8_t v17 = (int16x8_t)v27;
    uint16x8_t v40 = (uint16x8_t)vextq_s8(v11, (int8x16_t)v18, 0xCuLL);
    int16x8_t v18 = (int16x8_t)v26;
    _X11 = result + v32;
    int8x16_t v26 = *(int8x16_t *)(result + 2 * a2);
    int8x16_t v27 = *(int8x16_t *)(result + v32 + 16);
    int8x16_t v28 = *(int8x16_t *)(result + v32 + 32);
    int8x16_t v29 = *(int8x16_t *)(result + v32 + 48);
    __asm { PRFM            #0, [X11,#0x40] }
    v7.i32[0] = *(_DWORD *)(result + v32 + 64);
    uint16x8_t v43 = (uint16x8_t)vextq_s8(v26, v27, 4uLL);
    uint16x8_t v44 = (uint16x8_t)vextq_s8(v27, v28, 4uLL);
    uint16x8_t v45 = (uint16x8_t)vextq_s8(v28, v29, 4uLL);
    uint16x8_t v46 = (uint16x8_t)vextq_s8(v29, (int8x16_t)v7, 4uLL);
    int8x16_t v47 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v40, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v40)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v43)), (int16x8_t)vcgtq_u16(v43, (uint16x8_t)v18))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v39, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v39)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v44)), (int16x8_t)vcgtq_u16(v44, (uint16x8_t)v17))), (int8x16_t)xmmword_1BBB6F560));
    int16x8_t v48 = (int16x8_t)vcgtq_u16((uint16x8_t)v19, v46);
    int16x8_t v7 = (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v19);
    int8x16_t v49 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v38, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v38)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v20))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v37, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v37)), v48), v7)), (int8x16_t)xmmword_1BBB6F560));
    *(int8x16_t *)CFTypeID result = vbslq_s8(v34, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v47.i8), (int16x8_t)0), v35), (int8x16_t)v18);
    *(int16x8_t *)(result + 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v17, v47), (int16x8_t)0), v35);
    *(int16x8_t *)(result + 32) = vminq_s16(vmaxq_s16(vaddw_s8(v20, *(int8x8_t *)v49.i8), (int16x8_t)0), v35);
    *(int8x16_t *)(result + 48) = vbslq_s8(v33, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v49), (int16x8_t)0), v35), (int8x16_t)v19);
    int8x16_t v11 = (int8x16_t)vld1q_dup_f32(v36++);
    --v31;
    result += v32;
    *a5 = *(float *)&v19.i32[3];
    a5 = (float *)v36;
  }
  while (v31 > 1);
  return result;
}

uint8x16_t *sub_1BB9FFA04(uint8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, uint8x16_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i16[7];
    _X5 = result;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  int v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int16 *)((char *)&result[1].i16[7] + (v9 + 1) * a2);
  uint8x16_t v11 = *_X5;
  uint8x16_t v10 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  uint8x16_t v17 = *result;
  uint8x16_t v18 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  int v20 = v9 + 2;
  do
  {
    uint8x16_t v21 = v17;
    uint8x16_t v22 = v18;
    _X9 = (uint64_t)result->i64 + a2;
    uint8x16_t v17 = *(uint8x16_t *)((char *)result + a2);
    uint8x16_t v18 = *(uint8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X9,#0x20] }
    *a5++ = v22.i16[7];
    int8x16_t v25 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v21, v11), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v11, v21)), (int8x16_t)vcgtq_u8(v21, v17)), (int8x16_t)vcgtq_u8(v17, v21)));
    uint8x16_t v11 = v21;
    uint8x16_t v26 = vsqaddq_u8(v21, v25);
    int8x16_t v27 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v22, v10), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v10, v22)), (int8x16_t)vcgtq_u8(v22, v18)), (int8x16_t)vcgtq_u8(v18, v22)));
    uint8x16_t v10 = v22;
    *CFTypeID result = v26;
    result[1] = vsqaddq_u8(v22, v27);
    --v20;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
  }
  while (v20 > 1);
  return result;
}

uint16x8_t *sub_1BB9FFAF4(uint16x8_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, uint16x8_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i32[3];
    _X5 = result;
    CFTypeID result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  v7.i64[1] = v8;
  int v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int32 *)((char *)&result[3].i32[3] + 2 * (v9 + 1) * a2);
  uint16x8_t v11 = *_X5;
  uint16x8_t v10 = _X5[1];
  uint16x8_t v13 = _X5[2];
  uint16x8_t v12 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  uint16x8_t v19 = *result;
  uint16x8_t v20 = result[1];
  uint16x8_t v21 = result[2];
  uint16x8_t v22 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  int v24 = v9 + 2;
  uint64_t v25 = 2 * a2;
  v26.i64[0] = 0xFC00FC00FC00FC00;
  v26.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v27 = (int16x8_t)v19;
    int16x8_t v28 = (int16x8_t)v20;
    int16x8_t v29 = (int16x8_t)v21;
    int16x8_t v30 = (int16x8_t)v22;
    _X10 = (uint64_t)result->i64 + v25;
    uint16x8_t v19 = *(uint16x8_t *)((char *)result + 2 * a2);
    uint16x8_t v20 = *(uint16x8_t *)((char *)&result[1] + v25);
    uint16x8_t v21 = *(uint16x8_t *)((char *)&result[2] + v25);
    uint16x8_t v22 = *(uint16x8_t *)((char *)&result[3] + v25);
    __asm { PRFM            #0, [X10,#0x40] }
    *a5++ = v30.i32[3];
    int8x16_t v33 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v11, (uint16x8_t)v27), (int16x8_t)vcgtq_u16((uint16x8_t)v27, v11)), (int16x8_t)vcgtq_u16((uint16x8_t)v27, v19)), (int16x8_t)vcgtq_u16(v19, (uint16x8_t)v27))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v28), (int16x8_t)vcgtq_u16((uint16x8_t)v28, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v28, v20)), (int16x8_t)vcgtq_u16(v20, (uint16x8_t)v28))), (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v34 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v13, (uint16x8_t)v29), (int16x8_t)vcgtq_u16((uint16x8_t)v29, v13)), (int16x8_t)vcgtq_u16((uint16x8_t)v29, v21)), (int16x8_t)vcgtq_u16(v21, (uint16x8_t)v29))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v12, (uint16x8_t)v30), (int16x8_t)vcgtq_u16((uint16x8_t)v30, v12)), (int16x8_t)vcgtq_u16((uint16x8_t)v30, v22)), (int16x8_t)vcgtq_u16(v22, (uint16x8_t)v30))), (int8x16_t)xmmword_1BBB6F560));
    *(int16x8_t *)CFTypeID result = vminq_s16(vmaxq_s16(vaddw_s8(v27, *(int8x8_t *)v33.i8), (int16x8_t)0), v26);
    result[1] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v28, v33), (int16x8_t)0), v26);
    result[2] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_s8(v29, *(int8x8_t *)v34.i8), (int16x8_t)0), v26);
    result[3] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v30, v34), (int16x8_t)0), v26);
    --v24;
    CFTypeID result = (uint16x8_t *)((char *)result + v25);
    uint16x8_t v11 = (uint16x8_t)v27;
    uint16x8_t v10 = (uint16x8_t)v28;
    uint16x8_t v13 = (uint16x8_t)v29;
    uint16x8_t v12 = (uint16x8_t)v30;
  }
  while (v24 > 1);
  return result;
}

int8x16_t *sub_1BB9FFC84(int8x16_t *result, uint64_t a2, uint64_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  v8.i64[0] = *a3;
  v8.i64[1] = a3[4];
  int8x16_t v9 = vdupq_n_s8(~a4);
  int8x16_t v10 = vandq_s8(v9, (int8x16_t)xmmword_1BBB6F540);
  _X8 = result + 2;
  int v12 = a7 + 1;
  int8x16_t v13 = vceqzq_s8(vandq_s8(v9, (int8x16_t)xmmword_1BBB6F550));
  int8x16_t v14 = vceqzq_s8(v10);
  int16x8_t v15 = a5;
  do
  {
    int8x16_t v16 = _X8[-2];
    int8x16_t v17 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    int8x16_t v23 = (int8x16_t)vld1q_dup_s16(v15++);
    *a5 = v17.i16[7];
    v7.i16[0] = _X8->i16[0];
    uint8x16_t v24 = (uint8x16_t)vextq_s8(v23, v16, 0xEuLL);
    uint8x16_t v25 = (uint8x16_t)vextq_s8(v16, v17, 0xEuLL);
    uint8x16_t v26 = (uint8x16_t)vextq_s8(v16, v17, 2uLL);
    uint8x16_t v27 = (uint8x16_t)vextq_s8(v17, v7, 2uLL);
    int8x16_t v7 = (int8x16_t)vsqaddq_u8((uint8x16_t)v17, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v17, v25), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v25, (uint8x16_t)v17)), (int8x16_t)vcgtq_u8((uint8x16_t)v17, v27)), (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v17))));
    _X8[-2] = vbslq_s8(v14, (int8x16_t)vsqaddq_u8((uint8x16_t)v16, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v16, v26), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v26, (uint8x16_t)v16)), (int8x16_t)vcgtq_u8((uint8x16_t)v16, v24)), (int8x16_t)vcgtq_u8(v24, (uint8x16_t)v16)))), v16);
    _X8[-1] = vbslq_s8(v13, v7, v17);
    _X8 = (int8x16_t *)((char *)_X8 + a2);
    --v12;
    a5 = (__int16 *)v15;
  }
  while (v12 > 1);
  return result;
}

int16x8_t *sub_1BB9FFD74(int16x8_t *result, uint64_t a2, uint64_t *a3, int a4, float *a5, uint64_t a6, int a7)
{
  v8.i64[0] = *a3;
  v8.i64[1] = a3[4];
  int8x16_t v9 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F580);
  _X8 = result + 2;
  int v12 = a7 + 1;
  int8x16_t v13 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F590));
  int8x16_t v14 = (int8x16_t)vceqzq_s16(v10);
  v15.i64[0] = 0xFC00FC00FC00FC00;
  v15.i64[1] = 0xFC00FC00FC00FC00;
  int8x16_t v16 = a5;
  do
  {
    int16x8_t v17 = _X8[-2];
    int16x8_t v18 = _X8[-1];
    int16x8_t v20 = *_X8;
    int16x8_t v19 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    int8x16_t v26 = (int8x16_t)vld1q_dup_f32(v16++);
    *a5 = *(float *)&v19.i32[3];
    v7.i32[0] = _X8[2].i32[0];
    uint16x8_t v27 = (uint16x8_t)vextq_s8(v26, (int8x16_t)v17, 0xCuLL);
    uint16x8_t v28 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 0xCuLL);
    uint16x8_t v29 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v20, 0xCuLL);
    uint16x8_t v30 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v19, 0xCuLL);
    uint16x8_t v31 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 4uLL);
    uint16x8_t v32 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v20, 4uLL);
    uint16x8_t v33 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v19, 4uLL);
    uint16x8_t v34 = (uint16x8_t)vextq_s8((int8x16_t)v19, v7, 4uLL);
    int8x16_t v35 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v31, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v31)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v27)), (int16x8_t)vcgtq_u16(v27, (uint16x8_t)v17))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v28, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v28)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v32)), (int16x8_t)vcgtq_u16(v32, (uint16x8_t)v18))), (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v36 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v29, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v29)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v33)), (int16x8_t)vcgtq_u16(v33, (uint16x8_t)v20))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v30, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v30)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v34)), (int16x8_t)vcgtq_u16(v34, (uint16x8_t)v19))), (int8x16_t)xmmword_1BBB6F560));
    int16x8_t v37 = vaddw_s8(v20, *(int8x8_t *)v36.i8);
    int8x16_t v7 = (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v36), (int16x8_t)0), v15);
    _X8[-2] = (int16x8_t)vbslq_s8(v14, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v35.i8), (int16x8_t)0), v15), (int8x16_t)v17);
    _X8[-1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v18, v35), (int16x8_t)0), v15);
    *_X8 = vminq_s16(vmaxq_s16(v37, (int16x8_t)0), v15);
    _X8[1] = (int16x8_t)vbslq_s8(v13, v7, (int8x16_t)v19);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v12;
    a5 = (float *)v16;
  }
  while (v12 > 1);
  return result;
}

int8x16_t *sub_1BB9FFEE8(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, int8x16_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  a5[a7] = *(__int16 *)((char *)&result->i16[-1] + a7 * a2);
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[7];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  int8x16_t v9 = *_X5;
  i16 = _X5[1].i16;
  __asm { PRFM            #0, [X5,#0x10] }
  _X10 = result + 1;
  int8x16_t v17 = *result;
  __asm { PRFM            #0, [X10] }
  int8x16_t v19 = (int8x16_t)vld1q_dup_s16(i16);
  *a5 = HIWORD(*(unsigned long long *)result);
  int16x8_t v20 = a5 + 1;
  signed int v21 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  int8x16_t v22 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1BBB6F5A0));
  int8x16_t v23 = v20;
  do
  {
    _X11 = (uint64_t)result[1].i64 + a2;
    int8x16_t v25 = *(int8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X11] }
    int8x16_t v27 = (int8x16_t)vld1q_dup_s16(v23++);
    *int16x8_t v20 = v25.i16[7];
    uint8x16_t v28 = (uint8x16_t)vextq_s8(v9, v19, 2uLL);
    uint8x16_t v29 = (uint8x16_t)vextq_s8(v27, v25, 0xEuLL);
    *CFTypeID result = vbslq_s8(v22, (int8x16_t)vsqaddq_u8((uint8x16_t)v17, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v17, v28), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v28, (uint8x16_t)v17)), (int8x16_t)vcgtq_u8((uint8x16_t)v17, v29)), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v17)))), v17);
    uint16x8_t v30 = result[1].i16;
    --v21;
    int16x8_t v20 = (__int16 *)v23;
    int8x16_t v19 = (int8x16_t)vld1q_dup_s16(v30);
    int8x16_t v9 = v17;
    int8x16_t v17 = v25;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
  }
  while (v21 > 1);
  return result;
}

uint64_t sub_1BB9FFFF8(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, _OWORD *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  a5[a7] = *(_DWORD *)(result + 2 * a7 * a2 - 4);
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_DWORD *)(result + 28);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  v7.i64[1] = v8;
  int8x16_t v9 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F580);
  int8x16_t v12 = *(int8x16_t *)_X5;
  int8x16_t v11 = *((int8x16_t *)_X5 + 1);
  __asm { PRFM            #0, [X5,#0x20] }
  int16x8_t v18 = (const float *)(_X5 + 2);
  int8x16_t v19 = *(int8x16_t *)result;
  int8x16_t v20 = *(int8x16_t *)(result + 16);
  __asm { PRFM            #0, [X0,#0x20] }
  int8x16_t v22 = (int8x16_t)vld1q_dup_f32(v18);
  *a5 = v20.i32[3];
  int8x16_t v23 = (float *)(a5 + 1);
  uint64_t v24 = 2 * a2;
  signed int v25 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  int8x16_t v26 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F590));
  int8x16_t v27 = (int8x16_t)vceqzq_s16(v10);
  v28.i64[0] = 0xFC00FC00FC00FC00;
  v28.i64[1] = 0xFC00FC00FC00FC00;
  uint8x16_t v29 = v23;
  do
  {
    uint16x8_t v30 = (uint16x8_t)vextq_s8(v12, v11, 4uLL);
    int16x8_t v31 = (int16x8_t)v20;
    int16x8_t v32 = (int16x8_t)v19;
    _X11 = result + v24;
    int8x16_t v19 = *(int8x16_t *)(result + 2 * a2);
    int8x16_t v20 = *(int8x16_t *)(result + v24 + 16);
    __asm { PRFM            #0, [X11,#0x20] }
    int8x16_t v35 = (int8x16_t)vld1q_dup_f32(v29++);
    uint16x8_t v36 = (uint16x8_t)vextq_s8(v11, v22, 4uLL);
    *int8x16_t v23 = *(float *)&v20.i32[3];
    uint16x8_t v37 = (uint16x8_t)vextq_s8(v35, v19, 0xCuLL);
    uint16x8_t v38 = (uint16x8_t)vextq_s8(v19, v20, 0xCuLL);
    int8x16_t v39 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v30, (uint16x8_t)v32), (int16x8_t)vcgtq_u16((uint16x8_t)v32, v30)), (int16x8_t)vcgtq_u16((uint16x8_t)v32, v37)), (int16x8_t)vcgtq_u16(v37, (uint16x8_t)v32))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v36, (uint16x8_t)v31), (int16x8_t)vcgtq_u16((uint16x8_t)v31, v36)), (int16x8_t)vcgtq_u16((uint16x8_t)v31, v38)), (int16x8_t)vcgtq_u16(v38, (uint16x8_t)v31))), (int8x16_t)xmmword_1BBB6F560));
    *(int8x16_t *)CFTypeID result = vbslq_s8(v27, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v32, *(int8x8_t *)v39.i8), (int16x8_t)0), v28), (int8x16_t)v32);
    *(int8x16_t *)(result + 16) = vbslq_s8(v26, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v31, v39), (int16x8_t)0), v28), (int8x16_t)v31);
    uint16x8_t v40 = (const float *)(result + 32);
    --v25;
    result += v24;
    int8x16_t v22 = (int8x16_t)vld1q_dup_f32(v40);
    int8x16_t v23 = (float *)v29;
    int8x16_t v12 = (int8x16_t)v32;
    int8x16_t v11 = (int8x16_t)v31;
  }
  while (v25 > 1);
  return result;
}

int8x16_t *sub_1BBA00164(int8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, __int16 *a5, int8x16_t *a6, int a7)
{
  v8.i64[0] = *a3;
  uint64_t v9 = a3[4];
  if ((a4 & 4) != 0)
  {
    int8x16_t v12 = &a6[-1].i16[7];
    int8x16_t v11 = (int8x16_t)vld1q_dup_s16(v12);
  }
  else
  {
    int16x8_t v10 = a5;
    int8x16_t v11 = (int8x16_t)vld1q_dup_s16(v10++);
    *a5 = result->i16[7];
    a6 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (__int16 *)v10;
  }
  v8.i64[1] = v9;
  int v13 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v13 + 1] = *(__int16 *)((char *)&result->i16[7] + (v13 + 1) * a2);
  int8x16_t v15 = *a6;
  _X5 = a6 + 1;
  int8x16_t v16 = v15;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  int8x16_t v23 = *result;
  __asm { PRFM            #0, [X9] }
  int v25 = v13 + 2;
  int8x16_t v26 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1BBB6F5A0));
  int8x16_t v27 = a5;
  do
  {
    _X10 = (uint64_t)result->i64 + a2;
    int8x16_t v29 = *(int8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10,#0x10] }
    v7.i16[0] = *(__int16 *)((char *)result[1].i16 + a2);
    uint8x16_t v31 = (uint8x16_t)vextq_s8(v11, v16, 0xEuLL);
    uint8x16_t v32 = (uint8x16_t)vextq_s8(v29, v7, 2uLL);
    int8x16_t v7 = vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v23, v31), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560);
    *CFTypeID result = vbslq_s8(v26, (int8x16_t)vsqaddq_u8((uint8x16_t)v23, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(v7, (int8x16_t)vcgtq_u8(v31, (uint8x16_t)v23)), (int8x16_t)vcgtq_u8((uint8x16_t)v23, v32)), (int8x16_t)vcgtq_u8(v32, (uint8x16_t)v23)))), v23);
    int8x16_t v11 = (int8x16_t)vld1q_dup_s16(v27++);
    --v25;
    int8x16_t v16 = v23;
    *a5 = v23.i16[7];
    int8x16_t v23 = v29;
    a5 = (__int16 *)v27;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
  }
  while (v25 > 1);
  return result;
}

uint64_t sub_1BBA0027C(uint64_t result, uint64_t a2, uint64_t *a3, unsigned int a4, float *a5, _OWORD *_X5, int a7)
{
  v8.i64[0] = *a3;
  uint64_t v9 = a3[4];
  if ((a4 & 4) != 0)
  {
    int8x16_t v12 = (const float *)_X5 - 1;
    int8x16_t v11 = (int8x16_t)vld1q_dup_f32(v12);
  }
  else
  {
    int16x8_t v10 = a5;
    int8x16_t v11 = (int8x16_t)vld1q_dup_f32(v10++);
    *a5 = *(float *)(result + 28);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
    a5 = (float *)v10;
  }
  v8.i64[1] = v9;
  int v13 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v13 + 1] = *(float *)(result + 2 * (v13 + 1) * a2 + 28);
  int8x16_t v14 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v15 = (int16x8_t)vandq_s8(v14, (int8x16_t)xmmword_1BBB6F580);
  int16x8_t v16 = (int16x8_t)vandq_s8(v14, (int8x16_t)xmmword_1BBB6F590);
  int16x8_t v17 = *(int16x8_t *)_X5;
  int8x16_t v18 = *((int8x16_t *)_X5 + 1);
  __asm { PRFM            #0, [X5,#0x20] }
  int8x16_t v24 = *(int8x16_t *)result;
  int8x16_t v25 = *(int8x16_t *)(result + 16);
  __asm { PRFM            #0, [X0,#0x20] }
  uint64_t v27 = 2 * a2;
  int v28 = v13 + 2;
  int8x16_t v29 = (int8x16_t)vceqzq_s16(v16);
  int8x16_t v30 = (int8x16_t)vceqzq_s16(v15);
  v31.i64[0] = 0xFC00FC00FC00FC00;
  v31.i64[1] = 0xFC00FC00FC00FC00;
  uint8x16_t v32 = a5;
  do
  {
    uint16x8_t v33 = (uint16x8_t)vextq_s8((int8x16_t)v17, v18, 0xCuLL);
    int16x8_t v34 = (int16x8_t)v25;
    uint16x8_t v35 = (uint16x8_t)vextq_s8(v11, (int8x16_t)v17, 0xCuLL);
    int16x8_t v17 = (int16x8_t)v24;
    _X11 = result + v27;
    int8x16_t v24 = *(int8x16_t *)(result + 2 * a2);
    int8x16_t v25 = *(int8x16_t *)(result + v27 + 16);
    __asm { PRFM            #0, [X11,#0x20] }
    v7.i32[0] = *(_DWORD *)(result + v27 + 32);
    uint16x8_t v38 = (uint16x8_t)vextq_s8(v24, v25, 4uLL);
    uint16x8_t v39 = (uint16x8_t)vextq_s8(v25, (int8x16_t)v7, 4uLL);
    int16x8_t v40 = (int16x8_t)vcgtq_u16((uint16x8_t)v34, v39);
    int16x8_t v7 = (int16x8_t)vcgtq_u16(v39, (uint16x8_t)v34);
    int8x16_t v41 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v35, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v35)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v38)), (int16x8_t)vcgtq_u16(v38, (uint16x8_t)v17))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v33, (uint16x8_t)v34), (int16x8_t)vcgtq_u16((uint16x8_t)v34, v33)), v40), v7)), (int8x16_t)xmmword_1BBB6F560));
    *(int8x16_t *)CFTypeID result = vbslq_s8(v30, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v41.i8), (int16x8_t)0), v31), (int8x16_t)v17);
    *(int8x16_t *)(result + 16) = vbslq_s8(v29, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v34, v41), (int16x8_t)0), v31), (int8x16_t)v34);
    int8x16_t v11 = (int8x16_t)vld1q_dup_f32(v32++);
    --v28;
    result += v27;
    *a5 = *(float *)&v34.i32[3];
    int8x16_t v18 = (int8x16_t)v34;
    a5 = (float *)v32;
  }
  while (v28 > 1);
  return result;
}

uint8x16_t *sub_1BBA003F0(uint8x16_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, uint8x16_t *a6, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[7];
    a6 = result;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  int v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int16 *)((char *)&result->i16[7] + (v9 + 1) * a2);
  uint8x16_t v11 = *a6;
  _X5 = a6 + 1;
  uint8x16_t v12 = v11;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  uint8x16_t v19 = *result;
  __asm { PRFM            #0, [X9] }
  int v21 = v9 + 2;
  do
  {
    _X10 = (uint64_t)result[1].i64 + a2;
    uint8x16_t v23 = *(uint8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10] }
    *a5++ = v19.i16[7];
    int8x16_t v25 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v19, v12), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v12, v19)), (int8x16_t)vcgtq_u8(v19, v23)), (int8x16_t)vcgtq_u8(v23, v19)));
    uint8x16_t v12 = v19;
    *CFTypeID result = vsqaddq_u8(v19, v25);
    --v21;
    uint8x16_t v19 = v23;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
  }
  while (v21 > 1);
  return result;
}

uint16x8_t *sub_1BBA004B8(uint16x8_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _DWORD *a5, uint16x8_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i32[3];
    _X5 = result;
    CFTypeID result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  v7.i64[1] = v8;
  int v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int32 *)((char *)&result[1].i32[3] + 2 * (v9 + 1) * a2);
  uint16x8_t v11 = *_X5;
  uint16x8_t v10 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  uint16x8_t v17 = *result;
  uint16x8_t v18 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  uint64_t v20 = 2 * a2;
  int v21 = v9 + 2;
  v22.i64[0] = 0xFC00FC00FC00FC00;
  v22.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v23 = (int16x8_t)v17;
    int16x8_t v24 = (int16x8_t)v18;
    _X10 = (uint64_t)result->i64 + v20;
    uint16x8_t v17 = *(uint16x8_t *)((char *)result + 2 * a2);
    uint16x8_t v18 = *(uint16x8_t *)((char *)&result[1] + v20);
    __asm { PRFM            #0, [X10,#0x20] }
    *a5++ = v24.i32[3];
    int8x16_t v27 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v11, (uint16x8_t)v23), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v11)), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v17)), (int16x8_t)vcgtq_u16(v17, (uint16x8_t)v23))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v24), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v18)), (int16x8_t)vcgtq_u16(v18, (uint16x8_t)v24))), (int8x16_t)xmmword_1BBB6F560));
    --v21;
    *(int16x8_t *)CFTypeID result = vminq_s16(vmaxq_s16(vaddw_s8(v23, *(int8x8_t *)v27.i8), (int16x8_t)0), v22);
    result[1] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v24, v27), (int16x8_t)0), v22);
    CFTypeID result = (uint16x8_t *)((char *)result + v20);
    uint16x8_t v11 = (uint16x8_t)v23;
    uint16x8_t v10 = (uint16x8_t)v24;
  }
  while (v21 > 1);
  return result;
}

uint64_t sub_1BBA005C8(uint64_t result, uint64_t a2, uint64_t *a3, int a4, __int16 *a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x16_t a12, uint64_t a13, int a14)
{
  v14.i64[0] = *a3;
  v14.i64[1] = a3[4];
  _X8 = (unsigned __int16 *)(result + 16);
  int v16 = a14 + 1;
  int8x16_t v17 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1BBB6F5A0));
  uint16x8_t v18 = a5;
  do
  {
    int8x16_t v19 = *((int8x16_t *)_X8 - 1);
    __asm { PRFM            #0, [X8] }
    int8x16_t v25 = (int8x16_t)vld1q_dup_s16(v18++);
    uint8x16_t v26 = (uint8x16_t)vextq_s8(v25, v19, 0xEuLL);
    *a5 = v19.i16[7];
    a12.i16[0] = *_X8;
    uint8x16_t v27 = (uint8x16_t)vextq_s8(v19, a12, 2uLL);
    a12 = (int8x16_t)vsqaddq_u8((uint8x16_t)v19, vqtbl1q_s8(v14, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v19, v26), (int8x16_t)xmmword_1BBB6F570, (int8x16_t)xmmword_1BBB6F560), (int8x16_t)vcgtq_u8(v26, (uint8x16_t)v19)), (int8x16_t)vcgtq_u8((uint8x16_t)v19, v27)), (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v19))));
    *((int8x16_t *)_X8 - 1) = vbslq_s8(v17, a12, v19);
    _X8 = (unsigned __int16 *)((char *)_X8 + a2);
    --v16;
    a5 = (__int16 *)v18;
  }
  while (v16 > 1);
  return result;
}

int16x8_t *sub_1BBA00670(int16x8_t *result, uint64_t a2, uint64_t *a3, int a4, float *a5, uint64_t a6, int a7)
{
  v8.i64[0] = *a3;
  v8.i64[1] = a3[4];
  int8x16_t v9 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F580);
  _X8 = result + 2;
  int v12 = a7 + 1;
  int8x16_t v13 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F590));
  int8x16_t v14 = (int8x16_t)vceqzq_s16(v10);
  v15.i64[0] = 0xFC00FC00FC00FC00;
  v15.i64[1] = 0xFC00FC00FC00FC00;
  int v16 = a5;
  do
  {
    int16x8_t v17 = _X8[-2];
    int16x8_t v18 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    int8x16_t v24 = (int8x16_t)vld1q_dup_f32(v16++);
    *a5 = *(float *)&v18.i32[3];
    v7.i32[0] = _X8->i32[0];
    uint16x8_t v25 = (uint16x8_t)vextq_s8(v24, (int8x16_t)v17, 0xCuLL);
    uint16x8_t v26 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 0xCuLL);
    uint16x8_t v27 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 4uLL);
    uint16x8_t v28 = (uint16x8_t)vextq_s8((int8x16_t)v18, v7, 4uLL);
    int8x16_t v29 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v27, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v27)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v25)), (int16x8_t)vcgtq_u16(v25, (uint16x8_t)v17))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v26, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v26)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v28)), (int16x8_t)vcgtq_u16(v28, (uint16x8_t)v18))), (int8x16_t)xmmword_1BBB6F560));
    int8x16_t v7 = (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v29.i8), (int16x8_t)0), v15);
    _X8[-2] = (int16x8_t)vbslq_s8(v14, v7, (int8x16_t)v17);
    _X8[-1] = (int16x8_t)vbslq_s8(v13, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v18, v29), (int16x8_t)0), v15), (int8x16_t)v18);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v12;
    a5 = (float *)v16;
  }
  while (v12 > 1);
  return result;
}

int8x8_t *sub_1BBA0076C(int8x8_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, int8x8_t *_X5, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  a5[a7] = *(__int16 *)((char *)&result->i16[-1] + a7 * a2);
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[3];
    _X5 = result;
    CFTypeID result = (int8x8_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  int8x8_t v9 = *_X5;
  int16x8_t v10 = (const __int16 *)&_X5[1];
  __asm { PRFM            #0, [X5,#8] }
  _X10 = result + 1;
  int8x8_t v17 = *result;
  __asm { PRFM            #0, [X10] }
  int8x8_t v19 = (int8x8_t)vld1q_dup_s16(v10).u64[0];
  *a5 = HIWORD(*(unint64_t *)result);
  uint64_t v20 = a5 + 1;
  signed int v21 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  int8x8_t v22 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x202000000000101));
  int16x8_t v23 = v20;
  do
  {
    _X11 = (uint64_t)&result[1] + a2;
    int8x8_t v25 = *(int8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X11] }
    int8x8_t v27 = (int8x8_t)vld1_dup_s16(v23++);
    *uint64_t v20 = v25.i16[3];
    uint8x8_t v28 = (uint8x8_t)vext_s8(v9, v19, 2uLL);
    uint8x8_t v29 = (uint8x8_t)vext_s8(v27, v25, 6uLL);
    *CFTypeID result = vbsl_s8(v22, (int8x8_t)vsqadd_u8((uint8x8_t)v17, vqtbl1_s8(v7, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v17, v28), (int8x8_t)0xB030B030B030B03, (int8x8_t)0xA020A020A020A02), (int8x8_t)vcgt_u8(v28, (uint8x8_t)v17)), (int8x8_t)vcgt_u8((uint8x8_t)v17, v29)), (int8x8_t)vcgt_u8(v29, (uint8x8_t)v17)))), v17);
    int8x16_t v30 = (const __int16 *)&result[1];
    --v21;
    uint64_t v20 = (__int16 *)v23;
    int8x8_t v19 = (int8x8_t)vld1q_dup_s16(v30).u64[0];
    int8x8_t v9 = v17;
    int8x8_t v17 = v25;
    CFTypeID result = (int8x8_t *)((char *)result + a2);
  }
  while (v21 > 1);
  return result;
}

uint64_t sub_1BBA0087C(uint64_t result, uint64_t a2, unint64_t *a3, unsigned int a4, _DWORD *a5, _OWORD *_X5, int a7, int8x16_t a8)
{
  a8.i64[0] = *a3;
  a5[a7] = *(_DWORD *)(result + 2 * a7 * a2 - 4);
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_DWORD *)(result + 12);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  int8x16_t v8 = *(int8x16_t *)_X5;
  int8x8_t v9 = (const float *)(_X5 + 1);
  __asm { PRFM            #0, [X5,#0x10] }
  _X10 = result + 16;
  int16x8_t v16 = *(int16x8_t *)result;
  __asm { PRFM            #0, [X10] }
  int8x16_t v18 = (int8x16_t)vld1q_dup_f32(v9);
  *a5 = HIDWORD(*(_OWORD *)result);
  int8x8_t v19 = (float *)(a5 + 1);
  uint64_t v20 = 2 * a2;
  signed int v21 = a7 + ((a4 >> 3) | 0xFFFFFFFE) + 2;
  int8x16_t v22 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_n_s16(~a4), (int8x16_t)xmmword_1BBB6F580));
  v23.i64[0] = 0xFC00FC00FC00FC00;
  v23.i64[1] = 0xFC00FC00FC00FC00;
  int8x16_t v24 = v19;
  do
  {
    _X12 = result + v20 + 16;
    int8x16_t v26 = *(int8x16_t *)(result + 2 * a2);
    __asm { PRFM            #0, [X12] }
    int8x16_t v28 = (int8x16_t)vld1q_dup_f32(v24++);
    *int8x8_t v19 = *(float *)&v26.i32[3];
    uint16x8_t v29 = (uint16x8_t)vextq_s8(v8, v18, 4uLL);
    uint16x8_t v30 = (uint16x8_t)vextq_s8(v28, v26, 0xCuLL);
    *(int8x16_t *)CFTypeID result = vbslq_s8(v22, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v16, vqtbl1_s8(a8, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v16, v29), (int8x16_t)xmmword_1BBB6F5C0, (int8x16_t)xmmword_1BBB6F5B0), (int16x8_t)vcgtq_u16(v29, (uint16x8_t)v16)), (int16x8_t)vcgtq_u16((uint16x8_t)v16,
                                                                                                  v30)),
                                                                                   (int16x8_t)vcgtq_u16(v30, (uint16x8_t)v16))))), (int16x8_t)0), v23), (int8x16_t)v16);
    int16x8_t v31 = (const float *)(result + 16);
    --v21;
    result += v20;
    int8x16_t v18 = (int8x16_t)vld1q_dup_f32(v31);
    int8x8_t v19 = (float *)v24;
    int8x16_t v8 = (int8x16_t)v16;
    int16x8_t v16 = (int16x8_t)v26;
  }
  while (v21 > 1);
  return result;
}

int8x8_t *sub_1BBA009A0(int8x8_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, __int16 *a5, int8x8_t *a6, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  if ((a4 & 4) != 0)
  {
    uint16x8_t v11 = (const __int16 *)&a6[-1] + 3;
    int8x8_t v10 = (int8x8_t)vld1q_dup_s16(v11).u64[0];
  }
  else
  {
    int8x8_t v9 = a5;
    int8x8_t v10 = (int8x8_t)vld1q_dup_s16(v9++).u64[0];
    *a5 = result->i16[3];
    a6 = result;
    CFTypeID result = (int8x8_t *)((char *)result + a2);
    --a7;
    a5 = (__int16 *)v9;
  }
  v7.i64[1] = v8;
  int v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(__int16 *)((char *)&result->i16[3] + (v12 + 1) * a2);
  int8x8_t v14 = *a6;
  _X5 = a6 + 1;
  int8x8_t v15 = v14;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  int8x8_t v22 = *result;
  __asm { PRFM            #0, [X9] }
  int v24 = v12 + 2;
  int8x8_t v25 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x202000000000101));
  int8x16_t v26 = a5;
  do
  {
    _X10 = (char *)result + a2;
    int8x8_t v28 = *(int8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10,#8] }
    uint8x8_t v30 = (uint8x8_t)vext_s8(v10, v15, 6uLL);
    v15.i16[0] = *(__int16 *)((char *)result[1].i16 + a2);
    uint8x8_t v31 = (uint8x8_t)vext_s8(v28, v15, 2uLL);
    *CFTypeID result = vbsl_s8(v25, (int8x8_t)vsqadd_u8((uint8x8_t)v22, vqtbl1_s8(v7, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v22, v30), (int8x8_t)0xB030B030B030B03, (int8x8_t)0xA020A020A020A02), (int8x8_t)vcgt_u8(v30, (uint8x8_t)v22)), (int8x8_t)vcgt_u8((uint8x8_t)v22, v31)), (int8x8_t)vcgt_u8(v31, (uint8x8_t)v22)))), v22);
    int8x8_t v10 = (int8x8_t)vld1q_dup_s16(v26++).u64[0];
    --v24;
    int8x8_t v15 = v22;
    *a5 = v22.i16[3];
    int8x8_t v22 = v28;
    a5 = (__int16 *)v26;
    CFTypeID result = (int8x8_t *)((char *)result + a2);
  }
  while (v24 > 1);
  return result;
}

uint64_t sub_1BBA00AB8(uint64_t result, uint64_t a2, unint64_t *a3, unsigned int a4, float *a5, int8x16_t *a6, int a7, int8x16_t a8)
{
  a8.i64[0] = *a3;
  if ((a4 & 4) != 0)
  {
    uint16x8_t v11 = (const float *)&a6[-1].i32[3];
    int8x16_t v10 = (int8x16_t)vld1q_dup_f32(v11);
  }
  else
  {
    int8x8_t v9 = a5;
    int8x16_t v10 = (int8x16_t)vld1q_dup_f32(v9++);
    *a5 = *(float *)(result + 12);
    a6 = (int8x16_t *)result;
    result += 2 * a2;
    --a7;
    a5 = (float *)v9;
  }
  int v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(float *)(result + 2 * (v12 + 1) * a2 + 12);
  int8x16_t v14 = *a6;
  _X5 = a6 + 1;
  int8x16_t v15 = v14;
  __asm { PRFM            #0, [X5] }
  _X8 = result + 16;
  int16x8_t v22 = *(int16x8_t *)result;
  __asm { PRFM            #0, [X8] }
  uint64_t v24 = 2 * a2;
  int v25 = v12 + 2;
  int8x16_t v26 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_n_s16(~a4), (int8x16_t)xmmword_1BBB6F580));
  v27.i64[0] = 0xFC00FC00FC00FC00;
  v27.i64[1] = 0xFC00FC00FC00FC00;
  int8x8_t v28 = a5;
  do
  {
    _X11 = result + v24;
    int8x16_t v30 = *(int8x16_t *)(result + 2 * a2);
    __asm { PRFM            #0, [X11,#0x10] }
    v8.i32[0] = *(_DWORD *)(result + v24 + 16);
    uint16x8_t v32 = (uint16x8_t)vextq_s8(v10, v15, 0xCuLL);
    uint16x8_t v33 = (uint16x8_t)vextq_s8(v30, (int8x16_t)v8, 4uLL);
    int16x8_t v8 = (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v22, v32), (int8x16_t)xmmword_1BBB6F5C0, (int8x16_t)xmmword_1BBB6F5B0);
    *(int8x16_t *)CFTypeID result = vbslq_s8(v26, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v22, vqtbl1_s8(a8, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16(v8, (int16x8_t)vcgtq_u16(v32, (uint16x8_t)v22)), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v33)), (int16x8_t)vcgtq_u16(v33,
                                                                                                (uint16x8_t)v22))))),
                                            (int16x8_t)0),
                                          v27),
                             (int8x16_t)v22);
    int8x16_t v10 = (int8x16_t)vld1q_dup_f32(v28++);
    --v25;
    result += v24;
    *a5 = *(float *)&v22.i32[3];
    int8x16_t v15 = (int8x16_t)v22;
    int16x8_t v22 = (int16x8_t)v30;
    a5 = (float *)v28;
  }
  while (v25 > 1);
  return result;
}

uint8x8_t *sub_1BBA00BE4(uint8x8_t *result, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, uint8x8_t *a6, int a7)
{
  v7.i64[0] = *a3;
  uint64_t v8 = a3[4];
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[3];
    a6 = result;
    CFTypeID result = (uint8x8_t *)((char *)result + a2);
    --a7;
  }
  v7.i64[1] = v8;
  int v9 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v9 + 1] = *(__int16 *)((char *)&result->i16[3] + (v9 + 1) * a2);
  uint8x8_t v11 = *a6;
  _X5 = a6 + 1;
  uint8x8_t v12 = v11;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  uint8x8_t v19 = *result;
  __asm { PRFM            #0, [X9] }
  int v21 = v9 + 2;
  do
  {
    _X10 = (uint64_t)&result[1] + a2;
    uint8x8_t v23 = *(uint8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10] }
    *a5++ = v19.i16[3];
    int8x8_t v25 = vqtbl1_s8(v7, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8(v19, v12), (int8x8_t)0xB030B030B030B03, (int8x8_t)0xA020A020A020A02), (int8x8_t)vcgt_u8(v12, v19)), (int8x8_t)vcgt_u8(v19, v23)), (int8x8_t)vcgt_u8(v23, v19)));
    uint8x8_t v12 = v19;
    *CFTypeID result = vsqadd_u8(v19, v25);
    --v21;
    uint8x8_t v19 = v23;
    CFTypeID result = (uint8x8_t *)((char *)result + a2);
  }
  while (v21 > 1);
  return result;
}

uint16x8_t *sub_1BBA00CAC(uint16x8_t *result, uint64_t a2, unint64_t *a3, unsigned int a4, _DWORD *a5, uint16x8_t *a6, int a7, int8x16_t a8)
{
  a8.i64[0] = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i32[3];
    a6 = result;
    CFTypeID result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  int v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = *(__int32 *)((char *)&result->i32[3] + 2 * (v8 + 1) * a2);
  uint16x8_t v10 = *a6;
  _X5 = a6 + 1;
  uint16x8_t v11 = v10;
  __asm { PRFM            #0, [X5] }
  _X8 = result + 1;
  int16x8_t v18 = *(int16x8_t *)result;
  __asm { PRFM            #0, [X8] }
  uint64_t v20 = 2 * a2;
  int v21 = v8 + 2;
  v22.i64[0] = 0xFC00FC00FC00FC00;
  v22.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    _X11 = (uint64_t)result[1].i64 + v20;
    uint16x8_t v24 = *(uint16x8_t *)((char *)result + 2 * a2);
    __asm { PRFM            #0, [X11] }
    *a5++ = v18.i32[3];
    --v21;
    *(int16x8_t *)CFTypeID result = vminq_s16(vmaxq_s16(vaddw_s8(v18, vqtbl1_s8(a8, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v18, v11), (int8x16_t)xmmword_1BBB6F5C0, (int8x16_t)xmmword_1BBB6F5B0), (int16x8_t)vcgtq_u16(v11, (uint16x8_t)v18)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v24)), (int16x8_t)vcgtq_u16(v24, (uint16x8_t)v18))))), (int16x8_t)0), v22);
    CFTypeID result = (uint16x8_t *)((char *)result + v20);
    uint16x8_t v11 = (uint16x8_t)v18;
    int16x8_t v18 = (int16x8_t)v24;
  }
  while (v21 > 1);
  return result;
}

int8x8_t *sub_1BBA00D90(int8x8_t *result, uint64_t a2, uint64_t *a3, int a4, __int16 *a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x8_t a12, uint64_t a13, int a14)
{
  v14.i64[0] = *a3;
  v14.i64[1] = a3[4];
  _X8 = result + 1;
  int v16 = a14 + 1;
  int8x8_t v17 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x202000000000101));
  int16x8_t v18 = a5;
  do
  {
    int8x8_t v19 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    int8x8_t v25 = (int8x8_t)vld1_dup_s16(v18++);
    uint8x8_t v26 = (uint8x8_t)vext_s8(v25, v19, 6uLL);
    *a5 = v19.i16[3];
    a12.i16[0] = _X8->i16[0];
    uint8x8_t v27 = (uint8x8_t)vext_s8(v19, a12, 2uLL);
    a12 = (int8x8_t)vsqadd_u8((uint8x8_t)v19, vqtbl1_s8(v14, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v19, v26), (int8x8_t)0xB030B030B030B03, (int8x8_t)0xA020A020A020A02), (int8x8_t)vcgt_u8(v26, (uint8x8_t)v19)), (int8x8_t)vcgt_u8((uint8x8_t)v19, v27)), (int8x8_t)vcgt_u8(v27, (uint8x8_t)v19))));
    _X8[-1] = vbsl_s8(v17, a12, v19);
    _X8 = (int8x8_t *)((char *)_X8 + a2);
    --v16;
    a5 = (__int16 *)v18;
  }
  while (v16 > 1);
  return result;
}

int16x8_t *sub_1BBA00E38(int16x8_t *result, uint64_t a2, unint64_t *a3, int a4, float *a5, int8x16_t a6, uint64_t a7, int a8)
{
  a6.i64[0] = *a3;
  _X8 = result + 1;
  int v10 = a8 + 1;
  int8x16_t v11 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_n_s16(~a4), (int8x16_t)xmmword_1BBB6F580));
  v12.i64[0] = 0xFC00FC00FC00FC00;
  v12.i64[1] = 0xFC00FC00FC00FC00;
  int8x16_t v13 = a5;
  do
  {
    int16x8_t v14 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    int8x16_t v20 = (int8x16_t)vld1q_dup_f32(v13++);
    uint16x8_t v21 = (uint16x8_t)vextq_s8(v20, (int8x16_t)v14, 0xCuLL);
    *a5 = *(float *)&v14.i32[3];
    v8.i32[0] = _X8->i32[0];
    uint16x8_t v22 = (uint16x8_t)vextq_s8((int8x16_t)v14, (int8x16_t)v8, 4uLL);
    int16x8_t v23 = (int16x8_t)vcgtq_u16((uint16x8_t)v14, v22);
    int16x8_t v8 = (int16x8_t)vcgtq_u16(v22, (uint16x8_t)v14);
    _X8[-1] = (int16x8_t)vbslq_s8(v11, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v14, vqtbl1_s8(a6, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v14, v21), (int8x16_t)xmmword_1BBB6F5C0, (int8x16_t)xmmword_1BBB6F5B0), (int16x8_t)vcgtq_u16(v21, (uint16x8_t)v14)), v23), v8)))),
                                          (int16x8_t)0),
                                        v12),
                           (int8x16_t)v14);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v10;
    a5 = (float *)v13;
  }
  while (v10 > 1);
  return result;
}

uint8x16_t *sub_1BBA00EEC(uint8x16_t *result, uint64_t a2, long long *a3, uint64_t a4, unsigned char *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  _X8 = result + 2;
  int v10 = a7 + 1;
  do
  {
    uint8x16_t v11 = _X8[-2];
    uint8x16_t v12 = _X8[-1];
    uint8x16_t v13 = *_X8;
    uint8x16_t v14 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    *a5++ = v14.i8[15];
    _X8[-2] = vsqaddq_u8(v11, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v11, 3uLL)));
    _X8[-1] = vsqaddq_u8(v12, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v12, 3uLL)));
    *_X8 = vsqaddq_u8(v13, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v13, 3uLL)));
    _X8[1] = vsqaddq_u8(v14, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v14, 3uLL)));
    _X8 = (uint8x16_t *)((char *)_X8 + a2);
    --v10;
  }
  while (v10 > 1);
  return result;
}

int16x8_t *sub_1BBA00F54(int16x8_t *result, uint64_t a2, long long *a3, uint64_t a4, _WORD *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  int v9 = a7 + 1;
  _X9 = result + 6;
  v11.i64[0] = 0xFC00FC00FC00FC00;
  v11.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v12 = _X9[-6];
    int16x8_t v13 = _X9[-5];
    int16x8_t v14 = _X9[-4];
    int16x8_t v15 = _X9[-3];
    int16x8_t v16 = _X9[-2];
    int16x8_t v17 = _X9[-1];
    int16x8_t v18 = *_X9;
    int16x8_t v19 = _X9[1];
    __asm
    {
      PRFM            #0, [X9,#0x20]
      PRFM            #0, [X9,#0x60]
    }
    *a5++ = v19.i16[7];
    int8x16_t v26 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v12, 5uLL), v13, 5uLL));
    int16x8_t v27 = vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v26.i8), (int16x8_t)0), v11);
    int16x8_t v28 = vminq_s16(vmaxq_s16(vaddw_high_s8(v13, v26), (int16x8_t)0), v11);
    int8x16_t v29 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v14, 5uLL), v15, 5uLL));
    int16x8_t v30 = vminq_s16(vmaxq_s16(vaddw_s8(v14, *(int8x8_t *)v29.i8), (int16x8_t)0), v11);
    int16x8_t v31 = vminq_s16(vmaxq_s16(vaddw_high_s8(v15, v29), (int16x8_t)0), v11);
    int8x16_t v32 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v16, 5uLL), v17, 5uLL));
    int16x8_t v33 = vminq_s16(vmaxq_s16(vaddw_s8(v16, *(int8x8_t *)v32.i8), (int16x8_t)0), v11);
    int16x8_t v34 = vminq_s16(vmaxq_s16(vaddw_high_s8(v17, v32), (int16x8_t)0), v11);
    int8x16_t v35 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v18, 5uLL), v19, 5uLL));
    _X9[-6] = v27;
    _X9[-5] = v28;
    _X9[-4] = v30;
    _X9[-3] = v31;
    _X9[-2] = v33;
    _X9[-1] = v34;
    *_X9 = vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v35.i8), (int16x8_t)0), v11);
    _X9[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v35), (int16x8_t)0), v11);
    --v9;
    _X9 = (int16x8_t *)((char *)_X9 + 2 * a2);
  }
  while (v9 > 1);
  return result;
}

int8x16_t *sub_1BBA0103C(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, unsigned char *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((~a4 & 9) == 0) {
    a5[a7] = result->i8[a7 * a2 - 1];
  }
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i8[15];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  int8x16_t v8 = vdupq_n_s8(~a4);
  int8x16_t v9 = vandq_s8(v8, (int8x16_t)xmmword_1BBB6F500);
  int8x16_t v10 = vandq_s8(v8, (int8x16_t)xmmword_1BBB6F5D0);
  int8x16_t v12 = *_X5;
  int8x16_t v11 = _X5[1];
  int8x16_t v13 = _X5[2];
  int8x16_t v14 = _X5[3];
  i8 = _X5[4].i8;
  __asm { PRFM            #0, [X5,#0x40] }
  int8x16_t v21 = *result;
  int8x16_t v22 = result[1];
  int8x16_t v23 = result[2];
  int8x16_t v24 = result[3];
  int8x8_t v25 = result[4].i8;
  __asm { PRFM            #0, [X0,#0x40] }
  int8x16_t v27 = vld1q_dup_s8(i8);
  *a5 = v24.i8[15];
  int16x8_t v28 = a5 + 1;
  int v29 = a7 + ((a4 >> 3) & 1);
  int8x16_t v30 = vceqzq_s8(v10);
  int8x16_t v31 = vceqzq_s8(v9);
  v32.i64[0] = 0x202020202020202;
  v32.i64[1] = 0x202020202020202;
  v33.i64[0] = 0x303030303030303;
  v33.i64[1] = 0x303030303030303;
  int16x8_t v34 = v28;
  do
  {
    uint8x16_t v35 = (uint8x16_t)vextq_s8(v13, v14, 1uLL);
    int8x16_t v36 = v24;
    uint8x16_t v37 = (uint8x16_t)v23;
    uint8x16_t v38 = (uint8x16_t)v22;
    uint8x16_t v39 = (uint8x16_t)vextq_s8(v12, v11, 1uLL);
    int8x16_t v12 = v21;
    _X11 = &v25[a2];
    int8x16_t v21 = *(int8x16_t *)&v25[a2 - 64];
    int8x16_t v22 = *(int8x16_t *)&v25[a2 - 48];
    int8x16_t v23 = *(int8x16_t *)&v25[a2 - 32];
    int8x16_t v24 = *(int8x16_t *)&v25[a2 - 16];
    __asm { PRFM            #0, [X11] }
    int8x16_t v42 = vld1q_dup_s8(v34++);
    *int16x8_t v28 = v24.i8[15];
    uint8x16_t v43 = (uint8x16_t)vextq_s8(v14, v27, 1uLL);
    uint8x16_t v44 = (uint8x16_t)vextq_s8(v11, v13, 1uLL);
    uint8x16_t v45 = (uint8x16_t)vextq_s8(v42, v21, 0xFuLL);
    uint8x16_t v46 = (uint8x16_t)vextq_s8(v21, v22, 0xFuLL);
    uint8x16_t v47 = (uint8x16_t)vextq_s8(v22, v23, 0xFuLL);
    uint8x16_t v48 = (uint8x16_t)vextq_s8(v23, v24, 0xFuLL);
    int8x16_t v49 = (int8x16_t)vsqaddq_u8((uint8x16_t)v12, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v12, v39), v33, v32), (int8x16_t)vcgtq_u8(v39, (uint8x16_t)v12)), (int8x16_t)vcgtq_u8((uint8x16_t)v12, v45)), (int8x16_t)vcgtq_u8(v45, (uint8x16_t)v12))));
    int8x16_t v50 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v38, v44), v33, v32), (int8x16_t)vcgtq_u8(v44, v38)), (int8x16_t)vcgtq_u8(v38, v46)), (int8x16_t)vcgtq_u8(v46, v38)));
    int8x16_t v11 = (int8x16_t)v38;
    uint8x16_t v51 = vsqaddq_u8(v38, v50);
    int8x16_t v13 = (int8x16_t)v37;
    int8x16_t v52 = vbslq_s8(v30, (int8x16_t)vsqaddq_u8((uint8x16_t)v36, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v36, v43), v33, v32), (int8x16_t)vcgtq_u8(v43, (uint8x16_t)v36)), (int8x16_t)vcgtq_u8((uint8x16_t)v36, v48)), (int8x16_t)vcgtq_u8(v48, (uint8x16_t)v36)))), v36);
    *((int8x16_t *)v25 - 4) = vbslq_s8(v31, v49, v12);
    *((uint8x16_t *)v25 - 3) = v51;
    int8x16_t v27 = vld1q_dup_s8(v25);
    --v29;
    *((uint8x16_t *)v25 - 2) = vsqaddq_u8(v37, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v37, v35), v33, v32), (int8x16_t)vcgtq_u8(v35, v37)), (int8x16_t)vcgtq_u8(v37, v47)), (int8x16_t)vcgtq_u8(v47, v37))));
    *((int8x16_t *)v25 - 1) = v52;
    v25 += a2;
    int16x8_t v28 = (char *)v34;
    int8x16_t v14 = v36;
  }
  while (v29 > 1);
  return result;
}

uint64_t sub_1BBA01204(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, _OWORD *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((~a4 & 9) == 0) {
    a5[a7] = *(_WORD *)(result + 2 * a7 * a2 - 2);
  }
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_WORD *)(result + 126);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  int8x16_t v8 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v9 = (int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1BBB6F500);
  int16x8_t v10 = (int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1BBB6F5E0);
  int16x8_t v12 = *(int16x8_t *)_X5;
  int16x8_t v11 = *((int16x8_t *)_X5 + 1);
  int16x8_t v14 = *((int16x8_t *)_X5 + 2);
  int16x8_t v13 = *((int16x8_t *)_X5 + 3);
  int16x8_t v16 = *((int16x8_t *)_X5 + 4);
  int16x8_t v15 = *((int16x8_t *)_X5 + 5);
  int16x8_t v17 = *((int16x8_t *)_X5 + 6);
  int8x16_t v18 = *((int8x16_t *)_X5 + 7);
  int16x8_t v19 = (const __int16 *)(_X5 + 8);
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  int8x16_t v26 = *(int8x16_t *)result;
  int8x16_t v27 = *(int8x16_t *)(result + 16);
  int8x16_t v28 = *(int8x16_t *)(result + 32);
  int8x16_t v29 = *(int8x16_t *)(result + 48);
  int8x16_t v30 = *(int8x16_t *)(result + 64);
  int8x16_t v31 = *(int8x16_t *)(result + 80);
  uint64_t v32 = result + 96;
  int8x16_t v33 = *(int8x16_t *)(result + 96);
  uint64_t v34 = 2 * a2;
  int v35 = a7 + ((a4 >> 3) & 1);
  int8x16_t v36 = *(int8x16_t *)(result + 112);
  __asm { PRFM            #0, [X0,#0x80] }
  int8x16_t v38 = (int8x16_t)vceqzq_s16(v10);
  int8x16_t v39 = (int8x16_t)vceqzq_s16(v9);
  __asm { PRFM            #0, [X0,#0xC0] }
  v41.i64[0] = 0x202020202020202;
  v41.i64[1] = 0x202020202020202;
  v42.i64[0] = 0xFC00FC00FC00FC00;
  v42.i64[1] = 0xFC00FC00FC00FC00;
  int8x16_t v43 = (int8x16_t)vld1q_dup_s16(v19);
  *a5 = v36.i16[7];
  uint8x16_t v44 = a5 + 1;
  uint8x16_t v45 = v44;
  do
  {
    uint16x8_t v46 = (uint16x8_t)vextq_s8((int8x16_t)v17, v18, 2uLL);
    int16x8_t v47 = (int16x8_t)v36;
    uint16x8_t v48 = (uint16x8_t)vextq_s8((int8x16_t)v15, (int8x16_t)v17, 2uLL);
    int16x8_t v17 = (int16x8_t)v33;
    uint16x8_t v49 = (uint16x8_t)vextq_s8((int8x16_t)v16, (int8x16_t)v15, 2uLL);
    int16x8_t v15 = (int16x8_t)v31;
    uint16x8_t v50 = (uint16x8_t)vextq_s8((int8x16_t)v13, (int8x16_t)v16, 2uLL);
    int16x8_t v16 = (int16x8_t)v30;
    uint16x8_t v51 = (uint16x8_t)vextq_s8((int8x16_t)v14, (int8x16_t)v13, 2uLL);
    int16x8_t v13 = (int16x8_t)v29;
    uint16x8_t v52 = (uint16x8_t)vextq_s8((int8x16_t)v11, (int8x16_t)v14, 2uLL);
    int16x8_t v14 = (int16x8_t)v28;
    uint16x8_t v53 = (uint16x8_t)vextq_s8((int8x16_t)v12, (int8x16_t)v11, 2uLL);
    int16x8_t v11 = (int16x8_t)v27;
    int16x8_t v12 = (int16x8_t)v26;
    _X12 = v32 + v34;
    int8x16_t v26 = *(int8x16_t *)(v32 + v34 - 96);
    int8x16_t v27 = *(int8x16_t *)(v32 + v34 - 80);
    int8x16_t v28 = *(int8x16_t *)(v32 + v34 - 64);
    int8x16_t v29 = *(int8x16_t *)(v32 + v34 - 48);
    int8x16_t v30 = *(int8x16_t *)(v32 + v34 - 32);
    int8x16_t v31 = *(int8x16_t *)(v32 + v34 - 16);
    int8x16_t v33 = *(int8x16_t *)(v32 + 2 * a2);
    int8x16_t v36 = *(int8x16_t *)(v32 + v34 + 16);
    __asm
    {
      PRFM            #0, [X12,#0x20]
      PRFM            #0, [X12,#0x60]
    }
    int8x16_t v57 = (int8x16_t)vld1q_dup_s16(v45++);
    uint16x8_t v58 = (uint16x8_t)vextq_s8(v18, v43, 2uLL);
    uint16x8_t v59 = (uint16x8_t)vextq_s8(v57, v26, 0xEuLL);
    uint16x8_t v60 = (uint16x8_t)vextq_s8(v26, v27, 0xEuLL);
    int16x8_t v61 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v53, (uint16x8_t)v12), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v53)), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v59)), (int16x8_t)vcgtq_u16(v59, (uint16x8_t)v12));
    uint16x8_t v62 = (uint16x8_t)vextq_s8(v27, v28, 0xEuLL);
    int8x16_t v63 = vqmovn_high_s16(vqmovn_s16(v61), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v52, (uint16x8_t)v11), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v52)), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v60)), (int16x8_t)vcgtq_u16(v60, (uint16x8_t)v11)));
    uint16x8_t v64 = (uint16x8_t)vextq_s8(v28, v29, 0xEuLL);
    int16x8_t v65 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v51, (uint16x8_t)v14), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v51)), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v62)), (int16x8_t)vcgtq_u16(v62, (uint16x8_t)v14));
    uint16x8_t v66 = (uint16x8_t)vextq_s8(v29, v30, 0xEuLL);
    int8x16_t v67 = vqmovn_high_s16(vqmovn_s16(v65), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v50, (uint16x8_t)v13), (int16x8_t)vcgtq_u16((uint16x8_t)v13, v50)), (int16x8_t)vcgtq_u16((uint16x8_t)v13, v64)), (int16x8_t)vcgtq_u16(v64, (uint16x8_t)v13)));
    uint16x8_t v68 = (uint16x8_t)vextq_s8(v30, v31, 0xEuLL);
    int16x8_t v69 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v48, (uint16x8_t)v15), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v48)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v68)), (int16x8_t)vcgtq_u16(v68, (uint16x8_t)v15));
    uint16x8_t v70 = (uint16x8_t)vextq_s8(v31, v33, 0xEuLL);
    int8x16_t v71 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v49, (uint16x8_t)v16), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v49)), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v66)), (int16x8_t)vcgtq_u16(v66, (uint16x8_t)v16))), v69);
    uint16x8_t v72 = (uint16x8_t)vextq_s8(v33, v36, 0xEuLL);
    *uint8x16_t v44 = v36.i16[7];
    int8x16_t v73 = vqtbl1q_s8(v7, vaddq_s8(v63, v41));
    int8x16_t v74 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v46, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v46)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v70)), (int16x8_t)vcgtq_u16(v70, (uint16x8_t)v17))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v58, (uint16x8_t)v47), (int16x8_t)vcgtq_u16((uint16x8_t)v47, v58)), (int16x8_t)vcgtq_u16((uint16x8_t)v47, v72)), (int16x8_t)vcgtq_u16(v72, (uint16x8_t)v47)));
    *(int8x16_t *)(v32 - 96) = vbslq_s8(v39, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v73.i8), (int16x8_t)0), v42), (int8x16_t)v12);
    *(int16x8_t *)(v32 - 80) = vminq_s16(vmaxq_s16(vaddw_high_s8(v11, v73), (int16x8_t)0), v42);
    int8x16_t v75 = vqtbl1q_s8(v7, vaddq_s8(v67, v41));
    *(int16x8_t *)(v32 - 64) = vminq_s16(vmaxq_s16(vaddw_s8(v14, *(int8x8_t *)v75.i8), (int16x8_t)0), v42);
    *(int16x8_t *)(v32 - 48) = vminq_s16(vmaxq_s16(vaddw_high_s8(v13, v75), (int16x8_t)0), v42);
    int8x16_t v76 = vqtbl1q_s8(v7, vaddq_s8(v71, v41));
    *(int16x8_t *)(v32 - 32) = vminq_s16(vmaxq_s16(vaddw_s8(v16, *(int8x8_t *)v76.i8), (int16x8_t)0), v42);
    *(int16x8_t *)(v32 - 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v15, v76), (int16x8_t)0), v42);
    int8x16_t v77 = vqtbl1q_s8(v7, vaddq_s8(v74, v41));
    *(int16x8_t *)uint64_t v32 = vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v77.i8), (int16x8_t)0), v42);
    *(int8x16_t *)(v32 + 16) = vbslq_s8(v38, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v47, v77), (int16x8_t)0), v42), (int8x16_t)v47);
    int8x16_t v78 = (const __int16 *)(v32 + 32);
    --v35;
    v32 += v34;
    uint8x16_t v44 = (__int16 *)v45;
    int8x16_t v18 = (int8x16_t)v47;
    int8x16_t v43 = (int8x16_t)vld1q_dup_s16(v78);
  }
  while (v35 > 1);
  return result;
}

int8x16_t *sub_1BBA01528(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, char *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((a4 & 4) != 0)
  {
    int16x8_t v10 = &_X5[-1].i8[15];
    int8x16_t v9 = vld1q_dup_s8(v10);
  }
  else
  {
    int8x16_t v8 = a5;
    int8x16_t v9 = vld1q_dup_s8(v8++);
    *a5 = result[3].i8[15];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (char *)v8;
  }
  int v11 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v11 + 1] = result[3].i8[(v11 + 1) * a2 + 15];
  int8x16_t v12 = vdupq_n_s8(~a4);
  int8x16_t v13 = vandq_s8(v12, (int8x16_t)xmmword_1BBB6F500);
  int8x16_t v14 = vandq_s8(v12, (int8x16_t)xmmword_1BBB6F5D0);
  int8x16_t v15 = *_X5;
  int8x16_t v16 = _X5[1];
  int8x16_t v18 = _X5[2];
  int8x16_t v17 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  int8x16_t v24 = *result;
  int8x16_t v25 = result[1];
  int8x16_t v26 = result[2];
  int8x16_t v27 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  int v29 = v11 + 2;
  int8x16_t v30 = vceqzq_s8(v14);
  int8x16_t v31 = vceqzq_s8(v13);
  v32.i64[0] = 0x202020202020202;
  v32.i64[1] = 0x202020202020202;
  v33.i64[0] = 0x303030303030303;
  v33.i64[1] = 0x303030303030303;
  uint64_t v34 = a5;
  do
  {
    uint8x16_t v35 = (uint8x16_t)vextq_s8(v18, v17, 0xFuLL);
    int8x16_t v17 = v27;
    uint8x16_t v36 = (uint8x16_t)v26;
    uint8x16_t v37 = (uint8x16_t)v25;
    uint8x16_t v38 = (uint8x16_t)vextq_s8(v9, v15, 0xFuLL);
    uint8x16_t v39 = (uint8x16_t)vextq_s8(v15, v16, 0xFuLL);
    int8x16_t v15 = v24;
    _X10 = (uint64_t)result->i64 + a2;
    int8x16_t v24 = *(int8x16_t *)((char *)result + a2);
    int8x16_t v25 = *(int8x16_t *)((char *)&result[1] + a2);
    int8x16_t v26 = *(int8x16_t *)((char *)&result[2] + a2);
    int8x16_t v27 = *(int8x16_t *)((char *)&result[3] + a2);
    __asm { PRFM            #0, [X10,#0x40] }
    v9.i8[0] = result[4].i8[a2];
    uint8x16_t v42 = (uint8x16_t)vextq_s8(v16, v18, 0xFuLL);
    uint8x16_t v43 = (uint8x16_t)vextq_s8(v24, v25, 1uLL);
    uint8x16_t v44 = (uint8x16_t)vextq_s8(v25, v26, 1uLL);
    uint8x16_t v45 = (uint8x16_t)vextq_s8(v26, v27, 1uLL);
    uint8x16_t v46 = (uint8x16_t)vextq_s8(v27, v9, 1uLL);
    int8x16_t v47 = (int8x16_t)vsqaddq_u8((uint8x16_t)v15, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v15, v38), v33, v32), (int8x16_t)vcgtq_u8(v38, (uint8x16_t)v15)), (int8x16_t)vcgtq_u8((uint8x16_t)v15, v43)), (int8x16_t)vcgtq_u8(v43, (uint8x16_t)v15))));
    int8x16_t v16 = (int8x16_t)v37;
    uint8x16_t v48 = vsqaddq_u8(v37, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v37, v39), v33, v32), (int8x16_t)vcgtq_u8(v39, v37)), (int8x16_t)vcgtq_u8(v37, v44)), (int8x16_t)vcgtq_u8(v44, v37))));
    int8x16_t v49 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v36, v42), v33, v32), (int8x16_t)vcgtq_u8(v42, v36)), (int8x16_t)vcgtq_u8(v36, v45)), (int8x16_t)vcgtq_u8(v45, v36)));
    int8x16_t v18 = (int8x16_t)v36;
    *CFTypeID result = vbslq_s8(v31, v47, v15);
    result[1] = (int8x16_t)v48;
    result[2] = (int8x16_t)vsqaddq_u8(v36, v49);
    result[3] = vbslq_s8(v30, (int8x16_t)vsqaddq_u8((uint8x16_t)v17, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v17, v35), v33, v32), (int8x16_t)vcgtq_u8(v35, (uint8x16_t)v17)), (int8x16_t)vcgtq_u8((uint8x16_t)v17, v46)), (int8x16_t)vcgtq_u8(v46, (uint8x16_t)v17)))), v17);
    int8x16_t v9 = vld1q_dup_s8(v34++);
    --v29;
    *a5 = v17.i8[15];
    a5 = (char *)v34;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
  }
  while (v29 > 1);
  return result;
}

uint64_t sub_1BBA016F4(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, __int16 *a5, int16x8_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((a4 & 4) != 0)
  {
    int16x8_t v10 = &_X5[-1].i16[7];
    int8x16_t v9 = (int8x16_t)vld1q_dup_s16(v10);
  }
  else
  {
    int8x16_t v8 = a5;
    int8x16_t v9 = (int8x16_t)vld1q_dup_s16(v8++);
    *a5 = *(_WORD *)(result + 126);
    _X5 = (int16x8_t *)result;
    result += 2 * a2;
    --a7;
    a5 = (__int16 *)v8;
  }
  int v11 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v11 + 1] = *(_WORD *)(result + 2 * (v11 + 1) * a2 + 126);
  int8x16_t v12 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v13 = (int16x8_t)vandq_s8(v12, (int8x16_t)xmmword_1BBB6F500);
  int16x8_t v15 = *_X5;
  int16x8_t v14 = _X5[1];
  int16x8_t v16 = (int16x8_t)vandq_s8(v12, (int8x16_t)xmmword_1BBB6F5E0);
  int16x8_t v18 = _X5[2];
  int16x8_t v17 = _X5[3];
  int16x8_t v20 = _X5[4];
  int16x8_t v19 = _X5[5];
  int16x8_t v22 = _X5[6];
  int16x8_t v21 = _X5[7];
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  int8x16_t v29 = *(int8x16_t *)result;
  int8x16_t v30 = *(int8x16_t *)(result + 16);
  int8x16_t v31 = *(int8x16_t *)(result + 32);
  int8x16_t v32 = *(int8x16_t *)(result + 48);
  uint64_t v33 = result + 96;
  int8x16_t v34 = *(int8x16_t *)(result + 96);
  int8x16_t v35 = *(int8x16_t *)(result + 64);
  int8x16_t v36 = *(int8x16_t *)(result + 80);
  int8x16_t v37 = *(int8x16_t *)(result + 112);
  __asm
  {
    PRFM            #0, [X0,#0x80]
    PRFM            #0, [X0,#0xC0]
  }
  int v40 = v11 + 2;
  uint64_t v41 = 2 * a2;
  int8x16_t v42 = (int8x16_t)vceqzq_s16(v16);
  int8x16_t v43 = (int8x16_t)vceqzq_s16(v13);
  v44.i64[0] = 0x202020202020202;
  v44.i64[1] = 0x202020202020202;
  v45.i64[0] = 0xFC00FC00FC00FC00;
  v45.i64[1] = 0xFC00FC00FC00FC00;
  uint8x16_t v46 = a5;
  do
  {
    uint16x8_t v47 = (uint16x8_t)vextq_s8((int8x16_t)v22, (int8x16_t)v21, 0xEuLL);
    int16x8_t v21 = (int16x8_t)v37;
    uint16x8_t v48 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v22, 0xEuLL);
    int16x8_t v22 = (int16x8_t)v34;
    uint16x8_t v49 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v19, 0xEuLL);
    int16x8_t v19 = (int16x8_t)v36;
    uint16x8_t v50 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v20, 0xEuLL);
    int16x8_t v20 = (int16x8_t)v35;
    uint16x8_t v51 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v17, 0xEuLL);
    int16x8_t v17 = (int16x8_t)v32;
    uint16x8_t v52 = (uint16x8_t)vextq_s8((int8x16_t)v14, (int8x16_t)v18, 0xEuLL);
    int16x8_t v18 = (int16x8_t)v31;
    uint16x8_t v53 = (uint16x8_t)vextq_s8((int8x16_t)v15, (int8x16_t)v14, 0xEuLL);
    int16x8_t v14 = (int16x8_t)v30;
    uint16x8_t v54 = (uint16x8_t)vextq_s8(v9, (int8x16_t)v15, 0xEuLL);
    int16x8_t v15 = (int16x8_t)v29;
    _X12 = v33 + v41;
    int8x16_t v29 = *(int8x16_t *)(v33 + v41 - 96);
    int8x16_t v30 = *(int8x16_t *)(v33 + v41 - 80);
    int8x16_t v31 = *(int8x16_t *)(v33 + v41 - 64);
    int8x16_t v32 = *(int8x16_t *)(v33 + v41 - 48);
    int8x16_t v35 = *(int8x16_t *)(v33 + v41 - 32);
    int8x16_t v36 = *(int8x16_t *)(v33 + v41 - 16);
    uint16x8_t v56 = (uint16x8_t)vextq_s8(v29, v30, 2uLL);
    uint16x8_t v57 = (uint16x8_t)vextq_s8(v30, v31, 2uLL);
    int16x8_t v58 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v54, (uint16x8_t)v15), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v54)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v56)), (int16x8_t)vcgtq_u16(v56, (uint16x8_t)v15));
    uint16x8_t v59 = (uint16x8_t)vextq_s8(v31, v32, 2uLL);
    int16x8_t v60 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v53, (uint16x8_t)v14), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v53)), (int16x8_t)vcgtq_u16((uint16x8_t)v14, v57)), (int16x8_t)vcgtq_u16(v57, (uint16x8_t)v14));
    uint16x8_t v61 = (uint16x8_t)vextq_s8(v32, v35, 2uLL);
    int8x16_t v62 = vqmovn_high_s16(vqmovn_s16(v58), v60);
    int16x8_t v63 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v52, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v52)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v59)), (int16x8_t)vcgtq_u16(v59, (uint16x8_t)v18));
    int16x8_t v64 = vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v51, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v51)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v61));
    int8x16_t v34 = *(int8x16_t *)(v33 + 2 * a2);
    int8x16_t v37 = *(int8x16_t *)(v33 + v41 + 16);
    int16x8_t v65 = vaddq_s16(v64, (int16x8_t)vcgtq_u16(v61, (uint16x8_t)v17));
    uint16x8_t v66 = (uint16x8_t)vextq_s8(v35, v36, 2uLL);
    int8x16_t v67 = vqmovn_high_s16(vqmovn_s16(v63), v65);
    uint16x8_t v68 = (uint16x8_t)vextq_s8(v36, v34, 2uLL);
    __asm
    {
      PRFM            #0, [X12,#0x20]
      PRFM            #0, [X12,#0x60]
    }
    int16x8_t v71 = vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v49, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v49)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v68)), (int16x8_t)vcgtq_u16(v68, (uint16x8_t)v19));
    uint16x8_t v72 = (uint16x8_t)vextq_s8(v34, v37, 2uLL);
    int8x16_t v73 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v50, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v50)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v66)), (int16x8_t)vcgtq_u16(v66, (uint16x8_t)v20))), v71);
    int16x8_t v74 = (int16x8_t)vcgtq_u16((uint16x8_t)v22, v72);
    int16x8_t v75 = vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v48, (uint16x8_t)v22), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v48)), v74);
    v74.i16[0] = *(_WORD *)(v33 + v41 + 32);
    uint16x8_t v76 = (uint16x8_t)vextq_s8(v37, (int8x16_t)v74, 2uLL);
    int8x16_t v77 = vqtbl1q_s8(v7, vaddq_s8(v62, v44));
    int8x16_t v78 = vqmovn_high_s16(vqmovn_s16(vaddq_s16(v75, (int16x8_t)vcgtq_u16(v72, (uint16x8_t)v22))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v47, (uint16x8_t)v21), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v47)), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v76)), (int16x8_t)vcgtq_u16(v76, (uint16x8_t)v21)));
    *(int8x16_t *)(v33 - 96) = vbslq_s8(v43, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v15, *(int8x8_t *)v77.i8), (int16x8_t)0), v45), (int8x16_t)v15);
    *(int16x8_t *)(v33 - 80) = vminq_s16(vmaxq_s16(vaddw_high_s8(v14, v77), (int16x8_t)0), v45);
    int8x16_t v79 = vqtbl1q_s8(v7, vaddq_s8(v67, v44));
    *(int16x8_t *)(v33 - 64) = vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v79.i8), (int16x8_t)0), v45);
    *(int16x8_t *)(v33 - 48) = vminq_s16(vmaxq_s16(vaddw_high_s8(v17, v79), (int16x8_t)0), v45);
    int8x16_t v80 = vqtbl1q_s8(v7, vaddq_s8(v73, v44));
    *(int16x8_t *)(v33 - 32) = vminq_s16(vmaxq_s16(vaddw_s8(v20, *(int8x8_t *)v80.i8), (int16x8_t)0), v45);
    *(int16x8_t *)(v33 - 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v80), (int16x8_t)0), v45);
    int8x16_t v81 = vqtbl1q_s8(v7, vaddq_s8(v78, v44));
    *(int16x8_t *)uint64_t v33 = vminq_s16(vmaxq_s16(vaddw_s8(v22, *(int8x8_t *)v81.i8), (int16x8_t)0), v45);
    *(int8x16_t *)(v33 + 16) = vbslq_s8(v42, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v21, v81), (int16x8_t)0), v45), (int8x16_t)v21);
    int8x16_t v9 = (int8x16_t)vld1q_dup_s16(v46++);
    --v40;
    v33 += v41;
    *a5 = v21.i16[7];
    a5 = (__int16 *)v46;
  }
  while (v40 > 1);
  return result;
}

uint8x16_t *sub_1BBA01A14(uint8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, unsigned char *a5, uint8x16_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i8[15];
    _X5 = result;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  int v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result[3].i8[(v8 + 1) * a2 + 15];
  uint8x16_t v10 = *_X5;
  uint8x16_t v9 = _X5[1];
  uint8x16_t v11 = _X5[2];
  uint8x16_t v12 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  uint8x16_t v18 = *result;
  uint8x16_t v19 = result[1];
  uint8x16_t v20 = result[2];
  uint8x16_t v21 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  int v23 = v8 + 2;
  v24.i64[0] = 0x202020202020202;
  v24.i64[1] = 0x202020202020202;
  v25.i64[0] = 0x303030303030303;
  v25.i64[1] = 0x303030303030303;
  do
  {
    uint8x16_t v26 = v18;
    uint8x16_t v27 = v19;
    uint8x16_t v28 = v20;
    uint8x16_t v29 = v21;
    _X9 = (uint64_t)result->i64 + a2;
    uint8x16_t v18 = *(uint8x16_t *)((char *)result + a2);
    uint8x16_t v19 = *(uint8x16_t *)((char *)&result[1] + a2);
    uint8x16_t v20 = *(uint8x16_t *)((char *)&result[2] + a2);
    uint8x16_t v21 = *(uint8x16_t *)((char *)&result[3] + a2);
    __asm { PRFM            #0, [X9,#0x40] }
    *a5++ = v29.i8[15];
    int8x16_t v32 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v26, v10), v25, v24), (int8x16_t)vcgtq_u8(v10, v26)), (int8x16_t)vcgtq_u8(v26, v18)), (int8x16_t)vcgtq_u8(v18, v26)));
    uint8x16_t v10 = v26;
    uint8x16_t v33 = vsqaddq_u8(v26, v32);
    int8x16_t v34 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v27, v9), v25, v24), (int8x16_t)vcgtq_u8(v9, v27)), (int8x16_t)vcgtq_u8(v27, v19)), (int8x16_t)vcgtq_u8(v19, v27)));
    uint8x16_t v9 = v27;
    uint8x16_t v35 = vsqaddq_u8(v27, v34);
    int8x16_t v36 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v28, v11), v25, v24), (int8x16_t)vcgtq_u8(v11, v28)), (int8x16_t)vcgtq_u8(v28, v20)), (int8x16_t)vcgtq_u8(v20, v28)));
    uint8x16_t v11 = v28;
    uint8x16_t v37 = vsqaddq_u8(v28, v36);
    int8x16_t v38 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v29, v12), v25, v24), (int8x16_t)vcgtq_u8(v12, v29)), (int8x16_t)vcgtq_u8(v29, v21)), (int8x16_t)vcgtq_u8(v21, v29)));
    uint8x16_t v12 = v29;
    *CFTypeID result = v33;
    result[1] = v35;
    result[2] = v37;
    result[3] = vsqaddq_u8(v29, v38);
    --v23;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
  }
  while (v23 > 1);
  return result;
}

uint64_t sub_1BBA01B64(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, uint16x8_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_WORD *)(result + 126);
    _X5 = (uint16x8_t *)result;
    result += 2 * a2;
    --a7;
  }
  int v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = *(_WORD *)(result + 2 * (v8 + 1) * a2 + 126);
  uint16x8_t v10 = *_X5;
  uint16x8_t v9 = _X5[1];
  uint16x8_t v12 = _X5[2];
  uint16x8_t v11 = _X5[3];
  uint16x8_t v14 = _X5[4];
  uint16x8_t v13 = _X5[5];
  uint16x8_t v16 = _X5[6];
  uint16x8_t v15 = _X5[7];
  __asm
  {
    PRFM            #0, [X5,#0x80]
    PRFM            #0, [X5,#0xC0]
  }
  uint16x8_t v23 = *(uint16x8_t *)result;
  uint16x8_t v24 = *(uint16x8_t *)(result + 16);
  uint16x8_t v25 = *(uint16x8_t *)(result + 32);
  uint16x8_t v26 = *(uint16x8_t *)(result + 48);
  uint16x8_t v27 = *(uint16x8_t *)(result + 64);
  uint16x8_t v28 = *(uint16x8_t *)(result + 80);
  uint8x16_t v29 = (int16x8_t *)(result + 96);
  uint16x8_t v30 = *(uint16x8_t *)(result + 96);
  uint16x8_t v31 = *(uint16x8_t *)(result + 112);
  __asm
  {
    PRFM            #0, [X0,#0x80]
    PRFM            #0, [X0,#0xC0]
  }
  int v34 = v8 + 2;
  uint64_t v35 = 2 * a2;
  v36.i64[0] = 0x202020202020202;
  v36.i64[1] = 0x202020202020202;
  v37.i64[0] = 0xFC00FC00FC00FC00;
  v37.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v38 = (int16x8_t)v31;
    int16x8_t v39 = (int16x8_t)v30;
    int16x8_t v40 = (int16x8_t)v28;
    int16x8_t v41 = (int16x8_t)v27;
    int16x8_t v42 = (int16x8_t)v26;
    int16x8_t v43 = (int16x8_t)v25;
    int16x8_t v44 = (int16x8_t)v24;
    int16x8_t v45 = (int16x8_t)v23;
    _X11 = &v29->i8[v35];
    uint16x8_t v23 = *(uint16x8_t *)((char *)&v29[-6] + v35);
    uint16x8_t v24 = *(uint16x8_t *)((char *)&v29[-5] + v35);
    uint16x8_t v25 = *(uint16x8_t *)((char *)&v29[-4] + v35);
    uint16x8_t v26 = *(uint16x8_t *)((char *)&v29[-3] + v35);
    uint16x8_t v27 = *(uint16x8_t *)((char *)&v29[-2] + v35);
    uint16x8_t v28 = *(uint16x8_t *)((char *)&v29[-1] + v35);
    uint16x8_t v30 = *(uint16x8_t *)((char *)v29 + 2 * a2);
    uint16x8_t v31 = *(uint16x8_t *)((char *)&v29[1] + v35);
    __asm
    {
      PRFM            #0, [X11,#0x20]
      PRFM            #0, [X11,#0x60]
    }
    *a5++ = v38.i16[7];
    int8x16_t v49 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v45), (int16x8_t)vcgtq_u16((uint16x8_t)v45, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v45, v23)), (int16x8_t)vcgtq_u16(v23, (uint16x8_t)v45))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v9, (uint16x8_t)v44), (int16x8_t)vcgtq_u16((uint16x8_t)v44, v9)), (int16x8_t)vcgtq_u16((uint16x8_t)v44, v24)), (int16x8_t)vcgtq_u16(v24, (uint16x8_t)v44))), v36));
    int8x16_t v50 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v12, (uint16x8_t)v43), (int16x8_t)vcgtq_u16((uint16x8_t)v43, v12)), (int16x8_t)vcgtq_u16((uint16x8_t)v43, v25)), (int16x8_t)vcgtq_u16(v25, (uint16x8_t)v43))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v11, (uint16x8_t)v42), (int16x8_t)vcgtq_u16((uint16x8_t)v42, v11)), (int16x8_t)vcgtq_u16((uint16x8_t)v42, v26)), (int16x8_t)vcgtq_u16(v26, (uint16x8_t)v42))), v36));
    int8x16_t v51 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v14, (uint16x8_t)v41), (int16x8_t)vcgtq_u16((uint16x8_t)v41, v14)), (int16x8_t)vcgtq_u16((uint16x8_t)v41, v27)), (int16x8_t)vcgtq_u16(v27, (uint16x8_t)v41))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v13, (uint16x8_t)v40), (int16x8_t)vcgtq_u16((uint16x8_t)v40, v13)), (int16x8_t)vcgtq_u16((uint16x8_t)v40, v28)), (int16x8_t)vcgtq_u16(v28, (uint16x8_t)v40))), v36));
    int8x16_t v52 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v16, (uint16x8_t)v39), (int16x8_t)vcgtq_u16((uint16x8_t)v39, v16)), (int16x8_t)vcgtq_u16((uint16x8_t)v39, v30)), (int16x8_t)vcgtq_u16(v30, (uint16x8_t)v39))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v15, (uint16x8_t)v38), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v15)), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v31)), (int16x8_t)vcgtq_u16(v31, (uint16x8_t)v38))), v36));
    v29[-6] = vminq_s16(vmaxq_s16(vaddw_s8(v45, *(int8x8_t *)v49.i8), (int16x8_t)0), v37);
    v29[-5] = vminq_s16(vmaxq_s16(vaddw_high_s8(v44, v49), (int16x8_t)0), v37);
    v29[-4] = vminq_s16(vmaxq_s16(vaddw_s8(v43, *(int8x8_t *)v50.i8), (int16x8_t)0), v37);
    v29[-3] = vminq_s16(vmaxq_s16(vaddw_high_s8(v42, v50), (int16x8_t)0), v37);
    v29[-2] = vminq_s16(vmaxq_s16(vaddw_s8(v41, *(int8x8_t *)v51.i8), (int16x8_t)0), v37);
    v29[-1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v40, v51), (int16x8_t)0), v37);
    --v34;
    *uint8x16_t v29 = vminq_s16(vmaxq_s16(vaddw_s8(v39, *(int8x8_t *)v52.i8), (int16x8_t)0), v37);
    v29[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v38, v52), (int16x8_t)0), v37);
    uint8x16_t v29 = (int16x8_t *)((char *)v29 + v35);
    uint16x8_t v10 = (uint16x8_t)v45;
    uint16x8_t v9 = (uint16x8_t)v44;
    uint16x8_t v12 = (uint16x8_t)v43;
    uint16x8_t v11 = (uint16x8_t)v42;
    uint16x8_t v14 = (uint16x8_t)v41;
    uint16x8_t v13 = (uint16x8_t)v40;
    uint16x8_t v16 = (uint16x8_t)v39;
    uint16x8_t v15 = (uint16x8_t)v38;
  }
  while (v34 > 1);
  return result;
}

int8x16_t *sub_1BBA01E14(int8x16_t *result, uint64_t a2, int8x16_t *a3, int a4, char *a5, uint64_t a6, int a7)
{
  int8x16_t v8 = *a3;
  int8x16_t v9 = vdupq_n_s8(~a4);
  int8x16_t v10 = vandq_s8(v9, (int8x16_t)xmmword_1BBB6F500);
  _X8 = result + 2;
  int v12 = a7 + 1;
  int8x16_t v13 = vceqzq_s8(vandq_s8(v9, (int8x16_t)xmmword_1BBB6F5D0));
  int8x16_t v14 = vceqzq_s8(v10);
  v15.i64[0] = 0x202020202020202;
  v15.i64[1] = 0x202020202020202;
  v16.i64[0] = 0x303030303030303;
  v16.i64[1] = 0x303030303030303;
  int16x8_t v17 = a5;
  do
  {
    int8x16_t v19 = _X8[-2];
    int8x16_t v18 = _X8[-1];
    int8x16_t v20 = *_X8;
    int8x16_t v21 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    int8x16_t v27 = vld1q_dup_s8(v17++);
    *a5 = v21.i8[15];
    v7.i8[0] = _X8[2].i8[0];
    uint8x16_t v28 = (uint8x16_t)vextq_s8(v27, v19, 0xFuLL);
    uint8x16_t v29 = (uint8x16_t)vextq_s8(v19, v18, 0xFuLL);
    uint8x16_t v30 = (uint8x16_t)vextq_s8(v18, v20, 0xFuLL);
    uint8x16_t v31 = (uint8x16_t)vextq_s8(v20, v21, 0xFuLL);
    uint8x16_t v32 = (uint8x16_t)vextq_s8(v19, v18, 1uLL);
    uint8x16_t v33 = (uint8x16_t)vextq_s8(v18, v20, 1uLL);
    uint8x16_t v34 = (uint8x16_t)vextq_s8(v20, v21, 1uLL);
    uint8x16_t v35 = (uint8x16_t)vextq_s8(v21, v7, 1uLL);
    int8x16_t v7 = (int8x16_t)vsqaddq_u8((uint8x16_t)v21, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v21, v31), v16, v15), (int8x16_t)vcgtq_u8(v31, (uint8x16_t)v21)), (int8x16_t)vcgtq_u8((uint8x16_t)v21, v35)), (int8x16_t)vcgtq_u8(v35, (uint8x16_t)v21))));
    _X8[-2] = vbslq_s8(v14, (int8x16_t)vsqaddq_u8((uint8x16_t)v19, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v19, v32), v16, v15), (int8x16_t)vcgtq_u8(v32, (uint8x16_t)v19)), (int8x16_t)vcgtq_u8((uint8x16_t)v19, v28)), (int8x16_t)vcgtq_u8(v28, (uint8x16_t)v19)))), v19);
    _X8[-1] = (int8x16_t)vsqaddq_u8((uint8x16_t)v18, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v18, v29), v16, v15), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v18)), (int8x16_t)vcgtq_u8((uint8x16_t)v18, v33)), (int8x16_t)vcgtq_u8(v33, (uint8x16_t)v18))));
    *(uint8x16_t *)_X8 = vsqaddq_u8((uint8x16_t)v20, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v20, v30), v16, v15), (int8x16_t)vcgtq_u8(v30, (uint8x16_t)v20)), (int8x16_t)vcgtq_u8((uint8x16_t)v20, v34)), (int8x16_t)vcgtq_u8(v34, (uint8x16_t)v20))));
    _X8[1] = vbslq_s8(v13, v7, v21);
    _X8 = (int8x16_t *)((char *)_X8 + a2);
    --v12;
    a5 = (char *)v17;
  }
  while (v12 > 1);
  return result;
}

int16x8_t *sub_1BBA01F5C(int16x8_t *result, uint64_t a2, int8x16_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  int8x16_t v8 = *a3;
  int16x8_t v9 = vdupq_n_s16(~a4);
  int8x16_t v10 = (int8x16_t)vtstq_s16(v9, (int16x8_t)xmmword_1BBB6F500);
  int8x16_t v11 = (int8x16_t)vtstq_s16(v9, (int16x8_t)xmmword_1BBB6F5E0);
  _X8 = result + 6;
  int v13 = a7 + 1;
  v14.i64[0] = 0x202020202020202;
  v14.i64[1] = 0x202020202020202;
  v15.i64[0] = 0xFC00FC00FC00FC00;
  v15.i64[1] = 0xFC00FC00FC00FC00;
  int8x16_t v16 = a5;
  do
  {
    int16x8_t v17 = _X8[-6];
    int16x8_t v18 = _X8[-5];
    int16x8_t v19 = _X8[-4];
    int16x8_t v20 = _X8[-3];
    int16x8_t v21 = _X8[-2];
    int16x8_t v22 = _X8[-1];
    int16x8_t v24 = *_X8;
    int16x8_t v23 = _X8[1];
    __asm
    {
      PRFM            #0, [X8,#0x20]
      PRFM            #0, [X8,#0x60]
    }
    int8x16_t v31 = (int8x16_t)vld1q_dup_s16(v16++);
    *a5 = v23.i16[7];
    uint16x8_t v32 = (uint16x8_t)vextq_s8(v31, (int8x16_t)v17, 0xEuLL);
    uint16x8_t v33 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 0xEuLL);
    uint16x8_t v34 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 0xEuLL);
    uint16x8_t v35 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v20, 0xEuLL);
    uint16x8_t v36 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v21, 0xEuLL);
    uint16x8_t v37 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v22, 0xEuLL);
    uint16x8_t v38 = (uint16x8_t)vextq_s8((int8x16_t)v22, (int8x16_t)v24, 0xEuLL);
    uint16x8_t v39 = (uint16x8_t)vextq_s8((int8x16_t)v24, (int8x16_t)v23, 0xEuLL);
    uint16x8_t v40 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v18, 2uLL);
    uint16x8_t v41 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 2uLL);
    uint16x8_t v42 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v20, 2uLL);
    uint16x8_t v43 = (uint16x8_t)vextq_s8((int8x16_t)v20, (int8x16_t)v21, 2uLL);
    uint16x8_t v44 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v22, 2uLL);
    uint16x8_t v45 = (uint16x8_t)vextq_s8((int8x16_t)v22, (int8x16_t)v24, 2uLL);
    uint16x8_t v46 = (uint16x8_t)vextq_s8((int8x16_t)v24, (int8x16_t)v23, 2uLL);
    v7.i16[0] = _X8[2].i16[0];
    uint16x8_t v47 = (uint16x8_t)vextq_s8((int8x16_t)v23, (int8x16_t)v7, 2uLL);
    int8x16_t v48 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v40, (uint16x8_t)v17), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v40)), (int16x8_t)vcgtq_u16((uint16x8_t)v17, v32)), (int16x8_t)vcgtq_u16(v32, (uint16x8_t)v17))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v33, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v33)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v41)), (int16x8_t)vcgtq_u16(v41, (uint16x8_t)v18))), v14));
    int8x16_t v49 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v34, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v34)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v42)), (int16x8_t)vcgtq_u16(v42, (uint16x8_t)v19))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v35, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v35)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v43)), (int16x8_t)vcgtq_u16(v43, (uint16x8_t)v20))), v14));
    int8x16_t v50 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v36, (uint16x8_t)v21), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v36)), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v44)), (int16x8_t)vcgtq_u16(v44, (uint16x8_t)v21))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v37, (uint16x8_t)v22), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v37)), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v22))), v14));
    int16x8_t v51 = vminq_s16(vmaxq_s16(vaddw_s8(v21, *(int8x8_t *)v50.i8), (int16x8_t)0), v15);
    int16x8_t v52 = vminq_s16(vmaxq_s16(vaddw_high_s8(v22, v50), (int16x8_t)0), v15);
    int16x8_t v53 = (int16x8_t)vcgtq_u16((uint16x8_t)v23, v47);
    int16x8_t v7 = (int16x8_t)vcgtq_u16(v47, (uint16x8_t)v23);
    int8x16_t v54 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v38, (uint16x8_t)v24), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v38)), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v46)), (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v24))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v39, (uint16x8_t)v23), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v39)), v53), v7)), v14));
    _X8[-6] = (int16x8_t)vbslq_s8(v10, (int8x16_t)v17, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v17, *(int8x8_t *)v48.i8), (int16x8_t)0), v15));
    _X8[-5] = vminq_s16(vmaxq_s16(vaddw_high_s8(v18, v48), (int16x8_t)0), v15);
    _X8[-4] = vminq_s16(vmaxq_s16(vaddw_s8(v19, *(int8x8_t *)v49.i8), (int16x8_t)0), v15);
    _X8[-3] = vminq_s16(vmaxq_s16(vaddw_high_s8(v20, v49), (int16x8_t)0), v15);
    _X8[-2] = v51;
    _X8[-1] = v52;
    *_X8 = vminq_s16(vmaxq_s16(vaddw_s8(v24, *(int8x8_t *)v54.i8), (int16x8_t)0), v15);
    _X8[1] = (int16x8_t)vbslq_s8(v11, (int8x16_t)v23, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v23, v54), (int16x8_t)0), v15));
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v13;
    a5 = (__int16 *)v16;
  }
  while (v13 > 1);
  return result;
}

uint8x16_t *sub_1BBA021D0(uint8x16_t *result, uint64_t a2, long long *a3, uint64_t a4, unsigned char *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  _X8 = result + 1;
  int v10 = a7 + 1;
  do
  {
    uint8x16_t v11 = _X8[-1];
    uint8x16_t v12 = *_X8;
    __asm { PRFM            #0, [X8,#0x10] }
    *a5++ = HIBYTE(*(unsigned long long *)_X8);
    _X8[-1] = vsqaddq_u8(v11, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v11, 3uLL)));
    *_X8 = vsqaddq_u8(v12, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v12, 3uLL)));
    _X8 = (uint8x16_t *)((char *)_X8 + a2);
    --v10;
  }
  while (v10 > 1);
  return result;
}

int16x8_t *sub_1BBA02218(int16x8_t *result, uint64_t a2, long long *a3, uint64_t a4, _WORD *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  _X8 = result + 2;
  int v10 = a7 + 1;
  v11.i64[0] = 0xFC00FC00FC00FC00;
  v11.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v12 = _X8[-2];
    int16x8_t v13 = _X8[-1];
    int16x8_t v14 = *_X8;
    int16x8_t v15 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    *a5++ = v15.i16[7];
    int8x16_t v21 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v12, 5uLL), v13, 5uLL));
    int16x8_t v22 = vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v21.i8), (int16x8_t)0), v11);
    int16x8_t v23 = vminq_s16(vmaxq_s16(vaddw_high_s8(v13, v21), (int16x8_t)0), v11);
    int8x16_t v24 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v14, 5uLL), v15, 5uLL));
    _X8[-2] = v22;
    _X8[-1] = v23;
    *_X8 = vminq_s16(vmaxq_s16(vaddw_s8(v14, *(int8x8_t *)v24.i8), (int16x8_t)0), v11);
    _X8[1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v15, v24), (int16x8_t)0), v11);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v10;
  }
  while (v10 > 1);
  return result;
}

int8x16_t *sub_1BBA022A4(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, unsigned char *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((~a4 & 9) == 0) {
    a5[a7] = result->i8[a7 * a2 - 1];
  }
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i8[15];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  int8x16_t v8 = vdupq_n_s8(~a4);
  int8x16_t v9 = vandq_s8(v8, (int8x16_t)xmmword_1BBB6F500);
  int8x16_t v10 = vandq_s8(v8, (int8x16_t)xmmword_1BBB6F5D0);
  int8x16_t v11 = *_X5;
  int8x16_t v12 = _X5[1];
  i8 = _X5[2].i8;
  __asm { PRFM            #0, [X5,#0x20] }
  int8x16_t v19 = *result;
  int8x16_t v20 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  int8x16_t v22 = vld1q_dup_s8(i8);
  *a5 = v20.i8[15];
  int16x8_t v23 = a5 + 1;
  int v24 = a7 + ((a4 >> 3) & 1);
  int8x16_t v25 = vceqzq_s8(v10);
  int8x16_t v26 = vceqzq_s8(v9);
  v27.i64[0] = 0x202020202020202;
  v27.i64[1] = 0x202020202020202;
  v28.i64[0] = 0x303030303030303;
  v28.i64[1] = 0x303030303030303;
  uint8x16_t v29 = v23;
  do
  {
    uint8x16_t v30 = (uint8x16_t)vextq_s8(v11, v12, 1uLL);
    uint8x16_t v31 = (uint8x16_t)vextq_s8(v12, v22, 1uLL);
    int8x16_t v32 = v20;
    int8x16_t v33 = v19;
    _X10 = (uint64_t)result->i64 + a2;
    int8x16_t v19 = *(int8x16_t *)((char *)result + a2);
    int8x16_t v20 = *(int8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X10,#0x20] }
    int8x16_t v36 = vld1q_dup_s8(v29++);
    *int16x8_t v23 = v20.i8[15];
    uint8x16_t v37 = (uint8x16_t)vextq_s8(v36, v19, 0xFuLL);
    uint8x16_t v38 = (uint8x16_t)vextq_s8(v19, v20, 0xFuLL);
    *CFTypeID result = vbslq_s8(v26, (int8x16_t)vsqaddq_u8((uint8x16_t)v33, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v33, v30), v28, v27), (int8x16_t)vcgtq_u8(v30, (uint8x16_t)v33)), (int8x16_t)vcgtq_u8((uint8x16_t)v33, v37)), (int8x16_t)vcgtq_u8(v37, (uint8x16_t)v33)))), v33);
    result[1] = vbslq_s8(v25, (int8x16_t)vsqaddq_u8((uint8x16_t)v32, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v32, v31), v28, v27), (int8x16_t)vcgtq_u8(v31, (uint8x16_t)v32)), (int8x16_t)vcgtq_u8((uint8x16_t)v32, v38)), (int8x16_t)vcgtq_u8(v38, (uint8x16_t)v32)))), v32);
    uint16x8_t v39 = result[2].i8;
    --v24;
    int16x8_t v23 = (char *)v29;
    int8x16_t v22 = vld1q_dup_s8(v39);
    int8x16_t v11 = v33;
    int8x16_t v12 = v32;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
  }
  while (v24 > 1);
  return result;
}

uint64_t sub_1BBA023F0(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, _OWORD *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((~a4 & 9) == 0) {
    a5[a7] = *(_WORD *)(result + 2 * a7 * a2 - 2);
  }
  if ((a4 & 4) == 0)
  {
    *a5++ = *(_WORD *)(result + 62);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
  }
  int8x16_t v8 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v9 = (int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1BBB6F500);
  int16x8_t v10 = (int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1BBB6F5E0);
  int16x8_t v12 = *(int16x8_t *)_X5;
  int16x8_t v11 = *((int16x8_t *)_X5 + 1);
  int8x16_t v13 = *((int8x16_t *)_X5 + 2);
  int8x16_t v14 = *((int8x16_t *)_X5 + 3);
  int16x8_t v15 = (const __int16 *)(_X5 + 4);
  __asm { PRFM            #0, [X5,#0x40] }
  int8x16_t v21 = *(int8x16_t *)result;
  int8x16_t v22 = *(int8x16_t *)(result + 16);
  int8x16_t v23 = *(int8x16_t *)(result + 32);
  int8x16_t v24 = *(int8x16_t *)(result + 48);
  __asm { PRFM            #0, [X0,#0x40] }
  int8x16_t v26 = (int8x16_t)vld1q_dup_s16(v15);
  int8x16_t v27 = (const __int16 *)(result + 64);
  *a5 = v24.i16[7];
  int8x16_t v28 = a5 + 1;
  uint64_t v29 = a2;
  int v30 = a7 + ((a4 >> 3) & 1);
  int8x16_t v31 = (int8x16_t)vceqzq_s16(v10);
  int8x16_t v32 = (int8x16_t)vceqzq_s16(v9);
  v33.i64[0] = 0x202020202020202;
  v33.i64[1] = 0x202020202020202;
  v34.i64[0] = 0xFC00FC00FC00FC00;
  v34.i64[1] = 0xFC00FC00FC00FC00;
  uint16x8_t v35 = v28;
  do
  {
    int16x8_t v36 = (int16x8_t)v24;
    uint16x8_t v37 = (uint16x8_t)vextq_s8((int8x16_t)v11, v13, 2uLL);
    int16x8_t v38 = (int16x8_t)v23;
    uint16x8_t v39 = (uint16x8_t)vextq_s8((int8x16_t)v12, (int8x16_t)v11, 2uLL);
    int16x8_t v11 = (int16x8_t)v22;
    int16x8_t v12 = (int16x8_t)v21;
    _X12 = &v27[v29];
    int8x16_t v21 = *(int8x16_t *)&v27[v29 - 32];
    int8x16_t v22 = *(int8x16_t *)&v27[v29 - 24];
    int8x16_t v23 = *(int8x16_t *)&v27[v29 - 16];
    int8x16_t v24 = *(int8x16_t *)&v27[v29 - 8];
    __asm { PRFM            #0, [X12] }
    int8x16_t v42 = (int8x16_t)vld1q_dup_s16(v35++);
    uint16x8_t v43 = (uint16x8_t)vextq_s8(v13, v14, 2uLL);
    uint16x8_t v44 = (uint16x8_t)vextq_s8(v14, v26, 2uLL);
    *int8x16_t v28 = v24.i16[7];
    uint16x8_t v45 = (uint16x8_t)vextq_s8(v42, v21, 0xEuLL);
    uint16x8_t v46 = (uint16x8_t)vextq_s8(v21, v22, 0xEuLL);
    uint16x8_t v47 = (uint16x8_t)vextq_s8(v22, v23, 0xEuLL);
    uint16x8_t v48 = (uint16x8_t)vextq_s8(v23, v24, 0xEuLL);
    int8x16_t v49 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v39, (uint16x8_t)v12), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v39)), (int16x8_t)vcgtq_u16((uint16x8_t)v12, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v12))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v37, (uint16x8_t)v11), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v37)), (int16x8_t)vcgtq_u16((uint16x8_t)v11, v46)), (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v11))), v33));
    int8x16_t v50 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v43, (uint16x8_t)v38), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v43)), (int16x8_t)vcgtq_u16((uint16x8_t)v38, v47)), (int16x8_t)vcgtq_u16(v47, (uint16x8_t)v38))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v44, (uint16x8_t)v36), (int16x8_t)vcgtq_u16((uint16x8_t)v36, v44)), (int16x8_t)vcgtq_u16((uint16x8_t)v36, v48)), (int16x8_t)vcgtq_u16(v48, (uint16x8_t)v36))), v33));
    *((int8x16_t *)v27 - 4) = vbslq_s8(v32, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v49.i8), (int16x8_t)0), v34), (int8x16_t)v12);
    *((int16x8_t *)v27 - 3) = vminq_s16(vmaxq_s16(vaddw_high_s8(v11, v49), (int16x8_t)0), v34);
    *((int16x8_t *)v27 - 2) = vminq_s16(vmaxq_s16(vaddw_s8(v38, *(int8x8_t *)v50.i8), (int16x8_t)0), v34);
    *((int8x16_t *)v27 - 1) = vbslq_s8(v31, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v36, v50), (int16x8_t)0), v34), (int8x16_t)v36);
    int8x16_t v26 = (int8x16_t)vld1q_dup_s16(v27);
    --v30;
    int8x16_t v27 = (const __int16 *)((char *)v27 + v29 * 2);
    int8x16_t v28 = (__int16 *)v35;
    int8x16_t v13 = (int8x16_t)v38;
    int8x16_t v14 = (int8x16_t)v36;
  }
  while (v30 > 1);
  return result;
}

int8x16_t *sub_1BBA025D4(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, char *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v8 = *a3;
  if ((a4 & 4) != 0)
  {
    int16x8_t v11 = &_X5[-1].i8[15];
    int8x16_t v10 = vld1q_dup_s8(v11);
  }
  else
  {
    int16x8_t v9 = a5;
    int8x16_t v10 = vld1q_dup_s8(v9++);
    *a5 = result[1].i8[15];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (char *)v9;
  }
  int v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = result[1].i8[(v12 + 1) * a2 + 15];
  int8x16_t v13 = vdupq_n_s8(~a4);
  int8x16_t v14 = vandq_s8(v13, (int8x16_t)xmmword_1BBB6F500);
  int8x16_t v15 = vandq_s8(v13, (int8x16_t)xmmword_1BBB6F5D0);
  int8x16_t v16 = *_X5;
  int8x16_t v17 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  int8x16_t v23 = *result;
  int8x16_t v24 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  int v26 = v12 + 2;
  int8x16_t v27 = vceqzq_s8(v15);
  int8x16_t v28 = vceqzq_s8(v14);
  v29.i64[0] = 0x202020202020202;
  v29.i64[1] = 0x202020202020202;
  v30.i64[0] = 0x303030303030303;
  v30.i64[1] = 0x303030303030303;
  int8x16_t v31 = a5;
  do
  {
    uint8x16_t v32 = (uint8x16_t)vextq_s8(v16, v17, 0xFuLL);
    int8x16_t v33 = v24;
    uint8x16_t v34 = (uint8x16_t)vextq_s8(v10, v16, 0xFuLL);
    int8x16_t v16 = v23;
    _X10 = (uint64_t)result->i64 + a2;
    int8x16_t v23 = *(int8x16_t *)((char *)result + a2);
    int8x16_t v24 = *(int8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X10,#0x20] }
    v7.i8[0] = result[2].i8[a2];
    uint8x16_t v37 = (uint8x16_t)vextq_s8(v23, v24, 1uLL);
    uint8x16_t v38 = (uint8x16_t)vextq_s8(v24, v7, 1uLL);
    int8x16_t v39 = (int8x16_t)vcgtq_u8((uint8x16_t)v33, v38);
    int8x16_t v7 = (int8x16_t)vcgtq_u8(v38, (uint8x16_t)v33);
    *CFTypeID result = vbslq_s8(v28, (int8x16_t)vsqaddq_u8((uint8x16_t)v16, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v16, v34), v30, v29), (int8x16_t)vcgtq_u8(v34, (uint8x16_t)v16)), (int8x16_t)vcgtq_u8((uint8x16_t)v16, v37)), (int8x16_t)vcgtq_u8(v37, (uint8x16_t)v16)))), v16);
    result[1] = vbslq_s8(v27, (int8x16_t)vsqaddq_u8((uint8x16_t)v33, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v33, v32), v30, v29), (int8x16_t)vcgtq_u8(v32, (uint8x16_t)v33)), v39), v7))), v33);
    int8x16_t v10 = vld1q_dup_s8(v31++);
    --v26;
    *a5 = v33.i8[15];
    int8x16_t v17 = v33;
    a5 = (char *)v31;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
  }
  while (v26 > 1);
  return result;
}

uint64_t sub_1BBA02724(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, __int16 *a5, int16x8_t *_X5, int a7)
{
  int8x16_t v8 = *a3;
  if ((a4 & 4) != 0)
  {
    int16x8_t v11 = &_X5[-1].i16[7];
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v11);
  }
  else
  {
    int16x8_t v9 = a5;
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v9++);
    *a5 = *(_WORD *)(result + 62);
    _X5 = (int16x8_t *)result;
    result += 2 * a2;
    --a7;
    a5 = (__int16 *)v9;
  }
  int v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(_WORD *)(result + 2 * (v12 + 1) * a2 + 62);
  int8x16_t v13 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v14 = (int16x8_t)vandq_s8(v13, (int8x16_t)xmmword_1BBB6F500);
  int16x8_t v16 = *_X5;
  int16x8_t v15 = _X5[1];
  int16x8_t v17 = (int16x8_t)vandq_s8(v13, (int8x16_t)xmmword_1BBB6F5E0);
  int16x8_t v19 = _X5[2];
  int16x8_t v18 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  int8x16_t v25 = *(int8x16_t *)result;
  int8x16_t v26 = *(int8x16_t *)(result + 16);
  int8x16_t v27 = *(int8x16_t *)(result + 32);
  int8x16_t v28 = *(int8x16_t *)(result + 48);
  __asm { PRFM            #0, [X0,#0x40] }
  int v30 = v12 + 2;
  uint64_t v31 = 2 * a2;
  int8x16_t v32 = (int8x16_t)vceqzq_s16(v17);
  int8x16_t v33 = (int8x16_t)vceqzq_s16(v14);
  v34.i64[0] = 0x202020202020202;
  v34.i64[1] = 0x202020202020202;
  v35.i64[0] = 0xFC00FC00FC00FC00;
  v35.i64[1] = 0xFC00FC00FC00FC00;
  int16x8_t v36 = a5;
  do
  {
    uint16x8_t v37 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v18, 0xEuLL);
    int16x8_t v18 = (int16x8_t)v28;
    uint16x8_t v38 = (uint16x8_t)vextq_s8((int8x16_t)v15, (int8x16_t)v19, 0xEuLL);
    int16x8_t v19 = (int16x8_t)v27;
    uint16x8_t v39 = (uint16x8_t)vextq_s8((int8x16_t)v16, (int8x16_t)v15, 0xEuLL);
    int16x8_t v15 = (int16x8_t)v26;
    uint16x8_t v40 = (uint16x8_t)vextq_s8(v10, (int8x16_t)v16, 0xEuLL);
    int16x8_t v16 = (int16x8_t)v25;
    _X11 = result + v31;
    int8x16_t v25 = *(int8x16_t *)(result + 2 * a2);
    int8x16_t v26 = *(int8x16_t *)(result + v31 + 16);
    int8x16_t v27 = *(int8x16_t *)(result + v31 + 32);
    int8x16_t v28 = *(int8x16_t *)(result + v31 + 48);
    __asm { PRFM            #0, [X11,#0x40] }
    v7.i16[0] = *(_WORD *)(result + v31 + 64);
    uint16x8_t v43 = (uint16x8_t)vextq_s8(v25, v26, 2uLL);
    uint16x8_t v44 = (uint16x8_t)vextq_s8(v26, v27, 2uLL);
    uint16x8_t v45 = (uint16x8_t)vextq_s8(v27, v28, 2uLL);
    uint16x8_t v46 = (uint16x8_t)vextq_s8(v28, (int8x16_t)v7, 2uLL);
    int8x16_t v47 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v40, (uint16x8_t)v16), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v40)), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v43)), (int16x8_t)vcgtq_u16(v43, (uint16x8_t)v16))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v39, (uint16x8_t)v15), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v39)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v44)), (int16x8_t)vcgtq_u16(v44, (uint16x8_t)v15))), v34));
    int16x8_t v48 = (int16x8_t)vcgtq_u16((uint16x8_t)v18, v46);
    int16x8_t v7 = (int16x8_t)vcgtq_u16(v46, (uint16x8_t)v18);
    int8x16_t v49 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v38, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v38)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v45)), (int16x8_t)vcgtq_u16(v45, (uint16x8_t)v19))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v37, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v37)), v48), v7)), v34));
    *(int8x16_t *)CFTypeID result = vbslq_s8(v33, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v16, *(int8x8_t *)v47.i8), (int16x8_t)0), v35), (int8x16_t)v16);
    *(int16x8_t *)(result + 16) = vminq_s16(vmaxq_s16(vaddw_high_s8(v15, v47), (int16x8_t)0), v35);
    *(int16x8_t *)(result + 32) = vminq_s16(vmaxq_s16(vaddw_s8(v19, *(int8x8_t *)v49.i8), (int16x8_t)0), v35);
    *(int8x16_t *)(result + 48) = vbslq_s8(v32, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v18, v49), (int16x8_t)0), v35), (int8x16_t)v18);
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v36++);
    --v30;
    result += v31;
    *a5 = v18.i16[7];
    a5 = (__int16 *)v36;
  }
  while (v30 > 1);
  return result;
}

uint8x16_t *sub_1BBA02908(uint8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, unsigned char *a5, uint8x16_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i8[15];
    _X5 = result;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  int v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result[1].i8[(v8 + 1) * a2 + 15];
  uint8x16_t v10 = *_X5;
  uint8x16_t v9 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  uint8x16_t v16 = *result;
  uint8x16_t v17 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  int v19 = v8 + 2;
  v20.i64[0] = 0x202020202020202;
  v20.i64[1] = 0x202020202020202;
  v21.i64[0] = 0x303030303030303;
  v21.i64[1] = 0x303030303030303;
  do
  {
    uint8x16_t v22 = v16;
    uint8x16_t v23 = v17;
    _X9 = (uint64_t)result->i64 + a2;
    uint8x16_t v16 = *(uint8x16_t *)((char *)result + a2);
    uint8x16_t v17 = *(uint8x16_t *)((char *)&result[1] + a2);
    __asm { PRFM            #0, [X9,#0x20] }
    *a5++ = v23.i8[15];
    int8x16_t v26 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v22, v10), v21, v20), (int8x16_t)vcgtq_u8(v10, v22)), (int8x16_t)vcgtq_u8(v22, v16)), (int8x16_t)vcgtq_u8(v16, v22)));
    uint8x16_t v10 = v22;
    uint8x16_t v27 = vsqaddq_u8(v22, v26);
    int8x16_t v28 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v23, v9), v21, v20), (int8x16_t)vcgtq_u8(v9, v23)), (int8x16_t)vcgtq_u8(v23, v17)), (int8x16_t)vcgtq_u8(v17, v23)));
    uint8x16_t v9 = v23;
    *CFTypeID result = v27;
    result[1] = vsqaddq_u8(v23, v28);
    --v19;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
  }
  while (v19 > 1);
  return result;
}

uint16x8_t *sub_1BBA029E8(uint16x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, uint16x8_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result[3].i16[7];
    _X5 = result;
    CFTypeID result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  int v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result[3].i16[(v8 + 1) * a2 + 7];
  uint16x8_t v10 = *_X5;
  uint16x8_t v9 = _X5[1];
  uint16x8_t v12 = _X5[2];
  uint16x8_t v11 = _X5[3];
  __asm { PRFM            #0, [X5,#0x40] }
  uint16x8_t v18 = *result;
  uint16x8_t v19 = result[1];
  uint16x8_t v20 = result[2];
  uint16x8_t v21 = result[3];
  __asm { PRFM            #0, [X0,#0x40] }
  int v23 = v8 + 2;
  uint64_t v24 = 2 * a2;
  v25.i64[0] = 0x202020202020202;
  v25.i64[1] = 0x202020202020202;
  v26.i64[0] = 0xFC00FC00FC00FC00;
  v26.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v27 = (int16x8_t)v18;
    int16x8_t v28 = (int16x8_t)v19;
    int16x8_t v29 = (int16x8_t)v20;
    int16x8_t v30 = (int16x8_t)v21;
    _X10 = (uint64_t)result->i64 + v24;
    uint16x8_t v18 = *(uint16x8_t *)((char *)result + 2 * a2);
    uint16x8_t v19 = *(uint16x8_t *)((char *)&result[1] + v24);
    uint16x8_t v20 = *(uint16x8_t *)((char *)&result[2] + v24);
    uint16x8_t v21 = *(uint16x8_t *)((char *)&result[3] + v24);
    __asm { PRFM            #0, [X10,#0x40] }
    *a5++ = v30.i16[7];
    int8x16_t v33 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v27), (int16x8_t)vcgtq_u16((uint16x8_t)v27, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v27, v18)), (int16x8_t)vcgtq_u16(v18, (uint16x8_t)v27))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v9, (uint16x8_t)v28), (int16x8_t)vcgtq_u16((uint16x8_t)v28, v9)), (int16x8_t)vcgtq_u16((uint16x8_t)v28, v19)), (int16x8_t)vcgtq_u16(v19, (uint16x8_t)v28))), v25));
    int8x16_t v34 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v12, (uint16x8_t)v29), (int16x8_t)vcgtq_u16((uint16x8_t)v29, v12)), (int16x8_t)vcgtq_u16((uint16x8_t)v29, v20)), (int16x8_t)vcgtq_u16(v20, (uint16x8_t)v29))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v11, (uint16x8_t)v30), (int16x8_t)vcgtq_u16((uint16x8_t)v30, v11)), (int16x8_t)vcgtq_u16((uint16x8_t)v30, v21)), (int16x8_t)vcgtq_u16(v21, (uint16x8_t)v30))), v25));
    *(int16x8_t *)CFTypeID result = vminq_s16(vmaxq_s16(vaddw_s8(v27, *(int8x8_t *)v33.i8), (int16x8_t)0), v26);
    result[1] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v28, v33), (int16x8_t)0), v26);
    result[2] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_s8(v29, *(int8x8_t *)v34.i8), (int16x8_t)0), v26);
    result[3] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v30, v34), (int16x8_t)0), v26);
    --v23;
    CFTypeID result = (uint16x8_t *)((char *)result + v24);
    uint16x8_t v10 = (uint16x8_t)v27;
    uint16x8_t v9 = (uint16x8_t)v28;
    uint16x8_t v12 = (uint16x8_t)v29;
    uint16x8_t v11 = (uint16x8_t)v30;
  }
  while (v23 > 1);
  return result;
}

int8x16_t *sub_1BBA02B64(int8x16_t *result, uint64_t a2, int8x16_t *a3, int a4, char *a5, uint64_t a6, int a7)
{
  int8x16_t v8 = *a3;
  int8x16_t v9 = vdupq_n_s8(~a4);
  int8x16_t v10 = vandq_s8(v9, (int8x16_t)xmmword_1BBB6F500);
  _X8 = result + 2;
  int v12 = a7 + 1;
  int8x16_t v13 = vceqzq_s8(vandq_s8(v9, (int8x16_t)xmmword_1BBB6F5D0));
  int8x16_t v14 = vceqzq_s8(v10);
  v15.i64[0] = 0x202020202020202;
  v15.i64[1] = 0x202020202020202;
  v16.i64[0] = 0x303030303030303;
  v16.i64[1] = 0x303030303030303;
  uint8x16_t v17 = a5;
  do
  {
    int8x16_t v18 = _X8[-2];
    int8x16_t v19 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    int8x16_t v25 = vld1q_dup_s8(v17++);
    *a5 = v19.i8[15];
    v7.i8[0] = _X8->i8[0];
    uint8x16_t v26 = (uint8x16_t)vextq_s8(v25, v18, 0xFuLL);
    uint8x16_t v27 = (uint8x16_t)vextq_s8(v18, v19, 0xFuLL);
    uint8x16_t v28 = (uint8x16_t)vextq_s8(v18, v19, 1uLL);
    uint8x16_t v29 = (uint8x16_t)vextq_s8(v19, v7, 1uLL);
    int8x16_t v7 = (int8x16_t)vsqaddq_u8((uint8x16_t)v19, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v19, v27), v16, v15), (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v19)), (int8x16_t)vcgtq_u8((uint8x16_t)v19, v29)), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v19))));
    _X8[-2] = vbslq_s8(v14, (int8x16_t)vsqaddq_u8((uint8x16_t)v18, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v18, v28), v16, v15), (int8x16_t)vcgtq_u8(v28, (uint8x16_t)v18)), (int8x16_t)vcgtq_u8((uint8x16_t)v18, v26)), (int8x16_t)vcgtq_u8(v26, (uint8x16_t)v18)))), v18);
    _X8[-1] = vbslq_s8(v13, v7, v19);
    _X8 = (int8x16_t *)((char *)_X8 + a2);
    --v12;
    a5 = (char *)v17;
  }
  while (v12 > 1);
  return result;
}

int16x8_t *sub_1BBA02C44(int16x8_t *result, uint64_t a2, int8x16_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  int8x16_t v8 = *a3;
  int8x16_t v9 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F500);
  _X8 = result + 2;
  int v12 = a7 + 1;
  int8x16_t v13 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F5E0));
  int8x16_t v14 = (int8x16_t)vceqzq_s16(v10);
  v15.i64[0] = 0x202020202020202;
  v15.i64[1] = 0x202020202020202;
  v16.i64[0] = 0xFC00FC00FC00FC00;
  v16.i64[1] = 0xFC00FC00FC00FC00;
  uint8x16_t v17 = a5;
  do
  {
    int16x8_t v18 = _X8[-2];
    int16x8_t v19 = _X8[-1];
    int16x8_t v21 = *_X8;
    int16x8_t v20 = _X8[1];
    __asm { PRFM            #0, [X8,#0x20] }
    int8x16_t v27 = (int8x16_t)vld1q_dup_s16(v17++);
    *a5 = v20.i16[7];
    v7.i16[0] = _X8[2].i16[0];
    uint16x8_t v28 = (uint16x8_t)vextq_s8(v27, (int8x16_t)v18, 0xEuLL);
    uint16x8_t v29 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 0xEuLL);
    uint16x8_t v30 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v21, 0xEuLL);
    uint16x8_t v31 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v20, 0xEuLL);
    uint16x8_t v32 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 2uLL);
    uint16x8_t v33 = (uint16x8_t)vextq_s8((int8x16_t)v19, (int8x16_t)v21, 2uLL);
    uint16x8_t v34 = (uint16x8_t)vextq_s8((int8x16_t)v21, (int8x16_t)v20, 2uLL);
    uint16x8_t v35 = (uint16x8_t)vextq_s8((int8x16_t)v20, v7, 2uLL);
    int8x16_t v36 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v32, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v32)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v28)), (int16x8_t)vcgtq_u16(v28, (uint16x8_t)v18))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v29, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v29)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v33)), (int16x8_t)vcgtq_u16(v33, (uint16x8_t)v19))), v15));
    int8x16_t v37 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v30, (uint16x8_t)v21), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v30)), (int16x8_t)vcgtq_u16((uint16x8_t)v21, v34)), (int16x8_t)vcgtq_u16(v34, (uint16x8_t)v21))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v31, (uint16x8_t)v20), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v31)), (int16x8_t)vcgtq_u16((uint16x8_t)v20, v35)), (int16x8_t)vcgtq_u16(v35, (uint16x8_t)v20))), v15));
    int16x8_t v38 = vaddw_s8(v21, *(int8x8_t *)v37.i8);
    int8x16_t v7 = (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v20, v37), (int16x8_t)0), v16);
    _X8[-2] = (int16x8_t)vbslq_s8(v14, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v36.i8), (int16x8_t)0), v16), (int8x16_t)v18);
    _X8[-1] = vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v36), (int16x8_t)0), v16);
    *_X8 = vminq_s16(vmaxq_s16(v38, (int16x8_t)0), v16);
    _X8[1] = (int16x8_t)vbslq_s8(v13, v7, (int8x16_t)v20);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v12;
    a5 = (__int16 *)v17;
  }
  while (v12 > 1);
  return result;
}

uint8x16_t *sub_1BBA02DAC(uint8x16_t *result, uint64_t a2, long long *a3, uint64_t a4, unsigned char *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  int v9 = a7 + 1;
  do
  {
    uint8x16_t v10 = *result;
    __asm { PRFM            #0, [X0,#0x10] }
    *a5++ = HIBYTE(*(unsigned long long *)result);
    *CFTypeID result = vsqaddq_u8(v10, vqtbl2q_s8(*(int8x16x2_t *)&v7, (int8x16_t)vshrq_n_u8(v10, 3uLL)));
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
    --v9;
  }
  while (v9 > 1);
  return result;
}

int16x8_t *sub_1BBA02DE4(int16x8_t *result, uint64_t a2, long long *a3, uint64_t a4, _WORD *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  _X8 = result + 1;
  int v10 = a7 + 1;
  v11.i64[0] = 0xFC00FC00FC00FC00;
  v11.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v12 = _X8[-1];
    int16x8_t v13 = *_X8;
    __asm { PRFM            #0, [X8,#0x10] }
    *a5++ = HIWORD(*(unsigned long long *)_X8);
    int8x16_t v19 = vqtbl2q_s8(*(int8x16x2_t *)&v7, vshrn_high_n_s16(vshrn_n_s16(v12, 5uLL), v13, 5uLL));
    _X8[-1] = vminq_s16(vmaxq_s16(vaddw_s8(v12, *(int8x8_t *)v19.i8), (int16x8_t)0), v11);
    *_X8 = vminq_s16(vmaxq_s16(vaddw_high_s8(v13, v19), (int16x8_t)0), v11);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v10;
  }
  while (v10 > 1);
  return result;
}

int8x16_t *sub_1BBA02E44(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, unsigned char *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((~a4 & 9) == 0) {
    a5[a7] = result->i8[a7 * a2 - 1];
  }
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i8[15];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
  }
  int8x16_t v8 = *_X5;
  i8 = _X5[1].i8;
  __asm { PRFM            #0, [X5,#0x10] }
  _X10 = result + 1;
  int8x16_t v16 = *result;
  __asm { PRFM            #0, [X10] }
  int8x16_t v18 = vld1q_dup_s8(i8);
  *a5 = HIBYTE(*(unsigned long long *)result);
  int8x16_t v19 = a5 + 1;
  int v20 = a7 + ((a4 >> 3) & 1);
  int8x16_t v21 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1BBB6F5F0));
  v22.i64[0] = 0x202020202020202;
  v22.i64[1] = 0x202020202020202;
  v23.i64[0] = 0x303030303030303;
  v23.i64[1] = 0x303030303030303;
  uint64_t v24 = v19;
  do
  {
    _X11 = (uint64_t)result[1].i64 + a2;
    int8x16_t v26 = *(int8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X11] }
    int8x16_t v28 = vld1q_dup_s8(v24++);
    *int8x16_t v19 = v26.i8[15];
    uint8x16_t v29 = (uint8x16_t)vextq_s8(v8, v18, 1uLL);
    uint8x16_t v30 = (uint8x16_t)vextq_s8(v28, v26, 0xFuLL);
    *CFTypeID result = vbslq_s8(v21, (int8x16_t)vsqaddq_u8((uint8x16_t)v16, vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v16, v29), v23, v22), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v16)), (int8x16_t)vcgtq_u8((uint8x16_t)v16, v30)), (int8x16_t)vcgtq_u8(v30, (uint8x16_t)v16)))), v16);
    uint16x8_t v31 = result[1].i8;
    --v20;
    int8x16_t v19 = (char *)v24;
    int8x16_t v18 = vld1q_dup_s8(v31);
    int8x16_t v8 = v16;
    int8x16_t v16 = v26;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
  }
  while (v20 > 1);
  return result;
}

int8x16_t *sub_1BBA02F48(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((~a4 & 9) == 0) {
    a5[a7] = result->i16[a7 * a2 - 1];
  }
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i16[7];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + 2 * a2);
    --a7;
  }
  int8x16_t v8 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v9 = (int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1BBB6F500);
  int8x16_t v11 = *_X5;
  int8x16_t v10 = _X5[1];
  i16 = _X5[2].i16;
  __asm { PRFM            #0, [X5,#0x20] }
  int8x16_t v18 = *result;
  int8x16_t v19 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  int8x16_t v21 = (int8x16_t)vld1q_dup_s16(i16);
  *a5 = v19.i16[7];
  int8x16_t v22 = a5 + 1;
  uint64_t v23 = 2 * a2;
  int v24 = a7 + ((a4 >> 3) & 1);
  int8x16_t v25 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v8, (int8x16_t)xmmword_1BBB6F5E0));
  int8x16_t v26 = (int8x16_t)vceqzq_s16(v9);
  v27.i64[0] = 0x202020202020202;
  v27.i64[1] = 0x202020202020202;
  v28.i64[0] = 0xFC00FC00FC00FC00;
  v28.i64[1] = 0xFC00FC00FC00FC00;
  uint8x16_t v29 = v22;
  do
  {
    uint16x8_t v30 = (uint16x8_t)vextq_s8(v11, v10, 2uLL);
    int16x8_t v31 = (int16x8_t)v19;
    int16x8_t v32 = (int16x8_t)v18;
    _X11 = (uint64_t)result->i64 + v23;
    int8x16_t v18 = *(int8x16_t *)((char *)result + 2 * a2);
    int8x16_t v19 = *(int8x16_t *)((char *)&result[1] + v23);
    __asm { PRFM            #0, [X11,#0x20] }
    int8x16_t v35 = (int8x16_t)vld1q_dup_s16(v29++);
    uint16x8_t v36 = (uint16x8_t)vextq_s8(v10, v21, 2uLL);
    *int8x16_t v22 = v19.i16[7];
    uint16x8_t v37 = (uint16x8_t)vextq_s8(v35, v18, 0xEuLL);
    uint16x8_t v38 = (uint16x8_t)vextq_s8(v18, v19, 0xEuLL);
    int8x16_t v39 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v30, (uint16x8_t)v32), (int16x8_t)vcgtq_u16((uint16x8_t)v32, v30)), (int16x8_t)vcgtq_u16((uint16x8_t)v32, v37)), (int16x8_t)vcgtq_u16(v37, (uint16x8_t)v32))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v36, (uint16x8_t)v31), (int16x8_t)vcgtq_u16((uint16x8_t)v31, v36)), (int16x8_t)vcgtq_u16((uint16x8_t)v31, v38)), (int16x8_t)vcgtq_u16(v38, (uint16x8_t)v31))), v27));
    *CFTypeID result = vbslq_s8(v26, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v32, *(int8x8_t *)v39.i8), (int16x8_t)0), v28), (int8x16_t)v32);
    result[1] = vbslq_s8(v25, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v31, v39), (int16x8_t)0), v28), (int8x16_t)v31);
    uint16x8_t v40 = result[2].i16;
    --v24;
    CFTypeID result = (int8x16_t *)((char *)result + v23);
    int8x16_t v21 = (int8x16_t)vld1q_dup_s16(v40);
    int8x16_t v22 = (__int16 *)v29;
    int8x16_t v11 = (int8x16_t)v32;
    int8x16_t v10 = (int8x16_t)v31;
  }
  while (v24 > 1);
  return result;
}

int8x16_t *sub_1BBA030A4(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, char *a5, int8x16_t *a6, int a7)
{
  int8x16_t v8 = *a3;
  if ((a4 & 4) != 0)
  {
    int8x16_t v11 = &a6[-1].i8[15];
    int8x16_t v10 = vld1q_dup_s8(v11);
  }
  else
  {
    int16x8_t v9 = a5;
    int8x16_t v10 = vld1q_dup_s8(v9++);
    *a5 = result->i8[15];
    a6 = result;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
    --a7;
    a5 = (char *)v9;
  }
  int v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = result->i8[(v12 + 1) * a2 + 15];
  int8x16_t v14 = *a6;
  _X5 = a6 + 1;
  int8x16_t v15 = v14;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  int8x16_t v22 = *result;
  __asm { PRFM            #0, [X9] }
  int v24 = v12 + 2;
  int8x16_t v25 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1BBB6F5F0));
  v26.i64[0] = 0x202020202020202;
  v26.i64[1] = 0x202020202020202;
  v27.i64[0] = 0x303030303030303;
  v27.i64[1] = 0x303030303030303;
  int16x8_t v28 = a5;
  do
  {
    _X10 = (uint64_t)result->i64 + a2;
    int8x16_t v30 = *(int8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10,#0x10] }
    v7.i8[0] = result[1].i8[a2];
    uint8x16_t v32 = (uint8x16_t)vextq_s8(v10, v15, 0xFuLL);
    uint8x16_t v33 = (uint8x16_t)vextq_s8(v30, v7, 1uLL);
    int8x16_t v7 = vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v22, v32), v27, v26);
    *CFTypeID result = vbslq_s8(v25, (int8x16_t)vsqaddq_u8((uint8x16_t)v22, vqtbl1q_s8(v8, vaddq_s8(vsubq_s8(vaddq_s8(v7, (int8x16_t)vcgtq_u8(v32, (uint8x16_t)v22)), (int8x16_t)vcgtq_u8((uint8x16_t)v22, v33)), (int8x16_t)vcgtq_u8(v33, (uint8x16_t)v22)))), v22);
    int8x16_t v10 = vld1q_dup_s8(v28++);
    --v24;
    int8x16_t v15 = v22;
    *a5 = v22.i8[15];
    int8x16_t v22 = v30;
    a5 = (char *)v28;
    CFTypeID result = (int8x16_t *)((char *)result + a2);
  }
  while (v24 > 1);
  return result;
}

uint64_t sub_1BBA031AC(uint64_t result, uint64_t a2, int8x16_t *a3, unsigned int a4, __int16 *a5, _OWORD *_X5, int a7)
{
  int8x16_t v8 = *a3;
  if ((a4 & 4) != 0)
  {
    int8x16_t v11 = (const __int16 *)_X5 - 1;
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v11);
  }
  else
  {
    int16x8_t v9 = a5;
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v9++);
    *a5 = *(_WORD *)(result + 30);
    _X5 = (_OWORD *)result;
    result += 2 * a2;
    --a7;
    a5 = (__int16 *)v9;
  }
  int v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = *(_WORD *)(result + 2 * (v12 + 1) * a2 + 30);
  int8x16_t v13 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v14 = (int16x8_t)vandq_s8(v13, (int8x16_t)xmmword_1BBB6F500);
  int16x8_t v15 = (int16x8_t)vandq_s8(v13, (int8x16_t)xmmword_1BBB6F5E0);
  int16x8_t v16 = *(int16x8_t *)_X5;
  int8x16_t v17 = *((int8x16_t *)_X5 + 1);
  __asm { PRFM            #0, [X5,#0x20] }
  int8x16_t v23 = *(int8x16_t *)result;
  int8x16_t v24 = *(int8x16_t *)(result + 16);
  __asm { PRFM            #0, [X0,#0x20] }
  uint64_t v26 = 2 * a2;
  int v27 = v12 + 2;
  int8x16_t v28 = (int8x16_t)vceqzq_s16(v15);
  int8x16_t v29 = (int8x16_t)vceqzq_s16(v14);
  v30.i64[0] = 0x202020202020202;
  v30.i64[1] = 0x202020202020202;
  v31.i64[0] = 0xFC00FC00FC00FC00;
  v31.i64[1] = 0xFC00FC00FC00FC00;
  uint8x16_t v32 = a5;
  do
  {
    uint16x8_t v33 = (uint16x8_t)vextq_s8((int8x16_t)v16, v17, 0xEuLL);
    int16x8_t v34 = (int16x8_t)v24;
    uint16x8_t v35 = (uint16x8_t)vextq_s8(v10, (int8x16_t)v16, 0xEuLL);
    int16x8_t v16 = (int16x8_t)v23;
    _X11 = result + v26;
    int8x16_t v23 = *(int8x16_t *)(result + 2 * a2);
    int8x16_t v24 = *(int8x16_t *)(result + v26 + 16);
    __asm { PRFM            #0, [X11,#0x20] }
    v7.i16[0] = *(_WORD *)(result + v26 + 32);
    uint16x8_t v38 = (uint16x8_t)vextq_s8(v23, v24, 2uLL);
    uint16x8_t v39 = (uint16x8_t)vextq_s8(v24, (int8x16_t)v7, 2uLL);
    int16x8_t v40 = (int16x8_t)vcgtq_u16((uint16x8_t)v34, v39);
    int16x8_t v7 = (int16x8_t)vcgtq_u16(v39, (uint16x8_t)v34);
    int8x16_t v41 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v35, (uint16x8_t)v16), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v35)), (int16x8_t)vcgtq_u16((uint16x8_t)v16, v38)), (int16x8_t)vcgtq_u16(v38, (uint16x8_t)v16))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v33, (uint16x8_t)v34), (int16x8_t)vcgtq_u16((uint16x8_t)v34, v33)), v40), v7)), v30));
    *(int8x16_t *)CFTypeID result = vbslq_s8(v29, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v16, *(int8x8_t *)v41.i8), (int16x8_t)0), v31), (int8x16_t)v16);
    *(int8x16_t *)(result + 16) = vbslq_s8(v28, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v34, v41), (int16x8_t)0), v31), (int8x16_t)v34);
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v32++);
    --v27;
    result += v26;
    *a5 = v34.i16[7];
    int8x16_t v17 = (int8x16_t)v34;
    a5 = (__int16 *)v32;
  }
  while (v27 > 1);
  return result;
}

uint8x16_t *sub_1BBA0330C(uint8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, unsigned char *a5, uint8x16_t *a6, int a7)
{
  int8x16_t v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i8[15];
    a6 = result;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
    --a7;
  }
  int v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result->i8[(v8 + 1) * a2 + 15];
  uint8x16_t v10 = *a6;
  _X5 = a6 + 1;
  uint8x16_t v11 = v10;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  uint8x16_t v18 = *result;
  __asm { PRFM            #0, [X9] }
  int v20 = v8 + 2;
  v21.i64[0] = 0x202020202020202;
  v21.i64[1] = 0x202020202020202;
  v22.i64[0] = 0x303030303030303;
  v22.i64[1] = 0x303030303030303;
  do
  {
    _X10 = (uint64_t)result[1].i64 + a2;
    uint8x16_t v24 = *(uint8x16_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10] }
    *a5++ = v18.i8[15];
    int8x16_t v26 = vqtbl1q_s8(v7, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8(v18, v11), v22, v21), (int8x16_t)vcgtq_u8(v11, v18)), (int8x16_t)vcgtq_u8(v18, v24)), (int8x16_t)vcgtq_u8(v24, v18)));
    uint8x16_t v11 = v18;
    *CFTypeID result = vsqaddq_u8(v18, v26);
    --v20;
    uint8x16_t v18 = v24;
    CFTypeID result = (uint8x16_t *)((char *)result + a2);
  }
  while (v20 > 1);
  return result;
}

uint16x8_t *sub_1BBA033C4(uint16x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, uint16x8_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result[1].i16[7];
    _X5 = result;
    CFTypeID result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  int v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result[1].i16[(v8 + 1) * a2 + 7];
  uint16x8_t v10 = *_X5;
  uint16x8_t v9 = _X5[1];
  __asm { PRFM            #0, [X5,#0x20] }
  uint16x8_t v16 = *result;
  uint16x8_t v17 = result[1];
  __asm { PRFM            #0, [X0,#0x20] }
  uint64_t v19 = 2 * a2;
  int v20 = v8 + 2;
  v21.i64[0] = 0x202020202020202;
  v21.i64[1] = 0x202020202020202;
  v22.i64[0] = 0xFC00FC00FC00FC00;
  v22.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v23 = (int16x8_t)v16;
    int16x8_t v24 = (int16x8_t)v17;
    _X10 = (uint64_t)result->i64 + v19;
    uint16x8_t v16 = *(uint16x8_t *)((char *)result + 2 * a2);
    uint16x8_t v17 = *(uint16x8_t *)((char *)&result[1] + v19);
    __asm { PRFM            #0, [X10,#0x20] }
    *a5++ = v24.i16[7];
    int8x16_t v27 = vqtbl1q_s8(v7, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v10, (uint16x8_t)v23), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v10)), (int16x8_t)vcgtq_u16((uint16x8_t)v23, v16)), (int16x8_t)vcgtq_u16(v16, (uint16x8_t)v23))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v9, (uint16x8_t)v24), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v9)), (int16x8_t)vcgtq_u16((uint16x8_t)v24, v17)), (int16x8_t)vcgtq_u16(v17, (uint16x8_t)v24))), v21));
    --v20;
    *(int16x8_t *)CFTypeID result = vminq_s16(vmaxq_s16(vaddw_s8(v23, *(int8x8_t *)v27.i8), (int16x8_t)0), v22);
    result[1] = (uint16x8_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v24, v27), (int16x8_t)0), v22);
    CFTypeID result = (uint16x8_t *)((char *)result + v19);
    uint16x8_t v10 = (uint16x8_t)v23;
    uint16x8_t v9 = (uint16x8_t)v24;
  }
  while (v20 > 1);
  return result;
}

uint64_t sub_1BBA034C0(uint64_t result, uint64_t a2, int8x16_t *a3, int a4, char *a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x16_t a12, uint64_t a13, int a14)
{
  int8x16_t v14 = *a3;
  _X8 = (unsigned __int8 *)(result + 16);
  int v16 = a14 + 1;
  int8x16_t v17 = vceqzq_s8(vandq_s8(vdupq_n_s8(~a4), (int8x16_t)xmmword_1BBB6F5F0));
  v18.i64[0] = 0x202020202020202;
  v18.i64[1] = 0x202020202020202;
  v19.i64[0] = 0x303030303030303;
  v19.i64[1] = 0x303030303030303;
  int v20 = a5;
  do
  {
    int8x16_t v21 = *((int8x16_t *)_X8 - 1);
    __asm { PRFM            #0, [X8] }
    int8x16_t v27 = vld1q_dup_s8(v20++);
    uint8x16_t v28 = (uint8x16_t)vextq_s8(v27, v21, 0xFuLL);
    *a5 = v21.i8[15];
    a12.i8[0] = *_X8;
    uint8x16_t v29 = (uint8x16_t)vextq_s8(v21, a12, 1uLL);
    a12 = (int8x16_t)vsqaddq_u8((uint8x16_t)v21, vqtbl1q_s8(v14, vaddq_s8(vsubq_s8(vaddq_s8(vbslq_s8((int8x16_t)vcgtq_u8((uint8x16_t)v21, v28), v19, v18), (int8x16_t)vcgtq_u8(v28, (uint8x16_t)v21)), (int8x16_t)vcgtq_u8((uint8x16_t)v21, v29)), (int8x16_t)vcgtq_u8(v29, (uint8x16_t)v21))));
    *((int8x16_t *)_X8 - 1) = vbslq_s8(v17, a12, v21);
    _X8 += a2;
    --v16;
    a5 = (char *)v20;
  }
  while (v16 > 1);
  return result;
}

int16x8_t *sub_1BBA03558(int16x8_t *result, uint64_t a2, int8x16_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  int8x16_t v8 = *a3;
  int8x16_t v9 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v10 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F500);
  _X8 = result + 2;
  int v12 = a7 + 1;
  int8x16_t v13 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F5E0));
  int8x16_t v14 = (int8x16_t)vceqzq_s16(v10);
  v15.i64[0] = 0x202020202020202;
  v15.i64[1] = 0x202020202020202;
  v16.i64[0] = 0xFC00FC00FC00FC00;
  v16.i64[1] = 0xFC00FC00FC00FC00;
  int8x16_t v17 = a5;
  do
  {
    int16x8_t v18 = _X8[-2];
    int16x8_t v19 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    int8x16_t v25 = (int8x16_t)vld1q_dup_s16(v17++);
    *a5 = v19.i16[7];
    v7.i16[0] = _X8->i16[0];
    uint16x8_t v26 = (uint16x8_t)vextq_s8(v25, (int8x16_t)v18, 0xEuLL);
    uint16x8_t v27 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 0xEuLL);
    uint16x8_t v28 = (uint16x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 2uLL);
    uint16x8_t v29 = (uint16x8_t)vextq_s8((int8x16_t)v19, v7, 2uLL);
    int8x16_t v30 = vqtbl1q_s8(v8, vaddq_s8(vqmovn_high_s16(vqmovn_s16(vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v28, (uint16x8_t)v18), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v28)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v26)), (int16x8_t)vcgtq_u16(v26, (uint16x8_t)v18))), vaddq_s16(vsubq_s16(vsubq_s16((int16x8_t)vcgtq_u16(v27, (uint16x8_t)v19), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v27)), (int16x8_t)vcgtq_u16((uint16x8_t)v19, v29)), (int16x8_t)vcgtq_u16(v29, (uint16x8_t)v19))), v15));
    int8x16_t v7 = (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v18, *(int8x8_t *)v30.i8), (int16x8_t)0), v16);
    _X8[-2] = (int16x8_t)vbslq_s8(v14, v7, (int8x16_t)v18);
    _X8[-1] = (int16x8_t)vbslq_s8(v13, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_high_s8(v19, v30), (int16x8_t)0), v16), (int8x16_t)v19);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v12;
    a5 = (__int16 *)v17;
  }
  while (v12 > 1);
  return result;
}

uint8x8_t *sub_1BBA03648(uint8x8_t *result, uint64_t a2, long long *a3, uint64_t a4, unsigned char *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  int v9 = a7 + 1;
  do
  {
    uint8x8_t v10 = *result;
    __asm { PRFM            #0, [X0,#8] }
    *a5++ = HIBYTE(*(unint64_t *)result);
    *CFTypeID result = vsqadd_u8(v10, vqtbl2_s8(*(int8x16x2_t *)&v7, (int8x8_t)vshr_n_u8(v10, 3uLL)));
    CFTypeID result = (uint8x8_t *)((char *)result + a2);
    --v9;
  }
  while (v9 > 1);
  return result;
}

int16x8_t *sub_1BBA03680(int16x8_t *result, uint64_t a2, long long *a3, uint64_t a4, _WORD *a5, uint64_t a6, int a7)
{
  long long v7 = *a3;
  long long v8 = a3[1];
  int v9 = a7 + 1;
  v10.i64[0] = 0xFC00FC00FC00FC00;
  v10.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v11 = *result;
    __asm { PRFM            #0, [X0,#0x10] }
    *a5++ = HIWORD(*(unsigned long long *)result);
    *CFTypeID result = vminq_s16(vmaxq_s16(vaddw_s8(v11, vqtbl2_s8(*(int8x16x2_t *)&v7, vshrn_n_s16(v11, 5uLL))), (int16x8_t)0), v10);
    CFTypeID result = (int16x8_t *)((char *)result + 2 * a2);
    --v9;
  }
  while (v9 > 1);
  return result;
}

int8x8_t *sub_1BBA036CC(int8x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, unsigned char *a5, int8x8_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((~a4 & 9) == 0) {
    a5[a7] = result->i8[a7 * a2 - 1];
  }
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i8[7];
    _X5 = result;
    CFTypeID result = (int8x8_t *)((char *)result + a2);
    --a7;
  }
  int8x8_t v8 = *_X5;
  int v9 = (const char *)&_X5[1];
  __asm { PRFM            #0, [X5,#8] }
  _X10 = result + 1;
  int8x8_t v16 = *result;
  __asm { PRFM            #0, [X10] }
  int8x8_t v18 = (int8x8_t)vld1q_dup_s8(v9).u64[0];
  *a5 = HIBYTE(*(unint64_t *)result);
  int16x8_t v19 = a5 + 1;
  int v20 = a7 + ((a4 >> 3) & 1);
  int8x8_t v21 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x200000000000001));
  int16x8_t v22 = v19;
  do
  {
    _X11 = (uint64_t)&result[1] + a2;
    int8x8_t v24 = *(int8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X11] }
    int8x8_t v26 = vld1_dup_s8(v22++);
    *int16x8_t v19 = v24.i8[7];
    uint8x8_t v27 = (uint8x8_t)vext_s8(v8, v18, 1uLL);
    uint8x8_t v28 = (uint8x8_t)vext_s8(v26, v24, 7uLL);
    *CFTypeID result = vbsl_s8(v21, (int8x8_t)vsqadd_u8((uint8x8_t)v16, vqtbl1_s8(v7, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v16, v27), (int8x8_t)0x303030303030303, (int8x8_t)0x202020202020202), (int8x8_t)vcgt_u8(v27, (uint8x8_t)v16)), (int8x8_t)vcgt_u8((uint8x8_t)v16, v28)), (int8x8_t)vcgt_u8(v28, (uint8x8_t)v16)))), v16);
    uint16x8_t v29 = (const char *)&result[1];
    --v20;
    int16x8_t v19 = (char *)v22;
    int8x8_t v18 = (int8x8_t)vld1q_dup_s8(v29).u64[0];
    int8x8_t v8 = v16;
    int8x8_t v16 = v24;
    CFTypeID result = (int8x8_t *)((char *)result + a2);
  }
  while (v20 > 1);
  return result;
}

int8x16_t *sub_1BBA037D0(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, int8x16_t *_X5, int a7)
{
  int8x16_t v7 = *a3;
  if ((~a4 & 9) == 0) {
    a5[a7] = result->i16[a7 * a2 - 1];
  }
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[7];
    _X5 = result;
    CFTypeID result = (int8x16_t *)((char *)result + 2 * a2);
    --a7;
  }
  int8x16_t v8 = *_X5;
  __asm { PRFM            #0, [X5,#0x10] }
  _X8 = result + 1;
  int16x8_t v15 = *(int16x8_t *)result;
  __asm { PRFM            #0, [X8] }
  i16 = _X5[1].i16;
  int8x16_t v18 = (int8x16_t)vld1q_dup_s16(i16);
  *a5 = HIWORD(*(unsigned long long *)result);
  int16x8_t v19 = a5 + 1;
  v7.i64[1] = 0;
  uint64_t v20 = 2 * a2;
  int v21 = a7 + ((a4 >> 3) & 1);
  int8x16_t v22 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_n_s16(~a4), (int8x16_t)xmmword_1BBB6F600));
  v23.i64[0] = 0x2000200020002;
  v23.i64[1] = 0x2000200020002;
  v24.i64[0] = 0x3000300030003;
  v24.i64[1] = 0x3000300030003;
  v25.i64[0] = 0xFC00FC00FC00FC00;
  v25.i64[1] = 0xFC00FC00FC00FC00;
  int8x8_t v26 = v19;
  do
  {
    _X12 = (uint64_t)result[1].i64 + v20;
    int8x16_t v28 = *(int8x16_t *)((char *)result + 2 * a2);
    __asm { PRFM            #0, [X12] }
    int8x16_t v30 = (int8x16_t)vld1q_dup_s16(v26++);
    *int16x8_t v19 = v28.i16[7];
    uint16x8_t v31 = (uint16x8_t)vextq_s8(v8, v18, 2uLL);
    uint16x8_t v32 = (uint16x8_t)vextq_s8(v30, v28, 0xEuLL);
    *CFTypeID result = vbslq_s8(v22, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v15, vqtbl1_s8(v7, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v15, v31), v24, v23), (int16x8_t)vcgtq_u16(v31, (uint16x8_t)v15)), (int16x8_t)vcgtq_u16((uint16x8_t)v15, v32)), (int16x8_t)vcgtq_u16(v32, (uint16x8_t)v15))))),
                               (int16x8_t)0),
                             v25),
                (int8x16_t)v15);
    uint16x8_t v33 = result[1].i16;
    --v21;
    CFTypeID result = (int8x16_t *)((char *)result + v20);
    int8x16_t v18 = (int8x16_t)vld1q_dup_s16(v33);
    int16x8_t v19 = (__int16 *)v26;
    int8x16_t v8 = (int8x16_t)v15;
    int16x8_t v15 = (int16x8_t)v28;
  }
  while (v21 > 1);
  return result;
}

int8x8_t *sub_1BBA038EC(int8x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, char *a5, int8x8_t *a6, int a7)
{
  int8x16_t v8 = *a3;
  if ((a4 & 4) != 0)
  {
    int16x8_t v11 = (char *)&a6[-1] + 7;
    int8x8_t v10 = (int8x8_t)vld1q_dup_s8(v11).u64[0];
  }
  else
  {
    int v9 = a5;
    int8x8_t v10 = (int8x8_t)vld1q_dup_s8(v9++).u64[0];
    *a5 = result->i8[7];
    a6 = result;
    CFTypeID result = (int8x8_t *)((char *)result + a2);
    --a7;
    a5 = (char *)v9;
  }
  int v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = result->i8[(v12 + 1) * a2 + 7];
  int8x8_t v14 = *a6;
  _X5 = a6 + 1;
  int8x8_t v15 = v14;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  int8x8_t v22 = *result;
  __asm { PRFM            #0, [X9] }
  int v24 = v12 + 2;
  int8x8_t v25 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x200000000000001));
  int8x8_t v26 = a5;
  do
  {
    _X10 = (char *)result + a2;
    int8x8_t v28 = *(int8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10,#8] }
    v7.i8[0] = result[1].i8[a2];
    uint8x8_t v30 = (uint8x8_t)vext_s8(v10, v15, 7uLL);
    uint8x8_t v31 = (uint8x8_t)vext_s8(v28, v7, 1uLL);
    int8x8_t v7 = vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v22, v30), (int8x8_t)0x303030303030303, (int8x8_t)0x202020202020202);
    *CFTypeID result = vbsl_s8(v25, (int8x8_t)vsqadd_u8((uint8x8_t)v22, vqtbl1_s8(v8, vadd_s8(vsub_s8(vadd_s8(v7, (int8x8_t)vcgt_u8(v30, (uint8x8_t)v22)), (int8x8_t)vcgt_u8((uint8x8_t)v22, v31)), (int8x8_t)vcgt_u8(v31, (uint8x8_t)v22)))), v22);
    int8x8_t v10 = (int8x8_t)vld1q_dup_s8(v26++).u64[0];
    --v24;
    int8x8_t v15 = v22;
    *a5 = v22.i8[7];
    int8x8_t v22 = v28;
    a5 = (char *)v26;
    CFTypeID result = (int8x8_t *)((char *)result + a2);
  }
  while (v24 > 1);
  return result;
}

int8x16_t *sub_1BBA039F4(int8x16_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, __int16 *a5, int8x16_t *a6, int a7)
{
  int8x16_t v8 = *a3;
  if ((a4 & 4) != 0)
  {
    int16x8_t v11 = &a6[-1].i16[7];
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v11);
  }
  else
  {
    int v9 = a5;
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v9++);
    *a5 = result->i16[7];
    a6 = result;
    CFTypeID result = (int8x16_t *)((char *)result + 2 * a2);
    --a7;
    a5 = (__int16 *)v9;
  }
  int v12 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v12 + 1] = result->i16[(v12 + 1) * a2 + 7];
  int8x16_t v14 = *a6;
  _X5 = a6 + 1;
  int8x16_t v15 = v14;
  __asm { PRFM            #0, [X5] }
  _X8 = result + 1;
  int16x8_t v22 = *(int16x8_t *)result;
  __asm { PRFM            #0, [X8] }
  v8.i64[1] = 0;
  uint64_t v24 = 2 * a2;
  int v25 = v12 + 2;
  int8x16_t v26 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)vdupq_n_s16(~a4), (int8x16_t)xmmword_1BBB6F600));
  v27.i64[0] = 0x2000200020002;
  v27.i64[1] = 0x2000200020002;
  v28.i64[0] = 0x3000300030003;
  v28.i64[1] = 0x3000300030003;
  v29.i64[0] = 0xFC00FC00FC00FC00;
  v29.i64[1] = 0xFC00FC00FC00FC00;
  uint8x8_t v30 = a5;
  do
  {
    _X11 = (uint64_t)result->i64 + v24;
    int8x16_t v32 = *(int8x16_t *)((char *)result + 2 * a2);
    __asm { PRFM            #0, [X11,#0x10] }
    v7.i16[0] = result[1].i16[(unint64_t)v24 / 2];
    uint16x8_t v34 = (uint16x8_t)vextq_s8(v10, v15, 0xEuLL);
    uint16x8_t v35 = (uint16x8_t)vextq_s8(v32, (int8x16_t)v7, 2uLL);
    int16x8_t v7 = (int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v22, v34), v28, v27);
    *CFTypeID result = vbslq_s8(v26, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v22, vqtbl1_s8(v8, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16(v7, (int16x8_t)vcgtq_u16(v34, (uint16x8_t)v22)), (int16x8_t)vcgtq_u16((uint16x8_t)v22, v35)), (int16x8_t)vcgtq_u16(v35, (uint16x8_t)v22))))), (int16x8_t)0), v29), (int8x16_t)v22);
    int8x16_t v10 = (int8x16_t)vld1q_dup_s16(v30++);
    --v25;
    CFTypeID result = (int8x16_t *)((char *)result + v24);
    *a5 = v22.i16[7];
    int8x16_t v15 = (int8x16_t)v22;
    int16x8_t v22 = (int16x8_t)v32;
    a5 = (__int16 *)v30;
  }
  while (v25 > 1);
  return result;
}

uint8x8_t *sub_1BBA03B14(uint8x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, unsigned char *a5, uint8x8_t *a6, int a7)
{
  int8x16_t v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i8[7];
    a6 = result;
    CFTypeID result = (uint8x8_t *)((char *)result + a2);
    --a7;
  }
  int v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result->i8[(v8 + 1) * a2 + 7];
  uint8x8_t v10 = *a6;
  _X5 = a6 + 1;
  uint8x8_t v11 = v10;
  __asm { PRFM            #0, [X5] }
  _X9 = result + 1;
  uint8x8_t v18 = *result;
  __asm { PRFM            #0, [X9] }
  int v20 = v8 + 2;
  do
  {
    _X10 = (uint64_t)&result[1] + a2;
    uint8x8_t v22 = *(uint8x8_t *)((char *)result + a2);
    __asm { PRFM            #0, [X10] }
    *a5++ = v18.i8[7];
    int8x8_t v24 = vqtbl1_s8(v7, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8(v18, v11), (int8x8_t)0x303030303030303, (int8x8_t)0x202020202020202), (int8x8_t)vcgt_u8(v11, v18)), (int8x8_t)vcgt_u8(v18, v22)), (int8x8_t)vcgt_u8(v22, v18)));
    uint8x8_t v11 = v18;
    *CFTypeID result = vsqadd_u8(v18, v24);
    --v20;
    uint8x8_t v18 = v22;
    CFTypeID result = (uint8x8_t *)((char *)result + a2);
  }
  while (v20 > 1);
  return result;
}

uint16x8_t *sub_1BBA03BCC(uint16x8_t *result, uint64_t a2, int8x16_t *a3, unsigned int a4, _WORD *a5, uint16x8_t *a6, int a7)
{
  int8x16_t v7 = *a3;
  if ((a4 & 4) == 0)
  {
    *a5++ = result->i16[7];
    a6 = result;
    CFTypeID result = (uint16x8_t *)((char *)result + 2 * a2);
    --a7;
  }
  int v8 = a7 + ((a4 >> 3) | 0xFFFFFFFE);
  a5[v8 + 1] = result->i16[(v8 + 1) * a2 + 7];
  uint16x8_t v10 = *a6;
  _X5 = a6 + 1;
  uint16x8_t v11 = v10;
  __asm { PRFM            #0, [X5] }
  _X8 = result + 1;
  int16x8_t v18 = *(int16x8_t *)result;
  v7.i64[1] = 0;
  __asm { PRFM            #0, [X8] }
  uint64_t v20 = 2 * a2;
  int v21 = v8 + 2;
  v22.i64[0] = 0x2000200020002;
  v22.i64[1] = 0x2000200020002;
  v23.i64[0] = 0x3000300030003;
  v23.i64[1] = 0x3000300030003;
  v24.i64[0] = 0xFC00FC00FC00FC00;
  v24.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    _X11 = (uint64_t)result[1].i64 + v20;
    uint16x8_t v26 = *(uint16x8_t *)((char *)result + 2 * a2);
    __asm { PRFM            #0, [X11] }
    *a5++ = v18.i16[7];
    --v21;
    *(int16x8_t *)CFTypeID result = vminq_s16(vmaxq_s16(vaddw_s8(v18, vqtbl1_s8(v7, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v18, v11), v23, v22), (int16x8_t)vcgtq_u16(v11, (uint16x8_t)v18)), (int16x8_t)vcgtq_u16((uint16x8_t)v18, v26)), (int16x8_t)vcgtq_u16(v26, (uint16x8_t)v18))))), (int16x8_t)0), v24);
    CFTypeID result = (uint16x8_t *)((char *)result + v20);
    uint16x8_t v11 = (uint16x8_t)v18;
    int16x8_t v18 = (int16x8_t)v26;
  }
  while (v21 > 1);
  return result;
}

int8x8_t *sub_1BBA03CA4(int8x8_t *result, uint64_t a2, int8x16_t *a3, int a4, char *a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x8_t a12, uint64_t a13, int a14)
{
  int8x16_t v14 = *a3;
  _X8 = result + 1;
  int v16 = a14 + 1;
  int8x8_t v17 = vceqz_s8(vand_s8(vdup_n_s8(~a4), (int8x8_t)0x200000000000001));
  int16x8_t v18 = a5;
  do
  {
    int8x8_t v19 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    int8x8_t v25 = vld1_dup_s8(v18++);
    uint8x8_t v26 = (uint8x8_t)vext_s8(v25, v19, 7uLL);
    *a5 = v19.i8[7];
    a12.i8[0] = _X8->i8[0];
    uint8x8_t v27 = (uint8x8_t)vext_s8(v19, a12, 1uLL);
    a12 = (int8x8_t)vsqadd_u8((uint8x8_t)v19, vqtbl1_s8(v14, vadd_s8(vsub_s8(vadd_s8(vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)v19, v26), (int8x8_t)0x303030303030303, (int8x8_t)0x202020202020202), (int8x8_t)vcgt_u8(v26, (uint8x8_t)v19)), (int8x8_t)vcgt_u8((uint8x8_t)v19, v27)), (int8x8_t)vcgt_u8(v27, (uint8x8_t)v19))));
    _X8[-1] = vbsl_s8(v17, a12, v19);
    _X8 = (int8x8_t *)((char *)_X8 + a2);
    --v16;
    a5 = (char *)v18;
  }
  while (v16 > 1);
  return result;
}

int16x8_t *sub_1BBA03D3C(int16x8_t *result, uint64_t a2, uint64_t *a3, int a4, __int16 *a5, uint64_t a6, int a7)
{
  int8x16_t v9 = (int8x16_t)vdupq_n_s16(~a4);
  int16x8_t v8 = (int16x8_t)vandq_s8(v9, (int8x16_t)xmmword_1BBB6F600);
  v9.i64[0] = *a3;
  _X8 = result + 1;
  int v11 = a7 + 1;
  int8x16_t v12 = (int8x16_t)vceqzq_s16(v8);
  v13.i64[0] = 0x2000200020002;
  v13.i64[1] = 0x2000200020002;
  v14.i64[0] = 0x3000300030003;
  v14.i64[1] = 0x3000300030003;
  v15.i64[0] = 0xFC00FC00FC00FC00;
  v15.i64[1] = 0xFC00FC00FC00FC00;
  int v16 = a5;
  do
  {
    int16x8_t v17 = _X8[-1];
    __asm { PRFM            #0, [X8] }
    int8x16_t v23 = (int8x16_t)vld1q_dup_s16(v16++);
    uint16x8_t v24 = (uint16x8_t)vextq_s8(v23, (int8x16_t)v17, 0xEuLL);
    *a5 = v17.i16[7];
    v7.i16[0] = _X8->i16[0];
    uint16x8_t v25 = (uint16x8_t)vextq_s8((int8x16_t)v17, (int8x16_t)v7, 2uLL);
    int16x8_t v26 = (int16x8_t)vcgtq_u16((uint16x8_t)v17, v25);
    int16x8_t v7 = (int16x8_t)vcgtq_u16(v25, (uint16x8_t)v17);
    _X8[-1] = (int16x8_t)vbslq_s8(v12, (int8x16_t)vminq_s16(vmaxq_s16(vaddw_s8(v17, vqtbl1_s8(v9, (int8x8_t)vqmovn_u16((uint16x8_t)vaddq_s16(vsubq_s16(vaddq_s16((int16x8_t)vbslq_s8((int8x16_t)vcgtq_u16((uint16x8_t)v17, v24), v14, v13), (int16x8_t)vcgtq_u16(v24, (uint16x8_t)v17)), v26), v7)))),
                                          (int16x8_t)0),
                                        v15),
                           (int8x16_t)v17);
    _X8 = (int16x8_t *)((char *)_X8 + 2 * a2);
    --v11;
    a5 = (__int16 *)v16;
  }
  while (v11 > 1);
  return result;
}

uint64_t sub_1BBA03DE8(uint64_t a1, uint64_t a2)
{
  v13[0] = 0;
  v13[1] = 0;
  memset(&v13[3], 0, 24);
  uint64_t v4 = sub_1BBA194F8(v13, (void *)a2);
  if (!v4)
  {
    int v5 = *(unsigned __int8 *)(a2 + 24);
    switch(v5)
    {
      case '""':
        int8x16_t v9 = operator new(0x6B8uLL, MEMORY[0x1E4FBA2D0]);
        uint64_t v10 = (uint64_t)v9;
        if (v9) {
          sub_1BBA39780((uint64_t)v9, a1);
        }
        sub_1BBA060BC(&v12, v10);
      case '!':
        int16x8_t v7 = operator new(0x820uLL, MEMORY[0x1E4FBA2D0]);
        uint64_t v8 = (uint64_t)v7;
        if (v7) {
          sub_1BBAE6B30((uint64_t)v7, a1);
        }
        sub_1BBA06034(&v12, v8);
      case ' ':
        uint64_t v6 = (char *)operator new(0x120uLL, MEMORY[0x1E4FBA2D0]);
        if (v6)
        {
          *(void *)(v6 + 7) = 0;
          *(void *)uint64_t v6 = 0;
          *((_OWORD *)v6 + 1) = 0u;
          *((_OWORD *)v6 + 2) = 0u;
          *((_OWORD *)v6 + 3) = 0u;
          *((_WORD *)v6 + 32) = 0;
          *(_OWORD *)(v6 + 68) = 0u;
          *(_OWORD *)(v6 + 84) = 0u;
          *(_OWORD *)(v6 + 100) = 0u;
          *(_OWORD *)(v6 + 116) = 0u;
          *(_OWORD *)(v6 + 132) = 0u;
          *(_OWORD *)(v6 + 148) = 0u;
          *((_WORD *)v6 + 82) = 0;
          *((_WORD *)v6 + 109) = 0;
          *((_DWORD *)v6 + 64) = 0;
          *((_WORD *)v6 + 130) = 0;
          v6[262] = 0;
          *((void *)v6 + 21) = 0;
          *((void *)v6 + 22) = 0;
          *((_WORD *)v6 + 92) = 0;
          *(void *)(v6 + 204) = 0;
          *(void *)(v6 + 209) = 0;
          *(void *)(v6 + 188) = 0;
          *(void *)(v6 + 196) = 0;
          *((void *)v6 + 28) = 0;
          *((void *)v6 + 29) = 0;
          v6[240] = 0;
          *(void *)(v6 + 244) = 0;
          v6[252] = 0;
          *((void *)v6 + 33) = 0;
          *((void *)v6 + 34) = 0;
          v6[280] = 0;
        }
        sub_1BBA05FAC(&v12, (uint64_t)v6);
    }
    uint64_t v4 = 4294954385;
  }
  if (v13[0]) {
    free(v13[0]);
  }
  return v4;
}

void sub_1BBA05F64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *a12)
{
  if (a11) {
    sub_1BB9C09B4(a11);
  }
  if (a12) {
    free(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1BBA05FAC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1BBA06020(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BBA06300((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1BBA06034(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1BBA060A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BBA06228((void **)va);
  _Unwind_Resume(a1);
}

void sub_1BBA060BC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1BBA06124(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1BBA0613C(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1BBA0613C(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    unint64_t v2 = (void *)result[209];
    if (v2)
    {
      free(v2);
      v1[209] = 0;
      v1[210] = 0;
    }
    int v3 = (void *)v1[207];
    if (v3)
    {
      free(v3);
      v1[207] = 0;
      v1[208] = 0;
    }
    uint64_t v4 = (void **)(v1 + 203);
    int v5 = (void *)v1[205];
    if (v5)
    {
      free(v5);
      v1[205] = 0;
      v1[206] = 0;
    }
    if (*v4)
    {
      free(*v4);
      *uint64_t v4 = 0;
      v1[204] = 0;
    }
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

void *sub_1BBA061E4(uint64_t a1)
{
  return sub_1BBA0613C(*(void **)(a1 + 24));
}

void sub_1BBA061EC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C18605E0);
}

void *sub_1BBA06228(void **a1)
{
  CFTypeID result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1BBAE6CE4(result);
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

void *sub_1BBA0627C(uint64_t a1)
{
  CFTypeID result = *(void **)(a1 + 24);
  if (result)
  {
    sub_1BBAE6CE4(result);
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

void sub_1BBA062C4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C18605E0);
}

uint64_t sub_1BBA06300(uint64_t *a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1BBA5633C(result);
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

uint64_t sub_1BBA06354(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_1BBA5633C(result);
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

void sub_1BBA0639C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C18605E0);
}

uint64_t sub_1BBA063DC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

void sub_1BBA063FC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C18605E0);
}

uint64_t sub_1BBA0643C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

void sub_1BBA0645C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C18605E0);
}

uint64_t sub_1BBA06498(char *a1, int a2, char *a3, uint64_t a4, uint64_t a5)
{
  size_t v9 = (a2 + 2);
  bzero(a1, v9);
  a1[v9] = 1;
  uint64_t v10 = &a1[v9 + 1];
  if (a5)
  {
    uint64_t v11 = a5;
    do
    {
      char v12 = *a3++;
      *v10++ = v12;
      --v11;
    }
    while (v11);
  }
  if (a4 != a5)
  {
    int v13 = 0;
    uint64_t v14 = a5 - a4;
    do
    {
      unsigned int v15 = *a3;
      if (v13 == 2)
      {
        if (v15 > 3)
        {
          int v13 = 2;
        }
        else
        {
          int v13 = 0;
          *v10++ = 3;
          unsigned int v15 = *a3;
        }
      }
      if (v15) {
        int v13 = 0;
      }
      else {
        ++v13;
      }
      ++a3;
      *v10++ = v15;
    }
    while (!__CFADD__(v14++, 1));
  }
  return v10 - a1;
}

BOOL sub_1BBA0655C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 24) - 39 < 2;
}

uint64_t sub_1BBA06570(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 24) < 0x29uLL) & (0x18700000000uLL >> *(unsigned char *)(a1 + 24));
}

uint64_t sub_1BBA0658C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 24) < 0x16uLL) & (0x3F03FFu >> *(unsigned char *)(a1 + 24));
}

uint64_t sub_1BBA065AC(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 32) = a3;
  *(unsigned char *)(a1 + 24) = 64;
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3 > a3) {
    return 4294954387;
  }
  if ((char)*a2 < 0) {
    return 4294954387;
  }
  unsigned __int8 v4 = *a2;
  unsigned int v5 = *a2 >> 1;
  *(unsigned char *)(a1 + 24) = v5;
  if (v3 >= a3 && (v4 & 0xFC) != 0x48) {
    return 4294954387;
  }
  if ((a2[1] & 7) == 0) {
    return 4294954387;
  }
  int v6 = (a2[1] & 7) - 1;
  *(unsigned char *)(a1 + 25) = v6;
  if (v5 > 0x28) {
    return 0;
  }
  if (((1 << v5) & 0x183003F0000) != 0)
  {
    if (v6) {
      return 4294954387;
    }
    return 0;
  }
  if (((1 << v5) & 0x3C) != 0)
  {
    if (!v6) {
      return 4294954387;
    }
    return 0;
  }
  if (((1 << v5) & 0x3000000000) == 0) {
    return 0;
  }
  uint64_t result = 4294954387;
  if (v3 >= a3 && !v6) {
    return 0;
  }
  return result;
}

void sub_1BBA06670()
{
}

uint64_t sub_1BBA06688(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 276) = *(void *)(a2 + 176);
  unsigned int v2 = *(unsigned __int8 *)(a2 + 2000);
  *(unsigned char *)(a1 + 284) = v2;
  *(_DWORD *)(a1 + 1096) = *(unsigned __int8 *)(a2 + 2009);
  unint64_t v3 = (float *)(a1 + 400);
  float32x2x2_t v4 = *(float32x2x2_t *)(a2 + 2028);
  unint64_t v5 = vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL).u64[0];
  vst2_f32(v3, v4);
  if (v2 - 8 > 2) {
    return 4294954386;
  }
  *(void *)(a1 + 464) = off_1F14EF260[(v2 - 8)];
  *(unsigned char *)(a1 + 286) = v2 > 8;
  unint64_t v6 = *(unsigned __int8 *)(a2 + 173);
  if (v6 > 3) {
    return 4294954394;
  }
  if (*(unsigned char *)(a2 + 174)) {
    return 4294954386;
  }
  (*(&off_1F14EF010 + 4 * v6 + 2 * (v2 > 8)))();
  return 0;
}

void *sub_1BBA06744(void *result)
{
  result[53] = sub_1BBA0807C;
  result[54] = sub_1BBA07E48;
  result[55] = sub_1BBA079F0;
  result[56] = sub_1BBA07218;
  result[57] = sub_1BBA06E6C;
  result[134] = sub_1BBA06D64;
  result[135] = sub_1BBA06C58;
  result[136] = sub_1BBA067C8;
  return result;
}

_DWORD *sub_1BBA067C8(int a1, int a2, int a3, int a4, int a5, int a6, int *a7)
{
  uint64_t v14 = (*(uint64_t (**)(int *, void))(*(void *)a7 + 32))(a7, 0);
  uint64_t v15 = *((void *)a7 + 14);
  uint64_t result = (_DWORD *)(*(uint64_t (**)(int *, uint64_t))(*(void *)a7 + 32))(a7, 1);
  uint64_t v79 = *((void *)a7 + 15);
  uint64_t v17 = v79 >> 1;
  if (a1 <= 2)
  {
    if (a2 <= 3) {
      uint64_t v18 = 3;
    }
    else {
      uint64_t v18 = a2;
    }
    int v19 = a7[70];
    LODWORD(v20) = a2 + a6 + 4;
    if ((int)v20 >= v19) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = v20;
    }
    if ((int)v18 - 3 < (int)v20)
    {
      uint64_t v21 = v18 - 3;
      uint64_t v22 = v14 + 2 * v15 * v21 - 2;
      do
      {
        __int16 v23 = *(_WORD *)(v14 + 2 * v15 * v21);
        uint16x8_t v24 = (_WORD *)v22;
        uint64_t v25 = (3 - a1);
        do
        {
          *v24-- = v23;
          --v25;
        }
        while (v25);
        ++v21;
        v22 += 2 * v15;
      }
      while (v21 != v20);
    }
    if (a4 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = a4;
    }
    int v27 = a4 + a6 + 2;
    if (v27 >= v19) {
      int v28 = v19;
    }
    else {
      int v28 = a4 + a6 + 2;
    }
    if ((int)v26 <= v28)
    {
      uint64_t v29 = v26 - 1;
      uint64_t v30 = (uint64_t)&result[v17 * v29 - 1];
      do
      {
        if (a3 <= 0)
        {
          int v31 = result[v17 * v29];
          int8x16_t v32 = (_DWORD *)v30;
          uint64_t v33 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v32-- = v31;
            --v33;
          }
          while (v33);
          int v19 = a7[70];
        }
        ++v29;
        if (v27 >= v19) {
          int v34 = v19;
        }
        else {
          int v34 = a4 + a6 + 2;
        }
        v30 += 4 * v17;
      }
      while (v29 < v34);
    }
  }
  int v35 = a1 + a5 + 4;
  uint64_t v36 = a7[69];
  if (v35 > (int)v36)
  {
    if (a2 <= 3) {
      uint64_t v37 = 3;
    }
    else {
      uint64_t v37 = a2;
    }
    int v38 = a7[70];
    LODWORD(v39) = a2 + a6 + 4;
    if ((int)v39 >= v38) {
      uint64_t v39 = v38;
    }
    else {
      uint64_t v39 = v39;
    }
    if ((int)v37 - 3 < (int)v39)
    {
      uint64_t v40 = v37 - 3;
      uint64_t v41 = 2 * v15 * v40 + 2 * (v36 - 1) + v14 + 2;
      do
      {
        if (v35 != v36)
        {
          __int16 v42 = *(_WORD *)(v14 + 2 * (v36 - 1 + v15 * v40));
          uint16x8_t v43 = (_WORD *)v41;
          uint64_t v44 = v35 - (int)v36;
          do
          {
            *v43++ = v42;
            --v44;
          }
          while (v44);
        }
        ++v40;
        v41 += 2 * v15;
      }
      while (v40 != v39);
    }
    if (a4 <= 1) {
      uint64_t v45 = 1;
    }
    else {
      uint64_t v45 = a4;
    }
    int v46 = a4 + a6 + 2;
    if (v46 >= v38) {
      int v47 = v38;
    }
    else {
      int v47 = a4 + a6 + 2;
    }
    if ((int)v45 <= v47)
    {
      uint64_t v48 = 2 * (int)v36 - 2;
      int8x16_t v49 = (char *)result + 2 * v48;
      int v50 = a3 + a5 - v36 + 2;
      uint64_t v51 = v45 - 1;
      uint64_t v52 = (uint64_t)&result[v17 * v51 + 1] + 2 * v48;
      do
      {
        if (v50 >= 1)
        {
          int v53 = *(_DWORD *)&v49[4 * v17 * v51];
          int8x16_t v54 = (_DWORD *)v52;
          uint64_t v55 = v50 & ~(v50 >> 31);
          do
          {
            *v54++ = v53;
            --v55;
          }
          while (v55);
          int v38 = a7[70];
        }
        ++v51;
        if (v46 >= v38) {
          int v56 = v38;
        }
        else {
          int v56 = a4 + a6 + 2;
        }
        v52 += 4 * v17;
      }
      while (v51 < v56);
    }
  }
  int8x16_t v78 = result;
  int v81 = a5;
  int v57 = a6;
  uint64_t v80 = v14 + 2 * a1;
  int v58 = a2;
  if (a2 <= 2)
  {
    int v59 = a2 - 3;
    int16x8_t v60 = (char *)(v80 - 6);
    do
    {
      uint16x8_t v61 = &v60[-2 * v15];
      uint64_t result = memcpy(v61, v60, 2 * (v81 + 7));
      int16x8_t v60 = v61;
      BOOL v62 = __CFADD__(v59++, 1);
    }
    while (!v62);
    if (a4 <= 0)
    {
      int v63 = a4 - 1;
      int16x8_t v64 = (char *)&v78[a3 - 1];
      do
      {
        int16x8_t v65 = &v64[-2 * v79];
        uint64_t result = memcpy(v65, v64, 2 * (2 * v81 + 6));
        int16x8_t v64 = v65;
        BOOL v62 = __CFADD__(v63++, 1);
      }
      while (!v62);
    }
  }
  uint64_t v66 = a7[70];
  if (a2 + v57 + 4 > (int)v66)
  {
    int v67 = a4;
    int v68 = v57 + v58 - v66 + 4;
    uint64_t v69 = 2 * v15 * (v66 - 1);
    uint64_t v70 = v80 - 6;
    uint64_t v71 = 2 * v15;
    uint64_t v72 = v15 * (2 * (v66 - 1) + 2);
    do
    {
      uint64_t result = memcpy((void *)(v70 + v72), (const void *)(v70 + v69), 2 * (v81 + 7));
      v70 += v71;
      --v68;
    }
    while (v68);
    uint64_t v73 = a7[70];
    if ((int)v73 < v67 + v57 + 2)
    {
      int v74 = v57 + v67 - v73 + 2;
      uint64_t v75 = 2 * v79 * (v73 - 1);
      uint16x8_t v76 = &v78[a3 - 1];
      uint64_t v77 = v79 * (2 * (v73 - 1) + 2);
      do
      {
        uint64_t result = memcpy((char *)v76 + v77, (char *)v76 + v75, 2 * (2 * v81 + 6));
        uint16x8_t v76 = (_DWORD *)((char *)v76 + 2 * v79);
        --v74;
      }
      while (v74);
    }
  }
  return result;
}

int *sub_1BBA06C58(int *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10 = (int)result;
  if (a5)
  {
    int v11 = *(_DWORD *)(a6 + 276);
    uint64_t v12 = (a3 + result - v11);
    if ((int)v12 >= 1)
    {
      int v13 = (int *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (v11 - 1), (a2 - 1), 1);
      int v15 = *v13;
      uint64_t result = v13 + 1;
      int v14 = v15;
      do
      {
        *result++ = v14;
        --v12;
      }
      while (v12);
    }
  }
  if (a4)
  {
    int v16 = *(_DWORD *)(a6 + 280);
    uint64_t v17 = (a3 + a2 - v16);
    if ((int)v17 >= 1)
    {
      uint64_t v18 = *(void *)(a6 + 120);
      uint64_t result = (int *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (v10 - 1), (v16 - 1), 1);
      int v19 = *result;
      unint64_t v20 = (2 * v18) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v21 = (int *)((char *)result + v20);
      do
      {
        *uint64_t v21 = v19;
        uint64_t v21 = (_DWORD *)((char *)v21 + v20);
        --v17;
      }
      while (v17);
    }
  }
  return result;
}

__int16 *sub_1BBA06D64(__int16 *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10 = (int)result;
  if (a5)
  {
    int v11 = *(_DWORD *)(a6 + 276);
    uint64_t v12 = (a3 + result - v11);
    if ((int)v12 >= 1)
    {
      int v13 = (__int16 *)(*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a6 + 16))(a6, (v11 - 1), (a2 - 1), 0);
      __int16 v15 = *v13;
      uint64_t result = v13 + 1;
      __int16 v14 = v15;
      do
      {
        *result++ = v14;
        --v12;
      }
      while (v12);
    }
  }
  if (a4)
  {
    int v16 = *(_DWORD *)(a6 + 280);
    uint64_t v17 = (a3 + a2 - v16);
    if ((int)v17 >= 1)
    {
      uint64_t v18 = *(void *)(a6 + 112);
      uint64_t result = (__int16 *)(*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a6 + 16))(a6, (v10 - 1), (v16 - 1), 0);
      __int16 v19 = *result;
      unint64_t v20 = &result[v18];
      do
      {
        *unint64_t v20 = v19;
        v20 += v18;
        --v17;
      }
      while (v17);
    }
  }
  return result;
}

uint64_t *sub_1BBA06E6C(int *a1, int *a2, uint64_t a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v65 = 0;
  memset(v64, 0, sizeof(v64));
  uint64_t v6 = (a2[69] - (a2[100] + a2[102]));
  int v7 = a2[70] - (a2[101] + a2[103]);
  uint64_t v8 = *((void *)a2 + 14);
  uint64_t v9 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v10 = a2[100];
  uint64_t v11 = a2[101];
  uint64_t v12 = *((void *)a1 + 14);
  uint64_t v13 = (*(uint64_t (**)(int *, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v14 = 0;
  uint64_t v15 = v13 + 2 * a1[100];
  uint64_t v16 = 2 * a1[101];
  uint64_t v17 = v9 + 2 * v10;
  do
  {
    int v18 = v7 * (int)v14 / 3;
    uint64_t v19 = v14 + 1;
    int v20 = v7 * ((int)v14 + 1) / 3;
    if (v18 < v20)
    {
      uint64_t v21 = (uint64_t *)v64 + 3 * v14;
      uint64_t v22 = v18;
      __int16 v23 = (unsigned __int16 *)(v15 + v12 * (v16 + 2 * v18));
      uint16x8_t v24 = (unsigned __int16 *)(v17 + v8 * (2 * v11 + 2 * v18));
      do
      {
        if ((int)v6 >= 1)
        {
          uint64_t v25 = *v21;
          uint64_t v26 = v24;
          int v27 = v23;
          uint64_t v28 = v6;
          do
          {
            int v30 = *v26++;
            int v29 = v30;
            int v31 = *v27++;
            v25 += ((v29 - v31) * (v29 - v31));
            --v28;
          }
          while (v28);
          *uint64_t v21 = v25;
        }
        ++v22;
        v23 += v12;
        v24 += v8;
      }
      while (v22 != v20);
    }
    uint64_t v14 = v19;
  }
  while (v19 != 3);
  uint64_t v32 = *((void *)a1 + 15);
  uint64_t v33 = *((void *)a2 + 15);
  uint64_t v34 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v35 = a2[100];
  uint64_t v36 = a2[101];
  uint64_t v37 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v38 = 0;
  uint64_t v39 = v37 + 4 * a1[100] + 2;
  uint64_t v40 = 2 * a1[101];
  uint64_t v41 = v34 + 4 * v35 + 2;
  uint64_t v42 = 2 * v36;
  do
  {
    int v43 = v7 * (int)v38 / 3;
    uint64_t v44 = v38 + 1;
    uint64_t result = (uint64_t *)((unint64_t)(1431655766 * v7 * ((int)v38 + 1)) >> 32);
    int v46 = v7 * ((int)v38 + 1) / 3;
    if (v43 < v46)
    {
      int v47 = (char *)v64 + 24 * v38;
      uint64_t result = (uint64_t *)(v47 + 8);
      uint64_t v48 = (uint64_t *)(v47 + 16);
      uint64_t v49 = v43;
      int v50 = (unsigned __int16 *)(v39 + v32 * (v40 + 2 * v43));
      uint64_t v51 = (unsigned __int16 *)(v41 + v33 * (v42 + 2 * v43));
      do
      {
        if ((int)v6 >= 1)
        {
          uint64_t v52 = *result;
          uint64_t v53 = *v48;
          int8x16_t v54 = v51;
          uint64_t v55 = v50;
          uint64_t v56 = v6;
          do
          {
            int v57 = *(v54 - 1) - *(v55 - 1);
            int v59 = *v54;
            v54 += 2;
            int v58 = v59;
            int v60 = *v55;
            v55 += 2;
            v52 += (v57 * v57);
            v53 += ((v58 - v60) * (v58 - v60));
            --v56;
          }
          while (v56);
          *uint64_t result = v52;
          *uint64_t v48 = v53;
        }
        ++v49;
        v50 += v32;
        v51 += v33;
      }
      while (v49 != v46);
    }
    uint64_t v38 = v44;
  }
  while (v44 != 3);
  uint64_t v61 = 0;
  BOOL v62 = v64;
  do
  {
    for (uint64_t i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(void *)((char *)v62 + i));
    ++v61;
    a3 += 24;
    BOOL v62 = (_OWORD *)((char *)v62 + 24);
  }
  while (v61 != 3);
  return result;
}

uint64_t sub_1BBA07218(uint64_t a1, int *a2, double *a3, int a4)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  double v8 = sub_1BBA12160((uint64_t)v94);
  v94[0] = &unk_1F14EE0C0;
  uint64_t v103 = 0;
  int v104 = 0;
  uint64_t v105 = 0;
  char v106 = 0;
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v9 = (__CVBuffer *)(*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 96))(a1, v8);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v9);
  int v11 = a2[69];
  int v85 = a2[102];
  int v86 = a2[100];
  int v12 = a2[70];
  int v83 = a2[103];
  int v84 = a2[101];
  uint64_t v13 = *((void *)a2 + 14);
  uint64_t v14 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  signed int v15 = CVPixelBufferGetPixelFormatType(v14);
  char v16 = 0;
  int v81 = v12;
  int v82 = v11;
  if (v15 <= 2016687155)
  {
    BOOL v17 = v15 == 1278226736;
    int v18 = 2016686640;
  }
  else
  {
    BOOL v17 = v15 == 2016687156 || v15 == 2019963956;
    int v18 = 2019963440;
  }
  if (v17 || v15 == v18) {
    char v16 = 16 - sub_1BBA13A1C(v15);
  }
  uint64_t v20 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v21 = a2[100];
  uint64_t v22 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    uint64_t v79 = v13;
    int v80 = a4;
    CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    OSStatus v24 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
    if (v24)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v24;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", buf, 8u);
      }
      goto LABEL_49;
    }
    size_t Width = CVPixelBufferGetWidth(v9);
    size_t Height = CVPixelBufferGetHeight(v9);
    *(void *)CMSampleTimingInfo buf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, (const void *)*MEMORY[0x1E4F24D20], Mutable);
    int v31 = a3;
    DescriptionWithOSType PixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    CFNumberRef Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E4F24E50]);
    if (sub_1BBA13A1C(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F24E60]))
    {
      a3 = v31;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int64x2_t v91 = 0;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        uint32_t v76 = 2;
        goto LABEL_75;
      }
      goto LABEL_38;
    }
    CVReturn v34 = CVPixelBufferCreate(v23, Width, Height, 0x34323076u, *(CFDictionaryRef *)buf, &pixelBufferOut);
    a3 = v31;
    if (v34)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int64x2_t v91 = 67109120;
        CVReturn v92 = v34;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_72:
        uint32_t v76 = 8;
LABEL_75:
        _os_log_error_impl(&dword_1BB9B9000, v35, OS_LOG_TYPE_ERROR, v36, v91, v76);
        goto LABEL_38;
      }
      goto LABEL_38;
    }
    OSStatus v75 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v9, pixelBufferOut);
    if (v75)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int64x2_t v91 = 67109120;
        CVReturn v92 = v75;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_72;
      }
LABEL_38:
      sub_1BB9BE228((const void **)&Mutable);
      sub_1BB9BE228((const void **)buf);
LABEL_49:
      unint64_t v39 = 0;
      goto LABEL_50;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1BBA133CC((uint64_t)v94, pixelBufferOut, 0);
    sub_1BB9BE228((const void **)&Mutable);
    sub_1BB9BE228((const void **)buf);
    a3 = v31;
    a4 = v80;
    uint64_t v13 = v79;
  }
  else
  {
    sub_1BBA133CC((uint64_t)v94, v9, 0);
  }
  uint64_t v25 = (v82 - (v86 + v85));
  uint64_t v26 = (v81 - (v84 + v83));
  uint64_t v27 = v20 + 2 * v21 + 2 * v13 * v22;
  uint64_t v28 = v95;
  if (a4)
  {
    uint64_t v29 = v100;
    if (v95 || !sub_1BBA13E0C((uint64_t)v94)) {
      uint64_t v30 = v97;
    }
    else {
      uint64_t v30 = 0;
    }
    if ((int)v26 < 1) {
      goto LABEL_49;
    }
    uint64_t v47 = 0;
    unint64_t v39 = 0;
    uint64_t v48 = v30 + 2 * v101 + 2 * v29 * v102;
    do
    {
      if ((int)v25 >= 1)
      {
        uint64_t v49 = (unsigned __int16 *)v27;
        int v50 = (unsigned __int16 *)v48;
        uint64_t v51 = (v82 - (v86 + v85));
        do
        {
          int v53 = *v49++;
          int v52 = v53;
          int v54 = *v50++;
          v39 += ((v52 - v54) * (v52 - v54));
          --v51;
        }
        while (v51);
      }
      ++v47;
      v48 += 2 * v29;
      v27 += 2 * v13;
    }
    while (v47 != v26);
  }
  else
  {
    uint64_t v37 = v98;
    if (!v95)
    {
      if (sub_1BBA13E0C((uint64_t)v94)) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = v95;
      }
    }
    if ((int)v26 < 1)
    {
      unint64_t v39 = 0;
      goto LABEL_57;
    }
    uint64_t v38 = 0;
    unint64_t v39 = 0;
    uint64_t v40 = v28 + 2 * v101 + 2 * v37 * v102;
    do
    {
      if ((int)v25 >= 1)
      {
        uint64_t v41 = (unsigned __int16 *)v27;
        uint64_t v42 = (unsigned __int16 *)v40;
        uint64_t v43 = (v82 - (v86 + v85));
        do
        {
          unsigned int v45 = *v41++;
          unsigned int v44 = v45;
          unsigned int v46 = *v42++;
          v39 += ((v44 >> v16) - (v46 >> v16)) * ((v44 >> v16) - (v46 >> v16));
          --v43;
        }
        while (v43);
      }
      ++v38;
      v40 += 2 * v37;
      v27 += 2 * v13;
    }
    while (v38 != v26);
  }
  if (a4)
  {
LABEL_50:
    unint64_t v55 = 0;
    unint64_t v56 = 0;
    goto LABEL_51;
  }
LABEL_57:
  uint64x2_t v87 = a3;
  uint64_t v58 = v99;
  uint64_t v59 = *((void *)a2 + 15);
  uint64_t v60 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v61 = a2[100];
  uint64_t v62 = a2[101];
  if (v95 || !sub_1BBA13E0C((uint64_t)v94)) {
    uint64_t v63 = v96;
  }
  else {
    uint64_t v63 = 0;
  }
  if ((int)v26 < 1)
  {
    unint64_t v55 = 0;
    unint64_t v56 = 0;
    a3 = v87;
  }
  else
  {
    uint64_t v64 = 0;
    unint64_t v56 = 0;
    uint64_t v65 = v60;
    unint64_t v55 = 0;
    uint64_t v66 = 2 * v58 * v102 + 4 * v101 + v63 + 2;
    uint64_t v67 = 2 * v59 * v62 + 4 * v61 + v65 + 2;
    a3 = v87;
    do
    {
      if ((int)v25 >= 1)
      {
        int v68 = (unsigned __int16 *)v67;
        uint64_t v69 = (unsigned __int16 *)v66;
        uint64_t v70 = v25;
        do
        {
          int v71 = (*(v68 - 1) >> v16) - (*(v69 - 1) >> v16);
          unsigned int v72 = *v68;
          v68 += 2;
          unsigned int v73 = v72 >> v16;
          unsigned int v74 = *v69;
          v69 += 2;
          v55 += (v71 * v71);
          v56 += (v73 - (v74 >> v16)) * (v73 - (v74 >> v16));
          --v70;
        }
        while (v70);
      }
      ++v64;
      v66 += 2 * v58;
      v67 += 2 * v59;
    }
    while (v64 != v26);
  }
LABEL_51:
  if (pixelBufferOut) {
    CVPixelBufferRelease(pixelBufferOut);
  }
  if (pixelTransferSessionOut) {
    CFRelease(pixelTransferSessionOut);
  }
  *a3 = (double)v39;
  a3[1] = (double)v55;
  a3[2] = (double)v56;
  return sub_1BBA141AC((uint64_t)v94);
}

void sub_1BBA07980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, const void *);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  va_copy(va2, va1);
  signed int v15 = va_arg(va2, const void *);
  uint64_t v17 = va_arg(va2, void);
  sub_1BB9BE228((const void **)va);
  sub_1BB9BE228((const void **)va1);
  sub_1BBA141AC((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1BBA079F0(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned int v2 = a2;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  memset(data, 0, sizeof(data));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  uint64_t v4 = *a1;
  if (*((unsigned char *)a1 + 136))
  {
    unint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 56))(a1, 0);
    uint64_t v6 = a1 + 22;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    double v8 = a1 + 21;
  }
  else
  {
    unint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 40))(a1, 0);
    uint64_t v6 = a1 + 15;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    double v8 = a1 + 14;
  }
  uint64_t v9 = 0;
  uint64_t v10 = *v6;
  uint64_t v11 = *v8;
  do
  {
    *((unsigned char *)&c + v9 + 92) = 1;
    *((unsigned char *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    unint64_t v12 = 0;
    do
    {
      char v13 = CC_MD5_Update(&c, v5, 2 * *((_DWORD *)a1 + 69));
      v36 &= v13;
      ++v12;
      int v14 = *((_DWORD *)a1 + 70);
      v5 += 2 * v11;
    }
    while (v12 < v14);
    uint64_t v15 = v14;
    if (v7) {
      goto LABEL_10;
    }
  }
  else
  {
    int v14 = 0;
    uint64_t v15 = 0;
    if (v7)
    {
LABEL_10:
      uint64_t v16 = *((int *)a1 + 69);
      signed int v17 = 2 * v16 * v14;
      sub_1BBA07D38((char **)data, v17);
      int v18 = data[0];
      uint64_t v19 = (char *)data[0] + 2 * (int)v16 * v14;
      if (v14)
      {
        uint64_t v20 = 2 * v16;
        uint64_t v21 = v7 + 4 * v16 - 2;
        uint64_t v22 = (char *)data[0];
        CFAllocatorRef v23 = (char *)data[0] + 2 * (int)v16 * v14;
        do
        {
          if (v16)
          {
            OSStatus v24 = (__int16 *)v21;
            uint64_t v25 = v16 - 1;
            do
            {
              *(_WORD *)&v22[2 * v25] = *(v24 - 1);
              __int16 v26 = *v24;
              v24 -= 2;
              *(_WORD *)&v23[2 * v25--] = v26;
            }
            while (v25 != -1);
          }
          v23 += v20;
          v22 += v20;
          v21 += 2 * v10;
          --v15;
        }
        while (v15);
      }
      char v27 = CC_MD5_Update(&v37, v18, v17);
      v38 &= v27;
      char v28 = CC_MD5_Update(&v39, v19, v17);
      v40 &= v28;
      goto LABEL_19;
    }
  }
  int v18 = 0;
LABEL_19:
  uint64_t v29 = 0;
  while (1)
  {
    char v30 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v29));
    BOOL v31 = (v30 & *((unsigned char *)&c + v29 + 92)) == 0;
    *((unsigned char *)&c + v29 + 92) &= v30;
    if (v31) {
      break;
    }
    v29 += 96;
    v2 += 16;
    if (v29 == 288)
    {
      uint64_t v32 = 0;
      if (!v18) {
        return v32;
      }
      goto LABEL_25;
    }
  }
  uint64_t v32 = 4294954385;
  if (!v18) {
    return v32;
  }
LABEL_25:
  operator delete(v18);
  return v32;
}

void sub_1BBA07D04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1BBA07D38(char **a1, unint64_t a2)
{
  unint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 1;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    uint64_t v16 = &v3[2 * a2];
    goto LABEL_17;
  }
  unint64_t v6 = a2 - v5;
  uint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 1)
  {
    bzero(a1[1], 2 * v6);
    uint64_t v16 = &v4[2 * v6];
LABEL_17:
    a1[1] = v16;
    return;
  }
  if ((a2 & 0x8000000000000000) != 0) {
    sub_1BB9C185C();
  }
  unint64_t v8 = v7 - v3;
  if (v8 <= a2) {
    unint64_t v9 = a2;
  }
  else {
    unint64_t v9 = v8;
  }
  if (v8 >= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v10 = v9;
  }
  if (v10 < 0) {
    sub_1BB9C18AC();
  }
  uint64_t v11 = (char *)operator new(2 * v10);
  unint64_t v12 = &v11[2 * v5];
  char v13 = &v11[2 * v10];
  bzero(v12, 2 * v6);
  int v14 = &v12[2 * v6];
  while (v4 != v3)
  {
    __int16 v15 = *((_WORD *)v4 - 1);
    v4 -= 2;
    *((_WORD *)v12 - 1) = v15;
    v12 -= 2;
  }
  *a1 = v12;
  a1[1] = v14;
  a1[2] = v13;
  if (v3)
  {
    operator delete(v3);
  }
}

uint64_t sub_1BBA07E48(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  uint64_t v4 = *(int *)(a1 + 276);
  int v5 = *(_DWORD *)(a1 + 408) + *(_DWORD *)(a1 + 400);
  int v6 = v4 - v5;
  int v7 = *(_DWORD *)(a1 + 280);
  int v8 = *(_DWORD *)(a1 + 412);
  int v30 = v8 + *(_DWORD *)(a1 + 404);
  int v31 = v7 - v30;
  int v9 = v7 - v8;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v11 = *(int *)(a1 + 404);
  if ((int)v11 < v9)
  {
    uint64_t v12 = v10 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v12 + 2 * *(void *)(a1 + 112) * v11++), 1uLL, 2 * v6, a2);
    while (v11 < v9);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v28 = *(int *)(a1 + 400);
  uint64_t v29 = v13;
  uint64_t v14 = *(int *)(a1 + 404);
  uint64_t v15 = *(void *)(a1 + 120);
  if (v31 * v6 < 0) {
    size_t v16 = -1;
  }
  else {
    size_t v16 = 4 * v31 * v6;
  }
  signed int v17 = (char *)operator new[](v16, MEMORY[0x1E4FBA2D0]);
  if (!v17) {
    return 4294954392;
  }
  int v18 = v17;
  if (v7 != v30)
  {
    uint64_t v19 = v31;
    uint64_t v20 = &v17[2 * v31 * v6];
    uint64_t v21 = 2 * v4 - 2 * v5;
    uint64_t v22 = 2 * v15 * v14 + 4 * v4 + 4 * v28 - 4 * v5 + v29 - 2;
    CFAllocatorRef v23 = v17;
    do
    {
      if (v4 != v5)
      {
        OSStatus v24 = (__int16 *)v22;
        uint64_t v25 = ~(uint64_t)v5 + v4;
        do
        {
          *(_WORD *)&v23[2 * v25] = *(v24 - 1);
          __int16 v26 = *v24;
          v24 -= 2;
          *(_WORD *)&v20[2 * v25--] = v26;
        }
        while (v25 != -1);
      }
      v20 += v21;
      v23 += v21;
      v22 += 2 * v15;
      --v19;
    }
    while (v19);
  }
  fwrite(v17, 1uLL, 4 * v31 * v6, a2);
  MEMORY[0x1C18605A0](v18, 0x1000C80BDFB0063);
  return 0;
}

uint64_t sub_1BBA0807C(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  uint64_t v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    uint64_t v8 = v6 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + 2 * *(void *)(a1 + 112) * v7++), 1uLL, 2 * v4, a2);
    while (v7 < v5);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v5)
  {
    uint64_t v11 = v9 + 4 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + 2 * *(void *)(a1 + 120) * v10++), 1uLL, 4 * v4, a2);
    while (v10 < (int)v5);
  }
  return 0;
}

void *sub_1BBA081C4(void *result)
{
  result[53] = sub_1BBA09938;
  result[54] = sub_1BBA0971C;
  result[55] = sub_1BBA093F0;
  result[56] = sub_1BBA08C64;
  result[57] = sub_1BBA088E0;
  result[134] = sub_1BBA087E0;
  result[135] = sub_1BBA086D8;
  result[136] = sub_1BBA08248;
  return result;
}

uint64_t sub_1BBA08248(int a1, int a2, int a3, int a4, int a5, int a6, void *a7)
{
  uint64_t v83 = (*(uint64_t (**)(void *, void))(*a7 + 32))(a7, 0);
  uint64_t v13 = a7[14];
  uint64_t result = (*(uint64_t (**)(void *, uint64_t))(*a7 + 32))(a7, 1);
  uint64_t v15 = result;
  uint64_t v16 = a7[15];
  uint64_t v17 = v16;
  int v84 = a6;
  int v85 = a2;
  uint64_t v82 = result;
  if (a1 <= 2)
  {
    if (a2 <= 3) {
      uint64_t v18 = 3;
    }
    else {
      uint64_t v18 = a2;
    }
    int v19 = a2 + a6 + 4;
    LODWORD(v20) = *((_DWORD *)a7 + 70);
    if (v19 >= (int)v20) {
      int v21 = *((_DWORD *)a7 + 70);
    }
    else {
      int v21 = v19;
    }
    if ((int)v18 - 3 < v21)
    {
      int v79 = a5;
      size_t v22 = (3 - a1);
      int v23 = a1;
      uint64_t v24 = v18 - 3;
      int v25 = v23;
      __int16 v26 = (unsigned __int8 *)(v83 + v13 * (v18 - 3));
      uint64_t v27 = v23 - 3;
      do
      {
        uint64_t result = (uint64_t)memset(&v26[v27], *v26, v22);
        LODWORD(v20) = *((_DWORD *)a7 + 70);
        ++v24;
        if (v19 >= (int)v20) {
          int v28 = *((_DWORD *)a7 + 70);
        }
        else {
          int v28 = v19;
        }
        v26 += v13;
      }
      while (v24 < v28);
      uint64_t v17 = a7[15];
      a6 = v84;
      uint64_t v15 = v82;
      a5 = v79;
      a1 = v25;
    }
    if (a4 <= 1) {
      uint64_t v29 = 1;
    }
    else {
      uint64_t v29 = a4;
    }
    int v30 = a4 + a6 + 2;
    if (v30 >= (int)v20) {
      uint64_t v20 = v20;
    }
    else {
      uint64_t v20 = v30;
    }
    if ((int)v29 <= (int)v20)
    {
      uint64_t v31 = v29 - 1;
      uint64_t v32 = v15 + 2 * (v17 >> 1) * v31 - 2;
      a2 = v85;
      do
      {
        if (a3 <= 0)
        {
          __int16 v33 = *(_WORD *)(v15 + 2 * (v17 >> 1) * v31);
          CVReturn v34 = (_WORD *)v32;
          uint64_t v35 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v34-- = v33;
            --v35;
          }
          while (v35);
        }
        ++v31;
        v32 += 2 * (v17 >> 1);
      }
      while (v31 != v20);
    }
    else
    {
      a2 = v85;
    }
  }
  int v36 = a1 + a5 + 4;
  int v37 = *((_DWORD *)a7 + 69);
  int v38 = v36 - v37;
  if (v36 > v37)
  {
    int v39 = a1;
    if (a2 <= 3) {
      uint64_t v40 = 3;
    }
    else {
      uint64_t v40 = a2;
    }
    int v41 = a2 + a6 + 4;
    LODWORD(v42) = *((_DWORD *)a7 + 70);
    if (v41 >= (int)v42) {
      int v43 = *((_DWORD *)a7 + 70);
    }
    else {
      int v43 = a2 + a6 + 4;
    }
    if ((int)v40 - 3 < v43)
    {
      int v80 = a5;
      uint64_t v44 = v40 - 3;
      size_t v45 = v38;
      unsigned int v46 = (char *)(v37 + v13 * (v40 - 3) + v83);
      do
      {
        uint64_t result = (uint64_t)memset(v46, *(v46 - 1), v45);
        ++v44;
        LODWORD(v42) = *((_DWORD *)a7 + 70);
        if (v41 >= (int)v42) {
          int v47 = *((_DWORD *)a7 + 70);
        }
        else {
          int v47 = v41;
        }
        v46 += v13;
      }
      while (v44 < v47);
      int v37 = *((_DWORD *)a7 + 69);
      uint64_t v17 = a7[15];
      a6 = v84;
      a2 = v85;
      a5 = v80;
    }
    a1 = v39;
    if (a4 <= 1) {
      uint64_t v48 = 1;
    }
    else {
      uint64_t v48 = a4;
    }
    int v49 = a4 + a6 + 2;
    if (v49 >= (int)v42) {
      uint64_t v42 = v42;
    }
    else {
      uint64_t v42 = v49;
    }
    if ((int)v48 <= (int)v42)
    {
      uint64_t v50 = 2 * v37 - 2;
      uint64_t v51 = v15 + v50;
      uint64_t v52 = v17 >> 1;
      int v53 = a3 + a5 - v37 + 2;
      uint64_t v54 = v48 - 1;
      uint64_t v55 = v50 + 2 * v52 * v54 + v15 + 2;
      do
      {
        if (v53 >= 1)
        {
          __int16 v56 = *(_WORD *)(v51 + 2 * v52 * v54);
          int v57 = (_WORD *)v55;
          uint64_t result = v53 & ~(v53 >> 31);
          do
          {
            *v57++ = v56;
            --result;
          }
          while (result);
        }
        ++v54;
        v55 += 2 * v52;
      }
      while (v54 != v42);
    }
  }
  int v58 = a5;
  int v81 = 2 * a5;
  uint64_t v59 = v83 + a1;
  if (a2 <= 2)
  {
    int v60 = v85 - 3;
    uint64_t v61 = (char *)(v59 - 3);
    do
    {
      uint64_t v62 = &v61[-v13];
      uint64_t result = (uint64_t)memcpy(&v61[-v13], v61, v58 + 7);
      uint64_t v61 = v62;
      BOOL v63 = __CFADD__(v60++, 1);
    }
    while (!v63);
    if (a4 <= 0)
    {
      int v64 = a4 - 1;
      uint64_t v65 = (char *)(v82 + 2 * a3 - 2);
      do
      {
        uint64_t v66 = &v65[-v16];
        uint64_t result = (uint64_t)memcpy(&v65[-v16], v65, v81 + 6);
        uint64_t v65 = v66;
        BOOL v63 = __CFADD__(v64++, 1);
      }
      while (!v63);
    }
  }
  uint64_t v67 = *((int *)a7 + 70);
  if (v85 + v84 + 4 > (int)v67)
  {
    uint64_t v68 = v13 * (v67 - 1);
    size_t v69 = v58 + 7;
    int v70 = v84 + v85 - v67 + 4;
    uint64_t v71 = v59 - 3;
    uint64_t v72 = v13 * v67;
    do
    {
      uint64_t result = (uint64_t)memcpy((void *)(v71 + v72), (const void *)(v71 + v68), v69);
      v71 += v13;
      --v70;
    }
    while (v70);
    uint64_t v73 = *((int *)a7 + 70);
    if ((int)v73 < a4 + v84 + 2)
    {
      uint64_t v74 = v16 * (v73 - 1);
      int v75 = 2 * a3 - 2;
      int v76 = v84 + a4 - v73 + 2;
      uint64_t v77 = v82 + v75;
      uint64_t v78 = v16 * v73;
      do
      {
        uint64_t result = (uint64_t)memcpy((void *)(v77 + v78), (const void *)(v77 + v74), v81 + 6);
        v77 += v16;
        --v76;
      }
      while (v76);
    }
  }
  return result;
}

__int16 *sub_1BBA086D8(__int16 *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10 = (int)result;
  if (a5)
  {
    int v11 = *(_DWORD *)(a6 + 276);
    uint64_t v12 = (a3 + result - v11);
    if ((int)v12 >= 1)
    {
      uint64_t v13 = (__int16 *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (v11 - 1), (a2 - 1), 1);
      __int16 v15 = *v13;
      uint64_t result = v13 + 1;
      __int16 v14 = v15;
      do
      {
        *result++ = v14;
        --v12;
      }
      while (v12);
    }
  }
  if (a4)
  {
    int v16 = *(_DWORD *)(a6 + 280);
    uint64_t v17 = (a3 + a2 - v16);
    if ((int)v17 >= 1)
    {
      uint64_t v18 = *(void *)(a6 + 120);
      uint64_t result = (__int16 *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (v10 - 1), (v16 - 1), 1);
      __int16 v19 = *result;
      uint64_t v20 = (__int16 *)((char *)result + (v18 & 0xFFFFFFFFFFFFFFFELL));
      do
      {
        *uint64_t v20 = v19;
        uint64_t v20 = (_WORD *)((char *)v20 + (v18 & 0xFFFFFFFFFFFFFFFELL));
        --v17;
      }
      while (v17);
    }
  }
  return result;
}

char *sub_1BBA087E0(char *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10 = (int)result;
  if (a5)
  {
    int v11 = *(_DWORD *)(a6 + 276);
    size_t v12 = (a3 + result - v11);
    if ((int)v12 >= 1)
    {
      uint64_t v13 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a6 + 16))(a6, (v11 - 1), (a2 - 1), 0);
      uint64_t result = (char *)memset(v13 + 1, *v13, v12);
    }
  }
  if (a4)
  {
    int v14 = *(_DWORD *)(a6 + 280);
    uint64_t v15 = (a3 + a2 - v14);
    if ((int)v15 >= 1)
    {
      uint64_t v16 = *(void *)(a6 + 112);
      uint64_t result = (char *)(*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a6 + 16))(a6, (v10 - 1), (v14 - 1), 0);
      char v17 = *result;
      uint64_t v18 = &result[v16];
      do
      {
        *uint64_t v18 = v17;
        v18 += v16;
        --v15;
      }
      while (v15);
    }
  }
  return result;
}

uint64_t sub_1BBA088E0(int *a1, int *a2, uint64_t a3)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  uint64_t v57 = 0;
  memset(v56, 0, sizeof(v56));
  uint64_t v6 = (a2[69] - (a2[100] + a2[102]));
  int v7 = a2[70] - (a2[101] + a2[103]);
  uint64_t v8 = *((void *)a2 + 14);
  uint64_t v9 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v10 = a2[100];
  uint64_t v11 = a2[101];
  uint64_t v12 = *((void *)a1 + 14);
  uint64_t v13 = (*(uint64_t (**)(int *, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v14 = 0;
  uint64_t v15 = v13 + a1[100];
  uint64_t v16 = a1[101];
  do
  {
    int v17 = v7 * (int)v14 / 3;
    uint64_t v18 = v14 + 1;
    int v19 = v7 * ((int)v14 + 1) / 3;
    if (v17 < v19)
    {
      uint64_t v20 = (uint64_t *)v56 + 3 * v14;
      uint64_t v21 = v17;
      size_t v22 = (unsigned __int8 *)(v15 + v12 * (v16 + v17));
      int v23 = (unsigned __int8 *)(v9 + v10 + v8 * (v11 + v17));
      do
      {
        if ((int)v6 >= 1)
        {
          uint64_t v24 = *v20;
          int v25 = v23;
          __int16 v26 = v22;
          uint64_t v27 = v6;
          do
          {
            int v29 = *v25++;
            int v28 = v29;
            int v30 = *v26++;
            v24 += ((v28 - v30) * (v28 - v30));
            --v27;
          }
          while (v27);
          *uint64_t v20 = v24;
        }
        ++v21;
        v22 += v12;
        v23 += v8;
      }
      while (v21 != v19);
    }
    uint64_t v14 = v18;
  }
  while (v18 != 3);
  uint64_t v31 = *((void *)a1 + 15);
  uint64_t v32 = *((void *)a2 + 15);
  uint64_t v33 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v34 = a2[100];
  uint64_t v35 = a2[101];
  uint64_t result = (*(uint64_t (**)(int *, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v37 = 0;
  uint64_t v38 = a1[101];
  uint64_t v39 = result + 2 * a1[100];
  do
  {
    int v40 = v7 * (int)v37 / 3;
    uint64_t v41 = v37 + 1;
    int v42 = v7 * ((int)v37 + 1) / 3;
    if (v40 < v42)
    {
      int v43 = (uint64x2_t *)((char *)v56 + 24 * v37 + 8);
      uint64_t v44 = v40;
      uint64_t result = v39 + v31 * (v38 + v40);
      uint64_t v45 = v33 + 2 * v34 + v32 * (v35 + v40);
      do
      {
        if ((int)v6 >= 1)
        {
          uint64x2_t v46 = *v43;
          int v47 = (unsigned __int8 *)v45;
          uint64_t v48 = (unsigned __int8 *)result;
          uint64_t v49 = v6;
          do
          {
            v50.i32[0] = *v47;
            v50.i32[1] = v47[1];
            v51.i32[0] = *v48;
            v51.i32[1] = v48[1];
            int32x2_t v52 = vsub_s32(v50, v51);
            uint64x2_t v46 = vaddw_u32(v46, (uint32x2_t)vmul_s32(v52, v52));
            v48 += 2;
            v47 += 2;
            --v49;
          }
          while (v49);
          *int v43 = v46;
        }
        ++v44;
        result += v31;
        v45 += v32;
      }
      while (v44 != v42);
    }
    uint64_t v37 = v41;
  }
  while (v41 != 3);
  uint64_t v53 = 0;
  uint64_t v54 = v56;
  do
  {
    for (uint64_t i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(void *)((char *)v54 + i));
    ++v53;
    a3 += 24;
    uint64_t v54 = (_OWORD *)((char *)v54 + 24);
  }
  while (v53 != 3);
  return result;
}

uint64_t sub_1BBA08C64(uint64_t a1, int *a2, uint64_t a3, int a4)
{
  uint64_t v105 = *MEMORY[0x1E4F143B8];
  double v8 = sub_1BBA12160((uint64_t)v92);
  v92[0] = &unk_1F14EE0C0;
  uint64_t v101 = 0;
  int v102 = 0;
  uint64_t v103 = 0;
  char v104 = 0;
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v9 = (__CVBuffer *)(*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 96))(a1, v8);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v9);
  int v11 = a2[69];
  int v83 = a2[102];
  int v84 = a2[100];
  int v12 = a2[70];
  int v81 = a2[103];
  int v82 = a2[101];
  uint64_t v13 = *((void *)a2 + 14);
  uint64_t v14 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  signed int v15 = CVPixelBufferGetPixelFormatType(v14);
  unsigned int v16 = 0;
  int v80 = v12;
  if (v15 <= 2016687155)
  {
    BOOL v17 = v15 == 1278226736;
    int v18 = 2016686640;
  }
  else
  {
    BOOL v17 = v15 == 2016687156 || v15 == 2019963956;
    int v18 = 2019963440;
  }
  if (v17 || v15 == v18) {
    unsigned int v16 = 8 - sub_1BBA13A1C(v15);
  }
  uint64_t v79 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v20 = a2[100];
  uint64_t v21 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    int v77 = v11;
    int v78 = a4;
    CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    OSStatus v23 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
    if (v23)
    {
      BOOL v24 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      uint64x2_t v25 = 0uLL;
      if (v24)
      {
        LODWORD(theDict[0]) = 67109120;
        HIDWORD(theDict[0]) = v23;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", (uint8_t *)theDict, 8u);
        uint64x2_t v25 = 0uLL;
      }
      unint64_t v26 = 0;
      goto LABEL_63;
    }
    size_t Width = CVPixelBufferGetWidth(v9);
    size_t Height = CVPixelBufferGetHeight(v9);
    theDict[0] = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(theDict[0], (const void *)*MEMORY[0x1E4F24D20], Mutable);
    uint64_t v33 = a3;
    DescriptionWithOSType PixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    CFNumberRef Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E4F24E50]);
    if (sub_1BBA13A1C(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F24E60]))
    {
      a3 = v33;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CMSampleTimingInfo buf = 0;
        uint64_t v37 = MEMORY[0x1E4F14500];
        uint64_t v38 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        uint32_t v74 = 2;
        goto LABEL_74;
      }
      goto LABEL_39;
    }
    CVReturn v36 = CVPixelBufferCreate(v22, Width, Height, 0x34323076u, theDict[0], &pixelBufferOut);
    a3 = v33;
    if (v36)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        CVReturn v90 = v36;
        uint64_t v37 = MEMORY[0x1E4F14500];
        uint64_t v38 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_71:
        uint32_t v74 = 8;
LABEL_74:
        _os_log_error_impl(&dword_1BB9B9000, v37, OS_LOG_TYPE_ERROR, v38, buf, v74);
        goto LABEL_39;
      }
      goto LABEL_39;
    }
    OSStatus v73 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v9, pixelBufferOut);
    if (v73)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        CVReturn v90 = v73;
        uint64_t v37 = MEMORY[0x1E4F14500];
        uint64_t v38 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_71;
      }
LABEL_39:
      sub_1BB9BE228((const void **)&Mutable);
      sub_1BB9BE228((const void **)theDict);
LABEL_50:
      unint64_t v26 = 0;
LABEL_51:
      uint64x2_t v25 = 0uLL;
      goto LABEL_63;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1BBA133CC((uint64_t)v92, pixelBufferOut, 0);
    sub_1BB9BE228((const void **)&Mutable);
    sub_1BB9BE228((const void **)theDict);
    a3 = v33;
    int v11 = v77;
    a4 = v78;
  }
  else
  {
    sub_1BBA133CC((uint64_t)v92, v9, 0);
  }
  uint64_t v27 = (v11 - (v84 + v83));
  uint64_t v28 = (v80 - (v82 + v81));
  int v29 = (unsigned __int8 *)(v79 + v20 + v13 * v21);
  uint64_t v30 = v93;
  if (a4)
  {
    uint64_t v31 = v98;
    if (v93 || !sub_1BBA13E0C((uint64_t)v92)) {
      uint64_t v32 = v95;
    }
    else {
      uint64_t v32 = 0;
    }
    if ((int)v28 < 1) {
      goto LABEL_50;
    }
    uint64_t v48 = 0;
    unint64_t v26 = 0;
    uint64_t v49 = (unsigned __int8 *)(v32 + v99 + v31 * v100);
    do
    {
      if ((int)v27 >= 1)
      {
        int32x2_t v50 = v29;
        int32x2_t v51 = v49;
        uint64_t v52 = v27;
        do
        {
          int v54 = *v50++;
          int v53 = v54;
          int v55 = *v51++;
          v26 += ((v53 - v55) * (v53 - v55));
          --v52;
        }
        while (v52);
      }
      ++v48;
      v49 += v31;
      v29 += v13;
    }
    while (v48 != v28);
  }
  else
  {
    uint64_t v39 = v96;
    if (!v93)
    {
      if (sub_1BBA13E0C((uint64_t)v92)) {
        uint64_t v30 = 0;
      }
      else {
        uint64_t v30 = v93;
      }
    }
    if ((int)v28 < 1)
    {
      unint64_t v26 = 0;
      goto LABEL_53;
    }
    uint64_t v40 = 0;
    unint64_t v26 = 0;
    uint64_t v41 = (unsigned __int8 *)(v30 + v99 + v39 * v100);
    do
    {
      if ((int)v27 >= 1)
      {
        int v42 = v29;
        int v43 = v41;
        uint64_t v44 = v27;
        do
        {
          unsigned int v46 = *v42++;
          unsigned int v45 = v46;
          unsigned int v47 = *v43++;
          v26 += ((v45 >> v16) - (v47 >> v16)) * ((v45 >> v16) - (v47 >> v16));
          --v44;
        }
        while (v44);
      }
      ++v40;
      v41 += v39;
      v29 += v13;
    }
    while (v40 != v28);
  }
  uint64x2_t v25 = 0uLL;
  if (a4) {
    goto LABEL_63;
  }
LABEL_53:
  uint64_t v56 = v97;
  uint64_t v57 = *((void *)a2 + 15);
  uint64_t v58 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v59 = a2[100];
  uint64_t v60 = a2[101];
  if (v93 || !sub_1BBA13E0C((uint64_t)v92)) {
    uint64_t v61 = v94;
  }
  else {
    uint64_t v61 = 0;
  }
  if ((int)v28 < 1) {
    goto LABEL_51;
  }
  uint64_t v62 = 0;
  uint64_t v63 = v58 + 2 * v59 + v57 * v60;
  uint64_t v64 = v61 + 2 * v99 + v56 * v100;
  uint64x2_t v25 = 0uLL;
  uint32x2_t v65 = (uint32x2_t)vneg_s32(vdup_n_s32(v16));
  do
  {
    if ((int)v27 >= 1)
    {
      uint64_t v66 = (unsigned __int8 *)v63;
      uint64_t v67 = (unsigned __int8 *)v64;
      uint64_t v68 = v27;
      do
      {
        v69.i32[0] = *v66;
        v69.i32[1] = v66[1];
        v70.i32[0] = *v67;
        v70.i32[1] = v67[1];
        int32x2_t v71 = vsub_s32((int32x2_t)vshl_u32(v69, v65), (int32x2_t)vshl_u32(v70, v65));
        uint64x2_t v25 = vaddw_u32(v25, (uint32x2_t)vmul_s32(v71, v71));
        v67 += 2;
        v66 += 2;
        --v68;
      }
      while (v68);
    }
    ++v62;
    v64 += v56;
    v63 += v57;
  }
  while (v62 != v28);
LABEL_63:
  uint64x2_t v85 = v25;
  if (pixelBufferOut) {
    CVPixelBufferRelease(pixelBufferOut);
  }
  if (pixelTransferSessionOut) {
    CFRelease(pixelTransferSessionOut);
  }
  *(double *)a3 = (double)v26;
  *(float64x2_t *)(a3 + 8) = vcvtq_f64_u64(v85);
  return sub_1BBA141AC((uint64_t)v92);
}

void sub_1BBA09380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  int v11 = va_arg(va1, const void *);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  va_copy(va2, va1);
  BOOL v17 = va_arg(va2, const void *);
  uint64_t v19 = va_arg(va2, void);
  sub_1BB9BE228((const void **)va);
  sub_1BB9BE228((const void **)va1);
  sub_1BBA141AC((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1BBA093F0(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned int v2 = a2;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  uint64_t v4 = *a1;
  if (*((unsigned char *)a1 + 136))
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 56))(a1, 0);
    uint64_t v6 = a1 + 22;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    double v8 = a1 + 21;
  }
  else
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 40))(a1, 0);
    uint64_t v6 = a1 + 15;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    double v8 = a1 + 14;
  }
  uint64_t v9 = 0;
  uint64_t v10 = *v6;
  uint64_t v11 = *v8;
  do
  {
    *((unsigned char *)&c + v9 + 92) = 1;
    *((unsigned char *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    for (unint64_t i = 0; i < v14; ++i)
    {
      char v13 = CC_MD5_Update(&c, v5, *((_DWORD *)a1 + 69));
      v35 &= v13;
      v5 += v11;
      int v14 = *((_DWORD *)a1 + 70);
    }
    uint64_t v15 = v14;
    if (!v7) {
      goto LABEL_22;
    }
LABEL_12:
    uint64_t v16 = *((int *)a1 + 69);
    uint64_t v17 = (int)v16 * (uint64_t)v14;
    if (v17)
    {
      sub_1BB9C1970((unint64_t *)__p, 2 * (int)v17);
      int v18 = (char *)__p[0];
    }
    else
    {
      int v18 = 0;
    }
    uint64_t v19 = &v18[v17];
    if (v14)
    {
      uint64_t v20 = v7 + 2 * v16 - 1;
      uint64_t v21 = v18;
      CFAllocatorRef v22 = &v18[v17];
      do
      {
        if (v16)
        {
          OSStatus v23 = (char *)v20;
          uint64_t v24 = v16;
          do
          {
            v21[v24 - 1] = *(v23 - 1);
            char v25 = *v23;
            v23 -= 2;
            v22[--v24] = v25;
          }
          while (v24);
        }
        v21 += v16;
        v22 += v16;
        v20 += v10;
        --v15;
      }
      while (v15);
    }
    char v26 = CC_MD5_Update(&v36, v18, v16 * v14);
    v37 &= v26;
    char v27 = CC_MD5_Update(&v38, v19, v16 * v14);
    v39 &= v27;
    goto LABEL_22;
  }
  int v14 = 0;
  uint64_t v15 = 0;
  if (v7) {
    goto LABEL_12;
  }
LABEL_22:
  uint64_t v28 = 0;
  while (1)
  {
    char v29 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v28));
    BOOL v30 = (v29 & *((unsigned char *)&c + v28 + 92)) == 0;
    *((unsigned char *)&c + v28 + 92) &= v29;
    if (v30) {
      break;
    }
    v28 += 96;
    v2 += 16;
    if (v28 == 288)
    {
      uint64_t v31 = 0;
      goto LABEL_27;
    }
  }
  uint64_t v31 = 4294954385;
LABEL_27:
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v31;
}

void sub_1BBA096F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA0971C(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  uint64_t v4 = *(int *)(a1 + 276);
  int v5 = *(_DWORD *)(a1 + 408) + *(_DWORD *)(a1 + 400);
  int v6 = v4 - v5;
  int v7 = *(_DWORD *)(a1 + 280);
  int v8 = *(_DWORD *)(a1 + 412);
  int v9 = v8 + *(_DWORD *)(a1 + 404);
  int v30 = v7 - v9;
  int v10 = v7 - v8;
  uint64_t v11 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v12 = *(int *)(a1 + 404);
  if ((int)v12 < v10)
  {
    uint64_t v13 = v11 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v13 + *(void *)(a1 + 112) * v12++), 1uLL, v4 - v5, a2);
    while (v12 < v10);
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v28 = *(int *)(a1 + 400);
  uint64_t v29 = v14;
  uint64_t v27 = *(int *)(a1 + 404);
  uint64_t v15 = *(void *)(a1 + 120);
  uint64_t v16 = v30 * (uint64_t)v6;
  uint64_t v17 = (char *)operator new[](2 * (int)v16, MEMORY[0x1E4FBA2D0]);
  if (!v17) {
    return 4294954392;
  }
  int v18 = v17;
  if (v7 != v9)
  {
    uint64_t v19 = v30;
    uint64_t v20 = &v17[v16];
    uint64_t v21 = v29 + ~(2 * v5) + v15 * v27 + 2 * v4 + 2 * v28;
    CFAllocatorRef v22 = v17;
    do
    {
      if (v4 != v5)
      {
        OSStatus v23 = (char *)v21;
        uint64_t v24 = v6;
        do
        {
          v22[v24 - 1] = *(v23 - 1);
          char v25 = *v23;
          v23 -= 2;
          v20[--v24] = v25;
        }
        while (v24);
      }
      v22 += v6;
      v20 += v6;
      v21 += v15;
      --v19;
    }
    while (v19);
  }
  fwrite(v17, 1uLL, 2 * (int)v16, a2);
  MEMORY[0x1C18605A0](v18, 0x1000C8077774924);
  return 0;
}

uint64_t sub_1BBA09938(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  uint64_t v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    uint64_t v8 = v6 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + *(void *)(a1 + 112) * v7++), 1uLL, v4, a2);
    while (v7 < v5);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v5)
  {
    uint64_t v11 = v9 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + *(void *)(a1 + 120) * v10++), 1uLL, 2 * v4, a2);
    while (v10 < (int)v5);
  }
  return 0;
}

void *sub_1BBA09A78(void *result)
{
  result[53] = sub_1BBA0B1D4;
  result[54] = sub_1BBA0AFA0;
  result[55] = sub_1BBA0AC40;
  result[56] = sub_1BBA0A458;
  result[57] = sub_1BBA0A0A0;
  result[134] = sub_1BBA06D64;
  result[135] = sub_1BBA09F88;
  result[136] = sub_1BBA09AFC;
  return result;
}

_DWORD *sub_1BBA09AFC(int a1, int a2, int a3, int a4, int a5, int a6, int *a7)
{
  uint64_t v14 = (*(uint64_t (**)(int *, void))(*(void *)a7 + 32))(a7, 0);
  uint64_t v15 = *((void *)a7 + 14);
  uint64_t result = (_DWORD *)(*(uint64_t (**)(int *, uint64_t))(*(void *)a7 + 32))(a7, 1);
  uint64_t v79 = *((void *)a7 + 15);
  uint64_t v17 = v79 >> 1;
  if (a1 <= 2)
  {
    if (a2 <= 3) {
      uint64_t v18 = 3;
    }
    else {
      uint64_t v18 = a2;
    }
    int v19 = a7[70];
    LODWORD(v20) = a2 + a6 + 4;
    if ((int)v20 >= v19) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = v20;
    }
    if ((int)v18 - 3 < (int)v20)
    {
      uint64_t v21 = v18 - 3;
      uint64_t v22 = v14 + 2 * v15 * v21 - 2;
      do
      {
        __int16 v23 = *(_WORD *)(v14 + 2 * v15 * v21);
        uint64_t v24 = (_WORD *)v22;
        uint64_t v25 = (3 - a1);
        do
        {
          *v24-- = v23;
          --v25;
        }
        while (v25);
        ++v21;
        v22 += 2 * v15;
      }
      while (v21 != v20);
    }
    if (a4 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = a4;
    }
    int v27 = a4 + a6 + 2;
    if (v27 >= v19) {
      int v28 = v19;
    }
    else {
      int v28 = a4 + a6 + 2;
    }
    if ((int)v26 <= v28)
    {
      uint64_t v29 = v26 - 1;
      uint64_t v30 = (uint64_t)&result[v17 * v29 - 1];
      do
      {
        if (a3 <= 0)
        {
          int v31 = result[v17 * v29];
          uint64_t v32 = (_DWORD *)v30;
          uint64_t v33 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v32-- = v31;
            --v33;
          }
          while (v33);
          int v19 = a7[70];
        }
        ++v29;
        if (v27 >= v19) {
          int v34 = v19;
        }
        else {
          int v34 = a4 + a6 + 2;
        }
        v30 += 4 * v17;
      }
      while (v29 < v34);
    }
  }
  int v35 = a1 + a5 + 4;
  uint64_t v36 = a7[69];
  if (v35 > (int)v36)
  {
    if (a2 <= 3) {
      uint64_t v37 = 3;
    }
    else {
      uint64_t v37 = a2;
    }
    int v38 = a7[70];
    LODWORD(v39) = a2 + a6 + 4;
    if ((int)v39 >= v38) {
      uint64_t v39 = v38;
    }
    else {
      uint64_t v39 = v39;
    }
    if ((int)v37 - 3 < (int)v39)
    {
      uint64_t v40 = v37 - 3;
      uint64_t v41 = 2 * v15 * v40 + 2 * (v36 - 1) + v14 + 2;
      do
      {
        if (v35 != v36)
        {
          __int16 v42 = *(_WORD *)(v14 + 2 * (v36 - 1 + v15 * v40));
          int v43 = (_WORD *)v41;
          uint64_t v44 = v35 - (int)v36;
          do
          {
            *v43++ = v42;
            --v44;
          }
          while (v44);
        }
        ++v40;
        v41 += 2 * v15;
      }
      while (v40 != v39);
    }
    if (a4 <= 1) {
      uint64_t v45 = 1;
    }
    else {
      uint64_t v45 = a4;
    }
    int v46 = a4 + a6 + 2;
    if (v46 >= v38) {
      int v47 = v38;
    }
    else {
      int v47 = a4 + a6 + 2;
    }
    if ((int)v45 <= v47)
    {
      uint64_t v48 = (int)v36 - 2;
      uint64_t v49 = (char *)result + 2 * v48;
      int v50 = a3 + (a5 >> 1) - ((int)v36 >> 1) + 2;
      uint64_t v51 = v45 - 1;
      uint64_t v52 = (uint64_t)&result[v17 * v51 + 1] + 2 * v48;
      do
      {
        if (v50 >= 1)
        {
          int v53 = *(_DWORD *)&v49[4 * v17 * v51];
          int v54 = (_DWORD *)v52;
          uint64_t v55 = v50 & ~(v50 >> 31);
          do
          {
            *v54++ = v53;
            --v55;
          }
          while (v55);
          int v38 = a7[70];
        }
        ++v51;
        if (v46 >= v38) {
          int v56 = v38;
        }
        else {
          int v56 = a4 + a6 + 2;
        }
        v52 += 4 * v17;
      }
      while (v51 < v56);
    }
  }
  int v78 = result;
  int v81 = a5;
  int v57 = a6;
  uint64_t v80 = v14 + 2 * a1;
  int v58 = a2;
  if (a2 <= 2)
  {
    int v59 = a2 - 3;
    uint64_t v60 = (char *)(v80 - 6);
    do
    {
      uint64_t v61 = &v60[-2 * v15];
      uint64_t result = memcpy(v61, v60, 2 * (v81 + 7));
      uint64_t v60 = v61;
      BOOL v62 = __CFADD__(v59++, 1);
    }
    while (!v62);
    if (a4 <= 0)
    {
      int v63 = a4 - 1;
      uint64_t v64 = (char *)&v78[a3 - 1];
      do
      {
        uint32x2_t v65 = &v64[-2 * v79];
        uint64_t result = memcpy(v65, v64, 2 * (int)((v81 & 0xFFFFFFFE) + 6));
        uint64_t v64 = v65;
        BOOL v62 = __CFADD__(v63++, 1);
      }
      while (!v62);
    }
  }
  uint64_t v66 = a7[70];
  if (a2 + v57 + 4 > (int)v66)
  {
    int v67 = a4;
    int v68 = v57 + v58 - v66 + 4;
    uint64_t v69 = 2 * v15 * (v66 - 1);
    uint64_t v70 = v80 - 6;
    uint64_t v71 = 2 * v15;
    uint64_t v72 = v15 * (2 * (v66 - 1) + 2);
    do
    {
      uint64_t result = memcpy((void *)(v70 + v72), (const void *)(v70 + v69), 2 * (v81 + 7));
      v70 += v71;
      --v68;
    }
    while (v68);
    uint64_t v73 = a7[70];
    if ((int)v73 < v67 + v57 + 2)
    {
      int v74 = v57 + v67 - v73 + 2;
      uint64_t v75 = 2 * v79 * (v73 - 1);
      int v76 = &v78[a3 - 1];
      uint64_t v77 = v79 * (2 * (v73 - 1) + 2);
      do
      {
        uint64_t result = memcpy((char *)v76 + v77, (char *)v76 + v75, 2 * (int)((v81 & 0xFFFFFFFE) + 6));
        int v76 = (_DWORD *)((char *)v76 + 2 * v79);
        --v74;
      }
      while (v74);
    }
  }
  return result;
}

int *sub_1BBA09F88(int *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10 = (int)result;
  if (a5)
  {
    uint64_t v11 = (a3 + result - *(_DWORD *)(a6 + 276) / 2);
    if ((int)v11 >= 1)
    {
      uint64_t v12 = (int *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (*(_DWORD *)(a6 + 276) / 2 - 1), (a2 - 1), 1);
      int v14 = *v12;
      uint64_t result = v12 + 1;
      int v13 = v14;
      do
      {
        *result++ = v13;
        --v11;
      }
      while (v11);
    }
  }
  if (a4)
  {
    int v15 = *(_DWORD *)(a6 + 280);
    uint64_t v16 = (a3 + a2 - v15);
    if ((int)v16 >= 1)
    {
      uint64_t v17 = *(void *)(a6 + 120);
      uint64_t result = (int *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (v10 - 1), (v15 - 1), 1);
      int v18 = *result;
      unint64_t v19 = (2 * v17) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v20 = (int *)((char *)result + v19);
      do
      {
        *uint64_t v20 = v18;
        uint64_t v20 = (_DWORD *)((char *)v20 + v19);
        --v16;
      }
      while (v16);
    }
  }
  return result;
}

uint64_t *sub_1BBA0A0A0(int *a1, int *a2, uint64_t a3)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  uint64_t v67 = 0;
  memset(v66, 0, sizeof(v66));
  uint64_t v6 = (a2[69] - (a2[100] + a2[102]));
  int v7 = a2[70] - (a2[101] + a2[103]);
  uint64_t v8 = *((void *)a2 + 14);
  uint64_t v9 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v10 = a2[100];
  uint64_t v11 = a2[101];
  uint64_t v12 = *((void *)a1 + 14);
  uint64_t v13 = (*(uint64_t (**)(int *, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v14 = 0;
  uint64_t v15 = v13 + 2 * a1[100];
  uint64_t v16 = 2 * a1[101];
  uint64_t v17 = v9 + 2 * v10;
  do
  {
    int v18 = v7 * (int)v14 / 3;
    uint64_t v19 = v14 + 1;
    int v20 = v7 * ((int)v14 + 1) / 3;
    if (v18 < v20)
    {
      uint64_t v21 = (uint64_t *)v66 + 3 * v14;
      uint64_t v22 = v18;
      __int16 v23 = (unsigned __int16 *)(v15 + v12 * (v16 + 2 * v18));
      uint64_t v24 = (unsigned __int16 *)(v17 + v8 * (2 * v11 + 2 * v18));
      do
      {
        if ((int)v6 >= 1)
        {
          uint64_t v25 = *v21;
          uint64_t v26 = v24;
          int v27 = v23;
          uint64_t v28 = v6;
          do
          {
            int v30 = *v26++;
            int v29 = v30;
            int v31 = *v27++;
            v25 += ((v29 - v31) * (v29 - v31));
            --v28;
          }
          while (v28);
          *uint64_t v21 = v25;
        }
        ++v22;
        v23 += v12;
        v24 += v8;
      }
      while (v22 != v20);
    }
    uint64_t v14 = v19;
  }
  while (v19 != 3);
  if ((int)v6 >= 0) {
    int v32 = v6;
  }
  else {
    int v32 = v6 + 1;
  }
  uint64_t v33 = (v32 >> 1);
  uint64_t v34 = *((void *)a1 + 15);
  uint64_t v35 = *((void *)a2 + 15);
  uint64_t v36 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v37 = a2[100];
  uint64_t v38 = a2[101];
  uint64_t v39 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v40 = 0;
  uint64_t v41 = v39 + 2 * a1[100] + 2;
  uint64_t v42 = 2 * a1[101];
  uint64_t v43 = v36 + 2 * v37 + 2;
  uint64_t v44 = 2 * v38;
  do
  {
    int v45 = v7 * (int)v40 / 3;
    uint64_t v46 = v40 + 1;
    uint64_t result = (uint64_t *)((unint64_t)(1431655766 * v7 * ((int)v40 + 1)) >> 32);
    int v48 = v7 * ((int)v40 + 1) / 3;
    if (v45 < v48)
    {
      uint64_t v49 = (char *)v66 + 24 * v40;
      uint64_t result = (uint64_t *)(v49 + 8);
      int v50 = (uint64_t *)(v49 + 16);
      uint64_t v51 = v45;
      uint64_t v52 = (unsigned __int16 *)(v41 + v34 * (v42 + 2 * v45));
      int v53 = (unsigned __int16 *)(v43 + v35 * (v44 + 2 * v45));
      do
      {
        if ((int)v6 >= 2)
        {
          uint64_t v54 = *result;
          uint64_t v55 = *v50;
          int v56 = v53;
          int v57 = v52;
          uint64_t v58 = v33;
          do
          {
            int v59 = *(v56 - 1) - *(v57 - 1);
            int v61 = *v56;
            v56 += 2;
            int v60 = v61;
            int v62 = *v57;
            v57 += 2;
            v54 += (v59 * v59);
            v55 += ((v60 - v62) * (v60 - v62));
            --v58;
          }
          while (v58);
          *uint64_t result = v54;
          *int v50 = v55;
        }
        ++v51;
        v52 += v34;
        v53 += v35;
      }
      while (v51 != v48);
    }
    uint64_t v40 = v46;
  }
  while (v46 != 3);
  uint64_t v63 = 0;
  uint64_t v64 = v66;
  do
  {
    for (uint64_t i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(void *)((char *)v64 + i));
    ++v63;
    a3 += 24;
    uint64_t v64 = (_OWORD *)((char *)v64 + 24);
  }
  while (v63 != 3);
  return result;
}

uint64_t sub_1BBA0A458(uint64_t a1, int *a2, double *a3, int a4)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  double v8 = sub_1BBA12160((uint64_t)v96);
  v96[0] = &unk_1F14EE0C0;
  uint64_t v105 = 0;
  int v106 = 0;
  uint64_t v107 = 0;
  char v108 = 0;
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v9 = (__CVBuffer *)(*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 96))(a1, v8);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v9);
  int v11 = a2[69];
  int v88 = a2[100];
  int v12 = a2[70];
  int v85 = a2[101];
  int v86 = a2[102];
  int v84 = a2[103];
  uint64_t v13 = *((void *)a2 + 14);
  uint64_t v14 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  signed int v15 = CVPixelBufferGetPixelFormatType(v14);
  char v16 = 0;
  int v82 = v12;
  int v83 = v11;
  if (v15 <= 2016687155)
  {
    BOOL v17 = v15 == 1278226736;
    int v18 = 2016686640;
  }
  else
  {
    BOOL v17 = v15 == 2016687156 || v15 == 2019963956;
    int v18 = 2019963440;
  }
  if (v17 || v15 == v18) {
    char v16 = 16 - sub_1BBA13A1C(v15);
  }
  uint64_t v20 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v21 = a2[100];
  uint64_t v22 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    uint64_t v80 = v13;
    int v81 = a4;
    CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    OSStatus v24 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
    if (v24)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v24;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", buf, 8u);
      }
      goto LABEL_49;
    }
    size_t Width = CVPixelBufferGetWidth(v9);
    size_t Height = CVPixelBufferGetHeight(v9);
    *(void *)CMSampleTimingInfo buf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, (const void *)*MEMORY[0x1E4F24D20], Mutable);
    int v31 = a3;
    DescriptionWithOSType PixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    CFNumberRef Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E4F24E50]);
    if (sub_1BBA13A1C(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F24E60]))
    {
      a3 = v31;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v93 = 0;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        uint32_t v77 = 2;
        goto LABEL_78;
      }
      goto LABEL_38;
    }
    CVReturn v34 = CVPixelBufferCreate(v23, Width, Height, 0x34323076u, *(CFDictionaryRef *)buf, &pixelBufferOut);
    a3 = v31;
    if (v34)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v93 = 67109120;
        CVReturn v94 = v34;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_75:
        uint32_t v77 = 8;
LABEL_78:
        _os_log_error_impl(&dword_1BB9B9000, v35, OS_LOG_TYPE_ERROR, v36, v93, v77);
        goto LABEL_38;
      }
      goto LABEL_38;
    }
    OSStatus v76 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v9, pixelBufferOut);
    if (v76)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v93 = 67109120;
        CVReturn v94 = v76;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_75;
      }
LABEL_38:
      sub_1BB9BE228((const void **)&Mutable);
      sub_1BB9BE228((const void **)buf);
LABEL_49:
      unint64_t v39 = 0;
      goto LABEL_50;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1BBA133CC((uint64_t)v96, pixelBufferOut, 0);
    sub_1BB9BE228((const void **)&Mutable);
    sub_1BB9BE228((const void **)buf);
    a3 = v31;
    a4 = v81;
    uint64_t v13 = v80;
  }
  else
  {
    sub_1BBA133CC((uint64_t)v96, v9, 0);
  }
  int v25 = v83 - (v88 + v86);
  uint64_t v26 = (v82 - (v85 + v84));
  uint64_t v27 = v20 + 2 * v21 + 2 * v13 * v22;
  uint64_t v28 = v97;
  if (a4)
  {
    uint64_t v29 = v102;
    if (v97 || !sub_1BBA13E0C((uint64_t)v96)) {
      uint64_t v30 = v99;
    }
    else {
      uint64_t v30 = 0;
    }
    if ((int)v26 < 1) {
      goto LABEL_49;
    }
    uint64_t v47 = 0;
    unint64_t v39 = 0;
    uint64_t v48 = v30 + 2 * v103 + 2 * v29 * v104;
    do
    {
      if (v25 >= 1)
      {
        uint64_t v49 = (unsigned __int16 *)v27;
        int v50 = (unsigned __int16 *)v48;
        uint64_t v51 = (v83 - (v88 + v86));
        do
        {
          int v53 = *v49++;
          int v52 = v53;
          int v54 = *v50++;
          v39 += ((v52 - v54) * (v52 - v54));
          --v51;
        }
        while (v51);
      }
      ++v47;
      v48 += 2 * v29;
      v27 += 2 * v13;
    }
    while (v47 != v26);
  }
  else
  {
    uint64_t v37 = v100;
    if (!v97)
    {
      if (sub_1BBA13E0C((uint64_t)v96)) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = v97;
      }
    }
    if ((int)v26 < 1)
    {
      CGSize v89 = a3;
      unint64_t v39 = 0;
      goto LABEL_57;
    }
    uint64_t v38 = 0;
    unint64_t v39 = 0;
    uint64_t v40 = v28 + 2 * v103 + 2 * v37 * v104;
    do
    {
      if (v25 >= 1)
      {
        uint64_t v41 = (unsigned __int16 *)v27;
        uint64_t v42 = (unsigned __int16 *)v40;
        uint64_t v43 = (v83 - (v88 + v86));
        do
        {
          unsigned int v45 = *v41++;
          unsigned int v44 = v45;
          unsigned int v46 = *v42++;
          v39 += ((v44 >> v16) - (v46 >> v16)) * ((v44 >> v16) - (v46 >> v16));
          --v43;
        }
        while (v43);
      }
      ++v38;
      v40 += 2 * v37;
      v27 += 2 * v13;
    }
    while (v38 != v26);
  }
  if (a4)
  {
LABEL_50:
    unint64_t v55 = 0;
    unint64_t v56 = 0;
    goto LABEL_51;
  }
  CGSize v89 = a3;
LABEL_57:
  if (v25 >= 0) {
    int v58 = v25;
  }
  else {
    int v58 = v25 + 1;
  }
  uint64_t v59 = v101;
  uint64_t v60 = *((void *)a2 + 15);
  uint64_t v87 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v61 = a2[100];
  uint64_t v62 = a2[101];
  if (v97 || !sub_1BBA13E0C((uint64_t)v96)) {
    uint64_t v63 = v98;
  }
  else {
    uint64_t v63 = 0;
  }
  if ((int)v26 < 1)
  {
    unint64_t v55 = 0;
    unint64_t v56 = 0;
    a3 = v89;
  }
  else
  {
    uint64_t v64 = 0;
    unint64_t v56 = 0;
    int v65 = v58;
    unint64_t v55 = 0;
    uint64_t v66 = 2 * v59 * v104 + 2 * v103 + v63 + 2;
    uint64_t v67 = 2 * v59;
    a3 = v89;
    uint64_t v68 = 2 * v60 * v62 + 2 * v61 + v87 + 2;
    do
    {
      if (v25 >= 2)
      {
        uint64_t v69 = (unsigned __int16 *)v68;
        uint64_t v70 = (unsigned __int16 *)v66;
        uint64_t v71 = (v65 >> 1);
        do
        {
          int v72 = (*(v69 - 1) >> v16) - (*(v70 - 1) >> v16);
          unsigned int v73 = *v69;
          v69 += 2;
          unsigned int v74 = v73 >> v16;
          unsigned int v75 = *v70;
          v70 += 2;
          v55 += (v72 * v72);
          v56 += (v74 - (v75 >> v16)) * (v74 - (v75 >> v16));
          --v71;
        }
        while (v71);
      }
      ++v64;
      v66 += v67;
      v68 += 2 * v60;
    }
    while (v64 != v26);
  }
LABEL_51:
  if (pixelBufferOut) {
    CVPixelBufferRelease(pixelBufferOut);
  }
  if (pixelTransferSessionOut) {
    CFRelease(pixelTransferSessionOut);
  }
  *a3 = (double)v39;
  a3[1] = (double)v55;
  a3[2] = (double)v56;
  return sub_1BBA141AC((uint64_t)v96);
}

void sub_1BBA0ABD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  int v11 = va_arg(va1, const void *);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  va_copy(va2, va1);
  BOOL v17 = va_arg(va2, const void *);
  uint64_t v19 = va_arg(va2, void);
  sub_1BB9BE228((const void **)va);
  sub_1BB9BE228((const void **)va1);
  sub_1BBA141AC((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1BBA0AC40(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned int v2 = a2;
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  memset(data, 0, sizeof(data));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  uint64_t v4 = *a1;
  if (*((unsigned char *)a1 + 136))
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 56))(a1, 0);
    uint64_t v6 = a1 + 22;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    double v8 = a1 + 21;
  }
  else
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 40))(a1, 0);
    uint64_t v6 = a1 + 15;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    double v8 = a1 + 14;
  }
  uint64_t v9 = 0;
  uint64_t v10 = *v6;
  uint64_t v11 = *v8;
  do
  {
    *((unsigned char *)&c + v9 + 92) = 1;
    *((unsigned char *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    unint64_t v12 = 0;
    uint64_t v13 = 2 * v11;
    do
    {
      char v14 = CC_MD5_Update(&c, v5, 2 * *((_DWORD *)a1 + 69));
      v40 &= v14;
      ++v12;
      int v15 = *((_DWORD *)a1 + 70);
      v5 += v13;
    }
    while (v12 < v15);
    uint64_t v16 = v15;
    if (v7)
    {
LABEL_10:
      int v17 = *((_DWORD *)a1 + 69);
      if (v17 >= 0) {
        int v18 = *((_DWORD *)a1 + 69);
      }
      else {
        int v18 = v17 + 1;
      }
      int v19 = v18 >> 1;
      int v20 = (v18 >> 1) * v15;
      CC_LONG v21 = 2 * v20;
      sub_1BBA07D38((char **)data, 2 * v20);
      uint64_t v22 = data[0];
      CFAllocatorRef v23 = (char *)data[0] + 2 * v20;
      if (v15)
      {
        uint64_t v24 = 2 * v19;
        uint64_t v25 = v7 + 4 * v19 - 2;
        uint64_t v26 = (char *)data[0];
        uint64_t v27 = v23;
        do
        {
          if ((v17 + 1) >= 3)
          {
            uint64_t v28 = (__int16 *)v25;
            uint64_t v29 = v19 - 1;
            do
            {
              *(_WORD *)&v26[2 * v29] = *(v28 - 1);
              __int16 v30 = *v28;
              v28 -= 2;
              *(_WORD *)&v27[2 * v29--] = v30;
            }
            while (v29 != -1);
          }
          v27 += v24;
          v26 += v24;
          v25 += 2 * v10;
          --v16;
        }
        while (v16);
      }
      char v31 = CC_MD5_Update(&v41, v22, v21);
      v42 &= v31;
      char v32 = CC_MD5_Update(&v43, v23, v21);
      v44 &= v32;
      goto LABEL_22;
    }
  }
  else
  {
    int v15 = 0;
    uint64_t v16 = 0;
    if (v7) {
      goto LABEL_10;
    }
  }
  uint64_t v22 = 0;
LABEL_22:
  uint64_t v33 = 0;
  while (1)
  {
    char v34 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v33));
    BOOL v35 = (v34 & *((unsigned char *)&c + v33 + 92)) == 0;
    *((unsigned char *)&c + v33 + 92) &= v34;
    if (v35) {
      break;
    }
    v33 += 96;
    v2 += 16;
    if (v33 == 288)
    {
      uint64_t v36 = 0;
      if (!v22) {
        return v36;
      }
      goto LABEL_28;
    }
  }
  uint64_t v36 = 4294954385;
  if (!v22) {
    return v36;
  }
LABEL_28:
  operator delete(v22);
  return v36;
}

void sub_1BBA0AF6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA0AFA0(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  int v5 = *(_DWORD *)(a1 + 280);
  int v6 = *(_DWORD *)(a1 + 412);
  int v7 = v5 - (*(_DWORD *)(a1 + 404) + v6);
  int v8 = v5 - v6;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < v8)
  {
    uint64_t v11 = v9 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + 2 * *(void *)(a1 + 112) * v10++), 1uLL, 2 * v4, a2);
    while (v10 < v8);
  }
  if (v4 >= 0) {
    int v12 = v4;
  }
  else {
    int v12 = v4 + 1;
  }
  int v13 = v12 >> 1;
  if (v7 >= 0) {
    int v14 = v7;
  }
  else {
    int v14 = v7 + 1;
  }
  int v15 = v14 >> 1;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v33 = *(int *)(a1 + 400);
  uint64_t v34 = v16;
  uint64_t v17 = *(int *)(a1 + 404);
  uint64_t v18 = *(void *)(a1 + 120);
  int v19 = 2 * v15 * v13;
  size_t v20 = 2 * v19;
  if (v15 * v13 < 0) {
    size_t v21 = -1;
  }
  else {
    size_t v21 = 2 * v19;
  }
  uint64_t v22 = (char *)operator new[](v21, MEMORY[0x1E4FBA2D0]);
  if (!v22) {
    return 4294954392;
  }
  CFAllocatorRef v23 = v22;
  if ((v7 + 1) >= 3)
  {
    uint64_t v24 = v15;
    uint64_t v25 = &v22[2 * v15 * v13];
    uint64_t v26 = 2 * v13;
    uint64_t v27 = 2 * v18 * v17 + 4 * v13 + 2 * v33 + v34 - 2;
    uint64_t v28 = v22;
    do
    {
      if ((v4 + 1) >= 3)
      {
        uint64_t v29 = (__int16 *)v27;
        uint64_t v30 = v13 - 1;
        do
        {
          *(_WORD *)&v28[2 * v30] = *(v29 - 1);
          __int16 v31 = *v29;
          v29 -= 2;
          *(_WORD *)&v25[2 * v30--] = v31;
        }
        while (v30 != -1);
      }
      v25 += v26;
      v28 += v26;
      v27 += 2 * v18;
      --v24;
    }
    while (v24);
  }
  fwrite(v22, 1uLL, v20, a2);
  MEMORY[0x1C18605A0](v23, 0x1000C80BDFB0063);
  return 0;
}

uint64_t sub_1BBA0B1D4(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  uint64_t v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    uint64_t v8 = v6 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + 2 * *(void *)(a1 + 112) * v7++), 1uLL, 2 * v4, a2);
    while (v7 < v5);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v5)
  {
    uint64_t v11 = v9 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + 2 * *(void *)(a1 + 120) * v10++), 1uLL, 2 * (v4 & 0x3FFFFFFFFFFFFFFFLL), a2);
    while (v10 < (int)v5);
  }
  return 0;
}

void *sub_1BBA0B320(void *result)
{
  result[53] = sub_1BBA0C9D4;
  result[54] = sub_1BBA0C7B4;
  result[55] = sub_1BBA0C470;
  result[56] = sub_1BBA0BCC4;
  result[57] = sub_1BBA0B934;
  result[134] = sub_1BBA087E0;
  result[135] = sub_1BBA0B820;
  result[136] = sub_1BBA0B3A4;
  return result;
}

uint64_t sub_1BBA0B3A4(int a1, int a2, int a3, int a4, int a5, int a6, void *a7)
{
  uint64_t v12 = (*(uint64_t (**)(void *, void))(*a7 + 32))(a7, 0);
  uint64_t v13 = a7[14];
  uint64_t result = (*(uint64_t (**)(void *, uint64_t))(*a7 + 32))(a7, 1);
  uint64_t v15 = result;
  uint64_t v16 = a7[15];
  uint64_t v17 = v16;
  int v80 = a6;
  uint64_t v77 = result;
  if (a1 <= 2)
  {
    uint64_t v78 = v12;
    if (a2 <= 3) {
      uint64_t v18 = 3;
    }
    else {
      uint64_t v18 = a2;
    }
    int v19 = a2 + a6 + 4;
    LODWORD(v20) = *((_DWORD *)a7 + 70);
    if (v19 >= (int)v20) {
      int v21 = *((_DWORD *)a7 + 70);
    }
    else {
      int v21 = a2 + a6 + 4;
    }
    if ((int)v18 - 3 < v21)
    {
      int v22 = a1;
      size_t v23 = (3 - a1);
      uint64_t v24 = v18 - 3;
      int v75 = v22;
      uint64_t v25 = (unsigned __int8 *)(v78 + v13 * (v18 - 3));
      uint64_t v26 = v22 - 3;
      do
      {
        uint64_t result = (uint64_t)memset(&v25[v26], *v25, v23);
        LODWORD(v20) = *((_DWORD *)a7 + 70);
        ++v24;
        if (v19 >= (int)v20) {
          int v27 = *((_DWORD *)a7 + 70);
        }
        else {
          int v27 = v19;
        }
        v25 += v13;
      }
      while (v24 < v27);
      uint64_t v17 = a7[15];
      a6 = v80;
      a1 = v75;
      uint64_t v15 = v77;
    }
    if (a4 <= 1) {
      uint64_t v28 = 1;
    }
    else {
      uint64_t v28 = a4;
    }
    int v29 = a4 + a6 + 2;
    if (v29 >= (int)v20) {
      uint64_t v20 = v20;
    }
    else {
      uint64_t v20 = v29;
    }
    if ((int)v28 <= (int)v20)
    {
      uint64_t v30 = v28 - 1;
      uint64_t v31 = v15 + 2 * (v17 >> 1) * v30 - 2;
      uint64_t v12 = v78;
      do
      {
        if (a3 <= 0)
        {
          __int16 v32 = *(_WORD *)(v15 + 2 * (v17 >> 1) * v30);
          uint64_t v33 = (_WORD *)v31;
          uint64_t v34 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v33-- = v32;
            --v34;
          }
          while (v34);
        }
        ++v30;
        v31 += 2 * (v17 >> 1);
      }
      while (v30 != v20);
    }
    else
    {
      uint64_t v12 = v78;
    }
  }
  int v35 = a1 + a5 + 4;
  int v36 = *((_DWORD *)a7 + 69);
  int v37 = v35 - v36;
  if (v35 > v36)
  {
    if (a2 <= 3) {
      uint64_t v38 = 3;
    }
    else {
      uint64_t v38 = a2;
    }
    int v39 = a2 + a6 + 4;
    LODWORD(v40) = *((_DWORD *)a7 + 70);
    if (v39 >= (int)v40) {
      int v41 = *((_DWORD *)a7 + 70);
    }
    else {
      int v41 = a2 + a6 + 4;
    }
    if ((int)v38 - 3 < v41)
    {
      int v76 = a1;
      uint64_t v42 = v38 - 3;
      size_t v43 = v37;
      uint64_t v79 = v12;
      char v44 = (char *)(v36 + v13 * (v38 - 3) + v12);
      do
      {
        uint64_t result = (uint64_t)memset(v44, *(v44 - 1), v43);
        ++v42;
        LODWORD(v40) = *((_DWORD *)a7 + 70);
        if (v39 >= (int)v40) {
          int v45 = *((_DWORD *)a7 + 70);
        }
        else {
          int v45 = v39;
        }
        v44 += v13;
      }
      while (v42 < v45);
      int v36 = *((_DWORD *)a7 + 69);
      uint64_t v17 = a7[15];
      a6 = v80;
      a1 = v76;
      uint64_t v12 = v79;
    }
    if (a4 <= 1) {
      uint64_t v46 = 1;
    }
    else {
      uint64_t v46 = a4;
    }
    int v47 = a4 + a6 + 2;
    if (v47 >= (int)v40) {
      uint64_t v40 = v40;
    }
    else {
      uint64_t v40 = v47;
    }
    if ((int)v46 <= (int)v40)
    {
      uint64_t v48 = v36 - 2;
      uint64_t v49 = v15 + v48;
      uint64_t v50 = v17 >> 1;
      int v51 = a3 + (a5 >> 1) - (v36 >> 1) + 2;
      uint64_t v52 = v46 - 1;
      uint64_t v53 = v48 + 2 * v50 * v52 + v15 + 2;
      do
      {
        if (v51 >= 1)
        {
          __int16 v54 = *(_WORD *)(v49 + 2 * v50 * v52);
          unint64_t v55 = (_WORD *)v53;
          uint64_t result = v51 & ~(v51 >> 31);
          do
          {
            *v55++ = v54;
            --result;
          }
          while (result);
        }
        ++v52;
        v53 += 2 * v50;
      }
      while (v52 != v40);
    }
  }
  uint64_t v56 = v12 + a1;
  if (a2 <= 2)
  {
    int v57 = a2 - 3;
    int v58 = (char *)(v56 - 3);
    do
    {
      uint64_t v59 = &v58[-v13];
      uint64_t result = (uint64_t)memcpy(&v58[-v13], v58, a5 + 7);
      int v58 = v59;
      BOOL v60 = __CFADD__(v57++, 1);
    }
    while (!v60);
    if (a4 <= 0)
    {
      int v61 = a4 - 1;
      uint64_t v62 = (char *)(v77 + 2 * a3 - 2);
      do
      {
        uint64_t v63 = &v62[-v16];
        uint64_t result = (uint64_t)memcpy(&v62[-v16], v62, (int)((a5 & 0xFFFFFFFE) + 6));
        uint64_t v62 = v63;
        BOOL v60 = __CFADD__(v61++, 1);
      }
      while (!v60);
    }
  }
  uint64_t v64 = *((int *)a7 + 70);
  if (a2 + v80 + 4 > (int)v64)
  {
    uint64_t v65 = v13 * (v64 - 1);
    int v66 = v80 + a2 - v64 + 4;
    uint64_t v67 = v56 - 3;
    uint64_t v68 = v13 * v64;
    do
    {
      uint64_t result = (uint64_t)memcpy((void *)(v67 + v68), (const void *)(v67 + v65), a5 + 7);
      v67 += v13;
      --v66;
    }
    while (v66);
    uint64_t v69 = *((int *)a7 + 70);
    if ((int)v69 < a4 + v80 + 2)
    {
      uint64_t v70 = v16 * (v69 - 1);
      int v71 = 2 * a3 - 2;
      int v72 = v80 + a4 - v69 + 2;
      uint64_t v73 = v16 * v69;
      uint64_t v74 = v77 + v71;
      do
      {
        uint64_t result = (uint64_t)memcpy((void *)(v74 + v73), (const void *)(v74 + v70), (int)((a5 & 0xFFFFFFFE) + 6));
        v74 += v16;
        --v72;
      }
      while (v72);
    }
  }
  return result;
}

__int16 *sub_1BBA0B820(__int16 *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10 = (int)result;
  if (a5)
  {
    uint64_t v11 = (a3 + result - *(_DWORD *)(a6 + 276) / 2);
    if ((int)v11 >= 1)
    {
      uint64_t v12 = (__int16 *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (*(_DWORD *)(a6 + 276) / 2 - 1), (a2 - 1), 1);
      __int16 v14 = *v12;
      uint64_t result = v12 + 1;
      __int16 v13 = v14;
      do
      {
        *result++ = v13;
        --v11;
      }
      while (v11);
    }
  }
  if (a4)
  {
    int v15 = *(_DWORD *)(a6 + 280);
    uint64_t v16 = (a3 + a2 - v15);
    if ((int)v16 >= 1)
    {
      uint64_t v17 = *(void *)(a6 + 120);
      uint64_t result = (__int16 *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (v10 - 1), (v15 - 1), 1);
      __int16 v18 = *result;
      int v19 = (__int16 *)((char *)result + (v17 & 0xFFFFFFFFFFFFFFFELL));
      do
      {
        *int v19 = v18;
        int v19 = (_WORD *)((char *)v19 + (v17 & 0xFFFFFFFFFFFFFFFELL));
        --v16;
      }
      while (v16);
    }
  }
  return result;
}

uint64_t sub_1BBA0B934(int *a1, int *a2, uint64_t a3)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v59 = 0;
  memset(v58, 0, sizeof(v58));
  uint64_t v6 = (a2[69] - (a2[100] + a2[102]));
  int v7 = a2[70] - (a2[101] + a2[103]);
  uint64_t v8 = *((void *)a2 + 14);
  uint64_t v9 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v10 = a2[100];
  uint64_t v11 = a2[101];
  uint64_t v12 = *((void *)a1 + 14);
  uint64_t v13 = (*(uint64_t (**)(int *, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v14 = 0;
  uint64_t v15 = v13 + a1[100];
  uint64_t v16 = a1[101];
  do
  {
    int v17 = v7 * (int)v14 / 3;
    uint64_t v18 = v14 + 1;
    int v19 = v7 * ((int)v14 + 1) / 3;
    if (v17 < v19)
    {
      uint64_t v20 = (uint64_t *)v58 + 3 * v14;
      uint64_t v21 = v17;
      int v22 = (unsigned __int8 *)(v15 + v12 * (v16 + v17));
      size_t v23 = (unsigned __int8 *)(v9 + v10 + v8 * (v11 + v17));
      do
      {
        if ((int)v6 >= 1)
        {
          uint64_t v24 = *v20;
          uint64_t v25 = v23;
          uint64_t v26 = v22;
          uint64_t v27 = v6;
          do
          {
            int v29 = *v25++;
            int v28 = v29;
            int v30 = *v26++;
            v24 += ((v28 - v30) * (v28 - v30));
            --v27;
          }
          while (v27);
          *uint64_t v20 = v24;
        }
        ++v21;
        v22 += v12;
        v23 += v8;
      }
      while (v21 != v19);
    }
    uint64_t v14 = v18;
  }
  while (v18 != 3);
  if ((int)v6 >= 0) {
    int v31 = v6;
  }
  else {
    int v31 = v6 + 1;
  }
  uint64_t v32 = (v31 >> 1);
  uint64_t v33 = *((void *)a1 + 15);
  uint64_t v34 = *((void *)a2 + 15);
  uint64_t v35 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v36 = a2[100];
  uint64_t v37 = a2[101];
  uint64_t result = (*(uint64_t (**)(int *, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v39 = 0;
  uint64_t v40 = result + a1[100];
  uint64_t v41 = a1[101];
  do
  {
    int v42 = v7 * (int)v39 / 3;
    uint64_t v43 = v39 + 1;
    int v44 = v7 * ((int)v39 + 1) / 3;
    if (v42 < v44)
    {
      int v45 = (uint64x2_t *)((char *)v58 + 24 * v39 + 8);
      uint64_t v46 = v42;
      uint64_t result = v40 + v33 * (v41 + v42);
      int v47 = (unsigned __int8 *)(v35 + v36 + v34 * (v37 + v42));
      do
      {
        if ((int)v6 >= 2)
        {
          uint64x2_t v48 = *v45;
          uint64_t v49 = v47;
          uint64_t v50 = (unsigned __int8 *)result;
          uint64_t v51 = v32;
          do
          {
            v52.i32[0] = *v49;
            v52.i32[1] = v49[1];
            v53.i32[0] = *v50;
            v53.i32[1] = v50[1];
            int32x2_t v54 = vsub_s32(v52, v53);
            uint64x2_t v48 = vaddw_u32(v48, (uint32x2_t)vmul_s32(v54, v54));
            v50 += 2;
            v49 += 2;
            --v51;
          }
          while (v51);
          *int v45 = v48;
        }
        ++v46;
        result += v33;
        v47 += v34;
      }
      while (v46 != v44);
    }
    uint64_t v39 = v43;
  }
  while (v43 != 3);
  uint64_t v55 = 0;
  uint64_t v56 = v58;
  do
  {
    for (uint64_t i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(void *)((char *)v56 + i));
    ++v55;
    a3 += 24;
    uint64_t v56 = (_OWORD *)((char *)v56 + 24);
  }
  while (v55 != 3);
  return result;
}

uint64_t sub_1BBA0BCC4(uint64_t a1, int *a2, uint64_t a3, int a4)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  double v8 = sub_1BBA12160((uint64_t)v94);
  v94[0] = &unk_1F14EE0C0;
  uint64_t v103 = 0;
  int v104 = 0;
  uint64_t v105 = 0;
  char v106 = 0;
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v9 = (__CVBuffer *)(*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 96))(a1, v8);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v9);
  int v11 = a2[69];
  int v84 = a2[102];
  int v85 = a2[100];
  int v12 = a2[70];
  int v82 = a2[103];
  int v83 = a2[101];
  uint64_t v13 = *((void *)a2 + 14);
  uint64_t v14 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  signed int v15 = CVPixelBufferGetPixelFormatType(v14);
  unsigned int v16 = 0;
  int v81 = v12;
  if (v15 <= 2016687155)
  {
    BOOL v17 = v15 == 1278226736;
    int v18 = 2016686640;
  }
  else
  {
    BOOL v17 = v15 == 2016687156 || v15 == 2019963956;
    int v18 = 2019963440;
  }
  if (v17 || v15 == v18) {
    unsigned int v16 = 8 - sub_1BBA13A1C(v15);
  }
  uint64_t v80 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v20 = a2[100];
  uint64_t v21 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    int v78 = v11;
    int v79 = a4;
    CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    OSStatus v23 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
    if (v23)
    {
      BOOL v24 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      uint64x2_t v25 = 0uLL;
      if (v24)
      {
        LODWORD(theDict[0]) = 67109120;
        HIDWORD(theDict[0]) = v23;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", (uint8_t *)theDict, 8u);
        uint64x2_t v25 = 0uLL;
      }
      unint64_t v26 = 0;
      goto LABEL_67;
    }
    size_t Width = CVPixelBufferGetWidth(v9);
    size_t Height = CVPixelBufferGetHeight(v9);
    theDict[0] = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(theDict[0], (const void *)*MEMORY[0x1E4F24D20], Mutable);
    uint64_t v33 = a3;
    DescriptionWithOSType PixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    CFNumberRef Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E4F24E50]);
    if (sub_1BBA13A1C(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F24E60]))
    {
      a3 = v33;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CMSampleTimingInfo buf = 0;
        uint64_t v37 = MEMORY[0x1E4F14500];
        uint64_t v38 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        uint32_t v75 = 2;
        goto LABEL_78;
      }
      goto LABEL_39;
    }
    CVReturn v36 = CVPixelBufferCreate(v22, Width, Height, 0x34323076u, theDict[0], &pixelBufferOut);
    a3 = v33;
    if (v36)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        CVReturn v92 = v36;
        uint64_t v37 = MEMORY[0x1E4F14500];
        uint64_t v38 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_75:
        uint32_t v75 = 8;
LABEL_78:
        _os_log_error_impl(&dword_1BB9B9000, v37, OS_LOG_TYPE_ERROR, v38, buf, v75);
        goto LABEL_39;
      }
      goto LABEL_39;
    }
    OSStatus v74 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v9, pixelBufferOut);
    if (v74)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        CVReturn v92 = v74;
        uint64_t v37 = MEMORY[0x1E4F14500];
        uint64_t v38 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_75;
      }
LABEL_39:
      sub_1BB9BE228((const void **)&Mutable);
      sub_1BB9BE228((const void **)theDict);
LABEL_50:
      unint64_t v26 = 0;
      uint64x2_t v25 = 0uLL;
      goto LABEL_67;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1BBA133CC((uint64_t)v94, pixelBufferOut, 0);
    sub_1BB9BE228((const void **)&Mutable);
    sub_1BB9BE228((const void **)theDict);
    a3 = v33;
    int v11 = v78;
    a4 = v79;
  }
  else
  {
    sub_1BBA133CC((uint64_t)v94, v9, 0);
  }
  uint64_t v27 = (v11 - (v85 + v84));
  uint64_t v28 = (v81 - (v83 + v82));
  int v29 = (unsigned __int8 *)(v80 + v20 + v13 * v21);
  uint64_t v30 = v95;
  if (a4)
  {
    uint64_t v31 = v100;
    if (v95 || !sub_1BBA13E0C((uint64_t)v94)) {
      uint64_t v32 = v97;
    }
    else {
      uint64_t v32 = 0;
    }
    if ((int)v28 < 1) {
      goto LABEL_50;
    }
    uint64_t v48 = 0;
    unint64_t v26 = 0;
    uint64_t v49 = (unsigned __int8 *)(v32 + v101 + v31 * v102);
    do
    {
      if ((int)v27 >= 1)
      {
        uint64_t v50 = v29;
        uint64_t v51 = v49;
        uint64_t v52 = v27;
        do
        {
          int v54 = *v50++;
          int v53 = v54;
          int v55 = *v51++;
          v26 += ((v53 - v55) * (v53 - v55));
          --v52;
        }
        while (v52);
      }
      ++v48;
      v49 += v31;
      v29 += v13;
    }
    while (v48 != v28);
    goto LABEL_48;
  }
  uint64_t v39 = v98;
  if (!v95)
  {
    if (sub_1BBA13E0C((uint64_t)v94)) {
      uint64_t v30 = 0;
    }
    else {
      uint64_t v30 = v95;
    }
  }
  if ((int)v28 >= 1)
  {
    uint64_t v40 = 0;
    unint64_t v26 = 0;
    uint64_t v41 = (unsigned __int8 *)(v30 + v101 + v39 * v102);
    do
    {
      if ((int)v27 >= 1)
      {
        int v42 = v29;
        uint64_t v43 = v41;
        uint64_t v44 = v27;
        do
        {
          unsigned int v46 = *v42++;
          unsigned int v45 = v46;
          unsigned int v47 = *v43++;
          v26 += ((v45 >> v16) - (v47 >> v16)) * ((v45 >> v16) - (v47 >> v16));
          --v44;
        }
        while (v44);
      }
      ++v40;
      v41 += v39;
      v29 += v13;
    }
    while (v40 != v28);
LABEL_48:
    uint64x2_t v25 = 0uLL;
    if (a4) {
      goto LABEL_67;
    }
    goto LABEL_52;
  }
  unint64_t v26 = 0;
LABEL_52:
  uint64_t v86 = a3;
  if ((int)v27 >= 0) {
    int v56 = v27;
  }
  else {
    int v56 = v27 + 1;
  }
  uint64_t v57 = v99;
  uint64_t v58 = *((void *)a2 + 15);
  uint64_t v59 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v60 = a2[100];
  uint64_t v61 = a2[101];
  if (v95 || !sub_1BBA13E0C((uint64_t)v94)) {
    uint64_t v62 = v96;
  }
  else {
    uint64_t v62 = 0;
  }
  if ((int)v28 < 1)
  {
    uint64x2_t v25 = 0uLL;
    a3 = v86;
  }
  else
  {
    uint64_t v63 = 0;
    uint64_t v64 = (unsigned __int8 *)(v59 + v60 + v58 * v61);
    uint64_t v65 = (unsigned __int8 *)(v62 + v101 + v57 * v102);
    uint64x2_t v25 = 0uLL;
    uint32x2_t v66 = (uint32x2_t)vneg_s32(vdup_n_s32(v16));
    a3 = v86;
    do
    {
      if ((int)v27 >= 2)
      {
        uint64_t v67 = v64;
        uint64_t v68 = v65;
        uint64_t v69 = (v56 >> 1);
        do
        {
          v70.i32[0] = *v67;
          v70.i32[1] = v67[1];
          v71.i32[0] = *v68;
          v71.i32[1] = v68[1];
          int32x2_t v72 = vsub_s32((int32x2_t)vshl_u32(v70, v66), (int32x2_t)vshl_u32(v71, v66));
          uint64x2_t v25 = vaddw_u32(v25, (uint32x2_t)vmul_s32(v72, v72));
          v68 += 2;
          v67 += 2;
          --v69;
        }
        while (v69);
      }
      ++v63;
      v65 += v57;
      v64 += v58;
    }
    while (v63 != v28);
  }
LABEL_67:
  uint64x2_t v87 = v25;
  if (pixelBufferOut) {
    CVPixelBufferRelease(pixelBufferOut);
  }
  if (pixelTransferSessionOut) {
    CFRelease(pixelTransferSessionOut);
  }
  *(double *)a3 = (double)v26;
  *(float64x2_t *)(a3 + 8) = vcvtq_f64_u64(v87);
  return sub_1BBA141AC((uint64_t)v94);
}

void sub_1BBA0C400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  int v11 = va_arg(va1, const void *);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  va_copy(va2, va1);
  BOOL v17 = va_arg(va2, const void *);
  uint64_t v19 = va_arg(va2, void);
  sub_1BB9BE228((const void **)va);
  sub_1BB9BE228((const void **)va1);
  sub_1BBA141AC((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1BBA0C470(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned int v2 = a2;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  uint64_t v4 = *a1;
  if (*((unsigned char *)a1 + 136))
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 56))(a1, 0);
    uint64_t v6 = a1 + 22;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    double v8 = a1 + 21;
  }
  else
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 40))(a1, 0);
    uint64_t v6 = a1 + 15;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    double v8 = a1 + 14;
  }
  uint64_t v9 = 0;
  uint64_t v10 = *v6;
  uint64_t v11 = *v8;
  do
  {
    *((unsigned char *)&c + v9 + 92) = 1;
    *((unsigned char *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    for (unint64_t i = 0; i < v14; ++i)
    {
      char v13 = CC_MD5_Update(&c, v5, *((_DWORD *)a1 + 69));
      v37 &= v13;
      v5 += v11;
      int v14 = *((_DWORD *)a1 + 70);
    }
    uint64_t v15 = v14;
    if (!v7) {
      goto LABEL_25;
    }
LABEL_12:
    int v16 = *((_DWORD *)a1 + 69);
    if (v16 >= 0) {
      int v17 = *((_DWORD *)a1 + 69);
    }
    else {
      int v17 = v16 + 1;
    }
    uint64_t v18 = (v17 >> 1) * (uint64_t)v14;
    if (v18)
    {
      sub_1BB9C1970((unint64_t *)__p, 2 * (int)v18);
      uint64_t v19 = (char *)__p[0];
    }
    else
    {
      uint64_t v19 = 0;
    }
    uint64_t v20 = &v19[v18];
    if (v14)
    {
      uint64_t v21 = (uint64_t)v17 >> 1;
      uint64_t v22 = v7 + 2 * v21 - 1;
      OSStatus v23 = v19;
      BOOL v24 = &v19[v18];
      do
      {
        if ((v16 + 1) >= 3)
        {
          uint64x2_t v25 = (char *)v22;
          uint64_t v26 = (uint64_t)v17 >> 1;
          do
          {
            v23[v26 - 1] = *(v25 - 1);
            char v27 = *v25;
            v25 -= 2;
            v24[--v26] = v27;
          }
          while (v26);
        }
        v23 += v21;
        v24 += v21;
        v22 += v10;
        --v15;
      }
      while (v15);
    }
    char v28 = CC_MD5_Update(&v38, v19, v18);
    v39 &= v28;
    char v29 = CC_MD5_Update(&v40, v20, v18);
    v41 &= v29;
    goto LABEL_25;
  }
  int v14 = 0;
  uint64_t v15 = 0;
  if (v7) {
    goto LABEL_12;
  }
LABEL_25:
  uint64_t v30 = 0;
  while (1)
  {
    char v31 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v30));
    BOOL v32 = (v31 & *((unsigned char *)&c + v30 + 92)) == 0;
    *((unsigned char *)&c + v30 + 92) &= v31;
    if (v32) {
      break;
    }
    v30 += 96;
    v2 += 16;
    if (v30 == 288)
    {
      uint64_t v33 = 0;
      goto LABEL_30;
    }
  }
  uint64_t v33 = 4294954385;
LABEL_30:
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v33;
}

void sub_1BBA0C790(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA0C7B4(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  int v5 = *(_DWORD *)(a1 + 280);
  int v6 = *(_DWORD *)(a1 + 412);
  int v7 = v5 - (*(_DWORD *)(a1 + 404) + v6);
  int v8 = v5 - v6;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < v8)
  {
    uint64_t v11 = v9 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + *(void *)(a1 + 112) * v10++), 1uLL, v4, a2);
    while (v10 < v8);
  }
  if (v4 >= 0) {
    int v12 = v4;
  }
  else {
    int v12 = v4 + 1;
  }
  if (v7 >= 0) {
    int v13 = v7;
  }
  else {
    int v13 = v7 + 1;
  }
  int v14 = v13 >> 1;
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v30 = *(int *)(a1 + 400);
  uint64_t v31 = v15;
  uint64_t v16 = *(int *)(a1 + 404);
  uint64_t v17 = *(void *)(a1 + 120);
  uint64_t v18 = v14 * (uint64_t)(v12 >> 1);
  uint64_t v19 = (char *)operator new[](2 * (int)v18, MEMORY[0x1E4FBA2D0]);
  if (!v19) {
    return 4294954392;
  }
  uint64_t v20 = v19;
  if ((v7 + 1) >= 3)
  {
    uint64_t v21 = (uint64_t)v12 >> 1;
    uint64_t v22 = v14;
    OSStatus v23 = &v19[v18];
    uint64_t v24 = v17 * v16 + 2 * v21 + v30 + v31 - 1;
    uint64x2_t v25 = v19;
    do
    {
      if ((v4 + 1) >= 3)
      {
        uint64_t v26 = (char *)v24;
        uint64_t v27 = (uint64_t)v12 >> 1;
        do
        {
          v25[v27 - 1] = *(v26 - 1);
          char v28 = *v26;
          v26 -= 2;
          v23[--v27] = v28;
        }
        while (v27);
      }
      v25 += v21;
      v23 += v21;
      v24 += v17;
      --v22;
    }
    while (v22);
  }
  fwrite(v19, 1uLL, 2 * (int)v18, a2);
  MEMORY[0x1C18605A0](v20, 0x1000C8077774924);
  return 0;
}

uint64_t sub_1BBA0C9D4(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  uint64_t v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    uint64_t v8 = v6 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + *(void *)(a1 + 112) * v7++), 1uLL, v4, a2);
    while (v7 < v5);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v5)
  {
    uint64_t v11 = v9 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + *(void *)(a1 + 120) * v10++), 1uLL, v4 & 0x7FFFFFFFFFFFFFFFLL, a2);
    while (v10 < (int)v5);
  }
  return 0;
}

void *sub_1BBA0CB18(void *result)
{
  result[53] = sub_1BBA0E2F8;
  result[54] = sub_1BBA0E0B8;
  result[55] = sub_1BBA0DD48;
  result[56] = sub_1BBA0D540;
  result[57] = sub_1BBA0D164;
  result[134] = sub_1BBA06D64;
  result[135] = sub_1BBA0D040;
  result[136] = sub_1BBA0CB9C;
  return result;
}

_DWORD *sub_1BBA0CB9C(int a1, int a2, int a3, int a4, int a5, int a6, int *a7)
{
  uint64_t v14 = (*(uint64_t (**)(int *, void))(*(void *)a7 + 32))(a7, 0);
  uint64_t v15 = *((void *)a7 + 14);
  uint64_t result = (_DWORD *)(*(uint64_t (**)(int *, uint64_t))(*(void *)a7 + 32))(a7, 1);
  uint64_t v78 = *((void *)a7 + 15);
  uint64_t v17 = v78 >> 1;
  if (a1 <= 2)
  {
    if (a2 <= 3) {
      uint64_t v18 = 3;
    }
    else {
      uint64_t v18 = a2;
    }
    int v19 = a7[70];
    LODWORD(v20) = a2 + a6 + 4;
    if ((int)v20 >= v19) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = v20;
    }
    if ((int)v18 - 3 < (int)v20)
    {
      uint64_t v21 = v18 - 3;
      uint64_t v22 = v14 + 2 * v15 * v21 - 2;
      do
      {
        __int16 v23 = *(_WORD *)(v14 + 2 * v15 * v21);
        uint64_t v24 = (_WORD *)v22;
        uint64_t v25 = (3 - a1);
        do
        {
          *v24-- = v23;
          --v25;
        }
        while (v25);
        ++v21;
        v22 += 2 * v15;
      }
      while (v21 != v20);
    }
    if (a4 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = a4;
    }
    int v27 = a4 + (a6 >> 1) + 2;
    int v28 = v19 >> 1;
    if (v27 < v19 >> 1) {
      int v28 = a4 + (a6 >> 1) + 2;
    }
    if ((int)v26 <= v28)
    {
      uint64_t v29 = v26 - 1;
      uint64_t v30 = (uint64_t)&result[v17 * v29 - 1];
      do
      {
        if (a3 <= 0)
        {
          int v31 = result[v17 * v29];
          BOOL v32 = (_DWORD *)v30;
          uint64_t v33 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v32-- = v31;
            --v33;
          }
          while (v33);
          int v19 = a7[70];
        }
        ++v29;
        int v34 = v19 >> 1;
        if (v27 < v19 >> 1) {
          int v34 = a4 + (a6 >> 1) + 2;
        }
        v30 += 4 * v17;
      }
      while (v29 < v34);
    }
  }
  int v35 = a1 + a5 + 4;
  uint64_t v36 = a7[69];
  if (v35 > (int)v36)
  {
    if (a2 <= 3) {
      uint64_t v37 = 3;
    }
    else {
      uint64_t v37 = a2;
    }
    int v38 = a7[70];
    LODWORD(v39) = a2 + a6 + 4;
    if ((int)v39 >= v38) {
      uint64_t v39 = v38;
    }
    else {
      uint64_t v39 = v39;
    }
    if ((int)v37 - 3 < (int)v39)
    {
      uint64_t v40 = v37 - 3;
      uint64_t v41 = 2 * v15 * v40 + 2 * (v36 - 1) + v14 + 2;
      do
      {
        if (v35 != v36)
        {
          __int16 v42 = *(_WORD *)(v14 + 2 * (v36 - 1 + v15 * v40));
          uint64_t v43 = (_WORD *)v41;
          uint64_t v44 = v35 - (int)v36;
          do
          {
            *v43++ = v42;
            --v44;
          }
          while (v44);
        }
        ++v40;
        v41 += 2 * v15;
      }
      while (v40 != v39);
    }
    if (a4 <= 1) {
      uint64_t v45 = 1;
    }
    else {
      uint64_t v45 = a4;
    }
    int v46 = a4 + (a6 >> 1) + 2;
    int v47 = v38 >> 1;
    if (v46 < v38 >> 1) {
      int v47 = a4 + (a6 >> 1) + 2;
    }
    if ((int)v45 <= v47)
    {
      uint64_t v48 = (int)v36 - 2;
      uint64_t v49 = (char *)result + 2 * v48;
      int v50 = a3 + (a5 >> 1) - ((int)v36 >> 1) + 2;
      uint64_t v51 = v45 - 1;
      uint64_t v52 = (uint64_t)&result[v17 * v51 + 1] + 2 * v48;
      do
      {
        if (v50 >= 1)
        {
          int v53 = *(_DWORD *)&v49[4 * v17 * v51];
          int v54 = (_DWORD *)v52;
          uint64_t v55 = v50 & ~(v50 >> 31);
          do
          {
            *v54++ = v53;
            --v55;
          }
          while (v55);
          int v38 = a7[70];
        }
        ++v51;
        int v56 = v38 >> 1;
        if (v46 < v38 >> 1) {
          int v56 = a4 + (a6 >> 1) + 2;
        }
        v52 += 4 * v17;
      }
      while (v51 < v56);
    }
  }
  uint64_t v77 = result;
  int v80 = a5;
  uint64_t v79 = v14 + 2 * a1;
  int v57 = a2;
  if (a2 <= 2)
  {
    int v58 = a2 - 3;
    uint64_t v59 = (char *)(v79 - 6);
    do
    {
      uint64_t v60 = &v59[-2 * v15];
      uint64_t result = memcpy(v60, v59, 2 * (v80 + 7));
      uint64_t v59 = v60;
      BOOL v61 = __CFADD__(v58++, 1);
    }
    while (!v61);
    if (a4 <= 0)
    {
      int v62 = a4 - 1;
      uint64_t v63 = (char *)&v77[a3 - 1];
      do
      {
        uint64_t v64 = &v63[-2 * v78];
        uint64_t result = memcpy(v64, v63, 2 * (int)((v80 & 0xFFFFFFFE) + 6));
        uint64_t v63 = v64;
        BOOL v61 = __CFADD__(v62++, 1);
      }
      while (!v61);
    }
  }
  uint64_t v65 = a7[70];
  if (v57 + a6 + 4 > (int)v65)
  {
    int v66 = a4;
    int v67 = v65 - v57 - 4;
    uint64_t v68 = 2 * v15 * (v65 - 1);
    uint64_t v69 = v79 - 6;
    uint64_t v70 = 2 * v15;
    uint64_t v71 = v15 * (2 * (v65 - 1) + 2);
    do
    {
      uint64_t result = memcpy((void *)(v69 + v71), (const void *)(v69 + v68), 2 * (v80 + 7));
      ++v67;
      v69 += v70;
    }
    while (a6 != v67);
    int v72 = a7[70] >> 1;
    if (v72 < v66 + (a6 >> 1) + 2)
    {
      int v73 = (a6 >> 1) + v66 - v72 + 2;
      uint64_t v74 = 2 * v78 * (v72 - 1);
      uint32_t v75 = &v77[a3 - 1];
      uint64_t v76 = 2 * v78 * v72;
      do
      {
        uint64_t result = memcpy((char *)v75 + v76, (char *)v75 + v74, 2 * (int)((v80 & 0xFFFFFFFE) + 6));
        uint32_t v75 = (_DWORD *)((char *)v75 + 2 * v78);
        --v73;
      }
      while (v73);
    }
  }
  return result;
}

int *sub_1BBA0D040(int *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10 = (int)result;
  if (a5)
  {
    uint64_t v11 = (a3 + result - *(_DWORD *)(a6 + 276) / 2);
    if ((int)v11 >= 1)
    {
      int v12 = (int *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (*(_DWORD *)(a6 + 276) / 2 - 1), (a2 - 1), 1);
      int v14 = *v12;
      uint64_t result = v12 + 1;
      int v13 = v14;
      do
      {
        *result++ = v13;
        --v11;
      }
      while (v11);
    }
  }
  if (a4)
  {
    uint64_t v15 = (a3 + a2 - *(_DWORD *)(a6 + 280) / 2);
    if ((int)v15 >= 1)
    {
      uint64_t v16 = *(void *)(a6 + 120);
      uint64_t result = (int *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (v10 - 1), (*(_DWORD *)(a6 + 280) / 2 - 1), 1);
      int v17 = *result;
      unint64_t v18 = (2 * v16) & 0xFFFFFFFFFFFFFFFCLL;
      int v19 = (int *)((char *)result + v18);
      do
      {
        *int v19 = v17;
        int v19 = (_DWORD *)((char *)v19 + v18);
        --v15;
      }
      while (v15);
    }
  }
  return result;
}

uint64_t *sub_1BBA0D164(int *a1, int *a2, uint64_t a3)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t v69 = 0;
  memset(v68, 0, sizeof(v68));
  uint64_t v6 = (a2[69] - (a2[100] + a2[102]));
  int v7 = a2[70] - (a2[101] + a2[103]);
  uint64_t v8 = *((void *)a2 + 14);
  uint64_t v9 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v10 = a2[100];
  uint64_t v11 = a2[101];
  uint64_t v12 = *((void *)a1 + 14);
  uint64_t v13 = (*(uint64_t (**)(int *, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v14 = 0;
  uint64_t v15 = v13 + 2 * a1[100];
  uint64_t v16 = 2 * a1[101];
  uint64_t v17 = v9 + 2 * v10;
  do
  {
    int v18 = v7 * (int)v14 / 3;
    uint64_t v19 = v14 + 1;
    int v20 = v7 * ((int)v14 + 1) / 3;
    if (v18 < v20)
    {
      uint64_t v21 = (uint64_t *)v68 + 3 * v14;
      uint64_t v22 = v18;
      __int16 v23 = (unsigned __int16 *)(v15 + v12 * (v16 + 2 * v18));
      uint64_t v24 = (unsigned __int16 *)(v17 + v8 * (2 * v11 + 2 * v18));
      do
      {
        if ((int)v6 >= 1)
        {
          uint64_t v25 = *v21;
          uint64_t v26 = v24;
          int v27 = v23;
          uint64_t v28 = v6;
          do
          {
            int v30 = *v26++;
            int v29 = v30;
            int v31 = *v27++;
            v25 += ((v29 - v31) * (v29 - v31));
            --v28;
          }
          while (v28);
          *uint64_t v21 = v25;
        }
        ++v22;
        v23 += v12;
        v24 += v8;
      }
      while (v22 != v20);
    }
    uint64_t v14 = v19;
  }
  while (v19 != 3);
  if ((int)v6 >= 0) {
    int v32 = v6;
  }
  else {
    int v32 = v6 + 1;
  }
  uint64_t v33 = (v32 >> 1);
  if (v7 >= 0) {
    int v34 = v7;
  }
  else {
    int v34 = v7 + 1;
  }
  int v35 = v34 >> 1;
  uint64_t v36 = *((void *)a1 + 15);
  uint64_t v37 = *((void *)a2 + 15);
  uint64_t v38 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v39 = a2[100];
  int v40 = a2[101] / 2;
  uint64_t v41 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v42 = 0;
  uint64_t v43 = v41 + 2 * a1[100] + 2;
  uint64_t v44 = 2 * (a1[101] / 2);
  uint64_t v45 = v38 + 2 * v39 + 2;
  uint64_t v46 = 2 * v40;
  do
  {
    int v47 = v35 * (int)v42 / 3;
    uint64_t v48 = v42 + 1;
    uint64_t result = (uint64_t *)((unint64_t)(1431655766 * v35 * ((int)v42 + 1)) >> 32);
    int v50 = v35 * ((int)v42 + 1) / 3;
    if (v47 < v50)
    {
      uint64_t v51 = (char *)v68 + 24 * v42;
      uint64_t result = (uint64_t *)(v51 + 8);
      uint64_t v52 = (uint64_t *)(v51 + 16);
      uint64_t v53 = v47;
      int v54 = (unsigned __int16 *)(v43 + v36 * (v44 + 2 * v47));
      uint64_t v55 = (unsigned __int16 *)(v45 + v37 * (v46 + 2 * v47));
      do
      {
        if ((int)v6 >= 2)
        {
          uint64_t v56 = *result;
          uint64_t v57 = *v52;
          int v58 = v55;
          uint64_t v59 = v54;
          uint64_t v60 = v33;
          do
          {
            int v61 = *(v58 - 1) - *(v59 - 1);
            int v63 = *v58;
            v58 += 2;
            int v62 = v63;
            int v64 = *v59;
            v59 += 2;
            v56 += (v61 * v61);
            v57 += ((v62 - v64) * (v62 - v64));
            --v60;
          }
          while (v60);
          *uint64_t result = v56;
          *uint64_t v52 = v57;
        }
        ++v53;
        v54 += v36;
        v55 += v37;
      }
      while (v53 != v50);
    }
    uint64_t v42 = v48;
  }
  while (v48 != 3);
  uint64_t v65 = 0;
  int v66 = v68;
  do
  {
    for (uint64_t i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(void *)((char *)v66 + i));
    ++v65;
    a3 += 24;
    int v66 = (_OWORD *)((char *)v66 + 24);
  }
  while (v65 != 3);
  return result;
}

uint64_t sub_1BBA0D540(uint64_t a1, int *a2, double *a3, int a4)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  double v8 = sub_1BBA12160((uint64_t)v99);
  v99[0] = &unk_1F14EE0C0;
  uint64_t v108 = 0;
  int v109 = 0;
  uint64_t v110 = 0;
  char v111 = 0;
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v9 = (__CVBuffer *)(*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 96))(a1, v8);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v9);
  int v11 = a2[69];
  int v89 = a2[102];
  int v91 = a2[100];
  int v12 = a2[70];
  int v86 = a2[103];
  int v87 = a2[101];
  uint64_t v13 = *((void *)a2 + 14);
  uint64_t v14 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  signed int v15 = CVPixelBufferGetPixelFormatType(v14);
  char v16 = 0;
  int v85 = v12;
  if (v15 <= 2016687155)
  {
    BOOL v17 = v15 == 1278226736;
    int v18 = 2016686640;
  }
  else
  {
    BOOL v17 = v15 == 2016687156 || v15 == 2019963956;
    int v18 = 2019963440;
  }
  if (v17 || v15 == v18) {
    char v16 = 16 - sub_1BBA13A1C(v15);
  }
  uint64_t v84 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v20 = a2[100];
  uint64_t v21 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    uint64_t v82 = v13;
    int v83 = a4;
    CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    OSStatus v23 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
    if (v23)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v23;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", buf, 8u);
      }
      goto LABEL_49;
    }
    size_t Width = CVPixelBufferGetWidth(v9);
    size_t Height = CVPixelBufferGetHeight(v9);
    *(void *)CMSampleTimingInfo buf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, (const void *)*MEMORY[0x1E4F24D20], Mutable);
    int v30 = a3;
    DescriptionWithOSType PixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    CFNumberRef Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E4F24E50]);
    if (sub_1BBA13A1C(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F24E60]))
    {
      a3 = v30;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v96 = 0;
        int v34 = MEMORY[0x1E4F14500];
        int v35 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        uint32_t v79 = 2;
        goto LABEL_87;
      }
      goto LABEL_38;
    }
    CVReturn v33 = CVPixelBufferCreate(v22, Width, Height, 0x34323076u, *(CFDictionaryRef *)buf, &pixelBufferOut);
    a3 = v30;
    if (v33)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v96 = 67109120;
        CVReturn v97 = v33;
        int v34 = MEMORY[0x1E4F14500];
        int v35 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_84:
        uint32_t v79 = 8;
LABEL_87:
        _os_log_error_impl(&dword_1BB9B9000, v34, OS_LOG_TYPE_ERROR, v35, v96, v79);
        goto LABEL_38;
      }
      goto LABEL_38;
    }
    OSStatus v78 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v9, pixelBufferOut);
    if (v78)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v96 = 67109120;
        CVReturn v97 = v78;
        int v34 = MEMORY[0x1E4F14500];
        int v35 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_84;
      }
LABEL_38:
      sub_1BB9BE228((const void **)&Mutable);
      sub_1BB9BE228((const void **)buf);
LABEL_49:
      unint64_t v38 = 0;
      goto LABEL_50;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1BBA133CC((uint64_t)v99, pixelBufferOut, 0);
    sub_1BB9BE228((const void **)&Mutable);
    sub_1BB9BE228((const void **)buf);
    a3 = v30;
    a4 = v83;
    uint64_t v13 = v82;
  }
  else
  {
    sub_1BBA133CC((uint64_t)v99, v9, 0);
  }
  uint64_t v24 = (v11 - (v91 + v89));
  uint64_t v25 = (v85 - (v87 + v86));
  uint64_t v26 = v84 + 2 * v20 + 2 * v13 * v21;
  uint64_t v27 = v100;
  if (a4)
  {
    uint64_t v28 = v105;
    if (v100 || !sub_1BBA13E0C((uint64_t)v99)) {
      uint64_t v29 = v102;
    }
    else {
      uint64_t v29 = 0;
    }
    if ((int)v25 < 1) {
      goto LABEL_49;
    }
    uint64_t v46 = 0;
    unint64_t v38 = 0;
    uint64_t v47 = v29 + 2 * v106 + 2 * v28 * v107;
    do
    {
      if ((int)v24 >= 1)
      {
        uint64_t v48 = (unsigned __int16 *)v26;
        uint64_t v49 = (unsigned __int16 *)v47;
        uint64_t v50 = v24;
        do
        {
          int v52 = *v48++;
          int v51 = v52;
          int v53 = *v49++;
          v38 += ((v51 - v53) * (v51 - v53));
          --v50;
        }
        while (v50);
      }
      ++v46;
      v47 += 2 * v28;
      v26 += 2 * v13;
    }
    while (v46 != v25);
  }
  else
  {
    uint64_t v36 = v103;
    if (!v100)
    {
      if (sub_1BBA13E0C((uint64_t)v99)) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = v100;
      }
    }
    if ((int)v25 < 1)
    {
      CVReturn v92 = a3;
      unint64_t v38 = 0;
      goto LABEL_57;
    }
    uint64_t v37 = 0;
    unint64_t v38 = 0;
    uint64_t v39 = v27 + 2 * v106 + 2 * v36 * v107;
    do
    {
      if ((int)v24 >= 1)
      {
        int v40 = (unsigned __int16 *)v26;
        uint64_t v41 = (unsigned __int16 *)v39;
        uint64_t v42 = v24;
        do
        {
          unsigned int v44 = *v40++;
          unsigned int v43 = v44;
          unsigned int v45 = *v41++;
          v38 += ((v43 >> v16) - (v45 >> v16)) * ((v43 >> v16) - (v45 >> v16));
          --v42;
        }
        while (v42);
      }
      ++v37;
      v39 += 2 * v36;
      v26 += 2 * v13;
    }
    while (v37 != v25);
  }
  if (a4)
  {
LABEL_50:
    unint64_t v54 = 0;
    unint64_t v55 = 0;
    goto LABEL_51;
  }
  CVReturn v92 = a3;
LABEL_57:
  if ((int)v24 >= 0) {
    int v57 = v24;
  }
  else {
    int v57 = v24 + 1;
  }
  if ((int)v25 >= 0) {
    int v58 = v85 - (v87 + v86);
  }
  else {
    int v58 = v25 + 1;
  }
  int v88 = v58;
  int v90 = v57;
  uint64_t v59 = v104;
  uint64_t v60 = *((void *)a2 + 15);
  uint64_t v61 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v62 = a2[100];
  int v63 = a2[101];
  if (v63 >= 0) {
    int v64 = a2[101];
  }
  else {
    int v64 = v63 + 1;
  }
  if (v100 || !sub_1BBA13E0C((uint64_t)v99)) {
    uint64_t v65 = v101;
  }
  else {
    uint64_t v65 = 0;
  }
  if (v107 >= 0) {
    int v66 = v107;
  }
  else {
    int v66 = v107 + 1;
  }
  if ((int)v25 < 2)
  {
    unint64_t v54 = 0;
    unint64_t v55 = 0;
    a3 = v92;
  }
  else
  {
    uint64_t v67 = 0;
    unint64_t v55 = 0;
    unint64_t v54 = 0;
    uint64_t v68 = 2 * v59 * ((uint64_t)v66 >> 1) + 2 * v106 + v65 + 2;
    uint64_t v69 = 2 * v59;
    uint64_t v70 = 2 * v60 * ((uint64_t)v64 >> 1) + 2 * v62 + v61 + 2;
    a3 = v92;
    do
    {
      if ((int)v24 >= 2)
      {
        uint64_t v71 = (unsigned __int16 *)v70;
        int v72 = (unsigned __int16 *)v68;
        uint64_t v73 = (v90 >> 1);
        do
        {
          int v74 = (*(v71 - 1) >> v16) - (*(v72 - 1) >> v16);
          unsigned int v75 = *v71;
          v71 += 2;
          unsigned int v76 = v75 >> v16;
          unsigned int v77 = *v72;
          v72 += 2;
          v54 += (v74 * v74);
          v55 += (v76 - (v77 >> v16)) * (v76 - (v77 >> v16));
          --v73;
        }
        while (v73);
      }
      ++v67;
      v68 += v69;
      v70 += 2 * v60;
    }
    while (v67 != v88 >> 1);
  }
LABEL_51:
  if (pixelBufferOut) {
    CVPixelBufferRelease(pixelBufferOut);
  }
  if (pixelTransferSessionOut) {
    CFRelease(pixelTransferSessionOut);
  }
  *a3 = (double)v38;
  a3[1] = (double)v54;
  a3[2] = (double)v55;
  return sub_1BBA141AC((uint64_t)v99);
}

void sub_1BBA0DCD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  int v11 = va_arg(va1, const void *);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  va_copy(va2, va1);
  BOOL v17 = va_arg(va2, const void *);
  uint64_t v19 = va_arg(va2, void);
  sub_1BB9BE228((const void **)va);
  sub_1BB9BE228((const void **)va1);
  sub_1BBA141AC((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1BBA0DD48(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned int v2 = a2;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  memset(data, 0, sizeof(data));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  uint64_t v4 = *a1;
  if (*((unsigned char *)a1 + 136))
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 56))(a1, 0);
    uint64_t v6 = a1 + 22;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    double v8 = a1 + 21;
  }
  else
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 40))(a1, 0);
    uint64_t v6 = a1 + 15;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    double v8 = a1 + 14;
  }
  uint64_t v9 = 0;
  uint64_t v10 = *v6;
  uint64_t v11 = *v8;
  do
  {
    *((unsigned char *)&c + v9 + 92) = 1;
    *((unsigned char *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    unint64_t v12 = 0;
    uint64_t v13 = 2 * v11;
    do
    {
      char v14 = CC_MD5_Update(&c, v5, 2 * *((_DWORD *)a1 + 69));
      v42 &= v14;
      ++v12;
      unint64_t v15 = *((int *)a1 + 70);
      v5 += v13;
    }
    while (v12 < v15);
    if (v7)
    {
LABEL_10:
      int v16 = *((_DWORD *)a1 + 69);
      if (v16 >= 0) {
        int v17 = *((_DWORD *)a1 + 69);
      }
      else {
        int v17 = v16 + 1;
      }
      int v18 = v17 >> 1;
      if ((v15 & 0x80000000) == 0) {
        int v19 = v15;
      }
      else {
        int v19 = v15 + 1;
      }
      int v20 = v19 >> 1;
      int v21 = v18 * (v19 >> 1);
      CC_LONG v22 = 2 * v21;
      sub_1BBA07D38((char **)data, 2 * v21);
      OSStatus v23 = data[0];
      uint64_t v24 = (char *)data[0] + 2 * v21;
      if ((v15 + 1) >= 3)
      {
        uint64_t v25 = v20;
        uint64_t v26 = 2 * v18;
        uint64_t v27 = v7 + 4 * v18 - 2;
        uint64_t v28 = (char *)data[0];
        uint64_t v29 = v24;
        do
        {
          if ((v16 + 1) >= 3)
          {
            int v30 = (__int16 *)v27;
            uint64_t v31 = v18 - 1;
            do
            {
              *(_WORD *)&v28[2 * v31] = *(v30 - 1);
              __int16 v32 = *v30;
              v30 -= 2;
              *(_WORD *)&v29[2 * v31--] = v32;
            }
            while (v31 != -1);
          }
          v29 += v26;
          v28 += v26;
          v27 += 2 * v10;
          --v25;
        }
        while (v25);
      }
      char v33 = CC_MD5_Update(&v43, v23, v22);
      v44 &= v33;
      char v34 = CC_MD5_Update(&v45, v24, v22);
      v46 &= v34;
      goto LABEL_25;
    }
  }
  else
  {
    LODWORD(v15) = 0;
    if (v7) {
      goto LABEL_10;
    }
  }
  OSStatus v23 = 0;
LABEL_25:
  uint64_t v35 = 0;
  while (1)
  {
    char v36 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v35));
    BOOL v37 = (v36 & *((unsigned char *)&c + v35 + 92)) == 0;
    *((unsigned char *)&c + v35 + 92) &= v36;
    if (v37) {
      break;
    }
    v35 += 96;
    v2 += 16;
    if (v35 == 288)
    {
      uint64_t v38 = 0;
      if (!v23) {
        return v38;
      }
      goto LABEL_31;
    }
  }
  uint64_t v38 = 4294954385;
  if (!v23) {
    return v38;
  }
LABEL_31:
  operator delete(v23);
  return v38;
}

void sub_1BBA0E084(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA0E0B8(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  int v5 = *(_DWORD *)(a1 + 280);
  int v6 = *(_DWORD *)(a1 + 412);
  int v7 = v5 - (*(_DWORD *)(a1 + 404) + v6);
  int v8 = v5 - v6;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < v8)
  {
    uint64_t v11 = v9 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + 2 * *(void *)(a1 + 112) * v10++), 1uLL, 2 * v4, a2);
    while (v10 < v8);
  }
  if (v4 >= 0) {
    int v12 = v4;
  }
  else {
    int v12 = v4 + 1;
  }
  int v13 = v12 >> 1;
  if (v7 >= 0) {
    int v14 = v7;
  }
  else {
    int v14 = v7 + 1;
  }
  int v15 = v14 >> 1;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v34 = *(int *)(a1 + 400);
  uint64_t v35 = v16;
  int v17 = *(_DWORD *)(a1 + 404);
  uint64_t v18 = *(void *)(a1 + 120);
  int v19 = 2 * v15 * v13;
  size_t v20 = 2 * v19;
  if (v15 * v13 < 0) {
    size_t v21 = -1;
  }
  else {
    size_t v21 = 2 * v19;
  }
  CC_LONG v22 = (char *)operator new[](v21, MEMORY[0x1E4FBA2D0]);
  if (!v22) {
    return 4294954392;
  }
  OSStatus v23 = v22;
  if ((v7 + 1) >= 3)
  {
    uint64_t v24 = v15;
    uint64_t v25 = &v22[2 * v15 * v13];
    if (v17 >= 0) {
      int v26 = v17;
    }
    else {
      int v26 = v17 + 1;
    }
    uint64_t v27 = 2 * v13;
    uint64_t v28 = 2 * v18 * ((uint64_t)v26 >> 1) + 4 * v13 + 2 * v34 + v35 - 2;
    uint64_t v29 = v22;
    do
    {
      if ((v4 + 1) >= 3)
      {
        int v30 = (__int16 *)v28;
        uint64_t v31 = v13 - 1;
        do
        {
          *(_WORD *)&v29[2 * v31] = *(v30 - 1);
          __int16 v32 = *v30;
          v30 -= 2;
          *(_WORD *)&v25[2 * v31--] = v32;
        }
        while (v31 != -1);
      }
      v25 += v27;
      v29 += v27;
      v28 += 2 * v18;
      --v24;
    }
    while (v24);
  }
  fwrite(v22, 1uLL, v20, a2);
  MEMORY[0x1C18605A0](v23, 0x1000C80BDFB0063);
  return 0;
}

uint64_t sub_1BBA0E2F8(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  uint64_t v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    uint64_t v8 = v6 + 2 * *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + 2 * *(void *)(a1 + 112) * v7++), 1uLL, 2 * v4, a2);
    while (v7 < v5);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  int v10 = *(_DWORD *)(a1 + 404) / 2;
  if ((int)v5 >= 0) {
    int v11 = v5;
  }
  else {
    int v11 = v5 + 1;
  }
  if (v10 < v11 >> 1)
  {
    uint64_t v12 = v9 + 2 * *(int *)(a1 + 400);
    int v13 = v11 >> 1;
    size_t v14 = 2 * (v4 & 0x3FFFFFFFFFFFFFFFLL);
    uint64_t v15 = v10;
    do
      fwrite((const void *)(v12 + 2 * *(void *)(a1 + 120) * v15++), 1uLL, v14, a2);
    while (v13 != v15);
  }
  return 0;
}

void *sub_1BBA0E45C(void *result)
{
  result[53] = sub_1BBA0FBB8;
  result[54] = sub_1BBA0F98C;
  result[55] = sub_1BBA0F638;
  result[56] = sub_1BBA0EE60;
  result[57] = sub_1BBA0EAAC;
  result[134] = sub_1BBA087E0;
  result[135] = sub_1BBA0E98C;
  result[136] = sub_1BBA0E4E0;
  return result;
}

uint64_t sub_1BBA0E4E0(int a1, int a2, int a3, int a4, int a5, int a6, int *a7)
{
  uint64_t v12 = (*(uint64_t (**)(int *, void))(*(void *)a7 + 32))(a7, 0);
  uint64_t v13 = *((void *)a7 + 14);
  uint64_t result = (*(uint64_t (**)(int *, uint64_t))(*(void *)a7 + 32))(a7, 1);
  uint64_t v15 = result;
  uint64_t v16 = *((void *)a7 + 15);
  uint64_t v17 = v16;
  int v82 = a2;
  uint64_t v79 = result;
  if (a1 <= 2)
  {
    uint64_t v80 = v12;
    if (a2 <= 3) {
      uint64_t v18 = 3;
    }
    else {
      uint64_t v18 = a2;
    }
    int v19 = a2 + a6 + 4;
    int v20 = a7[70];
    if (v19 >= v20) {
      int v21 = a7[70];
    }
    else {
      int v21 = a2 + a6 + 4;
    }
    if ((int)v18 - 3 < v21)
    {
      int v22 = a1;
      size_t v23 = (3 - a1);
      uint64_t v24 = v18 - 3;
      int v77 = v22;
      uint64_t v25 = (unsigned __int8 *)(v80 + v13 * (v18 - 3));
      uint64_t v26 = v22 - 3;
      do
      {
        uint64_t result = (uint64_t)memset(&v25[v26], *v25, v23);
        int v20 = a7[70];
        ++v24;
        if (v19 >= v20) {
          int v27 = a7[70];
        }
        else {
          int v27 = v19;
        }
        v25 += v13;
      }
      while (v24 < v27);
      uint64_t v17 = *((void *)a7 + 15);
      a1 = v77;
      uint64_t v15 = v79;
    }
    if (a4 <= 1) {
      uint64_t v28 = 1;
    }
    else {
      uint64_t v28 = a4;
    }
    int v29 = a4 + (a6 >> 1) + 2;
    if (v29 >= v20 >> 1) {
      uint64_t v30 = (v20 >> 1);
    }
    else {
      uint64_t v30 = v29;
    }
    if ((int)v28 <= (int)v30)
    {
      uint64_t v31 = v17 >> 1;
      uint64_t v32 = v28 - 1;
      if (v30 > v28) {
        uint64_t v28 = v30;
      }
      uint64_t v33 = v15 + 2 * v31 * v32 - 2;
      a2 = v82;
      uint64_t v12 = v80;
      do
      {
        if (a3 <= 0)
        {
          __int16 v34 = *(_WORD *)(v15 + 2 * v31 * v32);
          uint64_t v35 = (_WORD *)v33;
          uint64_t v36 = (1 - a3) & ~((1 - a3) >> 31);
          do
          {
            *v35-- = v34;
            --v36;
          }
          while (v36);
        }
        ++v32;
        v33 += 2 * v31;
      }
      while (v32 != v28);
    }
    else
    {
      a2 = v82;
      uint64_t v12 = v80;
    }
  }
  int v37 = a1 + a5 + 4;
  int v38 = a7[69];
  int v39 = v37 - v38;
  if (v37 > v38)
  {
    if (a2 <= 3) {
      uint64_t v40 = 3;
    }
    else {
      uint64_t v40 = a2;
    }
    int v41 = a2 + a6 + 4;
    int v42 = a7[70];
    if (v41 >= v42) {
      int v43 = a7[70];
    }
    else {
      int v43 = a2 + a6 + 4;
    }
    if ((int)v40 - 3 < v43)
    {
      int v78 = a1;
      uint64_t v44 = v40 - 3;
      size_t v45 = v39;
      uint64_t v81 = v12;
      char v46 = (char *)(v38 + v13 * (v40 - 3) + v12);
      do
      {
        uint64_t result = (uint64_t)memset(v46, *(v46 - 1), v45);
        ++v44;
        int v42 = a7[70];
        if (v41 >= v42) {
          int v47 = a7[70];
        }
        else {
          int v47 = v41;
        }
        v46 += v13;
      }
      while (v44 < v47);
      int v38 = a7[69];
      uint64_t v17 = *((void *)a7 + 15);
      a2 = v82;
      a1 = v78;
      uint64_t v12 = v81;
    }
    if (a4 <= 1) {
      uint64_t v48 = 1;
    }
    else {
      uint64_t v48 = a4;
    }
    int v49 = a4 + (a6 >> 1) + 2;
    if (v49 >= v42 >> 1) {
      uint64_t v50 = (v42 >> 1);
    }
    else {
      uint64_t v50 = v49;
    }
    if ((int)v48 <= (int)v50)
    {
      uint64_t v51 = v38 - 2;
      uint64_t v52 = v17 >> 1;
      int v53 = a3 + (a5 >> 1) - (v38 >> 1) + 2;
      uint64_t v54 = v48 - 1;
      if (v50 > v48) {
        uint64_t v48 = v50;
      }
      uint64_t v55 = v51 + 2 * v52 * v54 + v15 + 2;
      do
      {
        if (v53 >= 1)
        {
          __int16 v56 = *(_WORD *)(v15 + v51 + 2 * v52 * v54);
          int v57 = (_WORD *)v55;
          uint64_t result = v53 & ~(v53 >> 31);
          do
          {
            *v57++ = v56;
            --result;
          }
          while (result);
        }
        ++v54;
        v55 += 2 * v52;
      }
      while (v54 != v48);
    }
  }
  uint64_t v58 = v12 + a1;
  if (a2 <= 2)
  {
    int v59 = v82 - 3;
    uint64_t v60 = (char *)(v58 - 3);
    do
    {
      uint64_t v61 = &v60[-v13];
      uint64_t result = (uint64_t)memcpy(&v60[-v13], v60, a5 + 7);
      uint64_t v60 = v61;
      BOOL v62 = __CFADD__(v59++, 1);
    }
    while (!v62);
    if (a4 <= 0)
    {
      int v63 = a4 - 1;
      int v64 = (char *)(v79 + 2 * a3 - 2);
      do
      {
        uint64_t v65 = &v64[-v16];
        uint64_t result = (uint64_t)memcpy(&v64[-v16], v64, (int)((a5 & 0xFFFFFFFE) + 6));
        int v64 = v65;
        BOOL v62 = __CFADD__(v63++, 1);
      }
      while (!v62);
    }
  }
  uint64_t v66 = a7[70];
  if (v82 + a6 + 4 > (int)v66)
  {
    uint64_t v67 = v13 * (v66 - 1);
    int v68 = v66 - v82 - 4;
    uint64_t v69 = v58 - 3;
    uint64_t v70 = v13 * v66;
    do
    {
      uint64_t result = (uint64_t)memcpy((void *)(v69 + v70), (const void *)(v69 + v67), a5 + 7);
      ++v68;
      v69 += v13;
    }
    while (a6 != v68);
    int v71 = a7[70] >> 1;
    if (v71 < a4 + (a6 >> 1) + 2)
    {
      uint64_t v72 = v16 * (v71 - 1);
      int v73 = 2 * a3 - 2;
      int v74 = (a6 >> 1) + a4 - v71 + 2;
      uint64_t v75 = v79 + v73;
      uint64_t v76 = v16 * v71;
      do
      {
        uint64_t result = (uint64_t)memcpy((void *)(v75 + v76), (const void *)(v75 + v72), (int)((a5 & 0xFFFFFFFE) + 6));
        v75 += v16;
        --v74;
      }
      while (v74);
    }
  }
  return result;
}

__int16 *sub_1BBA0E98C(__int16 *result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  int v10 = (int)result;
  if (a5)
  {
    uint64_t v11 = (a3 + result - *(_DWORD *)(a6 + 276) / 2);
    if ((int)v11 >= 1)
    {
      uint64_t v12 = (__int16 *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (*(_DWORD *)(a6 + 276) / 2 - 1), (a2 - 1), 1);
      __int16 v14 = *v12;
      uint64_t result = v12 + 1;
      __int16 v13 = v14;
      do
      {
        *result++ = v13;
        --v11;
      }
      while (v11);
    }
  }
  if (a4)
  {
    uint64_t v15 = (a3 + a2 - *(_DWORD *)(a6 + 280) / 2);
    if ((int)v15 >= 1)
    {
      uint64_t v16 = *(void *)(a6 + 120);
      uint64_t result = (__int16 *)(*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a6 + 16))(a6, (v10 - 1), (*(_DWORD *)(a6 + 280) / 2 - 1), 1);
      __int16 v17 = *result;
      uint64_t v18 = (__int16 *)((char *)result + (v16 & 0xFFFFFFFFFFFFFFFELL));
      do
      {
        *uint64_t v18 = v17;
        uint64_t v18 = (_WORD *)((char *)v18 + (v16 & 0xFFFFFFFFFFFFFFFELL));
        --v15;
      }
      while (v15);
    }
  }
  return result;
}

uint64_t sub_1BBA0EAAC(int *a1, int *a2, uint64_t a3)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  uint64_t v61 = 0;
  memset(v60, 0, sizeof(v60));
  uint64_t v6 = (a2[69] - (a2[100] + a2[102]));
  int v7 = a2[70] - (a2[101] + a2[103]);
  uint64_t v8 = *((void *)a2 + 14);
  uint64_t v9 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v10 = a2[100];
  uint64_t v11 = a2[101];
  uint64_t v12 = *((void *)a1 + 14);
  uint64_t v13 = (*(uint64_t (**)(int *, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v14 = 0;
  uint64_t v15 = v13 + a1[100];
  uint64_t v16 = a1[101];
  do
  {
    int v17 = v7 * (int)v14 / 3;
    uint64_t v18 = v14 + 1;
    int v19 = v7 * ((int)v14 + 1) / 3;
    if (v17 < v19)
    {
      int v20 = (uint64_t *)v60 + 3 * v14;
      uint64_t v21 = v17;
      int v22 = (unsigned __int8 *)(v15 + v12 * (v16 + v17));
      size_t v23 = (unsigned __int8 *)(v9 + v10 + v8 * (v11 + v17));
      do
      {
        if ((int)v6 >= 1)
        {
          uint64_t v24 = *v20;
          uint64_t v25 = v23;
          uint64_t v26 = v22;
          uint64_t v27 = v6;
          do
          {
            int v29 = *v25++;
            int v28 = v29;
            int v30 = *v26++;
            v24 += ((v28 - v30) * (v28 - v30));
            --v27;
          }
          while (v27);
          *int v20 = v24;
        }
        ++v21;
        v22 += v12;
        v23 += v8;
      }
      while (v21 != v19);
    }
    uint64_t v14 = v18;
  }
  while (v18 != 3);
  if ((int)v6 >= 0) {
    int v31 = v6;
  }
  else {
    int v31 = v6 + 1;
  }
  uint64_t v32 = (v31 >> 1);
  if (v7 >= 0) {
    int v33 = v7;
  }
  else {
    int v33 = v7 + 1;
  }
  int v34 = v33 >> 1;
  uint64_t v35 = *((void *)a1 + 15);
  uint64_t v36 = *((void *)a2 + 15);
  uint64_t v37 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v38 = a2[100];
  uint64_t v39 = (uint64_t)(a2[101] + (a2[101] < 0)) >> 1;
  uint64_t result = (*(uint64_t (**)(int *, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v41 = 0;
  uint64_t v42 = (uint64_t)(a1[101] + (a1[101] < 0)) >> 1;
  uint64_t v43 = result + a1[100];
  do
  {
    int v44 = v34 * (int)v41 / 3;
    uint64_t v45 = v41 + 1;
    int v46 = v34 * ((int)v41 + 1) / 3;
    if (v44 < v46)
    {
      int v47 = (uint64x2_t *)((char *)v60 + 24 * v41 + 8);
      uint64_t v48 = v44;
      uint64_t result = v43 + v35 * (v42 + v44);
      int v49 = (unsigned __int8 *)(v37 + v38 + v36 * (v39 + v44));
      do
      {
        if ((int)v6 >= 2)
        {
          uint64x2_t v50 = *v47;
          uint64_t v51 = v49;
          uint64_t v52 = (unsigned __int8 *)result;
          uint64_t v53 = v32;
          do
          {
            v54.i32[0] = *v51;
            v54.i32[1] = v51[1];
            v55.i32[0] = *v52;
            v55.i32[1] = v52[1];
            int32x2_t v56 = vsub_s32(v54, v55);
            uint64x2_t v50 = vaddw_u32(v50, (uint32x2_t)vmul_s32(v56, v56));
            v52 += 2;
            v51 += 2;
            --v53;
          }
          while (v53);
          *int v47 = v50;
        }
        ++v48;
        result += v35;
        v49 += v36;
      }
      while (v48 != v46);
    }
    uint64_t v41 = v45;
  }
  while (v45 != 3);
  uint64_t v57 = 0;
  uint64_t v58 = v60;
  do
  {
    for (uint64_t i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(void *)((char *)v58 + i));
    ++v57;
    a3 += 24;
    uint64_t v58 = (_OWORD *)((char *)v58 + 24);
  }
  while (v57 != 3);
  return result;
}

uint64_t sub_1BBA0EE60(uint64_t a1, int *a2, uint64_t a3, int a4)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  double v8 = sub_1BBA12160((uint64_t)v98);
  v98[0] = &unk_1F14EE0C0;
  uint64_t v107 = 0;
  int v108 = 0;
  uint64_t v109 = 0;
  char v110 = 0;
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v9 = (__CVBuffer *)(*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 96))(a1, v8);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v9);
  int v11 = a2[69];
  int v86 = a2[102];
  int v87 = a2[100];
  int v89 = a2[70];
  int v85 = a2[101];
  int v12 = a2[103];
  uint64_t v13 = *((void *)a2 + 14);
  uint64_t v14 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  signed int v15 = CVPixelBufferGetPixelFormatType(v14);
  unsigned int v16 = 0;
  if (v15 <= 2016687155)
  {
    BOOL v17 = v15 == 1278226736;
    int v18 = 2016686640;
  }
  else
  {
    BOOL v17 = v15 == 2016687156 || v15 == 2019963956;
    int v18 = 2019963440;
  }
  if (v17 || v15 == v18) {
    unsigned int v16 = 8 - sub_1BBA13A1C(v15);
  }
  uint64_t v84 = (*(uint64_t (**)(int *, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v20 = a2[100];
  uint64_t v83 = a2[101];
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    int v81 = v11;
    int v82 = a4;
    CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    OSStatus v22 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
    if (v22)
    {
      BOOL v23 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
      uint64x2_t v24 = 0uLL;
      if (v23)
      {
        LODWORD(theDict[0]) = 67109120;
        HIDWORD(theDict[0]) = v22;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", (uint8_t *)theDict, 8u);
        uint64x2_t v24 = 0uLL;
      }
      unint64_t v25 = 0;
      goto LABEL_76;
    }
    size_t Width = CVPixelBufferGetWidth(v9);
    size_t Height = CVPixelBufferGetHeight(v9);
    theDict[0] = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(theDict[0], (const void *)*MEMORY[0x1E4F24D20], Mutable);
    uint64_t v32 = a3;
    DescriptionWithOSType PixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    CFNumberRef Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E4F24E50]);
    if (sub_1BBA13A1C(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F24E60]))
    {
      a3 = v32;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CMSampleTimingInfo buf = 0;
        uint64_t v36 = MEMORY[0x1E4F14500];
        uint64_t v37 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        uint32_t v78 = 2;
        goto LABEL_87;
      }
      goto LABEL_39;
    }
    CVReturn v35 = CVPixelBufferCreate(v21, Width, Height, 0x34323076u, theDict[0], &pixelBufferOut);
    a3 = v32;
    if (v35)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        CVReturn v96 = v35;
        uint64_t v36 = MEMORY[0x1E4F14500];
        uint64_t v37 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_84:
        uint32_t v78 = 8;
LABEL_87:
        _os_log_error_impl(&dword_1BB9B9000, v36, OS_LOG_TYPE_ERROR, v37, buf, v78);
        goto LABEL_39;
      }
      goto LABEL_39;
    }
    OSStatus v77 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v9, pixelBufferOut);
    if (v77)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        CVReturn v96 = v77;
        uint64_t v36 = MEMORY[0x1E4F14500];
        uint64_t v37 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_84;
      }
LABEL_39:
      sub_1BB9BE228((const void **)&Mutable);
      sub_1BB9BE228((const void **)theDict);
LABEL_50:
      unint64_t v25 = 0;
      uint64x2_t v24 = 0uLL;
      goto LABEL_76;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1BBA133CC((uint64_t)v98, pixelBufferOut, 0);
    sub_1BB9BE228((const void **)&Mutable);
    sub_1BB9BE228((const void **)theDict);
    a3 = v32;
    int v11 = v81;
    a4 = v82;
  }
  else
  {
    sub_1BBA133CC((uint64_t)v98, v9, 0);
  }
  uint64_t v26 = (v11 - (v87 + v86));
  uint64_t v27 = (v89 - (v85 + v12));
  int v28 = (unsigned __int8 *)(v84 + v20 + v13 * v83);
  uint64_t v29 = v99;
  if (a4)
  {
    uint64_t v30 = v104;
    if (v99 || !sub_1BBA13E0C((uint64_t)v98)) {
      uint64_t v31 = v101;
    }
    else {
      uint64_t v31 = 0;
    }
    if ((int)v27 < 1) {
      goto LABEL_50;
    }
    uint64_t v47 = 0;
    unint64_t v25 = 0;
    uint64_t v48 = (unsigned __int8 *)(v31 + v105 + v30 * v106);
    do
    {
      if ((int)v26 >= 1)
      {
        int v49 = v28;
        uint64x2_t v50 = v48;
        uint64_t v51 = v26;
        do
        {
          int v53 = *v49++;
          int v52 = v53;
          int v54 = *v50++;
          v25 += ((v52 - v54) * (v52 - v54));
          --v51;
        }
        while (v51);
      }
      ++v47;
      v48 += v30;
      v28 += v13;
    }
    while (v47 != v27);
    goto LABEL_48;
  }
  uint64_t v38 = v102;
  if (!v99)
  {
    if (sub_1BBA13E0C((uint64_t)v98)) {
      uint64_t v29 = 0;
    }
    else {
      uint64_t v29 = v99;
    }
  }
  if ((int)v27 >= 1)
  {
    uint64_t v39 = 0;
    unint64_t v25 = 0;
    uint64_t v40 = (unsigned __int8 *)(v29 + v105 + v38 * v106);
    do
    {
      if ((int)v26 >= 1)
      {
        uint64_t v41 = v28;
        uint64_t v42 = v40;
        uint64_t v43 = v26;
        do
        {
          unsigned int v45 = *v41++;
          unsigned int v44 = v45;
          unsigned int v46 = *v42++;
          v25 += ((v44 >> v16) - (v46 >> v16)) * ((v44 >> v16) - (v46 >> v16));
          --v43;
        }
        while (v43);
      }
      ++v39;
      v40 += v38;
      v28 += v13;
    }
    while (v39 != v27);
LABEL_48:
    uint64x2_t v24 = 0uLL;
    if (a4) {
      goto LABEL_76;
    }
    goto LABEL_52;
  }
  unint64_t v25 = 0;
LABEL_52:
  uint64_t v90 = a3;
  if ((int)v26 >= 0) {
    int v55 = v26;
  }
  else {
    int v55 = v26 + 1;
  }
  int v88 = v55;
  if ((int)v27 >= 0) {
    int v56 = v27;
  }
  else {
    int v56 = v27 + 1;
  }
  uint64_t v57 = v103;
  uint64_t v58 = *((void *)a2 + 15);
  uint64_t v59 = (*(uint64_t (**)(int *, uint64_t))(*(void *)a2 + 40))(a2, 1);
  uint64_t v60 = a2[100];
  int v61 = a2[101];
  if (v61 >= 0) {
    int v62 = a2[101];
  }
  else {
    int v62 = v61 + 1;
  }
  if (v99 || !sub_1BBA13E0C((uint64_t)v98)) {
    uint64_t v63 = v100;
  }
  else {
    uint64_t v63 = 0;
  }
  if (v106 >= 0) {
    int v64 = v106;
  }
  else {
    int v64 = v106 + 1;
  }
  uint64x2_t v24 = 0uLL;
  if ((int)v27 < 2)
  {
    a3 = v90;
  }
  else
  {
    uint64_t v65 = 0;
    uint64_t v66 = (v56 >> 1);
    uint64_t v67 = v59 + v60 + v58 * ((uint64_t)v62 >> 1);
    uint64_t v68 = v63 + v105 + v57 * ((uint64_t)v64 >> 1);
    uint32x2_t v69 = (uint32x2_t)vneg_s32(vdup_n_s32(v16));
    a3 = v90;
    do
    {
      if ((int)v26 >= 2)
      {
        uint64_t v70 = (unsigned __int8 *)v67;
        int v71 = (unsigned __int8 *)v68;
        uint64_t v72 = (v88 >> 1);
        do
        {
          v73.i32[0] = *v70;
          v73.i32[1] = v70[1];
          v74.i32[0] = *v71;
          v74.i32[1] = v71[1];
          int32x2_t v75 = vsub_s32((int32x2_t)vshl_u32(v73, v69), (int32x2_t)vshl_u32(v74, v69));
          uint64x2_t v24 = vaddw_u32(v24, (uint32x2_t)vmul_s32(v75, v75));
          v71 += 2;
          v70 += 2;
          --v72;
        }
        while (v72);
      }
      ++v65;
      v68 += v57;
      v67 += v58;
    }
    while (v65 != v66);
  }
LABEL_76:
  uint64x2_t v91 = v24;
  if (pixelBufferOut) {
    CVPixelBufferRelease(pixelBufferOut);
  }
  if (pixelTransferSessionOut) {
    CFRelease(pixelTransferSessionOut);
  }
  *(double *)a3 = (double)v25;
  *(float64x2_t *)(a3 + 8) = vcvtq_f64_u64(v91);
  return sub_1BBA141AC((uint64_t)v98);
}

void sub_1BBA0F5C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, const void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,uint64_t a26,char a27)
{
}

uint64_t sub_1BBA0F638(uint64_t *a1, unsigned __int8 *a2)
{
  unsigned int v2 = a2;
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  uint64_t v4 = *a1;
  if (*((unsigned char *)a1 + 136))
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 56))(a1, 0);
    uint64_t v6 = a1 + 22;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    double v8 = a1 + 21;
  }
  else
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 40))(a1, 0);
    uint64_t v6 = a1 + 15;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    double v8 = a1 + 14;
  }
  uint64_t v9 = 0;
  uint64_t v10 = *v6;
  uint64_t v11 = *v8;
  do
  {
    *((unsigned char *)&c + v9 + 92) = 1;
    *((unsigned char *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    unint64_t v12 = 0;
    do
    {
      char v13 = CC_MD5_Update(&c, v5, *((_DWORD *)a1 + 69));
      v39 &= v13;
      ++v12;
      v5 += v11;
      unint64_t v14 = *((int *)a1 + 70);
    }
    while (v12 < v14);
    if (!v7) {
      goto LABEL_28;
    }
LABEL_12:
    int v15 = *((_DWORD *)a1 + 69);
    if (v15 >= 0) {
      int v16 = *((_DWORD *)a1 + 69);
    }
    else {
      int v16 = v15 + 1;
    }
    if ((v14 & 0x80000000) == 0) {
      int v17 = v14;
    }
    else {
      int v17 = v14 + 1;
    }
    int v18 = v17 >> 1;
    uint64_t v19 = (v16 >> 1) * (uint64_t)(v17 >> 1);
    if (v19)
    {
      sub_1BB9C1970((unint64_t *)__p, 2 * (int)v19);
      uint64_t v20 = (char *)__p[0];
    }
    else
    {
      uint64_t v20 = 0;
    }
    CFAllocatorRef v21 = &v20[v19];
    if ((v14 + 1) >= 3)
    {
      uint64_t v22 = (uint64_t)v16 >> 1;
      uint64_t v23 = v18;
      uint64_t v24 = v7 + 2 * v22 - 1;
      unint64_t v25 = v20;
      uint64_t v26 = &v20[v19];
      do
      {
        if ((v15 + 1) >= 3)
        {
          uint64_t v27 = (char *)v24;
          uint64_t v28 = (uint64_t)v16 >> 1;
          do
          {
            v25[v28 - 1] = *(v27 - 1);
            char v29 = *v27;
            v27 -= 2;
            v26[--v28] = v29;
          }
          while (v28);
        }
        v25 += v22;
        v26 += v22;
        v24 += v10;
        --v23;
      }
      while (v23);
    }
    char v30 = CC_MD5_Update(&v40, v20, v19);
    v41 &= v30;
    char v31 = CC_MD5_Update(&v42, v21, v19);
    v43 &= v31;
    goto LABEL_28;
  }
  LODWORD(v14) = 0;
  if (v7) {
    goto LABEL_12;
  }
LABEL_28:
  uint64_t v32 = 0;
  while (1)
  {
    char v33 = CC_MD5_Final(v2, (CC_MD5_CTX *)((char *)&c + v32));
    BOOL v34 = (v33 & *((unsigned char *)&c + v32 + 92)) == 0;
    *((unsigned char *)&c + v32 + 92) &= v33;
    if (v34) {
      break;
    }
    v32 += 96;
    v2 += 16;
    if (v32 == 288)
    {
      uint64_t v35 = 0;
      goto LABEL_33;
    }
  }
  uint64_t v35 = 4294954385;
LABEL_33:
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v35;
}

void sub_1BBA0F968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA0F98C(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  int v5 = *(_DWORD *)(a1 + 280);
  int v6 = *(_DWORD *)(a1 + 412);
  int v7 = v5 - (*(_DWORD *)(a1 + 404) + v6);
  int v8 = v5 - v6;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < v8)
  {
    uint64_t v11 = v9 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v11 + *(void *)(a1 + 112) * v10++), 1uLL, v4, a2);
    while (v10 < v8);
  }
  if (v4 >= 0) {
    int v12 = v4;
  }
  else {
    int v12 = v4 + 1;
  }
  if (v7 >= 0) {
    int v13 = v7;
  }
  else {
    int v13 = v7 + 1;
  }
  int v14 = v13 >> 1;
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  uint64_t v31 = *(int *)(a1 + 400);
  uint64_t v32 = v15;
  int v16 = *(_DWORD *)(a1 + 404);
  uint64_t v17 = *(void *)(a1 + 120);
  uint64_t v18 = v14 * (uint64_t)(v12 >> 1);
  uint64_t v19 = (char *)operator new[](2 * (int)v18, MEMORY[0x1E4FBA2D0]);
  if (!v19) {
    return 4294954392;
  }
  uint64_t v20 = v19;
  if ((v7 + 1) >= 3)
  {
    uint64_t v21 = (uint64_t)v12 >> 1;
    uint64_t v22 = v14;
    uint64_t v23 = &v19[v18];
    if (v16 >= 0) {
      int v24 = v16;
    }
    else {
      int v24 = v16 + 1;
    }
    uint64_t v25 = v17 * ((uint64_t)v24 >> 1) + 2 * v21 + v31 + v32 - 1;
    uint64_t v26 = v19;
    do
    {
      if ((v4 + 1) >= 3)
      {
        uint64_t v27 = (char *)v25;
        uint64_t v28 = (uint64_t)v12 >> 1;
        do
        {
          v26[v28 - 1] = *(v27 - 1);
          char v29 = *v27;
          v27 -= 2;
          v23[--v28] = v29;
        }
        while (v28);
      }
      v26 += v21;
      v23 += v21;
      v25 += v17;
      --v22;
    }
    while (v22);
  }
  fwrite(v19, 1uLL, 2 * (int)v18, a2);
  MEMORY[0x1C18605A0](v20, 0x1000C8077774924);
  return 0;
}

uint64_t sub_1BBA0FBB8(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276) - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
  uint64_t v5 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v7 = *(int *)(a1 + 404);
  if ((int)v7 < (int)v5)
  {
    uint64_t v8 = v6 + *(int *)(a1 + 400);
    do
      fwrite((const void *)(v8 + *(void *)(a1 + 112) * v7++), 1uLL, v4, a2);
    while (v7 < v5);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  int v10 = *(_DWORD *)(a1 + 404) / 2;
  if ((int)v5 >= 0) {
    int v11 = v5;
  }
  else {
    int v11 = v5 + 1;
  }
  if (v10 < v11 >> 1)
  {
    uint64_t v12 = v9 + *(int *)(a1 + 400);
    int v13 = v11 >> 1;
    size_t v14 = v4 & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v15 = v10;
    do
      fwrite((const void *)(v12 + *(void *)(a1 + 120) * v15++), 1uLL, v14, a2);
    while (v13 != v15);
  }
  return 0;
}

void *sub_1BBA0FD14(void *result)
{
  result[53] = sub_1BBA10C90;
  result[54] = sub_1BBA10BB0;
  result[55] = sub_1BBA10894;
  result[56] = sub_1BBA10224;
  result[57] = sub_1BBA0FFEC;
  result[134] = sub_1BBA06D64;
  result[136] = sub_1BBA0FD88;
  return result;
}

uint64_t sub_1BBA0FD88(int a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, int *a7)
{
  uint64_t v12 = (*(uint64_t (**)(int *, void))(*(void *)a7 + 32))(a7, 0);
  uint64_t v13 = *((void *)a7 + 14);
  uint64_t result = (*(uint64_t (**)(int *, uint64_t))(*(void *)a7 + 32))(a7, 1);
  if (a1 <= 2)
  {
    uint64_t v15 = a2 <= 3 ? 3 : a2;
    LODWORD(v16) = a7[70];
    int v17 = a2 + a6 + 4;
    uint64_t v16 = v17 >= (int)v16 ? v16 : v17;
    if ((int)v15 - 3 < (int)v16)
    {
      uint64_t v18 = v15 - 3;
      uint64_t v19 = v12 + 2 * v13 * v18 - 2;
      do
      {
        __int16 v20 = *(_WORD *)(v12 + 2 * v13 * v18);
        uint64_t v21 = (_WORD *)v19;
        uint64_t v22 = (3 - a1);
        do
        {
          *v21-- = v20;
          --v22;
        }
        while (v22);
        ++v18;
        v19 += 2 * v13;
      }
      while (v18 != v16);
    }
  }
  int v23 = a1 + a5 + 4;
  uint64_t v24 = a7[69];
  if (v23 > (int)v24)
  {
    uint64_t v25 = a2 <= 3 ? 3 : a2;
    LODWORD(v26) = a7[70];
    int v27 = a2 + a6 + 4;
    uint64_t v26 = v27 >= (int)v26 ? v26 : v27;
    if ((int)v25 - 3 < (int)v26)
    {
      uint64_t v28 = v25 - 3;
      uint64_t v29 = 2 * v13 * v28 + 2 * (v24 - 1) + v12 + 2;
      do
      {
        if (v23 != v24)
        {
          __int16 v30 = *(_WORD *)(v12 + 2 * (v24 - 1 + v13 * v28));
          uint64_t v31 = (_WORD *)v29;
          uint64_t result = v23 - (int)v24;
          do
          {
            *v31++ = v30;
            --result;
          }
          while (result);
        }
        ++v28;
        v29 += 2 * v13;
      }
      while (v28 != v26);
    }
  }
  uint64_t v32 = v12 + 2 * a1;
  if (a2 <= 2)
  {
    int v33 = a2 - 3;
    BOOL v34 = (char *)(v32 - 6);
    do
    {
      uint64_t v35 = &v34[-2 * v13];
      uint64_t result = (uint64_t)memcpy(v35, v34, 2 * (a5 + 7));
      BOOL v34 = v35;
    }
    while (!__CFADD__(v33++, 1));
  }
  uint64_t v37 = a7[70];
  if (a2 + a6 + 4 > (int)v37)
  {
    size_t v38 = 2 * (a5 + 7);
    int v39 = a6 + a2 - v37 + 4;
    uint64_t v40 = 2 * v13 * (v37 - 1);
    uint64_t v41 = v32 - 6;
    uint64_t v42 = v13 * (2 * (v37 - 1) + 2);
    do
    {
      uint64_t result = (uint64_t)memcpy((void *)(v41 + v42), (const void *)(v41 + v40), v38);
      v41 += 2 * v13;
      --v39;
    }
    while (v39);
  }
  return result;
}

uint64_t *sub_1BBA0FFEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v36 = 0;
  memset(v35, 0, sizeof(v35));
  uint64_t v6 = (*(_DWORD *)(a2 + 276) - (*(_DWORD *)(a2 + 400) + *(_DWORD *)(a2 + 408)));
  int v7 = *(_DWORD *)(a2 + 280) - (*(_DWORD *)(a2 + 404) + *(_DWORD *)(a2 + 412));
  uint64_t v8 = *(void *)(a2 + 112);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v10 = *(int *)(a2 + 400);
  uint64_t v11 = *(int *)(a2 + 404);
  uint64_t v12 = *(void *)(a1 + 112);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v14 = 0;
  uint64_t v15 = v13 + 2 * *(int *)(a1 + 400);
  uint64_t v16 = 2 * *(int *)(a1 + 404);
  uint64_t v17 = v9 + 2 * v10;
  do
  {
    int v18 = v7 * (int)v14 / 3;
    uint64_t v19 = v14 + 1;
    uint64_t result = (uint64_t *)((unint64_t)(1431655766 * v7 * ((int)v14 + 1)) >> 32);
    int v21 = v7 * ((int)v14 + 1) / 3;
    if (v18 < v21)
    {
      uint64_t result = (uint64_t *)v35 + 3 * v14;
      uint64_t v22 = v18;
      int v23 = (unsigned __int16 *)(v15 + v12 * (v16 + 2 * v18));
      uint64_t v24 = (unsigned __int16 *)(v17 + v8 * (2 * v11 + 2 * v18));
      do
      {
        if ((int)v6 >= 1)
        {
          uint64_t v25 = *result;
          uint64_t v26 = v24;
          int v27 = v23;
          uint64_t v28 = v6;
          do
          {
            int v30 = *v26++;
            int v29 = v30;
            int v31 = *v27++;
            v25 += ((v29 - v31) * (v29 - v31));
            --v28;
          }
          while (v28);
          *uint64_t result = v25;
        }
        ++v22;
        v23 += v12;
        v24 += v8;
      }
      while (v22 != v21);
    }
    uint64_t v14 = v19;
  }
  while (v19 != 3);
  uint64_t v32 = 0;
  int v33 = v35;
  do
  {
    for (uint64_t i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(void *)((char *)v33 + i));
    ++v32;
    a3 += 24;
    int v33 = (_OWORD *)((char *)v33 + 24);
  }
  while (v32 != 3);
  return result;
}

uint64_t sub_1BBA10224(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  double v8 = sub_1BBA12160((uint64_t)v73);
  v73[0] = &unk_1F14EE0C0;
  uint64_t v80 = 0;
  int v81 = 0;
  uint64_t v82 = 0;
  char v83 = 0;
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v9 = (__CVBuffer *)(*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 96))(a1, v8);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v9);
  int v11 = *(_DWORD *)(a2 + 276);
  int v65 = *(_DWORD *)(a2 + 408);
  int v66 = *(_DWORD *)(a2 + 400);
  int v12 = *(_DWORD *)(a2 + 280);
  int v63 = *(_DWORD *)(a2 + 412);
  int v64 = *(_DWORD *)(a2 + 404);
  uint64_t v13 = *(void *)(a2 + 112);
  uint64_t v14 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  signed int v15 = CVPixelBufferGetPixelFormatType(v14);
  char v16 = 0;
  int v61 = v12;
  int v62 = v11;
  if (v15 <= 2016687155)
  {
    BOOL v17 = v15 == 1278226736;
    int v18 = 2016686640;
  }
  else
  {
    BOOL v17 = v15 == 2016687156 || v15 == 2019963956;
    int v18 = 2019963440;
  }
  if (v17 || v15 == v18) {
    char v16 = 16 - sub_1BBA13A1C(v15);
  }
  uint64_t v20 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v21 = *(int *)(a2 + 400);
  uint64_t v22 = *(int *)(a2 + 404);
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    int v60 = a4;
    CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    OSStatus v24 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
    if (v24)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v24;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", buf, 8u);
      }
      goto LABEL_48;
    }
    size_t width = CVPixelBufferGetWidth(v9);
    size_t Height = CVPixelBufferGetHeight(v9);
    *(void *)CMSampleTimingInfo buf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, (const void *)*MEMORY[0x1E4F24D20], Mutable);
    uint64_t v58 = v13;
    DescriptionWithOSType PixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    CFNumberRef Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E4F24E50]);
    if (sub_1BBA13A1C(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F24E60]))
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v70 = 0;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        uint32_t v57 = 2;
        goto LABEL_60;
      }
      goto LABEL_38;
    }
    CVReturn v34 = CVPixelBufferCreate(v23, width, Height, 0x34323076u, *(CFDictionaryRef *)buf, &pixelBufferOut);
    if (v34)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v70 = 67109120;
        CVReturn v71 = v34;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_57:
        uint32_t v57 = 8;
LABEL_60:
        _os_log_error_impl(&dword_1BB9B9000, v35, OS_LOG_TYPE_ERROR, v36, v70, v57);
        goto LABEL_38;
      }
      goto LABEL_38;
    }
    OSStatus v56 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v9, pixelBufferOut);
    if (v56)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v70 = 67109120;
        CVReturn v71 = v56;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_57;
      }
LABEL_38:
      sub_1BB9BE228((const void **)&Mutable);
      sub_1BB9BE228((const void **)buf);
LABEL_48:
      unint64_t v39 = 0;
      goto LABEL_49;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1BBA133CC((uint64_t)v73, pixelBufferOut, 0);
    sub_1BB9BE228((const void **)&Mutable);
    sub_1BB9BE228((const void **)buf);
    uint64_t v13 = v58;
    a4 = v60;
  }
  else
  {
    sub_1BBA133CC((uint64_t)v73, v9, 0);
  }
  int v25 = v62 - (v66 + v65);
  uint64_t v26 = (v61 - (v64 + v63));
  uint64_t v27 = v20 + 2 * v21 + 2 * v13 * v22;
  uint64_t v28 = v74;
  if (a4)
  {
    uint64_t v29 = v77;
    if (v74 || !sub_1BBA13E0C((uint64_t)v73)) {
      uint64_t v30 = v75;
    }
    else {
      uint64_t v30 = 0;
    }
    if ((int)v26 < 1) {
      goto LABEL_48;
    }
    uint64_t v47 = 0;
    unint64_t v39 = 0;
    uint64_t v48 = v30 + 2 * v78 + 2 * v29 * v79;
    do
    {
      if (v25 >= 1)
      {
        int v49 = (unsigned __int16 *)v27;
        uint64x2_t v50 = (unsigned __int16 *)v48;
        uint64_t v51 = (v62 - (v66 + v65));
        do
        {
          int v53 = *v49++;
          int v52 = v53;
          int v54 = *v50++;
          v39 += ((v52 - v54) * (v52 - v54));
          --v51;
        }
        while (v51);
      }
      ++v47;
      v48 += 2 * v29;
      v27 += 2 * v13;
    }
    while (v47 != v26);
  }
  else
  {
    uint64_t v37 = v76;
    if (!v74)
    {
      if (sub_1BBA13E0C((uint64_t)v73)) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = v74;
      }
    }
    if ((int)v26 < 1) {
      goto LABEL_48;
    }
    uint64_t v38 = 0;
    unint64_t v39 = 0;
    uint64_t v40 = v28 + 2 * v78 + 2 * v37 * v79;
    do
    {
      if (v25 >= 1)
      {
        uint64_t v41 = (unsigned __int16 *)v27;
        uint64_t v42 = (unsigned __int16 *)v40;
        uint64_t v43 = (v62 - (v66 + v65));
        do
        {
          unsigned int v45 = *v41++;
          unsigned int v44 = v45;
          unsigned int v46 = *v42++;
          v39 += ((v44 >> v16) - (v46 >> v16)) * ((v44 >> v16) - (v46 >> v16));
          --v43;
        }
        while (v43);
      }
      ++v38;
      v40 += 2 * v37;
      v27 += 2 * v13;
    }
    while (v38 != v26);
  }
LABEL_49:
  if (pixelBufferOut) {
    CVPixelBufferRelease(pixelBufferOut);
  }
  if (pixelTransferSessionOut) {
    CFRelease(pixelTransferSessionOut);
  }
  *(double *)a3 = (double)v39;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  return sub_1BBA141AC((uint64_t)v73);
}

void sub_1BBA1082C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, const void *);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  va_copy(va2, va1);
  signed int v15 = va_arg(va2, const void *);
  uint64_t v17 = va_arg(va2, void);
  sub_1BB9BE228((const void **)va);
  sub_1BB9BE228((const void **)va1);
  sub_1BBA141AC((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1BBA10894(uint64_t *a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  memset(data, 0, sizeof(data));
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  uint64_t v4 = *a1;
  if (*((unsigned char *)a1 + 136))
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 56))(a1, 0);
    uint64_t v6 = a1 + 22;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    double v8 = a1 + 21;
  }
  else
  {
    uint64_t v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 40))(a1, 0);
    uint64_t v6 = a1 + 15;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    double v8 = a1 + 14;
  }
  uint64_t v9 = 0;
  uint64_t v10 = *v6;
  uint64_t v11 = *v8;
  do
  {
    *((unsigned char *)&c + v9 + 92) = 1;
    *((unsigned char *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    unint64_t v12 = 0;
    do
    {
      char v13 = CC_MD5_Update(&c, v5, 2 * *((_DWORD *)a1 + 69));
      v34 &= v13;
      ++v12;
      int v14 = *((_DWORD *)a1 + 70);
      v5 += 2 * v11;
    }
    while (v12 < v14);
    uint64_t v15 = v14;
    if (v7) {
      goto LABEL_10;
    }
LABEL_18:
    int v18 = 0;
    goto LABEL_19;
  }
  int v14 = 0;
  uint64_t v15 = 0;
  if (!v7) {
    goto LABEL_18;
  }
LABEL_10:
  uint64_t v16 = *((int *)a1 + 69);
  signed int v17 = 2 * v16 * v14;
  sub_1BBA07D38((char **)data, v17);
  int v18 = data[0];
  uint64_t v19 = (char *)data[0] + 2 * (int)v16 * v14;
  if (v14)
  {
    uint64_t v20 = 2 * v16;
    uint64_t v21 = v7 + 4 * v16 - 2;
    uint64_t v22 = (char *)data[0];
    CFAllocatorRef v23 = (char *)data[0] + 2 * (int)v16 * v14;
    do
    {
      if (v16)
      {
        OSStatus v24 = (__int16 *)v21;
        uint64_t v25 = v16 - 1;
        do
        {
          *(_WORD *)&v22[2 * v25] = *(v24 - 1);
          __int16 v26 = *v24;
          v24 -= 2;
          *(_WORD *)&v23[2 * v25--] = v26;
        }
        while (v25 != -1);
      }
      v23 += v20;
      v22 += v20;
      v21 += 2 * v10;
      --v15;
    }
    while (v15);
  }
  char v27 = CC_MD5_Update(&v35, v18, v17);
  v36 &= v27;
  char v28 = CC_MD5_Update(&v37, v19, v17);
  v38 &= v28;
LABEL_19:
  int v29 = CC_MD5_Final((unsigned __int8 *)a2, &c);
  int v30 = v34;
  if (v18) {
    operator delete(v18);
  }
  if ((v29 & v30) != 0) {
    return 0;
  }
  else {
    return 4294954385;
  }
}

void sub_1BBA10B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (v11) {
    operator delete(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA10BB0(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276);
  int v5 = *(_DWORD *)(a1 + 400);
  int v6 = *(_DWORD *)(a1 + 408);
  uint64_t v7 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t result = 0;
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v7)
  {
    uint64_t v11 = v8 + 2 * *(int *)(a1 + 400);
    size_t v12 = 2 * (v4 - (v5 + v6));
    do
      fwrite((const void *)(v11 + 2 * *(void *)(a1 + 112) * v10++), 1uLL, v12, a2);
    while (v10 < v7);
    return 0;
  }
  return result;
}

uint64_t sub_1BBA10C90(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276);
  int v5 = *(_DWORD *)(a1 + 400);
  int v6 = *(_DWORD *)(a1 + 408);
  uint64_t v7 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t result = 0;
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v7)
  {
    uint64_t v11 = v8 + 2 * *(int *)(a1 + 400);
    size_t v12 = 2 * (v4 - (v5 + v6));
    do
      fwrite((const void *)(v11 + 2 * *(void *)(a1 + 112) * v10++), 1uLL, v12, a2);
    while (v10 < v7);
    return 0;
  }
  return result;
}

void *sub_1BBA10D70(void *result)
{
  result[53] = sub_1BBA11C94;
  result[54] = sub_1BBA11BB8;
  result[55] = sub_1BBA118B4;
  result[56] = sub_1BBA1125C;
  result[57] = sub_1BBA11034;
  result[134] = sub_1BBA087E0;
  result[136] = sub_1BBA10DE4;
  return result;
}

void *sub_1BBA10DE4(int a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, int *a7)
{
  uint64_t v10 = (*(uint64_t (**)(int *, void))(*(void *)a7 + 32))(a7, 0);
  uint64_t v11 = *((void *)a7 + 14);
  uint64_t result = (void *)(*(uint64_t (**)(int *, uint64_t))(*(void *)a7 + 32))(a7, 1);
  if (a1 <= 2)
  {
    if (a2 <= 3) {
      uint64_t v13 = 3;
    }
    else {
      uint64_t v13 = a2;
    }
    int v14 = a2 + a6 + 4;
    int v15 = a7[70];
    if (v14 < v15) {
      int v15 = a2 + a6 + 4;
    }
    if ((int)v13 - 3 < v15)
    {
      uint64_t v16 = v13 - 3;
      signed int v17 = (unsigned __int8 *)(v10 + v11 * (v13 - 3));
      do
      {
        uint64_t result = memset(&v17[a1 - 3], *v17, (3 - a1));
        int v18 = a7[70];
        ++v16;
        if (v14 < v18) {
          int v18 = a2 + a6 + 4;
        }
        v17 += v11;
      }
      while (v16 < v18);
    }
  }
  int v19 = a1 + a5 + 4;
  uint64_t v20 = a7[69];
  if (v19 > (int)v20)
  {
    if (a2 <= 3) {
      uint64_t v21 = 3;
    }
    else {
      uint64_t v21 = a2;
    }
    int v22 = a2 + a6 + 4;
    int v23 = a7[70];
    if (v22 < v23) {
      int v23 = a2 + a6 + 4;
    }
    if ((int)v21 - 3 < v23)
    {
      uint64_t v24 = v21 - 3;
      size_t v25 = v19 - (int)v20;
      __int16 v26 = (char *)(v20 + v11 * (v21 - 3) + v10);
      do
      {
        uint64_t result = memset(v26, *(v26 - 1), v25);
        ++v24;
        int v27 = a7[70];
        if (v22 < v27) {
          int v27 = a2 + a6 + 4;
        }
        v26 += v11;
      }
      while (v24 < v27);
    }
  }
  uint64_t v28 = v10 + a1;
  if (a2 <= 2)
  {
    int v29 = a2 - 3;
    int v30 = (char *)(v28 - 3);
    do
    {
      int v31 = &v30[-v11];
      uint64_t result = memcpy(&v30[-v11], v30, a5 + 7);
      int v30 = v31;
    }
    while (!__CFADD__(v29++, 1));
  }
  uint64_t v33 = a7[70];
  if (a2 + a6 + 4 > (int)v33)
  {
    uint64_t v34 = v11 * (v33 - 1);
    int v35 = a6 + a2 - v33 + 4;
    uint64_t v36 = v28 - 3;
    uint64_t v37 = v11 * v33;
    do
    {
      uint64_t result = memcpy((void *)(v36 + v37), (const void *)(v36 + v34), a5 + 7);
      v36 += v11;
      --v35;
    }
    while (v35);
  }
  return result;
}

uint64_t sub_1BBA11034(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v34 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v6 = (*(_DWORD *)(a2 + 276) - (*(_DWORD *)(a2 + 400) + *(_DWORD *)(a2 + 408)));
  int v7 = *(_DWORD *)(a2 + 280) - (*(_DWORD *)(a2 + 404) + *(_DWORD *)(a2 + 412));
  uint64_t v8 = *(void *)(a2 + 112);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v10 = *(int *)(a2 + 400);
  uint64_t v11 = *(int *)(a2 + 404);
  uint64_t v12 = *(void *)(a1 + 112);
  uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t v14 = 0;
  uint64_t v15 = result + *(int *)(a1 + 400);
  uint64_t v16 = *(int *)(a1 + 404);
  do
  {
    int v17 = v7 * (int)v14 / 3;
    uint64_t v18 = v14 + 1;
    int v19 = v7 * ((int)v14 + 1) / 3;
    if (v17 < v19)
    {
      uint64_t v20 = (uint64_t *)v33 + 3 * v14;
      uint64_t v21 = v17;
      uint64_t result = v15 + v12 * (v16 + v17);
      int v22 = (unsigned __int8 *)(v9 + v10 + v8 * (v11 + v17));
      do
      {
        if ((int)v6 >= 1)
        {
          uint64_t v23 = *v20;
          uint64_t v24 = v22;
          size_t v25 = (unsigned __int8 *)result;
          uint64_t v26 = v6;
          do
          {
            int v28 = *v24++;
            int v27 = v28;
            int v29 = *v25++;
            v23 += ((v27 - v29) * (v27 - v29));
            --v26;
          }
          while (v26);
          *uint64_t v20 = v23;
        }
        ++v21;
        result += v12;
        v22 += v8;
      }
      while (v21 != v19);
    }
    uint64_t v14 = v18;
  }
  while (v18 != 3);
  uint64_t v30 = 0;
  int v31 = v33;
  do
  {
    for (uint64_t i = 0; i != 24; i += 8)
      *(double *)(a3 + i) = (double)(unint64_t)(3 * *(void *)((char *)v31 + i));
    ++v30;
    a3 += 24;
    int v31 = (_OWORD *)((char *)v31 + 24);
  }
  while (v30 != 3);
  return result;
}

uint64_t sub_1BBA1125C(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  double v8 = sub_1BBA12160((uint64_t)v73);
  v73[0] = &unk_1F14EE0C0;
  uint64_t v80 = 0;
  int v81 = 0;
  uint64_t v82 = 0;
  char v83 = 0;
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v9 = (__CVBuffer *)(*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 96))(a1, v8);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v9);
  int v11 = *(_DWORD *)(a2 + 276);
  int v65 = *(_DWORD *)(a2 + 408);
  int v66 = *(_DWORD *)(a2 + 400);
  int v12 = *(_DWORD *)(a2 + 280);
  int v63 = *(_DWORD *)(a2 + 412);
  int v64 = *(_DWORD *)(a2 + 404);
  uint64_t v13 = *(void *)(a2 + 112);
  uint64_t v14 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  signed int v15 = CVPixelBufferGetPixelFormatType(v14);
  char v16 = 0;
  int v61 = v12;
  int v62 = v11;
  if (v15 <= 2016687155)
  {
    BOOL v17 = v15 == 1278226736;
    int v18 = 2016686640;
  }
  else
  {
    BOOL v17 = v15 == 2016687156 || v15 == 2019963956;
    int v18 = 2019963440;
  }
  if (v17 || v15 == v18) {
    char v16 = 8 - sub_1BBA13A1C(v15);
  }
  uint64_t v20 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 40))(a2, 0);
  uint64_t v21 = *(int *)(a2 + 400);
  uint64_t v22 = *(int *)(a2 + 404);
  if (CVIsCompressedPixelFormatAvailable(PixelFormatType))
  {
    int v60 = a4;
    CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    OSStatus v24 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
    if (v24)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CMSampleTimingInfo buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v24;
        _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate for PSNR calculation failed with error: %d\n", buf, 8u);
      }
      goto LABEL_48;
    }
    size_t Width = CVPixelBufferGetWidth(v9);
    size_t Height = CVPixelBufferGetHeight(v9);
    *(void *)CMSampleTimingInfo buf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, (const void *)*MEMORY[0x1E4F24D20], Mutable);
    uint64_t v31 = a3;
    DescriptionWithOSType PixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
    CFNumberRef Value = CFDictionaryGetValue(DescriptionWithPixelFormatType, (const void *)*MEMORY[0x1E4F24E50]);
    if (sub_1BBA13A1C(PixelFormatType) != 8 || !CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F24E60]))
    {
      a3 = v31;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v70 = 0;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "Bit depth of source pixel buffer is not 8 or source pixel buffer is not video range for PSNR calculation";
        uint32_t v57 = 2;
        goto LABEL_60;
      }
      goto LABEL_38;
    }
    CVReturn v34 = CVPixelBufferCreate(v23, Width, Height, 0x34323076u, *(CFDictionaryRef *)buf, &pixelBufferOut);
    a3 = v31;
    if (v34)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v70 = 67109120;
        CVReturn v71 = v34;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "CVPixelBufferCreate for PSNR calculation failed with error: %d\n";
LABEL_57:
        uint32_t v57 = 8;
LABEL_60:
        _os_log_error_impl(&dword_1BB9B9000, v35, OS_LOG_TYPE_ERROR, v36, v70, v57);
        goto LABEL_38;
      }
      goto LABEL_38;
    }
    OSStatus v56 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, v9, pixelBufferOut);
    if (v56)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v70 = 67109120;
        CVReturn v71 = v56;
        uint64_t v35 = MEMORY[0x1E4F14500];
        uint64_t v36 = "Pixel transfer from compressed to linear format for PSNR calculation failed with error: %d\n";
        goto LABEL_57;
      }
LABEL_38:
      sub_1BB9BE228((const void **)&Mutable);
      sub_1BB9BE228((const void **)buf);
LABEL_48:
      unint64_t v39 = 0;
      goto LABEL_49;
    }
    CVPixelBufferGetPixelFormatType(pixelBufferOut);
    sub_1BBA133CC((uint64_t)v73, pixelBufferOut, 0);
    sub_1BB9BE228((const void **)&Mutable);
    sub_1BB9BE228((const void **)buf);
    a3 = v31;
    a4 = v60;
  }
  else
  {
    sub_1BBA133CC((uint64_t)v73, v9, 0);
  }
  int v25 = v62 - (v66 + v65);
  uint64_t v26 = (v61 - (v64 + v63));
  int v27 = (unsigned __int8 *)(v20 + v21 + v13 * v22);
  uint64_t v28 = v74;
  if (a4)
  {
    uint64_t v29 = v77;
    if (v74 || !sub_1BBA13E0C((uint64_t)v73)) {
      uint64_t v30 = v75;
    }
    else {
      uint64_t v30 = 0;
    }
    if ((int)v26 < 1) {
      goto LABEL_48;
    }
    uint64_t v47 = 0;
    unint64_t v39 = 0;
    uint64_t v48 = (unsigned __int8 *)(v30 + v78 + v29 * v79);
    do
    {
      if (v25 >= 1)
      {
        int v49 = v27;
        uint64x2_t v50 = v48;
        uint64_t v51 = (v62 - (v66 + v65));
        do
        {
          int v53 = *v49++;
          int v52 = v53;
          int v54 = *v50++;
          v39 += ((v52 - v54) * (v52 - v54));
          --v51;
        }
        while (v51);
      }
      ++v47;
      v48 += v29;
      v27 += v13;
    }
    while (v47 != v26);
  }
  else
  {
    uint64_t v37 = v76;
    if (!v74)
    {
      if (sub_1BBA13E0C((uint64_t)v73)) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = v74;
      }
    }
    if ((int)v26 < 1) {
      goto LABEL_48;
    }
    uint64_t v38 = 0;
    unint64_t v39 = 0;
    uint64_t v40 = (unsigned __int8 *)(v28 + v78 + v37 * v79);
    do
    {
      if (v25 >= 1)
      {
        uint64_t v41 = v27;
        uint64_t v42 = v40;
        uint64_t v43 = (v62 - (v66 + v65));
        do
        {
          unsigned int v45 = *v41++;
          unsigned int v44 = v45;
          unsigned int v46 = *v42++;
          v39 += ((v44 >> v16) - (v46 >> v16)) * ((v44 >> v16) - (v46 >> v16));
          --v43;
        }
        while (v43);
      }
      ++v38;
      v40 += v37;
      v27 += v13;
    }
    while (v38 != v26);
  }
LABEL_49:
  if (pixelBufferOut) {
    CVPixelBufferRelease(pixelBufferOut);
  }
  if (pixelTransferSessionOut) {
    CFRelease(pixelTransferSessionOut);
  }
  *(double *)a3 = (double)v39;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  return sub_1BBA141AC((uint64_t)v73);
}

void sub_1BBA1184C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, const void *);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  va_copy(va2, va1);
  signed int v15 = va_arg(va2, const void *);
  uint64_t v17 = va_arg(va2, void);
  sub_1BB9BE228((const void **)va);
  sub_1BB9BE228((const void **)va1);
  sub_1BBA141AC((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1BBA118B4(uint64_t *a1, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  uint64_t v4 = *a1;
  if (*((unsigned char *)a1 + 136))
  {
    int v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 56))(a1, 0);
    uint64_t v6 = a1 + 22;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, 1);
    double v8 = a1 + 21;
  }
  else
  {
    int v5 = (char *)(*(uint64_t (**)(uint64_t *, void))(v4 + 40))(a1, 0);
    uint64_t v6 = a1 + 15;
    uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, 1);
    double v8 = a1 + 14;
  }
  uint64_t v9 = 0;
  uint64_t v10 = *v6;
  uint64_t v11 = *v8;
  do
  {
    *((unsigned char *)&c + v9 + 92) = 1;
    *((unsigned char *)&c + v9 + 92) = CC_MD5_Init((CC_MD5_CTX *)((char *)&c + v9)) != 0;
    v9 += 96;
  }
  while (v9 != 288);
  if (*((_DWORD *)a1 + 70))
  {
    for (unint64_t i = 0; i < v14; ++i)
    {
      char v13 = CC_MD5_Update(&c, v5, *((_DWORD *)a1 + 69));
      v33 &= v13;
      v5 += v11;
      int v14 = *((_DWORD *)a1 + 70);
    }
    uint64_t v15 = v14;
    if (!v7) {
      goto LABEL_22;
    }
  }
  else
  {
    int v14 = 0;
    uint64_t v15 = 0;
    if (!v7) {
      goto LABEL_22;
    }
  }
  uint64_t v16 = *((int *)a1 + 69);
  uint64_t v17 = (int)v16 * (uint64_t)v14;
  if (v17)
  {
    sub_1BB9C1970((unint64_t *)__p, 2 * (int)v17);
    int v18 = (char *)__p[0];
  }
  else
  {
    int v18 = 0;
  }
  int v19 = &v18[v17];
  if (v14)
  {
    uint64_t v20 = v7 + 2 * v16 - 1;
    uint64_t v21 = v18;
    uint64_t v22 = &v18[v17];
    do
    {
      if (v16)
      {
        CFAllocatorRef v23 = (char *)v20;
        uint64_t v24 = v16;
        do
        {
          v21[v24 - 1] = *(v23 - 1);
          char v25 = *v23;
          v23 -= 2;
          v22[--v24] = v25;
        }
        while (v24);
      }
      v21 += v16;
      v22 += v16;
      v20 += v10;
      --v15;
    }
    while (v15);
  }
  char v26 = CC_MD5_Update(&v34, v18, v16 * v14);
  v35 &= v26;
  char v27 = CC_MD5_Update(&v36, v19, v16 * v14);
  v37 &= v27;
LABEL_22:
  int v28 = CC_MD5_Final((unsigned __int8 *)a2, &c);
  int v29 = v33;
  if (__p[0]) {
    operator delete(__p[0]);
  }
  if ((v28 & v29) != 0) {
    return 0;
  }
  else {
    return 4294954385;
  }
}

void sub_1BBA11B94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA11BB8(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276);
  int v5 = *(_DWORD *)(a1 + 400);
  int v6 = *(_DWORD *)(a1 + 408);
  uint64_t v7 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t result = 0;
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v7)
  {
    uint64_t v11 = v8 + *(int *)(a1 + 400);
    size_t v12 = v4 - (v5 + v6);
    do
      fwrite((const void *)(v11 + *(void *)(a1 + 112) * v10++), 1uLL, v12, a2);
    while (v10 < v7);
    return 0;
  }
  return result;
}

uint64_t sub_1BBA11C94(uint64_t a1, FILE *a2)
{
  if (!a2) {
    return 4294954394;
  }
  int v4 = *(_DWORD *)(a1 + 276);
  int v5 = *(_DWORD *)(a1 + 400);
  int v6 = *(_DWORD *)(a1 + 408);
  uint64_t v7 = *(int *)(a1 + 280) - (uint64_t)*(int *)(a1 + 412);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 40))(a1, 0);
  uint64_t result = 0;
  uint64_t v10 = *(int *)(a1 + 404);
  if ((int)v10 < (int)v7)
  {
    uint64_t v11 = v8 + *(int *)(a1 + 400);
    size_t v12 = v4 - (v5 + v6);
    do
      fwrite((const void *)(v11 + *(void *)(a1 + 112) * v10++), 1uLL, v12, a2);
    while (v10 < v7);
    return 0;
  }
  return result;
}

void sub_1BBA11D70(_DWORD *a1, double *a2, double *a3)
{
  double v5 = (double)(unint64_t)(1046529 * (a1[69] - (a1[100] + a1[102])) * (uint64_t)(a1[70] - (a1[101] + a1[103])));
  double v6 = 999.0;
  double v7 = 999.0;
  if (*a2 > 0.0) {
    double v7 = log10(v5 / *a2) * 10.0;
  }
  *a3 = v7;
  double v8 = a2[1];
  double v9 = 999.0;
  if (v8 > 0.0) {
    double v9 = log10(v5 * 0.25 / v8) * 10.0;
  }
  a3[1] = v9;
  double v10 = a2[2];
  double v11 = 999.0;
  if (v10 > 0.0) {
    double v11 = log10(v5 * 0.25 / v10) * 10.0;
  }
  a3[2] = v11;
  double v12 = *a2 + a2[1] + a2[2];
  if (v12 > 0.0) {
    double v6 = log10(v5 * 1.5 / v12) * 10.0;
  }
  a3[3] = v6;
}

void sub_1BBA11E90(_DWORD *a1, double *a2, double *a3)
{
  double v5 = (double)(unint64_t)(261121 * (a1[69] - (a1[100] + a1[102])) * (uint64_t)(a1[70] - (a1[101] + a1[103])));
  double v6 = 999.0;
  double v7 = 999.0;
  if (*a2 > 0.0) {
    double v7 = log10(v5 / *a2) * 10.0;
  }
  *a3 = v7;
  double v8 = a2[1];
  double v9 = 999.0;
  if (v8 > 0.0) {
    double v9 = log10(v5 * 0.25 / v8) * 10.0;
  }
  a3[1] = v9;
  double v10 = a2[2];
  double v11 = 999.0;
  if (v10 > 0.0) {
    double v11 = log10(v5 * 0.25 / v10) * 10.0;
  }
  a3[2] = v11;
  double v12 = *a2 + a2[1] + a2[2];
  if (v12 > 0.0) {
    double v6 = log10(v5 * 1.5 / v12) * 10.0;
  }
  a3[3] = v6;
}

void sub_1BBA11FB0(_DWORD *a1, double *a2, double *a3)
{
  double v5 = (double)(unint64_t)(65025 * (a1[69] - (a1[100] + a1[102])) * (uint64_t)(a1[70] - (a1[101] + a1[103])));
  double v6 = 999.0;
  double v7 = 999.0;
  if (*a2 > 0.0) {
    double v7 = log10(v5 / *a2) * 10.0;
  }
  *a3 = v7;
  double v8 = a2[1];
  double v9 = 999.0;
  if (v8 > 0.0) {
    double v9 = log10(v5 * 0.25 / v8) * 10.0;
  }
  a3[1] = v9;
  double v10 = a2[2];
  double v11 = 999.0;
  if (v10 > 0.0) {
    double v11 = log10(v5 * 0.25 / v10) * 10.0;
  }
  a3[2] = v11;
  double v12 = *a2 + a2[1] + a2[2];
  if (v12 > 0.0) {
    double v6 = log10(v5 * 1.5 / v12) * 10.0;
  }
  a3[3] = v6;
}

uint64_t sub_1BBA120D0(uint64_t a1, int a2)
{
  return *(void *)(a1 + 8 * a2 + 144);
}

uint64_t sub_1BBA120DC(uint64_t a1, int a2)
{
  return *(void *)(a1 + 8 * a2 + 144);
}

uint64_t sub_1BBA120E8(uint64_t a1, int a2)
{
  return *(void *)(a1 + 8 * a2 + 88);
}

uint64_t sub_1BBA120F4(uint64_t a1, int a2)
{
  return *(void *)(a1 + 8 * a2 + 88);
}

uint64_t sub_1BBA12100(uint64_t a1, int a2, int a3, int a4)
{
  return *(void *)(a1 + 8 * a4 + 88)
       + ((*(void *)(a1 + 8 * a4 + 112) * a3 + (a2 << a4)) << *(unsigned char *)(a1 + 286));
}

uint64_t sub_1BBA1212C(uint64_t a1, int a2, int a3, int a4)
{
  return *(void *)(a1 + 8 * a4 + 88)
       + ((*(void *)(a1 + 8 * a4 + 112) * a3 + (a2 << a4)) << *(unsigned char *)(a1 + 286));
}

double sub_1BBA12160(uint64_t a1)
{
  *(void *)a1 = &unk_1F14EEA18;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 272) = 1;
  double result = 0.0;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_WORD *)(a1 + 284) = 0;
  *(void *)(a1 + 276) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(void *)(a1 + 944) = a1;
  *(void *)(a1 + 1029) = 0;
  *(_OWORD *)(a1 + 1016) = 0u;
  *(_OWORD *)(a1 + 1000) = 0u;
  *(_OWORD *)(a1 + 984) = 0u;
  *(_OWORD *)(a1 + 968) = 0u;
  *(_OWORD *)(a1 + 952) = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(void *)(a1 + 1104) = 850045863;
  *(_OWORD *)(a1 + 1112) = 0u;
  *(_OWORD *)(a1 + 1128) = 0u;
  *(_OWORD *)(a1 + 1144) = 0u;
  *(void *)(a1 + 1160) = 0;
  *(void *)(a1 + 1168) = 1018212795;
  *(_OWORD *)(a1 + 1176) = 0u;
  *(_OWORD *)(a1 + 1192) = 0u;
  *(void *)(a1 + 1208) = 0;
  *(void *)(a1 + 656) = 0;
  *(_WORD *)(a1 + 45) = 0;
  *(_DWORD *)(a1 + 680) = 0;
  *(void *)(a1 + 36) = 0;
  *(unsigned char *)(a1 + 300) = 0;
  *(unsigned char *)(a1 + 349) = 0;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(void *)(a1 + 488) = 0;
  *(_OWORD *)(a1 + 472) = 0u;
  *(void *)(a1 + 552) = 0;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  return result;
}

uint64_t sub_1BBA1226C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v5 = 1;
  if (a3 && *(unsigned char *)(a1 + 136))
  {
    int v6 = *(_DWORD *)(a1 + 276);
    int v8 = *(_DWORD *)(a1 + 240);
    int v7 = *(_DWORD *)(a1 + 244);
    int v9 = *(_DWORD *)(a1 + 280);
    if (v8 != v6 || v7 != v9)
    {
      int v12 = v6 - (*(_DWORD *)(a1 + 400) + *(_DWORD *)(a1 + 408));
      int v13 = v9 - (*(_DWORD *)(a1 + 404) + *(_DWORD *)(a1 + 412));
      int v14 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
      uint64_t v15 = (__CVBuffer *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 104))(a1);
      uint64_t v16 = sub_1BBAA6374((_DWORD *)a3, v8, v7, v12, v13, v14, v15);
      if (v16)
      {
LABEL_34:
        *(void *)(a1 + 248) = 0;
        return v16;
      }
      uint64_t v16 = CVPixelBufferLockBaseAddress(v14, 1uLL);
      if (v16)
      {
LABEL_11:
        CVBufferPropagateAttachments(v14, v15);
        goto LABEL_34;
      }
      uint64_t v17 = CVPixelBufferLockBaseAddress(v15, 0);
      if (v17)
      {
        uint64_t v16 = v17;
        CVPixelBufferUnlockBaseAddress(v14, 1uLL);
        goto LABEL_11;
      }
      *(void *)a3 = CVPixelBufferGetBaseAddressOfPlane(v14, 0);
      *(void *)(a3 + 8) = CVPixelBufferGetBaseAddressOfPlane(v14, 1uLL);
      *(void *)(a3 + 16) = CVPixelBufferGetBaseAddressOfPlane(v15, 0);
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(v15, 1uLL);
      *(void *)(a3 + 24) = BaseAddressOfPlane;
      if (*(void *)a3 && *(void *)(a3 + 8) && *(void *)(a3 + 16) && BaseAddressOfPlane)
      {
        *(void *)(a3 + 32) = CVPixelBufferGetBytesPerRowOfPlane(v14, 0);
        *(void *)(a3 + 40) = CVPixelBufferGetBytesPerRowOfPlane(v14, 1uLL);
        *(void *)(a3 + 48) = CVPixelBufferGetBytesPerRowOfPlane(v15, 0);
        *(void *)(a3 + 56) = CVPixelBufferGetBytesPerRowOfPlane(v15, 1uLL);
        uint64_t v24 = *(int *)(a3 + 4252);
        unint64_t v25 = *(int *)(a3 + 4248) & 0xFFFFFFFFFFFFFFFELL;
        unint64_t v26 = v25 + *(void *)(a3 + 32) * v24;
        if ((int)v24 >= -1) {
          int v27 = v24 + 1;
        }
        else {
          int v27 = v24 + 2;
        }
        uint64_t v28 = *(void *)(a3 + 8) + v25 + *(void *)(a3 + 40) * ((uint64_t)v27 >> 1);
        *(void *)a3 += v26;
        *(void *)(a3 + 8) = v28;
        uint64_t v16 = sub_1BBAC8AEC((uint64_t *)a3, v19, v20, v21, v22, v23);
      }
      else
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v38 = 0;
          _os_log_error_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "NULL plane!\n", v38, 2u);
        }
        uint64_t v16 = 4294954394;
      }
      CVPixelBufferUnlockBaseAddress(v14, 1uLL);
      CVPixelBufferUnlockBaseAddress(v15, 0);
      CVBufferPropagateAttachments(v14, v15);
      if (v16) {
        goto LABEL_34;
      }
      uint64_t v29 = *(unsigned __int8 *)(a1 + 285);
      if (*(unsigned char *)(a1 + 285))
      {
        uint64_t v30 = (void *)(a1 + 112);
        do
        {
          *(v30 - 3) = v30[10];
          *uint64_t v30 = v30[13];
          ++v30;
          --v29;
        }
        while (v29);
      }
      char v5 = 0;
      *(void *)(a1 + 248) = *(void *)(a1 + 276);
    }
  }
  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 432))(a1, a2);
  uint64_t v16 = v31;
  if ((v5 & 1) == 0 && !v31)
  {
    if (!*(unsigned char *)(a1 + 136)) {
      return 0;
    }
    uint64_t v32 = 0;
    char v33 = 1;
    do
    {
      char v34 = v33;
      uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 48))(a1, v32);
      char v33 = 0;
      CC_MD5_CTX v36 = (void *)(a1 + 8 * v32);
      v36[11] = v35;
      v36[14] = v36[21];
      uint64_t v32 = 1;
    }
    while ((v34 & 1) != 0);
    uint64_t v16 = 0;
    goto LABEL_34;
  }
  return v16;
}

uint64_t sub_1BBA125DC(void **memptr, unint64_t a2)
{
  if ((unint64_t)memptr[1] >= a2) {
    return 0;
  }
  if (a2 > 0x3200000) {
    return 4294954392;
  }
  int v4 = *memptr;
  if (v4)
  {
    free(v4);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, 0x10uLL, 2 * a2, 0x1000040BDFB0063uLL) || !*memptr) {
    return 4294954392;
  }
  uint64_t v6 = 0;
  do
    *((_WORD *)*memptr + v6++) = 0;
  while (a2 != v6);
  uint64_t result = 0;
  memptr[1] = (void *)a2;
  return result;
}

uint64_t sub_1BBA12684(void **memptr, unint64_t a2)
{
  if ((unint64_t)memptr[1] >= a2) {
    return 0;
  }
  if (a2 > 0x640000) {
    return 4294954392;
  }
  int v4 = *memptr;
  if (v4)
  {
    free(v4);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, 0x10uLL, 16 * a2, 0x10000402CEA329FuLL) || !*memptr) {
    return 4294954392;
  }
  uint64_t v6 = 0;
  unint64_t v7 = a2;
  do
  {
    int v8 = (char *)*memptr + v6;
    void *v8 = 0;
    v8[1] = 0;
    v6 += 16;
    --v7;
  }
  while (v7);
  uint64_t result = 0;
  memptr[1] = (void *)a2;
  return result;
}

uint64_t sub_1BBA12730(void **memptr, size_t size, size_t alignment)
{
  if ((unint64_t)memptr[1] >= size) {
    return 0;
  }
  if (size > 0x6400000) {
    return 4294954392;
  }
  unsigned int v4 = alignment;
  uint64_t v6 = *memptr;
  if (v6)
  {
    free(v6);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, v4, size, 0x100004077774924uLL) || !*memptr) {
    return 4294954392;
  }
  uint64_t v8 = 0;
  do
    *((unsigned char *)*memptr + v8++) = 0;
  while (size != v8);
  uint64_t result = 0;
  memptr[1] = (void *)size;
  return result;
}

uint64_t sub_1BBA127E4(void **memptr, unint64_t a2)
{
  if ((unint64_t)memptr[1] >= a2) {
    return 0;
  }
  if (a2 > 0x640000) {
    return 4294954392;
  }
  unsigned int v4 = *memptr;
  if (v4)
  {
    free(v4);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, 0x10uLL, 16 * a2, 0x1000040451B5BE8uLL) || !*memptr) {
    return 4294954392;
  }
  uint64_t v6 = 0;
  unint64_t v7 = a2;
  do
  {
    uint64_t v8 = (char *)*memptr + v6;
    void *v8 = 0;
    v8[1] = 0;
    v6 += 16;
    --v7;
  }
  while (v7);
  uint64_t result = 0;
  memptr[1] = (void *)a2;
  return result;
}

uint64_t sub_1BBA12890(void *a1)
{
  if (!a1) {
    return 4294967246;
  }
  NSClassFromString(&cfstr_Vcprealtimeana.isa);
  unsigned int v2 = [(id)objc_opt_class() analysisService];
  unint64_t v3 = v2;
  if (v2)
  {
    id v4 = v2;
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 4294967188;
  }
  *a1 = v3;

  return v5;
}

void sub_1BBA12900(void *a1, uint64_t a2, unsigned int a3, uint64_t a4, void *a5)
{
  id v9 = a5;
  double v10 = v9;
  if (a1 && a2 && v9)
  {
    double v11 = (void *)MEMORY[0x1C1860C30]();
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = sub_1BBA12A08;
    v12[3] = &unk_1E6247CA0;
    id v13 = v10;
    [a1 requestAnalysis:a3 ofPixelBuffer:a2 withProperties:a4 withCompletionHandler:v12];
  }
}

void sub_1BBA129E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BBA12A08(uint64_t a1, void *a2, void *a3)
{
  id v6 = a2;
  id v5 = a3;
  (*(void (**)(void, uint64_t, id))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), [v5 code], v6);
}

void sub_1BBA12A7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1BBA12A94(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1BBA06688(a1, a2);
  if (!result)
  {
    int v5 = *(unsigned __int8 *)(a2 + 2000);
    BOOL v6 = v5 == 8;
    if (v5 == 8) {
      unint64_t v7 = sub_1BBA13138;
    }
    else {
      unint64_t v7 = sub_1BBA12F38;
    }
    uint64_t v8 = sub_1BBA12B10;
    if (v6) {
      uint64_t v8 = sub_1BBA12D24;
    }
    *(void *)(a1 + 1264) = v7;
    *(void *)(a1 + 1272) = v8;
  }
  return result;
}

unint64_t sub_1BBA12B10(int a1, unint64_t a2, CVPixelBufferRef pixelBuffer)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  CVPixelBufferGetHeight(pixelBuffer);
  uint64x2_t v30 = 0u;
  uint64x2_t v31 = 0u;
  CVPixelBufferGetExtendedPixels(pixelBuffer, (size_t *)&v30, &v30.u64[1], (size_t *)&v31, &v31.u64[1]);
  uint64x2_t v30 = vshrq_n_u64(v30, 1uLL);
  uint64x2_t v31 = vshrq_n_u64(v31, 1uLL);
  size_t v7 = Width >> 1;
  unint64_t v8 = a1 & ~(a1 >> 31);
  BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
  unint64_t result = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
  unint64_t v11 = result >> 2;
  uint64_t v12 = v30.i64[0];
  unint64_t v13 = 4 * (result >> 2);
  if (v8 < a2)
  {
    int v14 = &BaseAddressOfPlane[4 * v11 * v8];
    uint64_t v15 = &v14[4 * v7 - 4];
    uint64_t v16 = v30.i64[1];
    do
    {
      if (v12)
      {
        int v17 = *(_DWORD *)v14;
        uint64_t v18 = -v12;
        do
          *(_DWORD *)&v14[4 * v18] = v17;
        while (!__CFADD__(v18++, 1));
      }
      if (v16)
      {
        int v20 = *(_DWORD *)v15;
        uint64_t v21 = 4 * v7;
        uint64_t v22 = v16;
        do
        {
          *(_DWORD *)&v14[v21] = v20;
          v21 += 4;
          --v22;
        }
        while (v22);
      }
      ++v8;
      v14 += v13;
      v15 += 4 * v11;
    }
    while (v8 != a2);
  }
  if (a1 < 1 && v31.i64[0])
  {
    unint64_t v23 = 0;
    uint64_t v24 = &BaseAddressOfPlane[-4 * v12];
    unint64_t v25 = &BaseAddressOfPlane[-4 * v12 + -4 * v11];
    do
    {
      unint64_t result = (unint64_t)memcpy(v25, v24, 4 * (v30.i64[0] + v7 + v30.i64[1]));
      ++v23;
      v25 -= 4 * v11;
    }
    while (v31.i64[0] > v23);
    uint64_t v12 = v30.i64[0];
  }
  if (v31.i64[1])
  {
    unint64_t v26 = 0;
    int v27 = &BaseAddressOfPlane[-4 * v12];
    uint64_t v28 = &v27[4 * v11 * (a2 - 1)];
    uint64_t v29 = &v27[4 * a2 * v11];
    do
    {
      unint64_t result = (unint64_t)memcpy(v29, v28, 4 * (v30.i64[0] + v7 + v30.i64[1]));
      ++v26;
      v29 += v13;
    }
    while (v31.i64[1] > v26);
  }
  return result;
}

unint64_t sub_1BBA12D24(int a1, unint64_t a2, CVPixelBufferRef pixelBuffer)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  CVPixelBufferGetHeight(pixelBuffer);
  uint64x2_t v30 = 0u;
  uint64x2_t v31 = 0u;
  CVPixelBufferGetExtendedPixels(pixelBuffer, (size_t *)&v30, &v30.u64[1], (size_t *)&v31, &v31.u64[1]);
  uint64x2_t v30 = vshrq_n_u64(v30, 1uLL);
  uint64x2_t v31 = vshrq_n_u64(v31, 1uLL);
  size_t v7 = Width >> 1;
  unint64_t v8 = a1 & ~(a1 >> 31);
  BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
  unint64_t result = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
  unint64_t v11 = result >> 1;
  uint64_t v12 = v30.i64[0];
  unint64_t v13 = 2 * (result >> 1);
  if (v8 < a2)
  {
    int v14 = &BaseAddressOfPlane[2 * v11 * v8];
    uint64_t v15 = &v14[2 * v7 - 2];
    uint64_t v16 = v30.i64[1];
    do
    {
      if (v12)
      {
        __int16 v17 = *(_WORD *)v14;
        uint64_t v18 = -v12;
        do
          *(_WORD *)&v14[2 * v18] = v17;
        while (!__CFADD__(v18++, 1));
      }
      if (v16)
      {
        __int16 v20 = *(_WORD *)v15;
        uint64_t v21 = 2 * v7;
        uint64_t v22 = v16;
        do
        {
          *(_WORD *)&v14[v21] = v20;
          v21 += 2;
          --v22;
        }
        while (v22);
      }
      ++v8;
      v14 += v13;
      v15 += 2 * v11;
    }
    while (v8 != a2);
  }
  if (a1 < 1 && v31.i64[0])
  {
    unint64_t v23 = 0;
    uint64_t v24 = &BaseAddressOfPlane[-2 * v12];
    unint64_t v25 = &BaseAddressOfPlane[-2 * v12 + -2 * v11];
    do
    {
      unint64_t result = (unint64_t)memcpy(v25, v24, 2 * (v30.i64[0] + v7 + v30.i64[1]));
      ++v23;
      v25 -= 2 * v11;
    }
    while (v31.i64[0] > v23);
    uint64_t v12 = v30.i64[0];
  }
  if (v31.i64[1])
  {
    unint64_t v26 = 0;
    int v27 = &BaseAddressOfPlane[-2 * v12];
    uint64_t v28 = &v27[2 * v11 * (a2 - 1)];
    uint64_t v29 = &v27[2 * a2 * v11];
    do
    {
      unint64_t result = (unint64_t)memcpy(v29, v28, 2 * (v30.i64[0] + v7 + v30.i64[1]));
      ++v26;
      v29 += v13;
    }
    while (v31.i64[1] > v26);
  }
  return result;
}

unint64_t sub_1BBA12F38(int a1, unint64_t a2, CVPixelBufferRef pixelBuffer)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  CVPixelBufferGetHeight(pixelBuffer);
  long long v29 = 0u;
  long long v30 = 0u;
  CVPixelBufferGetExtendedPixels(pixelBuffer, (size_t *)&v29, (size_t *)&v29 + 1, (size_t *)&v30, (size_t *)&v30 + 1);
  unint64_t v7 = a1 & ~(a1 >> 31);
  BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
  unint64_t result = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
  unint64_t v10 = result >> 1;
  uint64_t v11 = v29;
  unint64_t v12 = 2 * (result >> 1);
  if (v7 < a2)
  {
    unint64_t v13 = &BaseAddressOfPlane[2 * v10 * v7];
    int v14 = &v13[2 * Width - 2];
    uint64_t v15 = *((void *)&v29 + 1);
    do
    {
      if (v11)
      {
        __int16 v16 = *(_WORD *)v13;
        uint64_t v17 = -v11;
        do
          *(_WORD *)&v13[2 * v17] = v16;
        while (!__CFADD__(v17++, 1));
      }
      if (v15)
      {
        __int16 v19 = *(_WORD *)v14;
        uint64_t v20 = 2 * Width;
        uint64_t v21 = v15;
        do
        {
          *(_WORD *)&v13[v20] = v19;
          v20 += 2;
          --v21;
        }
        while (v21);
      }
      ++v7;
      v13 += v12;
      v14 += 2 * v10;
    }
    while (v7 != a2);
  }
  if (a1 < 1 && (void)v30)
  {
    unint64_t v22 = 0;
    unint64_t v23 = &BaseAddressOfPlane[-2 * v11];
    uint64_t v24 = &BaseAddressOfPlane[-2 * v11 + -2 * v10];
    do
    {
      unint64_t result = (unint64_t)memcpy(v24, v23, 2 * (v29 + Width + *((void *)&v29 + 1)));
      ++v22;
      v24 -= 2 * v10;
    }
    while ((unint64_t)v30 > v22);
    uint64_t v11 = v29;
  }
  if (*((void *)&v30 + 1))
  {
    unint64_t v25 = 0;
    unint64_t v26 = &BaseAddressOfPlane[-2 * v11];
    int v27 = &v26[2 * v10 * (a2 - 1)];
    uint64_t v28 = &v26[2 * a2 * v10];
    do
    {
      unint64_t result = (unint64_t)memcpy(v28, v27, 2 * (v29 + Width + *((void *)&v29 + 1)));
      ++v25;
      v28 += v12;
    }
    while (*((void *)&v30 + 1) > v25);
  }
  return result;
}

uint64_t sub_1BBA13138(int a1, unint64_t a2, CVPixelBufferRef pixelBuffer)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  CVPixelBufferGetHeight(pixelBuffer);
  *(_OWORD *)__len = 0u;
  long long v21 = 0u;
  CVPixelBufferGetExtendedPixels(pixelBuffer, __len, &__len[1], (size_t *)&v21, (size_t *)&v21 + 1);
  unint64_t v7 = a1 & ~(a1 >> 31);
  BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
  uint64_t result = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
  uint64_t v10 = result;
  unint64_t v11 = a2 - v7;
  if (a2 > v7)
  {
    unint64_t v12 = &BaseAddressOfPlane[result * v7];
    do
    {
      memset(&v12[-__len[0]], *v12, __len[0]);
      uint64_t result = (uint64_t)memset(&v12[Width], v12[Width - 1], __len[1]);
      v12 += v10;
      --v11;
    }
    while (v11);
  }
  size_t v13 = __len[0];
  if (a1 < 1 && (void)v21)
  {
    unint64_t v14 = 0;
    uint64_t v15 = &BaseAddressOfPlane[-__len[0]];
    __int16 v16 = &BaseAddressOfPlane[-v10 - __len[0]];
    do
    {
      uint64_t result = (uint64_t)memcpy(v16, v15, __len[0] + Width + __len[1]);
      ++v14;
      v16 -= v10;
    }
    while ((unint64_t)v21 > v14);
    size_t v13 = __len[0];
  }
  if (*((void *)&v21 + 1))
  {
    unint64_t v17 = 0;
    uint64_t v18 = &BaseAddressOfPlane[v10 * (a2 - 1) - v13];
    __int16 v19 = &BaseAddressOfPlane[v10 * a2 - v13];
    do
    {
      uint64_t result = (uint64_t)memcpy(v19, v18, __len[0] + Width + __len[1]);
      ++v17;
      v19 += v10;
    }
    while (*((void *)&v21 + 1) > v17);
  }
  return result;
}

uint64_t sub_1BBA132EC(uint64_t a1)
{
  return *(void *)(a1 + 1248);
}

uint64_t sub_1BBA132F4(uint64_t a1)
{
  return *(void *)(a1 + 1232);
}

uint64_t sub_1BBA132FC(uint64_t a1)
{
  return *(void *)(a1 + 1232);
}

uint64_t sub_1BBA13304(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (!*(unsigned char *)(a1 + 136))
  {
    id v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8 * a4 + 1264);
    uint64_t v5 = a3;
    goto LABEL_5;
  }
  id v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8 * a4 + 1264);
  uint64_t v5 = a3;
  if (*(void *)(a1 + 88) == *(void *)(a1 + 144))
  {
LABEL_5:
    uint64_t v6 = *(void *)(a1 + 1232);
    return v4(a2, v5, v6);
  }
  uint64_t v6 = *(void *)(a1 + 1248);
  return v4(a2, v5, v6);
}

double sub_1BBA1334C(uint64_t a1)
{
  unsigned int v2 = *(__CVBuffer **)(a1 + 1232);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 1256))
    {
      CVPixelBufferUnlockBaseAddress(v2, *(unsigned int *)(a1 + 1240));
      *(unsigned char *)(a1 + 1256) = 0;
      unsigned int v2 = *(__CVBuffer **)(a1 + 1232);
    }
    CVPixelBufferRelease(v2);
    *(void *)(a1 + 1232) = 0;
  }
  unint64_t v3 = *(__CVBuffer **)(a1 + 1248);
  if (v3)
  {
    CVPixelBufferUnlockBaseAddress(v3, 0);
    CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 1248));
    *(void *)(a1 + 1248) = 0;
  }
  double result = 0.0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  return result;
}

uint64_t sub_1BBA133CC(uint64_t a1, CVPixelBufferRef pixelBuffer, __CVBuffer *a3)
{
  signed int PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  if (!sub_1BBA136E8(PixelFormatType)) {
    return 4294954394;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  *(void *)(a1 + 1232) = CVPixelBufferRetain(pixelBuffer);
  char v7 = 1;
  *(_DWORD *)(a1 + 1240) = 1;
  *(_DWORD *)(a1 + 276) = CVPixelBufferGetWidth(pixelBuffer);
  *(_DWORD *)(a1 + 280) = CVPixelBufferGetHeight(pixelBuffer);
  Planeunsigned int Count = CVPixelBufferGetPlaneCount(pixelBuffer);
  *(unsigned char *)(a1 + 285) = PlaneCount;
  if (PixelFormatType <= 875836517)
  {
    if (PixelFormatType > 645428787)
    {
      if (PixelFormatType == 645428788) {
        goto LABEL_24;
      }
      if (PixelFormatType != 875704934 && PixelFormatType != 875704950) {
        goto LABEL_25;
      }
    }
    else if (PixelFormatType != 641230386 && PixelFormatType != 641234482)
    {
      int v10 = 645424692;
      goto LABEL_23;
    }
    char v7 = 2;
    goto LABEL_25;
  }
  if (PixelFormatType <= 1278226735)
  {
    if (PixelFormatType != 875836518 && PixelFormatType != 875836534)
    {
      int v9 = 1278226488;
      goto LABEL_14;
    }
    goto LABEL_24;
  }
  if (PixelFormatType > 2016687155)
  {
    if (PixelFormatType != 2016687156)
    {
      int v10 = 2019963956;
LABEL_23:
      if (PixelFormatType != v10) {
        goto LABEL_25;
      }
    }
LABEL_24:
    char v7 = 3;
    goto LABEL_25;
  }
  if (PixelFormatType == 1278226736) {
    goto LABEL_15;
  }
  int v9 = 1751411059;
LABEL_14:
  if (PixelFormatType == v9)
  {
LABEL_15:
    *(unsigned char *)(a1 + 287) = 0;
    if (!PlaneCount)
    {
      *(unsigned char *)(a1 + 285) = 1;
LABEL_28:
      unsigned int v11 = sub_1BBA13A1C(PixelFormatType);
      size_t v12 = 0;
      char v13 = v11 > 8;
      do
      {
        *(void *)(a1 + 112 + 8 * v12) = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, v12) >> v13;
        ++v12;
      }
      while (v12 < *(unsigned __int8 *)(a1 + 285));
      if (!a3) {
        return 0;
      }
      goto LABEL_35;
    }
    goto LABEL_32;
  }
LABEL_25:
  *(unsigned char *)(a1 + 287) = v7;
  if (PlaneCount)
  {
    if (PixelFormatType == 1982882104)
    {
      if (PlaneCount <= 3u) {
        goto LABEL_28;
      }
      return 4294954386;
    }
LABEL_32:
    if (PlaneCount <= 2u) {
      goto LABEL_28;
    }
    return 4294954386;
  }
  char v13 = sub_1BBA13A1C(PixelFormatType) > 8;
  if (!a3) {
    return 0;
  }
LABEL_35:
  OSType v15 = CVPixelBufferGetPixelFormatType(a3);
  if (!sub_1BBA136E8(v15)) {
    return 4294954394;
  }
  uint64_t result = CVPixelBufferLockBaseAddress(a3, 0);
  if (result) {
    return result;
  }
  *(void *)(a1 + 1248) = CVPixelBufferRetain(a3);
  if (CVPixelBufferGetWidth(a3) != *(_DWORD *)(a1 + 276) || CVPixelBufferGetHeight(a3) != *(_DWORD *)(a1 + 280)) {
    return 4294954394;
  }
  if (!*(unsigned char *)(a1 + 285)) {
    return 0;
  }
  size_t v16 = 0;
  char v17 = v13;
  do
  {
    uint64_t v18 = (void *)(a1 + 8 * v16);
    v18[24] = CVPixelBufferGetBaseAddressOfPlane(a3, v16);
    size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a3, v16);
    uint64_t result = 0;
    v18[27] = BytesPerRowOfPlane >> v17;
    v18[21] = v18[14];
    ++v16;
  }
  while (v16 < *(unsigned __int8 *)(a1 + 285));
  return result;
}

uint64_t sub_1BBA136E8(int a1)
{
  uint64_t result = 1;
  if (a1 <= 875704949)
  {
    if (a1 <= 758674991)
    {
      if (a1 <= 645424687)
      {
        if (a1 > 641234479)
        {
          if (a1 == 641234480) {
            return result;
          }
          unsigned __int16 v4 = 30260;
        }
        else
        {
          if (a1 == 641230384) {
            return result;
          }
          unsigned __int16 v4 = 26164;
        }
        int v3 = v4 | 0x26380000;
        goto LABEL_56;
      }
      if (a1 <= 645428783)
      {
        if (a1 == 645424688) {
          return result;
        }
        int v3 = 645424692;
        goto LABEL_56;
      }
      if (a1 == 645428784 || a1 == 645428788) {
        return result;
      }
      int v3 = 758670896;
    }
    else if (a1 > 796419631)
    {
      if (a1 <= 875704421)
      {
        if (a1 == 796419632) {
          return result;
        }
        int v3 = 796423728;
        goto LABEL_56;
      }
      if (a1 == 875704422 || a1 == 875704438) {
        return result;
      }
      int v3 = 875704934;
    }
    else
    {
      if (a1 <= 762869295)
      {
        if (a1 == 758674992) {
          return result;
        }
        int v3 = 762865200;
        goto LABEL_56;
      }
      if (a1 == 762869296 || a1 == 792225328) {
        return result;
      }
      int v3 = 792229424;
    }
    goto LABEL_56;
  }
  if (a1 > 1751411058)
  {
    if (a1 > 2019963955)
    {
      if (a1 <= 2084075055)
      {
        if (a1 == 2019963956) {
          return result;
        }
        int v3 = 2084070960;
        goto LABEL_56;
      }
      if (a1 == 2084075056 || a1 == 2088265264) {
        return result;
      }
      int v3 = 2088269360;
    }
    else
    {
      if (a1 <= 2016686639)
      {
        if (a1 == 1751411059) {
          return result;
        }
        int v3 = 1982882104;
        goto LABEL_56;
      }
      if (a1 == 2016686640 || a1 == 2016687156) {
        return result;
      }
      int v3 = 2019963440;
    }
LABEL_56:
    if (a1 != v3) {
      return 0;
    }
    return result;
  }
  if (a1 > 1496395841)
  {
    if (a1 <= 1563981359)
    {
      if (a1 == 1496395842) {
        return result;
      }
      int v3 = 1563977268;
      goto LABEL_56;
    }
    if (a1 == 1563981360 || a1 == 1563981364) {
      return result;
    }
    int v3 = 1568171568;
    goto LABEL_56;
  }
  if (a1 <= 875836533)
  {
    if (a1 == 875704950) {
      return result;
    }
    int v3 = 875836518;
    goto LABEL_56;
  }
  if (a1 != 875836534 && a1 != 1278226488)
  {
    int v3 = 1278226736;
    goto LABEL_56;
  }
  return result;
}

uint64_t sub_1BBA13A1C(int a1)
{
  uint64_t result = 8;
  if (a1 <= 1278226487)
  {
    if (a1 <= 758674991)
    {
      if (a1 <= 642527535)
      {
        if (a1 <= 641234479)
        {
          if (a1 == 641230384) {
            return result;
          }
          int v5 = 641230388;
        }
        else
        {
          if (a1 == 641234480 || a1 == 641234484) {
            return result;
          }
          int v5 = 642527288;
        }
      }
      else
      {
        if (a1 <= 645428783)
        {
          if (a1 == 642527536 || a1 == 645424688) {
            return 10;
          }
          int v3 = 645424692;
          goto LABEL_64;
        }
        if (a1 == 645428784 || a1 == 645428788) {
          return 10;
        }
        int v5 = 758670896;
      }
      goto LABEL_60;
    }
    if (a1 > 796419631)
    {
      if (a1 > 875704437)
      {
        if (a1 == 875704438 || a1 == 875836518) {
          return result;
        }
        int v5 = 875836534;
      }
      else
      {
        if (a1 == 796419632 || a1 == 796423728) {
          return 10;
        }
        int v5 = 875704422;
      }
      goto LABEL_60;
    }
    if (a1 <= 762869295)
    {
      if (a1 != 758674992)
      {
        int v3 = 762865200;
        goto LABEL_64;
      }
      return result;
    }
    if (a1 == 762869296) {
      return 10;
    }
    if (a1 != 792225328)
    {
      int v5 = 792229424;
      goto LABEL_60;
    }
  }
  else
  {
    if (a1 <= 1882469427)
    {
      if (a1 <= 1563977267)
      {
        if (a1 <= 1534617135)
        {
          if (a1 != 1278226488)
          {
            int v3 = 1278226736;
            goto LABEL_64;
          }
          return result;
        }
        if (a1 == 1534617136 || a1 == 1534621232) {
          return 10;
        }
        unsigned __int16 v4 = 26160;
      }
      else
      {
        if (a1 > 1568171567)
        {
          if (a1 == 1568171568 || a1 == 1751411059) {
            return 10;
          }
          int v3 = 1882468912;
          goto LABEL_64;
        }
        if (a1 == 1563977268 || a1 == 1563981360) {
          return result;
        }
        unsigned __int16 v4 = 30260;
      }
      int v5 = v4 | 0x5D380000;
LABEL_60:
      if (a1 != v5) {
        return 0;
      }
      return result;
    }
    if (a1 <= 2019963439)
    {
      if (a1 <= 1982882103)
      {
        if (a1 == 1882469428 || a1 == 1885745712) {
          return 10;
        }
        int v3 = 1885746228;
LABEL_64:
        if (a1 == v3) {
          return 10;
        }
        return 0;
      }
      if (a1 != 1982882104)
      {
        if (a1 != 2016686640)
        {
          int v3 = 2016687156;
          goto LABEL_64;
        }
        return 10;
      }
      return result;
    }
    if (a1 <= 2084075055)
    {
      if (a1 == 2019963440 || a1 == 2019963956) {
        return 10;
      }
      int v5 = 2084070960;
      goto LABEL_60;
    }
    if (a1 != 2084075056)
    {
      if (a1 != 2088269360)
      {
        int v3 = 2088265264;
        goto LABEL_64;
      }
      return 10;
    }
  }
  return result;
}

uint64_t sub_1BBA13DBC(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 136) && !*(void *)(a1 + 144) && sub_1BBA13E0C(a1)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 8 * a2 + 144);
  }
}

uint64_t sub_1BBA13E0C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 1256))
  {
    uint64_t result = CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)(a1 + 1232), *(unsigned int *)(a1 + 1240));
    if (result) {
      return result;
    }
    *(unsigned char *)(a1 + 1256) = 1;
  }
  Planeunsigned int Count = CVPixelBufferGetPlaneCount(*(CVPixelBufferRef *)(a1 + 1232));
  if (PlaneCount) {
    goto LABEL_3;
  }
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(*(CVPixelBufferRef *)(a1 + 1232));
  if (!sub_1BBA13EC4(PixelFormatType))
  {
    Planeunsigned int Count = 1;
LABEL_3:
    for (size_t i = 0; i != PlaneCount; ++i)
    {
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(*(CVPixelBufferRef *)(a1 + 1232), i);
      size_t v5 = a1 + 8 * i;
      if (!*(void *)(v5 + 88)) {
        *(void *)(v5 + 88) = BaseAddressOfPlane;
      }
      if (*(unsigned char *)(a1 + 136)) {
        *(void *)(a1 + 8 * i + 144) = BaseAddressOfPlane;
      }
    }
  }
  return 0;
}

uint64_t sub_1BBA13EC4(int a1)
{
  uint64_t result = 1;
  if (a1 > 1278226735)
  {
    if (a1 <= 1751411058)
    {
      if (a1 == 1278226736) {
        return 0;
      }
      int v3 = 1496395842;
    }
    else
    {
      if (a1 == 2019963956 || a1 == 2016687156) {
        return 3;
      }
      int v3 = 1751411059;
    }
LABEL_15:
    if (a1 != v3) {
      return result;
    }
    return 0;
  }
  if (a1 > 875836517)
  {
    if (a1 != 875836518 && a1 != 875836534)
    {
      int v3 = 1278226488;
      goto LABEL_15;
    }
    return 3;
  }
  if (a1 == 645424692 || a1 == 645428788) {
    return 3;
  }
  return result;
}

uint64_t sub_1BBA13FA4(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 136) && !*(void *)(a1 + 144) && sub_1BBA13E0C(a1)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 8 * a2 + 144);
  }
}

uint64_t sub_1BBA13FF4(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 88) || !sub_1BBA13E0C(a1)) {
    return *(void *)(a1 + 8 * a2 + 88);
  }
  else {
    return 0;
  }
}

uint64_t sub_1BBA1403C(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 88) || !sub_1BBA13E0C(a1)) {
    return *(void *)(a1 + 8 * a2 + 88);
  }
  else {
    return 0;
  }
}

uint64_t sub_1BBA14084(uint64_t a1, int a2, int a3, int a4)
{
  if (*(void *)(a1 + 88) || !sub_1BBA13E0C(a1)) {
    return *(void *)(a1 + 8 * a4 + 88)
  }
         + ((*(void *)(a1 + 8 * a4 + 112) * a3 + (a2 << a4)) << *(unsigned char *)(a1 + 286));
  else {
    return 0;
  }
}

uint64_t sub_1BBA140FC(uint64_t a1, int a2, int a3, int a4)
{
  if (*(void *)(a1 + 88) || !sub_1BBA13E0C(a1)) {
    return *(void *)(a1 + 8 * a4 + 88)
  }
         + ((*(void *)(a1 + 8 * a4 + 112) * a3 + (a2 << a4)) << *(unsigned char *)(a1 + 286));
  else {
    return 0;
  }
}

void sub_1BBA14174(uint64_t a1)
{
  sub_1BBA141AC(a1);

  JUMPOUT(0x1C18605E0);
}

uint64_t sub_1BBA141AC(uint64_t a1)
{
  *(void *)a1 = &unk_1F14EE0C0;
  sub_1BBA1334C(a1);
  *(void *)a1 = &unk_1F14EEA18;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 1168));
  std::mutex::~mutex((std::mutex *)(a1 + 1104));
  *(_DWORD *)(a1 + 1032) = 0;
  *(_OWORD *)(a1 + 1016) = 0u;
  *(_OWORD *)(a1 + 1000) = 0u;
  *(_OWORD *)(a1 + 984) = 0u;
  *(_OWORD *)(a1 + 968) = 0u;
  unsigned int v2 = *(void **)(a1 + 952);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 952) = 0;
    *(void *)(a1 + 960) = 0;
  }
  int v3 = *(void **)(a1 + 664);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 664) = 0;
    *(void *)(a1 + 672) = 0;
  }
  unsigned __int16 v4 = *(void **)(a1 + 640);
  if (v4)
  {
    free(v4);
    *(void *)(a1 + 640) = 0;
    *(void *)(a1 + 648) = 0;
  }
  size_t v5 = *(void **)(a1 + 624);
  if (v5)
  {
    free(v5);
    *(void *)(a1 + 624) = 0;
    *(void *)(a1 + 632) = 0;
  }
  uint64_t v6 = *(void **)(a1 + 592);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 592) = 0;
    *(void *)(a1 + 600) = 0;
  }
  char v7 = *(void **)(a1 + 576);
  if (v7)
  {
    free(v7);
    *(void *)(a1 + 576) = 0;
    *(void *)(a1 + 584) = 0;
  }
  unint64_t v8 = *(void **)(a1 + 560);
  if (v8)
  {
    free(v8);
    *(void *)(a1 + 560) = 0;
    *(void *)(a1 + 568) = 0;
  }
  int v9 = *(void **)(a1 + 520);
  if (v9)
  {
    free(v9);
    *(void *)(a1 + 520) = 0;
    *(void *)(a1 + 528) = 0;
  }
  int v10 = *(void **)(a1 + 496);
  if (v10)
  {
    free(v10);
    *(void *)(a1 + 496) = 0;
    *(void *)(a1 + 504) = 0;
  }
  return a1;
}

uint64_t sub_1BBA142F4(uint64_t a1, CVPixelBufferRef *pixelBufferOut)
{
  unsigned __int16 v4 = *(CVPixelBufferPoolRef **)(a1 + 48);
  if (*pixelBufferOut) {
    CVPixelBufferRelease(*pixelBufferOut);
  }
  uint64_t PixelBuffer = CVPixelBufferPoolCreatePixelBuffer(0, *v4, pixelBufferOut);
  if (PixelBuffer) {
    CVPixelBufferRelease(*pixelBufferOut);
  }
  else {
    sub_1BBA14364(a1, *pixelBufferOut);
  }
  return PixelBuffer;
}

void sub_1BBA14364(uint64_t a1, CVBufferRef buffer)
{
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 32);
  if (v4) {
    CVBufferSetAttachments(buffer, v4, kCVAttachmentMode_ShouldPropagate);
  }
  CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 40);
  if (v5)
  {
    CVBufferSetAttachments(buffer, v5, kCVAttachmentMode_ShouldNotPropagate);
  }
}

uint64_t sub_1BBA143C8(uint64_t a1, int a2)
{
  uint64_t v41 = 0;
  uint64_t result = sub_1BBA14868(*(void *)(a1 + 48), &v41, 0, *(_DWORD *)(a1 + 24) != 0, *(unsigned __int8 *)(a1 + 28), a1);
  if (result) {
    return result;
  }
  uint64_t v5 = v41;
  *(_DWORD *)(v41 + 680) = a2;
  *(unsigned char *)(v5 + 1228) = *(unsigned char *)(a1 + 64);
  int v6 = *(_DWORD *)(a1 + 24);
  char v7 = *(_DWORD *)(v5 + 1096);
  int v8 = ~(-1 << v7);
  unsigned int v9 = (*(_DWORD *)(v5 + 276) + v8) >> v7;
  *(_DWORD *)(v5 + 656) = v9;
  unsigned int v10 = (*(_DWORD *)(v5 + 280) + v8) >> v7;
  *(_DWORD *)(v5 + 660) = v10;
  uint64_t v11 = ((v9 << v7) + 7) >> 3;
  uint64_t v12 = ((v10 << v7) + 7) >> 3;
  *(void *)(v5 + 472) = v11;
  *(void *)(v5 + 480) = v12;
  uint64_t v13 = (v11 + 7) & 0x3FFFFFF8;
  *(void *)(v5 + 488) = v13;
  uint64_t v14 = v12 + 3;
  *(void *)(v5 + 512) = 0;
  if (v6 == 3)
  {
    uint64_t result = sub_1BBA125DC((void **)(v5 + 520), ((v12 + 7) & 0x3FFFFFF8 | 2u) * (unint64_t)v13);
    if (result) {
      return result;
    }
    *(void *)(v5 + 512) = *(void *)(v5 + 520) + 2 * *(void *)(v5 + 488);
  }
  else if (v6 == 2)
  {
    unint64_t v15 = v14 * (unint64_t)v13;
    unint64_t v16 = v15 + 8;
    if (*(void *)(v5 + 504) < v15 + 8)
    {
      if (v15 > 0x31FFFF8) {
        return 4294954392;
      }
      char v17 = (void *)(v5 + 496);
      uint64_t v18 = *(void **)(v5 + 496);
      if (v18)
      {
        free(v18);
        void *v17 = 0;
        *(void *)(v5 + 504) = 0;
      }
      if (malloc_type_posix_memalign((void **)(v5 + 496), 0x10uLL, 2 * v16, 0x1000040BDFB0063uLL) || !*v17) {
        return 4294954392;
      }
      uint64_t v19 = 0;
      do
        *(_WORD *)(*v17 + 2 * v19++) = 0;
      while (v16 != v19);
      *(void *)(v5 + 504) = v16;
    }
  }
  uint64_t v20 = *(void *)(v5 + 480);
  uint64_t v21 = 2 * *(void *)(v5 + 472);
  *(void *)(v5 + 536) = v21;
  v20 *= 2;
  *(void *)(v5 + 544) = v20;
  uint64_t v22 = v21 + 3;
  *(void *)(v5 + 552) = v22;
  uint64_t v23 = v20 + 3;
  if (v6 == 3)
  {
    uint64_t result = sub_1BBA12684((void **)(v5 + 576), v23 * v22);
    if (result) {
      return result;
    }
    unint64_t v24 = *(void *)(v5 + 552) * v23;
    if (*(void *)(v5 + 600) >= v24) {
      goto LABEL_38;
    }
    if (v24 <= 0x1900000)
    {
      unint64_t v25 = (void *)(v5 + 592);
      unint64_t v26 = *(void **)(v5 + 592);
      if (v26)
      {
        free(v26);
        *unint64_t v25 = 0;
        *(void *)(v5 + 600) = 0;
      }
      if (!malloc_type_posix_memalign((void **)(v5 + 592), 0x10uLL, 4 * v24, 0x100004052888210uLL) && *v25)
      {
        uint64_t v27 = 0;
        do
          *(_DWORD *)(*v25 + 4 * v27++) = 0;
        while (v24 != v27);
        *(void *)(v5 + 600) = v24;
        goto LABEL_38;
      }
    }
    return 4294954392;
  }
  if (v6 == 2)
  {
    unint64_t v28 = v23 * v22;
    if (*(void *)(v5 + 568) < (unint64_t)(v23 * v22))
    {
      if (v28 > 0x855555) {
        return 4294954392;
      }
      long long v29 = (void *)(v5 + 560);
      long long v30 = *(void **)(v5 + 560);
      if (v30)
      {
        free(v30);
        *long long v29 = 0;
        *(void *)(v5 + 568) = 0;
      }
      if (malloc_type_posix_memalign((void **)(v5 + 560), 0x10uLL, 12 * v28, 0x1000040E45D73ADuLL) || !*v29) {
        return 4294954392;
      }
      uint64_t v31 = 0;
      unint64_t v32 = v28;
      do
      {
        uint64_t v33 = *v29 + v31;
        *(_DWORD *)(v33 + 8) = 0;
        *(void *)uint64_t v33 = 0;
        v31 += 12;
        --v32;
      }
      while (v32);
      *(void *)(v5 + 568) = v28;
    }
  }
LABEL_38:
  uint64_t v34 = *(void *)(v5 + 480);
  uint64_t v35 = 2 * *(void *)(v5 + 472) + 16;
  *(void *)(v5 + 608) = v35;
  *(void *)(v5 + 616) = 2 * v34;
  if (v6 < 2
    || (uint64_t result = sub_1BBA12730((void **)(v5 + 624), v35 * v14 + 31, 0x10uLL), !result)
    && (uint64_t result = sub_1BBA12730((void **)(v5 + 640), (*(void *)(v5 + 472) + 8) * *(void *)(v5 + 616) + 31, 0x10uLL),
        !result)
    && (uint64_t result = sub_1BBA127E4((void **)(v5 + 664), (*(_DWORD *)(v5 + 660) * *(_DWORD *)(v5 + 656))),
        !result))
  {
    CC_MD5_CTX v36 = *(void **)(v5 + 624);
    if (v36) {
      bzero(v36, *(void *)(v5 + 608) * *(void *)(v5 + 480));
    }
    char v37 = *(void **)(v5 + 640);
    if (v37) {
      bzero(v37, *(void *)(v5 + 616) * *(void *)(v5 + 472));
    }
    uint64_t v38 = *(void **)(v5 + 512);
    if (v38) {
      bzero(v38, 2 * *(void *)(v5 + 480) * *(void *)(v5 + 488));
    }
    unint64_t v39 = *(void **)(v5 + 576);
    if (v39) {
      bzero(v39, 16 * *(void *)(v5 + 544) * *(void *)(v5 + 552));
    }
    v42[0] = (std::mutex *)(v5 + 1104);
    LOBYTE(v42[1]) = 1;
    std::mutex::lock((std::mutex *)(v5 + 1104));
    atomic_store(0x80000000, (unsigned int *)(v5 + 1100));
    sub_1BB9D9FD4((uint64_t)v42);
    std::condition_variable::notify_all((std::condition_variable *)(v5 + 1168));
    if (LOBYTE(v42[1])) {
      std::mutex::unlock(v42[0]);
    }
    uint64_t v40 = *(void *)(a1 + 56);
    if (v40) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v40 + 8), 1uLL, memory_order_relaxed);
    }
    sub_1BBA14BB0(v42, v5);
  }
  return result;
}

void sub_1BBA14838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::mutex *a13, char a14)
{
  if (a11) {
    sub_1BB9C09B4(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA14868(uint64_t a1, void *a2, __CVBuffer *a3, char a4, int a5, uint64_t a6)
{
  CVPixelBufferRef texture = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t v11 = (std::mutex *)(a1 + 56);
  *a2 = 0;
  if (!a3)
  {
    if ((a4 & 1) == 0) {
      goto LABEL_15;
    }
LABEL_9:
    uint64_t v15 = CVPixelBufferPoolCreatePixelBuffer(0, *(CVPixelBufferPoolRef *)a1, &pixelBufferOut);
    if (v15)
    {
LABEL_13:
      int v16 = 0;
      goto LABEL_22;
    }
    sub_1BBA14364(a6, pixelBufferOut);
    goto LABEL_11;
  }
  CFDictionaryRef PixelBufferAttributes = CVPixelBufferPoolGetPixelBufferAttributes(*(CVPixelBufferPoolRef *)a1);
  if (!CVPixelBufferIsCompatibleWithAttributes())
  {
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 0x40000000;
    v21[2] = sub_1BBA153A0;
    v21[3] = &unk_1E6247CC8;
    v21[4] = a3;
    v21[5] = PixelBufferAttributes;
    uint64_t v22 = v21;
    if (atomic_load_explicit((atomic_ullong *volatile)(a1 + 168), memory_order_acquire) != -1)
    {
      unint64_t v26 = &v22;
      unint64_t v25 = &v26;
      std::__call_once((std::once_flag::_State_type *)(a1 + 168), &v25, (void (__cdecl *)(void *))sub_1BBA1553C);
    }
  }
  uint64_t v14 = CVPixelBufferRetain(a3);
  CVPixelBufferRef pixelBufferOut = v14;
  if ((a4 & 1) == 0) {
    goto LABEL_15;
  }
  if (!v14) {
    goto LABEL_9;
  }
LABEL_11:
  if (a5)
  {
    uint64_t v15 = CVPixelBufferPoolCreatePixelBuffer(0, *(CVPixelBufferPoolRef *)a1, &texture);
    if (v15) {
      goto LABEL_13;
    }
    sub_1BBA14364(a6, texture);
  }
LABEL_15:
  std::mutex::lock(v11);
  if (*(void *)(a1 + 48))
  {
    uint64_t v17 = *(void *)(*(void *)(*(void *)(a1 + 16) + ((*(void *)(a1 + 40) >> 6) & 0x3FFFFFFFFFFFFF8))
                    + 8 * (*(void *)(a1 + 40) & 0x1FFLL));
    *a2 = v17;
    *(void *)(v17 + 656) = 0;
    *(_WORD *)(v17 + 45) = 0;
    *(_DWORD *)(v17 + 680) = 0;
    *(void *)(v17 + 36) = 0;
    *(unsigned char *)(v17 + 300) = 0;
    *(unsigned char *)(v17 + 349) = 0;
    *(_OWORD *)(v17 + 400) = 0u;
    *(_OWORD *)(v17 + 240) = 0u;
    *(void *)(v17 + 472) = 0;
    *(_OWORD *)(v17 + 480) = 0u;
    *(void *)(v17 + 536) = 0;
    *(_OWORD *)(v17 + 544) = 0u;
    *(_OWORD *)(v17 + 608) = 0u;
    *(int64x2_t *)(a1 + 40) = vaddq_s64(*(int64x2_t *)(a1 + 40), (int64x2_t)xmmword_1BBB6F610);
    sub_1BBA154EC(a1 + 8);
    uint64_t v18 = *a2;
  }
  else
  {
    uint64_t v19 = operator new(0x500uLL, MEMORY[0x1E4FBA2D0]);
    if (!v19)
    {
      *a2 = 0;
      uint64_t v15 = 4294954392;
      goto LABEL_27;
    }
    sub_1BBA12160((uint64_t)v19);
    *(void *)uint64_t v18 = &unk_1F14EE0C0;
    *(void *)(v18 + 1232) = 0;
    *(_DWORD *)(v18 + 1240) = 0;
    *(void *)(v18 + 1248) = 0;
    *(unsigned char *)(v18 + 1256) = 0;
    *a2 = v18;
  }
  if (!pixelBufferOut)
  {
LABEL_25:
    (*(void (**)(uint64_t, void))(*(void *)v18 + 112))(v18, *(void *)(a6 + 8));
    uint64_t v15 = 0;
    *(unsigned char *)(*a2 + 136) = a5;
LABEL_27:
    int v16 = 1;
    goto LABEL_28;
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t, CVPixelBufferRef, CVPixelBufferRef))(*(void *)v18 + 64))(v18, pixelBufferOut, texture);
  if (!v15)
  {
    uint64_t v18 = *a2;
    goto LABEL_25;
  }
  int v16 = 1;
LABEL_22:
  if (*a2)
  {
    sub_1BBA14CFC((void *)(a1 + 8), a2);
    *a2 = 0;
  }
LABEL_28:
  CVPixelBufferRelease(pixelBufferOut);
  CVPixelBufferRelease(texture);
  if (v16) {
    std::mutex::unlock(v11);
  }
  return v15;
}

void sub_1BBA14B70(_Unwind_Exception *exception_object)
{
}

void sub_1BBA14BB0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1BBA14C30(void *a1)
{
  __cxa_begin_catch(a1);
  sub_1BBA14C5C(*v2, v1);
  __cxa_rethrow();
}

void sub_1BBA14C48(_Unwind_Exception *a1)
{
}

void sub_1BBA14C5C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  CFDictionaryRef v4 = (std::mutex *)(a1 + 56);
  std::mutex::lock((std::mutex *)(a1 + 56));
  (*(void (**)(uint64_t))(*(void *)a2 + 72))(a2);
  sub_1BBA14CFC((void *)(a1 + 8), &v5);

  std::mutex::unlock(v4);
}

void sub_1BBA14CE8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1BBA14CFC(void *a1, void *a2)
{
  CFDictionaryRef v4 = (char *)a1[2];
  uint64_t v5 = (char *)a1[1];
  uint64_t v6 = v4 - v5;
  if (v4 == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = ((v4 - v5) << 6) - 1;
  }
  unint64_t v9 = a1[4];
  uint64_t v8 = a1[5];
  unint64_t v10 = v8 + v9;
  if (v7 == v8 + v9)
  {
    if (v9 >= 0x200)
    {
      a1[4] = v9 - 512;
      uint64_t v13 = *(void *)v5;
      uint64_t v11 = v5 + 8;
      uint64_t v12 = v13;
      a1[1] = v11;
      if ((char *)a1[3] == v4)
      {
        uint64_t v14 = (uint64_t)&v11[-*a1];
        if ((unint64_t)v11 <= *a1)
        {
          if (v4 == (char *)*a1) {
            unint64_t v42 = 1;
          }
          else {
            unint64_t v42 = (uint64_t)&v4[-*a1] >> 2;
          }
          uint64_t v43 = (char *)sub_1BB9C91CC(v42);
          unsigned int v45 = &v43[8 * (v42 >> 2)];
          unsigned int v46 = (uint64_t *)a1[1];
          CFDictionaryRef v4 = v45;
          uint64_t v47 = a1[2] - (void)v46;
          if (v47)
          {
            CFDictionaryRef v4 = &v45[v47 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v48 = 8 * (v47 >> 3);
            int v49 = &v43[8 * (v42 >> 2)];
            do
            {
              uint64_t v50 = *v46++;
              *(void *)int v49 = v50;
              v49 += 8;
              v48 -= 8;
            }
            while (v48);
          }
          uint64_t v51 = (char *)*a1;
          *a1 = v43;
          a1[1] = v45;
          a1[2] = v4;
          a1[3] = &v43[8 * v44];
          if (v51)
          {
            operator delete(v51);
            CFDictionaryRef v4 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v15 = v14 >> 3;
          BOOL v16 = v14 >> 3 < -1;
          uint64_t v17 = (v14 >> 3) + 2;
          if (v16) {
            uint64_t v18 = v17;
          }
          else {
            uint64_t v18 = v15 + 1;
          }
          uint64_t v19 = -(v18 >> 1);
          uint64_t v20 = v18 >> 1;
          uint64_t v21 = &v11[-8 * v20];
          int64_t v22 = v4 - v11;
          if (v4 == v11)
          {
            uint64_t v23 = v4;
          }
          else
          {
            memmove(&v11[-8 * v20], v11, v4 - v11);
            uint64_t v23 = (char *)a1[1];
          }
          CFDictionaryRef v4 = &v21[v22];
          a1[1] = &v23[8 * v19];
          a1[2] = &v21[v22];
        }
      }
      *(void *)CFDictionaryRef v4 = v12;
LABEL_82:
      a1[2] += 8;
LABEL_83:
      uint64_t v5 = (char *)a1[1];
      uint64_t v8 = a1[5];
      unint64_t v10 = a1[4] + v8;
      goto LABEL_84;
    }
    uint64_t v24 = v6 >> 3;
    unint64_t v25 = (char *)a1[3];
    unint64_t v26 = (char *)*a1;
    uint64_t v27 = (uint64_t)&v25[-*a1];
    if (v6 >> 3 < (unint64_t)(v27 >> 3))
    {
      unint64_t v28 = operator new(0x1000uLL);
      long long v29 = v28;
      if (v25 == v4)
      {
        if (v26 == v5)
        {
          if (v4 == v5) {
            unint64_t v52 = 1;
          }
          else {
            unint64_t v52 = v27 >> 2;
          }
          uint64_t v53 = 2 * v52;
          int v54 = (char *)sub_1BB9C91CC(v52);
          uint64_t v5 = &v54[(v53 + 6) & 0xFFFFFFFFFFFFFFF8];
          OSStatus v56 = (uint64_t *)a1[1];
          uint32_t v57 = v5;
          uint64_t v58 = a1[2] - (void)v56;
          if (v58)
          {
            uint32_t v57 = &v5[v58 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v59 = 8 * (v58 >> 3);
            int v60 = v5;
            do
            {
              uint64_t v61 = *v56++;
              *(void *)int v60 = v61;
              v60 += 8;
              v59 -= 8;
            }
            while (v59);
          }
          int v62 = (char *)*a1;
          *a1 = v54;
          a1[1] = v5;
          a1[2] = v57;
          a1[3] = &v54[8 * v55];
          if (v62)
          {
            operator delete(v62);
            uint64_t v5 = (char *)a1[1];
          }
        }
        *((void *)v5 - 1) = v29;
        int v63 = (char *)a1[1];
        int v64 = (char *)a1[2];
        a1[1] = v63 - 8;
        uint64_t v65 = *((void *)v63 - 1);
        a1[1] = v63;
        if (v64 == (char *)a1[3])
        {
          uint64_t v66 = (uint64_t)&v63[-*a1];
          if ((unint64_t)v63 <= *a1)
          {
            if (v64 == (char *)*a1) {
              unint64_t v97 = 1;
            }
            else {
              unint64_t v97 = (uint64_t)&v64[-*a1] >> 2;
            }
            uint64_t v98 = (char *)sub_1BB9C91CC(v97);
            uint64_t v100 = &v98[8 * (v97 >> 2)];
            uint64_t v101 = (uint64_t *)a1[1];
            int v64 = v100;
            uint64_t v102 = a1[2] - (void)v101;
            if (v102)
            {
              int v64 = &v100[v102 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v103 = 8 * (v102 >> 3);
              uint64_t v104 = &v98[8 * (v97 >> 2)];
              do
              {
                uint64_t v105 = *v101++;
                *(void *)uint64_t v104 = v105;
                v104 += 8;
                v103 -= 8;
              }
              while (v103);
            }
            int v106 = (char *)*a1;
            *a1 = v98;
            a1[1] = v100;
            a1[2] = v64;
            a1[3] = &v98[8 * v99];
            if (v106)
            {
              operator delete(v106);
              int v64 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v67 = v66 >> 3;
            BOOL v16 = v66 >> 3 < -1;
            uint64_t v68 = (v66 >> 3) + 2;
            if (v16) {
              uint64_t v69 = v68;
            }
            else {
              uint64_t v69 = v67 + 1;
            }
            uint64_t v70 = -(v69 >> 1);
            uint64_t v71 = v69 >> 1;
            uint64_t v72 = &v63[-8 * v71];
            int64_t v73 = v64 - v63;
            if (v64 != v63)
            {
              memmove(&v63[-8 * v71], v63, v64 - v63);
              int v63 = (char *)a1[1];
            }
            int v64 = &v72[v73];
            a1[1] = &v63[8 * v70];
            a1[2] = &v72[v73];
          }
        }
        *(void *)int v64 = v65;
      }
      else
      {
        *(void *)CFDictionaryRef v4 = v28;
      }
      goto LABEL_82;
    }
    if (v25 == v26) {
      unint64_t v30 = 1;
    }
    else {
      unint64_t v30 = v27 >> 2;
    }
    uint64_t v31 = (char *)sub_1BB9C91CC(v30);
    uint64_t v33 = v32;
    uint64_t v34 = &v31[8 * v24];
    *(void *)&long long v35 = v31;
    *((void *)&v35 + 1) = v34;
    long long v110 = v35;
    CC_MD5_CTX v36 = operator new(0x1000uLL);
    *(void *)&long long v37 = v34;
    *((void *)&v37 + 1) = &v31[8 * v33];
    if (v24 == v33)
    {
      uint64_t v38 = 8 * v24;
      *(void *)&long long v39 = v110;
      if (v6 >= 1)
      {
        uint64_t v40 = v38 >> 3;
        if (v40 >= -1) {
          unint64_t v41 = v40 + 1;
        }
        else {
          unint64_t v41 = v40 + 2;
        }
        v34 -= 8 * (v41 >> 1);
        *(void *)&long long v37 = v34;
        *((void *)&v39 + 1) = v34;
        goto LABEL_56;
      }
      uint64_t v74 = v38 >> 2;
      if (v4 == v5) {
        unint64_t v75 = 1;
      }
      else {
        unint64_t v75 = v74;
      }
      uint64_t v76 = (char *)sub_1BB9C91CC(v75);
      uint64_t v34 = &v76[8 * (v75 >> 2)];
      *(void *)&long long v39 = v76;
      *((void *)&v39 + 1) = v34;
      *(void *)&long long v37 = v34;
      *((void *)&v37 + 1) = &v76[8 * v77];
      if (!v31) {
        goto LABEL_56;
      }
      long long v107 = v37;
      long long v110 = v39;
      operator delete(v31);
      long long v37 = v107;
    }
    long long v39 = v110;
LABEL_56:
    *(void *)uint64_t v34 = v36;
    *(void *)&long long v37 = v37 + 8;
    for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
    {
      int v79 = (void *)*((void *)&v39 + 1);
      if (*((void *)&v39 + 1) == (void)v39)
      {
        int v81 = (unsigned char *)v37;
        if ((unint64_t)v37 >= *((void *)&v37 + 1))
        {
          if (*((void *)&v37 + 1) == *((void *)&v39 + 1)) {
            unint64_t v86 = 1;
          }
          else {
            unint64_t v86 = (uint64_t)(*((void *)&v37 + 1) - *((void *)&v39 + 1)) >> 2;
          }
          int v87 = (char *)sub_1BB9C91CC(v86);
          uint64_t v80 = &v87[(2 * v86 + 6) & 0xFFFFFFFFFFFFFFF8];
          int v89 = v80;
          uint64_t v90 = v81 - (unsigned char *)v79;
          if (v81 != (unsigned char *)v79)
          {
            int v89 = &v80[v90 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v91 = 8 * (v90 >> 3);
            CVReturn v92 = v80;
            uint64_t v93 = v79;
            do
            {
              uint64_t v94 = *v93++;
              *(void *)CVReturn v92 = v94;
              v92 += 8;
              v91 -= 8;
            }
            while (v91);
          }
          *(void *)&long long v39 = v87;
          *((void *)&v39 + 1) = v80;
          *(void *)&long long v37 = v89;
          *((void *)&v37 + 1) = &v87[8 * v88];
          if (v79)
          {
            long long v108 = v37;
            long long v112 = v39;
            operator delete(v79);
            long long v37 = v108;
            long long v39 = v112;
          }
        }
        else
        {
          uint64_t v82 = (uint64_t)(*((void *)&v37 + 1) - v37) >> 3;
          if (v82 >= -1) {
            uint64_t v83 = v82 + 1;
          }
          else {
            uint64_t v83 = v82 + 2;
          }
          uint64_t v84 = v83 >> 1;
          uint64_t v85 = v37 + 8 * (v83 >> 1);
          uint64_t v80 = (char *)(v85 - (v37 - *((void *)&v39 + 1)));
          if ((void)v37 == *((void *)&v39 + 1))
          {
            int v81 = (unsigned char *)*((void *)&v39 + 1);
          }
          else
          {
            uint64_t v109 = *((void *)&v37 + 1);
            uint64_t v111 = v39;
            memmove((void *)(v85 - (v37 - *((void *)&v39 + 1))), *((const void **)&v39 + 1), v37 - *((void *)&v39 + 1));
            *((void *)&v37 + 1) = v109;
            *(void *)&long long v39 = v111;
          }
          *((void *)&v39 + 1) = v80;
          *(void *)&long long v37 = &v81[8 * v84];
        }
      }
      else
      {
        uint64_t v80 = (char *)*((void *)&v39 + 1);
      }
      uint64_t v95 = *(void *)(i - 8);
      *((void *)v80 - 1) = v95;
      *((void *)&v39 + 1) -= 8;
    }
    CVReturn v96 = (char *)*a1;
    *(_OWORD *)a1 = v39;
    *((_OWORD *)a1 + 1) = v37;
    if (v96) {
      operator delete(v96);
    }
    goto LABEL_83;
  }
LABEL_84:
  *(void *)(*(void *)&v5[(v10 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v10 & 0x1FF)) = *a2;
  a1[5] = v8 + 1;
}

void sub_1BBA15250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11)
{
  operator delete(v11);
  if ((void)a11) {
    operator delete((void *)a11);
  }
  _Unwind_Resume(a1);
}

void sub_1BBA15284(uint64_t *a1)
{
  sub_1BBA14C5C(a1[4], a1[3]);
  unsigned int v2 = (std::__shared_weak_count *)a1[5];
  if (v2)
  {
    sub_1BB9C09B4(v2);
  }
}

void sub_1BBA152D4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14EEC88;
  shared_weak_owners = (std::__shared_weak_count *)this[1].__shared_weak_owners_;
  if (shared_weak_owners) {
    sub_1BB9C09B4(shared_weak_owners);
  }
  std::__shared_weak_count::~__shared_weak_count(this);

  JUMPOUT(0x1C18605E0);
}

void sub_1BBA15344(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F14EEC88;
  shared_weak_owners = (std::__shared_weak_count *)this[1].__shared_weak_owners_;
  if (shared_weak_owners) {
    sub_1BB9C09B4(shared_weak_owners);
  }

  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1BBA153A0(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  Attributes = (const void *)CVPixelBufferGetAttributes();
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  sub_1BBAA99BC(Mutable, Attributes);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    uint64_t v8 = Mutable;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "External attributes: %@\n", (uint8_t *)&v7, 0xCu);
  }
  CFRelease(Mutable);
  uint64_t v5 = *(const void **)(a1 + 40);
  uint64_t v6 = CFStringCreateMutable(v3, 0);
  sub_1BBAA99BC(v6, v5);
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    uint64_t v8 = v6;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Expected attributes: %@\n", (uint8_t *)&v7, 0xCu);
  }
  CFRelease(v6);
}

void sub_1BBA154EC(uint64_t a1)
{
  if (*(void *)(a1 + 32) >= 0x400uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 512;
  }
}

void *sub_1BBA1553C(void ***a1)
{
  return (*(void *(**)(void *__return_ptr))(***a1 + 16))(**a1);
}

uint64_t sub_1BBA15554(uint64_t a1, uint64_t a2, __CVBuffer *a3)
{
  uint64_t v9 = 0;
  uint64_t v4 = sub_1BBA14868(*(void *)(a1 + 48), &v9, a3, 1, *(unsigned __int8 *)(a1 + 28), a1);
  if (!v4)
  {
    uint64_t v5 = v9;
    if (*(unsigned char *)(a1 + 28)) {
      *(int32x2_t *)(v9 + 240) = vsub_s32(*(int32x2_t *)(v9 + 276), vadd_s32(*(int32x2_t *)(v9 + 400), *(int32x2_t *)(v9 + 408)));
    }
    uint64_t v6 = *(void *)(a1 + 56);
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    sub_1BBA14BB0(&v8, v5);
  }
  return v4;
}

void sub_1BBA15628(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1BB9C09B4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1BBA15640(void *a1)
{
  sub_1BBA15678(a1);

  JUMPOUT(0x1C18605E0);
}

void *sub_1BBA15678(void *a1)
{
  *a1 = &unk_1F14EE6B8;
  unsigned int v2 = (const void *)a1[4];
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)a1[5];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_1BB9C09B4(v4);
  }
  *a1 = &unk_1F14EDC40;
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5) {
    sub_1BB9C09B4(v5);
  }
  return a1;
}

uint64_t sub_1BBA15714(int a1, int a2, int a3, int a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t v47 = 0;
  if (sub_1BBA4013C())
  {
    if (a4 == 1752589105 || a4 == 1718908520)
    {
      int v8 = 64;
      int v9 = 160;
    }
    else
    {
      int v8 = 96;
      int v9 = 192;
    }
    int v12 = 16 - (a1 & 0xF);
    if ((a1 & 0xF) == 0) {
      int v12 = 0;
    }
    BOOL v13 = __OFSUB__(v9, a1);
    int v14 = v9 - a1;
    if ((v14 < 0) ^ v13 | (v14 == 0)) {
      int v10 = v12;
    }
    else {
      int v10 = v14;
    }
    int v15 = 16 - (a2 & 0xF);
    if ((a2 & 0xF) == 0) {
      int v15 = 0;
    }
    BOOL v13 = __OFSUB__(v8, a2);
    int v16 = v8 - a2;
    if ((v16 < 0) ^ v13 | (v16 == 0)) {
      int v11 = v15;
    }
    else {
      int v11 = v16;
    }
  }
  else
  {
    int v10 = 0;
    int v11 = 0;
  }
  sub_1BBA15BC8(a1, a2, 0, v10, 0, v11, 0, &v47);
  BOOL v17 = 0;
  if (a1 >= 1 && a2 >= 1) {
    BOOL v17 = (a1 < 0xC1 || a2 <= 0x60) && (v11 | v10) != 0;
  }
  uint64_t v18 = v47;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (!Mutable) {
    goto LABEL_71;
  }
  uint64_t v20 = Mutable;
  if (a4 != 1684632424 && a4 != 1752589105 && a4 != 1718908520)
  {
    uint64_t v21 = "f024v024";
    int64_t v22 = "0v8&0f8&0v8-0v8/0v8|0f8-0f8/0f8|";
    if (v17) {
      goto LABEL_62;
    }
    goto LABEL_49;
  }
  if ((a3 & 0xFFFFFFFD) == 1)
  {
    uint64_t v21 = "f024v0248a0v800L";
    int64_t v22 = "0v8&0f8&80v&0v8-0v8/0v8|0f8-0f8/0f8|";
    if (v17) {
      goto LABEL_62;
    }
LABEL_49:
    if (*(_DWORD *)v22)
    {
      uint64_t v23 = (const void *)*MEMORY[0x1E4F24EE0];
      uint64_t v24 = (const void *)*MEMORY[0x1E4F24E88];
      unint64_t v25 = v22 + 4;
      do
      {
        DescriptionWithOSType PixelFormatType = (const __CFDictionary *)CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
        if (DescriptionWithPixelFormatType)
        {
          CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(DescriptionWithPixelFormatType, v23);
          if (Value)
          {
            CFArrayRef v28 = Value;
            CFTypeID v29 = CFGetTypeID(Value);
            if (v29 == CFArrayGetTypeID())
            {
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v28, 0);
              if (ValueAtIndex)
              {
                CFDictionaryRef v31 = ValueAtIndex;
                CFTypeID v32 = CFGetTypeID(ValueAtIndex);
                if (v32 == CFDictionaryGetTypeID())
                {
                  valuePtr[0] = 0;
                  CFNumberRef v33 = (const __CFNumber *)CFDictionaryGetValue(v31, v24);
                  if (v33)
                  {
                    CFNumberRef v34 = v33;
                    CFTypeID v35 = CFGetTypeID(v33);
                    if (v35 == CFNumberGetTypeID())
                    {
                      CFNumberGetValue(v34, kCFNumberSInt32Type, valuePtr);
                      if ((valuePtr[0] - 5) >= 0xFFFFFFFE)
                      {
                        valuePtr[0] = *(v25 - 1);
                        CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, valuePtr);
                        if (!v36) {
                          goto LABEL_70;
                        }
                        CFNumberRef v37 = v36;
                        CFArrayAppendValue(v20, v36);
                        CFRelease(v37);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      while (*v25++);
    }
    goto LABEL_62;
  }
  if (a3 <= 99)
  {
    if (a3 == 2)
    {
      uint64_t v21 = "024x02fxf024v024010Lsidh";
      int64_t v22 = "0vx&0fx&";
      if (v17) {
        goto LABEL_62;
      }
      goto LABEL_49;
    }
    if (a3 == 20)
    {
      uint64_t v21 = "800L";
LABEL_40:
      int64_t v22 = (const char *)&dword_1BBB78280;
      if (v17) {
        goto LABEL_62;
      }
      goto LABEL_49;
    }
  }
  else
  {
    switch(a3)
    {
      case 100:
        uint64_t v21 = "f444v444";
        int64_t v22 = "4v8&4f8&";
        if (v17) {
          goto LABEL_62;
        }
        goto LABEL_49;
      case 116:
        uint64_t v21 = "f444v444444x44fx";
        int64_t v22 = "4fx&4vx&";
        if (v17) {
          goto LABEL_62;
        }
        goto LABEL_49;
      case 132:
        uint64_t v21 = "010Lsidh";
        goto LABEL_40;
    }
  }
  uint64_t v21 = "024x02fxf024v024f444v444800L444x44fx010Lsidh8a0v";
  int64_t v22 = "0v8&0f8&4fx&4vx&0v8-0v8/0v8|0vx-0vx|0vx/0f8-0f8/0f8|0fx&0fx/0fx|";
  if (!v17) {
    goto LABEL_49;
  }
LABEL_62:
  int v39 = *(_DWORD *)v21;
  if (!*(_DWORD *)v21)
  {
LABEL_66:
    CFDictionarySetValue(v18, (const void *)*MEMORY[0x1E4F24D70], v20);
    CFRelease(v20);
    uint64_t v44 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    sub_1BBAA99BC(v44, v18);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      valuePtr[0] = 67109378;
      valuePtr[1] = a3;
      __int16 v49 = 2114;
      uint64_t v50 = v44;
      _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Buffer attributes for profile %d %{public}@", (uint8_t *)valuePtr, 0x12u);
    }
    CFRelease(v44);
    uint64_t v45 = VTEncoderSessionSetPixelBufferAttributes();
    if (v18) {
      goto LABEL_72;
    }
    return v45;
  }
  uint64_t v40 = (int *)(v21 + 4);
  while (1)
  {
    valuePtr[0] = v39;
    CFNumberRef v41 = CFNumberCreate(0, kCFNumberSInt32Type, valuePtr);
    if (!v41) {
      break;
    }
    CFNumberRef v42 = v41;
    CFArrayAppendValue(v20, v41);
    CFRelease(v42);
    int v43 = *v40++;
    int v39 = v43;
    if (!v43) {
      goto LABEL_66;
    }
  }
LABEL_70:
  CFRelease(v20);
LABEL_71:
  uint64_t v45 = 4294954392;
  if (v18) {
LABEL_72:
  }
    CFRelease(v18);
  return v45;
}

void sub_1BBA15BC8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, __CFDictionary **a8)
{
  values[1] = *(void **)MEMORY[0x1E4F143B8];
  *a8 = 0;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  BOOL v17 = Mutable;
  if (!Mutable) {
    goto LABEL_17;
  }
  sub_1BBA15E4C(Mutable, (const void *)*MEMORY[0x1E4F24E10], a1);
  sub_1BBA15E4C(v17, (const void *)*MEMORY[0x1E4F24D08], a2);
  if (a7) {
    sub_1BBA15E4C(v17, (const void *)*MEMORY[0x1E4F24D70], a7);
  }
  sub_1BBA15EB0(v17, (const void *)*MEMORY[0x1E4F24C98]);
  sub_1BBA15EB0(v17, (const void *)*MEMORY[0x1E4F24D78]);
  if (a4 | a3 | a5 | a6)
  {
    sub_1BBA15E4C(v17, (const void *)*MEMORY[0x1E4F24CE0], a3);
    sub_1BBA15E4C(v17, (const void *)*MEMORY[0x1E4F24CF0], a5);
    sub_1BBA15E4C(v17, (const void *)*MEMORY[0x1E4F24CE8], a4);
  }
  else
  {
    if ((a1 & 0xF) != 0) {
      sub_1BBA15E4C(v17, (const void *)*MEMORY[0x1E4F24CE8], 16 - (a1 & 0xF));
    }
    if ((a2 & 0xF) == 0) {
      goto LABEL_11;
    }
    a6 = 16 - (a2 & 0xF);
  }
  sub_1BBA15E4C(v17, (const void *)*MEMORY[0x1E4F24CD0], a6);
LABEL_11:
  CFMutableDictionaryRef v18 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v18)
  {
    CFMutableDictionaryRef v19 = v18;
    CFDictionaryAddValue(v17, (const void *)*MEMORY[0x1E4F24D20], v18);
    CFRelease(v19);
  }
  int valuePtr = 0;
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (v20)
  {
    CFNumberRef v21 = v20;
    values[0] = v20;
    CFArrayRef v22 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x1E4F1D510]);
    if (v22)
    {
      CFArrayRef v23 = v22;
      CFDictionaryAddValue(v17, (const void *)*MEMORY[0x1E4F24CB0], v22);
      CFRelease(v23);
    }
    CFRelease(v21);
  }
LABEL_17:
  *a8 = v17;
}

void sub_1BBA15E4C(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(a1, a2, v5);
  CFRelease(v5);
}

void sub_1BBA15EB0(__CFDictionary *a1, const void *a2)
{
  uint64_t valuePtr = 64;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  CFDictionaryAddValue(a1, a2, v4);
  CFRelease(v4);
}

uint64_t sub_1BBA15F18(unsigned __int8 *a1, int *a2)
{
  int v2 = a1[2000];
  if (v2 != a1[2002]) {
    return 4294954386;
  }
  if ((v2 - 9) >= 2)
  {
    if (v2 != 8) {
      return 4294954386;
    }
    int v5 = a1[173];
    if (a1[173])
    {
      if (v5 == 3)
      {
        int v6 = a1[1903];
        int v7 = 875836518;
      }
      else
      {
        if (v5 != 1) {
          return 4294954386;
        }
        int v6 = a1[1903];
        int v7 = 875704422;
      }
      if (v6) {
        int v4 = v7;
      }
      else {
        int v4 = v7 | 0x10;
      }
      goto LABEL_24;
    }
    int v4 = 1278226488;
  }
  else
  {
    int v3 = a1[173];
    if (a1[173])
    {
      if (v3 == 3)
      {
        if (a1[1903]) {
          int v4 = 2019963956;
        }
        else {
          int v4 = 2016687156;
        }
        goto LABEL_24;
      }
      if (v3 == 1)
      {
        if (a1[1903]) {
          int v4 = 2019963440;
        }
        else {
          int v4 = 2016686640;
        }
        goto LABEL_24;
      }
      return 4294954386;
    }
    int v4 = 1278226736;
  }
LABEL_24:
  uint64_t result = 0;
  *a2 = v4;
  return result;
}

uint64_t sub_1BBA16004(uint64_t a1)
{
  int v2 = *(void ***)(a1 + 8);
  int v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      int v3 = *(void ***)(a1 + 16);
      int v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 512;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      int v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1BBA160CC(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  for (uint64_t i = *(void *)(a1 + 48); i; uint64_t i = *(void *)(a1 + 48))
  {
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 16) + ((*(void *)(a1 + 40) >> 6) & 0x3FFFFFFFFFFFFF8))
                   + 8 * (*(void *)(a1 + 40) & 0x1FFLL));
    ++*(void *)(a1 + 40);
    *(void *)(a1 + 48) = i - 1;
    sub_1BBA154EC(v2);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  CVPixelBufferPoolRelease(*(CVPixelBufferPoolRef *)a1);
  std::mutex::~mutex((std::mutex *)(a1 + 56));
  sub_1BBA16004(v2);
  return a1;
}

uint64_t sub_1BBA16184(uint64_t *a1, int a2, uint64_t a3, void *a4, void *a5, int a6)
{
  int v6 = a6;
  values[2] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v27 = 0;
  CVPixelBufferPoolRef poolOut = 0;
  CFDictionaryRef resolvedDictionaryOut = 0;
  uint64_t v9 = *a1;
  if (a2) {
    int v10 = *(unsigned __int8 *)(v9 + 2013) + 7;
  }
  else {
    int v10 = 0;
  }
  int v11 = *(_DWORD *)(v9 + 2032);
  int v12 = *(_DWORD *)(v9 + 2040);
  int v14 = *(_DWORD *)(v9 + 176);
  int v13 = *(_DWORD *)(v9 + 180);
  if (!a6)
  {
    int v25 = 0;
    uint64_t v18 = sub_1BBA15F18((unsigned __int8 *)v9, &v25);
    if (v18) {
      goto LABEL_20;
    }
    int v6 = v25;
  }
  sub_1BBA15BC8(v14 - v11, v13 - v12, v10, v11 + v10, v10, v12 + v10, v6, &v27);
  CFDictionaryRef v15 = v27;
  if (a4
    && (values[0] = v27, values[1] = a4, (CFArrayRef v16 = CFArrayCreate(0, (const void **)values, 2, 0)) != 0)
    && (CVPixelBufferCreateResolvedAttributesDictionary(0, v16, &resolvedDictionaryOut),
        CFRelease(v16),
        resolvedDictionaryOut))
  {
    CFDictionaryRef v17 = v15;
    CFDictionaryRef v15 = resolvedDictionaryOut;
  }
  else
  {
    CFDictionaryRef v17 = 0;
    CFDictionaryRef resolvedDictionaryOut = v15;
    uint64_t v27 = 0;
  }
  uint64_t v18 = CVPixelBufferPoolCreate(0, 0, v15, &poolOut);
  if (!v18)
  {
    CFMutableDictionaryRef v19 = poolOut;
    CFNumberRef v20 = (char *)operator new(0xB0uLL, MEMORY[0x1E4FBA2D0]);
    if (v20)
    {
      CFNumberRef v21 = v20;
      *(_OWORD *)(v20 + 8) = 0u;
      *(_OWORD *)(v20 + 40) = 0u;
      *(_OWORD *)(v20 + 24) = 0u;
      *((void *)v20 + 7) = 850045863;
      *((_OWORD *)v20 + 4) = 0u;
      *((_OWORD *)v20 + 5) = 0u;
      *((_OWORD *)v20 + 6) = 0u;
      *((_DWORD *)v20 + 38) = 0;
      *((void *)v20 + 20) = sub_1BBAC7774;
      *((void *)v20 + 21) = 0;
      *((void *)v20 + 14) = 0;
      *((void *)v20 + 15) = sub_1BBAA6B34;
      *((void *)v20 + 17) = sub_1BBAA6AEC;
      *((void *)v20 + 16) = sub_1BBAC76D0;
      *((void *)v20 + 18) = sub_1BBAC762C;
      *(void *)CFNumberRef v20 = v19;
      CVPixelBufferPoolRetain(v19);
      CFArrayRef v22 = operator new(0x48uLL, MEMORY[0x1E4FBA2D0]);
      if (v22)
      {
        v22[1] = 0;
        v22[2] = 0;
        *(void *)((char *)v22 + 21) = 0;
        *CFArrayRef v22 = &unk_1F14EE6B8;
        v22[6] = v21;
        values[0] = v21;
        operator new();
      }
      *a5 = 0;
      uint64_t v23 = sub_1BBA160CC((uint64_t)v21);
      MEMORY[0x1C18605E0](v23, 0x10A0C40507A846CLL);
    }
    uint64_t v18 = 4294954392;
  }
  if (v17) {
    CFRelease(v17);
  }
LABEL_20:
  if (resolvedDictionaryOut) {
    CFRelease(resolvedDictionaryOut);
  }
  CVPixelBufferPoolRelease(poolOut);
  return v18;
}

void sub_1BBA16714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1BBA1681C((uint64_t *)va);
  void *v8 = &unk_1F14EDC40;
  int v10 = (std::__shared_weak_count *)v8[2];
  if (v10) {
    sub_1BB9C09B4(v10);
  }
  MEMORY[0x1C18605C0](v8, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

uint64_t sub_1BBA16784(int a1)
{
  switch(a1)
  {
    case 0:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F24A38];
      goto LABEL_9;
    case 1:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F24A28];
      goto LABEL_9;
    case 2:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F24A48];
      goto LABEL_9;
    case 3:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F24A40];
      goto LABEL_9;
    case 4:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F24A20];
      goto LABEL_9;
    case 5:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F24A18];
LABEL_9:
      uint64_t result = *v1;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t sub_1BBA1681C(uint64_t *a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1BBA160CC(result);
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

uint64_t sub_1BBA16870(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_1BBA160CC(result);
    JUMPOUT(0x1C18605E0);
  }
  return result;
}

void sub_1BBA168B8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C18605E0);
}

uint64_t sub_1BBA168F4(uint64_t a1)
{
  *(_OWORD *)(a1 + 177) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 194) = 0u;
  *(_OWORD *)(a1 + 210) = 0u;
  *(_OWORD *)(a1 + 226) = 0u;
  *(_OWORD *)(a1 + 242) = 0u;
  *(_OWORD *)(a1 + 254) = 0u;
  *(_DWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  *(_DWORD *)(a1 + 492) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(_OWORD *)(a1 + 1360) = 0u;
  *(_OWORD *)(a1 + 1376) = 0u;
  *(void *)(a1 + 1392) = 0;
  *(_DWORD *)(a1 + 1840) = 8;
  *(unsigned char *)(a1 + 1844) = 0;
  uint64_t v2 = (_OWORD *)(a1 + 3464);
  *(void *)(a1 + 3528) = 0;
  *(void *)(a1 + 3512) = 0;
  *(void *)(a1 + 3520) = 0;
  bzero((void *)(a1 + 3544), 0x210uLL);
  *(_OWORD *)(a1 + 4184) = 0u;
  *(_OWORD *)(a1 + 4168) = 0u;
  *uint64_t v2 = 0u;
  v2[1] = 0u;
  *(void *)(a1 + 3496) = 0;
  *(unsigned char *)(a1 + 627) = 1;
  *(_WORD *)a1 = 1;
  *(unsigned char *)(a1 + 2) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) = 258;
  *(unsigned char *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(void *)(a1 + 542) = 0;
  *(unsigned char *)(a1 + 550) = 1;
  *(_DWORD *)(a1 + 552) = 0;
  *(unsigned char *)(a1 + 556) = 0;
  *(_WORD *)(a1 + 576) = 0;
  *(void *)(a1 + 1416) = 0;
  return a1;
}

uint64_t sub_1BBA16A1C(uint64_t a1, unsigned int *a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  v37[1] = *MEMORY[0x1E4F143B8];
  uint64_t v15 = *((char *)a2 + 8);
  uint64_t v16 = a1 + 6 * v15;
  CFDictionaryRef v17 = (__int16 *)(v16 + 640);
  uint64_t v18 = (__int16 *)(v16 + 736);
  uint64_t v19 = *((char *)a2 + 9);
  if (v19 == -1)
  {
    if (v15 == -1) {
      CFNumberRef v21 = 0;
    }
    else {
      CFNumberRef v21 = v17;
    }
    if (v15 == -1) {
      CFArrayRef v22 = 0;
    }
    else {
      CFArrayRef v22 = v18;
    }
    uint64_t v28 = *(void *)(a1 + 16 * v15 + 3544);
    unsigned int v29 = *a2;
    return sub_1BBA16C84(a1, v28, v29, (unsigned int *)(a1 + 632), v21, v22, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  uint64_t v20 = a1 + 6 * *((char *)a2 + 9);
  CFNumberRef v21 = (__int16 *)(v20 + 832);
  CFArrayRef v22 = (__int16 *)(v20 + 928);
  if (v15 == -1)
  {
    uint64_t v28 = *(void *)(a1 + 16 * v19 + 3800);
    unsigned int v29 = a2[1];
    return sub_1BBA16C84(a1, v28, v29, (unsigned int *)(a1 + 632), v21, v22, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  uint64_t v23 = *(void *)(a1 + 3544 + 16 * v15);
  uint64_t v24 = *(void *)(a1 + 3544 + 16 * v19 + 256);
  uint64_t v26 = *a2;
  uint64_t v25 = a2[1];
  uint64_t v36 = 0;
  v37[0] = 0;
  CFTypeID v32 = (__int16 *)(v20 + 928);
  CFNumberRef v33 = (__int16 *)(v20 + 832);
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  unint64_t v30 = v17;
  CFDictionaryRef v31 = v18;
  sub_1BBA16DF0((_DWORD *)v23, v26, a3, a4, a5, a6, &v36, &v34);
  sub_1BBA16DF0((_DWORD *)v24, v25, a3, a4, a5, a6, v37, &v35);
  uint64_t result = sub_1BBA2F5A0(a1 + 2104, a5, a6, *(unsigned int *)(a1 + 632), *v31, *v30, v26, *(void *)(v23 + 112), v36, *v32, *v33, v25, *(void *)(v24 + 112), v37[0]);
  if (*(unsigned char *)(*(void *)(a1 + 1368) + 173)) {
    return sub_1BBA2F760(a1 + 2104, ((int)a5 >> 1), ((int)a6 >> 1), *(unsigned int *)(a1 + 636), (uint64_t)(v31 + 1), (uint64_t)(v30 + 1), v26, *(void *)(v23 + 120), v34, (uint64_t)(v32 + 1), (uint64_t)(v33 + 1), v25, *(void *)(v24 + 120), v35);
  }
  return result;
}

uint64_t sub_1BBA16C84(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4, __int16 *a5, __int16 *a6, int a7, int a8, int a9, int a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v21 = a3;
  sub_1BBA16DF0((_DWORD *)a2, a3, a7, a8, a9, a10, &v26, &v25);
  uint64_t result = sub_1BBA2F368(a1 + 2104, a9, a10, *a4, *a6, *a5, v21, *(void *)(a2 + 112), v26, a11, a12);
  if (*(unsigned char *)(*(void *)(a1 + 1368) + 173))
  {
    uint64_t v23 = a4[1];
    uint64_t v24 = *(void *)(a2 + 120);
    uint64_t v28 = v25;
    return sub_1BBA2F48C(a1 + 2104, (a9 >> 1), (a10 >> 1), v23, (uint64_t)(a6 + 1), (uint64_t)(a5 + 1), v21, v24, v28, a13, a14);
  }
  return result;
}

uint64_t sub_1BBA16DF0(_DWORD *a1, int a2, int a3, int a4, uint64_t a5, uint64_t a6, void *a7, void *a8)
{
  int v15 = -3 - a5;
  int v16 = a1[69] + 2;
  int v17 = a3 + ((__int16)a2 >> 2);
  if (v17 < v16) {
    int v16 = a3 + ((__int16)a2 >> 2);
  }
  if (v17 <= v15) {
    uint64_t v18 = v15;
  }
  else {
    uint64_t v18 = v16;
  }
  int v19 = -3 - a6;
  int v20 = a1[70] + 2;
  int v21 = a4 + (a2 >> 18);
  if (v21 < v20) {
    int v20 = a4 + (a2 >> 18);
  }
  if (v21 <= v19) {
    uint64_t v22 = v19;
  }
  else {
    uint64_t v22 = v20;
  }
  *a7 = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 16))(a1, v18, v22, 0);
  int v23 = ((__int16)a2 >> 3) + (a3 >> 1);
  if (v23 >= (int)a1[69] >> 1) {
    unsigned int v24 = (int)a1[69] >> 1;
  }
  else {
    unsigned int v24 = ((__int16)a2 >> 3) + (a3 >> 1);
  }
  if (v23 <= ~((int)a5 >> 1)) {
    uint64_t v25 = ~((int)a5 >> 1);
  }
  else {
    uint64_t v25 = v24;
  }
  int v26 = (a4 >> 1) + (a2 >> 19);
  if (v26 >= (int)a1[70] >> 1) {
    unsigned int v27 = (int)a1[70] >> 1;
  }
  else {
    unsigned int v27 = (a4 >> 1) + (a2 >> 19);
  }
  if (v26 <= ~((int)a6 >> 1)) {
    uint64_t v28 = ~((int)a6 >> 1);
  }
  else {
    uint64_t v28 = v27;
  }
  *a8 = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 16))(a1, v25, v28, 1);
  signed int v29 = a6 + v22 + 4;
  if ((int)atomic_load_explicit(a1 + 275, memory_order_acquire) < v29)
  {
    v31.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 276);
    v31.__owns_ = 1;
    std::mutex::lock((std::mutex *)(a1 + 276));
    while ((int)atomic_load_explicit(a1 + 275, memory_order_acquire) < v29)
      std::condition_variable::wait((std::condition_variable *)(a1 + 292), &v31);
    if (v31.__owns_) {
      std::mutex::unlock(v31.__m_);
    }
  }
  return (*((uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _DWORD *))a1 + 136))(v18, v22, v25, v28, a5, a6, a1);
}

uint64_t sub_1BBA16FE8(uint64_t a1, unsigned int *a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  v31[1] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = *((char *)a2 + 9);
  if (v16 == -1)
  {
    uint64_t v24 = *(void *)(a1 + 16 * *((char *)a2 + 8) + 3544);
    unsigned int v25 = *a2;
    return sub_1BBA17200(a1, v24, v25, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  uint64_t v17 = *((char *)a2 + 8);
  if (v17 == -1)
  {
    uint64_t v24 = *(void *)(a1 + 16 * v16 + 3800);
    unsigned int v25 = a2[1];
    return sub_1BBA17200(a1, v24, v25, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  uint64_t v18 = *(void *)(a1 + 3544 + 16 * v17);
  uint64_t v19 = *(void *)(a1 + 3544 + 16 * v16 + 256);
  uint64_t v20 = *a2;
  uint64_t v21 = a2[1];
  if (v18 == v19 && v20 == v21) {
    return sub_1BBA17200(a1, v18, v20, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  uint64_t v30 = 0;
  v31[0] = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v27 = v20;
  sub_1BBA16DF0((_DWORD *)v18, v20, a3, a4, a5, a6, &v30, &v28);
  sub_1BBA16DF0((_DWORD *)v19, v21, a3, a4, a5, a6, v31, &v29);
  uint64_t result = sub_1BBA2F098(a1 + 2104, a5, a6, v27, *(void *)(v18 + 112), v30, v21, *(void *)(v19 + 112), v31[0], a7, a8);
  if (*(unsigned char *)(*(void *)(a1 + 1368) + 173)) {
    return sub_1BBA2F200(a1 + 2104, ((int)a5 >> 1), ((int)a6 >> 1), v27, *(void *)(v18 + 120), v28, v21, *(void *)(v19 + 120), v29, a9, a10);
  }
  return result;
}

uint64_t sub_1BBA17200(uint64_t a1, uint64_t a2, unsigned int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v13 = a6;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v17 = a3;
  sub_1BBA16DF0((_DWORD *)a2, a3, a4, a5, a6, a7, &v24, &v23);
  uint64_t v18 = byte_1BBB78AC5[(v13 >> 2) - 1];
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t))(a1
                                                                                          + 2104
                                                                                          + (((unint64_t)((a3 & 3) != 0) << 6) | ((unint64_t)((*(void *)&a3 & 0x30000) != 0) << 7))
                                                                                          + 8 * v18))(a7, v17, *(void *)(a2 + 112), v24, a8, a9);
  if (*(unsigned char *)(*(void *)(a1 + 1368) + 173))
  {
    uint64_t v20 = *(void *)(a2 + 120);
    uint64_t v21 = v23;
    uint64_t v22 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1
                                                                                        + 2104
                                                                                        + (((unint64_t)((a3 & 7) != 0) << 6) | ((unint64_t)((*(void *)&a3 & 0x70000) != 0) << 7))
                                                                                        + 8 * v18
                                                                                        + 256);
    return v22(((int)a7 >> 1), v17, v20, v21, a10, a11);
  }
  return result;
}

uint64_t sub_1BBA1735C(uint64_t result, __int16 *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *(void **)(result + 1360);
  uint64_t v7 = v6[69];
  if (a4 && (a4 & 7) == 0 && a5 >= 4)
  {
    uint64_t v8 = (unsigned __int8 *)(v6[78] + v6[76] * ((uint64_t)a4 >> 3) + (a3 >> 2));
    uint64_t v9 = a5 >> 2;
    uint64_t v10 = result + 4080;
    int v11 = &a2[-6 * v7 + 2];
    do
    {
      uint64_t v12 = *((char *)a2 + 8);
      if (v12 == -1) {
        int v13 = 0;
      }
      else {
        int v13 = *(unsigned __int8 *)(v10 + v12);
      }
      uint64_t v14 = *((char *)a2 + 9);
      if (v14 == -1) {
        int v15 = 0;
      }
      else {
        int v15 = *(unsigned __int8 *)(v10 + v14 + 16);
      }
      uint64_t v16 = *((char *)v11 + 4);
      if (v16 == -1) {
        int v17 = 0;
      }
      else {
        int v17 = *(unsigned __int8 *)(v10 + v16);
      }
      uint64_t v18 = *((char *)v11 + 5);
      if (v18 == -1) {
        int v19 = 0;
      }
      else {
        int v19 = *(unsigned __int8 *)(v10 + v18 + 16);
      }
      unsigned int v20 = 1;
      if (v13 == v17 && v15 == v19)
      {
        int v21 = *(v11 - 2) - *a2;
        if (v21 < 0) {
          int v21 = *a2 - *(v11 - 2);
        }
        if (v21 <= 3)
        {
          int v22 = *(v11 - 1) - a2[1];
          if (v22 < 0) {
            int v22 = a2[1] - *(v11 - 1);
          }
          if (v22 <= 3)
          {
            int v23 = *v11 - a2[2];
            if (v23 < 0) {
              int v23 = a2[2] - *v11;
            }
            if (v23 <= 3)
            {
              int v24 = v11[1] - a2[3];
              if (v24 < 0) {
                int v24 = a2[3] - v11[1];
              }
              unsigned int v20 = v24 > 3;
            }
          }
        }
      }
      unsigned int v25 = *v8;
      if (v25 <= v20) {
        LOBYTE(v25) = v20;
      }
      *v8++ = v25;
      v11 += 6;
      --v9;
    }
    while (v9);
  }
  if (a3 && (a3 & 7) == 0 && a6 >= 4)
  {
    int v26 = (unsigned __int8 *)(*(void *)(*(void *)(result + 1360) + 640)
                            + *(void *)(*(void *)(result + 1360) + 616) * ((uint64_t)a3 >> 3)
                            + (a4 >> 2));
    uint64_t v27 = a6 >> 2;
    uint64_t v28 = result + 4080;
    uint64_t v29 = a2 - 3;
    uint64_t v30 = 12 * v7;
    do
    {
      uint64_t v31 = *((char *)a2 + 8);
      if (v31 == -1) {
        int v32 = 0;
      }
      else {
        int v32 = *(unsigned __int8 *)(v28 + v31);
      }
      uint64_t v33 = *((char *)a2 + 9);
      if (v33 == -1) {
        int v34 = 0;
      }
      else {
        int v34 = *(unsigned __int8 *)(v28 + v33 + 16);
      }
      uint64_t v35 = *((char *)v29 + 2);
      if (v35 == -1) {
        int v36 = 0;
      }
      else {
        int v36 = *(unsigned __int8 *)(v28 + v35);
      }
      uint64_t v37 = *((char *)v29 + 3);
      if (v37 == -1) {
        int v38 = 0;
      }
      else {
        int v38 = *(unsigned __int8 *)(v28 + v37 + 16);
      }
      unsigned int v39 = 1;
      if (v32 == v36 && v34 == v38)
      {
        int v40 = *(v29 - 3) - *a2;
        if (v40 < 0) {
          int v40 = *a2 - *(v29 - 3);
        }
        if (v40 <= 3)
        {
          int v41 = *(v29 - 2) - a2[1];
          if (v41 < 0) {
            int v41 = a2[1] - *(v29 - 2);
          }
          if (v41 <= 3)
          {
            int v42 = *(v29 - 1) - a2[2];
            if (v42 < 0) {
              int v42 = a2[2] - *(v29 - 1);
            }
            if (v42 <= 3)
            {
              int v43 = *v29 - a2[3];
              if (v43 < 0) {
                int v43 = a2[3] - *v29;
              }
              unsigned int v39 = v43 > 3;
            }
          }
        }
      }
      unsigned int v44 = *v26;
      if (v44 <= v39) {
        LOBYTE(v44) = v39;
      }
      *v26++ = v44;
      uint64_t v29 = (__int16 *)((char *)v29 + v30);
      --v27;
    }
    while (v27);
  }
  return result;
}

uint64_t sub_1BBA175E4(uint64_t result, __int16 *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *(void **)(result + 1360);
  uint64_t v7 = v6[69];
  if (a4 && (a4 & 7) == 0 && a5 >= 4)
  {
    uint64_t v8 = (unsigned char *)(v6[78] + v6[76] * ((uint64_t)a4 >> 3) + (a3 >> 2));
    uint64_t v9 = a5 >> 2;
    uint64_t v10 = result + 4080;
    int v11 = &a2[-6 * v7];
    do
    {
      uint64_t v12 = *((char *)a2 + 8);
      if (v12 == -1) {
        int v13 = 0;
      }
      else {
        int v13 = *(unsigned __int8 *)(v10 + v12);
      }
      uint64_t v14 = *((char *)v11 + 8);
      if (v14 == -1) {
        int v15 = 0;
      }
      else {
        int v15 = *(unsigned __int8 *)(v10 + v14);
      }
      if (v13 != v15) {
        goto LABEL_15;
      }
      int v16 = *a2 - *v11;
      if (v16 < 0) {
        int v16 = *v11 - *a2;
      }
      if (v16 <= 3)
      {
        int v18 = a2[1] - v11[1];
        if (v18 < 0) {
          int v18 = v11[1] - a2[1];
        }
        unsigned int v17 = v18 > 3;
      }
      else
      {
LABEL_15:
        unsigned int v17 = 1;
      }
      if (*v8 > v17) {
        LOBYTE(v17) = *v8;
      }
      *v8++ = v17;
      v11 += 6;
      --v9;
    }
    while (v9);
  }
  if (a3 && (a3 & 7) == 0 && a6 >= 4)
  {
    int v19 = (unsigned char *)(*(void *)(*(void *)(result + 1360) + 640)
                  + *(void *)(*(void *)(result + 1360) + 616) * ((uint64_t)a3 >> 3)
                  + (a4 >> 2));
    uint64_t v20 = a6 >> 2;
    uint64_t v21 = result + 4080;
    int v22 = a2 - 2;
    uint64_t v23 = 12 * v7;
    do
    {
      uint64_t v24 = *((char *)a2 + 8);
      if (v24 == -1) {
        int v25 = 0;
      }
      else {
        int v25 = *(unsigned __int8 *)(v21 + v24);
      }
      uint64_t v26 = *(char *)v22;
      if (v26 == -1) {
        int v27 = 0;
      }
      else {
        int v27 = *(unsigned __int8 *)(v21 + v26);
      }
      if (v25 != v27) {
        goto LABEL_36;
      }
      int v28 = *a2 - *(v22 - 4);
      if (v28 < 0) {
        int v28 = *(v22 - 4) - *a2;
      }
      if (v28 <= 3)
      {
        int v30 = a2[1] - *(v22 - 3);
        if (v30 < 0) {
          int v30 = *(v22 - 3) - a2[1];
        }
        unsigned int v29 = v30 > 3;
      }
      else
      {
LABEL_36:
        unsigned int v29 = 1;
      }
      if (*v19 > v29) {
        LOBYTE(v29) = *v19;
      }
      *v19++ = v29;
      int v22 = (__int16 *)((char *)v22 + v23);
      --v20;
    }
    while (v20);
  }
  return result;
}

uint64_t sub_1BBA17790(uint64_t result, __int16 *a2, int a3, int a4, int a5, int a6)
{
  uint64_t v10 = result;
  int v11 = *(void **)(result + 1360);
  uint64_t v12 = v11[69];
  if (a4 && (a4 & 7) == 0 && a5 >= 4)
  {
    int v13 = (unsigned __int8 *)(v11[78] + v11[76] * ((uint64_t)a4 >> 3) + (a3 >> 2));
    uint64_t v14 = a5 >> 2;
    int v15 = &a2[-6 * v12];
    do
    {
      uint64_t result = sub_1BBA178C8(a2, v15, v10 + 4080);
      unsigned int v16 = *v13;
      if (v16 <= result) {
        LOBYTE(v16) = result;
      }
      *v13++ = v16;
      v15 += 6;
      --v14;
    }
    while (v14);
  }
  if (a3 && (a3 & 7) == 0 && a6 >= 4)
  {
    unsigned int v17 = (unsigned __int8 *)(*(void *)(*(void *)(v10 + 1360) + 640)
                            + *(void *)(*(void *)(v10 + 1360) + 616) * ((uint64_t)a3 >> 3)
                            + (a4 >> 2));
    uint64_t v18 = a6 >> 2;
    uint64_t v19 = v10 + 4080;
    uint64_t v20 = a2 - 6;
    do
    {
      uint64_t result = sub_1BBA178C8(a2, v20, v19);
      unsigned int v21 = *v17;
      if (v21 <= result) {
        LOBYTE(v21) = result;
      }
      *v17++ = v21;
      v20 += 6 * v12;
      --v18;
    }
    while (v18);
  }
  return result;
}

BOOL sub_1BBA178C8(__int16 *a1, __int16 *a2, uint64_t a3)
{
  uint64_t v3 = *((char *)a1 + 8);
  if (v3 == -1) {
    int v4 = 0;
  }
  else {
    int v4 = *(unsigned __int8 *)(a3 + v3);
  }
  uint64_t v5 = *((char *)a1 + 9);
  if (v5 == -1) {
    int v6 = 0;
  }
  else {
    int v6 = *(unsigned __int8 *)(a3 + v5 + 16);
  }
  uint64_t v7 = *((char *)a2 + 8);
  if (v7 == -1) {
    int v8 = 0;
  }
  else {
    int v8 = *(unsigned __int8 *)(a3 + v7);
  }
  uint64_t v9 = *((char *)a2 + 9);
  if (v9 == -1) {
    int v10 = 0;
  }
  else {
    int v10 = *(unsigned __int8 *)(a3 + v9 + 16);
  }
  if (v4 != v8 || v6 != v10)
  {
    uint64_t v15 = 1;
    if (v4 != v10 || v6 != v8) {
      return v15;
    }
    if (v4 != v6)
    {
      int v24 = a2[2] - *a1;
      if (v24 < 0) {
        int v24 = *a1 - a2[2];
      }
      if (v24 > 3) {
        return 1;
      }
      int v25 = a2[3] - a1[1];
      if (v25 < 0) {
        int v25 = a1[1] - a2[3];
      }
      if (v25 > 3) {
        return 1;
      }
      int v16 = *a2;
      goto LABEL_55;
    }
LABEL_29:
    int v16 = *a2;
    int v17 = *a1;
    unsigned int v18 = v16 - v17;
    if (v16 - v17 < 0) {
      unsigned int v18 = v17 - v16;
    }
    if (v18 <= 3)
    {
      int v19 = a2[1] - a1[1];
      if (v19 < 0) {
        int v19 = a1[1] - a2[1];
      }
      if (v19 <= 3)
      {
        int v20 = a2[2] - a1[2];
        if (v20 < 0) {
          int v20 = a1[2] - a2[2];
        }
        if (v20 <= 3)
        {
          int v21 = a2[3] - a1[3];
          if (v21 < 0) {
            int v21 = a1[3] - a2[3];
          }
          if (v21 < 4) {
            return 0;
          }
        }
      }
    }
    int v22 = a2[2] - v17;
    if (v22 < 0) {
      int v22 = -v22;
    }
    if (v22 > 3) {
      return 1;
    }
    int v23 = a2[3] - a1[1];
    if (v23 < 0) {
      int v23 = a1[1] - a2[3];
    }
    if (v23 > 3) {
      return 1;
    }
LABEL_55:
    int v26 = v16 - a1[2];
    if (v26 < 0) {
      int v26 = -v26;
    }
    if (v26 <= 3)
    {
      uint64_t v14 = a2 + 1;
      goto LABEL_61;
    }
    return 1;
  }
  if (v4 == v6) {
    goto LABEL_29;
  }
  int v11 = *a2 - *a1;
  if (v11 < 0) {
    int v11 = *a1 - *a2;
  }
  if (v11 > 3) {
    return 1;
  }
  int v12 = a2[1] - a1[1];
  if (v12 < 0) {
    int v12 = a1[1] - a2[1];
  }
  if (v12 > 3) {
    return 1;
  }
  int v13 = a2[2] - a1[2];
  if (v13 < 0) {
    int v13 = a1[2] - a2[2];
  }
  if (v13 > 3) {
    return 1;
  }
  uint64_t v14 = a2 + 3;
LABEL_61:
  int v28 = *v14 - a1[3];
  if (v28 < 0) {
    int v28 = -v28;
  }
  return v28 > 3;
}

void *sub_1BBA17AC0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[524];
  if (v2) {
    sub_1BB9C09B4(v2);
  }
  uint64_t v3 = (void *)a1[521];
  if (v3)
  {
    int v4 = (void **)(a1 + 521);
    if (a1[522])
    {
      unint64_t v5 = 0;
      uint64_t v6 = 64;
      do
      {
        uint64_t v7 = (std::condition_variable *)(a1[521] + v6);
        int v8 = (std::mutex *)&v7[-2].__cv_.__opaque[24];
        std::condition_variable::~condition_variable(v7);
        std::mutex::~mutex(v8);
        ++v5;
        v6 += 120;
      }
      while (v5 < a1[522]);
      uint64_t v3 = *v4;
    }
    free(v3);
    *int v4 = 0;
    a1[522] = 0;
  }
  uint64_t v9 = (std::__shared_weak_count *)a1[508];
  if (v9) {
    sub_1BB9C09B4(v9);
  }
  for (uint64_t i = 506; i != 442; i -= 2)
  {
    int v11 = (std::__shared_weak_count *)a1[i];
    if (v11) {
      sub_1BB9C09B4(v11);
    }
  }
  int v12 = (void *)a1[436];
  if (v12)
  {
    free(v12);
    a1[436] = 0;
    a1[437] = 0;
  }
  int v13 = (void *)a1[433];
  if (v13)
  {
    a1[434] = v13;
    operator delete(v13);
  }
  uint64_t v14 = (std::__shared_weak_count *)a1[174];
  if (v14) {
    sub_1BB9C09B4(v14);
  }
  uint64_t v15 = (std::__shared_weak_count *)a1[172];
  if (v15) {
    sub_1BB9C09B4(v15);
  }
  int v16 = (void *)a1[128];
  if (v16)
  {
    free(v16);
    a1[128] = 0;
    a1[129] = 0;
  }
  int v17 = (void *)a1[73];
  if (v17)
  {
    free(v17);
    a1[73] = 0;
    a1[74] = 0;
  }
  unsigned int v18 = (void *)a1[70];
  if (v18)
  {
    free(v18);
    a1[70] = 0;
    a1[71] = 0;
  }
  return a1;
}

void sub_1BBA17BF8(uint64_t a1, int a2, unsigned __int8 *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  memset(v17, 0, sizeof(v17));
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v5 = (a2 + 1);
    uint64_t v6 = (std::__shared_weak_count **)v17 + 1;
    do
    {
      unsigned int v7 = *a3++;
      long long v8 = *(_OWORD *)(a1 + 16 * v7);
      uint64_t v9 = *(void *)(a1 + 16 * v7 + 8);
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
      }
      int v10 = *v6;
      *(_OWORD *)(v6 - 1) = v8;
      if (v10) {
        sub_1BB9C09B4(v10);
      }
      v6 += 2;
      --v5;
    }
    while (v5);
  }
  for (uint64_t i = 0; i != 16; ++i)
  {
    long long v12 = v17[i];
    uint64_t v13 = *((void *)&v17[i] + 1);
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = *(std::__shared_weak_count **)(a1 + i * 16 + 8);
    *(_OWORD *)(a1 + i * 16) = v12;
    if (v14) {
      sub_1BB9C09B4(v14);
    }
  }
  for (uint64_t j = 248; j != -8; j -= 16)
  {
    int v16 = *(std::__shared_weak_count **)((char *)v17 + j);
    if (v16) {
      sub_1BB9C09B4(v16);
    }
  }
}

int32x2_t sub_1BBA17D2C(uint64_t a1, unsigned int a2, int a3, uint64_t a4, uint64_t a5)
{
  v19[2] = *MEMORY[0x1E4F143B8];
  if (a4 && *(unsigned char *)(a4 + 10) != 1)
  {
    v19[0] = a1 + 3544;
    v19[1] = a1 + 3800;
    uint64_t v5 = a4 + 8;
    unsigned int v6 = a2;
    if (!*(unsigned char *)(a1 + 627)) {
      unsigned int v6 = *(unsigned __int8 *)(a1 + 538);
    }
    LODWORD(v7) = 1 - v6;
    if (*(unsigned __int8 *)(v5 + v6) == 255) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = v6;
    }
    uint64_t v8 = v19[a2] + 16 * a3;
    unsigned int v9 = *(_DWORD *)(*(void *)v8 + 36);
    if (((v9 >> 1) & 1) == *(unsigned char *)(*(void *)(a1 + 4056) + (v7 << 7) + 8 * *(char *)(v5 + v7) + 692))
    {
      __int32 v10 = *(_DWORD *)(a4 + 4 * v7);
      *(_DWORD *)a5 = v10;
      if ((v9 & 2) == 0)
      {
        int v11 = *(_DWORD *)(*(void *)(a1 + 4056) + 680)
            - *(_DWORD *)(*(void *)(a1 + 4056) + (v7 << 7) + 8 * *(char *)(v5 + v7) + 688);
        int v12 = *(_DWORD *)(a1 + 608) - *(_DWORD *)(*(void *)v8 + 680);
        if (v11 >= 127) {
          int v11 = 127;
        }
        if (v11 <= -128) {
          int v11 = -128;
        }
        if (v11)
        {
          if (v11 >= 0) {
            unsigned int v13 = v11;
          }
          else {
            unsigned int v13 = -v11;
          }
          int v11 = (__int16)((__int16)((v13 >> 1) + 0x4000) / (__int16)v11);
        }
        if (v12 >= 127) {
          int v12 = 127;
        }
        if (v12 <= -128) {
          int v12 = -128;
        }
        signed int v14 = (v11 * v12 + 32) >> 6;
        if (v14 >= 4095) {
          signed int v14 = 4095;
        }
        if (v14 <= -4096) {
          signed int v14 = -4096;
        }
        v15.i32[0] = v10 << 16;
        v15.i32[1] = v10;
        int32x2_t v16 = vmul_s32(vdup_n_s32(v14), vshr_n_s32(v15, 0x10uLL));
        int32x2_t v17 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32(vabs_s32(v16), (int32x2_t)0x7F0000007FLL), 8uLL);
        int32x2_t result = vmax_s32(vmin_s32((int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v16), (int8x8_t)vneg_s32(v17), (int8x8_t)v17), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
        *(_WORD *)(a5 + 2) = result.i16[2];
        *(_WORD *)a5 = result.i16[0];
      }
    }
  }
  return result;
}

void sub_1BBA17EF8(uint64_t a1, int a2, int a3, int a4, int a5, unsigned int a6, int a7, uint64_t a8)
{
  int v8 = a7;
  unsigned int v9 = a6;
  int v15 = a5 + a3;
  uint64_t v16 = *(void *)(a1 + 4056);
  if ((int)atomic_load_explicit((atomic_uint *volatile)(v16 + 1100), memory_order_acquire) < a5 + a3)
  {
    uint64_t v18 = a8;
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v16 + 1104);
    __lk.__owns_ = 1;
    std::mutex::lock((std::mutex *)(v16 + 1104));
    while ((int)atomic_load_explicit((atomic_uint *volatile)(v16 + 1100), memory_order_acquire) < v15)
      std::condition_variable::wait((std::condition_variable *)(v16 + 1168), &__lk);
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
    a8 = v18;
    int v8 = a7;
    unsigned int v9 = a6;
  }
  char v19 = *(unsigned char *)(*(void *)(a1 + 1368) + 2009);
  int v20 = a3 >> v19;
  int v21 = v15 >> v19;
  uint64_t v22 = *(void *)(a1 + 4056);
  if (v20 == v21 && a4 + a2 < *(_DWORD *)(v22 + 276) && v15 < *(_DWORD *)(v22 + 280))
  {
    uint64_t v23 = a8;
    sub_1BBA17D2C(a1, v9, v8, *(void *)(v22 + 576)+ 16 * (*(void *)(v22 + 552) * (int)((v15 >> 2) & 0xFFFFFFFC) + (int)(((a4 + a2) >> 2) & 0xFFFFFFFC)), a8);
    if (v24) {
      return;
    }
    uint64_t v22 = *(void *)(a1 + 4056);
    a8 = v23;
  }
  int v25 = a2 + (a4 >> 1);
  if (v25 < *(_DWORD *)(v22 + 276))
  {
    int v26 = a3 + (a5 >> 1);
    if (v26 < *(_DWORD *)(v22 + 280)) {
      sub_1BBA17D2C(a1, v9, v8, *(void *)(v22 + 576)+ 16 * (*(void *)(v22 + 552) * (int)((v26 >> 2) & 0xFFFFFFFC) + (int)((v25 >> 2) & 0xFFFFFFFC)), a8);
    }
  }
}

void sub_1BBA180C8(uint64_t a1, int a2, int a3, unsigned int a4, int a5, int a6, int a7, __int32 *a8, void *a9, uint64_t a10)
{
  uint64_t v13 = a4;
  unint64_t v14 = a1 + 3544 + ((unint64_t)a4 << 8);
  uint64_t v15 = a4 == 0;
  uint64_t v16 = a1 + 3544 + (v15 << 8);
  uint64_t v17 = 1 - a4;
  unint64_t v18 = v14 + 16 * a5;
  unsigned int v19 = *(_DWORD *)(*(void *)v18 + 36);
  if (*a9 && *(unsigned __int8 *)(*a9 + 10) > 1u)
  {
    LOBYTE(v20) = 1;
  }
  else
  {
    uint64_t v20 = a9[1];
    if (v20) {
      LOBYTE(v20) = *(unsigned __int8 *)(v20 + 10) > 1u;
    }
  }
  uint64_t v21 = 0;
  int v22 = *(_DWORD *)(*(void *)v18 + 680);
  *((unsigned char *)a8 + 48) = 0;
  char v23 = 1;
  do
  {
    char v24 = v23;
    uint64_t v25 = a9[v21];
    if (v25 && *(unsigned __int8 *)(v25 + 10) >= 2u)
    {
      uint64_t v26 = *(char *)(v25 + v13 + 8);
      if (v26 != -1 && v22 == *(_DWORD *)(*(void *)(v14 + 16 * v26) + 680))
      {
        LOBYTE(v28) = 0;
        unsigned int v34 = 1;
        *((unsigned char *)a8 + 48) = 1;
        int v35 = *(_DWORD *)(v25 + 4 * v13);
LABEL_25:
        *a8 = v35;
        goto LABEL_50;
      }
      uint64_t v27 = *(char *)(v25 + v17 + 8);
      if (v27 != -1 && v22 == *(_DWORD *)(*(void *)(v16 + 16 * v27) + 680))
      {
        LOBYTE(v28) = 0;
        unsigned int v34 = 1;
        *((unsigned char *)a8 + 48) = 1;
        int v35 = *(_DWORD *)(v25 + 4 * v17);
        goto LABEL_25;
      }
    }
    char v23 = 0;
    uint64_t v21 = 1;
  }
  while ((v24 & 1) != 0);
  uint64_t v28 = 0;
  char v29 = 1;
  while (1)
  {
    char v30 = v29;
    uint64_t v31 = a9[v28];
    if (v31)
    {
      if (*(unsigned __int8 *)(v31 + 10) >= 2u)
      {
        uint64_t v32 = *(char *)(v31 + v13 + 8);
        if (v32 != -1 && ((v19 >> 1) & 1) == (*(unsigned char *)(*(void *)(v14 + 16 * v32) + 36) & 2) >> 1)
        {
          uint64_t v36 = v13;
          uint64_t v37 = v13;
          goto LABEL_28;
        }
        uint64_t v33 = *(char *)(v31 + v17 + 8);
        if (v33 != -1 && ((v19 ^ *(unsigned __int8 *)(*(void *)(v16 + 16 * v33) + 36)) & 2) == 0) {
          break;
        }
      }
    }
    char v29 = 0;
    uint64_t v28 = 1;
    if ((v30 & 1) == 0)
    {
      unsigned int v34 = 0;
      goto LABEL_50;
    }
  }
  uint64_t v36 = v17;
  uint64_t v37 = v15;
LABEL_28:
  unsigned int v34 = 1;
  *((unsigned char *)a8 + 48) = 1;
  __int32 v38 = *(_DWORD *)(v31 + 4 * v36);
  *a8 = v38;
  if ((v19 & 2) != 0)
  {
    LOBYTE(v28) = 0;
  }
  else
  {
    int v39 = *(_DWORD *)(*(void *)(a1 + (v37 << 8) + 16 * *(char *)(a9[v28] + v36 + 8) + 3544) + 680);
    int v40 = *(_DWORD *)(a1 + 608);
    int v41 = v40 - v39;
    int v42 = v40 - *(_DWORD *)(*(void *)v18 + 680);
    if (v41 >= 127) {
      int v43 = 127;
    }
    else {
      int v43 = v41;
    }
    if (v43 <= -128) {
      int v43 = -128;
    }
    if (v43)
    {
      if (v43 >= 0) {
        unsigned int v44 = v43;
      }
      else {
        unsigned int v44 = -v43;
      }
      int v45 = (__int16)((__int16)((v44 >> 1) + 0x4000) / (__int16)v43);
    }
    else
    {
      int v45 = 0;
    }
    LOBYTE(v28) = 0;
    if (v42 >= 127) {
      int v42 = 127;
    }
    if (v42 <= -128) {
      int v42 = -128;
    }
    signed int v46 = (v45 * v42 + 32) >> 6;
    if (v46 >= 4095) {
      signed int v46 = 4095;
    }
    if (v46 <= -4096) {
      signed int v46 = -4096;
    }
    v47.i32[0] = v38 << 16;
    v47.i32[1] = v38;
    int32x2_t v48 = vmul_s32(vdup_n_s32(v46), vshr_n_s32(v47, 0x10uLL));
    int32x2_t v49 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32(vabs_s32(v48), (int32x2_t)0x7F0000007FLL), 8uLL);
    int32x2_t v50 = vmax_s32(vmin_s32((int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v48), (int8x8_t)vneg_s32(v49), (int8x8_t)v49), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
    *((_WORD *)a8 + 1) = v50.i16[2];
    *(_WORD *)a8 = v50.i16[0];
    unsigned int v34 = 1;
  }
LABEL_50:
  uint64_t v51 = 0;
  while (1)
  {
    uint64_t v52 = *(void *)(a10 + v51);
    if (v52 && *(unsigned __int8 *)(v52 + 10) >= 2u)
    {
      uint64_t v53 = *(char *)(v52 + v13 + 8);
      if (v53 != -1 && v22 == *(_DWORD *)(*(void *)(v14 + 16 * v53) + 680))
      {
        uint64_t v55 = v13;
        if (v28) {
          goto LABEL_64;
        }
        int v56 = *a8;
        int v57 = *(_DWORD *)(v52 + 4 * v13);
        uint64_t v55 = v13;
        goto LABEL_63;
      }
      uint64_t v54 = *(char *)(v52 + v17 + 8);
      if (v54 != -1 && v22 == *(_DWORD *)(*(void *)(v16 + 16 * v54) + 680)) {
        break;
      }
    }
    v51 += 8;
    if (v51 == 24) {
      goto LABEL_65;
    }
  }
  uint64_t v55 = v17;
  if (v28) {
    goto LABEL_64;
  }
  int v56 = *a8;
  int v57 = *(_DWORD *)(v52 + 4 * v17);
  uint64_t v55 = v17;
LABEL_63:
  if (v56 == v57) {
    goto LABEL_65;
  }
LABEL_64:
  *((unsigned char *)a8 + 48) = v34 + 1;
  a8[v34++] = *(_DWORD *)(v52 + 4 * v55);
LABEL_65:
  if ((v20 & 1) == 0)
  {
    uint64_t v58 = 0;
    while (1)
    {
      uint64_t v59 = *(void *)(a10 + 8 * v58);
      if (v59 && *(unsigned __int8 *)(v59 + 10) >= 2u)
      {
        uint64_t v60 = *(char *)(v59 + v13 + 8);
        if (v60 != -1 && ((v19 >> 1) & 1) == (*(unsigned char *)(*(void *)(v14 + 16 * v60) + 36) & 2) >> 1)
        {
          uint64_t v15 = v13;
          goto LABEL_77;
        }
        uint64_t v61 = *(char *)(v59 + v17 + 8);
        if (v61 != -1 && ((v19 ^ *(unsigned __int8 *)(*(void *)(v16 + 16 * v61) + 36)) & 2) == 0) {
          break;
        }
      }
      if (++v58 == 3) {
        goto LABEL_104;
      }
    }
    uint64_t v13 = v17;
LABEL_77:
    int v62 = v19 & 2;
    a8[v34] = *(_DWORD *)(v59 + 4 * v13);
    int v63 = *(_DWORD *)(*(void *)(a1 + (v15 << 8) + 16 * *(char *)(*(void *)(a10 + 8 * v58) + v13 + 8) + 3544)
                    + 680);
    int v64 = *(_DWORD *)(*(void *)v18 + 680);
    if (v63 != v64 && v62 == 0)
    {
      int v66 = *(_DWORD *)(a1 + 608);
      int v67 = v66 - v64;
      if (v66 - v63 >= 127) {
        int v68 = 127;
      }
      else {
        int v68 = v66 - v63;
      }
      if (v68 <= -128) {
        int v68 = -128;
      }
      if (v68)
      {
        if (v68 >= 0) {
          unsigned int v69 = v68;
        }
        else {
          unsigned int v69 = -v68;
        }
        int v68 = (__int16)((__int16)((v69 >> 1) + 0x4000) / (__int16)v68);
      }
      if (v67 >= 127) {
        int v67 = 127;
      }
      if (v67 <= -128) {
        int v67 = -128;
      }
      signed int v70 = (v68 * v67 + 32) >> 6;
      if (v70 >= 4095) {
        signed int v70 = 4095;
      }
      if (v70 <= -4096) {
        signed int v70 = -4096;
      }
      uint64_t v71 = (__int16 *)&a8[*((unsigned __int8 *)a8 + 48)];
      v72.i32[0] = *v71;
      v72.i32[1] = v71[1];
      int32x2_t v73 = vmul_s32(vdup_n_s32(v70), v72);
      int32x2_t v74 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32(vabs_s32(v73), (int32x2_t)0x7F0000007FLL), 8uLL);
      int32x2_t v75 = vmax_s32(vmin_s32((int32x2_t)vbsl_s8((int8x8_t)vcltz_s32(v73), (int8x8_t)vneg_s32(v74), (int8x8_t)v74), (int32x2_t)0x7F0000007FLL), (int32x2_t)0x7F0000007FLL);
      __int16 *v71 = v75.i16[0];
      v71[1] = v75.i16[2];
    }
    LOBYTE(v34) = *((unsigned char *)a8 + 48);
    if (!(_BYTE)v34 || *a8 != a8[1])
    {
      LOBYTE(v34) = v34 + 1;
      *((unsigned char *)a8 + 48) = v34;
    }
  }
LABEL_104:
  if (*(unsigned char *)(a1 + 498))
  {
    if (v34 > 1u) {
      return;
    }
    sub_1BBA17EF8(a1, a2, a3, a6, a7, a4, a5, (uint64_t)&a8[v34]);
    LOBYTE(v34) = *((unsigned char *)a8 + 48) + v76;
    *((unsigned char *)a8 + 48) = v34;
  }
  if (v34 <= 1u)
  {
    uint64_t v77 = v34;
    do
    {
      uint64_t v78 = v77;
      *((unsigned char *)a8 + 48) = v77 + 1;
      a8[v77] = 0;
      uint64_t v77 = 1;
    }
    while (!v78);
  }
}

void sub_1BBA18690(unsigned char *a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t *a7, uint64_t *a8)
{
  *(unsigned char *)(a6 + 60) = 0;
  uint64_t v14 = a7[1];
  if (v14 && *(unsigned __int8 *)(v14 + 10) >= 2u && (a4 >= a5 || ((a5 - 1) & a2) <= 0))
  {
    __int16 v38 = *(_WORD *)(v14 + 8);
    *(void *)(a6 + 4) = *(void *)v14;
    *(_WORD *)a6 = v38;
    *(unsigned char *)(a6 + 60) = 1;
  }
  else
  {
    a7[1] = 0;
  }
  uint64_t v15 = a8[1];
  if (v15 && *(unsigned __int8 *)(v15 + 10) >= 2u && (a4 <= a5 || ((a4 - 1) & a3) <= 0))
  {
    uint64_t v39 = a7[1];
    if (!v39
      || *(unsigned __int8 *)(v39 + 10) < 2u
      || *(unsigned __int8 *)(v39 + 8) != *(unsigned __int8 *)(v15 + 8)
      || *(_DWORD *)v39 != *(_DWORD *)v15
      || *(unsigned __int8 *)(v39 + 9) != *(unsigned __int8 *)(v15 + 9)
      || *(_DWORD *)(v39 + 4) != *(_DWORD *)(v15 + 4))
    {
      char v40 = *(unsigned char *)(v15 + 8);
      char v41 = *(unsigned char *)(v15 + 9);
      uint64_t v42 = a6 + 12 * *(unsigned __int8 *)(a6 + 60);
      *(void *)(v42 + 4) = *(void *)v15;
      *(unsigned char *)uint64_t v42 = v40;
      unsigned __int8 v43 = *(unsigned char *)(a6 + 60);
      *(unsigned char *)(a6 + 12 * v43++ + 1) = v41;
      *(unsigned char *)(a6 + 60) = v43;
      if (v43 == 5) {
        return;
      }
    }
  }
  else
  {
    a8[1] = 0;
  }
  uint64_t v16 = *a8;
  if (!*a8) {
    goto LABEL_93;
  }
  if (*(unsigned __int8 *)(v16 + 10) < 2u) {
    goto LABEL_93;
  }
  uint64_t v17 = a8[1];
  if (v17)
  {
    if (*(unsigned __int8 *)(v17 + 10) >= 2u
      && *(unsigned __int8 *)(v17 + 8) == *(unsigned __int8 *)(v16 + 8)
      && *(_DWORD *)v17 == *(_DWORD *)v16
      && *(unsigned __int8 *)(v17 + 9) == *(unsigned __int8 *)(v16 + 9)
      && *(_DWORD *)(v17 + 4) == *(_DWORD *)(v16 + 4))
    {
      goto LABEL_93;
    }
  }
  char v18 = *(unsigned char *)(v16 + 8);
  char v19 = *(unsigned char *)(v16 + 9);
  uint64_t v20 = a6 + 12 * *(unsigned __int8 *)(a6 + 60);
  *(void *)(v20 + 4) = *(void *)v16;
  *(unsigned char *)uint64_t v20 = v18;
  unsigned __int8 v21 = *(unsigned char *)(a6 + 60);
  *(unsigned char *)(a6 + 12 * v21++ + 1) = v19;
  *(unsigned char *)(a6 + 60) = v21;
  if (v21 != 5)
  {
LABEL_93:
    uint64_t v22 = *a7;
    if (!*a7
      || *(unsigned __int8 *)(v22 + 10) < 2u
      || (uint64_t v23 = a7[1]) != 0
      && *(unsigned __int8 *)(v23 + 10) >= 2u
      && *(unsigned __int8 *)(v23 + 8) == *(unsigned __int8 *)(v22 + 8)
      && *(_DWORD *)v23 == *(_DWORD *)v22
      && *(unsigned __int8 *)(v23 + 9) == *(unsigned __int8 *)(v22 + 9)
      && *(_DWORD *)(v23 + 4) == *(_DWORD *)(v22 + 4))
    {
      unsigned __int8 v24 = *(unsigned char *)(a6 + 60);
    }
    else
    {
      char v34 = *(unsigned char *)(v22 + 8);
      char v35 = *(unsigned char *)(v22 + 9);
      uint64_t v36 = a6 + 12 * *(unsigned __int8 *)(a6 + 60);
      *(void *)(v36 + 4) = *(void *)v22;
      *(unsigned char *)uint64_t v36 = v34;
      unsigned __int8 v37 = *(unsigned char *)(a6 + 60);
      *(unsigned char *)(a6 + 12 * v37 + 1) = v35;
      unsigned __int8 v24 = v37 + 1;
      *(unsigned char *)(a6 + 60) = v24;
      if (v24 == 5) {
        return;
      }
    }
    if (v24 > 3u) {
      goto LABEL_94;
    }
    uint64_t v25 = a8[2];
    if (!v25) {
      goto LABEL_94;
    }
    if (*(unsigned __int8 *)(v25 + 10) < 2u) {
      goto LABEL_94;
    }
    uint64_t v26 = a7[1];
    if (v26)
    {
      if (*(unsigned __int8 *)(v26 + 10) >= 2u
        && *(unsigned __int8 *)(v26 + 8) == *(unsigned __int8 *)(v25 + 8)
        && *(_DWORD *)v26 == *(_DWORD *)v25
        && *(unsigned __int8 *)(v26 + 9) == *(unsigned __int8 *)(v25 + 9)
        && *(_DWORD *)(v26 + 4) == *(_DWORD *)(v25 + 4))
      {
        goto LABEL_94;
      }
    }
    uint64_t v27 = a8[1];
    if (v27)
    {
      if (*(unsigned __int8 *)(v27 + 10) >= 2u
        && *(unsigned __int8 *)(v27 + 8) == *(unsigned __int8 *)(v25 + 8)
        && *(_DWORD *)v27 == *(_DWORD *)v25
        && *(unsigned __int8 *)(v27 + 9) == *(unsigned __int8 *)(v25 + 9)
        && *(_DWORD *)(v27 + 4) == *(_DWORD *)(v25 + 4))
      {
        goto LABEL_94;
      }
    }
    char v28 = *(unsigned char *)(v25 + 8);
    char v29 = *(unsigned char *)(v25 + 9);
    uint64_t v30 = a6 + 12 * v24;
    *(void *)(v30 + 4) = *(void *)v25;
    *(unsigned char *)uint64_t v30 = v28;
    LOBYTE(v30) = *(unsigned char *)(a6 + 60);
    *(unsigned char *)(a6 + 12 * v30 + 1) = v29;
    LOBYTE(v30) = v30 + 1;
    *(unsigned char *)(a6 + 60) = v30;
    if (v30 != 5)
    {
LABEL_94:
      if (!a1[498]) {
        goto LABEL_95;
      }
      sub_1BBA17EF8((uint64_t)a1, a2, a3, a4, a5, 0, 0, (uint64_t)&v64);
      if (!v31) {
        goto LABEL_95;
      }
      if (a1[10])
      {
        int v32 = 0;
        char v33 = -1;
      }
      else
      {
        sub_1BBA17EF8((uint64_t)a1, a2, a3, a4, a5, 1u, 0, (uint64_t)&v63);
        int v32 = v44 ? v63 : 0;
        char v33 = v44 - 1;
      }
      uint64_t v45 = a6 + 12 * *(unsigned __int8 *)(a6 + 60);
      *(_DWORD *)(v45 + 4) = v64;
      *(_DWORD *)(v45 + 8) = v32;
      *(unsigned char *)uint64_t v45 = 0;
      unsigned __int8 v46 = *(unsigned char *)(a6 + 60);
      *(unsigned char *)(a6 + 12 * v46 + 1) = v33;
      *(unsigned char *)(a6 + 60) = v46 + 1;
      if ((v46 + 1) != 5)
      {
LABEL_95:
        if (a1[10])
        {
          LOBYTE(v47) = a1[500];
          unsigned __int8 v48 = *(unsigned char *)(a6 + 60);
        }
        else
        {
          LODWORD(v49) = *(unsigned __int8 *)(a6 + 60);
          uint64_t v50 = ((v49 - 1) * v49);
          if ((int)v50 <= 0)
          {
            LOBYTE(v47) = a1[500];
          }
          else
          {
            uint64_t v51 = &byte_1BBB7829C;
            uint64_t v52 = &byte_1BBB78290;
            do
            {
              if (v49 > 4u) {
                break;
              }
              uint64_t v53 = *(char *)(a6 + 12 * *v52);
              if (v53 != -1)
              {
                uint64_t v54 = *(char *)(a6 + 12 * *v51 + 1);
                if (v54 != -1)
                {
                  int v55 = *(_DWORD *)(a6 + 12 * *v52 + 4);
                  int v56 = *(_DWORD *)(a6 + 12 * *v51 + 8);
                  if (v55 != v56
                    || *(_DWORD *)(*(void *)&a1[16 * v53 + 3544] + 680) != *(_DWORD *)(*(void *)&a1[16 * v54 + 3800]
                                                                                         + 680))
                  {
                    uint64_t v49 = a6 + 12 * v49;
                    *(_DWORD *)(v49 + 4) = v55;
                    *(unsigned char *)uint64_t v49 = v53;
                    LOBYTE(v49) = *(unsigned char *)(a6 + 60);
                    uint64_t v57 = a6 + 12 * v49;
                    *(_DWORD *)(v57 + 8) = v56;
                    *(unsigned char *)(v57 + 1) = v54;
                    LOBYTE(v49) = v49 + 1;
                    *(unsigned char *)(a6 + 60) = v49;
                    if (v49 == 5) {
                      return;
                    }
                  }
                }
              }
              ++v51;
              ++v52;
              --v50;
            }
            while (v50);
            LOBYTE(v47) = a1[500];
            unsigned __int8 v48 = v49;
            if (a1[10]) {
              goto LABEL_82;
            }
          }
          if ((char)a1[501] < (char)v47) {
            LOBYTE(v47) = a1[501];
          }
          unsigned __int8 v48 = v49;
        }
LABEL_82:
        if (v48 <= 4u)
        {
          int v58 = 0;
          int v47 = (char)v47;
          do
          {
            uint64_t v59 = a6 + 12 * v48;
            *(_DWORD *)(v59 + 4) = 0;
            *(_DWORD *)(v59 + 8) = 0;
            if (v58 >= v47) {
              char v60 = 0;
            }
            else {
              char v60 = v58;
            }
            *(unsigned char *)uint64_t v59 = v60;
            char v61 = *(unsigned char *)(a6 + 60);
            if (a1[10]) {
              char v62 = -1;
            }
            else {
              char v62 = *(unsigned char *)(a6 + 12 * *(unsigned __int8 *)(a6 + 60));
            }
            *(unsigned char *)(a6 + 12 * *(unsigned __int8 *)(a6 + 60) + 1) = v62;
            ++v58;
            unsigned __int8 v48 = v61 + 1;
            *(unsigned char *)(a6 + 60) = v48;
          }
          while (v48 < 5u);
        }
      }
    }
  }
}

uint64_t sub_1BBA18C94(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 1368);
  int v2 = *(unsigned __int8 *)(v1 + 2001);
  uint64_t v3 = *(char **)(result + 1384);
  int v4 = v3[9] + *(char *)(result + 543) + 26;
  if (v4 >= 51) {
    int v5 = 51;
  }
  else {
    int v5 = v3[9] + *(char *)(result + 543) + 26;
  }
  if (v4 <= -v2) {
    int v6 = -v2;
  }
  else {
    int v6 = v5;
  }
  *(unsigned char *)(result + 621) = v6;
  int v7 = *(char *)(result + 544);
  int v8 = v6 + v3[14] + v7;
  int v9 = *(unsigned __int8 *)(v1 + 2003);
  if (v8 >= 57) {
    int v10 = 57;
  }
  else {
    int v10 = v6 + v3[14] + v7;
  }
  if (v8 <= -v9) {
    int v11 = -v9;
  }
  else {
    int v11 = v10;
  }
  if (v11 >= 30) {
    LOBYTE(v11) = byte_1BBB83580[v11 - 30];
  }
  *(unsigned char *)(result + 622) = v11;
  char v12 = *(unsigned char *)(result + 545);
  int v13 = v6 + v3[15] + v12;
  int v14 = *(unsigned __int8 *)(v1 + 2003);
  if (v13 >= 57) {
    int v15 = 57;
  }
  else {
    int v15 = v13;
  }
  if (v13 <= -v14) {
    int v16 = -v14;
  }
  else {
    int v16 = v15;
  }
  if (v16 >= 30) {
    LOBYTE(v16) = byte_1BBB83580[v16 - 30];
  }
  *(unsigned char *)(result + 623) = v16;
  *(unsigned char *)(result + 624) = 0;
  *(unsigned char *)(result + 625) = v3[14] + v7;
  *(unsigned char *)(result + 626) = v3[15] + v12;
  return result;
}

char *sub_1BBA18D70(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  unsigned int v6 = a6;
  int32x2_t result = (char *)(*(uint64_t (**)(void, void, void, uint64_t))(**(void **)(a1 + 1360) + 16))(*(void *)(a1 + 1360), (a2 >> a6), (a3 >> a6), a6);
  uint64_t v11 = (a5 >> v6);
  if ((int)v11 >= 1)
  {
    char v12 = result;
    int v13 = (char *)(a1 + 4392);
    uint64_t v14 = *(void *)(*(void *)(a1 + 1360) + 8 * v6 + 112);
    do
    {
      int32x2_t result = (char *)memcpy(v13, v12, a4);
      v12 += v14;
      v13 += a4;
      --v11;
    }
    while (v11);
  }
  return result;
}

char *sub_1BBA18E28(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  unsigned int v6 = a6;
  int32x2_t result = (char *)(*(uint64_t (**)(void, void, void, uint64_t))(**(void **)(a1 + 1360) + 16))(*(void *)(a1 + 1360), (a2 >> a6), (a3 >> a6), a6);
  uint64_t v11 = (a5 >> v6);
  if ((int)v11 >= 1)
  {
    char v12 = result;
    int v13 = (char *)(a1 + 4392);
    size_t v14 = 2 * a4;
    uint64_t v15 = 2 * *(void *)(*(void *)(a1 + 1360) + 8 * v6 + 112);
    do
    {
      int32x2_t result = (char *)memcpy(v13, v12, v14);
      v12 += v15;
      v13 += v14;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1BBA18EE4(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  unsigned int v6 = a6;
  uint64_t result = (*(uint64_t (**)(void, void, void, uint64_t))(**(void **)(a1 + 1360) + 16))(*(void *)(a1 + 1360), (a2 >> a6), (a3 >> a6), a6);
  if (a5 >= 1)
  {
    int v13 = 0;
    uint64_t v14 = *(void *)(*(void *)(a1 + 1360) + 8 * v6 + 112);
    uint64_t v15 = (void *)(a1 + 4392);
    uint64_t v16 = 8u >> v6;
    uint64_t v17 = v14 * v16;
    uint64_t v18 = (int)v16 * (uint64_t)a4;
    if (v16 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = v16;
    }
    do
    {
      if (a4 >= 1)
      {
        uint64_t v19 = 0;
        uint64_t v20 = (void *)result;
        unsigned __int8 v21 = v15;
        do
        {
          uint64_t v22 = *(void *)(a1 + 1360);
          uint64_t v24 = *(void *)(v22 + 488);
          uint64_t v23 = *(void *)(v22 + 496);
          uint64_t v25 = v24 * ((uint64_t)(v13 + a3) >> 3) + (((int)v19 + a2) >> 3);
          if (*(unsigned char *)(*(void *)(a1 + 1384) + 19) && (*(_WORD *)(v23 + 2 * v25) & 0x100) != 0
            || *(unsigned char *)(*(void *)(a1 + 1368) + 255) && (*(_WORD *)(v23 + 2 * v25) & 0xC) != 0)
          {
            uint64_t v26 = v20;
            uint64_t v27 = v21;
            uint64_t v28 = v16;
            do
            {
              *uint64_t v26 = *v27;
              uint64_t v27 = (void *)((char *)v27 + a4);
              uint64_t v26 = (void *)((char *)v26 + v14);
              --v28;
            }
            while (v28);
          }
          v19 += 8;
          ++v21;
          ++v20;
        }
        while (v19 < a4);
      }
      result += v17;
      uint64_t v15 = (void *)((char *)v15 + v18);
      v13 += 8;
    }
    while (v13 < a5);
  }
  return result;
}

uint64_t sub_1BBA19044(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6)
{
  unsigned int v6 = a6;
  uint64_t result = (*(uint64_t (**)(void, void, void, uint64_t))(**(void **)(a1 + 1360) + 16))(*(void *)(a1 + 1360), (a2 >> a6), (a3 >> a6), a6);
  if (a5 >= 1)
  {
    int v13 = 0;
    uint64_t v14 = *(void *)(*(void *)(a1 + 1360) + 8 * v6 + 112);
    uint64_t v15 = (_OWORD *)(a1 + 4392);
    uint64_t v16 = 8u >> v6;
    if (v16 <= 1) {
      uint64_t v17 = 1;
    }
    else {
      uint64_t v17 = v16;
    }
    uint64_t v18 = 2 * (int)v16 * a4;
    uint64_t v19 = 2 * v14 * v16;
    uint64_t v20 = 2 * v14;
    do
    {
      if (a4 >= 1)
      {
        uint64_t v21 = 0;
        uint64_t v22 = (_OWORD *)result;
        uint64_t v23 = v15;
        do
        {
          uint64_t v24 = *(void *)(a1 + 1360);
          uint64_t v26 = *(void *)(v24 + 488);
          uint64_t v25 = *(void *)(v24 + 496);
          uint64_t v27 = v26 * ((uint64_t)(v13 + a3) >> 3) + (((int)v21 + a2) >> 3);
          if (*(unsigned char *)(*(void *)(a1 + 1384) + 19) && (*(_WORD *)(v25 + 2 * v27) & 0x100) != 0
            || *(unsigned char *)(*(void *)(a1 + 1368) + 255) && (*(_WORD *)(v25 + 2 * v27) & 0xC) != 0)
          {
            uint64_t v28 = v22;
            char v29 = v23;
            uint64_t v30 = v17;
            do
            {
              *uint64_t v28 = *v29;
              char v29 = (_OWORD *)((char *)v29 + 2 * a4);
              uint64_t v28 = (_OWORD *)((char *)v28 + v20);
              --v30;
            }
            while (v30);
          }
          v21 += 8;
          ++v23;
          ++v22;
        }
        while (v21 < a4);
      }
      v13 += 8;
      uint64_t v15 = (_OWORD *)((char *)v15 + v18);
      result += v19;
    }
    while (v13 < a5);
  }
  return result;
}

uint64_t sub_1BBA191B4(void *a1, int a2, int a3)
{
  unsigned int v4 = *(_DWORD *)(a1[171] + 2016);
  int v5 = a2 + v4 * a3;
  uint64_t v6 = a1[173];
  if (*(unsigned char *)(v6 + 20))
  {
    uint64_t v7 = v6 + 1624;
    unsigned int v8 = sub_1BBA1949C(v6 + 1624, a2, a3);
    uint64_t v9 = a1[434];
    uint64_t v10 = a1[433];
    if (v9 != v10)
    {
      unsigned int v11 = v8;
      while (1)
      {
        uint64_t v12 = v9 - 16;
        unsigned int v13 = *(_DWORD *)(v9 - 12);
        if ((int)v13 <= v5)
        {
          signed int v14 = sub_1BBA1949C(v7, v13 % v4, v13 / v4);
          if ((int)v11 >= v14 && v11 <= *(_DWORD *)(v9 - 8) + v14) {
            break;
          }
        }
        v9 -= 16;
        if (v12 == v10) {
          return v10;
        }
      }
      v9 -= 16;
    }
  }
  else
  {
    uint64_t v15 = a1[434];
    uint64_t v9 = a1[433];
    while (v15 != v9)
    {
      uint64_t v16 = v15 - 16;
      int v17 = *(_DWORD *)(v15 - 12);
      v15 -= 16;
      if (v17 <= v5) {
        return v16;
      }
    }
  }
  return v9;
}

uint64_t sub_1BBA192A4(void **memptr, unint64_t a2)
{
  if ((unint64_t)memptr[1] >= a2) {
    return 0;
  }
  if (a2 > 0x3200000) {
    return 4294954392;
  }
  unsigned int v4 = *memptr;
  if (v4)
  {
    free(v4);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, 0x10uLL, 2 * a2, 0x1000040BDFB0063uLL) || !*memptr) {
    return 4294954392;
  }
  bzero(*memptr, 2 * a2);
  uint64_t result = 0;
  memptr[1] = (void *)a2;
  return result;
}

uint64_t sub_1BBA19348(void **memptr, unint64_t a2)
{
  if ((unint64_t)memptr[1] >= a2) {
    return 0;
  }
  if (a2 > 0x855555) {
    return 4294954392;
  }
  unsigned int v4 = *memptr;
  if (v4)
  {
    free(v4);
    *memptr = 0;
    memptr[1] = 0;
  }
  if (malloc_type_posix_memalign(memptr, 0x10uLL, 12 * a2, 0x10000403E1C8BA9uLL) || !*memptr) {
    return 4294954392;
  }
  uint64_t v6 = 0;
  unint64_t v7 = a2;
  do
  {
    unsigned int v8 = (char *)*memptr + v6;
    *((_DWORD *)v8 + 2) = 0;
    *(void *)unsigned int v8 = 0;
    v6 += 12;
    --v7;
  }
  while (v7);
  uint64_t result = 0;
  memptr[1] = (void *)a2;
  return result;
}

uint64_t sub_1BBA19404(int a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  int v5 = 0;
  int v6 = 0;
  uint64_t v7 = a4 + 8;
  while (v5 < a1)
  {
    uint64_t v8 = 0;
    unsigned int v9 = *(unsigned __int16 *)(a3 + 2 * v4);
    uint64_t v10 = (_DWORD *)(v7 + 12 * v5);
    do
    {
      *(v10 - 2) = v4;
      *(v10 - 1) = v6;
      _DWORD *v10 = v6 + v9 + 1;
      unsigned int v11 = v8;
      int v12 = v8 + 1;
      if (v8 >= v9) {
        break;
      }
      uint64_t v13 = v5 + 1 + v8;
      v10 += 3;
      ++v8;
    }
    while (v13 < a1);
    if (v11 < v9) {
      break;
    }
    v5 += v12;
    ++v4;
    v6 += v9 + 1;
    if (v4 == a2) {
      return 0;
    }
  }
  return 4294954387;
}

uint64_t sub_1BBA1949C(uint64_t a1, int a2, int a3)
{
  if (!*(unsigned char *)(a1 + 72)) {
    return 0;
  }
  int v3 = *(_DWORD *)(a1 + 64);
  if (v3 <= a2 || *(_DWORD *)(a1 + 68) <= a3) {
    return 0;
  }
  int v4 = *(_DWORD *)(*(void *)(a1 + 48) + 12 * a3);
  return (v4
                      + v4 * *(_DWORD *)(*(void *)(a1 + 32) + 12 * (v3 - 1))
                      + *(_DWORD *)(*(void *)(a1 + 32) + 12 * a2));
}

uint64_t sub_1BBA194F8(void **a1, void *a2)
{
  uint64_t result = sub_1BBA12730(a1, a2[4] + 4, 0x10uLL);
  if (!result)
  {
    int v5 = (uint64_t (*)(void *, void *))a2[5];
    uint64_t v6 = a2[6];
    uint64_t v7 = (void *)((char *)a2 + (v6 >> 1));
    if (v6) {
      int v5 = *(uint64_t (**)(void *, void *))(*v7 + v5);
    }
    uint64_t v8 = v5(v7, *a1);
    unsigned int v9 = (unsigned int *)*a1;
    if (v8) {
      BOOL v10 = v9 == 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (v10)
    {
      return 4294954387;
    }
    else
    {
      uint64_t v11 = v8;
      uint64_t result = 0;
      a1[2] = v9;
      a1[3] = v9;
      a1[4] = (char *)v9 + v11;
      a1[5] = (void *)bswap32(*v9);
      *((unsigned char *)a1 + 48) = 0;
    }
  }
  return result;
}

uint64_t sub_1BBA195B4(void **a1, int a2)
{
  uint64_t result = sub_1BBA12730(a1, (a2 + 4), 0x10uLL);
  if (!result)
  {
    uint64_t result = 4294954387;
    if (a2)
    {
      int v5 = (char *)*a1;
      if (*a1)
      {
        uint64_t result = 0;
        a1[2] = v5;
        a1[3] = v5;
        a1[4] = &v5[a2];
        *((_DWORD *)a1 + 11) = 0;
        *((unsigned char *)a1 + 48) = 0;
      }
    }
    *((_DWORD *)a1 + 10) = 0;
  }
  return result;
}

uint64_t sub_1BBA19614(uint64_t result, int a2, int a3)
{
  unsigned int v3 = (a2 << (-(char)a3 - *(_DWORD *)(result + 44))) | *(_DWORD *)(result + 40);
  *(_DWORD *)(result + 40) = v3;
  **(_DWORD **)(result + 24) = bswap32(v3);
  unint64_t v4 = *(int *)(result + 44) + (uint64_t)a3;
  int v5 = *(_DWORD *)(result + 40) << (v4 & 0xF8);
  unint64_t v6 = *(void *)(result + 32);
  unint64_t v7 = *(void *)(result + 24) + (v4 >> 3);
  *(void *)(result + 24) = v7;
  *(_DWORD *)(result + 40) = v5;
  *(_DWORD *)(result + 44) = v4 & 7;
  if (v7 >= v6)
  {
    *(unsigned char *)(result + 48) = 1;
    *(void *)(result + 24) = v6;
  }
  return result;
}

uint64_t sub_1BBA19678(uint64_t a1, unsigned int a2, int a3)
{
  unsigned __int16 v3 = a2;
  uint64_t v4 = a1;
  if (a3 > 25)
  {
    sub_1BBA19614(a1, HIWORD(a2), a3 - 16);
    a2 = v3;
    a1 = v4;
    a3 = 16;
  }

  return sub_1BBA19614(a1, a2, a3);
}

uint64_t sub_1BBA196DC(uint64_t a1, int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 40);
  unint64_t v3 = *(int *)(a1 + 44) + (uint64_t)a2;
  char v4 = v3 & 7;
  *(_DWORD *)(a1 + 44) = v3 & 7;
  unint64_t v5 = *(void *)(a1 + 32);
  unint64_t v6 = (unsigned int *)(*(void *)(a1 + 24) + (v3 >> 3));
  *(void *)(a1 + 24) = v6;
  if ((unint64_t)v6 >= v5)
  {
    if ((unint64_t)v6 > v5) {
      *(void *)(a1 + 24) = v5;
    }
    unsigned int v7 = v2;
  }
  else
  {
    unsigned int v7 = bswap32(*v6);
  }
  *(_DWORD *)(a1 + 40) = v7 << v4;
  return v2 >> -(char)a2;
}

uint64_t sub_1BBA19734(uint64_t a1, int a2)
{
  if (a2 > 25)
  {
    int v4 = sub_1BBA196DC(a1, a2 - 16);
    return sub_1BBA196DC(a1, 16) + (v4 << 16);
  }
  else
  {
    return sub_1BBA196DC(a1, a2);
  }
}

uint64_t sub_1BBA1979C(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 40);
  if (!v1) {
    return 0;
  }
  unsigned int v2 = __clz(v1);
  unsigned int v3 = v1 << (v2 + 1) >> -(char)v2;
  if (!v2) {
    unsigned int v3 = 0;
  }
  unint64_t v4 = *(int *)(a1 + 44) + (unint64_t)((2 * v2) | 1);
  unint64_t v5 = *(void *)(a1 + 32);
  unint64_t v6 = (unsigned int *)(*(void *)(a1 + 24) + (v4 >> 3));
  int v7 = v4 & 7;
  *(_DWORD *)(a1 + 44) = v7;
  *(void *)(a1 + 24) = v6;
  if ((unint64_t)v6 >= v5)
  {
    if ((unint64_t)v6 > v5) {
      *(void *)(a1 + 24) = v5;
    }
  }
  else
  {
    unsigned int v1 = bswap32(*v6);
  }
  *(_DWORD *)(a1 + 40) = v1 << v7;
  return v3 + ~(-1 << v2);
}

uint64_t sub_1BBA19824(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) >> 19)
  {
    return sub_1BBA1979C(a1);
  }
  else
  {
    unsigned int v3 = -1;
    do
      ++v3;
    while (!sub_1BBA196DC(a1, 1) && v3 < 0x20);
    return sub_1BBA19734(a1, v3) + ~(-1 << v3);
  }
}

uint64_t sub_1BBA198B8(uint64_t a1, int a2)
{
  unsigned int v3 = a2 + 1;
  if (a2 == -1)
  {
    sub_1BBA19614(a1, 0, 16);
    sub_1BBA19614(a1, 0, 16);
    sub_1BBA19614(a1, 1, 1);
    sub_1BBA19614(a1, 0, 16);
    uint64_t v4 = a1;
    int v5 = 0;
    int v6 = 16;
LABEL_11:
    return sub_1BBA19614(v4, v5, v6);
  }
  unsigned int v7 = __clz(v3);
  unsigned int v8 = v7 ^ 0x1F;
  unsigned int v9 = (v7 ^ 0x1F) >> 1;
  if ((v7 ^ 0x1F) >= 2) {
    sub_1BBA19614(a1, 0, v8 >> 1);
  }
  if (v8 != v9) {
    sub_1BBA19614(a1, 0, v8 - (v8 >> 1));
  }
  uint64_t result = sub_1BBA19614(a1, 1, 1);
  unsigned int v11 = v3 - (0x80000000 >> v7);
  if (v8 >= 2) {
    uint64_t result = sub_1BBA19614(a1, v11 >> (v8 - (v8 >> 1)), v8 >> 1);
  }
  if (v8 != v9)
  {
    uint64_t v4 = a1;
    int v5 = v11;
    int v6 = v8 - (v8 >> 1);
    goto LABEL_11;
  }
  return result;
}

uint64_t sub_1BBA199EC(uint64_t a1, int a2)
{
  if (a2 <= 0) {
    int v2 = -2 * a2;
  }
  else {
    int v2 = 2 * a2 - 1;
  }
  unsigned int v3 = v2 + 1;
  unsigned int v4 = __clz(v3);
  return sub_1BBA19614(a1, (v3 - (0x80000000 >> v4)) | (0x80000000 >> v4), 63 - 2 * v4);
}

uint64_t sub_1BBA19A20(uint64_t a1)
{
  uint64_t result = sub_1BBA19614(a1, 1, 1);
  uint64_t v3 = *(int *)(a1 + 44);
  if (v3)
  {
    unsigned int v4 = *(unsigned char **)(a1 + 24);
    if ((unint64_t)v4 < *(void *)(a1 + 32))
    {
      *v4 &= byte_1BBB8A4AC[v3];
      unsigned int v4 = *(unsigned char **)(a1 + 24);
    }
    *(void *)(a1 + 24) = v4 + 1;
  }
  *(void *)(a1 + 40) = 0;
  return result;
}

uint64_t sub_1BBA19A88(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 24) = sub_1BBA196DC(a2, 8);
  *(unsigned char *)(a1 + 25) = *(unsigned char *)(a1 + 25) & 0xFC | sub_1BBA196DC(a2, 2) & 3;
  *(unsigned char *)(a1 + 25) = *(unsigned char *)(a1 + 25) & 0xFB | (4 * (sub_1BBA196DC(a2, 1) != 0));
  *(unsigned char *)(a1 + 25) = *(unsigned char *)(a1 + 25) & 7 | (8 * sub_1BBA196DC(a2, 5));
  int v4 = sub_1BBA196DC(a2, 16);
  *(_DWORD *)(a1 + 28) = sub_1BBA196DC(a2, 16) + (v4 << 16);
  int v5 = sub_1BBA196DC(a2, 16);
  uint64_t v6 = sub_1BBA196DC(a2, 16) + (v5 << 16);
  *(void *)(a1 + 32) = sub_1BBA196DC(a2, 16) | (unint64_t)(v6 << 16);
  *(unsigned char *)(a1 + 40) = sub_1BBA196DC(a2, 8);
  int v7 = sub_1BBA196DC(a2, 4);
  *(_WORD *)(a1 + 42) = sub_1BBA196DC(a2, 12);
  int v8 = sub_1BBA196DC(a2, 6);
  *(unsigned char *)(a1 + 44) = sub_1BBA196DC(a2, 2);
  int v9 = sub_1BBA196DC(a2, 6);
  *(unsigned char *)(a1 + 45) = sub_1BBA196DC(a2, 2);
  int v10 = sub_1BBA196DC(a2, 5);
  *(unsigned char *)(a1 + 46) = sub_1BBA196DC(a2, 3);
  int v11 = sub_1BBA196DC(a2, 5);
  *(unsigned char *)(a1 + 47) = sub_1BBA196DC(a2, 3);
  *(_WORD *)(a1 + 48) = sub_1BBA196DC(a2, 16);
  *(unsigned char *)(a1 + 50) = *(unsigned char *)(a1 + 50) & 0xFC | sub_1BBA196DC(a2, 2) & 3;
  *(unsigned char *)(a1 + 50) = (4 * (sub_1BBA196DC(a2, 3) & 7)) | *(unsigned char *)(a1 + 50) & 0xE3;
  *(unsigned char *)(a1 + 50) = *(unsigned char *)(a1 + 50) & 0xDF | (32 * (sub_1BBA196DC(a2, 1) != 0));
  *(unsigned char *)(a1 + 50) = *(unsigned char *)(a1 + 50) & 0x3F | (sub_1BBA196DC(a2, 2) << 6);
  *(unsigned char *)(a1 + 51) = sub_1BBA196DC(a2, 8);
  uint64_t result = 4294954394;
  if (*(unsigned char *)(a1 + 24) == 1 && v7 == 15 && v8 == 63 && v9 == 63 && v10 == 31 && v11 == 31)
  {
    if (*(unsigned __int8 *)(a1 + 50) >= 0x40u)
    {
      if ((((*(unsigned char *)(a1 + 50) >> 6) - 1) & 0xFFFFFFFD) != 0) {
        return 4294954394;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *sub_1BBA19D2C(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[197];
  if (v2) {
    sub_1BB9C09B4(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[195];
  if (v3) {
    sub_1BB9C09B4(v3);
  }
  int v4 = (std::__shared_weak_count *)a1[193];
  if (v4) {
    sub_1BB9C09B4(v4);
  }
  for (uint64_t i = 191; i != 63; i -= 2)
  {
    uint64_t v6 = (std::__shared_weak_count *)a1[i];
    if (v6) {
      sub_1BB9C09B4(v6);
    }
  }
  do
  {
    int v7 = (std::__shared_weak_count *)a1[i];
    if (v7) {
      sub_1BB9C09B4(v7);
    }
    i -= 2;
  }
  while (i != 31);
  do
  {
    int v8 = (std::__shared_weak_count *)a1[i];
    if (v8) {
      sub_1BB9C09B4(v8);
    }
    i -= 2;
  }
  while (i != -1);
  return a1;
}

uint64_t sub_1BBA19DC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = 0;
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  do
  {
    int v10 = *(void **)(a4 + v9);
    if (v10) {
      bzero(v10, *(void *)(a5 + v9));
    }
    v9 += 8;
  }
  while (v9 != 40);
  int v11 = *(unsigned int **)a1;
  if (!*(void *)a1) {
    return 4294954394;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  if (!v12) {
    return 4294954394;
  }
  v58[0] = 0;
  v58[1] = 0;
  uint64_t v59 = v11;
  char v60 = v11;
  char v61 = (char *)v11 + v12;
  unsigned int v62 = bswap32(*v11);
  int v63 = 0;
  char v64 = 0;
  uint64_t v13 = sub_1BBA19A88(a1, (uint64_t)v58);
  if (!v13)
  {
    uint64_t v68 = 0;
    memset(v67, 0, sizeof(v67));
    uint64_t v66 = 0;
    memset(v65, 0, sizeof(v65));
    unsigned int v14 = *(unsigned __int8 *)(a1 + 51);
    uint64_t v15 = v60;
    uint64_t v50 = v59;
    if (*(unsigned char *)(a1 + 51))
    {
      int v16 = 0;
      unint64_t v17 = (unint64_t)v61;
      unsigned int v18 = v62;
      int v57 = v63;
      uint64_t v48 = a2;
      uint64_t v49 = a1;
      uint64_t v51 = a5;
      uint64_t v53 = a4;
      do
      {
        unint64_t v19 = v57 + 1;
        char v20 = v19 & 7;
        int v63 = v19 & 7;
        uint64_t v21 = (unsigned int *)((char *)v15 + (v19 >> 3));
        char v60 = v21;
        if ((unint64_t)v21 >= v17)
        {
          if ((unint64_t)v21 > v17) {
            uint64_t v21 = (unsigned int *)v17;
          }
        }
        else
        {
          unsigned int v18 = bswap32(*v21);
        }
        unsigned int v22 = v18 << v20;
        unint64_t v23 = (v19 & 7) + 1;
        unsigned int v62 = v18 << v20;
        int v63 = v23 & 7;
        uint64_t v24 = (unsigned int *)((char *)v21 + (v23 >> 3));
        char v60 = v24;
        if ((unint64_t)v24 >= v17)
        {
          if ((unint64_t)v24 > v17) {
            uint64_t v24 = (unsigned int *)v17;
          }
          unsigned int v25 = v18 << v20;
        }
        else
        {
          unsigned int v25 = bswap32(*v24);
        }
        unsigned int v26 = v25 << (v23 & 7);
        unsigned int v62 = v26;
        if ((v22 & 0x80000000) != 0) {
          goto LABEL_62;
        }
        unint64_t v27 = (v23 & 7) + 6;
        int v57 = v27 & 7;
        int v63 = v57;
        uint64_t v28 = (unsigned int *)((char *)v24 + (v27 >> 3));
        char v60 = v28;
        if ((unint64_t)v28 >= v17)
        {
          if ((unint64_t)v28 > v17) {
            uint64_t v28 = (unsigned int *)v17;
          }
          unsigned int v29 = v25 << (v23 & 7);
        }
        else
        {
          unsigned int v29 = bswap32(*v28);
        }
        unsigned int v30 = v29 << v57;
        unsigned int v62 = v30;
        int v63 = v57;
        uint64_t v15 = (unsigned int *)((char *)v28 + 2);
        char v60 = v15;
        if ((unint64_t)v15 >= v17)
        {
          if ((unint64_t)v15 > v17)
          {
            char v60 = (unsigned int *)v17;
            uint64_t v15 = (unsigned int *)v17;
          }
          unsigned int v31 = v30;
        }
        else
        {
          unsigned int v31 = bswap32(*v15);
        }
        unsigned int v32 = v26 >> 26;
        unsigned int v18 = v31 << v57;
        unsigned int v62 = v31 << v57;
        unsigned int v33 = v32 - 32;
        if (v32 - 32 > 8 || ((0x187u >> v33) & 1) == 0)
        {
LABEL_62:
          uint64_t v13 = 4294954394;
          goto LABEL_63;
        }
        int v52 = v16;
        uint64_t v34 = qword_1BBB78480[v33];
        uint64_t v35 = *(void *)(a2 + 8 * v34);
        uint64_t v36 = *(void *)(a4 + 8 * v34);
        if (v35) {
          BOOL v37 = v36 == 0;
        }
        else {
          BOOL v37 = 1;
        }
        if (v37) {
          unint64_t v56 = 0;
        }
        else {
          unint64_t v56 = *(void *)(v51 + 8 * v34) >> 3;
        }
        if (v30 >= 0x10000)
        {
          unint64_t v38 = 0;
          uint64_t v39 = HIWORD(v30);
          uint64_t v54 = *(void *)(a4 + 8 * v34);
          while (1)
          {
            char v40 = (unsigned int *)((char *)v15 + 2);
            if ((unint64_t)v15 + 2 >= v17)
            {
              if ((unint64_t)v15 + 2 > v17) {
                char v40 = (unsigned int *)v17;
              }
              unsigned int v41 = v18;
            }
            else
            {
              unsigned int v41 = bswap32(*v40);
            }
            uint64_t v42 = HIWORD(v18);
            if (v35 && v56 > v38 && v36)
            {
              uint64_t v43 = *((void *)v67 + v34);
              unint64_t v44 = v43 + v42;
              if (v44 > *(void *)(a3 + 8 * v34))
              {
                uint64_t v13 = 4294940770;
                goto LABEL_63;
              }
              uint64_t v45 = *((void *)v65 + v34);
              *(void *)(v36 + 8 * v45) = v42;
              uint64_t v46 = v39;
              memcpy((void *)(v35 + v43), v40, HIWORD(v18));
              uint64_t v39 = v46;
              a4 = v53;
              uint64_t v36 = v54;
              *((void *)v67 + v34) = v44;
              *((void *)v65 + v34) = v45 + 1;
            }
            uint64_t v15 = (unsigned int *)((char *)v40 + v42);
            if ((unint64_t)v15 >= v17)
            {
              unsigned int v18 = v41 << v57;
              if ((unint64_t)v15 > v17) {
                uint64_t v15 = (unsigned int *)v17;
              }
            }
            else
            {
              unsigned int v18 = bswap32(*v15);
            }
            if (v39 == ++v38)
            {
              unsigned int v62 = v18;
              int v63 = v57;
              char v60 = v15;
              a2 = v48;
              a1 = v49;
              unsigned int v14 = *(unsigned __int8 *)(v49 + 51);
              break;
            }
          }
        }
        int v16 = v52 + 1;
      }
      while (v52 + 1 < v14);
    }
    if ((unint64_t)((char *)v15 - (char *)v50) <= *(void *)(a1 + 16)) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = 4294940770;
    }
  }
LABEL_63:
  if (v58[0]) {
    free(v58[0]);
  }
  return v13;
}

uint64_t sub_1BBA1A16C(unsigned char *a1, uint64_t a2)
{
  a1[24] = sub_1BBA196DC(a2, 8);
  a1[25] = sub_1BBA196DC(a2, 8);
  a1[26] = sub_1BBA196DC(a2, 8);
  a1[27] = sub_1BBA196DC(a2, 8);
  int v4 = sub_1BBA196DC(a2, 6);
  a1[28] = sub_1BBA196DC(a2, 2);
  if (sub_1BBA196DC(a2, 3) == 7 && v4 == 63 && a1[24] == 1) {
    return 0;
  }
  else {
    return 4294954394;
  }
}

void sub_1BBA1A220(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      int v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void *sub_1BBA1A278(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1BBA1A540(a1, a2);
    uint64_t v4 = (char *)a1[1];
    int v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1BBA1A2D0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1BBA1A2EC(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1BBA1A540(result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1BBA1A34C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA1A368(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_1BB9C185C();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  char v20 = a1 + 2;
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      sub_1BB9C18AC();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  size_t v8 = &v7[24 * v2];
  unint64_t v17 = v7;
  v18.i64[0] = (uint64_t)v8;
  v18.i64[1] = (uint64_t)v8;
  unint64_t v19 = &v7[24 * v6];
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *(void *)size_t v8 = 0;
  sub_1BBA1A2EC(v8, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  uint64_t v9 = v18.i64[0];
  uint64_t v10 = v18.i64[1] + 24;
  v18.i64[1] += 24;
  uint64_t v12 = (void *)*a1;
  int v11 = (void *)a1[1];
  if (v11 == (void *)*a1)
  {
    int64x2_t v14 = vdupq_n_s64((unint64_t)v11);
  }
  else
  {
    do
    {
      *(void *)(v9 - 24) = 0;
      *(void *)(v9 - 16) = 0;
      v9 -= 24;
      *(void *)(v9 + 16) = 0;
      long long v13 = *(_OWORD *)(v11 - 3);
      v11 -= 3;
      *(_OWORD *)uint64_t v9 = v13;
      *(void *)(v9 + 16) = v11[2];
      *int v11 = 0;
      v11[1] = 0;
      v11[2] = 0;
    }
    while (v11 != v12);
    int64x2_t v14 = *(int64x2_t *)a1;
    uint64_t v10 = v18.i64[1];
  }
  *a1 = v9;
  a1[1] = v10;
  int64x2_t v18 = v14;
  uint64_t v15 = (char *)a1[2];
  a1[2] = (uint64_t)v19;
  unint64_t v19 = v15;
  unint64_t v17 = (char *)v14.i64[0];
  sub_1BBA1A4DC((uint64_t)&v17);
  return v10;
}

void sub_1BBA1A4C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1BBA1A4DC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1BBA1A4DC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v4 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_1BBA1A540(void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    sub_1BB9C185C();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

uint64_t *sub_1BBA1A580(uint64_t *result, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t *a5, int *a6, int a7, int a8)
{
  if ((int)a3 >= 17 && (int)a4 >= 17 && a7 >= 17 && a8 >= 17)
  {
    long long v13 = result;
    unsigned int v14 = (a7 << 16) / (int)a3;
    uint64_t v15 = *result;
    uint64_t v16 = *a2;
    uint64_t v17 = *a5;
    uint64_t v18 = a4 >> 1;
    uint64_t v19 = a3 >> 1;
    int v20 = *a6;
    int v21 = a7 >> 1;
    int v22 = a8 >> 1;
    if (v14 <= 0x20000)
    {
      sub_1BBA1A930(0, a4, v15, v16, a3, a4, v17, v20, a7, a8, (uint64_t (*)(uint64_t, uint16x8_t *, void, _DWORD *, char *, char *, uint64_t))BilinearFilterH_vperm2_neon64);
      return (uint64_t *)sub_1BBA1A930(1, v18, v13[1], a2[1], v19, v18, a5[1], a6[1], v21, v22, (uint64_t (*)(uint64_t, uint16x8_t *, void, _DWORD *, char *, char *, uint64_t))BilinearFilterH_chroma_vperm2_neon64);
    }
    else
    {
      sub_1BBA1A6E8(0, a4, v15, v16, a3, a4, v17, v20, a7, (uint64_t (*)(uint64_t, uint16x8_t *, void, void, unint64_t, uint64_t))BilinearFilterH_swift_neon);
      return (uint64_t *)sub_1BBA1A6E8(1, v18, v13[1], a2[1], v19, v18, a5[1], a6[1], v21, (uint64_t (*)(uint64_t, uint16x8_t *, void, void, unint64_t, uint64_t))BilinearFilterH_swift_chroma_neon);
    }
  }
  return result;
}

uint64_t sub_1BBA1A6E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9, uint64_t (*a10)(uint64_t, uint16x8_t *, void, void, unint64_t, uint64_t))
{
  int v51 = a8;
  uint64_t v50 = a7;
  uint64_t v10 = a3;
  int v11 = a2;
  int v47 = a10;
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  int v48 = a1;
  int v46 = a9 << a1;
  uint64_t v12 = MEMORY[0x1F4188790](a1, a2, a3, a4, a5, a6);
  unsigned int v14 = (uint16x8_t *)((unint64_t)&v43[-v13 + 15] & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12, v15, v16, v17, v18, v19);
  unsigned __int16 v24 = 0;
  uint64_t v25 = 0;
  unint64_t v26 = (unint64_t)&v43[-((v23 + 47) & 0x1FFFFFFF0) + 15] & 0xFFFFFFFFFFFFFFF0;
  unsigned int v49 = v27;
  uint64_t v28 = (v23 + 1) & 0x1FFFFFFFELL;
  uint64x2_t v29 = (uint64x2_t)vdupq_n_s64(v23 - 1);
  int64x2_t v30 = (int64x2_t)xmmword_1BBB6F620;
  int64x2_t v31 = vdupq_n_s64(2uLL);
  unsigned int v52 = (a9 << 16) / v27;
  __int16 v32 = 2 * v52;
  do
  {
    int32x2_t v33 = vmovn_s64((int64x2_t)vcgeq_u64(v29, (uint64x2_t)v30));
    if (v33.i8[0]) {
      *(unsigned char *)(v26 + v25) = v24 >> 12;
    }
    if (v33.i8[4]) {
      *(unsigned char *)(v26 + v25 + 1) = (unsigned __int16)(v52 + v24) >> 12;
    }
    v25 += 2;
    int64x2_t v30 = vaddq_s64(v30, v31);
    v24 += v32;
  }
  while (v28 != v25);
  unsigned int v34 = 0;
  int v35 = v22 - 1;
  uint64_t v36 = (2 * a9);
  uint64_t v45 = (int)v36 - 2;
  int v44 = (2 * a9) | 1;
  uint64_t v37 = v20;
  int v38 = (v22 << 16) / v21;
  do
  {
    if (v35 >= (int)(HIWORD(v34) + 1)) {
      int v39 = HIWORD(v34) + 1;
    }
    else {
      int v39 = v35;
    }
    BilinearFilterV_swift_neon(v14, (uint8x16_t *)(v50 + HIWORD(v34) * (uint64_t)v51), (uint8x16_t *)(v50 + v39 * (uint64_t)v51), v46, (unsigned __int16)v34 >> 12);
    int v40 = a9;
    int v41 = a9;
    if (v48)
    {
      v14->i16[v36] = v14->i16[v45];
      int v40 = v44;
      int v41 = 2 * a9;
    }
    v34 += v38;
    v14->i16[v40] = v14->i16[v41 - 1];
    uint64_t result = v47(v10, v14, v49, v52, v26, 16);
    v10 += v37;
    --v11;
  }
  while (v11);
  return result;
}

uint64_t sub_1BBA1A930(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9, int a10, uint64_t (*a11)(uint64_t, uint16x8_t *, void, _DWORD *, char *, char *, uint64_t))
{
  int v75 = a8;
  uint64_t v74 = a7;
  int v11 = a4;
  uint64_t v12 = a3;
  int v13 = a2;
  int32x2_t v72 = a11;
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  int v71 = a9 << a1;
  uint64_t v14 = MEMORY[0x1F4188790](a1, a2, a3, a4, a5, a6);
  uint64_t v16 = (uint16x8_t *)((char *)&v69 - v15);
  uint64_t v22 = MEMORY[0x1F4188790](v14, v17, v18, v19, v20, v21);
  uint64_t v78 = (char *)&v69 - v23;
  uint64_t v29 = MEMORY[0x1F4188790](v22, v24, v25, v26, v27, v28);
  int v35 = MEMORY[0x1F4188790](v29, v31, (char *)&v69 - v30, v32, v33, v34);
  uint64_t v42 = (char *)&v69 - v41;
  int v76 = v43;
  unsigned int v77 = v37;
  uint64_t v44 = v37;
  int v45 = (v43 << 16) / (int)v37;
  int v73 = v35;
  signed int v70 = v36;
  uint64_t v46 = 0;
  if (v35)
  {
    uint64_t v47 = 0;
    unsigned int v48 = 0;
    unsigned int v49 = 0;
    uint64_t v50 = v36;
    do
    {
      unsigned int v51 = HIWORD(v48);
      char v52 = (unsigned __int16)v48 >> 12;
      uint64_t v53 = &v78[v46];
      v53[1] = v52;
      *uint64_t v53 = v52;
      if ((v47 & 3) == 0)
      {
        *v50++ = 4 * v51;
        unsigned int v49 = HIWORD(v48);
      }
      v48 += v45;
      int v54 = 67372036 * (v51 - v49);
      int v55 = v46 & 0x7FFFFFF8 | v47 & 3;
      *(_DWORD *)&v42[4 * v55] = v54 + v39;
      *(_DWORD *)&v42[4 * (v55 | 4)] = v54 + 117835012;
      ++v47;
      v46 += 2;
    }
    while (v44 != v47);
  }
  else
  {
    unsigned int v56 = 0;
    unsigned int v57 = 0;
    uint64_t v50 = v36;
    int v58 = v78;
    do
    {
      unsigned int v59 = HIWORD(v56);
      v58[v46] = (unsigned __int16)v56 >> 12;
      if ((v46 & 3) == 0)
      {
        *v50++ = 2 * v59;
        unsigned int v57 = HIWORD(v56);
      }
      v56 += v45;
      *(_DWORD *)&v42[4 * v46++] = v39 + 33686018 * (v59 - v57);
    }
    while (v37 != v46);
  }
  unsigned int v60 = v77 + 4;
  if (v40 > (int)(v77 + 4)) {
    unsigned int v60 = v40;
  }
  int v61 = (a10 << 16) / v38;
  bzero(v50, ((v60 + ~v77) & 0xFFFFFFFC) + 4);
  unsigned int v62 = 0;
  uint64_t v63 = (2 * v76);
  uint64_t v69 = (int)v63 - 2;
  int v64 = (2 * v76) | 1;
  do
  {
    if (a10 - 1 >= (HIWORD(v62) + 1)) {
      int v65 = HIWORD(v62) + 1;
    }
    else {
      int v65 = a10 - 1;
    }
    BilinearFilterV_swift_neon(v16, (uint8x16_t *)(v74 + HIWORD(v62) * v75), (uint8x16_t *)(v74 + (v65 * v75)), v71, (unsigned __int16)v62 >> 12);
    int v66 = v76;
    int v67 = v76;
    if (v73)
    {
      v16->i16[v63] = v16->i16[v69];
      int v67 = v64;
      int v66 = v63;
    }
    v62 += v61;
    v16->i16[v67] = v16->i16[v66 - 1];
    uint64_t result = v72(v12, v16, v77, v70, v78, v42, 16);
    v12 += v11;
    --v13;
  }
  while (v13);
  return result;
}

void sub_1BBA1AC6C(char *a1)
{
  if (a1)
  {
    uint64_t v2 = 0;
    char v3 = 1;
    do
    {
      char v4 = v3;
      int v5 = (pthread_t *)&a1[336 * v2];
      if (*v5)
      {
        unint64_t v6 = &a1[336 * v2];
        pthread_mutex_lock((pthread_mutex_t *)(v6 + 104));
        *((_DWORD *)v6 + 42) = 1;
        pthread_cond_signal((pthread_cond_t *)(v6 + 8));
        pthread_mutex_unlock((pthread_mutex_t *)(v6 + 104));
        pthread_join(*v5, 0);
      }
      uint64_t v7 = &a1[336 * v2];
      pthread_mutex_destroy((pthread_mutex_t *)(v7 + 104));
      pthread_cond_destroy((pthread_cond_t *)(v7 + 56));
      pthread_cond_destroy((pthread_cond_t *)(v7 + 8));
      char v3 = 0;
      uint64_t v2 = 1;
    }
    while ((v4 & 1) != 0);
  }

  free(a1);
}

uint64_t sub_1BBA1AD34(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 104);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 104));
  while (1)
  {
    if (!*(_DWORD *)(a1 + 172)) {
      pthread_cond_wait((pthread_cond_t *)(a1 + 8), v2);
    }
    if (*(_DWORD *)(a1 + 168)) {
      break;
    }
    if (((*(_DWORD *)(a1 + 228) << 16) / *(_DWORD *)(a1 + 196)) <= 0x20000)
    {
      sub_1BBA1B274(0, a1 + 176, (void (*)(uint64_t, uint16x8_t *, void, char *, uint64_t, uint64_t, void))BilinearFilterH_vperm2_neon64, v3, v4, v5);
      sub_1BBA1B274(1u, a1 + 256, (void (*)(uint64_t, uint16x8_t *, void, char *, uint64_t, uint64_t, void))BilinearFilterH_chroma_vperm2_neon64, v9, v10, v11);
    }
    else
    {
      sub_1BBA1AE44(0, a1 + 176, (uint64_t (*)(uint64_t, uint16x8_t *, void, uint64_t, unint64_t, void))BilinearFilterH_swift_neon, v3, v4, v5);
      sub_1BBA1AE44(1, a1 + 256, (uint64_t (*)(uint64_t, uint16x8_t *, void, uint64_t, unint64_t, void))BilinearFilterH_swift_chroma_neon, v6, v7, v8);
    }
    *(_DWORD *)(a1 + 172) = 0;
    pthread_cond_signal((pthread_cond_t *)(a1 + 56));
  }
  pthread_mutex_unlock(v2);
  return 0;
}

uint64_t sub_1BBA1AE44(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint16x8_t *, void, uint64_t, unint64_t, void), uint64_t a4, uint64_t a5, uint64_t a6)
{
  signed int v70 = a3;
  int v7 = a1;
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = MEMORY[0x1F4188790](a1, *(unsigned int *)(a2 + 52), a3, a4, ((*(_DWORD *)(a2 + 52) << a1) + 16), a6);
  MEMORY[0x1F4188790](v8, v9, *(int *)(a2 + 20), v10, v11, v12);
  unint64_t v14 = (unint64_t)&v65[-((v13 + 47) & 0xFFFFFFFFFFFFFFF0) + 15] & 0xFFFFFFFFFFFFFFF0;
  uint64_t result = MEMORY[0x1F4188790](*(unsigned int *)(a2 + 76), v16, v13, (4 * v15 + 15) & 0x7FFFFFFF0, v15, v17);
  uint64_t v28 = &v65[-v27];
  int v29 = *(_DWORD *)(a2 + 56);
  int v30 = *(_DWORD *)(a2 + 24);
  if (v20 < 1)
  {
    int v33 = v24;
  }
  else
  {
    uint64_t v31 = 0;
    int v32 = 0;
    do
    {
      *(unsigned char *)(v14 + v31) = (unsigned __int16)v32 >> 12;
      v32 += (v19 << 16) / v20;
      ++v31;
    }
    while (v31 < *(int *)(a2 + 20));
    int v33 = *(_DWORD *)(a2 + 64);
  }
  if (v33 < *(_DWORD *)(a2 + 68))
  {
    int v66 = -v23;
    uint64_t v34 = v25 + (int)(((result + v24) & -v23) * v26 + 16 * ((result + v24) & (v23 - 1)));
    int v67 = (v29 << 16) / v30;
    unsigned int v68 = (v19 << 16) / v20;
    unsigned int v35 = v67 * v24;
    uint64_t v36 = (uint16x8_t *)((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
    unsigned int v71 = 16 * v23;
    int v72 = v23 - 1;
    int v37 = -1;
    int v73 = v28;
    uint64_t v74 = v21;
    unint64_t v69 = v14;
    while (1)
    {
      int v38 = (uint8x16_t *)&v28[v21 * (unint64_t)(HIWORD(v35) & 3)];
      int v39 = HIWORD(v35) + 1;
      if ((int)HIWORD(v35) <= v37) {
        goto LABEL_14;
      }
      int v40 = *(_DWORD *)(a2 + 76);
      uint64_t v41 = v40 + HIWORD(v35);
      uint64_t v42 = *(unsigned int *)(a2 + 48);
      uint64_t v43 = *(void *)(a2 + 32);
      uint64_t v44 = *(void *)(a2 + 40);
      if (v44) {
        break;
      }
      int v45 = (long long *)(v43 + (int)((v41 & v66) * v42 + 16 * (v41 & v72)));
      if (((v40 + v39) & v72) == 0)
      {
        DetileRow_neon(v38, v45, *(_DWORD *)(a2 + 52) << v7, v71);
        goto LABEL_11;
      }
      uint64_t v47 = v73;
      int v46 = v74;
      Detile2Rows_neon(v38, &v73[v74 * (unint64_t)((BYTE2(v35) + 1) & 3)], v45, *(_DWORD *)(a2 + 52) << v7, v71);
      uint64_t v28 = v47;
      LODWORD(v21) = v46;
      int v37 = HIWORD(v35) + 1;
LABEL_14:
      int v48 = *(_DWORD *)(a2 + 56);
      if (v48 <= v39) {
        int v49 = v48 - 1;
      }
      else {
        int v49 = HIWORD(v35) + 1;
      }
      uint64_t v50 = (uint8x16_t *)&v28[v21 * (unint64_t)(v49 & 3)];
      if (v49 <= v37) {
        goto LABEL_28;
      }
      int v51 = *(_DWORD *)(a2 + 76);
      uint64_t v52 = (v49 + v51);
      uint64_t v53 = *(unsigned int *)(a2 + 48);
      uint64_t v54 = *(void *)(a2 + 32);
      uint64_t v55 = *(void *)(a2 + 40);
      if (v55)
      {
        off_1E9F81F90(v50, v54, v52, (*(_DWORD *)(a2 + 52) << v7), v53, v55, v7 != 0);
      }
      else
      {
        int v57 = v49 + 1;
        int v58 = (long long *)(v54 + (int)((v52 & v66) * v53 + 16 * (v52 & v72)));
        if (((v57 + v51) & v72) != 0)
        {
          Detile2Rows_neon(v50, &v73[v74 * (unint64_t)(v57 & 3)], v58, *(_DWORD *)(a2 + 52) << v7, v71);
          int v59 = *(_DWORD *)(a2 + 56);
          if (v59 <= v39) {
            int v60 = v59 - 1;
          }
          else {
            int v60 = HIWORD(v35) + 1;
          }
          int v37 = v60 + 1;
          goto LABEL_28;
        }
        DetileRow_neon(v50, v58, *(_DWORD *)(a2 + 52) << v7, v71);
      }
      int v56 = *(_DWORD *)(a2 + 56);
      if (v56 <= v39) {
        int v37 = v56 - 1;
      }
      else {
        int v37 = HIWORD(v35) + 1;
      }
LABEL_28:
      int v61 = v33 + *(_DWORD *)(a2 + 76);
      if ((v61 & v72) == 0) {
        uint64_t v34 = *(void *)a2 + *(int *)(a2 + 16) * (uint64_t)(v61 & v66);
      }
      BilinearFilterV_swift_neon(v36, v38, v50, *(_DWORD *)(a2 + 52) << v7, (unsigned __int16)v35 >> 12);
      int v62 = *(_DWORD *)(a2 + 52);
      if (v7)
      {
        int v63 = 2 * v62;
        v36->i16[2 * v62] = v36->i16[2 * v62 - 2];
        int v62 = (2 * v62) | 1;
      }
      else
      {
        int v63 = *(_DWORD *)(a2 + 52);
      }
      uint64_t v64 = v68;
      v35 += v67;
      v36->i16[v62] = v36->i16[v63 - 1];
      uint64_t result = v70(v34, v36, *(unsigned int *)(a2 + 20), v64, v69, v71);
      v34 += 16;
      ++v33;
      uint64_t v28 = v73;
      LODWORD(v21) = v74;
      if (v33 >= *(_DWORD *)(a2 + 68)) {
        return result;
      }
    }
    off_1E9F81F90(v38, v43, v41, (*(_DWORD *)(a2 + 52) << v7), v42, v44, v7 != 0);
LABEL_11:
    int v37 = HIWORD(v35);
    uint64_t v28 = v73;
    LODWORD(v21) = v74;
    goto LABEL_14;
  }
  return result;
}

void sub_1BBA1B274(unsigned int a1, uint64_t a2, void (*a3)(uint64_t, uint16x8_t *, void, char *, uint64_t, uint64_t, void), uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v104 = a3;
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = MEMORY[0x1F4188790](((*(_DWORD *)(a2 + 52) << a1) + 16), a2, a3, a4, a5, a6);
  uint64_t v10 = (uint16x8_t *)((char *)&v99 - v9);
  uint64_t v16 = MEMORY[0x1F4188790](v8, v11, v12, v13, v14, v15);
  uint64_t v22 = MEMORY[0x1F4188790](v16, v18, v19, v20, v21, (char *)&v99 - v17);
  uint64_t v105 = (char *)&v99 - v23;
  uint64_t v29 = MEMORY[0x1F4188790](v22, v24, v25, v26, v27, v28);
  int v30 = *((_DWORD *)&qword_1E9F80A88 + a1);
  uint64_t v32 = *v31;
  int v33 = *((_DWORD *)v31 + 16);
  int v34 = v33;
  int v35 = *((_DWORD *)v31 + 19);
  unsigned int v106 = *((_DWORD *)v31 + 4);
  uint64_t v109 = v29;
  MEMORY[0x1F4188790](v29, v31, v36, v37, v38, v39);
  long long v108 = (char *)&v99 - v44;
  int v47 = *(_DWORD *)(v46 + 56);
  int v48 = *(_DWORD *)(v46 + 24);
  int v49 = (v45 << 16) / (int)v42;
  uint64_t v102 = v41;
  uint64_t v103 = v40;
  if (a1)
  {
    if ((int)v42 >= 1)
    {
      uint64_t v50 = 0;
      uint64_t v51 = 0;
      unsigned int v52 = 0;
      unsigned int v53 = 0;
      uint64_t v54 = v105;
      do
      {
        unsigned int v55 = HIWORD(v52);
        char v56 = (unsigned __int16)v52 >> 12;
        int v57 = (unsigned char *)(v40 + v50);
        v57[1] = v56;
        *int v57 = v56;
        if ((v51 & 3) == 0)
        {
          *v54++ = 4 * v55;
          unsigned int v53 = HIWORD(v52);
        }
        v52 += v49;
        int v58 = 67372036 * (v55 - v53);
        unsigned int v59 = v50 & 0x7FFFFFF8 | v51 & 3;
        *(_DWORD *)(v41 + 4 * v59) = v58 + 50462976;
        *(_DWORD *)(v41 + 4 * (v59 | 4)) = v58 + 117835012;
        ++v51;
        v50 += 2;
      }
      while (v42 != v51);
      goto LABEL_16;
    }
  }
  else if ((int)v42 >= 1)
  {
    uint64_t v60 = 0;
    unsigned int v61 = 0;
    unsigned int v62 = 0;
    uint64_t v54 = v105;
    do
    {
      unsigned int v63 = HIWORD(v61);
      *(unsigned char *)(v40 + v60) = (unsigned __int16)v61 >> 12;
      if ((v60 & 3) == 0)
      {
        *v54++ = 2 * v63;
        unsigned int v62 = HIWORD(v61);
      }
      v61 += v49;
      *(_DWORD *)(v41 + 4 * v60++) = 33686018 * (v63 - v62) + 50462976;
    }
    while (v42 != v60);
    goto LABEL_16;
  }
  if ((int)v42 <= -16) {
    goto LABEL_19;
  }
  LODWORD(v42) = 0;
  uint64_t v54 = v105;
LABEL_16:
  int v64 = v42 + 4;
  if (v43 > (int)v42 + 4) {
    int v64 = v43;
  }
  bzero(v54, ((v64 + ~v42) & 0xFFFFFFFC) + 4);
  int v34 = *(_DWORD *)(a2 + 64);
LABEL_19:
  if (v34 < *(_DWORD *)(a2 + 68))
  {
    int v100 = -v30;
    int v107 = v30 - 1;
    int v65 = (v47 << 16) / v48;
    uint64_t v66 = v32 + (int)(((v35 + v33) & -v30) * v106 + 16 * ((v35 + v33) & (v30 - 1)));
    int v101 = v65;
    unsigned int v67 = v65 * v33;
    unsigned int v106 = 16 * v30;
    int v68 = -1;
    while (1)
    {
      signed int v70 = v108;
      unsigned int v69 = v109;
      unsigned int v71 = (uint8x16_t *)&v108[v109 * (unint64_t)(HIWORD(v67) & 3)];
      int v72 = HIWORD(v67) + 1;
      if ((int)HIWORD(v67) <= v68) {
        goto LABEL_27;
      }
      int v73 = *(_DWORD *)(a2 + 76);
      uint64_t v74 = v73 + HIWORD(v67);
      uint64_t v75 = *(unsigned int *)(a2 + 48);
      uint64_t v76 = *(void *)(a2 + 32);
      uint64_t v77 = *(void *)(a2 + 40);
      if (v77) {
        break;
      }
      uint64_t v78 = (long long *)(v76 + (int)((v74 & v100) * v75 + 16 * (v74 & v107)));
      if (((v73 + v72) & v107) == 0)
      {
        DetileRow_neon(v71, v78, *(_DWORD *)(a2 + 52) << a1, v106);
        goto LABEL_24;
      }
      uint64_t v80 = v108;
      unsigned int v79 = v109;
      Detile2Rows_neon(v71, &v108[v109 * (unint64_t)((BYTE2(v67) + 1) & 3)], v78, *(_DWORD *)(a2 + 52) << a1, v106);
      signed int v70 = v80;
      unsigned int v69 = v79;
      int v68 = HIWORD(v67) + 1;
LABEL_27:
      int v81 = *(_DWORD *)(a2 + 56);
      if (v81 <= v72) {
        int v82 = v81 - 1;
      }
      else {
        int v82 = HIWORD(v67) + 1;
      }
      uint64_t v83 = (uint8x16_t *)&v70[v69 * (unint64_t)(v82 & 3)];
      if (v82 <= v68) {
        goto LABEL_41;
      }
      int v84 = *(_DWORD *)(a2 + 76);
      uint64_t v85 = (v82 + v84);
      uint64_t v86 = *(unsigned int *)(a2 + 48);
      uint64_t v87 = *(void *)(a2 + 32);
      uint64_t v88 = *(void *)(a2 + 40);
      if (v88)
      {
        off_1E9F81F90(v83, v87, v85, (*(_DWORD *)(a2 + 52) << a1), v86, v88, a1 != 0);
      }
      else
      {
        int v90 = v82 + 1;
        uint64_t v91 = (long long *)(v87 + (int)((v85 & v100) * v86 + 16 * (v85 & v107)));
        if (((v90 + v84) & v107) != 0)
        {
          Detile2Rows_neon(v83, &v108[v109 * (unint64_t)(v90 & 3)], v91, *(_DWORD *)(a2 + 52) << a1, v106);
          int v92 = *(_DWORD *)(a2 + 56);
          if (v92 <= v72) {
            int v93 = v92 - 1;
          }
          else {
            int v93 = HIWORD(v67) + 1;
          }
          int v68 = v93 + 1;
          goto LABEL_41;
        }
        DetileRow_neon(v83, v91, *(_DWORD *)(a2 + 52) << a1, v106);
      }
      int v89 = *(_DWORD *)(a2 + 56);
      if (v89 <= v72) {
        int v68 = v89 - 1;
      }
      else {
        int v68 = HIWORD(v67) + 1;
      }
LABEL_41:
      int v94 = v34 + *(_DWORD *)(a2 + 76);
      if ((v94 & v107) == 0) {
        uint64_t v66 = *(void *)a2 + *(int *)(a2 + 16) * (uint64_t)(v94 & v100);
      }
      BilinearFilterV_swift_neon(v10, v71, v83, *(_DWORD *)(a2 + 52) << a1, (unsigned __int16)v67 >> 12);
      int v95 = *(_DWORD *)(a2 + 52);
      if (a1)
      {
        int v96 = 2 * v95;
        v10->i16[2 * v95] = v10->i16[2 * v95 - 2];
        int v95 = (2 * v95) | 1;
      }
      else
      {
        int v96 = *(_DWORD *)(a2 + 52);
      }
      uint64_t v98 = v102;
      uint64_t v97 = v103;
      v67 += v101;
      v10->i16[v95] = v10->i16[v96 - 1];
      v104(v66, v10, *(unsigned int *)(a2 + 20), v105, v97, v98, v106);
      v66 += 16;
      if (++v34 >= *(_DWORD *)(a2 + 68)) {
        return;
      }
    }
    off_1E9F81F90(&v108[v109 * (unint64_t)(HIWORD(v67) & 3)], v76, v74, (*(_DWORD *)(a2 + 52) << a1), v75, v77, a1 != 0);
LABEL_24:
    int v68 = HIWORD(v67);
    signed int v70 = v108;
    unsigned int v69 = v109;
    goto LABEL_27;
  }
}

void sub_1BBA1B800(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, int a9, uint64_t a10, uint64_t a11)
{
  v40[1] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = (char *)malloc_type_calloc(1uLL, 0x2A0uLL, 0x10700409586CEC2uLL);
  if (v13)
  {
    uint64_t v14 = 0;
    char v15 = 1;
    while (1)
    {
      char v16 = v15;
      if (pthread_cond_init((pthread_cond_t *)&v13[336 * v14 + 8], 0)
        || pthread_cond_init((pthread_cond_t *)&v13[336 * v14 + 56], 0)
        || pthread_mutex_init((pthread_mutex_t *)&v13[336 * v14 + 104], 0)
        || pthread_create((pthread_t *)&v13[336 * v14], 0, (void *(__cdecl *)(void *))sub_1BBA1AD34, &v13[336 * v14]))
      {
        break;
      }
      char v15 = 0;
      uint64_t v14 = 1;
      if ((v16 & 1) == 0)
      {
        uint64_t v17 = 0;
        v40[0] = 0;
        char v19 = 1;
        do
        {
          char v39 = v19;
          uint64_t v38 = (pthread_mutex_t *)&v13[336 * v17 + 104];
          pthread_mutex_lock(v38);
          uint64_t v20 = 0;
          *(_DWORD *)&v13[336 * v17 + 172] = 1;
          char v21 = 1;
          do
          {
            uint64_t v22 = (uint64_t)&v13[336 * v17 + 80 * v20];
            *(void *)(v22 + 176) = *(void *)(a1 + 8 * v20);
            *(void *)(v22 + 184) = 0;
            *(_DWORD *)(v22 + 192) = *(_DWORD *)(a2 + 4 * v20);
            *(_DWORD *)(v22 + 196) = a3 >> v20;
            int v23 = a4 >> v20;
            *(_DWORD *)(v22 + 200) = a4 >> v20;
            int v24 = v21 & 1;
            if (v21) {
              uint64_t v25 = a6;
            }
            else {
              uint64_t v25 = 0;
            }
            *(void *)(v22 + 208) = *(void *)(a5 + 8 * v20);
            *(void *)(v22 + 216) = v25;
            *(_DWORD *)(v22 + 224) = *(_DWORD *)(a7 + 4 * v20);
            *(_DWORD *)(v22 + 228) = a8 >> v20;
            *(_DWORD *)(v22 + 232) = a9 >> v20;
            *(_DWORD *)(v22 + 236) = v20;
            int v26 = *((_DWORD *)v40 + v20);
            signed int v18 = (a4 + 63) & 0xFFFFFFC0;
            int v27 = v26 + (v18 >> v20 >> 1);
            *((_DWORD *)v40 + v20) = v27;
            if (v27 < v23) {
              int v23 = v26 + (v18 >> v20 >> 1);
            }
            *(_DWORD *)(v22 + 240) = v26;
            *(_DWORD *)(v22 + 244) = v23;
            *(_DWORD *)(v22 + 248) = *(_DWORD *)(a10 + 4 * v20);
            *(_DWORD *)(v22 + 252) = *(_DWORD *)(a11 + 4 * v20);
            uint64_t v20 = 1;
            char v21 = 0;
          }
          while (v24);
          pthread_cond_signal((pthread_cond_t *)&v13[336 * v17 + 8]);
          pthread_mutex_unlock(v38);
          char v19 = 0;
          uint64_t v17 = 1;
        }
        while ((v39 & 1) != 0);
        uint64_t v28 = 0;
        char v29 = 1;
        do
        {
          char v30 = v29;
          uint64_t v31 = &v13[336 * v28];
          pthread_mutex_lock((pthread_mutex_t *)(v31 + 104));
          if (*((_DWORD *)v31 + 43)) {
            pthread_cond_wait((pthread_cond_t *)&v13[336 * v28 + 56], (pthread_mutex_t *)(v31 + 104));
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v31 + 104));
          char v29 = 0;
          uint64_t v28 = 1;
        }
        while ((v30 & 1) != 0);
        break;
      }
    }
  }

  sub_1BBA1AC6C(v13);
}

uint64_t sub_1BBA1BAD0(uint64_t a1, uint64_t a2, CMSampleBufferRef sbuf)
{
  CFArrayRef SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbuf, 0);
  if (!SampleAttachmentsArray) {
    return 4294954394;
  }
  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(SampleAttachmentsArray, 0);
  if (!ValueAtIndex) {
    return 4294954394;
  }
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, @"MBStatistics");
  if (!Value) {
    return 4294954394;
  }
  CFDataRef v8 = Value;
  BytePtr = CFDataGetBytePtr(Value);
  int Length = CFDataGetLength(v8);
  uint64_t result = 4294954394;
  if (BytePtr && Length >= 1)
  {
    uint64_t v12 = 432 * *(int *)(a1 + 108);
    uint64_t v13 = Length == v12 ? 0 : 4294954394;
    if (Length == v12)
    {
      if (*(void *)(a2 + 400) && (uint64_t v14 = *(void *)(a2 + 392), *(void *)(v14 + 8))) {
        char v15 = *(void **)v14;
      }
      else {
        char v15 = 0;
      }
      int v16 = 0;
      do
      {
        (*(void (**)(const UInt8 *, void *))(a1 + 2560))(BytePtr, v15);
        BytePtr += 432;
        ++v16;
      }
      while (v16 < *(_DWORD *)(a1 + 108));
      sub_1BBA7E708(a1, a2, v15);
      return v13;
    }
  }
  return result;
}

uint64_t sub_1BBA1BBD8()
{
  return 0;
}

uint64_t sub_1BBA1BBE0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 154);
}

__CVPixelBufferPool *sub_1BBA1BBE8(uint64_t a1)
{
  uint64_t result = *(__CVPixelBufferPool **)(a1 + 240);
  if (result) {
    return CVPixelBufferPoolGetPixelBufferAttributes(result);
  }
  return result;
}

uint64_t sub_1BBA1BBF8(uint64_t a1)
{
  return *(void *)(a1 + 240);
}

void sub_1BBA1BC00(void *a1)
{
  *a1 = &unk_1F14EDF28;
  sub_1BBA7E50C((uint64_t)a1);

  JUMPOUT(0x1C18605E0);
}

uint64_t sub_1BBA1BC54(uint64_t a1)
{
  *(void *)a1 = &unk_1F14EDF28;
  return sub_1BBA7E50C(a1);
}

double sub_1BBA1BC74(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = 0;
  v37[4] = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *(unsigned int *)(a1 + 240);
  uint64_t v4 = (v3 >> 16) & 0xFFF;
  int v5 = v3 << 19;
  uint64_t v6 = *a2;
  uint64_t v7 = 16 * *a2 * v4 + ((int)(v3 << 19) >> 17);
  uint64_t v8 = 4 * *a2;
  do
  {
    v37[v2++] = v7;
    v7 += v8;
  }
  while (v2 != 4);
  uint64_t v9 = 0;
  int v10 = v5 >> 19;
  int v11 = v5 >> 18;
  uint64_t v12 = v6 * v4 + v10;
  uint64_t v13 = v6 * 4 * v4 + v11;
  *(unsigned char *)(a2[1] + v12) = *(unsigned char *)(a1 + 80) & 0x3F;
  *(unsigned char *)(a2[3] + v12) = (*(_DWORD *)(a1 + 80) & 0x400000) != 0;
  *(_WORD *)(a2[4] + 2 * v12) = *(_WORD *)(a1 + 102);
  uint64_t v14 = v6 * ((4 * v4) | 2u) + v11;
  *(unsigned char *)(a2[16] + v12) = *(unsigned char *)(a1 + 83) & 0x3F;
  *(_WORD *)(a2[18] + 2 * v12) = *(_WORD *)(a1 + 106);
  int8x16_t v15 = *(int8x16_t *)(a1 + 84);
  v16.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v16.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  int8x16_t v17 = vandq_s8(v15, v16);
  int8x16_t v18 = (int8x16_t)vshrq_n_u8((uint8x16_t)v15, 4uLL);
  int8x16_t v19 = vzip1q_s8(v17, v18);
  uint64_t v20 = v37[1];
  *(_DWORD *)(a2[14] + v37[0]) = v19.i32[0];
  *(_DWORD *)(a2[14] + v20) = v19.i32[1];
  uint64_t v21 = v37[3];
  *(_DWORD *)(a2[14] + v37[2]) = v19.i32[2];
  int8x16_t v22 = vzip2q_s8(v17, v18);
  *(_DWORD *)(a2[14] + v21) = v19.i32[3];
  *(_WORD *)(a2[13] + v13) = v22.i16[0];
  *(_WORD *)(a2[13] + v14) = v22.i16[1];
  v17.i64[0] = 0x303030303030303;
  v17.i64[1] = 0x303030303030303;
  int8x16_t v23 = vandq_s8(v22, v17);
  *(unsigned char *)(a2[12] + v12) = v23.i8[4];
  *(unsigned char *)(a2[15] + v12) = v23.i8[5];
  *(unsigned char *)(a2[40] + v13) = *(unsigned char *)(a1 + 96) & 0x1F;
  *(unsigned char *)(a2[40] + (v13 | 1)) = (*(_DWORD *)(a1 + 96) >> 5) & 0x1F;
  *(unsigned char *)(a2[40] + v14) = (*(_DWORD *)(a1 + 96) >> 10) & 0x1F;
  *(unsigned char *)(a2[40] + (v14 | 1)) = (*(_DWORD *)(a1 + 96) >> 15) & 0x1F;
  do
  {
    int16x8_t v24 = *(int16x8_t *)(a1 + 16 * v9 + 108);
    uint64_t v25 = v37[v9];
    *(int16x8_t *)(a2[20] + 4 * v25) = vtrn1q_s16(vshrq_n_s16(vshlq_n_s16(v24, 5uLL), 5uLL), (int16x8_t)vshrq_n_s32(vshlq_n_s32((int32x4_t)v24, 0xAuLL), 0x16uLL));
    *(_DWORD *)(a2[22] + v25) = vqtbl1q_s8(vshrq_n_s8(vshlq_n_s8((int8x16_t)v24, 5uLL), 5uLL), (int8x16_t)xmmword_1BBB6F630).u32[0];
    ++v9;
  }
  while (v9 != 4);
  uint64_t v26 = 4 * v12;
  *(_WORD *)(a2[24] + v26) = (__int16)(32 * *(_WORD *)a1) >> 5;
  *(_WORD *)(a2[24] + 4 * v12 + 2) = (__int16)(*(_DWORD *)a1 >> 6) >> 6;
  *(_WORD *)(a2[28] + 2 * v12) = *(_DWORD *)(a1 + 4);
  *(_WORD *)(a2[25] + v26) = (__int16)(32 * *(_WORD *)(a1 + 32)) >> 5;
  *(_WORD *)(a2[25] + 4 * v12 + 2) = (__int16)(*(_DWORD *)(a1 + 32) >> 6) >> 6;
  *(_WORD *)(a2[29] + 2 * v12) = *(_DWORD *)(a1 + 36);
  int16x8_t v27 = vtrn1q_s16(vshrq_n_s16(vshlq_n_s16(*(int16x8_t *)(a1 + 8), 5uLL), 5uLL), (int16x8_t)vshrq_n_s32(vshlq_n_s32(*(int32x4_t *)(a1 + 8), 0xAuLL), 0x16uLL));
  int16x8_t v28 = *(int16x8_t *)(a1 + 40);
  uint64_t v29 = 4 * v13;
  *(void *)(a2[32] + v29) = v27.i64[0];
  int16x8_t v30 = vtrn1q_s16(vshrq_n_s16(vshlq_n_s16(v28, 5uLL), 5uLL), (int16x8_t)vshrq_n_s32(vshlq_n_s32((int32x4_t)v28, 0xAuLL), 0x16uLL));
  *(void *)(a2[32] + 4 * v14) = v27.i64[1];
  *(void *)(a2[33] + v29) = v30.i64[0];
  *(void *)(a2[33] + 4 * v14) = v30.i64[1];
  v27.i64[0] = *(void *)(a1 + 24);
  v30.i64[0] = *(void *)(a1 + 56);
  uint64_t v31 = 2 * v13;
  *(_DWORD *)(a2[36] + v31) = v27.i32[0];
  *(_DWORD *)(a2[36] + 2 * v14) = v27.i32[1];
  *(_DWORD *)(a2[37] + v31) = v30.i32[0];
  *(_DWORD *)(a2[37] + 2 * v14) = v30.i32[1];
  int32x4_t v32 = vpaddq_s32((int32x4_t)vpaddlq_u16((uint16x8_t)vuzp1q_s16(*(int16x8_t *)(a1 + 248), *(int16x8_t *)(a1 + 264))), vpaddlq_s16(vuzp1q_s16(*(int16x8_t *)(a1 + 280), vuzp2q_s16(*(int16x8_t *)(a1 + 248), *(int16x8_t *)(a1 + 264)))));
  *(_WORD *)(a2[42] + 2 * v12) = v32.i16[0];
  *(_WORD *)(a2[43] + 2 * v12) = v32.i16[2];
  *(_WORD *)(a2[44] + 2 * v12) = v32.i16[4];
  int32x4_t v33 = vpaddq_s32(*(int32x4_t *)(a1 + 296), *(int32x4_t *)(a1 + 296));
  *(void *)&double result = vpaddq_s32(v33, v33).u64[0];
  int32x4_t v35 = vpaddq_s32(*(int32x4_t *)(a1 + 312), *(int32x4_t *)(a1 + 312));
  int32x4_t v36 = vpaddq_s32(*(int32x4_t *)(a1 + 328), *(int32x4_t *)(a1 + 328));
  *(_DWORD *)(a2[45] + 4 * v12) = LODWORD(result);
  *(_DWORD *)(a2[46] + 4 * v12) = vpaddq_s32(v35, v35).u32[0];
  *(_DWORD *)(a2[47] + 4 * v12) = vpaddq_s32(v36, v36).u32[0];
  return result;
}

uint64_t sub_1BBA1C004(uint64_t a1, int *a2)
{
  uint64_t v2 = 0;
  v56[2] = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *(unsigned int *)(a1 + 240);
  uint64_t v4 = (v3 >> 16) & 0xFFF;
  int v5 = v3 << 19;
  int v6 = (int)(v3 << 19) >> 18;
  int v7 = (int)(v3 << 19) >> 17;
  uint64_t v8 = *(void *)a2;
  uint64_t v9 = *(void *)a2 * 4 * v4 + v6;
  uint64_t v10 = *(void *)a2 * ((4 * v4) | 2u) + v6;
  v56[0] = v9;
  v56[1] = v10;
  uint64_t v11 = 16 * v8 * v4 + v7;
  do
  {
    v53[v2++] = v11;
    v11 += 4 * v8;
  }
  while (v2 != 4);
  uint64_t v12 = v8 * v4 + (v5 >> 19);
  *(unsigned char *)(*((void *)a2 + 1) + v12) = *(unsigned char *)(a1 + 80) & 0x3F;
  *(unsigned char *)(*((void *)a2 + 16) + v12) = *(unsigned char *)(a1 + 83) & 0x3F;
  *(unsigned char *)(*((void *)a2 + 3) + v12) = (*(_DWORD *)(a1 + 80) & 0x400000) != 0;
  *(_WORD *)(*((void *)a2 + 4) + 2 * v12) = *(_WORD *)(a1 + 102);
  *(_WORD *)(*((void *)a2 + 18) + 2 * v12) = *(_WORD *)(a1 + 106);
  *(unsigned char *)(*((void *)a2 + 13) + v9) = *(unsigned char *)(a1 + 92) & 0xF;
  uint64_t v13 = v9 | 1;
  *(unsigned char *)(*((void *)a2 + 13) + v13) = *(unsigned char *)(a1 + 92) >> 4;
  *(unsigned char *)(*((void *)a2 + 13) + v10) = *(unsigned char *)(a1 + 93) & 0xF;
  uint64_t v14 = v10 | 1;
  *(unsigned char *)(*((void *)a2 + 13) + v14) = (unsigned __int16)*(_DWORD *)(a1 + 92) >> 12;
  uint64_t v15 = v53[0];
  uint64_t v16 = v53[1];
  *(unsigned char *)(*((void *)a2 + 14) + v53[0]) = *(unsigned char *)(a1 + 84) & 0xF;
  *(unsigned char *)(v15 + *((void *)a2 + 14) + 1) = *(unsigned char *)(a1 + 84) >> 4;
  *(unsigned char *)(v15 + *((void *)a2 + 14) + 2) = *(unsigned char *)(a1 + 85) & 0xF;
  *(unsigned char *)(v15 + *((void *)a2 + 14) + 3) = (unsigned __int16)*(_DWORD *)(a1 + 84) >> 12;
  *(unsigned char *)(*((void *)a2 + 14) + v16) = *(unsigned char *)(a1 + 86) & 0xF;
  *(unsigned char *)(v16 + *((void *)a2 + 14) + 1) = (*(_DWORD *)(a1 + 84) >> 20) & 0xF;
  *(unsigned char *)(v16 + *((void *)a2 + 14) + 2) = *(unsigned char *)(a1 + 87) & 0xF;
  *(unsigned char *)(v16 + *((void *)a2 + 14) + 3) = *(_DWORD *)(a1 + 84) >> 28;
  uint64_t v17 = v54;
  uint64_t v18 = v55;
  *(unsigned char *)(*((void *)a2 + 14) + v54) = *(unsigned char *)(a1 + 88) & 0xF;
  *(unsigned char *)(v17 + *((void *)a2 + 14) + 1) = *(unsigned char *)(a1 + 88) >> 4;
  *(unsigned char *)(v17 + *((void *)a2 + 14) + 2) = *(unsigned char *)(a1 + 89) & 0xF;
  *(unsigned char *)(v17 + *((void *)a2 + 14) + 3) = (unsigned __int16)*(_DWORD *)(a1 + 88) >> 12;
  *(unsigned char *)(*((void *)a2 + 14) + v18) = *(unsigned char *)(a1 + 90) & 0xF;
  *(unsigned char *)(v18 + *((void *)a2 + 14) + 1) = (*(_DWORD *)(a1 + 88) >> 20) & 0xF;
  *(unsigned char *)(v18 + *((void *)a2 + 14) + 2) = *(unsigned char *)(a1 + 91) & 0xF;
  *(unsigned char *)(v18 + *((void *)a2 + 14) + 3) = *(_DWORD *)(a1 + 88) >> 28;
  *(unsigned char *)(*((void *)a2 + 12) + v12) = *(unsigned char *)(a1 + 94) & 3;
  *(unsigned char *)(*((void *)a2 + 15) + v12) = (*(_DWORD *)(a1 + 92) >> 20) & 3;
  *(unsigned char *)(*((void *)a2 + 40) + v9) = *(unsigned char *)(a1 + 96) & 0x1F;
  *(unsigned char *)(*((void *)a2 + 40) + v13) = (*(_DWORD *)(a1 + 96) >> 5) & 0x1F;
  *(unsigned char *)(*((void *)a2 + 40) + v10) = (*(_DWORD *)(a1 + 96) >> 10) & 0x1F;
  *(unsigned char *)(*((void *)a2 + 40) + v14) = (*(_DWORD *)(a1 + 96) >> 15) & 0x1F;
  if (a2[272] >= 1)
  {
    uint64_t v19 = 0;
    uint64_t v20 = a1 + 108;
    do
    {
      uint64_t v21 = 0;
      int v22 = 0;
      int8x16_t v23 = (uint64_t *)&a2[2 * v19];
      int16x8_t v24 = v23 + 20;
      uint64_t v25 = v23 + 22;
      do
      {
        uint64_t v26 = 0;
        uint64_t v27 = v53[v21];
        int v28 = v22;
        uint64_t v29 = v20 + 4 * v22;
        uint64_t v30 = 4 * v27;
        do
        {
          *(_WORD *)(*v24 + v30) = (__int16)(32 * *(_WORD *)(v29 + 4 * v26)) >> 5;
          *(_WORD *)(*v24 + v30 + 2) = (__int16)(*(_DWORD *)(v29 + 4 * v26) >> 6) >> 6;
          *(unsigned char *)(*v25 + v27 + v26) = (32 * *(_DWORD *)(v29 + 4 * v26)) >> 29;
          ++v26;
          v30 += 4;
        }
        while (v26 != 4);
        int v22 = v28 + 4;
        ++v21;
      }
      while (v21 != 4);
      ++v19;
      v20 += 64;
    }
    while (v19 < a2[272]);
  }
  uint64_t v31 = 0;
  int v32 = 0;
  uint64_t v33 = 4 * v12;
  *(_WORD *)(*((void *)a2 + 24) + v33) = (__int16)(32 * *(_WORD *)a1) >> 5;
  *(_WORD *)(*((void *)a2 + 24) + 4 * v12 + 2) = (__int16)(*(_DWORD *)a1 >> 6) >> 6;
  *(_WORD *)(*((void *)a2 + 28) + 2 * v12) = *(_DWORD *)(a1 + 4);
  *(_WORD *)(*((void *)a2 + 25) + v33) = (__int16)(32 * *(_WORD *)(a1 + 32)) >> 5;
  *(_WORD *)(*((void *)a2 + 25) + 4 * v12 + 2) = (__int16)(*(_DWORD *)(a1 + 32) >> 6) >> 6;
  *(_WORD *)(*((void *)a2 + 29) + 2 * v12) = *(_DWORD *)(a1 + 36);
  char v34 = 1;
  do
  {
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    char v37 = v34;
    uint64_t v38 = v56[v31];
    while (1)
    {
      uint64_t v39 = a1 + 4 * v32 + 4 * v35;
      uint64_t v40 = v38 + v36;
      uint64_t v41 = 4 * v40;
      *(_WORD *)(*((void *)a2 + 32) + v41) = (__int16)(32 * *(_WORD *)(v39 + 8)) >> 5;
      *(_WORD *)(*((void *)a2 + 32) + 4 * v40 + 2) = (__int16)(*(_DWORD *)(v39 + 8) >> 6) >> 6;
      *(_WORD *)(*((void *)a2 + 33) + v41) = (__int16)(32 * *(_WORD *)(v39 + 40)) >> 5;
      *(_WORD *)(*((void *)a2 + 33) + 4 * v40 + 2) = (__int16)(*(_DWORD *)(v39 + 40) >> 6) >> 6;
      uint64_t v42 = (uint64_t)(v32 + (int)v35) >> 1;
      int v43 = *(_DWORD *)(a1 + 4 * ((v32 + (int)v35) >> 1) + 24);
      if (v35 == 1) {
        break;
      }
      *(_WORD *)(*((void *)a2 + 36) + 2 * v40) = v43;
      *(_WORD *)(*((void *)a2 + 37) + 2 * v40) = *(_DWORD *)(a1 + 4 * v42 + 56);
      ++v35;
      uint64_t v36 = 1;
    }
    char v34 = 0;
    *(_WORD *)(*((void *)a2 + 36) + 2 * v40) = HIWORD(v43);
    *(_WORD *)(*((void *)a2 + 37) + 2 * v40) = *(_WORD *)(a1 + 4 * v42 + 58);
    v32 += 2;
    uint64_t v31 = 1;
  }
  while ((v37 & 1) != 0);
  uint64_t v44 = 0;
  uint64_t v45 = *((void *)a2 + 42);
  *(_WORD *)(v45 + 2 * v12) = 0;
  uint64_t v46 = *((void *)a2 + 45);
  *(_DWORD *)(v46 + 4 * v12) = 0;
  uint64_t v47 = *((void *)a2 + 43);
  *(_WORD *)(v47 + 2 * v12) = 0;
  uint64_t v48 = *((void *)a2 + 46);
  *(_DWORD *)(v48 + 4 * v12) = 0;
  uint64_t v49 = *((void *)a2 + 44);
  *(_WORD *)(v49 + 2 * v12) = 0;
  uint64_t v50 = *((void *)a2 + 47);
  *(_DWORD *)(v50 + 4 * v12) = 0;
  uint64_t v51 = a1 + 248;
  do
  {
    *(_WORD *)(v45 + 2 * v12) += *(_WORD *)(v51 + v44);
    *(_DWORD *)(v46 + 4 * v12) += *(_DWORD *)(v51 + v44 + 48) & 0x3FFFFFF;
    *(_WORD *)(v47 + 2 * v12) += *(_WORD *)(v51 + v44 + 16);
    *(_DWORD *)(v48 + 4 * v12) += *(_DWORD *)(v51 + v44 + 64) & 0x3FFFFFF;
    *(_WORD *)(v49 + 2 * v12) += *(_WORD *)(v51 + v44 + 32);
    uint64_t result = *(unsigned int *)(v50 + 4 * v12);
    *(_DWORD *)(v50 + 4 * v12) = result + (*(_DWORD *)(v51 + v44 + 80) & 0x3FFFFFF);
    v44 += 4;
  }
  while (v44 != 16);
  return result;
}

uint64_t sub_1BBA1C594(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1BBA7E404(a1, a2);
  *(void *)uint64_t v4 = &unk_1F14EDF28;
  *(_DWORD *)(v4 + 148) = 1;
  if (*(_DWORD *)(a2 + 508) == 2) {
    *(_DWORD *)(a1 + 148) = *(_DWORD *)(a2 + 504);
  }
  v5.i64[0] = *(void *)(a1 + 72);
  int32x4_t v6 = vzip1q_s32(v5, v5);
  v6.i32[2] = v5.i32[0];
  int32x4_t v7 = vshlq_s32(vaddq_s32(v6, (int32x4_t)xmmword_1BBB6F640), (int32x4_t)xmmword_1BBB6F650);
  int32x2_t v8 = vshl_s32(vadd_s32(vdup_lane_s32(*(int32x2_t *)v5.i8, 1), (int32x2_t)0x1F0000000FLL), (int32x2_t)0xFFFFFFFBFFFFFFFCLL);
  *(int32x2_t *)(a1 + 140) = v8;
  v8.i32[0] = v7.i32[2];
  *(int32x2_t *)(a1 + 112) = v8;
  *(int32x4_t *)(a1 + 124) = v7;
  *(_DWORD *)(a1 + 120) = v8.i32[1] * v7.i32[2];
  if (*(unsigned char *)(*(void *)(a1 + 88) + 581))
  {
    *(void *)(a1 + 2560) = sub_1BBA1C004;
    if (qword_1EC027190 != -1) {
      dispatch_once_f(&qword_1EC027190, 0, (dispatch_function_t)sub_1BBA3F73C);
    }
    if (dword_1EC027188 >= 2) {
      *(void *)(a1 + 2560) = sub_1BBA1BC74;
    }
  }
  return a1;
}

uint64_t sub_1BBA1C6C8(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 4; ++i)
  {
    unint64_t v5 = 0;
    if (i) {
      int32x4_t v6 = byte_1BBB83EA4;
    }
    else {
      int32x4_t v6 = (unsigned __int8 *)&unk_1BBB83E94;
    }
    if (i) {
      uint64_t v7 = 64;
    }
    else {
      uint64_t v7 = 16;
    }
    if (i == 3) {
      uint64_t v8 = 3;
    }
    else {
      uint64_t v8 = 1;
    }
    int16x8_t v24 = v6;
    uint64_t v23 = *v6 + 1;
    do
    {
      if (sub_1BBA196DC(a2, 1))
      {
        if (i <= 1)
        {
          unsigned int v10 = 8;
        }
        else
        {
          int v9 = sub_1BBA1979C(a2);
          unsigned int v10 = (-((v9 + 1) & 1) ^ ((v9 + 1) >> 1)) + ((v9 + 1) & 1) + 8;
          *(unsigned char *)(a1 + 390 * i + 65 * v5) = (-((v9 + 1) & 1) ^ ((v9 + 1) >> 1)) + ((v9 + 1) & 1) + 8;
        }
        uint64_t v16 = v24;
        uint64_t v17 = v7;
        do
        {
          uint64_t result = sub_1BBA1979C(a2);
          int v18 = (result + 1) & 1;
          unsigned int v19 = v10 + v18 + (-v18 ^ ((result + 1) >> 1)) + 256;
          unsigned int v20 = (v10 + v18 + (-(char)v18 ^ ((result + 1) >> 1)));
          int v21 = -v19;
          if (v21 >= 0) {
            unsigned int v10 = -v21;
          }
          else {
            unsigned int v10 = v20;
          }
          unsigned int v22 = *v16++;
          *(unsigned char *)(v22 + 65 * v5 + a1 + 390 * i + 1) = v10;
          --v17;
        }
        while (v17);
        if (i < 2) {
          *(unsigned char *)(a1 + 390 * i + 65 * v5) = *(unsigned char *)(a1 + 390 * i + 65 * v5 + v23);
        }
      }
      else
      {
        uint64_t result = sub_1BBA1979C(a2);
        unint64_t v12 = (result * v8);
        if (v5 < v12) {
          return result;
        }
        uint64_t v13 = (char *)&unk_1BBB784D9 + ((v5 > 2) | ((unint64_t)(v5 > 2) << 6));
        if (!i) {
          uint64_t v13 = (char *)&unk_1BBB784C8;
        }
        uint64_t v14 = a1 + 390 * i + 65 * ((int)v5 - (int)v12);
        if (result) {
          uint64_t v15 = (const void *)v14;
        }
        else {
          uint64_t v15 = v13;
        }
        uint64_t result = (uint64_t)memcpy((void *)(a1 + 390 * i + 65 * v5), v15, v7 | 1);
      }
      v5 += v8;
    }
    while (v5 < 6);
  }
  return result;
}

uint64_t sub_1BBA1C8B4(uint64_t result, uint64_t a2, unsigned int a3, int a4)
{
  unint64_t v4 = *(void *)(a2 + 24);
  unint64_t v5 = *(void *)(a2 + 32);
  if (*(_DWORD *)(a2 + 44)) {
    BOOL v6 = v4 >= v5;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    *(void *)(a2 + 24) = ++v4;
  }
  uint64_t v7 = 0;
  *(void *)(a2 + 40) = 0;
  *(_OWORD *)uint64_t result = xmmword_1BBB6F660;
  *(void *)(result + 200) = a2;
  *(void *)(result + 208) = v4;
  *(void *)(result + 16) = -1;
  *(void *)(result + 24) = v4;
  *(void *)(result + 32) = v5;
  if (a4 >= 51) {
    int v8 = 51;
  }
  else {
    int v8 = a4;
  }
  int v9 = v8 & ~(v8 >> 31);
  do
  {
    unsigned int v10 = byte_1BBB782A8[157 * a3 + v7];
    int v11 = 8 * (v10 & 0xF) + ((int)((5 * (v10 >> 4) - 45) * v9) >> 4) - 16;
    if (v11 >= 126) {
      int v11 = 126;
    }
    if (v11 <= 1) {
      int v11 = 1;
    }
    char v12 = 63 - v11;
    BOOL v13 = v11 > 0x3F;
    BOOL v14 = v11 > 0x3F;
    char v15 = v11 + 64;
    if (!v13) {
      char v15 = v12;
    }
    *(unsigned char *)(result + 40 + v7++) = v14 | (2 * v15);
  }
  while (v7 != 157);
  return result;
}

void *sub_1BBA1C980(void *result)
{
  unint64_t v1 = *result >> 8;
  uint64_t v2 = result[2];
  unint64_t v3 = (_DWORD *)result[3];
  uint64_t v4 = v2 + 2;
  if ((v1 >> (v2 + 2)))
  {
    v1 &= ~(-1 << v4);
    unint64_t v5 = (char *)v3 - 1;
    do
    {
      if ((unint64_t)v5 < result[26]) {
        break;
      }
      __int16 v6 = (*v5--)++ + 1;
    }
    while ((v6 & 0x100) != 0);
  }
  BOOL v7 = v2 < 30;
  uint64_t v8 = v2 - 30;
  if (!v7)
  {
    *v3++ = bswap32(v1 >> v8);
    LODWORD(v1) = v1 & ~(-1 << v8);
    uint64_t v4 = v8;
  }
  uint64_t v9 = result[25];
  unsigned int v10 = (char *)v3 + (*(int *)(v9 + 44) >> 3) - result[26];
  unint64_t v11 = *(void *)(v9 + 32);
  char v12 = &v10[*(void *)(v9 + 24)];
  *(void *)(v9 + 24) = v12;
  if ((unint64_t)v12 >= v11)
  {
    *(unsigned char *)(v9 + 48) = 1;
    *(void *)(v9 + 24) = v11;
  }
  *(_DWORD *)(v9 + 40) = 0;
  if (v4) {
    return (void *)sub_1BBA19678(v9, v1, v4);
  }
  return result;
}

unint64_t *sub_1BBA1CA34(unint64_t *result, int a2, unsigned char *a3)
{
  unint64_t v3 = *a3;
  uint64_t v4 = byte_1BBB78C10[(result[1] & 0xC0) + (v3 >> 1)];
  unint64_t v5 = result[2];
  unint64_t v6 = result[1] - v4;
  int v7 = v3 & 1 ^ a2;
  if (v7) {
    uint64_t v8 = result[1] - v4;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = v8 + *result;
  if (v7) {
    unint64_t v6 = byte_1BBB78C10[(result[1] & 0xC0) + (v3 >> 1)];
  }
  *a3 = byte_1BBB78C10[(v7 | (2 * v3)) + 256];
  int v10 = __clz(v6) - 55;
  unint64_t v11 = v6 << v10;
  unint64_t v12 = v9 << v10;
  uint64_t v13 = v5 + v10;
  result[1] = v11;
  uint64_t v14 = v13 - 32;
  if (v13 >= 32)
  {
    char v15 = (_DWORD *)result[3];
    if ((unint64_t)v15 < result[4])
    {
      unint64_t v16 = result[26];
      char v17 = v13 - 22;
      unint64_t v18 = v12 >> v17;
      result[3] = (unint64_t)(v15 + 1);
      *char v15 = bswap32(v12 >> v17);
      v12 &= ~(-1 << v17);
      if ((v18 & 0x100000000) != 0)
      {
        unsigned int v19 = v15 - 1;
        do
        {
          if ((unint64_t)v19 < v16) {
            break;
          }
          unsigned int v20 = *v19;
          *unsigned int v19 = bswap32(bswap32(*v19) + 1);
          --v19;
        }
        while (v20 == -1);
      }
      uint64_t v13 = v14;
    }
  }
  *uint64_t result = v12;
  result[2] = v13;
  return result;
}

unint64_t *sub_1BBA1CB10(unint64_t *result, int a2)
{
  unint64_t v2 = 2 * *result;
  if (a2) {
    v2 += result[1];
  }
  uint64_t v3 = result[2];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3 - 31;
  if (v3 >= 31)
  {
    unint64_t v6 = (_DWORD *)result[3];
    if ((unint64_t)v6 < result[4])
    {
      unint64_t v7 = result[26];
      char v8 = v3 - 21;
      unint64_t v9 = v2 >> v8;
      result[3] = (unint64_t)(v6 + 1);
      _DWORD *v6 = bswap32(v2 >> v8);
      v2 &= ~(-1 << v8);
      if ((v9 & 0x100000000) != 0)
      {
        int v10 = v6 - 1;
        do
        {
          if ((unint64_t)v10 < v7) {
            break;
          }
          unsigned int v11 = *v10;
          unsigned int *v10 = bswap32(bswap32(*v10) + 1);
          --v10;
        }
        while (v11 == -1);
      }
      uint64_t v4 = v5;
    }
  }
  *uint64_t result = v2;
  result[2] = v4;
  return result;
}

unint64_t *sub_1BBA1CBA4(unint64_t *result, int a2)
{
  uint64_t v2 = result[1] - 2;
  int v3 = 1 - ((int)v2 >> 8);
  uint64_t v4 = 2;
  if (!a2)
  {
    uint64_t v4 = result[1] - 2;
    uint64_t v2 = 0;
  }
  uint64_t v5 = v2 + *result;
  if (a2) {
    int v6 = 7;
  }
  else {
    int v6 = v3;
  }
  unint64_t v7 = v5 << v6;
  uint64_t v8 = result[2] + v6;
  result[1] = v4 << v6;
  uint64_t v9 = v8 - 32;
  if (v8 >= 32)
  {
    int v10 = (_DWORD *)result[3];
    if ((unint64_t)v10 < result[4])
    {
      unint64_t v11 = result[26];
      char v12 = v8 - 22;
      unint64_t v13 = v7 >> v12;
      result[3] = (unint64_t)(v10 + 1);
      _DWORD *v10 = bswap32(v7 >> v12);
      v7 &= ~(-1 << v12);
      if ((v13 & 0x100000000) != 0)
      {
        uint64_t v14 = v10 - 1;
        do
        {
          if ((unint64_t)v14 < v11) {
            break;
          }
          unsigned int v15 = *v14;
          *uint64_t v14 = bswap32(bswap32(*v14) + 1);
          --v14;
        }
        while (v15 == -1);
      }
      uint64_t v8 = v9;
    }
  }
  *uint64_t result = v7;
  result[2] = v8;
  return result;
}

unint64_t *sub_1BBA1CC5C(unint64_t *result, int a2, int a3)
{
  if (a3)
  {
    unint64_t v3 = *result;
    uint64_t v4 = result[2] + a3;
    if (a3 >= 1)
    {
      int v5 = a2 << -(char)a3;
      unsigned int v6 = a3 + 1;
      do
      {
        if (v5 >= 0) {
          unint64_t v7 = 0;
        }
        else {
          unint64_t v7 = result[1];
        }
        unint64_t v3 = v7 + 2 * v3;
        v5 *= 2;
        --v6;
      }
      while (v6 > 1);
    }
    uint64_t v8 = v4 - 32;
    if (v4 >= 32)
    {
      uint64_t v9 = (_DWORD *)result[3];
      if ((unint64_t)v9 < result[4])
      {
        unint64_t v10 = result[26];
        char v11 = v4 - 22;
        unint64_t v12 = v3 >> v11;
        result[3] = (unint64_t)(v9 + 1);
        _DWORD *v9 = bswap32(v3 >> v11);
        v3 &= ~(-1 << v11);
        if ((v12 & 0x100000000) != 0)
        {
          unint64_t v13 = v9 - 1;
          do
          {
            if ((unint64_t)v13 < v10) {
              break;
            }
            unsigned int v14 = *v13;
            *unint64_t v13 = bswap32(bswap32(*v13) + 1);
            --v13;
          }
          while (v14 == -1);
        }
        uint64_t v4 = v8;
      }
    }
    *uint64_t result = v3;
    result[2] = v4;
  }
  return result;
}

unint64_t *sub_1BBA1CD18(unint64_t *a1, int a2, int a3)
{
  do
  {
    uint64_t result = sub_1BBA1CB10(a1, 1);
    --a2;
  }
  while (a2);
  if (a3)
  {
    return sub_1BBA1CB10(a1, 0);
  }
  return result;
}

unint64_t *sub_1BBA1CD88(unint64_t *a1, unsigned int a2, int a3)
{
  int v4 = 1 << a3;
  for (i = a3; a2 >= 1 << i; int v4 = 1 << i)
  {
    ++i;
    a2 -= v4;
  }
  int v6 = 2 * i - a3;
  int v7 = -2 << i;
  unsigned int v8 = a2 | v7;
  if (v6 + 1 >= 23)
  {
    do
    {
      uint64_t result = sub_1BBA1CB10(a1, (v8 >> v6) & 1);
      unsigned int v11 = v6-- + 1;
    }
    while (v11 > 1);
  }
  else
  {
    int v9 = a2 | v7;
    return sub_1BBA1CC5C(a1, v9, v6 + 1);
  }
  return result;
}

void sub_1BBA1CE40(void *a1)
{
  for (uint64_t i = 0; i != 32; i += 2)
  {
    unint64_t v3 = &a1[i];
    int v4 = (std::__shared_weak_count *)a1[i + 4];
    v3[3] = 0;
    v3[4] = 0;
    if (v4) {
      sub_1BB9C09B4(v4);
    }
    int v5 = (std::__shared_weak_count *)v3[36];
    v3[35] = 0;
    v3[36] = 0;
    if (v5) {
      sub_1BB9C09B4(v5);
    }
    int v6 = &a1[i];
    int v7 = (std::__shared_weak_count *)a1[i + 68];
    *(_OWORD *)&a1[i + 67] = 0u;
    if (v7) {
      sub_1BB9C09B4(v7);
    }
    unsigned int v8 = (std::__shared_weak_count *)v6[100];
    *(_OWORD *)(v6 + 99) = 0u;
    if (v8) {
      sub_1BB9C09B4(v8);
    }
    int v9 = (std::__shared_weak_count *)a1[i + 132];
    *(_OWORD *)&a1[i + 131] = 0u;
    if (v9) {
      sub_1BB9C09B4(v9);
    }
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t sub_1BBA1CEF4(_DWORD *a1, uint64_t a2, unsigned char *a3, uint64_t a4, unsigned int a5, char a6)
{
  int v6 = a3;
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  unsigned int v62 = a1;
  if (a4)
  {
    uint64_t v61 = (*(_DWORD *)(a4 + 4) + *(_DWORD *)a4);
    if ((int)v61 >= 1)
    {
      uint64_t v9 = 0;
      int v10 = 0;
      unsigned int v60 = 0;
      uint64_t v58 = (-1 << a6) & a5;
      int v11 = ~(-1 << a6);
      while (1)
      {
        uint64_t v12 = *(unsigned __int16 *)(a4 + 2 * v9 + 24);
        int v13 = 1 << v9;
        if (((1 << v9) & *(unsigned __int16 *)(a4 + 218)) != 0) {
          break;
        }
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9F81D58, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1E9F81D58))
        {
          __cxa_atexit((void (*)(void *))sub_1BBA1D9D4, &qword_1E9F81D48, &dword_1BB9B9000);
          __cxa_guard_release(&qword_1E9F81D58);
        }
        uint64_t v23 = 16;
        while (1)
        {
          uint64_t v17 = *(void *)(a2 + v23);
          if (v17)
          {
            if ((*(_DWORD *)(v17 + 680) & v11) == v12) {
              break;
            }
          }
          v23 += 16;
          if (v23 == 288)
          {
            int16x8_t v24 = &qword_1E9F81D48;
            uint64_t v17 = qword_1E9F81D48;
            goto LABEL_35;
          }
        }
        int16x8_t v24 = (uint64_t *)(a2 + v23);
LABEL_35:
        unint64_t v18 = (std::__shared_weak_count *)v24[1];
        if (v18) {
          goto LABEL_6;
        }
LABEL_7:
        int v19 = *(unsigned __int16 *)(a4 + 216);
        if (v17) {
          goto LABEL_8;
        }
        if ((v13 & v19) != 0)
        {
          sub_1BBA1D70C(buf, a2, v12);
          uint64_t v17 = *(void *)buf;
          uint64_t v25 = v66;
          if (v18) {
            sub_1BB9C09B4(v18);
          }
          int v19 = *(unsigned __int16 *)(a4 + 216);
          if (!v17)
          {
            if ((v13 & v19) != 0)
            {
              sub_1BBAE66E0((unsigned int *)a4);
              if (dword_1E9F80A90 >= 1)
              {
                fprintf((FILE *)*MEMORY[0x1E4F143C8], "Unavailable long-term reference - POC %d!\n", v12);
                uint64_t v27 = MEMORY[0x1E4F14500];
                if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)CMSampleTimingInfo buf = 67109120;
                  *(_DWORD *)&uint8_t buf[4] = v12;
                  _os_log_impl(&dword_1BB9B9000, v27, OS_LOG_TYPE_DEFAULT, "Unavailable long-term reference - POC %d!\n", buf, 8u);
                }
              }
              char v22 = 0;
              unsigned int v60 = -12909;
            }
            else
            {
              char v22 = 1;
            }
            unint64_t v18 = v25;
            int v6 = a3;
            if (!v18) {
              goto LABEL_16;
            }
LABEL_15:
            sub_1BB9C09B4(v18);
            goto LABEL_16;
          }
          unint64_t v18 = v25;
          int v6 = a3;
LABEL_8:
          if ((v13 & v19) != 0)
          {
            if (v18) {
              atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            *(void *)&v62[4 * v10 + 134] = v17;
            unsigned int v20 = &v62[4 * v10];
            int v21 = (std::__shared_weak_count *)*((void *)v20 + 68);
            *((void *)v20 + 68) = v18;
            ++v10;
            if (v21) {
              goto LABEL_12;
            }
          }
          else
          {
            if (v18) {
              atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            *(void *)&v62[4 * SHIDWORD(v58) + 262] = v17;
            uint64_t v26 = &v62[4 * SHIDWORD(v58)];
            int v21 = (std::__shared_weak_count *)*((void *)v26 + 132);
            *((void *)v26 + 132) = v18;
            ++HIDWORD(v58);
            if (v21) {
LABEL_12:
            }
              sub_1BB9C09B4(v21);
          }
          *(_DWORD *)(v17 + 36) |= 2u;
        }
        char v22 = 1;
        if (v18) {
          goto LABEL_15;
        }
LABEL_16:
        if ((v22 & 1) == 0) {
          return v60;
        }
        if (++v9 == v61) {
          goto LABEL_50;
        }
      }
      int v14 = *(_DWORD *)(a4 + 4 * v9 + 152) << a6;
      int v15 = v58 + v12;
      uint64_t v12 = (v58 + v12 - v14);
      unint64_t v16 = (uint64_t *)sub_1BBA1D644(a2, v15 - v14);
      uint64_t v17 = *v16;
      unint64_t v18 = (std::__shared_weak_count *)v16[1];
      if (!v18) {
        goto LABEL_7;
      }
LABEL_6:
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      goto LABEL_7;
    }
    unsigned int v60 = 0;
    int v10 = 0;
    HIDWORD(v58) = 0;
LABEL_50:
    a1 = v62;
    v62[3] = v10;
    v62[5] = HIDWORD(v58);
    if (v6) {
      goto LABEL_51;
    }
LABEL_48:
    int v28 = 0;
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
    goto LABEL_119;
  }
  int v10 = 0;
  unsigned int v60 = 0;
  a1[5] = 0;
  a1[3] = 0;
  if (!a3) {
    goto LABEL_48;
  }
LABEL_51:
  if (v6[160])
  {
    unint64_t v29 = 0;
    int v30 = 0;
    uint64_t v31 = 0;
    int v32 = v6 + 2;
    while (1)
    {
      uint64_t v33 = (uint64_t *)sub_1BBA1D644(a2, *((__int16 *)v32 - 1) + a5);
      uint64_t v34 = *v33;
      uint64_t v35 = (std::__shared_weak_count *)v33[1];
      if (v35) {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v34)
      {
        BOOL v39 = *v32 == 0;
        int v40 = v60;
        if (*v32) {
          int v40 = -17694;
        }
        unsigned int v60 = v40;
        if (!v35) {
          goto LABEL_75;
        }
LABEL_74:
        sub_1BB9C09B4(v35);
        goto LABEL_75;
      }
      if (*(_DWORD *)(v34 + 36) != 1)
      {
        BOOL v39 = 1;
        if (!v35) {
          goto LABEL_75;
        }
        goto LABEL_74;
      }
      if (!*v32) {
        break;
      }
      if (v35) {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v36 = (v31 + 1);
      *(void *)&v62[4 * (int)v31 + 6] = v34;
      char v37 = &v62[4 * (int)v31];
      uint64_t v38 = (std::__shared_weak_count *)*((void *)v37 + 4);
      *((void *)v37 + 4) = v35;
      if (v38) {
        goto LABEL_72;
      }
LABEL_73:
      BOOL v39 = 1;
      uint64_t v31 = v36;
      if (v35) {
        goto LABEL_74;
      }
LABEL_75:
      if (!v39) {
        return v60;
      }
      ++v29;
      int v6 = a3;
      v32 += 4;
      if (v29 >= a3[160]) {
        goto LABEL_81;
      }
    }
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)&v62[4 * v30 + 198] = v34;
    uint64_t v41 = &v62[4 * v30];
    uint64_t v38 = (std::__shared_weak_count *)*((void *)v41 + 100);
    *((void *)v41 + 100) = v35;
    if (!v38)
    {
      BOOL v39 = 1;
      ++v30;
      if (!v35) {
        goto LABEL_75;
      }
      goto LABEL_74;
    }
    uint64_t v36 = v31;
    ++v30;
LABEL_72:
    sub_1BB9C09B4(v38);
    goto LABEL_73;
  }
  LODWORD(v31) = 0;
  int v30 = 0;
LABEL_81:
  a1 = v62;
  v62[1] = v31;
  if (v6[161])
  {
    unint64_t v42 = 0;
    int v43 = 0;
    uint64_t v44 = v6 + 66;
    while (1)
    {
      int v45 = *((__int16 *)v44 - 1);
      uint64_t v46 = v45 + a5;
      uint64_t v47 = (uint64_t *)sub_1BBA1D644(a2, v45 + a5);
      uint64_t v48 = *v47;
      uint64_t v49 = (std::__shared_weak_count *)v47[1];
      if (v49) {
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v48)
      {
        if (!*v44) {
          goto LABEL_98;
        }
        sub_1BBA1D70C(buf, a2, v46);
        uint64_t v48 = *(void *)buf;
        unsigned int v53 = v66;
        if (v49) {
          sub_1BB9C09B4(v49);
        }
        if (!v48)
        {
          if (*v44)
          {
            sub_1BBAE6060((__int16 *)a3);
            if (dword_1E9F80A90 >= 1)
            {
              fprintf((FILE *)*MEMORY[0x1E4F143C8], "Unavailable short-term reference - POC %d!\n", v46);
              char v56 = MEMORY[0x1E4F14500];
              if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)CMSampleTimingInfo buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v46;
                _os_log_impl(&dword_1BB9B9000, v56, OS_LOG_TYPE_DEFAULT, "Unavailable short-term reference - POC %d!\n", buf, 8u);
              }
            }
            char v52 = 0;
            unsigned int v60 = -12909;
          }
          else
          {
            char v52 = 1;
          }
          uint64_t v49 = v53;
LABEL_115:
          int v6 = a3;
          if (!v49) {
            goto LABEL_100;
          }
LABEL_99:
          sub_1BB9C09B4(v49);
          goto LABEL_100;
        }
        uint64_t v49 = v53;
        int v6 = a3;
      }
      if (*(_DWORD *)(v48 + 36) == 1)
      {
        if (*v44)
        {
          if (v49) {
            atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          *(void *)&v62[4 * v43 + 70] = v48;
          uint64_t v50 = &v62[4 * v43];
          uint64_t v51 = (std::__shared_weak_count *)*((void *)v50 + 36);
          *((void *)v50 + 36) = v49;
          if (v51) {
            sub_1BB9C09B4(v51);
          }
          char v52 = 1;
          ++v43;
        }
        else
        {
          if (v49) {
            atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          *(void *)&v62[4 * v30 + 198] = v48;
          uint64_t v54 = &v62[4 * v30];
          uint64_t v55 = (std::__shared_weak_count *)*((void *)v54 + 100);
          *((void *)v54 + 100) = v49;
          if (v55) {
            sub_1BB9C09B4(v55);
          }
          char v52 = 1;
          ++v30;
        }
        goto LABEL_115;
      }
LABEL_98:
      char v52 = 1;
      if (v49) {
        goto LABEL_99;
      }
LABEL_100:
      if ((v52 & 1) == 0) {
        return v60;
      }
      ++v42;
      v44 += 4;
      if (v42 >= v6[161])
      {
        a1 = v62;
        LODWORD(v31) = v62[1];
        goto LABEL_118;
      }
    }
  }
  int v43 = 0;
LABEL_118:
  a1[2] = v43;
  a1[4] = v30;
  int v28 = v43 + v31;
  int v10 = a1[3];
LABEL_119:
  *a1 = v28 + v10;
  return v60;
}

void sub_1BBA1D628(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1BB9C09B4(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1BBA1D644(uint64_t a1, int a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9F81D40, memory_order_acquire) & 1) == 0)
  {
    uint64_t v9 = a1;
    int v8 = a2;
    int v6 = __cxa_guard_acquire(&qword_1E9F81D40);
    a2 = v8;
    int v7 = v6;
    a1 = v9;
    if (v7)
    {
      __cxa_atexit((void (*)(void *))sub_1BBA1D9D4, &unk_1E9F81D30, &dword_1BB9B9000);
      __cxa_guard_release(&qword_1E9F81D40);
      a2 = v8;
      a1 = v9;
    }
  }
  uint64_t v2 = 16;
  unint64_t v3 = &unk_1E9F81D30;
  while (1)
  {
    uint64_t v4 = *(void *)(a1 + v2);
    if (v4)
    {
      if (*(_DWORD *)(v4 + 680) == a2) {
        break;
      }
    }
    v2 += 16;
    if (v2 == 288) {
      return v3;
    }
  }
  return (void *)(a1 + v2);
}

double sub_1BBA1D70C(void *a1, uint64_t a2, uint64_t a3)
{
  long long v26 = 0uLL;
  if (*(void *)a2)
  {
    if ((*(unsigned int (**)(void, uint64_t, long long *))a2)(*(void *)(a2 + 8), a3, &v26))
    {
      *a1 = 0;
      a1[1] = 0;
      if (*((void *)&v26 + 1)) {
        sub_1BB9C09B4(*((std::__shared_weak_count **)&v26 + 1));
      }
    }
    else
    {
      uint64_t v5 = v26;
      int v6 = *(unsigned __int8 *)(v26 + 284);
      if (v6 == 8)
      {
        int v7 = (void *)(*(uint64_t (**)(void, void))(*(void *)v26 + 32))(v26, 0);
        memset(v7, 128, *(void *)(v5 + 112) * *(int *)(v5 + 280));
      }
      else
      {
        uint64_t v8 = (*(uint64_t (**)(void, void))(*(void *)v26 + 32))(v26, 0);
        int v9 = *(_DWORD *)(v5 + 280);
        if (v9 >= 1)
        {
          int v10 = 0;
          int v11 = 1 << (v6 - 1);
          uint64_t v12 = *(void *)(v5 + 112);
          uint64_t v13 = 2 * v12;
          uint64_t v14 = *(unsigned int *)(v5 + 276);
          uint64_t v15 = 4 * v12;
          do
          {
            if ((int)v14 >= 1)
            {
              uint64_t v16 = 0;
              do
              {
                *(_WORD *)(v8 + v13 + v16) = v11;
                *(_WORD *)(v8 + v16) = v11;
                v16 += 2;
              }
              while (2 * v14 != v16);
            }
            v10 += 2;
            v8 += v15;
          }
          while (v10 < v9);
        }
      }
      if (*(unsigned __int8 *)(v5 + 285) >= 2u)
      {
        int v17 = *(unsigned __int8 *)(v5 + 284);
        if (v17 == 8)
        {
          unint64_t v18 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 1);
          memset(v18, 128, *(void *)(v5 + 120) * *(int *)(v5 + 280) / 2);
        }
        else
        {
          uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 1);
          int v20 = *(_DWORD *)(v5 + 280);
          if (v20 >= 1)
          {
            int v21 = 0;
            uint64_t v22 = *(unsigned int *)(v5 + 276);
            uint64_t v23 = 2 * *(void *)(v5 + 120);
            do
            {
              if ((int)v22 >= 1)
              {
                uint64_t v24 = 0;
                do
                {
                  *(_WORD *)(v19 + v24) = 1 << (v17 - 1);
                  v24 += 2;
                }
                while (2 * v22 != v24);
              }
              v21 += 2;
              v19 += v23;
            }
            while (v21 < v20);
          }
        }
      }
      uint64_t v25 = v26;
      *(_DWORD *)(v26 + 36) |= 1u;
      uint64_t v27 = (std::mutex *)(v25 + 1104);
      char v28 = 1;
      std::mutex::lock((std::mutex *)(v25 + 1104));
      atomic_store(0x7FFFFFFFu, (unsigned int *)(v25 + 1100));
      sub_1BB9D9FD4((uint64_t)&v27);
      std::condition_variable::notify_all((std::condition_variable *)(v25 + 1168));
      if (v28) {
        std::mutex::unlock(v27);
      }
      double result = *(double *)&v26;
      *(_OWORD *)a1 = v26;
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
  return result;
}

void sub_1BBA1D9A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, std::mutex *a11, char a12)
{
  if (a12) {
    std::mutex::unlock(a11);
  }
  if (a10) {
    sub_1BB9C09B4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA1D9D4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_1BB9C09B4(v2);
  }
  return a1;
}

uint64_t sub_1BBA1DA04(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  uint64_t v4 = 288;
  uint64_t v5 = 16;
  *(_OWORD *)(a1 + 16) = 0u;
  do
  {
    uint64_t v7 = *(void *)(a2 + v5);
    uint64_t v6 = *(void *)(a2 + v5 + 8);
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = (void *)(a1 + v5);
    int v9 = *(std::__shared_weak_count **)(a1 + v5 + 8);
    void *v8 = v7;
    v8[1] = v6;
    if (v9) {
      sub_1BB9C09B4(v9);
    }
    *(_DWORD *)(a1 + v4) = *(_DWORD *)(a2 + v4);
    v4 += 4;
    v5 += 16;
  }
  while (v4 != 356);
  *(_DWORD *)(a1 + 356) = *(_DWORD *)(a2 + 356);
  *(void *)(a1 + 360) = *(void *)(a2 + 360);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  return a1;
}

unsigned __int16 *sub_1BBA1DAC8(unsigned __int16 *result, unsigned __int16 *a2, unint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    uint64_t v6 = (char *)result;
    if (a3 == 2)
    {
      unsigned int v7 = *(a2 - 1);
      unsigned int v8 = *result;
      if (v7 < v8)
      {
        *double result = v7;
        *(a2 - 1) = v8;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      uint64_t v19 = (char *)a4;
      unint64_t v20 = a3 >> 1;
      int v21 = &result[a3 >> 1];
      unint64_t v22 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1BBA1DCE0(result, v21, v22, a4);
        uint64_t v23 = (unsigned __int16 *)&v19[2 * v20];
        double result = sub_1BBA1DCE0((unsigned __int16 *)&v6[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), v23);
        uint64_t v24 = (unsigned __int16 *)&v19[2 * a3];
        uint64_t v25 = v23;
        while (v25 != v24)
        {
          unsigned int v26 = *v25;
          unsigned int v27 = *(unsigned __int16 *)v19;
          BOOL v28 = v26 < v27;
          BOOL v29 = v26 >= v27;
          if (v26 >= v27) {
            LOWORD(v26) = *(_WORD *)v19;
          }
          v19 += 2 * v29;
          v25 += v28;
          *(_WORD *)uint64_t v6 = v26;
          v6 += 2;
          if (v19 == (char *)v23)
          {
            if (v25 != v24)
            {
              uint64_t v30 = 0;
              do
              {
                *(_WORD *)&v6[v30 * 2] = v25[v30];
                ++v30;
              }
              while (&v25[v30] != v24);
            }
            return result;
          }
        }
        if (v19 != (char *)v23)
        {
          uint64_t v31 = 0;
          do
          {
            *(_WORD *)&v6[v31] = *(_WORD *)&v19[v31];
            v31 += 2;
          }
          while (&v19[v31] != (char *)v23);
        }
      }
      else
      {
        sub_1BBA1DAC8(result, v21, v22, a4, a5);
        sub_1BBA1DAC8(&v6[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), v19, a5);
        return (unsigned __int16 *)sub_1BBA1DEB0(v6, &v6[2 * (a3 >> 1)], (char *)a2, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }
    else if (result != a2)
    {
      int v10 = result + 1;
      if (result + 1 != a2)
      {
        uint64_t v11 = 2;
        uint64_t v12 = result;
        do
        {
          unsigned int v13 = v12[1];
          unsigned int v14 = *v12;
          uint64_t v12 = v10;
          if (v13 < v14)
          {
            uint64_t v15 = v11;
            while (1)
            {
              *(unsigned __int16 *)((char *)result + v15) = v14;
              uint64_t v16 = v15 - 2;
              if (v15 == 2) {
                break;
              }
              unsigned int v14 = *(unsigned __int16 *)((char *)result + v15 - 4);
              v15 -= 2;
              if (v13 >= v14)
              {
                int v17 = (unsigned __int16 *)((char *)result + v16);
                goto LABEL_15;
              }
            }
            int v17 = result;
LABEL_15:
            unsigned __int16 *v17 = v13;
          }
          int v10 = v12 + 1;
          v11 += 2;
        }
        while (v12 + 1 != a2);
      }
    }
  }
  return result;
}

unsigned __int16 *sub_1BBA1DCE0(unsigned __int16 *result, unsigned __int16 *a2, unint64_t a3, unsigned __int16 *a4)
{
  if (a3)
  {
    uint64_t v4 = a4;
    uint64_t v6 = result;
    if (a3 == 1)
    {
LABEL_9:
      *uint64_t v4 = *v6;
      return result;
    }
    if (a3 == 2)
    {
      unsigned int v9 = *(a2 - 1);
      unsigned __int16 v8 = *(a2 - 1);
      unsigned int v10 = *result;
      BOOL v11 = v9 >= v10;
      if (v9 >= v10) {
        unsigned __int16 v8 = *result;
      }
      *a4 = v8;
      uint64_t v4 = a4 + 1;
      if (v11) {
        uint64_t v6 = a2 - 1;
      }
      goto LABEL_9;
    }
    if ((uint64_t)a3 > 8)
    {
      unint64_t v22 = &result[a3 >> 1];
      sub_1BBA1DAC8(result, v22, a3 >> 1, a4, a3 >> 1);
      double result = (unsigned __int16 *)sub_1BBA1DAC8(&v6[a3 >> 1], a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      uint64_t v23 = &v6[a3 >> 1];
      while (v23 != a2)
      {
        unsigned int v24 = *v23;
        unsigned int v25 = *v6;
        BOOL v26 = v24 >= v25;
        BOOL v27 = v24 < v25;
        if (v24 >= v25) {
          LOWORD(v24) = *v6;
        }
        v23 += v27;
        v6 += v26;
        *v4++ = v24;
        if (v6 == v22)
        {
          if (v23 != a2)
          {
            uint64_t v28 = 0;
            do
            {
              v4[v28] = v23[v28];
              ++v28;
            }
            while (&v23[v28] != a2);
          }
          return result;
        }
      }
      if (v6 != v22)
      {
        uint64_t v29 = 0;
        do
        {
          v4[v29] = v6[v29];
          ++v29;
        }
        while (&v6[v29] != v22);
      }
    }
    else if (result != a2)
    {
      uint64_t v12 = result + 1;
      *a4 = *result;
      if (result + 1 != a2)
      {
        uint64_t v13 = 0;
        unsigned int v14 = a4;
        uint64_t v15 = a4;
        do
        {
          unsigned int v17 = *v15++;
          unsigned __int16 v16 = v17;
          unsigned int v18 = *v12;
          if (v18 >= v17)
          {
            *uint64_t v15 = v18;
          }
          else
          {
            v14[1] = v16;
            uint64_t v19 = a4;
            if (v14 != a4)
            {
              uint64_t v20 = v13;
              while (1)
              {
                uint64_t v19 = (unsigned __int16 *)((char *)a4 + v20);
                unsigned int v21 = *(unsigned __int16 *)((char *)a4 + v20 - 2);
                if (*v12 >= v21) {
                  break;
                }
                *uint64_t v19 = v21;
                v20 -= 2;
                if (!v20)
                {
                  uint64_t v19 = a4;
                  break;
                }
              }
            }
            *uint64_t v19 = *v12;
          }
          ++v12;
          v13 += 2;
          unsigned int v14 = v15;
        }
        while (v12 != a2);
      }
    }
  }
  return result;
}

char *sub_1BBA1DEB0(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v8 = a5;
    BOOL v11 = result;
    while (v8 > a7 && a4 > a7)
    {
      if (!a4) {
        return result;
      }
      unsigned int v12 = *(unsigned __int16 *)a2;
      while (1)
      {
        unsigned int v13 = *(unsigned __int16 *)v11;
        if (v12 < v13) {
          break;
        }
        v11 += 2;
        if (!--a4) {
          return result;
        }
      }
      if (a4 >= v8)
      {
        if (a4 == 1)
        {
          *(_WORD *)BOOL v11 = v12;
          *(_WORD *)a2 = v13;
          return result;
        }
        if (a4 >= 0) {
          uint64_t v24 = a4;
        }
        else {
          uint64_t v24 = a4 + 1;
        }
        unsigned __int16 v16 = (unsigned __int16 *)&v11[v24 & 0xFFFFFFFFFFFFFFFELL];
        uint64_t v15 = a3;
        if (a3 != a2)
        {
          unint64_t v25 = (a3 - a2) >> 1;
          uint64_t v15 = a2;
          do
          {
            unint64_t v26 = v25 >> 1;
            BOOL v27 = (unsigned __int16 *)&v15[2 * (v25 >> 1)];
            unsigned int v29 = *v27;
            uint64_t v28 = v27 + 1;
            v25 += ~(v25 >> 1);
            if (v29 < *v16) {
              uint64_t v15 = (char *)v28;
            }
            else {
              unint64_t v25 = v26;
            }
          }
          while (v25);
        }
        uint64_t v23 = v24 >> 1;
        uint64_t v22 = (v15 - a2) >> 1;
      }
      else
      {
        if (v8 >= 0) {
          uint64_t v14 = v8;
        }
        else {
          uint64_t v14 = v8 + 1;
        }
        uint64_t v15 = &a2[v14 & 0xFFFFFFFFFFFFFFFELL];
        unsigned __int16 v16 = (unsigned __int16 *)a2;
        if (a2 != v11)
        {
          unint64_t v17 = (a2 - v11) >> 1;
          unsigned __int16 v16 = (unsigned __int16 *)v11;
          do
          {
            unint64_t v18 = v17 >> 1;
            uint64_t v19 = &v16[v17 >> 1];
            unsigned int v21 = *v19;
            uint64_t v20 = v19 + 1;
            v17 += ~(v17 >> 1);
            if (*(unsigned __int16 *)v15 < v21) {
              unint64_t v17 = v18;
            }
            else {
              unsigned __int16 v16 = v20;
            }
          }
          while (v17);
        }
        uint64_t v22 = v14 >> 1;
        uint64_t v23 = ((char *)v16 - v11) >> 1;
      }
      uint64_t v30 = (unsigned __int16 *)v15;
      if (v16 != (unsigned __int16 *)a2)
      {
        uint64_t v30 = v16;
        if (a2 != v15)
        {
          if (v16 + 1 == (unsigned __int16 *)a2)
          {
            unsigned __int16 v71 = *v16;
            int64_t v37 = v15 - a2;
            uint64_t v73 = v22;
            uint64_t v75 = a6;
            uint64_t v38 = a3;
            memmove(v16, a2, v15 - a2);
            uint64_t v22 = v73;
            a6 = v75;
            a3 = v38;
            uint64_t v30 = (unsigned __int16 *)((char *)v16 + v37);
            *uint64_t v30 = v71;
          }
          else if (a2 + 2 == v15)
          {
            unsigned __int16 v39 = *((_WORD *)v15 - 1);
            uint64_t v30 = v16 + 1;
            if (v15 - 2 != (char *)v16)
            {
              uint64_t v74 = v22;
              uint64_t v76 = a6;
              int v40 = a3;
              unsigned __int16 v72 = *((_WORD *)v15 - 1);
              memmove(v16 + 1, v16, v15 - 2 - (char *)v16);
              unsigned __int16 v39 = v72;
              uint64_t v22 = v74;
              a6 = v76;
              a3 = v40;
            }
            unsigned __int16 *v16 = v39;
          }
          else
          {
            uint64_t v31 = (a2 - (char *)v16) >> 1;
            if (v31 == (v15 - a2) >> 1)
            {
              uint64_t v32 = 0;
              do
              {
                unsigned __int16 v33 = v16[v32];
                v16[v32] = *(_WORD *)&a2[v32 * 2];
                uint64_t v34 = (uint64_t)&v16[v32 + 1];
                *(_WORD *)&a2[v32 * 2] = v33;
                uint64_t v35 = (uint64_t)&a2[v32 * 2 + 2];
                ++v32;
              }
              while ((char *)v34 != a2 && v35 != (void)v15);
              uint64_t v30 = (unsigned __int16 *)a2;
            }
            else
            {
              uint64_t v41 = (v15 - a2) >> 1;
              uint64_t v42 = (a2 - (char *)v16) >> 1;
              do
              {
                uint64_t v43 = v42;
                uint64_t v42 = v41;
                uint64_t v41 = v43 % v41;
              }
              while (v41);
              if (v42)
              {
                uint64_t v44 = &v16[v42];
                do
                {
                  unsigned __int16 v46 = *--v44;
                  unsigned __int16 v45 = v46;
                  uint64_t v47 = &v44[v31];
                  uint64_t v48 = v44;
                  do
                  {
                    uint64_t v49 = v48;
                    uint64_t v48 = v47;
                    *uint64_t v49 = *v47;
                    BOOL v50 = __OFSUB__(v31, (v15 - (char *)v47) >> 1);
                    uint64_t v52 = v31 - ((v15 - (char *)v47) >> 1);
                    char v51 = (v52 < 0) ^ v50;
                    uint64_t v47 = &v16[v52];
                    if (v51) {
                      uint64_t v47 = &v48[v31];
                    }
                  }
                  while (v47 != v44);
                  *uint64_t v48 = v45;
                }
                while (v44 != v16);
              }
              uint64_t v30 = &v16[(v15 - a2) >> 1];
            }
          }
        }
      }
      a4 -= v23;
      v8 -= v22;
      if (v23 + v22 >= a4 + v8)
      {
        uint64_t v56 = a4;
        uint64_t v57 = v22;
        uint64_t v54 = a6;
        double result = (char *)sub_1BBA1DEB0(v30, v15, a3, v56, v8, a6, a7);
        uint64_t v15 = (char *)v16;
        uint64_t v8 = v57;
        a4 = v23;
        a3 = (char *)v30;
      }
      else
      {
        unsigned int v53 = v11;
        uint64_t v54 = a6;
        uint64_t v55 = a3;
        double result = (char *)sub_1BBA1DEB0(v53, v16, v30, v23, v22, a6, a7);
        a3 = v55;
        BOOL v11 = (char *)v30;
      }
      a2 = v15;
      a6 = v54;
      if (!v8) {
        return result;
      }
    }
    if (a4 <= v8)
    {
      if (v11 != a2)
      {
        uint64_t v64 = 0;
        do
        {
          *(_WORD *)&a6[v64] = *(_WORD *)&v11[v64];
          v64 += 2;
        }
        while (&v11[v64] != a2);
        int v65 = &a6[v64];
        if (v65 != a6)
        {
          while (a2 != a3)
          {
            unsigned int v66 = *(unsigned __int16 *)a2;
            unsigned int v67 = *(unsigned __int16 *)a6;
            BOOL v68 = v66 < v67;
            BOOL v69 = v66 >= v67;
            if (v66 >= v67) {
              LOWORD(v66) = *(_WORD *)a6;
            }
            a6 += 2 * v69;
            a2 += 2 * v68;
            *(_WORD *)BOOL v11 = v66;
            v11 += 2;
            if (a6 == v65) {
              return result;
            }
          }
          return (char *)memmove(v11, a6, v65 - a6);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v58 = 0;
      do
      {
        *(_WORD *)&a6[v58] = *(_WORD *)&a2[v58];
        v58 += 2;
      }
      while (&a2[v58] != a3);
      unsigned int v59 = &a6[v58];
      if (v59 != a6)
      {
        unsigned int v60 = a3 - 2;
        while (a2 != v11)
        {
          unsigned int v61 = *((unsigned __int16 *)v59 - 1);
          unsigned int v62 = *((unsigned __int16 *)a2 - 1);
          BOOL v63 = v61 >= v62;
          if (v61 <= v62) {
            LOWORD(v61) = *((_WORD *)a2 - 1);
          }
          if (v63) {
            v59 -= 2;
          }
          else {
            a2 -= 2;
          }
          *(_WORD *)unsigned int v60 = v61;
          v60 -= 2;
          if (v59 == a6) {
            return result;
          }
        }
        uint64_t v70 = 0;
        do
        {
          *(_WORD *)&v60[v70] = *(_WORD *)&v59[v70 - 2];
          v70 -= 2;
        }
        while (&v59[v70] != a6);
      }
    }
  }
  return result;
}

void *sub_1BBA1E338(uint64_t a1, unsigned __int8 a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9F81D88, memory_order_acquire) & 1) == 0)
  {
    uint64_t v11 = a1;
    unsigned __int8 v10 = a2;
    int v8 = __cxa_guard_acquire(&qword_1E9F81D88);
    a2 = v10;
    int v9 = v8;
    a1 = v11;
    if (v9)
    {
      __cxa_atexit((void (*)(void *))sub_1BBA1D9D4, &unk_1E9F81D78, &dword_1BB9B9000);
      __cxa_guard_release(&qword_1E9F81D88);
      a2 = v10;
      a1 = v11;
    }
  }
  uint64_t v2 = 0;
  unint64_t v3 = (uint64_t *)(a1 + 16);
  int v4 = -1;
  int v5 = -1;
  do
  {
    uint64_t v6 = *v3;
    if (*v3 && *(_DWORD *)(v6 + 680) > v5 && *(_DWORD *)(v6 + 40) == a2)
    {
      int v5 = *(_DWORD *)(v6 + 680);
      int v4 = v2;
    }
    ++v2;
    v3 += 2;
  }
  while (v2 != 17);
  if (v4 == -1) {
    return &unk_1E9F81D78;
  }
  else {
    return (void *)(a1 + 16 * v4 + 16);
  }
}

void *sub_1BBA1E428(uint64_t a1, int a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9F81DB8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v9 = a1;
    int v8 = a2;
    int v6 = __cxa_guard_acquire(&qword_1E9F81DB8);
    a2 = v8;
    int v7 = v6;
    a1 = v9;
    if (v7)
    {
      __cxa_atexit((void (*)(void *))sub_1BBA1D9D4, &unk_1E9F81DA8, &dword_1BB9B9000);
      __cxa_guard_release(&qword_1E9F81DB8);
      a1 = v9;
      a2 = v8;
    }
  }
  uint64_t v2 = a1 + 16 * a2;
  uint64_t v4 = *(void *)(v2 + 16);
  uint64_t v3 = v2 + 16;
  if (v4) {
    return (void *)v3;
  }
  else {
    return &unk_1E9F81DA8;
  }
}

std::__shared_weak_count *sub_1BBA1E4D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 356);
  for (uint64_t i = (void *)(a1 + 16); *i; i += 2)
  {
    if (++v3 == 17) {
      return (std::__shared_weak_count *)4294954387;
    }
  }
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  *uint64_t i = a2;
  uint64_t v6 = a1 + 16 * v3;
  double result = *(std::__shared_weak_count **)(v6 + 24);
  *(void *)(v6 + 24) = a3;
  if (result)
  {
    sub_1BB9C09B4(result);
    return 0;
  }
  return result;
}

void sub_1BBA1E540(uint64_t a1)
{
  for (uint64_t i = 0; i != 272; i += 16)
  {
    uint64_t v3 = a1 + i;
    uint64_t v4 = *(void *)(a1 + i + 16);
    if (v4 && !*(_DWORD *)(v4 + 36) && *(unsigned char *)(v4 + 45))
    {
      int v5 = *(std::__shared_weak_count **)(a1 + i + 24);
      *(void *)(v3 + 16) = 0;
      *(void *)(v3 + 24) = 0;
      if (v5) {
        sub_1BB9C09B4(v5);
      }
    }
  }
}

void sub_1BBA1E5A8(uint64_t a1, int a2)
{
  uint64_t v2 = 0;
  for (uint64_t i = (void *)(a1 + 16); !*i || *(_DWORD *)(*i + 680) != a2; i += 2)
  {
    if (++v2 == 17) {
      return;
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16 * v2 + 24);
  *uint64_t i = 0;
  i[1] = 0;
  if (v4) {
    sub_1BB9C09B4(v4);
  }
}

uint64_t sub_1BBA1E5EC(uint64_t result, unsigned int *a2)
{
  if (a2)
  {
    for (uint64_t i = 16; i != 288; i += 16)
    {
      uint64_t v3 = *(void *)(result + i);
      if (v3) {
        *(_DWORD *)(v3 + 36) = 0;
      }
    }
    uint64_t v4 = a2[1];
    if ((int)v4 >= 1)
    {
      int v5 = a2 + 6;
      do
      {
        if (*(void *)v5) {
          *(_DWORD *)(*(void *)v5 + 36) |= 1u;
        }
        v5 += 4;
        --v4;
      }
      while (v4);
    }
    uint64_t v6 = a2[2];
    if ((int)v6 >= 1)
    {
      int v7 = a2 + 70;
      do
      {
        if (*(void *)v7) {
          *(_DWORD *)(*(void *)v7 + 36) |= 1u;
        }
        v7 += 4;
        --v6;
      }
      while (v6);
    }
    uint64_t v8 = a2[4];
    if ((int)v8 >= 1)
    {
      uint64_t v9 = a2 + 198;
      do
      {
        if (*(void *)v9) {
          *(_DWORD *)(*(void *)v9 + 36) |= 1u;
        }
        v9 += 4;
        --v8;
      }
      while (v8);
    }
    uint64_t v10 = a2[3];
    if ((int)v10 >= 1)
    {
      uint64_t v11 = a2 + 134;
      do
      {
        if (*(void *)v11) {
          *(_DWORD *)(*(void *)v11 + 36) |= 2u;
        }
        v11 += 4;
        --v10;
      }
      while (v10);
    }
    uint64_t v12 = a2[5];
    if ((int)v12 >= 1)
    {
      unsigned int v13 = a2 + 262;
      do
      {
        if (*(void *)v13) {
          *(_DWORD *)(*(void *)v13 + 36) |= 2u;
        }
        v13 += 4;
        --v12;
      }
      while (v12);
    }
  }
  return result;
}

uint64_t sub_1BBA1E700(uint64_t a1)
{
  int v1 = 0;
  for (uint64_t i = 16; i != 288; i += 16)
  {
    uint64_t v3 = *(void *)(a1 + i);
    if (v3)
    {
      uint64_t v4 = a1 + 4 * v1++;
      *(_DWORD *)(v4 + 288) = *(_DWORD *)(v3 + 680);
    }
  }
  uint64_t v5 = a1 + 288;
  unint64_t v6 = v1;
  int v7 = (int *)(a1 + 288 + 4 * v1);
  uint64_t v14 = (uint64_t (*)(int *, int *))sub_1BBA1F1A0;
  if (v1 < 129)
  {
LABEL_9:
    uint64_t v12 = 0;
    unint64_t v9 = 0;
  }
  else
  {
    uint64_t v8 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v9 = v1;
    while (1)
    {
      uint64_t v10 = (int *)operator new(4 * v9, v8);
      if (v10) {
        break;
      }
      BOOL v11 = v9 > 1;
      v9 >>= 1;
      if (!v11) {
        goto LABEL_9;
      }
    }
    uint64_t v12 = v10;
  }
  sub_1BBA1E804(v5, v7, &v14, v6, v12, v9);
  if (v12) {
    operator delete(v12);
  }
  return v5;
}

void sub_1BBA1E7EC(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1BBA1E804(uint64_t result, int *a2, uint64_t (**a3)(int *, int *), unint64_t a4, int *a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    uint64_t v8 = (int *)result;
    if (a4 == 2)
    {
      unint64_t v9 = a2 - 1;
      double result = (*a3)(a2 - 1, (int *)result);
      if (result)
      {
        int v10 = *v8;
        int *v8 = *v9;
        int *v9 = v10;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      uint64_t v19 = (char *)a5;
      unint64_t v20 = a4 >> 1;
      unsigned int v21 = (int *)(result + 4 * (a4 >> 1));
      unint64_t v22 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        sub_1BBA1EA7C((int *)result, v21, a3, v22, a5);
        uint64_t v23 = (int *)&v19[4 * v20];
        double result = (uint64_t)sub_1BBA1EA7C(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v23);
        uint64_t v24 = &v19[4 * a4];
        unint64_t v25 = v23;
        while (v25 != (int *)v24)
        {
          double result = (*a3)(v25, (int *)v19);
          if (result) {
            unint64_t v26 = (char *)v25;
          }
          else {
            unint64_t v26 = v19;
          }
          v19 += 4 * (result ^ 1);
          v25 += result;
          *v8++ = *(_DWORD *)v26;
          if (v19 == (char *)v23)
          {
            if (v25 != (int *)v24)
            {
              uint64_t v27 = 0;
              do
              {
                v8[v27] = v25[v27];
                ++v27;
              }
              while (&v25[v27] != (int *)v24);
            }
            return result;
          }
        }
        if (v19 != (char *)v23)
        {
          uint64_t v28 = 0;
          do
          {
            v8[v28] = *(_DWORD *)&v19[v28 * 4];
            ++v28;
          }
          while (&v19[v28 * 4] != (char *)v23);
        }
      }
      else
      {
        sub_1BBA1E804(result, v21, a3, v22, a5, a6);
        sub_1BBA1E804(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v19, a6);
        return sub_1BBA1EC8C((uint64_t)v8, &v8[a4 >> 1], a2, (uint64_t (**)(void, void))a3, a4 >> 1, a4 - (a4 >> 1), v19, a6);
      }
    }
    else if ((int *)result != a2)
    {
      uint64_t v12 = (int *)(result + 4);
      if ((int *)(result + 4) != a2)
      {
        uint64_t v13 = 0;
        uint64_t v14 = (int *)result;
        do
        {
          uint64_t v15 = v14;
          uint64_t v14 = v12;
          double result = (*a3)(v12, v15);
          if (result)
          {
            int v29 = *v14;
            uint64_t v16 = v13;
            while (1)
            {
              *(int *)((char *)v8 + v16 + 4) = *(int *)((char *)v8 + v16);
              if (!v16) {
                break;
              }
              v16 -= 4;
              double result = (*a3)(&v29, (int *)((char *)v8 + v16));
              if ((result & 1) == 0)
              {
                unint64_t v17 = (int *)((char *)v8 + v16 + 4);
                goto LABEL_15;
              }
            }
            unint64_t v17 = v8;
LABEL_15:
            int *v17 = v29;
          }
          uint64_t v12 = v14 + 1;
          v13 += 4;
        }
        while (v14 + 1 != a2);
      }
    }
  }
  return result;
}

int *sub_1BBA1EA7C(int *result, int *a2, uint64_t (**a3)(int *, int *), unint64_t a4, int *a5)
{
  if (a4)
  {
    uint64_t v5 = a5;
    int v7 = result;
    if (a4 == 1)
    {
LABEL_9:
      *uint64_t v5 = *v7;
      return result;
    }
    if (a4 == 2)
    {
      int v10 = a2 - 1;
      double result = (int *)(*a3)(a2 - 1, result);
      if (result) {
        BOOL v11 = v10;
      }
      else {
        BOOL v11 = v7;
      }
      *v5++ = *v11;
      if (!result) {
        int v7 = v10;
      }
      goto LABEL_9;
    }
    if ((uint64_t)a4 > 8)
    {
      uint64_t v19 = &result[a4 >> 1];
      sub_1BBA1E804(result, v19, a3, a4 >> 1, a5, a4 >> 1);
      double result = (int *)sub_1BBA1E804(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
      unint64_t v20 = &v7[a4 >> 1];
      while (v20 != a2)
      {
        double result = (int *)(*a3)(v20, v7);
        if (result) {
          unsigned int v21 = v20;
        }
        else {
          unsigned int v21 = v7;
        }
        v20 += result;
        v7 += result ^ 1;
        *v5++ = *v21;
        if (v7 == v19)
        {
          if (v20 != a2)
          {
            uint64_t v22 = 0;
            do
            {
              v5[v22] = v20[v22];
              ++v22;
            }
            while (&v20[v22] != a2);
          }
          return result;
        }
      }
      if (v7 != v19)
      {
        uint64_t v23 = 0;
        do
        {
          v5[v23] = v7[v23];
          ++v23;
        }
        while (&v7[v23] != v19);
      }
    }
    else if (result != a2)
    {
      uint64_t v12 = result + 1;
      *a5 = *result;
      if (result + 1 != a2)
      {
        uint64_t v13 = 0;
        uint64_t v14 = a5;
        do
        {
          uint64_t v15 = v14++;
          double result = (int *)(*a3)(v12, v15);
          uint64_t v16 = v14;
          if (result)
          {
            v15[1] = *v15;
            uint64_t v16 = v5;
            if (v15 != v5)
            {
              uint64_t v17 = v13;
              while (1)
              {
                uint64_t v16 = (int *)((char *)v5 + v17);
                double result = (int *)(*a3)(v12, (int *)((char *)v5 + v17 - 4));
                if (!result) {
                  break;
                }
                *(int *)((char *)v5 + v17) = *(int *)((char *)v5 + v17 - 4);
                v17 -= 4;
                if (!v17)
                {
                  uint64_t v16 = v5;
                  break;
                }
              }
            }
          }
          int v18 = *v12++;
          int *v16 = v18;
          v13 += 4;
        }
        while (v12 != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1BBA1EC8C(uint64_t result, _DWORD *a2, _DWORD *a3, uint64_t (**a4)(void, void), uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  if (!a6) {
    return result;
  }
  uint64_t v10 = a6;
  uint64_t v15 = (_DWORD *)result;
  while (v10 > a8 && a5 > a8)
  {
    if (!a5) {
      return result;
    }
    while (1)
    {
      double result = (*a4)(a2, v15);
      if (result) {
        break;
      }
      ++v15;
      if (!--a5) {
        return result;
      }
    }
    __srCC_MD5_CTX c = a7;
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        int v65 = *v15;
        *uint64_t v15 = *a2;
        *a2 = v65;
        return result;
      }
      if (a5 >= 0) {
        uint64_t v22 = a5;
      }
      else {
        uint64_t v22 = a5 + 1;
      }
      uint64_t v72 = v22 >> 1;
      unint64_t v20 = &v15[v22 >> 1];
      if (a3 == a2)
      {
        int v18 = a3;
        uint64_t v27 = a3;
      }
      else
      {
        uint64_t v69 = v10;
        uint64_t v68 = a8;
        uint64_t v23 = (uint64_t (*)(_DWORD *, _DWORD *))*a4;
        unint64_t v24 = a3 - a2;
        int v18 = a2;
        do
        {
          unint64_t v25 = &v18[v24 >> 1];
          int v26 = v23(v25, v20);
          if (v26) {
            v24 += ~(v24 >> 1);
          }
          else {
            v24 >>= 1;
          }
          if (v26) {
            int v18 = v25 + 1;
          }
        }
        while (v24);
        uint64_t v27 = a2;
        a8 = v68;
        uint64_t v10 = v69;
      }
      uint64_t v17 = v18 - v27;
    }
    else
    {
      if (v10 >= 0) {
        uint64_t v16 = v10;
      }
      else {
        uint64_t v16 = v10 + 1;
      }
      uint64_t v17 = v16 >> 1;
      int v18 = &a2[v16 >> 1];
      if (a2 == v15)
      {
        unint64_t v20 = a2;
        unsigned int v21 = a2;
      }
      else
      {
        uint64_t v71 = v16 >> 1;
        uint64_t v67 = a8;
        unint64_t v19 = a2 - v15;
        unint64_t v20 = v15;
        do
        {
          if ((*a4)(v18, &v20[v19 >> 1]))
          {
            v19 >>= 1;
          }
          else
          {
            v20 += (v19 >> 1) + 1;
            v19 += ~(v19 >> 1);
          }
        }
        while (v19);
        unsigned int v21 = v15;
        a8 = v67;
        uint64_t v17 = v71;
      }
      uint64_t v72 = v20 - v21;
    }
    uint64_t v28 = v18;
    if (v20 != a2)
    {
      uint64_t v28 = v20;
      if (a2 != v18)
      {
        if (v20 + 1 == a2)
        {
          uint64_t v70 = v10;
          int v35 = *v20;
          int64_t v36 = (char *)v18 - (char *)a2;
          int64_t v37 = a2;
          size_t v38 = (char *)v18 - (char *)a2;
          uint64_t v39 = v17;
          memmove(v20, v37, v38);
          uint64_t v17 = v39;
          uint64_t v28 = (_DWORD *)((char *)v20 + v36);
          *uint64_t v28 = v35;
        }
        else
        {
          if (a2 + 1 != v18)
          {
            uint64_t v29 = a2 - v20;
            if (v29 == v18 - a2)
            {
              uint64_t v30 = 0;
              do
              {
                int v31 = v20[v30];
                v20[v30] = a2[v30];
                uint64_t v32 = (uint64_t)&v20[v30 + 1];
                a2[v30] = v31;
                uint64_t v33 = (uint64_t)&a2[++v30];
              }
              while ((_DWORD *)v32 != a2 && v33 != (void)v18);
              uint64_t v28 = a2;
            }
            else
            {
              uint64_t v43 = v18 - a2;
              uint64_t v44 = a2 - v20;
              do
              {
                uint64_t v45 = v44;
                uint64_t v44 = v43;
                uint64_t v43 = v45 % v43;
              }
              while (v43);
              if (v44)
              {
                unsigned __int16 v46 = &v20[v44];
                do
                {
                  int v48 = *--v46;
                  int v47 = v48;
                  uint64_t v49 = &v46[v29];
                  BOOL v50 = v46;
                  do
                  {
                    char v51 = v50;
                    BOOL v50 = v49;
                    *char v51 = *v49;
                    BOOL v52 = __OFSUB__(v29, v18 - v49);
                    uint64_t v54 = v29 - (v18 - v49);
                    char v53 = (v54 < 0) ^ v52;
                    uint64_t v49 = &v20[v54];
                    if (v53) {
                      uint64_t v49 = &v50[v29];
                    }
                  }
                  while (v49 != v46);
                  *BOOL v50 = v47;
                }
                while (v46 != v20);
              }
              uint64_t v28 = &v20[v18 - a2];
            }
            goto LABEL_64;
          }
          uint64_t v70 = v10;
          uint64_t v40 = a8;
          int v41 = *(v18 - 1);
          uint64_t v28 = v20 + 1;
          if (v18 - 1 != v20)
          {
            uint64_t v42 = v17;
            memmove(v20 + 1, v20, (char *)(v18 - 1) - (char *)v20);
            uint64_t v17 = v42;
          }
          *unint64_t v20 = v41;
          a8 = v40;
        }
        uint64_t v10 = v70;
      }
    }
LABEL_64:
    a5 -= v72;
    v10 -= v17;
    if (v72 + v17 >= a5 + v10)
    {
      uint64_t v56 = a3;
      uint64_t v57 = v17;
      double result = sub_1BBA1EC8C(v28, v18, v56, a4, a5, v10, __src, a8);
      int v18 = v20;
      a7 = __src;
      uint64_t v10 = v57;
      a5 = v72;
      a3 = v28;
    }
    else
    {
      uint64_t v55 = v20;
      a7 = __src;
      double result = sub_1BBA1EC8C(v15, v55, v28, a4, v72, v17, __src, a8);
      uint64_t v15 = v28;
    }
    a2 = v18;
    if (!v10) {
      return result;
    }
  }
  if (a5 <= v10)
  {
    if (v15 != a2)
    {
      uint64_t v62 = 0;
      do
      {
        *(_DWORD *)&a7[v62 * 4] = v15[v62];
        ++v62;
      }
      while (&v15[v62] != a2);
      BOOL v63 = &a7[v62 * 4];
      if (&a7[v62 * 4] != a7)
      {
        while (a2 != a3)
        {
          double result = (*a4)(a2, a7);
          if (result) {
            uint64_t v64 = (char *)a2;
          }
          else {
            uint64_t v64 = a7;
          }
          a7 += 4 * (result ^ 1);
          a2 += result;
          *v15++ = *(_DWORD *)v64;
          if (a7 == v63) {
            return result;
          }
        }
        return (uint64_t)memmove(v15, a7, v63 - a7);
      }
    }
  }
  else if (a2 != a3)
  {
    uint64_t v58 = 0;
    do
    {
      *(_DWORD *)&a7[v58 * 4] = a2[v58];
      ++v58;
    }
    while (&a2[v58] != a3);
    unsigned int v59 = &a7[v58 * 4];
    if (&a7[v58 * 4] != a7)
    {
      unsigned int v60 = a3 - 1;
      while (a2 != v15)
      {
        double result = (*a4)(v59 - 4, a2 - 1);
        if (result) {
          unsigned int v61 = (char *)a2;
        }
        else {
          unsigned int v61 = v59;
        }
        if (result) {
          --a2;
        }
        else {
          v59 -= 4;
        }
        *v60-- = *((_DWORD *)v61 - 1);
        if (v59 == a7) {
          return result;
        }
      }
      uint64_t v66 = 0;
      do
      {
        v60[v66] = *(_DWORD *)&v59[v66 * 4 - 4];
        --v66;
      }
      while (&v59[v66 * 4] != a7);
    }
  }
  return result;
}

BOOL sub_1BBA1F1A0(_DWORD *a1, _DWORD *a2)
{
  return *a1 > *a2;
}

void sub_1BBA1F1B4(uint64_t a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v3 = dword_1E9F80A90;
  if (dword_1E9F80A90 >= 3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)CMSampleTimingInfo buf = 67109120;
    int v16 = a2;
    _os_log_impl(&dword_1BB9B9000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "<<<<<< [Poc %d]: SW DPB >>>>>>\n", buf, 8u);
    int v3 = dword_1E9F80A90;
  }
  uint64_t v5 = 16;
  unint64_t v6 = MEMORY[0x1E4F14500];
  do
  {
    int v7 = *(_DWORD **)(a1 + v5);
    if (v7) {
      BOOL v8 = v3 < 3;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8 && os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = v7[170];
      int v10 = v7[171];
      int v11 = v7[9];
      uint64_t v12 = "N/A";
      if (v11 == 1) {
        uint64_t v12 = "short_term";
      }
      if (v11 == 2) {
        uint64_t v13 = "long_term";
      }
      else {
        uint64_t v13 = v12;
      }
      int v14 = v7[3];
      *(_DWORD *)CMSampleTimingInfo buf = 67109890;
      int v16 = v9;
      __int16 v17 = 1024;
      int v18 = v10;
      __int16 v19 = 2080;
      unint64_t v20 = v13;
      __int16 v21 = 1024;
      int v22 = v14;
      _os_log_impl(&dword_1BB9B9000, v6, OS_LOG_TYPE_DEFAULT, "poc: %d\tframe_num_driver: %d\treference_type: %s temporalID %d\n", buf, 0x1Eu);
      int v3 = dword_1E9F80A90;
    }
    v5 += 16;
  }
  while (v5 != 288);
}

uint64_t sub_1BBA1F36C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 6) = 33685509;
  *(unsigned char *)(a1 + 10) = 2;
  *(_DWORD *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 44) = 0;
  *(void *)(a1 + 80) = 0;
  unint64_t v6 = (BOOL *)(a1 + 80);
  *(void *)(a1 + 11) = 0;
  *(void *)(a1 + 17) = 0;
  *(void *)(a1 + 28) = 0;
  *(unsigned char *)(a1 + 36) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  if (sub_1BBA196DC(a2, 1))
  {
    int v7 = sub_1BBA196DC(a2, 8);
    if (v7 == 255)
    {
      *(_WORD *)a1 = sub_1BBA196DC(a2, 16);
      __int16 v8 = sub_1BBA196DC(a2, 16);
    }
    else
    {
      if (v7 > 16) {
        goto LABEL_7;
      }
      int v9 = (unsigned __int8 *)&unk_1BBB7855B + 2 * v7;
      *(_WORD *)a1 = *v9;
      __int16 v8 = v9[1];
    }
    *(_WORD *)(a1 + 2) = v8;
  }
LABEL_7:
  int v10 = sub_1BBA196DC(a2, 1);
  *(unsigned char *)(a1 + 4) = v10 != 0;
  if (v10) {
    *(unsigned char *)(a1 + 5) = sub_1BBA196DC(a2, 1) != 0;
  }
  if (sub_1BBA196DC(a2, 1))
  {
    *(unsigned char *)(a1 + 6) = sub_1BBA196DC(a2, 3);
    *(unsigned char *)(a1 + 7) = sub_1BBA196DC(a2, 1) != 0;
    if (sub_1BBA196DC(a2, 1))
    {
      *(unsigned char *)(a1 + 8) = sub_1BBA196DC(a2, 8);
      *(unsigned char *)(a1 + 9) = sub_1BBA196DC(a2, 8);
      *(unsigned char *)(a1 + 10) = sub_1BBA196DC(a2, 8);
    }
  }
  if (sub_1BBA196DC(a2, 1))
  {
    *(unsigned char *)(a1 + 11) = sub_1BBA1979C(a2);
    *(unsigned char *)(a1 + 12) = sub_1BBA1979C(a2);
  }
  *(unsigned char *)(a1 + 13) = sub_1BBA196DC(a2, 1) != 0;
  *(unsigned char *)(a1 + 14) = sub_1BBA196DC(a2, 1) != 0;
  *(unsigned char *)(a1 + 15) = sub_1BBA196DC(a2, 1) != 0;
  if (sub_1BBA196DC(a2, 1))
  {
    *(_WORD *)(a1 + 16) = sub_1BBA1979C(a2);
    *(_WORD *)(a1 + 18) = sub_1BBA1979C(a2);
    *(_WORD *)(a1 + 20) = sub_1BBA1979C(a2);
    *(_WORD *)(a1 + 22) = sub_1BBA1979C(a2);
  }
  int v11 = sub_1BBA196DC(a2, 1);
  *(unsigned char *)(a1 + 24) = v11 != 0;
  if (v11)
  {
    int v12 = sub_1BBA196DC(a2, 16);
    *(_DWORD *)(a1 + 28) = sub_1BBA196DC(a2, 16) + (v12 << 16);
    int v13 = sub_1BBA196DC(a2, 16);
    *(_DWORD *)(a1 + 32) = sub_1BBA196DC(a2, 16) + (v13 << 16);
    int v14 = sub_1BBA196DC(a2, 1);
    *(unsigned char *)(a1 + 36) = v14 != 0;
    if (v14) {
      *(_DWORD *)(a1 + 40) = sub_1BBA19824(a2);
    }
    int v15 = sub_1BBA196DC(a2, 1);
    *(unsigned char *)(a1 + 44) = v15 != 0;
    if (v15) {
      sub_1BBA55DFC(a1 + 48, a2, 1, *(unsigned __int8 *)(a3 + 1) + 1);
    }
  }
  uint64_t result = sub_1BBA196DC(a2, 1);
  BOOL *v6 = result != 0;
  if (result)
  {
    *(unsigned char *)(a1 + 81) = sub_1BBA196DC(a2, 1) != 0;
    *(unsigned char *)(a1 + 82) = sub_1BBA196DC(a2, 1) != 0;
    *(unsigned char *)(a1 + 83) = sub_1BBA196DC(a2, 1) != 0;
    *(_DWORD *)(a1 + 84) = sub_1BBA1979C(a2);
    *(_DWORD *)(a1 + 88) = sub_1BBA1979C(a2);
    *(_DWORD *)(a1 + 92) = sub_1BBA1979C(a2);
    *(_DWORD *)(a1 + 96) = sub_1BBA1979C(a2);
    uint64_t result = sub_1BBA1979C(a2);
    *(_DWORD *)(a1 + 100) = result;
  }
  return result;
}

_WORD *sub_1BBA1F708(_WORD *result, int16x8_t *a2, char a3)
{
  uint64_t v3 = 0;
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  memset(v57, 0, sizeof(v57));
  int v4 = 1 << (a3 - 1);
  uint64_t v5 = a2 + 3;
  int32x4_t v55 = 0u;
  int32x4_t v56 = 0u;
  unint64_t v6 = result + 128;
  int v7 = result + 64;
  __int16 v8 = result + 32;
  int32x4_t v53 = 0u;
  int32x4_t v54 = 0u;
  int32x4_t v51 = 0u;
  int32x4_t v52 = 0u;
  int32x4_t v49 = 0u;
  int32x4_t v50 = 0u;
  do
  {
    uint64_t v9 = 0;
    int v10 = a2;
    int v11 = v5;
    do
    {
      int16x8_t v12 = *v10++;
      int16x8_t v13 = v12;
      int16x8_t v14 = *v11--;
      int8x16_t v15 = (int8x16_t)vrev64q_s16(v14);
      int16x8_t v16 = (int16x8_t)vextq_s8(v15, v15, 8uLL);
      __int16 v17 = (int32x4_t *)&v57[v9];
      int32x4_t *v17 = vaddl_s16(*(int16x4_t *)v16.i8, *(int16x4_t *)v13.i8);
      v17[1] = vaddl_high_s16(v16, v13);
      int v18 = (int32x4_t *)((char *)&v53 + v9 * 16);
      *int v18 = vsubl_s16(*(int16x4_t *)v13.i8, *(int16x4_t *)v16.i8);
      v18[1] = vsubl_high_s16(v13, v16);
      v9 += 2;
    }
    while (v9 != 4);
    uint64_t v19 = 0;
    for (uint64_t i = 3; i != 1; --i)
    {
      int32x4_t v21 = (int32x4_t)v57[v19];
      int8x16_t v22 = (int8x16_t)vrev64q_s32((int32x4_t)v57[i]);
      int32x4_t v23 = (int32x4_t)vextq_s8(v22, v22, 8uLL);
      *(int32x4_t *)((char *)&v51 + v19 * 16) = vaddq_s32(v23, v21);
      *(int32x4_t *)((char *)&v49 + v19 * 16) = vsubq_s32(v21, v23);
      ++v19;
    }
    int8x16_t v24 = (int8x16_t)vrev64q_s32(v52);
    int32x4_t v25 = (int32x4_t)vextq_s8(v24, v24, 8uLL);
    int32x4_t v26 = vaddq_s32(v25, v51);
    int32x4_t v27 = vsubq_s32(v51, v25);
    uint64_t v28 = &result[v3];
    *uint64_t v28 = (v4 + ((v26.i32[2] + v26.i32[1] + v26.i32[3] + v26.i32[0]) << 6)) >> a3;
    v28[512] = (v4 + ((v26.i32[3] + v26.i32[0] - (v26.i32[2] + v26.i32[1])) << 6)) >> a3;
    v28[256] = (v4 + 83 * (v26.i32[0] - v26.i32[3]) + 36 * (v26.i32[1] - v26.i32[2])) >> a3;
    v28[768] = (v4 + 36 * (v26.i32[0] - v26.i32[3]) - 83 * (v26.i32[1] - v26.i32[2])) >> a3;
    unint64_t v29 = -4;
    uint64_t v30 = &dword_1BBB786FD;
    int v31 = v6;
    do
    {
      v25.i32[0] = *v30;
      int32x4_t v25 = vmulq_s32(v27, vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)v25.i8)));
      *int v31 = (vaddvq_s32(v25) + v4) >> a3;
      v29 += 8;
      v31 += 256;
      v30 += 64;
    }
    while (v29 < 0x18);
    int32x4_t v33 = v49;
    int32x4_t v32 = v50;
    unint64_t v34 = -2;
    int v35 = &qword_1BBB786BD;
    int64_t v36 = v7;
    do
    {
      int8x8_t v37 = (int8x8_t)*v35;
      v35 += 16;
      int16x8_t v38 = vmovl_s8(v37);
      *int64_t v36 = (vaddvq_s32(vmlaq_s32(vmulq_s32(v32, vmovl_high_s16(v38)), v33, vmovl_s16(*(int16x4_t *)v38.i8))) + v4) >> a3;
      v34 += 4;
      v36 += 128;
    }
    while (v34 < 0x1C);
    int32x4_t v40 = v55;
    int32x4_t v39 = v56;
    unint64_t v41 = -1;
    uint64_t v42 = &xmmword_1BBB7869D;
    uint64_t v43 = v8;
    int32x4_t v45 = v53;
    int32x4_t v44 = v54;
    do
    {
      int8x16_t v46 = (int8x16_t)*v42;
      v42 += 4;
      int16x8_t v47 = vmovl_s8(*(int8x8_t *)v46.i8);
      int16x8_t v48 = vmovl_high_s8(v46);
      *uint64_t v43 = (vaddvq_s32(vaddq_s32(vmlaq_s32(vmulq_s32(v40, vmovl_s16(*(int16x4_t *)v48.i8)), v45, vmovl_s16(*(int16x4_t *)v47.i8)), vmlaq_s32(vmulq_s32(v39, vmovl_high_s16(v48)), v44, vmovl_high_s16(v47))))+ v4) >> a3;
      v43 += 64;
      v41 += 2;
    }
    while (v41 < 0x1E);
    ++v3;
    v5 += 4;
    a2 += 4;
    ++v6;
    ++v7;
    ++v8;
  }
  while (v3 != 32);
  return result;
}

uint64_t sub_1BBA1F9EC(uint64_t result, uint64_t a2, char a3)
{
  uint64_t v3 = 0;
  int v4 = 1 << (a3 - 1);
  uint64_t v5 = (_WORD *)(result + 64);
  unint64_t v6 = (_WORD *)(result + 32);
  do
  {
    int16x8_t v7 = *(int16x8_t *)(a2 + 32 * v3);
    int8x16_t v8 = (int8x16_t)vrev64q_s16(*(int16x8_t *)(a2 - 14 + 32 * v3 + 30));
    int16x8_t v9 = (int16x8_t)vextq_s8(v8, v8, 8uLL);
    int32x4_t v10 = vaddl_s16(*(int16x4_t *)v9.i8, *(int16x4_t *)v7.i8);
    int8x16_t v11 = (int8x16_t)vrev64q_s32(vaddl_high_s16(v9, v7));
    int32x4_t v12 = (int32x4_t)vextq_s8(v11, v11, 8uLL);
    int32x4_t v13 = vaddq_s32(v12, v10);
    int32x4_t v14 = vsubq_s32(v10, v12);
    int8x16_t v15 = (_WORD *)(result + 2 * v3);
    *int8x16_t v15 = (v4 + ((v13.i32[2] + v13.i32[1] + v13.i32[3] + v13.i32[0]) << 6)) >> a3;
    v15[128] = (v4 + ((v13.i32[3] + v13.i32[0] - (v13.i32[2] + v13.i32[1])) << 6)) >> a3;
    v15[64] = (v4 + 83 * (v13.i32[0] - v13.i32[3]) + 36 * (v13.i32[1] - v13.i32[2])) >> a3;
    v15[192] = (v4 + 36 * (v13.i32[0] - v13.i32[3]) - 83 * (v13.i32[1] - v13.i32[2])) >> a3;
    unint64_t v16 = -2;
    __int16 v17 = &dword_1BBB7859D;
    int v18 = v5;
    do
    {
      int v19 = *v17;
      v17 += 16;
      v12.i32[0] = v19;
      int32x4_t v12 = vmulq_s32(v14, vmovl_s16((int16x4_t)*(_OWORD *)&vmovl_s8(*(int8x8_t *)v12.i8)));
      *int v18 = (vaddvq_s32(v12) + v4) >> a3;
      v18 += 64;
      v16 += 4;
    }
    while (v16 < 0xC);
    int32x4_t v20 = vsubl_high_s16(v7, v9);
    int32x4_t v21 = vsubl_s16(*(int16x4_t *)v7.i8, *(int16x4_t *)v9.i8);
    unint64_t v22 = -1;
    int32x4_t v23 = &qword_1BBB7858D;
    int8x16_t v24 = v6;
    do
    {
      int8x8_t v25 = (int8x8_t)*v23;
      v23 += 4;
      int16x8_t v26 = vmovl_s8(v25);
      *int8x16_t v24 = (vaddvq_s32(vmlaq_s32(vmulq_s32(v20, vmovl_high_s16(v26)), v21, vmovl_s16(*(int16x4_t *)v26.i8))) + v4) >> a3;
      v24 += 32;
      v22 += 2;
    }
    while (v22 < 0xE);
    ++v3;
    ++v5;
    ++v6;
  }
  while (v3 != 16);
  return result;
}

int32x4_t sub_1BBA1FB60(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3 = 0;
  int v4 = 1 << (a3 - 1);
  uint64_t v5 = (_WORD *)(a1 + 64);
  do
  {
    int16x4_t v6 = *(int16x4_t *)(a2 + v3);
    int16x4_t v7 = vrev64_s16(*(int16x4_t *)(a2 + v3 + 8));
    int32x4_t v8 = vaddl_s16(v7, v6);
    int32x4_t result = vsubl_s16(v6, v7);
    *(v5 - 32) = (v4 + ((v8.i32[2] + v8.i32[1] + v8.i32[3] + v8.i32[0]) << 6)) >> a3;
    *uint64_t v5 = (v4 + ((v8.i32[3] + v8.i32[0] - (v8.i32[2] + v8.i32[1])) << 6)) >> a3;
    *(v5 - 16) = (v4 + 83 * (v8.i32[0] - v8.i32[3]) + 36 * (v8.i32[1] - v8.i32[2])) >> a3;
    v5[16] = (v4 + 36 * (v8.i32[0] - v8.i32[3]) - 83 * (v8.i32[1] - v8.i32[2])) >> a3;
    *(v5 - 24) = (v4 + 89 * result.i32[0] + 75 * result.i32[1] + 50 * result.i32[2] + 18 * result.i32[3]) >> a3;
    uint8_t v5[8] = (v4 + 50 * result.i32[0] - 89 * result.i32[1] + 18 * result.i32[2] + 75 * result.i32[3]) >> a3;
    *(v5 - 8) = (v4 + 75 * result.i32[0] - 18 * result.i32[1] - 89 * result.i32[2] - 50 * result.i32[3]) >> a3;
    v5[24] = (v4 + 18 * result.i32[0] - 50 * result.i32[1] + 75 * result.i32[2] - 89 * result.i32[3]) >> a3;
    v3 += 16;
    ++v5;
  }
  while (v3 != 128);
  return result;
}

uint64_t sub_1BBA1FCA4(uint64_t a1, uint64_t a2, char a3)
{
  int v3 = 1 << (a3 - 1);
  int v4 = (__int16 *)(a2 + 4);
  uint64_t v5 = a1 + 16;
  uint64_t v6 = -8;
  do
  {
    int v7 = *(v4 - 2);
    int v8 = v4[1];
    int v9 = v8 + v7;
    int v10 = v7 - v8;
    int v11 = *(v4 - 1);
    int v12 = *v4;
    int v13 = v12 + v11;
    int v14 = v11 - v12;
    uint64_t result = ((v3 + ((v13 + v9) << 6)) >> a3);
    unint64_t v16 = (_WORD *)(v5 + v6);
    *(v16 - 4) = result;
    v16[4] = (v3 + ((v9 - v13) << 6)) >> a3;
    _WORD *v16 = (v3 + 83 * v10 + 36 * v14) >> a3;
    v16[8] = (v3 + 36 * v10 - 83 * v14) >> a3;
    v4 += 4;
    v6 += 2;
  }
  while (v6);
  return result;
}

uint64_t sub_1BBA1FD3C(uint64_t a1, int a2)
{
  *(_DWORD *)a1 = a2;
  *(unsigned char *)(a1 + 4) = 20 - a2;
  switch(a2)
  {
    case 10:
      *(void *)(a1 + 48) = sub_1BBA20624;
      *(void *)(a1 + 56) = sub_1BBA20568;
      *(void *)(a1 + 64) = sub_1BBA204AC;
      *(void *)(a1 + 72) = sub_1BBA203F0;
      *(void *)(a1 + 80) = sub_1BBA20334;
      *(void *)(a1 + 88) = sub_1BBA202C0;
      *(void *)(a1 + 96) = sub_1BBA2024C;
      *(void *)(a1 + 104) = sub_1BBA201D8;
      *(void *)(a1 + 208) = sub_1BBA20190;
      *(void *)(a1 + 216) = sub_1BBA20148;
      *(void *)(a1 + 224) = sub_1BBA20100;
      *(void *)(a1 + 232) = sub_1BBA200B8;
      *(void *)(a1 + 240) = sub_1BBA2004C;
      *(void *)(a1 + 248) = sub_1BBA1FFE0;
      *(void *)(a1 + 256) = sub_1BBA1FF74;
LABEL_6:
      sub_1BBAD9194((void *)a1, a2);
      return 0;
    case 9:
      uint64_t v2 = 0;
      *(void *)(a1 + 48) = sub_1BBA20C34;
      *(void *)(a1 + 56) = sub_1BBA20B78;
      *(void *)(a1 + 64) = sub_1BBA20ABC;
      *(void *)(a1 + 72) = sub_1BBA20A00;
      *(void *)(a1 + 80) = sub_1BBA20944;
      *(void *)(a1 + 88) = sub_1BBA208D0;
      *(void *)(a1 + 96) = sub_1BBA2085C;
      *(void *)(a1 + 104) = sub_1BBA207E8;
      *(void *)(a1 + 208) = sub_1BBA20190;
      *(void *)(a1 + 216) = sub_1BBA20148;
      *(void *)(a1 + 224) = sub_1BBA20100;
      *(void *)(a1 + 232) = sub_1BBA200B8;
      *(void *)(a1 + 240) = sub_1BBA2004C;
      *(void *)(a1 + 248) = sub_1BBA1FFE0;
      *(void *)(a1 + 256) = sub_1BBA1FF74;
      return v2;
    case 8:
      goto LABEL_6;
  }
  return 4294954386;
}

uint64_t sub_1BBA1FF74(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = 0;
  int v7 = (__int16 *)(result + 2);
  int v8 = (__int16 *)(a3 + 2);
  do
  {
    uint64_t v9 = 0;
    int v10 = v8;
    int v11 = v7;
    do
    {
      *(_WORD *)(a5 + v9) = *(v11 - 1) - *(v10 - 1);
      __int16 v13 = *v11;
      v11 += 2;
      __int16 v12 = v13;
      __int16 v14 = *v10;
      v10 += 2;
      *(_WORD *)(a6 + v9) = v12 - v14;
      v9 += 2;
    }
    while (v9 != 32);
    ++v6;
    a6 += 32;
    a5 += 32;
    v7 += a2;
    v8 += a4;
  }
  while (v6 != 16);
  return result;
}

uint64_t sub_1BBA1FFE0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = 0;
  int v7 = (__int16 *)(result + 2);
  int v8 = (__int16 *)(a3 + 2);
  do
  {
    uint64_t v9 = 0;
    int v10 = v8;
    int v11 = v7;
    do
    {
      *(_WORD *)(a5 + v9) = *(v11 - 1) - *(v10 - 1);
      __int16 v13 = *v11;
      v11 += 2;
      __int16 v12 = v13;
      __int16 v14 = *v10;
      v10 += 2;
      *(_WORD *)(a6 + v9) = v12 - v14;
      v9 += 2;
    }
    while (v9 != 16);
    ++v6;
    a6 += 16;
    a5 += 16;
    v7 += a2;
    v8 += a4;
  }
  while (v6 != 8);
  return result;
}

uint64_t sub_1BBA2004C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = 0;
  int v7 = (__int16 *)(result + 2);
  int v8 = (__int16 *)(a3 + 2);
  do
  {
    uint64_t v9 = 0;
    int v10 = v8;
    int v11 = v7;
    do
    {
      *(_WORD *)(a5 + v9) = *(v11 - 1) - *(v10 - 1);
      __int16 v13 = *v11;
      v11 += 2;
      __int16 v12 = v13;
      __int16 v14 = *v10;
      v10 += 2;
      *(_WORD *)(a6 + v9) = v12 - v14;
      v9 += 2;
    }
    while (v9 != 8);
    ++v6;
    a6 += 8;
    a5 += 8;
    v7 += a2;
    v8 += a4;
  }
  while (v6 != 4);
  return result;
}

uint64_t sub_1BBA200B8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 0;
  do
  {
    for (uint64_t i = 0; i != 64; i += 2)
      *(_WORD *)(a5 + i) = *(_WORD *)(result + i) - *(_WORD *)(a3 + i);
    ++v5;
    a5 += 64;
    a3 += 2 * a4;
    result += 2 * a2;
  }
  while (v5 != 32);
  return result;
}

uint64_t sub_1BBA20100(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 0;
  do
  {
    for (uint64_t i = 0; i != 32; i += 2)
      *(_WORD *)(a5 + i) = *(_WORD *)(result + i) - *(_WORD *)(a3 + i);
    ++v5;
    a5 += 32;
    a3 += 2 * a4;
    result += 2 * a2;
  }
  while (v5 != 16);
  return result;
}

uint64_t sub_1BBA20148(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 0;
  do
  {
    for (uint64_t i = 0; i != 16; i += 2)
      *(_WORD *)(a5 + i) = *(_WORD *)(result + i) - *(_WORD *)(a3 + i);
    ++v5;
    a5 += 16;
    a3 += 2 * a4;
    result += 2 * a2;
  }
  while (v5 != 8);
  return result;
}

uint64_t sub_1BBA20190(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 0;
  do
  {
    for (uint64_t i = 0; i != 8; i += 2)
      *(_WORD *)(a5 + i) = *(_WORD *)(result + i) - *(_WORD *)(a3 + i);
    ++v5;
    a5 += 8;
    a3 += 2 * a4;
    result += 2 * a2;
  }
  while (v5 != 4);
  return result;
}

uint64_t sub_1BBA201D8(uint64_t a1)
{
  v3[65] = *MEMORY[0x1E4F143B8];
  sub_1BBA1F9EC((uint64_t)v3, a1, 5);
  return sub_1BBA1F9EC(a1, (uint64_t)v3, 10);
}

double sub_1BBA2024C(uint64_t a1)
{
  v3[17] = *MEMORY[0x1E4F143B8];
  sub_1BBA1FB60((uint64_t)v3, a1, 4);
  *(void *)&double result = sub_1BBA1FB60(a1, (uint64_t)v3, 9).u64[0];
  return result;
}

uint64_t sub_1BBA202C0(uint64_t a1)
{
  v3[5] = *MEMORY[0x1E4F143B8];
  sub_1BBA1FCA4((uint64_t)v3, a1, 3);
  return sub_1BBA1FCA4(a1, (uint64_t)v3, 8);
}

_WORD *sub_1BBA20334(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int16x8_t *a5)
{
  uint64_t v6 = 0;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v7 = a5;
  do
  {
    for (uint64_t i = 0; i != 32; ++i)
      v7->i16[i] = *(_WORD *)(a1 + i * 2) - *(_WORD *)(a3 + i * 2);
    ++v6;
    v7 += 4;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 32);
  sub_1BBA1F708(v10, a5, 6);
  return sub_1BBA1F708(a5, v10, 11);
}

uint64_t sub_1BBA203F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = 0;
  v10[65] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a5;
  do
  {
    for (uint64_t i = 0; i != 32; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 32;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 16);
  sub_1BBA1F9EC((uint64_t)v10, a5, 5);
  return sub_1BBA1F9EC(a5, (uint64_t)v10, 10);
}

double sub_1BBA204AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = 0;
  v10[17] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a5;
  do
  {
    for (uint64_t i = 0; i != 16; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 16;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 8);
  sub_1BBA1FB60((uint64_t)v10, a5, 4);
  *(void *)&double result = sub_1BBA1FB60(a5, (uint64_t)v10, 9).u64[0];
  return result;
}

uint64_t sub_1BBA20568(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = 0;
  v10[5] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a5;
  do
  {
    for (uint64_t i = 0; i != 8; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 8;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 4);
  sub_1BBA1FCA4((uint64_t)v10, a5, 3);
  return sub_1BBA1FCA4(a5, (uint64_t)v10, 8);
}

uint64_t sub_1BBA20624(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = 0;
  v10[5] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a5;
  do
  {
    for (uint64_t i = 0; i != 8; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 8;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 4);
  sub_1BBA206E0((uint64_t)v10, a5, 3);
  return sub_1BBA206E0(a5, (uint64_t)v10, 8);
}

uint64_t sub_1BBA206E0(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3 = 0;
  int v4 = 1 << (a3 - 1);
  uint64_t v5 = (__int16 *)(a2 + 4);
  uint64_t v6 = a1 + 8;
  do
  {
    int v7 = *(v5 - 2);
    int v8 = v5[1];
    int v9 = v8 + v7;
    int v10 = *(v5 - 1);
    int v11 = v10 + v8;
    int v12 = v7 - v10;
    int v13 = 74 * *v5;
    int v14 = (v13 + v4 + 29 * v9 + 55 * v11) >> a3;
    if (v14 >= 0x7FFF) {
      int v14 = 0x7FFF;
    }
    if (v14 <= -32768) {
      LOWORD(v14) = 0x8000;
    }
    int8x16_t v15 = (_WORD *)(v6 + v3);
    *(_WORD *)(v6 + v3 - 8) = v14;
    int v16 = (v4 + 74 * (*(v5 - 1) + *(v5 - 2) - v5[1])) >> a3;
    if (v16 >= 0x7FFF) {
      int v16 = 0x7FFF;
    }
    if (v16 <= -32768) {
      LOWORD(v16) = 0x8000;
    }
    *int8x16_t v15 = v16;
    int v17 = (v4 + 55 * v9 + 29 * v12 - v13) >> a3;
    if (v17 >= 0x7FFF) {
      int v17 = 0x7FFF;
    }
    if (v17 <= -32768) {
      LOWORD(v17) = 0x8000;
    }
    void v15[4] = v17;
    LODWORD(result) = (v13 + v4 + 55 * v12 - 29 * v11) >> a3;
    if ((int)result >= 0x7FFF) {
      LODWORD(result) = 0x7FFF;
    }
    if ((int)result <= -32768) {
      uint64_t result = 4294934528;
    }
    else {
      uint64_t result = result;
    }
    v15[8] = result;
    v3 += 2;
    v5 += 4;
  }
  while (v3 != 8);
  return result;
}

uint64_t sub_1BBA207E8(uint64_t a1)
{
  v3[65] = *MEMORY[0x1E4F143B8];
  sub_1BBA1F9EC((uint64_t)v3, a1, 4);
  return sub_1BBA1F9EC(a1, (uint64_t)v3, 10);
}

double sub_1BBA2085C(uint64_t a1)
{
  v3[17] = *MEMORY[0x1E4F143B8];
  sub_1BBA1FB60((uint64_t)v3, a1, 3);
  *(void *)&double result = sub_1BBA1FB60(a1, (uint64_t)v3, 9).u64[0];
  return result;
}

uint64_t sub_1BBA208D0(uint64_t a1)
{
  v3[5] = *MEMORY[0x1E4F143B8];
  sub_1BBA1FCA4((uint64_t)v3, a1, 2);
  return sub_1BBA1FCA4(a1, (uint64_t)v3, 8);
}

_WORD *sub_1BBA20944(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int16x8_t *a5)
{
  uint64_t v6 = 0;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v7 = a5;
  do
  {
    for (uint64_t i = 0; i != 32; ++i)
      v7->i16[i] = *(_WORD *)(a1 + i * 2) - *(_WORD *)(a3 + i * 2);
    ++v6;
    v7 += 4;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 32);
  sub_1BBA1F708(v10, a5, 5);
  return sub_1BBA1F708(a5, v10, 11);
}

uint64_t sub_1BBA20A00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = 0;
  v10[65] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a5;
  do
  {
    for (uint64_t i = 0; i != 32; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 32;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 16);
  sub_1BBA1F9EC((uint64_t)v10, a5, 4);
  return sub_1BBA1F9EC(a5, (uint64_t)v10, 10);
}

double sub_1BBA20ABC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = 0;
  v10[17] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a5;
  do
  {
    for (uint64_t i = 0; i != 16; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 16;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 8);
  sub_1BBA1FB60((uint64_t)v10, a5, 3);
  *(void *)&double result = sub_1BBA1FB60(a5, (uint64_t)v10, 9).u64[0];
  return result;
}

uint64_t sub_1BBA20B78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = 0;
  v10[5] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a5;
  do
  {
    for (uint64_t i = 0; i != 8; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 8;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 4);
  sub_1BBA1FCA4((uint64_t)v10, a5, 2);
  return sub_1BBA1FCA4(a5, (uint64_t)v10, 8);
}

uint64_t sub_1BBA20C34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = 0;
  v10[5] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a5;
  do
  {
    for (uint64_t i = 0; i != 8; i += 2)
      *(_WORD *)(v7 + i) = *(_WORD *)(a1 + i) - *(_WORD *)(a3 + i);
    ++v6;
    v7 += 8;
    a3 += 2 * a4;
    a1 += 2 * a2;
  }
  while (v6 != 4);
  sub_1BBA206E0((uint64_t)v10, a5, 2);
  return sub_1BBA206E0(a5, (uint64_t)v10, 8);
}

uint64_t sub_1BBA20CF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, char a9)
{
  if (a9)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a7 + 192))(a2, a3, a4, a5, a6);
    uint64_t v11 = *(uint64_t (**)(uint64_t))(a1 + 136);
    return v11(a6);
  }
  else
  {
    if (a8 == 1) {
      int v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 48);
    }
    else {
      int v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a7 + 40);
    }
    return v13(a2, a3, a4, a5, a6);
  }
}

uint64_t sub_1BBA20D9C(void *a1, int a2, int a3, int a4)
{
  switch(a2)
  {
    case 8:
      uint64_t result = 0;
      if (a4) {
        int v9 = sub_1BBA26470;
      }
      else {
        int v9 = sub_1BBA26280;
      }
      int v10 = sub_1BBA25DB4;
      if (a4) {
        int v10 = sub_1BBA25FEC;
      }
      *a1 = v9;
      a1[1] = v10;
      a1[50] = sub_1BBA25D14;
      a1[51] = sub_1BBA25C20;
      a1[2] = sub_1BBA521D4;
      a1[3] = sub_1BBA520EC;
      uint64_t v11 = sub_1BBA51E94;
      if (a3) {
        uint64_t v11 = sub_1BBA5202C;
      }
      a1[4] = v11;
      a1[5] = sub_1BBA51DE8;
      a1[6] = sub_1BBA51C8C;
      a1[7] = sub_1BBA51878;
      a1[8] = sub_1BBA51458;
      a1[9] = sub_1BBA50C78;
      a1[10] = sub_1BBA50C30;
      a1[11] = sub_1BBA50B54;
      a1[12] = sub_1BBA509E8;
      a1[13] = sub_1BBA509C8;
      a1[14] = sub_1BBA509A0;
      a1[15] = sub_1BBA50954;
      a1[16] = sub_1BBA508D8;
      a1[17] = sub_1BBA507E8;
      a1[18] = sub_1BBA5071C;
      a1[19] = sub_1BBA50624;
      a1[20] = sub_1BBA505BC;
      a1[21] = sub_1BBA50500;
      a1[22] = sub_1BBA50368;
      a1[23] = sub_1BBA5030C;
      a1[24] = sub_1BBA50284;
      a1[25] = sub_1BBA4FFEC;
      a1[26] = sub_1BBA4FF38;
      a1[27] = sub_1BBA4FB80;
      a1[28] = sub_1BBA4F70C;
      a1[29] = sub_1BBA4EA7C;
      a1[30] = sub_1BBA4E9C4;
      a1[31] = sub_1BBA4E7C0;
      a1[32] = sub_1BBA4E520;
      a1[33] = sub_1BBA4E070;
      a1[34] = sub_1BBA4E050;
      a1[35] = sub_1BBA4E034;
      a1[36] = sub_1BBA4E014;
      a1[37] = sub_1BBA4DFEC;
      a1[38] = sub_1BBA4DFBC;
      a1[39] = sub_1BBA4DF5C;
      a1[40] = sub_1BBA4DE8C;
      a1[41] = sub_1BBA4DD9C;
      a1[42] = sub_1BBA4DD58;
      a1[43] = sub_1BBA4DD10;
      a1[44] = sub_1BBA4DCA4;
      a1[45] = sub_1BBA4DC04;
      a1[46] = sub_1BBA4DB54;
      a1[47] = sub_1BBA4D804;
      a1[48] = sub_1BBA4D420;
      a1[49] = sub_1BBA4CA98;
      break;
    case 10:
      uint64_t result = 0;
      if (a4) {
        int v12 = sub_1BBA248C0;
      }
      else {
        int v12 = sub_1BBA24684;
      }
      int v13 = sub_1BBA241BC;
      if (a4) {
        int v13 = sub_1BBA243F4;
      }
      *a1 = v12;
      a1[1] = v13;
      a1[9] = sub_1BBA23DD0;
      a1[50] = sub_1BBA21940;
      a1[51] = sub_1BBA2184C;
      a1[2] = sub_1BBA4CA10;
      a1[3] = sub_1BBA4C94C;
      int v14 = sub_1BBA4C7D4;
      if (a3) {
        int v14 = sub_1BBA4C898;
      }
      a1[20] = sub_1BBA4C75C;
      a1[21] = sub_1BBA4C680;
      a1[22] = sub_1BBA4C51C;
      a1[23] = sub_1BBA4C4BC;
      a1[24] = sub_1BBA4C420;
      a1[4] = v14;
      a1[5] = sub_1BBA4C388;
      a1[6] = sub_1BBA4C2F0;
      a1[7] = sub_1BBA4C250;
      a1[8] = sub_1BBA4C150;
      a1[25] = sub_1BBA4BFC4;
      a1[26] = sub_1BBA4BD48;
      a1[27] = sub_1BBA4BA20;
      a1[28] = sub_1BBA4B648;
      a1[29] = sub_1BBA4B240;
      a1[10] = sub_1BBA4B1D8;
      a1[11] = sub_1BBA4B104;
      a1[12] = sub_1BBA4B054;
      a1[13] = sub_1BBA4B028;
      a1[14] = sub_1BBA4AFEC;
      a1[15] = sub_1BBA4AF90;
      a1[16] = sub_1BBA4AEF8;
      a1[17] = sub_1BBA4AE78;
      a1[18] = sub_1BBA4AE48;
      a1[19] = sub_1BBA4AE10;
      a1[42] = sub_1BBA4ADD4;
      a1[43] = sub_1BBA4AD88;
      a1[44] = sub_1BBA4AD2C;
      a1[45] = sub_1BBA4ACA0;
      a1[30] = sub_1BBA4ABF0;
      a1[31] = sub_1BBA4AB50;
      a1[32] = sub_1BBA4AA50;
      a1[33] = sub_1BBA4A944;
      a1[46] = sub_1BBA4A738;
      a1[47] = sub_1BBA4A430;
      a1[48] = sub_1BBA4A0E0;
      a1[49] = sub_1BBA49D68;
      a1[34] = sub_1BBA49D40;
      a1[35] = sub_1BBA49D10;
      a1[36] = sub_1BBA49CE4;
      a1[37] = sub_1BBA49CA8;
      a1[38] = sub_1BBA49C68;
      a1[39] = sub_1BBA49C28;
      a1[40] = sub_1BBA49BF8;
      a1[41] = sub_1BBA49BC0;
      break;
    case 9:
      uint64_t result = 0;
      if (a4) {
        uint64_t v6 = sub_1BBA258F8;
      }
      else {
        uint64_t v6 = sub_1BBA256BC;
      }
      uint64_t v7 = sub_1BBA251F4;
      if (a4) {
        uint64_t v7 = sub_1BBA2542C;
      }
      *a1 = v6;
      a1[1] = v7;
      a1[2] = sub_1BBA24128;
      a1[3] = sub_1BBA24094;
      int v8 = sub_1BBA24000;
      if (a3) {
        int v8 = sub_1BBA250BC;
      }
      a1[4] = v8;
      a1[5] = sub_1BBA23F90;
      a1[6] = sub_1BBA23F20;
      a1[7] = sub_1BBA23EB0;
      a1[8] = sub_1BBA23E40;
      a1[9] = sub_1BBA23DD0;
      a1[10] = sub_1BBA2505C;
      a1[11] = sub_1BBA24FFC;
      a1[12] = sub_1BBA24F9C;
      a1[13] = sub_1BBA24F70;
      a1[14] = sub_1BBA24F34;
      a1[15] = sub_1BBA24EC8;
      a1[16] = sub_1BBA24E5C;
      a1[17] = sub_1BBA24DEC;
      a1[18] = sub_1BBA24DB4;
      a1[19] = sub_1BBA24D7C;
      a1[20] = sub_1BBA23D28;
      a1[21] = sub_1BBA23C78;
      a1[22] = sub_1BBA23BAC;
      a1[23] = sub_1BBA23B30;
      a1[24] = sub_1BBA23AB4;
      a1[25] = sub_1BBA2381C;
      a1[26] = sub_1BBA23574;
      a1[27] = sub_1BBA2329C;
      a1[28] = sub_1BBA22F6C;
      a1[29] = sub_1BBA22C20;
      a1[30] = sub_1BBA22B78;
      a1[31] = sub_1BBA22AD0;
      a1[32] = sub_1BBA22A28;
      a1[33] = sub_1BBA22980;
      a1[34] = sub_1BBA2295C;
      a1[35] = sub_1BBA22938;
      a1[36] = sub_1BBA2290C;
      a1[37] = sub_1BBA228D0;
      a1[38] = sub_1BBA228A4;
      a1[39] = sub_1BBA22874;
      a1[40] = sub_1BBA22838;
      a1[41] = sub_1BBA227FC;
      a1[42] = sub_1BBA22798;
      a1[43] = sub_1BBA22724;
      a1[44] = sub_1BBA22670;
      a1[45] = sub_1BBA225A8;
      a1[46] = sub_1BBA222F4;
      a1[47] = sub_1BBA22014;
      a1[48] = sub_1BBA21D08;
      a1[49] = sub_1BBA219E0;
      a1[50] = sub_1BBA24CDC;
      a1[51] = sub_1BBA24BE8;
      break;
    default:
      return 4294954386;
  }
  return result;
}

uint64_t sub_1BBA2184C(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 >= 1)
  {
    uint64_t v5 = a5;
    uint64_t v8 = result;
    int v9 = 0;
    uint64_t v10 = a5 + 2;
    uint64_t v17 = a2;
    char v11 = 10 - a3;
    uint64_t v12 = 4 * a2;
    uint64_t v13 = 2 * a4;
    do
    {
      uint64_t v14 = 0;
      do
      {
        *(_WORD *)(v5 + v14) = sub_1BBA196DC(v8, a3) << v11;
        v14 += 4;
      }
      while (v12 != v14);
      ++v9;
      v5 += v13;
    }
    while (v9 != a2);
    int v15 = 0;
    do
    {
      uint64_t v16 = 0;
      do
      {
        uint64_t result = sub_1BBA196DC(v8, a3);
        *(_WORD *)(v10 + v16) = result << v11;
        v16 += 4;
      }
      while (4 * v17 != v16);
      ++v15;
      v10 += v13;
    }
    while (v15 != a2);
  }
  return result;
}

uint64_t sub_1BBA21940(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 >= 1)
  {
    uint64_t v8 = result;
    int v9 = 0;
    char v10 = 10 - a3;
    uint64_t v11 = 2 * a2;
    uint64_t v12 = 2 * a4;
    do
    {
      uint64_t v13 = 0;
      do
      {
        uint64_t result = sub_1BBA196DC(v8, a3);
        *(_WORD *)(a5 + v13) = result << v10;
        v13 += 2;
      }
      while (v11 != v13);
      ++v9;
      a5 += v12;
    }
    while (v9 != a2);
  }
  return result;
}

void *sub_1BBA219E0(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = (int)result;
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  int v7 = byte_1BBB795E8[(int)result];
  uint64_t v8 = byte_1BBB795E8[(int)result];
  unint64_t v9 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v9 >= 0xF)
    {
      uint64_t result = memcpy(v53, (const void *)(a2 - 4), 0x104uLL);
    }
    else
    {
      int v18 = word_1BBB79710[(int)result - 11];
      if ((int)v8 < 0) {
        int v19 = -1;
      }
      else {
        int v19 = byte_1BBB795E8[(int)result];
      }
      uint64_t v20 = v19 - v8 + 1;
      int32x4_t v21 = &v52[2 * v8 + 64];
      int v22 = v8 * v18 + 128;
      do
      {
        signed int v23 = ((v22 >> 7) & 0xFFFFFFFE) + 126;
        if (v22 < 0x100) {
          signed int v23 = -2;
        }
        *v21++ = *(_DWORD *)(a2 + 2 * v23);
        v22 += v18;
        --v20;
      }
      while (v20);
      long long v24 = *(_OWORD *)(a2 + 76);
      long long v25 = *(_OWORD *)(a2 + 108);
      v53[6] = *(_OWORD *)(a2 + 92);
      v53[7] = v25;
      LODWORD(v53[8]) = *(_DWORD *)(a2 + 124);
      long long v26 = *(_OWORD *)(a2 + 12);
      long long v27 = *(_OWORD *)(a2 + 44);
      void v53[2] = *(_OWORD *)(a2 + 28);
      v53[3] = v27;
      v53[4] = *(_OWORD *)(a2 + 60);
      v53[5] = v24;
      v53[0] = *(_OWORD *)(a2 - 4);
      v53[1] = v26;
    }
  }
  else if (v9 >= 0xF)
  {
    uint64_t v28 = 126;
    unint64_t v29 = v53;
    do
    {
      if (v28 == 126) {
        uint64_t v30 = -2;
      }
      else {
        uint64_t v30 = v28;
      }
      *v29++ = *(_DWORD *)(a2 + 2 * v30);
      v28 += 2;
    }
    while (v28 != 256);
  }
  else
  {
    int v10 = word_1BBB79710[result - 11];
    if ((int)v8 < 0) {
      int v11 = -1;
    }
    else {
      int v11 = byte_1BBB795E8[(int)result];
    }
    uint64_t v12 = v11 - v8 + 1;
    uint64_t v13 = &v52[2 * v8 + 64];
    int v14 = v7 * v10 + 128;
    do
    {
      *v13++ = *(_DWORD *)(a2 + 2 * (int)(((v14 >> 7) & 0xFFFFFFFE) - 2));
      v14 += v10;
      --v12;
    }
    while (v12);
    uint64_t v15 = 126;
    uint64_t v16 = v53;
    do
    {
      if (v15 == 126) {
        uint64_t v17 = -2;
      }
      else {
        uint64_t v17 = v15;
      }
      *v16++ = *(_DWORD *)(a2 + 2 * v17);
      v15 += 2;
    }
    while (v15 != 192);
  }
  uint64_t v31 = 0;
  uint64_t v32 = a4;
  do
  {
    uint64_t v33 = v31 + 1;
    int v34 = (v31 + 1) * v7;
    int v35 = v34 >> 5;
    unsigned int v36 = v34 & 0x1F;
    if (v36)
    {
      uint64_t v37 = 0;
      int16x8_t v38 = &v52[2 * v35];
      do
      {
        uint64_t result = &v38[v37];
        uint16x8_t v39 = (uint16x8_t)vdupq_n_s16(32 - v36);
        uint16x8_t v40 = (uint16x8_t)vdupq_n_s16(v36);
        *(int16x8_t *)(v32 + v37 * 2) = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v39.i8, *(uint16x4_t *)&v38[v37 + 66]), *(uint16x4_t *)v40.i8, *(uint16x4_t *)&v38[v37 + 68]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v39, *(uint16x8_t *)&v38[v37 + 66]), v40, *(uint16x8_t *)&v38[v37 + 68]), 5uLL);
        v37 += 8;
      }
      while (v37 != 64);
    }
    else
    {
      unint64_t v41 = (_OWORD *)((char *)v53 + 4 * v35 + 4);
      long long v42 = v41[5];
      uint64_t v43 = (_OWORD *)(a4 + 2 * v31 * a3);
      unsigned char v43[4] = v41[4];
      v43[5] = v42;
      long long v44 = v41[7];
      v43[6] = v41[6];
      v43[7] = v44;
      long long v45 = v41[1];
      *uint64_t v43 = *v41;
      v43[1] = v45;
      long long v46 = v41[3];
      v43[2] = v41[2];
      v43[3] = v46;
    }
    v32 += 2 * a3;
    uint64_t v31 = v33;
  }
  while (v33 != 32);
  if (v6 <= 17)
  {
    uint64_t v47 = 0;
    uint64_t v48 = 4 * (a3 >> 1);
    do
    {
      uint64_t v49 = 4 * (a3 >> 1);
      uint64_t v50 = 1;
      do
      {
        int v51 = *(_DWORD *)(a4 + 4 * v50);
        *(_DWORD *)(a4 + 4 * v50) = *(_DWORD *)(a4 + v49);
        *(_DWORD *)(a4 + v49) = v51;
        ++v50;
        v49 += v48;
      }
      while (v47 + v50 != 32);
      ++v47;
      a4 += v48 + 4;
    }
    while (v47 != 31);
  }
  return result;
}

uint64_t sub_1BBA21D08(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  int v4 = byte_1BBB795E8[(int)result];
  unint64_t v5 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v5 >= 0xF)
    {
      long long v27 = *(_OWORD *)(a2 + 76);
      long long v28 = *(_OWORD *)(a2 + 108);
      long long v57 = *(_OWORD *)(a2 + 92);
      long long v58 = v28;
      int v59 = *(_DWORD *)(a2 + 124);
      long long v29 = *(_OWORD *)(a2 + 12);
      long long v30 = *(_OWORD *)(a2 + 44);
      long long v53 = *(_OWORD *)(a2 + 28);
      long long v54 = v30;
      long long v55 = *(_OWORD *)(a2 + 60);
      long long v56 = v27;
      long long v51 = *(_OWORD *)(a2 - 4);
      long long v52 = v29;
    }
    else
    {
      int v15 = v4 >> 1;
      int v16 = word_1BBB79710[(int)result - 11];
      if (v4 >> 1 < 0) {
        int v17 = -1;
      }
      else {
        int v17 = v4 >> 1;
      }
      uint64_t v18 = v17 - (uint64_t)v15 + 1;
      int v19 = &v50[2 * v15 + 32];
      int v20 = v16 * v15 + 128;
      do
      {
        signed int v21 = ((v20 >> 7) & 0xFFFFFFFE) + 62;
        if (v20 < 0x100) {
          signed int v21 = -2;
        }
        *v19++ = *(_DWORD *)(a2 + 2 * v21);
        v20 += v16;
        --v18;
      }
      while (v18);
      long long v22 = *(_OWORD *)(a2 + 12);
      long long v23 = *(_OWORD *)(a2 + 44);
      long long v53 = *(_OWORD *)(a2 + 28);
      long long v54 = v23;
      LODWORD(v55) = *(_DWORD *)(a2 + 60);
      long long v51 = *(_OWORD *)(a2 - 4);
      long long v52 = v22;
    }
  }
  else if (v5 >= 0xF)
  {
    uint64_t v24 = 62;
    long long v25 = &v51;
    do
    {
      if (v24 == 62) {
        uint64_t v26 = -2;
      }
      else {
        uint64_t v26 = v24;
      }
      *(_DWORD *)long long v25 = *(_DWORD *)(a2 + 2 * v26);
      long long v25 = (long long *)((char *)v25 + 4);
      v24 += 2;
    }
    while (v24 != 128);
  }
  else
  {
    int v6 = v4 >> 1;
    int v7 = word_1BBB79710[(result - 11)];
    if (v4 >> 1 < 0) {
      int v8 = -1;
    }
    else {
      int v8 = v4 >> 1;
    }
    uint64_t v9 = v8 - (uint64_t)v6 + 1;
    int v10 = &v50[2 * v6 + 32];
    int v11 = v7 * v6 + 128;
    do
    {
      *v10++ = *(_DWORD *)(a2 + 2 * (int)(((v11 >> 7) & 0xFFFFFFFE) - 2));
      v11 += v7;
      --v9;
    }
    while (v9);
    uint64_t v12 = 62;
    uint64_t v13 = &v51;
    do
    {
      if (v12 == 62) {
        uint64_t v14 = -2;
      }
      else {
        uint64_t v14 = v12;
      }
      *(_DWORD *)uint64_t v13 = *(_DWORD *)(a2 + 2 * v14);
      uint64_t v13 = (long long *)((char *)v13 + 4);
      v12 += 2;
    }
    while (v12 != 96);
  }
  uint64_t v31 = 0;
  uint64_t v32 = a4;
  do
  {
    uint64_t v33 = v31 + 1;
    int v34 = (v31 + 1) * v4;
    int v35 = v34 >> 5;
    unsigned int v36 = v34 & 0x1F;
    if (v36)
    {
      for (uint64_t i = 0; i != 32; i += 8)
      {
        uint16x8_t v39 = (uint16x8_t)vdupq_n_s16(32 - v36);
        uint16x8_t v40 = (uint16x8_t)vdupq_n_s16(v36);
        int16x8_t v38 = &v50[2 * v35];
        *(int16x8_t *)(v32 + i * 2) = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v39.i8, *(uint16x4_t *)&v38[i + 34]), *(uint16x4_t *)v40.i8, *(uint16x4_t *)&v38[i + 36]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v39, *(uint16x8_t *)&v38[i + 34]), v40, *(uint16x8_t *)&v38[i + 36]), 5uLL);
      }
    }
    else
    {
      unint64_t v41 = (_OWORD *)(a4 + 2 * v31 * a3);
      long long v42 = (long long *)((char *)&v51 + 4 * v35 + 4);
      long long v43 = v42[1];
      *unint64_t v41 = *v42;
      v41[1] = v43;
      long long v44 = v42[3];
      v41[2] = v42[2];
      v41[3] = v44;
    }
    v32 += 2 * a3;
    uint64_t v31 = v33;
  }
  while (v33 != 16);
  if ((int)result <= 17)
  {
    uint64_t v45 = 0;
    uint64_t v46 = 4 * (a3 >> 1);
    do
    {
      uint64_t v47 = 4 * (a3 >> 1);
      uint64_t v48 = 1;
      do
      {
        int v49 = *(_DWORD *)(a4 + 4 * v48);
        *(_DWORD *)(a4 + 4 * v48) = *(_DWORD *)(a4 + v47);
        *(_DWORD *)(a4 + v47) = v49;
        ++v48;
        v47 += v46;
      }
      while (v45 + v48 != 16);
      ++v45;
      a4 += v46 + 4;
    }
    while (v45 != 15);
  }
  return result;
}

uint64_t sub_1BBA22014(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  int v4 = byte_1BBB795E8[(int)result];
  unint64_t v5 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v5 >= 0xF)
    {
      long long v26 = *(_OWORD *)(a2 + 12);
      long long v27 = *(_OWORD *)(a2 + 44);
      long long v50 = *(_OWORD *)(a2 + 28);
      long long v51 = v27;
      int v52 = *(_DWORD *)(a2 + 60);
      long long v48 = *(_OWORD *)(a2 - 4);
      long long v49 = v26;
    }
    else
    {
      int v15 = v4 >> 2;
      int v16 = word_1BBB79710[(int)result - 11];
      if (v4 >> 2 < 0) {
        int v17 = -1;
      }
      else {
        int v17 = v4 >> 2;
      }
      uint64_t v18 = v17 - (uint64_t)v15 + 1;
      int v19 = &v47[2 * v15 + 16];
      int v20 = v16 * v15 + 128;
      do
      {
        signed int v21 = ((v20 >> 7) & 0xFFFFFFFE) + 30;
        if (v20 < 0x100) {
          signed int v21 = -2;
        }
        *v19++ = *(_DWORD *)(a2 + 2 * v21);
        v20 += v16;
        --v18;
      }
      while (v18);
      long long v22 = *(_OWORD *)(a2 + 12);
      long long v48 = *(_OWORD *)(a2 - 4);
      long long v49 = v22;
      LODWORD(v50) = *(_DWORD *)(a2 + 28);
    }
  }
  else if (v5 >= 0xF)
  {
    uint64_t v23 = 30;
    uint64_t v24 = &v48;
    do
    {
      if (v23 == 30) {
        uint64_t v25 = -2;
      }
      else {
        uint64_t v25 = v23;
      }
      *(_DWORD *)uint64_t v24 = *(_DWORD *)(a2 + 2 * v25);
      uint64_t v24 = (long long *)((char *)v24 + 4);
      v23 += 2;
    }
    while (v23 != 64);
  }
  else
  {
    int v6 = v4 >> 2;
    int v7 = word_1BBB79710[(result - 11)];
    if (v4 >> 2 < 0) {
      int v8 = -1;
    }
    else {
      int v8 = v4 >> 2;
    }
    uint64_t v9 = v8 - (uint64_t)v6 + 1;
    int v10 = &v47[2 * v6 + 16];
    int v11 = v7 * v6 + 128;
    do
    {
      *v10++ = *(_DWORD *)(a2 + 2 * (int)(((v11 >> 7) & 0xFFFFFFFE) - 2));
      v11 += v7;
      --v9;
    }
    while (v9);
    uint64_t v12 = 30;
    uint64_t v13 = &v48;
    do
    {
      if (v12 == 30) {
        uint64_t v14 = -2;
      }
      else {
        uint64_t v14 = v12;
      }
      *(_DWORD *)uint64_t v13 = *(_DWORD *)(a2 + 2 * v14);
      uint64_t v13 = (long long *)((char *)v13 + 4);
      v12 += 2;
    }
    while (v12 != 48);
  }
  uint64_t v28 = 0;
  uint64_t v29 = a4;
  do
  {
    uint64_t v30 = v28 + 1;
    int v31 = (v28 + 1) * v4;
    int v32 = v31 >> 5;
    unsigned int v33 = v31 & 0x1F;
    if (v33)
    {
      for (uint64_t i = 0; i != 16; i += 8)
      {
        uint16x8_t v36 = (uint16x8_t)vdupq_n_s16(32 - v33);
        uint16x8_t v37 = (uint16x8_t)vdupq_n_s16(v33);
        int v35 = &v47[2 * v32];
        *(int16x8_t *)(v29 + i * 2) = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v36.i8, *(uint16x4_t *)&v35[i + 18]), *(uint16x4_t *)v37.i8, *(uint16x4_t *)&v35[i + 20]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v36, *(uint16x8_t *)&v35[i + 18]), v37, *(uint16x8_t *)&v35[i + 20]), 5uLL);
      }
    }
    else
    {
      uint64_t v38 = v28 * a3;
      uint16x8_t v39 = (long long *)((char *)&v48 + 4 * v32 + 4);
      long long v40 = v39[1];
      unint64_t v41 = (_OWORD *)(a4 + 2 * v38);
      *unint64_t v41 = *v39;
      v41[1] = v40;
    }
    v29 += 2 * a3;
    uint64_t v28 = v30;
  }
  while (v30 != 8);
  if ((int)result <= 17)
  {
    uint64_t v42 = 0;
    uint64_t v43 = 4 * (a3 >> 1);
    do
    {
      uint64_t v44 = 4 * (a3 >> 1);
      uint64_t v45 = 1;
      do
      {
        int v46 = *(_DWORD *)(a4 + 4 * v45);
        *(_DWORD *)(a4 + 4 * v45) = *(_DWORD *)(a4 + v44);
        *(_DWORD *)(a4 + v44) = v46;
        ++v45;
        v44 += v43;
      }
      while (v42 + v45 != 8);
      ++v42;
      a4 += v43 + 4;
    }
    while (v42 != 7);
  }
  return result;
}

uint64_t sub_1BBA222F4(uint64_t result, uint64_t a2, uint64_t a3, int16x8_t *a4)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  int v4 = byte_1BBB795E8[(int)result];
  unint64_t v5 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v5 >= 0xF)
    {
      long long v25 = *(_OWORD *)(a2 + 12);
      long long v46 = *(_OWORD *)(a2 - 4);
      long long v47 = v25;
      int v48 = *(_DWORD *)(a2 + 28);
    }
    else
    {
      int v15 = v4 >> 3;
      int v16 = word_1BBB79710[(int)result - 11];
      if (v4 >> 3 < 0) {
        int v17 = -1;
      }
      else {
        int v17 = v4 >> 3;
      }
      uint64_t v18 = v17 - (uint64_t)v15 + 1;
      int v19 = &v45[v15 + 4];
      int v20 = v16 * v15 + 128;
      do
      {
        signed int v21 = ((v20 >> 7) & 0xFFFFFFFE) + 14;
        if (v20 < 0x100) {
          signed int v21 = -2;
        }
        *v19++ = *(_DWORD *)(a2 + 2 * v21);
        v20 += v16;
        --v18;
      }
      while (v18);
      long long v46 = *(_OWORD *)(a2 - 4);
      LODWORD(v47) = *(_DWORD *)(a2 + 12);
    }
  }
  else if (v5 >= 0xF)
  {
    uint64_t v22 = 14;
    uint64_t v23 = &v46;
    do
    {
      if (v22 == 14) {
        uint64_t v24 = -2;
      }
      else {
        uint64_t v24 = v22;
      }
      *(_DWORD *)uint64_t v23 = *(_DWORD *)(a2 + 2 * v24);
      uint64_t v23 = (long long *)((char *)v23 + 4);
      v22 += 2;
    }
    while (v22 != 32);
  }
  else
  {
    int v6 = v4 >> 3;
    int v7 = word_1BBB79710[(result - 11)];
    if (v4 >> 3 < 0) {
      int v8 = -1;
    }
    else {
      int v8 = v4 >> 3;
    }
    uint64_t v9 = v8 - (uint64_t)v6 + 1;
    int v10 = &v45[v6 + 4];
    int v11 = v7 * v6 + 128;
    do
    {
      *v10++ = *(_DWORD *)(a2 + 2 * (int)(((v11 >> 7) & 0xFFFFFFFE) - 2));
      v11 += v7;
      --v9;
    }
    while (v9);
    uint64_t v12 = 14;
    uint64_t v13 = &v46;
    do
    {
      if (v12 == 14) {
        uint64_t v14 = -2;
      }
      else {
        uint64_t v14 = v12;
      }
      *(_DWORD *)uint64_t v13 = *(_DWORD *)(a2 + 2 * v14);
      uint64_t v13 = (long long *)((char *)v13 + 4);
      v12 += 2;
    }
    while (v12 != 24);
  }
  uint64_t v26 = 4;
  int v27 = v4;
  uint64_t v28 = a4;
  do
  {
    int v29 = v27 >> 5;
    unsigned int v30 = v27 & 0x1F;
    if ((v27 & 0x1F) != 0)
    {
      uint16x8_t v31 = (uint16x8_t)vdupq_n_s16(32 - v30);
      uint16x8_t v32 = *(uint16x8_t *)((char *)&v46 + 4 * v29 + 4);
      uint32x4_t v33 = vmull_u16(*(uint16x4_t *)v31.i8, *(uint16x4_t *)v32.i8);
      uint32x4_t v34 = vmull_high_u16(v31, v32);
      uint16x8_t v35 = (uint16x8_t)vdupq_n_s16(v30);
      uint16x8_t v36 = *(uint16x8_t *)((char *)&v46 + 4 * v29 + 8);
      *uint64_t v28 = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(v33, *(uint16x4_t *)v35.i8, *(uint16x4_t *)v36.i8), 5uLL), (int32x4_t)vmlal_high_u16(v34, v35, v36), 5uLL);
    }
    else
    {
      *uint64_t v28 = *(int16x8_t *)((char *)&v46 + 4 * v29 + 4);
    }
    uint64_t v28 = (int16x8_t *)((char *)v28 + 2 * a3);
    v27 += v4;
    --v26;
  }
  while (v26);
  if ((int)result <= 17)
  {
    uint64_t v37 = 0;
    uint64_t v38 = 4 * (a3 >> 1);
    uint16x8_t v39 = &a4->i32[(unint64_t)v38 / 4];
    uint64_t v40 = v38 + 4;
    unint64_t v41 = &a4->i8[4];
    do
    {
      uint64_t v42 = 0;
      uint64_t v43 = v39;
      do
      {
        int v44 = *(_DWORD *)&v41[4 * v42];
        *(_DWORD *)&v41[4 * v42] = *v43;
        *uint64_t v43 = v44;
        ++v42;
        uint64_t v43 = (__int32 *)((char *)v43 + v38);
      }
      while (v37 + v42 != 3);
      ++v37;
      uint16x8_t v39 = (__int32 *)((char *)v39 + v40);
      v41 += v40;
    }
    while (v37 != 3);
  }
  return result;
}

__n128 sub_1BBA225A8(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v4 = 0;
  int32x4_t v5 = (int32x4_t)xmmword_1BBB6F670;
  int32x4_t v6 = 0uLL;
  int32x4_t v7 = (int32x4_t)xmmword_1BBB6F670;
  int32x4_t v8 = 0uLL;
  do
  {
    uint64_t v9 = (const __int16 *)(a2 + v4);
    int v10 = (const __int16 *)(a2 + v4 + 256);
    int16x8x2_t v22 = vld2q_s16(v10);
    int16x8x2_t v23 = vld2q_s16(v9);
    int32x4_t v6 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v6, (uint16x8_t)v22.val[0]), (uint16x8_t)v23.val[0]);
    int32x4_t v5 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v22.val[0].i8), *(uint16x4_t *)v23.val[0].i8);
    int32x4_t v8 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v8, (uint16x8_t)v22.val[1]), (uint16x8_t)v23.val[1]);
    int32x4_t v7 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v7, *(uint16x4_t *)v22.val[1].i8), *(uint16x4_t *)v23.val[1].i8);
    v4 += 32;
  }
  while (v4 != 128);
  uint64_t v11 = 0;
  int32x4_t v12 = vdupq_n_s32((vaddvq_s32(vaddq_s32(v7, v8)) << 10) & 0xFFFF0000 | (unsigned __int16)(vaddvq_s32(vaddq_s32(v5, v6)) >> 6));
  do
    a4[v11++] = (__int128)v12;
  while (v11 != 8);
  uint64_t v13 = 2 * a3;
  int v14 = 31;
  do
  {
    uint64_t v15 = (uint64_t)a4 + v13;
    long long v16 = *a4;
    long long v17 = a4[1];
    long long v18 = a4[3];
    *(_OWORD *)(v15 + 32) = a4[2];
    *(_OWORD *)(v15 + 48) = v18;
    *(_OWORD *)uint64_t v15 = v16;
    *(_OWORD *)(v15 + 16) = v17;
    __n128 result = (__n128)a4[4];
    long long v20 = a4[5];
    long long v21 = a4[7];
    *(_OWORD *)(v15 + 96) = a4[6];
    *(_OWORD *)(v15 + 112) = v21;
    *(__n128 *)(v15 + 64) = result;
    *(_OWORD *)(v15 + 80) = v20;
    a4 = (long long *)((char *)a4 + v13);
    --v14;
  }
  while (v14);
  return result;
}

__n128 sub_1BBA22670(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  int32x4_t v5 = (int32x4_t)xmmword_1BBB6F680;
  int32x4_t v6 = 0uLL;
  int32x4_t v7 = (int32x4_t)xmmword_1BBB6F680;
  int32x4_t v8 = 0uLL;
  do
  {
    uint64_t v9 = (const __int16 *)(a2 + v4);
    int v10 = (const __int16 *)(a2 + v4 + 128);
    int16x8x2_t v18 = vld2q_s16(v10);
    int16x8x2_t v19 = vld2q_s16(v9);
    int32x4_t v6 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v6, (uint16x8_t)v18.val[0]), (uint16x8_t)v19.val[0]);
    int32x4_t v5 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v18.val[0].i8), *(uint16x4_t *)v19.val[0].i8);
    int32x4_t v8 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v8, (uint16x8_t)v18.val[1]), (uint16x8_t)v19.val[1]);
    int32x4_t v7 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v7, *(uint16x4_t *)v18.val[1].i8), *(uint16x4_t *)v19.val[1].i8);
    v4 += 32;
  }
  while (v4 != 64);
  uint64_t v11 = 0;
  int32x4_t v12 = vdupq_n_s32((vaddvq_s32(vaddq_s32(v7, v8)) << 11) & 0xFFFF0000 | (unsigned __int16)(vaddvq_s32(vaddq_s32(v5, v6)) >> 5));
  do
  {
    *(int32x4_t *)(a4 + v11) = v12;
    v11 += 16;
  }
  while (v11 != 64);
  int v13 = 15;
  do
  {
    __n128 result = *(__n128 *)a4;
    long long v15 = *(_OWORD *)(a4 + 16);
    long long v16 = *(_OWORD *)(a4 + 32);
    long long v17 = *(_OWORD *)(a4 + 48);
    a4 += 2 * a3;
    *(_OWORD *)(a4 + 32) = v16;
    *(_OWORD *)(a4 + 48) = v17;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v15;
    --v13;
  }
  while (v13);
  return result;
}

int16x8_t sub_1BBA22724(uint64_t a1, const __int16 *a2, uint64_t a3, int16x8_t *a4)
{
  uint64_t v4 = a2 + 32;
  int16x8x2_t v8 = vld2q_s16(v4);
  int16x8x2_t v9 = vld2q_s16(a2);
  v8.val[0] = (int16x8_t)vdupq_n_s32((vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v8.val[1].i8, *(uint16x4_t *)v9.val[1].i8), (int32x4_t)vaddl_high_u16((uint16x8_t)v8.val[1], (uint16x8_t)v9.val[1])), (int32x4_t)xmmword_1BBB6F690)) << 12) & 0xFFFF0000 | (unsigned __int16)(vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v8.val[0].i8, *(uint16x4_t *)v9.val[0].i8), (int32x4_t)vaddl_high_u16((uint16x8_t)v8.val[0], (uint16x8_t)v9.val[0])), (int32x4_t)xmmword_1BBB6F690)) >> 4));
  *a4 = v8.val[0];
  a4[1] = v8.val[0];
  int v5 = 7;
  do
  {
    int16x8_t result = *a4;
    int16x8_t v7 = a4[1];
    a4 = (int16x8_t *)((char *)a4 + 2 * a3);
    *a4 = result;
    a4[1] = v7;
    --v5;
  }
  while (v5);
  return result;
}

int32x4_t sub_1BBA22798(uint64_t a1, const __int16 *a2, uint64_t a3, int32x4_t *a4)
{
  uint64_t v4 = a2 + 16;
  int16x4x2_t v7 = vld2_s16(v4);
  int16x4x2_t v8 = vld2_s16(a2);
  *a4 = vdupq_n_s32((vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16((uint16x4_t)v7.val[1], (uint16x4_t)v8.val[1]), (int32x4_t)xmmword_1BBB6F6A0)) << 13) & 0xFFFF0000 | (unsigned __int16)(vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16((uint16x4_t)v7.val[0], (uint16x4_t)v8.val[0]), (int32x4_t)xmmword_1BBB6F6A0)) >> 3));
  int v5 = 3;
  do
  {
    int32x4_t result = *a4;
    a4 = (int32x4_t *)((char *)a4 + 2 * a3);
    *a4 = result;
    --v5;
  }
  while (v5);
  return result;
}

void sub_1BBA227FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  for (uint64_t i = 0; i != 32; ++i)
  {
    uint64_t v5 = 0;
    int32x4_t v6 = (const float *)(a2 + 4 * i);
    float32x4_t v7 = vld1q_dup_f32(v6);
    do
    {
      *(float32x4_t *)(a4 + v5) = v7;
      v5 += 16;
    }
    while (v5 != 128);
    a4 += (2 * a3) & 0xFFFFFFFFFFFFFFFCLL;
  }
}

void sub_1BBA22838(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  for (uint64_t i = 0; i != 16; ++i)
  {
    uint64_t v5 = 0;
    int32x4_t v6 = (const float *)(a2 + 4 * i);
    float32x4_t v7 = vld1q_dup_f32(v6);
    do
    {
      *(float32x4_t *)(a4 + v5) = v7;
      v5 += 16;
    }
    while (v5 != 64);
    a4 += (2 * a3) & 0xFFFFFFFFFFFFFFFCLL;
  }
}

float32x4_t sub_1BBA22874(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = a4 + 1;
  do
  {
    int32x4_t v6 = (const float *)(a2 + v4);
    float32x4_t result = vld1q_dup_f32(v6);
    v5[-1] = result;
    *uint64_t v5 = result;
    v4 += 4;
    uint64_t v5 = (float32x4_t *)((char *)v5 + ((2 * a3) & 0xFFFFFFFFFFFFFFFCLL));
  }
  while (v4 != 32);
  return result;
}

float32x4_t sub_1BBA228A4(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4)
{
  for (uint64_t i = 0; i != 16; i += 4)
  {
    uint64_t v5 = (const float *)(a2 + i);
    float32x4_t result = vld1q_dup_f32(v5);
    *a4 = result;
    a4 = (float32x4_t *)((char *)a4 + ((2 * a3) & 0xFFFFFFFFFFFFFFFCLL));
  }
  return result;
}

__n128 sub_1BBA228D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = 32;
  do
  {
    long long v5 = *(_OWORD *)(a2 + 256);
    long long v6 = *(_OWORD *)(a2 + 272);
    long long v7 = *(_OWORD *)(a2 + 304);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a4 + 48) = v7;
    *(_OWORD *)a4 = v5;
    *(_OWORD *)(a4 + 16) = v6;
    __n128 result = *(__n128 *)(a2 + 320);
    long long v9 = *(_OWORD *)(a2 + 336);
    long long v10 = *(_OWORD *)(a2 + 368);
    *(_OWORD *)(a4 + 96) = *(_OWORD *)(a2 + 352);
    *(_OWORD *)(a4 + 112) = v10;
    *(__n128 *)(a4 + 64) = result;
    *(_OWORD *)(a4 + 80) = v9;
    a4 += 2 * a3;
    --v4;
  }
  while (v4);
  return result;
}

__n128 sub_1BBA2290C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = 16;
  do
  {
    __n128 result = *(__n128 *)(a2 + 128);
    long long v6 = *(_OWORD *)(a2 + 144);
    long long v7 = *(_OWORD *)(a2 + 176);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(a4 + 48) = v7;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v6;
    a4 += 2 * a3;
    --v4;
  }
  while (v4);
  return result;
}

__n128 sub_1BBA22938(uint64_t a1, __n128 *a2, uint64_t a3, __n128 *a4)
{
  int v4 = a2 + 4;
  int v5 = 8;
  do
  {
    __n128 result = *v4;
    __n128 v7 = a2[5];
    *a4 = *v4;
    a4[1] = v7;
    a4 = (__n128 *)((char *)a4 + 2 * a3);
    --v5;
  }
  while (v5);
  return result;
}

__n128 sub_1BBA2295C(uint64_t a1, __n128 *a2, uint64_t a3, __n128 *a4)
{
  int v4 = a2 + 2;
  int v5 = 4;
  do
  {
    __n128 result = *v4;
    *a4 = *v4;
    a4 = (__n128 *)((char *)a4 + 2 * a3);
    --v5;
  }
  while (v5);
  return result;
}

uint64_t sub_1BBA22980(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  int v5 = a2 + 128;
  do
  {
    uint64_t v6 = 0;
    __n128 v7 = &a2[2 * v4];
    int v8 = 31;
    int v9 = 31 - v4++;
    int v10 = 1;
    do
    {
      uint64_t v11 = (_WORD *)(a4 + v6 * 2);
      *uint64_t v11 = (v10 * a2[192] + v8 * *v7 + v9 * v5[v6] + v4 * a2[64] + 32) >> 6;
      uint64_t result = v5[v6 + 1];
      v11[1] = (v10 * a2[193] + v8 * v7[1] + v9 * result + v4 * a2[65] + 32) >> 6;
      --v8;
      v6 += 2;
      ++v10;
    }
    while (v6 != 64);
    a4 += 2 * a3;
  }
  while (v4 != 32);
  return result;
}

uint64_t sub_1BBA22A28(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  int v5 = a2 + 64;
  do
  {
    uint64_t v6 = 0;
    __n128 v7 = &a2[2 * v4];
    int v8 = 15;
    int v9 = 15 - v4++;
    int v10 = 1;
    do
    {
      uint64_t v11 = (_WORD *)(a4 + v6 * 2);
      *uint64_t v11 = (v10 * a2[96] + v8 * *v7 + v9 * v5[v6] + v4 * a2[32] + 16) >> 5;
      uint64_t result = v5[v6 + 1];
      v11[1] = (v10 * a2[97] + v8 * v7[1] + v9 * result + v4 * a2[33] + 16) >> 5;
      --v8;
      v6 += 2;
      ++v10;
    }
    while (v6 != 32);
    a4 += 2 * a3;
  }
  while (v4 != 16);
  return result;
}

uint64_t sub_1BBA22AD0(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  int v5 = a2 + 32;
  do
  {
    uint64_t v6 = 0;
    __n128 v7 = &a2[2 * v4];
    int v8 = 7;
    int v9 = 7 - v4++;
    int v10 = 1;
    do
    {
      uint64_t v11 = (_WORD *)(a4 + v6 * 2);
      *uint64_t v11 = (v10 * a2[48] + v8 * *v7 + v9 * v5[v6] + v4 * a2[16] + 8) >> 4;
      uint64_t result = v5[v6 + 1];
      v11[1] = (v10 * a2[49] + v8 * v7[1] + v9 * result + v4 * a2[17] + 8) >> 4;
      --v8;
      v6 += 2;
      ++v10;
    }
    while (v6 != 16);
    a4 += 2 * a3;
  }
  while (v4 != 8);
  return result;
}

uint64_t sub_1BBA22B78(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  int v5 = a2 + 16;
  do
  {
    uint64_t v6 = 0;
    __n128 v7 = &a2[2 * v4];
    int v8 = 3;
    int v9 = 3 - v4++;
    int v10 = 1;
    do
    {
      uint64_t v11 = (_WORD *)(a4 + v6 * 2);
      *uint64_t v11 = (v10 * a2[24] + v8 * *v7 + v9 * v5[v6] + v4 * a2[8] + 4) >> 3;
      uint64_t result = v5[v6 + 1];
      v11[1] = (v10 * a2[25] + v8 * v7[1] + v9 * result + v4 * a2[9] + 4) >> 3;
      --v8;
      v6 += 2;
      ++v10;
    }
    while (v6 != 8);
    a4 += 2 * a3;
  }
  while (v4 != 4);
  return result;
}

unsigned char *sub_1BBA22C20(int a1, uint64_t a2, uint64_t a3, _WORD *a4)
{
  uint64_t v4 = a4;
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  int v7 = byte_1BBB795E8[a1];
  uint64_t v8 = a1;
  uint64_t result = v60;
  int v10 = v7;
  unint64_t v11 = v8 - 11;
  if (a1 < 18)
  {
    if (v11 >= 0xF)
    {
      uint64_t result = memcpy(v60, (const void *)(a2 - 2), sizeof(v60));
    }
    else
    {
      int v22 = 2 * v7;
      int v23 = word_1BBB79710[v8 - 11];
      if ((v7 & 0x40000000) != 0) {
        __int16 v24 = -1;
      }
      else {
        __int16 v24 = 2 * v7;
      }
      unint64_t v25 = v22 - (unint64_t)(unsigned __int16)(v24 + 1);
      uint64_t v26 = &v59[v22 + 64];
      int v27 = v23 * v22 + 128;
      do
      {
        int v28 = (v27 >> 8) + 127;
        if (v27 < 0x100) {
          int v28 = -1;
        }
        *v26++ = *(_WORD *)(a2 + 2 * v28);
        v27 += v23;
        BOOL v18 = __CFADD__(v25++, 1);
      }
      while (!v18);
      long long v29 = *(_OWORD *)(a2 + 78);
      long long v30 = *(_OWORD *)(a2 + 110);
      *(_OWORD *)&v60[96] = *(_OWORD *)(a2 + 94);
      *(_OWORD *)&v60[112] = v30;
      *(_WORD *)&v60[128] = *(_WORD *)(a2 + 126);
      long long v31 = *(_OWORD *)(a2 + 14);
      long long v32 = *(_OWORD *)(a2 + 46);
      *(_OWORD *)&v60[32] = *(_OWORD *)(a2 + 30);
      *(_OWORD *)&v60[48] = v32;
      *(_OWORD *)&v60[64] = *(_OWORD *)(a2 + 62);
      *(_OWORD *)&v60[80] = v29;
      *(_OWORD *)uint64_t v60 = *(_OWORD *)(a2 - 2);
      *(_OWORD *)&v60[16] = v31;
    }
    uint64_t v51 = 0;
    uint64_t v52 = 2 * a3;
    do
    {
      int v53 = v10 >> 5;
      if ((v10 & 0x1F) != 0)
      {
        uint64_t v54 = 0;
        long long v55 = v4;
        long long v56 = &v59[v53];
        do
        {
          uint64_t result = (unsigned char *)(((v10 & 0x1F) * (unsigned __int16)v56[v54 + 66]
                            + (32 - (v10 & 0x1F)) * (unsigned __int16)v56[v54 + 65]
                            + 16) >> 5);
          *long long v55 = (_WORD)result;
          ++v54;
          long long v55 = (_WORD *)((char *)v55 + v52);
        }
        while (v54 != 64);
      }
      else
      {
        uint64_t v57 = 0;
        long long v58 = v4;
        do
        {
          *long long v58 = *(_WORD *)&v60[2 * v53 + 2 + v57];
          v57 += 2;
          long long v58 = (_WORD *)((char *)v58 + v52);
        }
        while (v57 != 128);
      }
      ++v51;
      v10 += v7;
      ++v4;
    }
    while (v51 != 64);
  }
  else
  {
    if (v11 >= 0xF)
    {
      uint64_t v33 = 0;
      for (uint64_t i = 0; i != 129; ++i)
      {
        uint64_t v35 = i + 127;
        if (!v33) {
          uint64_t v35 = -1;
        }
        *(_WORD *)&v60[v33] = *(_WORD *)(a2 + 2 * v35);
        v33 += 2;
      }
    }
    else
    {
      int v12 = 2 * v7;
      int v13 = word_1BBB79710[a1 - 11];
      if ((v7 & 0x40000000) != 0) {
        __int16 v14 = -1;
      }
      else {
        __int16 v14 = 2 * v7;
      }
      unint64_t v15 = v12 - (unint64_t)(unsigned __int16)(v14 + 1);
      long long v16 = &v59[v12 + 64];
      int v17 = v13 * v12 + 128;
      do
      {
        *v16++ = *(_WORD *)(a2 + 2 * ((v17 >> 8) - 1));
        v17 += v13;
        BOOL v18 = __CFADD__(v15++, 1);
      }
      while (!v18);
      uint64_t v19 = 0;
      for (uint64_t j = 0; j != 65; ++j)
      {
        uint64_t v21 = j + 127;
        if (!v19) {
          uint64_t v21 = -1;
        }
        *(_WORD *)&v60[v19] = *(_WORD *)(a2 + 2 * v21);
        v19 += 2;
      }
    }
    uint64_t v36 = 0;
    uint64_t v37 = 2 * a3;
    uint64_t v38 = a4;
    do
    {
      uint64_t v39 = (uint64_t)v10 >> 5;
      unsigned int v40 = v10 & 0x1F;
      if ((v10 & 0x1F) != 0)
      {
        uint64_t v41 = 0;
        uint64_t v42 = &v59[v39];
        do
        {
          uint64_t result = &v42[v41];
          uint16x8_t v43 = (uint16x8_t)vdupq_n_s16(32 - v40);
          uint16x8_t v44 = (uint16x8_t)vdupq_n_s16(v40);
          *(int16x8_t *)&v38[v41] = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)&v42[v41 + 65]), *(uint16x4_t *)v44.i8, *(uint16x4_t *)&v42[v41 + 66]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v43, *(uint16x8_t *)&v42[v41 + 65]), v44, *(uint16x8_t *)&v42[v41 + 66]), 5uLL);
          v41 += 8;
        }
        while (v41 != 64);
      }
      else
      {
        uint64_t v45 = &v60[2 * v39 + 2];
        long long v46 = v45[5];
        long long v47 = (_OWORD *)((char *)a4 + v37 * v36);
        v47[4] = v45[4];
        v47[5] = v46;
        long long v48 = v45[7];
        v47[6] = v45[6];
        v47[7] = v48;
        long long v49 = v45[1];
        *long long v47 = *v45;
        v47[1] = v49;
        long long v50 = v45[3];
        v47[2] = v45[2];
        v47[3] = v50;
      }
      ++v36;
      v10 += v7;
      uint64_t v38 = (_WORD *)((char *)v38 + v37);
    }
    while (v36 != 64);
  }
  return result;
}

unint64_t sub_1BBA22F6C(unint64_t result, uint64_t a2, uint64_t a3, _WORD *a4)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  int v4 = byte_1BBB795E8[(int)result];
  uint64_t v5 = byte_1BBB795E8[(int)result];
  int v6 = v4;
  unint64_t v7 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v7 >= 0xF)
    {
      long long v40 = *(_OWORD *)(a2 + 78);
      long long v41 = *(_OWORD *)(a2 + 110);
      long long v58 = *(_OWORD *)(a2 + 94);
      long long v59 = v41;
      __int16 v60 = *(_WORD *)(a2 + 126);
      long long v42 = *(_OWORD *)(a2 + 14);
      long long v43 = *(_OWORD *)(a2 + 46);
      long long v54 = *(_OWORD *)(a2 + 30);
      long long v55 = v43;
      long long v56 = *(_OWORD *)(a2 + 62);
      long long v57 = v40;
      long long v52 = *(_OWORD *)(a2 - 2);
      long long v53 = v42;
    }
    else
    {
      int v16 = word_1BBB79710[(int)result - 11];
      if (v4 < 0) {
        int v17 = -1;
      }
      else {
        int v17 = byte_1BBB795E8[(int)result];
      }
      uint64_t v18 = v17 - v5 + 1;
      uint64_t v19 = &v51[v5 + 32];
      int v20 = v4 * v16 + 128;
      do
      {
        int v21 = (v20 >> 8) + 63;
        if (v20 < 0x100) {
          int v21 = -1;
        }
        *v19++ = *(_WORD *)(a2 + 2 * v21);
        v20 += v16;
        --v18;
      }
      while (v18);
      long long v22 = *(_OWORD *)(a2 + 14);
      long long v23 = *(_OWORD *)(a2 + 46);
      long long v54 = *(_OWORD *)(a2 + 30);
      long long v55 = v23;
      LOWORD(v56) = *(_WORD *)(a2 + 62);
      long long v52 = *(_OWORD *)(a2 - 2);
      long long v53 = v22;
    }
    uint64_t v44 = 0;
    uint64_t v45 = 2 * a3;
    do
    {
      int v46 = v6 >> 5;
      if ((v6 & 0x1F) != 0)
      {
        uint64_t v47 = 0;
        uint64_t result = (unint64_t)a4;
        long long v48 = &v51[v46];
        do
        {
          *(_WORD *)uint64_t result = ((v6 & 0x1F) * (unsigned __int16)v48[v47 + 34]
                            + (32 - (v6 & 0x1F)) * (unsigned __int16)v48[v47 + 33]
                            + 16) >> 5;
          ++v47;
          result += v45;
        }
        while (v47 != 32);
      }
      else
      {
        uint64_t v49 = 0;
        long long v50 = a4;
        do
        {
          uint64_t result = *(unsigned __int16 *)((char *)&v52 + 2 * v46 + v49 + 2);
          *long long v50 = result;
          v49 += 2;
          long long v50 = (_WORD *)((char *)v50 + v45);
        }
        while (v49 != 64);
      }
      ++v44;
      v6 += v4;
      ++a4;
    }
    while (v44 != 32);
  }
  else
  {
    if (v7 >= 0xF)
    {
      uint64_t v24 = 0;
      for (uint64_t i = 0; i != 65; ++i)
      {
        uint64_t v26 = i + 63;
        if (!v24) {
          uint64_t v26 = -1;
        }
        *(_WORD *)((char *)&v52 + v24) = *(_WORD *)(a2 + 2 * v26);
        v24 += 2;
      }
    }
    else
    {
      int v8 = word_1BBB79710[(result - 11)];
      if ((int)v5 < 0) {
        int v9 = -1;
      }
      else {
        int v9 = byte_1BBB795E8[(int)result];
      }
      uint64_t v10 = v9 - v5 + 1;
      unint64_t v11 = &v51[v5 + 32];
      int v12 = v4 * v8 + 128;
      do
      {
        *v11++ = *(_WORD *)(a2 + 2 * ((v12 >> 8) - 1));
        v12 += v8;
        --v10;
      }
      while (v10);
      uint64_t v13 = 0;
      for (uint64_t j = 0; j != 33; ++j)
      {
        uint64_t v15 = j + 63;
        if (!v13) {
          uint64_t v15 = -1;
        }
        *(_WORD *)((char *)&v52 + v13) = *(_WORD *)(a2 + 2 * v15);
        v13 += 2;
      }
    }
    uint64_t v27 = 0;
    uint64_t v28 = 2 * a3;
    long long v29 = a4;
    do
    {
      uint64_t v30 = (uint64_t)v6 >> 5;
      unsigned int v31 = v6 & 0x1F;
      if ((v6 & 0x1F) != 0)
      {
        uint64_t v32 = 0;
        uint64_t result = 32 - v31;
        uint64_t v33 = &v51[v30];
        do
        {
          uint16x8_t v34 = (uint16x8_t)vdupq_n_s16(result);
          uint16x8_t v35 = (uint16x8_t)vdupq_n_s16(v31);
          *(int16x8_t *)&v29[v32] = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v34.i8, *(uint16x4_t *)&v33[v32 + 33]), *(uint16x4_t *)v35.i8, *(uint16x4_t *)&v33[v32 + 34]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v34, *(uint16x8_t *)&v33[v32 + 33]), v35, *(uint16x8_t *)&v33[v32 + 34]), 5uLL);
          v32 += 8;
        }
        while (v32 != 32);
      }
      else
      {
        uint64_t v36 = (_OWORD *)((char *)a4 + v28 * v27);
        uint64_t v37 = (long long *)((char *)&v52 + 2 * v30 + 2);
        long long v38 = v37[1];
        *uint64_t v36 = *v37;
        v36[1] = v38;
        long long v39 = v37[3];
        v36[2] = v37[2];
        v36[3] = v39;
      }
      ++v27;
      v6 += v4;
      long long v29 = (_WORD *)((char *)v29 + v28);
    }
    while (v27 != 32);
  }
  return result;
}

unint64_t sub_1BBA2329C(unint64_t result, uint64_t a2, uint64_t a3, _WORD *a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  int v4 = byte_1BBB795E8[(int)result];
  int v5 = v4;
  unint64_t v6 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v6 >= 0xF)
    {
      long long v35 = *(_OWORD *)(a2 + 14);
      long long v36 = *(_OWORD *)(a2 + 46);
      long long v47 = *(_OWORD *)(a2 + 30);
      long long v48 = v36;
      __int16 v49 = *(_WORD *)(a2 + 62);
      long long v45 = *(_OWORD *)(a2 - 2);
      long long v46 = v35;
    }
    else
    {
      if ((v4 & 0x10000) != 0)
      {
        int v14 = word_1BBB79710[(int)result - 11];
        uint64_t v15 = (uint64_t)byte_1BBB795E8[(int)result] >> 1;
        int v16 = (v4 >> 1) * v14 + 128;
        do
        {
          int v17 = (v16 >> 8) + 31;
          if (v16 < 0x100) {
            int v17 = -1;
          }
          *((_WORD *)&v45 + v15) = *(_WORD *)(a2 + 2 * v17);
          v16 += v14;
          BOOL v10 = __CFADD__(v15++, 1);
        }
        while (!v10);
      }
      long long v18 = *(_OWORD *)(a2 + 14);
      long long v45 = *(_OWORD *)(a2 - 2);
      long long v46 = v18;
      LOWORD(v47) = *(_WORD *)(a2 + 30);
    }
    uint64_t v37 = 0;
    uint64_t v38 = 2 * a3;
    do
    {
      int v39 = v5 >> 5;
      if ((v5 & 0x1F) != 0)
      {
        uint64_t v40 = 0;
        uint64_t result = (unint64_t)a4;
        long long v41 = &v44[v39];
        do
        {
          *(_WORD *)uint64_t result = ((v5 & 0x1F) * (unsigned __int16)v41[v40 + 18]
                            + (32 - (v5 & 0x1F)) * (unsigned __int16)v41[v40 + 17]
                            + 16) >> 5;
          ++v40;
          result += v38;
        }
        while (v40 != 16);
      }
      else
      {
        uint64_t v42 = 0;
        long long v43 = a4;
        do
        {
          uint64_t result = *(unsigned __int16 *)((char *)&v45 + 2 * v39 + v42 + 2);
          *long long v43 = result;
          v42 += 2;
          long long v43 = (_WORD *)((char *)v43 + v38);
        }
        while (v42 != 32);
      }
      ++v37;
      v5 += v4;
      ++a4;
    }
    while (v37 != 16);
  }
  else
  {
    if (v6 >= 0xF)
    {
      uint64_t v19 = 0;
      for (uint64_t i = 0; i != 33; ++i)
      {
        uint64_t v21 = i + 31;
        if (!v19) {
          uint64_t v21 = -1;
        }
        *(_WORD *)((char *)&v45 + v19) = *(_WORD *)(a2 + 2 * v21);
        v19 += 2;
      }
    }
    else
    {
      if ((v4 & 0x10000) != 0)
      {
        int v7 = word_1BBB79710[(result - 11)];
        uint64_t v8 = (uint64_t)byte_1BBB795E8[(int)result] >> 1;
        int v9 = (v4 >> 1) * v7 + 128;
        do
        {
          *((_WORD *)&v45 + v8) = *(_WORD *)(a2 + 2 * ((v9 >> 8) - 1));
          v9 += v7;
          BOOL v10 = __CFADD__(v8++, 1);
        }
        while (!v10);
      }
      uint64_t v11 = 0;
      for (uint64_t j = 0; j != 17; ++j)
      {
        uint64_t v13 = j + 31;
        if (!v11) {
          uint64_t v13 = -1;
        }
        *(_WORD *)((char *)&v45 + v11) = *(_WORD *)(a2 + 2 * v13);
        v11 += 2;
      }
    }
    uint64_t v22 = 0;
    uint64_t v23 = 2 * a3;
    uint64_t v24 = a4;
    do
    {
      uint64_t v25 = (uint64_t)v5 >> 5;
      unsigned int v26 = v5 & 0x1F;
      if ((v5 & 0x1F) != 0)
      {
        uint64_t v27 = 0;
        uint64_t result = 32 - v26;
        uint64_t v28 = &v44[v25];
        do
        {
          uint16x8_t v29 = (uint16x8_t)vdupq_n_s16(result);
          uint16x8_t v30 = (uint16x8_t)vdupq_n_s16(v26);
          *(int16x8_t *)&v24[v27] = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16(*(uint16x4_t *)v29.i8, *(uint16x4_t *)&v28[v27 + 17]), *(uint16x4_t *)v30.i8, *(uint16x4_t *)&v28[v27 + 18]), 5uLL), (int32x4_t)vmlal_high_u16(vmull_high_u16(v29, *(uint16x8_t *)&v28[v27 + 17]), v30, *(uint16x8_t *)&v28[v27 + 18]), 5uLL);
          v27 += 8;
        }
        while (v27 != 16);
      }
      else
      {
        unsigned int v31 = (long long *)((char *)&v45 + 2 * v25 + 2);
        long long v32 = *v31;
        long long v33 = v31[1];
        uint16x8_t v34 = (_OWORD *)((char *)a4 + v23 * v22);
        *uint16x8_t v34 = v32;
        v34[1] = v33;
      }
      ++v22;
      v5 += v4;
      uint64_t v24 = (_WORD *)((char *)v24 + v23);
    }
    while (v22 != 16);
  }
  return result;
}

int16x8_t *sub_1BBA23574(int16x8_t *result, uint64_t a2, uint64_t a3, int16x8_t *a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  int v4 = byte_1BBB795E8[(int)result];
  int v5 = v4;
  unint64_t v6 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v6 >= 0xF)
    {
      long long v30 = *(_OWORD *)(a2 + 14);
      long long v39 = *(_OWORD *)(a2 - 2);
      long long v40 = v30;
      __int16 v41 = *(_WORD *)(a2 + 30);
    }
    else
    {
      if ((v4 & 0x20000) != 0)
      {
        int v14 = word_1BBB79710[(int)result - 11];
        uint64_t v15 = (uint64_t)byte_1BBB795E8[(int)result] >> 2;
        int v16 = (v4 >> 2) * v14 + 128;
        do
        {
          int v17 = (v16 >> 8) + 15;
          if (v16 < 0x100) {
            int v17 = -1;
          }
          *((_WORD *)&v39 + v15) = *(_WORD *)(a2 + 2 * v17);
          v16 += v14;
          BOOL v10 = __CFADD__(v15++, 1);
        }
        while (!v10);
      }
      long long v39 = *(_OWORD *)(a2 - 2);
      LOWORD(v40) = *(_WORD *)(a2 + 14);
    }
    uint64_t v31 = 0;
    uint64_t v32 = 2 * a3;
    do
    {
      int v33 = v5 >> 5;
      if ((v5 & 0x1F) != 0)
      {
        uint64_t v34 = 0;
        uint64_t result = a4;
        long long v35 = &v38[v33];
        do
        {
          result->i16[0] = ((v5 & 0x1F) * (unsigned __int16)v35[v34 + 10]
                          + (32 - (v5 & 0x1F)) * (unsigned __int16)v35[v34 + 9]
                          + 16) >> 5;
          ++v34;
          uint64_t result = (int16x8_t *)((char *)result + v32);
        }
        while (v34 != 8);
      }
      else
      {
        uint64_t v36 = 0;
        uint64_t v37 = a4;
        do
        {
          uint64_t result = (int16x8_t *)*(unsigned __int16 *)((char *)&v39 + 2 * v33 + v36 + 2);
          v37->i16[0] = (__int16)result;
          v36 += 2;
          uint64_t v37 = (int16x8_t *)((char *)v37 + v32);
        }
        while (v36 != 16);
      }
      ++v31;
      v5 += v4;
      a4 = (int16x8_t *)((char *)a4 + 2);
    }
    while (v31 != 8);
  }
  else
  {
    if (v6 >= 0xF)
    {
      uint64_t v18 = 0;
      for (uint64_t i = 0; i != 17; ++i)
      {
        uint64_t v20 = i + 15;
        if (!v18) {
          uint64_t v20 = -1;
        }
        *(_WORD *)((char *)&v39 + v18) = *(_WORD *)(a2 + 2 * v20);
        v18 += 2;
      }
    }
    else
    {
      if ((v4 & 0x20000) != 0)
      {
        int v7 = word_1BBB79710[result - 11];
        uint64_t v8 = (uint64_t)byte_1BBB795E8[(int)result] >> 2;
        int v9 = (v4 >> 2) * v7 + 128;
        do
        {
          *((_WORD *)&v39 + v8) = *(_WORD *)(a2 + 2 * ((v9 >> 8) - 1));
          v9 += v7;
          BOOL v10 = __CFADD__(v8++, 1);
        }
        while (!v10);
      }
      uint64_t v11 = 0;
      for (uint64_t j = 0; j != 9; ++j)
      {
        uint64_t v13 = j + 15;
        if (!v11) {
          uint64_t v13 = -1;
        }
        *(_WORD *)((char *)&v39 + v11) = *(_WORD *)(a2 + 2 * v13);
        v11 += 2;
      }
    }
    uint64_t v21 = 8;
    do
    {
      uint64_t v22 = (uint64_t)v5 >> 5;
      unsigned int v23 = v5 & 0x1F;
      if ((v5 & 0x1F) != 0)
      {
        uint64_t v24 = (char *)&v39 + 2 * v22;
        uint16x8_t v25 = *(uint16x8_t *)(v24 + 2);
        uint16x8_t v26 = (uint16x8_t)vdupq_n_s16(32 - v23);
        uint32x4_t v27 = vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v25.i8);
        uint32x4_t v28 = vmull_high_u16(v26, v25);
        uint16x8_t v29 = (uint16x8_t)vdupq_n_s16(v23);
        *a4 = vrshrn_high_n_s32(vrshrn_n_s32((int32x4_t)vmlal_u16(v27, *(uint16x4_t *)v29.i8, *(uint16x4_t *)(v24 + 4)), 5uLL), (int32x4_t)vmlal_high_u16(v28, v29, *(uint16x8_t *)(v24 + 4)), 5uLL);
      }
      else
      {
        *a4 = *(int16x8_t *)((char *)&v39 + 2 * v22 + 2);
      }
      v5 += v4;
      a4 = (int16x8_t *)((char *)a4 + 2 * a3);
      --v21;
    }
    while (v21);
  }
  return result;
}

int16x4_t *sub_1BBA2381C(int16x4_t *result, uint64_t a2, uint64_t a3, int16x4_t *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v4 = byte_1BBB795E8[(int)result];
  int v5 = v4;
  unint64_t v6 = (int)result - 11;
  if ((int)result < 18)
  {
    if (v6 >= 0xF)
    {
      long long v31 = *(_OWORD *)(a2 - 2);
      __int16 v32 = *(_WORD *)(a2 + 14);
    }
    else
    {
      if ((v4 & 0x40000) != 0)
      {
        int v14 = word_1BBB79710[(int)result - 11];
        uint64_t v15 = (uint64_t)byte_1BBB795E8[(int)result] >> 3;
        int v16 = (v4 >> 3) * v14 + 128;
        do
        {
          int v17 = (v16 >> 8) + 7;
          if (v16 < 0x100) {
            int v17 = -1;
          }
          *((_WORD *)&v31 + v15) = *(_WORD *)(a2 + 2 * v17);
          v16 += v14;
          BOOL v10 = __CFADD__(v15++, 1);
        }
        while (!v10);
      }
      *(void *)&long long v31 = *(void *)(a2 - 2);
      WORD4(v31) = *(_WORD *)(a2 + 6);
    }
    uint64_t v23 = 0;
    uint64_t v24 = 2 * a3;
    do
    {
      int v25 = v5 >> 5;
      if ((v5 & 0x1F) != 0)
      {
        uint64_t v26 = 0;
        uint64_t result = a4;
        uint32x4_t v27 = &v30[v25];
        do
        {
          result->i16[0] = ((v5 & 0x1F) * (unsigned __int16)v27[v26 + 6]
                          + (32 - (v5 & 0x1F)) * (unsigned __int16)v27[v26 + 5]
                          + 16) >> 5;
          ++v26;
          uint64_t result = (int16x4_t *)((char *)result + v24);
        }
        while (v26 != 4);
      }
      else
      {
        uint64_t v28 = 0;
        uint16x8_t v29 = a4;
        do
        {
          uint64_t result = (int16x4_t *)*(unsigned __int16 *)((char *)&v31 + 2 * v25 + v28 + 2);
          v29->i16[0] = (__int16)result;
          v28 += 2;
          uint16x8_t v29 = (int16x4_t *)((char *)v29 + v24);
        }
        while (v28 != 8);
      }
      ++v23;
      v5 += v4;
      a4 = (int16x4_t *)((char *)a4 + 2);
    }
    while (v23 != 4);
  }
  else
  {
    if (v6 >= 0xF)
    {
      uint64_t v18 = 0;
      for (uint64_t i = 0; i != 9; ++i)
      {
        uint64_t v20 = i + 7;
        if (!v18) {
          uint64_t v20 = -1;
        }
        *(_WORD *)((char *)&v31 + v18) = *(_WORD *)(a2 + 2 * v20);
        v18 += 2;
      }
    }
    else
    {
      if ((v4 & 0x40000) != 0)
      {
        int v7 = word_1BBB79710[result - 11];
        uint64_t v8 = (uint64_t)byte_1BBB795E8[(int)result] >> 3;
        int v9 = (v4 >> 3) * v7 + 128;
        do
        {
          *((_WORD *)&v31 + v8) = *(_WORD *)(a2 + 2 * ((v9 >> 8) - 1));
          v9 += v7;
          BOOL v10 = __CFADD__(v8++, 1);
        }
        while (!v10);
      }
      uint64_t v11 = 0;
      for (uint64_t j = 0; j != 5; ++j)
      {
        uint64_t v13 = j + 7;
        if (!v11) {
          uint64_t v13 = -1;
        }
        *(_WORD *)((char *)&v31 + v11) = *(_WORD *)(a2 + 2 * v13);
        v11 += 2;
      }
    }
    uint64_t v21 = 4;
    do
    {
      uint64_t v22 = (uint64_t)v5 >> 5;
      if ((v5 & 0x1F) != 0) {
        *a4 = vrshrn_n_s32((int32x4_t)vmlal_u16(vmull_u16((uint16x4_t)vdup_n_s16(32 - (v5 & 0x1Fu)), *(uint16x4_t *)((char *)&v31 + 2 * v22 + 2)), (uint16x4_t)vdup_n_s16(v5 & 0x1F), *(uint16x4_t *)((char *)&v31 + 2 * v22 + 4)), 5uLL);
      }
      else {
        *a4 = *(int16x4_t *)((char *)&v31 + 2 * v22 + 2);
      }
      v5 += v4;
      a4 = (int16x4_t *)((char *)a4 + 2 * a3);
      --v21;
    }
    while (v21);
  }
  return result;
}

void sub_1BBA23AB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  int32x4_t v5 = (int32x4_t)xmmword_1BBB6F6B0;
  int32x4_t v6 = 0uLL;
  do
  {
    uint16x8_t v7 = *(uint16x8_t *)(a2 + v4 + 256);
    uint16x8_t v8 = *(uint16x8_t *)(a2 + v4);
    int32x4_t v6 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v6, v7), v8);
    int32x4_t v5 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v7.i8), *(uint16x4_t *)v8.i8);
    v4 += 16;
  }
  while (v4 != 128);
  uint64_t v9 = 0;
  int16x8_t v10 = vdupq_n_s16(vaddvq_s32(vaddq_s32(v5, v6)) >> 7);
  do
  {
    for (uint64_t i = 0; i != 128; i += 16)
      *(int16x8_t *)(a4 + i) = v10;
    ++v9;
    a4 += 2 * a3;
  }
  while (v9 != 64);
}

void sub_1BBA23B30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  int32x4_t v5 = (int32x4_t)xmmword_1BBB6F670;
  int32x4_t v6 = 0uLL;
  do
  {
    uint16x8_t v7 = *(uint16x8_t *)(a2 + v4 + 128);
    uint16x8_t v8 = *(uint16x8_t *)(a2 + v4);
    int32x4_t v6 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v6, v7), v8);
    int32x4_t v5 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v7.i8), *(uint16x4_t *)v8.i8);
    v4 += 16;
  }
  while (v4 != 64);
  uint64_t v9 = 0;
  int16x8_t v10 = vdupq_n_s16(vaddvq_s32(vaddq_s32(v5, v6)) >> 6);
  do
  {
    for (uint64_t i = 0; i != 64; i += 16)
      *(int16x8_t *)(a4 + i) = v10;
    ++v9;
    a4 += 2 * a3;
  }
  while (v9 != 32);
}

void sub_1BBA23BAC(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _WORD *a4)
{
  uint64_t v4 = 0;
  int32x4_t v5 = (int32x4_t)xmmword_1BBB6F680;
  int32x4_t v6 = 0uLL;
  do
  {
    uint16x8_t v7 = *(uint16x8_t *)&a2[v4 + 32];
    uint16x8_t v8 = *(uint16x8_t *)&a2[v4];
    int32x4_t v6 = (int32x4_t)vaddw_high_u16(vaddw_high_u16((uint32x4_t)v6, v7), v8);
    int32x4_t v5 = (int32x4_t)vaddw_u16(vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v7.i8), *(uint16x4_t *)v8.i8);
    v4 += 8;
  }
  while (v4 != 16);
  unsigned int v9 = vaddvq_s32(vaddq_s32(v5, v6)) >> 5;
  *a4 = (*a2 + 2 * v9 + a2[32] + 2) >> 2;
  int v10 = 3 * v9 + 2;
  uint64_t v11 = &a4[a3];
  for (uint64_t i = 1; i != 16; ++i)
  {
    uint64_t v13 = &a2[i];
    a4[i] = (v10 + v13[32]) >> 2;
    a4[i * a3] = (v10 + *v13) >> 2;
    for (uint64_t j = 1; j != 16; ++j)
      v11[j] = v9;
    v11 += a3;
  }
}

void sub_1BBA23C78(uint64_t a1, uint16x4_t *a2, uint64_t a3, _WORD *a4)
{
  unsigned int v4 = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(a2[4], *a2), (int32x4_t)vaddl_high_u16(*(uint16x8_t *)a2[4].i8, *(uint16x8_t *)a2->i8)), (int32x4_t)xmmword_1BBB6F690)) >> 4;
  *a4 = (2 * v4 + (unsigned __int16)*(_OWORD *)a2->i8 + (unsigned __int16)*(_OWORD *)a2[4].i8 + 2) >> 2;
  int v5 = 3 * v4 + 2;
  int32x4_t v6 = &a4[a3];
  for (uint64_t i = 1; i != 8; ++i)
  {
    uint16x8_t v8 = (unsigned __int16 *)a2 + i;
    a4[i] = (v5 + v8[16]) >> 2;
    a4[i * a3] = (v5 + *v8) >> 2;
    for (uint64_t j = 1; j != 8; ++j)
      v6[j] = v4;
    v6 += a3;
  }
}

void sub_1BBA23D28(uint64_t a1, uint16x4_t *a2, uint64_t a3, _WORD *a4)
{
  uint64_t v4 = 0;
  unsigned int v5 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(a2[2], *a2), (int32x4_t)xmmword_1BBB6F6A0)) >> 3;
  *a4 = (2 * v5 + a2->u16[0] + (unsigned __int16)*(void *)&a2[2] + 2) >> 2;
  int v6 = 3 * v5 + 2;
  uint16x8_t v7 = (char *)&a2[2] + 2;
  uint16x8_t v8 = &a4[a3 + 2];
  do
  {
    a4[v4 + 1] = (v6 + *(unsigned __int16 *)&v7[v4 * 2]) >> 2;
    *(v8 - 2) = (v6 + *(unsigned __int16 *)&v7[v4 * 2 - 16]) >> 2;
    *(v8 - 1) = v5;
    _WORD *v8 = v5;
    v8[1] = v5;
    ++v4;
    v8 += a3;
  }
  while (v4 != 3);
}

uint64_t sub_1BBA23DD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  do
  {
    uint64_t v5 = 0;
    uint64_t v6 = v4 + 1;
    int v7 = 63;
    do
    {
      uint64_t result = *(unsigned __int16 *)(a2 + 256 + 2 * v5);
      *(_WORD *)(a4 + 2 * v5) = ((v5 + 1) * *(unsigned __int16 *)(a2 + 384)
                               + v7 * *(unsigned __int16 *)(a2 + 2 * v4)
                               + (63 - v4) * result
                               + v6 * *(unsigned __int16 *)(a2 + 128)
                               + 64) >> 7;
      --v7;
      ++v5;
    }
    while (v5 != 64);
    a4 += 2 * a3;
    ++v4;
  }
  while (v6 != 64);
  return result;
}

uint64_t sub_1BBA23E40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  do
  {
    uint64_t v5 = 0;
    uint64_t v6 = v4 + 1;
    int v7 = 31;
    do
    {
      uint64_t result = *(unsigned __int16 *)(a2 + 128 + 2 * v5);
      *(_WORD *)(a4 + 2 * v5) = ((v5 + 1) * *(unsigned __int16 *)(a2 + 192)
                               + v7 * *(unsigned __int16 *)(a2 + 2 * v4)
                               + (31 - v4) * result
                               + v6 * *(unsigned __int16 *)(a2 + 64)
                               + 32) >> 6;
      --v7;
      ++v5;
    }
    while (v5 != 32);
    a4 += 2 * a3;
    ++v4;
  }
  while (v6 != 32);
  return result;
}

uint64_t sub_1BBA23EB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  do
  {
    uint64_t v5 = 0;
    uint64_t v6 = v4 + 1;
    int v7 = 15;
    do
    {
      uint64_t result = *(unsigned __int16 *)(a2 + 64 + 2 * v5);
      *(_WORD *)(a4 + 2 * v5) = ((v5 + 1) * *(unsigned __int16 *)(a2 + 96)
                               + v7 * *(unsigned __int16 *)(a2 + 2 * v4)
                               + (15 - v4) * result
                               + v6 * *(unsigned __int16 *)(a2 + 32)
                               + 16) >> 5;
      --v7;
      ++v5;
    }
    while (v5 != 16);
    a4 += 2 * a3;
    ++v4;
  }
  while (v6 != 16);
  return result;
}

uint64_t sub_1BBA23F20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  do
  {
    uint64_t v5 = 0;
    uint64_t v6 = v4 + 1;
    int v7 = 7;
    do
    {
      uint64_t result = *(unsigned __int16 *)(a2 + 32 + 2 * v5);
      *(_WORD *)(a4 + 2 * v5) = ((v5 + 1) * *(unsigned __int16 *)(a2 + 48)
                               + v7 * *(unsigned __int16 *)(a2 + 2 * v4)
                               + (7 - v4) * result
                               + v6 * *(unsigned __int16 *)(a2 + 16)
                               + 8) >> 4;
      --v7;
      ++v5;
    }
    while (v5 != 8);
    a4 += 2 * a3;
    ++v4;
  }
  while (v6 != 8);
  return result;
}

uint64_t sub_1BBA23F90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  do
  {
    uint64_t v5 = 0;
    uint64_t v6 = v4 + 1;
    int v7 = 3;
    do
    {
      uint64_t result = *(unsigned __int16 *)(a2 + 16 + 2 * v5);
      *(_WORD *)(a4 + 2 * v5) = ((v5 + 1) * *(unsigned __int16 *)(a2 + 24)
                               + v7 * *(unsigned __int16 *)(a2 + 2 * v4)
                               + (3 - v4) * result
                               + v6 * *(unsigned __int16 *)(a2 + 8)
                               + 4) >> 3;
      --v7;
      ++v5;
    }
    while (v5 != 4);
    a4 += 2 * a3;
    ++v4;
  }
  while (v6 != 4);
  return result;
}

unsigned __int16 *sub_1BBA24000(unsigned __int16 *result, uint64_t a2)
{
  uint64_t v2 = 0;
  int v3 = *(result - 1);
  uint64_t v4 = result + 64;
  *(_WORD *)(a2 - 2) = (*result + 2 * v3 + result[64] + 2) >> 2;
  *(_WORD *)(a2 + 254) = result[127];
  *(_WORD *)(a2 + 126) = result[63];
  int v5 = v3;
  do
  {
    int v6 = result[v2];
    int v7 = (_WORD *)(a2 + v2 * 2);
    *int v7 = (v3 + 2 * v6 + v4[v2 - 63] + 2) >> 2;
    int v8 = v4[v2];
    v7[64] = (v5 + 2 * v8 + v4[++v2] + 2) >> 2;
    int v3 = v6;
    int v5 = v8;
  }
  while (v2 != 63);
  return result;
}

unsigned __int16 *sub_1BBA24094(unsigned __int16 *result, uint64_t a2)
{
  uint64_t v2 = 0;
  int v3 = *(result - 1);
  uint64_t v4 = result + 32;
  *(_WORD *)(a2 - 2) = (*result + 2 * v3 + result[32] + 2) >> 2;
  *(_WORD *)(a2 + 126) = result[63];
  *(_WORD *)(a2 + 62) = result[31];
  int v5 = v3;
  do
  {
    int v6 = result[v2];
    int v7 = (_WORD *)(a2 + v2 * 2);
    *int v7 = (v3 + 2 * v6 + v4[v2 - 31] + 2) >> 2;
    int v8 = v4[v2];
    v7[32] = (v5 + 2 * v8 + v4[++v2] + 2) >> 2;
    int v3 = v6;
    int v5 = v8;
  }
  while (v2 != 31);
  return result;
}

unsigned __int16 *sub_1BBA24128(unsigned __int16 *result, uint64_t a2)
{
  uint64_t v2 = 0;
  int v3 = *(result - 1);
  uint64_t v4 = result + 16;
  *(_WORD *)(a2 - 2) = (*result + 2 * v3 + result[16] + 2) >> 2;
  *(_WORD *)(a2 + 62) = result[31];
  *(_WORD *)(a2 + 30) = result[15];
  int v5 = v3;
  do
  {
    int v6 = result[v2];
    int v7 = (_WORD *)(a2 + v2 * 2);
    *int v7 = (v3 + 2 * v6 + v4[v2 - 15] + 2) >> 2;
    int v8 = v4[v2];
    v7[16] = (v5 + 2 * v8 + v4[++v2] + 2) >> 2;
    int v3 = v6;
    int v5 = v8;
  }
  while (v2 != 15);
  return result;
}

void sub_1BBA241BC(int a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  char v6 = a1;
  if (a2)
  {
    int v10 = 1 << a1;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << a1)
      {
        uint64_t v11 = (2 << a1) - (uint64_t)v10;
        int v12 = &a5[v10];
        uint64_t v13 = (_DWORD *)(a4 + 4 * a3 * v10 - 4);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      uint64_t v14 = v10 - a3;
      if ((a2 & 0x1E00) != 0) {
        uint64_t v14 = -a3;
      }
      if ((a2 & 0x100) != 0) {
        uint64_t v14 = ~a3;
      }
      if ((a2 & 0xF0) != 0) {
        uint64_t v14 = (v10 - 1) * a3 - 1;
      }
      int v15 = *(_DWORD *)(a4 + 4 * v14);
      uint64_t v16 = v10;
      int v17 = &a5[v10];
      do
      {
        *v17++ = v15;
        --v16;
      }
      while (v16);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (a1 != 31)
      {
        if (v10 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v10;
        }
        uint64_t v19 = (_DWORD *)(a4 - 4);
        uint64_t v20 = a5;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      uint64_t v21 = v10;
      int v22 = a5[v10];
      uint64_t v23 = a5;
      do
      {
        *v23++ = v22;
        --v21;
      }
      while (v21);
    }
    uint64_t v24 = (int *)(a4 + 4 * ~a3);
    if ((a2 & 0x100) == 0) {
      uint64_t v24 = a5;
    }
    int v25 = *v24;
    *(a5 - 1) = v25;
    if ((a2 & 0x1E00) != 0)
    {
      memcpy(&a5[2 << a1], (const void *)(a4 - 4 * a3), 4 * v10);
    }
    else
    {
      uint64_t v26 = v10;
      uint32x4_t v27 = &a5[2 << a1];
      do
      {
        *v27++ = v25;
        --v26;
      }
      while (v26);
    }
    if ((a2 & 0x1E000) != 0)
    {
      memcpy(&a5[3 << v6], (const void *)(a4 + 4 * v10 - 4 * a3), 4 * v10);
    }
    else
    {
      uint64_t v28 = v10;
      uint16x8_t v29 = &a5[3 << v6];
      int v30 = *(v29 - 1);
      do
      {
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
  }
  else
  {
    memset_pattern16(a5 - 1, &unk_1BBB70180, (16 * ((unint64_t)(4 << a1) >> 2)) | 4);
  }
}

void sub_1BBA243F4(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v5 = (1 << a1);
    unsigned int v6 = __clz(__rbit32(a2));
    if (v6 < 9) {
      uint64_t v7 = ((2 << a1) + (char)~byte_1BBB78A7D[9 * a1 + 18 + v6]) * a3 - 1;
    }
    else {
      uint64_t v7 = byte_1BBB78A7D[9 * a1 + 9 + v6] - a3;
    }
    LODWORD(v8) = (int)v5 >> 2;
    unsigned int v9 = *(_DWORD *)(a4 + 4 * v7);
    if ((int)v5 >= 4)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 2 << a1;
      uint64_t v12 = a5 + 4 * v11;
      if ((int)v8 <= 1) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v8;
      }
      uint64_t v14 = a4 + 4 * a3 * (v11 - 1) - 4;
      do
      {
        uint64_t v15 = v10 + 1;
        if ((a2 >> v10))
        {
          uint64_t v16 = -4;
          int v17 = (unsigned int *)v14;
          do
          {
            unsigned int v9 = *v17;
            *(_DWORD *)(v12 + v16) = *v17;
            v16 -= 4;
            v17 -= a3;
          }
          while (v16 != -20);
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v11 - 4 * v15)) = vdupq_n_s32(v9);
        }
        v12 -= 16;
        v14 -= 16 * a3;
        uint64_t v10 = v15;
      }
      while (v15 != v13);
      uint64_t v18 = 0;
      uint64_t v19 = a5 + 4 * v5;
      uint64_t v20 = a4 + 4 * a3 * (v5 - 1) - 4;
      do
      {
        uint64_t v21 = v18 + 1;
        if (((a2 >> v18) & 0x10) != 0)
        {
          uint64_t v22 = -4;
          uint64_t v23 = (unsigned int *)v20;
          do
          {
            unsigned int v9 = *v23;
            *(_DWORD *)(v19 + v22) = *v23;
            v22 -= 4;
            v23 -= a3;
          }
          while (v22 != -20);
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v5 - 4 * v21)) = vdupq_n_s32(v9);
        }
        v19 -= 16;
        v20 -= 16 * a3;
        uint64_t v18 = v21;
      }
      while (v21 != v13);
    }
    if ((a2 & 0x100) != 0) {
      unsigned int v9 = *(_DWORD *)(a4 + 4 * ~a3);
    }
    *(_DWORD *)(a5 - 4) = v9;
    if ((int)v5 >= 4)
    {
      uint64_t v24 = 0;
      int v25 = 2 << a1;
      if ((int)v8 <= 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = v8;
      }
      uint64_t v26 = a5 + 4 * v25;
      uint64_t v27 = a4 - 4 * a3;
      do
      {
        if (((a2 >> v24) & 0x200) != 0)
        {
          for (uint64_t i = 0; i != 16; i += 4)
          {
            unsigned int v9 = *(_DWORD *)(v27 + i);
            *(_DWORD *)(v26 + i) = v9;
          }
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v25 + 4 * v24)) = vdupq_n_s32(v9);
        }
        ++v24;
        v26 += 16;
        v27 += 16;
      }
      while (v24 != v8);
      uint64_t v29 = 0;
      uint64_t v30 = a5 + 4 * (v25 + (unint64_t)v5);
      uint64_t v31 = a4 - 4 * a3 + 4 * v5;
      do
      {
        if (((a2 >> v29) & 0x2000) != 0)
        {
          for (uint64_t j = 0; j != 16; j += 4)
          {
            unsigned int v9 = *(_DWORD *)(v31 + j);
            *(_DWORD *)(v30 + j) = v9;
          }
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v5 + 4 * v29 + (2 << a1))) = vdupq_n_s32(v9);
        }
        ++v29;
        v30 += 16;
        v31 += 16;
      }
      while (v29 != v8);
    }
  }
  else
  {
    memset_pattern16((void *)(a5 - 4), &unk_1BBB70180, (16 * ((unint64_t)(4 << a1) >> 2)) | 4);
  }
}

void sub_1BBA24684(int a1, int a2, uint64_t a3, uint64_t a4, _WORD *a5)
{
  char v6 = a1;
  if (a2)
  {
    int v10 = 1 << a1;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << a1)
      {
        uint64_t v11 = (2 << a1) - (uint64_t)v10;
        uint64_t v12 = &a5[v10];
        uint64_t v13 = (_WORD *)(a4 + 2 * a3 * v10 - 2);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      uint64_t v14 = v10 - a3;
      if ((a2 & 0x1E00) != 0) {
        uint64_t v14 = -a3;
      }
      if ((a2 & 0x100) != 0) {
        uint64_t v14 = ~a3;
      }
      if ((a2 & 0xF0) != 0) {
        uint64_t v14 = (v10 - 1) * a3 - 1;
      }
      __int16 v15 = *(_WORD *)(a4 + 2 * v14);
      uint64_t v16 = v10;
      int v17 = &a5[v10];
      do
      {
        *v17++ = v15;
        --v16;
      }
      while (v16);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (a1 != 31)
      {
        if (v10 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v10;
        }
        uint64_t v19 = (_WORD *)(a4 - 2);
        uint64_t v20 = a5;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      uint64_t v21 = v10;
      __int16 v22 = a5[v10];
      uint64_t v23 = a5;
      do
      {
        *v23++ = v22;
        --v21;
      }
      while (v21);
    }
    uint64_t v24 = (__int16 *)(a4 + 2 * ~a3);
    if ((a2 & 0x100) == 0) {
      uint64_t v24 = a5;
    }
    __int16 v25 = *v24;
    *(a5 - 1) = v25;
    if ((a2 & 0x1E00) != 0)
    {
      memcpy(&a5[2 << a1], (const void *)(a4 - 2 * a3), 2 * v10);
    }
    else
    {
      uint64_t v26 = v10;
      uint64_t v27 = &a5[2 << a1];
      do
      {
        *v27++ = v25;
        --v26;
      }
      while (v26);
    }
    if ((a2 & 0x1E000) != 0)
    {
      memcpy(&a5[3 << v6], (const void *)(a4 + 2 * v10 - 2 * a3), 2 * v10);
    }
    else
    {
      uint64_t v28 = v10;
      uint64_t v29 = &a5[3 << v6];
      __int16 v30 = *(v29 - 1);
      do
      {
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
  }
  else
  {
    memset_pattern16(a5 - 1, &unk_1BBB70180, (8 * ((unint64_t)(4 << a1) >> 2)) | 2);
  }
}

void sub_1BBA248C0(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v6 = (1 << a1);
    if ((int)v6 >= 8) {
      uint64_t v7 = 8;
    }
    else {
      uint64_t v7 = v6;
    }
    unsigned int v8 = __clz(__rbit32(a2));
    if (v8 < 9) {
      uint64_t v9 = ((2 << a1) + (char)~byte_1BBB78A7D[9 * a1 - 18 + v8]) * a3 - 1;
    }
    else {
      uint64_t v9 = byte_1BBB78A7D[9 * a1 - 27 + v8] - a3;
    }
    LODWORD(v10) = ((int)v6 + 4) >> 3;
    __int16 v11 = *(_WORD *)(a4 + 2 * v9);
    if ((int)v6 >= 4)
    {
      uint64_t v12 = 0;
      int v13 = 2 << a1;
      if ((int)v10 <= 1) {
        uint64_t v14 = 1;
      }
      else {
        uint64_t v14 = v10;
      }
      if ((int)v6 >= 8) {
        int v15 = 8;
      }
      else {
        int v15 = 1 << a1;
      }
      uint64_t v16 = v15;
      uint64_t v17 = a5 + 2 * v13;
      uint64_t v18 = -2 * v15;
      uint64_t v19 = a4 + 2 * a3 * (v13 - 1);
      uint64_t v20 = a3 * v15;
      uint64_t v21 = (__int16 *)(v17 - 2);
      __int16 v22 = (__int16 *)(v19 - 2);
      uint64_t v23 = -(uint64_t)v15;
      do
      {
        if ((a2 >> v12))
        {
          uint64_t v24 = v7 + 1;
          __int16 v25 = v22;
          uint64_t v26 = v21;
          do
          {
            __int16 v11 = *v25;
            *v26-- = *v25;
            v25 -= a3;
            --v24;
          }
          while (v24 > 1);
        }
        else
        {
          uint64_t v27 = v23;
          do
          {
            *(_WORD *)(v17 + 2 * v27) = v11;
            BOOL v28 = __CFADD__(v27++, 1);
          }
          while (!v28);
        }
        ++v12;
        uint64_t v21 = (__int16 *)((char *)v21 + v18);
        v22 -= v20;
        v17 += v18;
      }
      while (v12 != v14);
      uint64_t v29 = 0;
      uint64_t v30 = a5 + 2 * v6;
      uint64_t v31 = -2 * v16;
      if ((1 << a1) >= 8uLL) {
        uint64_t v32 = 8;
      }
      else {
        uint64_t v32 = (1 << a1);
      }
      uint64_t v33 = (__int16 *)(v30 - 2);
      uint64_t v34 = a4 + 2 * a3 * (v6 - 1) - 2;
      uint64_t v35 = -2 * v20;
      uint64_t v36 = v32 + 1;
      uint64_t v37 = -v16;
      do
      {
        if (((a2 >> v29) & 0x10) != 0)
        {
          uint64_t v38 = v36;
          long long v39 = (__int16 *)v34;
          long long v40 = v33;
          do
          {
            __int16 v11 = *v39;
            *v40-- = *v39;
            v39 -= a3;
            --v38;
          }
          while (v38 > 1);
        }
        else
        {
          uint64_t v41 = v37;
          do
          {
            *(_WORD *)(v30 + 2 * v41) = v11;
            BOOL v28 = __CFADD__(v41++, 1);
          }
          while (!v28);
        }
        ++v29;
        uint64_t v33 = (__int16 *)((char *)v33 + v31);
        v34 += v35;
        v30 += v31;
      }
      while (v29 != v14);
    }
    if ((a2 & 0x100) != 0) {
      __int16 v11 = *(_WORD *)(a4 + 2 * ~a3);
    }
    *(_WORD *)(a5 - 2) = v11;
    if ((int)v6 >= 4)
    {
      uint64_t v42 = 0;
      int v43 = 2 << a1;
      uint64_t v44 = (int)v7;
      if ((int)v7 <= 1) {
        uint64_t v45 = 1;
      }
      else {
        uint64_t v45 = v7;
      }
      uint64_t v46 = v43;
      if ((int)v10 <= 1) {
        uint64_t v10 = 1;
      }
      else {
        uint64_t v10 = v10;
      }
      uint64_t v47 = 2 * (int)v7;
      long long v48 = (__int16 *)(a4 - 2 * a3);
      __int16 v49 = v48;
      uint64_t v50 = (_WORD *)(a5 + 2 * v43);
      do
      {
        if (((a2 >> v42) & 0x200) != 0)
        {
          uint64_t v51 = v49;
          long long v52 = v50;
          uint64_t v53 = v45;
          do
          {
            __int16 v54 = *v51++;
            __int16 v11 = v54;
            *v52++ = v54;
            --v53;
          }
          while (v53);
        }
        else
        {
          uint64_t v55 = 0;
          do
            v50[v55++] = v11;
          while (v44 != v55);
        }
        ++v42;
        uint64_t v50 = (_WORD *)((char *)v50 + v47);
        __int16 v49 = (__int16 *)((char *)v49 + v47);
      }
      while (v42 != v10);
      uint64_t v56 = 0;
      long long v57 = (_WORD *)(a5 + 2 * (v46 + v6));
      uint64_t v58 = 2 * v44;
      long long v59 = &v48[v6];
      do
      {
        if (((a2 >> v56) & 0x2000) != 0)
        {
          __int16 v60 = v59;
          uint64_t v61 = v57;
          uint64_t v62 = v45;
          do
          {
            __int16 v63 = *v60++;
            __int16 v11 = v63;
            *v61++ = v63;
            --v62;
          }
          while (v62);
        }
        else
        {
          uint64_t v64 = 0;
          do
            v57[v64++] = v11;
          while (v44 != v64);
        }
        ++v56;
        long long v57 = (_WORD *)((char *)v57 + v58);
        long long v59 = (__int16 *)((char *)v59 + v58);
      }
      while (v56 != v10);
    }
  }
  else
  {
    memset_pattern16((void *)(a5 - 2), &unk_1BBB70180, (8 * ((unint64_t)(4 << a1) >> 2)) | 2);
  }
}

uint64_t sub_1BBA24BE8(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 >= 1)
  {
    uint64_t v5 = a5;
    uint64_t v8 = result;
    int v9 = 0;
    uint64_t v10 = a5 + 2;
    uint64_t v17 = a2;
    char v11 = 9 - a3;
    uint64_t v12 = 4 * a2;
    uint64_t v13 = 2 * a4;
    do
    {
      uint64_t v14 = 0;
      do
      {
        *(_WORD *)(v5 + v14) = sub_1BBA196DC(v8, a3) << v11;
        v14 += 4;
      }
      while (v12 != v14);
      ++v9;
      v5 += v13;
    }
    while (v9 != a2);
    int v15 = 0;
    do
    {
      uint64_t v16 = 0;
      do
      {
        uint64_t result = sub_1BBA196DC(v8, a3);
        *(_WORD *)(v10 + v16) = result << v11;
        v16 += 4;
      }
      while (4 * v17 != v16);
      ++v15;
      v10 += v13;
    }
    while (v15 != a2);
  }
  return result;
}

uint64_t sub_1BBA24CDC(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 >= 1)
  {
    uint64_t v8 = result;
    int v9 = 0;
    char v10 = 9 - a3;
    uint64_t v11 = 2 * a2;
    uint64_t v12 = 2 * a4;
    do
    {
      uint64_t v13 = 0;
      do
      {
        uint64_t result = sub_1BBA196DC(v8, a3);
        *(_WORD *)(a5 + v13) = result << v10;
        v13 += 2;
      }
      while (v11 != v13);
      ++v9;
      a5 += v12;
    }
    while (v9 != a2);
  }
  return result;
}

void sub_1BBA24D7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  for (uint64_t i = 0; i != 64; ++i)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (const __int16 *)(a2 + 2 * i);
    int16x8_t v7 = vld1q_dup_s16(v6);
    do
    {
      *(int16x8_t *)(a4 + v5) = v7;
      v5 += 16;
    }
    while (v5 != 128);
    a4 += 2 * a3;
  }
}

void sub_1BBA24DB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  for (uint64_t i = 0; i != 32; ++i)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (const __int16 *)(a2 + 2 * i);
    int16x8_t v7 = vld1q_dup_s16(v6);
    do
    {
      *(int16x8_t *)(a4 + v5) = v7;
      v5 += 16;
    }
    while (v5 != 64);
    a4 += 2 * a3;
  }
}

int16x8_t sub_1BBA24DEC(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  for (uint64_t i = 0; i != 16; ++i)
  {
    int v5 = *a2 + ((__int16)(a2[i + 32] - *(a2 - 1)) >> 1);
    if (v5 >= 511) {
      int v5 = 511;
    }
    *(_WORD *)(a4 + i * 2) = v5 & ~(unsigned __int16)(v5 >> 31);
  }
  uint64_t v6 = (int16x8_t *)(a4 + 2 * a3 + 16);
  for (uint64_t j = 1; j != 16; ++j)
  {
    uint64_t v8 = (const __int16 *)&a2[j];
    int16x8_t result = vld1q_dup_s16(v8);
    v6[-1] = result;
    int16x8_t *v6 = result;
    uint64_t v6 = (int16x8_t *)((char *)v6 + 2 * a3);
  }
  return result;
}

int16x8_t sub_1BBA24E5C(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  for (uint64_t i = 0; i != 8; ++i)
  {
    int v5 = *a2 + ((__int16)(a2[i + 16] - *(a2 - 1)) >> 1);
    if (v5 >= 511) {
      int v5 = 511;
    }
    *(_WORD *)(a4 + i * 2) = v5 & ~(unsigned __int16)(v5 >> 31);
  }
  uint64_t v6 = 1;
  int16x8_t v7 = (int16x8_t *)(a4 + 2 * a3);
  do
  {
    uint64_t v8 = (const __int16 *)&a2[v6];
    int16x8_t result = vld1q_dup_s16(v8);
    *int16x8_t v7 = result;
    ++v6;
    int16x8_t v7 = (int16x8_t *)((char *)v7 + 2 * a3);
  }
  while (v6 != 8);
  return result;
}

int16x4_t sub_1BBA24EC8(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  for (uint64_t i = 0; i != 4; ++i)
  {
    int v5 = *a2 + ((__int16)(a2[i + 8] - *(a2 - 1)) >> 1);
    if (v5 >= 511) {
      int v5 = 511;
    }
    *(_WORD *)(a4 + i * 2) = v5 & ~(unsigned __int16)(v5 >> 31);
  }
  uint64_t v6 = 1;
  int16x8_t v7 = (int16x4_t *)(a4 + 2 * a3);
  do
  {
    uint64_t v8 = (const __int16 *)&a2[v6];
    int16x4_t result = vld1_dup_s16(v8);
    *int16x8_t v7 = result;
    ++v6;
    int16x8_t v7 = (int16x4_t *)((char *)v7 + 2 * a3);
  }
  while (v6 != 4);
  return result;
}

__n128 sub_1BBA24F34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = 64;
  do
  {
    long long v5 = *(_OWORD *)(a2 + 256);
    long long v6 = *(_OWORD *)(a2 + 272);
    long long v7 = *(_OWORD *)(a2 + 304);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a4 + 48) = v7;
    *(_OWORD *)a4 = v5;
    *(_OWORD *)(a4 + 16) = v6;
    __n128 result = *(__n128 *)(a2 + 320);
    long long v9 = *(_OWORD *)(a2 + 336);
    long long v10 = *(_OWORD *)(a2 + 368);
    *(_OWORD *)(a4 + 96) = *(_OWORD *)(a2 + 352);
    *(_OWORD *)(a4 + 112) = v10;
    *(__n128 *)(a4 + 64) = result;
    *(_OWORD *)(a4 + 80) = v9;
    a4 += 2 * a3;
    --v4;
  }
  while (v4);
  return result;
}

__n128 sub_1BBA24F70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = 32;
  do
  {
    __n128 result = *(__n128 *)(a2 + 128);
    long long v6 = *(_OWORD *)(a2 + 144);
    long long v7 = *(_OWORD *)(a2 + 176);
    *(_OWORD *)(a4 + 32) = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(a4 + 48) = v7;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v6;
    a4 += 2 * a3;
    --v4;
  }
  while (v4);
  return result;
}

__n128 sub_1BBA24F9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = a4 + 2;
  do
  {
    int v6 = *(unsigned __int16 *)(a2 + 64) + ((__int16)(*(_WORD *)(a2 + v4) - *(_WORD *)(a2 - 2)) >> 1);
    if (v6 >= 511) {
      int v6 = 511;
    }
    *(_WORD *)(v5 - 2) = v6 & ~(unsigned __int16)(v6 >> 31);
    __n128 result = *(__n128 *)(a2 + 66);
    *(_OWORD *)(v5 + 14) = *(_OWORD *)(a2 + 80);
    *(__n128 *)uint64_t v5 = result;
    v4 += 2;
    v5 += 2 * a3;
  }
  while (v4 != 32);
  return result;
}

void sub_1BBA24FFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = (void *)(a4 + 2);
  do
  {
    int v6 = *(unsigned __int16 *)(a2 + 32) + ((__int16)(*(_WORD *)(a2 + v4) - *(_WORD *)(a2 - 2)) >> 1);
    if (v6 >= 511) {
      int v6 = 511;
    }
    *((_WORD *)v5 - 1) = v6 & ~(unsigned __int16)(v6 >> 31);
    uint64_t v7 = *(void *)(a2 + 34);
    *(void *)((char *)v5 + 6) = *(void *)(a2 + 40);
    *uint64_t v5 = v7;
    v4 += 2;
    uint64_t v5 = (void *)((char *)v5 + 2 * a3);
  }
  while (v4 != 16);
}

void sub_1BBA2505C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = a4 + 2;
  do
  {
    int v6 = *(unsigned __int16 *)(a2 + 16) + ((__int16)(*(_WORD *)(a2 + v4) - *(_WORD *)(a2 - 2)) >> 1);
    if (v6 >= 511) {
      int v6 = 511;
    }
    *(_WORD *)(v5 - 2) = v6 & ~(unsigned __int16)(v6 >> 31);
    int v7 = *(_DWORD *)(a2 + 18);
    *(_WORD *)(v5 + 4) = *(_WORD *)(a2 + 22);
    *(_DWORD *)uint64_t v5 = v7;
    v4 += 2;
    v5 += 2 * a3;
  }
  while (v4 != 8);
}

unsigned __int16 *sub_1BBA250BC(unsigned __int16 *result, uint64_t a2)
{
  int v2 = *(result - 1);
  int v3 = result[127];
  int v4 = v3 + v2 - 2 * result[95];
  if (v4 < 0) {
    int v4 = 2 * result[95] - (v3 + v2);
  }
  if (v4 > 0xF) {
    goto LABEL_7;
  }
  int v5 = result[63] + v2 - 2 * result[31];
  if (v5 < 0) {
    int v5 = 2 * result[31] - (result[63] + v2);
  }
  if (v5 < 0x10)
  {
    uint64_t v12 = 0;
    *(_WORD *)(a2 + 254) = v3;
    *(_WORD *)(a2 + 126) = result[63];
    *(_WORD *)(a2 - 2) = *(result - 1);
    do
    {
      uint64_t v13 = (_WORD *)(a2 + 2 * v12);
      *uint64_t v13 = *(result - 1) + (((result[63] - *(result - 1)) * (v12 + 1) + 32) >> 6);
      v13[64] = *(result - 1) + (((result[127] - *(result - 1)) * (v12++ + 1) + 32) >> 6);
    }
    while (v12 != 63);
  }
  else
  {
LABEL_7:
    uint64_t v6 = 0;
    int v7 = result + 64;
    *(_WORD *)(a2 - 2) = (*result + 2 * v2 + result[64] + 2) >> 2;
    *(_WORD *)(a2 + 254) = result[127];
    *(_WORD *)(a2 + 126) = result[63];
    int v8 = v2;
    do
    {
      int v9 = result[v6];
      long long v10 = (_WORD *)(a2 + v6 * 2);
      _WORD *v10 = (v2 + 2 * v9 + v7[v6 - 63] + 2) >> 2;
      int v11 = v7[v6];
      v10[64] = (v8 + 2 * v11 + v7[++v6] + 2) >> 2;
      int v2 = v9;
      int v8 = v11;
    }
    while (v6 != 63);
  }
  return result;
}

void sub_1BBA251F4(int a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  char v6 = a1;
  if (a2)
  {
    int v10 = 1 << a1;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << a1)
      {
        uint64_t v11 = (2 << a1) - (uint64_t)v10;
        uint64_t v12 = &a5[v10];
        uint64_t v13 = (_DWORD *)(a4 + 4 * a3 * v10 - 4);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      uint64_t v14 = v10 - a3;
      if ((a2 & 0x1E00) != 0) {
        uint64_t v14 = -a3;
      }
      if ((a2 & 0x100) != 0) {
        uint64_t v14 = ~a3;
      }
      if ((a2 & 0xF0) != 0) {
        uint64_t v14 = (v10 - 1) * a3 - 1;
      }
      int v15 = *(_DWORD *)(a4 + 4 * v14);
      uint64_t v16 = v10;
      uint64_t v17 = &a5[v10];
      do
      {
        *v17++ = v15;
        --v16;
      }
      while (v16);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (a1 != 31)
      {
        if (v10 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v10;
        }
        uint64_t v19 = (_DWORD *)(a4 - 4);
        uint64_t v20 = a5;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      uint64_t v21 = v10;
      int v22 = a5[v10];
      uint64_t v23 = a5;
      do
      {
        *v23++ = v22;
        --v21;
      }
      while (v21);
    }
    uint64_t v24 = (int *)(a4 + 4 * ~a3);
    if ((a2 & 0x100) == 0) {
      uint64_t v24 = a5;
    }
    int v25 = *v24;
    *(a5 - 1) = v25;
    if ((a2 & 0x1E00) != 0)
    {
      memcpy(&a5[2 << a1], (const void *)(a4 - 4 * a3), 4 * v10);
    }
    else
    {
      uint64_t v26 = v10;
      uint64_t v27 = &a5[2 << a1];
      do
      {
        *v27++ = v25;
        --v26;
      }
      while (v26);
    }
    if ((a2 & 0x1E000) != 0)
    {
      memcpy(&a5[3 << v6], (const void *)(a4 + 4 * v10 - 4 * a3), 4 * v10);
    }
    else
    {
      uint64_t v28 = v10;
      uint64_t v29 = &a5[3 << v6];
      int v30 = *(v29 - 1);
      do
      {
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
  }
  else
  {
    memset_pattern16(a5 - 1, &unk_1BBB70170, (16 * ((unint64_t)(4 << a1) >> 2)) | 4);
  }
}

void sub_1BBA2542C(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v5 = (1 << a1);
    unsigned int v6 = __clz(__rbit32(a2));
    if (v6 < 9) {
      uint64_t v7 = ((2 << a1) + (char)~byte_1BBB78A7D[9 * a1 + 18 + v6]) * a3 - 1;
    }
    else {
      uint64_t v7 = byte_1BBB78A7D[9 * a1 + 9 + v6] - a3;
    }
    LODWORD(v8) = (int)v5 >> 2;
    unsigned int v9 = *(_DWORD *)(a4 + 4 * v7);
    if ((int)v5 >= 4)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 2 << a1;
      uint64_t v12 = a5 + 4 * v11;
      if ((int)v8 <= 1) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v8;
      }
      uint64_t v14 = a4 + 4 * a3 * (v11 - 1) - 4;
      do
      {
        uint64_t v15 = v10 + 1;
        if ((a2 >> v10))
        {
          uint64_t v16 = -4;
          uint64_t v17 = (unsigned int *)v14;
          do
          {
            unsigned int v9 = *v17;
            *(_DWORD *)(v12 + v16) = *v17;
            v16 -= 4;
            v17 -= a3;
          }
          while (v16 != -20);
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v11 - 4 * v15)) = vdupq_n_s32(v9);
        }
        v12 -= 16;
        v14 -= 16 * a3;
        uint64_t v10 = v15;
      }
      while (v15 != v13);
      uint64_t v18 = 0;
      uint64_t v19 = a5 + 4 * v5;
      uint64_t v20 = a4 + 4 * a3 * (v5 - 1) - 4;
      do
      {
        uint64_t v21 = v18 + 1;
        if (((a2 >> v18) & 0x10) != 0)
        {
          uint64_t v22 = -4;
          uint64_t v23 = (unsigned int *)v20;
          do
          {
            unsigned int v9 = *v23;
            *(_DWORD *)(v19 + v22) = *v23;
            v22 -= 4;
            v23 -= a3;
          }
          while (v22 != -20);
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v5 - 4 * v21)) = vdupq_n_s32(v9);
        }
        v19 -= 16;
        v20 -= 16 * a3;
        uint64_t v18 = v21;
      }
      while (v21 != v13);
    }
    if ((a2 & 0x100) != 0) {
      unsigned int v9 = *(_DWORD *)(a4 + 4 * ~a3);
    }
    *(_DWORD *)(a5 - 4) = v9;
    if ((int)v5 >= 4)
    {
      uint64_t v24 = 0;
      int v25 = 2 << a1;
      if ((int)v8 <= 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = v8;
      }
      uint64_t v26 = a5 + 4 * v25;
      uint64_t v27 = a4 - 4 * a3;
      do
      {
        if (((a2 >> v24) & 0x200) != 0)
        {
          for (uint64_t i = 0; i != 16; i += 4)
          {
            unsigned int v9 = *(_DWORD *)(v27 + i);
            *(_DWORD *)(v26 + i) = v9;
          }
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v25 + 4 * v24)) = vdupq_n_s32(v9);
        }
        ++v24;
        v26 += 16;
        v27 += 16;
      }
      while (v24 != v8);
      uint64_t v29 = 0;
      uint64_t v30 = a5 + 4 * (v25 + (unint64_t)v5);
      uint64_t v31 = a4 - 4 * a3 + 4 * v5;
      do
      {
        if (((a2 >> v29) & 0x2000) != 0)
        {
          for (uint64_t j = 0; j != 16; j += 4)
          {
            unsigned int v9 = *(_DWORD *)(v31 + j);
            *(_DWORD *)(v30 + j) = v9;
          }
        }
        else
        {
          *(int32x4_t *)(a5 + 4 * (v5 + 4 * v29 + (2 << a1))) = vdupq_n_s32(v9);
        }
        ++v29;
        v30 += 16;
        v31 += 16;
      }
      while (v29 != v8);
    }
  }
  else
  {
    memset_pattern16((void *)(a5 - 4), &unk_1BBB70170, (16 * ((unint64_t)(4 << a1) >> 2)) | 4);
  }
}

void sub_1BBA256BC(int a1, int a2, uint64_t a3, uint64_t a4, _WORD *a5)
{
  char v6 = a1;
  if (a2)
  {
    int v10 = 1 << a1;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << a1)
      {
        uint64_t v11 = (2 << a1) - (uint64_t)v10;
        uint64_t v12 = &a5[v10];
        uint64_t v13 = (_WORD *)(a4 + 2 * a3 * v10 - 2);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      uint64_t v14 = v10 - a3;
      if ((a2 & 0x1E00) != 0) {
        uint64_t v14 = -a3;
      }
      if ((a2 & 0x100) != 0) {
        uint64_t v14 = ~a3;
      }
      if ((a2 & 0xF0) != 0) {
        uint64_t v14 = (v10 - 1) * a3 - 1;
      }
      __int16 v15 = *(_WORD *)(a4 + 2 * v14);
      uint64_t v16 = v10;
      uint64_t v17 = &a5[v10];
      do
      {
        *v17++ = v15;
        --v16;
      }
      while (v16);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (a1 != 31)
      {
        if (v10 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v10;
        }
        uint64_t v19 = (_WORD *)(a4 - 2);
        uint64_t v20 = a5;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      uint64_t v21 = v10;
      __int16 v22 = a5[v10];
      uint64_t v23 = a5;
      do
      {
        *v23++ = v22;
        --v21;
      }
      while (v21);
    }
    uint64_t v24 = (__int16 *)(a4 + 2 * ~a3);
    if ((a2 & 0x100) == 0) {
      uint64_t v24 = a5;
    }
    __int16 v25 = *v24;
    *(a5 - 1) = v25;
    if ((a2 & 0x1E00) != 0)
    {
      memcpy(&a5[2 << a1], (const void *)(a4 - 2 * a3), 2 * v10);
    }
    else
    {
      uint64_t v26 = v10;
      uint64_t v27 = &a5[2 << a1];
      do
      {
        *v27++ = v25;
        --v26;
      }
      while (v26);
    }
    if ((a2 & 0x1E000) != 0)
    {
      memcpy(&a5[3 << v6], (const void *)(a4 + 2 * v10 - 2 * a3), 2 * v10);
    }
    else
    {
      uint64_t v28 = v10;
      uint64_t v29 = &a5[3 << v6];
      __int16 v30 = *(v29 - 1);
      do
      {
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
  }
  else
  {
    memset_pattern16(a5 - 1, &unk_1BBB70170, (8 * ((unint64_t)(4 << a1) >> 2)) | 2);
  }
}

void sub_1BBA258F8(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v6 = (1 << a1);
    if ((int)v6 >= 8) {
      uint64_t v7 = 8;
    }
    else {
      uint64_t v7 = v6;
    }
    unsigned int v8 = __clz(__rbit32(a2));
    if (v8 < 9) {
      uint64_t v9 = ((2 << a1) + (char)~byte_1BBB78A7D[9 * a1 - 18 + v8]) * a3 - 1;
    }
    else {
      uint64_t v9 = byte_1BBB78A7D[9 * a1 - 27 + v8] - a3;
    }
    LODWORD(v10) = ((int)v6 + 4) >> 3;
    __int16 v11 = *(_WORD *)(a4 + 2 * v9);
    if ((int)v6 >= 4)
    {
      uint64_t v12 = 0;
      int v13 = 2 << a1;
      if ((int)v10 <= 1) {
        uint64_t v14 = 1;
      }
      else {
        uint64_t v14 = v10;
      }
      if ((int)v6 >= 8) {
        int v15 = 8;
      }
      else {
        int v15 = 1 << a1;
      }
      uint64_t v16 = v15;
      uint64_t v17 = a5 + 2 * v13;
      uint64_t v18 = -2 * v15;
      uint64_t v19 = a4 + 2 * a3 * (v13 - 1);
      uint64_t v20 = a3 * v15;
      uint64_t v21 = (__int16 *)(v17 - 2);
      __int16 v22 = (__int16 *)(v19 - 2);
      uint64_t v23 = -(uint64_t)v15;
      do
      {
        if ((a2 >> v12))
        {
          uint64_t v24 = v7 + 1;
          __int16 v25 = v22;
          uint64_t v26 = v21;
          do
          {
            __int16 v11 = *v25;
            *v26-- = *v25;
            v25 -= a3;
            --v24;
          }
          while (v24 > 1);
        }
        else
        {
          uint64_t v27 = v23;
          do
          {
            *(_WORD *)(v17 + 2 * v27) = v11;
            BOOL v28 = __CFADD__(v27++, 1);
          }
          while (!v28);
        }
        ++v12;
        uint64_t v21 = (__int16 *)((char *)v21 + v18);
        v22 -= v20;
        v17 += v18;
      }
      while (v12 != v14);
      uint64_t v29 = 0;
      uint64_t v30 = a5 + 2 * v6;
      uint64_t v31 = -2 * v16;
      if ((1 << a1) >= 8uLL) {
        uint64_t v32 = 8;
      }
      else {
        uint64_t v32 = (1 << a1);
      }
      uint64_t v33 = (__int16 *)(v30 - 2);
      uint64_t v34 = a4 + 2 * a3 * (v6 - 1) - 2;
      uint64_t v35 = -2 * v20;
      uint64_t v36 = v32 + 1;
      uint64_t v37 = -v16;
      do
      {
        if (((a2 >> v29) & 0x10) != 0)
        {
          uint64_t v38 = v36;
          long long v39 = (__int16 *)v34;
          long long v40 = v33;
          do
          {
            __int16 v11 = *v39;
            *v40-- = *v39;
            v39 -= a3;
            --v38;
          }
          while (v38 > 1);
        }
        else
        {
          uint64_t v41 = v37;
          do
          {
            *(_WORD *)(v30 + 2 * v41) = v11;
            BOOL v28 = __CFADD__(v41++, 1);
          }
          while (!v28);
        }
        ++v29;
        uint64_t v33 = (__int16 *)((char *)v33 + v31);
        v34 += v35;
        v30 += v31;
      }
      while (v29 != v14);
    }
    if ((a2 & 0x100) != 0) {
      __int16 v11 = *(_WORD *)(a4 + 2 * ~a3);
    }
    *(_WORD *)(a5 - 2) = v11;
    if ((int)v6 >= 4)
    {
      uint64_t v42 = 0;
      int v43 = 2 << a1;
      uint64_t v44 = (int)v7;
      if ((int)v7 <= 1) {
        uint64_t v45 = 1;
      }
      else {
        uint64_t v45 = v7;
      }
      uint64_t v46 = v43;
      if ((int)v10 <= 1) {
        uint64_t v10 = 1;
      }
      else {
        uint64_t v10 = v10;
      }
      uint64_t v47 = 2 * (int)v7;
      long long v48 = (__int16 *)(a4 - 2 * a3);
      __int16 v49 = v48;
      uint64_t v50 = (_WORD *)(a5 + 2 * v43);
      do
      {
        if (((a2 >> v42) & 0x200) != 0)
        {
          uint64_t v51 = v49;
          long long v52 = v50;
          uint64_t v53 = v45;
          do
          {
            __int16 v54 = *v51++;
            __int16 v11 = v54;
            *v52++ = v54;
            --v53;
          }
          while (v53);
        }
        else
        {
          uint64_t v55 = 0;
          do
            v50[v55++] = v11;
          while (v44 != v55);
        }
        ++v42;
        uint64_t v50 = (_WORD *)((char *)v50 + v47);
        __int16 v49 = (__int16 *)((char *)v49 + v47);
      }
      while (v42 != v10);
      uint64_t v56 = 0;
      long long v57 = (_WORD *)(a5 + 2 * (v46 + v6));
      uint64_t v58 = 2 * v44;
      long long v59 = &v48[v6];
      do
      {
        if (((a2 >> v56) & 0x2000) != 0)
        {
          __int16 v60 = v59;
          uint64_t v61 = v57;
          uint64_t v62 = v45;
          do
          {
            __int16 v63 = *v60++;
            __int16 v11 = v63;
            *v61++ = v63;
            --v62;
          }
          while (v62);
        }
        else
        {
          uint64_t v64 = 0;
          do
            v57[v64++] = v11;
          while (v44 != v64);
        }
        ++v56;
        long long v57 = (_WORD *)((char *)v57 + v58);
        long long v59 = (__int16 *)((char *)v59 + v58);
      }
      while (v56 != v10);
    }
  }
  else
  {
    memset_pattern16((void *)(a5 - 2), &unk_1BBB70170, (8 * ((unint64_t)(4 << a1) >> 2)) | 2);
  }
}

uint64_t sub_1BBA25C20(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 >= 1)
  {
    uint64_t v5 = a5;
    uint64_t v9 = result;
    int v10 = 0;
    uint64_t v11 = a5 + 1;
    char v12 = 8 - a3;
    uint64_t v17 = a2;
    uint64_t v13 = 2 * a2;
    do
    {
      uint64_t v14 = 0;
      do
      {
        *(unsigned char *)(v5 + v14) = sub_1BBA196DC(v9, a3) << v12;
        v14 += 2;
      }
      while (v13 != v14);
      v5 += a4;
      ++v10;
    }
    while (v10 != a2);
    int v15 = 0;
    do
    {
      uint64_t v16 = 0;
      do
      {
        __n128 result = sub_1BBA196DC(v9, a3);
        *(unsigned char *)(v11 + v16) = result << v12;
        v16 += 2;
      }
      while (2 * v17 != v16);
      v11 += a4;
      ++v15;
    }
    while (v15 != a2);
  }
  return result;
}

uint64_t sub_1BBA25D14(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 >= 1)
  {
    uint64_t v9 = result;
    int v10 = 0;
    char v11 = 8 - a3;
    uint64_t v12 = a2;
    do
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        __n128 result = sub_1BBA196DC(v9, a3);
        *(unsigned char *)(a5 + i) = result << v11;
      }
      a5 += a4;
      ++v10;
    }
    while (v10 != a2);
  }
  return result;
}

void *sub_1BBA25DB4(void *result, int a2, uint64_t a3, uint64_t a4, _WORD *a5)
{
  char v6 = (char)result;
  if (a2)
  {
    int v10 = 1 << (char)result;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << (char)result)
      {
        uint64_t v11 = (2 << (char)result) - (uint64_t)v10;
        uint64_t v12 = &a5[v10];
        uint64_t v13 = (_WORD *)(a4 + 2 * a3 * v10 - 2);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      uint64_t v14 = v10 - a3;
      if ((a2 & 0x1E00) != 0) {
        uint64_t v14 = -a3;
      }
      if ((a2 & 0x100) != 0) {
        uint64_t v14 = ~a3;
      }
      if ((a2 & 0xF0) != 0) {
        uint64_t v14 = (v10 - 1) * a3 - 1;
      }
      __int16 v15 = *(_WORD *)(a4 + 2 * v14);
      uint64_t v16 = v10;
      uint64_t v17 = &a5[v10];
      do
      {
        *v17++ = v15;
        --v16;
      }
      while (v16);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (result != 31)
      {
        if (v10 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v10;
        }
        uint64_t v19 = (_WORD *)(a4 - 2);
        uint64_t v20 = a5;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      uint64_t v21 = v10;
      __int16 v22 = a5[v10];
      uint64_t v23 = a5;
      do
      {
        *v23++ = v22;
        --v21;
      }
      while (v21);
    }
    uint64_t v24 = (__int16 *)(a4 + 2 * ~a3);
    if ((a2 & 0x100) == 0) {
      uint64_t v24 = a5;
    }
    __int16 v25 = *v24;
    *(a5 - 1) = v25;
    if ((a2 & 0x1E00) != 0)
    {
      __n128 result = memcpy(&a5[2 << (char)result], (const void *)(a4 - 2 * a3), 2 * v10);
    }
    else
    {
      uint64_t v26 = v10;
      uint64_t v27 = &a5[2 << (char)result];
      do
      {
        *v27++ = v25;
        --v26;
      }
      while (v26);
    }
    if ((a2 & 0x1E000) != 0)
    {
      return memcpy(&a5[3 << v6], (const void *)(a4 + 2 * v10 - 2 * a3), 2 * v10);
    }
    else
    {
      uint64_t v28 = v10;
      uint64_t v29 = &a5[3 << v6];
      __int16 v30 = *(v29 - 1);
      do
      {
        *v29++ = v30;
        --v28;
      }
      while (v28);
    }
  }
  else
  {
    return memset(a5 - 1, 128, (8 * ((unint64_t)(4 << (char)result) >> 2)) | 2);
  }
  return result;
}

void *sub_1BBA25FEC(void *result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a2) {
    return memset((void *)(a5 - 2), 128, (8 * ((unint64_t)(4 << (char)result) >> 2)) | 2);
  }
  uint64_t v5 = (1 << (char)result);
  unsigned int v6 = __clz(__rbit32(a2));
  if (v6 < 9) {
    uint64_t v7 = ((2 << (char)result) + (char)~byte_1BBB78A7D[9 * (int)result + 18 + v6]) * a3 - 1;
  }
  else {
    uint64_t v7 = byte_1BBB78A7D[9 * (int)result + 9 + v6] - a3;
  }
  LODWORD(v8) = (int)v5 >> 2;
  unsigned int v9 = *(unsigned __int16 *)(a4 + 2 * v7);
  if ((int)v5 >= 4)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 2 << (char)result;
    uint64_t v12 = a5 + 2 * v11;
    if ((int)v8 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = v8;
    }
    uint64_t v14 = a4 + 2 * a3 * (v11 - 1) - 2;
    do
    {
      uint64_t v15 = v10 + 1;
      if ((a2 >> v10))
      {
        uint64_t v16 = -2;
        uint64_t v17 = (unsigned __int16 *)v14;
        do
        {
          unsigned int v9 = *v17;
          *(_WORD *)(v12 + v16) = v9;
          v16 -= 2;
          v17 -= a3;
        }
        while (v16 != -10);
      }
      else
      {
        *(int16x4_t *)(a5 + 2 * (v11 - 4 * v15)) = vdup_n_s16(v9);
      }
      v12 -= 8;
      v14 -= 8 * a3;
      uint64_t v10 = v15;
    }
    while (v15 != v13);
    uint64_t v18 = 0;
    uint64_t v19 = a5 + 2 * v5;
    uint64_t v20 = a4 + 2 * a3 * (v5 - 1) - 2;
    do
    {
      uint64_t v21 = v18 + 1;
      if (((a2 >> v18) & 0x10) != 0)
      {
        uint64_t v22 = -2;
        uint64_t v23 = (unsigned __int16 *)v20;
        do
        {
          unsigned int v9 = *v23;
          *(_WORD *)(v19 + v22) = v9;
          v22 -= 2;
          v23 -= a3;
        }
        while (v22 != -10);
      }
      else
      {
        *(int16x4_t *)(a5 + 2 * (v5 - 4 * v21)) = vdup_n_s16(v9);
      }
      v19 -= 8;
      v20 -= 8 * a3;
      uint64_t v18 = v21;
    }
    while (v21 != v13);
  }
  if ((a2 & 0x100) != 0) {
    unsigned int v9 = *(unsigned __int16 *)(a4 + 2 * ~a3);
  }
  *(_WORD *)(a5 - 2) = v9;
  if ((int)v5 >= 4)
  {
    uint64_t v24 = 0;
    int v25 = 2 << (char)result;
    if ((int)v8 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v8;
    }
    uint64_t v26 = a5 + 2 * v25;
    uint64_t v27 = a4 - 2 * a3;
    do
    {
      if (((a2 >> v24) & 0x200) != 0)
      {
        for (uint64_t i = 0; i != 8; i += 2)
        {
          unsigned int v9 = *(unsigned __int16 *)(v27 + i);
          *(_WORD *)(v26 + i) = v9;
        }
      }
      else
      {
        *(int16x4_t *)(a5 + 2 * (4 * v24 + v25)) = vdup_n_s16(v9);
      }
      ++v24;
      v26 += 8;
      v27 += 8;
    }
    while (v24 != v8);
    uint64_t v29 = 0;
    uint64_t v30 = a5 + 2 * (v25 + (unint64_t)v5);
    uint64_t v31 = a4 - 2 * a3 + 2 * v5;
    do
    {
      if (((a2 >> v29) & 0x2000) != 0)
      {
        for (uint64_t j = 0; j != 8; j += 2)
        {
          unsigned int v9 = *(unsigned __int16 *)(v31 + j);
          *(_WORD *)(v30 + j) = v9;
        }
      }
      else
      {
        *(int16x4_t *)(a5 + 2 * (v5 + 4 * v29 + (2 << (char)result))) = vdup_n_s16(v9);
      }
      ++v29;
      v30 += 8;
      v31 += 8;
    }
    while (v29 != v8);
  }
  return result;
}

void *sub_1BBA26280(int a1, int a2, uint64_t a3, uint64_t a4, char *__b)
{
  if (a2)
  {
    int v10 = 1 << a1;
    if ((a2 & 0xF) != 0)
    {
      if (v10 < 2 << a1)
      {
        uint64_t v11 = (2 << a1) - (uint64_t)v10;
        uint64_t v12 = &__b[v10];
        uint64_t v13 = (char *)(a4 + a3 * v10 - 1);
        do
        {
          *v12++ = *v13;
          v13 += a3;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      uint64_t v17 = v10 - a3;
      if ((a2 & 0x1E00) != 0) {
        uint64_t v17 = -a3;
      }
      if ((a2 & 0x100) != 0) {
        uint64_t v17 = ~a3;
      }
      if ((a2 & 0xF0) != 0) {
        uint64_t v17 = (v10 - 1) * a3 - 1;
      }
      memset(&__b[v10], *(unsigned __int8 *)(a4 + v17), v10);
    }
    if ((a2 & 0xF0) != 0)
    {
      if (a1 != 31)
      {
        if (v10 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v10;
        }
        uint64_t v19 = (unsigned char *)(a4 - 1);
        uint64_t v20 = __b;
        do
        {
          *v20++ = *v19;
          v19 += a3;
          --v18;
        }
        while (v18);
      }
    }
    else
    {
      memset(__b, __b[v10], v10);
    }
    uint64_t v21 = (unsigned __int8 *)(a4 + ~a3);
    if ((a2 & 0x100) == 0) {
      uint64_t v21 = (unsigned __int8 *)__b;
    }
    int v22 = *v21;
    *(__b - 1) = v22;
    if ((a2 & 0x1E00) != 0) {
      memcpy(&__b[2 << a1], (const void *)(a4 - a3), v10);
    }
    else {
      memset(&__b[2 << a1], v22, v10);
    }
    if ((a2 & 0x1E000) != 0)
    {
      return memcpy(&__b[3 << a1], (const void *)(a4 + v10 - a3), v10);
    }
    size_t v14 = v10;
    uint64_t v15 = &__b[3 << a1];
    int v16 = *(v15 - 1);
  }
  else
  {
    size_t v14 = (4 << a1) | 1;
    uint64_t v15 = __b - 1;
    int v16 = 128;
  }

  return memset(v15, v16, v14);
}

void *sub_1BBA26470(void *result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    int v7 = 1 << (char)result;
    int v8 = (1 << (char)result) + 4;
    if (1 << (char)result >= 8) {
      uint64_t v9 = 8;
    }
    else {
      uint64_t v9 = v7;
    }
    unsigned int v10 = __clz(__rbit32(a2));
    if (v10 < 9) {
      uint64_t v11 = ((2 << (char)result) + (char)~byte_1BBB78A7D[9 * (int)result - 18 + v10]) * a3 - 1;
    }
    else {
      uint64_t v11 = byte_1BBB78A7D[9 * (int)result - 27 + v10] - a3;
    }
    int v12 = v8 >> 3;
    int v13 = *(unsigned __int8 *)(a4 + v11);
    uint64_t v64 = (1 << (char)result);
    int v56 = v9;
    char v57 = (char)result;
    int v55 = v8 >> 3;
    if (v7 >= 4)
    {
      uint64_t v14 = 0;
      size_t v15 = (int)v9;
      uint64_t v16 = 2 << (char)result;
      if (v12 <= 1) {
        uint64_t v17 = 1;
      }
      else {
        uint64_t v17 = v12;
      }
      if (v7 >= 8) {
        int v18 = 8;
      }
      else {
        int v18 = 1 << (char)result;
      }
      uint64_t v19 = (unsigned char *)(a5 + v16 - 1);
      uint64_t v20 = -(uint64_t)v18;
      uint64_t v21 = a4 + a3 * (v16 - 1) - 1;
      uint64_t v54 = v18;
      uint64_t v22 = -(a3 * v18);
      uint64_t v23 = -a3;
      uint64_t v60 = 2 << (char)result;
      uint64_t v61 = v9 + 1;
      do
      {
        uint64_t v24 = v14 + 1;
        if ((a2 >> v14))
        {
          uint64_t v25 = v61;
          uint64_t v26 = (unsigned __int8 *)v21;
          uint64_t v27 = v19;
          do
          {
            int v13 = *v26;
            *v27-- = v13;
            v26 += v23;
            --v25;
          }
          while (v25 > 1);
        }
        else
        {
          __n128 result = memset((void *)(a5 + v60 - v24 * v15), v13, v15);
        }
        v19 += v20;
        v21 += v22;
        uint64_t v14 = v24;
      }
      while (v24 != v17);
      uint64_t v28 = 0;
      uint64_t v29 = 8;
      if (v64 < 8) {
        uint64_t v29 = v64;
      }
      uint64_t v30 = (unsigned char *)(a5 + v64 - 1);
      uint64_t v31 = a4 + a3 * (v64 - 1) - 1;
      uint64_t v62 = v29 + 1;
      do
      {
        uint64_t v32 = v28 + 1;
        if (((a2 >> v28) & 0x10) != 0)
        {
          uint64_t v33 = v62;
          uint64_t v34 = (unsigned __int8 *)v31;
          uint64_t v35 = v30;
          do
          {
            int v13 = *v34;
            *v35-- = v13;
            v34 -= a3;
            --v33;
          }
          while (v33 > 1);
        }
        else
        {
          __n128 result = memset((void *)(a5 + v64 - v32 * v15), v13, v15);
        }
        v30 -= v54;
        v31 += v22;
        uint64_t v28 = v32;
      }
      while (v32 != v17);
    }
    if ((a2 & 0x100) != 0) {
      int v13 = *(unsigned __int8 *)(a4 + ~a3);
    }
    *(unsigned char *)(a5 - 1) = v13;
    if ((int)v64 >= 4)
    {
      uint64_t v36 = 0;
      int v37 = 2 << v57;
      if (v56 <= 1) {
        uint64_t v38 = 1;
      }
      else {
        uint64_t v38 = v56;
      }
      uint64_t v39 = v37;
      if (v55 <= 1) {
        uint64_t v40 = 1;
      }
      else {
        uint64_t v40 = v55;
      }
      uint64_t v41 = (unsigned char *)(a5 + v37);
      uint64_t v42 = (unsigned __int8 *)(a4 - a3);
      do
      {
        if (((a2 >> v36) & 0x200) != 0)
        {
          int v43 = v42;
          uint64_t v44 = v41;
          uint64_t v45 = v38;
          do
          {
            int v46 = *v43++;
            int v13 = v46;
            *v44++ = v46;
            --v45;
          }
          while (v45);
        }
        else
        {
          __n128 result = memset((void *)(a5 + v36 * v56 + v39), v13, v56);
        }
        ++v36;
        v41 += v56;
        v42 += v56;
      }
      while (v36 != v40);
      uint64_t v47 = 0;
      long long v48 = (unsigned char *)(a5 + v39 + v64);
      __int16 v49 = (unsigned __int8 *)(a4 + v64 - a3);
      do
      {
        if (((a2 >> v47) & 0x2000) != 0)
        {
          uint64_t v50 = v49;
          uint64_t v51 = v48;
          uint64_t v52 = v38;
          do
          {
            int v53 = *v50++;
            int v13 = v53;
            *v51++ = v53;
            --v52;
          }
          while (v52);
        }
        else
        {
          __n128 result = memset((void *)(a5 + v64 + v47 * v56 + v39), v13, v56);
        }
        ++v47;
        v48 += v56;
        v49 += v56;
      }
      while (v47 != v40);
    }
  }
  else
  {
    return memset((void *)(a5 - 1), 128, (4 << (char)result) | 1);
  }
  return result;
}

uint64_t sub_1BBA26804(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)a2 > 9)
  {
    if (a2 == 10)
    {
      unsigned int v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 104);
      return (*v6)(a2, a4, a5, a6);
    }
    if (a2 == 26)
    {
      unsigned int v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 64);
      return (*v6)(a2, a4, a5, a6);
    }
LABEL_8:
    unsigned int v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 184);
    return (*v6)(a2, a4, a5, a6);
  }
  if (!a2)
  {
    unsigned int v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 24);
    return (*v6)(a2, a4, a5, a6);
  }
  if (a2 != 1) {
    goto LABEL_8;
  }
  unsigned int v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 144);
  return (*v6)(a2, a4, a5, a6);
}

uint64_t sub_1BBA26878(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)a2 > 9)
  {
    if (a2 == 10)
    {
      unsigned int v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 288);
      return (*v6)(a2, a4, a5, a6);
    }
    if (a2 == 26)
    {
      unsigned int v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 256);
      return (*v6)(a2, a4, a5, a6);
    }
LABEL_8:
    unsigned int v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 352);
    return (*v6)(a2, a4, a5, a6);
  }
  if (!a2)
  {
    unsigned int v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 224);
    return (*v6)(a2, a4, a5, a6);
  }
  if (a2 != 1) {
    goto LABEL_8;
  }
  unsigned int v6 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8 * a3 + 320);
  return (*v6)(a2, a4, a5, a6);
}

uint64_t *sub_1BBA268EC(uint64_t *result, int *a2, int a3, int a4)
{
  if (a4 >= 1)
  {
    int v4 = 0;
    uint64_t v5 = *result;
    int v6 = *a2;
    do
    {
      if (v6 >= 1)
      {
        uint64_t v7 = 0;
        do
        {
          *(_DWORD *)(v5 + 4 * v7) = a3;
          int v6 = *a2;
          ++v7;
        }
        while ((int)v7 < *a2);
      }
      ++v4;
      v5 += *((int *)result + 3);
    }
    while (v4 != a4);
    *__n128 result = v5;
  }
  int v8 = a2[1];
  if (v8 > 2 * a4)
  {
    int v9 = 0;
    uint64_t v10 = *result;
    do
    {
      if (a4 >= 1)
      {
        uint64_t v11 = 0;
        do
          *(_DWORD *)(v10 + 4 * v11++) = a3;
        while (a4 != v11);
        int v12 = (_DWORD *)(v10 + 4 * *a2 - 4 * a4);
        int v13 = a4;
        do
        {
          *v12++ = a3;
          --v13;
        }
        while (v13);
        int v8 = a2[1];
      }
      ++v9;
      v10 += *((int *)result + 3);
    }
    while (v9 < v8 - 2 * a4);
    *__n128 result = v10;
  }
  if (a4 >= 1)
  {
    int v14 = 0;
    uint64_t v15 = *result;
    int v16 = *a2;
    do
    {
      if (v16 >= 1)
      {
        uint64_t v17 = 0;
        do
        {
          *(_DWORD *)(v15 + 4 * v17) = a3;
          int v16 = *a2;
          ++v17;
        }
        while ((int)v17 < *a2);
      }
      ++v14;
      v15 += *((int *)result + 3);
    }
    while (v14 != a4);
    *__n128 result = v15;
  }
  return result;
}

uint64_t sub_1BBA26A04(void *a1, int a2)
{
  int32x2_t v139 = sub_1BBA2FC20;
  int32x2_t v138 = sub_1BBA2FE8C;
  int32x2_t v137 = sub_1BBA30084;
  float64x2_t v136 = sub_1BBA3024C;
  int64x2_t v135 = sub_1BBA303AC;
  int32x2_t v134 = sub_1BBA30624;
  float64x2_t v133 = sub_1BBA307E0;
  __int32 v132 = sub_1BBA30938;
  int v131 = sub_1BBA30A6C;
  uint64_t v130 = sub_1BBA30B50;
  int v129 = sub_1BBA30C78;
  double v128 = sub_1BBA30D6C;
  int8x16_t v122 = sub_1BBA30E64;
  int8x16_t v121 = sub_1BBA30F34;
  int32x2_t v120 = sub_1BBA30FC0;
  int32x2_t v119 = sub_1BBA31034;
  int32x2_t v118 = sub_1BBA31574;
  float64x2_t v117 = sub_1BBA31858;
  int64x2_t v116 = sub_1BBA319D0;
  int32x2_t v115 = sub_1BBA31C44;
  CGSize v114 = sub_1BBA31CB8;
  float64x2_t v113 = sub_1BBA32054;
  long long v112 = sub_1BBA321EC;
  uint64_t v111 = sub_1BBA322F0;
  uint64_t v110 = sub_1BBA324D8;
  uint64_t v109 = sub_1BBA3254C;
  long long v108 = sub_1BBA327C4;
  int v107 = sub_1BBA32910;
  unsigned int v106 = sub_1BBA329D4;
  uint64_t v105 = sub_1BBA32B1C;
  uint64_t v104 = sub_1BBA334C0;
  uint64_t v103 = sub_1BBA335BC;
  uint64_t v102 = sub_1BBA32B98;
  int v101 = sub_1BBA336A4;
  int v100 = sub_1BBA33C18;
  uint64_t v99 = sub_1BBA340DC;
  uint64_t v98 = sub_1BBA33CC4;
  uint64_t v97 = sub_1BBA34244;
  int v96 = sub_1BBA34484;
  int v95 = sub_1BBA348A4;
  int v94 = sub_1BBA34B18;
  int v93 = sub_1BBA34BBC;
  uint64_t v91 = sub_1BBA34C54;
  int v89 = sub_1BBA34D00;
  double v127 = sub_1BBA34E54;
  __int32 v126 = sub_1BBA34FDC;
  __int32 v125 = sub_1BBA35164;
  __int32 v124 = sub_1BBA352B4;
  int32x2_t v123 = sub_1BBA35320;
  int v82 = sub_1BBA353B8;
  uint64_t v85 = sub_1BBA3542C;
  int v84 = sub_1BBA3597C;
  uint64_t v83 = sub_1BBA35C60;
  int v81 = sub_1BBA35DD8;
  uint64_t v77 = sub_1BBA36050;
  uint64_t v80 = sub_1BBA360C4;
  unsigned int v79 = sub_1BBA36474;
  uint64_t v78 = sub_1BBA3661C;
  uint64_t v76 = sub_1BBA36728;
  uint64_t v72 = sub_1BBA36910;
  uint64_t v75 = sub_1BBA36984;
  uint64_t v74 = sub_1BBA36C04;
  uint64_t v73 = sub_1BBA36D5C;
  uint64_t v71 = sub_1BBA36E24;
  uint64_t v67 = sub_1BBA36F68;
  uint64_t v70 = sub_1BBA37918;
  uint64_t v69 = sub_1BBA37A14;
  uint64_t v68 = sub_1BBA36FE4;
  uint64_t v66 = sub_1BBA37AFC;
  uint64_t v62 = sub_1BBA38070;
  int v65 = sub_1BBA38538;
  uint64_t v64 = sub_1BBA3811C;
  __int16 v63 = sub_1BBA386A0;
  uint64_t v61 = sub_1BBA388E8;
  char v57 = sub_1BBA38CF4;
  uint64_t v60 = sub_1BBA38F74;
  long long v59 = sub_1BBA39018;
  uint64_t v58 = sub_1BBA390B0;
  int v56 = sub_1BBA3915C;
  int v92 = sub_1BBA392A8;
  int v90 = sub_1BBA393B4;
  uint64_t v88 = sub_1BBA394D4;
  uint64_t v87 = sub_1BBA395EC;
  uint64_t v86 = sub_1BBA39648;
  int v55 = sub_1BBA2CC7C;
  uint64_t v54 = sub_1BBA2CCE0;
  int v53 = sub_1BBA2CD44;
  uint64_t v52 = sub_1BBA2CDA8;
  uint64_t v51 = sub_1BBA2CE9C;
  uint64_t v50 = sub_1BBA2CF90;
  __int16 v49 = sub_1BBA2D084;
  long long v48 = sub_1BBA2D13C;
  uint64_t v47 = sub_1BBA2D1F4;
  int v46 = sub_1BBA2D2AC;
  uint64_t v45 = sub_1BBA2D408;
  uint64_t v44 = sub_1BBA2D548;
  int v43 = sub_1BBA2D688;
  uint64_t v42 = sub_1BBA2D704;
  uint64_t v41 = sub_1BBA2D780;
  uint64_t v40 = sub_1BBA2D7FC;
  uint64_t v39 = sub_1BBA2D874;
  uint64_t v38 = sub_1BBA2D8EC;
  int v37 = sub_1BBA2D964;
  uint64_t v36 = sub_1BBA2DAC8;
  uint64_t v35 = sub_1BBA2DC10;
  uint64_t v34 = sub_1BBA2DD58;
  uint64_t v33 = sub_1BBA2DDD8;
  uint64_t v32 = sub_1BBA2DE58;
  uint64_t v31 = sub_1BBA2DED8;
  uint64_t v30 = sub_1BBA2DF54;
  int v2 = sub_1BBA2DFD0;
  int v3 = sub_1BBA2E04C;
  int v4 = sub_1BBA2E094;
  uint64_t v5 = sub_1BBA2E0DC;
  int v6 = sub_1BBA2E124;
  uint64_t v7 = sub_1BBA2E290;
  int v8 = sub_1BBA2E3E0;
  int v9 = sub_1BBA2E530;
  uint64_t v10 = sub_1BBA2E5C0;
  uint64_t v11 = sub_1BBA2E650;
  int v12 = sub_1BBA2E6E0;
  int v13 = sub_1BBA2E76C;
  int v14 = sub_1BBA2E7F8;
  uint64_t v15 = sub_1BBA2E884;
  int v16 = sub_1BBA2E9F8;
  uint64_t v17 = sub_1BBA2EB50;
  int v18 = sub_1BBA2ECA8;
  uint64_t v19 = sub_1BBA2ED3C;
  uint64_t v20 = sub_1BBA2EDD0;
  uint64_t v21 = sub_1BBA2EE64;
  uint64_t v22 = sub_1BBA2EEF4;
  uint64_t v23 = sub_1BBA2EF84;
  uint64_t v24 = sub_1BBA2F014;
  uint64_t v25 = sub_1BBA2F040;
  uint64_t v26 = sub_1BBA2F06C;
  if (a2 == 8)
  {
    uint64_t v28 = sub_1BBA2F8E0;
LABEL_7:
    uint64_t v27 = 0;
    a1[13] = v23;
    a1[14] = v22;
    a1[12] = v57;
    a1[15] = v21;
    a1[20] = v62;
    a1[21] = v20;
    a1[22] = v19;
    a1[23] = v18;
    a1[28] = v67;
    a1[29] = v17;
    a1[30] = v16;
    a1[31] = v15;
    a1[44] = v72;
    a1[45] = v14;
    a1[46] = v13;
    a1[47] = v12;
    a1[52] = v77;
    a1[53] = v11;
    a1[54] = v10;
    a1[55] = v9;
    a1[60] = v82;
    a1[61] = v8;
    a1[62] = v7;
    a1[63] = v6;
    a1[77] = v2;
    a1[78] = v30;
    a1[79] = v31;
    a1[85] = v32;
    a1[86] = v33;
    a1[87] = v34;
    a1[93] = v35;
    a1[94] = v36;
    a1[95] = v37;
    a1[109] = v38;
    a1[110] = v39;
    a1[111] = v40;
    a1[117] = v41;
    a1[118] = v42;
    a1[119] = v43;
    a1[125] = v44;
    a1[126] = v45;
    a1[127] = v46;
    a1[133] = v47;
    a1[134] = v48;
    a1[135] = v49;
    a1[141] = v50;
    a1[142] = v51;
    a1[143] = v52;
    a1[149] = v53;
    a1[150] = v54;
    a1[151] = v55;
    a1[8] = v56;
    a1[9] = v58;
    a1[10] = v59;
    a1[11] = v60;
    a1[16] = v61;
    a1[17] = v63;
    a1[18] = v64;
    a1[19] = v65;
    a1[24] = v66;
    a1[25] = v68;
    a1[26] = v69;
    a1[27] = v70;
    a1[40] = v71;
    a1[41] = v73;
    a1[42] = v74;
    a1[43] = v75;
    a1[48] = v76;
    a1[49] = v78;
    a1[50] = v79;
    a1[51] = v80;
    a1[56] = v81;
    a1[57] = v83;
    a1[58] = v84;
    a1[59] = v85;
    a1[72] = v89;
    a1[73] = v91;
    a1[74] = v93;
    a1[75] = v94;
    a1[76] = v95;
    a1[80] = v96;
    a1[81] = v97;
    a1[82] = v98;
    a1[83] = v99;
    a1[84] = v100;
    a1[88] = v101;
    a1[89] = v102;
    a1[90] = v103;
    a1[91] = v104;
    a1[92] = v105;
    a1[104] = v106;
    a1[105] = v107;
    a1[106] = v108;
    a1[107] = v109;
    a1[108] = v110;
    a1[112] = v111;
    a1[113] = v112;
    a1[114] = v113;
    a1[115] = v114;
    a1[116] = v115;
    a1[120] = v116;
    a1[121] = v117;
    a1[122] = v118;
    a1[123] = v119;
    a1[124] = v120;
    a1[144] = v121;
    a1[145] = v122;
    a1[6] = v25;
    a1[7] = v24;
    a1[38] = v25;
    a1[39] = v24;
    a1[69] = v5;
    a1[70] = v4;
    a1[71] = v3;
    a1[101] = v5;
    a1[102] = v4;
    a1[103] = v3;
    *a1 = v86;
    a1[1] = v87;
    a1[2] = v88;
    a1[3] = v90;
    a1[4] = v92;
    a1[5] = v26;
    a1[32] = v86;
    a1[33] = v87;
    a1[34] = v88;
    a1[35] = v90;
    a1[36] = v92;
    a1[37] = v26;
    a1[64] = v123;
    a1[65] = v124;
    a1[66] = v125;
    a1[67] = v126;
    a1[68] = v127;
    a1[96] = v123;
    a1[97] = v124;
    a1[98] = v125;
    a1[99] = v126;
    a1[100] = v127;
    a1[146] = v128;
    a1[147] = v129;
    a1[148] = v130;
    a1[128] = v131;
    a1[129] = v132;
    a1[130] = v133;
    a1[131] = v134;
    a1[132] = v135;
    a1[136] = v136;
    a1[137] = v137;
    a1[138] = v138;
    a1[139] = v139;
    a1[140] = v28;
    return v27;
  }
  if (a2 == 10)
  {
    uint64_t v28 = sub_1BBA2FAE8;
    int32x2_t v139 = sub_1BBA2FD54;
    int32x2_t v138 = sub_1BBA2FF4C;
    int32x2_t v137 = sub_1BBA3014C;
    float64x2_t v136 = sub_1BBA302E8;
    int64x2_t v135 = sub_1BBA30554;
    int32x2_t v134 = sub_1BBA30710;
    float64x2_t v133 = sub_1BBA30868;
    __int32 v132 = sub_1BBA309C8;
    int v131 = sub_1BBA30AD4;
    uint64_t v130 = sub_1BBA30BDC;
    int v129 = sub_1BBA30CD0;
    double v128 = sub_1BBA30DC8;
    int8x16_t v122 = sub_1BBA30ED0;
    int8x16_t v121 = sub_1BBA30F6C;
    int32x2_t v120 = sub_1BBA31290;
    int32x2_t v119 = sub_1BBA314F4;
    int32x2_t v118 = sub_1BBA317E4;
    float64x2_t v117 = sub_1BBA31310;
    int64x2_t v116 = sub_1BBA31AF4;
    int32x2_t v115 = sub_1BBA31E2C;
    CGSize v114 = sub_1BBA31FD4;
    float64x2_t v113 = sub_1BBA32178;
    long long v112 = sub_1BBA31EAC;
    uint64_t v111 = sub_1BBA323FC;
    uint64_t v110 = sub_1BBA32618;
    uint64_t v109 = sub_1BBA32744;
    long long v108 = sub_1BBA3289C;
    int v107 = sub_1BBA32698;
    unsigned int v106 = sub_1BBA32AA0;
    uint64_t v105 = sub_1BBA32FEC;
    uint64_t v104 = sub_1BBA3353C;
    uint64_t v103 = sub_1BBA33630;
    uint64_t v102 = sub_1BBA3306C;
    int v101 = sub_1BBA338BC;
    int v100 = sub_1BBA33EB0;
    uint64_t v99 = sub_1BBA34150;
    uint64_t v98 = sub_1BBA341D0;
    uint64_t v97 = sub_1BBA33F30;
    int v96 = sub_1BBA346E0;
    int v95 = sub_1BBA349BC;
    int v94 = sub_1BBA34B3C;
    int v93 = sub_1BBA34BE0;
    uint64_t v91 = sub_1BBA34A3C;
    int v89 = sub_1BBA34DB4;
    double v127 = sub_1BBA34F14;
    __int32 v126 = sub_1BBA350EC;
    __int32 v125 = sub_1BBA35240;
    __int32 v124 = sub_1BBA34F8C;
    int32x2_t v123 = sub_1BBA35368;
    int v82 = sub_1BBA35690;
    uint64_t v85 = sub_1BBA358FC;
    int v84 = sub_1BBA35BEC;
    uint64_t v83 = sub_1BBA35710;
    int v81 = sub_1BBA35EFC;
    uint64_t v77 = sub_1BBA3624C;
    uint64_t v80 = sub_1BBA363F4;
    unsigned int v79 = sub_1BBA365A8;
    uint64_t v78 = sub_1BBA362CC;
    uint64_t v76 = sub_1BBA36834;
    uint64_t v72 = sub_1BBA36A58;
    uint64_t v75 = sub_1BBA36B84;
    uint64_t v74 = sub_1BBA36CE8;
    uint64_t v73 = sub_1BBA36AD8;
    uint64_t v71 = sub_1BBA36EEC;
    uint64_t v67 = sub_1BBA3743C;
    uint64_t v70 = sub_1BBA37994;
    uint64_t v69 = sub_1BBA37A88;
    uint64_t v68 = sub_1BBA374BC;
    uint64_t v66 = sub_1BBA37D10;
    uint64_t v62 = sub_1BBA3830C;
    int v65 = sub_1BBA385AC;
    uint64_t v64 = sub_1BBA3862C;
    __int16 v63 = sub_1BBA3838C;
    uint64_t v61 = sub_1BBA38B30;
    char v57 = sub_1BBA38E18;
    uint64_t v60 = sub_1BBA38F98;
    long long v59 = sub_1BBA3903C;
    uint64_t v58 = sub_1BBA38E98;
    int v56 = sub_1BBA39208;
    int v92 = sub_1BBA39314;
    int v90 = sub_1BBA39470;
    uint64_t v88 = sub_1BBA3958C;
    uint64_t v87 = sub_1BBA39378;
    uint64_t v86 = sub_1BBA3967C;
    int v55 = sub_1BBA28298;
    uint64_t v54 = sub_1BBA28300;
    int v53 = sub_1BBA28368;
    uint64_t v52 = sub_1BBA283D0;
    uint64_t v51 = sub_1BBA284C4;
    uint64_t v50 = sub_1BBA285B8;
    __int16 v49 = sub_1BBA286AC;
    long long v48 = sub_1BBA28764;
    uint64_t v47 = sub_1BBA2881C;
    int v46 = sub_1BBA288D4;
    uint64_t v45 = sub_1BBA28A38;
    uint64_t v44 = sub_1BBA28B80;
    int v43 = sub_1BBA28CC8;
    uint64_t v42 = sub_1BBA28D4C;
    uint64_t v41 = sub_1BBA28DD0;
    uint64_t v40 = sub_1BBA28E54;
    uint64_t v39 = sub_1BBA28ED4;
    uint64_t v38 = sub_1BBA28F54;
    int v37 = sub_1BBA28FD4;
    uint64_t v36 = sub_1BBA29140;
    uint64_t v35 = sub_1BBA29290;
    uint64_t v34 = sub_1BBA293E0;
    uint64_t v33 = sub_1BBA29468;
    uint64_t v32 = sub_1BBA294F0;
    uint64_t v31 = sub_1BBA29578;
    uint64_t v30 = sub_1BBA295FC;
    int v2 = sub_1BBA29680;
    int v3 = sub_1BBA29704;
    int v4 = sub_1BBA29750;
    uint64_t v5 = sub_1BBA2979C;
    int v6 = sub_1BBA297E8;
    uint64_t v7 = sub_1BBA2995C;
    int v8 = sub_1BBA29AB4;
    int v9 = sub_1BBA29C0C;
    uint64_t v10 = sub_1BBA29CA0;
    uint64_t v11 = sub_1BBA29D34;
    int v12 = sub_1BBA29DC8;
    int v13 = sub_1BBA29E58;
    int v14 = sub_1BBA29EE8;
    uint64_t v15 = sub_1BBA29F78;
    int v16 = sub_1BBA2A0F4;
    uint64_t v17 = sub_1BBA2A254;
    int v18 = sub_1BBA2A3B4;
    uint64_t v19 = sub_1BBA2A44C;
    uint64_t v20 = sub_1BBA2A4E4;
    uint64_t v21 = sub_1BBA2A57C;
    uint64_t v22 = sub_1BBA2A610;
    uint64_t v23 = sub_1BBA2A6A4;
    uint64_t v24 = sub_1BBA2A738;
    uint64_t v25 = sub_1BBA2A774;
    uint64_t v26 = sub_1BBA2A7A8;
    goto LABEL_7;
  }
  if (a2 != 9) {
    return 4294954386;
  }
  uint64_t v27 = 0;
  a1[5] = sub_1BBA2A7A8;
  a1[6] = sub_1BBA2A774;
  a1[7] = sub_1BBA2A738;
  a1[13] = sub_1BBA2CBE8;
  a1[14] = sub_1BBA2CB54;
  a1[15] = sub_1BBA2CAC0;
  a1[21] = sub_1BBA2CA28;
  a1[22] = sub_1BBA2C990;
  a1[23] = sub_1BBA2C8F8;
  a1[29] = sub_1BBA2C798;
  a1[30] = sub_1BBA2C638;
  a1[31] = sub_1BBA2C4BC;
  a1[37] = sub_1BBA2A7A8;
  a1[38] = sub_1BBA2A774;
  a1[39] = sub_1BBA2A738;
  a1[45] = sub_1BBA2C42C;
  a1[46] = sub_1BBA2C39C;
  a1[47] = sub_1BBA2C30C;
  a1[53] = sub_1BBA2C278;
  a1[54] = sub_1BBA2C1E4;
  a1[55] = sub_1BBA2C150;
  a1[61] = sub_1BBA2BFF8;
  a1[62] = sub_1BBA2BEA0;
  a1[63] = sub_1BBA2BD2C;
  a1[69] = sub_1BBA2BCE0;
  a1[70] = sub_1BBA2BC94;
  a1[71] = sub_1BBA2BC48;
  a1[77] = sub_1BBA2BBC4;
  a1[78] = sub_1BBA2BB40;
  a1[79] = sub_1BBA2BABC;
  a1[85] = sub_1BBA2BA34;
  a1[86] = sub_1BBA2B9AC;
  a1[87] = sub_1BBA2B924;
  a1[93] = sub_1BBA2B7D4;
  a1[94] = sub_1BBA2B684;
  a1[95] = sub_1BBA2B518;
  a1[101] = sub_1BBA2BCE0;
  a1[102] = sub_1BBA2BC94;
  a1[103] = sub_1BBA2BC48;
  a1[109] = sub_1BBA2B498;
  a1[110] = sub_1BBA2B418;
  a1[111] = sub_1BBA2B398;
  a1[117] = sub_1BBA2B314;
  a1[118] = sub_1BBA2B290;
  a1[119] = sub_1BBA2B20C;
  a1[125] = sub_1BBA2B0C4;
  a1[126] = sub_1BBA2AF7C;
  a1[127] = sub_1BBA2AE18;
  a1[133] = sub_1BBA2AD60;
  a1[134] = sub_1BBA2ACA8;
  a1[135] = sub_1BBA2ABF0;
  a1[141] = sub_1BBA2AAFC;
  a1[142] = sub_1BBA2AA08;
  a1[143] = sub_1BBA2A914;
  a1[149] = sub_1BBA2A8AC;
  a1[150] = sub_1BBA2A844;
  a1[151] = sub_1BBA2A7DC;
  return v27;
}

uint64_t sub_1BBA28298(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((int)result >= 1)
  {
    int v5 = 0;
    do
    {
      for (uint64_t i = 0; i != 96; i += 2)
      {
        int v7 = (*(__int16 *)(a2 + i) + *(__int16 *)(a3 + i) + 16400) >> 5;
        if (v7 >= 1023) {
          int v7 = 1023;
        }
        *(_WORD *)(a5 + i) = v7 & ~(unsigned __int16)(v7 >> 31);
      }
      ++v5;
      a2 += 96;
      a3 += 96;
      a5 += 2 * a4;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t sub_1BBA28300(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((int)result >= 1)
  {
    int v5 = 0;
    do
    {
      for (uint64_t i = 0; i != 48; i += 2)
      {
        int v7 = (*(__int16 *)(a2 + i) + *(__int16 *)(a3 + i) + 16400) >> 5;
        if (v7 >= 1023) {
          int v7 = 1023;
        }
        *(_WORD *)(a5 + i) = v7 & ~(unsigned __int16)(v7 >> 31);
      }
      ++v5;
      a2 += 48;
      a3 += 48;
      a5 += 2 * a4;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t sub_1BBA28368(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((int)result >= 1)
  {
    int v5 = 0;
    do
    {
      for (uint64_t i = 0; i != 24; i += 2)
      {
        int v7 = (*(__int16 *)(a2 + i) + *(__int16 *)(a3 + i) + 16400) >> 5;
        if (v7 >= 1023) {
          int v7 = 1023;
        }
        *(_WORD *)(a5 + i) = v7 & ~(unsigned __int16)(v7 >> 31);
      }
      ++v5;
      a2 += 24;
      a3 += 24;
      a5 += 2 * a4;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t sub_1BBA283D0(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if ((int)result >= 1)
  {
    int v10 = 0;
    int v12 = (*a7 + *a4 + 1) << a2;
    char v13 = a2 + 1;
    int v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      uint64_t v15 = 0;
      unint64_t v16 = -2;
      do
      {
        int v17 = (v12 + (*(__int16 *)(a5 + v15) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15) + 0x2000) * *a6) >> v13;
        if (v17 >= 1023) {
          int v17 = 1023;
        }
        *(_WORD *)(a10 + v15) = v17 & ~(unsigned __int16)(v17 >> 31);
        int v18 = (v14 + (*(__int16 *)(a5 + v15 + 2) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15 + 2) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 1023) {
          int v18 = 1023;
        }
        *(_WORD *)(a10 + v15 + 2) = v18 & ~(unsigned __int16)(v18 >> 31);
        v16 += 2;
        v15 += 4;
      }
      while (v16 < 0x2E);
      ++v10;
      a5 += 96;
      a8 += 96;
      a10 += 2 * a9;
    }
    while (v10 != result);
  }
  return result;
}

uint64_t sub_1BBA284C4(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if ((int)result >= 1)
  {
    int v10 = 0;
    int v12 = (*a7 + *a4 + 1) << a2;
    char v13 = a2 + 1;
    int v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      uint64_t v15 = 0;
      unint64_t v16 = -2;
      do
      {
        int v17 = (v12 + (*(__int16 *)(a5 + v15) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15) + 0x2000) * *a6) >> v13;
        if (v17 >= 1023) {
          int v17 = 1023;
        }
        *(_WORD *)(a10 + v15) = v17 & ~(unsigned __int16)(v17 >> 31);
        int v18 = (v14 + (*(__int16 *)(a5 + v15 + 2) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15 + 2) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 1023) {
          int v18 = 1023;
        }
        *(_WORD *)(a10 + v15 + 2) = v18 & ~(unsigned __int16)(v18 >> 31);
        v16 += 2;
        v15 += 4;
      }
      while (v16 < 0x16);
      ++v10;
      a5 += 48;
      a8 += 48;
      a10 += 2 * a9;
    }
    while (v10 != result);
  }
  return result;
}

uint64_t sub_1BBA285B8(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if ((int)result >= 1)
  {
    int v10 = 0;
    int v12 = (*a7 + *a4 + 1) << a2;
    char v13 = a2 + 1;
    int v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      uint64_t v15 = 0;
      unint64_t v16 = -2;
      do
      {
        int v17 = (v12 + (*(__int16 *)(a5 + v15) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15) + 0x2000) * *a6) >> v13;
        if (v17 >= 1023) {
          int v17 = 1023;
        }
        *(_WORD *)(a10 + v15) = v17 & ~(unsigned __int16)(v17 >> 31);
        int v18 = (v14 + (*(__int16 *)(a5 + v15 + 2) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15 + 2) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 1023) {
          int v18 = 1023;
        }
        *(_WORD *)(a10 + v15 + 2) = v18 & ~(unsigned __int16)(v18 >> 31);
        v16 += 2;
        v15 += 4;
      }
      while (v16 < 0xA);
      ++v10;
      a5 += 24;
      a8 += 24;
      a10 += 2 * a9;
    }
    while (v10 != result);
  }
  return result;
}

uint64_t sub_1BBA286AC(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7 = 1 << (a2 - 1);
  if (a2 <= 0) {
    int v7 = 0;
  }
  if ((int)result >= 1)
  {
    int v8 = 0;
    do
    {
      uint64_t v9 = 0;
      unint64_t v10 = -2;
      do
      {
        int v11 = ((v7 + (*(__int16 *)(a5 + v9) + 0x2000) * *a3) >> a2) + *a4;
        if (v11 >= 1023) {
          int v11 = 1023;
        }
        *(_WORD *)(a7 + v9) = v11 & ~(unsigned __int16)(v11 >> 31);
        int v12 = ((v7 + (*(__int16 *)(a5 + v9 + 2) + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v12 >= 1023) {
          int v12 = 1023;
        }
        *(_WORD *)(a7 + v9 + 2) = v12 & ~(unsigned __int16)(v12 >> 31);
        v10 += 2;
        v9 += 4;
      }
      while (v10 < 0x2E);
      ++v8;
      a5 += 96;
      a7 += 2 * a6;
    }
    while (v8 != result);
  }
  return result;
}

uint64_t sub_1BBA28764(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7 = 1 << (a2 - 1);
  if (a2 <= 0) {
    int v7 = 0;
  }
  if ((int)result >= 1)
  {
    int v8 = 0;
    do
    {
      uint64_t v9 = 0;
      unint64_t v10 = -2;
      do
      {
        int v11 = ((v7 + (*(__int16 *)(a5 + v9) + 0x2000) * *a3) >> a2) + *a4;
        if (v11 >= 1023) {
          int v11 = 1023;
        }
        *(_WORD *)(a7 + v9) = v11 & ~(unsigned __int16)(v11 >> 31);
        int v12 = ((v7 + (*(__int16 *)(a5 + v9 + 2) + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v12 >= 1023) {
          int v12 = 1023;
        }
        *(_WORD *)(a7 + v9 + 2) = v12 & ~(unsigned __int16)(v12 >> 31);
        v10 += 2;
        v9 += 4;
      }
      while (v10 < 0x16);
      ++v8;
      a5 += 48;
      a7 += 2 * a6;
    }
    while (v8 != result);
  }
  return result;
}

uint64_t sub_1BBA2881C(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7 = 1 << (a2 - 1);
  if (a2 <= 0) {
    int v7 = 0;
  }
  if ((int)result >= 1)
  {
    int v8 = 0;
    do
    {
      uint64_t v9 = 0;
      unint64_t v10 = -2;
      do
      {
        int v11 = ((v7 + (*(__int16 *)(a5 + v9) + 0x2000) * *a3) >> a2) + *a4;
        if (v11 >= 1023) {
          int v11 = 1023;
        }
        *(_WORD *)(a7 + v9) = v11 & ~(unsigned __int16)(v11 >> 31);
        int v12 = ((v7 + (*(__int16 *)(a5 + v9 + 2) + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v12 >= 1023) {
          int v12 = 1023;
        }
        *(_WORD *)(a7 + v9 + 2) = v12 & ~(unsigned __int16)(v12 >> 31);
        v10 += 2;
        v9 += 4;
      }
      while (v10 < 0xA);
      ++v8;
      a5 += 24;
      a7 += 2 * a6;
    }
    while (v8 != result);
  }
  return result;
}

uint64_t sub_1BBA288D4()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * v2;
    uint64_t v8 = v3 - 2 * v2 - 4;
    uint64_t v9 = v26;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (v1 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = (v12 + 229376) >> 2;
        ++v11;
      }
      while (v10 != 48);
      v9 += 96;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      uint64_t v19 = (__int16 *)v26;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          unsigned int v22 = 0;
          uint64_t v23 = -4;
          uint64_t v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 48;
            v22 += byte_1BBB78AED[4 * ((v1 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(v5 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 48);
        ++v18;
        v5 += 2 * v4;
        v19 += 48;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA28A38(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * a3;
    uint64_t v8 = a4 - 2 * a3 - 4;
    uint64_t v9 = v26;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (a2 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = (v12 + 229376) >> 2;
        ++v11;
      }
      while (v10 != 24);
      v9 += 48;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      uint64_t v19 = (__int16 *)v26;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          unsigned int v22 = 0;
          uint64_t v23 = -4;
          uint64_t v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 24;
            v22 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(a6 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 24);
        ++v18;
        a6 += 2 * a5;
        v19 += 24;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA28B80(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v26[201] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * a3;
    uint64_t v8 = a4 - 2 * a3 - 4;
    uint64_t v9 = v26;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (a2 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *((_WORD *)v9 + v10++) = (v12 + 229376) >> 2;
        ++v11;
      }
      while (v10 != 12);
      v9 += 3;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      uint64_t v19 = (__int16 *)v26;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          unsigned int v22 = 0;
          uint64_t v23 = -4;
          uint64_t v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 12;
            v22 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(a6 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 12);
        ++v18;
        a6 += 2 * a5;
        v19 += 12;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA28CC8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA28D4C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA28DD0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA28E54(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 229376) >> 2;
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA28ED4(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 229376) >> 2;
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA28F54(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 229376) >> 2;
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA28FD4()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = v3 - 6 * v2 - 6;
    uint64_t v8 = 2 * v2;
    uint64_t v9 = v24;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (v1 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = (v13 + 229376) >> 2;
        v11 += 2;
      }
      while (v10 != 48);
      v9 += 96;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v24;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          unsigned int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 48;
            v19 += byte_1BBB78AD5[8 * ((v1 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(v5 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 48);
        ++v15;
        v5 += 2 * v4;
        v16 += 48;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA29140(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6 * a3 - 6;
    uint64_t v8 = 2 * a3;
    uint64_t v9 = v24;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = (v13 + 229376) >> 2;
        v11 += 2;
      }
      while (v10 != 24);
      v9 += 48;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v24;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          unsigned int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 24;
            v19 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(a6 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 24);
        ++v15;
        a6 += 2 * a5;
        v16 += 24;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA29290(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v24[213] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6 * a3 - 6;
    uint64_t v8 = 2 * a3;
    uint64_t v9 = v24;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *((_WORD *)v9 + v10++) = (v13 + 229376) >> 2;
        v11 += 2;
      }
      while (v10 != 12);
      v9 += 3;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v24;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          unsigned int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 12;
            v19 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(a6 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 12);
        ++v15;
        a6 += 2 * a5;
        v16 += 12;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA293E0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29468(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA294F0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 229376) >> 2;
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29578(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 229376) >> 2;
        v9 += 2;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA295FC(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 229376) >> 2;
        v9 += 2;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29680(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 229376) >> 2;
        v9 += 2;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29704(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    do
    {
      for (uint64_t i = 0; i != 96; i += 2)
        *(_WORD *)(a6 + i) = 16 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29750(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    do
    {
      for (uint64_t i = 0; i != 48; i += 2)
        *(_WORD *)(a6 + i) = 16 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2979C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    do
    {
      for (uint64_t i = 0; i != 24; i += 2)
        *(_WORD *)(a6 + i) = 16 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA297E8()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * v2;
    uint64_t v8 = v3 - 2 * v2 - 4;
    uint64_t v9 = v27;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        unsigned int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (v1 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = v12 >> 2;
        ++v11;
      }
      while (v10 != 48);
      v9 += 96;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      unsigned int v19 = (__int16 *)v27;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          int v22 = 0;
          uint64_t v23 = -4;
          uint64_t v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 48;
            v22 += byte_1BBB78AED[4 * ((v1 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          int v26 = (v22 + 512) >> 10;
          if (v26 >= 1023) {
            int v26 = 1023;
          }
          *(_WORD *)(v5 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 48);
        ++v18;
        v5 += 2 * v4;
        v19 += 48;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2995C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * a3;
    uint64_t v8 = a4 - 2 * a3 - 4;
    uint64_t v9 = v27;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        unsigned int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (a2 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = v12 >> 2;
        ++v11;
      }
      while (v10 != 24);
      v9 += 48;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      unsigned int v19 = (__int16 *)v27;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          int v22 = 0;
          uint64_t v23 = -4;
          uint64_t v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 24;
            v22 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          int v26 = (v22 + 512) >> 10;
          if (v26 >= 1023) {
            int v26 = 1023;
          }
          *(_WORD *)(a6 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 24);
        ++v18;
        a6 += 2 * a5;
        v19 += 24;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA29AB4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v27[201] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * a3;
    uint64_t v8 = a4 - 2 * a3 - 4;
    uint64_t v9 = v27;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        unsigned int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (a2 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *((_WORD *)v9 + v10++) = v12 >> 2;
        ++v11;
      }
      while (v10 != 12);
      v9 += 3;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      unsigned int v19 = (__int16 *)v27;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          int v22 = 0;
          uint64_t v23 = -4;
          uint64_t v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 12;
            v22 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          int v26 = (v22 + 512) >> 10;
          if (v26 >= 1023) {
            int v26 = 1023;
          }
          *(_WORD *)(a6 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 12);
        ++v18;
        a6 += 2 * a5;
        v19 += 12;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA29C0C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 1023) {
          int v15 = 1023;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29CA0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 1023) {
          int v15 = 1023;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29D34(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 1023) {
          int v15 = 1023;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29DC8(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        int v15 = (v10 + 32) >> 6;
        if (v15 >= 1023) {
          int v15 = 1023;
        }
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29E58(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        int v15 = (v10 + 32) >> 6;
        if (v15 >= 1023) {
          int v15 = 1023;
        }
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29EE8(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        int v15 = (v10 + 32) >> 6;
        if (v15 >= 1023) {
          int v15 = 1023;
        }
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA29F78()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = v3 - 6 * v2 - 6;
    uint64_t v8 = 2 * v2;
    uint64_t v9 = v25;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        unsigned int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (v1 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = v13 >> 2;
        v11 += 2;
      }
      while (v10 != 48);
      v9 += 96;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v25;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 48;
            v19 += byte_1BBB78AD5[8 * ((v1 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          int v24 = (v19 + 512) >> 10;
          if (v24 >= 1023) {
            int v24 = 1023;
          }
          *(_WORD *)(v5 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 48);
        ++v15;
        v5 += 2 * v4;
        v16 += 48;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2A0F4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6 * a3 - 6;
    uint64_t v8 = 2 * a3;
    uint64_t v9 = v25;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        unsigned int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = v13 >> 2;
        v11 += 2;
      }
      while (v10 != 24);
      v9 += 48;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v25;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 24;
            v19 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          int v24 = (v19 + 512) >> 10;
          if (v24 >= 1023) {
            int v24 = 1023;
          }
          *(_WORD *)(a6 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 24);
        ++v15;
        a6 += 2 * a5;
        v16 += 24;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2A254(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v25[213] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6 * a3 - 6;
    uint64_t v8 = 2 * a3;
    uint64_t v9 = v25;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        unsigned int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *((_WORD *)v9 + v10++) = v13 >> 2;
        v11 += 2;
      }
      while (v10 != 12);
      v9 += 3;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v25;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 12;
            v19 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          int v24 = (v19 + 512) >> 10;
          if (v24 >= 1023) {
            int v24 = 1023;
          }
          *(_WORD *)(a6 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 12);
        ++v15;
        a6 += 2 * a5;
        v16 += 12;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2A3B4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        unsigned int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          unsigned int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 1023) {
          int v15 = 1023;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2A44C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        unsigned int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          unsigned int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 1023) {
          int v15 = 1023;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2A4E4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        unsigned int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          unsigned int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 1023) {
          int v15 = 1023;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2A57C(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        int v12 = (v11 + 32) >> 6;
        if (v12 >= 1023) {
          int v12 = 1023;
        }
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2A610(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        int v12 = (v11 + 32) >> 6;
        if (v12 >= 1023) {
          int v12 = 1023;
        }
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2A6A4(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        int v12 = (v11 + 32) >> 6;
        if (v12 >= 1023) {
          int v12 = 1023;
        }
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2A738(uint64_t result, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5, _OWORD *a6)
{
  if ((int)result >= 1)
  {
    do
    {
      long long v6 = a4[1];
      *a6 = *a4;
      a6[1] = v6;
      long long v7 = a4[2];
      long long v8 = a4[3];
      long long v9 = a4[5];
      a6[4] = a4[4];
      a6[5] = v9;
      a6[2] = v7;
      a6[3] = v8;
      a6 = (_OWORD *)((char *)a6 + 2 * a5);
      a4 = (_OWORD *)((char *)a4 + 2 * a3);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

uint64_t sub_1BBA2A774(uint64_t result, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, _OWORD *a6)
{
  if ((int)result >= 1)
  {
    do
    {
      long long v6 = *a4;
      long long v7 = a4[2];
      a6[1] = a4[1];
      a6[2] = v7;
      *a6 = v6;
      a6 = (_OWORD *)((char *)a6 + 2 * a5);
      a4 = (long long *)((char *)a4 + 2 * a3);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

uint64_t sub_1BBA2A7A8(uint64_t result, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    do
    {
      long long v6 = *a4;
      *(void *)(a6 + 16) = *((void *)a4 + 2);
      *(_OWORD *)a6 = v6;
      a6 += 2 * a5;
      a4 = (long long *)((char *)a4 + 2 * a3);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

uint64_t sub_1BBA2A7DC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((int)result >= 1)
  {
    int v5 = 0;
    do
    {
      for (uint64_t i = 0; i != 96; i += 2)
      {
        int v7 = (*(__int16 *)(a2 + i) + *(__int16 *)(a3 + i) + 16416) >> 6;
        if (v7 >= 511) {
          int v7 = 511;
        }
        *(_WORD *)(a5 + i) = v7 & ~(unsigned __int16)(v7 >> 31);
      }
      ++v5;
      a2 += 96;
      a3 += 96;
      a5 += 2 * a4;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t sub_1BBA2A844(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((int)result >= 1)
  {
    int v5 = 0;
    do
    {
      for (uint64_t i = 0; i != 48; i += 2)
      {
        int v7 = (*(__int16 *)(a2 + i) + *(__int16 *)(a3 + i) + 16416) >> 6;
        if (v7 >= 511) {
          int v7 = 511;
        }
        *(_WORD *)(a5 + i) = v7 & ~(unsigned __int16)(v7 >> 31);
      }
      ++v5;
      a2 += 48;
      a3 += 48;
      a5 += 2 * a4;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t sub_1BBA2A8AC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((int)result >= 1)
  {
    int v5 = 0;
    do
    {
      for (uint64_t i = 0; i != 24; i += 2)
      {
        int v7 = (*(__int16 *)(a2 + i) + *(__int16 *)(a3 + i) + 16416) >> 6;
        if (v7 >= 511) {
          int v7 = 511;
        }
        *(_WORD *)(a5 + i) = v7 & ~(unsigned __int16)(v7 >> 31);
      }
      ++v5;
      a2 += 24;
      a3 += 24;
      a5 += 2 * a4;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t sub_1BBA2A914(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if ((int)result >= 1)
  {
    int v10 = 0;
    int v12 = (*a7 + *a4 + 1) << a2;
    char v13 = a2 + 1;
    int v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      uint64_t v15 = 0;
      unint64_t v16 = -2;
      do
      {
        int v17 = (v12 + (*(__int16 *)(a5 + v15) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15) + 0x2000) * *a6) >> v13;
        if (v17 >= 511) {
          int v17 = 511;
        }
        *(_WORD *)(a10 + v15) = v17 & ~(unsigned __int16)(v17 >> 31);
        int v18 = (v14 + (*(__int16 *)(a5 + v15 + 2) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15 + 2) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 511) {
          int v18 = 511;
        }
        *(_WORD *)(a10 + v15 + 2) = v18 & ~(unsigned __int16)(v18 >> 31);
        v16 += 2;
        v15 += 4;
      }
      while (v16 < 0x2E);
      ++v10;
      a5 += 96;
      a8 += 96;
      a10 += 2 * a9;
    }
    while (v10 != result);
  }
  return result;
}

uint64_t sub_1BBA2AA08(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if ((int)result >= 1)
  {
    int v10 = 0;
    int v12 = (*a7 + *a4 + 1) << a2;
    char v13 = a2 + 1;
    int v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      uint64_t v15 = 0;
      unint64_t v16 = -2;
      do
      {
        int v17 = (v12 + (*(__int16 *)(a5 + v15) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15) + 0x2000) * *a6) >> v13;
        if (v17 >= 511) {
          int v17 = 511;
        }
        *(_WORD *)(a10 + v15) = v17 & ~(unsigned __int16)(v17 >> 31);
        int v18 = (v14 + (*(__int16 *)(a5 + v15 + 2) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15 + 2) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 511) {
          int v18 = 511;
        }
        *(_WORD *)(a10 + v15 + 2) = v18 & ~(unsigned __int16)(v18 >> 31);
        v16 += 2;
        v15 += 4;
      }
      while (v16 < 0x16);
      ++v10;
      a5 += 48;
      a8 += 48;
      a10 += 2 * a9;
    }
    while (v10 != result);
  }
  return result;
}

uint64_t sub_1BBA2AAFC(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if ((int)result >= 1)
  {
    int v10 = 0;
    int v12 = (*a7 + *a4 + 1) << a2;
    char v13 = a2 + 1;
    int v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      uint64_t v15 = 0;
      unint64_t v16 = -2;
      do
      {
        int v17 = (v12 + (*(__int16 *)(a5 + v15) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15) + 0x2000) * *a6) >> v13;
        if (v17 >= 511) {
          int v17 = 511;
        }
        *(_WORD *)(a10 + v15) = v17 & ~(unsigned __int16)(v17 >> 31);
        int v18 = (v14 + (*(__int16 *)(a5 + v15 + 2) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15 + 2) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 511) {
          int v18 = 511;
        }
        *(_WORD *)(a10 + v15 + 2) = v18 & ~(unsigned __int16)(v18 >> 31);
        v16 += 2;
        v15 += 4;
      }
      while (v16 < 0xA);
      ++v10;
      a5 += 24;
      a8 += 24;
      a10 += 2 * a9;
    }
    while (v10 != result);
  }
  return result;
}

uint64_t sub_1BBA2ABF0(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7 = 1 << (a2 - 1);
  if (a2 <= 0) {
    int v7 = 0;
  }
  if ((int)result >= 1)
  {
    int v8 = 0;
    do
    {
      uint64_t v9 = 0;
      unint64_t v10 = -2;
      do
      {
        int v11 = ((v7 + (*(__int16 *)(a5 + v9) + 0x2000) * *a3) >> a2) + *a4;
        if (v11 >= 511) {
          int v11 = 511;
        }
        *(_WORD *)(a7 + v9) = v11 & ~(unsigned __int16)(v11 >> 31);
        int v12 = ((v7 + (*(__int16 *)(a5 + v9 + 2) + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v12 >= 511) {
          int v12 = 511;
        }
        *(_WORD *)(a7 + v9 + 2) = v12 & ~(unsigned __int16)(v12 >> 31);
        v10 += 2;
        v9 += 4;
      }
      while (v10 < 0x2E);
      ++v8;
      a5 += 96;
      a7 += 2 * a6;
    }
    while (v8 != result);
  }
  return result;
}

uint64_t sub_1BBA2ACA8(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7 = 1 << (a2 - 1);
  if (a2 <= 0) {
    int v7 = 0;
  }
  if ((int)result >= 1)
  {
    int v8 = 0;
    do
    {
      uint64_t v9 = 0;
      unint64_t v10 = -2;
      do
      {
        int v11 = ((v7 + (*(__int16 *)(a5 + v9) + 0x2000) * *a3) >> a2) + *a4;
        if (v11 >= 511) {
          int v11 = 511;
        }
        *(_WORD *)(a7 + v9) = v11 & ~(unsigned __int16)(v11 >> 31);
        int v12 = ((v7 + (*(__int16 *)(a5 + v9 + 2) + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v12 >= 511) {
          int v12 = 511;
        }
        *(_WORD *)(a7 + v9 + 2) = v12 & ~(unsigned __int16)(v12 >> 31);
        v10 += 2;
        v9 += 4;
      }
      while (v10 < 0x16);
      ++v8;
      a5 += 48;
      a7 += 2 * a6;
    }
    while (v8 != result);
  }
  return result;
}

uint64_t sub_1BBA2AD60(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7 = 1 << (a2 - 1);
  if (a2 <= 0) {
    int v7 = 0;
  }
  if ((int)result >= 1)
  {
    int v8 = 0;
    do
    {
      uint64_t v9 = 0;
      unint64_t v10 = -2;
      do
      {
        int v11 = ((v7 + (*(__int16 *)(a5 + v9) + 0x2000) * *a3) >> a2) + *a4;
        if (v11 >= 511) {
          int v11 = 511;
        }
        *(_WORD *)(a7 + v9) = v11 & ~(unsigned __int16)(v11 >> 31);
        int v12 = ((v7 + (*(__int16 *)(a5 + v9 + 2) + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v12 >= 511) {
          int v12 = 511;
        }
        *(_WORD *)(a7 + v9 + 2) = v12 & ~(unsigned __int16)(v12 >> 31);
        v10 += 2;
        v9 += 4;
      }
      while (v10 < 0xA);
      ++v8;
      a5 += 24;
      a7 += 2 * a6;
    }
    while (v8 != result);
  }
  return result;
}

uint64_t sub_1BBA2AE18()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * v2;
    uint64_t v8 = v3 - 2 * v2 - 4;
    uint64_t v9 = v26;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (v1 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = (v12 + 114688) >> 1;
        ++v11;
      }
      while (v10 != 48);
      v9 += 96;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      int v19 = (__int16 *)v26;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          unsigned int v22 = 0;
          uint64_t v23 = -4;
          int v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 48;
            v22 += byte_1BBB78AED[4 * ((v1 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(v5 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 48);
        ++v18;
        v5 += 2 * v4;
        v19 += 48;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2AF7C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * a3;
    uint64_t v8 = a4 - 2 * a3 - 4;
    uint64_t v9 = v26;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (a2 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = (v12 + 114688) >> 1;
        ++v11;
      }
      while (v10 != 24);
      v9 += 48;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      int v19 = (__int16 *)v26;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          unsigned int v22 = 0;
          uint64_t v23 = -4;
          int v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 24;
            v22 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(a6 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 24);
        ++v18;
        a6 += 2 * a5;
        v19 += 24;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2B0C4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v26[201] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * a3;
    uint64_t v8 = a4 - 2 * a3 - 4;
    uint64_t v9 = v26;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (a2 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *((_WORD *)v9 + v10++) = (v12 + 114688) >> 1;
        ++v11;
      }
      while (v10 != 12);
      v9 += 3;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      int v19 = (__int16 *)v26;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          unsigned int v22 = 0;
          uint64_t v23 = -4;
          int v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 12;
            v22 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          *(_WORD *)(a6 + 2 * v20++) = v22 >> 6;
          ++v21;
        }
        while (v20 != 12);
        ++v18;
        a6 += 2 * a5;
        v19 += 12;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2B20C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2B290(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2B314(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2B398(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 114688) >> 1;
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2B418(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 114688) >> 1;
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2B498(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = (v10 + 114688) >> 1;
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2B518()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = v3 - 6 * v2 - 6;
    uint64_t v8 = 2 * v2;
    uint64_t v9 = v24;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (v1 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = (v13 + 114688) >> 1;
        v11 += 2;
      }
      while (v10 != 48);
      v9 += 96;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v24;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          unsigned int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 48;
            v19 += byte_1BBB78AD5[8 * ((v1 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(v5 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 48);
        ++v15;
        v5 += 2 * v4;
        v16 += 48;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2B684(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6 * a3 - 6;
    uint64_t v8 = 2 * a3;
    uint64_t v9 = v24;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = (v13 + 114688) >> 1;
        v11 += 2;
      }
      while (v10 != 24);
      v9 += 48;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v24;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          unsigned int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 24;
            v19 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(a6 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 24);
        ++v15;
        a6 += 2 * a5;
        v16 += 24;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2B7D4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v24[213] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6 * a3 - 6;
    uint64_t v8 = 2 * a3;
    uint64_t v9 = v24;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *((_WORD *)v9 + v10++) = (v13 + 114688) >> 1;
        v11 += 2;
      }
      while (v10 != 12);
      v9 += 3;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v24;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          unsigned int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 12;
            v19 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          *(_WORD *)(a6 + 2 * v17++) = v19 >> 6;
          ++v18;
        }
        while (v17 != 12);
        ++v15;
        a6 += 2 * a5;
        v16 += 12;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2B924(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2B9AC(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2BA34(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        *(_WORD *)(a6 + 2 * v9++) = (v11 + 114688) >> 1;
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2BABC(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 114688) >> 1;
        v9 += 2;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2BB40(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 114688) >> 1;
        v9 += 2;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2BBC4(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = (v11 + 114688) >> 1;
        v9 += 2;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2BC48(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    do
    {
      for (uint64_t i = 0; i != 96; i += 2)
        *(_WORD *)(a6 + i) = 32 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2BC94(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    do
    {
      for (uint64_t i = 0; i != 48; i += 2)
        *(_WORD *)(a6 + i) = 32 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2BCE0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    do
    {
      for (uint64_t i = 0; i != 24; i += 2)
        *(_WORD *)(a6 + i) = 32 * *(_WORD *)(a4 + i) - 0x2000;
      ++v6;
      a6 += 2 * a5;
      a4 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2BD2C()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * v2;
    uint64_t v8 = v3 - 2 * v2 - 4;
    uint64_t v9 = v27;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        unsigned int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (v1 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = v12 >> 1;
        ++v11;
      }
      while (v10 != 48);
      v9 += 96;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      unsigned int v19 = (__int16 *)v27;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          int v22 = 0;
          uint64_t v23 = -4;
          int v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 48;
            v22 += byte_1BBB78AED[4 * ((v1 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          int v26 = (v22 + 1024) >> 11;
          if (v26 >= 511) {
            int v26 = 511;
          }
          *(_WORD *)(v5 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 48);
        ++v18;
        v5 += 2 * v4;
        v19 += 48;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2BEA0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * a3;
    uint64_t v8 = a4 - 2 * a3 - 4;
    uint64_t v9 = v27;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        unsigned int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (a2 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *(_WORD *)&v9[2 * v10++] = v12 >> 1;
        ++v11;
      }
      while (v10 != 24);
      v9 += 48;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      unsigned int v19 = (__int16 *)v27;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          int v22 = 0;
          uint64_t v23 = -4;
          int v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 24;
            v22 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          int v26 = (v22 + 1024) >> 11;
          if (v26 >= 511) {
            int v26 = 511;
          }
          *(_WORD *)(a6 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 24);
        ++v18;
        a6 += 2 * a5;
        v19 += 24;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2BFF8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v27[201] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = 2 * a3;
    uint64_t v8 = a4 - 2 * a3 - 4;
    uint64_t v9 = v27;
    do
    {
      uint64_t v10 = 0;
      int v11 = (unsigned __int16 *)v8;
      do
      {
        unsigned int v12 = 0;
        uint64_t v13 = -4;
        int v14 = v11;
        do
        {
          int v15 = *v14;
          v14 += 2;
          v12 += byte_1BBB78AED[4 * (a2 & 7) + v13] * v15;
          BOOL v16 = __CFADD__(v13++, 1);
        }
        while (!v16);
        *((_WORD *)v9 + v10++) = v12 >> 1;
        ++v11;
      }
      while (v10 != 12);
      v9 += 3;
      v8 += v7;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v18 = 0;
      unsigned int v19 = (__int16 *)v27;
      do
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19;
        do
        {
          int v22 = 0;
          uint64_t v23 = -4;
          int v24 = v21;
          do
          {
            int v25 = *v24;
            v24 += 12;
            v22 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v23] * v25;
            BOOL v16 = __CFADD__(v23++, 1);
          }
          while (!v16);
          int v26 = (v22 + 1024) >> 11;
          if (v26 >= 511) {
            int v26 = 511;
          }
          *(_WORD *)(a6 + 2 * v20++) = v26 & ~(unsigned __int16)(v26 >> 31);
          ++v21;
        }
        while (v20 != 12);
        ++v18;
        a6 += 2 * a5;
        v19 += 12;
      }
      while (v18 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2C150(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 511) {
          int v15 = 511;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2C1E4(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 511) {
          int v15 = 511;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2C278(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 2 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -4;
        uint64_t v13 = v10;
        do
        {
          v11 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v12] * *v13;
          uint64_t v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 511) {
          int v15 = 511;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2C30C(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        int v15 = (v10 + 32) >> 6;
        if (v15 >= 511) {
          int v15 = 511;
        }
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2C39C(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        int v15 = (v10 + 32) >> 6;
        if (v15 >= 511) {
          int v15 = 511;
        }
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2C42C(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 4);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        int v15 = (v10 + 32) >> 6;
        if (v15 >= 511) {
          int v15 = 511;
        }
        *(_WORD *)(a6 + 2 * v8++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2C4BC()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = v3 - 6 * v2 - 6;
    uint64_t v8 = 2 * v2;
    uint64_t v9 = v25;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        unsigned int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (v1 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = v13 >> 1;
        v11 += 2;
      }
      while (v10 != 48);
      v9 += 96;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v25;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 48;
            v19 += byte_1BBB78AD5[8 * ((v1 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          int v24 = (v19 + 1024) >> 11;
          if (v24 >= 511) {
            int v24 = 511;
          }
          *(_WORD *)(v5 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 48);
        ++v15;
        v5 += 2 * v4;
        v16 += 48;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2C638(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6 * a3 - 6;
    uint64_t v8 = 2 * a3;
    uint64_t v9 = v25;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        unsigned int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *(_WORD *)&v9[2 * v10++] = v13 >> 1;
        v11 += 2;
      }
      while (v10 != 24);
      v9 += 48;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v25;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 24;
            v19 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          int v24 = (v19 + 1024) >> 11;
          if (v24 >= 511) {
            int v24 = 511;
          }
          *(_WORD *)(a6 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 24);
        ++v15;
        a6 += 2 * a5;
        v16 += 24;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2C798(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v25[213] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6 * a3 - 6;
    uint64_t v8 = 2 * a3;
    uint64_t v9 = v25;
    do
    {
      uint64_t v10 = 0;
      uint64_t v11 = v7;
      do
      {
        uint64_t v12 = 0;
        unsigned int v13 = 0;
        do
        {
          v13 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v12] * *(unsigned __int16 *)(v11 + 2 * v12);
          ++v12;
        }
        while (v12 != 8);
        *((_WORD *)v9 + v10++) = v13 >> 1;
        v11 += 2;
      }
      while (v10 != 12);
      v9 += 3;
      v7 += v8;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v15 = 0;
      BOOL v16 = (__int16 *)v25;
      do
      {
        uint64_t v17 = 0;
        int v18 = v16;
        do
        {
          int v19 = 0;
          uint64_t v20 = -8;
          uint64_t v21 = v18;
          do
          {
            int v22 = *v21;
            v21 += 12;
            v19 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v20] * v22;
          }
          while (!__CFADD__(v20++, 1));
          int v24 = (v19 + 1024) >> 11;
          if (v24 >= 511) {
            int v24 = 511;
          }
          *(_WORD *)(a6 + 2 * v17++) = v24 & ~(unsigned __int16)(v24 >> 31);
          ++v18;
        }
        while (v17 != 12);
        ++v15;
        a6 += 2 * a5;
        v16 += 12;
      }
      while (v15 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2C8F8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        unsigned int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          unsigned int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 511) {
          int v15 = 511;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 48);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2C990(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        unsigned int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          unsigned int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 511) {
          int v15 = 511;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 24);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2CA28(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int16 *)(a4 - 6 * a3);
    uint64_t v8 = 2 * a3;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        int v11 = 0;
        uint64_t v12 = -8;
        unsigned int v13 = v10;
        do
        {
          v11 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v12] * *v13;
          unsigned int v13 = (unsigned __int16 *)((char *)v13 + v8);
        }
        while (!__CFADD__(v12++, 1));
        int v15 = (v11 + 32) >> 6;
        if (v15 >= 511) {
          int v15 = 511;
        }
        *(_WORD *)(a6 + 2 * v9++) = v15 & ~(unsigned __int16)(v15 >> 31);
        ++v10;
      }
      while (v9 != 12);
      ++v6;
      a6 += 2 * a5;
      uint64_t v7 = (unsigned __int16 *)((char *)v7 + v8);
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2CAC0(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        int v12 = (v11 + 32) >> 6;
        if (v12 >= 511) {
          int v12 = 511;
        }
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2CB54(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        int v12 = (v11 + 32) >> 6;
        if (v12 >= 511) {
          int v12 = 511;
        }
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2CBE8(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 6;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int16 *)(v9 + 2 * v10);
          ++v10;
        }
        while (v10 != 8);
        int v12 = (v11 + 32) >> 6;
        if (v12 >= 511) {
          int v12 = 511;
        }
        *(_WORD *)(a6 + 2 * v8++) = v12 & ~(unsigned __int16)(v12 >> 31);
        v9 += 2;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += 2 * a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2CC7C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((int)result >= 1)
  {
    int v5 = 0;
    do
    {
      for (uint64_t i = 0; i != 48; ++i)
      {
        int v7 = (*(__int16 *)(a2 + 2 * i) + *(__int16 *)(a3 + 2 * i) + 16448) >> 7;
        if (v7 >= 255) {
          int v7 = 255;
        }
        *(unsigned char *)(a5 + i) = v7 & ~(v7 >> 31);
      }
      ++v5;
      a2 += 96;
      a3 += 96;
      a5 += a4;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t sub_1BBA2CCE0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((int)result >= 1)
  {
    int v5 = 0;
    do
    {
      for (uint64_t i = 0; i != 24; ++i)
      {
        int v7 = (*(__int16 *)(a2 + 2 * i) + *(__int16 *)(a3 + 2 * i) + 16448) >> 7;
        if (v7 >= 255) {
          int v7 = 255;
        }
        *(unsigned char *)(a5 + i) = v7 & ~(v7 >> 31);
      }
      ++v5;
      a2 += 48;
      a3 += 48;
      a5 += a4;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t sub_1BBA2CD44(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((int)result >= 1)
  {
    int v5 = 0;
    do
    {
      for (uint64_t i = 0; i != 12; ++i)
      {
        int v7 = (*(__int16 *)(a2 + 2 * i) + *(__int16 *)(a3 + 2 * i) + 16448) >> 7;
        if (v7 >= 255) {
          int v7 = 255;
        }
        *(unsigned char *)(a5 + i) = v7 & ~(v7 >> 31);
      }
      ++v5;
      a2 += 24;
      a3 += 24;
      a5 += a4;
    }
    while (v5 != result);
  }
  return result;
}

uint64_t sub_1BBA2CDA8(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if ((int)result >= 1)
  {
    int v10 = 0;
    int v12 = (*a7 + *a4 + 1) << a2;
    char v13 = a2 + 1;
    int v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      uint64_t v15 = 2;
      uint64_t v16 = 1;
      do
      {
        int v17 = (v12 + (*(__int16 *)(a5 + v15 - 2) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15 - 2) + 0x2000) * *a6) >> v13;
        if (v17 >= 255) {
          int v17 = 255;
        }
        *(unsigned char *)(a10 + v16 - 1) = v17 & ~(v17 >> 31);
        int v18 = (v14 + (*(__int16 *)(a5 + v15) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 255) {
          int v18 = 255;
        }
        *(unsigned char *)(a10 + v16) = v18 & ~(v18 >> 31);
        unint64_t v19 = v16 - 1;
        v16 += 2;
        v15 += 4;
      }
      while (v19 < 0x2E);
      ++v10;
      a5 += 96;
      a8 += 96;
      a10 += a9;
    }
    while (v10 != result);
  }
  return result;
}

uint64_t sub_1BBA2CE9C(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if ((int)result >= 1)
  {
    int v10 = 0;
    int v12 = (*a7 + *a4 + 1) << a2;
    char v13 = a2 + 1;
    int v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      uint64_t v15 = 2;
      uint64_t v16 = 1;
      do
      {
        int v17 = (v12 + (*(__int16 *)(a5 + v15 - 2) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15 - 2) + 0x2000) * *a6) >> v13;
        if (v17 >= 255) {
          int v17 = 255;
        }
        *(unsigned char *)(a10 + v16 - 1) = v17 & ~(v17 >> 31);
        int v18 = (v14 + (*(__int16 *)(a5 + v15) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 255) {
          int v18 = 255;
        }
        *(unsigned char *)(a10 + v16) = v18 & ~(v18 >> 31);
        unint64_t v19 = v16 - 1;
        v16 += 2;
        v15 += 4;
      }
      while (v19 < 0x16);
      ++v10;
      a5 += 48;
      a8 += 48;
      a10 += a9;
    }
    while (v10 != result);
  }
  return result;
}

uint64_t sub_1BBA2CF90(uint64_t result, char a2, __int16 *a3, __int16 *a4, uint64_t a5, __int16 *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if ((int)result >= 1)
  {
    int v10 = 0;
    int v12 = (*a7 + *a4 + 1) << a2;
    char v13 = a2 + 1;
    int v14 = (a7[1] + a4[1] + 1) << a2;
    do
    {
      uint64_t v15 = 2;
      uint64_t v16 = 1;
      do
      {
        int v17 = (v12 + (*(__int16 *)(a5 + v15 - 2) + 0x2000) * *a3 + (*(__int16 *)(a8 + v15 - 2) + 0x2000) * *a6) >> v13;
        if (v17 >= 255) {
          int v17 = 255;
        }
        *(unsigned char *)(a10 + v16 - 1) = v17 & ~(v17 >> 31);
        int v18 = (v14 + (*(__int16 *)(a5 + v15) + 0x2000) * a3[1] + (*(__int16 *)(a8 + v15) + 0x2000) * a6[1]) >> v13;
        if (v18 >= 255) {
          int v18 = 255;
        }
        *(unsigned char *)(a10 + v16) = v18 & ~(v18 >> 31);
        unint64_t v19 = v16 - 1;
        v16 += 2;
        v15 += 4;
      }
      while (v19 < 0xA);
      ++v10;
      a5 += 24;
      a8 += 24;
      a10 += a9;
    }
    while (v10 != result);
  }
  return result;
}

uint64_t sub_1BBA2D084(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7 = 1 << (a2 - 1);
  if (a2 <= 0) {
    int v7 = 0;
  }
  if ((int)result >= 1)
  {
    int v8 = 0;
    uint64_t v9 = (__int16 *)(a5 + 2);
    do
    {
      int v10 = v9;
      uint64_t v11 = 1;
      do
      {
        int v12 = ((v7 + (*(v10 - 1) + 0x2000) * *a3) >> a2) + *a4;
        if (v12 >= 255) {
          int v12 = 255;
        }
        *(unsigned char *)(a7 + v11 - 1) = v12 & ~(v12 >> 31);
        int v13 = ((v7 + (*v10 + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v13 >= 255) {
          int v13 = 255;
        }
        *(unsigned char *)(a7 + v11) = v13 & ~(v13 >> 31);
        unint64_t v14 = v11 - 1;
        v11 += 2;
        v10 += 2;
      }
      while (v14 < 0x2E);
      ++v8;
      a7 += a6;
      v9 += 48;
    }
    while (v8 != result);
  }
  return result;
}

uint64_t sub_1BBA2D13C(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7 = 1 << (a2 - 1);
  if (a2 <= 0) {
    int v7 = 0;
  }
  if ((int)result >= 1)
  {
    int v8 = 0;
    uint64_t v9 = (__int16 *)(a5 + 2);
    do
    {
      int v10 = v9;
      uint64_t v11 = 1;
      do
      {
        int v12 = ((v7 + (*(v10 - 1) + 0x2000) * *a3) >> a2) + *a4;
        if (v12 >= 255) {
          int v12 = 255;
        }
        *(unsigned char *)(a7 + v11 - 1) = v12 & ~(v12 >> 31);
        int v13 = ((v7 + (*v10 + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v13 >= 255) {
          int v13 = 255;
        }
        *(unsigned char *)(a7 + v11) = v13 & ~(v13 >> 31);
        unint64_t v14 = v11 - 1;
        v11 += 2;
        v10 += 2;
      }
      while (v14 < 0x16);
      ++v8;
      a7 += a6;
      v9 += 24;
    }
    while (v8 != result);
  }
  return result;
}

uint64_t sub_1BBA2D1F4(uint64_t result, int a2, __int16 *a3, __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7 = 1 << (a2 - 1);
  if (a2 <= 0) {
    int v7 = 0;
  }
  if ((int)result >= 1)
  {
    int v8 = 0;
    uint64_t v9 = (__int16 *)(a5 + 2);
    do
    {
      int v10 = v9;
      uint64_t v11 = 1;
      do
      {
        int v12 = ((v7 + (*(v10 - 1) + 0x2000) * *a3) >> a2) + *a4;
        if (v12 >= 255) {
          int v12 = 255;
        }
        *(unsigned char *)(a7 + v11 - 1) = v12 & ~(v12 >> 31);
        int v13 = ((v7 + (*v10 + 0x2000) * a3[1]) >> a2) + a4[1];
        if (v13 >= 255) {
          int v13 = 255;
        }
        *(unsigned char *)(a7 + v11) = v13 & ~(v13 >> 31);
        unint64_t v14 = v11 - 1;
        v11 += 2;
        v10 += 2;
      }
      while (v14 < 0xA);
      ++v8;
      a7 += a6;
      v9 += 12;
    }
    while (v8 != result);
  }
  return result;
}

uint64_t sub_1BBA2D2AC()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = v3 - v2 - 2;
    int v8 = v25;
    do
    {
      uint64_t v9 = 0;
      int v10 = (unsigned __int8 *)v7;
      do
      {
        __int16 v11 = 0;
        uint64_t v12 = -4;
        int v13 = v10;
        do
        {
          __int16 v14 = *v13;
          v13 += 2;
          v11 += byte_1BBB78AED[4 * (v1 & 7) + v12] * v14;
          BOOL v15 = __CFADD__(v12++, 1);
        }
        while (!v15);
        *(_WORD *)&v8[2 * v9++] = v11 - 0x2000;
        ++v10;
      }
      while (v9 != 48);
      v8 += 96;
      v7 += v2;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v17 = 0;
      int v18 = (__int16 *)v25;
      do
      {
        uint64_t v19 = 0;
        uint64_t v20 = v18;
        do
        {
          unsigned int v21 = 0;
          uint64_t v22 = -4;
          uint64_t v23 = v20;
          do
          {
            int v24 = *v23;
            v23 += 48;
            v21 += byte_1BBB78AED[4 * ((v1 >> 16) & 7) + v22] * v24;
            BOOL v15 = __CFADD__(v22++, 1);
          }
          while (!v15);
          *(_WORD *)(v5 + 2 * v19++) = v21 >> 6;
          ++v20;
        }
        while (v19 != 48);
        ++v17;
        v5 += 2 * v4;
        v18 += 48;
      }
      while (v17 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2D408(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = a4 - a3 - 2;
    int v8 = v25;
    do
    {
      uint64_t v9 = 0;
      int v10 = (unsigned __int8 *)v7;
      do
      {
        __int16 v11 = 0;
        uint64_t v12 = -4;
        int v13 = v10;
        do
        {
          __int16 v14 = *v13;
          v13 += 2;
          v11 += byte_1BBB78AED[4 * (a2 & 7) + v12] * v14;
          BOOL v15 = __CFADD__(v12++, 1);
        }
        while (!v15);
        *(_WORD *)&v8[2 * v9++] = v11 - 0x2000;
        ++v10;
      }
      while (v9 != 24);
      v8 += 48;
      v7 += a3;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v17 = 0;
      int v18 = (__int16 *)v25;
      do
      {
        uint64_t v19 = 0;
        uint64_t v20 = v18;
        do
        {
          unsigned int v21 = 0;
          uint64_t v22 = -4;
          uint64_t v23 = v20;
          do
          {
            int v24 = *v23;
            v23 += 24;
            v21 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v22] * v24;
            BOOL v15 = __CFADD__(v22++, 1);
          }
          while (!v15);
          *(_WORD *)(a6 + 2 * v19++) = v21 >> 6;
          ++v20;
        }
        while (v19 != 24);
        ++v17;
        a6 += 2 * a5;
        v18 += 24;
      }
      while (v17 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2D548(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v25[201] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = a4 - a3 - 2;
    int v8 = v25;
    do
    {
      uint64_t v9 = 0;
      int v10 = (unsigned __int8 *)v7;
      do
      {
        __int16 v11 = 0;
        uint64_t v12 = -4;
        int v13 = v10;
        do
        {
          __int16 v14 = *v13;
          v13 += 2;
          v11 += byte_1BBB78AED[4 * (a2 & 7) + v12] * v14;
          BOOL v15 = __CFADD__(v12++, 1);
        }
        while (!v15);
        *((_WORD *)v8 + v9++) = v11 - 0x2000;
        ++v10;
      }
      while (v9 != 12);
      v8 += 3;
      v7 += a3;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v17 = 0;
      int v18 = (__int16 *)v25;
      do
      {
        uint64_t v19 = 0;
        uint64_t v20 = v18;
        do
        {
          unsigned int v21 = 0;
          uint64_t v22 = -4;
          uint64_t v23 = v20;
          do
          {
            int v24 = *v23;
            v23 += 12;
            v21 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v22] * v24;
            BOOL v15 = __CFADD__(v22++, 1);
          }
          while (!v15);
          *(_WORD *)(a6 + 2 * v19++) = v21 >> 6;
          ++v20;
        }
        while (v19 != 12);
        ++v17;
        a6 += 2 * a5;
        v18 += 12;
      }
      while (v17 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2D688(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        __int16 v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          v10 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = v10 - 0x2000;
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2D704(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        __int16 v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          v10 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = v10 - 0x2000;
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2D780(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        __int16 v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          v10 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = v10 - 0x2000;
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2D7FC(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 2);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        __int16 v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          __int16 v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = v10 - 0x2000;
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2D874(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 2);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        __int16 v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          __int16 v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = v10 - 0x2000;
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2D8EC(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 2);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        __int16 v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          __int16 v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = v10 - 0x2000;
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2D964()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = v3 - 3 * v2 - 3;
    uint64_t v8 = v23;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        uint64_t v11 = 0;
        __int16 v12 = 0;
        do
        {
          v12 += byte_1BBB78AD5[8 * (v1 & 3) - 8 + v11] * *(unsigned __int8 *)(v10 + v11);
          ++v11;
        }
        while (v11 != 8);
        *(_WORD *)&v8[2 * v9++] = v12 - 0x2000;
        ++v10;
      }
      while (v9 != 48);
      v8 += 96;
      v7 += v2;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v14 = 0;
      BOOL v15 = (__int16 *)v23;
      do
      {
        uint64_t v16 = 0;
        int v17 = v15;
        do
        {
          unsigned int v18 = 0;
          uint64_t v19 = -8;
          uint64_t v20 = v17;
          do
          {
            int v21 = *v20;
            v20 += 48;
            v18 += byte_1BBB78AD5[8 * ((v1 >> 16) & 3) + v19] * v21;
          }
          while (!__CFADD__(v19++, 1));
          *(_WORD *)(v5 + 2 * v16++) = v18 >> 6;
          ++v17;
        }
        while (v16 != 48);
        ++v14;
        v5 += 2 * v4;
        v15 += 48;
      }
      while (v14 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2DAC8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 3 * a3 - 3;
    uint64_t v8 = v23;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        uint64_t v11 = 0;
        __int16 v12 = 0;
        do
        {
          v12 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v11] * *(unsigned __int8 *)(v10 + v11);
          ++v11;
        }
        while (v11 != 8);
        *(_WORD *)&v8[2 * v9++] = v12 - 0x2000;
        ++v10;
      }
      while (v9 != 24);
      v8 += 48;
      v7 += a3;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v14 = 0;
      BOOL v15 = (__int16 *)v23;
      do
      {
        uint64_t v16 = 0;
        int v17 = v15;
        do
        {
          unsigned int v18 = 0;
          uint64_t v19 = -8;
          uint64_t v20 = v17;
          do
          {
            int v21 = *v20;
            v20 += 24;
            v18 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v19] * v21;
          }
          while (!__CFADD__(v19++, 1));
          *(_WORD *)(a6 + 2 * v16++) = v18 >> 6;
          ++v17;
        }
        while (v16 != 24);
        ++v14;
        a6 += 2 * a5;
        v15 += 24;
      }
      while (v14 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2DC10(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v23[213] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 3 * a3 - 3;
    uint64_t v8 = v23;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        uint64_t v11 = 0;
        __int16 v12 = 0;
        do
        {
          v12 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v11] * *(unsigned __int8 *)(v10 + v11);
          ++v11;
        }
        while (v11 != 8);
        *((_WORD *)v8 + v9++) = v12 - 0x2000;
        ++v10;
      }
      while (v9 != 12);
      v8 += 3;
      v7 += a3;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v14 = 0;
      BOOL v15 = (__int16 *)v23;
      do
      {
        uint64_t v16 = 0;
        int v17 = v15;
        do
        {
          unsigned int v18 = 0;
          uint64_t v19 = -8;
          uint64_t v20 = v17;
          do
          {
            int v21 = *v20;
            v20 += 12;
            v18 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v19] * v21;
          }
          while (!__CFADD__(v19++, 1));
          *(_WORD *)(a6 + 2 * v16++) = v18 >> 6;
          ++v17;
        }
        while (v16 != 12);
        ++v14;
        a6 += 2 * a5;
        v15 += 12;
      }
      while (v14 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2DD58(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 3 * a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        __int16 v10 = 0;
        uint64_t v11 = -8;
        __int16 v12 = v9;
        do
        {
          v10 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = v10 - 0x2000;
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2DDD8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 3 * a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        __int16 v10 = 0;
        uint64_t v11 = -8;
        __int16 v12 = v9;
        do
        {
          v10 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = v10 - 0x2000;
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2DE58(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 3 * a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        __int16 v10 = 0;
        uint64_t v11 = -8;
        __int16 v12 = v9;
        do
        {
          v10 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        *(_WORD *)(a6 + 2 * v8++) = v10 - 0x2000;
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2DED8(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 3;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        __int16 v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int8 *)(v9 + v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = v11 - 0x2000;
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2DF54(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 3;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        __int16 v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int8 *)(v9 + v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = v11 - 0x2000;
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2DFD0(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 3;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        __int16 v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int8 *)(v9 + v10);
          ++v10;
        }
        while (v10 != 8);
        *(_WORD *)(a6 + 2 * v8++) = v11 - 0x2000;
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += 2 * a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2E04C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    do
    {
      for (uint64_t i = 0; i != 48; ++i)
        *(_WORD *)(a6 + 2 * i) = (*(unsigned __int8 *)(a4 + i) << 6) - 0x2000;
      ++v6;
      a4 += a3;
      a6 += 2 * a5;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2E094(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    do
    {
      for (uint64_t i = 0; i != 24; ++i)
        *(_WORD *)(a6 + 2 * i) = (*(unsigned __int8 *)(a4 + i) << 6) - 0x2000;
      ++v6;
      a4 += a3;
      a6 += 2 * a5;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2E0DC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    do
    {
      for (uint64_t i = 0; i != 12; ++i)
        *(_WORD *)(a6 + 2 * i) = (*(unsigned __int8 *)(a4 + i) << 6) - 0x2000;
      ++v6;
      a4 += a3;
      a6 += 2 * a5;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2E124()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = v3 - v2 - 2;
    uint64_t v8 = v26;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = (unsigned __int8 *)v7;
      do
      {
        __int16 v11 = 0;
        uint64_t v12 = -4;
        __int16 v13 = v10;
        do
        {
          __int16 v14 = *v13;
          v13 += 2;
          v11 += byte_1BBB78AED[4 * (v1 & 7) + v12] * v14;
          BOOL v15 = __CFADD__(v12++, 1);
        }
        while (!v15);
        *(_WORD *)&v8[2 * v9++] = v11;
        ++v10;
      }
      while (v9 != 48);
      v8 += 96;
      v7 += v2;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v17 = 0;
      unsigned int v18 = (__int16 *)v26;
      do
      {
        uint64_t v19 = 0;
        uint64_t v20 = v18;
        do
        {
          int v21 = 0;
          uint64_t v22 = -4;
          uint64_t v23 = v20;
          do
          {
            int v24 = *v23;
            v23 += 48;
            v21 += byte_1BBB78AED[4 * ((v1 >> 16) & 7) + v22] * v24;
            BOOL v15 = __CFADD__(v22++, 1);
          }
          while (!v15);
          int v25 = (v21 + 2048) >> 12;
          if (v25 >= 255) {
            int v25 = 255;
          }
          *(unsigned char *)(v5 + v19++) = v25 & ~(v25 >> 31);
          ++v20;
        }
        while (v19 != 48);
        ++v17;
        v5 += v4;
        v18 += 48;
      }
      while (v17 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2E290(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = a4 - a3 - 2;
    uint64_t v8 = v26;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = (unsigned __int8 *)v7;
      do
      {
        __int16 v11 = 0;
        uint64_t v12 = -4;
        __int16 v13 = v10;
        do
        {
          __int16 v14 = *v13;
          v13 += 2;
          v11 += byte_1BBB78AED[4 * (a2 & 7) + v12] * v14;
          BOOL v15 = __CFADD__(v12++, 1);
        }
        while (!v15);
        *(_WORD *)&v8[2 * v9++] = v11;
        ++v10;
      }
      while (v9 != 24);
      v8 += 48;
      v7 += a3;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v17 = 0;
      unsigned int v18 = (__int16 *)v26;
      do
      {
        uint64_t v19 = 0;
        uint64_t v20 = v18;
        do
        {
          int v21 = 0;
          uint64_t v22 = -4;
          uint64_t v23 = v20;
          do
          {
            int v24 = *v23;
            v23 += 24;
            v21 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v22] * v24;
            BOOL v15 = __CFADD__(v22++, 1);
          }
          while (!v15);
          int v25 = (v21 + 2048) >> 12;
          if (v25 >= 255) {
            int v25 = 255;
          }
          *(unsigned char *)(a6 + v19++) = v25 & ~(v25 >> 31);
          ++v20;
        }
        while (v19 != 24);
        ++v17;
        a6 += a5;
        v18 += 24;
      }
      while (v17 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2E3E0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v26[201] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -2)
  {
    int v6 = 0;
    uint64_t v7 = a4 - a3 - 2;
    uint64_t v8 = v26;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = (unsigned __int8 *)v7;
      do
      {
        __int16 v11 = 0;
        uint64_t v12 = -4;
        __int16 v13 = v10;
        do
        {
          __int16 v14 = *v13;
          v13 += 2;
          v11 += byte_1BBB78AED[4 * (a2 & 7) + v12] * v14;
          BOOL v15 = __CFADD__(v12++, 1);
        }
        while (!v15);
        *((_WORD *)v8 + v9++) = v11;
        ++v10;
      }
      while (v9 != 12);
      v8 += 3;
      v7 += a3;
    }
    while (v6++ != result + 2);
    if ((int)result >= 1)
    {
      int v17 = 0;
      unsigned int v18 = (__int16 *)v26;
      do
      {
        uint64_t v19 = 0;
        uint64_t v20 = v18;
        do
        {
          int v21 = 0;
          uint64_t v22 = -4;
          uint64_t v23 = v20;
          do
          {
            int v24 = *v23;
            v23 += 12;
            v21 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v22] * v24;
            BOOL v15 = __CFADD__(v22++, 1);
          }
          while (!v15);
          int v25 = (v21 + 2048) >> 12;
          if (v25 >= 255) {
            int v25 = 255;
          }
          *(unsigned char *)(a6 + v19++) = v25 & ~(v25 >> 31);
          ++v20;
        }
        while (v19 != 12);
        ++v17;
        a6 += a5;
        v18 += 12;
      }
      while (v17 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2E530(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          v10 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        int v14 = (v10 + 32) >> 6;
        if (v14 >= 255) {
          int v14 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v14 & ~(v14 >> 31);
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2E5C0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          v10 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        int v14 = (v10 + 32) >> 6;
        if (v14 >= 255) {
          int v14 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v14 & ~(v14 >> 31);
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2E650(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          v10 += byte_1BBB78AED[4 * ((a2 >> 16) & 7) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        int v14 = (v10 + 32) >> 6;
        if (v14 >= 255) {
          int v14 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v14 & ~(v14 >> 31);
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2E6E0(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 2);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        int v15 = (v10 + 32) >> 6;
        if (v15 >= 255) {
          int v15 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v15 & ~(v15 >> 31);
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2E76C(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 2);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        int v15 = (v10 + 32) >> 6;
        if (v15 >= 255) {
          int v15 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v15 & ~(v15 >> 31);
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2E7F8(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 2);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -4;
        uint64_t v12 = v9;
        do
        {
          int v13 = *v12;
          v12 += 2;
          v10 += byte_1BBB78AED[4 * (a2 & 7) + v11] * v13;
        }
        while (!__CFADD__(v11++, 1));
        int v15 = (v10 + 32) >> 6;
        if (v15 >= 255) {
          int v15 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v15 & ~(v15 >> 31);
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2E884()
{
  uint64_t result = MEMORY[0x1F4188790]();
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = v3 - 3 * v2 - 3;
    uint64_t v8 = v24;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        uint64_t v11 = 0;
        __int16 v12 = 0;
        do
        {
          v12 += byte_1BBB78AD5[8 * (v1 & 3) - 8 + v11] * *(unsigned __int8 *)(v10 + v11);
          ++v11;
        }
        while (v11 != 8);
        *(_WORD *)&v8[2 * v9++] = v12;
        ++v10;
      }
      while (v9 != 48);
      v8 += 96;
      v7 += v2;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v14 = 0;
      int v15 = (__int16 *)v24;
      do
      {
        uint64_t v16 = 0;
        int v17 = v15;
        do
        {
          int v18 = 0;
          uint64_t v19 = -8;
          uint64_t v20 = v17;
          do
          {
            int v21 = *v20;
            v20 += 48;
            v18 += byte_1BBB78AD5[8 * ((v1 >> 16) & 3) + v19] * v21;
          }
          while (!__CFADD__(v19++, 1));
          int v23 = (v18 + 2048) >> 12;
          if (v23 >= 255) {
            int v23 = 255;
          }
          *(unsigned char *)(v5 + v16++) = v23 & ~(v23 >> 31);
          ++v17;
        }
        while (v16 != 48);
        ++v14;
        v5 += v4;
        v15 += 48;
      }
      while (v14 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2E9F8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 3 * a3 - 3;
    uint64_t v8 = v24;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        uint64_t v11 = 0;
        __int16 v12 = 0;
        do
        {
          v12 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v11] * *(unsigned __int8 *)(v10 + v11);
          ++v11;
        }
        while (v11 != 8);
        *(_WORD *)&v8[2 * v9++] = v12;
        ++v10;
      }
      while (v9 != 24);
      v8 += 48;
      v7 += a3;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v14 = 0;
      int v15 = (__int16 *)v24;
      do
      {
        uint64_t v16 = 0;
        int v17 = v15;
        do
        {
          int v18 = 0;
          uint64_t v19 = -8;
          uint64_t v20 = v17;
          do
          {
            int v21 = *v20;
            v20 += 24;
            v18 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v19] * v21;
          }
          while (!__CFADD__(v19++, 1));
          int v23 = (v18 + 2048) >> 12;
          if (v23 >= 255) {
            int v23 = 255;
          }
          *(unsigned char *)(a6 + v16++) = v23 & ~(v23 >> 31);
          ++v17;
        }
        while (v16 != 24);
        ++v14;
        a6 += a5;
        v15 += 24;
      }
      while (v14 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2EB50(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v24[213] = *MEMORY[0x1E4F143B8];
  if ((int)result >= -6)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 3 * a3 - 3;
    uint64_t v8 = v24;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v7;
      do
      {
        uint64_t v11 = 0;
        __int16 v12 = 0;
        do
        {
          v12 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v11] * *(unsigned __int8 *)(v10 + v11);
          ++v11;
        }
        while (v11 != 8);
        *((_WORD *)v8 + v9++) = v12;
        ++v10;
      }
      while (v9 != 12);
      v8 += 3;
      v7 += a3;
    }
    while (v6++ != result + 6);
    if ((int)result >= 1)
    {
      int v14 = 0;
      int v15 = (__int16 *)v24;
      do
      {
        uint64_t v16 = 0;
        int v17 = v15;
        do
        {
          int v18 = 0;
          uint64_t v19 = -8;
          uint64_t v20 = v17;
          do
          {
            int v21 = *v20;
            v20 += 12;
            v18 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v19] * v21;
          }
          while (!__CFADD__(v19++, 1));
          int v23 = (v18 + 2048) >> 12;
          if (v23 >= 255) {
            int v23 = 255;
          }
          *(unsigned char *)(a6 + v16++) = v23 & ~(v23 >> 31);
          ++v17;
        }
        while (v16 != 12);
        ++v14;
        a6 += a5;
        v15 += 12;
      }
      while (v14 != result);
    }
  }
  return result;
}

uint64_t sub_1BBA2ECA8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 3 * a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -8;
        __int16 v12 = v9;
        do
        {
          v10 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        int v14 = (v10 + 32) >> 6;
        if (v14 >= 255) {
          int v14 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v14 & ~(v14 >> 31);
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2ED3C(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 3 * a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -8;
        __int16 v12 = v9;
        do
        {
          v10 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        int v14 = (v10 + 32) >> 6;
        if (v14 >= 255) {
          int v14 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v14 & ~(v14 >> 31);
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2EDD0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = (unsigned __int8 *)(a4 - 3 * a3);
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        int v10 = 0;
        uint64_t v11 = -8;
        __int16 v12 = v9;
        do
        {
          v10 += byte_1BBB78AD5[8 * ((a2 >> 16) & 3) + v11] * *v12;
          v12 += a3;
        }
        while (!__CFADD__(v11++, 1));
        int v14 = (v10 + 32) >> 6;
        if (v14 >= 255) {
          int v14 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v14 & ~(v14 >> 31);
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2EE64(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 3;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int8 *)(v9 + v10);
          ++v10;
        }
        while (v10 != 8);
        int v12 = (v11 + 32) >> 6;
        if (v12 >= 255) {
          int v12 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v12 & ~(v12 >> 31);
        ++v9;
      }
      while (v8 != 48);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2EEF4(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 3;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int8 *)(v9 + v10);
          ++v10;
        }
        while (v10 != 8);
        int v12 = (v11 + 32) >> 6;
        if (v12 >= 255) {
          int v12 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v12 & ~(v12 >> 31);
        ++v9;
      }
      while (v8 != 24);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2EF84(uint64_t result, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    int v6 = 0;
    uint64_t v7 = a4 - 3;
    do
    {
      uint64_t v8 = 0;
      uint64_t v9 = v7;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          v11 += byte_1BBB78AD5[8 * (a2 & 3) - 8 + v10] * *(unsigned __int8 *)(v9 + v10);
          ++v10;
        }
        while (v10 != 8);
        int v12 = (v11 + 32) >> 6;
        if (v12 >= 255) {
          int v12 = 255;
        }
        *(unsigned char *)(a6 + v8++) = v12 & ~(v12 >> 31);
        ++v9;
      }
      while (v8 != 12);
      ++v6;
      a6 += a5;
      v7 += a3;
    }
    while (v6 != result);
  }
  return result;
}

uint64_t sub_1BBA2F014(uint64_t result, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, _OWORD *a6)
{
  if ((int)result >= 1)
  {
    do
    {
      long long v6 = *a4;
      long long v7 = a4[2];
      a6[1] = a4[1];
      a6[2] = v7;
      *a6 = v6;
      a4 = (long long *)((char *)a4 + a3);
      a6 = (_OWORD *)((char *)a6 + a5);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

uint64_t sub_1BBA2F040(uint64_t result, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    do
    {
      long long v6 = *a4;
      *(void *)(a6 + 16) = *((void *)a4 + 2);
      *(_OWORD *)a6 = v6;
      a4 = (long long *)((char *)a4 + a3);
      a6 += a5;
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

uint64_t sub_1BBA2F06C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  if ((int)result >= 1)
  {
    do
    {
      uint64_t v6 = *a4;
      *(_DWORD *)(a6 + 8) = *((_DWORD *)a4 + 2);
      *(void *)a6 = v6;
      a4 = (uint64_t *)((char *)a4 + a3);
      a6 += a5;
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

uint64_t sub_1BBA2F098(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11 = MEMORY[0x1F4188790]();
  uint64_t v13 = v12;
  unsigned int v15 = v14;
  uint64_t v17 = v16;
  uint64_t v18 = v11;
  STACK[0x4038] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = byte_1BBB78AC5[(v19 >> 2) - 1];
  uint64_t v22 = v11 + 512;
  uint64_t v23 = v19;
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, void, unint64_t *))(v11
                                                                                        + 512
                                                                                        + (((unint64_t)((v21 & 3) != 0) << 6) | ((unint64_t)((*(void *)&v21 & 0x30000) != 0) << 7))
                                                                                        + 8 * v20))(v16, v21, v24, v25, v19, &STACK[0x2020]);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t *))(v22
                                                                                + (((unint64_t)((v15 & 3) != 0) << 6) | ((unint64_t)((*(void *)&v15 & 0x30000) != 0) << 7))
                                                                                + 8 * v20))(v17, v15, v13, a9, v23, &v27);
  return (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t *, uint64_t, uint64_t))(v18 + 8 * v20 + 1152))(v17, &STACK[0x2020], &v27, a10, a11);
}

uint64_t sub_1BBA2F200(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11 = MEMORY[0x1F4188790]();
  uint64_t v13 = v12;
  unsigned int v15 = v14;
  uint64_t v17 = v16;
  uint64_t v18 = v11;
  STACK[0x2038] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = byte_1BBB78AC5[(v19 >> 1) - 1];
  uint64_t v22 = v11 + 768;
  uint64_t v23 = 2 * v19;
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, unint64_t *))(v11
                                                                                         + 768
                                                                                         + (((unint64_t)((v21 & 7) != 0) << 6) | ((unint64_t)((*(void *)&v21 & 0x70000) != 0) << 7))
                                                                                         + 8 * v20))(v16, v21, v24, v25, v23, &STACK[0x1020]);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t *))(v22
                                                                                + (((unint64_t)((v15 & 7) != 0) << 6) | ((unint64_t)((*(void *)&v15 & 0x70000) != 0) << 7))
                                                                                + 8 * v20))(v17, v15, v13, a9, v23, &v27);
  return (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t *, uint64_t, uint64_t))(v18 + 8 * v20 + 1152))(v17, &STACK[0x1020], &v27, a10, a11);
}

uint64_t sub_1BBA2F368(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11 = MEMORY[0x1F4188790]();
  __int16 v13 = v12;
  __int16 v15 = v14;
  uint64_t v17 = v16;
  uint64_t v19 = v18;
  STACK[0x2028] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = v11 + 8 * byte_1BBB78AC5[(v20 >> 2) - 1];
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, void, uint64_t *))(v22
                                                                               + (((unint64_t)((v21 & 3) != 0) << 6) | ((unint64_t)((*(void *)&v21 & 0x30000) != 0) << 7))
                                                                               + 512))(v18, v21, v23, a9, v20, &v27);
  v26[0] = v15;
  v26[1] = v15;
  v25[0] = v13;
  v25[1] = v13;
  return (*(uint64_t (**)(uint64_t, uint64_t, _WORD *, _WORD *, uint64_t *, uint64_t, uint64_t))(v22 + 1024))(v19, v17, v26, v25, &v27, a10, a11);
}

uint64_t sub_1BBA2F48C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11 = MEMORY[0x1F4188790]();
  uint64_t v13 = v12;
  uint64_t v15 = v14;
  uint64_t v17 = v16;
  uint64_t v19 = v18;
  STACK[0x1008] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = v11 + 8 * byte_1BBB78AC5[(v20 >> 1) - 1];
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, void, uint64_t *))(v22
                                                                               + (((unint64_t)((v21 & 7) != 0) << 6) | ((unint64_t)((*(void *)&v21 & 0x70000) != 0) << 7))
                                                                               + 768))(v18, v21, v23, a9, 2 * v20, &v25);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t))(v22 + 1024))(v19, v17, v15, v13, &v25, a10, a11);
}

uint64_t sub_1BBA2F5A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, __int16 a10, __int16 a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14 = MEMORY[0x1F4188790]();
  __int16 v16 = v15;
  __int16 v18 = v17;
  unsigned int v36 = v19;
  uint64_t v21 = v20;
  uint64_t v22 = v14;
  __int16 v23 = a11;
  __int16 v24 = a10;
  uint64_t v35 = a14;
  uint64_t v34 = a13;
  unsigned int v25 = a12;
  uint64_t v26 = a9;
  STACK[0x4078] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = byte_1BBB78AC5[(v27 >> 2) - 1];
  uint64_t v30 = v14 + 512;
  uint64_t v31 = v27;
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, void, unint64_t *))(v14
                                                                                        + 512
                                                                                        + (((unint64_t)((v29 & 3) != 0) << 6) | ((unint64_t)((*(void *)&v29 & 0x30000) != 0) << 7))
                                                                                        + 8 * v28))(v20, v29, v32, v26, v27, &STACK[0x2060]);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t *))(v30
                                                                                + (((unint64_t)((v25 & 3) != 0) << 6) | ((unint64_t)((*(void *)&v25 & 0x30000) != 0) << 7))
                                                                                + 8 * v28))(v21, v25, v34, v35, v31, &a9);
  vars8_4[0] = v18;
  vars8_4[1] = v18;
  vars8[0] = v16;
  vars8[1] = v16;
  vars0_4[0] = v24;
  vars0_4[1] = v24;
  vars0[0] = v23;
  vars0[1] = v23;
  return (*(uint64_t (**)(uint64_t, void, _WORD *, _WORD *, unint64_t *, _WORD *, _WORD *, uint64_t *))(v22 + 8 * v28 + 1088))(v21, v36, vars8_4, vars8, &STACK[0x2060], vars0_4, vars0, &a9);
}

uint64_t sub_1BBA2F760(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, unsigned int a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14 = MEMORY[0x1F4188790]();
  uint64_t v29 = v15;
  uint64_t v30 = v16;
  unsigned int v28 = v17;
  uint64_t v19 = v18;
  uint64_t v20 = v14;
  STACK[0x2058] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = byte_1BBB78AC5[(v21 >> 1) - 1];
  uint64_t v24 = v14 + 768;
  uint64_t v25 = 2 * v21;
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, unint64_t *))(v14
                                                                                         + 768
                                                                                         + (((unint64_t)((v23 & 7) != 0) << 6) | ((unint64_t)((*(void *)&v23 & 0x70000) != 0) << 7))
                                                                                         + 8 * v22))(v18, v23, v26, a9, v25, &STACK[0x1040]);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t *))(v24
                                                                                + (((unint64_t)((a12 & 7) != 0) << 6) | ((unint64_t)((a12 & 0x70000) != 0) << 7))
                                                                                + 8 * v22))(v19, a12, a13, a14, v25, &v31);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, unint64_t *, uint64_t, uint64_t, uint64_t *))(v20 + 8 * v22 + 1088))(v19, v28, v29, v30, &STACK[0x1040], a10, a11, &v31);
}

uint64_t sub_1BBA2F8E0(uint64_t result, int a2, const float *a3, __int16 *a4, uint64_t a5, const float *a6, __int16 *a7, int16x4_t *a8, uint64_t a9, int8x16_t *a10)
{
  int32x4_t v10 = vdupq_n_s32(~a2);
  int32x4_t v11 = (int32x4_t)vdupq_n_s64(((*a7 + *a4) << a2) | ((unint64_t)((a7[1] + a4[1]) << a2) << 32));
  int16x4_t v12 = (int16x4_t)vld1_dup_f32(a3);
  int16x4_t v13 = (int16x4_t)vld1_dup_f32(a6);
  uint64_t v14 = a10 + 2;
  int v15 = result + 1;
  do
  {
    int8x16_t v16 = *(int8x16_t *)(a5 + 16);
    int8x16_t v17 = vqmovun_high_s16(vqmovun_s16(vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)a5, v12), *a8, v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a5, *(int8x16_t *)a5, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8->i8, *(int8x16_t *)a8->i8, 8uLL), v13), v10))), vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v16.i8, v12), a8[2], v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8[2].i8, *(int8x16_t *)a8[2].i8, 8uLL), v13),
                           v10)));
    int8x16_t v18 = *(int8x16_t *)(a5 + 32);
    int8x16_t v19 = *(int8x16_t *)(a5 + 48);
    int8x16_t v20 = vqmovun_high_s16(vqmovun_s16(vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v18.i8, v12), a8[4], v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8[4].i8, *(int8x16_t *)a8[4].i8, 8uLL), v13), v10))), vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v19.i8, v12), a8[6], v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8[6].i8, *(int8x16_t *)a8[6].i8, 8uLL), v13), v10)));
    int8x16_t v21 = *(int8x16_t *)(a5 + 64);
    int8x16_t v22 = *(int8x16_t *)(a5 + 80);
    int8x16_t v23 = vqmovun_high_s16(vqmovun_s16(vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v21.i8, v12), a8[8], v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8[8].i8, *(int8x16_t *)a8[8].i8, 8uLL), v13), v10))), vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v22.i8, v12), a8[10], v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8[10].i8, *(int8x16_t *)a8[10].i8, 8uLL), v13), v10)));
    int8x16_t v24 = *(int8x16_t *)(a5 + 96);
    int8x16_t v25 = *(int8x16_t *)(a5 + 112);
    int8x16_t v26 = vqmovun_high_s16(vqmovun_s16(vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v24.i8, v12), a8[12], v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8[12].i8, *(int8x16_t *)a8[12].i8, 8uLL), v13), v10))), vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v25.i8, v12), a8[14], v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8[14].i8, *(int8x16_t *)a8[14].i8, 8uLL), v13), v10)));
    v14[-2] = v17;
    v14[-1] = v20;
    *uint64_t v14 = v23;
    v14[1] = v26;
    uint64_t v14 = (int8x16_t *)((char *)v14 + a9);
    --v15;
    a5 += 128;
    a8 += 16;
  }
  while (v15 > 1);
  return result;
}

uint64_t sub_1BBA2FAE8(uint64_t result, int a2, const float *a3, __int16 *a4, uint64_t a5, const float *a6, __int16 *a7, uint64_t a8, uint64_t a9, int16x8_t *a10)
{
  unint64_t v10 = 0;
  int16x4_t v12 = (int16x4_t)vld1_dup_f32(a3);
  int32x4_t v13 = vmovl_s16(v12);
  int16x4_t v14 = (int16x4_t)vld1_dup_f32(a6);
  int32x4_t v15 = vmovl_s16(v14);
  int32x4_t v16 = (int32x4_t)vdupq_n_s64(((*a7 + *a4) << a2) | ((unint64_t)((a7[1] + a4[1]) << a2) << 32));
  int32x4_t v17 = vdupq_n_s32(~a2);
  v18.i64[0] = 0x200000002000;
  v18.i64[1] = 0x200000002000;
  v19.i64[0] = 0xFC00FC00FC00FC00;
  v19.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int8x16_t v20 = (int16x4_t *)(a5 + 2 * v10);
    int v21 = result + 2;
    int8x16_t v22 = a10;
    int8x16_t v23 = (int16x4_t *)(a8 + 2 * v10);
    do
    {
      int16x8_t v24 = vminq_s16(vmaxq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmlaq_s32(vmlaq_s32(v16, vaddw_s16(v18, v20[16]), v13), vaddw_s16(v18, v23[16]), v15), v17)), vrshlq_s32(vmlaq_s32(vmlaq_s32(v16, vaddw_high_s16(v18, *(int16x8_t *)v20[16].i8), v13), vaddw_high_s16(v18, *(int16x8_t *)v23[16].i8), v15), v17)), (int16x8_t)0), v19);
      *int8x16_t v22 = vminq_s16(vmaxq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmlaq_s32(vmlaq_s32(v16, vaddw_s16(v18, *v20), v13), vaddw_s16(v18, *v23), v15), v17)), vrshlq_s32(vmlaq_s32(vmlaq_s32(v16, vaddw_high_s16(v18, *(int16x8_t *)v20->i8), v13), vaddw_high_s16(v18, *(int16x8_t *)v23->i8), v15), v17)), (int16x8_t)0), v19);
      *(int16x8_t *)((char *)v22 + 2 * a9) = v24;
      int8x16_t v22 = (int16x8_t *)((char *)v22 + 4 * a9);
      v21 -= 2;
      v20 += 32;
      v23 += 32;
    }
    while (v21 > 2);
    ++a10;
    BOOL v25 = v10 >= 0x38;
    v10 += 8;
  }
  while (!v25);
  return result;
}

uint64_t sub_1BBA2FC20(uint64_t result, int a2, const float *a3, __int16 *a4, uint64_t a5, const float *a6, __int16 *a7, int16x4_t *a8, uint64_t a9, int8x16_t *a10)
{
  int32x4_t v10 = vdupq_n_s32(~a2);
  int32x4_t v11 = (int32x4_t)vdupq_n_s64(((*a7 + *a4) << a2) | ((unint64_t)((a7[1] + a4[1]) << a2) << 32));
  int16x4_t v12 = (int16x4_t)vld1_dup_f32(a3);
  int16x4_t v13 = (int16x4_t)vld1_dup_f32(a6);
  int16x4_t v14 = a10 + 1;
  int v15 = result + 1;
  do
  {
    int8x16_t v16 = *(int8x16_t *)(a5 + 16);
    int8x16_t v17 = *(int8x16_t *)(a5 + 32);
    int8x16_t v18 = *(int8x16_t *)(a5 + 48);
    int8x16_t v19 = vqmovun_high_s16(vqmovun_s16(vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v17.i8, v12), a8[4], v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8[4].i8, *(int8x16_t *)a8[4].i8, 8uLL), v13), v10))), vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v18.i8, v12), a8[6], v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8[6].i8, *(int8x16_t *)a8[6].i8, 8uLL), v13), v10)));
    v14[-1] = vqmovun_high_s16(vqmovun_s16(vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)a5, v12), *a8, v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a5, *(int8x16_t *)a5, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8->i8, *(int8x16_t *)a8->i8, 8uLL), v13), v10))), vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v16.i8, v12), a8[2], v13), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), v12), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a8[2].i8, *(int8x16_t *)a8[2].i8, 8uLL), v13),
                               v10)));
    *int16x4_t v14 = v19;
    int16x4_t v14 = (int8x16_t *)((char *)v14 + a9);
    --v15;
    a5 += 64;
    a8 += 8;
  }
  while (v15 > 1);
  return result;
}

uint64_t sub_1BBA2FD54(uint64_t result, int a2, const float *a3, __int16 *a4, uint64_t a5, const float *a6, __int16 *a7, uint64_t a8, uint64_t a9, int16x8_t *a10)
{
  unint64_t v10 = 0;
  int16x4_t v12 = (int16x4_t)vld1_dup_f32(a3);
  int32x4_t v13 = vmovl_s16(v12);
  int16x4_t v14 = (int16x4_t)vld1_dup_f32(a6);
  int32x4_t v15 = vmovl_s16(v14);
  int32x4_t v16 = (int32x4_t)vdupq_n_s64(((*a7 + *a4) << a2) | ((unint64_t)((a7[1] + a4[1]) << a2) << 32));
  int32x4_t v17 = vdupq_n_s32(~a2);
  v18.i64[0] = 0x200000002000;
  v18.i64[1] = 0x200000002000;
  v19.i64[0] = 0xFC00FC00FC00FC00;
  v19.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int8x16_t v20 = (int16x4_t *)(a5 + 2 * v10);
    int v21 = result + 2;
    int8x16_t v22 = a10;
    int8x16_t v23 = (int16x4_t *)(a8 + 2 * v10);
    do
    {
      int16x8_t v24 = vminq_s16(vmaxq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmlaq_s32(vmlaq_s32(v16, vaddw_s16(v18, v20[8]), v13), vaddw_s16(v18, v23[8]), v15), v17)), vrshlq_s32(vmlaq_s32(vmlaq_s32(v16, vaddw_high_s16(v18, *(int16x8_t *)v20[8].i8), v13), vaddw_high_s16(v18, *(int16x8_t *)v23[8].i8), v15), v17)), (int16x8_t)0), v19);
      *int8x16_t v22 = vminq_s16(vmaxq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmlaq_s32(vmlaq_s32(v16, vaddw_s16(v18, *v20), v13), vaddw_s16(v18, *v23), v15), v17)), vrshlq_s32(vmlaq_s32(vmlaq_s32(v16, vaddw_high_s16(v18, *(int16x8_t *)v20->i8), v13), vaddw_high_s16(v18, *(int16x8_t *)v23->i8), v15), v17)), (int16x8_t)0), v19);
      *(int16x8_t *)((char *)v22 + 2 * a9) = v24;
      int8x16_t v22 = (int16x8_t *)((char *)v22 + 4 * a9);
      v21 -= 2;
      v20 += 16;
      v23 += 16;
    }
    while (v21 > 2);
    ++a10;
    BOOL v25 = v10 >= 0x18;
    v10 += 8;
  }
  while (!v25);
  return result;
}

uint64_t sub_1BBA2FE8C(uint64_t result, int a2, const float *a3, __int16 *a4, int8x16_t *a5, const float *a6, __int16 *a7, int8x16_t *a8, uint64_t a9, int8x16_t *a10)
{
  int32x4_t v10 = vdupq_n_s32(~a2);
  int32x4_t v11 = (int32x4_t)vdupq_n_s64(((*a7 + *a4) << a2) | ((unint64_t)((a7[1] + a4[1]) << a2) << 32));
  int16x4_t v13 = (int16x4_t)vld1_dup_f32(a3);
  int16x4_t v14 = (int16x4_t)vld1_dup_f32(a6);
  int v15 = result + 1;
  do
  {
    int8x16_t v16 = *a5;
    int8x16_t v17 = a5[1];
    a5 += 2;
    int8x16_t v18 = *a8;
    int8x16_t v19 = a8[1];
    a8 += 2;
    *a10 = vqmovun_high_s16(vqmovun_s16(vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v16.i8, v13), *(int16x4_t *)v18.i8, v14), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), v13), (int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), v14), v10))), vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, *(int16x4_t *)v17.i8, v13), *(int16x4_t *)v19.i8, v14), v10), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v11, (int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), v13), (int16x4_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL),
                              v14),
                            v10)));
    a10 = (int8x16_t *)((char *)a10 + a9);
    --v15;
  }
  while (v15 > 1);
  return result;
}

uint64_t sub_1BBA2FF4C(uint64_t result, int a2, const float *a3, __int16 *a4, uint64_t a5, const float *a6, __int16 *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10 = 0;
  int16x4_t v11 = (int16x4_t)vld1_dup_f32(a3);
  int32x4_t v12 = vmovl_s16(v11);
  int16x4_t v13 = (int16x4_t)vld1_dup_f32(a6);
  int32x4_t v14 = vmovl_s16(v13);
  int32x4_t v15 = (int32x4_t)vdupq_n_s64(((*a7 + *a4) << a2) | ((unint64_t)((a7[1] + a4[1]) << a2) << 32));
  int32x4_t v16 = vdupq_n_s32(~a2);
  char v17 = 1;
  v18.i64[0] = 0x200000002000;
  v18.i64[1] = 0x200000002000;
  v19.i64[0] = 0xFC00FC00FC00FC00;
  v19.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    char v20 = v17;
    int v21 = (int16x4_t *)(a5 + 2 * v10);
    int8x16_t v22 = (int16x4_t *)(a8 + 2 * v10);
    int v23 = result + 2;
    int16x8_t v24 = (int16x8_t *)(a10 + 2 * v10);
    do
    {
      int16x8_t v25 = vminq_s16(vmaxq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmlaq_s32(vmlaq_s32(v15, vaddw_s16(v18, v21[4]), v12), vaddw_s16(v18, v22[4]), v14), v16)), vrshlq_s32(vmlaq_s32(vmlaq_s32(v15, vaddw_high_s16(v18, *(int16x8_t *)v21[4].i8), v12), vaddw_high_s16(v18, *(int16x8_t *)v22[4].i8), v14), v16)), (int16x8_t)0), v19);
      *int16x8_t v24 = vminq_s16(vmaxq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmlaq_s32(vmlaq_s32(v15, vaddw_s16(v18, *v21), v12), vaddw_s16(v18, *v22), v14), v16)), vrshlq_s32(vmlaq_s32(vmlaq_s32(v15, vaddw_high_s16(v18, *(int16x8_t *)v21->i8), v12), vaddw_high_s16(v18, *(int16x8_t *)v22->i8), v14), v16)), (int16x8_t)0), v19);
      *(int16x8_t *)((char *)v24 + 2 * a9) = v25;
      int16x8_t v24 = (int16x8_t *)((char *)v24 + 4 * a9);
      v23 -= 2;
      v21 += 8;
      v22 += 8;
    }
    while (v23 > 2);
    char v17 = 0;
    uint64_t v10 = 8;
  }
  while ((v20 & 1) != 0);
  return result;
}

uint64_t sub_1BBA30084(uint64_t result, int a2, const float *a3, __int16 *a4, int8x16_t *a5, const float *a6, __int16 *a7, int8x16_t *a8, uint64_t a9, int8x8_t *a10)
{
  int32x4_t v11 = vdupq_n_s32(~a2);
  int32x4_t v12 = (int32x4_t)vdupq_n_s64(((*a7 + *a4) << a2) | ((unint64_t)((a7[1] + a4[1]) << a2) << 32));
  int16x4_t v13 = (int16x4_t)vld1_dup_f32(a3);
  int16x4_t v14 = (int16x4_t)vld1_dup_f32(a6);
  int v15 = result + 2;
  do
  {
    int8x16_t v16 = *a5;
    int8x16_t v17 = a5[1];
    a5 += 2;
    int8x16_t v18 = *a8;
    int8x16_t v19 = a8[1];
    a8 += 2;
    *a10 = vqmovun_s16(vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v12, *(int16x4_t *)v16.i8, v13), *(int16x4_t *)v18.i8, v14), v11), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v12, (int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), v13), (int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), v14), v11)));
    *(int8x8_t *)((char *)a10 + a9) = vqmovun_s16(vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v12, *(int16x4_t *)v17.i8, v13), *(int16x4_t *)v19.i8, v14), v11), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v12, (int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), v13), (int16x4_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), v14), v11)));
    a10 = (int8x8_t *)((char *)a10 + 2 * a9);
    v15 -= 2;
  }
  while (v15 > 2);
  return result;
}

uint64_t sub_1BBA3014C(uint64_t result, int a2, const float *a3, __int16 *a4, int16x8_t *a5, const float *a6, __int16 *a7, int16x8_t *a8, uint64_t a9, int16x8_t *a10)
{
  int16x4_t v11 = (int16x4_t)vld1_dup_f32(a3);
  int32x4_t v12 = vmovl_s16(v11);
  int16x4_t v13 = (int16x4_t)vld1_dup_f32(a6);
  int32x4_t v14 = vmovl_s16(v13);
  int32x4_t v15 = (int32x4_t)vdupq_n_s64(((*a7 + *a4) << a2) | ((unint64_t)((a7[1] + a4[1]) << a2) << 32));
  int32x4_t v16 = vdupq_n_s32(~a2);
  int v17 = result + 2;
  v18.i64[0] = 0x200000002000;
  v18.i64[1] = 0x200000002000;
  v19.i64[0] = 0xFC00FC00FC00FC00;
  v19.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v20 = *a5;
    int16x8_t v21 = a5[1];
    a5 += 2;
    int32x4_t v22 = vmlaq_s32(v15, vaddw_s16(v18, *(int16x4_t *)v20.i8), v12);
    int32x4_t v23 = vmlaq_s32(v15, vaddw_high_s16(v18, v20), v12);
    int16x8_t v24 = *a8;
    int16x8_t v25 = a8[1];
    a8 += 2;
    *a10 = vminq_s16(vmaxq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmlaq_s32(v22, vaddw_s16(v18, *(int16x4_t *)v24.i8), v14), v16)), vrshlq_s32(vmlaq_s32(v23, vaddw_high_s16(v18, v24), v14), v16)), (int16x8_t)0), v19);
    *(int16x8_t *)((char *)a10 + 2 * a9) = vminq_s16(vmaxq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmlaq_s32(vmlaq_s32(v15, vaddw_s16(v18, *(int16x4_t *)v21.i8), v12), vaddw_s16(v18, *(int16x4_t *)v25.i8), v14), v16)), vrshlq_s32(vmlaq_s32(vmlaq_s32(v15, vaddw_high_s16(v18, v21), v12), vaddw_high_s16(v18, v25), v14), v16)), (int16x8_t)0), v19);
    a10 = (int16x8_t *)((char *)a10 + 4 * a9);
    v17 -= 2;
  }
  while (v17 > 2);
  return result;
}

uint64_t sub_1BBA3024C(uint64_t result, int a2, const float *a3, __int16 *a4, int8x16_t *a5, const float *a6, __int16 *a7, int8x16_t *a8, uint64_t a9, _DWORD *a10)
{
  int16x4_t v10 = (int16x4_t)vld1_dup_f32(a3);
  int16x4_t v11 = (int16x4_t)vld1_dup_f32(a6);
  int32x4_t v12 = (int32x4_t)vdupq_n_s64(((*a7 + *a4) << a2) | ((unint64_t)((a7[1] + a4[1]) << a2) << 32));
  int32x4_t v14 = vdupq_n_s32(~a2);
  int v15 = result + 2;
  do
  {
    int8x16_t v16 = *a5++;
    int8x16_t v17 = v16;
    int8x16_t v18 = *a8++;
    *(int8x8_t *)v17.i8 = vqmovun_s16(vuzp1q_s16((int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v12, *(int16x4_t *)v17.i8, v10), *(int16x4_t *)v18.i8, v11), v14), (int16x8_t)vrshlq_s32(vmlal_s16(vmlal_s16(v12, (int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), v10), (int16x4_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL), v11), v14)));
    *a10 = v17.i32[0];
    *(_DWORD *)((char *)a10 + a9) = v17.i32[1];
    a10 = (_DWORD *)((char *)a10 + 2 * a9);
    v15 -= 2;
  }
  while (v15 > 2);
  return result;
}

uint64_t sub_1BBA302E8(uint64_t result, int a2, const float *a3, __int16 *a4, int16x8_t *a5, const float *a6, __int16 *a7, int16x8_t *a8, uint64_t a9, void *a10)
{
  int16x4_t v11 = (int16x4_t)vld1_dup_f32(a3);
  int32x4_t v12 = vmovl_s16(v11);
  int16x4_t v13 = (int16x4_t)vld1_dup_f32(a6);
  int32x4_t v14 = vmovl_s16(v13);
  int32x4_t v15 = (int32x4_t)vdupq_n_s64(((*a7 + *a4) << a2) | ((unint64_t)((a7[1] + a4[1]) << a2) << 32));
  int32x4_t v16 = vdupq_n_s32(~a2);
  int v17 = result + 2;
  v18.i64[0] = 0x200000002000;
  v18.i64[1] = 0x200000002000;
  v19.i64[0] = 0xFC00FC00FC00FC00;
  v19.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v20 = *a5++;
    int16x8_t v21 = v20;
    int16x8_t v22 = *a8++;
    int16x8_t v23 = vminq_s16(vmaxq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmlaq_s32(vmlaq_s32(v15, vaddw_s16(v18, *(int16x4_t *)v21.i8), v12), vaddw_s16(v18, *(int16x4_t *)v22.i8), v14), v16)), vrshlq_s32(vmlaq_s32(vmlaq_s32(v15, vaddw_high_s16(v18, v21), v12), vaddw_high_s16(v18, v22), v14), v16)), (int16x8_t)0), v19);
    *a10 = v23.i64[0];
    *(void *)((char *)a10 + 2 * a9) = v23.i64[1];
    a10 = (void *)((char *)a10 + 4 * a9);
    v17 -= 2;
  }
  while (v17 > 2);
  return result;
}

uint64_t sub_1BBA303AC(uint64_t result, int a2, const float *a3, const float *a4, uint64_t a5, uint64_t a6, int8x16_t *a7)
{
  int16x4_t v7 = (int16x4_t)vld1_dup_f32(a4);
  int32x4_t v8 = vdupq_n_s32(-a2);
  int16x4_t v9 = (int16x4_t)vld1_dup_f32(a3);
  int16x4_t v10 = a7 + 2;
  int v11 = result + 1;
  do
  {
    int8x16_t v12 = *(int8x16_t *)(a5 + 16);
    *(int16x4_t *)v13.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)a5, v9), v8)));
    v13.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a5, *(int8x16_t *)a5, 8uLL), v9), v8)));
    int8x8_t v14 = vqmovun_s16(v13);
    *(int16x4_t *)v13.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v12.i8, v9), v8)));
    v13.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL), v9), v8)));
    int8x16_t v15 = vqmovun_high_s16(v14, v13);
    int8x16_t v16 = *(int8x16_t *)(a5 + 32);
    int8x16_t v17 = *(int8x16_t *)(a5 + 48);
    *(int16x4_t *)v18.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v16.i8, v9), v8)));
    v18.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), v9), v8)));
    *(int8x8_t *)v16.i8 = vqmovun_s16(v18);
    *(int16x4_t *)v18.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v17.i8, v9), v8)));
    v18.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), v9), v8)));
    int8x16_t v19 = vqmovun_high_s16(*(int8x8_t *)v16.i8, v18);
    int16x8_t v20 = *(int16x8_t *)(a5 + 64);
    int8x16_t v21 = *(int8x16_t *)(a5 + 80);
    *(int16x4_t *)v22.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v20.i8, v9), v8)));
    v22.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL), v9), v8)));
    *(int16x4_t *)v20.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v21.i8, v9), v8)));
    v20.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL), v9), v8)));
    int8x16_t v23 = vqmovun_high_s16(vqmovun_s16(v22), v20);
    int8x16_t v24 = *(int8x16_t *)(a5 + 96);
    int8x16_t v25 = *(int8x16_t *)(a5 + 112);
    *(int16x4_t *)v26.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v24.i8, v9), v8)));
    v26.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL), v9), v8)));
    *(int8x8_t *)v24.i8 = vqmovun_s16(v26);
    *(int16x4_t *)v26.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v25.i8, v9), v8)));
    v26.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), v9), v8)));
    v10[-2] = v15;
    v10[-1] = v19;
    int8x16_t *v10 = v23;
    v10[1] = vqmovun_high_s16(*(int8x8_t *)v24.i8, v26);
    int16x4_t v10 = (int8x16_t *)((char *)v10 + a6);
    --v11;
    a5 += 128;
  }
  while (v11 > 1);
  return result;
}

uint64_t sub_1BBA30554(uint64_t result, int a2, const float *a3, const float *a4, uint64_t a5, uint64_t a6, int16x8_t *a7)
{
  unint64_t v7 = 0;
  int16x4_t v8 = (int16x4_t)vld1_dup_f32(a3);
  int32x4_t v9 = vmovl_s16(v8);
  int16x8_t v10 = (int16x8_t)vld1q_dup_f32(a4);
  int32x4_t v11 = vdupq_n_s32(-a2);
  v12.i64[0] = 0x200000002000;
  v12.i64[1] = 0x200000002000;
  v13.i64[0] = 0xFC00FC00FC00FC00;
  v13.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int8x8_t v14 = (int16x4_t *)(a5 + 2 * v7);
    int v15 = result + 2;
    int8x16_t v16 = a7;
    do
    {
      int16x8_t v17 = vminq_s16(vmaxq_s16(vaddq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmulq_s32(vaddw_s16(v12, v14[16]), v9), v11)), vrshlq_s32(vmulq_s32(vaddw_high_s16(v12, *(int16x8_t *)v14[16].i8), v9), v11)), v10), (int16x8_t)0), v13);
      int16x8_t *v16 = vminq_s16(vmaxq_s16(vaddq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmulq_s32(vaddw_s16(v12, *v14), v9), v11)), vrshlq_s32(vmulq_s32(vaddw_high_s16(v12, *(int16x8_t *)v14->i8), v9), v11)), v10), (int16x8_t)0), v13);
      *(int16x8_t *)((char *)v16 + 2 * a6) = v17;
      int8x16_t v16 = (int16x8_t *)((char *)v16 + 4 * a6);
      v15 -= 2;
      v14 += 32;
    }
    while (v15 > 2);
    ++a7;
    BOOL v18 = v7 >= 0x38;
    v7 += 8;
  }
  while (!v18);
  return result;
}

uint64_t sub_1BBA30624(uint64_t result, int a2, const float *a3, const float *a4, uint64_t a5, uint64_t a6, int8x16_t *a7)
{
  int16x4_t v7 = (int16x4_t)vld1_dup_f32(a4);
  int32x4_t v8 = vdupq_n_s32(-a2);
  int16x4_t v9 = (int16x4_t)vld1_dup_f32(a3);
  int16x8_t v10 = a7 + 1;
  int v11 = result + 1;
  do
  {
    int8x16_t v12 = *(int8x16_t *)(a5 + 16);
    *(int16x4_t *)v13.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)a5, v9), v8)));
    v13.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a5, *(int8x16_t *)a5, 8uLL), v9), v8)));
    int8x8_t v14 = vqmovun_s16(v13);
    *(int16x4_t *)v13.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v12.i8, v9), v8)));
    v13.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL), v9), v8)));
    int8x16_t v15 = vqmovun_high_s16(v14, v13);
    int8x16_t v16 = *(int8x16_t *)(a5 + 32);
    int8x16_t v17 = *(int8x16_t *)(a5 + 48);
    *(int16x4_t *)v18.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v16.i8, v9), v8)));
    v18.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), v9), v8)));
    *(int8x8_t *)v16.i8 = vqmovun_s16(v18);
    *(int16x4_t *)v18.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v17.i8, v9), v8)));
    v18.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL), v9), v8)));
    v10[-1] = v15;
    int8x16_t *v10 = vqmovun_high_s16(*(int8x8_t *)v16.i8, v18);
    int16x8_t v10 = (int8x16_t *)((char *)v10 + a6);
    --v11;
    a5 += 64;
  }
  while (v11 > 1);
  return result;
}

uint64_t sub_1BBA30710(uint64_t result, int a2, const float *a3, const float *a4, uint64_t a5, uint64_t a6, int16x8_t *a7)
{
  unint64_t v7 = 0;
  int16x4_t v8 = (int16x4_t)vld1_dup_f32(a3);
  int32x4_t v9 = vmovl_s16(v8);
  int16x8_t v10 = (int16x8_t)vld1q_dup_f32(a4);
  int32x4_t v11 = vdupq_n_s32(-a2);
  v12.i64[0] = 0x200000002000;
  v12.i64[1] = 0x200000002000;
  v13.i64[0] = 0xFC00FC00FC00FC00;
  v13.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int8x8_t v14 = (int16x4_t *)(a5 + 2 * v7);
    int v15 = result + 2;
    int8x16_t v16 = a7;
    do
    {
      int16x8_t v17 = vminq_s16(vmaxq_s16(vaddq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmulq_s32(vaddw_s16(v12, v14[8]), v9), v11)), vrshlq_s32(vmulq_s32(vaddw_high_s16(v12, *(int16x8_t *)v14[8].i8), v9), v11)), v10), (int16x8_t)0), v13);
      int16x8_t *v16 = vminq_s16(vmaxq_s16(vaddq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmulq_s32(vaddw_s16(v12, *v14), v9), v11)), vrshlq_s32(vmulq_s32(vaddw_high_s16(v12, *(int16x8_t *)v14->i8), v9), v11)), v10), (int16x8_t)0), v13);
      *(int16x8_t *)((char *)v16 + 2 * a6) = v17;
      int8x16_t v16 = (int16x8_t *)((char *)v16 + 4 * a6);
      v15 -= 2;
      v14 += 16;
    }
    while (v15 > 2);
    ++a7;
    BOOL v18 = v7 >= 0x18;
    v7 += 8;
  }
  while (!v18);
  return result;
}

uint64_t sub_1BBA307E0(uint64_t result, int a2, const float *a3, const float *a4, int8x16_t *a5, uint64_t a6, int8x16_t *a7)
{
  int16x4_t v7 = (int16x4_t)vld1_dup_f32(a4);
  int32x4_t v8 = vdupq_n_s32(-a2);
  int16x4_t v9 = (int16x4_t)vld1_dup_f32(a3);
  int v10 = result + 1;
  do
  {
    int8x16_t v11 = *a5;
    int8x16_t v12 = a5[1];
    a5 += 2;
    *(int16x4_t *)v13.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v11.i8, v9), v8)));
    v13.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL), v9), v8)));
    *(int8x8_t *)v11.i8 = vqmovun_s16(v13);
    *(int16x4_t *)v13.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v12.i8, v9), v8)));
    v13.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL), v9), v8)));
    *a7 = vqmovun_high_s16(*(int8x8_t *)v11.i8, v13);
    a7 = (int8x16_t *)((char *)a7 + a6);
    --v10;
  }
  while (v10 > 1);
  return result;
}

uint64_t sub_1BBA30868(uint64_t result, int a2, const float *a3, const float *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = 0;
  int16x4_t v8 = (int16x4_t)vld1_dup_f32(a3);
  int32x4_t v9 = vmovl_s16(v8);
  int16x8_t v10 = (int16x8_t)vld1q_dup_f32(a4);
  int32x4_t v11 = vdupq_n_s32(-a2);
  char v12 = 1;
  v13.i64[0] = 0x200000002000;
  v13.i64[1] = 0x200000002000;
  v14.i64[0] = 0xFC00FC00FC00FC00;
  v14.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    char v15 = v12;
    int8x16_t v16 = (int16x4_t *)(a5 + 2 * v7);
    int v17 = result + 2;
    BOOL v18 = (int16x8_t *)(a7 + 2 * v7);
    do
    {
      int16x8_t v19 = vminq_s16(vmaxq_s16(vaddq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmulq_s32(vaddw_s16(v13, v16[4]), v9), v11)), vrshlq_s32(vmulq_s32(vaddw_high_s16(v13, *(int16x8_t *)v16[4].i8), v9), v11)), v10), (int16x8_t)0), v14);
      *BOOL v18 = vminq_s16(vmaxq_s16(vaddq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmulq_s32(vaddw_s16(v13, *v16), v9), v11)), vrshlq_s32(vmulq_s32(vaddw_high_s16(v13, *(int16x8_t *)v16->i8), v9), v11)), v10), (int16x8_t)0), v14);
      *(int16x8_t *)((char *)v18 + 2 * a6) = v19;
      BOOL v18 = (int16x8_t *)((char *)v18 + 4 * a6);
      v17 -= 2;
      v16 += 8;
    }
    while (v17 > 2);
    char v12 = 0;
    uint64_t v7 = 8;
  }
  while ((v15 & 1) != 0);
  return result;
}

uint64_t sub_1BBA30938(uint64_t result, int a2, const float *a3, const float *a4, int8x16_t *a5, uint64_t a6, void *a7)
{
  int16x4_t v7 = (int16x4_t)vld1_dup_f32(a4);
  int32x4_t v8 = vdupq_n_s32(-a2);
  int16x4_t v9 = (int16x4_t)vld1_dup_f32(a3);
  int v10 = result + 2;
  do
  {
    int8x16_t v11 = *a5;
    int8x16_t v12 = a5[1];
    a5 += 2;
    *(int16x4_t *)v13.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v11.i8, v9), v8)));
    v13.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL), v9), v8)));
    *(int8x8_t *)v11.i8 = vqmovun_s16(v13);
    *(int16x4_t *)v13.i8 = vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v12.i8, v9), v8)));
    v13.u64[1] = (unint64_t)vadd_s16(v7, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL), v9), v8)));
    *a7 = v11.i64[0];
    *(int8x8_t *)((char *)a7 + a6) = vqmovun_s16(v13);
    a7 = (void *)((char *)a7 + 2 * a6);
    v10 -= 2;
  }
  while (v10 > 2);
  return result;
}

uint64_t sub_1BBA309C8(uint64_t result, int a2, const float *a3, const float *a4, int16x8_t *a5, uint64_t a6, int16x8_t *a7)
{
  int16x4_t v7 = (int16x4_t)vld1_dup_f32(a3);
  int32x4_t v8 = vmovl_s16(v7);
  int16x8_t v9 = (int16x8_t)vld1q_dup_f32(a4);
  int32x4_t v10 = vdupq_n_s32(-a2);
  int v11 = result + 2;
  v12.i64[0] = 0x200000002000;
  v12.i64[1] = 0x200000002000;
  v13.i64[0] = 0xFC00FC00FC00FC00;
  v13.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v14 = *a5;
    int16x8_t v15 = a5[1];
    a5 += 2;
    *a7 = vminq_s16(vmaxq_s16(vaddq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmulq_s32(vaddw_s16(v12, *(int16x4_t *)v14.i8), v8), v10)), vrshlq_s32(vmulq_s32(vaddw_high_s16(v12, v14), v8), v10)), v9), (int16x8_t)0), v13);
    *(int16x8_t *)((char *)a7 + 2 * a6) = vminq_s16(vmaxq_s16(vaddq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmulq_s32(vaddw_s16(v12, *(int16x4_t *)v15.i8), v8), v10)), vrshlq_s32(vmulq_s32(vaddw_high_s16(v12, v15), v8), v10)), v9), (int16x8_t)0), v13);
    a7 = (int16x8_t *)((char *)a7 + 4 * a6);
    v11 -= 2;
  }
  while (v11 > 2);
  return result;
}

uint64_t sub_1BBA30A6C(uint64_t result, int a2, const float *a3, const float *a4, int8x16_t *a5, uint64_t a6, _DWORD *a7)
{
  int16x4_t v7 = (int16x4_t)vld1_dup_f32(a3);
  int16x4_t v8 = (int16x4_t)vld1_dup_f32(a4);
  int32x4_t v9 = vdupq_n_s32(-a2);
  int v10 = result + 2;
  do
  {
    int8x16_t v11 = *a5++;
    *(int16x4_t *)v12.i8 = vadd_s16(v8, vmovn_s32(vrshlq_s32(vmull_s16(*(int16x4_t *)v11.i8, v7), v9)));
    v12.u64[1] = (unint64_t)vadd_s16(v8, vmovn_s32(vrshlq_s32(vmull_s16((int16x4_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL), v7), v9)));
    int8x8_t v13 = vqmovun_s16(v12);
    *a7 = v13.i32[0];
    *(_DWORD *)((char *)a7 + a6) = v13.i32[1];
    a7 = (_DWORD *)((char *)a7 + 2 * a6);
    v10 -= 2;
  }
  while (v10 > 2);
  return result;
}

uint64_t sub_1BBA30AD4(uint64_t result, int a2, const float *a3, const float *a4, int16x8_t *a5, uint64_t a6, void *a7)
{
  int16x4_t v7 = (int16x4_t)vld1_dup_f32(a3);
  int32x4_t v8 = vmovl_s16(v7);
  int16x8_t v9 = (int16x8_t)vld1q_dup_f32(a4);
  int32x4_t v10 = vdupq_n_s32(-a2);
  int v11 = result + 2;
  v12.i64[0] = 0x200000002000;
  v12.i64[1] = 0x200000002000;
  v13.i64[0] = 0xFC00FC00FC00FC00;
  v13.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v14 = *a5++;
    int16x8_t v15 = vminq_s16(vmaxq_s16(vaddq_s16(vqmovn_high_s32(vqmovn_s32(vrshlq_s32(vmulq_s32(vaddw_s16(v12, *(int16x4_t *)v14.i8), v8), v10)), vrshlq_s32(vmulq_s32(vaddw_high_s16(v12, v14), v8), v10)), v9), (int16x8_t)0), v13);
    *a7 = v15.i64[0];
    *(void *)((char *)a7 + 2 * a6) = v15.i64[1];
    a7 = (void *)((char *)a7 + 4 * a6);
    v11 -= 2;
  }
  while (v11 > 2);
  return result;
}

int8x16_t sub_1BBA30B50(int a1, int16x8_t *a2, int16x8_t *a3, uint64_t a4, int8x16_t *a5)
{
  uint64_t v5 = a5 + 2;
  int v6 = a1 + 1;
  do
  {
    int8x16_t v7 = vqrshrun_high_n_s16(vqrshrun_n_s16(vhaddq_s16(a2[2], a3[2]), 6uLL), vhaddq_s16(a2[3], a3[3]), 6uLL);
    v5[-2] = vqrshrun_high_n_s16(vqrshrun_n_s16(vhaddq_s16(*a2, *a3), 6uLL), vhaddq_s16(a2[1], a3[1]), 6uLL);
    v5[-1] = v7;
    int8x16_t result = vqrshrun_high_n_s16(vqrshrun_n_s16(vhaddq_s16(a2[4], a3[4]), 6uLL), vhaddq_s16(a2[5], a3[5]), 6uLL);
    int8x16_t v9 = vqrshrun_high_n_s16(vqrshrun_n_s16(vhaddq_s16(a2[6], a3[6]), 6uLL), vhaddq_s16(a2[7], a3[7]), 6uLL);
    *uint64_t v5 = result;
    v5[1] = v9;
    uint64_t v5 = (int8x16_t *)((char *)v5 + a4);
    --v6;
    a2 += 8;
    a3 += 8;
  }
  while (v6 > 1);
  return result;
}

uint64_t sub_1BBA30BDC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int16x8_t *a5)
{
  unint64_t v5 = 0;
  v6.i64[0] = 0x2000200020002000;
  v6.i64[1] = 0x2000200020002000;
  v7.i64[0] = 0xFC00FC00FC00FC00;
  v7.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int32x4_t v8 = (int16x8_t *)(a2 + 2 * v5);
    int v9 = result + 2;
    int32x4_t v10 = a5;
    int v11 = (int16x8_t *)(a3 + 2 * v5);
    do
    {
      int16x8_t v12 = vminq_s16(vmaxq_s16(vrshrq_n_s16(vhaddq_s16(vhaddq_s16(v8[8], v11[8]), v6), 3uLL), (int16x8_t)0), v7);
      int16x8_t *v10 = vminq_s16(vmaxq_s16(vrshrq_n_s16(vhaddq_s16(vhaddq_s16(*v8, *v11), v6), 3uLL), (int16x8_t)0), v7);
      *(int16x8_t *)((char *)v10 + 2 * a4) = v12;
      int32x4_t v10 = (int16x8_t *)((char *)v10 + 4 * a4);
      v9 -= 2;
      v8 += 16;
      v11 += 16;
    }
    while (v9 > 2);
    ++a5;
    BOOL v13 = v5 >= 0x38;
    v5 += 8;
  }
  while (!v13);
  return result;
}

int8x16_t sub_1BBA30C78(int a1, int16x8_t *a2, int16x8_t *a3, uint64_t a4, int8x16_t *a5)
{
  unint64_t v5 = a5 + 1;
  int v6 = a1 + 1;
  do
  {
    int8x16_t result = vqrshrun_high_n_s16(vqrshrun_n_s16(vhaddq_s16(*a2, *a3), 6uLL), vhaddq_s16(a2[1], a3[1]), 6uLL);
    int8x16_t v8 = vqrshrun_high_n_s16(vqrshrun_n_s16(vhaddq_s16(a2[2], a3[2]), 6uLL), vhaddq_s16(a2[3], a3[3]), 6uLL);
    v5[-1] = result;
    *unint64_t v5 = v8;
    unint64_t v5 = (int8x16_t *)((char *)v5 + a4);
    --v6;
    a2 += 4;
    a3 += 4;
  }
  while (v6 > 1);
  return result;
}

uint64_t sub_1BBA30CD0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int16x8_t *a5)
{
  unint64_t v5 = 0;
  v6.i64[0] = 0x2000200020002000;
  v6.i64[1] = 0x2000200020002000;
  v7.i64[0] = 0xFC00FC00FC00FC00;
  v7.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int8x16_t v8 = (int16x8_t *)(a2 + 2 * v5);
    int v9 = result + 2;
    int32x4_t v10 = a5;
    int v11 = (int16x8_t *)(a3 + 2 * v5);
    do
    {
      int16x8_t v12 = vminq_s16(vmaxq_s16(vrshrq_n_s16(vhaddq_s16(vhaddq_s16(v8[4], v11[4]), v6), 3uLL), (int16x8_t)0), v7);
      int16x8_t *v10 = vminq_s16(vmaxq_s16(vrshrq_n_s16(vhaddq_s16(vhaddq_s16(*v8, *v11), v6), 3uLL), (int16x8_t)0), v7);
      *(int16x8_t *)((char *)v10 + 2 * a4) = v12;
      int32x4_t v10 = (int16x8_t *)((char *)v10 + 4 * a4);
      v9 -= 2;
      v8 += 8;
      v11 += 8;
    }
    while (v9 > 2);
    ++a5;
    BOOL v13 = v5 >= 0x18;
    v5 += 8;
  }
  while (!v13);
  return result;
}

int8x16_t sub_1BBA30D6C(int a1, int16x8_t *a2, int16x8_t *a3, uint64_t a4, int8x16_t *a5)
{
  int v5 = a1 + 2;
  do
  {
    int16x8_t v6 = vhaddq_s16(a2[3], a3[3]);
    int8x8_t v7 = vqrshrun_n_s16(vhaddq_s16(a2[2], a3[2]), 6uLL);
    int8x16_t result = vqrshrun_high_n_s16(vqrshrun_n_s16(vhaddq_s16(*a2, *a3), 6uLL), vhaddq_s16(a2[1], a3[1]), 6uLL);
    *a5 = result;
    *(int8x16_t *)((char *)a5 + a4) = vqrshrun_high_n_s16(v7, v6, 6uLL);
    a5 = (int8x16_t *)((char *)a5 + 2 * a4);
    v5 -= 2;
    a2 += 4;
    a3 += 4;
  }
  while (v5 > 2);
  return result;
}

uint64_t sub_1BBA30DC8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 0;
  v6.i64[0] = 0x2000200020002000;
  v6.i64[1] = 0x2000200020002000;
  v7.i64[0] = 0xFC00FC00FC00FC00;
  v7.i64[1] = 0xFC00FC00FC00FC00;
  char v8 = 1;
  do
  {
    char v9 = v8;
    int32x4_t v10 = (int16x8_t *)(a2 + 2 * v5);
    int v11 = (int16x8_t *)(a3 + 2 * v5);
    int v12 = result + 2;
    BOOL v13 = (int16x8_t *)(a5 + 2 * v5);
    do
    {
      int16x8_t v14 = vminq_s16(vmaxq_s16(vrshrq_n_s16(vhaddq_s16(vhaddq_s16(v10[2], v11[2]), v6), 3uLL), (int16x8_t)0), v7);
      *BOOL v13 = vminq_s16(vmaxq_s16(vrshrq_n_s16(vhaddq_s16(vhaddq_s16(*v10, *v11), v6), 3uLL), (int16x8_t)0), v7);
      *(int16x8_t *)((char *)v13 + 2 * a4) = v14;
      BOOL v13 = (int16x8_t *)((char *)v13 + 4 * a4);
      v12 -= 2;
      v10 += 4;
      v11 += 4;
    }
    while (v12 > 2);
    char v8 = 0;
    uint64_t v5 = 8;
  }
  while ((v9 & 1) != 0);
  return result;
}

int8x8_t sub_1BBA30E64(int a1, int16x8_t *a2, int16x8_t *a3, uint64_t a4, int8x8_t *a5)
{
  int v5 = a1 + 4;
  do
  {
    int16x8_t v6 = vhaddq_s16(a2[3], a3[3]);
    int8x8_t v7 = vqrshrun_n_s16(vhaddq_s16(a2[1], a3[1]), 6uLL);
    int8x8_t v8 = vqrshrun_n_s16(vhaddq_s16(a2[2], a3[2]), 6uLL);
    *a5 = vqrshrun_n_s16(vhaddq_s16(*a2, *a3), 6uLL);
    *(int8x8_t *)((char *)a5 + a4) = v7;
    char v9 = (int8x8_t *)((char *)a5 + a4 + a4);
    int8x8_t *v9 = v8;
    int32x4_t v10 = (int8x8_t *)((char *)v9 + a4);
    v5 -= 4;
    int8x8_t result = vqrshrun_n_s16(v6, 6uLL);
    int8x8_t *v10 = result;
    a2 += 4;
    a3 += 4;
    a5 = (int8x8_t *)((char *)v10 + a4);
  }
  while (v5 > 4);
  return result;
}

uint64_t sub_1BBA30ED0(uint64_t result, int16x8_t *a2, int16x8_t *a3, uint64_t a4, int16x8_t *a5)
{
  int v5 = result + 2;
  v6.i64[0] = 0x2000200020002000;
  v6.i64[1] = 0x2000200020002000;
  v7.i64[0] = 0xFC00FC00FC00FC00;
  v7.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v8 = *a2;
    int16x8_t v9 = a2[1];
    a2 += 2;
    int16x8_t v10 = *a3;
    int16x8_t v11 = a3[1];
    a3 += 2;
    *a5 = vminq_s16(vmaxq_s16(vrshrq_n_s16(vhaddq_s16(vhaddq_s16(v8, v10), v6), 3uLL), (int16x8_t)0), v7);
    *(int16x8_t *)((char *)a5 + 2 * a4) = vminq_s16(vmaxq_s16(vrshrq_n_s16(vhaddq_s16(vhaddq_s16(v9, v11), v6), 3uLL), (int16x8_t)0), v7);
    a5 = (int16x8_t *)((char *)a5 + 4 * a4);
    v5 -= 2;
  }
  while (v5 > 2);
  return result;
}

int8x8_t sub_1BBA30F34(int a1, int16x8_t *a2, int16x8_t *a3, uint64_t a4, _DWORD *a5)
{
  int v5 = a1 + 2;
  do
  {
    int16x8_t v6 = *a2++;
    int16x8_t v7 = v6;
    int16x8_t v8 = *a3++;
    int8x8_t result = vqrshrun_n_s16(vhaddq_s16(v7, v8), 6uLL);
    *a5 = result.i32[0];
    *(_DWORD *)((char *)a5 + a4) = result.i32[1];
    a5 = (_DWORD *)((char *)a5 + 2 * a4);
    v5 -= 2;
  }
  while (v5 > 2);
  return result;
}

uint64_t sub_1BBA30F6C(uint64_t result, int16x8_t *a2, int16x8_t *a3, uint64_t a4, void *a5)
{
  int v5 = result + 2;
  v6.i64[0] = 0x2000200020002000;
  v6.i64[1] = 0x2000200020002000;
  v7.i64[0] = 0xFC00FC00FC00FC00;
  v7.i64[1] = 0xFC00FC00FC00FC00;
  do
  {
    int16x8_t v8 = *a2++;
    int16x8_t v9 = v8;
    int16x8_t v10 = *a3++;
    int16x8_t v11 = vminq_s16(vmaxq_s16(vrshrq_n_s16(vhaddq_s16(vhaddq_s16(v9, v10), v6), 3uLL), (int16x8_t)0), v7);
    *a5 = v11.i64[0];
    *(void *)((char *)a5 + 2 * a4) = v11.i64[1];
    a5 = (void *)((char *)a5 + 4 * a4);
    v5 -= 2;
  }
  while (v5 > 2);
  return result;
}

uint64_t sub_1BBA30FC0(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, int16x8_t *a6)
{
  unint64_t v11 = a2;
  sub_1BBA31034(a1, a2, a3, a4, a5, a6);

  return sub_1BBA31034(a1, v11, a3, a4 + 32, a5, a6 + 4);
}

uint64_t sub_1BBA31034(uint64_t result, unint64_t a2, uint64_t a3, uint64_t _X3, uint64_t a5, int16x8_t *a6)
{
  int8x8_t v6 = (int8x8_t)qword_1BBB78B30[((a2 >> 16) & 7) - 1];
  _X8 = _X3 - a3;
  uint8x16_t v8 = *(uint8x16_t *)(_X3 - a3 - 2);
  uint8x16_t v9 = *(uint8x16_t *)(_X3 - a3 + 14);
  __asm
  {
    PRFUM           #0, [X8,#0x3D]
    PRFUM           #0, [X8,#0x7E]
    PRFUM           #0, [X8,#0x9D]
  }
  _X8 = (uint8x8_t *)(_X3 - a3 + 30);
  uint8x8_t v18 = *_X8;
  int16x4_t v19 = (int16x4_t)vmovl_u8(qword_1BBB78B30[(a2 & 7) - 1]).u64[0];
  __asm { PRFUM           #0, [X8,#0xF] }
  _X8 = (char *)&_X8[-16] + 4 * a3;
  __asm
  {
    PRFM            #0, [X8]
    PRFUM           #0, [X8,#7]
  }
  uint8x16_t v24 = *(uint8x16_t *)(_X3 - 2);
  uint8x16_t v25 = *(uint8x16_t *)(_X3 + 14);
  __asm
  {
    PRFUM           #0, [X3,#0x3D]
    PRFUM           #0, [X3,#0x7E]
    PRFUM           #0, [X3,#0x9D]
  }
  _X8 = _X3 + 30;
  uint8x8_t v30 = *(uint8x8_t *)(_X3 + 30);
  __asm { PRFUM           #0, [X8,#0xF] }
  _X10 = _X3 + 30 + 4 * (a3 - 32);
  __asm
  {
    PRFM            #0, [X10]
    PRFUM           #0, [X10,#7]
  }
  _X10 = (uint8x16_t *)(_X3 + 30 + a3 - 32);
  uint8x16_t v36 = *_X10;
  uint8x16_t v37 = _X10[1];
  __asm
  {
    PRFUM           #0, [X10,#0x3F]
    PRFM            #0, [X10,#0x80]
    PRFUM           #0, [X10,#0x9F]
  }
  _X8 = (void *)(_X3 + 30 + a3);
  _X9 = (char *)_X8 + 4 * a3 - 128;
  uint8x8_t v43 = *(uint8x8_t *)_X8;
  _X8 = (void *)((char *)_X8 + 15);
  uint8x8_t v44 = v43;
  __asm
  {
    PRFM            #0, [X8]
    PRFM            #0, [X9]
    PRFUM           #0, [X9,#7]
  }
  int v48 = result + 1;
  uint64_t v49 = 2 * a3;
  uint64_t v50 = a6 + 2;
  uint8x16_t v51 = (uint8x16_t)vdupq_lane_s8(v6, 0);
  uint8x16_t v52 = (uint8x16_t)vdupq_lane_s8(v6, 1);
  uint8x16_t v53 = (uint8x16_t)vdupq_lane_s8(v6, 2);
  uint8x16_t v54 = (uint8x16_t)vdupq_lane_s8(v6, 3);
  do
  {
    uint8x16_t v55 = v25;
    uint8x16_t v56 = v24;
    uint8x16_t v25 = v37;
    uint8x16_t v24 = v36;
    uint8x8_t v57 = v30;
    uint8x8_t v30 = v44;
    _X13 = _X3 + v49;
    uint8x16_t v36 = *(uint8x16_t *)(_X3 + v49 - 2);
    uint8x16_t v37 = *(uint8x16_t *)(_X3 + v49 + 14);
    __asm
    {
      PRFUM           #0, [X13,#0x3D]
      PRFUM           #0, [X13,#0x7E]
      PRFUM           #0, [X13,#0x9D]
    }
    uint8x8_t v44 = *(uint8x8_t *)(_X3 + v49 + 30);
    __asm { PRFUM           #0, [X13,#0x2D] }
    _X13 = _X3 + 6 * a3 - 98;
    __asm
    {
      PRFM            #0, [X13]
      PRFUM           #0, [X13,#7]
    }
    int16x8_t v66 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8(*(uint8x8_t *)v56.i8, *(uint8x8_t *)v52.i8), *(uint8x8_t *)v24.i8, *(uint8x8_t *)v53.i8), *(uint8x8_t *)v8.i8, *(uint8x8_t *)v51.i8), *(uint8x8_t *)v36.i8, *(uint8x8_t *)v54.i8);
    int16x8_t v67 = (int16x8_t)vmlsl_high_u8(vmlsl_high_u8(vmlal_high_u8(vmull_high_u8(v56, v52), v24, v53), v8, v51), v36, v54);
    int16x8_t v68 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8(*(uint8x8_t *)v55.i8, *(uint8x8_t *)v52.i8), *(uint8x8_t *)v25.i8, *(uint8x8_t *)v53.i8), *(uint8x8_t *)v9.i8, *(uint8x8_t *)v51.i8), *(uint8x8_t *)v37.i8, *(uint8x8_t *)v54.i8);
    int16x4_t v69 = (int16x4_t)vextq_s8((int8x16_t)v66, (int8x16_t)v67, 0xCuLL).u64[0];
    int16x4_t v70 = (int16x4_t)vextq_s8((int8x16_t)v67, (int8x16_t)v67, 4uLL).u64[0];
    int32x4_t v71 = vmlsl_lane_s16(vmlsl_lane_s16(vmlal_high_lane_s16(vmull_lane_s16((int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v66, (int8x16_t)v66, 4uLL), v19, 1), v66, v19, 2), *(int16x4_t *)v66.i8, v19, 0), v69, v19, 3);
    int32x4_t v72 = vmlsl_high_lane_s16(vmlal_lane_s16(vmull_lane_s16(v69, v19, 1), *(int16x4_t *)v67.i8, v19, 2), v66, v19, 0);
    v66.i64[0] = vextq_s8((int8x16_t)v67, (int8x16_t)v68, 0xCuLL).u64[0];
    int32x4_t v73 = vmlsl_lane_s16(v72, v70, v19, 3);
    int32x4_t v74 = vmlsl_lane_s16(vmlal_high_lane_s16(vmull_lane_s16(v70, v19, 1), v67, v19, 2), *(int16x4_t *)v67.i8, v19, 0);
    int16x4_t v75 = (int16x4_t)vextq_s8((int8x16_t)v68, (int8x16_t)v68, 4uLL).u64[0];
    int32x4_t v76 = vmlsl_lane_s16(v74, *(int16x4_t *)v66.i8, v19, 3);
    int32x4_t v77 = vmlsl_lane_s16(vmlsl_high_lane_s16(vmlal_lane_s16(vmull_lane_s16(*(int16x4_t *)v66.i8, v19, 1), *(int16x4_t *)v68.i8, v19, 2), v67, v19, 0), v75, v19, 3);
    int16x8_t v78 = (int16x8_t)vmlsl_high_u8(vmlsl_high_u8(vmlal_high_u8(vmull_high_u8(v55, v52), v25, v53), v9, v51), v37, v54);
    int16x4_t v79 = vshrn_n_s32(v71, 6uLL);
    int8x16_t v80 = (int8x16_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8(v57, *(uint8x8_t *)v52.i8), v30, *(uint8x8_t *)v53.i8), v18, *(uint8x8_t *)v51.i8), v44, *(uint8x8_t *)v54.i8);
    int16x4_t v81 = (int16x4_t)vextq_s8((int8x16_t)v68, (int8x16_t)v78, 0xCuLL).u64[0];
    int32x4_t v82 = vmlsl_lane_s16(vmlsl_lane_s16(vmlal_high_lane_s16(vmull_lane_s16(v75, v19, 1), v68, v19, 2), *(int16x4_t *)v68.i8, v19, 0), v81, v19, 3);
    int16x4_t v83 = (int16x4_t)vextq_s8((int8x16_t)v78, (int8x16_t)v78, 4uLL).u64[0];
    int32x4_t v84 = vmlsl_lane_s16(vmlsl_high_lane_s16(vmlal_lane_s16(vmull_lane_s16(v81, v19, 1), *(int16x4_t *)v78.i8, v19, 2), v68, v19, 0), v83, v19, 3);
    v68.i64[0] = vextq_s8((int8x16_t)v78, v80, 0xCuLL).u64[0];
    v50[-2] = vshrn_high_n_s32(v79, v73, 6uLL);
    v50[-1] = vshrn_high_n_s32(vshrn_n_s32(v76, 6uLL), v77, 6uLL);
    --v48;
    _X3 += a3;
    *uint64_t v50 = vshrn_high_n_s32(vshrn_n_s32(v82, 6uLL), v84, 6uLL);
    v50[1] = vshrn_high_n_s32(vshrn_n_s32(vmlsl_lane_s16(vmlsl_lane_s16(vmlal_high_lane_s16(vmull_lane_s16(v83, v19, 1), v78, v19, 2), *(int16x4_t *)v78.i8, v19, 0), *(int16x4_t *)v68.i8, v19, 3), 6uLL), vmlsl_lane_s16(vmlsl_high_lane_s16(vmlal_lane_s16(vmull_lane_s16(*(int16x4_t *)v68.i8, v19, 1), *(int16x4_t *)v80.i8, v19, 2), v78, v19, 0), (int16x4_t)*(_OWORD *)&vextq_s8(v80, v80, 4uLL), v19,
                 3),
               6uLL);
    uint64_t v50 = (int16x8_t *)((char *)v50 + 2 * a5);
    uint8x8_t v18 = v57;
    uint8x16_t v8 = v56;
    uint8x16_t v9 = v55;
  }
  while (v48 > 1);
  return result;
}

uint64_t sub_1BBA31290(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, int16x8_t *a6)
{
  unint64_t v11 = a2;
  unint64_t v12 = -8;
  do
  {
    uint64_t result = sub_1BBA31310(a1, v11, a3, a4, a5, a6);
    v12 += 8;
    ++a6;
    a4 += 16;
  }
  while (v12 < 0x38);
  return result;
}

uint64_t sub_1BBA31310(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int16x8_t *a6)
{
  int16x4_t v6 = qword_1BBB78BA0[2 * (a2 & 7) - 2];
  int16x4_t v7 = qword_1BBB78BA0[2 * ((a2 >> 16) & 7) - 2];
  _X9 = (_OWORD *)(a4 + 2 * (-2 - a3));
  int16x8_t v10 = *(int16x8_t *)_X9;
  int8x16_t v9 = *((int8x16_t *)_X9 + 1);
  __asm { PRFUM           #0, [X9,#0x3E] }
  uint64_t v16 = 4 * a3;
  _X9 = (char *)_X9 + 8 * a3;
  __asm
  {
    PRFM            #0, [X9]
    PRFUM           #0, [X9,#0x1E]
  }
  int16x8_t v20 = (int16x8_t)vextq_s8((int8x16_t)v10, v9, 4uLL);
  int16x8_t v21 = (int16x8_t)vextq_s8((int8x16_t)v10, v9, 8uLL);
  int16x8_t v22 = (int16x8_t)vextq_s8((int8x16_t)v10, v9, 0xCuLL);
  int16x8_t v23 = vdupq_lane_s16(v6, 0);
  int16x8_t v24 = vmulq_n_s16(v10, v6.i16[0]);
  int16x8_t v25 = vdupq_lane_s16(v6, 3);
  int16x8_t v26 = vmlaq_lane_s16(v24, v22, v6, 3);
  int16x8_t v27 = vdupq_lane_s16(v6, 1);
  uint16x8_t v28 = (uint16x8_t)vmulq_lane_s16(v20, v6, 1);
  int16x8_t v29 = vdupq_lane_s16(v6, 2);
  uint16x8_t v30 = (uint16x8_t)vmulq_lane_s16(v21, v6, 2);
  int16x8_t v31 = vshrn_high_n_s32(vshrn_n_s32(vaddw_s16((int32x4_t)vaddl_u16(*(uint16x4_t *)v30.i8, *(uint16x4_t *)v28.i8), *(int16x4_t *)v26.i8), 2uLL), vaddw_high_s16((int32x4_t)vaddl_high_u16(v28, v30), v26), 2uLL);
  _X9 = a4 - 4;
  int16x8_t v33 = *(int16x8_t *)(a4 - 4);
  int8x16_t v34 = *(int8x16_t *)(a4 + 12);
  __asm { PRFUM           #0, [X9,#0x3E] }
  _X10 = a4 - 4 + 8 * a3;
  __asm
  {
    PRFM            #0, [X10]
    PRFUM           #0, [X10,#0x1E]
  }
  _X10 = (_OWORD *)(a4 - 4 + 2 * a3);
  int16x8_t v40 = (int16x8_t)vextq_s8((int8x16_t)v33, v34, 4uLL);
  int16x8_t v41 = (int16x8_t)vextq_s8((int8x16_t)v33, v34, 8uLL);
  int16x8_t v42 = vmlaq_lane_s16(vmulq_n_s16(v33, v6.i16[0]), (int16x8_t)vextq_s8((int8x16_t)v33, v34, 0xCuLL), v6, 3);
  uint16x8_t v43 = (uint16x8_t)vmulq_lane_s16(v40, v6, 1);
  uint16x8_t v44 = (uint16x8_t)vmulq_lane_s16(v41, v6, 2);
  int16x8_t v45 = vshrn_high_n_s32(vshrn_n_s32(vaddw_s16((int32x4_t)vaddl_u16(*(uint16x4_t *)v44.i8, *(uint16x4_t *)v43.i8), *(int16x4_t *)v42.i8), 2uLL), vaddw_high_s16((int32x4_t)vaddl_high_u16(v43, v44), v42), 2uLL);
  int16x8_t v46 = *(int16x8_t *)_X10;
  int8x16_t v47 = *((int8x16_t *)_X10 + 1);
  __asm { PRFUM           #0, [X10,#0x3E] }
  _X10 = (char *)_X10 + 8 * a3;
  __asm
  {
    PRFM            #0, [X10]
    PRFUM           #0, [X10,#0x1E]
  }
  int16x8_t v52 = (int16x8_t)vextq_s8((int8x16_t)v46, v47, 4uLL);
  int16x8_t v53 = (int16x8_t)vextq_s8((int8x16_t)v46, v47, 8uLL);
  int16x8_t v54 = vmlaq_lane_s16(vmulq_n_s16(v46, v6.i16[0]), (int16x8_t)vextq_s8((int8x16_t)v46, v47, 0xCuLL), v6, 3);
  uint16x8_t v55 = (uint16x8_t)vmulq_lane_s16(v52, v6, 1);
  uint16x8_t v56 = (uint16x8_t)vmulq_lane_s16(v53, v6, 2);
  int16x8_t v57 = vshrn_high_n_s32(vshrn_n_s32(vaddw_s16((int32x4_t)vaddl_u16(*(uint16x4_t *)v56.i8, *(uint16x4_t *)v55.i8), *(int16x4_t *)v54.i8), 2uLL), vaddw_high_s16((int32x4_t)vaddl_high_u16(v55, v56), v54), 2uLL);
  int v58 = result + 1;
  do
  {
    _X13 = a4 + v16;
    int16x8_t v60 = *(int16x8_t *)(a4 + v16 - 4);
    int8x16_t v61 = *(int8x16_t *)(a4 + v16 + 12);
    int16x8_t v62 = (int16x8_t)vextq_s8((int8x16_t)v60, v61, 4uLL);
    int16x8_t v63 = (int16x8_t)vextq_s8((int8x16_t)v60, v61, 8uLL);
    int16x8_t v64 = vmlaq_s16(vmulq_s16(v60, v23), (int16x8_t)vextq_s8((int8x16_t)v60, v61, 0xCuLL), v25);
    uint16x8_t v65 = (uint16x8_t)vmulq_s16(v62, v27);
    int32x4_t v66 = (int32x4_t)vmulq_s16(v63, v29);
    int32x4_t v67 = (int32x4_t)vaddl_u16(*(uint16x4_t *)v66.i8, *(uint16x4_t *)v65.i8);
    int32x4_t v68 = (int32x4_t)vaddl_high_u16(v65, (uint16x8_t)v66);
    v66.i64[0] = 0x38000000380000;
    v66.i64[1] = 0x38000000380000;
    v69.i64[0] = 0x38000000380000;
    v69.i64[1] = 0x38000000380000;
    int32x4_t v70 = vmlal_lane_s16(vmlal_lane_s16(v66, *(int16x4_t *)v31.i8, v7, 0), *(int16x4_t *)v45.i8, v7, 1);
    int32x4_t v71 = vmlal_high_lane_s16(vmlal_high_lane_s16(v69, v31, v7, 0), v45, v7, 1);
    int16x8_t v31 = v45;
    int16x8_t v45 = v57;
    __asm { PRFUM           #0, [X13,#0x3A] }
    _X13 = a4 + 12 * a3 - 4;
    __asm
    {
      PRFM            #0, [X13]
      PRFUM           #0, [X13,#0x1E]
    }
    int32x4_t v76 = vaddw_s16(v67, *(int16x4_t *)v64.i8);
    int32x4_t v77 = vaddw_high_s16(v68, v64);
    *(int16x4_t *)v76.i8 = vshrn_n_s32(v76, 2uLL);
    int32x4_t v78 = vmlal_lane_s16(vmlal_lane_s16(v70, *(int16x4_t *)v45.i8, v7, 2), *(int16x4_t *)v76.i8, v7, 3);
    int16x8_t v57 = vshrn_high_n_s32(*(int16x4_t *)v76.i8, v77, 2uLL);
    *a6 = vshrn_high_n_s32(vshrn_n_s32(v78, 6uLL), vmlal_lane_s16(vmlal_high_lane_s16(v71, v45, v7, 2), vshrn_n_s32(v77, 2uLL), v7, 3), 6uLL);
    --v58;
    a4 += 2 * a3;
    a6 = (int16x8_t *)((char *)a6 + 2 * a5);
  }
  while (v58 > 1);
  return result;
}

uint64_t sub_1BBA314F4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, int16x8_t *a6)
{
  unint64_t v11 = a2;
  unint64_t v12 = -8;
  do
  {
    uint64_t result = sub_1BBA31310(a1, v11, a3, a4, a5, a6);
    v12 += 8;
    ++a6;
    a4 += 16;
  }
  while (v12 < 0x18);
  return result;
}

uint64_t sub_1BBA31574(uint64_t result, unint64_t a2, uint64_t a3, uint64_t _X3, uint64_t a5, int16x8_t *a6, double a7, double a8, double a9, int8x16_t a10, int8x16_t a11)
{
  int8x8_t v12 = (int8x8_t)qword_1BBB78B30[(a2 & 7) - 1];
  uint8x16_t v13 = (uint8x16_t)vdupq_lane_s8(v12, 0);
  uint8x8_t v14 = (uint8x8_t)vdup_lane_s8(v12, 1);
  uint8x8_t v15 = (uint8x8_t)vdup_lane_s8(v12, 2);
  uint8x8_t v16 = (uint8x8_t)vdup_lane_s8(v12, 3);
  int16x4_t v17 = (int16x4_t)vmovl_u8(qword_1BBB78B30[((a2 >> 16) & 7) - 1]).u64[0];
  _X8 = _X3 - a3;
  int8x16_t v19 = *(int8x16_t *)(_X3 - a3 - 2);
  __asm
  {
    PRFUM           #0, [X8,#0x1D]
    PRFUM           #0, [X8,#0x3E]
    PRFUM           #0, [X8,#0x4D]
  }
  a10.i64[0] = *(void *)(_X3 - a3 + 14);
  __asm { PRFUM           #0, [X8,#0x1D] }
  _X8 = _X3 - a3 + 14 + 4 * (a3 - 16);
  __asm
  {
    PRFM            #0, [X8]
    PRFUM           #0, [X8,#7]
  }
  int8x16_t v31 = *(int8x16_t *)(_X3 - 2);
  __asm
  {
    PRFUM           #0, [X3,#0x1D]
    PRFUM           #0, [X3,#0x3E]
    PRFUM           #0, [X3,#0x4D]
  }
  a11.i64[0] = *(void *)(_X3 + 14);
  __asm { PRFUM           #0, [X3,#0x1D] }
  _X10 = _X3 + 14 + 4 * (a3 - 16);
  __asm
  {
    PRFM            #0, [X10]
    PRFUM           #0, [X10,#7]
  }
  _X10 = (int8x16_t *)(_X3 + 14 + a3 - 16);
  _X11 = &_X10[4].i8[15];
  int8x16_t v41 = *_X10;
  __asm
  {
    PRFUM           #0, [X10,#0x1F]
    PRFM            #0, [X10,#0x40]
    PRFM            #0, [X11]
  }
  _X8 = (uint64_t *)(_X3 + 14 + a3);
  _X9 = (char *)_X8 + 4 * a3 - 64;
  uint64_t v47 = *_X8;
  _X8 = (uint64_t *)((char *)_X8 + 15);
  v11.i64[0] = v47;
  __asm
  {
    PRFM            #0, [X8]
    PRFM            #0, [X9]
    PRFUM           #0, [X9,#7]
  }
  int16x8_t v51 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v19, v19, 2uLL), v14), (uint8x8_t)*(_OWORD *)&vextq_s8(v19, v19, 4uLL), v15), *(uint8x8_t *)v19.i8, *(uint8x8_t *)v13.i8), (uint8x8_t)*(_OWORD *)&vextq_s8(v19, v19, 6uLL), v16);
  int16x8_t v52 = (int16x8_t)vmlsl_u8(vmlsl_high_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v19, a10, 0xAuLL), v14), (uint8x8_t)*(_OWORD *)&vextq_s8(v19, a10, 0xCuLL), v15), (uint8x16_t)v19, v13), (uint8x8_t)*(_OWORD *)&vextq_s8(v19, a10, 0xEuLL), v16);
  int16x8_t v53 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 2uLL), v14), (uint8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 4uLL), v15), *(uint8x8_t *)v31.i8, *(uint8x8_t *)v13.i8), (uint8x8_t)*(_OWORD *)&vextq_s8(v31, v31, 6uLL), v16);
  int16x8_t v54 = (int16x8_t)vmlsl_u8(vmlsl_high_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v31, a11, 0xAuLL), v14), (uint8x8_t)*(_OWORD *)&vextq_s8(v31, a11, 0xCuLL), v15), (uint8x16_t)v31, v13), (uint8x8_t)*(_OWORD *)&vextq_s8(v31, a11, 0xEuLL), v16);
  int16x8_t v55 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v41, v41, 2uLL), v14), (uint8x8_t)*(_OWORD *)&vextq_s8(v41, v41, 4uLL), v15), *(uint8x8_t *)v41.i8, *(uint8x8_t *)v13.i8), (uint8x8_t)*(_OWORD *)&vextq_s8(v41, v41, 6uLL), v16);
  int32x4_t v56 = (int32x4_t)vextq_s8(*_X10, v11, 0xAuLL);
  int16x8_t v57 = (int16x8_t)vmlsl_u8(vmlsl_high_u8(vmlal_u8(vmull_u8(*(uint8x8_t *)v56.i8, v14), (uint8x8_t)*(_OWORD *)&vextq_s8(v41, v11, 0xCuLL), v15), (uint8x16_t)v41, v13), (uint8x8_t)*(_OWORD *)&vextq_s8(v41, v11, 0xEuLL), v16);
  int v58 = result + 1;
  long long v59 = a6 + 1;
  uint64_t v60 = 2 * a3;
  uint8x8_t v61 = (uint8x8_t)vdup_lane_s8(v12, 1);
  uint8x8_t v62 = (uint8x8_t)vdup_lane_s8(v12, 3);
  do
  {
    int16x8_t v63 = v53;
    int16x8_t v53 = v55;
    _X13 = _X3 + v60;
    int8x16_t v65 = *(int8x16_t *)(_X3 + v60 - 2);
    __asm
    {
      PRFUM           #0, [X13,#0x1D]
      PRFUM           #0, [X13,#0x3E]
      PRFUM           #0, [X13,#0x4D]
    }
    v56.i64[0] = *(void *)(_X3 + v60 + 14);
    int16x8_t v55 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v65, v65, 2uLL), v61), (uint8x8_t)*(_OWORD *)&vextq_s8(v65, v65, 4uLL), v15), *(uint8x8_t *)v65.i8, *(uint8x8_t *)v13.i8), (uint8x8_t)*(_OWORD *)&vextq_s8(v65, v65, 6uLL), v62);
    int32x4_t v69 = vmlsl_lane_s16(vmlal_lane_s16(vmull_lane_s16(*(int16x4_t *)v54.i8, v17, 1), *(int16x4_t *)v57.i8, v17, 2), *(int16x4_t *)v52.i8, v17, 0);
    int32x4_t v70 = vmlsl_high_lane_s16(vmlal_high_lane_s16(vmull_high_lane_s16(v54, v17, 1), v57, v17, 2), v52, v17, 0);
    int16x8_t v52 = v54;
    int16x8_t v54 = v57;
    __asm { PRFUM           #0, [X13,#0x1D] }
    _X13 = _X3 + 6 * a3 - 50;
    __asm
    {
      PRFM            #0, [X13]
      PRFUM           #0, [X13,#7]
    }
    int16x8_t v57 = (int16x8_t)vmlsl_u8(vmlsl_high_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v65, (int8x16_t)v56, 0xAuLL), v61), (uint8x8_t)*(_OWORD *)&vextq_s8(v65, (int8x16_t)v56, 0xCuLL), v15), (uint8x16_t)v65, v13), (uint8x8_t)*(_OWORD *)&vextq_s8(v65, (int8x16_t)v56, 0xEuLL), v62);
    int32x4_t v56 = vmlsl_high_lane_s16(vmlsl_high_lane_s16(vmlal_high_lane_s16(vmull_high_lane_s16(v63, v17, 1), v53, v17, 2), v51, v17, 0), v55, v17, 3);
    v59[-1] = vshrn_high_n_s32(vshrn_n_s32(vmlsl_lane_s16(vmlsl_lane_s16(vmlal_lane_s16(vmull_lane_s16(*(int16x4_t *)v63.i8, v17, 1), *(int16x4_t *)v53.i8, v17, 2), *(int16x4_t *)v51.i8, v17, 0), *(int16x4_t *)v55.i8, v17, 3), 6uLL), v56, 6uLL);
    int16x8_t *v59 = vshrn_high_n_s32(vshrn_n_s32(vmlsl_lane_s16(v69, *(int16x4_t *)v57.i8, v17, 3), 6uLL), vmlsl_high_lane_s16(v70, v57, v17, 3), 6uLL);
    --v58;
    long long v59 = (int16x8_t *)((char *)v59 + 2 * a5);
    _X3 += a3;
    int16x8_t v51 = v63;
  }
  while (v58 > 1);
  return result;
}

uint64_t sub_1BBA317E4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, int16x8_t *a6)
{
  unint64_t v11 = a2;
  sub_1BBA31310(a1, a2, a3, a4, a5, a6);

  return sub_1BBA31310(a1, v11, a3, a4 + 16, a5, a6 + 1);
}

uint64_t sub_1BBA31858(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int16x8_t *a6)
{
  int8x8_t v6 = (int8x8_t)qword_1BBB78B30[(a2 & 7) - 1];
  uint8x8_t v7 = (uint8x8_t)vdup_lane_s8(v6, 0);
  uint8x8_t v8 = (uint8x8_t)vdup_lane_s8(v6, 1);
  uint8x8_t v9 = (uint8x8_t)vdup_lane_s8(v6, 2);
  uint8x8_t v10 = (uint8x8_t)vdup_lane_s8(v6, 3);
  _X8 = (int8x16_t *)(a4 - a3 - 2);
  int8x16_t v12 = *_X8;
  __asm { PRFUM           #0, [X8,#0x1F] }
  _X8 = &_X8->i8[4 * a3];
  __asm
  {
    PRFM            #0, [X8]
    PRFUM           #0, [X8,#0xF]
  }
  _X8 = a4 - 2;
  int8x16_t v22 = *(int8x16_t *)(a4 - 2);
  int16x4_t v23 = (int16x4_t)vmovl_u8(qword_1BBB78B30[((a2 >> 16) & 7) - 1]).u64[0];
  __asm { PRFUM           #0, [X8,#0x1F] }
  _X9 = a4 - 2 + 4 * a3;
  __asm
  {
    PRFM            #0, [X9]
    PRFUM           #0, [X9,#0xF]
  }
  _X8 = (_OWORD *)(a4 - 2 + a3);
  _X9 = (char *)_X8 + 4 * a3;
  int8x16_t v30 = *(int8x16_t *)_X8;
  _X8 = (_OWORD *)((char *)_X8 + 31);
  __asm
  {
    PRFM            #0, [X8]
    PRFM            #0, [X9]
    PRFUM           #0, [X9,#0xF]
  }
  int16x8_t v34 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v12, v12, 2uLL), v8), (uint8x8_t)*(_OWORD *)&vextq_s8(v12, v12, 4uLL), v9), *(uint8x8_t *)v12.i8, v7), (uint8x8_t)*(_OWORD *)&vextq_s8(v12, v12, 6uLL), v10);
  int16x8_t v35 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v22, v22, 2uLL), v8), (uint8x8_t)*(_OWORD *)&vextq_s8(v22, v22, 4uLL), v9), *(uint8x8_t *)v22.i8, v7), (uint8x8_t)*(_OWORD *)&vextq_s8(v22, v22, 6uLL), v10);
  int16x8_t v36 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 2uLL), v8), (uint8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 4uLL), v9), *(uint8x8_t *)v30.i8, v7), (uint8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 6uLL), v10);
  int v37 = result + 1;
  uint64_t v38 = 2 * a3;
  uint8x8_t v39 = (uint8x8_t)vdup_lane_s8(v6, 1);
  uint8x8_t v40 = (uint8x8_t)vdup_lane_s8(v6, 3);
  do
  {
    _X12 = a4 + v38;
    int8x16_t v42 = *(int8x16_t *)(a4 + v38 - 2);
    __asm { PRFUM           #0, [X12,#0x1D] }
    _X12 = a4 + 6 * a3 - 2;
    __asm
    {
      PRFM            #0, [X12]
      PRFUM           #0, [X12,#0xF]
    }
    int32x4_t v47 = vmlsl_lane_s16(vmlal_lane_s16(vmull_lane_s16(*(int16x4_t *)v35.i8, v23, 1), *(int16x4_t *)v36.i8, v23, 2), *(int16x4_t *)v34.i8, v23, 0);
    int32x4_t v48 = vmlsl_high_lane_s16(vmlal_high_lane_s16(vmull_high_lane_s16(v35, v23, 1), v36, v23, 2), v34, v23, 0);
    int16x8_t v34 = v35;
    int16x8_t v35 = v36;
    int16x8_t v36 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v42, v42, 2uLL), v39), (uint8x8_t)*(_OWORD *)&vextq_s8(v42, v42, 4uLL), v9), *(uint8x8_t *)v42.i8, v7), (uint8x8_t)*(_OWORD *)&vextq_s8(v42, v42, 6uLL), v40);
    *a6 = vshrn_high_n_s32(vshrn_n_s32(vmlsl_lane_s16(v47, *(int16x4_t *)v36.i8, v23, 3), 6uLL), vmlsl_high_lane_s16(v48, v36, v23, 3), 6uLL);
    a6 = (int16x8_t *)((char *)a6 + 2 * a5);
    --v37;
    a4 += a3;
  }
  while (v37 > 1);
  return result;
}

uint64_t sub_1BBA319D0(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int16x4_t *a6)
{
  int8x8_t v6 = (int8x8_t)qword_1BBB78B30[((a2 >> 16) & 7) - 1];
  _X8 = (uint8x16_t *)(a4 - a3 - 2);
  uint8x16_t v8 = *_X8;
  int16x4_t v9 = (int16x4_t)vmovl_u8(qword_1BBB78B30[(a2 & 7) - 1]).u64[0];
  __asm { PRFUM           #0, [X8,#0x1F] }
  _X8 = &_X8->i8[4 * a3];
  __asm
  {
    PRFM            #0, [X8]
    PRFUM           #0, [X8,#0xF]
  }
  _X8 = a4 - 2;
  int8x16_t v19 = *(int8x16_t *)(a4 - 2);
  __asm { PRFUM           #0, [X8,#0x1F] }
  _X9 = a4 - 2 + 4 * a3;
  __asm
  {
    PRFM            #0, [X9]
    PRFUM           #0, [X9,#0xF]
  }
  _X8 = (_OWORD *)(a4 - 2 + a3);
  _X9 = (char *)_X8 + 4 * a3;
  int8x16_t v26 = *(int8x16_t *)_X8;
  _X8 = (_OWORD *)((char *)_X8 + 31);
  int8x16_t v27 = v26;
  __asm
  {
    PRFM            #0, [X8]
    PRFM            #0, [X9]
    PRFUM           #0, [X9,#0xF]
  }
  int v31 = result + 1;
  uint64_t v32 = 2 * a3;
  uint8x16_t v33 = (uint8x16_t)vdupq_lane_s8(v6, 0);
  uint8x16_t v34 = (uint8x16_t)vdupq_lane_s8(v6, 1);
  int8x16_t v35 = vdupq_lane_s8(v6, 2);
  uint8x8_t v36 = (uint8x8_t)vextq_s8(v35, v35, 8uLL).u64[0];
  int8x16_t v37 = vdupq_lane_s8(v6, 3);
  uint8x8_t v38 = (uint8x8_t)vextq_s8(v37, v37, 8uLL).u64[0];
  do
  {
    uint8x16_t v39 = (uint8x16_t)v19;
    int8x16_t v19 = v27;
    _X12 = a4 + v32;
    int8x16_t v27 = *(int8x16_t *)(a4 + v32 - 2);
    __asm { PRFUM           #0, [X12,#0x1D] }
    _X12 = a4 + 6 * a3 - 2;
    __asm
    {
      PRFM            #0, [X12]
      PRFUM           #0, [X12,#0xF]
    }
    int16x8_t v45 = (int16x8_t)vmlsl_u8(vmlsl_u8(vmlal_u8(vmull_u8(*(uint8x8_t *)v39.i8, *(uint8x8_t *)v34.i8), *(uint8x8_t *)v19.i8, *(uint8x8_t *)v35.i8), *(uint8x8_t *)v8.i8, *(uint8x8_t *)v33.i8), *(uint8x8_t *)v27.i8, *(uint8x8_t *)v37.i8);
    int8x16_t v46 = (int8x16_t)vmlal_u8(vmull_high_u8(v8, v33), (uint8x8_t)*(_OWORD *)&vextq_s8(v27, v27, 8uLL), v38);
    *(int16x4_t *)v46.i8 = vsub_s16((int16x4_t)*(_OWORD *)&vmlal_u8(vmull_high_u8(v39, v34), (uint8x8_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL), v36), *(int16x4_t *)v46.i8);
    *a6 = vshrn_n_s32(vmlsl_lane_s16(vmlsl_lane_s16(vmlal_high_lane_s16(vmull_lane_s16((int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v45, (int8x16_t)v45, 4uLL), v9, 1), v45, v9, 2), *(int16x4_t *)v45.i8, v9, 0), (int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v45, v46, 0xCuLL), v9, 3), 6uLL);
    a6 = (int16x4_t *)((char *)a6 + 2 * a5);
    --v31;
    a4 += a3;
    uint8x16_t v8 = v39;
  }
  while (v31 > 1);
  return result;
}

uint64_t sub_1BBA31AF4(uint64_t result, unint64_t a2, uint64_t a3, int16x4_t *_X3, uint64_t a5, int16x4_t *a6)
{
  int16x4_t v6 = qword_1BBB78BA0[2 * (a2 & 7) - 2];
  int16x4_t v7 = qword_1BBB78BA0[2 * ((a2 >> 16) & 7) - 2];
  _X9 = (char *)_X3 + 2 * (-2 - a3);
  int16x4_t v9 = *(int16x4_t *)_X9;
  int16x8_t v10 = *(int16x8_t *)(_X9 + 4);
  __asm { PRFUM           #0, [X9,#0x22] }
  _X9 = &_X9[8 * a3];
  __asm
  {
    PRFM            #0, [X9]
    PRFUM           #0, [X9,#0x12]
  }
  int16x4_t v19 = vshrn_n_s32(vmlal_high_lane_s16(vmlal_lane_s16(vmlal_lane_s16(vmull_lane_s16(*(int16x4_t *)v10.i8, v6, 1), v9, v6, 0), (int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v10, (int8x16_t)v10, 4uLL), v6, 2), v10, v6, 3), 2uLL);
  __asm { PRFUM           #0, [X3,#0x1E] }
  _X10 = (uint64_t)&_X3[a3 - 1] + 4;
  __asm
  {
    PRFM            #0, [X10]
    PRFUM           #0, [X10,#0x12]
  }
  _X10 = (int16x4_t *)((char *)_X3 + 2 * a3 - 4);
  int16x4_t v25 = vshrn_n_s32(vmlal_high_lane_s16(vmlal_lane_s16(vmlal_lane_s16(vmull_lane_s16(*_X3, v6, 1), *(int16x4_t *)((char *)_X3 - 4), v6, 0), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)_X3->i8, *(int8x16_t *)_X3->i8, 4uLL), v6, 2), *(int16x8_t *)_X3->i8, v6, 3), 2uLL);
  int16x4_t v26 = *_X10;
  __asm { PRFUM           #0, [X10,#0x22] }
  _X10 = &_X10[a3];
  __asm
  {
    PRFM            #0, [X10]
    PRFUM           #0, [X10,#0x12]
  }
  int16x4_t v31 = vshrn_n_s32(vmlal_high_lane_s16(vmlal_lane_s16(vmlal_lane_s16(vmull_lane_s16(*(int16x4_t *)((char *)_X3 + 2 * a3), v6, 1), v26, v6, 0), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)&_X3->i8[2 * a3], *(int8x16_t *)&_X3->i8[2 * a3], 4uLL), v6, 2), *(int16x8_t *)&_X3->i8[2 * a3], v6, 3), 2uLL);
  int v32 = result + 1;
  do
  {
    v33.i64[0] = 0x38000000380000;
    v33.i64[1] = 0x38000000380000;
    int32x4_t v34 = vmlal_lane_s16(vmlal_lane_s16(v33, v19, v7, 0), v25, v7, 1);
    int16x4_t v19 = v25;
    int16x4_t v25 = v31;
    _X13 = (char *)_X3 + 4 * a3;
    __asm { PRFUM           #0, [X13,#0x1E] }
    _X13 = (char *)_X3 + 12 * a3 - 4;
    __asm
    {
      PRFM            #0, [X13]
      PRFUM           #0, [X13,#0x12]
    }
    int16x4_t v31 = vshrn_n_s32(vmlal_high_lane_s16(vmlal_lane_s16(vmlal_lane_s16(vmull_lane_s16(*(int16x4_t *)((char *)_X3 + 4 * a3), v6, 1), *(int16x4_t *)((char *)_X3 + 4 * a3 - 4), v6, 0), (int16x4_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)&_X3->i8[4 * a3], *(int8x16_t *)&_X3->i8[4 * a3], 4uLL), v6, 2), *(int16x8_t *)&_X3->i8[4 * a3], v6, 3), 2uLL);
    *a6 = vshrn_n_s32(vmlal_lane_s16(vmlal_lane_s16(v34, v25, v7, 2), v31, v7, 3), 6uLL);
    --v32;
    _X3 = (int16x4_t *)((char *)_X3 + 2 * a3);
    a6 = (int16x4_t *)((char *)a6 + 2 * a5);
  }
  while (v32 > 1);
  return result;
}