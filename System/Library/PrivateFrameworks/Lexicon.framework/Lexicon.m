uint64_t sub_19E038DD8(uint64_t a1, void *a2)
{
  uint64_t v2;
  uint64_t v5;
  NSObject *v7;
  char *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  unsigned char buf[22];
  __int16 v14;
  void *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E4F143B8];
  v2 = *(unsigned int *)(a1 + 14352);
  if (v2 == -1) {
    sub_19E07D5D0();
  }
  *(void *)buf = &v12;
  if (((unsigned int (*)(unsigned char *, uint64_t))off_1EF09D600[v2])(buf, a1)) {
    __assert_rtn("load", "TIStaticDictionaryImpl.cpp", 183, "!m_baseline_trie.valid()");
  }
  v5 = *(unsigned int *)(a1 + 14352);
  if (v5 == -1) {
    sub_19E07D5D0();
  }
  *(void *)buf = &v12;
  if ((((uint64_t (*)(unsigned char *, uint64_t))off_1EF09D600[v5])(buf, a1) & 1) == 0)
  {
    if (qword_1EB4FED60 != -1) {
      dispatch_once(&qword_1EB4FED60, &unk_1EF098F08);
    }
    v7 = qword_1EB4FED68;
    if (os_log_type_enabled((os_log_t)qword_1EB4FED68, OS_LOG_TYPE_DEBUG))
    {
      v9 = (void *)a2[1];
      if (!v9) {
        v9 = a2 + 2;
      }
      v10 = (void *)a2[5];
      if (!v10) {
        v10 = a2 + 6;
      }
      v11 = (void *)a2[9];
      *(_DWORD *)buf = 136315650;
      if (!v11) {
        v11 = a2 + 10;
      }
      *(void *)&buf[4] = v9;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v10;
      v14 = 2080;
      v15 = v11;
      _os_log_debug_impl(&dword_19E038000, v7, OS_LOG_TYPE_DEBUG, "Loading static dictionary for localeIdentifier=%s, unigrams='%s', delta='%s'", buf, 0x20u);
    }
    if (a2[1]) {
      v8 = (char *)a2[1];
    }
    else {
      v8 = (char *)(a2 + 2);
    }
    sub_19E03A61C((int)buf, v8);
  }
  return 0;
}

void sub_19E039518(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_19E04137C(a1);
  }
  _Unwind_Resume(a1);
}

void sub_19E039520(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_19E04137C();
  }
  _Unwind_Resume(a1);
}

void sub_19E039528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, uint64_t a11, _Unwind_Exception *exception_object, const void *a13, long long __p, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete((void *)__p);
    if ((a10 & 1) == 0) {
      goto LABEL_6;
    }
  }
  else if (!a10)
  {
LABEL_6:
    if (v22) {
      CFRelease(v22);
    }
    sub_19E07D4F0(v20, 0);
    sub_19E0782A0((const void **)(v23 + 120), 0);
    sub_19E07D528((void ***)&__p);
    *(void *)&__p = v23 + 72;
    sub_19E076F34((void ***)&__p);
    v24 = (void *)v19[7];
    if (v24)
    {
      v19[8] = v24;
      operator delete(v24);
    }
    v25 = (void *)v19[4];
    if (v25)
    {
      v19[5] = v25;
      operator delete(v25);
    }
    v26 = *(void **)v23;
    if (*(void *)v23)
    {
      v19[2] = v26;
      operator delete(v26);
    }
    MEMORY[0x19F3BA710](v19, 0x1070C4046963303);
    if (a2 == 1)
    {
      v27 = __cxa_begin_catch(a1);
      if (qword_1EB4FED60 != -1) {
        dispatch_once(&qword_1EB4FED60, &unk_1EF098F08);
      }
      v28 = qword_1EB4FED68;
      if (os_log_type_enabled((os_log_t)qword_1EB4FED68, OS_LOG_TYPE_ERROR))
      {
        uint64_t v29 = (*(uint64_t (**)(void *))(*(void *)v27 + 16))(v27);
        LODWORD(__p) = 136315138;
        *(void *)((char *)&__p + 4) = v29;
        _os_log_error_impl(&dword_19E038000, v28, OS_LOG_TYPE_ERROR, "failed to create the stem-suffix lexiconID converter: %s", (uint8_t *)&__p, 0xCu);
      }
      __cxa_end_catch();
      if (!v18) {
        JUMPOUT(0x19E038FE0);
      }
      JUMPOUT(0x19E038FD8);
    }
    sub_19E07D4F0(&a13, 0);
    _Unwind_Resume(a1);
  }
  __cxa_free_exception(v21);
  goto LABEL_6;
}

void sub_19E0396E8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  sub_19E085810(0, v11);
  JUMPOUT(0x19E039738);
}

void sub_19E0396F4(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_19E03A480(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_19E039714(_Unwind_Exception *a1)
{
}

void sub_19E039720(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x19E039724);
  }
  _Unwind_Resume(a1);
}

void sub_19E039728()
{
}

uint64_t sub_19E039744(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_19E039858(a1, (unsigned __int16 *)a2);
  sub_19E039858(v4 + 32, (unsigned __int16 *)(a2 + 32));
  sub_19E039858(a1 + 64, (unsigned __int16 *)(a2 + 64));
  sub_19E039858(a1 + 96, (unsigned __int16 *)(a2 + 96));
  sub_19E039858(a1 + 128, (unsigned __int16 *)(a2 + 128));
  sub_19E039858(a1 + 160, (unsigned __int16 *)(a2 + 160));
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 192);
  return a1;
}

void sub_19E0397B4(_Unwind_Exception *exception_object)
{
  v3 = *(void **)(v1 + 136);
  if (v3 && *(unsigned char *)(v1 + 134) == 1) {
    free(v3);
  }
  uint64_t v4 = *(void **)(v1 + 104);
  if (v4 && *(unsigned char *)(v1 + 102) == 1) {
    free(v4);
  }
  v5 = *(void **)(v1 + 72);
  if (v5 && *(unsigned char *)(v1 + 70) == 1) {
    free(v5);
  }
  v6 = *(void **)(v1 + 40);
  if (v6 && *(unsigned char *)(v1 + 38) == 1) {
    free(v6);
  }
  v7 = *(void **)(v1 + 8);
  if (v7)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v7);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E039858(uint64_t a1, unsigned __int16 *a2)
{
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  int v4 = *((unsigned __int8 *)a2 + 6);
  *(unsigned char *)(a1 + 6) = v4;
  *(void *)(a1 + 8) = 0;
  if (v4 == 1)
  {
    if (*((void *)a2 + 1)) {
      uint64_t v6 = *((void *)a2 + 1);
    }
    else {
      uint64_t v6 = (uint64_t)(a2 + 8);
    }
    sub_19E03F6F8((void *)a1, v6, 0, *a2);
  }
  else if (!v4)
  {
    *(void *)(a1 + 8) = *((void *)a2 + 1);
    *(_WORD *)a1 = *a2;
    unsigned __int16 v5 = a2[2];
    if (!v5)
    {
      sub_19E0398F4(a2);
      unsigned __int16 v5 = a2[2];
    }
    *(_WORD *)(a1 + 4) = v5;
    *(unsigned char *)(a1 + 17) = 0;
  }
  return a1;
}

unsigned __int16 *sub_19E0398F4(unsigned __int16 *result)
{
  result[2] = 0;
  unsigned int v1 = *result;
  if (*result)
  {
    int v2 = 0;
    __int16 v3 = 0;
    int v4 = (unsigned __int16 *)*((void *)result + 1);
    if (!v4) {
      int v4 = result + 8;
    }
    do
    {
      uint64_t v5 = (unsigned __int16)v2 + 1;
      if (v1 == (unsigned __int16)(v2 + 1)) {
        goto LABEL_22;
      }
      unsigned int v6 = *((unsigned __int8 *)v4 + (unsigned __int16)v2);
      if ((v6 + 11) < 0xCDu) {
        goto LABEL_22;
      }
      unint64_t v7 = *((unsigned __int8 *)v4 + v5);
      if ((v6 & 0xF0) == 0xE0)
      {
        if ((a00000000000000[v6 & 0xF] >> (*((unsigned char *)v4 + v5) >> 5)))
        {
          LODWORD(v5) = v2 + 2;
          if (v1 == (unsigned __int16)(v2 + 2)) {
            goto LABEL_24;
          }
          int v8 = *((char *)v4 + (unsigned __int16)(v2 + 2));
          int v9 = v2 + 3;
LABEL_10:
          if (v8 < -64) {
            LODWORD(v5) = v9;
          }
        }
      }
      else
      {
        if (v6 <= 0xDF)
        {
          int v10 = v2 + 2;
          if ((char)v7 < -64) {
            LODWORD(v5) = v10;
          }
          goto LABEL_22;
        }
        if ((byte_19E125CEE[v7 >> 4] >> (v6 & 7)))
        {
          LODWORD(v5) = v2 + 2;
          if (v1 == (unsigned __int16)(v2 + 2)) {
            goto LABEL_24;
          }
          if (*((char *)v4 + (unsigned __int16)(v2 + 2)) <= -65)
          {
            LODWORD(v5) = v2 + 3;
            if (v1 == (unsigned __int16)(v2 + 3))
            {
LABEL_24:
              result[2] = v3 + 1;
              return result;
            }
            int v8 = *((char *)v4 + (unsigned __int16)(v2 + 3));
            int v9 = v2 + 4;
            goto LABEL_10;
          }
        }
      }
LABEL_22:
      result[2] = ++v3;
      int v2 = v5;
    }
    while (v1 > (unsigned __int16)v5);
  }
  return result;
}

uint64_t sub_19E039A20(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09CB68;
  int v2 = *(_DWORD *)(a1 + 32);
  if (v2 != -1) {
    close(v2);
  }
  *(unsigned char *)(a1 + 24) = 0;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  return a1;
}

uint64_t sub_19E039A88(uint64_t a1, long long *a2, int a3)
{
  uint64_t v4 = sub_19E039B58(a1, a2, a3, 256);
  *(void *)uint64_t v4 = &unk_1EF09C5A0;
  *(void *)(v4 + 64) = 0;
  *(void *)(v4 + 72) = 0;
  *(_DWORD *)(v4 + 80) = 1;
  *(unsigned char *)(v4 + 84) = 0;
  *(_DWORD *)(v4 + 88) = 0;
  *(void *)(v4 + 96) = 0;
  if (*(unsigned char *)(v4 + 24))
  {
    size_t v5 = *(void *)(a1 + 16);
    *(void *)(a1 + 64) = v5;
    if (!v5
      || ((unsigned int v6 = getpagesize(), v7 = v5 / v6 * v6, v5 != v7) ? (v8 = v7 + v6) : (v8 = v5),
          *(void *)(a1 + 72) = v8,
          int v9 = mmap(0, v8, 1, 1, *(_DWORD *)(a1 + 32), 0),
          *(void *)(a1 + 96) = v9,
          v9 == (void *)-1))
    {
      *(unsigned char *)(a1 + 24) = 0;
    }
  }
  return a1;
}

void sub_19E039B44(_Unwind_Exception *a1)
{
  sub_19E039A20(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E039B58(uint64_t a1, long long *a2, int a3, int a4)
{
  *(void *)a1 = &unk_1EF09CB68;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(void *)(a1 + 28) = 0xFFFFFFFF00000000;
  size_t v5 = (char *)(a1 + 40);
  if (*((char *)a2 + 23) < 0)
  {
    sub_19E03FA9C((unsigned char *)(a1 + 40), *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    *(void *)(a1 + 56) = *((void *)a2 + 2);
    *(_OWORD *)size_t v5 = v6;
  }
  unint64_t v7 = v5;
  if (*(char *)(a1 + 63) < 0) {
    unint64_t v7 = *(const char **)v5;
  }
  int v8 = open_dprotected_np(v7, *(_DWORD *)(a1 + 8), 3, 0, *(unsigned int *)(a1 + 12));
  *(_DWORD *)(a1 + 32) = v8;
  if (v8 < 0)
  {
    *(_DWORD *)(a1 + 28) = *__error();
    __error();
  }
  else if (fstat(v8, &v10))
  {
    *(_DWORD *)(a1 + 28) = *__error();
  }
  else
  {
    *(void *)(a1 + 16) = v10.st_size;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_19E039C58(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_19E039C78(const __CFLocale *a1, const __CFString *a2)
{
  CFStringRef Value = (const __CFString *)CFLocaleGetValue(a1, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
  return CFEqual(a2, Value);
}

unsigned __int16 *sub_19E039CC0(unsigned __int16 *result, char *__s1, size_t __n)
{
  if (__s1)
  {
    uint64_t v4 = result;
    result = (unsigned __int16 *)strnlen(__s1, __n);
    size_t v5 = (unsigned __int16)result;
    if ((_WORD)result)
    {
      __int16 v6 = (__int16)result;
      if (!*((unsigned char *)v4 + 6)) {
        sub_19E0B12F4(v4);
      }
      sub_19E03F794((uint64_t)v4, *v4 + v6);
      unint64_t v7 = (unsigned __int16 *)*((void *)v4 + 1);
      if (!v7) {
        unint64_t v7 = v4 + 8;
      }
      result = (unsigned __int16 *)memcpy((char *)v7 + *v4, __s1, v5);
      unsigned __int16 v8 = *v4 + v6;
      *uint64_t v4 = v8;
      int v9 = (unsigned __int16 *)*((void *)v4 + 1);
      if (!v9) {
        int v9 = v4 + 8;
      }
      *((unsigned char *)v9 + v8) = 0;
      v4[2] = 0;
    }
  }
  return result;
}

uint64_t sub_19E039D80()
{
  return 0;
}

const __CFString *sub_19E039E88@<X0>(const __CFString *result@<X0>, void *a2@<X8>)
{
  if (result)
  {
    CFStringRef v3 = result;
    CStringPtr = (char *)CFStringGetCStringPtr(result, 0x8000100u);
    if (!CStringPtr)
    {
      CFIndex Length = CFStringGetLength(v3);
      CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
      operator new[]();
    }
    return (const __CFString *)sub_19E0413C8(a2, CStringPtr);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return result;
}

void sub_19E039F84(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA6E0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

CFStringRef sub_19E039FA8(const __CFDictionary *a1)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"locale");
  CFStringRef v2 = Value;
  if (!Value) {
    return v2;
  }
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 == CFStringGetTypeID())
  {
    CFLocaleRef v4 = CFLocaleCreate(0, v2);
  }
  else
  {
    CFTypeID v5 = CFGetTypeID(v2);
    if (v5 != CFLocaleGetTypeID()) {
      __assert_rtn("createLocale", "LXUtils.cpp", 61, "false && \"received unsupported CFType for locale\"");
    }
    CFLocaleRef v4 = (const __CFLocale *)MEMORY[0x19F3B9E30](0, v2);
  }
  CFStringRef v2 = (const __CFString *)v4;
  if (!sub_19E039C78(v4, @"ars")) {
    return v2;
  }
  CFLocaleRef v6 = sub_19E041100((uint64_t)v2, @"ar");
  CFRelease(v2);
  return (const __CFString *)v6;
}

uint64_t sub_19E03A080(uint64_t a1)
{
  CFStringRef v2 = sub_19E03A13C((_DWORD *)a1);
  sub_19E03A13C(v2 + 3590);
  *(void *)(a1 + 28736) = 0;
  *(_OWORD *)(a1 + 28720) = 0u;
  sub_19E03A348(a1 + 28744);
  *(void *)(a1 + 30120) = 0;
  return a1;
}

void sub_19E03A0DC(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void *)(v1 + 28736);
  *(void *)(v1 + 28736) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  CFTypeID v5 = *(std::__shared_weak_count **)(v1 + 28728);
  if (v5) {
    sub_19E0616BC(v5);
  }
  sub_19E07C6A4(v2);
  sub_19E07C6A4(v1);
  _Unwind_Resume(a1);
}

_DWORD *sub_19E03A13C(_DWORD *a1)
{
  bzero(a1, 0x3810uLL);
  uint64_t v2 = (_DWORD *)sub_19E03A18C((uint64_t)a1);
  a1[3588] = 0;
  sub_19E105DA0(v2);
  return a1;
}

void sub_19E03A178(_Unwind_Exception *a1)
{
  sub_19E07C6A4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E03A18C(uint64_t a1)
{
  uint64_t v2 = (_WORD *)(a1 + 14296);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 13) = 0;
  uint64_t v3 = 296;
  do
  {
    uint64_t v4 = a1 + v3;
    *(_DWORD *)uint64_t v4 = 0;
    *(void *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    v3 += 24;
  }
  while (v4 + 24 != a1 + 6440);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 276) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v5 = -6144;
  do
  {
    uint64_t v6 = a1 + v5;
    *(_DWORD *)(v6 + 6440) = 0;
    *(void *)(v6 + 6448) = 0;
    *(_DWORD *)(v6 + 6456) = 0;
    v5 += 24;
  }
  while (v5);
  *(_DWORD *)(a1 + 6440) = 0;
  *(_OWORD *)(a1 + 6448) = 0u;
  uint64_t v7 = 6736;
  do
  {
    uint64_t v8 = a1 + v7;
    *(_DWORD *)uint64_t v8 = 0;
    *(void *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 16) = 0;
    v7 += 24;
  }
  while (v8 + 24 != a1 + 12880);
  *(_OWORD *)(a1 + 6704) = 0u;
  *(_OWORD *)(a1 + 6688) = 0u;
  *(_OWORD *)(a1 + 6672) = 0u;
  *(_OWORD *)(a1 + 6656) = 0u;
  *(_OWORD *)(a1 + 6640) = 0u;
  *(_OWORD *)(a1 + 6624) = 0u;
  *(_OWORD *)(a1 + 6608) = 0u;
  *(_OWORD *)(a1 + 6592) = 0u;
  *(_OWORD *)(a1 + 6576) = 0u;
  *(_OWORD *)(a1 + 6560) = 0u;
  *(_OWORD *)(a1 + 6544) = 0u;
  *(_OWORD *)(a1 + 6528) = 0u;
  *(_OWORD *)(a1 + 6512) = 0u;
  *(_OWORD *)(a1 + 6496) = 0u;
  *(_OWORD *)(a1 + 6480) = 0u;
  *(_OWORD *)(a1 + 6716) = 0u;
  uint64_t v9 = -6144;
  *(_OWORD *)(a1 + 6464) = 0u;
  do
  {
    uint64_t v10 = a1 + v9;
    *(_DWORD *)(v10 + 12880) = 0;
    *(void *)(v10 + 12888) = 0;
    *(_DWORD *)(v10 + 12896) = 0;
    v9 += 24;
  }
  while (v9);
  *(_DWORD *)(a1 + 12880) = 0;
  *(_OWORD *)(a1 + 12888) = 0u;
  *(_OWORD *)(a1 + 12904) = 0u;
  sub_19E03A348(a1 + 12920);
  _WORD *v2 = 0;
  *(_OWORD *)(a1 + 14336) = 0u;
  *(void *)(a1 + 14308) = 0;
  *(void *)(a1 + 14316) = 0;
  *(void *)(a1 + 14300) = 0;
  *(void *)(a1 + 14322) = 0;
  return a1;
}

void sub_19E03A31C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[1];
  v1[1] = 0;
  if (v3) {
    sub_19E0D054C(v3);
  }
  uint64_t v4 = *v1;
  *uint64_t v1 = 0;
  if (v4) {
    sub_19E0D054C(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E03A348(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C8E8;
  *(_DWORD *)(a1 + 8) = 0;
  *(_OWORD *)(a1 + 1296) = 0u;
  *(_OWORD *)(a1 + 1312) = 0u;
  *(_DWORD *)(a1 + 1328) = 1065353216;
  *(_DWORD *)(a1 + 1336) = 0;
  *(_DWORD *)(a1 + 1344) = 0x100000;
  *(_WORD *)(a1 + 1348) = 0;
  *(unsigned char *)(a1 + 1350) = 0;
  *(void *)(a1 + 1352) = 0;
  *(unsigned char *)(a1 + 1360) = 0;
  sub_19E03A3C0(a1);
  return a1;
}

void sub_19E03A3C0(uint64_t a1)
{
  if (*(void *)(a1 + 1320))
  {
    sub_19E03A480(*(void **)(a1 + 1312));
    *(void *)(a1 + 1312) = 0;
    uint64_t v2 = *(void *)(a1 + 1304);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)(a1 + 1296) + 8 * i) = 0;
    }
    *(void *)(a1 + 1320) = 0;
  }
  *(_DWORD *)(a1 + 1336) = 0;
  bzero((void *)(a1 + 12), 0x400uLL);
  for (uint64_t j = 0; j != 256; j += 16)
    *(_OWORD *)(a1 + 1036 + j) = 0uLL;
}

uint64_t sub_19E03A444(uint64_t a1)
{
  sub_19E03A480(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_19E03A480(void *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      uint64_t v2 = v1;
      uint64_t v1 = (void *)*v1;
      if (*((unsigned __int16 *)v2 + 8) >= 0xFu)
      {
        uint64_t v3 = v2[3];
        if (v3) {
          MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
        }
      }
      operator delete(v2);
    }
    while (v1);
  }
}

double sub_19E03A4E4(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  *(void *)a1 = 0;
  if (v2) {
    sub_19E0D054C(v2);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v3) {
    sub_19E0D054C(v3);
  }
  uint64_t v4 = *(void *)a1;
  *(void *)a1 = 0;
  if (v4) {
    sub_19E0D054C(v4);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v5) {
    sub_19E0D054C(v5);
  }
  *(_OWORD *)(a1 + 24) = 0u;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 12916) = 0;
  *(unsigned char *)(a1 + 20) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 276) = 0u;
  uint64_t v6 = -6144;
  do
  {
    uint64_t v7 = a1 + v6;
    *(_DWORD *)(v7 + 6440) = 0;
    *(void *)(v7 + 6448) = 0;
    *(_DWORD *)(v7 + 6456) = 0;
    v6 += 24;
  }
  while (v6);
  *(_DWORD *)(a1 + 6440) = 0;
  *(_OWORD *)(a1 + 6716) = 0u;
  *(_OWORD *)(a1 + 6448) = 0u;
  *(_OWORD *)(a1 + 6464) = 0u;
  *(_OWORD *)(a1 + 6480) = 0u;
  *(_OWORD *)(a1 + 6496) = 0u;
  *(_OWORD *)(a1 + 6512) = 0u;
  *(_OWORD *)(a1 + 6528) = 0u;
  *(_OWORD *)(a1 + 6544) = 0u;
  *(_OWORD *)(a1 + 6560) = 0u;
  *(_OWORD *)(a1 + 6576) = 0u;
  *(_OWORD *)(a1 + 6592) = 0u;
  *(_OWORD *)(a1 + 6608) = 0u;
  *(_OWORD *)(a1 + 6624) = 0u;
  *(_OWORD *)(a1 + 6640) = 0u;
  *(_OWORD *)(a1 + 6656) = 0u;
  *(_OWORD *)(a1 + 6672) = 0u;
  *(_OWORD *)(a1 + 6688) = 0u;
  uint64_t v8 = -6144;
  *(_OWORD *)(a1 + 6704) = 0u;
  do
  {
    uint64_t v9 = a1 + v8;
    *(_DWORD *)(v9 + 12880) = 0;
    *(void *)(v9 + 12888) = 0;
    *(_DWORD *)(v9 + 12896) = 0;
    v8 += 24;
  }
  while (v8);
  *(_DWORD *)(a1 + 12880) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 12888) = 0u;
  return result;
}

void sub_19E03A61C(int a1, char *__s1)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (!__s1 || !strcmp(__s1, "root"))
  {
    int v11 = 1;
LABEL_31:
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4FEEA0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB4FEEA0))
    {
      sub_19E0DDA74(buf);
      xmmword_1EB4FEE00 = *(_OWORD *)buf;
      __cxa_guard_release(&qword_1EB4FEEA0);
    }
    long long v13 = xmmword_1EB4FEE00;
    if (*((void *)&xmmword_1EB4FEE00 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1EB4FEE00 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    if ((void)v13)
    {
      code[0] = U_ZERO_ERROR;
      sub_19E040A48(buf);
      uint64_t v14 = ucol_openBinary();
      if (*(void *)&buf[8]) {
        sub_19E0616BC(*(std::__shared_weak_count **)&buf[8]);
      }
      code[0] = sub_19E039D80();
      if (code[0] < U_ILLEGAL_ARGUMENT_ERROR)
      {
        if (v14) {
          goto LABEL_94;
        }
      }
      else
      {
        ucol_close();
      }
    }
    if (qword_1E94577C0 != -1) {
      dispatch_once(&qword_1E94577C0, &unk_1EF09E9E8);
    }
    v15 = qword_1E94577B8;
    if (os_log_type_enabled((os_log_t)qword_1E94577B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_19E038000, v15, OS_LOG_TYPE_DEFAULT, "WARNING! Creating precompiled collator. This is expensive!", buf, 2u);
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v48 = 0;
    v16 = aI_0;
    unint64_t v17 = 21;
    switch(v11)
    {
      case 1:
        uint64_t v18 = 0;
        v16 = (__int16 *)"&";
        do
          unint64_t v19 = v18 + 1;
        while (*(unsigned __int16 *)&asc_19E132986[2 * v18++ + 2]);
        if (v19 < 0xB)
        {
          uint64_t v21 = 0;
          do
            v22 = &asc_19E132986[2 * v21++];
          while (*((_WORD *)v22 + 1));
          HIBYTE(v48) = v21 & 0x7F;
          if (!v21) {
            goto LABEL_60;
          }
          size_t v23 = 2 * v21;
          v24 = "&";
LABEL_59:
          memcpy(buf, v24, v23);
LABEL_60:
          *(_WORD *)&buf[2 * v21] = 0;
          goto LABEL_70;
        }
        unint64_t v17 = 0;
        do
          uint64_t v29 = &asc_19E132986[2 * v17++];
        while (*((_WORD *)v29 + 1));
        break;
      case 2:
        break;
      case 3:
        v16 = aZ;
        unint64_t v17 = 54;
        break;
      case 5:
        uint64_t v25 = 0;
        v16 = (__int16 *)word_19E133042;
        do
          unint64_t v26 = v25 + 1;
        while (word_19E133042[++v25]);
        if (v26 < 0xB)
        {
          uint64_t v21 = 0;
          do
            v28 = (char *)&word_19E133042[v21++];
          while (*((_WORD *)v28 + 1));
          HIBYTE(v48) = v21 & 0x7F;
          if (!v21) {
            goto LABEL_60;
          }
          size_t v23 = 2 * v21;
          v24 = (const char *)word_19E133042;
          goto LABEL_59;
        }
        unint64_t v17 = 0;
        do
          v30 = (char *)&word_19E133042[v17++];
        while (*((_WORD *)v30 + 1));
        break;
      case 6:
        v16 = (__int16 *)&unk_19E133252;
        unint64_t v17 = 65;
        break;
      default:
        goto LABEL_70;
    }
    sub_19E0DD844((void **)buf, v16, v17);
LABEL_70:
    int v31 = SHIBYTE(v48);
    if (v48 >= 0) {
      uint64_t v32 = HIBYTE(v48);
    }
    else {
      uint64_t v32 = *(void *)&buf[8];
    }
    unint64_t v33 = v32 + 27;
    if ((unint64_t)(v32 + 27) >= 0x7FFFFFFFFFFFFFF8) {
      sub_19E04147C();
    }
    if (v33 > 0xA)
    {
      uint64_t v35 = (v33 & 0xFFFFFFFFFFFFFFFCLL) + 4;
      if ((v33 | 3) != 0xB) {
        uint64_t v35 = v33 | 3;
      }
      uint64_t v36 = v35 + 1;
      if (v35 + 1 < 0) {
        sub_19E0416C4();
      }
      p_p = (char *)operator new(2 * v36);
      uint64_t v42 = v32 + 27;
      unint64_t v43 = v36 | 0x8000000000000000;
      __p = p_p;
      if (!v32) {
        goto LABEL_86;
      }
    }
    else
    {
      uint64_t v42 = 0;
      unint64_t v43 = 0;
      __p = 0;
      HIBYTE(v43) = v32 + 27;
      if ((v33 & 0x80u) == 0) {
        p_p = (char *)&__p;
      }
      else {
        p_p = 0;
      }
    }
    if (v31 >= 0) {
      v37 = buf;
    }
    else {
      v37 = *(uint8_t **)buf;
    }
    memmove(p_p, v37, 2 * v32);
LABEL_86:
    v38 = &p_p[2 * v32];
    *(_OWORD *)v38 = xmmword_19E1332D6;
    *((_OWORD *)v38 + 1) = unk_19E1332E6;
    *((_OWORD *)v38 + 2) = xmmword_19E1332F6;
    *(void *)(v38 + 46) = 0x20002700260027;
    *((_WORD *)v38 + 27) = 0;
    if (SHIBYTE(v48) < 0) {
      operator delete(*(void **)buf);
    }
    UErrorCode v45 = U_ZERO_ERROR;
    uint64_t v39 = ucol_openRules();
    if (v45 >= U_ILLEGAL_ARGUMENT_ERROR) {
      operator new();
    }
    uint64_t v14 = v39;
    UErrorCode v45 = sub_19E039D80();
    if (v45 >= U_ILLEGAL_ARGUMENT_ERROR)
    {
      ucol_close();
      uint64_t v14 = 0;
    }
    if (SHIBYTE(v43) < 0) {
      operator delete(__p);
    }
LABEL_94:
    if (*((void *)&v13 + 1)) {
      sub_19E0616BC(*((std::__shared_weak_count **)&v13 + 1));
    }
    sub_19E0DD934(&v40, v14);
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v4 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __s1, 0x8000100u);
  *(void *)code = v4;
  CFLocaleRef v5 = CFLocaleCreate(v3, v4);
  CFLocaleRef v6 = v5;
  CFLocaleRef v44 = v5;
  if (!v5)
  {
    if (qword_1E94577C0 != -1) {
      dispatch_once(&qword_1E94577C0, &unk_1EF09E9E8);
    }
    v12 = qword_1E94577B8;
    if (os_log_type_enabled((os_log_t)qword_1E94577B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&buf[4] = 0;
      _os_log_impl(&dword_19E038000, v12, OS_LOG_TYPE_DEFAULT, "could not create custom collator for locale=%@; using default custom collator",
        buf,
        0xCu);
    }
    int v11 = 1;
    goto LABEL_29;
  }
  CFStringRef Value = (const __CFString *)CFLocaleGetValue(v5, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
  sub_19E039E88(Value, buf);
  uint64_t v8 = HIBYTE(v48);
  int v9 = SHIBYTE(v48);
  if (v48 < 0) {
    uint64_t v8 = *(void *)&buf[8];
  }
  if (v8 != 2) {
    goto LABEL_16;
  }
  uint64_t v10 = *(uint8_t **)buf;
  if (v48 >= 0) {
    uint64_t v10 = buf;
  }
  switch(*(_WORD *)v10)
  {
    case 0x6164:
    case 0x626E:
    case 0x6966:
    case 0x7673:
    case 0x6E6E:
      int v11 = 3;
      break;
    case 0x7274:
      int v11 = 2;
      break;
    case 0x6174:
      int v11 = 5;
      break;
    default:
LABEL_16:
      if (sub_19E0701A8((const void **)buf, "de")) {
        int v11 = 6;
      }
      else {
        int v11 = 1;
      }
      break;
  }
  if (v9 < 0) {
    operator delete(*(void **)buf);
  }
  CFRelease(v6);
LABEL_29:
  if (v4) {
    CFRelease(v4);
  }
  goto LABEL_31;
}

void sub_19E03B4AC(_Unwind_Exception *a1)
{
}

void sub_19E03B5FC(uint64_t a1)
{
  v49[4] = *(const void **)MEMORY[0x1E4F143B8];
  std::mutex::lock((std::mutex *)(a1 + 1600));
  if (*(_WORD *)(a1 + 8))
  {
    uint64_t v2 = *(void *)(a1 + 16) ? *(const char **)(a1 + 16) : (const char *)(a1 + 24);
    if (strcmp(v2, "root"))
    {
      sub_19E03FC9C();
      CFAllocatorRef v3 = qword_1EB4FED50;
      if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v18 = *(void *)(a1 + 16);
        if (!v18) {
          uint64_t v18 = a1 + 24;
        }
        *(_DWORD *)uint64_t v21 = 136315138;
        *(void *)&v21[4] = v18;
        _os_log_debug_impl(&dword_19E038000, v3, OS_LOG_TYPE_DEBUG, "Valid locale identifier: %s", v21, 0xCu);
      }
      sub_19E03CD54(a1 + 1480, (unsigned __int16 *)(a1 + 8));
      sub_19E03FD18((CFStringRef *)v49, (unsigned __int16 *)(a1 + 8));
      CFLocaleRef v4 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFLocaleIdentifier)v49[0]);
      CFLocaleRef v48 = v4;
      CFStringRef v5 = (const __CFString *)sub_19E0F45E8(*(const __CFDictionary **)(a1 + 104), v4);
      CFStringRef v6 = (const __CFString *)sub_19E0F4BC0(*(const __CFDictionary **)(a1 + 104), v4);
      if (v5)
      {
        *(_DWORD *)uint64_t v21 = 0x100000;
        *(_WORD *)&v21[4] = 0;
        v21[6] = 0;
        *(void *)&v21[8] = 0;
        v21[16] = 0;
        int v22 = 0x100000;
        __int16 v23 = 0;
        char v24 = 0;
        uint64_t v25 = 0;
        LOBYTE(v26) = 0;
        int v27 = 0x100000;
        __int16 v28 = 0;
        char v29 = 0;
        v30 = 0;
        char v31 = 0;
        int v32 = 0x100000;
        __int16 v33 = 0;
        char v34 = 0;
        uint64_t v35 = 0;
        char v36 = 0;
        int v37 = 0x100000;
        __int16 v38 = 0;
        char v39 = 0;
        long long v40 = 0;
        char v41 = 0;
        int v42 = 0x100000;
        __int16 v43 = 0;
        char v44 = 0;
        UErrorCode v45 = 0;
        char v46 = 0;
        sub_19E03F0BC((uint64_t)buf, v5);
        sub_19E03CED8((uint64_t)&v22, (unsigned __int16 *)buf);
        if (v20 && buf[6] == 1) {
          free(v20);
        }
        sub_19E03F0BC((uint64_t)buf, v6);
        sub_19E03CED8((uint64_t)&v27, (unsigned __int16 *)buf);
        if (v20)
        {
          if (buf[6] == 1) {
            free(v20);
          }
        }
        sub_19E03CD54((uint64_t)v21, (unsigned __int16 *)(a1 + 8));
        int v47 = 1065353216;
        operator new();
      }
      if (v6) {
        CFRelease(v6);
      }
      if (v4) {
        CFRelease(v4);
      }
      sub_19E040A10(v49);
    }
  }
  sub_19E03FC9C();
  uint64_t v7 = qword_1EB4FED50;
  if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v15 = *(void *)(a1 + 16);
    if (!v15) {
      uint64_t v15 = a1 + 24;
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (!v16) {
      uint64_t v16 = a1 + 56;
    }
    *(_DWORD *)uint64_t v21 = 136315394;
    *(void *)&v21[4] = v15;
    *(_WORD *)&v21[12] = 2080;
    *(void *)&v21[14] = v16;
    _os_log_debug_impl(&dword_19E038000, v7, OS_LOG_TYPE_DEBUG, "Loading mutable lexicon locale=%s path=%s", v21, 0x16u);
  }
  uint64_t v8 = *(void *)(a1 + 112);
  if (v8 && sub_19E07D808(v8))
  {
    sub_19E03FC9C();
    int v9 = qword_1EB4FED50;
    if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t v21 = 0;
      _os_log_debug_impl(&dword_19E038000, v9, OS_LOG_TYPE_DEBUG, "Getting collator from static lexicon", v21, 2u);
    }
    sub_19E03F97C((uint64_t)v21, *(void *)(a1 + 112));
    v12 = *(std::__shared_weak_count **)(a1 + 1520);
    *(_OWORD *)(a1 + 1512) = *(_OWORD *)v21;
    if (v12) {
      sub_19E0616BC(v12);
    }
    uint64_t v13 = *(void *)(a1 + 1536);
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = *(void *)(a1 + 1520);
    if (v14) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
    }
    operator new();
  }
  sub_19E03FC9C();
  uint64_t v10 = qword_1EB4FED50;
  if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v17 = *(void *)(a1 + 16);
    if (!v17) {
      uint64_t v17 = a1 + 24;
    }
    *(_DWORD *)uint64_t v21 = 136315138;
    *(void *)&v21[4] = v17;
    _os_log_debug_impl(&dword_19E038000, v10, OS_LOG_TYPE_DEBUG, "Getting ICU collator for locale=%s", v21, 0xCu);
  }
  if (*(void *)(a1 + 16)) {
    int v11 = *(char **)(a1 + 16);
  }
  else {
    int v11 = (char *)(a1 + 24);
  }
  sub_19E03A61C((int)v21, v11);
}

void sub_19E03C9D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::mutex *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a43 < 0) {
    operator delete(__p);
  }
  sub_19E0D6CD8(a15);
  v77 = *(void **)(v75 - 160);
  if (v77 && *(unsigned char *)(v75 - 162) == 1) {
    free(v77);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  sub_19E040984((uint64_t)&a72);
  if (v73) {
    sub_19E0616BC(v73);
  }
  v78 = *(std::__shared_weak_count **)(v74 + 72);
  if (v78) {
    sub_19E0616BC(v78);
  }
  uint64_t v79 = *(void *)(v74 + 56);
  *(void *)(v74 + 56) = 0;
  if (v79) {
    sub_19E0D6CD8(v79);
  }
  v80 = *(void **)(v74 + 32);
  if (v80 && *(unsigned char *)(v74 + 30) == 1) {
    free(v80);
  }
  v81 = *(std::__shared_weak_count **)(v74 + 8);
  if (v81) {
    std::__shared_weak_count::__release_weak(v81);
  }
  if (v73)
  {
    sub_19E0616BC(v73);
    if (!v72) {
      goto LABEL_21;
    }
  }
  else if (!v72)
  {
    goto LABEL_21;
  }
  sub_19E0616BC(v72);
LABEL_21:
  MEMORY[0x19F3BA710](v74, 0x1030C40FB63F55ELL);
  if (v73)
  {
    sub_19E0616BC(v73);
    if (!v72) {
      goto LABEL_28;
    }
  }
  else if (!v72)
  {
    goto LABEL_28;
  }
  sub_19E0616BC(v72);
LABEL_28:
  std::mutex::unlock(a14);
  _Unwind_Resume(a1);
}

uint64_t sub_19E03CD54(uint64_t a1, unsigned __int16 *a2)
{
  if ((unsigned __int16 *)a1 != a2)
  {
    CFLocaleRef v4 = *(void **)(a1 + 8);
    if (v4) {
      BOOL v5 = v4 == *((void **)a2 + 1);
    }
    else {
      BOOL v5 = 0;
    }
    if (v5 && *(unsigned char *)(a1 + 6)) {
      __assert_rtn("operator=", "TIString.cpp", 145, "!m_buffer || m_buffer != o.m_buffer || m_buffer_type == External");
    }
    if (*((unsigned char *)a2 + 6) == 1)
    {
      sub_19E03CE84(a1);
      if (*a2)
      {
        sub_19E03F794(a1, *a2);
        if (*(void *)(a1 + 8)) {
          uint64_t v7 = *(char **)(a1 + 8);
        }
        else {
          uint64_t v7 = (char *)(a1 + 16);
        }
        if (*((void *)a2 + 1)) {
          uint64_t v8 = (const char *)*((void *)a2 + 1);
        }
        else {
          uint64_t v8 = (const char *)(a2 + 8);
        }
        strlcpy(v7, v8, *a2 + 1);
        *(_WORD *)a1 = *a2;
        unsigned __int16 v9 = a2[2];
        if (!v9)
        {
          sub_19E0398F4(a2);
          unsigned __int16 v9 = a2[2];
        }
        *(_WORD *)(a1 + 4) = v9;
      }
    }
    else if (!*((unsigned char *)a2 + 6))
    {
      if (v4 && *(unsigned char *)(a1 + 6) == 1) {
        free(v4);
      }
      *(_WORD *)(a1 + 2) = 16;
      *(unsigned char *)(a1 + 16) = 0;
      *(void *)(a1 + 8) = *((void *)a2 + 1);
      *(_WORD *)a1 = *a2;
      unsigned __int16 v6 = a2[2];
      if (!v6)
      {
        sub_19E0398F4(a2);
        unsigned __int16 v6 = a2[2];
      }
      *(_WORD *)(a1 + 4) = v6;
      *(unsigned char *)(a1 + 6) = 0;
    }
  }
  return a1;
}

void sub_19E03CE84(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2 && *(unsigned char *)(a1 + 6) == 1) {
    free(v2);
  }
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 6) = 1;
  *(unsigned char *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
}

uint64_t sub_19E03CED8(uint64_t a1, unsigned __int16 *a2)
{
  CFLocaleRef v4 = *(void **)(a1 + 8);
  if (v4 && *(unsigned char *)(a1 + 6) == 1) {
    free(v4);
  }
  int v5 = *a2;
  *(_WORD *)a1 = v5;
  *(_DWORD *)(a1 + 2) = *(_DWORD *)(a2 + 1);
  *(unsigned char *)(a1 + 6) = *((unsigned char *)a2 + 6);
  uint64_t v6 = *((void *)a2 + 1);
  *(void *)(a1 + 8) = v6;
  if (!v6)
  {
    uint64_t v7 = (_OWORD *)(a1 + 16);
    if (v5) {
      _OWORD *v7 = *((_OWORD *)a2 + 1);
    }
    else {
      *(unsigned char *)uint64_t v7 = 0;
    }
  }
  *((void *)a2 + 1) = 0;
  sub_19E03CE84((uint64_t)a2);
  return a1;
}

uint64_t LXLexiconCreateTransient(const __CFDictionary *a1, CFErrorRef *a2)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"name");
  if (Value)
  {
    uint64_t v5 = (uint64_t)Value;
    if (CFStringGetLength(Value))
    {
      sub_19E039FA8(a1);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB4FED48, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB4FED48))
      {
        operator new();
      }
      uint64_t v6 = qword_1EB4FECB8;
      uint64_t v7 = qword_1EB4FED30;
      if (qword_1EB4FED30) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_1EB4FED30 + 8), 1uLL, memory_order_relaxed);
      }
      if (qword_1EB4FEF30 != -1) {
        dispatch_once(&qword_1EB4FEF30, &unk_1EF098E48);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      sub_19E0DCED8((void *)(Instance + 16), v5, (uint64_t)&stru_1EF0A2040, v6, v7);
    }
  }
  if (a2) {
    *a2 = sub_19E0A4344(@"A name is required when creating a transient lexicon");
  }
  return 0;
}

void sub_19E03D19C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void *sub_19E03D214(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  if (*(char *)(a2 + 23) >= 0) {
    CFLocaleRef v4 = (const char *)a2;
  }
  else {
    CFLocaleRef v4 = *(const char **)a2;
  }
  int v5 = open(v4, 0);
  if (v5 < 0)
  {
    exception = (std::ios_base::failure *)__cxa_allocate_exception(0x20uLL);
    sub_19E0413C8(&v18, "open()");
    int v11 = __error();
    sub_19E0D0664(exception, (const void **)&v18, a2, *v11);
    __cxa_throw(exception, MEMORY[0x1E4FBA300], MEMORY[0x1E4FBA298]);
  }
  int v6 = v5;
  if (fstat(v5, &v18) < 0)
  {
    v12 = (std::ios_base::failure *)__cxa_allocate_exception(0x20uLL);
    sub_19E0413C8(&v16, "fstat()");
    uint64_t v13 = __error();
    sub_19E0D0664(v12, &v16, a2, *v13);
    __cxa_throw(v12, MEMORY[0x1E4FBA300], MEMORY[0x1E4FBA298]);
  }
  unint64_t st_size = v18.st_size;
  a1[1] = v18.st_size;
  if (st_size >= 0x7FFFFFFF) {
    LODWORD(st_size) = 0x7FFFFFFF;
  }
  int v17 = st_size;
  uint64_t v16 = 0;
  fcntl(v6, 44, &v16);
  uint64_t v8 = mmap(0, a1[1], 1, 1, v6, 0);
  *a1 = v8;
  if (v8 == (void *)-1)
  {
    uint64_t v14 = (std::ios_base::failure *)__cxa_allocate_exception(0x20uLL);
    sub_19E0413C8(&v16, "mmap()");
    uint64_t v15 = __error();
    sub_19E0D0664(v14, &v16, a2, *v15);
    __cxa_throw(v14, MEMORY[0x1E4FBA300], MEMORY[0x1E4FBA298]);
  }
  close(v6);
  return a1;
}

void sub_19E03D3F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v23 & 1) == 0)
    {
LABEL_6:
      close(v21);
      _Unwind_Resume(a1);
    }
  }
  else if (!v23)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v22);
  goto LABEL_6;
}

uint64_t sub_19E03D488(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 14360);
  if (v1 == -1
    || (int v6 = &v5,
        ((void (*)(char **, uint64_t))off_1EF09D808[v1])(&v6, a1 + 8),
        uint64_t v3 = *(unsigned int *)(a1 + 28720),
        v3 == -1))
  {
    sub_19E07D5D0();
  }
  int v6 = &v5;
  return ((uint64_t (*)(char **, uint64_t))off_1EF09D808[v3])(&v6, a1 + 14368);
}

void sub_19E03D510(unsigned char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*a1)
  {
    if (qword_1E9457280 != -1) {
      dispatch_once(&qword_1E9457280, &unk_1EF09D1F8);
    }
    CFLocaleRef v4 = qword_1E9457288;
    if (os_log_type_enabled((os_log_t)qword_1E9457288, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a3 + 23) >= 0) {
        char v5 = (std::string *)a3;
      }
      else {
        char v5 = *(std::string **)a3;
      }
      *(_DWORD *)buf = 136315394;
      uint64_t v15 = "handle_locking";
      __int16 v16 = 2080;
      int v17 = v5;
      int v6 = "%s: %s file is already locked";
LABEL_30:
      _os_log_impl(&dword_19E038000, v4, OS_LOG_TYPE_DEFAULT, v6, buf, 0x16u);
    }
  }
  else
  {
    if (mlock(*(const void **)a2, *(void *)(a2 + 8)))
    {
      *(void *)&v13.__val_ = *__error();
      v13.__cat_ = std::generic_category();
      if (v13.__val_)
      {
        if (qword_1E9457280 != -1) {
          dispatch_once(&qword_1E9457280, &unk_1EF09D1F8);
        }
        uint64_t v8 = qword_1E9457288;
        if (os_log_type_enabled((os_log_t)qword_1E9457288, OS_LOG_TYPE_DEFAULT))
        {
          std::error_code::message(&v12, &v13);
          unsigned __int16 v9 = (v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
             ? &v12
             : (std::string *)v12.__r_.__value_.__r.__words[0];
          uint64_t v10 = *(char *)(a3 + 23) >= 0 ? a3 : *(void *)a3;
          *(_DWORD *)buf = 136315650;
          uint64_t v15 = "handle_locking";
          __int16 v16 = 2080;
          int v17 = v9;
          __int16 v18 = 2080;
          uint64_t v19 = v10;
          _os_log_impl(&dword_19E038000, v8, OS_LOG_TYPE_DEFAULT, "%s: mlock() failed for %s file: %s", buf, 0x20u);
          if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v12.__r_.__value_.__l.__data_);
          }
        }
        return;
      }
    }
    else
    {
      std::system_category();
    }
    *a1 = 1;
    if (qword_1E9457280 != -1) {
      dispatch_once(&qword_1E9457280, &unk_1EF09D1F8);
    }
    CFLocaleRef v4 = qword_1E9457288;
    if (os_log_type_enabled((os_log_t)qword_1E9457288, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a3 + 23) >= 0) {
        int v11 = (std::string *)a3;
      }
      else {
        int v11 = *(std::string **)a3;
      }
      *(_DWORD *)buf = 136315394;
      uint64_t v15 = "handle_locking";
      __int16 v16 = 2080;
      int v17 = v11;
      int v6 = "%s: %s file locked successfully";
      goto LABEL_30;
    }
  }
}

void sub_19E03D79C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_19E04137C(a1);
}

BOOL sub_19E03D7A8(const __CFURL *a1, const __CFString *a2)
{
  CFStringRef PathComponent = CFURLCopyLastPathComponent(a1);
  if ((unint64_t)CFStringFind(PathComponent, a2, 0).location)
  {
    BOOL v5 = 0;
  }
  else
  {
    CFStringRef v6 = CFURLCopyPathExtension(a1);
    BOOL v5 = CFEqual(@"dat", v6);
    if (v6) {
      CFRelease(v6);
    }
  }
  if (PathComponent) {
    CFRelease(PathComponent);
  }
  return v5;
}

void sub_19E03D84C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_19E03D880(const void **a1, const void *a2)
{
  CFLocaleRef v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

uint64_t LXLexiconCreate(const __CFDictionary *a1, CFErrorRef *a2)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  CFLocaleRef v4 = (const __CFLocale *)sub_19E039FA8(a1);
  CFLocaleRef v46 = v4;
  if (!_os_feature_enabled_impl()
    || (CFStringRef v5 = (const __CFString *)sub_19E0A405C(a1, v4), v6 = v5, (v47 = (void *)v5) == 0)
    || (CFIndex v7 = CFStringGetLength(v5), CFRelease(v6), v7 < 1))
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"type");
    if (Value)
    {
      if (CFEqual(Value, @"morphemes")) {
        goto LABEL_14;
      }
    }
    else if (_os_feature_enabled_impl())
    {
      CFStringRef v14 = sub_19E0A3E74(a1, v4);
      CFStringRef v15 = v14;
      int v47 = (void *)v14;
      if (v14)
      {
        CFIndex Length = CFStringGetLength(v14);
        CFRelease(v15);
        if (Length >= 1)
        {
LABEL_14:
          CFStringRef v17 = sub_19E0A3E74(a1, v4);
          int v47 = (void *)v17;
          if (qword_1EB4FEF30 != -1) {
            dispatch_once(&qword_1EB4FEF30, &unk_1EF098E48);
          }
          uint64_t Instance = _CFRuntimeCreateInstance();
          sub_19E0A5878((char *)(Instance + 16), (uint64_t)v4, v17, 0, 0);
          *(void *)(Instance + 16) = &unk_1EF099CD0;
          sub_19E066AF8((void *)(Instance + 30280));
        }
      }
    }
    CFStringRef v19 = (const __CFString *)CFDictionaryGetValue(a1, @"dataFile");
    if (v19)
    {
      uint64_t Copy = (uint64_t)CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v19);
    }
    else
    {
      CFStringRef v21 = (const __CFString *)CFDictionaryGetValue(a1, @"type");
      CFStringRef v22 = v21;
      if (v21 && CFStringCompare(v21, @"unigrams", 0))
      {
        if (CFStringCompare(v22, @"phrases", 0))
        {
          CFStringRef v23 = 0;
        }
        else
        {
          int v47 = &unk_1EF098868;
          uint64_t v49 = &v47;
          CFStringRef v23 = (const __CFString *)sub_19E0F4688(a1, v4);
          sub_19E0F4820(&v47);
        }
LABEL_25:
        CFStringRef v24 = (const __CFString *)CFDictionaryGetValue(a1, @"type");
        if (v24 && CFEqual(v24, @"phrases"))
        {
          CFStringRef v29 = 0;
        }
        else
        {
          CFArrayRef v25 = (const __CFArray *)CFDictionaryGetValue(a1, @"deltaFiles");
          CFArrayRef v26 = v25;
          if (v25 && CFArrayGetCount(v25) >= 1)
          {
            if (CFArrayGetCount(v26) != 1) {
              __assert_rtn("createDeltaLexiconPath", "LXUtils.cpp", 105, "CFArrayGetCount(delta_paths) == 1 && \"multiple delta files are not currently supported\"");
            }
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v26, 0);
            uint64_t v28 = (uint64_t)CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ValueAtIndex);
          }
          else
          {
            uint64_t v28 = sub_19E0F4BC0(a1, v4);
          }
          CFStringRef v29 = (const __CFString *)v28;
        }
        CFBooleanRef v30 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"enableInternalStemSuffix");
        CFBooleanRef v31 = v30;
        if (v30 && (CFTypeID v32 = CFGetTypeID(v30), v32 == CFBooleanGetTypeID()) && (v33 = CFBooleanGetValue(v31), v23) && v33)
        {
          CFAllocatorRef v34 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFURLRef v35 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v23, kCFURLPOSIXPathStyle, 0);
          int v47 = v35;
          if (v35)
          {
            CFURLRef url = CFURLCreateCopyDeletingLastPathComponent(v34, v35);
            CFStringRef PathComponent = CFURLCopyLastPathComponent(v35);
            if (CFStringHasPrefix(PathComponent, @"Unigrams"))
            {
              v51.length = CFStringGetLength(PathComponent) - 8;
              v51.location = 8;
              CFStringRef v37 = CFStringCreateWithSubstring(v34, PathComponent, v51);
              CFStringRef v38 = CFStringCreateWithFormat(v34, 0, @"lstsfmap%@", v37);
              CFURLRef v39 = CFURLCreateCopyAppendingPathComponent(v34, url, v38, 0);
              if (CFURLResourceIsReachable(v39, 0)) {
                CFStringRef v40 = CFURLCopyFileSystemPath(v39, kCFURLPOSIXPathStyle);
              }
              else {
                CFStringRef v40 = 0;
              }
              if (v39) {
                CFRelease(v39);
              }
              if (v38) {
                CFRelease(v38);
              }
              if (v37) {
                CFRelease(v37);
              }
            }
            else
            {
              CFStringRef v40 = 0;
            }
            if (PathComponent) {
              CFRelease(PathComponent);
            }
            if (url) {
              CFRelease(url);
            }
            CFRelease(v35);
          }
          else
          {
            CFStringRef v40 = 0;
          }
          CFStringRef cf = v40;
        }
        else
        {
          CFStringRef v40 = 0;
          CFStringRef cf = 0;
          if (!v23) {
            goto LABEL_71;
          }
        }
        if (CFStringGetLength(v23))
        {
          if (qword_1EB4FEF30 != -1) {
            dispatch_once(&qword_1EB4FEF30, &unk_1EF098E48);
          }
          uint64_t v10 = _CFRuntimeCreateInstance();
          sub_19E0A5878((char *)(v10 + 16), (uint64_t)v4, v23, v29, v40);
          char v42 = 1;
          CFStringRef v40 = cf;
          if (!cf)
          {
LABEL_76:
            if (v29) {
              CFRelease(v29);
            }
            if (v23) {
              CFRelease(v23);
            }
            if ((v42 & 1) == 0) {
              goto LABEL_83;
            }
            goto LABEL_81;
          }
LABEL_75:
          CFRelease(v40);
          goto LABEL_76;
        }
LABEL_71:
        if (a2)
        {
          uint64_t v10 = 0;
          char v42 = 0;
          *a2 = sub_19E0A4344(@"Could not determine the location of the base unigrams file, or one was not provided.");
          if (!v40) {
            goto LABEL_76;
          }
        }
        else
        {
          uint64_t v10 = 0;
          char v42 = 0;
          if (!v40) {
            goto LABEL_76;
          }
        }
        goto LABEL_75;
      }
      uint64_t Copy = sub_19E0F45E8(a1, v4);
    }
    CFStringRef v23 = (const __CFString *)Copy;
    goto LABEL_25;
  }
  CFStringRef v8 = (const __CFString *)sub_19E0A405C(a1, v4);
  if (qword_1EB4FEF30 != -1) {
    dispatch_once(&qword_1EB4FEF30, &unk_1EF098E48);
  }
  uint64_t v9 = _CFRuntimeCreateInstance();
  uint64_t v10 = v9;
  *(void *)(v9 + 24) = 0;
  uint64_t v11 = v9 + 24;
  *(void *)(v9 + 16) = &unk_1EF099980;
  if (v4)
  {
    CFStringRef v12 = (const __CFString *)MEMORY[0x19F3B9E50](v4);
    sub_19E03F0BC(v11 + 8, v12);
  }
  else
  {
    *(_DWORD *)(v9 + 32) = 0x100000;
    *(_WORD *)(v9 + 36) = 0;
    *(unsigned char *)(v9 + 38) = 0;
    *(void *)(v9 + 4sub_19E03D880(&a9, 0) = 0;
    *(unsigned char *)(v9 + 48) = 0;
  }
  sub_19E03F0BC(v10 + 64, v8);
  *(_DWORD *)(v10 + 16sub_19E03D880(&a9, 0) = 0x100000;
  *(_DWORD *)(v10 + 96) = 0x100000;
  *(_WORD *)(v10 + 10sub_19E03D880(&a9, 0) = 0;
  *(unsigned char *)(v10 + 102) = 0;
  *(void *)(v10 + 104) = 0;
  *(unsigned char *)(v10 + 112) = 0;
  *(_DWORD *)(v10 + 128) = 0x100000;
  *(_WORD *)(v10 + 132) = 0;
  *(unsigned char *)(v10 + 134) = 0;
  *(void *)(v10 + 136) = 0;
  *(unsigned char *)(v10 + 144) = 0;
  *(_WORD *)(v10 + 164) = 0;
  *(unsigned char *)(v10 + 166) = 0;
  *(void *)(v10 + 168) = 0;
  *(unsigned char *)(v10 + 176) = 0;
  CFStringRef v41 = (const __CFString *)CFLocaleGetValue(v4, (CFLocaleKey)*MEMORY[0x1E4F1D220]);
  sub_19E03F0BC((uint64_t)&v47, v41);
  sub_19E03CED8(v10 + 160, (unsigned __int16 *)&v47);
  if (v48 && BYTE6(v47) == 1) {
    free(v48);
  }
  if (v8) {
    CFRelease(v8);
  }
LABEL_81:
  if ((*(uint64_t (**)(uint64_t, CFErrorRef *))(*(void *)(v10 + 16) + 16))(v10 + 16, a2)) {
    goto LABEL_84;
  }
  CFRelease((CFTypeRef)v10);
LABEL_83:
  uint64_t v10 = 0;
LABEL_84:
  if (v46) {
    CFRelease(v46);
  }
  return v10;
}

void sub_19E03E0E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, int a20,__int16 a21,char a22,char a23,int a24,__int16 a25,char a26,char a27,int a28,__int16 a29,char a30,char a31,int a32,__int16 a33,char a34,char a35,int a36,__int16 a37,char a38,char a39,int a40,__int16 a41,char a42,char a43,int a44,__int16 a45,char a46,char a47)
{
  if (a2) {
    sub_19E04137C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E03E388(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  sub_19E03F0BC((uint64_t)v5, a3);
  (*(void (**)(uint64_t, unsigned char *))(*(void *)a2 + 8))(a2, v5);
  if (v6) {
    BOOL v4 = v5[6] == 1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    free(v6);
  }
}

void sub_19E03E434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, void *a13)
{
  if (a13) {
    BOOL v14 = a12 == 1;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14) {
    free(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_19E03E460@<X0>(uint64_t *a1@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  LOWORD(__src[0]) = 0;
  char v24 = 0;
  LOWORD(v25) = 0;
  int v26 = 0;
  CFStringRef v6 = (unsigned __int16 *)*((void *)a2 + 1);
  uint64_t v7 = a2 + 8;
  if (v6) {
    uint64_t v8 = *((void *)a2 + 1);
  }
  else {
    uint64_t v8 = (uint64_t)(a2 + 8);
  }
  uint64_t v19 = v8;
  int v9 = *a2;
  int v20 = 0;
  int v21 = v9;
  unsigned int v22 = 0;
  sub_19E03E768(&v19);
  while (1)
  {
    if (v6) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = v7;
    }
    *(void *)&long long v13 = v10;
    DWORD2(v13) = v9;
    HIDWORD(v13) = v9;
    int v14 = 0;
    double result = sub_19E03E768((uint64_t *)&v13);
    if (v19 != (void)v13) {
      __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
    }
    if (v20 == DWORD2(v13)) {
      break;
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t *, void))(*a1 + 16))(&v17, a1, v22);
    sub_19E03EB40((uint64_t)&v13, a1[1], (uint64_t)__src, 0, (unsigned __int16 *)&v17);
    if (LOWORD(__src[0]) >= 0xFu && __src[1]) {
      MEMORY[0x19F3BA6E0](__src[1], 0x1000C8077774924);
    }
    *(_OWORD *)__src = v13;
    if ((unsigned __int16)v13 >= 0xFu) {
      LOWORD(v13) = 0;
    }
    char v24 = v14;
    if ((unsigned __int16)v25 >= 0xFu && *((void *)&v25 + 1)) {
      MEMORY[0x19F3BA6E0](*((void *)&v25 + 1), 0x1000C8077774924);
    }
    long long v25 = v15;
    if ((unsigned __int16)v15 >= 0xFu) {
      LOWORD(v15) = 0;
    }
    int v26 = v16;
    if ((unsigned __int16)v13 >= 0xFu && *((void *)&v13 + 1)) {
      MEMORY[0x19F3BA6E0](*((void *)&v13 + 1), 0x1000C8077774924);
    }
    if ((unsigned __int16)v17 >= 0xFu)
    {
      if (v18) {
        MEMORY[0x19F3BA6E0](v18, 0x1000C8077774924);
      }
    }
    sub_19E03E768(&v19);
    int v9 = *a2;
    CFStringRef v6 = (unsigned __int16 *)*((void *)a2 + 1);
  }
  unsigned int v12 = LOWORD(__src[0]);
  if (LOWORD(__src[0]) >= 0xFuLL)
  {
    *a3 = __src[0];
    operator new[]();
  }
  *(_OWORD *)a3 = *(_OWORD *)__src;
  if ((unsigned __int16)v25 >= 0xFu)
  {
    double result = (uint64_t *)*((void *)&v25 + 1);
    if (*((void *)&v25 + 1)) {
      double result = (uint64_t *)MEMORY[0x19F3BA6E0](*((void *)&v25 + 1), 0x1000C8077774924);
    }
  }
  if (v12 >= 0xF)
  {
    double result = (uint64_t *)__src[1];
    if (__src[1]) {
      return (uint64_t *)MEMORY[0x19F3BA6E0](__src[1], 0x1000C8077774924);
    }
  }
  return result;
}

void sub_19E03E71C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_19E0879E0((unsigned __int16 *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E03E768(uint64_t *result)
{
  int v1 = *((_DWORD *)result + 3);
  uint64_t v2 = *((int *)result + 2);
  if ((int)v2 >= v1)
  {
    *((_DWORD *)result + 2) = v1 + 1;
    *((_DWORD *)result + 4) = 0;
  }
  else
  {
    uint64_t v3 = *result;
    uint64_t v4 = v2 + 1;
    *((_DWORD *)result + 2) = v2 + 1;
    int v5 = *(char *)(v3 + v2);
    unsigned int v6 = *(unsigned __int8 *)(v3 + v2);
    *((_DWORD *)result + 4) = v6;
    if (v5 < 0)
    {
      if (v6 > 0xDF)
      {
        uint64_t v7 = v2 + 3;
        if (v6 > 0xEF)
        {
          *((_DWORD *)result + 4) = ((v6 & 7) << 18) | ((*(unsigned char *)(v3 + v4) & 0x3F) << 12) | ((*(unsigned char *)(v2 + v3 + 2) & 0x3F) << 6) | *(unsigned char *)(v3 + v7) & 0x3F;
          *((_DWORD *)result + 2) = v2 + 4;
        }
        else
        {
          *((_DWORD *)result + 4) = ((v6 & 0xF) << 12) | ((*(unsigned char *)(v3 + v4) & 0x3F) << 6) | *(unsigned char *)(v2 + v3 + 2) & 0x3F;
          *((_DWORD *)result + 2) = v7;
        }
      }
      else
      {
        *((_DWORD *)result + 2) = v2 + 2;
        *((_DWORD *)result + 4) = *(unsigned char *)(v3 + v4) & 0x3F | ((v6 & 0x1F) << 6);
      }
    }
  }
  return result;
}

char *sub_19E03E82C(_WORD *a1, unint64_t a2, void *__src, size_t __len)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 < 0x10000)
  {
    *a1 = a2;
    if ((unsigned __int16)a2 >= 0xFu) {
      operator new[]();
    }
    uint64_t v8 = (char *)(a1 + 1);
    if (__len) {
      memmove(v8, __src, __len);
    }
    return &v8[__len];
  }
  else
  {
    if (qword_1E9457778 != -1) {
      dispatch_once(&qword_1E9457778, &unk_1EF098FC8);
    }
    int v5 = qword_1E9457770;
    if (os_log_type_enabled((os_log_t)qword_1E9457770, OS_LOG_TYPE_ERROR))
    {
      v10[0] = 67109120;
      v10[1] = 0xFFFF;
      _os_log_error_impl(&dword_19E038000, v5, OS_LOG_TYPE_ERROR, "ByteString initialized with buffer longer than 0x%x. Returning empty byte string", (uint8_t *)v10, 8u);
    }
    *a1 = 0;
    return (char *)(a1 + 1);
  }
}

void sub_19E03E980(void *a1@<X0>, unsigned int a2@<W1>, _WORD *a3@<X8>)
{
  v21[2] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = a1[3];
  if (v4)
  {
    int v5 = (_DWORD *)a1[2];
    unsigned int v6 = &v5[2 * v4];
    do
    {
      unint64_t v7 = v4 >> 1;
      uint64_t v8 = &v5[2 * (v4 >> 1)];
      int v10 = *v8;
      int v9 = v8 + 2;
      v4 += ~(v4 >> 1);
      if ((v10 & 0xFFFFFFu) < (a2 & 0xFFFFFF)) {
        int v5 = v9;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    while (v4);
    if (v5 != v6 && (*v5 & 0xFFFFFF) == a2)
    {
      uint64_t v11 = (char *)(v5 + 1);
      if (HIBYTE(*v5) != 1)
      {
        size_t v13 = strnlen(v11, 4uLL);
        goto LABEL_20;
      }
      unint64_t v12 = *(unsigned int *)v11;
      if (a1[5] > v12)
      {
        uint64_t v11 = (char *)(a1[4] + v12);
        size_t v13 = strlen(v11);
LABEL_20:
        sub_19E03E82C(a3, v13, v11, v13);
        return;
      }
    }
  }
  sub_19E040834((uint64_t)&__n, a2);
  int v17 = 0;
  char __src = 2;
  if (v20) {
    int v14 = v20;
  }
  else {
    int v14 = v21;
  }
  uint64_t v15 = __n;
  memcpy(&v17, v14, __n);
  sub_19E03E82C(a3, v15 + 1, &__src, v15 + 1);
  if (v20 && __n_6 == 1) {
    free(v20);
  }
}

void sub_19E03EB1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, void *a13)
{
  if (a13)
  {
    if (a12 == 1) {
      free(a13);
    }
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E03EB40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5)
{
  uint64_t v54 = a4;
  v70[2] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = MEMORY[0x1F4188790]();
  int v10 = (char *)&v51 - v9;
  v55 = (unsigned __int16 *)v11;
  unsigned int v12 = *(unsigned __int8 *)(v11 + 16);
  uint64_t v53 = v7;
  if (v8)
  {
    size_t v13 = (unsigned __int8 *)*((void *)a5 + 1);
    if (v8 <= 0xE) {
      size_t v13 = (unsigned __int8 *)(a5 + 1);
    }
    unsigned int v14 = *v13;
    if (v12 == v14)
    {
      unsigned int v56 = v12;
      unsigned int v15 = 0;
    }
    else
    {
      if (v12)
      {
        if (v14 > v12) {
          char v16 = -1;
        }
        else {
          char v16 = 3;
        }
        *int v10 = v16;
        unsigned int v12 = 1;
      }
      unsigned int v15 = v12 + 1;
      v10[v12] = v14;
      if ((v14 - 95) >= 0x1Eu && v14 != 254) {
        unsigned int v14 = 0;
      }
      unsigned int v56 = v14;
    }
    if (v8 < 2)
    {
      unsigned int v8 = 1;
    }
    else
    {
      uint64_t v18 = 0;
      v52 = (void *)(a2 + 1296);
      uint64_t v19 = &v10[v15];
      do
      {
        if (v8 <= 0xE) {
          int v20 = (unsigned __int8 *)(a5 + 1);
        }
        else {
          int v20 = (unsigned __int8 *)*((void *)a5 + 1);
        }
        uint64_t v21 = v20[v18 + 1];
        v19[v18] = v21;
        if (*(unsigned char *)(a2 + v21 + 1036))
        {
          BOOL v22 = v21 != 254 && (v21 - 95) > 0x1Du;
          if (!v22 && !*(_DWORD *)(a2 + 4 * v21 + 12))
          {
            sub_19E03E82C(v67, v18 + 1, v20, v18 + 1);
            CFStringRef v23 = sub_19E0AF554(v52, v67);
            if (v67[0] >= 0xFu && v69) {
              MEMORY[0x19F3BA6E0](v69, 0x1000C8077774924);
            }
            unsigned int v24 = v56;
            if (v23) {
              unsigned int v24 = v21;
            }
            unsigned int v56 = v24;
            unsigned int v8 = *a5;
          }
        }
        LOWORD(v15) = v15 + 1;
        BOOL v25 = v18 + 2 >= (unint64_t)v8;
        ++v18;
      }
      while (!v25);
    }
  }
  else
  {
    unsigned int v56 = v12;
    LOWORD(v15) = 0;
  }
  if (v8 + 1 < (unsigned __int16)v15)
  {
    unsigned __int8 v26 = atomic_load(byte_1E9457268);
    if (v26)
    {
      unsigned __int8 v27 = atomic_load(byte_1E94578A0);
      if (v27)
      {
        sub_19E039858((uint64_t)v67, (unsigned __int16 *)(a2 + 1344));
        CFStringRef v38 = v69;
        sub_19E0A7188((uint64_t)v63, v55, v39, v40, v41, v42, v43, v44);
        UErrorCode v45 = (const char *)v70;
        if (v38) {
          UErrorCode v45 = v38;
        }
        CFLocaleRef v46 = v65;
        if (!v65) {
          CFLocaleRef v46 = v66;
        }
        printf("Attempted to write past bounds of sortkey buffer: UTF-32 char: (%#07x), locale code: (%s), partial sort key (%s)", v54, v45, v46);
        if (v65 && v64 == 1) {
          free(v65);
        }
        if (v69 && v68 == 1) {
          free(v69);
        }
        putchar(10);
      }
      else
      {
        uint64_t v28 = sub_19E08D084();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
        {
          sub_19E039858((uint64_t)v67, (unsigned __int16 *)(a2 + 1344));
          CFStringRef v29 = v69;
          sub_19E0A7188((uint64_t)v63, v55, v30, v31, v32, v33, v34, v35);
          char v36 = (char *)v70;
          if (v29) {
            char v36 = v29;
          }
          CFStringRef v37 = v65;
          *(_DWORD *)buf = 67109634;
          int v58 = v54;
          if (!v65) {
            CFStringRef v37 = v66;
          }
          __int16 v59 = 2080;
          v60 = v36;
          __int16 v61 = 2080;
          v62 = v37;
          _os_log_impl(&dword_19E038000, v28, OS_LOG_TYPE_FAULT, "Attempted to write past bounds of sortkey buffer: UTF-32 char: (%#07x), locale code: (%s), partial sort key (%s)", buf, 0x1Cu);
          if (v65 && v64 == 1) {
            free(v65);
          }
          if (v69 && v68 == 1) {
            free(v69);
          }
        }
      }
    }
  }
  size_t v47 = *v55;
  if (v47 <= 0xE) {
    CFLocaleRef v48 = v55 + 1;
  }
  else {
    CFLocaleRef v48 = (unsigned __int16 *)*((void *)v55 + 1);
  }
  uint64_t v49 = sub_19E03E82C(v67, v47 + (unsigned __int16)v15, v48, v47);
  if ((_WORD)v15) {
    memcpy(v49, v10, (unsigned __int16)v15);
  }
  v63[0] = 0;
  double result = (void *)sub_19E03EFB8(v53, v67, v56, v63, v54);
  if (v67[0] >= 0xFu)
  {
    double result = v69;
    if (v69) {
      return (void *)MEMORY[0x19F3BA6E0](v69, 0x1000C8077774924);
    }
  }
  return result;
}

void sub_19E03EF58(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 - 120);
  if (v3)
  {
    if (*(unsigned char *)(v1 - 122) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E03EFB8(uint64_t a1, unsigned __int16 *a2, char a3, unsigned __int16 *a4, int a5)
{
  unint64_t v6 = *a2;
  if (v6 >= 0xF)
  {
    *(_WORD *)a1 = v6;
    operator new[]();
  }
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(unsigned char *)(a1 + 16) = a3;
  uint64_t v7 = (_WORD *)(a1 + 24);
  unint64_t v8 = *a4;
  if (v8 >= 0xF)
  {
    _WORD *v7 = v8;
    operator new[]();
  }
  *(_OWORD *)uint64_t v7 = *(_OWORD *)a4;
  *(_DWORD *)(a1 + 4sub_19E03D880(&a9, 0) = a5;
  return a1;
}

void sub_19E03F088(_Unwind_Exception *exception_object)
{
  if (*v1 >= 0xFu)
  {
    uint64_t v3 = *((void *)v1 + 1);
    if (v3) {
      MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E03F0BC(uint64_t a1, CFStringRef theString)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!theString)
  {
    *(_DWORD *)a1 = 0x100000;
    *(_WORD *)(a1 + 4) = 0;
    *(unsigned char *)(a1 + 6) = 0;
    *(void *)(a1 + 8) = 0;
    *(unsigned char *)(a1 + 16) = 0;
    return;
  }
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (CStringPtr)
  {
    uint64_t v5 = (uint64_t)CStringPtr;
    *(_DWORD *)a1 = 0x100000;
    *(_WORD *)(a1 + 4) = 0;
    *(unsigned char *)(a1 + 6) = 1;
    *(void *)(a1 + 8) = 0;
    unsigned int v6 = (unsigned __int16)strlen(CStringPtr);
    sub_19E03F6F8((void *)a1, v5, 0, v6);
    return;
  }
  if (CFStringGetCString(theString, buffer, 1024, 0x8000100u))
  {
    *(_DWORD *)a1 = 0x100000;
    *(_WORD *)(a1 + 4) = 0;
    *(unsigned char *)(a1 + 6) = 1;
    *(void *)(a1 + 8) = 0;
    unsigned __int16 v7 = strlen(buffer);
    sub_19E03F6F8((void *)a1, (uint64_t)buffer, 0, v7);
    return;
  }
  CFIndex Length = CFStringGetLength(theString);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFIndex v10 = MaximumSizeForEncoding + 1;
  if (MaximumSizeForEncoding == -1)
  {
    uint64_t v11 = 0;
    unsigned int v12 = 0;
    size_t v13 = 0;
  }
  else
  {
    if (MaximumSizeForEncoding <= -2) {
      sub_19E041BEC();
    }
    unsigned int v14 = (char *)operator new(MaximumSizeForEncoding + 1);
    uint64_t v11 = v14;
    uint64_t v15 = 0;
    size_t v13 = &v14[v10];
    do
      v14[v15++] = 0;
    while (v10 != v15);
    unsigned int v12 = v14;
  }
  if (CFStringGetCString(theString, v11, v13 - v12, 0x8000100u))
  {
    sub_19E0B1358(a1, v11);
    if (!v11) {
      return;
    }
    goto LABEL_17;
  }
  CFIndex v16 = CFStringGetLength(theString);
  sub_19E07C428(&v30, v16);
  v39.location = 0;
  v39.length = v16;
  CFStringGetCharacters(theString, v39, v30);
  sub_19E0538DC((uint64_t)v25);
  *(_DWORD *)((char *)v27 + *(void *)(v26 - 24)) = *(_DWORD *)((unsigned char *)v27 + *(void *)(v26 - 24)) & 0xFFFFFFB5 | 8;
  int v17 = v30;
  uint64_t v18 = v31;
  if (v30 != v31)
  {
    char v19 = 1;
    do
    {
      if ((v19 & 1) == 0) {
        sub_19E0416F8(&v26, (uint64_t)" ", 1);
      }
      sub_19E0416F8(&v26, (uint64_t)"0x", 2);
      std::ostream::operator<<();
      char v19 = 0;
      ++v17;
    }
    while (v17 != v18);
  }
  if (qword_1E9457768 != -1) {
    dispatch_once(&qword_1E9457768, &unk_1EF098FA8);
  }
  int v20 = qword_1E9457760;
  if (os_log_type_enabled((os_log_t)qword_1E9457760, OS_LOG_TYPE_FAULT))
  {
    sub_19E05EEA4(__dst, (uint64_t)v27);
    BOOL v22 = v24 >= 0 ? __dst : (void **)__dst[0];
    *(_DWORD *)buf = 138412546;
    CFStringRef v34 = theString;
    __int16 v35 = 2080;
    char v36 = v22;
    _os_log_fault_impl(&dword_19E038000, v20, OS_LOG_TYPE_FAULT, "Failed to convert '%@' (%s) to UTF-8", buf, 0x16u);
    if (v24 < 0) {
      operator delete(__dst[0]);
    }
  }
  v25[0] = *MEMORY[0x1E4FBA408];
  uint64_t v21 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v25 + *(void *)(v25[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  uint64_t v26 = v21;
  v27[0] = MEMORY[0x1E4FBA470] + 16;
  if (v28 < 0) {
    operator delete((void *)v27[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x19F3BA690](&v29);
  if (v30)
  {
    uint64_t v31 = v30;
    operator delete(v30);
  }
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 6) = 0;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  if (v11) {
LABEL_17:
  }
    operator delete(v11);
}

void sub_19E03F58C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *__p,uint64_t a49)
{
  sub_19E053BB4((uint64_t)&a13);
  if (__p)
  {
    a49 = (uint64_t)__p;
    operator delete(__p);
  }
  if (v49) {
    operator delete(v49);
  }
  _Unwind_Resume(a1);
}

unint64_t LXLexiconGetSortkeyBytes(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5)
{
  if (!a5) {
    __assert_rtn("LXLexiconGetSortkeyBytes", "LXLexicon.cpp", 512, "numBytes != NULL && \"numBytes must not be NULL\"");
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)(a1 + 16) + 96))(&v14);
  if (a3)
  {
    uint64_t v8 = 0xFFFFLL;
    if ((unint64_t)a4 < 0xFFFF) {
      uint64_t v8 = a4;
    }
    if (a4 <= 0) {
      unint64_t v9 = 0;
    }
    else {
      unint64_t v9 = v8;
    }
    unint64_t v10 = (unsigned __int16)v14;
    if (v9 >= (unsigned __int16)v14) {
      size_t v11 = (unsigned __int16)v14;
    }
    else {
      size_t v11 = v9;
    }
    if ((unsigned __int16)v14 <= 0xEu) {
      unsigned int v12 = (char *)&v14 + 2;
    }
    else {
      unsigned int v12 = v15;
    }
    memcpy((void *)a3, v12, v11);
    if (v9 > v10) {
      *(unsigned char *)(a3 + v11) = 0;
    }
    *a5 = v10;
    a3 = v9 >= v10;
  }
  else
  {
    LODWORD(v1sub_19E03D880(&a9, 0) = (unsigned __int16)v14;
    *a5 = (unsigned __int16)v14;
  }
  if (v10 >= 0xF && v15) {
    MEMORY[0x19F3BA6E0](v15, 0x1000C8077774924);
  }
  return a3;
}

void *sub_19E03F6F8(void *result, uint64_t a2, unsigned int a3, unsigned int a4)
{
  result[2] = 0;
  result[3] = 0;
  unint64_t v4 = (char *)(result + 2);
  if (a2 && a4)
  {
    uint64_t v8 = result;
    sub_19E03F794((uint64_t)result, a4);
    if (*((unsigned __int16 *)v8 + 1) < a4) {
      __assert_rtn("initialize", "TIString.cpp", 215, "len <= m_capacity");
    }
    if (v8[1]) {
      unint64_t v9 = (void *)v8[1];
    }
    else {
      unint64_t v9 = v4;
    }
    double result = memcpy(v9, (const void *)(a2 + a3), a4);
    *(_WORD *)uint64_t v8 = a4;
  }
  return result;
}

void sub_19E03F794(uint64_t a1, __int16 a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 2);
  if (v2 <= 0xF) {
    __assert_rtn("ensure_capacity", "TIString.cpp", 249, "m_capacity >= InitialCapacity");
  }
  unsigned __int16 v3 = a2 + 1;
  if (v2 <= (unsigned __int16)(a2 + 1))
  {
    if (!*(unsigned char *)(a1 + 6))
    {
      sub_19E0B12F4((unsigned __int16 *)a1);
      unsigned int v2 = *(unsigned __int16 *)(a1 + 2);
    }
    unsigned __int16 v5 = v2;
    if (v2 < v3)
    {
      unsigned __int16 v5 = v2;
      do
        unsigned __int16 v5 = 2 * v5 + 16;
      while ((v5 & 0xFFFEu) < v3);
      *(_WORD *)(a1 + 2) = v5;
    }
    if (v5 >= 0x11u)
    {
      if (*(unsigned char *)(a1 + 6) == 1 && (unsigned int v6 = *(void **)(a1 + 8)) != 0)
      {
        uint64_t v7 = v2;
        uint64_t v8 = (char *)malloc_type_realloc(v6, v5 + 1, 0x634B52BCuLL);
        *(void *)(a1 + 8) = v8;
        bzero(&v8[v7], *(unsigned __int16 *)(a1 + 2) - v7 + 1);
      }
      else
      {
        unint64_t v9 = malloc_type_malloc(v5 + 1, 0x5966F548uLL);
        *(void *)(a1 + 8) = v9;
        bzero(v9, *(unsigned __int16 *)(a1 + 2) + 1);
        if (*(_WORD *)a1)
        {
          strlcpy(*(char **)(a1 + 8), (const char *)(a1 + 16), *(unsigned __int16 *)(a1 + 2) + 1);
          *(void *)(a1 + 16) = 0;
          *(void *)(a1 + 24) = 0;
        }
      }
      if (*(unsigned char *)(a1 + 6) != 1 || !*(void *)(a1 + 8)) {
        __assert_rtn("ensure_capacity", "TIString.cpp", 275, "data_in_allocated_internal_buffer()");
      }
    }
  }
}

void sub_19E03F8F4(uint64_t a1@<X0>, const __CFString *a2@<X1>, uint64_t a3@<X8>)
{
  sub_19E03F97C((uint64_t)&v6, a1 + 8);
  sub_19E03E388(a3, v6, a2);
  unsigned __int16 v5 = v7;
  if (v7)
  {
    sub_19E0616BC(v5);
  }
}

void sub_19E03F964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_19E0616BC(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E03F97C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 14352);
  if (v2 == -1) {
    goto LABEL_8;
  }
  *(void *)&long long v8 = &v10;
  double result = (void *)((uint64_t (*)(long long *))off_1EF09D6D0[v2])(&v8);
  if (result)
  {
    uint64_t v6 = *(unsigned int *)(a2 + 14352);
    if (v6 != -1)
    {
      unint64_t v10 = &v9;
      double result = ((void *(*)(long long *__return_ptr, char **, uint64_t))off_1EF09D738[v6])(&v8, &v10, a2);
      *(_OWORD *)a1 = v8;
      return result;
    }
LABEL_8:
    sub_19E07D5D0();
  }
  uint64_t v7 = *(void *)(a2 + 28728);
  *(void *)a1 = *(void *)(a2 + 28720);
  *(void *)(a1 + 8) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t LXLexiconLockMemory(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 40))();
}

uint64_t LXLexiconIncrementUsageCount(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 144))();
}

uint64_t LXLexiconAdd(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 128))();
}

void *sub_19E03FA9C(unsigned char *__dst, void *__src, unint64_t a3)
{
  unsigned __int16 v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      sub_19E04147C();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    long long v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    void *v5 = v8;
    unsigned __int16 v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }

  return memmove(v5, __src, a3 + 1);
}

BOOL sub_19E03FB3C(unsigned __int16 *a1, unsigned __int16 *a2)
{
  size_t v2 = *a2;
  uint64_t v3 = *a1;
  if (v2 > v3) {
    return 0;
  }
  size_t v5 = v3 - v2;
  uint64_t v6 = (unsigned __int16 *)*((void *)a1 + 1);
  if (!v6) {
    uint64_t v6 = a1 + 8;
  }
  if (*((void *)a2 + 1)) {
    uint64_t v7 = (const char *)*((void *)a2 + 1);
  }
  else {
    uint64_t v7 = (const char *)(a2 + 8);
  }
  return strncmp((const char *)v6 + v5, v7, v2) == 0;
}

void *sub_19E03FB9C(void *result, unsigned __int16 *a2, unsigned int a3, int a4)
{
  unint64_t v4 = result;
  unsigned int v5 = *a2;
  if (v5 <= a3)
  {
    *(_DWORD *)double result = 0x100000;
    *((_WORD *)result + 2) = 0;
    *((unsigned char *)result + 6) = 0;
    result[1] = 0;
    *((unsigned char *)result + 16) = 0;
  }
  else
  {
    if (a4 + a3 <= v5) {
      unsigned __int16 v7 = a4;
    }
    else {
      unsigned __int16 v7 = v5 - a3;
    }
    if (*((void *)a2 + 1)) {
      long long v8 = (const char *)*((void *)a2 + 1);
    }
    else {
      long long v8 = (const char *)(a2 + 8);
    }
    *(_DWORD *)double result = 0x100000;
    *((_WORD *)result + 2) = 0;
    *((unsigned char *)result + 6) = 1;
    result[1] = 0;
    if (v7 + (unint64_t)a3 > strlen(v8) && a3 + v7) {
      __assert_rtn("String", "TIString.cpp", 95, "(str && pos + len <= strlen(str)) || pos + len == 0");
    }
    return sub_19E03F6F8(v4, (uint64_t)v8, a3, v7);
  }
  return result;
}

void sub_19E03FC9C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_1EB4FED78, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_1EB4FED78))
  {
    sub_19E0AB48C();
    __cxa_guard_release(qword_1EB4FED78);
  }
}

void sub_19E03FD00(_Unwind_Exception *a1)
{
}

const void **sub_19E03FD18(CFStringRef *a1, unsigned __int16 *a2)
{
  uint64_t v3 = (const UInt8 *)*((void *)a2 + 1);
  if (!v3) {
    uint64_t v3 = (const UInt8 *)(a2 + 8);
  }
  CFStringRef v4 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3, *a2, 0x8000100u, 1u);
  uint64_t v6 = 0;
  *a1 = v4;
  return sub_19E040A10(&v6);
}

uint64_t sub_19E03FD84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 8)) {
    uint64_t v6 = *(char **)(a2 + 8);
  }
  else {
    uint64_t v6 = (char *)(a2 + 16);
  }
  sub_19E0408EC(&v29, v6, 0);
  if (!v30 || ((unint64_t)(v31 - 1) >= 0x2B ? (BOOL v7 = v32 == 0) : (BOOL v7 = 1), v7))
  {
    sub_19E040984((uint64_t)&v29);
LABEL_11:
    sub_19E105DA0((_DWORD *)a1);
    int v8 = *(_DWORD *)(a1 + 14352);
    *(void *)&long long v29 = a2;
    *((void *)&v29 + 1) = a3;
    if (v8 == -1) {
      sub_19E07D5D0();
    }
  }
  else
  {
    int v9 = *(_DWORD *)(v32 + 40);
    if ((unint64_t)(v31 - 48) > 0xFFFFFFFFFFFFFFD0) {
      unsigned int v10 = 0;
    }
    else {
      unsigned int v10 = bswap32(*(_DWORD *)(v32 + 44));
    }
    BOOL v11 = (unint64_t)(v31 - 48) < 0xFFFFFFFFFFFFFFD1 && v10 != 0;
    if ((unint64_t)(v31 - 48) < 0xFFFFFFFFFFFFFFD1 && v10 != 0) {
      int v12 = v10;
    }
    else {
      int v12 = 5;
    }
    sub_19E040984((uint64_t)&v29);
    if (!v11 || (v9 & 0x1000) == 0)
    {
      switch(v12)
      {
        case 1:
          uint64_t v14 = *(unsigned int *)(a1 + 14352);
          if (v14 != -1) {
            ((void (*)(long long *, uint64_t))off_1EF0A0248[v14])(&v29, a1);
          }
          *(_DWORD *)(a1 + 14352) = -1;
          bzero((void *)a1, 0x630uLL);
          *(void *)(a1 + 16sub_19E03D880(&a9, 0) = 0;
          *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A0328;
          *(void *)(a1 + 48) = &unk_1EF0A0400;
          *(_DWORD *)(a1 + 14sub_19E03D880(&a9, 0) = 0;
          *(_OWORD *)(a1 + 56) = 0u;
          *(_OWORD *)(a1 + 72) = 0u;
          *(void *)(a1 + 168) = 0;
          *(void *)(a1 + 152) = a1 + 160;
          sub_19E03A348(a1 + 176);
          *(_OWORD *)(a1 + 1568) = 0u;
          *(_OWORD *)(a1 + 1552) = 0u;
          int v8 = 2;
          goto LABEL_59;
        case 2:
          uint64_t v22 = *(unsigned int *)(a1 + 14352);
          if (v22 != -1) {
            ((void (*)(long long *, uint64_t))off_1EF0A0248[v22])(&v29, a1);
          }
          *(_DWORD *)(a1 + 14352) = -1;
          bzero((void *)a1, 0x5F0uLL);
          *(void *)(a1 + 96) = 0;
          *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A0868;
          *(void *)(a1 + 48) = &unk_1EF0A0940;
          *(void *)(a1 + 56) = &unk_1EF09B980;
          *(void *)(a1 + 64) = 0;
          *(void *)(a1 + 72) = 0;
          *(void *)(a1 + 8sub_19E03D880(&a9, 0) = 0;
          *(void *)(a1 + 104) = 0;
          *(void *)(a1 + 88) = a1 + 96;
          sub_19E03A348(a1 + 112);
          *(_OWORD *)(a1 + 1504) = 0u;
          *(_OWORD *)(a1 + 1488) = 0u;
          int v8 = 1;
          goto LABEL_59;
        case 3:
          uint64_t v23 = *(unsigned int *)(a1 + 14352);
          if (v23 != -1) {
            ((void (*)(long long *, uint64_t))off_1EF0A0248[v23])(&v29, a1);
          }
          *(_DWORD *)(a1 + 14352) = -1;
          bzero((void *)a1, 0x5F8uLL);
          *(void *)(a1 + 104) = 0;
          *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A1508;
          *(void *)(a1 + 48) = &unk_1EF09B9F0;
          *(void *)(a1 + 112) = 0;
          *(void *)(a1 + 88) = 0;
          *(void *)(a1 + 96) = a1 + 104;
          sub_19E03A348(a1 + 120);
          *(_OWORD *)(a1 + 1496) = 0u;
          *(_OWORD *)(a1 + 1512) = 0u;
          int v8 = 6;
          goto LABEL_59;
        case 5:
          goto LABEL_11;
        case 6:
          uint64_t v20 = *(unsigned int *)(a1 + 14352);
          if (v20 != -1) {
            ((void (*)(long long *, uint64_t))off_1EF0A0248[v20])(&v29, a1);
          }
          *(_DWORD *)(a1 + 14352) = -1;
          bzero((void *)a1, 0x608uLL);
          *(void *)(a1 + 12sub_19E03D880(&a9, 0) = 0;
          *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A1288;
          *(void *)(a1 + 56) = &unk_1EF09B980;
          *(void *)(a1 + 64) = 0;
          *(void *)(a1 + 8sub_19E03D880(&a9, 0) = 0;
          *(void *)(a1 + 88) = 0;
          *(void *)(a1 + 72) = 0;
          *(void *)(a1 + 48) = &unk_1EF0A1348;
          *(void *)(a1 + 96) = 0;
          *(void *)(a1 + 104) = 0;
          *(void *)(a1 + 128) = 0;
          *(void *)(a1 + 112) = a1 + 120;
          sub_19E03A348(a1 + 136);
          *(_OWORD *)(a1 + 1512) = 0u;
          *(_OWORD *)(a1 + 1528) = 0u;
          int v8 = 5;
          goto LABEL_59;
        case 7:
          uint64_t v21 = *(unsigned int *)(a1 + 14352);
          if (v21 != -1) {
            ((void (*)(long long *, uint64_t))off_1EF0A0248[v21])(&v29, a1);
          }
          *(_DWORD *)(a1 + 14352) = -1;
          bzero((void *)a1, 0x828uLL);
          *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A0DA8;
          *(void *)(a1 + 48) = &unk_1EF0A0E80;
          bzero((void *)(a1 + 56), 0x252uLL);
          sub_19E0B7598(a1 + 56);
          *(void *)(a1 + 672) = 0;
          *(void *)(a1 + 664) = 0;
          *(void *)(a1 + 656) = a1 + 664;
          sub_19E03A348(a1 + 680);
          *(_OWORD *)(a1 + 2056) = 0u;
          *(_OWORD *)(a1 + 2072) = 0u;
          int v8 = 3;
          goto LABEL_59;
        case 8:
          uint64_t v24 = *(unsigned int *)(a1 + 14352);
          if (v24 != -1) {
            ((void (*)(long long *, uint64_t))off_1EF0A0248[v24])(&v29, a1);
          }
          *(_DWORD *)(a1 + 14352) = -1;
          bzero((void *)a1, 0x608uLL);
          *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF099BA8;
          *(void *)(a1 + 48) = &unk_1EF099A58;
          sub_19E0420AC((void *)(a1 + 64));
          *(void *)(a1 + 12sub_19E03D880(&a9, 0) = 0;
          *(_OWORD *)(a1 + 72) = 0u;
          *(_OWORD *)(a1 + 88) = 0u;
          *(void *)(a1 + 128) = 0;
          *(void *)(a1 + 104) = 0;
          *(void *)(a1 + 112) = a1 + 120;
          sub_19E03A348(a1 + 136);
          *(_OWORD *)(a1 + 1512) = 0u;
          *(_OWORD *)(a1 + 1528) = 0u;
          int v8 = 4;
          goto LABEL_59;
        default:
          exception = __cxa_allocate_exception(0x20uLL);
          sub_19E0413C8(&v29, "unsupported");
          sub_19E08DA70(exception, &v29);
          __cxa_throw(exception, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
      }
    }
    switch(v12)
    {
      case 1:
        uint64_t v15 = *(unsigned int *)(a1 + 14352);
        if (v15 != -1) {
          ((void (*)(long long *, uint64_t))off_1EF0A0248[v15])(&v29, a1);
        }
        *(_DWORD *)(a1 + 14352) = -1;
        bzero((void *)a1, 0x610uLL);
        *(_OWORD *)(a1 + 48) = 0u;
        *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A1760;
        *(_DWORD *)(a1 + 132) = 0;
        *(_OWORD *)(a1 + 64) = 0u;
        sub_19E03A348(a1 + 144);
        *(_OWORD *)(a1 + 1536) = 0u;
        *(_OWORD *)(a1 + 152sub_19E03D880(&a9, 0) = 0u;
        int v8 = 7;
        break;
      case 2:
        uint64_t v19 = *(unsigned int *)(a1 + 14352);
        if (v19 != -1) {
          ((void (*)(long long *, uint64_t))off_1EF0A0248[v19])(&v29, a1);
        }
        *(_DWORD *)(a1 + 14352) = -1;
        bzero((void *)a1, 0x5D0uLL);
        *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A1920;
        *(void *)(a1 + 48) = &unk_1EF09B980;
        *(void *)(a1 + 56) = 0;
        *(void *)(a1 + 64) = 0;
        *(void *)(a1 + 72) = 0;
        sub_19E03A348(a1 + 80);
        *(_OWORD *)(a1 + 1472) = 0u;
        *(_OWORD *)(a1 + 1456) = 0u;
        int v8 = 8;
        break;
      case 6:
        uint64_t v17 = *(unsigned int *)(a1 + 14352);
        if (v17 != -1) {
          ((void (*)(long long *, uint64_t))off_1EF0A0248[v17])(&v29, a1);
        }
        *(_DWORD *)(a1 + 14352) = -1;
        bzero((void *)a1, 0x5E8uLL);
        *(void *)(a1 + 48) = &unk_1EF09B980;
        *(void *)(a1 + 56) = 0;
        *(void *)(a1 + 72) = 0;
        *(void *)(a1 + 8sub_19E03D880(&a9, 0) = 0;
        *(void *)(a1 + 64) = 0;
        *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A1F10;
        *(void *)(a1 + 88) = 0;
        *(void *)(a1 + 96) = 0;
        sub_19E03A348(a1 + 104);
        *(_OWORD *)(a1 + 148sub_19E03D880(&a9, 0) = 0u;
        *(_OWORD *)(a1 + 1496) = 0u;
        int v8 = 11;
        break;
      case 7:
        uint64_t v18 = *(unsigned int *)(a1 + 14352);
        if (v18 != -1) {
          ((void (*)(long long *, uint64_t))off_1EF0A0248[v18])(&v29, a1);
        }
        *(_DWORD *)(a1 + 14352) = -1;
        bzero((void *)a1, 0x808uLL);
        *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A1AE0;
        bzero((void *)(a1 + 48), 0x252uLL);
        sub_19E101108(a1 + 48);
        sub_19E03A348(a1 + 648);
        *(_OWORD *)(a1 + 2024) = 0u;
        *(_OWORD *)(a1 + 204sub_19E03D880(&a9, 0) = 0u;
        int v8 = 9;
        break;
      case 8:
        uint64_t v16 = *(unsigned int *)(a1 + 14352);
        if (v16 != -1) {
          ((void (*)(long long *, uint64_t))off_1EF0A0248[v16])(&v29, a1);
        }
        *(_DWORD *)(a1 + 14352) = -1;
        bzero((void *)a1, 0x5E8uLL);
        *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A1C50;
        sub_19E0420AC((void *)(a1 + 56));
        *(void *)(a1 + 96) = 0;
        *(_OWORD *)(a1 + 64) = 0u;
        *(_OWORD *)(a1 + 8sub_19E03D880(&a9, 0) = 0u;
        sub_19E03A348(a1 + 104);
        *(_OWORD *)(a1 + 148sub_19E03D880(&a9, 0) = 0u;
        *(_OWORD *)(a1 + 1496) = 0u;
        int v8 = 10;
        break;
      default:
        uint64_t v26 = __cxa_allocate_exception(0x20uLL);
        sub_19E0413C8(&v29, "unsupported");
        sub_19E08DA70(v26, &v29);
        __cxa_throw(v26, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
    }
LABEL_59:
    *(_DWORD *)(a1 + 14352) = v8;
    *(void *)&long long v29 = a2;
    *((void *)&v29 + 1) = a3;
  }
  char v28 = &v29;
  return ((uint64_t (*)(long long **, uint64_t))off_1EF0A02B0[v8])(&v28, a1);
}

void sub_19E0406E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t sub_19E040834(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(result + 2) = 16;
  *(unsigned char *)(result + 6) = 1;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 8) = 0;
  if (a2 > 0x7F)
  {
    if (a2 > 0x7FF)
    {
      if (HIWORD(a2))
      {
        unsigned int v3 = (a2 >> 18) | 0xFFFFFFF0;
        *(unsigned char *)(result + 17) = (a2 >> 12) & 0x3F | 0x80;
        unsigned int v4 = 2;
      }
      else
      {
        unsigned int v3 = (a2 >> 12) | 0xFFFFFFE0;
        unsigned int v4 = 1;
      }
      *(unsigned char *)(result + 16) = v3;
      unsigned int v2 = v4 + 1;
      *(unsigned char *)(result + 16 + v4) = (a2 >> 6) & 0x3F | 0x80;
    }
    else
    {
      *(unsigned char *)(result + 16) = (a2 >> 6) | 0xC0;
      unsigned int v2 = 1;
    }
    *(_WORD *)double result = v2 + 1;
    *(unsigned char *)(result + 16 + v2) = a2 & 0x3F | 0x80;
    *(unsigned char *)(result + 16 + v2 + 1) = 0;
  }
  else
  {
    *(unsigned char *)(result + 16) = a2;
    *(_WORD *)double result = 1;
  }
  return result;
}

void sub_19E0408E4(uint64_t a1)
{
}

void *sub_19E0408EC(void *a1, char *a2, int a3)
{
  sub_19E0413C8(__p, a2);
  if (a3) {
    int v5 = 16;
  }
  else {
    int v5 = 0;
  }
  sub_19E039A88((uint64_t)a1, (long long *)__p, v5);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  *a1 = &unk_1EF09C6D0;
  return a1;
}

void sub_19E040968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E040984(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C5A0;
  if (*(unsigned char *)(a1 + 24))
  {
    if (*(unsigned char *)(a1 + 84) && (*(unsigned char *)(a1 + 80) & 2) != 0)
    {
      msync(*(void **)(a1 + 96), *(void *)(a1 + 72), 16);
      *(unsigned char *)(a1 + 84) = 0;
    }
    munmap(*(void **)(a1 + 96), *(void *)(a1 + 72));
  }

  return sub_19E039A20(a1);
}

const void **sub_19E040A10(const void **a1)
{
  unsigned int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

void *sub_19E040A48(void *result)
{
  uint64_t v1 = result;
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_1EB4FEE90, memory_order_acquire) & 1) == 0)
  {
    double result = (void *)__cxa_guard_acquire(qword_1EB4FEE90);
    if (result)
    {
      uint64_t v3 = ucol_open();
      sub_19E0DD934(&qword_1EB4FEF20, v3);
    }
  }
  if (dword_1E94577C8 >= 1) {
    __assert_rtn("getRootCollator", "TIKeyboardCollator.cpp", 78, "U_SUCCESS(error)");
  }
  if (!qword_1EB4FEF20) {
    __assert_rtn("getRootCollator", "TIKeyboardCollator.cpp", 79, "*rootCollator");
  }
  uint64_t v2 = qword_1EB4FEF28;
  *uint64_t v1 = qword_1EB4FEF20;
  v1[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_19E040B34(_Unwind_Exception *a1)
{
}

CFStringRef sub_19E040B4C(uint64_t a1)
{
  uint64_t v1 = (const UInt8 *)a1;
  if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    CFIndex v2 = *(unsigned __int8 *)(a1 + 23);
    if (!*(unsigned char *)(a1 + 23)) {
      return &stru_1EF0A2040;
    }
    return CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, v2, 0x8000100u, 0);
  }
  CFIndex v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v1 = *(const UInt8 **)a1;
    return CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, v2, 0x8000100u, 0);
  }
  return &stru_1EF0A2040;
}

void sub_19E040B98()
{
}

void sub_19E040C24(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA6E0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

BOOL sub_19E040C48(const void *a1, CFURLRef fileURL, CFPropertyListFormat a3, int a4, CFErrorRef *a5)
{
  BOOL v5 = 0;
  if (a1 && fileURL)
  {
    buffer[0] = 0;
    buffer[1] = 0;
    uint64_t v13 = 0;
    if (a4)
    {
      CFURLCreateCopyDeletingLastPathComponent(0, fileURL);
      sub_19E040B98();
    }
    int v9 = CFWriteStreamCreateWithFile(0, fileURL);
    if (v9)
    {
      if (CFWriteStreamOpen(v9))
      {
        CFIndex v10 = CFPropertyListWrite(a1, v9, a3, 0, a5);
        CFWriteStreamClose(v9);
      }
      else
      {
        CFIndex v10 = 0;
      }
      CFRelease(v9);
      BOOL v5 = v10 > 0;
    }
    else
    {
      BOOL v5 = 0;
    }
    if (SHIBYTE(v13) < 0) {
      operator delete(buffer[0]);
    }
  }
  return v5;
}

void sub_19E040E78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_19E040EC0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0)
  {
    sub_19E03FA9C((unsigned char *)a2, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    *(void *)(a2 + 16) = *(void *)(a1 + 16);
  }
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  if (!v3)
  {
    unsigned int v4 = getenv("TMPDIR");
    if (v4) {
      BOOL v5 = v4;
    }
    else {
      BOOL v5 = "/tmp";
    }
    MEMORY[0x19F3BA340](a2, v5);
  }
  std::string::append((std::string *)a2, "/nlptemp-XXXXXX");
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v6 = (char *)a2;
  }
  else {
    uint64_t v6 = *(char **)a2;
  }
  return mktemp(v6);
}

void sub_19E040F68(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

CFPropertyListRef sub_19E040F84(const __CFURL *a1, CFErrorRef *a2)
{
  return sub_19E040F90(a1, 0, a2);
}

CFPropertyListRef sub_19E040F90(CFURLRef fileURL, int a2, CFErrorRef *a3)
{
  uint64_t v6 = CFReadStreamCreateWithFile((CFAllocatorRef)*MEMORY[0x1E4F1CF80], fileURL);
  if (v6)
  {
    BOOL v7 = v6;
    if (CFReadStreamOpen(v6)
      && (!a2 ? (CFOptionFlags v8 = 0) : (CFOptionFlags v8 = 2),
          CFPropertyListRef v9 = CFPropertyListCreateWithStream(0, v7, 0, v8, 0, 0),
          CFReadStreamClose(v7),
          v9))
    {
      CFTypeID v10 = CFGetTypeID(v9);
      if (v10 != CFDictionaryGetTypeID())
      {
        if (a3) {
          *a3 = sub_19E041210(@"Property list at URL is not a dictionary", fileURL);
        }
        CFRelease(v9);
        goto LABEL_15;
      }
    }
    else
    {
      if (!a3)
      {
LABEL_15:
        CFPropertyListRef v9 = 0;
        goto LABEL_16;
      }
      CFPropertyListRef v9 = 0;
      *a3 = sub_19E041210(@"File at URL is not a valid property list", fileURL);
    }
LABEL_16:
    CFRelease(v7);
    return v9;
  }
  CFPropertyListRef v9 = 0;
  if (a3) {
    *a3 = sub_19E041210(@"File at URL is not readable", fileURL);
  }
  return v9;
}

void sub_19E0410CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E041390((const void **)va, 0);
  _Unwind_Resume(a1);
}

CFLocaleRef sub_19E041100(uint64_t a1, const void *a2)
{
  CFStringRef v3 = (const __CFString *)MEMORY[0x19F3B9E50]();
  CFDictionaryRef ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, v3);
  Mutableuint64_t Copy = CFDictionaryCreateMutableCopy(0, 3, ComponentsFromLocaleIdentifier);
  CFDictionarySetValue(MutableCopy, (const void *)*MEMORY[0x1E4F1D218], a2);
  CFStringRef LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents(0, MutableCopy);
  CFLocaleRef v7 = CFLocaleCreate(0, LocaleIdentifierFromComponents);
  if (LocaleIdentifierFromComponents) {
    CFRelease(LocaleIdentifierFromComponents);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (ComponentsFromLocaleIdentifier) {
    CFRelease(ComponentsFromLocaleIdentifier);
  }
  return v7;
}

void sub_19E0411CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  CFStringRef v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  BOOL v5 = va_arg(va2, const void *);
  sub_19E03D880((const void **)va, 0);
  sub_19E041344((const void **)va1, 0);
  sub_19E041524((const void **)va2, 0);
  _Unwind_Resume(a1);
}

CFErrorRef sub_19E041210(uint64_t a1, CFURLRef anURL)
{
  CFStringRef v3 = CFURLCopyPath(anURL);
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@: %@", a1, v3);
  Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F1D170], v5);
  CFErrorRef v7 = CFErrorCreate(v4, @"com.apple.NLPUtils.ErrorDomain", 0, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v3) {
    CFRelease(v3);
  }
  return v7;
}

void sub_19E041304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  CFStringRef v5 = va_arg(va1, const void *);
  sub_19E03D880((const void **)va, 0);
  sub_19E03D880((const void **)va1, 0);
  _Unwind_Resume(a1);
}

void sub_19E041344(const void **a1, const void *a2)
{
  CFAllocatorRef v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

void sub_19E04137C(void *a1)
{
}

void sub_19E041390(const void **a1, const void *a2)
{
  CFAllocatorRef v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

void *sub_19E0413C8(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E04147C();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void sub_19E04147C()
{
}

void sub_19E041494(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_19E0414F0(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E599B420, MEMORY[0x1E4FBA1C8]);
}

void sub_19E0414DC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_19E0414F0(std::logic_error *a1, const char *a2)
{
  double result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void sub_19E041524(const void **a1, const void *a2)
{
  size_t v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

uint64_t sub_19E04155C()
{
  return atomic_load((unsigned int *)&unk_1E9457290);
}

uint64_t sub_19E04156C(uint64_t result)
{
  return result;
}

void sub_19E04157C()
{
  if (!dword_1E945726C)
  {
    v0 = sub_19E0415C4(MEMORY[0x1E4FBA240], "Program terminated with an unrecoverable error.");
    sub_19E04160C(v0);
    exit(-1);
  }
  dword_1E945726C = 2;
}

void *sub_19E0415C4(void *a1, char *__s)
{
  size_t v4 = strlen(__s);

  return sub_19E0416F8(a1, (uint64_t)__s, v4);
}

void *sub_19E04160C(void *a1)
{
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
  CFIndex v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  std::ostream::flush();
  return a1;
}

void sub_19E0416B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void sub_19E0416C4()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

void *sub_19E0416F8(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x19F3BA4C0](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      CFTypeID v10 = std::locale::use_facet(&v14, MEMORY[0x1E4FBA258]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!sub_19E04189C(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x19F3BA4D0](v13);
  return a1;
}

void sub_19E041834(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x19F3BA4D0](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x19E041814);
}

void sub_19E041888(_Unwind_Exception *a1)
{
}

uint64_t sub_19E04189C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      sub_19E041A24(__p, v12, __c);
      uint64_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_19E041A08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E041A24(void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E04147C();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

void sub_19E041AD0(void ***a1)
{
  CFIndex v2 = *a1;
  if (*v2)
  {
    sub_19E041B24((uint64_t *)v2);
    CFStringRef v3 = **a1;
    operator delete(v3);
  }
}

void sub_19E041B24(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

uint64_t sub_19E041B74(uint64_t *a1, void *a2)
{
  uint64_t result = sub_19E041C4C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void sub_19E041BEC()
{
}

void *sub_19E041C04(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_19E0416C4();
  }
  return operator new(24 * a2);
}

uint64_t sub_19E041C4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }
  char v13 = 1;
  sub_19E041CEC((uint64_t)v12);
  return a6;
}

uint64_t sub_19E041CEC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_19E041D24(a1);
  }
  return a1;
}

void sub_19E041D24(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 24;
  }
}

uint64_t sub_19E041D6C(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_19E041DA4(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

std::string *sub_19E041DFC(std::string *this, char *a2, char *a3)
{
  std::locale v4 = a2;
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  unint64_t v7 = a3 - a2;
  if ((v6 & 0x80000000) != 0)
  {
    if (a3 == a2) {
      return this;
    }
    std::string::size_type size = this->__r_.__value_.__l.__size_;
    unint64_t v11 = this->__r_.__value_.__r.__words[2];
    std::string::size_type v9 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    long long v10 = (std::string *)this->__r_.__value_.__r.__words[0];
    unint64_t v6 = HIBYTE(v11);
  }
  else
  {
    if (a3 == a2) {
      return this;
    }
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v9 = 22;
    long long v10 = this;
  }
  if (v10 > (std::string *)v4 || (char *)&v10->__r_.__value_.__l.__data_ + size + 1 <= v4)
  {
    if (v9 - size < v7)
    {
      std::string::__grow_by(this, v9, size - v9 + v7, size, size, 0, 0);
      this->__r_.__value_.__l.__size_ = size;
      LOBYTE(v6) = *((unsigned char *)&this->__r_.__value_.__s + 23);
    }
    long long v14 = this;
    if ((v6 & 0x80) != 0) {
      long long v14 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    for (uint64_t i = (char *)v14 + size; v4 != a3; ++i)
    {
      char v16 = *v4++;
      *uint64_t i = v16;
    }
    *uint64_t i = 0;
    std::string::size_type v17 = v7 + size;
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
      this->__r_.__value_.__l.__size_ = v17;
    }
    else {
      *((unsigned char *)&this->__r_.__value_.__s + 23) = v17 & 0x7F;
    }
  }
  else
  {
    sub_19E041FD0(__p, v4, a3, v7);
    if ((v20 & 0x80u) == 0) {
      int64_t v12 = __p;
    }
    else {
      int64_t v12 = (void **)__p[0];
    }
    if ((v20 & 0x80u) == 0) {
      std::string::size_type v13 = v20;
    }
    else {
      std::string::size_type v13 = (std::string::size_type)__p[1];
    }
    std::string::append(this, (const std::string::value_type *)v12, v13);
    if ((char)v20 < 0) {
      operator delete(__p[0]);
    }
  }
  return this;
}

void sub_19E041F58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E041F74(const char *a1)
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  sub_19E042078(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E599B418, MEMORY[0x1E4FBA1B8]);
}

void sub_19E041FBC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_19E041FD0(void *result, char *a2, char *a3, unint64_t a4)
{
  std::locale v4 = result;
  if (a4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E04147C();
  }
  if (a4 > 0x16)
  {
    uint64_t v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17) {
      uint64_t v8 = a4 | 7;
    }
    uint64_t v9 = v8 + 1;
    uint64_t result = operator new(v8 + 1);
    v4[1] = a4;
    v4[2] = v9 | 0x8000000000000000;
    *std::locale v4 = result;
    std::locale v4 = result;
  }
  else
  {
    *((unsigned char *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    char v10 = *a2++;
    *(unsigned char *)std::locale v4 = v10;
    std::locale v4 = (void *)((char *)v4 + 1);
  }
  *(unsigned char *)std::locale v4 = 0;
  return result;
}

std::runtime_error *sub_19E042078(std::runtime_error *a1, const char *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
  return result;
}

void *sub_19E0420AC(void *result)
{
  *uint64_t result = 0;
  return result;
}

void *sub_19E0420B8(uint64_t *a1, uint64_t *a2, void *a3, unsigned int a4)
{
  uint64_t v8 = operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
  if (!v8)
  {
    uint64_t v13 = 0;
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x800000014;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:20: MARISA_"
                   "MEMORY_ERROR: temp.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  uint64_t v9 = (uint64_t)v8;
  sub_19E04348C((uint64_t)v8);
  uint64_t v13 = v9;
  sub_19E0436F8(v9, a2, a3, a4);
  uint64_t v10 = *a1;
  *a1 = v9;
  uint64_t v13 = v10;
  return sub_19E04297C(&v13);
}

void sub_19E0421B0(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA700](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

void *sub_19E0421E0(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x200000029;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:41: MARISA_"
                   "NULL_ERROR: (ptr == NULL) && (size != 0)";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  unint64_t v6 = operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
  if (!v6)
  {
    uint64_t v13 = 0;
    unint64_t v11 = __cxa_allocate_exception(0x20uLL);
    void *v11 = &unk_1EF099E88;
    v11[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    v11[2] = 0x80000002CLL;
    v11[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:44: MARISA_MEMORY"
             "_ERROR: temp.get() == NULL";
    __cxa_throw(v11, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  uint64_t v7 = (uint64_t)v6;
  sub_19E04348C((uint64_t)v6);
  uint64_t v13 = v7;
  sub_19E042E80((uint64_t)v12);
  sub_19E042F2C(v12, a2, a3);
  sub_19E043C44(v13, (uint64_t *)v12);
  uint64_t v8 = *a1;
  *a1 = v13;
  uint64_t v13 = v8;
  sub_19E042EE4(v12);
  return sub_19E04297C(&v13);
}

void sub_19E04234C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_19E04297C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E04238C(uint64_t *a1, uint64_t a2)
{
  if (!*a1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x100000064;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:100: MARISA"
                   "_STATE_ERROR: trie_.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  sub_19E0429C0((uint64_t)v6);
  sub_19E042A0C((uint64_t)v6, a2);
  sub_19E043F48(*a1, (uint64_t)v6);
  return sub_19E0429D8((uint64_t)v6);
}

void sub_19E042448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E04245C(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a1;
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x10000006DLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:109: MARISA"
                   "_STATE_ERROR: trie_.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }

  return sub_19E044060(v3, a2, a3);
}

uint64_t sub_19E0424E8(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v4 = *a1;
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x100000073;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:115: MARISA"
                   "_STATE_ERROR: trie_.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }

  return sub_19E044BD8(v4, a2, a3, a4);
}

void sub_19E042574(uint64_t *a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X8>)
{
  uint64_t v3 = *a1;
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x100000079;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:121: MARISA"
                   "_STATE_ERROR: trie_.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }

  sub_19E044EE8(v3, a2, a3);
}

uint64_t sub_19E042600(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x10000007FLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:127: MARISA"
                   "_STATE_ERROR: trie_.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }

  return sub_19E04519C(v4, a2, a3, a4);
}

void sub_19E04268C(unint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = *a1;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x100000086;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:134: MARISA"
                   "_STATE_ERROR: trie_.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }

  sub_19E0440CC(v5, a2, a3, a4, a5);
}

void sub_19E042718(uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v5 = *a1;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x10000008CLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:140: MARISA"
                   "_STATE_ERROR: trie_.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }

  sub_19E046478(v5, a2, a3, a4, a5);
}

void sub_19E0427A4(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *a1;
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x100000093;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:147: MARISA"
                   "_STATE_ERROR: trie_.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }

  sub_19E0446D4(v4, a2, a3, a4);
}

void sub_19E042830(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x100000099;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:153: MARISA"
                   "_STATE_ERROR: trie_.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }

  sub_19E044834(v3, a2, a3);
}

uint64_t sub_19E0428BC(uint64_t a1)
{
  if (!*(void *)a1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc";
    exception[2] = 0x1000000C3;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/trie.cc:195: MARISA"
                   "_STATE_ERROR: trie_.get() == NULL";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  return *(void *)(*(void *)a1 + 264);
}

void sub_19E04293C(std::exception *a1)
{
  std::exception::~exception(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E042974(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

void *sub_19E04297C(void *a1)
{
  if (*a1)
  {
    uint64_t v2 = sub_19E0436F4();
    MEMORY[0x19F3BA710](v2, 0x10F0C4010279AD7);
  }
  return a1;
}

uint64_t sub_19E0429C0(uint64_t result)
{
  *(void *)uint64_t result = 0;
  *(_DWORD *)(result + 8) = -1;
  *(void *)(result + 16) = 0;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

uint64_t sub_19E0429D8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24)) {
    fclose(*(FILE **)a1);
  }
  return a1;
}

FILE *sub_19E042A0C(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(FILE **)a1;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = -1;
  *(void *)(a1 + 16) = a2;
  int v4 = *(unsigned __int8 *)(a1 + 24);
  *(unsigned char *)(a1 + 24) = 0;
  if (v4) {
    return (FILE *)fclose(result);
  }
  return result;
}

uint64_t sub_19E042A38(uint64_t result, size_t __nitems)
{
  size_t v2 = __nitems;
  uint64_t v3 = result;
  __buf[128] = *MEMORY[0x1E4F143B8];
  if (!*(void *)result && *(_DWORD *)(result + 8) == -1 && !*(void *)(result + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x10000004FLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer."
                   "cc:79: MARISA_STATE_ERROR: !is_open()";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  if (__nitems)
  {
    if (__nitems > 0x10)
    {
      bzero(__buf, 0x400uLL);
      do
      {
        if (v2 >= 0x400) {
          size_t v4 = 1024;
        }
        else {
          size_t v4 = v2;
        }
        uint64_t result = sub_19E042B74(v3, (char *)__buf, v4);
        v2 -= v4;
      }
      while (v2);
    }
    else
    {
      __buf[0] = 0;
      __buf[1] = 0;
      return sub_19E042B74(result, (char *)__buf, __nitems);
    }
  }
  return result;
}

uint64_t sub_19E042B74(uint64_t result, char *__buf, size_t __nitems)
{
  size_t v3 = __nitems;
  size_t v4 = __buf;
  uint64_t v5 = result;
  unint64_t v6 = *(FILE **)result;
  if (!*(void *)result && *(_DWORD *)(result + 8) == -1 && !*(void *)(result + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x100000076;
    uint64_t v9 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.cc:118: MA"
         "RISA_STATE_ERROR: !is_open()";
    goto LABEL_20;
  }
  if (__nitems)
  {
    if (*(_DWORD *)(result + 8) != -1)
    {
      while (1)
      {
        size_t v7 = v3 >= 0x7FFFFFFFFFFFFFFFLL ? 0x7FFFFFFFFFFFFFFFLL : v3;
        uint64_t result = write(*(_DWORD *)(v5 + 8), v4, v7);
        if (result <= 0) {
          break;
        }
        v4 += result;
        v3 -= result;
        if (!v3) {
          return result;
        }
      }
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1EF099E88;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.cc";
      exception[2] = 0x900000084;
      uint64_t v9 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.cc:132: "
           "MARISA_IO_ERROR: size_written <= 0";
LABEL_20:
      exception[3] = v9;
      __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
    }
    if (v6)
    {
      if (fwrite(__buf, 1uLL, __nitems, v6) != __nitems)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        void *exception = &unk_1EF099E88;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.cc";
        exception[2] = 0x900000089;
        uint64_t v9 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.cc:137"
             ": MARISA_IO_ERROR: ::fwrite(data, 1, size, file_) != size";
        goto LABEL_20;
      }
      uint64_t result = fflush(*(FILE **)v5);
      if (result)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        void *exception = &unk_1EF099E88;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.cc";
        exception[2] = 0x90000008ALL;
        uint64_t v9 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.cc:138"
             ": MARISA_IO_ERROR: ::fflush(file_) != 0";
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t result = *(void *)(result + 16);
      if (result)
      {
        uint64_t result = std::ostream::write();
        if ((*(unsigned char *)(result + *(void *)(*(void *)result - 24) + 32) & 5) != 0)
        {
          uint64_t v10 = __cxa_allocate_exception(0x20uLL);
          *uint64_t v10 = &unk_1EF099E88;
          v10[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.cc";
          _DWORD v10[2] = 0x90000008FLL;
          v10[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer."
                   "cc:143: MARISA_IO_ERROR: !stream_->write(static_cast<const char*>(data), static_cast<std::streamsize>(size))";
          __cxa_throw(v10, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
        }
      }
    }
  }
  return result;
}

void sub_19E042DF0()
{
}

void sub_19E042E6C()
{
}

uint64_t sub_19E042E80(uint64_t result)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = -1;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(_DWORD *)(result + 32) = -1;
  return result;
}

uint64_t sub_19E042E98(uint64_t a1)
{
  size_t v2 = *(void **)(a1 + 8);
  if (v2 != (void *)-1) {
    munmap(v2, *(void *)(a1 + 24));
  }
  int v3 = *(_DWORD *)(a1 + 32);
  if (v3 != -1) {
    close(v3);
  }
  return a1;
}

uint64_t *sub_19E042EE8(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *uint64_t result = *a2;
  *a2 = v2;
  uint64_t v4 = result[1];
  uint64_t v3 = result[2];
  uint64_t v5 = a2[2];
  result[1] = a2[1];
  result[2] = v5;
  a2[1] = v4;
  a2[2] = v3;
  uint64_t v6 = result[3];
  result[3] = a2[3];
  a2[3] = v6;
  LODWORD(v6) = *((_DWORD *)result + 8);
  *((_DWORD *)result + 8) = *((_DWORD *)a2 + 8);
  *((_DWORD *)a2 + 8) = v6;
  return result;
}

uint64_t sub_19E042F2C(long long *a1, uint64_t a2, uint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x200000050;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper."
                   "cc:80: MARISA_NULL_ERROR: (ptr == NULL) && (size != 0)";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  long long v3 = *a1;
  long long v4 = a1[1];
  *(void *)a1 = a2;
  *((void *)a1 + 1) = -1;
  *((void *)a1 + 2) = a3;
  *((void *)a1 + 3) = 0;
  v8[0] = v3;
  v8[1] = v4;
  int v5 = *((_DWORD *)a1 + 8);
  *((_DWORD *)a1 + 8) = -1;
  int v9 = v5;
  return sub_19E042E98((uint64_t)v8);
}

uint64_t sub_19E042FDC(uint64_t *a1, unint64_t a2)
{
  if (!*a1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x100000059;
    long long v4 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.cc:89: MAR"
         "ISA_STATE_ERROR: !is_open()";
    goto LABEL_8;
  }
  if (a1[2] < a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x90000005ALL;
    long long v4 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.cc:90: MAR"
         "ISA_IO_ERROR: size > avail_";
LABEL_8:
    exception[3] = v4;
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }

  return sub_19E0430B8(a1, a2);
}

uint64_t sub_19E0430B8(uint64_t *a1, unint64_t a2)
{
  uint64_t v2 = *a1;
  if (!*a1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x100000073;
    uint64_t v8 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.cc:115: MA"
         "RISA_STATE_ERROR: !is_open()";
LABEL_6:
    exception[3] = v8;
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  unint64_t v3 = a1[2];
  BOOL v4 = v3 >= a2;
  unint64_t v5 = v3 - a2;
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x900000074;
    uint64_t v8 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.cc:116: MA"
         "RISA_IO_ERROR: size > avail_";
    goto LABEL_6;
  }
  *a1 = v2 + a2;
  a1[2] = v5;
  return v2;
}

uint64_t sub_19E043194(uint64_t a1)
{
  *(_OWORD *)(a1 + 25) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 137) = 0u;
  *(_OWORD *)(a1 + 16sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 185) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 89) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 233) = 0u;
  *(_OWORD *)(a1 + 32sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 345) = 0u;
  *(_OWORD *)(a1 + 393) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 297) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 441) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 553) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 601) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 505) = 0u;
  *(_OWORD *)(a1 + 48sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 649) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 64sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 697) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(void *)(a1 + 72sub_19E03D880(&a9, 0) = 0;
  *(_DWORD *)(a1 + 728) = 0;
  *(void *)(a1 + 736) = 0;
  sub_19E04D198((_OWORD *)(a1 + 744));
  *(unsigned char *)(a1 + 1048) = 0;
  *(_OWORD *)(a1 + 1016) = 0u;
  *(_OWORD *)(a1 + 1032) = 0u;
  *(_OWORD *)(a1 + 100sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(void *)(a1 + 1072) = 3;
  *(void *)(a1 + 108sub_19E03D880(&a9, 0) = 0x100000000200;
  *(_DWORD *)(a1 + 1088) = 0x20000;
  sub_19E042E80(a1 + 1096);
  return a1;
}

void sub_19E0432B8(_Unwind_Exception *a1)
{
  uint64_t v9 = v1[126];
  if (v9) {
    MEMORY[0x19F3BA6E0](v9, 0x1000C8077774924);
  }
  sub_19E04297C(v5);
  sub_19E043348(v4);
  if (*v7) {
    MEMORY[0x19F3BA6E0](*v7, 0x1000C8077774924);
  }
  if (*v6) {
    MEMORY[0x19F3BA6E0](*v6, 0x1000C8077774924);
  }
  sub_19E0433F8(v3);
  sub_19E0433F8(v2);
  sub_19E0433F8(v1);
  _Unwind_Resume(a1);
}

void *sub_19E043348(void *a1)
{
  uint64_t v2 = a1[26];
  if (v2) {
    MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
  }
  uint64_t v3 = a1[20];
  if (v3) {
    MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  uint64_t v4 = a1[14];
  if (v4) {
    MEMORY[0x19F3BA6E0](v4, 0x1000C8077774924);
  }
  uint64_t v5 = a1[6];
  if (v5) {
    MEMORY[0x19F3BA6E0](v5, 0x1000C8077774924);
  }
  if (*a1) {
    MEMORY[0x19F3BA6E0](*a1, 0x1000C8077774924);
  }
  return a1;
}

void *sub_19E0433F8(void *a1)
{
  uint64_t v2 = a1[20];
  if (v2) {
    MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
  }
  uint64_t v3 = a1[14];
  if (v3) {
    MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  uint64_t v4 = a1[8];
  if (v4) {
    MEMORY[0x19F3BA6E0](v4, 0x1000C8077774924);
  }
  if (*a1) {
    MEMORY[0x19F3BA6E0](*a1, 0x1000C8077774924);
  }
  return a1;
}

void *sub_19E043490(void *a1)
{
  sub_19E042EE4(a1 + 137);
  uint64_t v2 = a1[126];
  if (v2) {
    MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
  }
  sub_19E04297C(a1 + 125);
  uint64_t v3 = a1[119];
  if (v3) {
    MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  uint64_t v4 = a1[113];
  if (v4) {
    MEMORY[0x19F3BA6E0](v4, 0x1000C8077774924);
  }
  uint64_t v5 = a1[107];
  if (v5) {
    MEMORY[0x19F3BA6E0](v5, 0x1000C8077774924);
  }
  uint64_t v6 = a1[99];
  if (v6) {
    MEMORY[0x19F3BA6E0](v6, 0x1000C8077774924);
  }
  uint64_t v7 = a1[93];
  if (v7) {
    MEMORY[0x19F3BA6E0](v7, 0x1000C8077774924);
  }
  uint64_t v8 = a1[84];
  if (v8) {
    MEMORY[0x19F3BA6E0](v8, 0x1000C8077774924);
  }
  uint64_t v9 = a1[78];
  if (v9) {
    MEMORY[0x19F3BA6E0](v9, 0x1000C8077774924);
  }
  uint64_t v10 = a1[72];
  if (v10) {
    MEMORY[0x19F3BA6E0](v10, 0x1000C8077774924);
  }
  uint64_t v11 = a1[66];
  if (v11) {
    MEMORY[0x19F3BA6E0](v11, 0x1000C8077774924);
  }
  uint64_t v12 = a1[60];
  if (v12) {
    MEMORY[0x19F3BA6E0](v12, 0x1000C8077774924);
  }
  uint64_t v13 = a1[52];
  if (v13) {
    MEMORY[0x19F3BA6E0](v13, 0x1000C8077774924);
  }
  uint64_t v14 = a1[46];
  if (v14) {
    MEMORY[0x19F3BA6E0](v14, 0x1000C8077774924);
  }
  uint64_t v15 = a1[40];
  if (v15) {
    MEMORY[0x19F3BA6E0](v15, 0x1000C8077774924);
  }
  uint64_t v16 = a1[34];
  if (v16) {
    MEMORY[0x19F3BA6E0](v16, 0x1000C8077774924);
  }
  uint64_t v17 = a1[26];
  if (v17) {
    MEMORY[0x19F3BA6E0](v17, 0x1000C8077774924);
  }
  uint64_t v18 = a1[20];
  if (v18) {
    MEMORY[0x19F3BA6E0](v18, 0x1000C8077774924);
  }
  uint64_t v19 = a1[14];
  if (v19) {
    MEMORY[0x19F3BA6E0](v19, 0x1000C8077774924);
  }
  uint64_t v20 = a1[8];
  if (v20) {
    MEMORY[0x19F3BA6E0](v20, 0x1000C8077774924);
  }
  if (*a1) {
    MEMORY[0x19F3BA6E0](*a1, 0x1000C8077774924);
  }
  return a1;
}

void *sub_19E0436F8(uint64_t a1, uint64_t *a2, void *a3, unsigned int a4)
{
  uint64_t v8 = 3;
  uint64_t v9 = 0x100000000200;
  int v10 = 0x20000;
  sub_19E046DA0(&v8, a4);
  v11[0] = v8;
  v11[1] = v9;
  int v12 = v10;
  sub_19E043194((uint64_t)&v8);
  sub_19E0437B4((uint64_t)&v8, a2, a3, (uint64_t)v11);
  sub_19E043B2C(a1, (uint64_t)&v8);
  return sub_19E043490(&v8);
}

void sub_19E0437A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E043490((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0437B4(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  memset(v36, 0, 41);
  sub_19E045398((uint64_t *)v36, (a2[1] - *a2) >> 4);
  uint64_t v8 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      uint64_t v12 = *((void *)&v36[0] + 1) + v10;
      uint64_t v13 = (uint64_t *)(v8 + v9);
      uint64_t v15 = *v13;
      uint64_t v14 = v13[1];
      *(void *)uint64_t v12 = v15;
      *(_DWORD *)(v12 + 8) = v14;
      *(_DWORD *)(v12 + 12) = 1065353216;
      ++v11;
      uint64_t v8 = *a2;
      v10 += 24;
      v9 += 16;
    }
    while (v11 < (a2[1] - *a2) >> 4);
  }
  long long v34 = 0u;
  memset(v35, 0, 25);
  sub_19E045428(a1, (uint64_t *)v36, &v34, a4, 1);
  memset(v33, 0, 41);
  sub_19E04560C((uint64_t *)v33, v35[1]);
  unint64_t v16 = *((void *)&v33[1] + 1);
  if (*((void *)&v33[1] + 1))
  {
    uint64_t v17 = 0;
    uint64_t v18 = *((void *)&v34 + 1);
    uint64_t v19 = (_DWORD *)(*((void *)&v33[0] + 1) + 4);
    do
    {
      *(v19 - 1) = *(_DWORD *)(v18 + 4 * v17);
      _DWORD *v19 = v17++;
      v19 += 2;
    }
    while (v16 != v17);
  }
  uint64_t v20 = v34;
  long long v34 = 0u;
  memset(v35, 0, 25);
  if (v20)
  {
    MEMORY[0x19F3BA6E0](v20, 0x1000C8077774924);
    unint64_t v16 = *((void *)&v33[1] + 1);
  }
  unint64_t v21 = 126 - 2 * __clz(v16);
  if (v16) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  sub_19E04AD70(*((uint64_t *)&v33[0] + 1), (unsigned int *)(*((void *)&v33[0] + 1) + 8 * v16), (uint64_t)&v37, v22, 1);
  if (*((void *)&v33[1] + 1))
  {
    unint64_t v23 = 0;
    unint64_t v24 = 0;
    do
    {
      for (uint64_t i = *((void *)&v33[0] + 1); ; uint64_t i = *((void *)&v33[0] + 1))
      {
        unint64_t v26 = *(unsigned int *)(i + 8 * v23);
        if (v24 >= v26) {
          break;
        }
        sub_19E045680((uint64_t *)(a1 + 208), 0);
        ++v24;
      }
      if (v24 == v26)
      {
        sub_19E045680((uint64_t *)(a1 + 208), 1);
        ++v24;
      }
      ++v23;
    }
    while (v23 < *((void *)&v33[1] + 1));
  }
  else
  {
    unint64_t v24 = 0;
  }
  for (; v24 < *(void *)(a1 + 648); ++v24)
    sub_19E045680((uint64_t *)(a1 + 208), 0);
  unsigned __int8 v27 = (uint64_t *)(a1 + 208);
  sub_19E045680(v27, 0);
  sub_19E045778((uint64_t)v27, 0, 1);
  if (a3)
  {
    sub_19E0458B8((uint64_t)a3, (a2[1] - *a2) >> 4);
    if (a2[1] != *a2)
    {
      uint64_t v28 = 0;
      unint64_t v29 = 0;
      uint64_t v30 = *((void *)&v33[0] + 1);
      do
      {
        uint64_t v31 = sub_19E04E2B8((uint64_t)v27, *(unsigned int *)(v30 + v28));
        uint64_t v30 = *((void *)&v33[0] + 1);
        *(void *)(*a3 + 8 * *(unsigned int *)(*((void *)&v33[0] + 1) + v28 + 4)) = v31;
        ++v29;
        v28 += 8;
      }
      while (v29 < (a2[1] - *a2) >> 4);
    }
  }
  if (*(void *)&v33[0]) {
    MEMORY[0x19F3BA6E0](*(void *)&v33[0], 0x1000C8077774924);
  }
  if ((void)v34) {
    MEMORY[0x19F3BA6E0](v34, 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v36[0];
  if (*(void *)&v36[0]) {
    return MEMORY[0x19F3BA6E0](*(void *)&v36[0], 0x1000C8077774924);
  }
  return result;
}

void sub_19E043AA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a15) {
    MEMORY[0x19F3BA6E0](a15, 0x1000C8077774924);
  }
  if (a21) {
    MEMORY[0x19F3BA6E0](a21, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_19E043B2C(uint64_t a1, uint64_t a2)
{
  sub_19E0452CC((uint64_t *)a1, (uint64_t *)a2);
  sub_19E0452CC((uint64_t *)(a1 + 208), (uint64_t *)(a2 + 208));
  sub_19E0452CC((uint64_t *)(a1 + 416), (uint64_t *)(a2 + 416));
  sub_19E045344((uint64_t *)(a1 + 624), (uint64_t *)(a2 + 624));
  sub_19E045344((uint64_t *)(a1 + 672), (uint64_t *)(a2 + 672));
  uint64_t v4 = *(void *)(a1 + 720);
  *(void *)(a1 + 72sub_19E03D880(&a9, 0) = *(void *)(a2 + 720);
  *(void *)(a2 + 72sub_19E03D880(&a9, 0) = v4;
  LODWORD(v4) = *(_DWORD *)(a1 + 728);
  *(_DWORD *)(a1 + 728) = *(_DWORD *)(a2 + 728);
  *(_DWORD *)(a2 + 728) = v4;
  uint64_t v5 = *(void *)(a1 + 736);
  *(void *)(a1 + 736) = *(void *)(a2 + 736);
  *(void *)(a2 + 736) = v5;
  sub_19E04D7A8((uint64_t *)(a1 + 744), (uint64_t *)(a2 + 744));
  uint64_t v6 = *(void *)(a1 + 1000);
  *(void *)(a1 + 100sub_19E03D880(&a9, 0) = *(void *)(a2 + 1000);
  *(void *)(a2 + 100sub_19E03D880(&a9, 0) = v6;
  sub_19E045344((uint64_t *)(a1 + 1008), (uint64_t *)(a2 + 1008));
  uint64_t v7 = *(void *)(a1 + 1056);
  *(void *)(a1 + 1056) = *(void *)(a2 + 1056);
  *(void *)(a2 + 1056) = v7;
  uint64_t v8 = *(void *)(a1 + 1064);
  *(void *)(a1 + 1064) = *(void *)(a2 + 1064);
  *(void *)(a2 + 1064) = v8;
  uint64_t v9 = *(void *)(a1 + 1072);
  *(void *)(a1 + 1072) = *(void *)(a2 + 1072);
  *(void *)(a2 + 1072) = v9;
  uint64_t v10 = *(void *)(a1 + 1080);
  *(void *)(a1 + 108sub_19E03D880(&a9, 0) = *(void *)(a2 + 1080);
  *(void *)(a2 + 108sub_19E03D880(&a9, 0) = v10;
  LODWORD(v9) = *(_DWORD *)(a1 + 1088);
  *(_DWORD *)(a1 + 1088) = *(_DWORD *)(a2 + 1088);
  *(_DWORD *)(a2 + 1088) = v9;

  return sub_19E042EE8((uint64_t *)(a1 + 1096), (uint64_t *)(a2 + 1096));
}

void *sub_19E043C44(uint64_t a1, uint64_t *a2)
{
  sub_19E043CCC((uint64_t)v5, a2);
  sub_19E043194((uint64_t)v5);
  sub_19E043D8C((uint64_t)v5, a2);
  sub_19E042EE8(v6, a2);
  sub_19E043B2C(a1, (uint64_t)v5);
  return sub_19E043490(v5);
}

void sub_19E043CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unsigned char *sub_19E043CCC(uint64_t a1, uint64_t *a2)
{
  uint64_t result = (unsigned char *)sub_19E0430B8(a2, 0x10uLL);
  if (*result != 87) {
    goto LABEL_7;
  }
  uint64_t v3 = 1u;
  do
  {
    if (v3 == 16) {
      return result;
    }
    int v4 = result[v3];
    int v5 = aWeLoveMarisa[v3++];
  }
  while (v4 == v5);
  if ((unint64_t)(v3 - 2) <= 0xE)
  {
LABEL_7:
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/header.h";
    exception[2] = 0xA00000015;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/heade"
                   "r.h:21: MARISA_FORMAT_ERROR: !test_header(ptr)";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  return result;
}

double sub_19E043D8C(uint64_t a1, uint64_t *a2)
{
  sub_19E046110((uint64_t *)a1, a2);
  sub_19E046110((uint64_t *)(a1 + 208), a2);
  sub_19E046110((uint64_t *)(a1 + 416), a2);
  sub_19E0461FC((long long *)(a1 + 624), a2);
  sub_19E0462BC((long long *)(a1 + 672), a2);
  sub_19E04D7E8(a1 + 744, a2);
  if (*(void *)(a1 + 472) && !*(void *)(a1 + 768))
  {
    int v4 = operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
    int v5 = v4;
    if (v4) {
      sub_19E043194((uint64_t)v4);
    }
    uint64_t v10 = *(void *)(a1 + 1000);
    *(void *)(a1 + 100sub_19E03D880(&a9, 0) = v5;
    sub_19E04297C(&v10);
    uint64_t v6 = *(void *)(a1 + 1000);
    if (!v6)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1EF099E88;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x800000249;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/lou"
                     "ds-trie.cc:585: MARISA_MEMORY_ERROR: next_trie_.get() == NULL";
      __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
    }
    sub_19E043D8C(v6, a2);
  }
  sub_19E0463B8((long long *)(a1 + 1008), a2);
  *(void *)(a1 + 1056) = *(void *)(a1 + 1032) - 1;
  *(void *)(a1 + 1064) = *(unsigned int *)sub_19E0430B8(a2, 4uLL);
  unsigned int v7 = *(_DWORD *)sub_19E0430B8(a2, 4uLL);
  uint64_t v10 = 3;
  *(void *)&double v11 = 0x100000000200;
  int v12 = 0x20000;
  sub_19E046DA0(&v10, v7);
  *(void *)(a1 + 1072) = v10;
  double result = v11;
  *(double *)(a1 + 108sub_19E03D880(&a9, 0) = v11;
  *(_DWORD *)(a1 + 1088) = v12;
  return result;
}

void sub_19E043F2C(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA700](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

uint64_t sub_19E043F48(uint64_t a1, uint64_t a2)
{
  sub_19E042B74(a2, "We love Marisa.", 0x10uLL);

  return sub_19E043F98(a1, a2);
}

uint64_t sub_19E043F98(uint64_t a1, uint64_t a2)
{
  sub_19E047E6C(a1, a2);
  sub_19E047E6C(a1 + 208, a2);
  sub_19E047E6C(a1 + 416, a2);
  sub_19E04D0B0(a1 + 624, a2);
  sub_19E0482C0(a1 + 672, a2);
  sub_19E04D954(a1 + 744, a2);
  uint64_t v4 = *(void *)(a1 + 1000);
  if (v4) {
    sub_19E043F98(v4, a2);
  }
  sub_19E04802C(a1 + 1008, a2);
  int __buf = *(void *)(a1 + 1064);
  sub_19E042B74(a2, (char *)&__buf, 4uLL);
  int v6 = *(_DWORD *)(a1 + 1084) | *(_DWORD *)(a1 + 1072) | *(_DWORD *)(a1 + 1088);
  return sub_19E042B74(a2, (char *)&v6, 4uLL);
}

uint64_t sub_19E044060(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 31);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 16);
  }
  if (v3) {
    return 0;
  }
  unint64_t v5 = *(void *)a2;
  if (((*(void *)(*(void *)(a1 + 224) + ((v5 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v5) & 1) == 0) {
    return 0;
  }
  *a3 = sub_19E04E2B8(a1 + 208, v5);
  return 1;
}

void sub_19E0440CC(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v13 = 0;
  unint64_t v14 = 0;
  char v12 = 0;
  memset(&__p, 0, sizeof(__p));
  while (v13 < a3)
  {
    if ((sub_19E0441BC(a1, a2, a3, &v13, &v14, &__p) & 1) == 0) {
      goto LABEL_8;
    }
  }
  int v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    int v10 = __p.__r_.__value_.__r.__words[1];
  }
  sub_19E044460(a1, v14, (uint64_t)&__p, &v12, a4, (v10 - a3) & ~((v10 - (int)a3) >> 31), a5);
LABEL_8:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_19E04419C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0441BC(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5, std::string *this)
{
  unint64_t v12 = (*(unsigned __int8 *)(a2 + *a4) ^ (32 * *a5) ^ *a5) & *(void *)(a1 + 1056);
  uint64_t v13 = *(void *)(a1 + 1024);
  if (*a5 != *(_DWORD *)(v13 + 12 * v12))
  {
    unint64_t v15 = sub_19E04E400((void *)a1, *a5);
    uint64_t v16 = *(void *)(a1 + 16);
    if ((*(void *)(v16 + (((v15 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v15 + 1)))
    {
      unint64_t v17 = v15 - *a5;
      *a5 = v17;
      unint64_t v18 = v15 + 2;
      uint64_t v19 = 0xFFFFFFFFLL;
      while (1)
      {
        if ((*(void *)(*(void *)(a1 + 432) + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v17))
        {
          if (v19 == 0xFFFFFFFFLL)
          {
            uint64_t v19 = sub_19E04E2B8(a1 + 416, v17);
            unint64_t v17 = *a5;
          }
          else
          {
            ++v19;
          }
          unint64_t v21 = *a4;
          uint64_t v22 = *(void *)(a1 + 720);
          unint64_t v23 = (unint64_t)(v22 * v19) >> 6;
          uint64_t v24 = (v22 * v19) & 0x3F;
          unint64_t v25 = v24 + v22;
          uint64_t v26 = *(void *)(a1 + 688);
          uint64_t v27 = *(void *)(v26 + 8 * v23) >> v24;
          if (v25 > 0x40) {
            v27 |= (2 * *(void *)(v26 + 8 * v23 + 8)) << (v24 ^ 0x3Fu);
          }
          unint64_t v28 = *(unsigned __int8 *)(*(void *)(a1 + 640) + v17) | ((*(_DWORD *)(a1 + 728) & v27) << 8);
          uint64_t v29 = *(void *)(a1 + 1000);
          if (v29)
          {
            if (sub_19E046B60(v29, a2, a3, a4, v28, this)) {
              return 1;
            }
          }
          else if (sub_19E04DAB8((void *)(a1 + 744), a2, a3, a4, v28, this))
          {
            return 1;
          }
          if (*a4 != v21) {
            return 0;
          }
          unint64_t v17 = *a5;
          uint64_t v16 = *(void *)(a1 + 16);
        }
        else
        {
          int v20 = *(unsigned __int8 *)(*(void *)(a1 + 640) + v17);
          if (v20 == *(unsigned __int8 *)(a2 + *a4))
          {
            std::string::push_back(this, v20);
            ++*a4;
            return 1;
          }
        }
        *a5 = ++v17;
        uint64_t v30 = *(void *)(v16 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v18;
        ++v18;
        if ((v30 & 1) == 0) {
          return 0;
        }
      }
    }
    return 0;
  }
  unint64_t v14 = *(unsigned int *)(v13 + 12 * v12 + 8);
  if (v14 > 0xFFFFFEFF)
  {
    std::string::push_back(this, v14);
    ++*a4;
    goto LABEL_24;
  }
  uint64_t v31 = *(void *)(a1 + 1000);
  if (v31)
  {
    if (sub_19E046B60(v31, a2, a3, a4, v14, this)) {
      goto LABEL_24;
    }
    return 0;
  }
  if (!sub_19E04DAB8((void *)(a1 + 744), a2, a3, a4, v14, this)) {
    return 0;
  }
LABEL_24:
  *a5 = *(unsigned int *)(*(void *)(a1 + 1024) + 12 * v12 + 4);
  return 1;
}

unint64_t sub_19E044460(unint64_t result, unint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, int a6, uint64_t a7)
{
  if (!*a4)
  {
    unint64_t v11 = result;
    if ((a7 & 0x80000000) != 0 || a6 <= (int)a7)
    {
      if (((*(void *)(*(void *)(result + 224) + ((a2 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a2) & 1) == 0
        || ((v12 = sub_19E04E2B8(result + 208, a2), int v13 = *(char *)(a3 + 23), v13 >= 0)
          ? (uint64_t v14 = a3)
          : (uint64_t v14 = *(void *)a3),
            v13 >= 0 ? (uint64_t v15 = *(unsigned __int8 *)(a3 + 23)) : (uint64_t v15 = *(void *)(a3 + 8)),
            double result = sub_19E0447D4(a5, v12, v14, v15, (uint64_t)a4),
            !*a4))
      {
        std::string::size_type v16 = *(char *)(a3 + 23) >= 0 ? *(unsigned __int8 *)(a3 + 23) : *(void *)(a3 + 8);
        double result = sub_19E04E400((void *)v11, a2);
        if (!*a4)
        {
          unint64_t v17 = result;
          uint64_t v18 = 0xFFFFFFFFLL;
          do
          {
            if (((*(void *)(*(void *)(v11 + 16) + (((v17 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v17 + 1)) & 1) == 0) {
              break;
            }
            if ((*(void *)(*(void *)(v11 + 432) + (((v17 - a2) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v17 - a2)))
            {
              if (v18 == 0xFFFFFFFFLL) {
                uint64_t v18 = sub_19E04E2B8(v11 + 416, v17 - a2);
              }
              else {
                ++v18;
              }
              uint64_t v19 = *(void *)(v11 + 720);
              unint64_t v20 = (unint64_t)(v19 * v18) >> 6;
              uint64_t v21 = (v19 * v18) & 0x3F;
              unint64_t v22 = v21 + v19;
              uint64_t v23 = *(void *)(v11 + 688);
              uint64_t v24 = *(void *)(v23 + 8 * v20) >> v21;
              if (v22 > 0x40) {
                v24 |= (2 * *(void *)(v23 + 8 * v20 + 8)) << (v21 ^ 0x3Fu);
              }
              unint64_t v25 = *(unsigned __int8 *)(*(void *)(v11 + 640) - a2 + v17) | ((*(_DWORD *)(v11 + 728) & v24) << 8);
              uint64_t v26 = *(void *)(v11 + 1000);
              if (v26) {
                sub_19E046788(v26, (std::string *)a3, v25);
              }
              else {
                sub_19E04D994((void *)(v11 + 744), (std::string *)a3, v25);
              }
            }
            else
            {
              std::string::push_back((std::string *)a3, *(unsigned char *)(*(void *)(v11 + 640) - a2 + v17));
            }
            int v27 = *(unsigned __int8 *)(a3 + 23);
            if ((v27 & 0x80u) != 0) {
              int v27 = *(_DWORD *)(a3 + 8);
            }
            sub_19E044460(v11, v17 - a2, a3, a4, a5, (v27 - v16 + a6), a7);
            uint64_t v28 = *(unsigned __int8 *)(a3 + 23);
            int v29 = (char)v28;
            uint64_t v30 = a3 + v28;
            if (v29 >= 0)
            {
              uint64_t v31 = a3;
            }
            else
            {
              uint64_t v30 = *(void *)a3 + *(void *)(a3 + 8);
              uint64_t v31 = *(void *)a3;
            }
            double result = (unint64_t)std::string::erase((std::string *)a3, v16, v30 - (v31 + v16));
            ++v17;
          }
          while (!*a4);
        }
      }
    }
  }
  return result;
}

void sub_19E0446D4(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((a4 & 0x80000000) != 0)
  {
    uint64_t v8 = *(unsigned __int8 *)(a2 + 31);
    uint64_t v10 = *(void *)(a2 + 16);
    char v9 = *(unsigned char *)(a2 + 31);
LABEL_8:
    char v20 = 0;
    uint64_t v12 = *(void *)(a2 + 8) + v10;
    uint64_t v13 = a2 + 8 + v8;
    if (v9 >= 0) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = v12;
    }
    if (v9 >= 0) {
      uint64_t v15 = a2 + 8;
    }
    else {
      uint64_t v15 = *(void *)(a2 + 8);
    }
    sub_19E048338(&__p, v14, v14, v15, v15, v14 - v15);
    if ((v19 & 0x80u) == 0) {
      int v16 = v19;
    }
    else {
      int v16 = v18;
    }
    sub_19E044460(a1, *(void *)a2, (uint64_t)&__p, &v20, a3, v16, a4);
    if ((char)v19 < 0) {
      operator delete(__p);
    }
    return;
  }
  uint64_t v8 = *(unsigned __int8 *)(a2 + 31);
  char v9 = v8;
  uint64_t v10 = *(void *)(a2 + 16);
  if ((v8 & 0x80u) == 0) {
    unint64_t v11 = *(unsigned __int8 *)(a2 + 31);
  }
  else {
    unint64_t v11 = *(void *)(a2 + 16);
  }
  if (v11 <= a4) {
    goto LABEL_8;
  }
}

void sub_19E0447B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0447D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v8[0] = a3;
  v8[1] = a4;
  uint64_t v7 = a2;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, void *, uint64_t))(*(void *)v5 + 48))(v5, &v7, v8, a5);
}

void sub_19E044834(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v38 = 0;
  uint64_t v5 = *(unsigned __int8 *)(a2 + 31);
  int v6 = (char)v5;
  unint64_t v7 = *(void *)(a2 + 16);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 16);
  }
  if (v5)
  {
    uint64_t v8 = (void **)(a2 + 8);
    unint64_t v36 = *(void *)a2;
    p_p = &__p;
    if (v6 < 0)
    {
      sub_19E03FA9C(&__p, *v8, v7);
    }
    else
    {
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)v8;
      __p.__r_.__value_.__r.__words[2] = *(void *)(a2 + 24);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      char v32 = *(unsigned char *)(__p.__r_.__value_.__r.__words[0] + __p.__r_.__value_.__l.__size_ - 1);
      uint64_t v33 = --__p.__r_.__value_.__l.__size_;
    }
    else
    {
      char v32 = __p.__r_.__value_.__s.__data_[HIBYTE(__p.__r_.__value_.__r.__words[2]) - 1];
      uint64_t v33 = HIBYTE(__p.__r_.__value_.__r.__words[2]) - 1;
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = v33 & 0x7F;
    }
    p_p->__r_.__value_.__s.__data_[v33] = 0;
    sub_19E044B84(a3, v32);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    unint64_t v11 = sub_19E04E400((void *)a1, *(void *)a2);
    unint64_t v12 = v11 - *(void *)a2;
    *(void *)long long v34 = a1 + 744;
    uint64_t v13 = 0xFFFFFFFFLL;
    do
    {
      ++v11;
      if (((*(void *)(*(void *)(a1 + 16) + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v11) & 1) == 0) {
        break;
      }
      memset(&v35, 0, sizeof(v35));
      if ((*(void *)(*(void *)(a1 + 432) + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v12))
      {
        if (v13 == 0xFFFFFFFFLL) {
          uint64_t v13 = sub_19E04E2B8(a1 + 416, v12);
        }
        else {
          ++v13;
        }
        uint64_t v14 = *(void *)(a1 + 720);
        unint64_t v15 = (unint64_t)(v14 * v13) >> 6;
        uint64_t v16 = (v14 * v13) & 0x3F;
        unint64_t v17 = v16 + v14;
        uint64_t v18 = *(void *)(a1 + 688);
        uint64_t v19 = *(void *)(v18 + 8 * v15) >> v16;
        if (v17 > 0x40) {
          v19 |= (2 * *(void *)(v18 + 8 * v15 + 8)) << (v16 ^ 0x3Fu);
        }
        unint64_t v20 = *(unsigned __int8 *)(*(void *)(a1 + 640) + v12) | ((*(_DWORD *)(a1 + 728) & v19) << 8);
        uint64_t v21 = *(void *)(a1 + 1000);
        if (v21) {
          sub_19E046788(v21, &v35, v20);
        }
        else {
          sub_19E04D994(*(void **)v34, &v35, v20);
        }
        std::string::size_type size = HIBYTE(v35.__r_.__value_.__r.__words[2]);
        if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v23 = &v35;
        }
        else {
          uint64_t v23 = (std::string *)v35.__r_.__value_.__r.__words[0];
        }
        if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = v35.__r_.__value_.__l.__size_;
        }
        if (size)
        {
          uint64_t v24 = (std::string *)((char *)v23 + size - 1);
          if (v24 > v23)
          {
            unint64_t v25 = &v23->__r_.__value_.__s.__data_[1];
            do
            {
              std::string::value_type v26 = *(v25 - 1);
              *(v25 - 1) = v24->__r_.__value_.__s.__data_[0];
              v24->__r_.__value_.__s.__data_[0] = v26;
              uint64_t v24 = (std::string *)((char *)v24 - 1);
            }
            while (v25++ < (char *)v24);
          }
        }
      }
      else
      {
        std::string::push_back(&v35, *(unsigned char *)(*(void *)(a1 + 640) + v12));
      }
      std::string __p = v35;
      memset(&v35, 0, sizeof(v35));
      unint64_t v36 = v12;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        uint64_t v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
        char v28 = *(unsigned char *)(__p.__r_.__value_.__r.__words[0] + __p.__r_.__value_.__l.__size_ - 1);
        uint64_t v29 = --__p.__r_.__value_.__l.__size_;
      }
      else
      {
        char v28 = *((unsigned char *)&v36 + HIBYTE(__p.__r_.__value_.__r.__words[2]) + 7);
        uint64_t v29 = HIBYTE(__p.__r_.__value_.__r.__words[2]) - 1;
        *((unsigned char *)&__p.__r_.__value_.__s + 23) = v29 & 0x7F;
        uint64_t v30 = &__p;
      }
      v30->__r_.__value_.__s.__data_[v29] = 0;
      sub_19E044B84(a3, v28);
      int v31 = v38;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v35.__r_.__value_.__l.__data_);
      }
      ++v12;
    }
    while (!v31);
  }
}

void sub_19E044B3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E044B84(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_19E044BD8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  while (v9 < a3)
  {
    if ((sub_19E044C78(a1, a2, a3, &v9, &v10) & 1) == 0) {
      return 0;
    }
  }
  if ((*(void *)(*(void *)(a1 + 224) + ((v10 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v10))
  {
    *a4 = sub_19E04E2B8(a1 + 208, v10);
    return 1;
  }
  return 0;
}

uint64_t sub_19E044C78(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v10 = (*(unsigned __int8 *)(a2 + *a4) ^ (32 * *a5) ^ *a5) & *(void *)(a1 + 1056);
  uint64_t v11 = *(void *)(a1 + 1024);
  if (*a5 != *(_DWORD *)(v11 + 12 * v10))
  {
    unint64_t v13 = sub_19E04E400((void *)a1, *a5);
    uint64_t v14 = *(void *)(a1 + 16);
    if ((*(void *)(v14 + (((v13 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v13 + 1)))
    {
      unint64_t v15 = v13 - *a5;
      *a5 = v15;
      unint64_t v16 = v13 + 2;
      uint64_t v17 = 0xFFFFFFFFLL;
      while (1)
      {
        if ((*(void *)(*(void *)(a1 + 432) + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15))
        {
          if (v17 == 0xFFFFFFFFLL)
          {
            uint64_t v17 = sub_19E04E2B8(a1 + 416, v15);
            unint64_t v15 = *a5;
          }
          else
          {
            ++v17;
          }
          unint64_t v18 = *a4;
          uint64_t v19 = *(void *)(a1 + 720);
          unint64_t v20 = (unint64_t)(v19 * v17) >> 6;
          uint64_t v21 = (v19 * v17) & 0x3F;
          unint64_t v22 = v21 + v19;
          uint64_t v23 = *(void *)(a1 + 688);
          uint64_t v24 = *(void *)(v23 + 8 * v20) >> v21;
          if (v22 > 0x40) {
            v24 |= (2 * *(void *)(v23 + 8 * v20 + 8)) << (v21 ^ 0x3Fu);
          }
          unint64_t v25 = *(unsigned __int8 *)(*(void *)(a1 + 640) + v15) | ((*(_DWORD *)(a1 + 728) & v24) << 8);
          uint64_t v26 = *(void *)(a1 + 1000);
          if (v26)
          {
            if (sub_19E046914(v26, a2, a3, a4, v25)) {
              return 1;
            }
          }
          else if (sub_19E04DA24((void *)(a1 + 744), a2, a3, a4, v25))
          {
            return 1;
          }
          if (*a4 != v18) {
            return 0;
          }
          unint64_t v15 = *a5;
          uint64_t v14 = *(void *)(a1 + 16);
        }
        else if (*(unsigned __int8 *)(*(void *)(a1 + 640) + v15) == *(unsigned __int8 *)(a2 + *a4))
        {
          ++*a4;
          return 1;
        }
        *a5 = ++v15;
        uint64_t v27 = *(void *)(v14 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v16;
        ++v16;
        if ((v27 & 1) == 0) {
          return 0;
        }
      }
    }
    return 0;
  }
  unint64_t v12 = *(unsigned int *)(v11 + 12 * v10 + 8);
  if (v12 > 0xFFFFFEFF)
  {
    ++*a4;
    goto LABEL_24;
  }
  uint64_t v28 = *(void *)(a1 + 1000);
  if (v28)
  {
    if (sub_19E046914(v28, a2, a3, a4, v12)) {
      goto LABEL_24;
    }
    return 0;
  }
  if ((sub_19E04DA24((void *)(a1 + 744), a2, a3, a4, v12) & 1) == 0) {
    return 0;
  }
LABEL_24:
  *a5 = *(unsigned int *)(*(void *)(a1 + 1024) + 12 * v10 + 4);
  return 1;
}

void sub_19E044EE8(uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X8>)
{
  if (*(void *)(a1 + 264) <= a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x3000000C6;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/louds"
                   "-trie.cc:198: MARISA_BOUND_ERROR: payload_id >= size()";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  unint64_t v5 = sub_19E04E66C((void *)(a1 + 208), a2);
  if (v5)
  {
    unint64_t v6 = v5;
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    while (1)
    {
      if ((*(void *)(*(void *)(a1 + 432) + ((v6 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v6))
      {
        if (*(char *)(a3 + 23) >= 0) {
          uint64_t v7 = *(unsigned __int8 *)(a3 + 23);
        }
        else {
          uint64_t v7 = *(void *)(a3 + 8);
        }
        int v8 = *(unsigned __int8 *)(*(void *)(a1 + 640) + v6);
        uint64_t v9 = sub_19E04E2B8(a1 + 416, v6);
        uint64_t v10 = *(void *)(a1 + 720);
        unint64_t v11 = (unint64_t)(v10 * v9) >> 6;
        uint64_t v12 = (v10 * v9) & 0x3F;
        unint64_t v13 = v12 + v10;
        uint64_t v14 = *(void *)(a1 + 688);
        unint64_t v15 = *(void *)(v14 + 8 * v11);
        if (v13 > 0x40) {
          uint64_t v16 = ((2 * *(void *)(v14 + 8 * v11 + 8)) << (v12 ^ 0x3Fu)) | (v15 >> v12);
        }
        else {
          uint64_t v16 = v15 >> v12;
        }
        unint64_t v17 = v8 | ((*(_DWORD *)(a1 + 728) & v16) << 8);
        uint64_t v18 = *(void *)(a1 + 1000);
        if (v18) {
          sub_19E046788(v18, (std::string *)a3, v17);
        }
        else {
          sub_19E04D994((void *)(a1 + 744), (std::string *)a3, v17);
        }
        uint64_t v19 = *(unsigned __int8 *)(a3 + 23);
        if ((v19 & 0x80u) == 0) {
          unint64_t v20 = a3;
        }
        else {
          unint64_t v20 = *(void *)a3;
        }
        if ((v19 & 0x80u) != 0) {
          uint64_t v19 = *(void *)(a3 + 8);
        }
        if (v7 != v19)
        {
          uint64_t v21 = (unsigned char *)(v20 + v19 - 1);
          if ((unint64_t)v21 > v20 + v7)
          {
            unint64_t v22 = v20 + v7 + 1;
            do
            {
              char v23 = *(unsigned char *)(v22 - 1);
              *(unsigned char *)(v22 - 1) = *v21;
              *v21-- = v23;
              BOOL v24 = v22++ >= (unint64_t)v21;
            }
            while (!v24);
          }
        }
      }
      else
      {
        std::string::push_back((std::string *)a3, *(unsigned char *)(*(void *)(a1 + 640) + v6));
      }
      if (v6 <= *(void *)(a1 + 1064)) {
        break;
      }
      unint64_t v6 = sub_19E04E66C((void *)a1, v6) + ~v6;
    }
    int v25 = *(char *)(a3 + 23);
    BOOL v26 = v25 < 0;
    if (v25 >= 0) {
      unint64_t v27 = a3;
    }
    else {
      unint64_t v27 = *(void *)a3;
    }
    if (v26) {
      uint64_t v28 = *(void *)(a3 + 8);
    }
    else {
      uint64_t v28 = *(unsigned __int8 *)(a3 + 23);
    }
    uint64_t v29 = (unsigned char *)(v27 + v28 - 1);
    if (v28) {
      BOOL v30 = (unint64_t)v29 > v27;
    }
    else {
      BOOL v30 = 0;
    }
    if (v30)
    {
      unint64_t v31 = v27 + 1;
      do
      {
        char v32 = *(unsigned char *)(v31 - 1);
        *(unsigned char *)(v31 - 1) = *v29;
        *v29-- = v32;
        BOOL v24 = v31++ >= (unint64_t)v29;
      }
      while (!v24);
    }
  }
  else
  {
    sub_19E0413C8((void *)a3, "");
  }
}

void sub_19E04517C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E04519C(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = result;
  char v15 = 0;
  unint64_t v13 = 0;
  unint64_t v14 = 0;
  uint64_t v8 = result + 208;
  if (**(unsigned char **)(result + 224))
  {
    uint64_t v9 = sub_19E04E2B8(result + 208, 0);
    double result = sub_19E0447D4(a4, v9, a2, 0, (uint64_t)&v15);
    if (v15) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = a3 == 0;
    }
    if (v10) {
      return result;
    }
  }
  else if (!a3)
  {
    return result;
  }
  double result = sub_19E044C78(v7, a2, a3, &v13, &v14);
  if (result)
  {
    do
    {
      if ((*(void *)(*(void *)(v7 + 224) + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14))
      {
        uint64_t v11 = sub_19E04E2B8(v8, v14);
        double result = sub_19E0447D4(a4, v11, a2, v13, (uint64_t)&v15);
        if (v15) {
          BOOL v12 = 1;
        }
        else {
          BOOL v12 = v13 >= a3;
        }
        if (v12) {
          return result;
        }
      }
      else if (v13 >= a3)
      {
        return result;
      }
      double result = sub_19E044C78(v7, a2, a3, &v13, &v14);
    }
    while ((result & 1) != 0);
  }
  return result;
}

uint64_t *sub_19E0452CC(uint64_t *a1, uint64_t *a2)
{
  sub_19E045344(a1, a2);
  uint64_t v4 = a1[6];
  a1[6] = a2[6];
  a2[6] = v4;
  uint64_t v5 = a1[7];
  a1[7] = a2[7];
  a2[7] = v5;
  sub_19E045344(a1 + 8, a2 + 8);
  sub_19E045344(a1 + 14, a2 + 14);

  return sub_19E045344(a1 + 20, a2 + 20);
}

uint64_t *sub_19E045344(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *double result = *a2;
  *a2 = v2;
  uint64_t v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  uint64_t v4 = result[2];
  uint64_t v5 = result[3];
  uint64_t v6 = a2[3];
  result[2] = a2[2];
  result[3] = v6;
  a2[2] = v4;
  a2[3] = v5;
  uint64_t v7 = result[4];
  result[4] = a2[4];
  a2[4] = v7;
  LOBYTE(v7) = *((unsigned char *)result + 40);
  *((unsigned char *)result + 4sub_19E03D880(&a9, 0) = *((unsigned char *)a2 + 40);
  *((unsigned char *)a2 + 4sub_19E03D880(&a9, 0) = v7;
  return result;
}

uint64_t *sub_19E045398(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 > 0x555555555555555) {
      uint64_t v5 = 0xAAAAAAAAAAAAAAALL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    double result = (uint64_t *)sub_19E048468(result, a2);
  }
  unint64_t v6 = v3[3];
  unint64_t v7 = v2 - v6;
  if (v2 > v6)
  {
    uint64_t v8 = 24 * v6;
    do
    {
      uint64_t v9 = v3[1] + v8;
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      v8 += 24;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

uint64_t sub_19E045428(uint64_t a1, uint64_t *a2, long long *a3, uint64_t a4, uint64_t a5)
{
  sub_19E048520((uint64_t *)a1, (uint64_t)a2, a3, a4, a5);
  memset(v17, 0, 41);
  if (a2[3]) {
    sub_19E0458E8(a1, a2, v17, a4, a5);
  }
  uint64_t v9 = *(_DWORD **)(a1 + 1000);
  if (v9)
  {
    unsigned int v10 = (v9[268] + 1) | v9[271] | v9[272];
    uint64_t v18 = 3;
    uint64_t v19 = 0x100000000200;
    int v20 = 0x20000;
    sub_19E046DA0(&v18, v10);
  }
  else
  {
    if (*(void *)(a1 + 840)) {
      int v11 = 0x2000;
    }
    else {
      int v11 = 4096;
    }
    unsigned int v12 = *(_DWORD *)(a4 + 16) | *(_DWORD *)(a4 + 8) | v11 | 1;
    uint64_t v18 = 3;
    uint64_t v19 = 0x100000000200;
    int v20 = 0x20000;
    sub_19E046DA0(&v18, v12);
  }
  *(void *)(a1 + 1072) = v18;
  *(void *)(a1 + 108sub_19E03D880(&a9, 0) = v19;
  *(_DWORD *)(a1 + 1088) = v20;
  sub_19E045778(a1 + 416, 0, 0);
  if (*((void *)&v17[1] + 1))
  {
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      do
      {
        uint64_t v15 = *(void *)(*(void *)(a1 + 432) + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14;
        ++v14;
      }
      while ((v15 & 1) == 0);
      *(unsigned char *)(*(void *)(a1 + 632) + v14 - 1) = *(_DWORD *)(*((void *)&v17[0] + 1) + 4 * v13);
      *(_DWORD *)(*((void *)&v17[0] + 1) + 4 * v13++) >>= 8;
    }
    while (v13 < *((void *)&v17[1] + 1));
  }
  sub_19E048C88((long long *)(a1 + 672), (uint64_t)v17);
  sub_19E046004(a1);
  uint64_t result = *(void *)&v17[0];
  if (*(void *)&v17[0]) {
    return MEMORY[0x19F3BA6E0](*(void *)&v17[0], 0x1000C8077774924);
  }
  return result;
}

void sub_19E0455E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E04560C(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  unint64_t v4 = a1[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 >> 60) {
      uint64_t v5 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    sub_19E0470E4(a1, a2);
  }
  unint64_t v6 = a1[3];
  if (v2 > v6) {
    bzero((void *)(a1[1] + 8 * v6), 8 * (v2 - v6));
  }
  a1[3] = v2;
}

uint64_t *sub_19E045680(uint64_t *result, int a2)
{
  unint64_t v2 = result[6];
  if (v2 == 0xFFFFFFFF)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/bit-vector.h";
    exception[2] = 0x70000003ALL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/bit"
                   "-vector.h:58: MARISA_SIZE_ERROR: size_ == MARISA_UINT32_MAX";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  unint64_t v4 = result;
  uint64_t v5 = result[3];
  if (v2 == v5 << 6)
  {
    uint64_t v7 = 0;
    uint64_t result = sub_19E04705C(result, v5 + 1, &v7);
    unint64_t v2 = v4[6];
  }
  if (a2)
  {
    *(void *)(v4[1] + ((v2 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v2;
    ++v4[7];
  }
  v4[6] = v2 + 1;
  return result;
}

uint64_t sub_19E045778(uint64_t a1, uint64_t a2, uint64_t a3)
{
  memset(v8, 0, 41);
  long long v11 = 0u;
  memset(v12, 0, sizeof(v12));
  long long v13 = 0u;
  memset(v14, 0, sizeof(v14));
  v8[3] = 0u;
  long long v9 = 0u;
  memset(v10, 0, sizeof(v10));
  sub_19E04E7E0(v8, (void *)a1, a2, a3);
  sub_19E04717C((void *)a1);
  long long v4 = v8[0];
  v8[0] = *(_OWORD *)a1;
  *(_OWORD *)a1 = v4;
  uint64_t v5 = *(void *)&v8[1];
  *(void *)&v8[1] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v5;
  long long v6 = *(_OWORD *)((char *)&v8[1] + 8);
  *(_OWORD *)((char *)&v8[1] + 8) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a1 + 24) = v6;
  LOBYTE(v5) = BYTE8(v8[2]);
  BYTE8(v8[2]) = *(unsigned char *)(a1 + 40);
  *(unsigned char *)(a1 + 4sub_19E03D880(&a9, 0) = v5;
  sub_19E0452CC((uint64_t *)a1, (uint64_t *)v8);
  if ((void)v13) {
    MEMORY[0x19F3BA6E0](v13, 0x1000C8077774924);
  }
  if ((void)v11) {
    MEMORY[0x19F3BA6E0](v11, 0x1000C8077774924);
  }
  if ((void)v9) {
    MEMORY[0x19F3BA6E0](v9, 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v8[0];
  if (*(void *)&v8[0]) {
    return MEMORY[0x19F3BA6E0](*(void *)&v8[0], 0x1000C8077774924);
  }
  return result;
}

void sub_19E0458A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_19E0458B8(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    sub_19E04BF0C((char **)a1, a2 - v2);
  }
}

uint64_t sub_19E0458E8(uint64_t a1, uint64_t *a2, long long *a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)a4 == a5)
  {
    long long v26 = 0u;
    memset(v27, 0, sizeof(v27));
    sub_19E045B48((uint64_t *)&v26, a2[3]);
    uint64_t v9 = a2[3];
    if (v9)
    {
      unsigned int v10 = (unsigned int *)(*((void *)&v26 + 1) + 8);
      long long v11 = (_DWORD *)(a2[1] + 8);
      do
      {
        uint64_t v12 = *((void *)v11 - 1);
        unsigned int v13 = *v11;
        v11 += 6;
        *((void *)v10 - 1) = v12 + v13 - 1;
        *unsigned int v10 = v13;
        v10 += 4;
        --v9;
      }
      while (v9);
    }
    sub_19E04D1CC((long long *)(a1 + 744), (uint64_t)&v26, a3, *(_DWORD *)(a4 + 12));
  }
  else
  {
    long long v26 = 0u;
    memset(v27, 0, sizeof(v27));
    sub_19E045398((uint64_t *)&v26, a2[3]);
    if (a2[3])
    {
      uint64_t v15 = 0;
      unint64_t v16 = 0;
      do
      {
        uint64_t v17 = *((void *)&v26 + 1) + v15;
        uint64_t v18 = a2[1] + v15;
        uint64_t v19 = *(unsigned int *)(v18 + 8);
        *(void *)uint64_t v17 = *(void *)v18 + v19;
        *(_DWORD *)(v17 + 8) = v19;
        *(_DWORD *)(v17 + 12) = *(_DWORD *)(v18 + 12);
        ++v16;
        v15 += 24;
      }
      while (v16 < a2[3]);
    }
    uint64_t v20 = *a2;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_OWORD *)((char *)a2 + 25) = 0u;
    if (v20) {
      MEMORY[0x19F3BA6E0](v20, 0x1000C8077774924);
    }
    uint64_t v21 = operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
    unint64_t v22 = v21;
    if (v21) {
      sub_19E043194((uint64_t)v21);
    }
    uint64_t v28 = *(void *)(a1 + 1000);
    *(void *)(a1 + 100sub_19E03D880(&a9, 0) = v22;
    sub_19E04297C(&v28);
    uint64_t v23 = *(void *)(a1 + 1000);
    if (!v23)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1EF099E88;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x8000001EBLL;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/lou"
                     "ds-trie.cc:491: MARISA_MEMORY_ERROR: next_trie_.get() == NULL";
      __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
    }
    sub_19E045BC8(v23, (uint64_t)&v26, a3, a4, a5 + 1);
  }
  uint64_t result = v26;
  if ((void)v26) {
    return MEMORY[0x19F3BA6E0](v26, 0x1000C8077774924);
  }
  return result;
}

void sub_19E045B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  MEMORY[0x19F3BA700](v9, MEMORY[0x1E4FBA2D0]);
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_19E045B48(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 >> 59) {
      uint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    uint64_t result = (uint64_t *)sub_19E04C028(result, a2);
  }
  unint64_t v6 = v3[3];
  unint64_t v7 = v2 - v6;
  if (v2 > v6)
  {
    uint64_t v8 = 16 * v6;
    do
    {
      uint64_t v9 = (void *)(v3[1] + v8);
      *uint64_t v9 = 0;
      v9[1] = 0;
      v8 += 16;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

uint64_t sub_19E045BC8(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5)
{
  sub_19E04C0CC((uint64_t *)a1, a2, a3, a4, a5);
  memset(v17, 0, 41);
  if (*(void *)(a2 + 24)) {
    sub_19E045DAC(a1, a2, v17, a4, a5);
  }
  uint64_t v9 = *(_DWORD **)(a1 + 1000);
  if (v9)
  {
    unsigned int v10 = (v9[268] + 1) | v9[271] | v9[272];
    uint64_t v18 = 3;
    uint64_t v19 = 0x100000000200;
    int v20 = 0x20000;
    sub_19E046DA0(&v18, v10);
  }
  else
  {
    if (*(void *)(a1 + 840)) {
      int v11 = 0x2000;
    }
    else {
      int v11 = 4096;
    }
    unsigned int v12 = *(_DWORD *)(a4 + 16) | *(_DWORD *)(a4 + 8) | v11 | 1;
    uint64_t v18 = 3;
    uint64_t v19 = 0x100000000200;
    int v20 = 0x20000;
    sub_19E046DA0(&v18, v12);
  }
  *(void *)(a1 + 1072) = v18;
  *(void *)(a1 + 108sub_19E03D880(&a9, 0) = v19;
  *(_DWORD *)(a1 + 1088) = v20;
  sub_19E045778(a1 + 416, 0, 0);
  if (*((void *)&v17[1] + 1))
  {
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      do
      {
        uint64_t v15 = *(void *)(*(void *)(a1 + 432) + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14;
        ++v14;
      }
      while ((v15 & 1) == 0);
      *(unsigned char *)(*(void *)(a1 + 632) + v14 - 1) = *(_DWORD *)(*((void *)&v17[0] + 1) + 4 * v13);
      *(_DWORD *)(*((void *)&v17[0] + 1) + 4 * v13++) >>= 8;
    }
    while (v13 < *((void *)&v17[1] + 1));
  }
  sub_19E048C88((long long *)(a1 + 672), (uint64_t)v17);
  sub_19E046004(a1);
  uint64_t result = *(void *)&v17[0];
  if (*(void *)&v17[0]) {
    return MEMORY[0x19F3BA6E0](*(void *)&v17[0], 0x1000C8077774924);
  }
  return result;
}

void sub_19E045D80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E045DAC(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)a4 == a5)
  {
    memset(v20, 0, 41);
    sub_19E045B48((uint64_t *)v20, *(void *)(a2 + 24));
    uint64_t v9 = *(void *)(a2 + 24);
    if (v9)
    {
      unsigned int v10 = (_DWORD *)(*((void *)&v20[0] + 1) + 8);
      int v11 = (_DWORD *)(*(void *)(a2 + 8) + 8);
      do
      {
        uint64_t v12 = *((void *)v11 - 1);
        int v13 = *v11;
        v11 += 6;
        *((void *)v10 - 1) = v12 - 1;
        *unsigned int v10 = v13;
        v10 += 4;
        --v9;
      }
      while (v9);
    }
    sub_19E04D1CC((long long *)(a1 + 744), (uint64_t)v20, a3, *(_DWORD *)(a4 + 12));
    uint64_t result = *(void *)&v20[0];
    if (*(void *)&v20[0]) {
      return MEMORY[0x19F3BA6E0](*(void *)&v20[0], 0x1000C8077774924);
    }
  }
  else
  {
    unint64_t v16 = operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
    uint64_t v17 = v16;
    if (v16) {
      sub_19E043194((uint64_t)v16);
    }
    *(void *)&v20[0] = *(void *)(a1 + 1000);
    *(void *)(a1 + 100sub_19E03D880(&a9, 0) = v17;
    sub_19E04297C(v20);
    uint64_t v18 = *(void *)(a1 + 1000);
    if (!v18)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1EF099E88;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x8000001FDLL;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/lou"
                     "ds-trie.cc:509: MARISA_MEMORY_ERROR: next_trie_.get() == NULL";
      __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
    }
    return sub_19E045BC8(v18, a2, a3, a4, a5 + 1);
  }
  return result;
}

void sub_19E045F30(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA700](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E045F70(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 > 0xAAAAAAAAAAAAAAALL) {
      uint64_t v5 = 0x1555555555555555;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    uint64_t result = (uint64_t *)sub_19E04CF94(result, a2);
  }
  unint64_t v6 = v3[3];
  unint64_t v7 = v2 - v6;
  if (v2 > v6)
  {
    uint64_t v8 = 12 * v6;
    do
    {
      uint64_t v9 = v3[1] + v8;
      *(void *)uint64_t v9 = 0;
      *(_DWORD *)(v9 + 8) = 0x800000;
      v8 += 12;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

uint64_t sub_19E046004(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 1032);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    uint64_t v5 = result + 416;
    do
    {
      uint64_t v6 = *(void *)(v2 + 1016);
      unint64_t v7 = *(unsigned int *)(v6 + v3 + 4);
      if (v7)
      {
        *(unsigned char *)(v6 + v3 + 8) = *(unsigned char *)(*(void *)(v2 + 632) + v7);
        uint64_t v8 = *(void *)(v2 + 1016);
        if ((*(void *)(*(void *)(v2 + 432) + ((v7 >> 3) & 0x1FFFFFF8)) >> v7))
        {
          uint64_t result = sub_19E04E2B8(v5, v7);
          uint64_t v9 = *(void *)(v2 + 720);
          unint64_t v10 = (unint64_t)(v9 * result) >> 6;
          uint64_t v11 = (v9 * result) & 0x3F;
          unint64_t v12 = v11 + v9;
          uint64_t v13 = *(void *)(v2 + 688);
          unint64_t v14 = *(void *)(v13 + 8 * v10);
          if (v12 > 0x40) {
            uint64_t v15 = ((2 * *(void *)(v13 + 8 * v10 + 8)) << (v11 ^ 0x3Fu)) | (v14 >> v11);
          }
          else {
            uint64_t v15 = v14 >> v11;
          }
          int v16 = *(_DWORD *)(v2 + 728) & v15;
        }
        else
        {
          int v16 = 0xFFFFFF;
        }
        *(_DWORD *)(v8 + v3 + 8) = *(unsigned __int8 *)(v8 + v3 + 8) | (v16 << 8);
        unint64_t v1 = *(void *)(v2 + 1032);
      }
      else
      {
        *(void *)(v6 + v3) = -1;
      }
      ++v4;
      v3 += 12;
    }
    while (v4 < v1);
  }
  return result;
}

uint64_t sub_19E046110(uint64_t *a1, uint64_t *a2)
{
  memset(v4, 0, 41);
  long long v7 = 0u;
  memset(v8, 0, sizeof(v8));
  long long v9 = 0u;
  memset(v10, 0, sizeof(v10));
  v4[3] = 0u;
  long long v5 = 0u;
  memset(v6, 0, sizeof(v6));
  sub_19E04721C((uint64_t)v4, a2);
  sub_19E0452CC(a1, (uint64_t *)v4);
  if ((void)v9) {
    MEMORY[0x19F3BA6E0](v9, 0x1000C8077774924);
  }
  if ((void)v7) {
    MEMORY[0x19F3BA6E0](v7, 0x1000C8077774924);
  }
  if ((void)v5) {
    MEMORY[0x19F3BA6E0](v5, 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v4[0];
  if (*(void *)&v4[0]) {
    return MEMORY[0x19F3BA6E0](*(void *)&v4[0], 0x1000C8077774924);
  }
  return result;
}

void sub_19E0461E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E0461FC(long long *a1, uint64_t *a2)
{
  memset(v7, 0, 41);
  sub_19E04D03C((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 4sub_19E03D880(&a9, 0) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_19E046294(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0462BC(long long *a1, uint64_t *a2)
{
  memset(v9, 0, 41);
  uint64_t v10 = 0;
  int v11 = 0;
  uint64_t v12 = 0;
  sub_19E047B2C((uint64_t)v9, a2);
  long long v3 = *a1;
  *a1 = v9[0];
  v9[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v9[1];
  *(void *)&v9[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v9[1] + 8);
  *(_OWORD *)((char *)&v9[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 4sub_19E03D880(&a9, 0) = BYTE8(v9[2]);
  BYTE8(v9[2]) = v4;
  uint64_t v6 = *((void *)a1 + 6);
  *((void *)a1 + 6) = v10;
  uint64_t v10 = v6;
  LODWORD(v6) = *((_DWORD *)a1 + 14);
  *((_DWORD *)a1 + 14) = v11;
  int v11 = v6;
  uint64_t v7 = *((void *)a1 + 8);
  *((void *)a1 + 8) = v12;
  uint64_t result = v3;
  uint64_t v12 = v7;
  if ((void)v3) {
    return MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_19E046390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0463B8(long long *a1, uint64_t *a2)
{
  memset(v7, 0, 41);
  sub_19E04778C((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 4sub_19E03D880(&a9, 0) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_19E046450(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E046478(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  if (*(void *)a4 == 0xFFFFFFFFLL)
  {
    MEMORY[0xFFFFFFFF] = 0xFFFFFFFFLL;
    if (*(char *)(a4 + 31) < 0)
    {
      long long v9 = *(void **)(a4 + 8);
      unint64_t v10 = *(void *)(a4 + 16);
      sub_19E03FA9C((unsigned char *)0x100000007, v9, v10);
    }
    else
    {
      MEMORY[0x100000007] = *(_OWORD *)(a4 + 8);
      MEMORY[0x100000017] = *(void *)(a4 + 24);
    }
    return;
  }
  unint64_t v27 = *(void *)a4;
  if (*(char *)(a4 + 31) < 0) {
    sub_19E03FA9C(&__p, *(void **)(a4 + 8), *(void *)(a4 + 16));
  }
  else {
    std::string __p = *(std::string *)(a4 + 8);
  }
  unint64_t v26 = 0;
  if (!a3)
  {
LABEL_20:
    *a5 = v27;
    unint64_t v14 = (std::string *)(a5 + 1);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_19E03FA9C(v14, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      *unint64_t v14 = __p;
    }
    goto LABEL_46;
  }
  unint64_t v11 = 0;
  while ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
      goto LABEL_23;
    }
    unint64_t v26 = v11 + 1;
    if (*(unsigned __int8 *)(a2 + v11) != *((unsigned __int8 *)&v27 + HIBYTE(__p.__r_.__value_.__r.__words[2]) + 7))
    {
LABEL_27:
      *a5 = 0xFFFFFFFFLL;
      a5[1] = 0;
      a5[2] = 0;
      a5[3] = 0;
      goto LABEL_46;
    }
    uint64_t v12 = HIBYTE(__p.__r_.__value_.__r.__words[2]) - 1;
    --*((unsigned char *)&__p.__r_.__value_.__s + 23);
    ++v11;
    p_p = &__p;
LABEL_19:
    p_p->__r_.__value_.__s.__data_[v12] = 0;
    if (v11 >= a3) {
      goto LABEL_20;
    }
  }
  if (__p.__r_.__value_.__l.__size_)
  {
    unint64_t v26 = v11 + 1;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (*(unsigned __int8 *)(a2 + v11) != *(unsigned __int8 *)(__p.__r_.__value_.__r.__words[0]
                                                              + __p.__r_.__value_.__l.__size_
                                                              - 1))
      goto LABEL_27;
    uint64_t v12 = --__p.__r_.__value_.__l.__size_;
    ++v11;
    goto LABEL_19;
  }
LABEL_23:
  memset(&__str, 0, sizeof(__str));
  while (v26 < a3)
  {
    if ((sub_19E0441BC(a1, a2, a3, &v26, &v27, &__str) & 1) == 0)
    {
      *a5 = 0xFFFFFFFFLL;
      a5[1] = 0;
      a5[2] = 0;
      a5[3] = 0;
      goto LABEL_44;
    }
  }
  std::string::basic_string(&v24, &__str, v26 - v11, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v29);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string __p = v24;
  char v15 = HIBYTE(v24.__r_.__value_.__r.__words[2]);
  std::string::size_type size = v24.__r_.__value_.__l.__size_;
  int v16 = (std::string *)v24.__r_.__value_.__r.__words[0];
  if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    int v16 = &__p;
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  uint64_t v18 = (std::string *)((char *)v16 + size - 1);
  if (size) {
    BOOL v19 = v18 > v16;
  }
  else {
    BOOL v19 = 0;
  }
  if (v19)
  {
    int v20 = &v16->__r_.__value_.__s.__data_[1];
    do
    {
      std::string::value_type v21 = *(v20 - 1);
      *(v20 - 1) = v18->__r_.__value_.__s.__data_[0];
      v18->__r_.__value_.__s.__data_[0] = v21;
      uint64_t v18 = (std::string *)((char *)v18 - 1);
    }
    while (v20++ < (char *)v18);
    char v15 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  *a5 = v27;
  uint64_t v23 = (std::string *)(a5 + 1);
  if (v15 < 0) {
    sub_19E03FA9C(v23, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    *uint64_t v23 = __p;
  }
LABEL_44:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
LABEL_46:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_19E04674C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E046788(uint64_t a1, std::string *a2, unint64_t a3)
{
  uint64_t v6 = a1 + 416;
  uint64_t v7 = (void *)(a1 + 744);
  while (1)
  {
    while (1)
    {
      unint64_t v8 = *(void *)(a1 + 1056) & a3;
      uint64_t v9 = *(void *)(a1 + 1024);
      if (a3 != *(_DWORD *)(v9 + 12 * v8 + 4)) {
        break;
      }
      unint64_t v10 = *(unsigned int *)(v9 + 12 * v8 + 8);
      if (v10 <= 0xFFFFFEFF)
      {
        uint64_t v20 = *(void *)(a1 + 1000);
        if (v20) {
          sub_19E046788(v20, a2, v10);
        }
        else {
          sub_19E04D994(v7, a2, v10);
        }
      }
      else
      {
        std::string::push_back(a2, v10);
      }
      a3 = *(unsigned int *)(*(void *)(a1 + 1024) + 12 * v8);
      if (!a3) {
        return;
      }
    }
    int v11 = *(unsigned __int8 *)(*(void *)(a1 + 640) + a3);
    if ((*(void *)(*(void *)(a1 + 432) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3))
    {
      uint64_t v12 = sub_19E04E2B8(v6, a3);
      uint64_t v13 = *(void *)(a1 + 720);
      unint64_t v14 = (unint64_t)(v13 * v12) >> 6;
      uint64_t v15 = (v13 * v12) & 0x3F;
      unint64_t v16 = v15 + v13;
      uint64_t v17 = *(void *)(a1 + 688);
      unint64_t v18 = *(void *)(v17 + 8 * v14);
      uint64_t v19 = v16 > 0x40
          ? ((2 * *(void *)(v17 + 8 * v14 + 8)) << (v15 ^ 0x3Fu)) | (v18 >> v15)
          : v18 >> v15;
      unint64_t v21 = v11 | ((*(_DWORD *)(a1 + 728) & v19) << 8);
      uint64_t v22 = *(void *)(a1 + 1000);
      if (v22) {
        sub_19E046788(v22, a2, v21);
      }
      else {
        sub_19E04D994(v7, a2, v21);
      }
    }
    else
    {
      std::string::push_back(a2, v11);
    }
    if (a3 <= *(void *)(a1 + 1064)) {
      break;
    }
    a3 = sub_19E04E66C((void *)a1, a3) + ~a3;
  }
}

uint64_t sub_19E046914(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  uint64_t v10 = a1 + 416;
  int v11 = (void *)(a1 + 744);
  while (1)
  {
    while (1)
    {
      unint64_t v12 = *(void *)(a1 + 1056) & a5;
      uint64_t v13 = *(void *)(a1 + 1024);
      if (a5 == *(_DWORD *)(v13 + 12 * v12 + 4)) {
        break;
      }
      if ((*(void *)(*(void *)(a1 + 432) + ((a5 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a5))
      {
        uint64_t v15 = *(void *)(a1 + 1000);
        int v16 = *(unsigned __int8 *)(*(void *)(a1 + 640) + a5);
        uint64_t v17 = sub_19E04E2B8(v10, a5);
        uint64_t v18 = *(void *)(a1 + 720);
        unint64_t v19 = (unint64_t)(v18 * v17) >> 6;
        uint64_t v20 = (v18 * v17) & 0x3F;
        unint64_t v21 = v20 + v18;
        uint64_t v22 = *(void *)(a1 + 688);
        unint64_t v23 = *(void *)(v22 + 8 * v19);
        if (v15)
        {
          unint64_t v24 = v23 >> v20;
          if (v21 > 0x40) {
            v24 |= (2 * *(void *)(v22 + 8 * v19 + 8)) << (v20 ^ 0x3Fu);
          }
          unint64_t v25 = v16 | ((*(_DWORD *)(a1 + 728) & v24) << 8);
          uint64_t v26 = *(void *)(a1 + 1000);
          if (v26)
          {
            if ((sub_19E046914(v26, a2, a3, a4, v25) & 1) == 0) {
              return 0;
            }
            goto LABEL_27;
          }
        }
        else
        {
          if (v21 > 0x40) {
            uint64_t v28 = ((2 * *(void *)(v22 + 8 * v19 + 8)) << (v20 ^ 0x3Fu)) | (v23 >> v20);
          }
          else {
            uint64_t v28 = v23 >> v20;
          }
          unint64_t v25 = v16 | ((*(_DWORD *)(a1 + 728) & v28) << 8);
        }
        if ((sub_19E04DA24(v11, a2, a3, a4, v25) & 1) == 0) {
          return 0;
        }
      }
      else
      {
        if (*(unsigned __int8 *)(*(void *)(a1 + 640) + a5) != *(unsigned __int8 *)(a2 + *a4)) {
          return 0;
        }
        ++*a4;
      }
LABEL_27:
      if (a5 <= *(void *)(a1 + 1064)) {
        return 1;
      }
      if (*a4 >= a3) {
        return 0;
      }
      a5 = sub_19E04E66C((void *)a1, a5) + ~a5;
    }
    unint64_t v14 = *(unsigned int *)(v13 + 12 * v12 + 8);
    if (v14 <= 0xFFFFFEFF)
    {
      uint64_t v27 = *(void *)(a1 + 1000);
      if (v27)
      {
        if ((sub_19E046914(v27, a2, a3, a4, v14) & 1) == 0) {
          return 0;
        }
      }
      else if ((sub_19E04DA24(v11, a2, a3, a4, v14) & 1) == 0)
      {
        return 0;
      }
    }
    else
    {
      if (*(unsigned __int8 *)(a2 + *a4) != v14) {
        return 0;
      }
      ++*a4;
    }
    a5 = *(unsigned int *)(*(void *)(a1 + 1024) + 12 * v12);
    if (!a5) {
      return 1;
    }
    if (*a4 >= a3) {
      return 0;
    }
  }
}

uint64_t sub_19E046B60(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, unint64_t a5, std::string *a6)
{
  uint64_t v12 = a1 + 416;
  uint64_t v13 = (void *)(a1 + 744);
  while (1)
  {
    unint64_t v14 = *(void *)(a1 + 1056) & a5;
    uint64_t v15 = *(void *)(a1 + 1024);
    if (a5 != *(_DWORD *)(v15 + 12 * v14 + 4))
    {
      int v17 = *(unsigned __int8 *)(*(void *)(a1 + 640) + a5);
      if ((*(void *)(*(void *)(a1 + 432) + ((a5 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a5))
      {
        uint64_t v18 = sub_19E04E2B8(v12, a5);
        uint64_t v19 = *(void *)(a1 + 720);
        unint64_t v20 = (unint64_t)(v19 * v18) >> 6;
        uint64_t v21 = (v19 * v18) & 0x3F;
        unint64_t v22 = v21 + v19;
        uint64_t v23 = *(void *)(a1 + 688);
        unint64_t v24 = *(void *)(v23 + 8 * v20);
        if (v22 > 0x40) {
          uint64_t v25 = ((2 * *(void *)(v23 + 8 * v20 + 8)) << (v21 ^ 0x3Fu)) | (v24 >> v21);
        }
        else {
          uint64_t v25 = v24 >> v21;
        }
        unint64_t v27 = v17 | ((*(_DWORD *)(a1 + 728) & v25) << 8);
        uint64_t v28 = *(void *)(a1 + 1000);
        if (v28)
        {
          if ((sub_19E046B60(v28, a2, a3, a4, v27, a6) & 1) == 0) {
            return 0;
          }
        }
        else if (!sub_19E04DAB8(v13, a2, a3, a4, v27, a6))
        {
          return 0;
        }
      }
      else
      {
        if (v17 != *(unsigned __int8 *)(a2 + *a4)) {
          return 0;
        }
        std::string::push_back(a6, v17);
        ++*a4;
      }
      if (a5 <= *(void *)(a1 + 1064)) {
        return 1;
      }
      a5 = sub_19E04E66C((void *)a1, a5) + ~a5;
      goto LABEL_23;
    }
    unint64_t v16 = *(unsigned int *)(v15 + 12 * v14 + 8);
    if (v16 > 0xFFFFFEFF)
    {
      if (*(unsigned __int8 *)(a2 + *a4) != v16) {
        return 0;
      }
      std::string::push_back(a6, v16);
      ++*a4;
      goto LABEL_22;
    }
    uint64_t v26 = *(void *)(a1 + 1000);
    if (!v26) {
      break;
    }
    if ((sub_19E046B60(v26, a2, a3, a4, v16, a6) & 1) == 0) {
      return 0;
    }
LABEL_22:
    a5 = *(unsigned int *)(*(void *)(a1 + 1024) + 12 * v14);
    if (!a5) {
      return 1;
    }
LABEL_23:
    if (*a4 >= a3)
    {
      sub_19E046788(a1, a6, a5);
      return 1;
    }
  }
  if (sub_19E04DAB8(v13, a2, a3, a4, v16, a6)) {
    goto LABEL_22;
  }
  return 0;
}

uint64_t sub_19E046DA0(void *a1, unsigned int a2)
{
  if (a2 >= 0x100000)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/config.h";
    exception[2] = 0x500000034;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/confi"
                   "g.h:52: MARISA_CODE_ERROR: (config_flags & ~MARISA_CONFIG_MASK) != 0";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  if ((a2 & 0x7F) != 0) {
    *a1 = a2 & 0x7F;
  }
  sub_19E046E68((uint64_t)a1, a2);
  sub_19E046F2C((uint64_t)a1, a2);

  return sub_19E046FC4((uint64_t)a1, a2);
}

uint64_t sub_19E046E68(uint64_t result, __int16 a2)
{
  unsigned int v2 = a2 & 0xF80;
  int v3 = 512;
  if (v2 > 0x1FF)
  {
    if (v2 == 512) {
      goto LABEL_11;
    }
    if (v2 != 1024)
    {
      int v3 = a2 & 0xF80;
      if (v2 != 2048) {
        goto LABEL_9;
      }
      goto LABEL_11;
    }
LABEL_10:
    int v3 = a2 & 0xF80;
    goto LABEL_11;
  }
  if ((a2 & 0xF80) == 0) {
    goto LABEL_11;
  }
  if (v2 == 128) {
    goto LABEL_10;
  }
  int v3 = a2 & 0xF80;
  if (v2 != 256)
  {
LABEL_9:
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/config.h";
    exception[2] = 0x500000060;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/confi"
                   "g.h:96: MARISA_CODE_ERROR: undefined cache level";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
LABEL_11:
  *(_DWORD *)(result + 8) = v3;
  return result;
}

uint64_t sub_19E046F2C(uint64_t result, __int16 a2)
{
  int v2 = 4096;
  int v3 = a2 & 0xF000;
  if ((a2 & 0xF000) != 0 && v3 != 4096)
  {
    if (v3 != 0x2000)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1EF099E88;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/config.h";
      exception[2] = 0x500000075;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/con"
                     "fig.h:117: MARISA_CODE_ERROR: undefined tail mode";
      __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
    }
    int v2 = 0x2000;
  }
  *(_DWORD *)(result + 12) = v2;
  return result;
}

uint64_t sub_19E046FC4(uint64_t result, int a2)
{
  int v2 = 0x20000;
  int v3 = a2 & 0xF0000;
  if ((a2 & 0xF0000) != 0 && v3 != 0x20000)
  {
    if (v3 != 0x10000)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1EF099E88;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/config.h";
      exception[2] = 0x50000008ALL;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/con"
                     "fig.h:138: MARISA_CODE_ERROR: undefined node order";
      __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
    }
    int v2 = 0x10000;
  }
  *(_DWORD *)(result + 16) = v2;
  return result;
}

uint64_t *sub_19E04705C(uint64_t *result, unint64_t a2, void *a3)
{
  unint64_t v4 = a2;
  long long v5 = result;
  unint64_t v6 = result[4];
  if (v6 < a2)
  {
    uint64_t v7 = 2 * v6;
    if (v6 >> 60) {
      uint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v6 > a2 >> 1) {
      a2 = v7;
    }
    uint64_t result = sub_19E0470E4(result, a2);
  }
  unint64_t v8 = v5[3];
  unint64_t v9 = v4 - v8;
  if (v4 > v8)
  {
    uint64_t v10 = (void *)(v5[1] + 8 * v8);
    do
    {
      *v10++ = *a3;
      --v9;
    }
    while (v9);
  }
  v5[3] = v4;
  return result;
}

void *sub_19E0470E4(uint64_t *a1, uint64_t a2)
{
  uint64_t result = operator new[](8 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    unint64_t v6 = (uint64_t *)a1[1];
    uint64_t v7 = result;
    do
    {
      uint64_t v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x19F3BA6E0);
  }
  return result;
}

void *sub_19E04717C(void *result)
{
  if (*((unsigned char *)result + 40))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vector.h";
    exception[2] = 0x100000072;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vec"
                   "tor.h:114: MARISA_STATE_ERROR: fixed_";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  uint64_t v1 = result[3];
  if (v1 != result[4])
  {
    return sub_19E0470E4(result, v1);
  }
  return result;
}

uint64_t sub_19E04721C(uint64_t a1, uint64_t *a2)
{
  sub_19E047308((long long *)a1, a2);
  *(void *)(a1 + 48) = *(unsigned int *)sub_19E0430B8(a2, 4uLL);
  unint64_t v4 = *(unsigned int *)sub_19E0430B8(a2, 4uLL);
  if (*(void *)(a1 + 48) < v4)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/bit-vector.h";
    exception[2] = 0xA00000086;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/bit"
                   "-vector.h:134: MARISA_FORMAT_ERROR: temp_num_1s > size_";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  *(void *)(a1 + 56) = v4;
  sub_19E0473C8((long long *)(a1 + 64), a2);
  sub_19E047488((long long *)(a1 + 112), a2);

  return sub_19E047488((long long *)(a1 + 160), a2);
}

uint64_t sub_19E047308(long long *a1, uint64_t *a2)
{
  memset(v7, 0, 41);
  sub_19E047548((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 4sub_19E03D880(&a9, 0) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_19E0473A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0473C8(long long *a1, uint64_t *a2)
{
  memset(v7, 0, 41);
  sub_19E04778C((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 4sub_19E03D880(&a9, 0) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_19E047460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E047488(long long *a1, uint64_t *a2)
{
  memset(v7, 0, 41);
  sub_19E04796C((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 4sub_19E03D880(&a9, 0) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_19E047520(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E047548(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = *(void *)sub_19E0430B8(a2, 8uLL);
  if ((v4 & 7) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vector.h";
    exception[2] = 0xA000000D2;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vec"
                   "tor.h:210: MARISA_FORMAT_ERROR: (total_size % sizeof(T)) != 0";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  sub_19E047628(a2, (uint64_t *)(a1 + 16), v4 >> 3);
  sub_19E042FDC(a2, -(int)v4 & 7);
  *(void *)(a1 + 24) = v4 >> 3;

  return sub_19E047708(a1);
}

uint64_t sub_19E047628(uint64_t *a1, uint64_t *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h";
    exception[2] = 0x20000001FLL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h:31: MARI"
         "SA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >> 61)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h";
    exception[2] = 0x700000020;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h:32: MARI"
         "SA_SIZE_ERROR: num_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v6;
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  uint64_t result = sub_19E0430B8(a1, 8 * a3);
  *a2 = result;
  return result;
}

uint64_t sub_19E047708(uint64_t result)
{
  if (*(unsigned char *)(result + 40))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vector.h";
    exception[2] = 0x10000007ALL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vec"
                   "tor.h:122: MARISA_STATE_ERROR: fixed_";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  *(unsigned char *)(result + 4sub_19E03D880(&a9, 0) = 1;
  return result;
}

uint64_t sub_19E04778C(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = *(void *)sub_19E0430B8(a2, 8uLL);
  unint64_t v5 = v4 / 0xC;
  if (v4 % 0xC)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vector.h";
    exception[2] = 0xA000000D2;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vec"
                   "tor.h:210: MARISA_FORMAT_ERROR: (total_size % sizeof(T)) != 0";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  sub_19E04787C(a2, (uint64_t *)(a1 + 16), v5);
  sub_19E042FDC(a2, -(int)v4 & 7);
  *(void *)(a1 + 24) = v5;

  return sub_19E047708(a1);
}

uint64_t sub_19E04787C(uint64_t *a1, uint64_t *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h";
    exception[2] = 0x20000001FLL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h:31: MARI"
         "SA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >= 0x1555555555555556)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h";
    exception[2] = 0x700000020;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h:32: MARI"
         "SA_SIZE_ERROR: num_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v6;
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  uint64_t result = sub_19E0430B8(a1, 12 * a3);
  *a2 = result;
  return result;
}

uint64_t sub_19E04796C(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = *(void *)sub_19E0430B8(a2, 8uLL);
  if ((v4 & 3) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vector.h";
    exception[2] = 0xA000000D2;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vec"
                   "tor.h:210: MARISA_FORMAT_ERROR: (total_size % sizeof(T)) != 0";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  sub_19E047A4C(a2, (uint64_t *)(a1 + 16), v4 >> 2);
  sub_19E042FDC(a2, -(int)v4 & 7);
  *(void *)(a1 + 24) = v4 >> 2;

  return sub_19E047708(a1);
}

uint64_t sub_19E047A4C(uint64_t *a1, uint64_t *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h";
    exception[2] = 0x20000001FLL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h:31: MARI"
         "SA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >> 62)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h";
    exception[2] = 0x700000020;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/mapper.h:32: MARI"
         "SA_SIZE_ERROR: num_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v6;
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  uint64_t result = sub_19E0430B8(a1, 4 * a3);
  *a2 = result;
  return result;
}

void *sub_19E047B2C(uint64_t a1, uint64_t *a2)
{
  sub_19E047308((long long *)a1, a2);
  uint64_t v4 = *(unsigned int *)sub_19E0430B8(a2, 4uLL);
  if (v4 >= 0x21)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/flat-vector.h";
    exception[2] = 0xA00000084;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/fla"
                   "t-vector.h:132: MARISA_FORMAT_ERROR: temp_value_size > 32";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  *(void *)(a1 + 48) = v4;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)sub_19E0430B8(a2, 4uLL);
  uint64_t result = (void *)sub_19E0430B8(a2, 8uLL);
  *(void *)(a1 + 64) = *result;
  return result;
}

uint64_t *sub_19E047BF8(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  long long v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 >> 60) {
      uint64_t v5 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    uint64_t result = sub_19E0470E4(result, a2);
  }
  v3[3] = v2;
  return result;
}

void sub_19E047C50(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  unint64_t v4 = a1[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 > 0xAAAAAAAAAAAAAAALL) {
      uint64_t v5 = 0x1555555555555555;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    sub_19E047CD4(a1, a2);
  }
  unint64_t v6 = a1[3];
  if (v2 > v6) {
    bzero((void *)(a1[1] + 12 * v6), 12 * (v2 - v6));
  }
  a1[3] = v2;
}

_DWORD *sub_19E047CD4(uint64_t *a1, uint64_t a2)
{
  uint64_t result = operator new[](12 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    unint64_t v6 = (uint64_t *)a1[1];
    uint64_t v7 = result;
    do
    {
      uint64_t v8 = *v6;
      v7[2] = *((_DWORD *)v6 + 2);
      *(void *)uint64_t v7 = v8;
      v7 += 3;
      unint64_t v6 = (uint64_t *)((char *)v6 + 12);
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x19F3BA6E0);
  }
  return result;
}

uint64_t *sub_19E047D7C(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  long long v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 >> 61) {
      uint64_t v5 = 0x3FFFFFFFFFFFFFFFLL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    uint64_t result = (uint64_t *)sub_19E047DD4(result, a2);
  }
  v3[3] = v2;
  return result;
}

_DWORD *sub_19E047DD4(uint64_t *a1, uint64_t a2)
{
  uint64_t result = operator new[](4 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    unint64_t v6 = (int *)a1[1];
    uint64_t v7 = result;
    do
    {
      int v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x19F3BA6E0);
  }
  return result;
}

uint64_t sub_19E047E6C(uint64_t a1, uint64_t a2)
{
  sub_19E047EF0(a1, a2);
  int __buf = *(void *)(a1 + 48);
  sub_19E042B74(a2, (char *)&__buf, 4uLL);
  int v5 = *(void *)(a1 + 56);
  sub_19E042B74(a2, (char *)&v5, 4uLL);
  sub_19E04802C(a1 + 64, a2);
  sub_19E048180(a1 + 112, a2);
  return sub_19E048180(a1 + 160, a2);
}

uint64_t sub_19E047EF0(uint64_t a1, uint64_t a2)
{
  uint64_t __buf = 8 * *(void *)(a1 + 24);
  sub_19E042B74(a2, (char *)&__buf, 8uLL);
  sub_19E047F50(a2, *(char **)(a1 + 16), *(void *)(a1 + 24));
  return sub_19E042A38(a2, 0);
}

uint64_t sub_19E047F50(uint64_t a1, char *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h";
    exception[2] = 0x200000021;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h:33: MARI"
         "SA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
    goto LABEL_9;
  }
  if (a3 >> 61)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h";
    exception[2] = 0x700000022;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h:34: MARI"
         "SA_SIZE_ERROR: num_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_9:
    exception[3] = v6;
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  size_t v3 = 8 * a3;

  return sub_19E042B74(a1, a2, v3);
}

uint64_t sub_19E04802C(uint64_t a1, uint64_t a2)
{
  uint64_t __buf = 12 * *(void *)(a1 + 24);
  sub_19E042B74(a2, (char *)&__buf, 8uLL);
  sub_19E048094(a2, *(char **)(a1 + 16), *(void *)(a1 + 24));
  return sub_19E042A38(a2, 4 * (*(_DWORD *)(a1 + 24) & 1));
}

uint64_t sub_19E048094(uint64_t a1, char *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h";
    exception[2] = 0x200000021;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h:33: MARI"
         "SA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
    goto LABEL_9;
  }
  if (a3 >= 0x1555555555555556)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h";
    exception[2] = 0x700000022;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h:34: MARI"
         "SA_SIZE_ERROR: num_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_9:
    exception[3] = v6;
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  size_t v3 = 12 * a3;

  return sub_19E042B74(a1, a2, v3);
}

uint64_t sub_19E048180(uint64_t a1, uint64_t a2)
{
  uint64_t __buf = 4 * *(void *)(a1 + 24);
  sub_19E042B74(a2, (char *)&__buf, 8uLL);
  sub_19E0481E4(a2, *(char **)(a1 + 16), *(void *)(a1 + 24));
  return sub_19E042A38(a2, 4 * (*(_DWORD *)(a1 + 24) & 1));
}

uint64_t sub_19E0481E4(uint64_t a1, char *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h";
    exception[2] = 0x200000021;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h:33: MARI"
         "SA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
    goto LABEL_9;
  }
  if (a3 >> 62)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h";
    exception[2] = 0x700000022;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h:34: MARI"
         "SA_SIZE_ERROR: num_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_9:
    exception[3] = v6;
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  size_t v3 = 4 * a3;

  return sub_19E042B74(a1, a2, v3);
}

uint64_t sub_19E0482C0(uint64_t a1, uint64_t a2)
{
  sub_19E047EF0(a1, a2);
  LODWORD(__buf) = *(void *)(a1 + 48);
  sub_19E042B74(a2, (char *)&__buf, 4uLL);
  LODWORD(__buf) = *(_DWORD *)(a1 + 56);
  sub_19E042B74(a2, (char *)&__buf, 4uLL);
  uint64_t __buf = *(void *)(a1 + 64);
  return sub_19E042B74(a2, (char *)&__buf, 8uLL);
}

void *sub_19E048338(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v6 = result;
  if (a6 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E04147C();
  }
  if (a6 > 0x16)
  {
    uint64_t v10 = (a6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a6 | 7) != 0x17) {
      uint64_t v10 = a6 | 7;
    }
    uint64_t v11 = v10 + 1;
    uint64_t result = operator new(v10 + 1);
    v6[1] = a6;
    v6[2] = v11 | 0x8000000000000000;
    void *v6 = result;
    unint64_t v6 = result;
  }
  else
  {
    *((unsigned char *)result + 23) = a6;
  }
  while (a3 != a5)
  {
    char v12 = *(unsigned char *)--a3;
    *(unsigned char *)unint64_t v6 = v12;
    unint64_t v6 = (void *)((char *)v6 + 1);
  }
  *(unsigned char *)unint64_t v6 = 0;
  return result;
}

void sub_19E0483E0()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = &unk_1EF09D008;
  __cxa_throw(exception, (struct type_info *)&unk_1EF09B608, (void (*)(void *))std::exception::~exception);
}

void sub_19E048430(std::exception *a1)
{
  std::exception::~exception(a1);

  JUMPOUT(0x19F3BA710);
}

char *sub_19E048468(uint64_t *a1, uint64_t a2)
{
  uint64_t result = (char *)operator new[](24 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    unint64_t v6 = (_DWORD *)(a1[1] + 16);
    uint64_t v7 = result + 16;
    do
    {
      *((void *)v7 - 2) = *((void *)v6 - 2);
      *(v7 - 2) = *(v6 - 2);
      *(v7 - 1) = *(v6 - 1);
      int v8 = *v6;
      v6 += 6;
      _DWORD *v7 = v8;
      v7 += 6;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x19F3BA6E0);
  }
  return result;
}

uint64_t sub_19E048520(uint64_t *a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a2 + 24);
  unint64_t v10 = *(void *)(a2 + 8);
  if (v9)
  {
    uint64_t v11 = 0;
    char v12 = (_DWORD *)(v10 + 16);
    do
    {
      _DWORD *v12 = v11;
      v12 += 6;
      ++v11;
    }
    while (v9 != v11);
  }
  unint64_t v13 = sub_19E049098(v10, v10 + 24 * v9, 0);
  uint64_t v14 = 256;
  if (a5 != 1) {
    uint64_t v14 = 1;
  }
  do
  {
    unint64_t v15 = v14;
    v14 *= 2;
  }
  while (v15 < v13 / *(unsigned int *)(a4 + 8));
  sub_19E045F70(a1 + 126, v15);
  a1[132] = v15 - 1;
  sub_19E045680(a1, 1);
  sub_19E045680(a1, 0);
  unint64_t v16 = a1 + 78;
  LOBYTE(v84[0]) = 0;
  sub_19E048D84(a1 + 78, v84);
  v77 = a1 + 52;
  sub_19E045680(a1 + 52, 0);
  uint64_t v72 = a5;
  memset(v84, 0, 41);
  long long v83 = 0u;
  memset(v82, 0, sizeof(v82));
  long long v80 = 0u;
  memset(v81, 0, 25);
  v78.n128_u64[0] = *(void *)(a2 + 24) << 32;
  v78.n128_u32[2] = 0;
  sub_19E04976C(v82, (uint64_t *)&v78);
  uint64_t v17 = *((void *)&v83 + 1);
  if (*((void *)&v83 + 1))
  {
    v73 = a1 + 78;
    do
    {
      uint64_t v18 = a1[58];
      uint64_t v19 = (unsigned int *)(*(void *)(*((void *)&v82[0] + 1) + 8 * ((unint64_t)v83 / 0x155))
                           + 12 * ((unint64_t)v83 % 0x155));
      uint64_t v20 = *v19;
      unint64_t v21 = v19[1];
      uint64_t v22 = v19[2];
      *(void *)&long long v83 = v83 + 1;
      *((void *)&v83 + 1) = v17 - 1;
      if ((unint64_t)v83 >= 0x2AA)
      {
        uint64_t v23 = v18;
        operator delete(**((void ***)&v82[0] + 1));
        uint64_t v18 = v23;
        *((void *)&v82[0] + 1) += 8;
        *(void *)&long long v83 = v83 - 341;
      }
      uint64_t v76 = v17;
      uint64_t v24 = v18 - v17;
      if (v20 < v21)
      {
        while (1)
        {
          uint64_t v25 = *(void *)(a2 + 8);
          if (*(_DWORD *)(v25 + 24 * v20 + 8) != v22) {
            break;
          }
          *(_DWORD *)(v25 + 24 * v20 + 12) = v24;
          uint64_t v20 = (v20 + 1);
          if (v21 == v20) {
            goto LABEL_49;
          }
        }
      }
      if (v20 != v21)
      {
        uint64_t v75 = v18;
        uint64_t v26 = v80;
        long long v80 = 0u;
        memset(v81, 0, 25);
        if (v26) {
          MEMORY[0x19F3BA6E0](v26, 0x1000C8077774924);
        }
        uint64_t v27 = *(void *)(a2 + 8);
        double v28 = *(float *)(v27 + 24 * v20 + 12);
        uint64_t v29 = v20 + 1;
        if (v20 + 1 < v21)
        {
          uint64_t v30 = 24 * v20;
          uint64_t v31 = (v20 << 32) + 0x100000000;
          do
          {
            if (*(unsigned __int8 *)(*(void *)(v27 + v30) + v22) != *(unsigned __int8 *)(*(void *)(v27 + v30 + 24)
                                                                                          + v22))
            {
              *(float *)&unsigned int v32 = v28;
              v78.n128_u64[0] = v31 + v20;
              v78.n128_u64[1] = v22 | ((unint64_t)v32 << 32);
              sub_19E048DF0((uint64_t *)&v80, &v78);
              uint64_t v27 = *(void *)(a2 + 8);
              double v28 = 0.0;
              LODWORD(v2sub_19E03D880(&a9, 0) = v29;
            }
            double v28 = v28 + *(float *)(v27 + v30 + 36);
            ++v29;
            v30 += 24;
            v31 += 0x100000000;
          }
          while (v21 != v29);
        }
        *(float *)&unsigned int v33 = v28;
        v78.n128_u32[0] = v20;
        v78.n128_u32[1] = v21;
        v78.n128_u64[1] = v22 | ((unint64_t)v33 << 32);
        __n128 v34 = sub_19E048DF0((uint64_t *)&v80, &v78);
        unint64_t v16 = a1 + 78;
        uint64_t v35 = v75;
        if (*(_DWORD *)(a4 + 16) == 0x20000)
        {
          unint64_t v36 = (__n128 *)*((void *)&v80 + 1);
          unint64_t v37 = v81[1];
          if (v81[1] < 129)
          {
            unsigned __int8 v38 = 0;
            uint64_t v40 = 0;
          }
          else
          {
            unsigned __int8 v38 = (__n128 *)sub_19E04A080(v81[1]);
            uint64_t v40 = v39;
          }
          sub_19E04A0E4(v36, &v36[v37], (uint64_t)&v78, v37, v38, v40, v34);
          if (v38) {
            operator delete(v38);
          }
          uint64_t v35 = v75;
        }
        uint64_t v41 = v81[1];
        if (v35 == v76) {
          a1[133] = v81[1];
        }
        if (v41)
        {
          unint64_t v42 = 0;
          do
          {
            uint64_t v43 = (unsigned int *)(*((void *)&v80 + 1) + 16 * v42);
            uint64_t v44 = (uint64_t *)v43;
            uint64_t v45 = v43[2];
            unsigned int v46 = *v43;
            uint64_t v47 = *(void *)(a2 + 8);
            unint64_t v48 = *(unsigned int *)(v47 + 24 * *v43 + 8);
            unint64_t v49 = v45 + 1;
            if (v45 + 1 >= v48)
            {
              unint64_t v50 = v43[2];
              LODWORD(v48) = v45 + 1;
            }
            else
            {
              unint64_t v50 = v48 - 1;
              unint64_t v51 = v43[2];
              do
              {
                unint64_t v52 = v51;
                unint64_t v51 = v49;
                uint64_t v53 = (uint64_t *)(v47 + 24 * v46);
                uint64_t v54 = *v43;
                while (++v54 < (unint64_t)v43[1])
                {
                  uint64_t v55 = *v53;
                  uint64_t v56 = v53[3];
                  v53 += 3;
                  if (*(unsigned __int8 *)(v55 + v51) != *(unsigned __int8 *)(v56 + v51))
                  {
                    unint64_t v50 = v52;
                    LODWORD(v48) = v51;
                    goto LABEL_43;
                  }
                }
                unint64_t v49 = v51 + 1;
              }
              while (v51 + 1 != v48);
            }
LABEL_43:
            float v58 = *((float *)v43 + 3);
            v57 = v43 + 3;
            float v59 = v58;
            uint64_t v60 = ((32 * v24) ^ v24 ^ *(unsigned __int8 *)(*(void *)(v47 + 24 * v46) + v45)) & a1[132];
            uint64_t v61 = a1[127];
            uint64_t v62 = v61 + 12 * v60;
            float v64 = *(float *)(v62 + 8);
            v63 = (float *)(v62 + 8);
            if (v64 < v59)
            {
              uint64_t v65 = a1[81];
              v66 = (_DWORD *)(v61 + 12 * v60);
              _DWORD *v66 = v24;
              v66[1] = v65;
              float *v63 = v59;
              uint64_t v45 = *((unsigned int *)v44 + 2);
            }
            if (v50 == v45)
            {
              v78.n128_u8[0] = *(unsigned char *)(*(void *)(*(void *)(a2 + 8) + 24 * *(unsigned int *)v44) + v50);
              sub_19E048D84(v73, &v78);
              sub_19E045680(v77, 0);
            }
            else
            {
              v78.n128_u8[0] = 0;
              sub_19E048D84(v73, &v78);
              sub_19E045680(v77, 1);
              __n128 v78 = 0uLL;
              int v79 = 0;
              uint64_t v67 = *((unsigned int *)v44 + 2);
              v78.n128_u64[0] = *(void *)(*(void *)(a2 + 8) + 24 * *(unsigned int *)v44) + v67;
              v78.n128_u64[1] = (v48 - v67);
              v78.n128_u32[3] = *v57;
              sub_19E048E64((uint64_t *)v84, (uint64_t)&v78);
            }
            *((_DWORD *)v44 + 2) = v48;
            sub_19E04976C(v82, v44);
            sub_19E045680(a1, 1);
            ++v42;
          }
          while (v42 < v81[1]);
        }
      }
LABEL_49:
      sub_19E045680(a1, 0);
      uint64_t v17 = *((void *)&v83 + 1);
    }
    while (*((void *)&v83 + 1));
  }
  sub_19E045680(a1, 0);
  sub_19E045778((uint64_t)a1, v72 == 1, 1);
  sub_19E048F00(v16);
  sub_19E048FA0((uint64_t)a1, a2, a3);
  long long v68 = *(_OWORD *)a2;
  *(_OWORD *)a2 = v84[0];
  v84[0] = v68;
  uint64_t v69 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = *(void *)&v84[1];
  *(void *)&v84[1] = v69;
  long long v70 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)&v84[1] + 8);
  *(_OWORD *)((char *)&v84[1] + 8) = v70;
  LOBYTE(v69) = *(unsigned char *)(a2 + 40);
  *(unsigned char *)(a2 + 4sub_19E03D880(&a9, 0) = BYTE8(v84[2]);
  BYTE8(v84[2]) = v69;
  if ((void)v80) {
    MEMORY[0x19F3BA6E0](v80, 0x1000C8077774924);
  }
  sub_19E04AB14(v82);
  uint64_t result = *(void *)&v84[0];
  if (*(void *)&v84[0]) {
    return MEMORY[0x19F3BA6E0](*(void *)&v84[0], 0x1000C8077774924);
  }
  return result;
}

void sub_19E048B68(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, ...)
{
  va_start(va, a18);
  if (a13) {
    MEMORY[0x19F3BA6E0](a13, 0x1000C8077774924);
  }
  sub_19E04AB14((uint64_t *)va);
  uint64_t v21 = *(void *)(v18 - 144);
  if (v21) {
    MEMORY[0x19F3BA6E0](v21, 0x1000C8077774924);
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x8000001D3;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/louds"
                   "-trie.cc:467: MARISA_MEMORY_ERROR: std::bad_alloc";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E048C88(long long *a1, uint64_t a2)
{
  memset(v9, 0, 41);
  uint64_t v10 = 0;
  int v11 = 0;
  uint64_t v12 = 0;
  sub_19E04AC0C((uint64_t)v9, a2);
  long long v3 = *a1;
  *a1 = v9[0];
  v9[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v9[1];
  *(void *)&v9[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v9[1] + 8);
  *(_OWORD *)((char *)&v9[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 4sub_19E03D880(&a9, 0) = BYTE8(v9[2]);
  BYTE8(v9[2]) = v4;
  uint64_t v6 = *((void *)a1 + 6);
  *((void *)a1 + 6) = v10;
  uint64_t v10 = v6;
  LODWORD(v6) = *((_DWORD *)a1 + 14);
  *((_DWORD *)a1 + 14) = v11;
  int v11 = v6;
  uint64_t v7 = *((void *)a1 + 8);
  *((void *)a1 + 8) = v12;
  uint64_t result = v3;
  uint64_t v12 = v7;
  if ((void)v3) {
    return MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_19E048D5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_19E048D84(uint64_t *result, unsigned char *a2)
{
  long long v3 = result;
  uint64_t v4 = result[3];
  uint64_t v5 = result[4];
  size_t v6 = v4 + 1;
  if (v5 < (unint64_t)(v4 + 1))
  {
    uint64_t v7 = 2 * v5;
    if (v5 < 0) {
      uint64_t v7 = -1;
    }
    if (v5 <= v6 >> 1) {
      size_t v8 = v6;
    }
    else {
      size_t v8 = v7;
    }
    uint64_t result = (uint64_t *)sub_19E0496D4(result, v8);
    uint64_t v4 = v3[3];
  }
  *(unsigned char *)(v3[1] + v4) = *a2;
  ++v3[3];
  return result;
}

__n128 sub_19E048DF0(uint64_t *a1, __n128 *a2)
{
  uint64_t v4 = a1[3];
  unint64_t v5 = a1[4];
  unint64_t v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    uint64_t v7 = 2 * v5;
    if (v5 >> 59) {
      uint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
    }
    if (v5 <= v6 >> 1) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = v7;
    }
    sub_19E049FE8(a1, v8);
    uint64_t v4 = a1[3];
  }
  __n128 result = *a2;
  *(__n128 *)(a1[1] + 16 * v4) = *a2;
  ++a1[3];
  return result;
}

uint64_t *sub_19E048E64(uint64_t *result, uint64_t a2)
{
  long long v3 = result;
  uint64_t v4 = result[3];
  unint64_t v5 = result[4];
  unint64_t v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    uint64_t v7 = 2 * v5;
    if (v5 > 0x555555555555555) {
      uint64_t v7 = 0xAAAAAAAAAAAAAAALL;
    }
    if (v5 <= v6 >> 1) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = v7;
    }
    __n128 result = (uint64_t *)sub_19E048468(result, v8);
    uint64_t v4 = v3[3];
  }
  uint64_t v9 = v3[1] + 24 * v4;
  *(void *)uint64_t v9 = *(void *)a2;
  *(_DWORD *)(v9 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v9 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(v9 + 16) = *(_DWORD *)(a2 + 16);
  ++v3[3];
  return result;
}

unsigned char *sub_19E048F00(unsigned char *result)
{
  if (result[40])
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vector.h";
    exception[2] = 0x100000072;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vec"
                   "tor.h:114: MARISA_STATE_ERROR: fixed_";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  size_t v1 = *((void *)result + 3);
  if (v1 != *((void *)result + 4))
  {
    return sub_19E0496D4((uint64_t *)result, v1);
  }
  return result;
}

uint64_t sub_19E048FA0(uint64_t a1, uint64_t a2, long long *a3)
{
  memset(v13, 0, 41);
  sub_19E047D7C((uint64_t *)v13, *(void *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5)
  {
    uint64_t v6 = *((void *)&v13[0] + 1);
    uint64_t v7 = (unsigned int *)(*(void *)(a2 + 16) + 16);
    do
    {
      *(_DWORD *)(v6 + 4 * *v7) = *(v7 - 1);
      v7 += 6;
      --v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v6 = *((void *)&v13[0] + 1);
  }
  long long v8 = *a3;
  uint64_t v9 = *(void *)&v13[1];
  *(void *)a3 = *(void *)&v13[0];
  *((void *)a3 + 1) = v6;
  v13[0] = v8;
  uint64_t v10 = *((void *)a3 + 2);
  *((void *)a3 + 2) = v9;
  *(void *)&v13[1] = v10;
  long long v11 = *(long long *)((char *)a3 + 24);
  *(long long *)((char *)a3 + 24) = *(_OWORD *)((char *)&v13[1] + 8);
  *(_OWORD *)((char *)&v13[1] + 8) = v11;
  LOBYTE(v1sub_19E03D880(&a9, 0) = *((unsigned char *)a3 + 40);
  *((unsigned char *)a3 + 4sub_19E03D880(&a9, 0) = BYTE8(v13[2]);
  uint64_t result = v8;
  BYTE8(v13[2]) = v10;
  if ((void)v8) {
    return MEMORY[0x19F3BA6E0](v8, 0x1000C8077774924);
  }
  return result;
}

void sub_19E049070(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E049098(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = a2;
  unint64_t v5 = a1;
  uint64_t v6 = a2 - a1;
  if ((uint64_t)(a2 - a1) < 241)
  {
    uint64_t v7 = 0;
    goto LABEL_69;
  }
  uint64_t v7 = 0;
  do
  {
    int v8 = sub_19E049514(v5, v5 + 24 * (v6 / 0x30uLL), v4 - 24, a3);
    int v9 = v8;
    unint64_t v10 = v5;
    unint64_t v11 = v4;
    unint64_t v12 = v5;
    unint64_t v13 = v4;
    while (v10 < v11)
    {
      unint64_t v14 = *(unsigned int *)(v10 + 8);
      int v15 = a3 >= v14 ? -1 : *(unsigned __int8 *)(*(void *)v10 + a3);
      if (v15 > v8) {
        break;
      }
      if (v15 == v8)
      {
        uint64_t v16 = *(void *)v10;
        *(void *)unint64_t v10 = *(void *)v12;
        *(_DWORD *)(v10 + 8) = *(_DWORD *)(v12 + 8);
        uint64_t v17 = *(void *)(v10 + 12);
        *(_DWORD *)(v10 + 12) = *(_DWORD *)(v12 + 12);
        *(_DWORD *)(v10 + 16) = *(_DWORD *)(v12 + 16);
        *(void *)unint64_t v12 = v16;
        *(_DWORD *)(v12 + 8) = v14;
        *(void *)(v12 + 12) = v17;
        v12 += 24;
      }
LABEL_11:
      v10 += 24;
    }
    if (v10 < v11)
    {
      unint64_t v18 = v11 - 24;
      do
      {
        unint64_t v11 = v18;
        unint64_t v19 = *(unsigned int *)(v18 + 8);
        if (a3 >= v19) {
          int v20 = -1;
        }
        else {
          int v20 = *(unsigned __int8 *)(*(void *)v11 + a3);
        }
        if (v20 < v8) {
          break;
        }
        if (v20 == v8)
        {
          uint64_t v21 = *(void *)(v13 - 24);
          v13 -= 24;
          uint64_t v22 = *(void *)v11;
          *(void *)unint64_t v11 = v21;
          *(_DWORD *)(v11 + 8) = *(_DWORD *)(v13 + 8);
          uint64_t v23 = *(void *)(v11 + 12);
          *(_DWORD *)(v11 + 12) = *(_DWORD *)(v13 + 12);
          *(_DWORD *)(v11 + 16) = *(_DWORD *)(v13 + 16);
          *(void *)unint64_t v13 = v22;
          *(_DWORD *)(v13 + 8) = v19;
          *(void *)(v13 + 12) = v23;
        }
        unint64_t v18 = v11 - 24;
      }
      while (v10 < v11);
    }
    if (v10 < v11)
    {
      uint64_t v24 = *(void *)v10;
      int v25 = *(_DWORD *)(v10 + 16);
      *(void *)unint64_t v10 = *(void *)v11;
      uint64_t v26 = *(void *)(v10 + 8);
      *(_DWORD *)(v10 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v10 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v10 + 16) = *(_DWORD *)(v11 + 16);
      *(void *)unint64_t v11 = v24;
      *(void *)(v11 + 8) = v26;
      *(_DWORD *)(v11 + 16) = v25;
      goto LABEL_11;
    }
    uint64_t v44 = v7;
    if (v12 > v5)
    {
      uint64_t v27 = 0;
      do
      {
        uint64_t v28 = v12 + v27;
        uint64_t v29 = v10 + v27;
        uint64_t v30 = *(void *)(v12 + v27 - 24);
        int v31 = *(_DWORD *)(v12 + v27 - 8);
        *(void *)(v28 - 24) = *(void *)(v10 + v27 - 24);
        uint64_t v32 = *(void *)(v12 + v27 - 16);
        *(_DWORD *)(v28 - 16) = *(_DWORD *)(v10 + v27 - 16);
        *(_DWORD *)(v28 - 12) = *(_DWORD *)(v10 + v27 - 12);
        *(_DWORD *)(v28 - 8) = *(_DWORD *)(v10 + v27 - 8);
        *(void *)(v29 - 24) = v30;
        *(void *)(v29 - 16) = v32;
        *(_DWORD *)(v29 - 8) = v31;
        v27 -= 24;
      }
      while (v12 + v27 > v5);
      v10 += v27;
    }
    while (v13 < v4)
    {
      uint64_t v33 = *(void *)v13;
      int v34 = *(_DWORD *)(v13 + 16);
      *(void *)unint64_t v13 = *(void *)v11;
      uint64_t v35 = *(void *)(v13 + 8);
      *(_DWORD *)(v13 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v13 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v13 + 16) = *(_DWORD *)(v11 + 16);
      *(void *)unint64_t v11 = v33;
      *(void *)(v11 + 8) = v35;
      *(_DWORD *)(v11 + 16) = v34;
      v11 += 24;
      v13 += 24;
    }
    uint64_t v36 = v10 - v5;
    int64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v5) >> 3);
    uint64_t v38 = v11 - v10;
    int64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v10) >> 3);
    if (v37 <= v39)
    {
      uint64_t v40 = v4 - v11;
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)) <= v39)
      {
        if (v36 == 24)
        {
          uint64_t v41 = v44 + 1;
        }
        else
        {
          if (v36 < 25) {
            goto LABEL_53;
          }
          uint64_t v41 = sub_19E049098(v5, v10, a3) + v44;
        }
        uint64_t v44 = v41;
LABEL_53:
        if (v40 == 24)
        {
          uint64_t v7 = v44 + 1;
        }
        else if (v40 < 25)
        {
          uint64_t v7 = v44;
        }
        else
        {
          uint64_t v7 = sub_19E049098(v11, v4, a3) + v44;
        }
        if (v38 == 24)
        {
          ++v7;
        }
        else if (v38 >= 25)
        {
          if (v9 == -1)
          {
            ++v7;
            unint64_t v5 = v11;
            goto LABEL_64;
          }
          ++a3;
        }
        unint64_t v5 = v10;
LABEL_64:
        unint64_t v4 = v11;
        goto LABEL_65;
      }
    }
    if (v38 == 24) {
      goto LABEL_32;
    }
    if (v38 < 25)
    {
      uint64_t v7 = v44;
    }
    else if (v8 == -1)
    {
LABEL_32:
      uint64_t v7 = v44 + 1;
    }
    else
    {
      uint64_t v7 = sub_19E049098(v10, v11, a3 + 1) + v44;
    }
    uint64_t v42 = v4 - v11;
    if (v37 >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)))
    {
      if (v42 == 24)
      {
        ++v7;
      }
      else if (v42 >= 25)
      {
        v7 += sub_19E049098(v11, v4, a3);
      }
      unint64_t v4 = v10;
    }
    else
    {
      if (v36 == 24)
      {
        ++v7;
      }
      else if (v36 >= 25)
      {
        v7 += sub_19E049098(v5, v10, a3);
      }
      unint64_t v5 = v11;
    }
LABEL_65:
    uint64_t v6 = v4 - v5;
  }
  while ((uint64_t)(v4 - v5) > 240);
LABEL_69:
  if (v6 >= 25) {
    v7 += sub_19E049588(v5, v4, a3);
  }
  return v7;
}

uint64_t sub_19E049514(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(unsigned int *)(a1 + 8) <= a4) {
    int v4 = -1;
  }
  else {
    int v4 = *(unsigned __int8 *)(*(void *)a1 + a4);
  }
  if (*(unsigned int *)(a2 + 8) <= a4) {
    int v5 = -1;
  }
  else {
    int v5 = *(unsigned __int8 *)(*(void *)a2 + a4);
  }
  if (*(unsigned int *)(a3 + 8) <= a4) {
    int v6 = -1;
  }
  else {
    int v6 = *(unsigned __int8 *)(*(void *)a3 + a4);
  }
  if (v4 <= v5) {
    int v7 = v5;
  }
  else {
    int v7 = v4;
  }
  if (v4 >= v5) {
    int v4 = v5;
  }
  if (v4 <= v6) {
    int v4 = v6;
  }
  if (v7 >= v6) {
    return v4;
  }
  else {
    return v7;
  }
}

uint64_t sub_19E049588(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a1 + 24;
  if (a1 + 24 >= a2) {
    return 1;
  }
  uint64_t v7 = 1;
  do
  {
    uint64_t v8 = v3;
    if (v3 <= a1)
    {
      int v10 = 0;
    }
    else
    {
      while (1)
      {
        unint64_t v9 = v8 - 24;
        int v10 = sub_19E049668(v8 - 24, v8, a3);
        if (v10 < 1) {
          break;
        }
        uint64_t v11 = *(void *)(v8 - 24);
        int v12 = *(_DWORD *)(v8 - 8);
        *(void *)(v8 - 24) = *(void *)v8;
        uint64_t v13 = *(void *)(v8 + 8);
        *(_DWORD *)(v8 - 8) = *(_DWORD *)(v8 + 16);
        *(void *)uint64_t v8 = v11;
        uint64_t v14 = *(void *)(v8 - 16);
        *(void *)(v8 - 16) = v13;
        *(void *)(v8 + 8) = v14;
        *(_DWORD *)(v8 + 16) = v12;
        v8 -= 24;
        if (v9 <= a1)
        {
          int v10 = 1;
          break;
        }
      }
    }
    if (v10) {
      ++v7;
    }
    v3 += 24;
  }
  while (v3 < a2);
  return v7;
}

uint64_t sub_19E049668(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  unint64_t v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v3 == v4) {
      return 0;
    }
    else {
      return v12;
    }
  }
  else
  {
    uint64_t v6 = v4 - a3;
    uint64_t v7 = (unsigned __int8 *)(*(void *)a1 + a3);
    uint64_t v8 = (unsigned __int8 *)(*(void *)a2 + a3);
    while (v6)
    {
      int v9 = *v7;
      int v10 = *v8;
      uint64_t result = (v9 - v10);
      if (v9 != v10) {
        return result;
      }
      --v6;
      ++v7;
      ++v8;
      if (!--v5) {
        goto LABEL_6;
      }
    }
    return 1;
  }
}

unsigned char *sub_19E0496D4(uint64_t *a1, size_t __sz)
{
  uint64_t result = operator new[](__sz, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = (char *)a1[1];
    uint64_t v7 = result;
    do
    {
      char v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = __sz;
  if (v9)
  {
    JUMPOUT(0x19F3BA6E0);
  }
  return result;
}

void sub_19E04976C(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 341 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_19E04982C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x155)) + 12 * (v7 % 0x155);
  uint64_t v9 = *a2;
  *(_DWORD *)(v8 + 8) = *((_DWORD *)a2 + 2);
  *(void *)unint64_t v8 = v9;
  ++a1[5];
}

void sub_19E04982C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x155;
  unint64_t v4 = v2 - 341;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      int v34 = (char *)sub_19E049FB0(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      int64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    unint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFFCuLL);
      sub_19E049B44(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFFCuLL);
    sub_19E049C5C((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      int v34 = (char *)sub_19E049FB0((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      int64_t v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = sub_19E049FB0((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0xFFCuLL);
  sub_19E049D7C(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_19E049E94((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_19E049AF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_19E049B44(void *a1, void *a2)
{
  uint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  uint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    unint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v18 = 1;
      }
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      unint64_t v19 = (char *)sub_19E049FB0(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      unint64_t v22 = (uint64_t *)a1[1];
      uint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        uint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      uint64_t v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        uint64_t v6 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        uint64_t v6 = (char *)a1[1];
      }
      uint64_t v17 = &v6[8 * v13];
      uint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(void *)uint64_t v6 = *a2;
  a1[2] += 8;
}

void sub_19E049C5C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    unint64_t v7 = *(unsigned char **)(a1 + 24);
    uint64_t v8 = *(unsigned char **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)sub_19E049FB0(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void sub_19E049D7C(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)sub_19E049FB0(a1[4], v16);
      uint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }
      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)uint64_t v4 = *a2;
  a1[2] += 8;
}

void sub_19E049E94(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)sub_19E049FB0(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void *sub_19E049FB0(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_19E0416C4();
  }
  return operator new(8 * a2);
}

_OWORD *sub_19E049FE8(uint64_t *a1, uint64_t a2)
{
  uint64_t result = operator new[](16 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = (long long *)a1[1];
    uint64_t v7 = result;
    do
    {
      long long v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x19F3BA6E0);
  }
  return result;
}

void *sub_19E04A080(uint64_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  if (a1 >= 0x7FFFFFFFFFFFFFFLL) {
    unint64_t v1 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v1 = a1;
  }
  unint64_t v2 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
  while (1)
  {
    uint64_t result = operator new(16 * v1, v2);
    if (result) {
      break;
    }
    BOOL v4 = v1 > 1;
    v1 >>= 1;
    if (!v4) {
      return 0;
    }
  }
  return result;
}

double sub_19E04A0E4(__n128 *a1, __n128 *a2, uint64_t a3, unint64_t a4, __n128 *a5, uint64_t a6, __n128 a7)
{
  if (a4 >= 2)
  {
    if (a4 == 2)
    {
      a7.n128_u32[0] = a2[-1].n128_u32[3];
      if (a7.n128_f32[0] > a1->n128_f32[3])
      {
        a7 = *a1;
        *a1 = a2[-1];
        a2[-1] = a7;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      unint64_t v13 = a4 >> 1;
      uint64_t v14 = &a1[a4 >> 1];
      unint64_t v15 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        v17.n128_f64[0] = sub_19E04A354(a1, v14, a3, v15, a5, a7);
        v18.n128_f64[0] = sub_19E04A354(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), &a5[v13], v17);
        a7.n128_u64[0] = sub_19E04A4B4(a5, &a5[v13], &a5[v13], &a5[a4], a1, v18).n128_u64[0];
      }
      else
      {
        sub_19E04A0E4(a1, v14, a3, v15, a5, a6);
        sub_19E04A0E4(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), a5, a6);
        a7.n128_u64[0] = sub_19E04A528((long long *)a1, (long long *)&a1[a4 >> 1], (long long *)a2, a3, a4 >> 1, a4 - (a4 >> 1), (char *)a5, a6, v16).n128_u64[0];
      }
    }
    else
    {
      sub_19E04A2B0((uint64_t)a1, (uint64_t)a2);
    }
  }
  return a7.n128_f64[0];
}

uint64_t sub_19E04A2B0(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 16;
    if (result + 16 != a2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = result;
      do
      {
        float v5 = *(float *)(v4 + 28);
        float v6 = *(float *)(v4 + 12);
        uint64_t v4 = v2;
        if (v5 > v6)
        {
          uint64_t v10 = *(void *)v2;
          int v11 = *(_DWORD *)(v2 + 8);
          uint64_t v7 = v3;
          while (1)
          {
            *(_OWORD *)(result + v7 + 16) = *(_OWORD *)(result + v7);
            if (!v7) {
              break;
            }
            float v8 = *(float *)(result + v7 - 4);
            v7 -= 16;
            if (v5 <= v8)
            {
              uint64_t v9 = result + v7 + 16;
              goto LABEL_10;
            }
          }
          uint64_t v9 = result;
LABEL_10:
          *(void *)uint64_t v9 = v10;
          *(_DWORD *)(v9 + 8) = v11;
          *(float *)(v9 + 12) = v5;
        }
        uint64_t v2 = v4 + 16;
        v3 += 16;
      }
      while (v4 + 16 != a2);
    }
  }
  return result;
}

double sub_19E04A354(__n128 *a1, __n128 *a2, uint64_t a3, unint64_t a4, __n128 *a5, __n128 a6)
{
  if (a4)
  {
    if (a4 == 2)
    {
      uint64_t v10 = a2 - 1;
      if (a2[-1].n128_f32[3] <= a1->n128_f32[3])
      {
        *a5 = *a1;
        a6 = *v10;
      }
      else
      {
        *a5 = *v10;
        a6 = *a1;
      }
      a5[1] = a6;
    }
    else if (a4 == 1)
    {
      a6 = *a1;
      *a5 = *a1;
    }
    else if ((uint64_t)a4 > 8)
    {
      sub_19E04A0E4(a1, &a1[a4 >> 1], a3, a4 >> 1, a5, a4 >> 1);
      sub_19E04A0E4(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), &a5[a4 >> 1], a4 - (a4 >> 1));
      a6.n128_u64[0] = sub_19E04A4B4(a1, &a1[a4 >> 1], &a1[a4 >> 1], a2, a5, v12).n128_u64[0];
    }
    else
    {
      a6.n128_u64[0] = sub_19E04A7A4(a1, a2, a5).n128_u64[0];
    }
  }
  return a6.n128_f64[0];
}

__n128 sub_19E04A4B4(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, __n128 result)
{
  while (1)
  {
    if (a1 == a2)
    {
      while (a3 != a4)
      {
        __n128 v8 = *a3++;
        result.n128_u64[0] = v8.n128_u64[0];
        *a5++ = v8;
      }
      return result;
    }
    if (a3 == a4) {
      break;
    }
    if (a3->n128_f32[3] <= a1->n128_f32[3])
    {
      __n128 v7 = *a1++;
      uint64_t result = v7;
    }
    else
    {
      __n128 v6 = *a3++;
      uint64_t result = v6;
    }
    *a5++ = result;
  }
  if (a1 != a2)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t result = a1[v9];
      a5[v9++] = result;
    }
    while (&a1[v9] != a2);
  }
  return result;
}

__n128 sub_19E04A528(long long *a1, long long *a2, long long *a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8, __n128 result)
{
  if (a6)
  {
    uint64_t v10 = a6;
    while (v10 > a8 && a5 > a8)
    {
      if (!a5) {
        return result;
      }
      uint64_t v12 = 0;
      result.n128_u32[0] = *((_DWORD *)a2 + 3);
      uint64_t v13 = -a5;
      while (1)
      {
        uint64_t v14 = &a1[v12];
        if (result.n128_f32[0] > *((float *)&a1[v12] + 3)) {
          break;
        }
        ++v12;
        if (__CFADD__(v13++, 1)) {
          return result;
        }
      }
      uint64_t v16 = -v13;
      uint64_t v39 = a3;
      uint64_t v40 = a8;
      if (-v13 >= v10)
      {
        if (v13 == -1)
        {
          __n128 v43 = (__n128)a1[v12];
          a1[v12] = *a2;
          uint64_t result = v43;
          *a2 = (__int128)v43;
          return result;
        }
        if (v13 > 0) {
          uint64_t v16 = 1 - v13;
        }
        uint64_t v26 = v16 >> 1;
        uint64_t v20 = &a1[(v16 >> 1) + v12];
        uint64_t v19 = a3;
        if (a3 != a2)
        {
          unint64_t v27 = a3 - a2;
          uint64_t v19 = a2;
          do
          {
            unint64_t v28 = v27 >> 1;
            uint64_t v29 = &v19[v27 >> 1];
            float v30 = *((float *)v29 + 3);
            long long v31 = v29 + 1;
            v27 += ~(v27 >> 1);
            if (v30 > *((float *)v20 + 3)) {
              uint64_t v19 = v31;
            }
            else {
              unint64_t v27 = v28;
            }
          }
          while (v27);
        }
        uint64_t v18 = v19 - a2;
      }
      else
      {
        if (v10 >= 0) {
          uint64_t v17 = v10;
        }
        else {
          uint64_t v17 = v10 + 1;
        }
        uint64_t v18 = v17 >> 1;
        uint64_t v19 = &a2[v17 >> 1];
        uint64_t v20 = a2;
        if (v14 != a2)
        {
          unint64_t v21 = ((char *)a2 - (char *)a1 - v12 * 16) >> 4;
          uint64_t v20 = &a1[v12];
          do
          {
            unint64_t v22 = v21 >> 1;
            uint64_t v23 = &v20[v21 >> 1];
            float v24 = *((float *)v23 + 3);
            unint64_t v25 = v23 + 1;
            v21 += ~(v21 >> 1);
            if (*((float *)v19 + 3) > v24) {
              unint64_t v21 = v22;
            }
            else {
              uint64_t v20 = v25;
            }
          }
          while (v21);
        }
        uint64_t v26 = ((char *)v20 - (char *)a1 - v12 * 16) >> 4;
      }
      a5 = -(v26 + v13);
      uint64_t v32 = v10 - v18;
      uint64_t v33 = v18;
      int v34 = sub_19E04A958((char *)v20, (char *)a2, (char *)v19);
      uint64_t v35 = v33;
      uint64_t v36 = (long long *)v34;
      if (v26 + v35 >= v10 - (v26 + v35) - v13)
      {
        uint64_t v38 = v35;
        sub_19E04A528(v34, v19, v39, a4, a5, v32, a7, v40);
        uint64_t v19 = v20;
        uint64_t v32 = v38;
        a5 = v26;
        a8 = v40;
        a3 = v36;
      }
      else
      {
        uint64_t v37 = v26;
        a8 = v40;
        sub_19E04A528(v14, v20, v34, a4, v37, v35, a7, v40);
        uint64_t v14 = v36;
        a3 = v39;
      }
      uint64_t v10 = v32;
      a1 = v14;
      a2 = v19;
      if (!v32) {
        return result;
      }
    }
    sub_19E04A848(a1, a2, a3, a4, a5, v10, a7);
  }
  return result;
}

__n128 sub_19E04A7A4(__n128 *a1, __n128 *a2, __n128 *a3)
{
  if (a1 != a2)
  {
    __n128 result = *a1;
    *a3 = *a1;
    uint64_t v4 = a1 + 1;
    if (&a1[1] != a2)
    {
      uint64_t v5 = 0;
      __n128 v6 = a3;
      do
      {
        __n128 v7 = a1;
        __n128 v8 = v6;
        a1 = v4;
        uint64_t v9 = ++v6;
        if (v7[1].n128_f32[3] > v8->n128_f32[3])
        {
          __n128 *v6 = *v8;
          uint64_t v9 = a3;
          if (v8 != a3)
          {
            uint64_t v10 = v5;
            while (1)
            {
              uint64_t v9 = (__n128 *)((char *)a3 + v10);
              if (v7[1].n128_f32[3] <= *(float *)((char *)&a3->n128_f32[-1] + v10)) {
                break;
              }
              *uint64_t v9 = v9[-1];
              v10 -= 16;
              if (!v10)
              {
                uint64_t v9 = a3;
                break;
              }
            }
          }
        }
        __n128 result = *a1;
        *uint64_t v9 = *a1;
        uint64_t v4 = a1 + 1;
        v5 += 16;
      }
      while (&a1[1] != a2);
    }
  }
  return result;
}

long long *sub_19E04A848(long long *result, long long *a2, long long *a3, int a4, uint64_t a5, uint64_t a6, char *__src)
{
  if (a5 <= a6)
  {
    if (result != a2)
    {
      unint64_t v13 = 0;
      do
      {
        *(_OWORD *)&__src[v13] = result[v13 / 0x10];
        v13 += 16;
      }
      while (&result[v13 / 0x10] != a2);
      if (v13)
      {
        uint64_t v14 = (float *)__src;
        while (a2 != a3)
        {
          if (*((float *)a2 + 3) <= v14[3])
          {
            long long v17 = *(_OWORD *)v14;
            v14 += 4;
            long long v16 = v17;
          }
          else
          {
            long long v15 = *a2++;
            long long v16 = v15;
          }
          *result++ = v16;
          if (&__src[v13] == (char *)v14) {
            return result;
          }
        }
        return (long long *)memmove(result, v14, __src - (char *)v14 + v13);
      }
    }
  }
  else if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      *(_OWORD *)&__src[v7 * 16] = a2[v7];
      ++v7;
    }
    while (&a2[v7] != a3);
    if (v7 * 16)
    {
      __n128 v8 = (float *)&__src[v7 * 16];
      uint64_t v9 = a3 - 1;
      while (a2 != result)
      {
        float v10 = *(v8 - 1);
        float v11 = *((float *)a2 - 1);
        if (v10 <= v11) {
          uint64_t v12 = (char *)(v8 - 4);
        }
        else {
          uint64_t v12 = (char *)(a2 - 1);
        }
        if (v10 <= v11) {
          v8 -= 4;
        }
        else {
          --a2;
        }
        *v9-- = *(_OWORD *)v12;
        if (v8 == (float *)__src) {
          return result;
        }
      }
      unint64_t v18 = 0;
      do
      {
        v9[v18 / 4] = *(_OWORD *)&v8[v18 - 4];
        v18 -= 4;
      }
      while (&v8[v18] != (float *)__src);
    }
  }
  return result;
}

char *sub_19E04A958(char *__src, char *a2, char *a3)
{
  uint64_t v4 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 16 == a2)
    {
      long long v9 = *(_OWORD *)__src;
      int64_t v6 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      uint64_t v4 = &__src[v6];
      *(_OWORD *)uint64_t v4 = v9;
    }
    else if (a2 + 16 == a3)
    {
      uint64_t v4 = __src + 16;
      long long v10 = *((_OWORD *)a3 - 1);
      size_t v7 = a3 - 16 - __src;
      if (a3 - 16 != __src) {
        memmove(__src + 16, __src, v7);
      }
      *(_OWORD *)char __src = v10;
    }
    else
    {
      return (char *)sub_19E04AA34(__src, a2, a3);
    }
  }
  return v4;
}

_OWORD *sub_19E04AA34(_OWORD *a1, _OWORD *a2, _OWORD *a3)
{
  uint64_t v3 = a2 - a1;
  if (v3 == a3 - a2)
  {
    if (a1 != a2 && a2 != a3)
    {
      uint64_t v4 = 0;
      do
      {
        long long v5 = a1[v4];
        a1[v4] = a2[v4];
        uint64_t v6 = (uint64_t)&a1[v4 + 1];
        a2[v4] = v5;
        uint64_t v7 = (uint64_t)&a2[++v4];
      }
      while ((_OWORD *)v6 != a2 && v7 != (void)a3);
    }
  }
  else
  {
    uint64_t v9 = a3 - a2;
    uint64_t v10 = a2 - a1;
    do
    {
      uint64_t v11 = v10;
      uint64_t v10 = v9;
      uint64_t v9 = v11 % v9;
    }
    while (v9);
    if (v10)
    {
      uint64_t v12 = &a1[v10];
      do
      {
        long long v13 = *--v12;
        uint64_t v14 = &v12[v3];
        long long v15 = v12;
        do
        {
          long long v16 = v15;
          long long v15 = v14;
          _OWORD *v16 = *v14;
          BOOL v17 = __OFSUB__(v3, a3 - v14);
          uint64_t v19 = v3 - (a3 - v14);
          char v18 = (v19 < 0) ^ v17;
          uint64_t v14 = &a1[v19];
          if (v18) {
            uint64_t v14 = &v15[v3];
          }
        }
        while (v14 != v12);
        _OWORD *v15 = v13;
      }
      while (v12 != a1);
    }
    return &a1[a3 - a2];
  }
  return a2;
}

uint64_t sub_19E04AB14(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 170;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 341;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_19E04ABBC((uint64_t)a1);
}

uint64_t sub_19E04ABBC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_19E04AC0C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  if (!v4) {
    goto LABEL_10;
  }
  unsigned int v5 = 0;
  uint64_t v6 = *(unsigned int **)(a2 + 16);
  uint64_t v7 = *(void *)(a2 + 24);
  do
  {
    unsigned int v9 = *v6++;
    unsigned int v8 = v9;
    if (v9 > v5) {
      unsigned int v5 = v8;
    }
    --v7;
  }
  while (v7);
  if (v5)
  {
    uint64_t v10 = 0;
    do
    {
      ++v10;
      BOOL v11 = v5 > 1;
      v5 >>= 1;
    }
    while (v11);
  }
  else
  {
LABEL_10:
    uint64_t v10 = 0;
  }
  BOOL v12 = v4 != 0;
  unint64_t v13 = (unint64_t)(v10 * v4 + 63) >> 6;
  if (v10) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = v12;
  }
  uint64_t result = (uint64_t)sub_19E047BF8((uint64_t *)a1, v14);
  if (v14) {
    *(void *)(*(void *)(a1 + 8) + 8 * *(void *)(a1 + 24) - 8) = 0;
  }
  *(void *)(a1 + 48) = v10;
  if (v10) {
    *(_DWORD *)(a1 + 56) = 0xFFFFFFFF >> -(char)v10;
  }
  uint64_t v16 = *(void *)(a2 + 24);
  *(void *)(a1 + 64) = v16;
  if (v16)
  {
    unint64_t v17 = 0;
    do
    {
      uint64_t result = sub_19E04AD0C(a1, v17, *(_DWORD *)(*(void *)(a2 + 16) + 4 * v17));
      ++v17;
    }
    while (v17 < *(void *)(a2 + 24));
  }
  return result;
}

uint64_t sub_19E04AD0C(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(result + 48);
  unint64_t v4 = (unint64_t)(v3 * a2) >> 6;
  uint64_t v5 = (v3 * a2) & 0x3F;
  unint64_t v6 = *(unsigned int *)(result + 56);
  uint64_t v7 = *(void *)(result + 8);
  unint64_t v8 = v6 & a3;
  *(void *)(v7 + 8 * v4) = *(void *)(v7 + 8 * v4) & ~(v6 << (v3 * a2)) | (v8 << (v3 * a2));
  if ((unint64_t)(v5 + v3) >= 0x41) {
    *(void *)(v7 + 8 * v4 + 8) = *(void *)(v7 + 8 * v4 + 8) & ~(v6 >> -(char)v5) | (v8 >> -(char)v5);
  }
  return result;
}

uint64_t sub_19E04AD70(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v10 = (unsigned int *)result;
LABEL_2:
  BOOL v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = ((char *)a2 - (char *)v11) >> 3;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unsigned int v23 = *(a2 - 2);
          unsigned int v24 = *v11;
          if (v23 < *v11 || v24 >= v23 && *(a2 - 1) < v11[1])
          {
            unsigned int *v11 = v23;
            *(a2 - 2) = v24;
            unsigned int v25 = v11[1];
            v11[1] = *(a2 - 1);
            *(a2 - 1) = v25;
          }
          break;
        case 3uLL:
          uint64_t result = sub_19E04B2D4(v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          uint64_t result = sub_19E04B8B4(v11, v11 + 2, v11 + 4, a2 - 2);
          break;
        case 5uLL:
          uint64_t result = sub_19E04B9B8(v11, v11 + 2, v11 + 4, v11 + 6, a2 - 2);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)sub_19E04BB10(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x401)
    {
      sub_19E04B2D4(v11, &v11[2 * (v15 >> 1)], a2 - 2);
      sub_19E04B2D4(v11 + 2, v17 - 2, a2 - 4);
      sub_19E04B2D4(v11 + 4, &v11[2 * v16 + 2], a2 - 6);
      sub_19E04B2D4(v17 - 2, v17, &v11[2 * v16 + 2]);
      uint64_t v18 = *(void *)v11;
      *(void *)BOOL v11 = *(void *)v17;
      *(void *)unint64_t v17 = v18;
      if (a5) {
        goto LABEL_16;
      }
    }
    else
    {
      sub_19E04B2D4(&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_16;
      }
    }
    unsigned int v19 = *(v11 - 2);
    if (v19 >= *v11 && (*v11 < v19 || *(v11 - 1) >= v11[1]))
    {
      uint64_t result = (uint64_t)sub_19E04B428(v11, a2);
      BOOL v11 = (unsigned int *)result;
      goto LABEL_21;
    }
LABEL_16:
    uint64_t v20 = sub_19E04B55C(v11, a2);
    if ((v21 & 1) == 0) {
      goto LABEL_19;
    }
    BOOL v22 = sub_19E04B698(v11, v20);
    BOOL v11 = v20 + 2;
    uint64_t result = sub_19E04B698(v20 + 2, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v20;
      if (v22) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v22)
    {
LABEL_19:
      uint64_t result = sub_19E04AD70(v10, v20, a3, -v13, a5 & 1);
      BOOL v11 = v20 + 2;
LABEL_21:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)sub_19E04B168(v11, a2);
  }
  else
  {
    return (uint64_t)sub_19E04B23C(v11, a2);
  }
}

unsigned int *sub_19E04B168(unsigned int *result, unsigned int *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = 0;
      unint64_t v4 = result;
      do
      {
        char v5 = v4;
        unint64_t v4 = v2;
        unsigned int v6 = v5[2];
        unsigned int v7 = *v5;
        if (v6 < *v5 || v7 >= v6 && v5[3] < v5[1])
        {
          unsigned int v9 = v5[2];
          unsigned int v8 = v5[3];
          unsigned int v10 = v5[1];
          v5[2] = v7;
          v4[1] = v10;
          BOOL v11 = result;
          if (v5 != result)
          {
            uint64_t v12 = v3;
            do
            {
              unsigned int v13 = *(unsigned int *)((char *)result + v12 - 8);
              if (v13 <= v9)
              {
                if (v13 < v9)
                {
                  BOOL v11 = v5;
                  goto LABEL_17;
                }
                BOOL v11 = (unsigned int *)((char *)result + v12);
                unsigned int v14 = *(unsigned int *)((char *)result + v12 - 4);
                if (v14 <= v8) {
                  goto LABEL_17;
                }
              }
              else
              {
                unsigned int v14 = *(unsigned int *)((char *)result + v12 - 4);
              }
              v5 -= 2;
              unint64_t v15 = (unsigned int *)((char *)result + v12);
              unsigned int *v15 = v13;
              v15[1] = v14;
              v12 -= 8;
            }
            while (v12);
            BOOL v11 = result;
          }
LABEL_17:
          unsigned int *v11 = v9;
          v11[1] = v8;
        }
        uint64_t v2 = v4 + 2;
        v3 += 8;
      }
      while (v4 + 2 != a2);
    }
  }
  return result;
}

unsigned int *sub_19E04B23C(unsigned int *result, unsigned int *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = result + 1;
      do
      {
        unint64_t v4 = result;
        uint64_t result = v2;
        unsigned int v5 = v4[2];
        unsigned int v6 = *v4;
        if (v5 < *v4 || v6 >= v5 && v4[3] < v4[1])
        {
          unsigned int v7 = *result;
          unsigned int v8 = result[1];
          for (uint64_t i = v3; ; i -= 2)
          {
            unsigned int v10 = *i;
            i[1] = v6;
            i[2] = v10;
            unsigned int v6 = *(i - 3);
            if (v6 <= v7 && (v6 < v7 || *(i - 2) <= v8)) {
              break;
            }
          }
          *(i - 1) = v7;
          *uint64_t i = v8;
        }
        uint64_t v2 = result + 2;
        v3 += 2;
      }
      while (result + 2 != a2);
    }
  }
  return result;
}

uint64_t sub_19E04B2D4(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a1;
  if (*a2 >= *a1 && (v4 < v3 || a2[1] >= a1[1]))
  {
    unsigned int v9 = *a3;
    if (*a3 >= v3 && (v3 < v9 || a3[1] >= a2[1])) {
      return 0;
    }
    *a2 = v9;
    *a3 = v3;
    BOOL v11 = (int *)(a2 + 1);
    unsigned int v10 = a2[1];
    a2[1] = a3[1];
    a3[1] = v10;
    unsigned int v12 = *a2;
    unsigned int v13 = *a1;
    if (*a2 >= *a1 && (v13 < v12 || *v11 >= a1[1])) {
      return 1;
    }
    *a1 = v12;
    unsigned int v6 = (int *)(a1 + 1);
    *a2 = v13;
    uint64_t v8 = 2;
  }
  else
  {
    unsigned int v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && a3[1] < a2[1])
    {
      *a1 = v5;
      unsigned int v6 = (int *)(a1 + 1);
      *a3 = v4;
      unsigned int v7 = (int *)(a3 + 1);
      uint64_t v8 = 1;
    }
    else
    {
      *a1 = v3;
      *a2 = v4;
      unsigned int v14 = a1[1];
      a1[1] = a2[1];
      a2[1] = v14;
      unsigned int v15 = *a3;
      unsigned int v16 = *a2;
      if (*a3 >= *a2 && (v16 < v15 || a3[1] >= v14)) {
        return 1;
      }
      *a2 = v15;
      *a3 = v16;
      unsigned int v7 = (int *)(a3 + 1);
      uint64_t v8 = 2;
      unsigned int v6 = (int *)(a2 + 1);
    }
    BOOL v11 = v7;
  }
  int v17 = *v6;
  int *v6 = *v11;
  int *v11 = v17;
  return v8;
}

unsigned int *sub_19E04B428(unsigned int *a1, unsigned int *a2)
{
  unsigned int v3 = *a1;
  unsigned int v2 = a1[1];
  unsigned int v4 = *(a2 - 2);
  if (v4 <= *a1 && (v4 < v3 || *(a2 - 1) <= v2))
  {
    for (uint64_t i = a1 + 2; i < a2 && *i <= v3 && (*i < v3 || i[1] <= v2); i += 2)
      ;
  }
  else
  {
    uint64_t i = a1;
    do
    {
      unsigned int v7 = i[2];
      i += 2;
      unsigned int v6 = v7;
    }
    while (v7 <= v3 && (v6 < v3 || i[1] <= v2));
  }
  if (i < a2)
  {
    for (a2 -= 2; v4 > v3 || v4 >= v3 && a2[1] > v2; a2 -= 2)
    {
      unsigned int v8 = *(a2 - 2);
      unsigned int v4 = v8;
    }
  }
  if (i < a2)
  {
    unsigned int v9 = *i;
    unsigned int v10 = *a2;
    do
    {
      *uint64_t i = v10;
      *a2 = v9;
      unsigned int v11 = i[1];
      i[1] = a2[1];
      a2[1] = v11;
      do
      {
        unsigned int v12 = i[2];
        i += 2;
        unsigned int v9 = v12;
      }
      while (v12 <= v3 && (v9 < v3 || i[1] <= v2));
      do
      {
        do
        {
          unsigned int v13 = *(a2 - 2);
          a2 -= 2;
          unsigned int v10 = v13;
          BOOL v14 = v13 >= v3;
        }
        while (v13 > v3);
      }
      while (v14 && a2[1] > v2);
    }
    while (i < a2);
  }
  if (i - 2 != a1)
  {
    *a1 = *(i - 2);
    a1[1] = *(i - 1);
  }
  *(i - 2) = v3;
  *(i - 1) = v2;
  return i;
}

unsigned int *sub_19E04B55C(unsigned int *a1, unsigned int *a2)
{
  uint64_t v2 = 0;
  unsigned int v3 = *a1;
  unsigned int v4 = a1[1];
  while (1)
  {
    unsigned int v5 = a1[v2 + 2];
    if (v5 >= v3 && (v5 > v3 || a1[v2 + 3] >= v4)) {
      break;
    }
    v2 += 2;
  }
  unint64_t v6 = (unint64_t)&a1[v2 + 2];
  if (v2 * 4)
  {
    do
    {
      unsigned int v8 = *(a2 - 2);
      a2 -= 2;
      unsigned int v7 = v8;
    }
    while (v8 >= v3 && (v7 > v3 || a2[1] >= v4));
  }
  else
  {
LABEL_19:
    if (v6 < (unint64_t)a2)
    {
      do
      {
        unsigned int v10 = *(a2 - 2);
        a2 -= 2;
        unsigned int v9 = v10;
        if (v10 < v3) {
          break;
        }
        if (v9 > v3) {
          goto LABEL_19;
        }
      }
      while (a2[1] >= v4 && v6 < (unint64_t)a2);
    }
  }
  if (v6 >= (unint64_t)a2)
  {
    unsigned int v13 = (unsigned int *)v6;
  }
  else
  {
    unsigned int v12 = *a2;
    unsigned int v13 = (unsigned int *)v6;
    BOOL v14 = a2;
    do
    {
      *unsigned int v13 = v12;
      *BOOL v14 = v5;
      unsigned int v15 = v13[1];
      v13[1] = v14[1];
      v14[1] = v15;
      do
      {
        do
        {
          unsigned int v16 = v13[2];
          v13 += 2;
          unsigned int v5 = v16;
          BOOL v17 = v16 > v3;
        }
        while (v16 < v3);
      }
      while (!v17 && v13[1] < v4);
      do
      {
        unsigned int v18 = *(v14 - 2);
        v14 -= 2;
        unsigned int v12 = v18;
      }
      while (v18 >= v3 && (v12 > v3 || v14[1] >= v4));
    }
    while (v13 < v14);
  }
  if (v13 - 2 != a1)
  {
    *a1 = *(v13 - 2);
    a1[1] = *(v13 - 1);
  }
  *(v13 - 2) = v3;
  *(v13 - 1) = v4;
  return v13 - 2;
}

BOOL sub_19E04B698(unsigned int *a1, unsigned int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 2);
      unsigned int v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && *(a2 - 1) < a1[1])
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        unsigned int v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      sub_19E04B2D4(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      sub_19E04B8B4(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      sub_19E04B9B8(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      unsigned int v9 = a1 + 4;
      sub_19E04B2D4(a1, a1 + 2, a1 + 4);
      unsigned int v10 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  do
  {
    unsigned int v13 = *v9;
    if (*v10 >= *v9 && (v13 < *v10 || v10[1] >= v9[1])) {
      goto LABEL_22;
    }
    unsigned int v14 = *v10;
    unsigned int v15 = v10[1];
    *unsigned int v10 = v13;
    v10[1] = v9[1];
    unsigned int v16 = a1;
    if (v9 == a1) {
      goto LABEL_21;
    }
    uint64_t v17 = v11;
    while (1)
    {
      unsigned int v18 = (char *)a1 + v17;
      unsigned int v19 = *(unsigned int *)((char *)a1 + v17 + 8);
      if (v19 <= v14) {
        break;
      }
      unsigned int v20 = *((_DWORD *)v18 + 3);
LABEL_18:
      v9 -= 2;
      *((_DWORD *)v18 + 4) = v19;
      *(unsigned int *)((char *)a1 + v17 + 2sub_19E03D880(&a9, 0) = v20;
      v17 -= 8;
      if (v17 == -16)
      {
        unsigned int v16 = a1;
        goto LABEL_21;
      }
    }
    if (v19 < v14)
    {
      unsigned int v16 = v9;
      goto LABEL_21;
    }
    unsigned int v20 = *(unsigned int *)((char *)a1 + v17 + 12);
    if (v20 > v15) {
      goto LABEL_18;
    }
    unsigned int v16 = (unsigned int *)((char *)a1 + v17 + 16);
LABEL_21:
    unsigned int *v16 = v14;
    v16[1] = v15;
    if (++v12 == 8) {
      return v10 + 2 == a2;
    }
LABEL_22:
    unsigned int v9 = v10;
    v11 += 8;
    v10 += 2;
  }
  while (v10 != a2);
  return 1;
}

uint64_t sub_19E04B8B4(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result = sub_19E04B2D4(a1, a2, a3);
  unsigned int v9 = *a4;
  unsigned int v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && a4[1] < a3[1])
  {
    *a3 = v9;
    *a4 = v10;
    unsigned int v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    unsigned int v12 = *a3;
    unsigned int v13 = *a2;
    if (*a3 < *a2 || v13 >= v12 && a3[1] < a2[1])
    {
      *a2 = v12;
      *a3 = v13;
      unsigned int v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      unsigned int v15 = *a2;
      unsigned int v16 = *a1;
      if (*a2 < *a1 || v16 >= v15 && a2[1] < a1[1])
      {
        *a1 = v15;
        *a2 = v16;
        unsigned int v17 = a1[1];
        a1[1] = a2[1];
        a2[1] = v17;
      }
    }
  }
  return result;
}

uint64_t sub_19E04B9B8(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t result = sub_19E04B8B4(a1, a2, a3, a4);
  unsigned int v11 = *a5;
  unsigned int v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && a5[1] < a4[1])
  {
    *a4 = v11;
    *a5 = v12;
    unsigned int v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    unsigned int v14 = *a4;
    unsigned int v15 = *a3;
    if (*a4 < *a3 || v15 >= v14 && a4[1] < a3[1])
    {
      *a3 = v14;
      *a4 = v15;
      unsigned int v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      unsigned int v17 = *a3;
      unsigned int v18 = *a2;
      if (*a3 < *a2 || v18 >= v17 && a3[1] < a2[1])
      {
        *a2 = v17;
        *a3 = v18;
        unsigned int v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        unsigned int v20 = *a2;
        unsigned int v21 = *a1;
        if (*a2 < *a1 || v21 >= v20 && a2[1] < a1[1])
        {
          *a1 = v20;
          *a2 = v21;
          unsigned int v22 = a1[1];
          a1[1] = a2[1];
          a2[1] = v22;
        }
      }
    }
  }
  return result;
}

unsigned int *sub_19E04BB10(unsigned int *a1, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 3;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      unsigned int v12 = &a1[2 * v10];
      do
      {
        sub_19E04BC8C((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    unsigned int v13 = a2;
    if (a2 != a3)
    {
      unsigned int v14 = a2;
      do
      {
        unsigned int v15 = *v14;
        unsigned int v16 = *a1;
        if (*v14 < *a1 || v16 >= v15 && v14[1] < a1[1])
        {
          *unsigned int v14 = v16;
          *a1 = v15;
          unsigned int v17 = v14[1];
          v14[1] = a1[1];
          a1[1] = v17;
          sub_19E04BC8C((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      unsigned int v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v18 = (unint64_t)v8 >> 3;
      unsigned int v19 = a2 - 2;
      do
      {
        unsigned int v21 = *a1;
        unsigned int v20 = a1[1];
        unsigned int v22 = sub_19E04BDD0(a1, a4, v18);
        if (v19 == v22)
        {
          unsigned int *v22 = v21;
          v22[1] = v20;
        }
        else
        {
          unsigned int *v22 = *v19;
          v22[1] = v19[1];
          unsigned int *v19 = v21;
          v19[1] = v20;
          sub_19E04BE64((uint64_t)a1, (uint64_t)(v22 + 2), a4, ((char *)(v22 + 2) - (char *)a1) >> 3);
        }
        v19 -= 2;
      }
      while (v18-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_19E04BC8C(uint64_t result, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v6 = v4 >> 2;
      uint64_t v7 = (v4 >> 2) + 1;
      uint64_t v8 = (unsigned int *)(result + 8 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3)
      {
        unsigned int v10 = v8[2];
        if (*v8 < v10 || v10 >= *v8 && *(_DWORD *)(result + 8 * v7 + 4) < v8[3])
        {
          v8 += 2;
          uint64_t v7 = v9;
        }
      }
      unsigned int v11 = *v8;
      if (*v8 >= *a4 && (*a4 < v11 || v8[1] >= a4[1]))
      {
        unsigned int v12 = *a4;
        unsigned int v13 = a4[1];
        *a4 = v11;
        a4[1] = v8[1];
        if (v5 >= v7)
        {
          while (1)
          {
            uint64_t v15 = 2 * v7;
            uint64_t v7 = (2 * v7) | 1;
            unsigned int v14 = (unsigned int *)(result + 8 * v7);
            uint64_t v16 = v15 + 2;
            if (v16 < a3)
            {
              unsigned int v17 = v14[2];
              if (*v14 < v17 || v17 >= *v14 && *(_DWORD *)(result + 8 * v7 + 4) < v14[3])
              {
                v14 += 2;
                uint64_t v7 = v16;
              }
            }
            unsigned int v18 = *v14;
            if (*v14 < v12 || v18 <= v12 && v14[1] < v13) {
              break;
            }
            *uint64_t v8 = v18;
            v8[1] = v14[1];
            uint64_t v8 = v14;
            if (v5 < v7) {
              goto LABEL_22;
            }
          }
        }
        unsigned int v14 = v8;
LABEL_22:
        *unsigned int v14 = v12;
        v14[1] = v13;
      }
    }
  }
  return result;
}

unsigned int *sub_19E04BDD0(unsigned int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = result;
    uint64_t v7 = v3 + 1;
    result += 2 * v3 + 2;
    uint64_t v8 = 2 * v3;
    uint64_t v3 = (2 * v3) | 1;
    uint64_t v9 = v8 + 2;
    if (v9 < a3)
    {
      unsigned int v10 = result[2];
      if (*result < v10 || v10 >= *result && v6[2 * v7 + 1] < result[3])
      {
        result += 2;
        uint64_t v3 = v9;
      }
    }
    unsigned int *v6 = *result;
    v6[1] = result[1];
  }
  while (v3 <= v5);
  return result;
}

uint64_t sub_19E04BE64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    uint64_t v6 = (unsigned int *)(result + 8 * (v4 >> 1));
    unsigned int v7 = *v6;
    unsigned int v8 = *(_DWORD *)(a2 - 8);
    if (*v6 < v8 || v8 >= v7 && *(_DWORD *)(result + 8 * v5 + 4) < *(_DWORD *)(a2 - 4))
    {
      unsigned int v9 = *(_DWORD *)(a2 - 8);
      unsigned int v10 = *(_DWORD *)(a2 - 4);
      *(_DWORD *)(a2 - 8) = v7;
      *(_DWORD *)(a2 - 4) = v6[1];
      if (v4 >= 2)
      {
        while (1)
        {
          unint64_t v12 = v5 - 1;
          unint64_t v5 = (v5 - 1) >> 1;
          unsigned int v11 = (unsigned int *)(result + 8 * v5);
          unsigned int v13 = *v11;
          if (*v11 >= v9)
          {
            if (v13 > v9) {
              break;
            }
            unsigned int v14 = *(_DWORD *)(result + 8 * v5 + 4);
            if (v14 >= v10) {
              break;
            }
          }
          else
          {
            unsigned int v14 = v11[1];
          }
          unsigned int *v6 = v13;
          v6[1] = v14;
          uint64_t v6 = (unsigned int *)(result + 8 * v5);
          if (v12 <= 1) {
            goto LABEL_12;
          }
        }
      }
      unsigned int v11 = v6;
LABEL_12:
      unsigned int *v11 = v9;
      v11[1] = v10;
    }
  }
  return result;
}

void sub_19E04BF0C(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unsigned int v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    unsigned int v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      sub_19E041BEC();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unsigned int v14 = (char *)sub_19E049FB0(v4, v13);
      unsigned int v8 = *a1;
      unsigned int v7 = a1[1];
    }
    else
    {
      unsigned int v14 = 0;
    }
    uint64_t v15 = &v14[8 * v11];
    uint64_t v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    unsigned int v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

char *sub_19E04C028(uint64_t *a1, uint64_t a2)
{
  uint64_t result = (char *)operator new[](16 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(a1[1] + 8);
    unsigned int v7 = result + 8;
    do
    {
      *(v7 - 1) = *(v6 - 1);
      uint64_t v8 = *v6;
      v6 += 2;
      void *v7 = v8;
      v7 += 2;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x19F3BA6E0);
  }
  return result;
}

uint64_t sub_19E04C0CC(uint64_t *a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a2 + 24);
  unint64_t v9 = *(void *)(a2 + 8);
  if (v8)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (_DWORD *)(v9 + 16);
    do
    {
      _DWORD *v11 = v10;
      v11 += 6;
      ++v10;
    }
    while (v8 != v10);
  }
  unint64_t v12 = sub_19E04C93C(v9, v9 + 24 * v8, 0);
  uint64_t v13 = 256;
  if (a5 != 1) {
    uint64_t v13 = 1;
  }
  do
  {
    unint64_t v14 = v13;
    v13 *= 2;
  }
  while (v14 < v12 / *(unsigned int *)(a4 + 8));
  sub_19E045F70(a1 + 126, v14);
  a1[132] = v14 - 1;
  sub_19E045680(a1, 1);
  sub_19E045680(a1, 0);
  uint64_t v15 = a1 + 78;
  LOBYTE(v84[0]) = 0;
  sub_19E048D84(a1 + 78, v84);
  sub_19E045680(a1 + 52, 0);
  memset(v84, 0, 41);
  long long v83 = 0u;
  memset(v82, 0, sizeof(v82));
  long long v80 = 0u;
  memset(v81, 0, 25);
  v78.n128_u64[0] = *(void *)(a2 + 24) << 32;
  v78.n128_u32[2] = 0;
  sub_19E04976C(v82, (uint64_t *)&v78);
  uint64_t v16 = *((void *)&v83 + 1);
  if (*((void *)&v83 + 1))
  {
    uint64_t v72 = a1 + 52;
    v73 = a1 + 78;
    do
    {
      uint64_t v17 = a1[58];
      uint64_t v18 = (unsigned int *)(*(void *)(*((void *)&v82[0] + 1) + 8 * ((unint64_t)v83 / 0x155))
                           + 12 * ((unint64_t)v83 % 0x155));
      uint64_t v19 = *v18;
      unint64_t v20 = v18[1];
      uint64_t v21 = v18[2];
      *(void *)&long long v83 = v83 + 1;
      *((void *)&v83 + 1) = v16 - 1;
      if ((unint64_t)v83 >= 0x2AA)
      {
        uint64_t v22 = v17;
        uint64_t v23 = v16;
        operator delete(**((void ***)&v82[0] + 1));
        uint64_t v16 = v23;
        uint64_t v17 = v22;
        *((void *)&v82[0] + 1) += 8;
        *(void *)&long long v83 = v83 - 341;
      }
      if (v19 < v20)
      {
        while (1)
        {
          uint64_t v24 = *(void *)(a2 + 8);
          if (*(_DWORD *)(v24 + 24 * v19 + 8) != v21) {
            break;
          }
          *(_DWORD *)(v24 + 24 * v19 + 12) = v17 - v16;
          uint64_t v19 = (v19 + 1);
          if (v20 == v19) {
            goto LABEL_49;
          }
        }
      }
      if (v19 != v20)
      {
        uint64_t v76 = v16;
        int v77 = v17 - v16;
        uint64_t v25 = v80;
        long long v80 = 0u;
        memset(v81, 0, 25);
        if (v25) {
          MEMORY[0x19F3BA6E0](v25, 0x1000C8077774924);
        }
        uint64_t v75 = v17;
        uint64_t v26 = *(void *)(a2 + 8);
        double v27 = *(float *)(v26 + 24 * v19 + 12);
        uint64_t v28 = v19 + 1;
        if (v19 + 1 < v20)
        {
          uint64_t v29 = 24 * v19;
          uint64_t v30 = (v19 << 32) + 0x100000000;
          do
          {
            if (*(unsigned __int8 *)(*(void *)(v26 + v29) - v21 - 1) != *(unsigned __int8 *)(*(void *)(v26 + v29 + 24)
                                                                                              - v21
                                                                                              - 1))
            {
              *(float *)&unsigned int v31 = v27;
              v78.n128_u64[0] = v30 + v19;
              v78.n128_u64[1] = v21 | ((unint64_t)v31 << 32);
              sub_19E048DF0((uint64_t *)&v80, &v78);
              uint64_t v26 = *(void *)(a2 + 8);
              double v27 = 0.0;
              LODWORD(v19) = v28;
            }
            double v27 = v27 + *(float *)(v26 + v29 + 36);
            ++v28;
            v29 += 24;
            v30 += 0x100000000;
          }
          while (v20 != v28);
        }
        *(float *)&unsigned int v32 = v27;
        v78.n128_u32[0] = v19;
        v78.n128_u32[1] = v20;
        v78.n128_u64[1] = v21 | ((unint64_t)v32 << 32);
        __n128 v33 = sub_19E048DF0((uint64_t *)&v80, &v78);
        uint64_t v15 = a1 + 78;
        uint64_t v34 = v76;
        if (*(_DWORD *)(a4 + 16) == 0x20000)
        {
          uint64_t v35 = (__n128 *)*((void *)&v80 + 1);
          unint64_t v36 = v81[1];
          if (v81[1] < 129)
          {
            uint64_t v37 = 0;
            uint64_t v39 = 0;
          }
          else
          {
            uint64_t v37 = (__n128 *)sub_19E04A080(v81[1]);
            uint64_t v39 = v38;
          }
          sub_19E04A0E4(v35, &v35[v36], (uint64_t)&v78, v36, v37, v39, v33);
          if (v37) {
            operator delete(v37);
          }
          uint64_t v34 = v76;
        }
        uint64_t v40 = v81[1];
        if (v75 == v34) {
          a1[133] = v81[1];
        }
        if (v40)
        {
          unint64_t v41 = 0;
          do
          {
            uint64_t v42 = (unsigned int *)(*((void *)&v80 + 1) + 16 * v41);
            __n128 v43 = (uint64_t *)v42;
            uint64_t v44 = v42[2];
            uint64_t v45 = *(void *)(a2 + 8);
            unint64_t v46 = *(unsigned int *)(v45 + 24 * *v42 + 8);
            unint64_t v47 = v44 + 1;
            if (v44 + 1 >= v46)
            {
              unint64_t v48 = v42[2];
              LODWORD(v46) = v44 + 1;
            }
            else
            {
              unint64_t v48 = v46 - 1;
              uint64_t v49 = (uint64_t *)(v45 + 24 * *v42);
              unint64_t v50 = v42[2];
              do
              {
                unint64_t v51 = v50;
                unint64_t v50 = v47;
                uint64_t v52 = v49;
                uint64_t v53 = *v42;
                while (++v53 < (unint64_t)v42[1])
                {
                  uint64_t v54 = *v52;
                  uint64_t v55 = v52[3];
                  v52 += 3;
                  if (*(unsigned __int8 *)(v54 + ~v51 - 1) != *(unsigned __int8 *)(v55 + ~v51 - 1))
                  {
                    unint64_t v48 = v51;
                    LODWORD(v46) = v47;
                    goto LABEL_43;
                  }
                }
                ++v47;
              }
              while (v50 + 1 != v46);
            }
LABEL_43:
            uint64_t v56 = a1[81];
            float v58 = *((float *)v42 + 3);
            v57 = v42 + 3;
            float v59 = v58;
            uint64_t v60 = a1[132] & v56;
            uint64_t v61 = a1[127];
            uint64_t v62 = v61 + 12 * v60;
            float v64 = *(float *)(v62 + 8);
            v63 = (float *)(v62 + 8);
            if (v64 < v59)
            {
              uint64_t v65 = (_DWORD *)(v61 + 12 * v60);
              _DWORD *v65 = v77;
              v65[1] = v56;
              float *v63 = v59;
              uint64_t v44 = *((unsigned int *)v43 + 2);
            }
            if (v48 == v44)
            {
              v78.n128_u8[0] = *(unsigned char *)(~v48 + *(void *)(*(void *)(a2 + 8) + 24 * *(unsigned int *)v43));
              sub_19E048D84(v73, &v78);
              sub_19E045680(v72, 0);
            }
            else
            {
              v78.n128_u8[0] = 0;
              sub_19E048D84(v73, &v78);
              sub_19E045680(v72, 1);
              __n128 v78 = 0uLL;
              int v79 = 0;
              uint64_t v66 = *((unsigned int *)v43 + 2);
              v78.n128_u64[0] = *(void *)(*(void *)(a2 + 8) + 24 * *(unsigned int *)v43) - v66;
              v78.n128_u64[1] = (v46 - v66);
              v78.n128_u32[3] = *v57;
              sub_19E048E64((uint64_t *)v84, (uint64_t)&v78);
            }
            *((_DWORD *)v43 + 2) = v46;
            sub_19E04976C(v82, v43);
            sub_19E045680(a1, 1);
            ++v41;
          }
          while (v41 < v81[1]);
        }
      }
LABEL_49:
      sub_19E045680(a1, 0);
      uint64_t v16 = *((void *)&v83 + 1);
    }
    while (*((void *)&v83 + 1));
  }
  sub_19E045680(a1, 0);
  sub_19E045778((uint64_t)a1, a5 == 1, 1);
  sub_19E048F00(v15);
  sub_19E04C844((uint64_t)a1, a2, a3);
  long long v67 = *(_OWORD *)a2;
  *(_OWORD *)a2 = v84[0];
  v84[0] = v67;
  uint64_t v68 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = *(void *)&v84[1];
  *(void *)&v84[1] = v68;
  long long v69 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)&v84[1] + 8);
  *(_OWORD *)((char *)&v84[1] + 8) = v69;
  LOBYTE(v68) = *(unsigned char *)(a2 + 40);
  *(unsigned char *)(a2 + 4sub_19E03D880(&a9, 0) = BYTE8(v84[2]);
  BYTE8(v84[2]) = v68;
  if ((void)v80) {
    MEMORY[0x19F3BA6E0](v80, 0x1000C8077774924);
  }
  sub_19E04AB14(v82);
  uint64_t result = *(void *)&v84[0];
  if (*(void *)&v84[0]) {
    return MEMORY[0x19F3BA6E0](*(void *)&v84[0], 0x1000C8077774924);
  }
  return result;
}

void sub_19E04C724(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a21) {
    MEMORY[0x19F3BA6E0](a21, 0x1000C8077774924);
  }
  sub_19E04AB14(&a27);
  uint64_t v30 = *(void *)(v27 - 144);
  if (v30) {
    MEMORY[0x19F3BA6E0](v30, 0x1000C8077774924);
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x8000001D3;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/louds"
                   "-trie.cc:467: MARISA_MEMORY_ERROR: std::bad_alloc";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E04C844(uint64_t a1, uint64_t a2, long long *a3)
{
  memset(v13, 0, 41);
  sub_19E047D7C((uint64_t *)v13, *(void *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5)
  {
    uint64_t v6 = *((void *)&v13[0] + 1);
    unsigned int v7 = (unsigned int *)(*(void *)(a2 + 16) + 16);
    do
    {
      *(_DWORD *)(v6 + 4 * *v7) = *(v7 - 1);
      v7 += 6;
      --v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v6 = *((void *)&v13[0] + 1);
  }
  long long v8 = *a3;
  uint64_t v9 = *(void *)&v13[1];
  *(void *)a3 = *(void *)&v13[0];
  *((void *)a3 + 1) = v6;
  v13[0] = v8;
  uint64_t v10 = *((void *)a3 + 2);
  *((void *)a3 + 2) = v9;
  *(void *)&v13[1] = v10;
  long long v11 = *(long long *)((char *)a3 + 24);
  *(long long *)((char *)a3 + 24) = *(_OWORD *)((char *)&v13[1] + 8);
  *(_OWORD *)((char *)&v13[1] + 8) = v11;
  LOBYTE(v1sub_19E03D880(&a9, 0) = *((unsigned char *)a3 + 40);
  *((unsigned char *)a3 + 4sub_19E03D880(&a9, 0) = BYTE8(v13[2]);
  uint64_t result = v8;
  BYTE8(v13[2]) = v10;
  if ((void)v8) {
    return MEMORY[0x19F3BA6E0](v8, 0x1000C8077774924);
  }
  return result;
}

void sub_19E04C914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E04C93C(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = a2;
  unint64_t v5 = a1;
  uint64_t v6 = a2 - a1;
  if ((uint64_t)(a2 - a1) < 241)
  {
    uint64_t v7 = 0;
    goto LABEL_69;
  }
  uint64_t v7 = 0;
  do
  {
    int v8 = sub_19E04CDC4(v5, v5 + 24 * (v6 / 0x30uLL), v4 - 24, a3);
    int v9 = v8;
    unint64_t v10 = v5;
    unint64_t v11 = v4;
    unint64_t v12 = v5;
    unint64_t v13 = v4;
    while (v10 < v11)
    {
      unint64_t v14 = *(unsigned int *)(v10 + 8);
      int v15 = a3 >= v14 ? -1 : *(unsigned __int8 *)(*(void *)v10 - a3 - 1);
      if (v15 > v8) {
        break;
      }
      if (v15 == v8)
      {
        uint64_t v16 = *(void *)v10;
        *(void *)unint64_t v10 = *(void *)v12;
        *(_DWORD *)(v10 + 8) = *(_DWORD *)(v12 + 8);
        uint64_t v17 = *(void *)(v10 + 12);
        *(_DWORD *)(v10 + 12) = *(_DWORD *)(v12 + 12);
        *(_DWORD *)(v10 + 16) = *(_DWORD *)(v12 + 16);
        *(void *)unint64_t v12 = v16;
        *(_DWORD *)(v12 + 8) = v14;
        *(void *)(v12 + 12) = v17;
        v12 += 24;
      }
LABEL_11:
      v10 += 24;
    }
    if (v10 < v11)
    {
      unint64_t v18 = v11 - 24;
      do
      {
        unint64_t v11 = v18;
        unint64_t v19 = *(unsigned int *)(v18 + 8);
        if (a3 >= v19) {
          int v20 = -1;
        }
        else {
          int v20 = *(unsigned __int8 *)(*(void *)v11 - a3 - 1);
        }
        if (v20 < v8) {
          break;
        }
        if (v20 == v8)
        {
          uint64_t v21 = *(void *)(v13 - 24);
          v13 -= 24;
          uint64_t v22 = *(void *)v11;
          *(void *)unint64_t v11 = v21;
          *(_DWORD *)(v11 + 8) = *(_DWORD *)(v13 + 8);
          uint64_t v23 = *(void *)(v11 + 12);
          *(_DWORD *)(v11 + 12) = *(_DWORD *)(v13 + 12);
          *(_DWORD *)(v11 + 16) = *(_DWORD *)(v13 + 16);
          *(void *)unint64_t v13 = v22;
          *(_DWORD *)(v13 + 8) = v19;
          *(void *)(v13 + 12) = v23;
        }
        unint64_t v18 = v11 - 24;
      }
      while (v10 < v11);
    }
    if (v10 < v11)
    {
      uint64_t v24 = *(void *)v10;
      int v25 = *(_DWORD *)(v10 + 16);
      *(void *)unint64_t v10 = *(void *)v11;
      uint64_t v26 = *(void *)(v10 + 8);
      *(_DWORD *)(v10 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v10 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v10 + 16) = *(_DWORD *)(v11 + 16);
      *(void *)unint64_t v11 = v24;
      *(void *)(v11 + 8) = v26;
      *(_DWORD *)(v11 + 16) = v25;
      goto LABEL_11;
    }
    uint64_t v44 = v7;
    if (v12 > v5)
    {
      uint64_t v27 = 0;
      do
      {
        uint64_t v28 = v12 + v27;
        uint64_t v29 = v10 + v27;
        uint64_t v30 = *(void *)(v12 + v27 - 24);
        int v31 = *(_DWORD *)(v12 + v27 - 8);
        *(void *)(v28 - 24) = *(void *)(v10 + v27 - 24);
        uint64_t v32 = *(void *)(v12 + v27 - 16);
        *(_DWORD *)(v28 - 16) = *(_DWORD *)(v10 + v27 - 16);
        *(_DWORD *)(v28 - 12) = *(_DWORD *)(v10 + v27 - 12);
        *(_DWORD *)(v28 - 8) = *(_DWORD *)(v10 + v27 - 8);
        *(void *)(v29 - 24) = v30;
        *(void *)(v29 - 16) = v32;
        *(_DWORD *)(v29 - 8) = v31;
        v27 -= 24;
      }
      while (v12 + v27 > v5);
      v10 += v27;
    }
    while (v13 < v4)
    {
      uint64_t v33 = *(void *)v13;
      int v34 = *(_DWORD *)(v13 + 16);
      *(void *)unint64_t v13 = *(void *)v11;
      uint64_t v35 = *(void *)(v13 + 8);
      *(_DWORD *)(v13 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v13 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v13 + 16) = *(_DWORD *)(v11 + 16);
      *(void *)unint64_t v11 = v33;
      *(void *)(v11 + 8) = v35;
      *(_DWORD *)(v11 + 16) = v34;
      v11 += 24;
      v13 += 24;
    }
    uint64_t v36 = v10 - v5;
    int64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v5) >> 3);
    uint64_t v38 = v11 - v10;
    int64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v10) >> 3);
    if (v37 <= v39)
    {
      uint64_t v40 = v4 - v11;
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)) <= v39)
      {
        if (v36 == 24)
        {
          uint64_t v41 = v44 + 1;
        }
        else
        {
          if (v36 < 25) {
            goto LABEL_53;
          }
          uint64_t v41 = sub_19E04C93C(v5, v10, a3) + v44;
        }
        uint64_t v44 = v41;
LABEL_53:
        if (v40 == 24)
        {
          uint64_t v7 = v44 + 1;
        }
        else if (v40 < 25)
        {
          uint64_t v7 = v44;
        }
        else
        {
          uint64_t v7 = sub_19E04C93C(v11, v4, a3) + v44;
        }
        if (v38 == 24)
        {
          ++v7;
        }
        else if (v38 >= 25)
        {
          if (v9 == -1)
          {
            ++v7;
            unint64_t v5 = v11;
            goto LABEL_64;
          }
          ++a3;
        }
        unint64_t v5 = v10;
LABEL_64:
        unint64_t v4 = v11;
        goto LABEL_65;
      }
    }
    if (v38 == 24) {
      goto LABEL_32;
    }
    if (v38 < 25)
    {
      uint64_t v7 = v44;
    }
    else if (v8 == -1)
    {
LABEL_32:
      uint64_t v7 = v44 + 1;
    }
    else
    {
      uint64_t v7 = sub_19E04C93C(v10, v11, a3 + 1) + v44;
    }
    uint64_t v42 = v4 - v11;
    if (v37 >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)))
    {
      if (v42 == 24)
      {
        ++v7;
      }
      else if (v42 >= 25)
      {
        v7 += sub_19E04C93C(v11, v4, a3);
      }
      unint64_t v4 = v10;
    }
    else
    {
      if (v36 == 24)
      {
        ++v7;
      }
      else if (v36 >= 25)
      {
        v7 += sub_19E04C93C(v5, v10, a3);
      }
      unint64_t v5 = v11;
    }
LABEL_65:
    uint64_t v6 = v4 - v5;
  }
  while ((uint64_t)(v4 - v5) > 240);
LABEL_69:
  if (v6 >= 25) {
    v7 += sub_19E04CE44(v5, v4, a3);
  }
  return v7;
}

uint64_t sub_19E04CDC4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(unsigned int *)(a1 + 8) <= a4) {
    int v4 = -1;
  }
  else {
    int v4 = *(unsigned __int8 *)(~a4 + *(void *)a1);
  }
  if (*(unsigned int *)(a2 + 8) <= a4) {
    int v5 = -1;
  }
  else {
    int v5 = *(unsigned __int8 *)(~a4 + *(void *)a2);
  }
  if (*(unsigned int *)(a3 + 8) <= a4) {
    int v6 = -1;
  }
  else {
    int v6 = *(unsigned __int8 *)(~a4 + *(void *)a3);
  }
  if (v4 <= v5) {
    int v7 = v5;
  }
  else {
    int v7 = v4;
  }
  if (v4 >= v5) {
    int v4 = v5;
  }
  if (v4 <= v6) {
    int v4 = v6;
  }
  if (v7 >= v6) {
    return v4;
  }
  else {
    return v7;
  }
}

uint64_t sub_19E04CE44(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a1 + 24;
  if (a1 + 24 >= a2) {
    return 1;
  }
  uint64_t v7 = 1;
  do
  {
    uint64_t v8 = v3;
    if (v3 <= a1)
    {
      int v10 = 0;
    }
    else
    {
      while (1)
      {
        unint64_t v9 = v8 - 24;
        int v10 = sub_19E04CF24(v8 - 24, v8, a3);
        if (v10 < 1) {
          break;
        }
        uint64_t v11 = *(void *)(v8 - 24);
        int v12 = *(_DWORD *)(v8 - 8);
        *(void *)(v8 - 24) = *(void *)v8;
        uint64_t v13 = *(void *)(v8 + 8);
        *(_DWORD *)(v8 - 8) = *(_DWORD *)(v8 + 16);
        *(void *)uint64_t v8 = v11;
        uint64_t v14 = *(void *)(v8 - 16);
        *(void *)(v8 - 16) = v13;
        *(void *)(v8 + 8) = v14;
        *(_DWORD *)(v8 + 16) = v12;
        v8 -= 24;
        if (v9 <= a1)
        {
          int v10 = 1;
          break;
        }
      }
    }
    if (v10) {
      ++v7;
    }
    v3 += 24;
  }
  while (v3 < a2);
  return v7;
}

uint64_t sub_19E04CF24(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  unint64_t v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v3 == v4) {
      return 0;
    }
    else {
      return v12;
    }
  }
  else
  {
    uint64_t v6 = v4 - a3;
    uint64_t v7 = (unsigned __int8 *)(*(void *)a2 + ~a3);
    uint64_t v8 = (unsigned __int8 *)(*(void *)a1 + ~a3);
    while (v6)
    {
      int v9 = *v8;
      int v10 = *v7;
      uint64_t result = (v9 - v10);
      if (v9 != v10) {
        return result;
      }
      --v6;
      --v7;
      --v8;
      if (!--v5) {
        goto LABEL_6;
      }
    }
    return 1;
  }
}

char *sub_19E04CF94(uint64_t *a1, uint64_t a2)
{
  uint64_t result = (char *)operator new[](12 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = (_DWORD *)(a1[1] + 8);
    uint64_t v7 = result + 8;
    do
    {
      *((void *)v7 - 1) = *((void *)v6 - 1);
      int v8 = *v6;
      v6 += 3;
      _DWORD *v7 = v8;
      v7 += 3;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x19F3BA6E0);
  }
  return result;
}

uint64_t sub_19E04D03C(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = *(void *)sub_19E0430B8(a2, 8uLL);
  *(void *)(a1 + 16) = sub_19E0430B8(a2, v4);
  sub_19E042FDC(a2, -(int)v4 & 7);
  *(void *)(a1 + 24) = v4;

  return sub_19E047708(a1);
}

uint64_t sub_19E04D0B0(uint64_t a1, uint64_t a2)
{
  uint64_t __buf = *(void *)(a1 + 24);
  sub_19E042B74(a2, (char *)&__buf, 8uLL);
  sub_19E04D114(a2, *(char **)(a1 + 16), *(void *)(a1 + 24));
  return sub_19E042A38(a2, -*(_DWORD *)(a1 + 24) & 7);
}

uint64_t sub_19E04D114(uint64_t a1, char *a2, size_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer.h";
    exception[2] = 0x200000021;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/io/writer."
                   "h:33: MARISA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  return sub_19E042B74(a1, a2, a3);
}

double sub_19E04D198(_OWORD *a1)
{
  double result = 0.0;
  *(_OWORD *)((char *)a1 + 25) = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  *(_OWORD *)((char *)a1 + 73) = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  *(_OWORD *)((char *)a1 + 185) = 0u;
  a1[13] = 0u;
  a1[14] = 0u;
  *(_OWORD *)((char *)a1 + 233) = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  *(_OWORD *)((char *)a1 + 137) = 0u;
  return result;
}

uint64_t sub_19E04D1CC(long long *a1, uint64_t a2, long long *a3, int a4)
{
  if (!a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/tail.cc";
    exception[2] = 0x200000011;
    uint64_t v17 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/tail.cc:17: MA"
          "RISA_NULL_ERROR: offsets == NULL";
    goto LABEL_28;
  }
  if (a4 == 0x2000) {
    goto LABEL_15;
  }
  if (a4 != 4096)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/tail.cc";
    exception[2] = 0x500000028;
    uint64_t v17 = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/tail.cc:40: MA"
          "RISA_CODE_ERROR: undefined tail mode";
LABEL_28:
    exception[3] = v17;
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5)
  {
    uint64_t v6 = 0;
    a4 = 4096;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + 8) + 16 * v6;
      uint64_t v8 = *(unsigned int *)(v7 + 8);
      if (v8) {
        break;
      }
LABEL_11:
      if (++v6 == v5) {
        goto LABEL_15;
      }
    }
    uint64_t v9 = -v8;
    uint64_t v10 = *(void *)v7 + 1;
    while (*(unsigned char *)(v10 + v9))
    {
      if (__CFADD__(v9++, 1)) {
        goto LABEL_11;
      }
    }
    a4 = 0x2000;
  }
  else
  {
    a4 = 4096;
  }
LABEL_15:
  memset(v18, 0, 41);
  memset(v19, 0, 41);
  long long v22 = 0u;
  memset(v23, 0, sizeof(v23));
  long long v24 = 0u;
  memset(v25, 0, sizeof(v25));
  v19[3] = 0u;
  long long v20 = 0u;
  memset(v21, 0, sizeof(v21));
  sub_19E04D438((uint64_t)v18, a2, a3, a4);
  long long v12 = *a1;
  *a1 = v18[0];
  v18[0] = v12;
  uint64_t v13 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v18[1];
  *(void *)&v18[1] = v13;
  long long v14 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v18[1] + 8);
  *(_OWORD *)((char *)&v18[1] + 8) = v14;
  LOBYTE(v13) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 4sub_19E03D880(&a9, 0) = BYTE8(v18[2]);
  BYTE8(v18[2]) = v13;
  sub_19E0452CC((uint64_t *)a1 + 6, (uint64_t *)v19);
  if ((void)v24) {
    MEMORY[0x19F3BA6E0](v24, 0x1000C8077774924);
  }
  if ((void)v22) {
    MEMORY[0x19F3BA6E0](v22, 0x1000C8077774924);
  }
  if ((void)v20) {
    MEMORY[0x19F3BA6E0](v20, 0x1000C8077774924);
  }
  if (*(void *)&v19[0]) {
    MEMORY[0x19F3BA6E0](*(void *)&v19[0], 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v18[0];
  if (*(void *)&v18[0]) {
    return MEMORY[0x19F3BA6E0](*(void *)&v18[0], 0x1000C8077774924);
  }
  return result;
}

void sub_19E04D424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E04D438(uint64_t a1, uint64_t a2, long long *a3, int a4)
{
  uint64_t v8 = *(void *)(a2 + 24);
  unint64_t v9 = *(void *)(a2 + 8);
  if (v8)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (_DWORD *)(v9 + 12);
    do
    {
      _DWORD *v11 = v10;
      v11 += 4;
      ++v10;
    }
    while (v8 != v10);
  }
  sub_19E04DD64(v9, v9 + 16 * v8, 0);
  memset(v34, 0, 41);
  unint64_t v12 = *(void *)(a2 + 24);
  LODWORD(v33[0]) = 0;
  sub_19E04DC1C((uint64_t *)v34, v12, v33);
  v33[0] = 0;
  v33[1] = 0;
  uint64_t v13 = *(void *)(a2 + 24);
  if (v13)
  {
    long long v14 = v33;
    do
    {
      --v13;
      uint64_t v15 = *(void *)(a2 + 8);
      uint64_t v16 = v15 + 16 * v13;
      unint64_t v18 = (unsigned int *)(v16 + 8);
      uint64_t v17 = *(unsigned int *)(v16 + 8);
      if (!*(_DWORD *)(v16 + 8))
      {
        exception = __cxa_allocate_exception(0x20uLL);
        void *exception = &unk_1EF099E88;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/tail.cc";
        exception[2] = 0x4000000ACLL;
        exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/t"
                       "ail.cc:172: MARISA_RANGE_ERROR: current.length() == 0";
        __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
      }
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = *((unsigned int *)v14 + 2);
      while (v21 != v20)
      {
        if (*(unsigned __int8 *)(*v14 + v19) != *(unsigned __int8 *)(*(void *)v16 + v19)) {
          goto LABEL_13;
        }
        ++v20;
        --v19;
        if (v17 == v20) {
          goto LABEL_14;
        }
      }
      uint64_t v20 = *((unsigned int *)v14 + 2);
LABEL_13:
      if (v20 != v17)
      {
        uint64_t v22 = *((void *)&v34[0] + 1);
        goto LABEL_17;
      }
LABEL_14:
      uint64_t v22 = *((void *)&v34[0] + 1);
      if (v21)
      {
        *(_DWORD *)(*((void *)&v34[0] + 1) + 4 * *(unsigned int *)(v15 + 16 * v13 + 12)) = v21
                                                                                             - v17
                                                                                             + *(_DWORD *)(*((void *)&v34[0] + 1) + 4 * *((unsigned int *)v14 + 3));
        goto LABEL_29;
      }
LABEL_17:
      *(_DWORD *)(v22 + 4 * *(unsigned int *)(v15 + 16 * v13 + 12)) = *(void *)(a1 + 24);
      unint64_t v23 = *v18;
      if (v23)
      {
        for (unint64_t i = 0; i < v23; ++i)
        {
          char v32 = *(unsigned char *)(*(void *)v16 - v23 + i + 1);
          sub_19E048D84((uint64_t *)a1, &v32);
          unint64_t v23 = *v18;
        }
        if (a4 != 4096)
        {
          if (v23 >= 2)
          {
            unint64_t v25 = 1;
            do
            {
              sub_19E045680((uint64_t *)(a1 + 48), 0);
              ++v25;
            }
            while (v25 < *v18);
          }
LABEL_27:
          sub_19E045680((uint64_t *)(a1 + 48), 1);
          goto LABEL_28;
        }
      }
      else if (a4 != 4096)
      {
        goto LABEL_27;
      }
      char v32 = 0;
      sub_19E048D84((uint64_t *)a1, &v32);
LABEL_28:
      if (*(_DWORD *)(a1 + 28))
      {
        int v31 = __cxa_allocate_exception(0x20uLL);
        *int v31 = &unk_1EF099E88;
        v31[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/tail.cc";
        v31[2] = 0x7000000C2;
        v31[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/trie/tail.cc"
                 ":194: MARISA_SIZE_ERROR: buf_.size() > MARISA_UINT32_MAX";
        __cxa_throw(v31, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
      }
LABEL_29:
      long long v14 = (void *)v16;
    }
    while (v13);
  }
  sub_19E048F00((unsigned char *)a1);
  long long v26 = *a3;
  *a3 = v34[0];
  v34[0] = v26;
  uint64_t v27 = *((void *)a3 + 2);
  *((void *)a3 + 2) = *(void *)&v34[1];
  *(void *)&v34[1] = v27;
  long long v28 = *(long long *)((char *)a3 + 24);
  *(long long *)((char *)a3 + 24) = *(_OWORD *)((char *)&v34[1] + 8);
  *(_OWORD *)((char *)&v34[1] + 8) = v28;
  LOBYTE(v27) = *((unsigned char *)a3 + 40);
  *((unsigned char *)a3 + 4sub_19E03D880(&a9, 0) = BYTE8(v34[2]);
  uint64_t result = v26;
  BYTE8(v34[2]) = v27;
  if ((void)v26) {
    return MEMORY[0x19F3BA6E0](v26, 0x1000C8077774924);
  }
  return result;
}

void sub_19E04D764(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    MEMORY[0x19F3BA6E0](a13, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_19E04D7A8(uint64_t *a1, uint64_t *a2)
{
  sub_19E045344(a1, a2);

  return sub_19E0452CC(a1 + 6, a2 + 6);
}

uint64_t sub_19E04D7E8(uint64_t a1, uint64_t *a2)
{
  memset(v8, 0, 41);
  memset(v9, 0, 41);
  long long v12 = 0u;
  memset(v13, 0, sizeof(v13));
  long long v14 = 0u;
  memset(v15, 0, sizeof(v15));
  _OWORD v9[3] = 0u;
  long long v10 = 0u;
  memset(v11, 0, sizeof(v11));
  sub_19E04DCA4(v8, a2);
  sub_19E046110((uint64_t *)v9, a2);
  long long v4 = *(_OWORD *)a1;
  *(_OWORD *)a1 = v8[0];
  v8[0] = v4;
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)&v8[1];
  *(void *)&v8[1] = v5;
  long long v6 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a1 + 24) = *(long long *)((char *)&v8[1] + 8);
  *(long long *)((char *)&v8[1] + 8) = v6;
  LOBYTE(v5) = *(unsigned char *)(a1 + 40);
  *(unsigned char *)(a1 + 4sub_19E03D880(&a9, 0) = BYTE8(v8[2]);
  BYTE8(v8[2]) = v5;
  sub_19E0452CC((uint64_t *)(a1 + 48), (uint64_t *)v9);
  if ((void)v14) {
    MEMORY[0x19F3BA6E0](v14, 0x1000C8077774924);
  }
  if ((void)v12) {
    MEMORY[0x19F3BA6E0](v12, 0x1000C8077774924);
  }
  if ((void)v10) {
    MEMORY[0x19F3BA6E0](v10, 0x1000C8077774924);
  }
  if (*(void *)&v9[0]) {
    MEMORY[0x19F3BA6E0](*(void *)&v9[0], 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v8[0];
  if (*(void *)&v8[0]) {
    return MEMORY[0x19F3BA6E0](*(void *)&v8[0], 0x1000C8077774924);
  }
  return result;
}

void sub_19E04D940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E04D954(uint64_t a1, uint64_t a2)
{
  sub_19E04D0B0(a1, a2);

  return sub_19E047E6C(a1 + 48, a2);
}

void sub_19E04D994(void *a1, std::string *this, unint64_t a3)
{
  unint64_t v3 = a3;
  if (a1[12])
  {
    do
    {
      std::string::push_back(this, *(unsigned char *)(a1[2] + v3));
      uint64_t v6 = *(void *)(a1[8] + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v3;
      ++v3;
    }
    while ((v6 & 1) == 0);
  }
  else
  {
    uint64_t v7 = a1[2];
    std::string::value_type v8 = *(unsigned char *)(v7 + a3);
    if (v8)
    {
      unint64_t v9 = (unsigned __int8 *)(a3 + v7 + 1);
      do
      {
        std::string::push_back(this, v8);
        int v10 = *v9++;
        std::string::value_type v8 = v10;
      }
      while (v10);
    }
  }
}

uint64_t sub_19E04DA24(void *a1, uint64_t a2, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  uint64_t v5 = a1[2];
  if (a1[12])
  {
    unint64_t v6 = *a4;
    do
    {
      if (*(unsigned __int8 *)(v5 + a5) != *(unsigned __int8 *)(a2 + v6)) {
        break;
      }
      *a4 = ++v6;
      if ((*(void *)(a1[8] + ((a5 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a5)) {
        return 1;
      }
      ++a5;
    }
    while (v6 < a3);
  }
  else
  {
    uint64_t v7 = (unsigned __int8 *)(v5 + a5);
    unint64_t v8 = *a4;
    int v11 = *v7;
    unint64_t v9 = v7 + 1;
    int v10 = v11;
    while (v10 == *(unsigned __int8 *)(a2 + v8))
    {
      *a4 = ++v8;
      int v10 = *v9;
      if (!*v9) {
        return 1;
      }
      ++v9;
      if (v8 >= a3) {
        return 0;
      }
    }
  }
  return 0;
}

BOOL sub_19E04DAB8(void *a1, uint64_t a2, unint64_t a3, unint64_t *a4, unint64_t a5, std::string *this)
{
  unint64_t v7 = a5;
  if (a1[12])
  {
    unint64_t v12 = *a4;
    while (1)
    {
      int v13 = *(unsigned __int8 *)(a1[2] + v7);
      int v14 = *(unsigned __int8 *)(a2 + v12);
      BOOL v15 = v13 == v14;
      if (v13 != v14) {
        break;
      }
      std::string::push_back(this, v13);
      unint64_t v12 = *a4 + 1;
      *a4 = v12;
      if ((*(void *)(a1[8] + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v7)) {
        break;
      }
      ++v7;
      if (v12 >= a3)
      {
        do
        {
          std::string::push_back(this, *(unsigned char *)(a1[2] + v7));
          uint64_t v16 = *(void *)(a1[8] + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v7;
          ++v7;
        }
        while ((v16 & 1) == 0);
        return 1;
      }
    }
  }
  else
  {
    uint64_t v17 = a1[2];
    unint64_t v18 = *a4;
    unint64_t v19 = v17 + a5 - *a4;
    unsigned __int8 v20 = *(unsigned char *)(v17 + a5);
    unint64_t v21 = *a4;
    while (1)
    {
      int v22 = *(unsigned __int8 *)(a2 + v21);
      BOOL v15 = v20 == v22;
      if (v20 != v22) {
        break;
      }
      std::string::push_back(this, v20);
      unint64_t v23 = *a4;
      unint64_t v21 = *a4 + 1;
      *a4 = v21;
      unsigned __int8 v20 = *(unsigned char *)(v19 + v21);
      if (!v20) {
        break;
      }
      if (v21 >= a3)
      {
        long long v24 = (unsigned __int8 *)(v7 - v18 + v17 + v23 + 2);
        do
        {
          std::string::push_back(this, v20);
          int v25 = *v24++;
          unsigned __int8 v20 = v25;
        }
        while (v25);
        return 1;
      }
    }
  }
  return v15;
}

uint64_t *sub_19E04DC1C(uint64_t *result, unint64_t a2, _DWORD *a3)
{
  unint64_t v4 = a2;
  uint64_t v5 = result;
  unint64_t v6 = result[4];
  if (v6 < a2)
  {
    uint64_t v7 = 2 * v6;
    if (v6 >> 61) {
      uint64_t v7 = 0x3FFFFFFFFFFFFFFFLL;
    }
    if (v6 > a2 >> 1) {
      a2 = v7;
    }
    uint64_t result = (uint64_t *)sub_19E047DD4(result, a2);
  }
  unint64_t v8 = v5[3];
  unint64_t v9 = v4 - v8;
  if (v4 > v8)
  {
    int v10 = (_DWORD *)(v5[1] + 4 * v8);
    do
    {
      *v10++ = *a3;
      --v9;
    }
    while (v9);
  }
  v5[3] = v4;
  return result;
}

uint64_t sub_19E04DCA4(long long *a1, uint64_t *a2)
{
  memset(v7, 0, 41);
  sub_19E04D03C((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 4sub_19E03D880(&a9, 0) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_19E04DD3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E04DD64(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = a2;
  unint64_t v5 = a1;
  uint64_t v6 = a2 - a1;
  if ((uint64_t)(a2 - a1) < 161)
  {
    uint64_t v7 = 0;
    goto LABEL_68;
  }
  uint64_t v7 = 0;
  do
  {
    int v8 = sub_19E04E0FC(v5, v5 + 16 * ((unint64_t)v6 >> 5), v4 - 16, a3);
    int v9 = v8;
    unint64_t v10 = v5;
    unint64_t v11 = v4;
    unint64_t v12 = v5;
    unint64_t v13 = v4;
    while (v10 < v11)
    {
      unint64_t v14 = *(unsigned int *)(v10 + 8);
      int v15 = a3 >= v14 ? -1 : *(unsigned __int8 *)(*(void *)v10 - a3);
      if (v15 > v8) {
        break;
      }
      if (v15 == v8)
      {
        uint64_t v16 = *(void *)v10;
        int v17 = *(_DWORD *)(v10 + 12);
        *(void *)unint64_t v10 = *(void *)v12;
        *(void *)(v10 + 8) = *(void *)(v12 + 8);
        *(void *)unint64_t v12 = v16;
        *(_DWORD *)(v12 + 8) = v14;
        *(_DWORD *)(v12 + 12) = v17;
        v12 += 16;
      }
LABEL_11:
      v10 += 16;
    }
    if (v10 < v11)
    {
      unint64_t v18 = v11 - 16;
      do
      {
        unint64_t v11 = v18;
        unint64_t v19 = *(unsigned int *)(v18 + 8);
        if (a3 >= v19) {
          int v20 = -1;
        }
        else {
          int v20 = *(unsigned __int8 *)(*(void *)v11 - a3);
        }
        if (v20 < v8) {
          break;
        }
        if (v20 == v8)
        {
          uint64_t v21 = *(void *)(v13 - 16);
          v13 -= 16;
          uint64_t v22 = *(void *)v11;
          int v23 = *(_DWORD *)(v11 + 12);
          *(void *)unint64_t v11 = v21;
          *(void *)(v11 + 8) = *(void *)(v13 + 8);
          *(void *)unint64_t v13 = v22;
          *(_DWORD *)(v13 + 8) = v19;
          *(_DWORD *)(v13 + 12) = v23;
        }
        unint64_t v18 = v11 - 16;
      }
      while (v10 < v11);
    }
    if (v10 < v11)
    {
      uint64_t v24 = *(void *)v10;
      *(void *)unint64_t v10 = *(void *)v11;
      uint64_t v25 = *(void *)(v11 + 8);
      *(void *)unint64_t v11 = v24;
      uint64_t v26 = *(void *)(v10 + 8);
      *(void *)(v10 + 8) = v25;
      *(void *)(v11 + 8) = v26;
      goto LABEL_11;
    }
    uint64_t v42 = v7;
    while (v12 > v5)
    {
      uint64_t v28 = *(void *)(v12 - 16);
      v12 -= 16;
      uint64_t v27 = v28;
      uint64_t v29 = *(void *)(v10 - 16);
      v10 -= 16;
      *(void *)unint64_t v12 = v29;
      uint64_t v30 = *(void *)(v10 + 8);
      *(void *)unint64_t v10 = v27;
      uint64_t v31 = *(void *)(v12 + 8);
      *(void *)(v12 + 8) = v30;
      *(void *)(v10 + 8) = v31;
    }
    while (v13 < v4)
    {
      uint64_t v32 = *(void *)v13;
      *(void *)unint64_t v13 = *(void *)v11;
      uint64_t v33 = *(void *)(v11 + 8);
      *(void *)unint64_t v11 = v32;
      uint64_t v34 = *(void *)(v13 + 8);
      *(void *)(v13 + 8) = v33;
      *(void *)(v11 + 8) = v34;
      v11 += 16;
      v13 += 16;
    }
    uint64_t v35 = v10 - v5;
    uint64_t v36 = (uint64_t)(v10 - v5) >> 4;
    uint64_t v37 = v11 - v10;
    if (v36 <= (uint64_t)(v11 - v10) >> 4)
    {
      uint64_t v38 = v4 - v11;
      if (v37 >> 4 >= (uint64_t)(v4 - v11) >> 4)
      {
        if (v35 == 16)
        {
          uint64_t v39 = v42 + 1;
        }
        else
        {
          if (v35 < 17) {
            goto LABEL_52;
          }
          uint64_t v39 = sub_19E04DD64(v5, v10, a3) + v42;
        }
        uint64_t v42 = v39;
LABEL_52:
        if (v38 == 16)
        {
          uint64_t v7 = v42 + 1;
        }
        else if (v38 < 17)
        {
          uint64_t v7 = v42;
        }
        else
        {
          uint64_t v7 = sub_19E04DD64(v11, v4, a3) + v42;
        }
        if (v37 == 16)
        {
          ++v7;
        }
        else if (v37 >= 17)
        {
          if (v9 == -1)
          {
            ++v7;
            unint64_t v5 = v11;
            goto LABEL_63;
          }
          ++a3;
        }
        unint64_t v5 = v10;
LABEL_63:
        unint64_t v4 = v11;
        goto LABEL_64;
      }
    }
    if (v37 == 16) {
      goto LABEL_31;
    }
    if (v37 < 17)
    {
      uint64_t v7 = v42;
    }
    else if (v8 == -1)
    {
LABEL_31:
      uint64_t v7 = v42 + 1;
    }
    else
    {
      uint64_t v7 = sub_19E04DD64(v10, v11, a3 + 1) + v42;
    }
    uint64_t v40 = v4 - v11;
    if (v36 >= (uint64_t)(v4 - v11) >> 4)
    {
      if (v40 == 16)
      {
        ++v7;
      }
      else if (v40 >= 17)
      {
        v7 += sub_19E04DD64(v11, v4, a3);
      }
      unint64_t v4 = v10;
    }
    else
    {
      if (v35 == 16)
      {
        ++v7;
      }
      else if (v35 >= 17)
      {
        v7 += sub_19E04DD64(v5, v10, a3);
      }
      unint64_t v5 = v11;
    }
LABEL_64:
    uint64_t v6 = v4 - v5;
  }
  while ((uint64_t)(v4 - v5) > 160);
LABEL_68:
  if (v6 >= 17) {
    v7 += sub_19E04E17C(v5, v4, a3);
  }
  return v7;
}

uint64_t sub_19E04E0FC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(unsigned int *)(a1 + 8) <= a4) {
    int v4 = -1;
  }
  else {
    int v4 = *(unsigned __int8 *)(*(void *)a1 - a4);
  }
  if (*(unsigned int *)(a2 + 8) <= a4) {
    int v5 = -1;
  }
  else {
    int v5 = *(unsigned __int8 *)(*(void *)a2 - a4);
  }
  if (*(unsigned int *)(a3 + 8) <= a4) {
    int v6 = -1;
  }
  else {
    int v6 = *(unsigned __int8 *)(*(void *)a3 - a4);
  }
  if (v4 <= v5) {
    int v7 = v5;
  }
  else {
    int v7 = v4;
  }
  if (v4 >= v5) {
    int v4 = v5;
  }
  if (v4 <= v6) {
    int v4 = v6;
  }
  if (v7 >= v6) {
    return v4;
  }
  else {
    return v7;
  }
}

uint64_t sub_19E04E17C(unint64_t a1, unint64_t a2, unint64_t a3)
{
  long long v3 = (void *)(a1 + 16);
  if (a1 + 16 >= a2) {
    return 1;
  }
  uint64_t v7 = 1;
  do
  {
    int v8 = v3;
    if ((unint64_t)v3 <= a1)
    {
      int v10 = 0;
    }
    else
    {
      while (1)
      {
        int v9 = v8 - 2;
        int v10 = sub_19E04E24C((uint64_t)(v8 - 2), (uint64_t)v8, a3);
        if (v10 < 1) {
          break;
        }
        uint64_t v11 = *(v8 - 2);
        *(v8 - 2) = *v8;
        uint64_t v12 = v8[1];
        *int v8 = v11;
        uint64_t v13 = *(v8 - 1);
        *(v8 - 1) = v12;
        v8[1] = v13;
        v8 -= 2;
        if ((unint64_t)v9 <= a1)
        {
          int v10 = 1;
          break;
        }
      }
    }
    if (v10) {
      ++v7;
    }
    v3 += 2;
  }
  while ((unint64_t)v3 < a2);
  return v7;
}

uint64_t sub_19E04E24C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  unint64_t v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v3 == v4) {
      return 0;
    }
    else {
      return v12;
    }
  }
  else
  {
    uint64_t v6 = v4 - a3;
    uint64_t v7 = (unsigned __int8 *)(*(void *)a2 - a3);
    int v8 = (unsigned __int8 *)(*(void *)a1 - a3);
    while (v6)
    {
      int v9 = *v8;
      int v10 = *v7;
      uint64_t result = (v9 - v10);
      if (v9 != v10) {
        return result;
      }
      --v6;
      --v7;
      --v8;
      if (!--v5) {
        goto LABEL_6;
      }
    }
    return 1;
  }
}

uint64_t sub_19E04E2B8(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2 >> 9;
  uint64_t v3 = *(void *)(a1 + 80);
  uint64_t v4 = *(unsigned int *)(v3 + 12 * (a2 >> 9));
  switch((a2 >> 6) & 7)
  {
    case 1uLL:
      unint64_t v5 = *(_DWORD *)(v3 + 12 * v2 + 4) & 0x7F;
      goto LABEL_10;
    case 2uLL:
      unint64_t v6 = (unint64_t)*(unsigned int *)(v3 + 12 * v2 + 4) >> 7;
      goto LABEL_5;
    case 3uLL:
      unint64_t v6 = (unint64_t)*(unsigned int *)(v3 + 12 * v2 + 4) >> 15;
LABEL_5:
      v4 += v6;
      break;
    case 4uLL:
      v4 += (unint64_t)*(unsigned int *)(v3 + 12 * v2 + 4) >> 23;
      break;
    case 5uLL:
      unint64_t v5 = *(_DWORD *)(v3 + 12 * v2 + 8) & 0x1FF;
      goto LABEL_10;
    case 6uLL:
      unint64_t v5 = ((unint64_t)*(unsigned int *)(v3 + 12 * v2 + 8) >> 9) & 0x1FF;
      goto LABEL_10;
    case 7uLL:
      unint64_t v5 = ((unint64_t)*(unsigned int *)(v3 + 12 * v2 + 8) >> 18) & 0x1FF;
LABEL_10:
      v4 += v5;
      break;
    default:
      break;
  }
  unint64_t v7 = *(void *)(*(void *)(a1 + 16) + 8 * (a2 >> 6)) & ~(-1 << a2);
  unint64_t v8 = (((((v7 >> 1) & 0x5555555555555555) + (v7 & 0x5555555555555555)) >> 2) & 0x3333333333333333)
     + ((((v7 >> 1) & 0x5555555555555555) + (v7 & 0x5555555555555555)) & 0x3333333333333333);
  return v4 + ((0x101010101010101 * (((v8 >> 4) & 0x707070707070707) + (v8 & 0x707070707070707))) >> 56);
}

unint64_t sub_19E04E400(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[16];
  if ((a2 & 0x1FF) == 0) {
    return *(unsigned int *)(v2 + 4 * (a2 >> 9));
  }
  unint64_t v3 = *(_DWORD *)(v2 + 4 * (a2 >> 9)) >> 9;
  unint64_t v4 = (*(_DWORD *)(v2 + 4 * (a2 >> 9) + 4) + 511) >> 9;
  uint64_t v5 = a1[10];
  if (v3 + 10 >= v4)
  {
    uint64_t v7 = v5 + 12 * v3;
    unint64_t v8 = v3-- << 9;
    int v9 = (unsigned int *)(v7 + 12);
    do
    {
      unsigned int v10 = *v9;
      v9 += 3;
      ++v3;
      v8 += 512;
    }
    while (v8 - v10 <= a2);
  }
  else
  {
    do
    {
      if (((v4 + v3) >> 1 << 9) - *(unsigned int *)(v5 + 12 * ((v4 + v3) >> 1)) > a2) {
        unint64_t v4 = (v4 + v3) >> 1;
      }
      else {
        unint64_t v3 = (v4 + v3) >> 1;
      }
    }
    while (v3 + 1 < v4);
  }
  uint64_t v11 = (unsigned int *)(v5 + 12 * v3);
  unint64_t v12 = v11[1];
  unint64_t v13 = a2 - (v3 << 9) + *v11;
  uint64_t v14 = 8 * v3;
  if (v13 >= 256 - (v12 >> 23))
  {
    unint64_t v15 = *(unsigned int *)(v5 + 12 * v3 + 8);
    uint64_t v16 = (v15 >> 9) & 0x1FF;
    if (v13 >= 384 - v16)
    {
      uint64_t v18 = (v15 >> 18) & 0x1FF;
      if (v13 >= 448 - v18)
      {
        v14 |= 7uLL;
        unint64_t v13 = v13 + v18 - 448;
      }
      else
      {
        v14 |= 6uLL;
        unint64_t v13 = v13 + v16 - 384;
      }
    }
    else if (v13 >= 320 - (v15 & 0x1FF))
    {
      v14 |= 5uLL;
      unint64_t v13 = v13 + (v15 & 0x1FF) - 320;
    }
    else
    {
      v14 |= 4uLL;
      unint64_t v13 = (v12 >> 23) + v13 - 256;
    }
  }
  else if (v13 >= 128 - (unint64_t)(v12 >> 7))
  {
    uint64_t v17 = (v12 >> 15);
    if (v13 >= 192 - v17)
    {
      v14 |= 3uLL;
      unint64_t v13 = v13 + v17 - 192;
    }
    else
    {
      v14 |= 2uLL;
      unint64_t v13 = v13 + (v12 >> 7) - 128;
    }
  }
  else if (v13 >= 64 - (v12 & 0x7F))
  {
    v14 |= 1uLL;
    unint64_t v13 = (v12 & 0x7F) + v13 - 64;
  }
  return sub_19E04E5E4(v13, v14 << 6, ~*(void *)(a1[2] + 8 * v14));
}

unint64_t sub_19E04E5E4(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = (((a3 - ((a3 >> 1) & 0x5555555555555555)) >> 2) & 0x3333333333333333)
     + ((a3 - ((a3 >> 1) & 0x5555555555555555)) & 0x3333333333333333);
  uint64_t v4 = (v3 + (v3 >> 4)) & 0xF0F0F0F0F0F0F0FLL;
  unint64_t v5 = __clz(__rbit64(((((0x101010101010101 * v4) | 0x8080808080808080)
                      - 0x101010101010101 * a1
                      - 0x101010101010101) >> 7) & 0x101010101010101));
  return v5
       + a2
       + byte_19E122D48[256 * (a1 - ((unint64_t)(0x101010101010100 * v4) >> v5))
                      + (a3 >> v5)];
}

unint64_t sub_19E04E66C(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[22];
  if ((a2 & 0x1FF) == 0) {
    return *(unsigned int *)(v2 + 4 * (a2 >> 9));
  }
  unint64_t v3 = *(_DWORD *)(v2 + 4 * (a2 >> 9)) >> 9;
  unint64_t v4 = (*(_DWORD *)(v2 + 4 * (a2 >> 9) + 4) + 511) >> 9;
  uint64_t v5 = a1[10];
  if (v3 + 10 >= v4)
  {
    uint64_t v7 = v5 + 12 * v3--;
    unint64_t v8 = (unsigned int *)(v7 + 12);
    do
    {
      unsigned int v9 = *v8;
      v8 += 3;
      ++v3;
    }
    while (v9 <= a2);
  }
  else
  {
    do
    {
      if (*(unsigned int *)(v5 + 12 * ((v4 + v3) >> 1)) > a2) {
        unint64_t v4 = (v4 + v3) >> 1;
      }
      else {
        unint64_t v3 = (v4 + v3) >> 1;
      }
    }
    while (v3 + 1 < v4);
  }
  unsigned int v10 = (unsigned int *)(v5 + 12 * v3);
  unint64_t v11 = v10[1];
  unint64_t v12 = a2 - *v10;
  uint64_t v13 = 8 * v3;
  if (v12 >= v11 >> 23)
  {
    unint64_t v23 = v11 >> 23;
    unint64_t v24 = *(unsigned int *)(v5 + 12 * v3 + 8);
    unint64_t v25 = (v24 >> 9) & 0x1FF;
    unint64_t v26 = (v24 >> 18) & 0x1FF;
    uint64_t v27 = v13 | 7;
    BOOL v28 = v12 >= v26;
    if (v12 < v26) {
      uint64_t v29 = v12 - v25;
    }
    else {
      uint64_t v29 = v12 - v26;
    }
    if (!v28) {
      uint64_t v27 = v13 | 6;
    }
    unint64_t v30 = v24 & 0x1FF;
    uint64_t v31 = v13 | 5;
    uint64_t v32 = v13 | 4;
    uint64_t v33 = v12 - v23;
    BOOL v34 = v12 >= v30;
    if (v12 < v30) {
      uint64_t v21 = v33;
    }
    else {
      uint64_t v21 = v12 - v30;
    }
    if (v34) {
      uint64_t v32 = v31;
    }
    if (v12 < v25)
    {
      uint64_t v22 = v32;
    }
    else
    {
      uint64_t v21 = v29;
      uint64_t v22 = v27;
    }
  }
  else
  {
    unint64_t v14 = v11 >> 7;
    unint64_t v15 = (v11 >> 15);
    uint64_t v16 = v12 - (v11 >> 7);
    if (v12 < v15)
    {
      uint64_t v17 = v13 | 2;
    }
    else
    {
      uint64_t v16 = v12 - v15;
      uint64_t v17 = v13 | 3;
    }
    unint64_t v18 = v11 & 0x7F;
    BOOL v20 = v12 >= v18;
    unint64_t v19 = v12 - v18;
    if (v20) {
      v13 |= 1uLL;
    }
    else {
      unint64_t v19 = v12;
    }
    BOOL v20 = v12 >= v14;
    if (v12 < v14) {
      uint64_t v21 = v19;
    }
    else {
      uint64_t v21 = v16;
    }
    if (v20) {
      uint64_t v22 = v17;
    }
    else {
      uint64_t v22 = v13;
    }
  }
  return sub_19E04E5E4(v21, v22 << 6, *(void *)(a1[2] + 8 * v22));
}

void sub_19E04E7E0(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = a2;
  uint64_t v7 = a1;
  unint64_t v8 = a2[6];
  unsigned int v9 = a1 + 8;
  unint64_t v10 = v8 >> 9;
  if ((v8 & 0x1FF) != 0) {
    ++v10;
  }
  sub_19E047C50(v9, v10 + 1);
  uint64_t v11 = v6[3];
  if (!v11)
  {
    LODWORD(v14) = 0;
    if ((v8 & 0x1FF) == 0) {
      goto LABEL_41;
    }
    goto LABEL_29;
  }
  unint64_t v51 = v8 & 0x1FF;
  unint64_t v52 = v8;
  unint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v53 = v7 + 20;
  uint64_t v54 = v7 + 14;
  uint64_t v57 = v6[3];
  do
  {
    unint64_t v16 = v12 >> 9;
    switch(v13 & 7)
    {
      case 1:
        uint64_t v17 = (_DWORD *)(v7[9] + 12 * v16);
        unsigned int v18 = v17[1] & 0xFFFFFF80 | (v14 - *v17) & 0x7F;
        goto LABEL_11;
      case 2:
        uint64_t v17 = (_DWORD *)(v7[9] + 12 * v16);
        unsigned int v18 = v17[1] & 0xFFFF807F | ((v14 - *(unsigned char *)v17) << 7);
        goto LABEL_11;
      case 3:
        uint64_t v17 = (_DWORD *)(v7[9] + 12 * v16);
        unsigned int v18 = v17[1] & 0xFF807FFF | ((v14 - *(unsigned char *)v17) << 15);
        goto LABEL_11;
      case 4:
        uint64_t v17 = (_DWORD *)(v7[9] + 12 * v16);
        unsigned int v18 = v17[1] & 0x7FFFFF | ((unsigned __int16)(v14 - *(_WORD *)v17) << 23);
LABEL_11:
        v17[1] = v18;
        break;
      case 5:
        unint64_t v19 = (_DWORD *)(v7[9] + 12 * v16);
        unsigned int v20 = v19[2] & 0xFFFFFE00 | (v14 - *v19) & 0x1FF;
        goto LABEL_15;
      case 6:
        unint64_t v19 = (_DWORD *)(v7[9] + 12 * v16);
        unsigned int v20 = v19[2] & 0xFFFC01FF | (((v14 - *v19) & 0x1FF) << 9);
        goto LABEL_15;
      case 7:
        unint64_t v19 = (_DWORD *)(v7[9] + 12 * v16);
        unsigned int v20 = v19[2] & 0xF803FFFF | (((v14 - *v19) & 0x1FF) << 18);
LABEL_15:
        v19[2] = v20;
        break;
      default:
        *(_DWORD *)(v7[9] + 12 * v16) = v14;
        break;
    }
    unint64_t v21 = *(void *)(v6[2] + 8 * v13);
    unint64_t v22 = (((((v21 >> 1) & 0x5555555555555555) + (v21 & 0x5555555555555555)) >> 2) & 0x3333333333333333)
        + ((((v21 >> 1) & 0x5555555555555555) + (v21 & 0x5555555555555555)) & 0x3333333333333333);
    unint64_t v23 = (0x101010101010101 * (((v22 >> 4) & 0x707070707070707) + (v22 & 0x707070707070707))) >> 56;
    if (a3)
    {
      unint64_t v24 = v6;
      uint64_t v25 = a3;
      unint64_t v26 = v7;
      uint64_t v27 = a4;
      uint64_t v28 = 64;
      if (v8 < 0x40) {
        uint64_t v28 = v8;
      }
      unint64_t v29 = v28 - v23;
      unint64_t v30 = -(int)v15 & 0x1FFLL;
      if (v28 - v23 > v30)
      {
        uint64_t v55 = v15;
        uint64_t v56 = v14;
        int v58 = sub_19E04E5E4(v30, v12, ~v21);
        sub_19E04EC8C(v54, &v58);
        uint64_t v15 = v55;
        uint64_t v14 = v56;
        uint64_t v11 = v57;
      }
      v15 += v29;
      a4 = v27;
      uint64_t v7 = v26;
      a3 = v25;
      unint64_t v6 = v24;
    }
    if (a4)
    {
      unint64_t v31 = -(int)v14 & 0x1FFLL;
      if (v23 > v31)
      {
        unint64_t v32 = v21;
        uint64_t v33 = v14;
        uint64_t v34 = v15;
        int v58 = sub_19E04E5E4(v31, v12, v32);
        sub_19E04EC8C(v53, &v58);
        uint64_t v15 = v34;
        uint64_t v11 = v57;
        uint64_t v14 = v33;
      }
    }
    v14 += v23;
    ++v13;
    v12 += 64;
    v8 -= 64;
  }
  while (v11 != v13);
  unint64_t v8 = v52;
  if (v51)
  {
LABEL_29:
    unint64_t v35 = (v8 - 1) >> 9;
    switch(((v8 - 1) >> 6) & 7)
    {
      case 0uLL:
        uint64_t v36 = v7[9];
        uint64_t v37 = (_DWORD *)(v36 + 12 * v35);
        int v38 = v14 - *v37;
        unsigned int v39 = v37[1] & 0xFFFFFF80 | v38 & 0x7F;
        v37[1] = v39;
        goto LABEL_32;
      case 1uLL:
        uint64_t v36 = v7[9];
        uint64_t v40 = (_DWORD *)(v36 + 12 * v35);
        unsigned int v39 = v40[1];
        int v38 = v14 - *v40;
LABEL_32:
        unsigned int v41 = v39 & 0xFFFF807F | (v38 << 7);
        *(_DWORD *)(v36 + 12 * v35 + 4) = v41;
        goto LABEL_34;
      case 2uLL:
        uint64_t v36 = v7[9];
        uint64_t v42 = (_DWORD *)(v36 + 12 * v35);
        unsigned int v41 = v42[1];
        int v38 = v14 - *v42;
LABEL_34:
        unsigned int v43 = v41 & 0xFF807FFF | (v38 << 15);
        *(_DWORD *)(v36 + 12 * v35 + 4) = v43;
        goto LABEL_36;
      case 3uLL:
        uint64_t v36 = v7[9];
        uint64_t v44 = (_DWORD *)(v36 + 12 * v35);
        unsigned int v43 = v44[1];
        int v38 = v14 - *v44;
LABEL_36:
        *(_DWORD *)(v36 + 12 * v35 + 4) = v43 & 0x7FFFFF | ((unsigned __int16)v38 << 23);
        goto LABEL_38;
      case 4uLL:
        uint64_t v36 = v7[9];
        int v38 = v14 - *(_DWORD *)(v36 + 12 * v35);
LABEL_38:
        uint64_t v45 = v36 + 12 * v35;
        unsigned int v46 = *(_DWORD *)(v45 + 8) & 0xFFFFFE00 | v38 & 0x1FF;
        *(_DWORD *)(v45 + 8) = v46;
        goto LABEL_39;
      case 5uLL:
        uint64_t v36 = v7[9];
        uint64_t v49 = (_DWORD *)(v36 + 12 * v35);
        unsigned int v46 = v49[2];
        int v38 = v14 - *v49;
LABEL_39:
        unsigned int v47 = v46 & 0xFFFC01FF | ((v38 & 0x1FF) << 9);
        *(_DWORD *)(v36 + 12 * v35 + 8) = v47;
        goto LABEL_40;
      case 6uLL:
        uint64_t v36 = v7[9];
        unint64_t v50 = (_DWORD *)(v36 + 12 * v35);
        unsigned int v47 = v50[2];
        int v38 = v14 - *v50;
LABEL_40:
        *(_DWORD *)(v36 + 12 * v35 + 8) = v47 & 0xF803FFFF | ((v38 & 0x1FF) << 18);
        break;
      default:
        break;
    }
  }
LABEL_41:
  v7[6] = v8;
  v7[7] = v6[7];
  *(_DWORD *)(v7[9] + 12 * v7[11] - 12) = v14;
  if (a3)
  {
    int v58 = v8;
    sub_19E04EC8C(v7 + 14, &v58);
    sub_19E04ECFC((_DWORD *)v7 + 28);
  }
  if (a4)
  {
    unint64_t v48 = v7 + 20;
    int v58 = v8;
    sub_19E04EC8C(v48, &v58);
    sub_19E04ECFC(v48);
  }
}

uint64_t *sub_19E04EC8C(uint64_t *result, _DWORD *a2)
{
  unint64_t v3 = result;
  uint64_t v4 = result[3];
  unint64_t v5 = result[4];
  unint64_t v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    uint64_t v7 = 2 * v5;
    if (v5 >> 61) {
      uint64_t v7 = 0x3FFFFFFFFFFFFFFFLL;
    }
    if (v5 <= v6 >> 1) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = v7;
    }
    uint64_t result = (uint64_t *)sub_19E047DD4(result, v8);
    uint64_t v4 = v3[3];
    unint64_t v6 = v4 + 1;
  }
  *(_DWORD *)(v3[1] + 4 * v4) = *a2;
  v3[3] = v6;
  return result;
}

_DWORD *sub_19E04ECFC(_DWORD *result)
{
  if (*((unsigned char *)result + 40))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1EF099E88;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vector.h";
    exception[2] = 0x100000072;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/TrieUtils/src/third_party/marisa/lib/marisa/grimoire/vector/vec"
                   "tor.h:114: MARISA_STATE_ERROR: fixed_";
    __cxa_throw(exception, (struct type_info *)&unk_1EF099160, (void (*)(void *))std::exception::~exception);
  }
  uint64_t v1 = *((void *)result + 3);
  if (v1 != *((void *)result + 4))
  {
    return sub_19E047DD4((uint64_t *)result, v1);
  }
  return result;
}

uint64_t sub_19E04ED9C(unsigned int *a1)
{
  uint64_t v2 = sub_19E04EE08();
  uint64_t v3 = sub_19E05024C(a1);
  uint64_t v4 = *(void *)(v2 + 8 * (v3 & 3));
  return (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(void *)v4 + 40))(v4, a1, v3);
}

uint64_t sub_19E04EE08()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E94572A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E94572A0))
  {
    operator new();
  }
  return qword_1E9457298;
}

void sub_19E04EE80(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA710](v1, 0x20C40DC1BFBCFLL);
  __cxa_guard_abort(&qword_1E94572A0);
  _Unwind_Resume(a1);
}

void sub_19E04EEB8(_OWORD *a1)
{
  *a1 = 0u;
  a1[1] = 0u;
  operator new();
}

uint64_t sub_19E04EFC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8 * (*(_DWORD *)(a3 + 12) & 3)) + 16))();
}

uint64_t sub_19E04EFF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8 * (*(_DWORD *)(a3 + 12) & 3)) + 24))();
}

uint64_t sub_19E04F024(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8 * (*(_DWORD *)(a3 + 12) & 3)) + 32))();
}

uint64_t sub_19E04F054(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2) {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 8 * (*(_DWORD *)(a3 + 12) & 3)) + 48))();
  }
  else {
    return 0;
  }
}

BOOL sub_19E04F090(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 12);
  return (v1 & 3) != 0 && v1 != -1;
}

unint64_t sub_19E04F0A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(int *)(a3 + 12) & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(a2 + 8);
}

uint64_t sub_19E04F0B8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4 = *(uint64_t (**)(void))(**(void **)(sub_19E04EE08()
                                         + 8
                                         * (*(_DWORD *)(*(void *)(a2 + 8)
                                                      + (*(int *)(a3 + 12) & 0xFFFFFFFFFFFFFFFCLL)
                                                      + 4 * a4
                                                      + 4) & 3))
                           + 40);

  return v4();
}

void sub_19E04F140(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12 = *(void *)(a2 + 8);
  unint64_t v13 = *(int *)(a3 + 12) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v26 = 0;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x2000000000;
  v29[0] = 0;
  uint64_t v14 = *(unsigned int *)(v12 + v13);
  if (v14)
  {
    (*(void (**)(uint64_t, uint64_t, unint64_t, unsigned char *))(a7 + 16))(a7, v14, a4, v29);
    BOOL v15 = *((unsigned char *)v27 + 24) != 0;
  }
  else
  {
    BOOL v15 = 0;
  }
  if (a5 - 1 >= a4 && !v15)
  {
    uint64_t v16 = sub_19E04EE08();
    if (!*((unsigned char *)v27 + 24))
    {
      uint64_t v17 = v16;
      unint64_t v18 = 0;
      uint64_t v19 = v13 + v12 + 4;
      do
      {
        uint64_t v20 = *(void *)(v17 + 8 * (*(_DWORD *)(v19 + 4 * v18) & 3));
        v25[0] = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v20 + 40))(v20, a2);
        v25[1] = v21;
        if (a6) {
          *(unsigned char *)(a6 + a4) = v18;
        }
        v24[0] = MEMORY[0x1E4F143A8];
        v24[1] = 0x40000000;
        v24[2] = sub_19E04F350;
        v24[3] = &unk_1E599B580;
        v24[4] = a7;
        v24[5] = &v26;
        uint64_t v22 = *(void *)(v17 + 8 * (HIDWORD(v21) & 3));
        (*(void (**)(uint64_t, uint64_t, void *, unint64_t, uint64_t, uint64_t, void *))(*(void *)v22 + 24))(v22, a2, v25, a4 + 1, a5, a6, v24);
        if (*((unsigned char *)v27 + 24)) {
          break;
        }
      }
      while (v18++ < 0xFF);
    }
  }
  _Block_object_dispose(&v26, 8);
}

void sub_19E04F330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E04F350(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *a4 = *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t sub_19E04F3A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(unsigned int *)(*(void *)(a2 + 8) + (*(int *)(a3 + 12) & 0xFFFFFFFFFFFFFFFCLL));
}

uint64_t sub_19E04F3B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = *(int *)(a3 + 12) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v8 = sub_19E04EE08();
  uint64_t v9 = 0;
  char v16 = 0;
  uint64_t v10 = v7 + v6 + 4;
  do
  {
    uint64_t v11 = *(void *)(v8 + 8 * (*(_DWORD *)(v10 + 4 * v9) & 3));
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v11 + 40))(v11, a2);
    v15[0] = result;
    v15[1] = v13;
    BOOL v14 = HIDWORD(v13) == -1 || (v13 & 0x300000000) == 0;
    if (!v14) {
      uint64_t result = (*(uint64_t (**)(uint64_t, void, void *, char *))(a4 + 16))(a4, v9, v15, &v16);
    }
    if (v16) {
      break;
    }
    BOOL v14 = v9++ == 255;
  }
  while (!v14);
  return result;
}

uint64_t sub_19E04F49C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4 = *(void *)(a2 + 8);
  unint64_t v5 = *(int *)(a3 + 12) & 0xFFFFFFFFFFFFFFFCLL;
  unsigned int v6 = a4 >> 5;
  uint64_t v7 = v4 + v5 + 4 * (a4 >> 5);
  unsigned int v9 = *(_DWORD *)(v7 + 4);
  uint64_t v8 = (_DWORD *)(v7 + 4);
  if (((v9 >> a4) & 1) == 0) {
    return 0;
  }
  char v11 = a4 & 0x1F;
  uint64_t v12 = sub_19E04EE08();
  if (a4 >= 0x20)
  {
    int v14 = 0;
    if (v6 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = v6;
    }
    uint64_t v17 = (unsigned int *)(v5 + v4 + 4);
    do
    {
      unsigned int v18 = *v17++;
      int8x8_t v13 = vcnt_s8((int8x8_t)v18);
      v13.i16[0] = vaddlv_u8((uint8x8_t)v13);
      v14 += v13.i32[0];
      --v16;
    }
    while (v16);
  }
  else
  {
    int v14 = 0;
  }
  v13.i32[0] = *v8 & ~(-1 << v11);
  uint8x8_t v19 = (uint8x8_t)vcnt_s8(v13);
  v19.i16[0] = vaddlv_u8(v19);
  uint64_t v20 = *(uint64_t (**)(void))(**(void **)(v12
                                          + 8
                                          * (*(_DWORD *)(v4 + v5 + 4 * (v19.i32[0] + v14) + 40) & 3))
                            + 40);

  return v20();
}

void sub_19E04F5D0(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12 = *(void *)(a2 + 8);
  unint64_t v13 = *(int *)(a3 + 12) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v14 = v12 + v13;
  uint64_t v36 = 0;
  uint64_t v37 = &v36;
  uint64_t v38 = 0x2000000000;
  v39[0] = 0;
  uint64_t v15 = *(unsigned int *)(v12 + v13);
  if (v15)
  {
    (*(void (**)(uint64_t, uint64_t, unint64_t, char *))(a7 + 16))(a7, v15, a4, v39);
    BOOL v16 = *((unsigned char *)v37 + 24) != 0;
  }
  else
  {
    BOOL v16 = 0;
  }
  unint64_t v33 = a4;
  if (a5 - 1 >= a4 && !v16)
  {
    uint64_t v17 = sub_19E04EE08();
    uint8x8_t v19 = v37;
    if (!*((unsigned char *)v37 + 24))
    {
      uint64_t v20 = v17;
      unint64_t v21 = 0;
      uint64_t v22 = v13 + v12 + 4;
      do
      {
        if (v21 >> 5 <= 1) {
          uint64_t v23 = 1;
        }
        else {
          uint64_t v23 = v21 >> 5;
        }
        unsigned int v24 = *(_DWORD *)(v14 + 4 * (v21 >> 5) + 4);
        if ((v24 >> v21))
        {
          if (v21 >= 0x20u)
          {
            int v25 = 0;
            uint64_t v26 = (unsigned int *)v22;
            do
            {
              unsigned int v27 = *v26++;
              int8x8_t v18 = vcnt_s8((int8x8_t)v27);
              v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
              v25 += v18.i32[0];
              --v23;
            }
            while (v23);
          }
          else
          {
            int v25 = 0;
          }
          v18.i32[0] = v24 & ~(-1 << (v21 & 0x1F));
          uint8x8_t v28 = (uint8x8_t)vcnt_s8(v18);
          v28.i16[0] = vaddlv_u8(v28);
          uint64_t v29 = *(void *)(v20 + 8 * (*(_DWORD *)(v14 + 4 * (v28.i32[0] + v25) + 40) & 3));
          v35[0] = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v29 + 40))(v29, a2);
          v35[1] = v30;
          if (a6) {
            *(unsigned char *)(a6 + v33) = v21;
          }
          v34[0] = MEMORY[0x1E4F143A8];
          v34[1] = 0x40000000;
          int v34[2] = sub_19E04F874;
          _OWORD v34[3] = &unk_1E599B5A8;
          v34[4] = a7;
          v34[5] = &v36;
          uint64_t v31 = *(void *)(v20 + 8 * (HIDWORD(v30) & 3));
          (*(void (**)(uint64_t, uint64_t, void *, unint64_t, uint64_t, uint64_t, void *))(*(void *)v31 + 24))(v31, a2, v35, v33 + 1, a5, a6, v34);
          uint8x8_t v19 = v37;
        }
        if (*((unsigned char *)v19 + 24)) {
          break;
        }
      }
      while (v21++ < 0xFF);
    }
  }
  _Block_object_dispose(&v36, 8);
}

void sub_19E04F854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E04F874(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *a4 = *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t sub_19E04F8C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = *(void *)(a2 + 8) + (*(int *)(a3 + 12) & 0xFFFFFFFFFFFFFFFCLL);
  uint64_t result = sub_19E04EE08();
  uint64_t v9 = result;
  unint64_t v10 = 0;
  char v21 = 0;
  while (1)
  {
    uint64_t v11 = v10 >> 5 <= 1 ? 1 : v10 >> 5;
    unsigned int v12 = *(_DWORD *)(v6 + 4 * (v10 >> 5) + 4);
    if ((v12 >> v10)) {
      break;
    }
    if (v10 > 0xFE) {
      return result;
    }
LABEL_19:
    ++v10;
  }
  if (v10 >= 0x20u)
  {
    int v13 = 0;
    uint64_t v14 = (unsigned int *)(v6 + 4);
    do
    {
      unsigned int v15 = *v14++;
      int8x8_t v8 = vcnt_s8((int8x8_t)v15);
      v8.i16[0] = vaddlv_u8((uint8x8_t)v8);
      v13 += v8.i32[0];
      --v11;
    }
    while (v11);
  }
  else
  {
    int v13 = 0;
  }
  v8.i32[0] = v12 & ~(-1 << (v10 & 0x1F));
  uint8x8_t v16 = (uint8x8_t)vcnt_s8(v8);
  v16.i16[0] = vaddlv_u8(v16);
  uint64_t v17 = *(void *)(v9 + 8 * (*(_DWORD *)(v6 + 4 * (v16.i32[0] + v13) + 40) & 3));
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 40))(v17, a2);
  v20[0] = result;
  v20[1] = v18;
  if (HIDWORD(v18) != -1 && (v18 & 0x300000000) != 0) {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, void *, char *))(a4 + 16))(a4, v10, v20, &v21);
  }
  if (!v21 && v10 < 0xFF) {
    goto LABEL_19;
  }
  return result;
}

uint64_t sub_19E04FA3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(unsigned int *)(*(void *)(a2 + 8) + (*(int *)(a3 + 12) & 0xFFFFFFFFFFFFFFFCLL));
}

unsigned __int8 *sub_19E04FA50(int a1, uint64_t a2, unsigned __int8 **a3, char a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a3;
  if (!*a3) {
    return 0;
  }
  unint64_t v6 = (unsigned __int8 *)(*(void *)(a2 + 16) + (*((int *)a3 + 3) & 0xFFFFFFFFFFFFFFFCLL));
  memset(v12, 0, sizeof(v12));
  if (v4 <= v6 + 4)
  {
    if (v4 != v6 + 4) {
      sub_19E050104();
    }
    unint64_t v10 = (unint64_t)(v6 + 8);
    LOBYTE(v12[0]) = a4;
    unint64_t v9 = 1;
  }
  else
  {
    uint64_t v7 = *v4;
    size_t v8 = *((unsigned __int8 *)a3 + 8);
    a1 = memcpy(v12, v4 + 1, v8);
    unint64_t v9 = v8 + 1;
    *((unsigned char *)v12 + v8) = a4;
    if (v8 >= v7) {
      unint64_t v10 = (unint64_t)&v4[v7 + 5];
    }
    else {
      unint64_t v10 = (unint64_t)v4;
    }
  }
  return sub_19E04FB7C(a1, v10, (unint64_t)&v6[*(unsigned int *)v6 + 4], v12, v9);
}

unsigned __int8 *sub_19E04FB7C(int a1, unint64_t __s1, unint64_t a3, void *__s2, unint64_t a5)
{
  if (__s1 >= a3) {
    return 0;
  }
  size_t v8 = (unsigned __int8 *)__s1;
  size_t v9 = (int)a5;
  while (1)
  {
    unint64_t v10 = *v8;
    if (v10 >= a5)
    {
      int v11 = memcmp(v8 + 1, __s2, v9);
      if (v11 > 0) {
        return 0;
      }
      if (!v11) {
        break;
      }
    }
    v8 += v10 + 5;
    if ((unint64_t)v8 >= a3) {
      return 0;
    }
  }
  return v8;
}

void sub_19E04FC2C(uint64_t a1, uint64_t a2, unsigned int **a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a3;
  if (*a3)
  {
    unsigned __int8 v30 = 0;
    uint64_t v13 = (unsigned int *)(*(void *)(a2 + 16) + (*((int *)a3 + 3) & 0xFFFFFFFFFFFFFFFCLL));
    uint64_t v14 = v13 + 1;
    if (v7 != v13 + 1
      || (uint64_t v19 = *v7, !v19)
      || ((*(void (**)(uint64_t, uint64_t, unint64_t, unsigned __int8 *))(a7 + 16))(a7, v19, a4, &v30),
          !v30))
    {
      if (a5 - 1 >= a4)
      {
        memset(__dst, 0, sizeof(__dst));
        unsigned int v15 = (unsigned __int8 *)*a3;
        if (*a3 <= v14)
        {
          size_t v17 = 0;
          uint64_t v18 = (unsigned __int8 *)(v13 + 2);
        }
        else
        {
          uint64_t v16 = *v15;
          size_t v17 = *((unsigned __int8 *)a3 + 8);
          memcpy(__dst, v15 + 1, v17);
          if (v17 <= v16) {
            uint64_t v18 = v15;
          }
          else {
            uint64_t v18 = &v15[v16 + 5];
          }
        }
        size_t v20 = a5 - a4;
        uint8x8_t v28 = (void *)(a6 + a4);
        unint64_t v29 = a4 - v17;
        do
        {
          if (v18 >= (unsigned __int8 *)v14 + *v13) {
            break;
          }
          unsigned int v23 = *v18;
          char v21 = (char *)(v18 + 1);
          uint64_t v22 = v23;
          size_t v24 = v23 - v17;
          if (v23 < v17 || a5 && v24 > v20) {
            goto LABEL_19;
          }
          int v25 = memcmp(v21, __dst, v17);
          if (v25 > 0) {
            return;
          }
          if (v25 || (uint64_t v27 = *(unsigned int *)&v21[v22], !v27))
          {
LABEL_19:
            int v26 = 0;
          }
          else
          {
            if (a6)
            {
              memcpy(v28, &v21[v17], v24);
              uint64_t v27 = *(unsigned int *)&v21[v22];
            }
            (*(void (**)(uint64_t, uint64_t, unint64_t, unsigned __int8 *))(a7 + 16))(a7, v27, v29 + v22, &v30);
            int v26 = v30;
          }
          uint64_t v18 = (unsigned __int8 *)&v21[v22 + 4];
        }
        while (!v26);
      }
    }
  }
}

uint64_t sub_19E04FE28(uint64_t a1, uint64_t a2, int a3)
{
  return *(void *)(a2 + 16) + (int)(a3 & 0xFFFFFFFC) + 4;
}

uint64_t sub_19E04FE40(uint64_t a1, uint64_t a2, unsigned int **a3)
{
  uint64_t v3 = *a3;
  if (*a3 == (unsigned int *)(*(void *)(a2 + 16) + (*((int *)a3 + 3) & 0xFFFFFFFFFFFFFFFCLL) + 4)) {
    return *v3;
  }
  uint64_t v4 = *(unsigned __int8 *)v3;
  if (v4 == *((unsigned __int8 *)a3 + 8))
  {
    uint64_t v3 = (unsigned int *)((char *)v3 + v4 + 1);
    return *v3;
  }
  return 0;
}

uint64_t sub_19E04FE88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(unsigned __int8 *)(a3 + 8) + *(void *)a3;
}

void sub_19E04FE98(uint64_t a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a3;
  if (*a3)
  {
    uint64_t v7 = (unsigned __int8 *)(*(void *)(a2 + 16) + (*((int *)a3 + 3) & 0xFFFFFFFFFFFFFFFCLL));
    long long v8 = 0uLL;
    memset(__dst, 0, 256);
    if (v4 <= v7 + 4)
    {
      size_t v10 = 0;
      int v11 = v7 + 8;
    }
    else
    {
      uint64_t v9 = *v4;
      size_t v10 = *((unsigned __int8 *)a3 + 8);
      memcpy(__dst, v4 + 1, v10);
      long long v8 = 0uLL;
      if (v10 >= v9) {
        int v11 = &v4[v9 + 5];
      }
      else {
        int v11 = v4;
      }
    }
    int v12 = 0;
    v24[14] = v8;
    v24[15] = v8;
    v24[12] = v8;
    v24[13] = v8;
    v24[10] = v8;
    v24[11] = v8;
    v24[8] = v8;
    v24[9] = v8;
    v24[7] = v8;
    v24[5] = v8;
    void v24[6] = v8;
    v24[3] = v8;
    v24[4] = v8;
    v24[1] = v8;
    v24[2] = v8;
    v24[0] = v8;
    unsigned __int8 v23 = 0;
    while (v11 < &v7[*(unsigned int *)v7 + 4])
    {
      uint64_t v14 = v11 + 1;
      size_t v13 = *v11;
      if (v10 > v13 || (uint64_t v15 = v14[v10], *((unsigned char *)v24 + v15)))
      {
        int v16 = 0;
      }
      else
      {
        int v17 = memcmp(v11 + 1, __dst, v10);
        if (v17 > 0) {
          return;
        }
        if (!v17)
        {
          int v18 = *((_DWORD *)a3 + 3);
          uint64_t v19 = v11;
          char v20 = v10 + 1;
          char v21 = 0;
          int v22 = v18;
          (*(void (**)(uint64_t, uint64_t, unsigned __int8 **, unsigned __int8 *))(a4 + 16))(a4, v15, &v19, &v23);
          int v12 = v23;
        }
        *((unsigned char *)v24 + v15) = 1;
        int v16 = v12;
      }
      int v11 = &v14[v13 + 4];
      if (v16) {
        return;
      }
    }
  }
}

uint64_t sub_19E050088()
{
  return 0;
}

uint64_t sub_19E050094()
{
  return 0;
}

void sub_19E0500A0()
{
}

void sub_19E0500B8()
{
}

void sub_19E0500D0()
{
}

void sub_19E0500E8()
{
}

uint64_t sub_19E0500FC()
{
  return 0;
}

void sub_19E050104()
{
  __assert_rtn("nextPositionForByte", "BTriePositionInterpreter.cpp", 405, "position.m_flatPageKey == page->bytes");
}

float sub_19E050130(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  long long v8 = malloc_type_malloc(0x48uLL, 0x108004094C1867FuLL);
  if (v8)
  {
    LODWORD(v9) = 0;
    v8[1] = 0u;
    void v8[2] = 0u;
    *long long v8 = 0u;
    *((void *)v8 + 7) = a1;
    *((void *)v8 + 8) = a2;
    *((void *)v8 + 1) = a3;
    *((void *)v8 + 5) = a4;
    *((void *)v8 + 6) = 0;
    if (a3)
    {
      if (a4 >= 0x18)
      {
        *(_DWORD *)long long v8 = *(_DWORD *)(a3 + 4);
        *((void *)v8 + 2) = a3 + *(unsigned int *)(a3 + 12);
        uint64_t v9 = *(void *)(a3 + 16);
        *(void *)&long long v10 = v9;
        *((void *)&v10 + 1) = HIDWORD(v9);
        *(_OWORD *)((char *)v8 + 24) = v10;
      }
    }
  }
  return *(float *)&v9;
}

void sub_19E0501C4(void **a1)
{
  if (a1)
  {
    if (*((_DWORD *)a1 + 12)) {
      free(a1[1]);
    }
    free(a1);
  }
}

uint64_t sub_19E050210(void *a1, void *a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t result = a1[1];
      *a2 = a1[2] - result + a1[3];
    }
    else
    {
      return a1[1];
    }
  }
  else
  {
    uint64_t result = 0;
    if (a2) {
      *a2 = 0;
    }
  }
  return result;
}

uint64_t sub_19E05024C(unsigned int *a1)
{
  return *a1;
}

BOOL sub_19E050254(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    a2 = *(void *)(a2 + 8);
    int v3 = *(_DWORD *)(v2 + 16);
    uint64_t v4 = *(unsigned int *)(v2 + 4);
  }
  else
  {
    int v3 = 0;
    uint64_t v4 = 0;
  }
  return sub_19E050278(a1, a2, v3, v4);
}

BOOL sub_19E050278(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (*(void *)(a1 + 2080) || (*(unsigned char *)(a1 + 2064) & 1) != 0) {
    return 0;
  }
  int v5 = 0;
  int v22 = 0;
  int v6 = a3 - 1;
  if ((a3 - 1) <= 0x3FE)
  {
    int v7 = a4;
    if (a4)
    {
      uint64_t v9 = 0;
      long long v10 = (int *)a1;
      while (1)
      {
        uint64_t v11 = *(void *)&v10[2 * *(unsigned __int8 *)(a2 + v9) + 1];
        if ((v11 & 3) != 1) {
          break;
        }
        long long v10 = (int *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
        if (a3 == ++v9)
        {
          int v12 = *v10;
          *long long v10 = a4;
          if (!v12) {
            goto LABEL_17;
          }
LABEL_18:
          int v5 = 1;
          return v5 != 0;
        }
      }
      if ((v11 & 3) != 2)
      {
        int v17 = (unsigned __int8 *)(a2 + v9);
        int v18 = (const void *)(a2 + v9 + 1);
        unsigned int v19 = v6 - v9;
        size_t v20 = (v6 - v9);
        unint64_t v21 = (unint64_t)malloc_type_calloc(1uLL, v20 + 15, 0x16B4CD09uLL);
        memcpy((void *)(v21 + 14), v18, v20);
        *(unsigned char *)(v21 + 14 + v19) = 0;
        *(_WORD *)(v21 + 12) = v19;
        *(_DWORD *)(v21 + 8) = v7;
        *(void *)unint64_t v21 = 0;
        *(void *)&v10[2 * *v17 + 1] = v21 | 2;
        goto LABEL_17;
      }
      unsigned __int8 v23 = (unsigned __int16 *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
      unsigned int v14 = sub_19E053DEC(a1, &v23, a2, a3, (int)v9 + 1, a4, &v22);
      unint64_t v15 = (unint64_t)v23;
      if (v14 >= *(_DWORD *)(a1 + 2088))
      {
        unint64_t v15 = (unint64_t)sub_19E053FF4(a1, v23, &v22);
        uint64_t v16 = 1;
      }
      else
      {
        uint64_t v16 = 2;
      }
      int v5 = v22;
      *(void *)&v10[2 * *(unsigned __int8 *)(a2 + v9) + 1] = v16 | v15;
      if (v5 == 2)
      {
LABEL_17:
        ++*(_DWORD *)(a1 + 2060);
        goto LABEL_18;
      }
    }
  }
  return v5 != 0;
}

uint64_t sub_19E050428(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t sub_19E050434(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 16);
  }
  return result;
}

uint64_t sub_19E050440(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 4);
  }
  return result;
}

void *sub_19E05044C(uint64_t a1, uint64_t a2)
{
  v7[4] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v2 = (float *)a2;
    a2 = *(void *)(a2 + 8);
    uint64_t v3 = *((unsigned int *)v2 + 4);
    uint64_t v4 = *((unsigned int *)v2 + 1);
    float v5 = *v2;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v3 = 0;
    float v5 = 0.0;
  }
  _OWORD v7[3] = 0;
  sub_19E0504F0(a1, a2, v3, v4, 0, (uint64_t)v7, v5);
  return sub_19E057B40(v7);
}

void sub_19E0504DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E057B40((uint64_t *)va);
  _Unwind_Resume(a1);
}

BOOL sub_19E0504F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float a7)
{
  v17[4] = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 2080) || (*(unsigned char *)(a1 + 2064) & 1) == 0) {
    return 0;
  }
  BOOL result = 0;
  int v16 = 0;
  if ((a3 - 1) <= 0x3FE && a4)
  {
    int v15 = 0;
    sub_19E057D34((uint64_t)v17, a6);
    sub_19E050B1C(a1, a1, a2, a3, 0, a4, (float *)&v15, &v16, a7, a5, (uint64_t)v17);
    sub_19E057B40(v17);
    int v14 = v16;
    if (v16 == 2) {
      ++*(_DWORD *)(a1 + 2060);
    }
    return v14 != 0;
  }
  return result;
}

void sub_19E050608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E057B40((uint64_t *)va);
  _Unwind_Resume(a1);
}

double sub_19E050624(int a1, int a2)
{
  uint64_t v4 = (char *)malloc_type_calloc(1uLL, 0x838uLL, 0x105004014637929uLL);
  if (v4)
  {
    double result = 0.0;
    *(_OWORD *)(v4 + 206sub_19E03D880(&a9, 0) = 0u;
    *((_DWORD *)v4 + 519) = 1;
    *((void *)v4 + 26sub_19E03D880(&a9, 0) = 0;
    *(void *)(v4 + 2092) = 0x200000000;
    *((_DWORD *)v4 + 516) = a2;
    *((_DWORD *)v4 + 522) = a1;
  }
  return result;
}

char *sub_19E05069C(char *result, int a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(_DWORD *)result == 12648430 || *(_DWORD *)result == -900339842)
    {
      double result = (char *)malloc_type_calloc(1uLL, 0x838uLL, 0x105004014637929uLL);
      *((void *)result + 26sub_19E03D880(&a9, 0) = v2;
      int v5 = v2[3];
      *(void *)(result + 2068) = v2[2];
      *((_DWORD *)result + 515) = v5;
      int v6 = v2[4];
      *((_DWORD *)result + 516) = v6;
      if (*v2 == -900339842) {
        *((_DWORD *)result + 516) = v6 | 1;
      }
      *((_DWORD *)result + 522) = v2[5];
      *((_DWORD *)result + 523) = a2;
      *((_DWORD *)result + 524) = 2;
      *((_DWORD *)result + 519) = 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_19E050760(char *a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 519) - 1;
    *((_DWORD *)a1 + 519) = v2;
    if (!v2)
    {
      uint64_t v3 = (void *)*((void *)a1 + 260);
      if (v3)
      {
        if (*((_DWORD *)a1 + 523)) {
          munmap(v3, *(void *)(a1 + 2068));
        }
      }
      else if (a1[2064])
      {
        sub_19E053CEC((uint64_t)a1);
      }
      else
      {
        sub_19E053D6C((uint64_t)a1);
      }
      free(a1);
    }
  }
}

char *sub_19E0507F0(char *a1)
{
  double result = sub_19E05069C(a1, 0);
  if (result)
  {
    int v2 = result;
    uint64_t v3 = sub_19E050830((uint64_t)result);
    sub_19E050760(v2);
    return (char *)v3;
  }
  return result;
}

uint64_t sub_19E050830(uint64_t a1)
{
  v7[4] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  sub_19E050624(*(_DWORD *)(a1 + 2088), *(_DWORD *)(a1 + 2064));
  uint64_t v3 = v2;
  if (*(unsigned char *)(a1 + 2064))
  {
    uint64_t v4 = v7;
    v7[0] = &unk_1EF09CB88;
    v7[1] = sub_19E05044C;
    _OWORD v7[3] = v7;
    sub_19E050980((void *)a1, 0, 0, v2, (uint64_t)v7, -1);
  }
  else
  {
    uint64_t v4 = v6;
    v6[0] = &unk_1EF09CB88;
    v6[1] = sub_19E050254;
    v6[3] = v6;
    sub_19E050980((void *)a1, 0, 0, v2, (uint64_t)v6, -1);
  }
  sub_19E057CB0(v4);
  return v3;
}

void sub_19E050960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_19E057CB0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E050980(void *a1, void *a2, size_t a3, uint64_t a4, uint64_t a5, int a6)
{
  v18[4] = *MEMORY[0x1E4F143B8];
  if (a6 < 0)
  {
    std::string __p = (void *)0xFFFFFFFF00000003;
    int v16 = 0;
    uint64_t v17 = a4;
    sub_19E05890C((uint64_t)v18, a5);
    sub_19E0518B0(a1, a2, a3, 0, (uint64_t)&__p);
    sub_19E057CB0(v18);
  }
  else
  {
    uint64_t v11 = sub_19E051B00((uint64_t)a1, (unsigned __int8 *)a2, a3);
    if (v11)
    {
      int v12 = v11;
      sub_19E057A94(&__p, a2, a3);
      size_t v13 = operator new(0x20uLL);
      *(void *)size_t v13 = &unk_1EF09CC90;
      v13[2] = a3;
      *((void *)v13 + 2) = &__p;
      *((void *)v13 + 3) = a5;
      v14[3] = v13;
      sub_19E051B74(v12, 0, (uint64_t)v14, a6);
      sub_19E058B70(v14);
      free(v12);
      if (SHIBYTE(v17) < 0) {
        operator delete(__p);
      }
    }
  }
}

void sub_19E050AD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  sub_19E057CB0(v18);
  _Unwind_Resume(a1);
}

uint64_t sub_19E050B1C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, float *a7, int *a8, float a9, uint64_t a10, uint64_t a11)
{
  float v13 = a9;
  v32[4] = *MEMORY[0x1E4F143B8];
  if (a5 >= a4)
  {
    *a8 = 2;
    if (*(_DWORD *)(a2 + 8))
    {
      *a8 = 1;
      if (*(void *)(a11 + 24))
      {
        double result = sub_19E0545F8(a11, a10, *(float *)(a2 + 4), a9);
        float v13 = v21;
      }
    }
    *(float *)(a2 + 4) = v13;
    *(_DWORD *)(a2 + 8) = a6;
    *a7 = v13;
  }
  else
  {
    uint64_t v19 = result;
    unint64_t v29 = (unsigned __int8 *)(a3 + a5);
    uint64_t v20 = *(void *)(a2 + 8 * *v29 + 12);
    if ((v20 & 3) == 2)
    {
      unsigned __int8 v30 = (unsigned __int16 *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
      sub_19E057D34((uint64_t)v31, a11);
      unsigned int v22 = sub_19E0541A0(v19, (uint64_t **)&v30, a3, a4, a5 + 1, a6, a7, a8, v13, a10, (uint64_t)v31);
      double result = (uint64_t)sub_19E057B40(v31);
      unint64_t v23 = (unint64_t)v30;
      if (v22 >= *(_DWORD *)(v19 + 2088))
      {
        double result = (uint64_t)sub_19E0543CC(v19, v30, a7, a8);
        unint64_t v23 = result;
        uint64_t v24 = 1;
      }
      else
      {
        uint64_t v24 = 2;
      }
      uint64_t v28 = v24 | v23;
      int v25 = v29;
    }
    else
    {
      if ((v20 & 3) == 1)
      {
        sub_19E057D34((uint64_t)v32, a11);
        sub_19E050B1C(v19, v20 & 0xFFFFFFFFFFFFFFFCLL, a3, a4, a5 + 1, a6, a7, a8, v13, a10, v32);
        double result = (uint64_t)sub_19E057B40(v32);
        goto LABEL_15;
      }
      *a7 = a9;
      int v25 = (unsigned __int8 *)(a3 + a5);
      size_t v26 = ~a5 + a4;
      unint64_t v27 = (unint64_t)malloc_type_calloc(1uLL, v26 + 23, 0xD69735D9uLL);
      double result = (uint64_t)memcpy((void *)(v27 + 22), v29 + 1, v26);
      *(unsigned char *)(v27 + 22 + v26) = 0;
      *(_WORD *)(v27 + 2sub_19E03D880(&a9, 0) = v26;
      *(_DWORD *)(v27 + 16) = a6;
      *(float *)(v27 + 8) = v13;
      *(float *)(v27 + 12) = v13;
      *(void *)unint64_t v27 = 0;
      uint64_t v28 = v27 | 2;
      *a8 = 2;
    }
    *(void *)(a2 + 8 * *v25 + 12) = v28;
  }
LABEL_15:
  if (*a7 > *(float *)a2) {
    *(float *)a2 = *a7;
  }
  return result;
}

void sub_19E050D80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_19E057B40(va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E050DA8(_DWORD *a1, char *a2, int a3)
{
  uint64_t result = 0;
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return result;
  }
  int v5 = a2;
  if (!a2 || !a3) {
    return result;
  }
  if (a1[516])
  {
    unint64_t v23 = (unint64_t *)operator new(8uLL);
    uint64_t v24 = 0;
    *unint64_t v23 = (unint64_t)a1;
    int v25 = v23 + 1;
    v105 = (char *)(v23 + 1);
    __pa = v23;
    v104 = v23 + 1;
    unint64_t v26 = (unint64_t)a1;
    while (1)
    {
      unint64_t v27 = v26 + 8 * v5[v24];
      uint64_t v30 = *(void *)(v27 + 12);
      unint64_t v29 = (uint64_t *)(v27 + 12);
      uint64_t v28 = v30;
      uint64_t v31 = v30 & 3;
      if ((v30 & 3) == 0) {
        goto LABEL_62;
      }
      if (v31 == 2) {
        break;
      }
      unint64_t v26 = v28 & 0xFFFFFFFFFFFFFFFCLL;
      if (v25 >= (unint64_t *)v105)
      {
        uint64_t v32 = v25 - __pa;
        if ((unint64_t)(v32 + 1) >> 61) {
          sub_19E041BEC();
        }
        unint64_t v33 = (v105 - (char *)__pa) >> 2;
        if (v33 <= v32 + 1) {
          unint64_t v33 = v32 + 1;
        }
        if ((unint64_t)(v105 - (char *)__pa) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v34 = v33;
        }
        if (v34) {
          unint64_t v35 = (char *)sub_19E049FB0((uint64_t)&v105, v34);
        }
        else {
          unint64_t v35 = 0;
        }
        uint64_t v36 = (unint64_t *)&v35[8 * v32];
        *uint64_t v36 = v26;
        int v25 = v36 + 1;
        uint64_t v37 = v104;
        if (v104 != __pa)
        {
          do
          {
            unint64_t v38 = *--v37;
            *--uint64_t v36 = v38;
          }
          while (v37 != __pa);
          uint64_t v37 = __pa;
        }
        __pa = v36;
        v105 = &v35[8 * v34];
        if (v37) {
          operator delete(v37);
        }
      }
      else
      {
        *v25++ = v26;
      }
      v104 = v25;
      if (++v24 == a3)
      {
        if (*(_DWORD *)(v26 + 8))
        {
          *(_DWORD *)(v26 + 8) = 0;
          goto LABEL_79;
        }
LABEL_62:
        char v54 = 0;
        goto LABEL_137;
      }
    }
    unsigned int v47 = &v5[v24 + 1];
    int v48 = ~v24 + a3;
    uint64_t v49 = (uint64_t *)(v28 & 0xFFFFFFFFFFFFFFFCLL);
    size_t v50 = *(unsigned __int16 *)((v28 & 0xFFFFFFFFFFFFFFFCLL) + 20);
    if (v48 == v50 && !memcmp(v47, (char *)v49 + 22, v50))
    {
      uint64_t v57 = *v49;
      free(v49);
      uint64_t v58 = v57 | 2;
      if (!v57) {
        uint64_t v58 = 0;
      }
      *unint64_t v29 = v58;
      goto LABEL_79;
    }
    uint64_t v51 = *v49;
    if (!*v49) {
      goto LABEL_62;
    }
    while (1)
    {
      unint64_t v52 = (uint64_t *)v51;
      size_t v53 = *(unsigned __int16 *)(v51 + 20);
      if (v48 == v53 && !memcmp(v47, (const void *)(v51 + 22), v53)) {
        break;
      }
      uint64_t v51 = *v52;
      uint64_t v49 = v52;
      if (!*v52) {
        goto LABEL_62;
      }
    }
    *uint64_t v49 = *v52;
    free(v52);
LABEL_79:
    if ((unint64_t)((char *)v104 - (char *)__pa) >= 0x10)
    {
      uint64_t v64 = v104 - __pa;
      unsigned int v109 = 0;
      uint64_t v65 = v64 - 1;
      if (v64 != 1)
      {
        LOBYTE(v66) = 0;
        unint64_t v67 = a1[522];
        while (1)
        {
          uint64_t v68 = sub_19E057DCC((uint64_t)a1, __pa[v65]);
          unsigned int v109 = 0;
          v116 = &unk_1EF09CDF0;
          v117 = &v109;
          v118 = &v116;
          sub_19E051B74(v68, 0, (uint64_t)&v116, -1);
          sub_19E058B70(&v116);
          if (v68) {
            free(v68);
          }
          if (v109 >= v67) {
            break;
          }
          uint64_t v66 = 1;
          if (!--v65) {
            goto LABEL_116;
          }
        }
        if (v66)
        {
          uint64_t v66 = v65 + 1;
LABEL_116:
          uint64_t v106 = 0;
          uint64_t v107 = 0;
          uint64_t v108 = 0;
          sub_19E057E68(&v106, v67);
          uint64_t v85 = __pa[v66];
          v86 = sub_19E057DCC((uint64_t)a1, v85);
          v113 = &unk_1EF09CD98;
          v114 = &v106;
          v115 = &v113;
          sub_19E051B74(v86, 0, (uint64_t)&v113, -1);
          sub_19E058B70(&v113);
          if (v67 <= (v107 - v106) >> 5) {
            __assert_rtn("reverseBurst", "BurstTrie.cpp", 1003, "items.size() < sizeThreshold");
          }
          if (v86) {
            free(v86);
          }
          sub_19E053CEC(v85);
          a1[515] -= (unint64_t)(v107 - v106) >> 5;
          *(void *)(__pa[v65] + 8 * v5[v65] + 12) = 0;
          if ((a3 + 1) < (unint64_t)(v104 - __pa)) {
            __assert_rtn("reverseBurst", "BurstTrie.cpp", 1012, "levels.size() <= keyLen + 1");
          }
          v87 = sub_19E052D84();
          uint64_t v88 = (uint64_t)v87;
          if (v66)
          {
            v89 = v87;
            uint64_t v90 = v66;
            do
            {
              char v91 = *v5++;
              *v89++ = v91;
              --v90;
            }
            while (v90);
          }
          uint64_t v92 = v106;
          uint64_t v93 = v107;
          if (v106 != v107)
          {
            int v94 = a1[516];
            do
            {
              if (*(char *)(v92 + 23) < 0)
              {
                v96 = *(const void **)v92;
                size_t v95 = *(void *)(v92 + 8);
              }
              else
              {
                size_t v95 = *(unsigned __int8 *)(v92 + 23);
                v96 = (const void *)v92;
              }
              uint64_t v97 = *(unsigned int *)(v92 + 24);
              float v98 = *(float *)(v92 + 28);
              memcpy((void *)(v88 + v66), v96, v95);
              if (*(char *)(v92 + 23) < 0) {
                uint64_t v99 = *(void *)(v92 + 8);
              }
              else {
                LODWORD(v99) = *(unsigned __int8 *)(v92 + 23);
              }
              uint64_t v100 = (v99 + v66);
              if (v94)
              {
                uint64_t v112 = 0;
                sub_19E0504F0((uint64_t)a1, v88, v100, v97, 0, (uint64_t)v111, v98);
                sub_19E057B40(v111);
              }
              else
              {
                sub_19E050278((uint64_t)a1, v88, v100, v97);
              }
              v92 += 32;
            }
            while (v92 != v93);
          }
          v110 = (void **)&v106;
          sub_19E0584A0(&v110);
        }
      }
    }
    char v54 = 1;
LABEL_137:
    if (__pa) {
      operator delete(__pa);
    }
    if ((v54 & 1) == 0) {
      return 0;
    }
    goto LABEL_140;
  }
  int v7 = (char *)operator new(8uLL);
  uint64_t v8 = 0;
  *(void *)int v7 = a1;
  uint64_t v9 = v7 + 8;
  v105 = v7 + 8;
  std::string __p = v7;
  v103 = v7 + 8;
  long long v10 = a1;
  do
  {
    uint64_t v11 = &v10[2 * v5[v8]];
    uint64_t v14 = *(void *)(v11 + 1);
    float v13 = (uint64_t *)(v11 + 1);
    uint64_t v12 = v14;
    uint64_t v15 = v14 & 3;
    if ((v14 & 3) == 0) {
      goto LABEL_55;
    }
    if (v15 == 2)
    {
      unsigned int v39 = &v5[v8 + 1];
      int v40 = ~v8 + a3;
      unsigned int v41 = (uint64_t *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
      size_t v42 = *(unsigned __int16 *)((v12 & 0xFFFFFFFFFFFFFFFCLL) + 12);
      if (v40 == v42 && !memcmp(v39, (char *)v41 + 14, v42))
      {
        uint64_t v55 = *v41;
        free(v41);
        uint64_t v56 = v55 | 2;
        if (!v55) {
          uint64_t v56 = 0;
        }
        *float v13 = v56;
        goto LABEL_70;
      }
      uint64_t v43 = *v41;
      if (*v41)
      {
        while (1)
        {
          uint64_t v44 = (uint64_t *)v43;
          size_t v45 = *(unsigned __int16 *)(v43 + 12);
          if (v40 == v45 && !memcmp(v39, (const void *)(v43 + 14), v45)) {
            break;
          }
          uint64_t v43 = *v44;
          unsigned int v41 = v44;
          if (!*v44) {
            goto LABEL_55;
          }
        }
        *unsigned int v41 = *v44;
        free(v44);
        goto LABEL_70;
      }
LABEL_55:
      int v46 = 0;
      goto LABEL_110;
    }
    long long v10 = (_DWORD *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
    if (v9 >= v105)
    {
      uint64_t v16 = (v9 - __p) >> 3;
      if ((unint64_t)(v16 + 1) >> 61) {
        sub_19E041BEC();
      }
      unint64_t v17 = (v105 - __p) >> 2;
      if (v17 <= v16 + 1) {
        unint64_t v17 = v16 + 1;
      }
      if ((unint64_t)(v105 - __p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v17;
      }
      if (v18) {
        uint64_t v19 = (char *)sub_19E049FB0((uint64_t)&v105, v18);
      }
      else {
        uint64_t v19 = 0;
      }
      uint64_t v20 = &v19[8 * v16];
      *(void *)uint64_t v20 = v10;
      uint64_t v9 = v20 + 8;
      float v21 = v103;
      if (v103 != __p)
      {
        do
        {
          uint64_t v22 = *((void *)v21 - 1);
          v21 -= 8;
          *((void *)v20 - 1) = v22;
          v20 -= 8;
        }
        while (v21 != __p);
        float v21 = __p;
      }
      std::string __p = v20;
      v105 = &v19[8 * v18];
      if (v21) {
        operator delete(v21);
      }
    }
    else
    {
      *(void *)uint64_t v9 = v10;
      v9 += 8;
    }
    v103 = v9;
    ++v8;
  }
  while (v8 != a3);
  if (!*v10) {
    goto LABEL_55;
  }
  *long long v10 = 0;
LABEL_70:
  if ((unint64_t)(v103 - __p) >= 0x10)
  {
    uint64_t v59 = (v103 - __p) >> 3;
    unsigned int v109 = 0;
    uint64_t v60 = v59 - 1;
    if (v59 != 1)
    {
      LOBYTE(v61) = 0;
      unint64_t v62 = a1[522];
      while (1)
      {
        v63 = sub_19E058544((uint64_t)a1, *(void *)&__p[8 * v60]);
        unsigned int v109 = 0;
        v116 = &unk_1EF09CD40;
        v117 = &v109;
        v118 = &v116;
        sub_19E051B74(v63, 0, (uint64_t)&v116, -1);
        sub_19E058B70(&v116);
        if (v63) {
          free(v63);
        }
        if (v109 >= v62) {
          break;
        }
        uint64_t v61 = 1;
        if (!--v60) {
          goto LABEL_89;
        }
      }
      if ((v61 & 1) == 0) {
        goto LABEL_109;
      }
      uint64_t v61 = v60 + 1;
LABEL_89:
      uint64_t v106 = 0;
      uint64_t v107 = 0;
      uint64_t v108 = 0;
      sub_19E057E68(&v106, v62);
      unint64_t v69 = *(void *)&__p[8 * v61];
      long long v70 = sub_19E058544((uint64_t)a1, v69);
      v113 = &unk_1EF09CCE8;
      v114 = &v106;
      v115 = &v113;
      sub_19E051B74(v70, 0, (uint64_t)&v113, -1);
      sub_19E058B70(&v113);
      if (v62 <= (v107 - v106) >> 5) {
        __assert_rtn("reverseBurst", "BurstTrie.cpp", 1003, "items.size() < sizeThreshold");
      }
      if (v70) {
        free(v70);
      }
      sub_19E053D6C(v69);
      a1[515] -= (unint64_t)(v107 - v106) >> 5;
      *(void *)(*(void *)&__p[8 * v60] + 8 * v5[v60] + 4) = 0;
      if ((a3 + 1) < (unint64_t)((v103 - __p) >> 3)) {
        __assert_rtn("reverseBurst", "BurstTrie.cpp", 1012, "levels.size() <= keyLen + 1");
      }
      v71 = sub_19E052D84();
      uint64_t v72 = (uint64_t)v71;
      if (v61)
      {
        v73 = v71;
        uint64_t v74 = v61;
        do
        {
          char v75 = *v5++;
          *v73++ = v75;
          --v74;
        }
        while (v74);
      }
      uint64_t v76 = v106;
      uint64_t v77 = v107;
      if (v106 != v107)
      {
        int v78 = a1[516];
        do
        {
          if (*(char *)(v76 + 23) < 0)
          {
            long long v80 = *(const void **)v76;
            size_t v79 = *(void *)(v76 + 8);
          }
          else
          {
            size_t v79 = *(unsigned __int8 *)(v76 + 23);
            long long v80 = (const void *)v76;
          }
          uint64_t v81 = *(unsigned int *)(v76 + 24);
          float v82 = *(float *)(v76 + 28);
          memcpy((void *)(v72 + v61), v80, v79);
          if (*(char *)(v76 + 23) < 0) {
            uint64_t v83 = *(void *)(v76 + 8);
          }
          else {
            LODWORD(v83) = *(unsigned __int8 *)(v76 + 23);
          }
          uint64_t v84 = (v83 + v61);
          if (v78)
          {
            uint64_t v112 = 0;
            sub_19E0504F0((uint64_t)a1, v72, v84, v81, 0, (uint64_t)v111, v82);
            sub_19E057B40(v111);
          }
          else
          {
            sub_19E050278((uint64_t)a1, v72, v84, v81);
          }
          v76 += 32;
        }
        while (v76 != v77);
      }
      v110 = (void **)&v106;
      sub_19E0584A0(&v110);
    }
  }
LABEL_109:
  int v46 = 1;
LABEL_110:
  if (__p) {
    operator delete(__p);
  }
  if (!v46) {
    return 0;
  }
LABEL_140:
  --a1[515];
  return 1;
}

void sub_19E051730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  a16 = &a12;
  sub_19E0584A0((void ***)&a16);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_19E0517D8(void *a1, const void *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  v12[4] = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 0;
  }
  int64_t v9 = 0xFFFFFFFF00000000;
  int v10 = 0;
  uint64_t v11 = 0;
  void v12[3] = 0;
  sub_19E0518B0(a1, a2, a3, 1, (uint64_t)&v9);
  BOOL v7 = v9 >= 0;
  if ((v9 & 0x8000000000000000) == 0)
  {
    if (a4) {
      *a4 = HIDWORD(v9);
    }
    if (a5) {
      *a5 = v10;
    }
  }
  sub_19E057CB0(v12);
  return v7;
}

void sub_19E05189C(_Unwind_Exception *a1)
{
  sub_19E057CB0(v1);
  _Unwind_Resume(a1);
}

void *sub_19E0518B0(void *result, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v18[4] = *MEMORY[0x1E4F143B8];
  if (a3 <= 0x3FF)
  {
    uint64_t v9 = (uint64_t)result;
    int v10 = sub_19E052D84();
    memcpy(v10, a2, a3);
    *((unsigned char *)v10 + a3) = 0;
    uint64_t v11 = *(void *)(v9 + 2080);
    int v12 = *(_DWORD *)(v9 + 2064);
    if (v11)
    {
      uint64_t v13 = (*(_DWORD *)(v11 + 4) & 0xFFFFFFFC) + v11;
      if (v12)
      {
        uint64_t v14 = v18;
        v18[0] = &unk_1EF09CBE0;
        v18[1] = sub_19E0549FC;
        _OWORD v18[3] = v18;
        sub_19E0546A0(v9, v13, (uint64_t)v10, a3, 0, a4, a5, (uint64_t)v18);
      }
      else
      {
        uint64_t v14 = v17;
        v17[0] = &unk_1EF09CBE0;
        v17[1] = sub_19E0549FC;
        long long v17[3] = v17;
        sub_19E054A8C(v9, v13, (uint64_t)v10, a3, 0, a4, a5, (uint64_t)v17);
      }
    }
    else if (v12)
    {
      uint64_t v14 = v16;
      v16[0] = &unk_1EF09CBE0;
      v16[1] = sub_19E0549FC;
      v16[3] = v16;
      sub_19E054DE8(v9, (uint64_t)v10, a3, 0, a4, a5, (uint64_t)v16);
    }
    else
    {
      uint64_t v14 = v15;
      v15[0] = &unk_1EF09CBE0;
      v15[1] = sub_19E0549FC;
      v15[3] = v15;
      sub_19E055074((int *)v9, (uint64_t)v10, a3, 0, a4, a5, (uint64_t)v15);
    }
    return sub_19E055B34(v14);
  }
  return result;
}

void sub_19E051AC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_19E055B34(va);
  _Unwind_Resume(a1);
}

void *sub_19E051B00(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  int v6 = malloc_type_calloc(0x28uLL, 1uLL, 0x119D39A0uLL);
  if ((sub_19E05264C(a1, (uint64_t)v6, a2, a3) & 1) == 0 && v6)
  {
    free(v6);
    return 0;
  }
  return v6;
}

void *sub_19E051B74(void *result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    BOOL v7 = result;
    uint64_t result = sub_19E052D84();
    uint64_t v8 = (uint64_t)result;
    char v16 = 0;
    int v9 = *((_DWORD *)v7 + 7);
    if (v9)
    {
      if (v9 != 1) {
        return result;
      }
      long long v13 = *(_OWORD *)v7;
      uint64_t v14 = v7[2];
      int v10 = (void *)v7[4];
      sub_19E058BF4((uint64_t)v18, a3);
      sub_19E051D60(v10, (uint64_t)&v13, v8, 0x1000u, 0, &v16, a2, (uint64_t)v18);
      uint64_t v11 = v18;
    }
    else
    {
      long long v13 = *(_OWORD *)v7;
      uint64_t v14 = v7[2];
      int v15 = *((_DWORD *)v7 + 6);
      int v12 = (void *)v7[4];
      sub_19E058BF4((uint64_t)v17, a3);
      sub_19E052E24(v12, (uint64_t)&v13, v8, 0, &v16, a4, a2, (uint64_t)v17);
      uint64_t v11 = v17;
    }
    return sub_19E058B70(v11);
  }
  return result;
}

void sub_19E051CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_19E058B70(va);
  _Unwind_Resume(a1);
}

void sub_19E051CDC(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t sub_19E051CE8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, float a7)
{
  uint64_t v13 = a3;
  uint64_t v14 = a2;
  int v12 = a4;
  int v11 = a5;
  float v10 = a7;
  uint64_t v9 = a6;
  uint64_t v7 = *(void *)(a1 + 24);
  if (!v7) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, int *, int *, float *, uint64_t *))(*(void *)v7 + 48))(v7, &v14, &v13, &v12, &v11, &v10, &v9);
}

void *sub_19E051D60(void *result, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, unsigned char *a6, uint64_t a7, uint64_t a8)
{
  v69[4] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = (uint64_t)result;
  switch(*(void *)a2 & 3)
  {
    case 1:
      sub_19E058BF4((uint64_t)v68, a8);
      uint64_t v14 = v68;
      sub_19E0523DC(v13, (void *)a2, a3, a4, a5, a6, a7, (uint64_t)v68);
      return sub_19E058B70(v14);
    case 2:
      sub_19E058BF4((uint64_t)v66, a8);
      int v15 = *(_DWORD *)(v13 + 2064);
      char v16 = (_DWORD *)((*(void *)a2 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(v13 + 2080));
      if (v15)
      {
        unint64_t v17 = (void *)sub_19E058BF4((uint64_t)v69, (uint64_t)v66);
        unsigned int v27 = *v16 - 8;
        if (*v16 == 8) {
          goto LABEL_34;
        }
        unsigned int v28 = 0;
        do
        {
          unint64_t v29 = (char *)v16 + v28;
          uint64_t v30 = *((unsigned __int16 *)v29 + 8);
          uint64_t v31 = *(unsigned int *)(a2 + 12);
          if (v30 >= v31)
          {
            uint64_t v32 = v29 + 8;
            int v33 = v30 - v31;
            memcpy((void *)(a3 + a5), &v29[v31 + 18], v30 - (int)v31);
            *(unsigned char *)(a3 + v33 + a5) = 0;
            sub_19E051CE8((uint64_t)v69, a7, a3, *((unsigned __int16 *)v32 + 4), *((_DWORD *)v32 + 1), (uint64_t)a6, *(float *)v32);
            LODWORD(v3sub_19E03D880(&a9, 0) = *((unsigned __int16 *)v32 + 4);
          }
          v28 += v30 + 10;
        }
        while (v28 < v27);
      }
      else if ((v15 & 4) != 0)
      {
        unint64_t v17 = (void *)sub_19E058BF4((uint64_t)v69, (uint64_t)v66);
        unsigned int v34 = *v16 - 4;
        unsigned int v35 = *(_DWORD *)(a2 + 8);
        if (v35 >= v34) {
          goto LABEL_34;
        }
        do
        {
          uint64_t v36 = (char *)v16 + v35;
          uint64_t v37 = *((unsigned __int16 *)v36 + 4);
          uint64_t v38 = *(unsigned int *)(a2 + 12);
          if (v37 >= v38)
          {
            int v40 = v36 + 4;
            int v41 = v37 - v38;
            memcpy((void *)(a3 + a5 + v36[10]), &v36[v38 + 11], v37 - (int)v38);
            *(unsigned char *)(a3 + v41 + a5 + v40[6]) = 0;
            sub_19E051CE8((uint64_t)v69, a7, a3, *((unsigned __int16 *)v40 + 2), *(_DWORD *)v40, (uint64_t)a6, 0.0);
            int v39 = *((unsigned __int16 *)v40 + 2) + *(_DWORD *)(a2 + 8);
          }
          else
          {
            int v39 = v35 + v37;
          }
          unsigned int v35 = v39 + 7;
          *(_DWORD *)(a2 + 8) = v35;
        }
        while (v35 < v34);
      }
      else
      {
        unint64_t v17 = (void *)sub_19E058BF4((uint64_t)v69, (uint64_t)v66);
        unsigned int v18 = *v16 - 4;
        unsigned int v19 = *(_DWORD *)(a2 + 8);
        if (v19 >= v18) {
          goto LABEL_34;
        }
        do
        {
          uint64_t v20 = (char *)v16 + v19;
          uint64_t v21 = *((unsigned __int16 *)v20 + 4);
          uint64_t v22 = *(unsigned int *)(a2 + 12);
          if (v21 >= v22)
          {
            uint64_t v24 = v20 + 4;
            int v25 = v21 - v22;
            memcpy((void *)(a3 + a5), &v20[v22 + 10], v21 - (int)v22);
            *(unsigned char *)(a3 + v25 + a5) = 0;
            sub_19E051CE8((uint64_t)v69, a7, a3, *((unsigned __int16 *)v24 + 2), *(_DWORD *)v24, (uint64_t)a6, (float)*(unsigned int *)v24);
            int v23 = *((unsigned __int16 *)v24 + 2) + *(_DWORD *)(a2 + 8);
          }
          else
          {
            int v23 = v19 + v21;
          }
          unsigned int v19 = v23 + 6;
          *(_DWORD *)(a2 + 8) = v19;
        }
        while (v19 < v18);
      }
      unint64_t v17 = v69;
LABEL_34:
      sub_19E058B70(v17);
      uint64_t v14 = v66;
      return sub_19E058B70(v14);
    case 3:
      sub_19E058BF4((uint64_t)v67, a8);
      unint64_t v26 = (*(void *)a2 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(v13 + 2080);
      if ((*(unsigned char *)(v13 + 2064) & 1) == 0)
      {
        if (*(_DWORD *)(v26 + 32))
        {
          *(unsigned char *)(a3 + a5) = 0;
          sub_19E051CE8((uint64_t)v67, a7, a3, a5, *(_DWORD *)(v26 + 32), (uint64_t)a6, 0.0);
          if (a5 >= a4 || *a6) {
            goto LABEL_65;
          }
        }
        else if (a5 >= a4)
        {
          goto LABEL_65;
        }
        uint64_t v42 = a5;
        unint64_t v43 = 0;
        uint64_t v44 = a5 + 1;
        uint64_t v45 = a4 - 1;
        while (1)
        {
          *(unsigned char *)(a3 + v42) = v43;
          if (v43 >> 6 <= 1) {
            uint64_t v46 = 1;
          }
          else {
            uint64_t v46 = v43 >> 6;
          }
          uint64_t v47 = *(void *)(v26 + 8 * (v43 >> 6));
          if ((v47 & (1 << v43)) != 0)
          {
            if (v43 >= 0x40)
            {
              int v48 = 0;
              uint64_t v49 = (int8x8_t *)v26;
              do
              {
                int8x8_t v50 = *v49++;
                uint8x8_t v51 = (uint8x8_t)vcnt_s8(v50);
                v51.i16[0] = vaddlv_u8(v51);
                v48 += v51.i32[0];
                --v46;
              }
              while (v46);
            }
            else
            {
              int v48 = 0;
            }
            uint8x8_t v52 = (uint8x8_t)vcnt_s8((int8x8_t)(v47 & ((1 << v43) - 1)));
            v52.i16[0] = vaddlv_u8(v52);
            *(void *)a2 = *(unsigned int *)(v26 + 4 * (v48 + v52.i32[0]) + 36);
            *(void *)(a2 + 8) = 0;
            *(_DWORD *)(a2 + 16) = 0;
            sub_19E058BF4((uint64_t)v69, (uint64_t)v67);
            sub_19E051D60(v13, a2, a3, v45, v44, a6, a7, v69);
            sub_19E058B70(v69);
            if (*a6 || v43 >= 0xFF) {
              goto LABEL_65;
            }
          }
          else if (v43 > 0xFE)
          {
            goto LABEL_65;
          }
          ++v43;
        }
      }
      if (*(_DWORD *)(v26 + 40))
      {
        *(unsigned char *)(a3 + a5) = 0;
        sub_19E051CE8((uint64_t)v67, a7, a3, a5, *(_DWORD *)(v26 + 40), (uint64_t)a6, *(float *)(v26 + 36));
        if (a5 >= a4 || *a6) {
          goto LABEL_65;
        }
      }
      else if (a5 >= a4)
      {
        goto LABEL_65;
      }
      uint64_t v53 = a5;
      unint64_t v54 = 0;
      uint64_t v55 = a5 + 1;
      uint64_t v56 = a4 - 1;
      break;
    default:
      if (*(void *)a2 != *(_DWORD *)(result[260] + 4)) {
        return result;
      }
      sub_19E058BF4((uint64_t)v65, a8);
      uint64_t v14 = v65;
      sub_19E0523DC(v13, (void *)a2, a3, a4, a5, a6, a7, (uint64_t)v65);
      return sub_19E058B70(v14);
  }
  while (1)
  {
    *(unsigned char *)(a3 + v53) = v54;
    uint64_t v57 = v54 >> 6 <= 1 ? 1 : v54 >> 6;
    uint64_t v58 = *(void *)(v26 + 8 * (v54 >> 6));
    if ((v58 & (1 << v54)) != 0) {
      break;
    }
    if (v54 > 0xFE) {
      goto LABEL_65;
    }
LABEL_64:
    ++v54;
  }
  if (v54 >= 0x40)
  {
    int v59 = 0;
    uint64_t v60 = (int8x8_t *)v26;
    do
    {
      int8x8_t v61 = *v60++;
      uint8x8_t v62 = (uint8x8_t)vcnt_s8(v61);
      v62.i16[0] = vaddlv_u8(v62);
      v59 += v62.i32[0];
      --v57;
    }
    while (v57);
  }
  else
  {
    int v59 = 0;
  }
  uint8x8_t v63 = (uint8x8_t)vcnt_s8((int8x8_t)(v58 & ((1 << v54) - 1)));
  v63.i16[0] = vaddlv_u8(v63);
  *(void *)a2 = *(unsigned int *)(v26 + 4 * (v59 + v63.i32[0]) + 44);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  sub_19E058BF4((uint64_t)v69, (uint64_t)v67);
  sub_19E051D60(v13, a2, a3, v56, v55, a6, a7, v69);
  sub_19E058B70(v69);
  if (!*a6 && v54 < 0xFF) {
    goto LABEL_64;
  }
LABEL_65:
  uint64_t v14 = v67;
  return sub_19E058B70(v14);
}

void sub_19E052358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_19E058B70(va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0523DC(uint64_t result, void *a2, uint64_t a3, unsigned int a4, unsigned int a5, unsigned char *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = result;
  v23[4] = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (*a2 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(result + 2080);
  if (*(unsigned char *)(result + 2064))
  {
    if (*(_DWORD *)(v12 + 1024))
    {
      *(unsigned char *)(a3 + a5) = 0;
      uint64_t result = sub_19E051CE8(a8, a7, a3, 0, *(_DWORD *)(v12 + 1024), (uint64_t)a6, *(float *)(v12 + 1032));
      if (a5 >= a4 || *a6) {
        return result;
      }
    }
    else if (a5 >= a4)
    {
      return result;
    }
    uint64_t v16 = 0;
    do
    {
      *(unsigned char *)(a3 + a5) = v16;
      *a2 = *(unsigned int *)(v12 + 4 * v16);
      if (v16) {
        uint64_t v17 = a5 + 1;
      }
      else {
        uint64_t v17 = a5;
      }
      a2[1] = 0;
      a2[2] = 0;
      sub_19E058BF4((uint64_t)v23, a8);
      sub_19E051D60(v11, a2, a3, a4 - (v16 != 0), v17, a6, a7, v23);
      uint64_t result = (uint64_t)sub_19E058B70(v23);
      if (*a6) {
        break;
      }
      BOOL v15 = v16++ == 255;
    }
    while (!v15);
  }
  else
  {
    if (*(_DWORD *)(v12 + 1024))
    {
      *(unsigned char *)(a3 + a5) = 0;
      uint64_t result = sub_19E051CE8(a8, a7, a3, 0, *(_DWORD *)(v12 + 1024), (uint64_t)a6, 0.0);
      if (a5 >= a4 || *a6) {
        return result;
      }
    }
    else if (a5 >= a4)
    {
      return result;
    }
    uint64_t v13 = 0;
    do
    {
      *(unsigned char *)(a3 + a5) = v13;
      *a2 = *(unsigned int *)(v12 + 4 * v13);
      a2[1] = 0;
      *((_DWORD *)a2 + 4) = 0;
      if (v13) {
        uint64_t v14 = a5 + 1;
      }
      else {
        uint64_t v14 = a5;
      }
      sub_19E058BF4((uint64_t)v22, a8);
      sub_19E051D60(v11, a2, a3, a4 - (v13 != 0), v14, a6, a7, v22);
      uint64_t result = (uint64_t)sub_19E058B70(v22);
      if (*a6) {
        break;
      }
      BOOL v15 = v13++ == 255;
    }
    while (!v15);
  }
  return result;
}

void sub_19E052624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_19E058B70((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E05264C(uint64_t a1, uint64_t a2, unsigned __int8 *a3, size_t a4)
{
  if (!a1 || !a2 || !sub_19E0526C0(a1, a2)) {
    return 0;
  }

  return sub_19E052734(a2, a3, a4, v7, v8);
}

uint64_t sub_19E0526C0(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  *(void *)(a2 + 32) = a1;
  uint64_t v2 = *(_DWORD **)(a1 + 2080);
  if (v2)
  {
    if (*v2 == -900339842 || *v2 == 12648430 && v2[7] == 2)
    {
      uint64_t result = 1;
      *(_DWORD *)(a2 + 28) = 1;
      uint64_t v4 = v2[1];
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      *(void *)a2 = v4;
      return result;
    }
    return 0;
  }
  *(_DWORD *)(a2 + 28) = 0;
  *(void *)(a2 + 8) = a1 | 1;
  *(void *)(a2 + 16) = 0;
  return 1;
}

uint64_t sub_19E052734(uint64_t result, unsigned __int8 *a2, size_t a3, __n128 a4, __n128 a5)
{
  if (result)
  {
    unsigned int v5 = a3;
    int v6 = a2;
    uint64_t v7 = result;
    int v8 = *(_DWORD *)(result + 28);
    if (v8)
    {
      if (v8 != 1) {
        return 0;
      }
      uint64_t v9 = *(void *)result;
      uint64_t v10 = *(void *)(result + 8);
      int v11 = *(_DWORD *)(result + 16);
      int v12 = *(_DWORD *)(result + 20);
      if ((sub_19E052898(*(void *)(result + 32), result, a2, a3, a4.n128_f64[0], a5) & 1) == 0)
      {
        uint64_t result = 0;
        *(void *)uint64_t v7 = v9;
        *(void *)(v7 + 8) = v10;
        *(_DWORD *)(v7 + 16) = v11;
        *(_DWORD *)(v7 + 2sub_19E03D880(&a9, 0) = v12;
        return result;
      }
    }
    else
    {
      uint64_t v14 = *(void *)result;
      uint64_t v13 = *(void *)(result + 8);
      uint64_t v15 = *(void *)(result + 16);
      int v16 = *(_DWORD *)(result + 24);
      uint64_t v17 = *(void *)(result + 32);
      for (uint64_t i = v13; (i & 3) == 1; uint64_t i = *(void *)(v7 + 8))
      {
        unsigned int v19 = (_DWORD *)(i & 0xFFFFFFFFFFFFFFFCLL);
        if (*(unsigned char *)(v17 + 2064))
        {
          if (!v5)
          {
            *(_DWORD *)(v7 + 2sub_19E03D880(&a9, 0) = v19[2];
            *(_DWORD *)(v7 + 24) = v19[1];
            return 1;
          }
          uint64_t v20 = (uint64_t *)&v19[2 * *v6 + 3];
        }
        else
        {
          if (!v5)
          {
            *(_DWORD *)(v7 + 2sub_19E03D880(&a9, 0) = *v19;
            return 1;
          }
          uint64_t v20 = (uint64_t *)&v19[2 * *v6 + 1];
        }
        sub_19E056A0C(v17, v7, *v20);
        ++v6;
        --v5;
      }
      if ((i & 3) != 2 || (sub_19E056730(v17, v7, v6, v5, a4) & 1) == 0)
      {
        uint64_t result = 0;
        *(void *)uint64_t v7 = v14;
        *(void *)(v7 + 8) = v13;
        *(void *)(v7 + 16) = v15;
        *(_DWORD *)(v7 + 24) = v16;
        return result;
      }
    }
    return 1;
  }
  return result;
}

uint64_t sub_19E052898(uint64_t a1, uint64_t a2, unsigned __int8 *__s2, size_t __n, double a5, __n128 a6)
{
  for (unsigned int i = __n; ; --i)
  {
    uint64_t v10 = *(void *)a2;
    uint64_t v11 = *(void *)a2 & 3;
    if (v11 != 3) {
      break;
    }
    int v12 = (int8x8_t *)((v10 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(a1 + 2080));
    if (*(unsigned char *)(a1 + 2064))
    {
      if (!i)
      {
        *(_DWORD *)(a2 + 16) = v12[5].i32[0];
        *(_DWORD *)(a2 + 2sub_19E03D880(&a9, 0) = v12[4].i32[1];
        goto LABEL_46;
      }
      unsigned int v18 = *__s2;
      LODWORD(v19) = v18 >> 6;
      int8x8_t v20 = v12[v18 >> 6];
      uint64_t v21 = 1 << v18;
      if (((1 << v18) & *(void *)&v20) == 0) {
        goto LABEL_42;
      }
      if (v18 >= 0x40)
      {
        int v22 = 0;
        if (v19 <= 1) {
          uint64_t v19 = 1;
        }
        else {
          uint64_t v19 = v19;
        }
        unsigned int v28 = v12;
        do
        {
          int8x8_t v29 = *v28++;
          uint8x8_t v30 = (uint8x8_t)vcnt_s8(v29);
          v30.i16[0] = vaddlv_u8(v30);
          v22 += v30.i32[0];
          --v19;
        }
        while (v19);
      }
      else
      {
        int v22 = 0;
      }
      uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)((v21 - 1) & *(void *)&v20));
      v31.i16[0] = vaddlv_u8(v31);
      unsigned int v27 = (unsigned int *)&v12[5] + (v22 + v31.i32[0]) + 1;
    }
    else
    {
      if (!i)
      {
        __int32 v43 = v12[4].i32[0];
LABEL_44:
        *(_DWORD *)(a2 + 16) = v43;
        goto LABEL_46;
      }
      unsigned int v13 = *__s2;
      LODWORD(v14) = v13 >> 6;
      int8x8_t v15 = v12[v13 >> 6];
      uint64_t v16 = 1 << v13;
      if (((1 << v13) & *(void *)&v15) == 0) {
        goto LABEL_42;
      }
      if (v13 >= 0x40)
      {
        int v17 = 0;
        if (v14 <= 1) {
          uint64_t v14 = 1;
        }
        else {
          uint64_t v14 = v14;
        }
        int v23 = v12;
        do
        {
          int8x8_t v24 = *v23++;
          uint8x8_t v25 = (uint8x8_t)vcnt_s8(v24);
          v25.i16[0] = vaddlv_u8(v25);
          v17 += v25.i32[0];
          --v14;
        }
        while (v14);
      }
      else
      {
        int v17 = 0;
      }
      uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)((v16 - 1) & *(void *)&v15));
      v26.i16[0] = vaddlv_u8(v26);
      unsigned int v27 = (unsigned int *)&v12[4] + (v17 + v26.i32[0]) + 1;
    }
    sub_19E056644(a1, a2, *v27);
    ++__s2;
  }
  if (!v11)
  {
    if (v10 != *(_DWORD *)(*(void *)(a1 + 2080) + 4)) {
      goto LABEL_42;
    }
LABEL_38:
    return sub_19E05658C(a1, a2, __s2, i);
  }
  if (v11 != 2) {
    goto LABEL_38;
  }
  int v32 = *(_DWORD *)(a1 + 2064);
  int v33 = (int *)((v10 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(a1 + 2080));
  int v34 = *v33;
  if ((v32 & 1) == 0)
  {
    unsigned int v35 = v34 - 4;
    if (v34 == 4) {
      goto LABEL_42;
    }
    uint64_t v36 = *(unsigned int *)(a2 + 8);
    if ((v32 & 4) != 0)
    {
      if (i)
      {
        if (v36 < v35)
        {
          unsigned int v56 = 0;
          while (1)
          {
            uint64_t v57 = (char *)v33 + v36;
            uint64_t v58 = v57 + 4;
            uint64_t v59 = v57[10];
            LODWORD(v6sub_19E03D880(&a9, 0) = v59;
            if (i > v59)
            {
              if (v59 <= *((unsigned __int16 *)v58 + 2)) {
                uint64_t v60 = *((unsigned __int16 *)v58 + 2);
              }
              else {
                uint64_t v60 = v59;
              }
              uint64_t v61 = v59;
              while (v60 != v61)
              {
                if (v58[(v61 + *(_DWORD *)(a2 + 12)) + 7] != __s2[v56 + v61])
                {
                  LODWORD(v6sub_19E03D880(&a9, 0) = v61;
                  break;
                }
                if (i == ++v61)
                {
                  LODWORD(v6sub_19E03D880(&a9, 0) = i;
                  break;
                }
              }
            }
            v56 += v60;
            int v62 = *((unsigned __int16 *)v58 + 2);
            if (v56 == i) {
              break;
            }
            char v41 = 0;
            LODWORD(v36) = v36 + v62 + 7;
            *(_DWORD *)(a2 + 8) = v36;
            if (v36 >= v35) {
              return v41 & 1;
            }
          }
          unsigned int v64 = *(_DWORD *)(a2 + 12) + i;
          *(_DWORD *)(a2 + 16) = 0;
          if (v62 + v59 == v64) {
            *(_DWORD *)(a2 + 16) = *(_DWORD *)v58;
          }
          goto LABEL_91;
        }
LABEL_42:
        char v41 = 0;
        return v41 & 1;
      }
      uint8x8_t v63 = (char *)v33 + v36;
      if (*(unsigned __int16 *)((char *)v33 + v36 + 8) + *((unsigned __int8 *)v33 + v36 + 10))
      {
LABEL_82:
        *(_DWORD *)(a2 + 16) = 0;
        goto LABEL_46;
      }
    }
    else
    {
      if (i)
      {
        if (v36 < v35)
        {
          uint64_t v37 = *(unsigned int *)(a2 + 12);
          while (1)
          {
            uint64_t v38 = (char *)v33 + v36;
            unsigned int v39 = *((unsigned __int16 *)v38 + 4);
            if (v39 >= v37)
            {
              int v40 = v38 + 4;
              if (!memcmp(&v38[v37 + 10], __s2, i)) {
                break;
              }
            }
            char v41 = 0;
            LODWORD(v36) = v36 + v39 + 6;
            *(_DWORD *)(a2 + 8) = v36;
            if (v36 >= v35) {
              return v41 & 1;
            }
          }
          *(_DWORD *)(a2 + 16) = 0;
          if (v39 - v37 == i) {
            *(_DWORD *)(a2 + 16) = *v40;
          }
          unsigned int v64 = v37 + i;
LABEL_91:
          *(_DWORD *)(a2 + 12) = v64;
          goto LABEL_46;
        }
        goto LABEL_42;
      }
      uint8x8_t v63 = (char *)v33 + v36;
      if (*(_WORD *)((char *)v33 + v36 + 8)) {
        goto LABEL_82;
      }
    }
    *(_DWORD *)(a2 + 16) = 0;
    __int32 v43 = *((_DWORD *)v63 + 1);
    goto LABEL_44;
  }
  if (v34 == 4) {
    goto LABEL_42;
  }
  unsigned int v44 = *(_DWORD *)(a2 + 8);
  a6.n128_u64[0] = *(void *)(a2 + 12);
  float v45 = *(float *)(a2 + 20);
  unsigned int v46 = v34 - 8;
  if (v34 == 8)
  {
    char v41 = 0;
LABEL_80:
    *(_DWORD *)(a2 + 8) = v44;
    *(void *)(a2 + 12) = a6.n128_u64[0];
    *(float *)(a2 + 2sub_19E03D880(&a9, 0) = v45;
    return v41 & 1;
  }
  unsigned int v47 = 0;
  char v41 = 0;
  uint64_t v48 = a6.n128_u32[0];
  unsigned __int32 v49 = a6.n128_u32[0] + i;
  size_t v50 = i;
  while (1)
  {
    while (1)
    {
      uint8x8_t v51 = (char *)v33 + v47;
      unsigned __int32 v52 = *((unsigned __int16 *)v51 + 8);
      if (v49 <= v52) {
        break;
      }
      v47 += v52 + 10;
      if (v47 >= v46) {
        goto LABEL_80;
      }
    }
    __n128 v68 = a6;
    unsigned int v65 = v44;
    uint64_t v53 = v51 + 8;
    size_t v66 = v50;
    uint64_t v67 = v48;
    if (!memcmp(&v51[v48 + 18], __s2, v50)) {
      break;
    }
    unsigned int v44 = v65;
    a6 = v68;
LABEL_61:
    v47 += v52 + 10;
    size_t v50 = v66;
    uint64_t v48 = v67;
    if (v47 >= v46) {
      goto LABEL_80;
    }
  }
  a6 = v68;
  if (v49 != v52)
  {
    HIDWORD(v54) = 0;
    BOOL v55 = (v41 & 1) == 0;
    unsigned int v44 = v65;
    if ((v41 & 1) == 0)
    {
      unsigned int v44 = v47;
      float v45 = 0.0;
    }
    char v41 = 1;
    if (v55)
    {
      LODWORD(v54) = v68.n128_u32[0] + i;
      a6.n128_f64[0] = v54;
    }
    goto LABEL_61;
  }
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 16) = v53[1];
  *(_DWORD *)(a2 + 2sub_19E03D880(&a9, 0) = *v53;
  *(_DWORD *)(a2 + 8) = v47;
  *(_DWORD *)(a2 + 12) = v49;
LABEL_46:
  char v41 = 1;
  return v41 & 1;
}

void *sub_19E052D84()
{
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1E94572A8, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    uint64_t v3 = &v4;
    std::__call_once(&qword_1E94572A8, &v3, (void (__cdecl *)(void *))sub_19E056AA8);
  }
  v0 = pthread_getspecific(qword_1E94572B0);
  if (!v0)
  {
    v0 = malloc_type_malloc(0x1000uLL, 0xAE75DD23uLL);
    pthread_setspecific(qword_1E94572B0, v0);
  }
  return v0;
}

void *sub_19E052E24(void *result, uint64_t a2, uint64_t a3, unsigned int a4, unsigned char *a5, int a6, uint64_t a7, uint64_t a8)
{
  v61[4] = *MEMORY[0x1E4F143B8];
  int v14 = *((_DWORD *)result + 516);
  uint64_t v15 = *(void *)(a2 + 8) & 3;
  if (v15 != 2)
  {
    if (v15 != 1) {
      return result;
    }
    uint64_t v16 = (uint64_t)result;
    if ((v14 & 1) == 0)
    {
      sub_19E058BF4((uint64_t)v59, a8);
      int v17 = (int *)(*(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFCLL);
      if (*v17)
      {
        sub_19E051CE8((uint64_t)v59, a7, a3, a4, *v17, (uint64_t)a5, *(float *)(a2 + 24));
        if (!a6 || *a5) {
          goto LABEL_48;
        }
      }
      else if (!a6)
      {
LABEL_48:
        unsigned int v47 = v59;
        return sub_19E058B70(v47);
      }
      uint64_t v48 = 0;
      uint64_t v49 = (a6 - 1);
      size_t v50 = v17 + 1;
      do
      {
        *(unsigned char *)(a3 + a4) = v48;
        sub_19E056A0C(v16, a2, *(void *)&v50[2 * v48]);
        sub_19E058BF4((uint64_t)v61, (uint64_t)v59);
        sub_19E052E24(v16, a2, a3, a4 + 1, a5, v49, a7, v61);
        sub_19E058B70(v61);
        if (*a5) {
          break;
        }
        BOOL v51 = v48++ == 255;
      }
      while (!v51);
      goto LABEL_48;
    }
    sub_19E058BF4((uint64_t)v60, a8);
    unint64_t v31 = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFCLL;
    int v32 = *(_DWORD *)(v31 + 8);
    if (v32)
    {
      sub_19E051CE8((uint64_t)v60, a7, a3, a4, v32, (uint64_t)a5, *(float *)(a2 + 24));
      if (!a6 || *a5) {
        goto LABEL_54;
      }
    }
    else if (!a6)
    {
LABEL_54:
      unsigned int v47 = v60;
      return sub_19E058B70(v47);
    }
    uint64_t v52 = 0;
    uint64_t v53 = (a6 - 1);
    unint64_t v54 = v31 + 12;
    do
    {
      *(unsigned char *)(a3 + a4) = v52;
      sub_19E056A0C(v16, a2, *(void *)(v54 + 8 * v52));
      sub_19E058BF4((uint64_t)v61, (uint64_t)v60);
      sub_19E052E24(v16, a2, a3, a4 + 1, a5, v53, a7, v61);
      sub_19E058B70(v61);
      if (*a5) {
        break;
      }
      BOOL v51 = v52++ == 255;
    }
    while (!v51);
    goto LABEL_54;
  }
  if (v14)
  {
    sub_19E058BF4((uint64_t)v58, a8);
    unint64_t v33 = *(void *)a2 & 0xFFFFFFFFFFFFFFFCLL;
    if (!v33) {
      goto LABEL_42;
    }
    unsigned int v56 = (unsigned __int8 *)(v33 + 22);
    unsigned int v34 = a4;
    uint64_t v35 = *(unsigned int *)(a2 + 16);
    unsigned int v36 = v34;
    uint64_t v37 = (void *)(a3 + v34);
    while (1)
    {
      uint64_t v38 = *(unsigned __int16 *)(v33 + 20);
      if (v38 >= v35)
      {
        size_t v39 = v38 - (int)v35;
        if (a6 < 0 || (int)v39 <= a6)
        {
          if (v35)
          {
            int v40 = (unsigned __int8 *)(v33 + 22);
            char v41 = v56;
            uint64_t v42 = v35;
            while (1)
            {
              int v44 = *v40++;
              int v43 = v44;
              int v45 = *v41++;
              if (v43 != v45) {
                break;
              }
              if (!--v42) {
                goto LABEL_38;
              }
            }
          }
          else
          {
LABEL_38:
            unsigned int v46 = v39 + v36;
            memcpy(v37, (const void *)(v33 + v35 + 22), v39);
            *(unsigned char *)(a3 + v46) = 0;
            sub_19E051CE8((uint64_t)v58, a7, a3, v46, *(_DWORD *)(v33 + 16), (uint64_t)a5, *(float *)(v33 + 12));
          }
        }
      }
      unint64_t v33 = *(void *)v33;
      if (!v33) {
        goto LABEL_40;
      }
    }
  }
  sub_19E058BF4((uint64_t)v57, a8);
  unsigned int v55 = a4;
  unint64_t v18 = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v19 = *(unsigned int *)(a2 + 16);
  if (v19 > *(unsigned __int16 *)(v18 + 12)) {
    __assert_rtn("traverseFromMapCursorTrieList", "BurstTrie.cpp", 2107, "cursor.prfxlen <= head->restlen");
  }
  if (!v18) {
    goto LABEL_40;
  }
  unint64_t v20 = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFCLL;
  while (v20 == v18)
  {
    unsigned int v21 = *(unsigned __int16 *)(v18 + 12);
LABEL_20:
    int v28 = v21 - v19;
    if (a6 < 0 || v28 <= a6)
    {
      unsigned int v29 = v28 + v55;
      memcpy((void *)(a3 + v55), (const void *)(v20 + v19 + 14), v28);
      *(unsigned char *)(a3 + v29) = 0;
      uint64_t v30 = sub_19E058BF4((uint64_t)v61, (uint64_t)v57);
      sub_19E051CE8(v30, a7, a3, v29, *(_DWORD *)(v20 + 8), (uint64_t)a5, 0.0);
      sub_19E058B70(v61);
    }
    unint64_t v20 = *(void *)v20;
    if (!v20) {
      goto LABEL_40;
    }
  }
  unsigned int v21 = *(unsigned __int16 *)(v20 + 12);
  if (v21 <= (unsigned __int16)v19) {
    goto LABEL_40;
  }
  if (!v19) {
    goto LABEL_20;
  }
  int v22 = (unsigned __int8 *)(v20 + 14);
  int v23 = (unsigned __int8 *)(v18 + 14);
  uint64_t v24 = v19;
  while (1)
  {
    int v26 = *v22++;
    int v25 = v26;
    int v27 = *v23++;
    if (v25 != v27) {
      break;
    }
    if (!--v24) {
      goto LABEL_20;
    }
  }
LABEL_40:
  if ((v14 & 1) == 0)
  {
    unsigned int v47 = v57;
    return sub_19E058B70(v47);
  }
LABEL_42:
  unsigned int v47 = v58;
  return sub_19E058B70(v47);
}

void sub_19E05324C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  sub_19E058B70((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_19E0532C8(void *result)
{
  if (result)
  {
    int v1 = result;
    uint64_t result = malloc_type_calloc(0x28uLL, 1uLL, 0x105D286FuLL);
    int v2 = *((_DWORD *)v1 + 7);
    if (v2)
    {
      if (v2 == 1)
      {
        *uint64_t result = *v1;
        result[1] = v1[1];
        *((_DWORD *)result + 4) = *((_DWORD *)v1 + 4);
        *((_DWORD *)result + 5) = *((_DWORD *)v1 + 5);
      }
    }
    else
    {
      *(_OWORD *)uint64_t result = *(_OWORD *)v1;
      result[2] = v1[2];
      *((_DWORD *)result + 6) = *((_DWORD *)v1 + 6);
    }
    *((_DWORD *)result + 7) = v2;
    result[4] = v1[4];
  }
  return result;
}

uint64_t sub_19E05335C(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[7];
  if (v2)
  {
    if (v2 != 1) {
      return 0;
    }
    int v3 = a1[4];
    if (!v3) {
      return 0;
    }
  }
  else
  {
    int v3 = a1[5];
    if (!v3) {
      return 0;
    }
  }
  if (a2) {
    *a2 = v3;
  }
  return 1;
}

void *sub_19E053394@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (a1 && !*(void *)(a1 + 2080))
  {
    sub_19E0538DC((uint64_t)v14);
    uint64_t v19 = 12648430;
    int v20 = 0;
    uint64_t v21 = *(void *)(a1 + 2060);
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 0;
    int v26 = 0;
    int v22 = *(_DWORD *)(a1 + 2088);
    HIDWORD(v23) = 2;
    std::ostream::write();
    if (*(unsigned char *)(a1 + 2064)) {
      sub_19E056AC4(a1, a1, v15);
    }
    else {
      sub_19E056D74(a1, a1, v15);
    }
    unsigned int v5 = (char *)v15 + *(void *)(v15[0] - 24);
    if ((v5[32] & 5) != 0)
    {
      int v6 = -1;
    }
    else
    {
      (*(void (**)(void *__return_ptr))(**((void **)v5 + 5) + 32))(v30);
      int v6 = v31;
    }
    int v18 = v6;
    sub_19E057124(v15, (uint64_t)&v18, 4, 4);
    if (*(unsigned char *)(a1 + 2064)) {
      sub_19E05751C((_DWORD *)a1, v15, 0, 1, &v18);
    }
    else {
      sub_19E0577E4((_DWORD *)a1, v15, 0, 1, &v18);
    }
    sub_19E057124(v15, (uint64_t)&v18, 4, 8);
    MEMORY[0x19F3BA4C0](v27, v15);
    uint64_t v7 = (char *)v15 + *(void *)(v15[0] - 24);
    if ((v7[32] & 5) == 0)
    {
      (*(void (**)(void *__return_ptr))(**((void **)v7 + 5) + 32))(v30);
      if (v31 == -1) {
        std::ios_base::clear((std::ios_base *)((char *)v15 + *(void *)(v15[0] - 24)), *(_DWORD *)((char *)&v15[4] + *(void *)(v15[0] - 24)) | 4);
      }
    }
    MEMORY[0x19F3BA4D0](v27);
    *(_DWORD *)(a1 + 206sub_19E03D880(&a9, 0) = 0;
    if (*(_DWORD *)(a1 + 2064)) {
      size_t v8 = 2060;
    }
    else {
      size_t v8 = 2052;
    }
    bzero((void *)a1, v8);
    std::stringbuf::str();
    if (a2[23] >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(char **)a2;
    }
    uint64_t v10 = sub_19E05069C(v9, 0);
    uint64_t v11 = v10;
    if (*(unsigned char *)(a1 + 2064))
    {
      int v12 = v29;
      v29[0] = &unk_1EF09CB88;
      v29[1] = sub_19E05044C;
      v29[3] = v29;
      sub_19E050980(v10, 0, 0, a1, (uint64_t)v29, -1);
    }
    else
    {
      int v12 = v28;
      v28[0] = &unk_1EF09CB88;
      v28[1] = sub_19E050254;
      v28[3] = v28;
      sub_19E050980(v10, 0, 0, a1, (uint64_t)v28, -1);
    }
    sub_19E057CB0(v12);
    sub_19E050760(v11);
    v14[0] = *MEMORY[0x1E4FBA408];
    uint64_t v13 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    *(void *)((char *)v14 + *(void *)(v14[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
    v15[0] = v13;
    v15[1] = MEMORY[0x1E4FBA470] + 16;
    if (v16 < 0) {
      operator delete((void *)v15[9]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    return (void *)MEMORY[0x19F3BA690](&v17);
  }
  else
  {
    return sub_19E0413C8(a2, "");
  }
}

void sub_19E053878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
}

uint64_t sub_19E0538DC(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  unsigned int v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  size_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x1E4FBA488] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 12sub_19E03D880(&a9, 0) = 24;
  return a1;
}

void sub_19E053B8C(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x19F3BA690](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E053BB4(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA408];
  uint64_t v3 = *MEMORY[0x1E4FBA408];
  *(void *)a1 = *MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x19F3BA690](a1 + 128);
  return a1;
}

void sub_19E053CEC(uint64_t a1)
{
  for (uint64_t i = 0; i != 256; ++i)
  {
    uint64_t v3 = a1 + 8 * i;
    uint64_t v6 = *(void *)(v3 + 12);
    unsigned int v5 = (void *)(v3 + 12);
    uint64_t v4 = v6;
    uint64_t v7 = v6 & 3;
    if (v7 == 2)
    {
      size_t v8 = (void *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
      do
      {
        uint64_t v9 = (void *)*v8;
        free(v8);
        size_t v8 = v9;
      }
      while (v9);
    }
    else if (v7 == 1)
    {
      sub_19E053CEC(v4 & 0xFFFFFFFFFFFFFFFCLL);
      free((void *)(*v5 & 0xFFFFFFFFFFFFFFFCLL));
    }
  }
}

void sub_19E053D6C(uint64_t a1)
{
  for (uint64_t i = 0; i != 256; ++i)
  {
    uint64_t v3 = a1 + 8 * i;
    uint64_t v6 = *(void *)(v3 + 4);
    unsigned int v5 = (void *)(v3 + 4);
    uint64_t v4 = v6;
    uint64_t v7 = v6 & 3;
    if (v7 == 2)
    {
      size_t v8 = (void *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
      do
      {
        uint64_t v9 = (void *)*v8;
        free(v8);
        size_t v8 = v9;
      }
      while (v9);
    }
    else if (v7 == 1)
    {
      sub_19E053D6C(v4 & 0xFFFFFFFFFFFFFFFCLL);
      free((void *)(*v5 & 0xFFFFFFFFFFFFFFFCLL));
    }
  }
}

uint64_t sub_19E053DEC(uint64_t a1, void *a2, uint64_t a3, int a4, unsigned int a5, uint64_t a6, int *a7)
{
  uint64_t v12 = a2;
  uint64_t v13 = a1;
  int v14 = (uint64_t *)*a2;
  uint64_t v15 = malloc_type_calloc(8uLL, (*(_DWORD *)(a1 + 2088) + 1), 0x5241DECuLL);
  char v16 = (const void *)(a3 + a5);
  if (v14)
  {
    unsigned int v36 = v12;
    uint64_t v37 = v13;
    uint64_t v38 = a7;
    uint64_t v17 = 0;
    char v18 = 1;
LABEL_3:
    uint64_t v19 = a6;
    uint64_t v20 = 0;
    uint64_t v21 = v17;
    int v22 = &v15[v17];
    do
    {
      size_t v23 = *((unsigned __int16 *)v14 + 6);
      if (v23 + a5 == a4 && !memcmp(v16, (char *)v14 + 14, v23))
      {
        char v18 = 0;
        a6 = v19;
        *((_DWORD *)v14 + 2) = v19;
        uint64_t v17 = v21 + v20 + 1;
        v15[v21 + v20] = v14;
        int v14 = (uint64_t *)*v14;
        if (v14) {
          goto LABEL_3;
        }
        uint64_t v24 = (v21 + v20 + 1);
        int v25 = 1;
        goto LABEL_15;
      }
      v22[v20] = v14;
      int v14 = (uint64_t *)*v14;
      ++v20;
    }
    while (v14);
    uint64_t v26 = v21 + v20;
    if (v18)
    {
      uint64_t v13 = v37;
      a7 = v38;
      LODWORD(a6) = v19;
      uint64_t v12 = v36;
      goto LABEL_13;
    }
    int v25 = 1;
    uint64_t v24 = v26;
LABEL_15:
    uint64_t v13 = v37;
    a7 = v38;
    uint64_t v12 = v36;
  }
  else
  {
    LODWORD(v26) = 0;
LABEL_13:
    size_t v27 = a4 - a5;
    int v28 = (char *)malloc_type_calloc(1uLL, v27 + 15, 0x16B4CD09uLL);
    memcpy(v28 + 14, v16, v27);
    v28[v27 + 14] = 0;
    *((_WORD *)v28 + 6) = v27;
    *((_DWORD *)v28 + 2) = a6;
    uint64_t v24 = (v26 + 1);
    int v25 = 2;
    *(void *)int v28 = 0;
    v15[v26] = v28;
  }
  qsort(v15, (int)v24, 8uLL, (int (__cdecl *)(const void *, const void *))sub_19E054158);
  unsigned int v29 = (void *)*v15;
  uint64_t v30 = (void *)*v15;
  if ((int)v24 >= 2)
  {
    uint64_t v31 = v15 + 1;
    uint64_t v32 = v24 - 1;
    unint64_t v33 = (void *)*v15;
    do
    {
      unsigned int v34 = (void *)*v31++;
      uint64_t v30 = v34;
      *unint64_t v33 = v34;
      unint64_t v33 = v34;
      --v32;
    }
    while (v32);
  }
  void *v30 = 0;
  void *v12 = v29;
  free(v15);
  *a7 = v25;
  if (v24 > *(_DWORD *)(v13 + 2088)) {
    sub_19E058C8C();
  }
  return v24;
}

_DWORD *sub_19E053FF4(uint64_t a1, unsigned __int16 *a2, int *a3)
{
  uint64_t v6 = malloc_type_calloc(1uLL, 0x804uLL, 0x10000406A7154B6uLL);
  if (a2)
  {
    do
    {
      int v7 = a2[6];
      uint64_t v8 = *((unsigned int *)a2 + 2);
      if (a2[6])
      {
        uint64_t v9 = *(void *)&v6[2 * *((unsigned __int8 *)a2 + 14) + 1];
        if (v9)
        {
          unint64_t v19 = v9 & 0xFFFFFFFFFFFFFFFCLL;
          unsigned int v10 = sub_19E053DEC(a1, &v19, (uint64_t)(a2 + 7), v7, 1u, v8, a3);
          uint64_t v11 = v19;
          if (v10 >= *(_DWORD *)(a1 + 2088))
          {
            uint64_t v11 = sub_19E053FF4(a1, v19, a3);
            uint64_t v12 = 1;
          }
          else
          {
            uint64_t v12 = 2;
          }
          uint64_t v15 = v12 | v11;
          uint64_t v16 = *((unsigned __int8 *)a2 + 14);
        }
        else
        {
          size_t v13 = (v7 - 1);
          unint64_t v14 = (unint64_t)malloc_type_calloc(1uLL, v13 + 15, 0x16B4CD09uLL);
          memcpy((void *)(v14 + 14), (char *)a2 + 15, v13);
          *(unsigned char *)(v14 + 14 + v13) = 0;
          *(_WORD *)(v14 + 12) = v13;
          *(_DWORD *)(v14 + 8) = v8;
          *(void *)unint64_t v14 = 0;
          uint64_t v15 = v14 | 2;
          uint64_t v16 = *((unsigned __int8 *)a2 + 14);
        }
        *(void *)&v6[2 * v16 + 1] = v15;
      }
      else
      {
        _DWORD *v6 = v8;
      }
      uint64_t v17 = *(unsigned __int16 **)a2;
      free(a2);
      a2 = v17;
    }
    while (v17);
  }
  return v6;
}

uint64_t sub_19E054158(void *a1, void *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  uint64_t v4 = (const void *)(*a1 + 14);
  unsigned int v5 = (const void *)(*a2 + 14);
  unsigned int v6 = *(unsigned __int16 *)(v2 + 12);
  unsigned int v7 = *(unsigned __int16 *)(v3 + 12);
  unsigned int v8 = v6 - v7;
  if ((int)v6 >= (int)v7) {
    size_t v9 = v7;
  }
  else {
    size_t v9 = v6;
  }
  LODWORD(result) = memcmp(v4, v5, v9);
  if (result) {
    return result;
  }
  else {
    return v8;
  }
}

uint64_t sub_19E0541A0(uint64_t a1, uint64_t **a2, uint64_t a3, int a4, unsigned int a5, int a6, float *a7, int *a8, float a9, uint64_t a10, uint64_t a11)
{
  uint64_t v17 = *a2;
  char v18 = (uint64_t *)malloc_type_calloc(8uLL, (*(_DWORD *)(a1 + 2088) + 1), 0xA627795FuLL);
  unint64_t v19 = (const void *)(a3 + a5);
  if (v17)
  {
    uint64_t v20 = 0;
    int v21 = 0;
    float v22 = 0.0;
    do
    {
      uint64_t v23 = v20;
      size_t v24 = *((unsigned __int16 *)v17 + 10);
      if (v24 + a5 == a4 && !memcmp(v19, (char *)v17 + 22, v24))
      {
        *((_DWORD *)v17 + 4) = a6;
        float v25 = *((float *)v17 + 3);
        if (*(void *)(a11 + 24)) {
          sub_19E0545F8(a11, a10, v25, a9);
        }
        else {
          float v26 = v25 + a9;
        }
        *((float *)v17 + 3) = v26;
        int v21 = 1;
      }
      if (*((float *)v17 + 2) > v22) {
        float v22 = *((float *)v17 + 2);
      }
      ++v20;
      v18[v23] = (uint64_t)v17;
      uint64_t v17 = (uint64_t *)*v17;
    }
    while (v17);
    if (v21)
    {
      int v27 = 1;
      uint64_t v28 = v23 + 1;
      uint64_t v29 = a1;
      goto LABEL_18;
    }
  }
  else
  {
    LODWORD(v2sub_19E03D880(&a9, 0) = 0;
    float v22 = 0.0;
  }
  uint64_t v29 = a1;
  if (v22 < a9) {
    float v22 = a9;
  }
  size_t v30 = a4 - a5;
  uint64_t v31 = (char *)malloc_type_calloc(1uLL, v30 + 23, 0xD69735D9uLL);
  memcpy(v31 + 22, v19, v30);
  v31[v30 + 22] = 0;
  *((_WORD *)v31 + 1sub_19E03D880(&a9, 0) = v30;
  *((_DWORD *)v31 + 4) = a6;
  *((float *)v31 + 2) = v22;
  *((float *)v31 + 3) = a9;
  uint64_t v28 = (v20 + 1);
  int v27 = 2;
  *(void *)uint64_t v31 = 0;
  v18[v20] = (uint64_t)v31;
LABEL_18:
  qsort(v18, (int)v28, 8uLL, (int (__cdecl *)(const void *, const void *))sub_19E054658);
  uint64_t v32 = (void *)*v18;
  *a7 = v22;
  unint64_t v33 = v32;
  if ((int)v28 >= 2)
  {
    uint64_t v34 = (v28 - 1);
    uint64_t v35 = v18 + 1;
    unsigned int v36 = v32;
    do
    {
      uint64_t v37 = *v35++;
      unint64_t v33 = (void *)v37;
      *unsigned int v36 = v37;
      *(float *)(v37 + 8) = *a7;
      unsigned int v36 = (void *)v37;
      --v34;
    }
    while (v34);
  }
  *unint64_t v33 = 0;
  *a2 = v32;
  free(v18);
  *a8 = v27;
  if (v28 > *(_DWORD *)(v29 + 2088)) {
    sub_19E058CB8();
  }
  return v28;
}

float *sub_19E0543CC(uint64_t a1, unsigned __int16 *a2, float *a3, int *a4)
{
  v25[4] = *MEMORY[0x1E4F143B8];
  unsigned int v8 = (float *)malloc_type_calloc(1uLL, 0x80CuLL, 0x10000408B9410F9uLL);
  *a3 = 0.0;
  if (a2)
  {
    do
    {
      float v22 = 0.0;
      int v9 = a2[10];
      int v10 = *((_DWORD *)a2 + 4);
      float v11 = *((float *)a2 + 3);
      v24[3] = 0;
      if (v9)
      {
        uint64_t v12 = *(void *)&v8[2 * *((unsigned __int8 *)a2 + 22) + 3];
        if (v12)
        {
          uint64_t v23 = (uint64_t *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
          v25[3] = 0;
          unsigned int v13 = sub_19E0541A0(a1, &v23, (uint64_t)(a2 + 11), v9, 1u, v10, &v22, a4, v11, 0, (uint64_t)v25);
          sub_19E057B40(v25);
          uint64_t v14 = (uint64_t)v23;
          if (v13 >= *(_DWORD *)(a1 + 2088))
          {
            uint64_t v14 = sub_19E0543CC(a1, v23, &v22, a4);
            uint64_t v15 = 1;
          }
          else
          {
            uint64_t v15 = 2;
          }
          *(void *)&v8[2 * *((unsigned __int8 *)a2 + 22) + 3] = v15 | v14;
          float v11 = v22;
        }
        else
        {
          size_t v16 = (v9 - 1);
          unint64_t v17 = (unint64_t)malloc_type_calloc(1uLL, v16 + 23, 0xD69735D9uLL);
          memcpy((void *)(v17 + 22), (char *)a2 + 23, v16);
          *(unsigned char *)(v17 + 22 + v16) = 0;
          *(_WORD *)(v17 + 2sub_19E03D880(&a9, 0) = v16;
          *(_DWORD *)(v17 + 16) = v10;
          *(float *)(v17 + 8) = v11;
          *(float *)(v17 + 12) = v11;
          *(void *)unint64_t v17 = 0;
          *(void *)&v8[2 * *((unsigned __int8 *)a2 + 22) + 3] = v17 | 2;
        }
      }
      else
      {
        v8[1] = v11;
        *((_DWORD *)v8 + 2) = v10;
      }
      sub_19E057B40(v24);
      float v18 = *a3;
      if (v11 > *a3) {
        float v18 = v11;
      }
      *a3 = v18;
      unint64_t v19 = *(unsigned __int16 **)a2;
      free(a2);
      a2 = v19;
    }
    while (v19);
    float v20 = *a3;
  }
  else
  {
    float v20 = 0.0;
  }
  *unsigned int v8 = v20;
  return v8;
}

void sub_19E0545D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_19E057B40((uint64_t *)va1);
  sub_19E057B40((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0545F8(uint64_t a1, uint64_t a2, float a3, float a4)
{
  uint64_t v8 = a2;
  float v6 = a4;
  float v7 = a3;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, float *, float *))(*(void *)v4 + 48))(v4, &v8, &v7, &v6);
}

uint64_t sub_19E054658(uint64_t a1, uint64_t a2)
{
  float v2 = *(float *)(*(void *)a1 + 12);
  float v3 = *(float *)(*(void *)a2 + 12);
  if (v2 == v3)
  {
    unsigned int v4 = *(_DWORD *)(*(void *)a1 + 16);
    unsigned int v5 = *(_DWORD *)(*(void *)a2 + 16);
    BOOL v6 = v4 == v5;
    if (v4 > v5) {
      unsigned int v7 = -1;
    }
    else {
      unsigned int v7 = 1;
    }
    if (v6) {
      return 0;
    }
    else {
      return v7;
    }
  }
  else if ((float)(v2 - v3) <= 0.0)
  {
    return 1;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

BOOL sub_19E0546A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  char v38 = 0;
  if (a5 < a4)
  {
    int v15 = *(_DWORD *)(a2 + 4 * *(unsigned __int8 *)(a3 + a5));
    uint64_t v16 = v15 & 3;
    switch(v16)
    {
      case 3:
        uint64_t v31 = *(void *)(a1 + 2080);
        sub_19E0558FC((uint64_t)v43, a8);
        float v18 = v43;
        uint64_t v19 = sub_19E0552F8(a1, (int8x8_t *)((v15 & 0xFFFFFFFC) + v31), a3, a4, a5 + 1, a6, a7, (uint64_t)v43);
        goto LABEL_26;
      case 2:
        uint64_t v32 = *(void *)(a1 + 2080);
        sub_19E0558FC((uint64_t)v42, a8);
        float v18 = v42;
        uint64_t v19 = sub_19E055734((unsigned int *)((v15 & 0xFFFFFFFC) + v32), a3, a4, a5 + 1, a6, a7, (uint64_t)v42);
        goto LABEL_26;
      case 1:
        uint64_t v17 = *(void *)(a1 + 2080);
        sub_19E0558FC((uint64_t)v44, a8);
        float v18 = v44;
        uint64_t v19 = sub_19E0546A0(a1, (v15 & 0xFFFFFFFC) + v17, a3, a4, a5 + 1, a6, a7, v44);
LABEL_26:
        BOOL v21 = v19;
        sub_19E055B34(v18);
        return v21;
    }
    return 0;
  }
  int v20 = *(_DWORD *)(a2 + 1024);
  if (!v20)
  {
    if (a6) {
      return 0;
    }
    goto LABEL_12;
  }
  v35[0] = *(_DWORD *)(a2 + 1032);
  v35[1] = v20;
  uint64_t v36 = a3;
  uint64_t v37 = a4;
  sub_19E055890(a8, a7, (uint64_t)v35, 1, (uint64_t)&v38);
  BOOL v21 = v38 != 0;
  if (!v38 && (a6 & 1) == 0)
  {
LABEL_12:
    uint64_t v22 = 0;
    uint64_t v23 = (a4 + 1);
    while (1)
    {
      int v24 = *(_DWORD *)(a2 + 4 * v22);
      *(unsigned char *)(a3 + a5) = v22;
      uint64_t v25 = v24 & 3;
      switch(v25)
      {
        case 3:
          uint64_t v28 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v40, a8);
          char v38 = sub_19E0552F8(a1, (int8x8_t *)((v24 & 0xFFFFFFFC) + v28), a3, v23, a5 + 1, 0, a7, (uint64_t)v40);
          int v27 = v40;
          break;
        case 2:
          uint64_t v29 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v39, a8);
          char v38 = sub_19E055734((unsigned int *)((v24 & 0xFFFFFFFC) + v29), a3, v23, a5 + 1, 0, a7, (uint64_t)v39);
          int v27 = v39;
          break;
        case 1:
          uint64_t v26 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v41, a8);
          char v38 = sub_19E0546A0(a1, (v24 & 0xFFFFFFFC) + v26, a3, v23, a5 + 1, 0, a7, v41);
          int v27 = v41;
          break;
        default:
          goto LABEL_20;
      }
      sub_19E055B34(v27);
LABEL_20:
      BOOL v21 = v38 != 0;
      if (!v38 && v22++ != 255) {
        continue;
      }
      return v21;
    }
  }
  return v21;
}

void sub_19E0549A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
}

uint64_t sub_19E0549FC(uint64_t result, _DWORD *a2, int a3, unsigned char *a4)
{
  if (result)
  {
    if (*(_DWORD *)result == 1)
    {
LABEL_5:
      *(_DWORD *)(result + 4) = a2[1];
      *(_DWORD *)(result + 8) = *a2;
LABEL_8:
      *a4 = 1;
      return result;
    }
    if (!*(_DWORD *)result)
    {
      if (!a3) {
        return result;
      }
      goto LABEL_5;
    }
    char v5 = 0;
    if (*(void *)(result + 48))
    {
      uint64_t result = sub_19E055994(result + 24, *(void *)(result + 16), (uint64_t)a2, (uint64_t)&v5);
      if (v5) {
        goto LABEL_8;
      }
    }
  }
  return result;
}

BOOL sub_19E054A8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  char v38 = 0;
  if (a5 < a4)
  {
    int v15 = *(_DWORD *)(a2 + 4 * *(unsigned __int8 *)(a3 + a5));
    uint64_t v16 = v15 & 3;
    switch(v16)
    {
      case 3:
        uint64_t v31 = *(void *)(a1 + 2080);
        sub_19E0558FC((uint64_t)v43, a8);
        float v18 = v43;
        uint64_t v19 = sub_19E055BB8(a1, (int8x8_t *)((v15 & 0xFFFFFFFC) + v31), a3, a4, a5 + 1, a6, a7, (uint64_t)v43);
        goto LABEL_26;
      case 2:
        uint64_t v32 = *(void *)(a1 + 2080);
        sub_19E0558FC((uint64_t)v42, a8);
        float v18 = v42;
        uint64_t v19 = sub_19E055FF4(a1, (unsigned int *)((v15 & 0xFFFFFFFC) + v32), a3, a4, a5 + 1, a6, a7, (uint64_t)v42);
        goto LABEL_26;
      case 1:
        uint64_t v17 = *(void *)(a1 + 2080);
        sub_19E0558FC((uint64_t)v44, a8);
        float v18 = v44;
        uint64_t v19 = sub_19E054A8C(a1, (v15 & 0xFFFFFFFC) + v17, a3, a4, a5 + 1, a6, a7, v44);
LABEL_26:
        BOOL v21 = v19;
        sub_19E055B34(v18);
        return v21;
    }
    return 0;
  }
  int v20 = *(_DWORD *)(a2 + 1024);
  if (!v20)
  {
    if (a6) {
      return 0;
    }
    goto LABEL_12;
  }
  v35[0] = 0;
  v35[1] = v20;
  uint64_t v36 = a3;
  uint64_t v37 = a4;
  sub_19E055890(a8, a7, (uint64_t)v35, 1, (uint64_t)&v38);
  BOOL v21 = v38 != 0;
  if (!v38 && (a6 & 1) == 0)
  {
LABEL_12:
    uint64_t v22 = 0;
    uint64_t v23 = (a4 + 1);
    while (1)
    {
      int v24 = *(_DWORD *)(a2 + 4 * v22);
      *(unsigned char *)(a3 + a5) = v22;
      uint64_t v25 = v24 & 3;
      switch(v25)
      {
        case 3:
          uint64_t v28 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v40, a8);
          char v38 = sub_19E055BB8(a1, (int8x8_t *)((v24 & 0xFFFFFFFC) + v28), a3, v23, a5 + 1, 0, a7, (uint64_t)v40);
          int v27 = v40;
          break;
        case 2:
          uint64_t v29 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v39, a8);
          char v38 = sub_19E055FF4(a1, (unsigned int *)((v24 & 0xFFFFFFFC) + v29), a3, v23, a5 + 1, 0, a7, (uint64_t)v39);
          int v27 = v39;
          break;
        case 1:
          uint64_t v26 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v41, a8);
          char v38 = sub_19E054A8C(a1, (v24 & 0xFFFFFFFC) + v26, a3, v23, a5 + 1, 0, a7, v41);
          int v27 = v41;
          break;
        default:
          goto LABEL_20;
      }
      sub_19E055B34(v27);
LABEL_20:
      BOOL v21 = v38 != 0;
      if (!v38 && v22++ != 255) {
        continue;
      }
      return v21;
    }
  }
  return v21;
}

void sub_19E054D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
}

BOOL sub_19E054DE8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  char v34 = 0;
  if (a4 < a3)
  {
    uint64_t v14 = *(void *)(a1 + 8 * *(unsigned __int8 *)(a2 + a4) + 12);
    if ((v14 & 3) == 2)
    {
      sub_19E0558FC((uint64_t)v37, a7);
      int v15 = v37;
      uint64_t v16 = sub_19E056344(v14 & 0xFFFFFFFFFFFFFFFCLL, a2, a3, a4 + 1, a5, a6, (uint64_t)v37);
      goto LABEL_22;
    }
    if ((v14 & 3) == 1)
    {
      sub_19E0558FC((uint64_t)v38, a7);
      int v15 = v38;
      uint64_t v16 = sub_19E054DE8(v14 & 0xFFFFFFFFFFFFFFFCLL, a2, a3, a4 + 1, a5, a6, v38);
LABEL_22:
      BOOL v18 = v16;
      sub_19E055B34(v15);
      return v18;
    }
    return 0;
  }
  int v17 = *(_DWORD *)(a1 + 8);
  if (!v17)
  {
    if (a5) {
      return 0;
    }
    goto LABEL_11;
  }
  v31[0] = *(_DWORD *)(a1 + 4);
  v31[1] = v17;
  uint64_t v32 = a2;
  uint64_t v33 = a4;
  sub_19E055890(a7, a6, (uint64_t)v31, 1, (uint64_t)&v34);
  BOOL v18 = v34 != 0;
  if (!v34 && (a5 & 1) == 0)
  {
LABEL_11:
    uint64_t v19 = 0;
    uint64_t v20 = (a3 + 1);
    uint64_t v21 = a4 + 1;
    uint64_t v22 = a1 + 12;
    uint64_t v23 = a4;
    while (1)
    {
      uint64_t v24 = *(void *)(v22 + 8 * v19);
      *(unsigned char *)(a2 + v23) = v19;
      if ((v24 & 3) == 2)
      {
        sub_19E0558FC((uint64_t)v35, a7);
        unint64_t v28 = v24 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v26 = v35;
        char v27 = sub_19E056344(v28, a2, v20, v21, 0, a6, (uint64_t)v35);
      }
      else
      {
        if ((v24 & 3) != 1) {
          goto LABEL_17;
        }
        sub_19E0558FC((uint64_t)v36, a7);
        unint64_t v25 = v24 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v26 = v36;
        char v27 = sub_19E054DE8(v25, a2, v20, v21, 0, a6, v36);
      }
      char v34 = v27;
      sub_19E055B34(v26);
LABEL_17:
      BOOL v18 = v34 != 0;
      if (!v34 && v19++ != 255) {
        continue;
      }
      return v18;
    }
  }
  return v18;
}

void sub_19E055034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_19E055B34(va);
  _Unwind_Resume(a1);
}

BOOL sub_19E055074(int *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  char v34 = 0;
  if (a4 < a3)
  {
    uint64_t v14 = *(void *)&a1[2 * *(unsigned __int8 *)(a2 + a4) + 1];
    if ((v14 & 3) == 2)
    {
      sub_19E0558FC((uint64_t)v37, a7);
      int v15 = v37;
      uint64_t v16 = sub_19E05646C(v14 & 0xFFFFFFFFFFFFFFFCLL, a2, a3, a4 + 1, a5, a6, (uint64_t)v37);
      goto LABEL_22;
    }
    if ((v14 & 3) == 1)
    {
      sub_19E0558FC((uint64_t)v38, a7);
      int v15 = v38;
      uint64_t v16 = sub_19E055074(v14 & 0xFFFFFFFFFFFFFFFCLL, a2, a3, a4 + 1, a5, a6, v38);
LABEL_22:
      BOOL v18 = v16;
      sub_19E055B34(v15);
      return v18;
    }
    return 0;
  }
  int v17 = *a1;
  if (!*a1)
  {
    if (a5) {
      return 0;
    }
    goto LABEL_11;
  }
  v31[0] = 0;
  v31[1] = v17;
  uint64_t v32 = a2;
  uint64_t v33 = a4;
  sub_19E055890(a7, a6, (uint64_t)v31, 1, (uint64_t)&v34);
  BOOL v18 = v34 != 0;
  if (!v34 && (a5 & 1) == 0)
  {
LABEL_11:
    uint64_t v19 = 0;
    uint64_t v20 = (a3 + 1);
    uint64_t v21 = a4 + 1;
    uint64_t v22 = a1 + 1;
    uint64_t v23 = a4;
    while (1)
    {
      uint64_t v24 = *(void *)&v22[2 * v19];
      *(unsigned char *)(a2 + v23) = v19;
      if ((v24 & 3) == 2)
      {
        sub_19E0558FC((uint64_t)v35, a7);
        unint64_t v28 = v24 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v26 = v35;
        char v27 = sub_19E05646C(v28, a2, v20, v21, 0, a6, (uint64_t)v35);
      }
      else
      {
        if ((v24 & 3) != 1) {
          goto LABEL_17;
        }
        sub_19E0558FC((uint64_t)v36, a7);
        unint64_t v25 = v24 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v26 = v36;
        char v27 = sub_19E055074(v25, a2, v20, v21, 0, a6, v36);
      }
      char v34 = v27;
      sub_19E055B34(v26);
LABEL_17:
      BOOL v18 = v34 != 0;
      if (!v34 && v19++ != 255) {
        continue;
      }
      return v18;
    }
  }
  return v18;
}

void sub_19E0552B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_19E055B34(va);
  _Unwind_Resume(a1);
}

BOOL sub_19E0552F8(uint64_t a1, int8x8_t *a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  char v55 = 0;
  if (a5 < a4)
  {
    unint64_t v14 = *(unsigned __int8 *)(a3 + a5);
    uint64_t v15 = v14 >> 6;
    int8x8_t v16 = a2[v14 >> 6];
    uint64_t v17 = 1 << v14;
    if (((1 << v14) & *(void *)&v16) != 0)
    {
      if (v14 >= 0x40)
      {
        int v18 = 0;
        if (v15 <= 1) {
          uint64_t v15 = 1;
        }
        else {
          uint64_t v15 = v15;
        }
        uint64_t v36 = a2;
        do
        {
          int8x8_t v37 = *v36++;
          uint8x8_t v38 = (uint8x8_t)vcnt_s8(v37);
          v38.i16[0] = vaddlv_u8(v38);
          v18 += v38.i32[0];
          --v15;
        }
        while (v15);
      }
      else
      {
        int v18 = 0;
      }
      uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)((v17 - 1) & *(void *)&v16));
      v39.i16[0] = vaddlv_u8(v39);
      __int32 v40 = a2[5].i32[v18 + v39.i32[0] + 1];
      int v41 = v40 & 3;
      switch(v41)
      {
        case 1:
          uint64_t v46 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v61, a8);
          uint64_t v47 = (v40 & 0xFFFFFFFC) + v46;
          int v44 = v61;
          uint64_t v45 = sub_19E0546A0(a1, v47, a3, a4, a5 + 1, a6, a7, v61);
          goto LABEL_41;
        case 2:
          uint64_t v48 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v59, a8);
          int v44 = v59;
          uint64_t v45 = sub_19E055734((unsigned int *)((v40 & 0xFFFFFFFC) + v48), a3, a4, a5 + 1, a6, a7, (uint64_t)v59);
          goto LABEL_41;
        case 3:
          uint64_t v42 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v60, a8);
          uint64_t v43 = (v40 & 0xFFFFFFFC) + v42;
          int v44 = v60;
          uint64_t v45 = sub_19E0552F8(a1, v43, a3, a4, a5 + 1, a6, a7, v60);
LABEL_41:
          BOOL v20 = v45;
          sub_19E055B34(v44);
          return v20;
      }
    }
    return 0;
  }
  __int32 v19 = a2[5].i32[0];
  if (!v19)
  {
    if (a6) {
      return 0;
    }
    goto LABEL_10;
  }
  v52[0] = a2[4].i32[1];
  v52[1] = v19;
  uint64_t v53 = a3;
  uint64_t v54 = a4;
  sub_19E055890(a8, a7, (uint64_t)v52, 1, (uint64_t)&v55);
  BOOL v20 = v55 != 0;
  if (!v55 && (a6 & 1) == 0)
  {
LABEL_10:
    unint64_t v21 = 0;
    uint64_t v22 = (a4 + 1);
    while (1)
    {
      if (v21 >> 6 <= 1) {
        uint64_t v23 = 1;
      }
      else {
        uint64_t v23 = v21 >> 6;
      }
      int8x8_t v24 = a2[v21 >> 6];
      if ((*(void *)&v24 & (1 << v21)) == 0) {
        goto LABEL_26;
      }
      if (v21 >= 0x40)
      {
        int v25 = 0;
        uint64_t v26 = a2;
        do
        {
          int8x8_t v27 = *v26++;
          uint8x8_t v28 = (uint8x8_t)vcnt_s8(v27);
          v28.i16[0] = vaddlv_u8(v28);
          v25 += v28.i32[0];
          --v23;
        }
        while (v23);
      }
      else
      {
        int v25 = 0;
      }
      uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v24 & ((1 << v21) - 1)));
      v29.i16[0] = vaddlv_u8(v29);
      __int32 v30 = a2[5].i32[v25 + v29.i32[0] + 1];
      *(unsigned char *)(a3 + a5) = v21;
      int v31 = v30 & 3;
      switch(v31)
      {
        case 1:
          uint64_t v34 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v58, a8);
          char v55 = sub_19E0546A0(a1, v34 + (v30 & 0xFFFFFFFC), a3, v22, a5 + 1, 0, a7, v58);
          uint64_t v33 = v58;
          break;
        case 2:
          uint64_t v35 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v56, a8);
          char v55 = sub_19E055734((unsigned int *)(v35 + (v30 & 0xFFFFFFFC)), a3, v22, a5 + 1, 0, a7, (uint64_t)v56);
          uint64_t v33 = v56;
          break;
        case 3:
          uint64_t v32 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v57, a8);
          char v55 = sub_19E0552F8(a1, v32 + (v30 & 0xFFFFFFFC), a3, v22, a5 + 1, 0, a7, v57);
          uint64_t v33 = v57;
          break;
        default:
          goto LABEL_26;
      }
      sub_19E055B34(v33);
LABEL_26:
      BOOL v20 = v55 != 0;
      if (!v55 && ++v21 != 256) {
        continue;
      }
      return v20;
    }
  }
  return v20;
}

void sub_19E0556DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
}

uint64_t sub_19E055734(unsigned int *a1, uint64_t a2, unsigned int a3, unsigned int a4, char a5, uint64_t a6, uint64_t a7)
{
  char v33 = 0;
  unsigned int v7 = *a1;
  if (*a1)
  {
    unsigned int v8 = a4;
    unsigned int v10 = 0;
    uint64_t v11 = (const void *)(a2 + a4);
    int v12 = a3 - a4;
    uint64_t v24 = a3;
    __dst = (void *)(a2 + a3);
    do
    {
      unsigned int v13 = (char *)a1 + v10;
      uint64_t v14 = *((unsigned __int16 *)v13 + 8);
      if (v12 <= (int)v14)
      {
        uint64_t v15 = v13 + 8;
        int8x8_t v16 = v13 + 18;
        if (!memcmp(v13 + 18, v11, v12))
        {
          char v17 = a5;
          if (v12 == v14) {
            char v17 = 0;
          }
          if ((v17 & 1) == 0)
          {
            uint64_t v18 = v14 + v8;
            size_t v19 = v18 - a3;
            uint64_t v20 = v24;
            if ((int)v19 >= 1)
            {
              memcpy(__dst, &v16[v14 - (int)v19], v19);
              uint64_t v20 = v18;
            }
            *(unsigned char *)(a2 + v2sub_19E03D880(&a9, 0) = 0;
            v30[0] = *(_DWORD *)v15;
            v30[1] = *((_DWORD *)v15 + 1);
            uint64_t v31 = a2;
            uint64_t v32 = v20;
            sub_19E055890(a7, a6, (uint64_t)v30, v12 == v14, (uint64_t)&v33);
            if (v33) {
              return 1;
            }
            LODWORD(v14) = *((unsigned __int16 *)v15 + 4);
            unsigned int v8 = a4;
          }
        }
      }
      v10 += v14 + 10;
    }
    while (v10 < v7);
  }
  return 0;
}

uint64_t sub_19E055890(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v10 = a2;
  uint64_t v9 = a3;
  char v8 = a4;
  uint64_t v7 = a5;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, char *, uint64_t *))(*(void *)v5 + 48))(v5, &v10, &v9, &v8, &v7);
}

uint64_t sub_19E0558FC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_19E055994(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a2;
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *))(*(void *)v4 + 48))(v4, &v8, &v7, &v6);
}

void sub_19E0559F8()
{
}

void *sub_19E055A0C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF09CBE0;
  result[1] = v3;
  return result;
}

uint64_t sub_19E055A54(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF09CBE0;
  a2[1] = v2;
  return result;
}

uint64_t sub_19E055A80(uint64_t a1, void *a2, void *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(void, void, void, void))(a1 + 8))(*a2, *a3, *a4, *a5);
}

uint64_t sub_19E055A98(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B708)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_19E055AD8()
{
  return &unk_1EF09B708;
}

BOOL sub_19E055AE4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

void *sub_19E055B34(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL sub_19E055BB8(uint64_t a1, int8x8_t *a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  char v56 = 0;
  if (a5 < a4)
  {
    unint64_t v14 = *(unsigned __int8 *)(a3 + a5);
    uint64_t v15 = v14 >> 6;
    int8x8_t v16 = a2[v14 >> 6];
    uint64_t v17 = 1 << v14;
    if (((1 << v14) & *(void *)&v16) != 0)
    {
      if (v14 >= 0x40)
      {
        int v18 = 0;
        if (v15 <= 1) {
          uint64_t v15 = 1;
        }
        else {
          uint64_t v15 = v15;
        }
        uint64_t v36 = a2;
        do
        {
          int8x8_t v37 = *v36++;
          uint8x8_t v38 = (uint8x8_t)vcnt_s8(v37);
          v38.i16[0] = vaddlv_u8(v38);
          v18 += v38.i32[0];
          --v15;
        }
        while (v15);
      }
      else
      {
        int v18 = 0;
      }
      uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)((v17 - 1) & *(void *)&v16));
      v39.i16[0] = vaddlv_u8(v39);
      __int32 v40 = a2[4].i32[v18 + v39.i32[0] + 1];
      int v41 = v40 & 3;
      switch(v41)
      {
        case 1:
          uint64_t v46 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v62, a8);
          uint64_t v47 = (v40 & 0xFFFFFFFC) + v46;
          int v44 = v62;
          uint64_t v45 = sub_19E054A8C(a1, v47, a3, a4, a5 + 1, a6, a7, v62);
          goto LABEL_41;
        case 2:
          uint64_t v48 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v60, a8);
          uint64_t v49 = (unsigned int *)((v40 & 0xFFFFFFFC) + v48);
          int v44 = v60;
          uint64_t v45 = sub_19E055FF4(a1, v49, a3, a4, a5 + 1, a6, a7, (uint64_t)v60);
          goto LABEL_41;
        case 3:
          uint64_t v42 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v61, a8);
          uint64_t v43 = (v40 & 0xFFFFFFFC) + v42;
          int v44 = v61;
          uint64_t v45 = sub_19E055BB8(a1, v43, a3, a4, a5 + 1, a6, a7, v61);
LABEL_41:
          BOOL v20 = v45;
          sub_19E055B34(v44);
          return v20;
      }
    }
    return 0;
  }
  __int32 v19 = a2[4].i32[0];
  if (!v19)
  {
    if (a6) {
      return 0;
    }
    goto LABEL_10;
  }
  v53[0] = 0;
  v53[1] = v19;
  uint64_t v54 = a3;
  uint64_t v55 = a4;
  sub_19E055890(a8, a7, (uint64_t)v53, 1, (uint64_t)&v56);
  BOOL v20 = v56 != 0;
  if (!v56 && (a6 & 1) == 0)
  {
LABEL_10:
    unint64_t v21 = 0;
    uint64_t v22 = (a4 + 1);
    while (1)
    {
      if (v21 >> 6 <= 1) {
        uint64_t v23 = 1;
      }
      else {
        uint64_t v23 = v21 >> 6;
      }
      int8x8_t v24 = a2[v21 >> 6];
      if ((*(void *)&v24 & (1 << v21)) == 0) {
        goto LABEL_26;
      }
      if (v21 >= 0x40)
      {
        int v25 = 0;
        uint64_t v26 = a2;
        do
        {
          int8x8_t v27 = *v26++;
          uint8x8_t v28 = (uint8x8_t)vcnt_s8(v27);
          v28.i16[0] = vaddlv_u8(v28);
          v25 += v28.i32[0];
          --v23;
        }
        while (v23);
      }
      else
      {
        int v25 = 0;
      }
      uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v24 & ((1 << v21) - 1)));
      v29.i16[0] = vaddlv_u8(v29);
      __int32 v30 = a2[4].i32[v25 + v29.i32[0] + 1];
      *(unsigned char *)(a3 + a5) = v21;
      int v31 = v30 & 3;
      switch(v31)
      {
        case 1:
          uint64_t v34 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v59, a8);
          char v56 = sub_19E054A8C(a1, v34 + (v30 & 0xFFFFFFFC), a3, v22, a5 + 1, 0, a7, v59);
          char v33 = v59;
          break;
        case 2:
          uint64_t v35 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v57, a8);
          char v56 = sub_19E055FF4(a1, (unsigned int *)(v35 + (v30 & 0xFFFFFFFC)), a3, v22, a5 + 1, 0, a7, (uint64_t)v57);
          char v33 = v57;
          break;
        case 3:
          uint64_t v32 = *(void *)(a1 + 2080);
          sub_19E0558FC((uint64_t)v58, a8);
          char v56 = sub_19E055BB8(a1, v32 + (v30 & 0xFFFFFFFC), a3, v22, a5 + 1, 0, a7, v58);
          char v33 = v58;
          break;
        default:
          goto LABEL_26;
      }
      sub_19E055B34(v33);
LABEL_26:
      BOOL v20 = v56 != 0;
      if (!v56 && ++v21 != 256) {
        continue;
      }
      return v20;
    }
  }
  return v20;
}

void sub_19E055F9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
}

uint64_t sub_19E055FF4(uint64_t a1, unsigned int *a2, uint64_t a3, unsigned int a4, unsigned int a5, char a6, uint64_t a7, uint64_t a8)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  char v56 = 0;
  int v9 = a4 - a5;
  unsigned int v10 = *a2;
  if ((*(unsigned char *)(a1 + 2064) & 4) != 0)
  {
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v64 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long __s1 = 0u;
    if (v10)
    {
      uint64_t v22 = 0;
      unsigned int v23 = 0;
      int8x8_t v24 = (char *)(a3 + a5);
      unsigned int v45 = a5 - a4;
      int v41 = (void *)(a3 + a4);
      __dsta = v24;
      do
      {
        int v25 = (char *)a2 + v23;
        uint64_t v26 = v25[10];
        if (v22)
        {
          uint64_t v27 = v22[6];
          if (v26 > v27) {
            memcpy((char *)&__s1 + v27, v22 + 7, v26 - v27);
          }
        }
        uint64_t v22 = v25 + 4;
        unsigned int v28 = *((unsigned __int16 *)v25 + 4);
        int v29 = v28 + v26;
        if ((int)(v28 + v26) >= v9)
        {
          if (a4 == a5 || ((int)v26 >= v9 ? (int v30 = v9) : (int v30 = v26), !memcmp(&__s1, v24, v30)))
          {
            unsigned int v31 = v9 - v26;
            if (v9 - (int)v26 < 0
              || ((int)v28 >= (int)v31 ? (size_t v32 = v31) : (size_t v32 = v28), !memcmp(v25 + 11, &v24[v26], v32)))
            {
              char v33 = a6;
              if (v9 == v29) {
                char v33 = 0;
              }
              if ((v33 & 1) == 0)
              {
                unsigned int v34 = v26 + a5;
                int v35 = v26 + a5 - a4;
                if (v35 < 1)
                {
                  unsigned int v34 = a4;
                }
                else
                {
                  memcpy(v41, (char *)&__s1 + v26 - v35, v34 - a4);
                  unsigned int v28 = *((unsigned __int16 *)v22 + 2);
                  LODWORD(v26) = v22[6];
                }
                int v36 = v45 + v28 + v26;
                if (v36 < 1)
                {
                  uint64_t v38 = a3;
                }
                else
                {
                  int v37 = v36 - (v35 & ~(v35 >> 31));
                  uint64_t v38 = a3;
                  memcpy((void *)(a3 + v34), &v22[v28 - v37 + 7], v37);
                  v34 += v37;
                }
                *(unsigned char *)(v38 + v34) = 0;
                int v39 = *(_DWORD *)v22;
                v53[0] = 0;
                v53[1] = v39;
                uint64_t v54 = v38;
                uint64_t v55 = v34;
                sub_19E055890(a8, a7, (uint64_t)v53, v9 == v29, (uint64_t)&v56);
                if (v56) {
                  return 1;
                }
                unsigned int v28 = *((unsigned __int16 *)v22 + 2);
                int8x8_t v24 = __dsta;
              }
            }
          }
        }
        v23 += v28 + 7;
      }
      while (v23 < v10);
    }
  }
  else if (v10)
  {
    unsigned int v11 = 0;
    int v12 = (const void *)(a3 + a5);
    uint64_t v46 = a4;
    char v13 = a6;
    __dst = (void *)(a3 + a4);
    do
    {
      unint64_t v14 = (char *)a2 + v11;
      uint64_t v15 = *((unsigned __int16 *)v14 + 4);
      if (v9 <= (int)v15)
      {
        int8x8_t v16 = v14 + 4;
        uint64_t v17 = v14 + 10;
        if (!memcmp(v14 + 10, v12, v9))
        {
          char v18 = v9 == v15 ? 0 : v13;
          if ((v18 & 1) == 0)
          {
            size_t v19 = v15 + a5 - a4;
            uint64_t v20 = v46;
            if ((int)v19 >= 1)
            {
              memcpy(__dst, &v17[v15 - (int)v19], v19);
              uint64_t v20 = v15 + a5;
            }
            *(unsigned char *)(a3 + v2sub_19E03D880(&a9, 0) = 0;
            int v21 = *(_DWORD *)v16;
            LODWORD(__s1) = 0;
            DWORD1(__s1) = v21;
            *((void *)&__s1 + 1) = a3;
            *(void *)&long long v58 = v20;
            sub_19E055890(a8, a7, (uint64_t)&__s1, v9 == v15, (uint64_t)&v56);
            if (v56) {
              return 1;
            }
            LODWORD(v15) = *((unsigned __int16 *)v16 + 2);
            char v13 = a6;
          }
        }
      }
      v11 += v15 + 6;
    }
    while (v11 < v10);
  }
  return 0;
}

uint64_t sub_19E056344(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, char a5, uint64_t a6, uint64_t a7)
{
  char v25 = 0;
  if (result)
  {
    uint64_t v10 = result;
    unsigned int v11 = (const void *)(a2 + a4);
    size_t v12 = (int)(a3 - a4);
    __dst = (void *)(a2 + a3);
    uint64_t v19 = a3;
    while (1)
    {
      uint64_t v14 = *(unsigned __int16 *)(v10 + 20);
      if ((int)v12 <= (int)v14 && !memcmp((const void *)(v10 + 22), v11, v12))
      {
        char v15 = v12 == v14 ? 0 : a5;
        if ((v15 & 1) == 0)
        {
          size_t v16 = v14 + a4 - a3;
          uint64_t v17 = v19;
          if ((int)v16 >= 1)
          {
            memcpy(__dst, (const void *)(v10 + 22 + v14 - (int)v16), v16);
            uint64_t v17 = v14 + a4;
          }
          *(unsigned char *)(a2 + v17) = 0;
          v22[0] = *(_DWORD *)(v10 + 12);
          v22[1] = *(_DWORD *)(v10 + 16);
          uint64_t v23 = a2;
          uint64_t v24 = v17;
          sub_19E055890(a7, a6, (uint64_t)v22, v12 == v14, (uint64_t)&v25);
          if (v25) {
            break;
          }
        }
      }
      uint64_t v10 = *(void *)v10;
      if (!v10) {
        return 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t sub_19E05646C(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, char a5, uint64_t a6, uint64_t a7)
{
  char v26 = 0;
  if (result)
  {
    uint64_t v10 = result;
    unsigned int v11 = (const void *)(a2 + a4);
    size_t v12 = (int)(a3 - a4);
    __dst = (void *)(a2 + a3);
    uint64_t v20 = a3;
    while (1)
    {
      uint64_t v14 = *(unsigned __int16 *)(v10 + 12);
      if ((int)v12 <= (int)v14 && !memcmp((const void *)(v10 + 14), v11, v12))
      {
        char v15 = v12 == v14 ? 0 : a5;
        if ((v15 & 1) == 0)
        {
          size_t v16 = v14 + a4 - a3;
          uint64_t v17 = v20;
          if ((int)v16 >= 1)
          {
            memcpy(__dst, (const void *)(v10 + 14 + v14 - (int)v16), v16);
            uint64_t v17 = v14 + a4;
          }
          *(unsigned char *)(a2 + v17) = 0;
          int v18 = *(_DWORD *)(v10 + 8);
          v23[0] = 0;
          v23[1] = v18;
          uint64_t v24 = a2;
          uint64_t v25 = v17;
          sub_19E055890(a7, a6, (uint64_t)v23, v12 == v14, (uint64_t)&v26);
          if (v26) {
            break;
          }
        }
      }
      uint64_t v10 = *(void *)v10;
      if (!v10) {
        return 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t sub_19E05658C(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  int v6 = a2;
  int v7 = a1;
  unint64_t v8 = (*(void *)a2 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(a1 + 2080);
  if (*(unsigned char *)(a1 + 2064))
  {
    if (!a4)
    {
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(v8 + 1024);
      *(_DWORD *)(a2 + 2sub_19E03D880(&a9, 0) = *(_DWORD *)(v8 + 1032);
      return 1;
    }
  }
  else if (!a4)
  {
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(v8 + 1024);
    return 1;
  }
  sub_19E056644(a1, a2, *(unsigned int *)(v8 + 4 * *a3));

  return sub_19E052898(v7, v6, a3 + 1, (a4 - 1));
}

uint64_t sub_19E056644(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)a2 != a3)
  {
    switch(a3 & 3)
    {
      case 1:
        unint64_t v3 = (a3 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(result + 2080);
        if ((*(unsigned char *)(result + 2064) & 1) == 0)
        {
          int v4 = *(_DWORD *)(v3 + 1024);
          goto LABEL_13;
        }
        *(_DWORD *)(a2 + 16) = *(_DWORD *)(v3 + 1024);
        int v8 = *(_DWORD *)(v3 + 1032);
        goto LABEL_16;
      case 2:
        int v5 = *(_DWORD *)(result + 2064);
        if ((v5 & 4) != 0)
        {
          int v4 = *(_DWORD *)((a3 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(result + 2080));
          goto LABEL_13;
        }
        int v6 = (int *)((a3 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(result + 2080));
        if ((v5 & 1) == 0)
        {
          int v4 = *v6;
          goto LABEL_13;
        }
        *(_DWORD *)(a2 + 16) = v6[1];
        int v8 = *v6;
        goto LABEL_16;
      case 3:
        int v7 = (_DWORD *)((a3 & 0xFFFFFFFFFFFFFFFCLL) + *(void *)(result + 2080));
        if (*(unsigned char *)(result + 2064))
        {
          *(_DWORD *)(a2 + 16) = v7[10];
          int v8 = v7[9];
LABEL_16:
          *(_DWORD *)(a2 + 2sub_19E03D880(&a9, 0) = v8;
        }
        else
        {
          int v4 = v7[8];
LABEL_13:
          *(_DWORD *)(a2 + 16) = v4;
        }
LABEL_17:
        *(void *)a2 = a3;
        *(void *)(a2 + 8) = 0;
        break;
      default:
        *(_DWORD *)(a2 + 16) = 0;
        goto LABEL_17;
    }
  }
  return result;
}

uint64_t sub_19E056730(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4, __n128 a5)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a2 + 8);
  if ((*(unsigned char *)(a1 + 2064) & 1) == 0)
  {
    unint64_t v9 = v8 & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v10 = *(unsigned int *)(a2 + 16);
    if (v10 > *(unsigned __int16 *)((v8 & 0xFFFFFFFFFFFFFFFCLL) + 12)) {
      sub_19E058CE4();
    }
    if (!v9)
    {
LABEL_20:
      char v21 = 0;
      return v21 & 1;
    }
    unint64_t v11 = v8 & 0xFFFFFFFFFFFFFFFCLL;
    while (1)
    {
      unsigned int v12 = *(unsigned __int16 *)((v8 & 0xFFFFFFFFFFFFFFFCLL) + 12);
      if (v11 != v9)
      {
        unsigned int v12 = *(unsigned __int16 *)(v11 + 12);
        if (v10 >= v12) {
          goto LABEL_19;
        }
        if (v10)
        {
          char v13 = (unsigned __int8 *)(v11 + 14);
          uint64_t v14 = *(unsigned int *)(a2 + 16);
          char v15 = (unsigned __int8 *)(v9 + 14);
          do
          {
            int v17 = *v13++;
            int v16 = v17;
            int v18 = *v15++;
            if (v16 != v18) {
              goto LABEL_19;
            }
          }
          while (--v14);
        }
      }
      LODWORD(v19) = 0;
      int v20 = *(_DWORD *)(a2 + 16);
      if (v10 < v12 && a4)
      {
        unint64_t v19 = 0;
        do
        {
          if (*(unsigned __int8 *)(v11 + v10 + 14 + v19) != a3[v19]) {
            break;
          }
          if (++v19 + v10 >= v12) {
            break;
          }
        }
        while (v19 < a4);
        int v20 = v10 + v19;
      }
      if (v19 == a4)
      {
        *(void *)(a2 + 8) = v11 | 2;
        if (v20 == v12)
        {
          *(_DWORD *)(a2 + 16) = v12;
          *(_DWORD *)(a2 + 2sub_19E03D880(&a9, 0) = *(_DWORD *)(v11 + 8);
        }
        else
        {
          *(void *)(a2 + 16) = v10 + a4;
        }
        char v21 = 1;
        return v21 & 1;
      }
LABEL_19:
      unint64_t v11 = *(void *)v11;
      if (!v11) {
        goto LABEL_20;
      }
    }
  }
  v35[1] = v35;
  v35[0] = *(void *)a2;
  a5.n128_u64[0] = *(void *)(a2 + 16);
  float v22 = *(float *)(a2 + 24);
  __n128 v38 = a5;
  MEMORY[0x1F4188790]();
  uint64_t v24 = (char *)v35 - v23;
  size_t v26 = *(unsigned int *)(a2 + 16);
  memcpy((char *)v35 - v23, (const void *)(v25 + 22), v26);
  unint64_t v27 = *(void *)a2 & 0xFFFFFFFFFFFFFFFCLL;
  if (v27)
  {
    int v37 = 0;
    unsigned int v28 = v26 + a4;
    size_t v36 = a4;
    do
    {
      unsigned int v29 = *(unsigned __int16 *)(v27 + 20);
      if (v28 <= v29 && !memcmp((const void *)(v27 + 22), v24, v26) && !memcmp((const void *)(v27 + 22 + v26), a3, v36))
      {
        if (v28 == v29)
        {
          *(void *)(a2 + 8) = v27 | 2;
          int v34 = *(_DWORD *)(v27 + 16);
          *(_DWORD *)(a2 + 24) = *(_DWORD *)(v27 + 12);
          *(_DWORD *)(a2 + 16) = v28;
          *(_DWORD *)(a2 + 2sub_19E03D880(&a9, 0) = v34;
          char v21 = 1;
          return v21 & 1;
        }
        __n128 v30 = v38;
        HIDWORD(v31) = 0;
        char v32 = v37;
        if ((v37 & 1) == 0)
        {
          uint64_t v8 = v27 | 2;
          float v22 = 0.0;
        }
        int v37 = 1;
        if ((v32 & 1) == 0)
        {
          LODWORD(v31) = v38.n128_u32[0] + a4;
          v30.n128_f64[0] = v31;
        }
        __n128 v38 = v30;
      }
      unint64_t v27 = *(void *)v27;
    }
    while (v27);
  }
  else
  {
    int v37 = 0;
  }
  *(void *)a2 = v35[0];
  *(void *)(a2 + 8) = v8;
  *(void *)(a2 + 16) = v38.n128_u64[0];
  *(float *)(a2 + 24) = v22;
  char v21 = v37;
  return v21 & 1;
}

uint64_t sub_19E056A0C(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 8) != a3)
  {
    uint64_t v3 = a3 & 3;
    if ((a3 & 3) != 0)
    {
      if (v3 == 2)
      {
        unint64_t v6 = a3 & 0xFFFFFFFFFFFFFFFCLL;
        if ((*(unsigned char *)(result + 2064) & 1) == 0)
        {
          if (*(_WORD *)(v6 + 12)) {
            int v5 = 0;
          }
          else {
            int v5 = *(_DWORD *)(v6 + 8);
          }
          goto LABEL_14;
        }
        *(_DWORD *)(a2 + 2sub_19E03D880(&a9, 0) = *(_DWORD *)(v6 + 16);
        *(_DWORD *)(a2 + 24) = *(_DWORD *)(v6 + 12);
        *(void *)a2 = a3;
      }
      else if (v3 == 1)
      {
        int v4 = (int *)(a3 & 0xFFFFFFFFFFFFFFFCLL);
        if ((*(unsigned char *)(result + 2064) & 1) == 0)
        {
          int v5 = *v4;
LABEL_14:
          *(_DWORD *)(a2 + 2sub_19E03D880(&a9, 0) = v5;
          goto LABEL_15;
        }
        *(_DWORD *)(a2 + 2sub_19E03D880(&a9, 0) = v4[2];
        *(_DWORD *)(a2 + 24) = v4[1];
      }
    }
    else
    {
      *(void *)(a2 + 2sub_19E03D880(&a9, 0) = 0;
    }
LABEL_15:
    *(void *)(a2 + 8) = a3;
    *(_DWORD *)(a2 + 16) = 0;
  }
  return result;
}

uint64_t sub_19E056AA8()
{
  return pthread_key_create((pthread_key_t *)&qword_1E94572B0, MEMORY[0x1E4F14838]);
}

void sub_19E056AC4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  uint64_t v6 = 0;
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  do
  {
    uint64_t v7 = v4 + 8 * v6;
    uint64_t v10 = *(void *)(v7 + 12);
    unint64_t v9 = (uint64_t *)(v7 + 12);
    uint64_t v8 = v10;
    uint64_t v11 = v10 & 3;
    if (v11 == 2)
    {
      unsigned int v12 = (char *)v3 + *(void *)(*v3 - 24);
      if ((v12[32] & 5) != 0)
      {
        int v13 = -1;
      }
      else
      {
        (*(void (**)(uint64_t *__return_ptr))(**((void **)v12 + 5) + 32))(v34);
        int v13 = v35;
      }
      unsigned int v33 = v13;
      uint64_t v14 = (_DWORD *)(v8 & 0xFFFFFFFFFFFFFFFCLL);
      unsigned int v15 = *(_DWORD *)(v5 + 2088);
      if (v15 <= 1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = v15;
      }
      int v17 = v14[2];
      int v18 = malloc_type_malloc(1035 * v16 + 8, 0xEBBE78C5uLL);
      unint64_t v19 = malloc_type_malloc(8 * v16, 0x2004093837F09uLL);
      LODWORD(v2sub_19E03D880(&a9, 0) = 0;
      int v21 = 1;
      float v22 = v14;
      do
      {
        unsigned int v23 = v21;
        if (v16 <= v20)
        {
          unint64_t v19 = malloc_type_realloc(v19, 16 * v16, 0x2004093837F09uLL);
          v16 *= 2;
        }
        *((void *)v19 + v2sub_19E03D880(&a9, 0) = v22;
        float v22 = (void *)*v22;
        size_t v20 = (v20 + 1);
        int v21 = v23 + 1;
      }
      while (v22);
      qsort(v19, v20, 8uLL, (int (__cdecl *)(const void *, const void *))sub_19E054658);
      unsigned int v24 = 0;
      if (v20)
      {
        uint64_t v25 = v23;
        size_t v26 = (uint64_t *)v19;
        do
        {
          uint64_t v27 = *v26++;
          unsigned int v28 = (char *)v18 + v24;
          *((_WORD *)v28 + 8) = *(_WORD *)(v27 + 20);
          *((_DWORD *)v28 + 2) = *(_DWORD *)(v27 + 12);
          *((_DWORD *)v28 + 3) = *(_DWORD *)(v27 + 16);
          memcpy(v28 + 18, (const void *)(v27 + 22), *(unsigned __int16 *)(v27 + 20));
          v24 += *(unsigned __int16 *)(v27 + 20) + 10;
          --v25;
        }
        while (v25);
      }
      *int v18 = v24;
      v18[1] = v17;
      uint64_t v3 = a3;
      std::ostream::write();
      free(v19);
      free(v18);
      do
      {
        unsigned int v29 = *(_DWORD **)v14;
        free(v14);
        uint64_t v14 = v29;
      }
      while (v29);
      *unint64_t v9 = v33 | 2;
      uint64_t v5 = a1;
      uint64_t v4 = a2;
    }
    else if (v11 == 1)
    {
      sub_19E056AC4(v5, v8 & 0xFFFFFFFFFFFFFFFCLL, v3);
    }
    ++v6;
  }
  while (v6 != 256);
}

void sub_19E056D74(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  uint64_t v6 = 0;
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  do
  {
    uint64_t v7 = v4 + 8 * v6;
    uint64_t v10 = *(void *)(v7 + 4);
    unint64_t v9 = (uint64_t *)(v7 + 4);
    uint64_t v8 = v10;
    uint64_t v11 = v10 & 3;
    if (v11 != 2)
    {
      if (v11 == 1) {
        sub_19E056D74(v5, v8 & 0xFFFFFFFFFFFFFFFCLL, v3);
      }
      goto LABEL_43;
    }
    unsigned int v12 = (char *)v3 + *(void *)(*v3 - 24);
    if ((v12[32] & 5) != 0)
    {
      int v13 = -1;
    }
    else
    {
      (*(void (**)(void *__return_ptr))(**((void **)v12 + 5) + 32))(v42);
      int v13 = v43;
    }
    unsigned int v41 = v13;
    uint64_t v14 = (void *)(v8 & 0xFFFFFFFFFFFFFFFCLL);
    unsigned int v15 = *(_DWORD *)(v5 + 2088);
    if (v15 <= 1) {
      unint64_t v16 = 1;
    }
    else {
      unint64_t v16 = v15;
    }
    int v17 = malloc_type_malloc(1031 * v16 + 4, 0x4CD827F1uLL);
    int v18 = malloc_type_malloc(8 * v16, 0x2004093837F09uLL);
    unsigned int v19 = 0;
    if (v14)
    {
      size_t v20 = v14;
      do
      {
        if (v16 <= v19)
        {
          int v18 = malloc_type_realloc(v18, 16 * v16, 0x2004093837F09uLL);
          v16 *= 2;
        }
        *((void *)v18 + v19) = v20;
        size_t v20 = (void *)*v20;
        ++v19;
      }
      while (v20);
    }
    int v21 = *(_DWORD *)(v5 + 2064);
    if ((v21 & 4) != 0)
    {
      uint64_t v28 = v19;
      qsort(v18, v19, 8uLL, (int (__cdecl *)(const void *, const void *))sub_19E054158);
      if (v19)
      {
        uint64_t v29 = 0;
        uint64_t v30 = 0;
        unsigned int v24 = 0;
        do
        {
          uint64_t v31 = v30;
          uint64_t v30 = *((void *)v18 + v29);
          if (v31)
          {
            uint64_t v32 = 0;
            uint64_t v33 = *(unsigned __int16 *)(v30 + 12);
            unsigned int v34 = *(_WORD *)(v30 + 12);
            while (v33 != v32)
            {
              if (*(unsigned __int16 *)(v31 + 12) <= (unsigned __int16)v32
                || *(unsigned __int8 *)(v30 + 14 + v32) != *(unsigned __int8 *)(v31 + 14 + v32))
              {
                unsigned int v34 = v32;
                break;
              }
              if (++v32 == 255)
              {
                unsigned int v34 = 255;
                break;
              }
            }
          }
          else
          {
            unsigned int v34 = 0;
            LOWORD(v33) = *(_WORD *)(v30 + 12);
          }
          uint64_t v35 = (char *)v17 + v24;
          unsigned __int16 v36 = v33 - v34;
          *((_WORD *)v35 + 4) = v36;
          *((_DWORD *)v35 + 1) = *(_DWORD *)(v30 + 8);
          v35[10] = v34;
          memcpy(v35 + 11, (const void *)(v30 + v34 + 14), v36);
          unsigned int v24 = v24 - v34 + *(unsigned __int16 *)(v30 + 12) + 7;
          ++v29;
        }
        while (v29 != v28);
      }
      else
      {
        unsigned int v24 = 0;
      }
    }
    else
    {
      uint64_t v22 = v19;
      if (v21) {
        unsigned int v23 = (int (__cdecl *)(const void *, const void *))sub_19E054658;
      }
      else {
        unsigned int v23 = (int (__cdecl *)(const void *, const void *))sub_19E054158;
      }
      qsort(v18, v19, 8uLL, v23);
      unsigned int v24 = 0;
      if (v19)
      {
        uint64_t v25 = (uint64_t *)v18;
        uint64_t v4 = a2;
        do
        {
          uint64_t v26 = *v25++;
          uint64_t v27 = (char *)v17 + v24;
          *((_WORD *)v27 + 4) = *(_WORD *)(v26 + 12);
          *((_DWORD *)v27 + 1) = *(_DWORD *)(v26 + 8);
          memcpy(v27 + 10, (const void *)(v26 + 14), *(unsigned __int16 *)(v26 + 12));
          v24 += *(unsigned __int16 *)(v26 + 12) + 6;
          --v22;
        }
        while (v22);
        goto LABEL_40;
      }
    }
    uint64_t v4 = a2;
LABEL_40:
    *int v17 = v24;
    uint64_t v3 = a3;
    std::ostream::write();
    free(v18);
    free(v17);
    do
    {
      int v37 = (void *)*v14;
      free(v14);
      uint64_t v14 = v37;
    }
    while (v37);
    *unint64_t v9 = v41 | 2;
    uint64_t v5 = a1;
LABEL_43:
    ++v6;
  }
  while (v6 != 256);
}

uint64_t sub_19E057124(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (char *)a1 + *(void *)(*a1 - 24);
  if ((v6[32] & 5) != 0)
  {
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    uint64_t v32 = -1;
  }
  else
  {
    (*(void (**)(long long *__return_ptr))(**((void **)v6 + 5) + 32))(&v24);
  }
  MEMORY[0x19F3BA4C0](v33, a1);
  uint64_t v7 = (char *)a1 + *(void *)(*a1 - 24);
  if ((v7[32] & 5) == 0)
  {
    (*(void (**)(_OWORD *__return_ptr))(**((void **)v7 + 5) + 32))(v34);
    if (v35 == -1) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
    }
  }
  MEMORY[0x19F3BA4D0](v33);
  while (1)
  {
    uint64_t v8 = (char *)a1 + *(void *)(*a1 - 24);
    if ((v8[32] & 5) != 0)
    {
      uint64_t v9 = -1;
    }
    else
    {
      (*(void (**)(_OWORD *__return_ptr))(**((void **)v8 + 5) + 32))(v34);
      uint64_t v9 = v35;
    }
    if (v9 >= a4) {
      break;
    }
    LOBYTE(v34[0]) = 0;
    sub_19E0416F8(a1, (uint64_t)v34, 1);
  }
  MEMORY[0x19F3BA4C0](v33, a1);
  uint64_t v10 = (char *)a1 + *(void *)(*a1 - 24);
  if ((v10[32] & 5) == 0)
  {
    (*(void (**)(_OWORD *__return_ptr))(**((void **)v10 + 5) + 32))(v34);
    if (v35 == -1) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
    }
  }
  MEMORY[0x19F3BA4D0](v33);
  std::ostream::write();
  long long v21 = v30;
  long long v22 = v31;
  uint64_t v23 = v32;
  long long v17 = v26;
  long long v18 = v27;
  long long v19 = v28;
  long long v20 = v29;
  long long v15 = v24;
  long long v16 = v25;
  MEMORY[0x19F3BA4C0](v14, a1);
  uint64_t v11 = (char *)a1 + *(void *)(*a1 - 24);
  if ((v11[32] & 5) == 0)
  {
    uint64_t v12 = *((void *)v11 + 5);
    v34[0] = v15;
    v34[1] = v16;
    int v34[2] = v17;
    _OWORD v34[3] = v18;
    uint64_t v35 = v23;
    void v34[6] = v21;
    v34[7] = v22;
    v34[4] = v19;
    v34[5] = v20;
    (*(void (**)(void *__return_ptr))(*(void *)v12 + 40))(v33);
    if (v33[16] == -1) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
    }
  }
  return MEMORY[0x19F3BA4D0](v14);
}

void sub_19E0574E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E05751C(_DWORD *a1, void *a2, int a3, int a4, int *a5)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  int32x4_t v9 = 0uLL;
  for (uint64_t i = 3; i != 515; i += 8)
    int32x4_t v9 = vsubq_s32(v9, (int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)&a1[i]), (int32x4_t)vceqzq_s64(*(int64x2_t *)&a1[i + 4]))));
  unsigned int v11 = vaddvq_s32(v9);
  if (v11 > 0xC7) {
    a4 = 1;
  }
  unsigned int v33 = a4;
  if (a4)
  {
    uint64_t v13 = 0;
    uint64_t v14 = *a5;
    *a5 = v14 + 1036;
    do
    {
      uint64_t v15 = *(void *)&a1[2 * v13 + 3];
      if ((v15 & 3) == 1)
      {
        int v16 = *a5;
        if (sub_19E05751C(v15 & 0xFFFFFFFFFFFFFFFCLL, a2, 1, 0, a5)) {
          int v17 = v16 | 1;
        }
        else {
          int v17 = v16 | 3;
        }
        v34[v13] = v17;
      }
      else
      {
        v34[v13] = v15;
      }
      ++v13;
    }
    while (v13 != 256);
    v34[256] = a1[2];
    uint64_t v35 = *(void *)a1;
    sub_19E057124(a2, (uint64_t)v34, 1036, v14);
    if (a3) {
LABEL_16:
    }
      free(a1);
  }
  else
  {
    int v31 = a3;
    uint64_t v32 = v11;
    size_t v19 = 4 * v11 + 44;
    uint64_t v20 = *a5;
    MEMORY[0x1F4188790]();
    long long v22 = (int8x16_t *)((char *)&v29 - v21);
    bzero((char *)&v29 - v21, v19);
    bzero(v22, v19);
    uint64_t v23 = 0;
    int v24 = 0;
    uint64_t v29 = v20;
    size_t v30 = v19;
    *a5 = v20 + v19;
    do
    {
      uint64_t v25 = *(void *)&a1[2 * v23 + 3];
      if (v25)
      {
        v22->i64[v23 >> 6] |= 1 << v23;
        long long v26 = &v22->i8[4 * v24];
        if ((v25 & 3) == 1)
        {
          int v27 = *a5;
          if (sub_19E05751C(v25 & 0xFFFFFFFFFFFFFFFCLL, a2, 1, 0, a5)) {
            int v28 = v27 | 1;
          }
          else {
            int v28 = v27 | 3;
          }
          *((_DWORD *)v26 + 11) = v28;
        }
        else
        {
          *((_DWORD *)v26 + 11) = v25;
        }
        ++v24;
      }
      ++v23;
    }
    while (v23 != 256);
    if (vaddvq_s32(vuzp1q_s32((int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*v22)))), (int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(v22[1])))))) != v32)sub_19E058D10(); {
    v22[2].i32[2] = a1[2];
    }
    v22[2].i64[0] = *(void *)a1;
    sub_19E057124(a2, (uint64_t)v22, v30, v29);
    if (v31) {
      goto LABEL_16;
    }
  }
  return v33;
}

uint64_t sub_19E0577E4(_DWORD *a1, void *a2, int a3, int a4, int *a5)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  int32x4_t v9 = 0uLL;
  for (uint64_t i = 1; i != 513; i += 8)
    int32x4_t v9 = vsubq_s32(v9, (int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)&a1[i]), (int32x4_t)vceqzq_s64(*(int64x2_t *)&a1[i + 4]))));
  unsigned int v11 = vaddvq_s32(v9);
  if (v11 > 0xC7) {
    a4 = 1;
  }
  unsigned int v34 = a4;
  if (a4)
  {
    uint64_t v13 = 0;
    uint64_t v14 = *a5;
    *a5 = v14 + 1028;
    do
    {
      uint64_t v15 = *(void *)&a1[2 * v13 + 1];
      if ((v15 & 3) == 1)
      {
        int v16 = *a5;
        if (sub_19E0577E4(v15 & 0xFFFFFFFFFFFFFFFCLL, a2, 1, 0, a5)) {
          int v17 = v16 | 1;
        }
        else {
          int v17 = v16 | 3;
        }
        v35[v13] = v17;
      }
      else
      {
        v35[v13] = v15;
      }
      ++v13;
    }
    while (v13 != 256);
    v35[256] = *a1;
    sub_19E057124(a2, (uint64_t)v35, 1028, v14);
    if (a3) {
LABEL_16:
    }
      free(a1);
  }
  else
  {
    int v32 = a3;
    uint64_t v33 = v11;
    size_t v19 = 4 * v11 + 36;
    uint64_t v20 = *a5;
    MEMORY[0x1F4188790]();
    long long v22 = (int8x16_t *)((char *)&v29 - v21);
    bzero((char *)&v29 - v21, v19);
    bzero(v22, v19);
    uint64_t v23 = 0;
    int v24 = 0;
    uint64_t v30 = v20;
    size_t v31 = v19;
    *a5 = v20 + v19;
    do
    {
      uint64_t v25 = *(void *)&a1[2 * v23 + 1];
      if (v25)
      {
        v22->i64[v23 >> 6] |= 1 << v23;
        long long v26 = &v22->i8[4 * v24];
        if ((v25 & 3) == 1)
        {
          int v27 = *a5;
          if (sub_19E0577E4(v25 & 0xFFFFFFFFFFFFFFFCLL, a2, 1, 0, a5)) {
            int v28 = v27 | 1;
          }
          else {
            int v28 = v27 | 3;
          }
          *((_DWORD *)v26 + 9) = v28;
        }
        else
        {
          *((_DWORD *)v26 + 9) = v25;
        }
        ++v24;
      }
      ++v23;
    }
    while (v23 != 256);
    if (vaddvq_s32(vuzp1q_s32((int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*v22)))), (int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(v22[1])))))) != v33)sub_19E058D3C(); {
    v22[2].i32[0] = *a1;
    }
    sub_19E057124(a2, (uint64_t)v22, v31, v30);
    if (v32) {
      goto LABEL_16;
    }
  }
  return v34;
}

void *sub_19E057A94(void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E04147C();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    void *__dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    uint64_t v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

void *sub_19E057B40(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_19E057BC8()
{
}

void *sub_19E057BDC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF09CB88;
  result[1] = v3;
  return result;
}

uint64_t sub_19E057C24(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF09CB88;
  a2[1] = v2;
  return result;
}

uint64_t sub_19E057C50(uint64_t a1, void *a2, void *a3, void *a4)
{
  return (*(uint64_t (**)(void, void, void))(a1 + 8))(*a2, *a3, *a4);
}

uint64_t sub_19E057C64(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B6E8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_19E057CA4()
{
  return &unk_1EF09B6E8;
}

void *sub_19E057CB0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_19E057D34(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_19E057DCC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 2080)) {
      sub_19E058D68();
    }
    uint64_t v2 = malloc_type_calloc(0x28uLL, 1uLL, 0x2B391B84uLL);
    if (sub_19E0526C0(a1, (uint64_t)v2))
    {
      v2[1] = a2 | 1;
      *((_DWORD *)v2 + 5) = *(_DWORD *)(a2 + 8);
      *((_DWORD *)v2 + 6) = *(_DWORD *)(a2 + 4);
    }
    else if (v2)
    {
      free(v2);
      return 0;
    }
  }
  return v2;
}

uint64_t sub_19E057E68(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 5)
  {
    if (a2 >> 59) {
      sub_19E041BEC();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = sub_19E058060(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    _OWORD v7[3] = v7[0] + 32 * v6;
    sub_19E057FE8(a1, v7);
    return sub_19E0581C8((uint64_t)v7);
  }
  return result;
}

void sub_19E057EE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E0581C8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E057F00()
{
}

void *sub_19E057F14(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF09CDF0;
  result[1] = v3;
  return result;
}

uint64_t sub_19E057F5C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF09CDF0;
  a2[1] = v2;
  return result;
}

uint64_t sub_19E057F88(uint64_t result)
{
  return result;
}

uint64_t sub_19E057F9C(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B778)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_19E057FDC()
{
  return &unk_1EF09B778;
}

uint64_t sub_19E057FE8(uint64_t *a1, void *a2)
{
  uint64_t result = sub_19E058098((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_19E058060(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_19E0416C4();
  }
  return operator new(32 * a2);
}

uint64_t sub_19E058098(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  long long v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = a7;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 32);
      *(void *)(v8 - 16) = *(void *)(a3 - 16);
      *(_OWORD *)(v8 - 32) = v9;
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 32) = 0;
      *(void *)(v8 - ++**(_DWORD **)(result + 8) = *(void *)(a3 - 8);
      v8 -= 32;
      v7 -= 32;
      a3 -= 32;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v8;
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_19E058148((uint64_t)v12);
  return v10;
}

uint64_t sub_19E058148(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_19E058180(a1);
  }
  return a1;
}

void sub_19E058180(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 32;
  }
}

uint64_t sub_19E0581C8(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_19E058200(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 4;
      *(void *)(a1 + 16) = v2 - 4;
      if (*((char *)v2 - 9) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void sub_19E05825C()
{
}

void *sub_19E058270(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF09CD98;
  result[1] = v3;
  return result;
}

uint64_t sub_19E0582B8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF09CD98;
  a2[1] = v2;
  return result;
}

void sub_19E0582E4(uint64_t a1, uint64_t a2, void **a3, unsigned int *a4, int *a5, int *a6)
{
  int v6 = *a5;
  int v7 = *a6;
  uint64_t v8 = *(uint64_t **)(a1 + 8);
  sub_19E057A94(__p, *a3, *a4);
  unint64_t v9 = v8[1];
  unint64_t v10 = v8[2];
  if (v9 >= v10)
  {
    uint64_t v12 = (uint64_t)(v9 - *v8) >> 5;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 59) {
      sub_19E041BEC();
    }
    uint64_t v14 = v10 - *v8;
    if (v14 >> 4 > v13) {
      unint64_t v13 = v14 >> 4;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v15 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    v23[4] = v8 + 2;
    if (v15) {
      int v16 = (char *)sub_19E058060((uint64_t)(v8 + 2), v15);
    }
    else {
      int v16 = 0;
    }
    int v17 = &v16[32 * v12];
    v23[0] = v16;
    v23[1] = v17;
    v23[3] = &v16[32 * v15];
    long long v18 = *(_OWORD *)__p;
    *((void *)v17 + 2) = v22;
    *(_OWORD *)int v17 = v18;
    __p[1] = 0;
    uint64_t v22 = 0;
    __p[0] = 0;
    *((_DWORD *)v17 + 6) = v6;
    *((_DWORD *)v17 + 7) = v7;
    _DWORD v23[2] = v17 + 32;
    sub_19E057FE8(v8, v23);
    uint64_t v19 = v8[1];
    sub_19E0581C8((uint64_t)v23);
    int v20 = SHIBYTE(v22);
    v8[1] = v19;
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v11 = *(_OWORD *)__p;
    *(void *)(v9 + 16) = v22;
    *(_OWORD *)unint64_t v9 = v11;
    *(_DWORD *)(v9 + 24) = v6;
    *(_DWORD *)(v9 + 2++**(_DWORD **)(result + 8) = v7;
    v8[1] = v9 + 32;
  }
}

void sub_19E058428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E058454(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B768)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_19E058494()
{
  return &unk_1EF09B768;
}

void sub_19E0584A0(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_19E0584F4((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_19E0584F4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 32)
  {
    if (*(char *)(i - 9) < 0) {
      operator delete(*(void **)(i - 32));
    }
  }
  a1[1] = v2;
}

void *sub_19E058544(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 2080)) {
      sub_19E058D68();
    }
    uint64_t v2 = malloc_type_calloc(0x28uLL, 1uLL, 0x2B391B84uLL);
    if (sub_19E0526C0(a1, (uint64_t)v2))
    {
      v2[1] = a2 | 1;
      *((_DWORD *)v2 + 5) = *(_DWORD *)a2;
    }
    else if (v2)
    {
      free(v2);
      return 0;
    }
  }
  return v2;
}

void sub_19E0585DC()
{
}

void *sub_19E0585F0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF09CD40;
  result[1] = v3;
  return result;
}

uint64_t sub_19E058638(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF09CD40;
  a2[1] = v2;
  return result;
}

uint64_t sub_19E058664(uint64_t result)
{
  return result;
}

uint64_t sub_19E058678(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B758)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_19E0586B8()
{
  return &unk_1EF09B758;
}

void sub_19E0586C8()
{
}

void *sub_19E0586DC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF09CCE8;
  result[1] = v3;
  return result;
}

uint64_t sub_19E058724(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF09CCE8;
  a2[1] = v2;
  return result;
}

void sub_19E058750(uint64_t a1, uint64_t a2, void **a3, unsigned int *a4, int *a5, int *a6)
{
  int v6 = *a5;
  int v7 = *a6;
  uint64_t v8 = *(uint64_t **)(a1 + 8);
  sub_19E057A94(__p, *a3, *a4);
  unint64_t v9 = v8[1];
  unint64_t v10 = v8[2];
  if (v9 >= v10)
  {
    uint64_t v12 = (uint64_t)(v9 - *v8) >> 5;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 59) {
      sub_19E041BEC();
    }
    uint64_t v14 = v10 - *v8;
    if (v14 >> 4 > v13) {
      unint64_t v13 = v14 >> 4;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v15 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    v23[4] = v8 + 2;
    if (v15) {
      int v16 = (char *)sub_19E058060((uint64_t)(v8 + 2), v15);
    }
    else {
      int v16 = 0;
    }
    int v17 = &v16[32 * v12];
    v23[0] = v16;
    v23[1] = v17;
    v23[3] = &v16[32 * v15];
    long long v18 = *(_OWORD *)__p;
    *((void *)v17 + 2) = v22;
    *(_OWORD *)int v17 = v18;
    __p[1] = 0;
    uint64_t v22 = 0;
    __p[0] = 0;
    *((_DWORD *)v17 + 6) = v6;
    *((_DWORD *)v17 + 7) = v7;
    _DWORD v23[2] = v17 + 32;
    sub_19E057FE8(v8, v23);
    uint64_t v19 = v8[1];
    sub_19E0581C8((uint64_t)v23);
    int v20 = SHIBYTE(v22);
    v8[1] = v19;
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v11 = *(_OWORD *)__p;
    *(void *)(v9 + 16) = v22;
    *(_OWORD *)unint64_t v9 = v11;
    *(_DWORD *)(v9 + 24) = v6;
    *(_DWORD *)(v9 + 2++**(_DWORD **)(result + 8) = v7;
    v8[1] = v9 + 32;
  }
}

void sub_19E058894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E0588C0(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B748)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_19E058900()
{
  return &unk_1EF09B748;
}

uint64_t sub_19E05890C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_19E0589A8()
{
}

__n128 sub_19E0589BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF09CC90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++**(_DWORD **)(result + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_19E058A10(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09CC90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

uint64_t sub_19E058A48(uint64_t a1, uint64_t a2, const void **a3, unsigned int *a4, int *a5, int *a6, uint64_t *a7)
{
  size_t v8 = *a4;
  std::string::size_type v9 = (*(_DWORD *)(a1 + 8) + v8);
  unint64_t v10 = *(std::string **)(a1 + 16);
  int v11 = SHIBYTE(v10->__r_.__value_.__r.__words[2]);
  if (v11 < 0) {
    std::string::size_type size = v10->__r_.__value_.__l.__size_;
  }
  else {
    std::string::size_type size = HIBYTE(v10->__r_.__value_.__r.__words[2]);
  }
  unint64_t v13 = *a3;
  uint64_t v14 = *a7;
  int v15 = *a5;
  int v16 = *a6;
  if (size < v9)
  {
    std::string::resize(v10, v9, 0);
    unint64_t v10 = *(std::string **)(a1 + 16);
    LOBYTE(v11) = *((unsigned char *)&v10->__r_.__value_.__s + 23);
  }
  if ((v11 & 0x80) != 0) {
    unint64_t v10 = (std::string *)v10->__r_.__value_.__r.__words[0];
  }
  memcpy((char *)v10 + *(unsigned int *)(a1 + 8), v13, v8);
  v19[0] = v16;
  v19[1] = v15;
  int v17 = *(uint64_t **)(a1 + 16);
  if (*((char *)v17 + 23) < 0) {
    int v17 = (uint64_t *)*v17;
  }
  int v20 = v17;
  std::string::size_type v21 = v9;
  return sub_19E055994(*(void *)(a1 + 24), 0, (uint64_t)v19, v14);
}

uint64_t sub_19E058B24(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B738)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_19E058B64()
{
  return &unk_1EF09B738;
}

void *sub_19E058B70(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_19E058BF4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_19E058C8C()
{
  __assert_rtn("addListNode", "BurstTrie.cpp", 568, "listcount <= trie->reserved[ContainerSize]");
}

void sub_19E058CB8()
{
  __assert_rtn("addListNodeRanked", "BurstTrie.cpp", 721, "listcount <= trie->reserved[ContainerSize]");
}

void sub_19E058CE4()
{
  __assert_rtn("advanceMapCursorTrieList", "BurstTrie.cpp", 1995, "cursor->prfxlen <= head->restlen");
}

void sub_19E058D10()
{
  __assert_rtn("serializeLevelsRanked", "BurstTrie.cpp", 3366, "bitcount == count");
}

void sub_19E058D3C()
{
  __assert_rtn("serializeLevels", "BurstTrie.cpp", 3220, "bitcount == count");
}

void sub_19E058D68()
{
  __assert_rtn("burstTrieCreateCursorWithTrieLevelRef", "BurstTrie.cpp", 2892, "nullptr == trie->mapbase");
}

uint64_t sub_19E058D94(uint64_t a1, uint64_t a2, unsigned __int8 **a3, uint64_t *a4, _DWORD *a5)
{
  uint64_t v5 = 1;
  if (a1)
  {
    uint64_t v6 = a2;
    if (a2)
    {
      int v7 = a3;
      if (a3)
      {
        size_t v8 = a4;
        if (a4)
        {
          unsigned int v48 = 1024;
          unint64_t v31 = 0;
          uint64_t v32 = 0;
          unint64_t v30 = 0x10000;
          unsigned int v34 = malloc_type_malloc(0x10000uLL, 0x88F986E9uLL);
          int v33 = 0;
          bzero(v34, 0x10000uLL);
          size_t __n = 0;
          uint64_t v37 = 0;
          size_t v35 = 0x10000;
          char __src = malloc_type_malloc(0x10000uLL, 0x88F986E9uLL);
          int v38 = 0;
          bzero(__src, 0x10000uLL);
          size_t size = 0;
          uint64_t v42 = 0;
          size_t v40 = *(void *)(a1 + 40);
          int v11 = *(void **)(a1 + 8);
          long long v45 = *(_OWORD *)(a1 + 56);
          uint64_t v44 = a1 + 48;
          ptr = v11;
          int v43 = 1;
          bzero(v11, v40);
          unint64_t v12 = sub_19E0591CC(&v30, 1028, 4);
          uint64_t v13 = (v12 >> 2) | 0x300000000;
          if (v12 == -1) {
            uint64_t v13 = 0;
          }
          uint64_t v47 = v13;
          while (1)
          {
            uint64_t v15 = *v8++;
            int v14 = v15;
            if ((unint64_t)(v15 - 257) <= 0xFFFFFFFFFFFFFEFFLL) {
              break;
            }
            int v17 = *v7++;
            int v16 = v17;
            LODWORD(v17) = *a5++;
            sub_19E059014((unint64_t)&v30, v47, v16, v14, v17);
            if (!--v6)
            {
              unint64_t v30 = v31;
              size_t v35 = (v37 & 0xFFFFFFFC)
                  + (unint64_t)*(unsigned int *)((char *)__src + (v37 & 0xFFFFFFFC))
                  + 4;
              size_t __n = v35;
              uint64_t v18 = sub_19E0591CC(&v40, 24, 4);
              unint64_t v19 = sub_19E05940C((uint64_t)&v30, v47, &v40, 1);
              int v20 = size;
              uint64_t v21 = sub_19E0591CC(&v40, __n, 4096);
              if (v21 == -1)
              {
                uint64_t v5 = 0xFFFFFFFFLL;
              }
              else
              {
                uint64_t v22 = v21;
                memcpy((char *)ptr + v21, __src, __n);
                int v23 = HIDWORD(v19) + 4 * v19;
                int v24 = ptr;
                uint64_t v25 = (char *)ptr + v18;
                _DWORD *v25 = 1;
                v25[1] = v23;
                void v25[2] = v20;
                v25[3] = v22;
                uint64_t v26 = __n;
                v25[4] = __n;
                uint64_t v27 = v48;
                void v25[5] = v48;
                *(_DWORD *)a1 = v23;
                *(void *)(a1 + 24) = v26;
                *(void *)(a1 + 32) = v27;
                size_t v40 = size;
                if ((void)v45) {
                  int v28 = (char *)((uint64_t (*)(void))v45)();
                }
                else {
                  int v28 = (char *)malloc_type_realloc(v24, size, 0x28D4551EuLL);
                }
                uint64_t v5 = 0;
                ptr = v28;
                *(void *)(a1 + ++**(_DWORD **)(result + 8) = v28;
                *(void *)(a1 + 16) = &v28[v22];
              }
              if (v34) {
                free(v34);
              }
              if (__src) {
                free(__src);
              }
              return v5;
            }
          }
          if (v34) {
            free(v34);
          }
          if (__src) {
            free(__src);
          }
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return v5;
}

unint64_t sub_19E059014(unint64_t result, int a2, unsigned __int8 *a3, int a4, unsigned int a5)
{
  uint64_t v6 = *(void *)(result + 56);
  uint64_t v7 = (4 * a2);
  size_t v8 = (unsigned int *)(v6 + v7);
  if (!a4)
  {
LABEL_19:
    *size_t v8 = a5;
    return result;
  }
  int v9 = a4;
  unint64_t v11 = result;
  unint64_t v12 = (unint64_t *)(result + 64);
  while (1)
  {
    uint64_t v13 = *a3;
    int v14 = &v8[v13];
    unsigned int v16 = v14[1];
    uint64_t v15 = v14 + 1;
    int v17 = v16 & 3;
    unint64_t v18 = (unint64_t)v16 >> 2;
    if (v17 != 3) {
      break;
    }
    __n128 result = v18 | 0x300000000;
    ++a3;
    LODWORD(v19) = v9 - 1;
LABEL_18:
    uint64_t v7 = (4 * result);
    size_t v8 = (unsigned int *)(v6 + v7);
    int v9 = v19;
    if (!v19) {
      goto LABEL_19;
    }
  }
  if (v17 != 1)
  {
    if (v17) {
      return result;
    }
    if (*(void *)(v11 + 80) != *(void *)(v11 + 72)) {
      *(void *)(v11 + 72) = (*(void *)(v11 + 80) & 0xFFFFFFFCLL)
    }
                            + *(unsigned int *)(*(void *)(v11 + 120) + (*(void *)(v11 + 80) & 0xFFFFFFFCLL))
                            + 4;
    __n128 result = sub_19E0591CC(v12, *(unsigned int *)(v11 + 200), 4);
    if (result == -1) {
      unint64_t v18 = 0;
    }
    else {
      unint64_t v18 = (result >> 2) | 0x100000000;
    }
    _DWORD *v15 = HIDWORD(v18) | (4 * v18);
  }
  int v20 = (int *)(*(void *)(v11 + 120) + (4 * v18));
  size_t v19 = (v9 - 1);
  if (v9 == 1)
  {
    v20[1] = a5;
    int v24 = 4;
    goto LABEL_22;
  }
  uint64_t v21 = *v20;
  if (!v21)
  {
    *(void *)int v20 = 4;
    uint64_t v21 = 4;
  }
  ++a3;
  uint64_t v22 = (v9 + 4);
  uint64_t v23 = v21 + 4;
  if (v23 + v22 >= (unint64_t)*(unsigned int *)(v11 + 200))
  {
    __n128 result = sub_19E0592C8((unint64_t *)v11);
    uint64_t v6 = *(void *)(v11 + 56);
    *(_DWORD *)(v6 + v7 + 4 * v13 + 4) = HIDWORD(result) | (4 * result);
    goto LABEL_18;
  }
  *((unsigned char *)v20 + v23) = v19;
  uint64_t v25 = (char *)v20 + v23 + 1;
  __n128 result = (unint64_t)memcpy(v25, a3, v19);
  *(_DWORD *)&v25[v19] = a5;
  int v24 = *v20 + v22;
LABEL_22:
  int *v20 = v24;
  return result;
}

uint64_t sub_19E0591CC(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *a1;
  uint64_t v5 = (a3 + a1[1] - 1) & -a3;
  unint64_t v6 = v5 + a2;
  if (v5 + a2 <= *a1)
  {
LABEL_13:
    a1[1] = v6;
    a1[2] = v5;
    return v5;
  }
  while (1)
  {
    int v7 = 2 * (int)v4 ? 2 * v4 : 0x10000;
    if (!*((_DWORD *)a1 + 6)) {
      break;
    }
    size_t v8 = (uint64_t (*)(void *, void, unint64_t))a1[5];
    int v9 = (void *)a1[7];
    unint64_t v4 = v7;
    if (!v8)
    {
      unint64_t v10 = (char *)malloc_type_realloc(v9, v7, 0x949C1903uLL);
      a1[7] = (unint64_t)v10;
      *(_DWORD *)a1[4] = 1;
      goto LABEL_11;
    }
    a1[7] = v8(v9, v7, a1[6]);
LABEL_12:
    *a1 = v4;
    if (v6 <= v4) {
      goto LABEL_13;
    }
  }
  unint64_t v4 = v7;
  unint64_t v10 = (char *)malloc_type_realloc((void *)a1[7], v7, 0x868F7F08uLL);
  a1[7] = (unint64_t)v10;
  if (v10)
  {
LABEL_11:
    bzero(&v10[*a1], v4 - *a1);
    goto LABEL_12;
  }
  return -1;
}

uint64_t sub_19E0592C8(unint64_t *a1)
{
  v15[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = MEMORY[0x1F4188790]();
  unint64_t v4 = (_DWORD *)((char *)v15 - ((v3 + 19) & 0x1FFFFFFF0));
  uint64_t v6 = (4 * v5);
  int v7 = (unsigned int *)(*(void *)(v2 + 120) + v6);
  size_t v8 = *v7;
  *unint64_t v4 = v8;
  memcpy(v4 + 1, v7 + 1, v8);
  if (a1[10] == v6)
  {
    bzero(v7, a1[9] - v6);
    a1[9] = a1[10];
  }
  unint64_t v9 = sub_19E0591CC(a1, 1028, 4);
  if (v9 == -1) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = (v9 >> 2) | 0x300000000;
  }
  *(_DWORD *)(a1[7] + (4 * v10)) = v4[1];
  unint64_t v11 = (unsigned __int8 *)(v4 + 2);
  unint64_t v12 = (unint64_t)v4 + v8 + 4;
  if ((unint64_t)(v4 + 2) < v12)
  {
    do
    {
      unint64_t v13 = (unint64_t)&v11[*v11 + 5];
      sub_19E059014(a1, v10);
      unint64_t v11 = (unsigned __int8 *)v13;
    }
    while (v13 < v12);
  }
  return v10;
}

unint64_t sub_19E05940C(uint64_t a1, unint64_t a2, unint64_t *a3, int a4)
{
  LODWORD(v4) = a2;
  unint64_t v5 = HIDWORD(a2);
  if (HIDWORD(a2) == 3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(a1 + 56);
    uint64_t v10 = (4 * a2);
    int32x4_t v11 = 0uLL;
    v12.i64[0] = 0x300000003;
    v12.i64[1] = 0x300000003;
    do
    {
      int32x4_t v11 = vsubq_s32(v11, vtstq_s32(*(int32x4_t *)(v10 + v9 + 4 + v8), v12));
      v8 += 16;
    }
    while (v8 != 1024);
    if (a4 || (unsigned int v13 = vaddvq_s32(v11), v13 >= 0x21))
    {
      unint64_t v24 = sub_19E0591CC(a3, 1028, 4);
      uint64_t v25 = 0;
      if (v24 == -1) {
        unint64_t v4 = 0;
      }
      else {
        unint64_t v4 = (v24 >> 2) | 0x300000000;
      }
      uint64_t v26 = (4 * v4);
      uint64_t v27 = (int *)(v9 + v10);
      int v29 = *v27;
      int v28 = v27 + 1;
      *(_DWORD *)(a3[7] + v26) = v29;
      uint64_t v30 = v26 + 4;
      do
      {
        uint64_t v31 = sub_19E05940C(a1, ((unint64_t)v28[v25] >> 2) | ((unint64_t)(v28[v25] & 3) << 32), a3, 0);
        *(_DWORD *)(a3[7] + v30 + v25 * 4) = HIDWORD(v31) + 4 * v31;
        ++v25;
      }
      while (v25 != 256);
    }
    else
    {
      unint64_t v14 = sub_19E0591CC(a3, 4 * v13 + 40, 4);
      uint64_t v15 = 0;
      if (v14 == -1) {
        unint64_t v4 = 0;
      }
      else {
        unint64_t v4 = (v14 >> 2) | 0x200000000;
      }
      uint64_t v16 = (4 * v4);
      int v17 = (int *)(v9 + v10);
      int v19 = *v17;
      unint64_t v18 = v17 + 1;
      uint64_t v20 = a3[7] + v16;
      *(_DWORD *)uint64_t v20 = v19;
      *(unsigned char *)(v20 + 37) = v13;
      do
      {
        unint64_t v21 = sub_19E05940C(a1, ((unint64_t)v18[v15] >> 2) | ((unint64_t)(v18[v15] & 3) << 32), a3, 0);
        if (HIDWORD(v21))
        {
          uint64_t v22 = a3[7] + v16;
          uint64_t v23 = *(unsigned __int8 *)(v22 + 36);
          *(unsigned char *)(v22 + 36) = v23 + 1;
          *(_DWORD *)(v22 + 4 * v23 + 4sub_19E03D880(&a9, 0) = HIDWORD(v21) + 4 * v21;
          *(_DWORD *)(v22 + 4 * (v15 >> 5) + 4) |= 1 << v15;
        }
        ++v15;
      }
      while (v15 != 256);
    }
    unint64_t v5 = HIDWORD(v4);
  }
  return v4 | ((unint64_t)v5 << 32);
}

void *sub_19E0595E0(void *result, uint64_t a2, uint64_t a3)
{
  *__n128 result = a2;
  result[1] = a3;
  result[2] = 0;
  return result;
}

uint64_t sub_19E0595EC(uint64_t *a1, _DWORD *a2)
{
  unint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  unint64_t v4 = v2 + 4;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *a1;
  a1[2] = v4;
  if (!v6) {
    return 0;
  }
  *a2 = bswap32(*(_DWORD *)(v6 + v2));
  return 1;
}

uint64_t sub_19E059628(uint64_t *a1, void *__dst, size_t a3)
{
  size_t v4 = a1[1];
  uint64_t v3 = a1[2];
  size_t v5 = v3 + a3;
  if (v4) {
    BOOL v6 = v5 > v4;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6) {
    return 0;
  }
  uint64_t v7 = *a1;
  a1[2] = v5;
  if (!v7) {
    return 0;
  }
  memcpy(__dst, (const void *)(v7 + v3), a3);
  return 1;
}

uint64_t sub_19E059678(uint64_t *a1, _WORD *a2)
{
  unint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  unint64_t v4 = v2 + 2;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *a1;
  a1[2] = v4;
  if (!v6) {
    return 0;
  }
  *a2 = bswap32(*(unsigned __int16 *)(v6 + v2)) >> 16;
  return 1;
}

uint64_t sub_19E0596B8(uint64_t *a1, unsigned char *a2)
{
  unint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  unint64_t v4 = v2 + 1;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *a1;
  a1[2] = v4;
  if (!v6) {
    return 0;
  }
  *a2 = *(unsigned char *)(v6 + v2);
  return 1;
}

uint64_t sub_19E0596F0()
{
  return std::ostream::write();
}

uint64_t sub_19E0596F8()
{
  return std::ostream::write();
}

uint64_t sub_19E059728()
{
  return std::ostream::write();
}

uint64_t sub_19E05975C()
{
  return std::ostream::write();
}

uint64_t sub_19E05979C()
{
  return std::ostream::write();
}

uint64_t sub_19E0597D4()
{
  return std::ostream::write();
}

uint64_t sub_19E059808(unsigned int a1)
{
  if (a1 >= 0x3FFF) {
    unsigned int v1 = 4;
  }
  else {
    unsigned int v1 = 2;
  }
  if (a1 < 0x7F) {
    return 1;
  }
  else {
    return v1;
  }
}

uint64_t sub_19E059828(uint64_t a1)
{
  v3[17] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1 + 16 + *(void *)(*(void *)(a1 + 16) - 24);
  if ((*(unsigned char *)(v1 + 32) & 5) != 0) {
    return -1;
  }
  (*(void (**)(void *__return_ptr))(**(void **)(v1 + 40) + 32))(v3);
  return v3[16];
}

uint64_t sub_19E0598DC(uint64_t a1, uint64_t a2)
{
  v8[17] = *MEMORY[0x1E4F143B8];
  while (sub_19E059828(a1) < a2)
  {
    LOBYTE(v8[0]) = 0;
    std::ostream::write();
  }
  unint64_t v4 = (void *)(a1 + 16);
  MEMORY[0x19F3BA4C0](v7, v4);
  BOOL v5 = (char *)v4 + *(void *)(*v4 - 24);
  if ((v5[32] & 5) == 0)
  {
    (*(void (**)(void *__return_ptr))(**((void **)v5 + 5) + 32))(v8);
    if (v8[16] == -1) {
      std::ios_base::clear((std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)), *(_DWORD *)((char *)v4 + *(void *)(*v4 - 24) + 32) | 4);
    }
  }
  return MEMORY[0x19F3BA4D0](v7);
}

void sub_19E059A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E059A38(uint64_t a1, uint64_t *a2, int a3, BOOL *a4)
{
  uint64_t v8 = a2[2];
  char v29 = 0;
  int v9 = sub_19E0596B8(a2, &v29);
  uint64_t result = 0;
  if (v9)
  {
    char v11 = v29;
    *(unsigned char *)(a1 + 3) = v29;
    uint64_t result = sub_19E059628(a2, (void *)(a1 + 16), (v11 & 3) + 1);
    if (result)
    {
      int v12 = *(_DWORD *)a1;
      int v13 = (*(_DWORD *)a1 >> 26) & 3;
      unsigned __int8 v28 = 0;
      __int16 v27 = 0;
      if (v13 == 3)
      {
        uint64_t result = sub_19E059628(a2, __dst, 3uLL);
        if (!result) {
          return result;
        }
        int v12 = (__dst[0] << 16) | (*(unsigned __int8 *)(a1 + 3) << 24) | (__dst[1] << 8) | __dst[2];
      }
      else
      {
        if (v13 == 2)
        {
          uint64_t result = sub_19E059678(a2, &v27);
          if (!result) {
            return result;
          }
          int v14 = v27;
        }
        else
        {
          if (v13 != 1) {
            goto LABEL_14;
          }
          uint64_t result = sub_19E0596B8(a2, &v28);
          if (!result) {
            return result;
          }
          int v14 = v28;
        }
        int v12 = (v14 + v8) & 0xFFFFFF | (*(unsigned __int8 *)(a1 + 3) << 24);
      }
      *(_DWORD *)a1 = v12;
LABEL_14:
      if ((v12 & 0x40000000) != 0)
      {
        unsigned __int8 v25 = 0;
        uint64_t result = sub_19E0596B8(a2, &v25);
        if (!result) {
          return result;
        }
        unint64_t v15 = *(void *)(a1 + 8) & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v25 << 32);
        *(void *)(a1 + ++**(_DWORD **)(result + 8) = v15;
        int v12 = *(_DWORD *)a1;
        if ((*(_DWORD *)a1 & 0x20000000) == 0) {
          goto LABEL_16;
        }
      }
      else
      {
        unint64_t v15 = *(void *)(a1 + 8) | 0xFF00000000;
        *(void *)(a1 + ++**(_DWORD **)(result + 8) = v15;
        if ((v12 & 0x20000000) == 0)
        {
          if ((v12 & 0x10000000) == 0) {
            goto LABEL_19;
          }
LABEL_16:
          unsigned __int8 v22 = 0;
          uint64_t result = sub_19E0596B8(a2, &v22);
          if (!result) {
            return result;
          }
          int v16 = v22;
          unint64_t v15 = *(void *)(a1 + 8) & 0xFFFFFFFFFFFFFF00 | v22;
          *(void *)(a1 + ++**(_DWORD **)(result + 8) = v15;
          if ((*(unsigned char *)(a1 + 3) & 0x10) != 0)
          {
            char v17 = 0;
            if (!v13 && !v16) {
              goto LABEL_35;
            }
          }
          else
          {
LABEL_19:
            char v17 = 1;
          }
          if (!v13) {
            char v17 = 0;
          }
          if (a3 & 0x10000) == 0 || (v17) {
            goto LABEL_35;
          }
          unsigned __int8 v21 = 0;
          if (sub_19E0596B8(a2, &v21))
          {
            int v18 = (char)v21;
            unint64_t v15 = *(void *)(a1 + 8) & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)v21 << 8);
            *(void *)(a1 + ++**(_DWORD **)(result + 8) = v15;
            if ((v18 & 0x80000000) == 0)
            {
LABEL_35:
              int v19 = *(_DWORD *)a1;
              *(void *)(a1 + ++**(_DWORD **)(result + 8) = v15 & 0xFFFFF8FFFFFFFFFFLL | ((unint64_t)((*(_DWORD *)a1 >> 29) & 1) << 40) | ((unint64_t)((*(_DWORD *)a1 >> 28) & 1) << 41) | ((unint64_t)((*(_DWORD *)a1 & 0xFFFFFF) == 0) << 42);
              *a4 = v19 < 0;
              return 1;
            }
            unsigned __int8 v20 = 0;
            if (sub_19E0596B8(a2, &v20))
            {
              unint64_t v15 = *(void *)(a1 + 8) & 0xFFFFFFFFFF00FFFFLL | ((unint64_t)v20 << 16);
              goto LABEL_35;
            }
          }
          return 0;
        }
      }
      if ((a3 & 0x20000) != 0)
      {
        if (sub_19E059628(a2, &v23, 4uLL))
        {
          unint64_t v15 = (char)v23 & 0x80000000 | ((unint64_t)*(unsigned int *)(a1 + 12) << 32) | __rev16(*(unsigned __int16 *)&v24[1]) | ((unint64_t)v24[0] << 16) & 0xFFFFFFFF80FFFFFFLL | ((unint64_t)(v23 & 0x7F) << 24);
          goto LABEL_35;
        }
      }
      else if (sub_19E059628(a2, &v23, 3uLL))
      {
        unint64_t v15 = ((v23 << 24) | (v23 << 16)) & 0x807F0000 | ((unint64_t)*(unsigned int *)(a1 + 12) << 32) | __rev16(*(unsigned __int16 *)v24);
        goto LABEL_35;
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_19E059CF4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if ((int)v4 >= 1)
  {
    unint64_t v5 = v4 + 1;
    do
    {
      uint64_t v6 = a1 + 24 * *(unsigned __int8 *)(a1 + (v5 - 2) + 12);
      *(_DWORD *)(v6 + 272) = 0;
      *(void *)(v6 + 28sub_19E03D880(&a9, 0) = 0;
      *(_DWORD *)(v6 + 28++**(_DWORD **)(result + 8) = 0;
      --v5;
    }
    while (v5 > 1);
  }
  *(_DWORD *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  *(void *)a1 = a2;
  uint64_t v7 = (void *)(a1 + 6424);
  sub_19E0595E0(v15, *(void *)(a1 + 6424), *(void *)(a1 + 6432));
  void v15[2] = a2 - *(void *)(a1 + 6424);
  char v14 = 1;
  while (1)
  {
    int v11 = 0;
    uint64_t v12 = 0;
    int v13 = 0;
    uint64_t result = sub_19E059A38((uint64_t)&v11, v15, *(_DWORD *)(a1 + 6416), (BOOL *)&v14);
    if ((result & 1) == 0) {
      break;
    }
    uint64_t result = sub_19E059E24(a1, v13, (uint64_t)&v11);
    if (!v14) {
      return result;
    }
  }
  *(_OWORD *)(a1 + 252) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 24sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)(a1 + 16sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 12++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4++**(_DWORD **)(result + 8) = 0u;
  uint64_t v9 = -6144;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  do
  {
    uint64_t v10 = a1 + v9;
    *(_DWORD *)(v10 + 6416) = 0;
    *(void *)(v10 + 6424) = 0;
    *(_DWORD *)(v10 + 6432) = 0;
    v9 += 24;
  }
  while (v9);
  *(_DWORD *)(a1 + 6416) = 0;
  void *v7 = 0;
  *(void *)(a1 + 6432) = 0;
  return result;
}

uint64_t sub_19E059E24(uint64_t result, unsigned int a2, uint64_t a3)
{
  unint64_t v3 = (_DWORD *)(result + 24 * a2 + 272);
  if (v3 != (_DWORD *)a3)
  {
    uint64_t v4 = 0;
    _DWORD *v3 = *(_DWORD *)a3;
    uint64_t v5 = result + 24 * a2;
    *(void *)(v5 + 28sub_19E03D880(&a9, 0) = *(void *)(a3 + 8);
    do
    {
      *(unsigned char *)(v5 + 288 + v4) = *(unsigned char *)(a3 + 16 + v4);
      ++v4;
    }
    while (v4 != 4);
  }
  uint64_t v6 = *(int *)(result + 8);
  *(_DWORD *)(result + ++**(_DWORD **)(result + 8) = v6 + 1;
  *(unsigned char *)(result + v6 + 12) = a2;
  return result;
}

void *sub_19E059E8C@<X0>(int *a1@<X0>, void *a2@<X8>)
{
  return sub_19E0413C8(a2, off_1E599B5C8[*a1 - 1]);
}

uint64_t sub_19E059EA8(const void *a1, size_t a2)
{
  uint64_t v4 = operator new(0x20uLL);
  uint64_t v5 = 0;
  *uint64_t v4 = xmmword_19E123F08;
  v4[1] = unk_19E123F18;
  while (1)
  {
    uint64_t v6 = *(unsigned int *)((char *)v4 + v5);
    int v14 = *(_DWORD *)((char *)v4 + v5);
    sub_19E059E8C(&v14, __p);
    unint64_t v7 = v13;
    int v8 = (char)v13;
    if ((v13 & 0x80u) != 0) {
      unint64_t v7 = (unint64_t)__p[1];
    }
    if (v7 != a2)
    {
      BOOL v10 = 0;
      if (((char)v13 & 0x80000000) == 0) {
        goto LABEL_12;
      }
LABEL_11:
      operator delete(__p[0]);
      goto LABEL_12;
    }
    if ((v13 & 0x80u) == 0) {
      uint64_t v9 = __p;
    }
    else {
      uint64_t v9 = (void **)__p[0];
    }
    BOOL v10 = memcmp(v9, a1, a2) == 0;
    if (v8 < 0) {
      goto LABEL_11;
    }
LABEL_12:
    if (v10) {
      break;
    }
    v5 += 4;
    if (v5 == 32)
    {
      operator delete(v4);
      return 0;
    }
  }
  operator delete(v4);
  return v6 | 0x100000000;
}

void sub_19E059FA4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E059FB8(uint64_t a1)
{
  *(_OWORD *)(a1 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 16sub_19E03D880(&a9, 0) = 0;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  char __src = 0;
  sub_19E05B100((void *)(a1 + 104), &__src, (char *)&v4, 1uLL);
  *(void *)(a1 + 12++**(_DWORD **)(result + 8) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 152) = *(void *)(a1 + 144);
  *(_DWORD *)(a1 + 16++**(_DWORD **)(result + 8) = -1;
  ++dword_1E9457270;
  return a1;
}

void sub_19E05A06C(_Unwind_Exception *a1)
{
  uint64_t v6 = v5;
  int v8 = *v6;
  if (*v6)
  {
    *(void *)(v1 + 152) = v8;
    operator delete(v8);
  }
  sub_19E05B3A4(v3, v2, v1, v4);
  _Unwind_Resume(a1);
}

void *sub_19E05A0A0(uint64_t a1)
{
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = *(void *)a1;
  *(void *)(a1 + 96) = 0;
  char __src = 0;
  uint64_t result = sub_19E05B100((void *)(a1 + 104), &__src, (char *)&v4, 1uLL);
  *(void *)(a1 + 12++**(_DWORD **)(result + 8) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 152) = *(void *)(a1 + 144);
  *(_DWORD *)(a1 + 16++**(_DWORD **)(result + 8) = -1;
  return result;
}

void *sub_19E05A108(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_19E05A150(uint64_t a1)
{
  if (((*(void *)(a1 + 8) - *(void *)a1) & 0x7FFFFFFF8) != 0
    && *(_DWORD *)(a1 + 88) == 1
    && !*(_DWORD *)(a1 + 24))
  {
    double v3 = *(double *)(a1 + 80) / *(double *)(a1 + 96);
    unsigned int v4 = (sqrt(v3) * 255.0);
    if (v4 >= 0xFF) {
      unsigned __int8 v5 = -1;
    }
    else {
      unsigned __int8 v5 = v4;
    }
    if (v4) {
      BOOL v6 = 1;
    }
    else {
      BOOL v6 = v3 <= 0.0;
    }
    if (v6) {
      return v5;
    }
    else {
      return 1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_19E05A1C0(uint64_t *result)
{
  uint64_t v1 = *result;
  unint64_t v2 = result[1] - *result;
  unint64_t v3 = v2 >> 3;
  if ((v2 >> 3))
  {
    int v4 = 0;
    int v5 = 0;
    uint64_t v6 = (v2 >> 3);
    do
    {
      if (*(void *)(*(void *)v1 + 104) != *(void *)(*(void *)v1 + 112))
      {
        if (*(_DWORD *)(*(void *)v1 + 128)) {
          ++v4;
        }
        else {
          ++v5;
        }
      }
      v1 += 8;
      --v6;
    }
    while (v6);
  }
  else
  {
    int v5 = 0;
    int v4 = 0;
  }
  if (v4 != v3 && v5 != v3)
  {
    uint64_t result = (uint64_t *)sub_19E04155C();
    if ((int)result <= 0)
    {
      char v16 = 0;
      int v8 = sub_19E0416F8(MEMORY[0x1E4FBA240], (uint64_t)"UnigramTrieNode.cpp", 19);
      sub_19E0416F8(v8, (uint64_t)"(", 1);
      uint64_t v9 = (void *)std::ostream::operator<<();
      BOOL v10 = sub_19E0416F8(v9, (uint64_t)") ", 2);
      int v11 = sub_19E0416F8(v10, (uint64_t)"LOG(", 4);
      uint64_t v12 = sub_19E0416F8(v11, (uint64_t)"INFO", 4);
      unsigned __int8 v13 = sub_19E0416F8(v12, (uint64_t)") ", 2);
      sub_19E0416F8(v13, (uint64_t)"YIKES:  ", 8);
      int v14 = (void *)std::ostream::operator<<();
      sub_19E0416F8(v14, (uint64_t)" grandchildren already have trie offsets but ", 45);
      unint64_t v15 = (void *)std::ostream::operator<<();
      sub_19E0416F8(v15, (uint64_t)" don't!", 7);
      return (uint64_t *)sub_19E05AEC4(&v16);
    }
  }
  return result;
}

void sub_19E05A310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void sub_19E05A324(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (*(_DWORD *)(a1 + 88)) {
    LODWORD(v2) = v2 + 1;
  }
  if (v2 <= 1)
  {
    char v5 = **(unsigned char **)(a1 + 104);
    unint64_t v7 = *(unsigned char **)(a2 + 112);
    unint64_t v6 = *(void *)(a2 + 120);
    if ((unint64_t)v7 >= v6)
    {
      uint64_t v9 = (unsigned char **)(a2 + 104);
      unint64_t v10 = *(void *)(a2 + 104);
      int v11 = &v7[-v10];
      uint64_t v12 = (uint64_t)&v7[-v10 + 1];
      if (v12 < 0) {
        sub_19E041BEC();
      }
      unint64_t v13 = v6 - v10;
      if (2 * v13 > v12) {
        uint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v14 = v12;
      }
      if (v14) {
        unint64_t v15 = operator new(v14);
      }
      else {
        unint64_t v15 = 0;
      }
      char v16 = &v15[v14];
      v11[(void)v15] = v5;
      uint64_t v8 = (uint64_t)&v11[(void)v15 + 1];
      if (v7 == (unsigned char *)v10)
      {
        unint64_t v15 = &v11[(void)v15];
      }
      else
      {
        char v17 = &v7[~v10];
        do
        {
          char v18 = *--v7;
          (v17--)[(void)v15] = v18;
        }
        while (v7 != (unsigned char *)v10);
        unint64_t v7 = *v9;
      }
      *(void *)(a2 + 104) = v15;
      *(void *)(a2 + 112) = v8;
      *(void *)(a2 + 12sub_19E03D880(&a9, 0) = v16;
      if (v7) {
        operator delete(v7);
      }
    }
    else
    {
      unsigned char *v7 = v5;
      uint64_t v8 = (uint64_t)(v7 + 1);
    }
    *(void *)(a2 + 112) = v8;
    if (a2 != a1) {
      sub_19E05B254((char *)a2, *(char **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
    }
    if (((*(void *)(a1 + 8) - *(void *)a1) & 0x7FFFFFFF8) == 8)
    {
      **(void **)(**(void **)a1 + 144) = a2;
      *(void *)(a1 + ++**(_DWORD **)(result + 8) = *(void *)a1;
      if (*(void *)(a2 + 112) - *(void *)(a2 + 104) <= 3uLL) {
        sub_19E05A324();
      }
    }
    else if (*(_DWORD *)(a1 + 88))
    {
      *(void *)(a2 + 24) = *(void *)(a1 + 24);
      sub_19E05AFA0(a2 + 32, (__n128 *)(a1 + 32));
      sub_19E05AFA0(a2 + 56, (__n128 *)(a1 + 56));
      uint64_t v19 = *(void *)(a1 + 80);
      *(void *)(a2 + 85) = *(void *)(a1 + 85);
      *(void *)(a2 + 8sub_19E03D880(&a9, 0) = v19;
    }
    *(void *)(a1 + 152) = *(void *)(a1 + 144);
  }
}

uint64_t sub_19E05A4E8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v1 = a1[1];
  if (((v1 - *a1) & 0x7FFFFFFF8) == 0) {
    return 0;
  }
  unint64_t v4 = 0;
  uint64_t v5 = 0;
  do
  {
    uint64_t v6 = *(void *)(v2 + 8 * v4);
    if (*(void *)(v6 + 104) != *(void *)(v6 + 112))
    {
      if (((*(void *)(v6 + 8) - *(void *)v6) & 0x7FFFFFFF8) == 8)
      {
        int v7 = *(_DWORD *)(v6 + 168);
        BOOL v9 = v7 != -1 && v7 <= *((_DWORD *)a1 + 42);
        if (!*(_DWORD *)(v6 + 88) && !v9)
        {
          sub_19E05A324(**(void **)v6, v6);
          LODWORD(v5) = v5 + *(_DWORD *)(v6 + 112) - *(_DWORD *)(v6 + 104) - 1;
        }
      }
      uint64_t v5 = sub_19E05A4E8(v6) + v5;
      uint64_t v2 = *a1;
      uint64_t v1 = a1[1];
    }
    ++v4;
  }
  while (v4 < ((unint64_t)(v1 - v2) >> 3));
  return v5;
}

uint64_t *sub_19E05A5BC(uint64_t *result)
{
  uint64_t v2 = *result;
  uint64_t v1 = result[1];
  if (((v1 - *result) & 0x7FFFFFFF8) != 0)
  {
    unint64_t v3 = result;
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(v2 + 8 * v4);
      if (*(void *)(v5 + 104) != *(void *)(v5 + 112))
      {
        if (((*(void *)(v5 + 8) - *(void *)v5) & 0x7FFFFFFF8) != 0
          && (int v6 = *(_DWORD *)(**(void **)v5 + 128)) != 0)
        {
          unsigned int v7 = v6 - *(_DWORD *)(v5 + 128);
          if (v7 > 0xFF)
          {
            if (v7 == (__int16)v7) {
              *(_DWORD *)(v5 + 136) = 2;
            }
            else {
              *(_DWORD *)(v5 + 136) = 3;
            }
          }
          else
          {
            *(_DWORD *)(v5 + 136) = 1;
          }
        }
        else
        {
          *(_DWORD *)(v5 + 136) = 0;
        }
        uint64_t result = (uint64_t *)sub_19E05A5BC(v5);
        *(_DWORD *)(v5 + 12++**(_DWORD **)(result + 8) = 0;
        uint64_t v2 = *v3;
        uint64_t v1 = v3[1];
      }
      ++v4;
    }
    while (v4 < ((unint64_t)(v1 - v2) >> 3));
  }
  dword_1E9457274 = 0;
  return result;
}

uint64_t sub_19E05A69C(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = v5 - *a1;
  if ((v6 & 0x7FFFFFFF8) != 0)
  {
    unint64_t v8 = 0;
    BOOL v9 = *((_DWORD *)a1 + 22) + (v6 >> 3) > 1;
    if ((a3 & 0x1000) != 0) {
      int v10 = 4;
    }
    else {
      int v10 = 3;
    }
    int v29 = v10;
    BOOL v30 = v9;
    do
    {
      uint64_t v11 = *(void *)(v4 + 8 * v8);
      uint64_t v12 = *(void *)(v11 + 104);
      uint64_t v13 = *(void *)(v11 + 112);
      if (v12 != v13)
      {
        ++dword_1E9457274;
        *(_DWORD *)(v11 + 12++**(_DWORD **)(result + 8) = a2;
        int v14 = a2 + v13 - v12 + 1;
        uint64_t v15 = (*(void *)(v11 + 8) - *(void *)v11) >> 3;
        if (v15)
        {
          int v16 = *(_DWORD *)(v11 + 136);
          int v17 = v14 + 2;
          if (v16 == 1) {
            ++v14;
          }
          else {
            v14 += 3;
          }
          if (v16 == 2) {
            int v14 = v17;
          }
        }
        int v18 = v14 + v30;
        int v19 = *(_DWORD *)(v11 + 88);
        if (v19 && *(_DWORD *)(v11 + 24))
        {
          a2 = (v18 + v29);
        }
        else
        {
          int v20 = sub_19E05A150(v11);
          BOOL v21 = v19 + v15 == 0;
          if (v19 + v15) {
            BOOL v22 = v15 == 0;
          }
          else {
            BOOL v22 = 0;
          }
          if (v20) {
            BOOL v21 = 1;
          }
          a2 = (v18 + v21);
          if (v20) {
            int v23 = 1;
          }
          else {
            int v23 = v22;
          }
          if (v23 == 1 && (a3 & 0x100) != 0)
          {
            a2 = sub_19E059808(*(_DWORD *)(v11 + 28)) + a2;
            uint64_t v4 = *a1;
            uint64_t v5 = a1[1];
          }
        }
      }
      ++v8;
    }
    while (v8 < ((unint64_t)(v5 - v4) >> 3));
    if (((v5 - v4) & 0x7FFFFFFF8) != 0)
    {
      unint64_t v25 = 0;
      do
      {
        uint64_t v26 = *(void **)(v4 + 8 * v25);
        if (v26[13] != v26[14])
        {
          sub_19E05A1C0(*(uint64_t **)(v4 + 8 * v25));
          if (v26[13] != v26[14] && (((v26[1] - *v26) & 0x7FFFFFFF8) == 0 || !*(_DWORD *)(*(void *)*v26 + 128))) {
            a2 = sub_19E05A69C(v26, a2, a3);
          }
        }
        ++v25;
        uint64_t v4 = *a1;
      }
      while (v25 < ((unint64_t)(a1[1] - *a1) >> 3));
    }
  }
  return a2;
}

uint64_t sub_19E05A88C(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, __int16 a6)
{
  uint64_t v8 = *(unsigned int *)(a1 + 128);
  *(_DWORD *)(a1 + 132) = v8;
  if (sub_19E059828(a2) != v8) {
    sub_19E05B4AC();
  }
  if (*(_DWORD *)(a1 + 88)) {
    int v10 = *(_DWORD *)(a1 + 24);
  }
  else {
    int v10 = 0;
  }
  int v20 = sub_19E05A150(a1);
  if (((*(void *)(a1 + 8) - *(void *)a1) & 0x7FFFFFFF8) != 0)
  {
    uint64_t v11 = (void *)(a1 + 104);
    uint64_t v12 = (void *)(a1 + 112);
    if (~*(void *)(a1 + 104) + *(void *)(a1 + 112) <= 3uLL)
    {
      unsigned int v13 = *(_DWORD *)(**(void **)a1 + 128);
      unsigned int v19 = v13 - *(_DWORD *)(a1 + 128);
      BOOL v14 = v13 == 0;
      goto LABEL_10;
    }
LABEL_41:
    sub_19E05B3FC();
  }
  uint64_t v11 = (void *)(a1 + 104);
  uint64_t v12 = (void *)(a1 + 112);
  if (~*(void *)(a1 + 104) + *(void *)(a1 + 112) > 3uLL) {
    goto LABEL_41;
  }
  unsigned int v13 = 0;
  unsigned int v19 = -*(_DWORD *)(a1 + 128);
  BOOL v14 = 1;
LABEL_10:
  uint64_t result = sub_19E0596F8();
  if (*v12 != *v11)
  {
    unsigned int v16 = 1;
    do
      uint64_t result = sub_19E0596F8();
    while (*v12 - *v11 > (unint64_t)v16++);
  }
  if (!v14)
  {
    int v18 = *(_DWORD *)(a1 + 136);
    if (v18 == 2)
    {
      if (v19 != (__int16)v19) {
        sub_19E05B480();
      }
      uint64_t result = sub_19E0597D4();
    }
    else
    {
      if (v18 == 1)
      {
        if (v19 >= 0x100) {
          sub_19E05B454();
        }
      }
      else
      {
        if (HIBYTE(v13)) {
          sub_19E05B428();
        }
        sub_19E0596F8();
        sub_19E0596F8();
      }
      uint64_t result = sub_19E0596F8();
    }
  }
  if (a4) {
    uint64_t result = sub_19E0596F8();
  }
  if (v10) {
    return sub_19E0596F0();
  }
  if (v20)
  {
    uint64_t result = sub_19E0596F8();
LABEL_29:
    if ((a6 & 0x100) != 0)
    {
      return sub_19E05975C();
    }
    return result;
  }
  if (*(_DWORD *)(a1 + 88) + ((*(void *)(a1 + 8) - *(void *)a1) >> 3))
  {
    if (!v14) {
      return result;
    }
  }
  else
  {
    uint64_t result = sub_19E0596F8();
    if (!v14) {
      return result;
    }
  }
  if (*(_DWORD *)(a1 + 88) + ((*(void *)(a1 + 8) - *(void *)a1) >> 3)) {
    goto LABEL_29;
  }
  return result;
}

uint64_t sub_19E05AC14(uint64_t result, uint64_t a2, __int16 a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v3 = *(void *)(result + 8);
  unint64_t v5 = v3 - *(void *)result;
  if ((v5 & 0x7FFFFFFF8) != 0)
  {
    unsigned int v7 = (uint64_t *)result;
    unint64_t v8 = 0;
    unint64_t v9 = v5 >> 3;
    unsigned int v10 = *(_DWORD *)(result + 88) + v9;
    unint64_t v11 = (v9 - 1);
    do
    {
      uint64_t result = *(void *)(v4 + 8 * v8);
      if (*(void *)(result + 104) != *(void *)(result + 112))
      {
        if (!*(_DWORD *)(result + 128))
        {
          sub_19E0538DC((uint64_t)v19);
          sub_19E0416F8(v20, (uint64_t)"UnigramTrieNode ", 16);
          BOOL v14 = (void *)std::ostream::operator<<();
          sub_19E0416F8(v14, (uint64_t)"/", 1);
          uint64_t v15 = (void *)std::ostream::operator<<();
          unsigned int v16 = sub_19E0416F8(v15, (uint64_t)" was not allocated a write file offset: parent @0x", 50);
          *(_DWORD *)((char *)v16 + *(void *)(*v16 - 24) + ++**(_DWORD **)(result + 8) = *(_DWORD *)((unsigned char *)v16
                                                                              + *(void *)(*v16 - 24)
                                                                              + 8) & 0xFFFFFFB5 | 8;
          std::ostream::operator<<();
          exception = __cxa_allocate_exception(0x20uLL);
          std::stringbuf::str();
          sub_19E05AFF4(exception, &v18);
          __cxa_throw(exception, (struct type_info *)&unk_1EF09AEC0, (void (*)(void *))sub_19E05AE64);
        }
        ++dword_1E9457278;
        uint64_t result = sub_19E05A88C(result, a2, (uint64_t)v7, v10 > 1, v8 < v11, a3);
        uint64_t v4 = *v7;
        uint64_t v3 = v7[1];
      }
      ++v8;
    }
    while (v8 < ((unint64_t)(v3 - v4) >> 3));
    if (((v3 - v4) & 0x7FFFFFFF8) != 0)
    {
      unint64_t v13 = 0;
      do
      {
        uint64_t result = *(void *)(v4 + 8 * v13);
        if (*(void *)(result + 104) != *(void *)(result + 112)
          && (((*(void *)(result + 8) - *(void *)result) & 0x7FFFFFFF8) == 0
           || !*(_DWORD *)(**(void **)result + 132)))
        {
          uint64_t result = sub_19E05AC14();
          uint64_t v4 = *v7;
          uint64_t v3 = v7[1];
        }
        ++v13;
      }
      while (v13 < ((unint64_t)(v3 - v4) >> 3));
    }
  }
  return result;
}

void sub_19E05AE1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      sub_19E053BB4((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void sub_19E05AE64(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF09BBF8;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }

  std::exception::~exception(this);
}

unsigned char *sub_19E05AEC4(unsigned char *a1)
{
  std::ios_base::getloc((const std::ios_base *)(MEMORY[0x1E4FBA240] + *(void *)(*MEMORY[0x1E4FBA240] - 24)));
  uint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  std::ostream::flush();
  if (*a1) {
    sub_19E04157C();
  }
  return a1;
}

void sub_19E05AF84(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

__n128 sub_19E05AFA0(uint64_t a1, __n128 *a2)
{
  std::locale v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = v4;
    operator delete(v4);
    *(void *)a1 = 0;
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

void *sub_19E05AFF4(void *a1, long long *a2)
{
  *a1 = &unk_1EF09BBF8;
  uint64_t v3 = a1 + 1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_19E03FA9C(v3, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    v3[2] = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }
  return a1;
}

void sub_19E05B05C(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E05B070(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF09BBF8;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::exception::~exception(this);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E05B0E4(uint64_t a1)
{
  uint64_t result = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

void *sub_19E05B100(void *result, char *__src, char *a3, unint64_t a4)
{
  unsigned int v7 = result;
  unint64_t v8 = result[2];
  unint64_t v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      sub_19E041BEC();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    uint64_t result = sub_19E05B210(v7, v11);
    unint64_t v9 = (char *)v7[1];
    goto LABEL_17;
  }
  uint64_t v12 = (unsigned char *)result[1];
  size_t v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    size_t v16 = a3 - __src;
    if (v16) {
      uint64_t result = memmove(v9, __src, v16);
    }
    uint64_t v15 = &v9[v16];
    goto LABEL_20;
  }
  BOOL v14 = &__src[v13];
  if (v12 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v13);
    unint64_t v9 = (char *)v7[1];
  }
  if (a3 != v14) {
    uint64_t result = memmove(v9, v14, a3 - v14);
  }
  uint64_t v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

char *sub_19E05B210(void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    sub_19E041BEC();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

char *sub_19E05B254(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unsigned int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61) {
      sub_19E041BEC();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = sub_19E05B360(v7, v11);
    size_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      long long v18 = v9;
      unsigned int v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  BOOL v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  size_t v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    long long v18 = v9;
    unsigned int v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  unsigned char *v12 = &v9[v17];
  return result;
}

char *sub_19E05B360(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_19E041BEC();
  }
  uint64_t result = (char *)sub_19E049FB0((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void sub_19E05B3A4(void **a1, void *a2, uint64_t a3, void *a4)
{
  unsigned int v7 = *a1;
  if (v7)
  {
    *(void *)(a3 + 112) = v7;
    operator delete(v7);
  }
  sub_19E05A108(a2);
  uint64_t v8 = *(void **)a3;
  if (*(void *)a3)
  {
    *a4 = v8;
    operator delete(v8);
  }
}

void sub_19E05B3FC()
{
  __assert_rtn("write_trie_node_as_var_byte_slot", "UnigramTrieNode.cpp", 309, "patricia_key_size_1 <= (kMaxPatriciaKeyBytes - 1)");
}

void sub_19E05B428()
{
}

void sub_19E05B454()
{
  __assert_rtn("write_trie_node_as_var_byte_slot", "UnigramTrieNode.cpp", 340, "relative_child_offset >= 0 && relative_child_offset <= DC_UINT8_MAX");
}

void sub_19E05B480()
{
  __assert_rtn("write_trie_node_as_var_byte_slot", "UnigramTrieNode.cpp", 343, "relative_child_offset >= DC_INT16_MIN && relative_child_offset <= DC_INT16_MAX");
}

void sub_19E05B4AC()
{
  __assert_rtn("write_trie_node_as_var_byte_slot", "UnigramTrieNode.cpp", 302, "m_written_offset == idx_file.tell()");
}

void sub_19E05B4D8()
{
}

void sub_19E05B5CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E05D1BC((void ***)va);
  uint64_t v4 = *v2;
  uint64_t *v2 = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E05B630(void *a1)
{
  uint64_t v2 = a1[5];
  unint64_t v3 = a1[6];
  unint64_t v4 = a1[4];
  if (v4 >= v3)
  {
    unint64_t v4 = 0;
    ++v2;
    a1[4] = 0;
    a1[5] = v2;
  }
  uint64_t v5 = a1[1];
  if (v2 == (a1[2] - v5) >> 3)
  {
    is_mul_ok(v3, 0xB0uLL);
    operator new[]();
  }
  uint64_t result = *(void *)(v5 + 8 * v2) + 176 * v4;
  a1[4] = v4 + 1;
  return result;
}

uint64_t sub_19E05B818(uint64_t a1)
{
  uint64_t result = sub_19E04156C((*(_DWORD *)(a1 + 64) >> 19) & 1);
  int v3 = *(_DWORD *)(a1 + 64);
  if ((v3 & 0x8000) != 0) {
    *(_DWORD *)(a1 + 6++**(_DWORD **)(result + 8) = 1;
  }
  if ((v3 & 0x10000) != 0) {
    *(_DWORD *)(a1 + 6++**(_DWORD **)(result + 8) = 2;
  }
  return result;
}

void sub_19E05B860()
{
}

uint64_t *sub_19E05B868(uint64_t *a1)
{
  sub_19E05D848((uint64_t)(a1 + 5), (void *)a1[6]);
  unint64_t v4 = (void **)(a1 + 2);
  sub_19E05D1BC(&v4);
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

unsigned char *sub_19E05B8E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  while (v2 != v3)
  {
    sub_19E05BAD8((void **)a1, *(void **)(a1 + 8), v2, 0);
    v2 += 72;
  }
  uint64_t result = (unsigned char *)sub_19E04155C();
  if ((int)result < 1)
  {
    char v20 = 0;
    uint64_t v5 = sub_19E0416F8(MEMORY[0x1E4FBA240], (uint64_t)"UnigramsCompiler.cpp", 20);
    sub_19E0416F8(v5, (uint64_t)"(", 1);
    unint64_t v6 = (void *)std::ostream::operator<<();
    unsigned int v7 = sub_19E0416F8(v6, (uint64_t)") ", 2);
    uint64_t v8 = sub_19E0416F8(v7, (uint64_t)"LOG(", 4);
    unint64_t v9 = sub_19E0416F8(v8, (uint64_t)"INFO", 4);
    uint64_t v10 = sub_19E0416F8(v9, (uint64_t)") ", 2);
    sub_19E0416F8(v10, (uint64_t)"\tInserted ", 10);
    unint64_t v11 = (void *)std::ostream::operator<<();
    sub_19E0416F8(v11, (uint64_t)" trie nodes.", 12);
    uint64_t result = sub_19E05AEC4(&v20);
  }
  if (*(unsigned char *)(a1 + 64))
  {
    sub_19E05A4E8(*(uint64_t **)(a1 + 8));
    uint64_t result = (unsigned char *)sub_19E04155C();
    if ((int)result <= 0)
    {
      char v19 = 0;
      uint64_t v12 = sub_19E0416F8(MEMORY[0x1E4FBA240], (uint64_t)"UnigramsCompiler.cpp", 20);
      sub_19E0416F8(v12, (uint64_t)"(", 1);
      size_t v13 = (void *)std::ostream::operator<<();
      BOOL v14 = sub_19E0416F8(v13, (uint64_t)") ", 2);
      unint64_t v15 = sub_19E0416F8(v14, (uint64_t)"LOG(", 4);
      size_t v16 = sub_19E0416F8(v15, (uint64_t)"INFO", 4);
      size_t v17 = sub_19E0416F8(v16, (uint64_t)") ", 2);
      sub_19E0416F8(v17, (uint64_t)"\tCondensed ", 11);
      long long v18 = (void *)std::ostream::operator<<();
      sub_19E0416F8(v18, (uint64_t)" nodes into patricia nodes.", 27);
      return sub_19E05AEC4(&v19);
    }
  }
  return result;
}

void sub_19E05BAB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12)
{
}

void *sub_19E05BAD8(void **a1, void *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v8 = (void *)(a3 + 8);
  unint64_t v9 = (uint64_t *)(a3 + 56);
  while (1)
  {
    *((double *)a2 + 12) = *(double *)(a3 + 56) + *((double *)a2 + 12);
    unint64_t v10 = a4 - 1;
    uint64_t v11 = *(void *)(a3 + 32);
    if (*(void *)(a3 + 40) - v11 <= v10)
    {
      size_t v13 = (unsigned int *)(a2 + 21);
      unsigned int v14 = *((_DWORD *)a2 + 42);
LABEL_6:
      unsigned int v12 = v14;
      goto LABEL_7;
    }
    unsigned int v12 = *(unsigned __int8 *)(v11 + v10);
    size_t v13 = (unsigned int *)(a2 + 21);
    unsigned int v14 = *((_DWORD *)a2 + 42);
    if (v14 <= v12) {
      goto LABEL_6;
    }
LABEL_7:
    *size_t v13 = v12;
    if (*(void *)(a3 + 16) - *(void *)(a3 + 8) <= (unint64_t)a4) {
      break;
    }
    a2 = sub_19E05BBE4(a1, a2, v8, a4++);
  }
  if (a4)
  {
    a2[3] = *(void *)a3;
    if (a2 + 3 != (void *)a3)
    {
      sub_19E05B100(a2 + 4, *(char **)(a3 + 8), *(char **)(a3 + 16), *(void *)(a3 + 16) - *(void *)(a3 + 8));
      sub_19E05B100(a2 + 7, *(char **)(a3 + 32), *(char **)(a3 + 40), *(void *)(a3 + 40) - *(void *)(a3 + 32));
    }
    uint64_t v15 = *v9;
    *(void *)((char *)a2 + 85) = *(uint64_t *)((char *)v9 + 5);
    a2[10] = v15;
  }
  return a2;
}

void *sub_19E05BBE4(void **a1, void *a2, void *a3, unsigned int a4)
{
  unsigned int v5 = *(unsigned __int8 *)(*a3 + a4);
  uint64_t v6 = (a2[1] - *a2) >> 3;
  if ((int)v6 < 1)
  {
    LODWORD(v++**(_DWORD **)(result + 8) = -1;
  }
  else
  {
    uint64_t v7 = 0xFFFFFFFFLL;
    do
    {
      uint64_t v8 = (v7 + v6) >> 1;
      uint64_t v9 = *(void *)(*a2 + 8 * v8);
      unsigned int v10 = **(unsigned __int8 **)(v9 + 104);
      if (v10 <= v5)
      {
        if (v10 >= v5) {
          return (void *)v9;
        }
      }
      else
      {
        LODWORD(v6) = (v7 + v6) >> 1;
        uint64_t v8 = v7;
      }
      uint64_t v7 = v8;
    }
    while ((int)v6 - (int)v8 > 1);
  }
  if ((int)v6 >= (int)v8 + 1) {
    unsigned int v11 = v8 + 1;
  }
  else {
    unsigned int v11 = v6;
  }
  unsigned int v12 = (void *)sub_19E05B630(*a1);
  uint64_t v15 = v12;
  sub_19E05A0A0((uint64_t)v12);
  char __src = v5;
  sub_19E05B100(v12 + 13, &__src, (char *)&v15, 1uLL);
  sub_19E05BCDC(v12, (uint64_t)a2);
  sub_19E05BDBC((uint64_t)a2, (char *)(*a2 + 8 * v11), (char *)&v15);
  return v15;
}

void sub_19E05BCDC(void *a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v6 = a1[20];
    uint64_t v4 = (uint64_t)(a1 + 20);
    unint64_t v5 = v6;
    uint64_t v7 = *(void **)(v4 - 8);
    if ((unint64_t)v7 >= v6)
    {
      uint64_t v9 = (void **)(v4 - 16);
      uint64_t v10 = *(void *)(v4 - 16);
      uint64_t v11 = ((uint64_t)v7 - v10) >> 3;
      if ((unint64_t)(v11 + 1) >> 61) {
        sub_19E041BEC();
      }
      uint64_t v12 = v5 - v10;
      uint64_t v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
        uint64_t v13 = v11 + 1;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v13;
      }
      if (v14) {
        uint64_t v15 = (char *)sub_19E049FB0(v4, v14);
      }
      else {
        uint64_t v15 = 0;
      }
      size_t v16 = &v15[8 * v11];
      size_t v17 = &v15[8 * v14];
      *(void *)size_t v16 = a2;
      uint64_t v8 = v16 + 8;
      char v19 = (char *)a1[18];
      long long v18 = (char *)a1[19];
      if (v18 != v19)
      {
        do
        {
          uint64_t v20 = *((void *)v18 - 1);
          v18 -= 8;
          *((void *)v16 - 1) = v20;
          v16 -= 8;
        }
        while (v18 != v19);
        long long v18 = (char *)*v9;
      }
      a1[18] = v16;
      a1[19] = v8;
      a1[20] = v17;
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      void *v7 = a2;
      uint64_t v8 = v7 + 1;
    }
    a1[19] = v8;
  }
}

char *sub_19E05BDBC(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  unint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      sub_19E041BEC();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      char v19 = (char *)sub_19E049FB0(a1 + 16, v18);
    }
    else {
      char v19 = 0;
    }
    uint64_t v20 = &v19[8 * v16];
    std::string __p = v19;
    __int16 v27 = v20;
    unsigned __int8 v28 = v20;
    int v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        int v23 = (char *)sub_19E049FB0(v8, v22);
        uint64_t v20 = &v23[8 * (v22 >> 2)];
        std::string __p = v23;
        __int16 v27 = v20;
        int v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        __int16 v27 = v20;
      }
    }
    *(void *)uint64_t v20 = *(void *)v3;
    unsigned __int8 v28 = v20 + 8;
    uint64_t v4 = sub_19E05D8AC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)char __src = *(void *)a3;
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = __src + 8;
  }
  else
  {
    uint64_t v9 = __src + 8;
    uint64_t v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }
  return v4;
}

void sub_19E05BFC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E05C000(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  sub_19E059728();
  sub_19E059728();
  sub_19E059728();
  sub_19E0596F0();
  sub_19E0596F0();
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  sub_19E0596F0();
  sub_19E05979C();
  int v4 = *(_DWORD *)(a1 + 64);
  if (v4) {
    char v5 = 70;
  }
  else {
    char v5 = 6;
  }
  sub_19E059728();
  if (*(int *)(a1 + 68) >= 2)
  {
    memset(&v26, 0, sizeof(v26));
    std::string::append(&v26, " CommonLetterForms,");
    std::string::append(&v26, " PartialProbability,");
    std::string::append(&v26, " UnigramRecordV2,");
    std::string::append(&v26, " VarByteTrieNodesV2,");
    std::string::append(&v26, " RelativeChildOffsetsV2,");
    if ((v5 & 0x40) != 0) {
      std::string::append(&v26, " PatriciaTrieRuns,");
    }
    std::string::append(&v26, " AllSortKeysAreDistributive,");
    if (((v4 << 8) & 0x10000) != 0) {
      std::string::append(&v26, " WriteWordIds");
    }
    if (((32 * v4) & 0x20000) != 0) {
      std::string::append(&v26, " Write4ByteUnigramOffsets");
    }
    if ((int)sub_19E04155C() <= 0)
    {
      char v25 = 0;
      unint64_t v6 = sub_19E0416F8(MEMORY[0x1E4FBA240], (uint64_t)"UnigramsCompiler.cpp", 20);
      sub_19E0416F8(v6, (uint64_t)"(", 1);
      unint64_t v7 = (void *)std::ostream::operator<<();
      uint64_t v8 = sub_19E0416F8(v7, (uint64_t)") ", 2);
      uint64_t v9 = sub_19E0416F8(v8, (uint64_t)"LOG(", 4);
      uint64_t v10 = sub_19E0416F8(v9, (uint64_t)"INFO", 4);
      uint64_t v11 = sub_19E0416F8(v10, (uint64_t)") ", 2);
      uint64_t v12 = sub_19E0416F8(v11, (uint64_t)"    Options: ", 13);
      if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v13 = &v26;
      }
      else {
        uint64_t v13 = (std::string *)v26.__r_.__value_.__r.__words[0];
      }
      if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v26.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v26.__r_.__value_.__l.__size_;
      }
      sub_19E0416F8(v12, (uint64_t)v13, size);
      sub_19E05AEC4(&v25);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
  }
  sub_19E059728();
  sub_19E059728();
  sub_19E059728();
  sub_19E059728();
  sub_19E059728();
  int v15 = 8 * *(_DWORD *)(a1 + 56) + 8;
  sub_19E059728();
  sub_19E059728();
  uint64_t result = sub_19E0598DC(a2, 128);
  if (v15)
  {
    sub_19E059728();
    uint64_t result = sub_19E059728();
    uint64_t v17 = *(void **)(a1 + 40);
    if (v17 != (void *)(a1 + 48))
    {
      do
      {
        if (v17[6] - v17[5] <= 4uLL)
        {
          sub_19E0596F0();
          uint64_t v19 = v17[5];
          uint64_t v18 = v17[6];
          if (v19 - v18 != -4)
          {
            uint64_t v20 = v18 - v19 - 4;
            do
              sub_19E0596F8();
            while (!__CFADD__(v20++, 1));
          }
          uint64_t result = sub_19E059728();
        }
        unint64_t v22 = (void *)v17[1];
        if (v22)
        {
          do
          {
            int v23 = v22;
            unint64_t v22 = (void *)*v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            int v23 = (void *)v17[2];
            BOOL v24 = *v23 == (void)v17;
            uint64_t v17 = v23;
          }
          while (!v24);
        }
        uint64_t v17 = v23;
      }
      while (v23 != (void *)(a1 + 48));
    }
  }
  return result;
}

void sub_19E05C3B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E05C3EC(uint64_t a1)
{
  sub_19E05C93C((uint64_t)v25, 20);
  if ((int)sub_19E04155C() <= 0)
  {
    v23[0] = 0;
    uint64_t v2 = sub_19E0416F8(MEMORY[0x1E4FBA240], (uint64_t)"UnigramsCompiler.cpp", 20);
    sub_19E0416F8(v2, (uint64_t)"(", 1);
    uint64_t v3 = (void *)std::ostream::operator<<();
    int v4 = sub_19E0416F8(v3, (uint64_t)") ", 2);
    char v5 = sub_19E0416F8(v4, (uint64_t)"LOG(", 4);
    unint64_t v6 = sub_19E0416F8(v5, (uint64_t)"INFO", 4);
    unint64_t v7 = sub_19E0416F8(v6, (uint64_t)") ", 2);
    sub_19E0416F8(v7, (uint64_t)"\tAllocating trie slots: magic_number=", 37);
    uint64_t v8 = (void *)std::ostream::operator<<();
    sub_19E0416F8(v8, (uint64_t)", root_usage_sum=", 17);
    std::ostream::operator<<();
    sub_19E05AEC4(v23);
  }
  sub_19E05C000(a1, (uint64_t)v25);
  uint64_t v9 = sub_19E059828((uint64_t)v25);
  sub_19E05A69C(*(uint64_t **)(a1 + 8), v9, *(_DWORD *)(a1 + 64));
  sub_19E05A5BC(*(uint64_t **)(a1 + 8));
  if (sub_19E05A69C(*(uint64_t **)(a1 + 8), v9, *(_DWORD *)(a1 + 64)) >= 0x1000001)
  {
    sub_19E0538DC((uint64_t)v23);
    sub_19E0416F8(v24, (uint64_t)"Trie size=", 10);
    uint64_t v20 = (void *)std::ostream::operator<<();
    sub_19E0416F8(v20, (uint64_t)" bytes exceeds trie addressing capacity=", 40);
    std::ostream::operator<<();
    exception = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str();
    sub_19E05AFF4(exception, &v22);
    __cxa_throw(exception, (struct type_info *)&unk_1EF09AEC0, (void (*)(void *))sub_19E05AE64);
  }
  sub_19E05AC14(*(void *)(a1 + 8), (uint64_t)v25, *(_DWORD *)(a1 + 64));
  if ((int)sub_19E04155C() <= 0)
  {
    v23[0] = 0;
    uint64_t v10 = sub_19E0416F8(MEMORY[0x1E4FBA240], (uint64_t)"UnigramsCompiler.cpp", 20);
    sub_19E0416F8(v10, (uint64_t)"(", 1);
    uint64_t v11 = (void *)std::ostream::operator<<();
    uint64_t v12 = sub_19E0416F8(v11, (uint64_t)") ", 2);
    uint64_t v13 = sub_19E0416F8(v12, (uint64_t)"LOG(", 4);
    unint64_t v14 = sub_19E0416F8(v13, (uint64_t)"INFO", 4);
    int v15 = sub_19E0416F8(v14, (uint64_t)") ", 2);
    sub_19E0416F8(v15, (uint64_t)"\tReserved ", 10);
    uint64_t v16 = (void *)std::ostream::operator<<();
    sub_19E0416F8(v16, (uint64_t)" and wrote ", 11);
    uint64_t v17 = (void *)std::ostream::operator<<();
    sub_19E0416F8(v17, (uint64_t)" trie nodes in ", 15);
    uint64_t v18 = (void *)std::ostream::operator<<();
    sub_19E0416F8(v18, (uint64_t)" bytes", 6);
    sub_19E05AEC4(v23);
  }
  sub_19E059728();
  std::stringbuf::str();
  return sub_19E053BB4((uint64_t)v25);
}

void sub_19E05C6F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v52 & 1) == 0)
    {
LABEL_6:
      sub_19E053BB4((uint64_t)&a16);
      sub_19E053BB4((uint64_t)&a51);
      _Unwind_Resume(a1);
    }
  }
  else if (!v52)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v51);
  goto LABEL_6;
}

uint64_t sub_19E05C76C(uint64_t a1, uint64_t a2)
{
  sub_19E05B8E4(a1);
  sub_19E05C3EC(a1);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v5;
  *(void *)(a2 + 16) = v6;
  return 1;
}

void sub_19E05C7CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2 == 1)
  {
    uint64_t v10 = __cxa_begin_catch(exception_object);
    if ((int)sub_19E04155C() <= 0)
    {
      a10 = 0;
      uint64_t v11 = sub_19E0416F8(MEMORY[0x1E4FBA240], (uint64_t)"UnigramsCompiler.cpp", 20);
      sub_19E0416F8(v11, (uint64_t)"(", 1);
      uint64_t v12 = (void *)std::ostream::operator<<();
      uint64_t v13 = sub_19E0416F8(v12, (uint64_t)") ", 2);
      unint64_t v14 = sub_19E0416F8(v13, (uint64_t)"LOG(", 4);
      int v15 = sub_19E0416F8(v14, (uint64_t)"INFO", 4);
      uint64_t v16 = sub_19E0416F8(v15, (uint64_t)") ", 2);
      uint64_t v17 = sub_19E0416F8(v16, (uint64_t)"Error occurred during trie construction: ", 41);
      uint64_t v18 = (const char *)(*(uint64_t (**)(void *))(*(void *)v10 + 16))(v10);
      size_t v19 = strlen(v18);
      uint64_t v20 = sub_19E0416F8(v17, (uint64_t)v18, v19);
      sub_19E04160C(v20);
      sub_19E05AEC4(&a10);
    }
    __cxa_end_catch();
    JUMPOUT(0x19E05C7BCLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E05C8F8(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  sub_19E0595E0(v6, a1 + a3, 4);
  return sub_19E0595EC(v6, a4);
}

uint64_t sub_19E05C93C(uint64_t a1, int a2)
{
  uint64_t v4 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 12++**(_DWORD **)(result + 8) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v5 = a1 + 16;
  uint64_t v6 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  unint64_t v7 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v9 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + *(void *)(v9 - 24)) = v8;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  uint64_t v10 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v10, (void *)(a1 + 24));
  uint64_t v11 = MEMORY[0x1E4FBA488] + 24;
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  uint64_t v12 = v7[5];
  uint64_t v13 = v7[4];
  *(void *)(a1 + 16) = v13;
  *(void *)(v5 + *(void *)(v13 - 24)) = v12;
  uint64_t v14 = v7[1];
  *(void *)a1 = v14;
  *(void *)(a1 + *(void *)(v14 - 24)) = v7[6];
  *(void *)a1 = v11;
  *(void *)(a1 + 12++**(_DWORD **)(result + 8) = v4;
  *(void *)(a1 + 16) = v6;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 8++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 12sub_19E03D880(&a9, 0) = a2;
  return a1;
}

void sub_19E05CBEC(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x19F3BA690](v1);
  _Unwind_Resume(a1);
}

void sub_19E05CC18(void *a1)
{
  sub_19E05CC50(a1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E05CC50(void *a1)
{
  *a1 = &unk_1EF09BA98;
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v3 = (uint64_t *)a1[2];
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = *v2;
      if (*v2)
      {
        uint64_t v5 = *(void *)(v4 - 8);
        if (v5)
        {
          uint64_t v6 = 176 * v5;
          uint64_t v7 = v4 - 72;
          do
          {
            uint64_t v8 = v7 + v6;
            uint64_t v9 = *(void **)(v7 + v6 + 40);
            if (v9)
            {
              *(void *)(v8 + 4++**(_DWORD **)(result + 8) = v9;
              operator delete(v9);
            }
            uint64_t v10 = *(void **)(v7 + v6);
            if (v10)
            {
              *(void *)(v7 + v6 + ++**(_DWORD **)(result + 8) = v10;
              operator delete(v10);
            }
            uint64_t v11 = v7 + v6;
            uint64_t v12 = *(void **)(v7 + v6 - 48);
            if (v12)
            {
              *(void *)(v11 - 4sub_19E03D880(&a9, 0) = v12;
              operator delete(v12);
            }
            uint64_t v13 = *(void **)(v11 - 72);
            if (v13)
            {
              *(void *)(v7 + v6 - 64) = v13;
              operator delete(v13);
            }
            uint64_t v14 = *(void **)(v8 - 104);
            if (v14)
            {
              *(void *)(v7 + v6 - 96) = v14;
              operator delete(v14);
            }
            v6 -= 176;
          }
          while (v6);
        }
        MEMORY[0x19F3BA6E0](v4 - 16, 0x1090C8033691413);
      }
      ++v2;
    }
    while (v2 != v3);
    uint64_t v2 = (uint64_t *)a1[1];
  }
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_19E05CD7C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 144);
  if (v2)
  {
    *(void *)(a1 + 152) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 104);
  if (v3)
  {
    *(void *)(a1 + 112) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 56);
  if (v4)
  {
    *(void *)(a1 + 64) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 32);
  if (v5)
  {
    *(void *)(a1 + 4sub_19E03D880(&a9, 0) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = v6;
    operator delete(v6);
  }
  return a1;
}

void *sub_19E05CDF0(void *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_19E05CE78(result, a4);
    uint64_t result = sub_19E05CF1C((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_19E05CE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + ++**(_DWORD **)(result + 8) = v10;
  sub_19E05D1BC(&a9);
  _Unwind_Resume(a1);
}

char *sub_19E05CE78(void *a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    sub_19E041BEC();
  }
  uint64_t result = (char *)sub_19E05CED0((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[72 * v4];
  return result;
}

void *sub_19E05CED0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    sub_19E0416C4();
  }
  return operator new(72 * a2);
}

void *sub_19E05CF1C(uint64_t a1, uint64_t *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_19E05CFC8(a1, v4, v6);
      v6 += 9;
      uint64_t v4 = v12 + 9;
      v12 += 9;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  sub_19E05D0D8((uint64_t)v9);
  return v4;
}

void sub_19E05CFB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_19E05CFC8(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  a2[1] = 0;
  *a2 = v5;
  a2[2] = 0;
  a2[3] = 0;
  sub_19E05D05C(a2 + 1, (const void *)a3[1], a3[2], a3[2] - a3[1]);
  a2[4] = 0;
  a2[5] = 0;
  a2[6] = 0;
  uint64_t result = sub_19E05D05C(a2 + 4, (const void *)a3[4], a3[5], a3[5] - a3[4]);
  uint64_t v7 = a3[7];
  *(void *)((char *)a2 + 61) = *(uint64_t *)((char *)a3 + 61);
  a2[7] = v7;
  return result;
}

void sub_19E05D040(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E05D05C(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    uint64_t result = sub_19E05B210(result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_19E05D0BC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + ++**(_DWORD **)(result + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E05D0D8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_19E05D110((uint64_t *)a1);
  }
  return a1;
}

void sub_19E05D110(uint64_t *a1)
{
  uint64_t v2 = (void *)a1[1];
  uint64_t v1 = (void **)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = (void *)*v2;
  if (*v1 != (void *)*v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 9;
      sub_19E05D164(v5, v3);
    }
    while (v3 != v4);
  }
}

void sub_19E05D164(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)a2[4];
  if (v3)
  {
    a2[5] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a2[1];
  if (v4)
  {
    a2[2] = v4;
    operator delete(v4);
  }
}

void sub_19E05D1BC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 9;
        sub_19E05D164((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_19E05D254(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_19E05D2AC(a1, *(unsigned int **)a2, (unsigned int *)(a2 + 8));
  return a1;
}

void sub_19E05D294(_Unwind_Exception *a1)
{
  sub_19E05D848(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_19E05D2AC(uint64_t *result, unsigned int *a2, unsigned int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_19E05D338(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      uint64_t v7 = (unsigned int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          size_t v8 = v7;
          uint64_t v7 = *(unsigned int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          size_t v8 = (unsigned int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_19E05D338(uint64_t **a1, uint64_t *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)sub_19E05D3BC(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    sub_19E05D564((uint64_t)a1, a4, (uint64_t)&v8);
    sub_19E05D5F8(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

uint64_t *sub_19E05D3BC(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (unsigned int v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    size_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      char v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      uint64_t v9 = (uint64_t *)*a2;
      do
      {
        char v10 = v9;
        uint64_t v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v13 = a2;
      do
      {
        char v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }
      while (v14);
    }
    unsigned int v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = (uint64_t *)v16;
          unsigned int v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      uint64_t v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    uint64_t v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      uint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    size_t v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      size_t v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          unint64_t v21 = (uint64_t *)v20;
          unsigned int v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          uint64_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        uint64_t v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      unint64_t v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void *sub_19E05D564@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  unsigned int v6 = operator new(0x40uLL);
  *(void *)(a3 + ++**(_DWORD **)(result + 8) = v5;
  *(void *)a3 = v6;
  *(unsigned char *)(a3 + 16) = 0;
  v6[8] = *(_DWORD *)a2;
  *((void *)v6 + 6) = 0;
  *((void *)v6 + 7) = 0;
  *((void *)v6 + 5) = 0;
  uint64_t result = sub_19E05D05C((void *)v6 + 5, *(const void **)(a2 + 8), *(void *)(a2 + 16), *(void *)(a2 + 16) - *(void *)(a2 + 8));
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_19E05D5DC(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_19E05D7E8(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E05D5F8(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  uint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = sub_19E05D650(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_19E05D650(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), uint64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            char v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              _DWORD v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *uint64_t v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), uint64_t v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      unsigned char *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void sub_19E05D7E8(uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = (void *)__p[5];
    if (v3)
    {
      __p[6] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_19E05D848(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_19E05D848(a1, *a2);
    sub_19E05D848(a1, a2[1]);
    uint64_t v4 = (void *)a2[5];
    if (v4)
    {
      a2[6] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

char *sub_19E05D8AC(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  int v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    int v8 = __src;
    uint64_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + ++**(_DWORD **)(result + 8) = v7;
  char v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  uint64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + ++**(_DWORD **)(result + 8) = v13;
  BOOL v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  unsigned int v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void sub_19E05D974(uint64_t a1)
{
  sub_19E05D9AC(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E05D9AC(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C470;
  uint64_t v2 = a1 + 136;
  if (*(char *)(a1 + 423) < 0) {
    operator delete(*(void **)(a1 + 400));
  }
  uint64_t v3 = MEMORY[0x1E4FBA418];
  uint64_t v4 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 136) = *MEMORY[0x1E4FBA418];
  *(void *)(v2 + *(void *)(v4 - 24)) = *(void *)(v3 + 24);
  *(void *)(a1 + 144) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*(void **)(a1 + 208));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 248);
  sub_19E05DB24((uint64_t *)(a1 + 88), 0);
  uint64_t v5 = *(void *)(a1 + 80);
  *(void *)(a1 + 8sub_19E03D880(&a9, 0) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 16));
  return a1;
}

uint64_t sub_19E05DB24(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_19E0676D4(result);
    JUMPOUT(0x19F3BA710);
  }
  return result;
}

uint64_t sub_19E05DB78(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  uint64_t v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8++**(_DWORD **)(result + 8) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_19E05DCE8(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E05DD10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3) {
    return 1;
  }
  uint64_t v5 = a3;
  while (1)
  {
    uint64_t v7 = *(void *)(a4 + 8 * a2);
    if (!v7) {
      break;
    }
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(a1 + 88);
    int v10 = *(unsigned __int16 *)(v5 + 102);
    uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v12 = *(int *)(v5 + 80);
    do
    {
      uint64_t v13 = *(void *)(v7 + 112);
      int v14 = sub_19E05DDEC(v9, *(unsigned __int16 *)(v7 + 100), v10);
      if (v13 + v12 + v14 < v11)
      {
        uint64_t v11 = v13 + v12 + v14;
        uint64_t v8 = v7;
      }
      uint64_t v7 = *(void *)(v7 + 16);
    }
    while (v7);
    if (!v8) {
      break;
    }
    *(void *)uint64_t v5 = v8;
    *(void *)(v5 + ++**(_DWORD **)(result + 8) = 0;
    *(void *)(v5 + 112) = v11;
    uint64_t v15 = *(unsigned __int16 *)(v5 + 98) + a2;
    *(void *)(v5 + 16) = *(void *)(a4 + 8 * v15);
    *(void *)(a4 + 8 * v15) = v5;
    uint64_t v5 = *(void *)(v5 + 24);
    if (!v5) {
      return 1;
    }
  }
  return 0;
}

uint64_t sub_19E05DDEC(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(_DWORD *)(v3 + 4 * (a2 + 1));
  int v5 = *(_DWORD *)(v3 + 4 * a2);
  if (v4 - v5 == *(unsigned __int16 *)(a1 + 34)) {
    return *(__int16 *)(*(void *)(a1 + 24) + 2 * (v5 + a3));
  }
  else {
    return sub_19E05DE20((void *)a1, a2, a3);
  }
}

uint64_t sub_19E05DE20(void *a1, unsigned int a2, int a3)
{
  uint64_t v3 = a1[1];
  int v4 = *(_DWORD *)(v3 + 4 * a2);
  int v5 = *(_DWORD *)(v3 + 4 * (a2 + 1)) - 1;
  if (v4 > v5) {
    return 0x7FFFLL;
  }
  while (1)
  {
    int v6 = *(__int16 *)(a1[2] + 2 * ((v5 + v4) / 2));
    if (v6 >= a3) {
      break;
    }
    int v4 = (v5 + v4) / 2 + 1;
LABEL_6:
    if (v4 > v5) {
      return 0x7FFFLL;
    }
  }
  if (v6 > a3)
  {
    int v5 = (v5 + v4) / 2 - 1;
    goto LABEL_6;
  }
  return *(__int16 *)(a1[3] + 2 * ((uint64_t)(v5 + v4 + (v5 + v4 < 0)) >> 1));
}

void sub_19E05DE8C()
{
}

void sub_19E05E488(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_19E05E710(v21);
}

void sub_19E05E4B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void **sub_19E05E6A8(uint64_t a1)
{
  sub_19E05EEA4(&__dst, a1 + 8);
  uint64_t v2 = (void **)(a1 + 264);
  if (*(char *)(a1 + 287) < 0) {
    operator delete(*v2);
  }
  *(_OWORD *)uint64_t v2 = __dst;
  *(void *)(a1 + 28sub_19E03D880(&a9, 0) = v5;
  if (*(char *)(a1 + 287) < 0) {
    return (void **)*v2;
  }
  return v2;
}

void sub_19E05E710(uint64_t a1)
{
}

uint64_t sub_19E05E730(uint64_t a1, char *a2)
{
  uint64_t v3 = a1 + 8;
  sub_19E0413C8(__p, a2);
  int v4 = sub_19E05E980(v3, __p);
  if (SHIBYTE(__p[0].__sb_.__binp_) < 0) {
    operator delete(__p[0].__sb_.__vftable);
  }
  if ((void *)(a1 + 16) == v4) {
    operator new();
  }
  if (*((char *)v4 + 79) < 0)
  {
    sub_19E03FA9C(v11, (void *)v4[7], v4[8]);
  }
  else
  {
    *(_OWORD *)uint64_t v11 = *(_OWORD *)(v4 + 7);
    uint64_t v12 = v4[9];
  }
  sub_19E05EA00((uint64_t)__p);
  unsigned int v13 = 0;
  if (v12 >= 0) {
    uint64_t v5 = v11;
  }
  else {
    uint64_t v5 = (void **)v11[0];
  }
  if (v12 >= 0) {
    uint64_t v6 = HIBYTE(v12);
  }
  else {
    uint64_t v6 = (uint64_t)v11[1];
  }
  uint64_t v7 = sub_19E0416F8(&__p[0].__sb_.__binp_, (uint64_t)v5, v6);
  if ((*((unsigned char *)v7 + *(void *)(*v7 - 24) + 32) & 5) != 0
    || (uint64_t v8 = (void *)MEMORY[0x19F3BA460](__p, &v13), (*((unsigned char *)v8 + *(void *)(*v8 - 24) + 32) & 5) != 0)
    || (sub_19E05EB24(__p),
        (*((unsigned char *)&__p[0].__sb_.__einp_ + (unint64_t)__p[0].__sb_.__vftable[-1].pbackfail) & 2) == 0))
  {
    operator new();
  }
  uint64_t v10 = v13;
  std::strstream::~strstream(__p);
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  return v10;
}

void sub_19E05E950(_Unwind_Exception *__p, uint64_t a2, int a3, __int16 a4, char a5, char a6, uint64_t a7, uint64_t a8, void *__pa, std::strstream *a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a14 < 0) {
    operator delete(__pa);
  }
  _Unwind_Resume(__p);
}

void *sub_19E05E980(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = (void *)(a1 + 8);
  do
  {
    char v6 = sub_19E05EE24(v3 + 4, a2);
    if (v6 >= 0) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (v6 >= 0) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2 || (sub_19E05EE24(a2, v5 + 4) & 0x80) != 0) {
    return v2;
  }
  return v5;
}

uint64_t sub_19E05EA00(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA4B0] + 64;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  *(void *)(a1 + 16) = v2;
  uint64_t v3 = (std::strstreambuf *)(a1 + 24);
  *(void *)a1 = &unk_1EF09AD08;
  *(void *)(a1 + 12sub_19E03D880(&a9, 0) = &unk_1EF09AD30;
  std::ios_base::init((std::ios_base *)(a1 + 120), (void *)(a1 + 24));
  uint64_t v4 = MEMORY[0x1E4FBA4B0] + 104;
  uint64_t v5 = MEMORY[0x1E4FBA4B0] + 24;
  *(void *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 264) = -1;
  *(void *)a1 = v5;
  *(void *)(a1 + 12sub_19E03D880(&a9, 0) = v4;
  *(void *)(a1 + 16) = v2;
  std::strstreambuf::strstreambuf(v3, 0);
  return a1;
}

void sub_19E05EAF4(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x19F3BA690](v1);
  _Unwind_Resume(a1);
}

void *sub_19E05EB24(void *a1)
{
  MEMORY[0x19F3BA420](&v12, a1, 1);
  if (!v12) {
    return a1;
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
  uint64_t v2 = std::locale::use_facet(&v11, MEMORY[0x1E4FBA258]);
  std::locale::~locale(&v11);
  uint64_t v3 = a1 + 5;
  while (1)
  {
    uint64_t v4 = *(void **)((char *)v3 + *(void *)(*a1 - 24));
    uint64_t v5 = (unsigned char *)v4[3];
    if (v5 == (unsigned char *)v4[4]) {
      break;
    }
    LOBYTE(v6) = *v5;
LABEL_6:
    if ((v6 & 0x80) != 0 || (*((_DWORD *)&v2[1].~facet + v6) & 0x4000) == 0)
    {
      int v9 = 0;
      goto LABEL_12;
    }
    uint64_t v7 = *(void **)((char *)v3 + *(void *)(*a1 - 24));
    uint64_t v8 = v7[3];
    if (v8 == v7[4]) {
      (*(void (**)(void *))(*v7 + 80))(v7);
    }
    else {
      _OWORD v7[3] = v8 + 1;
    }
  }
  int v6 = (*(uint64_t (**)(void *))(*v4 + 72))(v4);
  if (v6 != -1) {
    goto LABEL_6;
  }
  int v9 = 2;
LABEL_12:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | v9);
  return a1;
}

void sub_19E05ECA4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
  std::locale::~locale(&a9);
  __cxa_begin_catch(a1);
  uint64_t v11 = *v9;
  *(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 32) |= 1u;
  if ((*((unsigned char *)v9 + *(void *)(v11 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x19E05EC60);
  }
  __cxa_rethrow();
}

void sub_19E05ED38(_Unwind_Exception *a1)
{
}

void sub_19E05ED4C(void *a1)
{
  *a1 = &unk_1EF09BFE0;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x19F3BA710](v1, 0x1000C4052888210);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E05EDC8(void *a1)
{
  *a1 = &unk_1EF09BFE0;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x19F3BA710](v2, 0x1000C4052888210);
  }
  return a1;
}

uint64_t sub_19E05EE24(void *a1, void *a2)
{
  size_t v2 = a1[1];
  if (*((char *)a1 + 23) >= 0)
  {
    size_t v3 = *((unsigned __int8 *)a1 + 23);
  }
  else
  {
    a1 = (void *)*a1;
    size_t v3 = v2;
  }
  size_t v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (void *)*a2;
    size_t v5 = v4;
  }
  if (v5 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v5;
  }
  int v7 = memcmp(a1, a2, v6);
  if (v7)
  {
    if ((v7 & 0x80000000) == 0) {
      return 1;
    }
  }
  else
  {
    if (v3 == v5) {
      return 0;
    }
    if (v3 >= v5) {
      return 1;
    }
  }
  return 255;
}

void *sub_19E05EEA4(void *__dst, uint64_t a2)
{
  size_t v2 = __dst;
  int v3 = *(_DWORD *)(a2 + 96);
  if ((v3 & 0x10) != 0)
  {
    unint64_t v5 = *(void *)(a2 + 88);
    unint64_t v6 = *(void *)(a2 + 48);
    if (v5 < v6)
    {
      *(void *)(a2 + 8++**(_DWORD **)(result + 8) = v6;
      unint64_t v5 = v6;
    }
    int v7 = (const void **)(a2 + 40);
  }
  else
  {
    if ((v3 & 8) == 0)
    {
      size_t v4 = 0;
      *((unsigned char *)__dst + 23) = 0;
      goto LABEL_16;
    }
    int v7 = (const void **)(a2 + 16);
    unint64_t v5 = *(void *)(a2 + 32);
  }
  uint64_t v8 = *v7;
  size_t v4 = v5 - (void)*v7;
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E04147C();
  }
  if (v4 >= 0x17)
  {
    uint64_t v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v9 = v4 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v11 = operator new(v9 + 1);
    v2[1] = v4;
    v2[2] = v10 | 0x8000000000000000;
    void *v2 = v11;
    size_t v2 = v11;
  }
  else
  {
    *((unsigned char *)__dst + 23) = v4;
    if (!v4) {
      goto LABEL_16;
    }
  }
  long long __dst = memmove(v2, v8, v4);
LABEL_16:
  *((unsigned char *)v2 + v4) = 0;
  return __dst;
}

uint64_t sub_19E05EF80(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4 = a1;
  v95[0] = MEMORY[0x1E4F143A8];
  v95[1] = 0x40000000;
  v96 = sub_19E05FE88;
  uint64_t v97 = &unk_1E599B608;
  uint64_t v98 = a1;
  unint64_t v5 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  *(_DWORD *)(v4 + ++**(_DWORD **)(result + 8) = 1;
  std::mutex::unlock(v5);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 168))(a2, 2) & 1) != 0
    || (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 168))(a2, 8))
  {
    *(void *)(v4 + 12sub_19E03D880(&a9, 0) = sub_19E060BB8;
    *(void *)(v4 + 12++**(_DWORD **)(result + 8) = 0;
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 168))(a2, 4)
    && !sub_19E05FECC(a2)
    || !(*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2))
  {
    goto LABEL_183;
  }
  unint64_t v6 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
  uint64_t v89 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  uint64_t v94 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 200))(a2);
  unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 88))(a2);
  uint64_t v88 = (unsigned __int16 *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
  uint64_t v8 = *(void *)(v4 + 80);
  uint64_t v9 = sub_19E0609C8(*(void **)(v94 + 16));
  *(_OWORD *)(v9 + 96) = 0u;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)(v9 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)uint64_t v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  uint64_t v10 = *(void *)(v8 + 136);
  *(unsigned char *)(v9 + 124) = 2;
  uint64_t v85 = (unsigned __int8 *)v88 + v7;
  *(void *)(v9 + 4++**(_DWORD **)(result + 8) = v88;
  *(void *)(v9 + 56) = v10;
  uint64_t *v6 = v9;
  if ((a3 & 2) == 0)
  {
    int v11 = sub_19E0608F8(v9);
    *(_DWORD *)(v4 + 112) = v11;
    if (v11 == -1)
    {
LABEL_11:
      *(_DWORD *)(v4 + 116) = v11;
      v87 = (_DWORD *)(v4 + 116);
      if (v7 >= 2)
      {
        uint64_t v92 = &v88[*v88 == 32];
        goto LABEL_19;
      }
      uint64_t v92 = v88;
      if (v7)
      {
LABEL_19:
        unint64_t v20 = 0;
        unint64_t v82 = v7;
        uint64_t v77 = v6;
        uint64_t v78 = v4;
        uint64_t v79 = a2;
        while (1)
        {
          if (*(_DWORD *)(v4 + 8) == 2) {
            goto LABEL_183;
          }
          if (v6[v20]) {
            break;
          }
LABEL_163:
          v20 += 2;
          if (v20 >= v7) {
            goto LABEL_177;
          }
        }
        if (!v20 && *(void *)v89)
        {
          uint64_t v92 = (unsigned __int16 *)((char *)v92 + *(unsigned __int16 *)(*(void *)v89 + 98));
LABEL_156:
          uint64_t v57 = *(unsigned int (**)(void *))(v4 + 120);
          uint64_t v58 = *(void *)(v4 + 128);
          long long v59 = (void *)(v4 + (v58 >> 1));
          if (v58) {
            uint64_t v57 = *(unsigned int (**)(void *))(*v59 + v57);
          }
          unint64_t v60 = v20;
          if (!v57(v59)) {
            goto LABEL_183;
          }
          if (*v87 == -1)
          {
            unint64_t v7 = v82;
            unint64_t v20 = v60;
          }
          else
          {
            unint64_t v7 = v82;
            unint64_t v20 = v60;
            if (*v87 >= *(_DWORD *)(v4 + 112)) {
              goto LABEL_177;
            }
          }
          goto LABEL_163;
        }
        uint64_t v21 = *(void *)(v4 + 80);
        if ((char *)v88 + v20 + 0xFFFF <= (char *)v85) {
          unint64_t v22 = (unint64_t)v88 + v20 + 0xFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)v85;
        }
        if (v22 <= (unint64_t)v88 + v20)
        {
          uint64_t v27 = 0;
          BOOL v24 = (unsigned __int8 *)v88 + v20;
LABEL_53:
          uint64_t v28 = 0;
          if (v24 && v24 != (unsigned __int8 *)v22)
          {
            uint64_t v80 = v27;
            unint64_t v81 = v20;
            uint64_t v84 = (uint64_t)v88 + v20;
            v102[0] = 0;
            unint64_t v90 = v22;
            unint64_t v86 = v22 - (void)v24;
            uint64_t v30 = *(uint64_t **)(v21 + 8);
            uint64_t v29 = *(uint64_t **)(v21 + 16);
            if (v30 != v29)
            {
              uint64_t v91 = (v22 - (unint64_t)v92) >> 1;
              unint64_t v31 = (unint64_t)(int)v20 >> 1;
              uint64_t v83 = *(void **)(v94 + 104);
              do
              {
                if (*(char *)(v21 + 1327) < 0)
                {
                  int v33 = *(const void **)(v21 + 1304);
                  size_t v32 = *(void *)(v21 + 1312);
                }
                else
                {
                  size_t v32 = *(unsigned __int8 *)(v21 + 1327);
                  int v33 = (const void *)(v21 + 1304);
                }
                if (*(char *)(v21 + 1351) < 0)
                {
                  size_t v35 = *(const void **)(v21 + 1328);
                  size_t v34 = *(void *)(v21 + 1336);
                }
                else
                {
                  size_t v34 = *(unsigned __int8 *)(v21 + 1351);
                  size_t v35 = (const void *)(v21 + 1328);
                }
                int v36 = (*(uint64_t (**)(void))(*(void *)*v30 + 160))();
                if (!sub_19E061BA0(v33, v32, v35, v34, v36, v92, v91, v31))
                {
                  int v37 = *(_DWORD *)(*v30 + 52);
                  if (((a3 & 0x40000) != 0 || v37 != 1) && ((a3 & 0x100000) == 0 || (v37 & 0xFFFFFFFD) != 1))
                  {
                    int v38 = ((v86 > 1) & ((*(unsigned int (**)(uint64_t))(*(void *)*v30 + 160))(*v30) | ((a3 & 8) >> 3))) != 0
                        ? 2
                        : 0;
                    uint64_t v39 = (a3 >> 2) & 5 | (a3 >> 4) & 8 | (a3 >> 15) & 0x10 | v38;
                    bzero(v83, 0x3000uLL);
                    unint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *, unint64_t, void, void, int64_t, void *, uint64_t))(*(void *)*v30 + 80))(*v30, v39, v24, v86, *(void *)(v21 + 1288), *(void *)(v21 + 1296), v24 - (unsigned __int8 *)v92, v83, 512);
                    if ((*(unsigned int (**)(void))(*(void *)*v30 + 160))()) {
                      sub_19E061C78((void *)v21, v94, (uint64_t)v102, v40);
                    }
                    else {
                      sub_19E061EC4((void *)v21, v94, v84, (uint64_t)v24, v86, a3, v40, *v30, (uint64_t)v102);
                    }
                    if (v40)
                    {
                      uint64_t v41 = 16;
                      do
                      {
                        sub_19E062044((const void **)(*(void *)(v94 + 104) + v41), 0);
                        v41 += 24;
                        --v40;
                      }
                      while (v40);
                    }
                  }
                }
                v30 += 2;
              }
              while (v30 != v29);
            }
            unint64_t v6 = v77;
            uint64_t v4 = v78;
            a2 = v79;
            if (*(unsigned char *)(v21 + 105))
            {
              sub_19E0E92C0((uint64_t)&v99, (unsigned __int16 *)v24, v86 >> 1);
              if (v101) {
                sub_19E06207C(v21, v94, *(void *)(v21 + 96) + v99, v84, (uint64_t)v24, (_WORD)v24 + 2 * v100, (uint64_t)v102);
              }
            }
            uint64_t v28 = v102[0];
            if ((v7 & 0x80000000) == 0 && v102[0]) {
              goto LABEL_154;
            }
            uint64_t v42 = (char *)&v24[v80];
            if ((unint64_t)&v24[v80] > v90)
            {
              uint64_t v28 = sub_19E06207C(v21, v94, (v7 >> 18), v84, (uint64_t)v24, (unsigned __int16)v24 + (unsigned __int16)v80, (uint64_t)v102);
              goto LABEL_154;
            }
            if ((v7 & 0x40000000) == 0)
            {
              int v43 = 0;
              goto LABEL_121;
            }
            if ((unint64_t)v42 >= v90)
            {
              unint64_t v44 = 0;
              int v43 = &v24[v80];
              goto LABEL_118;
            }
            unint64_t v44 = 0;
            int v43 = &v24[v80];
            int v45 = v7;
            unint64_t v46 = v90;
            while (2)
            {
              unint64_t v47 = v46 - (void)v43;
              if ((*(_DWORD *)(v21 + 304) - 4) <= 2)
              {
                if (v47 < 2)
                {
                  if ((v45 & **(_DWORD **)(v21 + 296) & 0x3FFFF) == 0)
                  {
LABEL_118:
                    if (v43)
                    {
LABEL_119:
                      if (v44 <= *(void *)(v21 + 792)) {
                        sub_19E06207C(v21, v94, (v7 >> 18), v84, (uint64_t)v24, (__int16)v43, (uint64_t)v102);
                      }
LABEL_121:
                      unint64_t v51 = (v7 >> 26) & 0xF;
                      if (!v51)
                      {
LABEL_151:
                        LOWORD(v53) = (_WORD)v42;
LABEL_152:
                        uint64_t v28 = v102[0];
                        uint64_t v4 = v78;
                        a2 = v79;
                        unint64_t v6 = v77;
                        if (!v102[0])
                        {
                          sub_19E06207C(v21, v94, (v7 >> 18), v84, (uint64_t)v24, (__int16)v53, (uint64_t)v102);
                          uint64_t v28 = v102[0];
                        }
                        goto LABEL_154;
                      }
                      unint64_t v52 = 1;
                      while (2)
                      {
                        uint64_t v53 = v43;
                        if (v42 != (char *)v43)
                        {
                          sub_19E06207C(v21, v94, (v7 >> 18), v84, (uint64_t)v24, (__int16)v42, (uint64_t)v102);
                          unint64_t v54 = v90 - (void)v42;
                          if ((*(_DWORD *)(v21 + 304) - 4) > 2)
                          {
                            unsigned __int16 v55 = *v42;
                            if (*v42 < 0)
                            {
                              if (v54 >= 2 && (v55 & 0xE0) == 0xC0)
                              {
                                uint64_t v56 = 2;
                                unsigned __int16 v55 = v42[1] & 0x3F | ((v55 & 0x1F) << 6);
                                goto LABEL_139;
                              }
                              if (v54 >= 3)
                              {
                                if ((v55 & 0xF0) == 0xE0)
                                {
                                  unsigned __int16 v55 = (v55 << 12) | ((v42[1] & 0x3F) << 6) | v42[2] & 0x3F;
                                  uint64_t v56 = 3;
                                  goto LABEL_139;
                                }
                                if (v54 >= 4)
                                {
                                  if ((v55 & 0xF8) == 0xF0)
                                  {
                                    unsigned __int16 v55 = 0;
                                    uint64_t v56 = 4;
                                    goto LABEL_139;
                                  }
                                  if (v54 >= 5)
                                  {
                                    if ((v55 & 0xFC) == 0xF8)
                                    {
                                      unsigned __int16 v55 = 0;
                                      uint64_t v56 = 5;
                                      goto LABEL_139;
                                    }
                                    if (v54 >= 6 && (v55 & 0xFE) == 0xFC)
                                    {
                                      unsigned __int16 v55 = 0;
                                      uint64_t v56 = 6;
                                      goto LABEL_139;
                                    }
                                  }
                                }
                              }
                              unsigned __int16 v55 = 0;
                            }
                            uint64_t v56 = 1;
                            goto LABEL_139;
                          }
                          if (v54 < 2)
                          {
                            uint64_t v56 = 0;
                            unsigned __int16 v55 = 0;
                          }
                          else
                          {
                            unsigned __int16 v55 = *(_WORD *)v42;
                            uint64_t v56 = 2;
                          }
LABEL_139:
                          if ((v7 & 0x3FFFF & *(_DWORD *)(*(void *)(v21 + 296) + 4 * v55)) == 0) {
                            goto LABEL_151;
                          }
                          uint64_t v53 = (unsigned __int8 *)&v42[v56];
                        }
                        if (v52 >= v51) {
                          goto LABEL_152;
                        }
                        ++v52;
                        uint64_t v42 = (char *)v53;
                        if ((unint64_t)v53 > v90) {
                          goto LABEL_152;
                        }
                        continue;
                      }
                    }
                  }
LABEL_154:
                  unint64_t v20 = v81;
                  break;
                }
                unsigned __int16 v48 = *(_WORD *)v43;
                uint64_t v49 = 2;
                goto LABEL_101;
              }
              unsigned __int16 v48 = *v43;
              if ((char)*v43 < 0)
              {
                if (v47 < 2 || (v48 & 0xE0) != 0xC0)
                {
                  if (v47 >= 3)
                  {
                    if ((v48 & 0xF0) == 0xE0)
                    {
                      unsigned __int16 v48 = (v48 << 12) | ((v43[1] & 0x3F) << 6) | v43[2] & 0x3F;
                      uint64_t v49 = 3;
                      goto LABEL_101;
                    }
                    if (v47 >= 4)
                    {
                      if ((v48 & 0xF8) == 0xF0)
                      {
                        unsigned __int16 v48 = 0;
                        uint64_t v49 = 4;
                        goto LABEL_101;
                      }
                      if (v47 >= 5)
                      {
                        if ((v48 & 0xFC) == 0xF8)
                        {
                          unsigned __int16 v48 = 0;
                          uint64_t v49 = 5;
                          goto LABEL_101;
                        }
                        if (v47 >= 6 && (v48 & 0xFE) == 0xFC)
                        {
                          unsigned __int16 v48 = 0;
                          uint64_t v49 = 6;
                          goto LABEL_101;
                        }
                      }
                    }
                  }
                  unsigned __int16 v48 = 0;
                  goto LABEL_97;
                }
                uint64_t v49 = 2;
                unsigned __int16 v48 = v43[1] & 0x3F | ((v48 & 0x1F) << 6);
              }
              else
              {
LABEL_97:
                uint64_t v49 = 1;
              }
LABEL_101:
              int v50 = *(_DWORD *)(*(void *)(v21 + 296) + 4 * v48);
              if ((v45 & v50 & 0x3FFFF) == 0) {
                goto LABEL_119;
              }
              v43 += v49;
              ++v44;
              int v45 = v50;
              unint64_t v46 = v90;
              if ((unint64_t)v43 >= v90) {
                goto LABEL_119;
              }
              continue;
            }
          }
LABEL_155:
          *(void *)(v89 + 8 * v2sub_19E03D880(&a9, 0) = v28;
          goto LABEL_156;
        }
        int v23 = *(_DWORD *)(v21 + 248);
        BOOL v24 = (unsigned __int8 *)v88 + v20;
        while (1)
        {
          unint64_t v25 = v22 - (void)v24;
          if ((*(_DWORD *)(v21 + 304) - 4) > 2)
          {
            unsigned __int16 v26 = *v24;
            if (((char)*v24 & 0x80000000) == 0) {
              goto LABEL_32;
            }
            if (v25 >= 2 && (v26 & 0xE0) == 0xC0)
            {
              uint64_t v27 = 2;
              unsigned __int16 v26 = v24[1] & 0x3F | ((v26 & 0x1F) << 6);
            }
            else
            {
              if (v25 < 3) {
                goto LABEL_51;
              }
              if ((v26 & 0xF0) == 0xE0)
              {
                unsigned __int16 v26 = (v26 << 12) | ((v24[1] & 0x3F) << 6) | v24[2] & 0x3F;
                uint64_t v27 = 3;
              }
              else
              {
                if (v25 < 4) {
                  goto LABEL_51;
                }
                if ((v26 & 0xF8) == 0xF0)
                {
                  unsigned __int16 v26 = 0;
                  uint64_t v27 = 4;
                }
                else
                {
                  if (v25 < 5) {
                    goto LABEL_51;
                  }
                  if ((v26 & 0xFC) == 0xF8)
                  {
                    unsigned __int16 v26 = 0;
                    uint64_t v27 = 5;
                  }
                  else
                  {
                    if (v25 < 6 || (v26 & 0xFE) != 0xFC)
                    {
LABEL_51:
                      unsigned __int16 v26 = 0;
LABEL_32:
                      uint64_t v27 = 1;
                      goto LABEL_36;
                    }
                    unsigned __int16 v26 = 0;
                    uint64_t v27 = 6;
                  }
                }
              }
            }
          }
          else
          {
            if (v25 < 2)
            {
              uint64_t v28 = 0;
              LODWORD(v7) = **(_DWORD **)(v21 + 296);
              if ((v23 & v7 & 0x3FFFF) == 0)
              {
                uint64_t v27 = 0;
                goto LABEL_53;
              }
              goto LABEL_155;
            }
            unsigned __int16 v26 = *(_WORD *)v24;
            uint64_t v27 = 2;
          }
LABEL_36:
          LODWORD(v7) = *(_DWORD *)(*(void *)(v21 + 296) + 4 * v26);
          if ((v23 & v7 & 0x3FFFF) != 0)
          {
            v24 += v27;
            int v23 = *(_DWORD *)(*(void *)(v21 + 296) + 4 * v26);
            if ((unint64_t)v24 < v22) {
              continue;
            }
          }
          goto LABEL_53;
        }
      }
      goto LABEL_177;
    }
    if (v11)
    {
      int v11 = 0;
      goto LABEL_11;
    }
LABEL_183:
    uint64_t v73 = 0;
    goto LABEL_184;
  }
  *(_DWORD *)(v4 + 116) = -1;
  uint64_t v12 = *(void *)v89;
  if (!*(void *)v89)
  {
    uint64_t v16 = sub_19E063788(*(void *)(v4 + 80), (unint64_t)v88, v85, v94, a3);
    *(void *)uint64_t v89 = v16;
    uint64_t v17 = *(uint64_t (**)(void *, void, uint64_t, uint64_t *, uint64_t, uint64_t))(v4 + 120);
    uint64_t v18 = *(void *)(v4 + 128);
    size_t v19 = (void *)(v4 + (v18 >> 1));
    if (v18) {
      uint64_t v17 = *(uint64_t (**)(void *, void, uint64_t, uint64_t *, uint64_t, uint64_t))(*v19 + v17);
    }
    char v66 = v17(v19, 0, v16, v6, v94, v4 + 116);
LABEL_176:
    if (v66) {
      goto LABEL_177;
    }
    goto LABEL_183;
  }
  unsigned int v13 = *(unsigned int (**)(void *, void, uint64_t, uint64_t *, uint64_t, uint64_t))(v4 + 120);
  uint64_t v14 = *(void *)(v4 + 128);
  uint64_t v15 = (void *)(v4 + (v14 >> 1));
  if (v14) {
    unsigned int v13 = *(unsigned int (**)(void *, void, uint64_t, uint64_t *, uint64_t, uint64_t))(*v15
  }
                                                                                                + v13);
  if (!v13(v15, 0, v12, v6, v94, v4 + 116)) {
    goto LABEL_183;
  }
  uint64_t v61 = *(unsigned __int16 *)(v12 + 98);
  if (v6[v61])
  {
    uint64_t v62 = sub_19E063788(*(void *)(v4 + 80), (unint64_t)v88 + v61, v85, v94, a3);
    *(void *)(v89 + 8 * v61) = v62;
    long long v63 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t))(v4 + 120);
    uint64_t v64 = *(void *)(v4 + 128);
    long long v65 = (void *)(v4 + (v64 >> 1));
    if (v64) {
      long long v63 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t))(*v65 + v63);
    }
    char v66 = v63(v65, v61, v62, v6, v94, v4 + 116);
    goto LABEL_176;
  }
LABEL_177:
  uint64_t v67 = *(void *)(v4 + 80);
  uint64_t v68 = sub_19E0609C8(*(void **)(v94 + 16));
  *(_OWORD *)(v68 + 96) = 0u;
  *(_OWORD *)(v68 + 112) = 0u;
  *(_OWORD *)(v68 + 64) = 0u;
  *(_OWORD *)(v68 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(v68 + 32) = 0u;
  *(_OWORD *)(v68 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)uint64_t v68 = 0u;
  *(_OWORD *)(v68 + 16) = 0u;
  uint64_t v69 = *(void *)(v67 + 136);
  *(unsigned char *)(v68 + 124) = 3;
  *(void *)(v68 + 4++**(_DWORD **)(result + 8) = v85;
  *(void *)(v68 + 56) = v69;
  *(void *)(v89 + 8 * v7) = v68;
  if (v6[v7])
  {
    long long v70 = *(unsigned int (**)(void *, unint64_t, uint64_t, uint64_t *, uint64_t, uint64_t))(v4 + 120);
    uint64_t v71 = *(void *)(v4 + 128);
    long long v72 = (void *)(v4 + (v71 >> 1));
    if (v71) {
      long long v70 = *(unsigned int (**)(void *, unint64_t, uint64_t, uint64_t *, uint64_t, uint64_t))(*v72 + v70);
    }
    if (!v70(v72, v7, v68, v6, v94, v4 + 116)) {
      goto LABEL_183;
    }
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 168))(a2, 32, v68))
  {
    sub_19E0607DC(a2);
  }
  else
  {
    char v75 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
    uint64_t v76 = (void *)*v75;
    if (*v75)
    {
      do
      {
        v76[1] = v75;
        char v75 = v76;
        uint64_t v76 = (void *)*v76;
      }
      while (v76);
    }
  }
  uint64_t v73 = 1;
LABEL_184:
  v96((uint64_t)v95);
  return v73;
}

void sub_19E05FE54(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(v1 - 144))(v1 - 160);
  _Unwind_Resume(a1);
}

void sub_19E05FE88(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  std::mutex::lock((std::mutex *)(v1 + 16));
  *(_DWORD *)(v1 + ++**(_DWORD **)(result + 8) = 0;

  std::mutex::unlock((std::mutex *)(v1 + 16));
}

uint64_t sub_19E05FECC(uint64_t a1)
{
  v52[5] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 200))(a1);
  (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
  unint64_t v4 = v3 + 1;
  unint64_t v6 = *(void *)(v2 + 72);
  unint64_t v5 = *(unsigned char **)(v2 + 80);
  int64_t v7 = (int64_t)&v5[-v6];
  size_t v8 = v3 + 1 - (void)&v5[-v6];
  if (v3 + 1 <= (unint64_t)&v5[-v6])
  {
    if (v3 + 1 < (unint64_t)&v5[-v6]) {
      *(void *)(v2 + 8sub_19E03D880(&a9, 0) = v6 + v4;
    }
  }
  else
  {
    uint64_t v9 = *(void *)(v2 + 88);
    if (v9 - (uint64_t)v5 >= v8)
    {
      bzero(*(void **)(v2 + 80), v8);
      *(void *)(v2 + 8sub_19E03D880(&a9, 0) = &v5[v8];
    }
    else
    {
      if ((v4 & 0x8000000000000000) != 0) {
        sub_19E041BEC();
      }
      unint64_t v10 = v9 - v6;
      uint64_t v11 = 2 * v10;
      if (2 * v10 <= v4) {
        uint64_t v11 = v3 + 1;
      }
      if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v12 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v12 = v11;
      }
      unsigned int v13 = operator new(v12);
      uint64_t v14 = (char *)v13 + v12;
      uint64_t v15 = (char *)v13 + v4;
      bzero((char *)v13 + v7, v8);
      if (v5 == (unsigned char *)v6)
      {
        unsigned int v13 = (char *)v13 + v7;
      }
      else
      {
        uint64_t v16 = &v5[~v6];
        do
        {
          char v17 = *--v5;
          (v16--)[(void)v13] = v17;
        }
        while (v5 != (unsigned char *)v6);
        unint64_t v5 = *(unsigned char **)(v2 + 72);
      }
      *(void *)(v2 + 72) = v13;
      *(void *)(v2 + 8sub_19E03D880(&a9, 0) = v15;
      *(void *)(v2 + 8++**(_DWORD **)(result + 8) = v14;
      if (v5) {
        operator delete(v5);
      }
    }
    unint64_t v6 = *(void *)(v2 + 72);
  }
  uint64_t v18 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  size_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
  memcpy((void *)v6, v18, v19);
  std::string __p = 0;
  unint64_t v51 = 0;
  v52[0] = 0;
  uint64_t v49 = a1;
  uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
  uint64_t v21 = 0;
  unint64_t v22 = 0;
  int v23 = 0;
  unint64_t v24 = 0;
  unint64_t v25 = (char *)(v6 + (v20 & 0xFFFFFFFFFFFFFFFELL));
  uint64_t v26 = 1;
  while (v24 != 0xFFFF)
  {
    unint64_t v27 = v24;
    uint64_t v28 = v26;
    uint64_t v29 = (char *)v6;
    if (v6 < (unint64_t)v25)
    {
      uint64_t v29 = (char *)v6;
      do
      {
        if (*(_WORD *)v29 == 10) {
          break;
        }
        v29 += 2;
      }
      while (v29 < v25);
    }
    if ((unint64_t)v21 >= v22)
    {
      uint64_t v30 = (v21 - v23) >> 3;
      unint64_t v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 61) {
        sub_19E041BEC();
      }
      if ((uint64_t)(v22 - (void)v23) >> 2 > v31) {
        unint64_t v31 = (uint64_t)(v22 - (void)v23) >> 2;
      }
      if (v22 - (unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v32 = v31;
      }
      if (v32) {
        unint64_t v32 = (unint64_t)sub_19E060B48(v32);
      }
      else {
        uint64_t v33 = 0;
      }
      size_t v34 = (unint64_t *)(v32 + 8 * v30);
      *size_t v34 = v6;
      size_t v35 = (char *)(v34 + 1);
      if (v21 != v23)
      {
        do
        {
          unint64_t v36 = *((void *)v21 - 1);
          v21 -= 8;
          *--size_t v34 = v36;
        }
        while (v21 != v23);
        uint64_t v21 = v23;
      }
      int v23 = (char *)v34;
      unint64_t v22 = v32 + 8 * v33;
      if (v21) {
        operator delete(v21);
      }
      uint64_t v21 = v35;
    }
    else
    {
      *(void *)uint64_t v21 = v6;
      v21 += 8;
    }
    int64_t v37 = (int64_t)&v29[-v6];
    int v38 = v51;
    if ((unint64_t)v51 >= v52[0])
    {
      unint64_t v40 = (char *)__p;
      uint64_t v41 = (v51 - (char *)__p) >> 3;
      unint64_t v42 = v41 + 1;
      if ((unint64_t)(v41 + 1) >> 61) {
        sub_19E041BEC();
      }
      uint64_t v43 = v52[0] - (void)__p;
      if ((uint64_t)(v52[0] - (void)__p) >> 2 > v42) {
        unint64_t v42 = v43 >> 2;
      }
      if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v44 = v42;
      }
      if (v44)
      {
        int v45 = (char *)sub_19E049FB0((uint64_t)v52, v44);
        unint64_t v40 = (char *)__p;
        int v38 = v51;
      }
      else
      {
        int v45 = 0;
      }
      unint64_t v46 = (int64_t *)&v45[8 * v41];
      *unint64_t v46 = v37;
      uint64_t v39 = (char *)(v46 + 1);
      while (v38 != v40)
      {
        int64_t v47 = *((void *)v38 - 1);
        v38 -= 8;
        *--unint64_t v46 = v47;
      }
      std::string __p = v46;
      v52[0] = &v45[8 * v44];
      if (v40) {
        operator delete(v40);
      }
    }
    else
    {
      *(void *)unint64_t v51 = v37;
      uint64_t v39 = v51 + 8;
    }
    unint64_t v51 = v39;
    unint64_t v24 = v27 + 1;
    unint64_t v6 = (unint64_t)(v29 + 2);
    uint64_t v26 = v28 + 1;
    if (v29 == v25)
    {
      if (v27 <= 0xFFFD)
      {
        sub_19E060980(v24);
        v52[3] = 0;
        v52[4] = 0;
        (*(void (**)(uint64_t))(*(void *)v49 + 88))(v49);
        operator new[]();
      }
      break;
    }
  }
  if (__p) {
    operator delete(__p);
  }
  if (v23) {
    operator delete(v23);
  }
  return 0;
}

void sub_19E060748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  sub_19E06FFE8((uint64_t)&a15);
  MEMORY[0x19F3BA6E0](a9, 0x1000C8077774924);
  if (v22) {
    operator delete(v22);
  }
  if (__p)
  {
    a21 = (uint64_t)__p;
    operator delete(__p);
  }
  if (v21) {
    operator delete(v21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E0607DC(uint64_t a1)
{
  uint64_t v2 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  uint64_t v3 = (void *)*v2;
  if (*v2)
  {
    do
    {
      v3[1] = v2;
      uint64_t v2 = v3;
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  if ((v5 & 0x8000000000000000) == 0)
  {
    uint64_t v7 = 0;
    do
    {
      for (uint64_t i = *(uint64_t **)(result + 8 * v7); i; uint64_t i = (uint64_t *)i[3])
      {
        *(void *)(v4 + ++**(_DWORD **)(result + 8) = i;
        *uint64_t i = v4;
        uint64_t v4 = (uint64_t)i;
      }
    }
    while (v7++ != v5);
  }
  return result;
}

unint64_t sub_19E0608F8(uint64_t a1)
{
  mach_msg_type_number_t v4 = 15;
  host_t v1 = MEMORY[0x19F3BAA90](a1);
  if (host_statistics(v1, 2, host_info_out, &v4)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *MEMORY[0x1E4F14B00] * host_info_out[0];
  if (v3 <= 0x100000) {
    return 0;
  }
  if (v3 >= 2148532223) {
    LODWORD(v3) = -2146435073;
  }
  return (v3 - 0x100000) / 0x18uLL;
}

void *sub_19E060980(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    sub_19E0416C4();
  }
  return operator new(24 * a1);
}

uint64_t sub_19E0609C8(void *a1)
{
  uint64_t v1 = a1[5];
  uint64_t v2 = a1[4];
  if (v2 == a1[6])
  {
    uint64_t v2 = 0;
    ++v1;
    a1[4] = 0;
    a1[5] = v1;
  }
  uint64_t v3 = a1[1];
  if (v1 == (a1[2] - v3) >> 3) {
    operator new[]();
  }
  uint64_t v4 = *(void *)(v3 + 8 * v1);
  a1[4] = v2 + 1;
  uint64_t v5 = v4 + (v2 << 7);
  sub_19E060B80((const void **)(v5 + 104), 0);
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  return v5;
}

void *sub_19E060B48(unint64_t a1)
{
  if (a1 >> 61) {
    sub_19E0416C4();
  }
  return operator new(8 * a1);
}

void sub_19E060B80(const void **a1, const void *a2)
{
  uint64_t v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

uint64_t sub_19E060BB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (!a3) {
    return 1;
  }
  uint64_t v8 = a3;
  uint64_t v25 = a2;
  uint64_t v26 = a4;
  while (1)
  {
    uint64_t v10 = *(void *)(a4 + 8 * a2);
    if (v10)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0x7FFFFFFFFFFFFFFFLL;
      do
      {
        if ((!*(unsigned char *)(v10 + 122) || *(int *)(v10 + 80) <= 20000)
          && (!*(unsigned char *)(v8 + 122) || *(int *)(v8 + 80) <= 20000))
        {
          int v13 = sub_19E060D8C(*(void *)(a1 + 88), *(unsigned __int16 *)(v10 + 100), *(unsigned __int16 *)(v8 + 102));
          if (v13 <= 32766)
          {
            uint64_t v14 = *(int *)(v8 + 80) + (uint64_t)v13;
            if (*(void *)(v10 + 112) + v14 < v12)
            {
              uint64_t v12 = *(void *)(v10 + 112) + v14;
              uint64_t v11 = v10;
            }
            uint64_t v15 = sub_19E060E20(a5);
            *((_DWORD *)v15 + 4) = v14;
            int v16 = *a6;
            if (*a6 != -1 && v16 < *(_DWORD *)(a1 + 112)) {
              *a6 = v16 + 1;
            }
            uint64_t v17 = *(void *)(v8 + 40);
            void *v15 = v10;
            v15[1] = v17;
            *(void *)(v8 + 4sub_19E03D880(&a9, 0) = v15;
            *(void *)(v10 + 32) = v15;
          }
        }
        uint64_t v10 = *(void *)(v10 + 16);
      }
      while (v10);
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0x7FFFFFFFFFFFFFFFLL;
    }
    if (*(void *)(v8 + 40)) {
      goto LABEL_30;
    }
    uint64_t v18 = *(void *)(v26 + 8 * v25);
    if (!v18) {
      goto LABEL_30;
    }
    uint64_t v24 = *(int *)(v8 + 80)
        + (uint64_t)(int)sub_19E05DDEC(*(void *)(a1 + 88), *(unsigned __int16 *)(v18 + 100), *(unsigned __int16 *)(v8 + 102));
    uint64_t v19 = *(void *)(v18 + 112) + v24;
    uint64_t v21 = sub_19E060E20(a5);
    *((_DWORD *)v21 + 4) = v24;
    uint64_t v22 = *(void *)(v8 + 40);
    void *v21 = v18;
    v21[1] = v22;
    *(void *)(v8 + 4sub_19E03D880(&a9, 0) = v21;
    *(void *)(v18 + 32) = v21;
    if (v19 >= v12)
    {
LABEL_30:
      uint64_t v18 = v11;
      uint64_t v19 = v12;
      if (!v11) {
        return 0;
      }
    }
    *(void *)uint64_t v8 = v18;
    *(void *)(v8 + ++**(_DWORD **)(result + 8) = 0;
    *(void *)(v8 + 112) = v19;
    a2 = v25;
    a4 = v26;
    uint64_t v20 = *(unsigned __int16 *)(v8 + 98) + v25;
    *(void *)(v8 + 16) = *(void *)(v26 + 8 * v20);
    *(void *)(v26 + 8 * v2sub_19E03D880(&a9, 0) = v8;
    uint64_t v8 = *(void *)(v8 + 24);
    if (!v8) {
      return 1;
    }
  }
}

uint64_t sub_19E060D8C(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(_DWORD *)(v4 + 4 * (a2 + 1));
  int v6 = *(_DWORD *)(v4 + 4 * a2);
  if (v5 - v6 == *(unsigned __int16 *)(a1 + 34)) {
    return *(__int16 *)(*(void *)(a1 + 24) + 2 * (v6 + a3));
  }
  int v8 = a3 | (a2 << 16);
  uint64_t v9 = *(_DWORD *)(a1 + 36) & (3 * a2 + a3);
  uint64_t v10 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v10 + 4 * v9) == v8) {
    return *(unsigned int *)(*(void *)(a1 + 48) + 4 * v9);
  }
  *(_DWORD *)(v10 + 4 * v9) = v8;
  uint64_t result = sub_19E05DE20((void *)a1, a2, a3);
  *(_DWORD *)(*(void *)(a1 + 48) + 4 * v9) = result;
  return result;
}

void *sub_19E060E20(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (!v1) {
    operator new();
  }
  uint64_t v2 = v1[5];
  unint64_t v3 = v1[6];
  uint64_t v4 = v1[4];
  if (v4 == v3)
  {
    uint64_t v4 = 0;
    ++v2;
    v1[4] = 0;
    v1[5] = v2;
  }
  uint64_t v5 = v1[1];
  if (v2 == (v1[2] - v5) >> 3)
  {
    is_mul_ok(v3, 0x18uLL);
    operator new[]();
  }
  uint64_t v6 = *(void *)(v5 + 8 * v2);
  v1[4] = v4 + 1;
  uint64_t result = (void *)(v6 + 24 * v4);
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

void sub_19E061008(void *a1)
{
  sub_19E061040(a1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E061040(void *a1)
{
  *a1 = &unk_1EF09C4B0;
  a1[5] = 0;
  uint64_t v4 = a1 + 1;
  uint64_t v2 = (void *)a1[1];
  unint64_t v3 = (void *)v4[1];
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (!v3) {
      return a1;
    }
    goto LABEL_7;
  }
  unint64_t v5 = 0;
  do
  {
    if (v2[v5])
    {
      MEMORY[0x19F3BA6E0](v2[v5], 0x1020C80EDCEB4C7);
      unint64_t v5 = a1[5];
      uint64_t v2 = (void *)a1[1];
      unint64_t v3 = (void *)a1[2];
    }
    a1[5] = ++v5;
  }
  while (v5 < v3 - v2);
  if (v2)
  {
LABEL_7:
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_19E0610EC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  std::mutex::lock((std::mutex *)(v1 + 16));
  *(_DWORD *)(v1 + ++**(_DWORD **)(result + 8) = 0;

  std::mutex::unlock((std::mutex *)(v1 + 16));
}

void sub_19E061130(uint64_t a1)
{
  sub_19E061168(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E061168(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C270;
  sub_19E061474((void *)a1);
  uint64_t v2 = *(void ***)(a1 + 1360);
  unint64_t v3 = *(void ***)(a1 + 1368);
  *(void *)(a1 + 1392) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v2 = (void **)(*(void *)(a1 + 1360) + 8);
      *(void *)(a1 + 136sub_19E03D880(&a9, 0) = v2;
      unint64_t v3 = *(void ***)(a1 + 1368);
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 2048;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 4096;
LABEL_7:
    *(void *)(a1 + 1384) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v8 = *(void *)(a1 + 1360);
    uint64_t v9 = *(void *)(a1 + 1368);
    if (v9 != v8) {
      *(void *)(a1 + 136++**(_DWORD **)(result + 8) = v9 + ((v8 - v9 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  uint64_t v10 = *(void **)(a1 + 1352);
  if (v10) {
    operator delete(v10);
  }
  if (*(char *)(a1 + 1351) < 0) {
    operator delete(*(void **)(a1 + 1328));
  }
  if (*(char *)(a1 + 1327) < 0) {
    operator delete(*(void **)(a1 + 1304));
  }
  if (*(char *)(a1 + 1087) < 0) {
    operator delete(*(void **)(a1 + 1064));
  }
  uint64_t v11 = MEMORY[0x1E4FBA418];
  uint64_t v12 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 80sub_19E03D880(&a9, 0) = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 800 + *(void *)(v12 - 24)) = *(void *)(v11 + 24);
  *(void *)(a1 + 80++**(_DWORD **)(result + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 895) < 0) {
    operator delete(*(void **)(a1 + 872));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 912);
  sub_19E0614BC(a1 + 256);
  int v13 = *(void **)(a1 + 216);
  if (v13)
  {
    *(void *)(a1 + 224) = v13;
    operator delete(v13);
  }
  sub_19E061614((void *)(a1 + 160));
  *(void *)(a1 + 144) = &unk_1EF09C230;
  uint64_t v14 = *(void *)(a1 + 152);
  if (v14) {
    MEMORY[0x19F3BA6E0](v14, 0x1000C8077774924);
  }
  *(void *)(a1 + 12++**(_DWORD **)(result + 8) = &unk_1EF09C230;
  uint64_t v15 = *(void *)(a1 + 136);
  if (v15) {
    MEMORY[0x19F3BA6E0](v15, 0x1000C8077774924);
  }
  int v16 = *(std::__shared_weak_count **)(a1 + 88);
  if (v16) {
    sub_19E0616BC(v16);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 72);
  if (v17) {
    sub_19E0616BC(v17);
  }
  uint64_t v18 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t v20 = (void **)(a1 + 32);
  sub_19E061730(&v20);
  uint64_t v20 = (void **)(a1 + 8);
  sub_19E061730(&v20);
  return a1;
}

uint64_t sub_19E061474(void *a1)
{
  sub_19E061784(a1 + 1);
  sub_19E061784(a1 + 4);
  a1[28] = a1[27];
  uint64_t v2 = sub_19E06CA50();
  uint64_t result = sub_19E06CB24(v2, a1[33]);
  a1[33] = 0;
  return result;
}

uint64_t sub_19E0614BC(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C188;
  uint64_t v2 = sub_19E06CA50();
  sub_19E06CB24(v2, *(void *)(a1 + 8));
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  if (*(char *)(a1 + 343) < 0) {
    operator delete(*(void **)(a1 + 320));
  }
  uint64_t v3 = MEMORY[0x1E4FBA418];
  uint64_t v4 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 56) = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 56 + *(void *)(v4 - 24)) = *(void *)(v3 + 24);
  *(void *)(a1 + 64) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 168);
  unint64_t v5 = *(void **)(a1 + 16);
  if (v5)
  {
    *(void *)(a1 + 24) = v5;
    operator delete(v5);
  }
  return a1;
}

void *sub_19E061614(void *a1)
{
  *a1 = &unk_1EF09C4D0;
  a1[5] = 0;
  uint64_t v4 = a1 + 1;
  uint64_t v2 = (void *)a1[1];
  uint64_t v3 = (void *)v4[1];
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (!v3) {
      return a1;
    }
    goto LABEL_7;
  }
  unint64_t v5 = 0;
  do
  {
    if (v2[v5])
    {
      MEMORY[0x19F3BA6E0](v2[v5], 0x1070C802D7A0B02);
      unint64_t v5 = a1[5];
      uint64_t v2 = (void *)a1[1];
      uint64_t v3 = (void *)a1[2];
    }
    a1[5] = ++v5;
  }
  while (v5 < v3 - v2);
  if (v2)
  {
LABEL_7:
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_19E0616BC(std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void sub_19E061730(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_19E061784((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_19E061784(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      sub_19E0616BC(v4);
    }
  }
  a1[1] = v2;
}

void sub_19E0617D0(void *a1)
{
  *a1 = &unk_1EF09C230;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x19F3BA6E0](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06184C(void *a1)
{
  *a1 = &unk_1EF09C230;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
  }
  return a1;
}

void sub_19E0618A8(void *a1)
{
  sub_19E061614(a1);

  JUMPOUT(0x19F3BA710);
}

void sub_19E0618E4(uint64_t a1)
{
  sub_19E0614BC(a1);

  JUMPOUT(0x19F3BA710);
}

void sub_19E061924(void *a1)
{
  *a1 = &unk_1EF09C290;
  a1[1] = 0;
  sub_19E0619B4((int)a1, "");
}

void sub_19E061970(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_1EF09C230;
  uint64_t v3 = v1[1];
  if (v3) {
    MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E0619B4(int a1, char *__s)
{
}

void sub_19E061A2C(void *a1)
{
  *a1 = &unk_1EF09C230;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x19F3BA6E0](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E061AA8(void *a1)
{
  *a1 = &unk_1EF09C230;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
  }
  return a1;
}

uint64_t sub_19E061B08(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E061B2C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF09AA98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x19F3BA710);
}

void sub_19E061B80(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF09AA98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL sub_19E061BA0(const void *a1, size_t a2, const void *a3, size_t a4, int a5, unsigned __int16 *a6, uint64_t a7, uint64_t a8)
{
  BOOL result = sub_19E0629E0(a1, a2, "ko", 2uLL);
  if (result)
  {
    BOOL v15 = sub_19E0629E0(a3, a4, "en", 2uLL);
    BOOL result = 0;
    if (a8)
    {
      if (v15 && a5)
      {
        if (a7)
        {
          uint64_t v16 = 2 * a7;
          uint64_t v17 = a6;
          while (1)
          {
            unint64_t v18 = *v17;
            if (v18 > 0xFF || (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v18 + 60) & 0x400) == 0) {
              break;
            }
            ++v17;
            v16 -= 2;
            if (!v16)
            {
              uint64_t v17 = &a6[a7];
              return a8 != v17 - a6;
            }
          }
        }
        else
        {
          uint64_t v17 = a6;
        }
        return a8 != v17 - a6;
      }
    }
  }
  return result;
}

void *sub_19E061C78(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v23[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  if (result[10])
  {
    uint64_t v4 = result;
    if (*((unsigned char *)result + 105))
    {
      if (*((char *)result + 1351) < 0)
      {
        uint64_t v7 = (void *)result[166];
        uint64_t v8 = result[167];
      }
      else
      {
        uint64_t v7 = result + 166;
        uint64_t v8 = *((unsigned __int8 *)result + 1351);
      }
      if (v8 == 5)
      {
        unsigned int v9 = bswap32(*(_DWORD *)v7);
        if (v9 == 1701732181) {
          int v10 = *((unsigned __int8 *)v7 + 4) - 83;
        }
        else {
          int v10 = v9 < 0x656E5F55 ? -1 : 1;
        }
        BOOL v11 = v10 == 0;
      }
      else
      {
        BOOL v11 = 0;
      }
      uint64_t v12 = *(void *)(result[27] + 16 * (v11 + result[12]));
      uint64_t v18 = *(void *)(a2 + 104);
      uint64_t v19 = v12;
      unint64_t v17 = 0;
      if (a4)
      {
        for (unint64_t i = 0; i < a4; v17 = i)
        {
          uint64_t v14 = v18;
          BOOL v15 = operator new(0x38uLL);
          void *v15 = &unk_1EF09A958;
          v15[1] = &v20;
          void v15[2] = v4;
          uint64_t v15[3] = &v19;
          void v15[4] = &v18;
          v15[5] = &v17;
          v15[6] = a3;
          void v21[3] = v15;
          uint64_t v16 = *(void *)(v14 + 24 * i + 16);
          if (v16)
          {
            v22[0] = MEMORY[0x1E4F143A8];
            v22[1] = 1174405120;
            _DWORD v22[2] = sub_19E0A96C4;
            v22[3] = &unk_1EF09D1A8;
            sub_19E0A9718((uint64_t)v23, (uint64_t)v21);
            (*(void (**)(uint64_t, void *))(*(void *)(v16 + 16) + 48))(v16 + 16, v22);
            sub_19E0626C4(v23);
          }
          BOOL result = sub_19E0626C4(v21);
          unint64_t i = v17 + 1;
        }
      }
    }
  }
  return result;
}

void sub_19E061E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_19E0626C4(v5);
  sub_19E0626C4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_19E061EC4(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unint64_t a7, uint64_t a8, uint64_t a9)
{
  v25[4] = *MEMORY[0x1E4F143B8];
  uint64_t v23 = a3;
  uint64_t v24 = a2;
  uint64_t v21 = a5;
  uint64_t v22 = a4;
  int v20 = a6;
  uint64_t v19 = a8;
  int v18 = *(_DWORD *)(a8 + 52);
  uint64_t v9 = *(void *)(a2 + 104);
  unint64_t v16 = 0;
  uint64_t v17 = v9;
  if (a7)
  {
    BOOL v11 = result;
    for (unint64_t i = 0; i < a7; v16 = i)
    {
      uint64_t v13 = v19;
      uint64_t v14 = v17;
      BOOL v15 = operator new(0x60uLL);
      void *v15 = &unk_1EF09A8A8;
      v15[1] = &v24;
      void v15[2] = &v19;
      uint64_t v15[3] = &v20;
      void v15[4] = &v17;
      v15[5] = &v16;
      v15[6] = &v21;
      v15[7] = &v22;
      v15[8] = &v23;
      v15[9] = &v18;
      v15[10] = a9;
      void v15[11] = v11;
      v25[3] = v15;
      (*(void (**)(uint64_t, unint64_t, void *))(*(void *)v13 + 144))(v13, v14 + 24 * i, v25);
      BOOL result = sub_19E0621CC(v25);
      unint64_t i = v16 + 1;
    }
  }
  return result;
}

void sub_19E062028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_19E0621CC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E062044(const void **a1, const void *a2)
{
  uint64_t v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

uint64_t sub_19E06207C(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4, uint64_t a5, __int16 a6, uint64_t a7)
{
  uint64_t v8 = (uint64_t *)(*(void *)(a1 + 216) + 16 * a3);
  uint64_t v9 = v8[1];
  if (!v9) {
    return *(void *)a7;
  }
  uint64_t v14 = *v8;
  __int16 v15 = a6 - a5;
  int v23 = 5000 * (unsigned __int16)(a6 - a5);
  __int16 v16 = a6 - a4;
  do
  {
    uint64_t v17 = sub_19E0609C8(*(void **)(a2 + 16));
    *(_OWORD *)(v17 + 96) = 0u;
    *(_OWORD *)(v17 + 112) = 0u;
    *(_OWORD *)(v17 + 64) = 0u;
    *(_OWORD *)(v17 + 8sub_19E03D880(&a9, 0) = 0u;
    *(_OWORD *)(v17 + 32) = 0u;
    *(_OWORD *)(v17 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)uint64_t v17 = 0u;
    *(_OWORD *)(v17 + 16) = 0u;
    int v18 = *(_DWORD **)(a1 + 56);
    HIDWORD(v19) = *(_DWORD *)v14;
    LODWORD(v19) = *(_DWORD *)v14;
    *(_DWORD *)(v17 + 10sub_19E03D880(&a9, 0) = v19 >> 16;
    *(_DWORD *)(v17 + 64) = *(_DWORD *)(v14 + 8) + (v18[13] << 28);
    int v20 = *(__int16 *)(v14 + 6);
    *(_DWORD *)(v17 + 76) = v20;
    *(_DWORD *)(v17 + 8sub_19E03D880(&a9, 0) = v20;
    uint64_t v21 = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)v18 + 152))(v18, v14);
    *(void *)(v17 + 4++**(_DWORD **)(result + 8) = a5;
    *(void *)(v17 + 56) = v21;
    *(_WORD *)(v17 + 96) = v15;
    if (!a3) {
      *(_DWORD *)(v17 + 80) += v23;
    }
    v14 += 12;
    *(_WORD *)(v17 + 9++**(_DWORD **)(result + 8) = v16;
    *(void *)(v17 + 24) = *(void *)a7;
    *(unsigned char *)(v17 + 124) = 1;
    *(_DWORD *)(v17 + 72) = 0;
    *(unsigned char *)(v17 + 123) = *(unsigned char *)(*(void *)(a1 + 56) + 656);
    *(void *)a7 = v17;
    --v9;
  }
  while (v9);
  return v17;
}

void *sub_19E0621CC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_19E062250()
{
  return &unk_1EF0997B8;
}

uint64_t sub_19E06225C(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF0997B8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

int32x2_t sub_19E06229C(uint64_t a1, uint64_t *a2, const void **a3)
{
  uint64_t v3 = *a2;
  if ((*(_WORD *)(*a2 + 4) & 0x40) == 0)
  {
    unint64_t v5 = *a3;
    uint64_t v6 = *(void *)(a1 + 88);
    uint64_t v7 = sub_19E0609C8(*(void **)(**(void **)(a1 + 8) + 16));
    *(_OWORD *)(v7 + 96) = 0u;
    *(_OWORD *)(v7 + 112) = 0u;
    *(_OWORD *)(v7 + 64) = 0u;
    *(_OWORD *)(v7 + 8sub_19E03D880(&a9, 0) = 0u;
    *(_OWORD *)(v7 + 32) = 0u;
    *(_OWORD *)(v7 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)uint64_t v7 = 0u;
    *(_OWORD *)(v7 + 16) = 0u;
    uint64_t v8 = **(_DWORD ***)(a1 + 16);
    HIDWORD(v9) = *(_DWORD *)v3;
    LODWORD(v9) = *(_DWORD *)v3;
    *(_DWORD *)(v7 + 10sub_19E03D880(&a9, 0) = v9 >> 16;
    *(_DWORD *)(v7 + 64) = *(_DWORD *)(v3 + 8) + (v8[13] << 28);
    int v10 = *(__int16 *)(v3 + 6);
    *(_DWORD *)(v7 + 76) = v10;
    *(_DWORD *)(v7 + 8sub_19E03D880(&a9, 0) = v10;
    *(void *)(v7 + 56) = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)v8 + 152))(v8, v3);
    if (v5) {
      sub_19E062580((const void **)(v7 + 104), v5);
    }
    uint64_t v12 = *(int **)(a1 + 24);
    if ((*v12 & 2) != 0)
    {
      if ((*v12 & 0x10) != 0) {
        __int16 v19 = *(_WORD *)(**(void **)(a1 + 32) + 24 * **(void **)(a1 + 40) + 12);
      }
      else {
        __int16 v19 = **(_WORD **)(a1 + 48);
      }
      *(_WORD *)(v7 + 96) = v19;
      uint64_t v18 = **(void **)(a1 + 56);
      *(_WORD *)(v7 + 9++**(_DWORD **)(result + 8) = v18 - **(_DWORD **)(a1 + 64) + **(_DWORD **)(a1 + 48);
      uint64_t v13 = *(uint64_t **)(a1 + 32);
      uint64_t v14 = *v13;
      uint64_t v15 = **(void **)(a1 + 40);
    }
    else
    {
      uint64_t v13 = *(uint64_t **)(a1 + 32);
      uint64_t v14 = *v13;
      uint64_t v15 = **(void **)(a1 + 40);
      unint64_t v16 = *(unsigned __int16 *)(*v13 + 24 * v15 + 12);
      *(_WORD *)(v7 + 96) = v16;
      unint64_t v17 = **(void **)(a1 + 48);
      if (v17 < v16)
      {
        *(_WORD *)(v7 + 96) = v17;
        LOWORD(v16) = v17;
      }
      uint64_t v18 = **(void **)(a1 + 56);
      *(_WORD *)(v7 + 9++**(_DWORD **)(result + 8) = v16 + v18 - **(_WORD **)(a1 + 64);
    }
    int v20 = *(int **)(a1 + 72);
    if (*v20 == 2) {
      int v21 = 0;
    }
    else {
      int v21 = *(_DWORD *)(v14 + 24 * v15 + 8) + (*v20 << 28);
    }
    int v22 = *(unsigned __int8 *)(v14 + 24 * v15);
    *(_DWORD *)(v7 + 72) = v21;
    *(unsigned char *)(v7 + 123) = *(unsigned char *)(**(void **)(a1 + 16) + 656);
    *(void *)(v7 + 4++**(_DWORD **)(result + 8) = v18;
    int v23 = *v20;
    __int16 v24 = *(_WORD *)(v3 + 4);
    if (v23 == 7)
    {
      char v25 = 9;
    }
    else if ((v24 & 2) != 0)
    {
      char v25 = 5;
    }
    else if ((v24 & 3) == 0 || v23 == 6)
    {
      char v25 = 6;
    }
    else
    {
      char v25 = 0;
    }
    *(unsigned char *)(v7 + 124) = v25;
    unint64_t v27 = *(uint64_t **)(a1 + 80);
    *(void *)(v7 + 24) = *v27;
    *(unsigned char *)(v7 + 122) = v22;
    if (v23 == 8) {
      v24 |= 0x10u;
    }
    *(_WORD *)(v7 + 12sub_19E03D880(&a9, 0) = v24;
    int v28 = *v12;
    if ((v28 & 0x80) == 0)
    {
      if ((v28 & 0x1580) == 0) {
        goto LABEL_36;
      }
      goto LABEL_33;
    }
    if ((v28 & 0x80000) == 0 || !v22 || (v24 & 2) != 0)
    {
LABEL_33:
      if (*(unsigned char *)(*v13 + 24 * v15))
      {
        int v29 = (int)(float)(0.0 - (float)(*(float *)(*v13 + 24 * v15 + 4) * (float)*(int *)(v6 + 1280)));
        if ((v28 & 8) != 0)
        {
LABEL_37:
          unsigned int v30 = *(unsigned __int16 *)(*v13 + 24 * v15 + 14);
          if (v30 >= 2) {
            int v31 = 1000 * (v30 >> 1) + 1000;
          }
          else {
            int v31 = 0;
          }
          v29 += v31;
        }
LABEL_41:
        v32.i32[0] = *(_DWORD *)(v7 + 80) + v29;
        v32.i32[1] = v29;
        int32x2_t result = vmin_s32(v32, (int32x2_t)0x7F0000007FLL);
        *(int32x2_t *)(v7 + 8sub_19E03D880(&a9, 0) = result;
        uint64_t *v27 = v7;
        return result;
      }
LABEL_36:
      int v29 = 0;
      if ((v28 & 8) != 0) {
        goto LABEL_37;
      }
      goto LABEL_41;
    }
  }
  return result;
}

void sub_19E062580(const void **a1, CFTypeRef cf)
{
  if (*a1 != cf)
  {
    CFRetain(cf);
    sub_19E060B80(a1, cf);
  }
}

__n128 sub_19E0625E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09A8A8;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + ++**(_DWORD **)(result + 8) = v2;
  __n128 result = *(__n128 *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 56);
  long long v5 = *(_OWORD *)(a1 + 72);
  *(void *)(a2 + 8++**(_DWORD **)(result + 8) = *(void *)(a1 + 88);
  *(_OWORD *)(a2 + 72) = v5;
  *(_OWORD *)(a2 + 56) = v4;
  *(__n128 *)(a2 + 4sub_19E03D880(&a9, 0) = result;
  return result;
}

__n128 sub_19E062638(uint64_t a1)
{
  long long v2 = (char *)operator new(0x60uLL);
  *(void *)long long v2 = &unk_1EF09A8A8;
  *(_OWORD *)(v2 + 4sub_19E03D880(&a9, 0) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)(a1 + 72);
  *((void *)v2 + 11) = *(void *)(a1 + 88);
  *(_OWORD *)(v2 + ++**(_DWORD **)(result + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_19E0626AC()
{
}

void *sub_19E0626C4(void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_19E062748()
{
  return &unk_1EF0997D8;
}

uint64_t sub_19E062754(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF0997D8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

double sub_19E062794(uint64_t a1, const void **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = sub_19E0609C8(*(void **)(**(void **)(a1 + 8) + 16));
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  uint64_t v6 = *(_DWORD **)(v4 + 56);
  uint64_t v7 = **(void **)(a1 + 24);
  HIDWORD(v++**(_DWORD **)(result + 8) = *(_DWORD *)v7;
  LODWORD(v++**(_DWORD **)(result + 8) = *(_DWORD *)v7;
  *(_DWORD *)(v5 + 10sub_19E03D880(&a9, 0) = v8 >> 16;
  *(_DWORD *)(v5 + 64) = *(_DWORD *)(v7 + 8) + (v6[13] << 28);
  int v9 = *(__int16 *)(v7 + 6);
  *(_DWORD *)(v5 + 76) = v9;
  *(_DWORD *)(v5 + 8sub_19E03D880(&a9, 0) = v9;
  *(void *)(v5 + 56) = (*(uint64_t (**)(_DWORD *))(*(void *)v6 + 152))(v6);
  if (v3) {
    sub_19E062580((const void **)(v5 + 104), v3);
  }
  uint64_t v11 = *(void *)(a1 + 24);
  int v10 = *(uint64_t **)(a1 + 32);
  uint64_t v12 = *(uint64_t **)(a1 + 48);
  uint64_t v13 = **(void **)(a1 + 40);
  __int16 v14 = *(_WORD *)(*v10 + 24 * v13 + 12);
  *(_WORD *)(v5 + 96) = v14;
  *(_WORD *)(v5 + 9++**(_DWORD **)(result + 8) = v14;
  *(_DWORD *)(v5 + 72) = 0;
  *(unsigned char *)(v5 + 123) = *(unsigned char *)(*(void *)(v4 + 56) + 656);
  *(void *)(v5 + 24) = *v12;
  uint64_t v15 = *v10;
  int v16 = *(unsigned __int8 *)(v15 + 24 * v13);
  *(unsigned char *)(v5 + 124) = 0;
  *(unsigned char *)(v5 + 122) = v16;
  *(_WORD *)(v5 + 12sub_19E03D880(&a9, 0) = *(_WORD *)(*(void *)v11 + 4);
  int v17 = *(_DWORD *)(v5 + 80);
  if (v16) {
    v17 -= (int)(float)(*(float *)(v15 + 24 * v13 + 4) * (float)*(int *)(v4 + 1280));
  }
  unsigned int v18 = *(unsigned __int16 *)(v15 + 24 * v13 + 14);
  int v19 = 1000 * (v18 >> 1) + 1000;
  if (v18 == 1) {
    int v19 = 0;
  }
  int v20 = v19 + v17;
  if (*(_WORD *)(v15 + 24 * v13 + 14)) {
    int v17 = v20;
  }
  if (v17 >= 0x7FFF) {
    int v17 = 0x7FFF;
  }
  *(_DWORD *)(v5 + 8sub_19E03D880(&a9, 0) = v17;
  double result = *(float *)(v15 + 24 * v13 + 4);
  *(double *)(v5 + 8++**(_DWORD **)(result + 8) = result;
  uint64_t *v12 = v5;
  return result;
}

__n128 sub_19E062934(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09A958;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 4sub_19E03D880(&a9, 0) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E06296C(uint64_t a1)
{
  long long v2 = (char *)operator new(0x38uLL);
  *(void *)long long v2 = &unk_1EF09A958;
  *(_OWORD *)(v2 + ++**(_DWORD **)(result + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 4sub_19E03D880(&a9, 0) = result;
  return result;
}

void sub_19E0629C8()
{
}

BOOL sub_19E0629E0(const void *a1, size_t a2, void *__s2, size_t __n)
{
  return __n <= a2 && memcmp(a1, __s2, __n) == 0;
}

void sub_19E062A1C(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_19E062A78(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E599B428, MEMORY[0x1E4FBA1D0]);
}

void sub_19E062A64(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_19E062A78(std::logic_error *a1, const char *a2)
{
  __n128 result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
  return result;
}

uint64_t sub_19E062AAC(uint64_t a1, uint64_t a2, int a3, unsigned __int16 *a4, unint64_t a5, uint64_t a6, unsigned int a7)
{
  uint64_t v8 = a6;
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  uint64_t v65 = 0;
  uint64_t v11 = *(uint64_t **)(a1 + 8);
  int v10 = *(uint64_t **)(a1 + 16);
  if (v11 != v10)
  {
    unint64_t v60 = (const void *)(a1 + 1328);
    uint64_t v61 = a1 + 1304;
    uint64_t v57 = a3;
    unint64_t v14 = (unint64_t)a3 >> 1;
    uint64_t v56 = *(void **)(a6 + 104);
    int v55 = (a7 >> 2) & 5 | (a7 >> 4) & 8 | (a7 >> 15) & 0x10;
    if (a3 >= 0) {
      int v15 = a3;
    }
    else {
      int v15 = a3 + 1;
    }
    unsigned int v54 = v15 >> 1;
    while (1)
    {
      sub_19E0D25D0((uint64_t)__p, a2);
      if (*(char *)(a1 + 1327) < 0)
      {
        uint64_t v7 = *(void *)(a1 + 1304);
        size_t v16 = *(void *)(a1 + 1312);
      }
      else
      {
        size_t v16 = *(unsigned __int8 *)(a1 + 1327);
        uint64_t v7 = v61;
      }
      if (*(char *)(a1 + 1351) < 0)
      {
        unsigned int v18 = *(const void **)(a1 + 1328);
        size_t v17 = *(void *)(a1 + 1336);
      }
      else
      {
        size_t v17 = *(unsigned __int8 *)(a1 + 1351);
        unsigned int v18 = v60;
      }
      int v19 = (*(uint64_t (**)(void))(*(void *)*v11 + 160))();
      if ((v64 & 0x80u) == 0) {
        int v20 = (unsigned __int16 *)__p;
      }
      else {
        int v20 = (unsigned __int16 *)__p[0];
      }
      if ((v64 & 0x80u) == 0) {
        uint64_t v21 = v64;
      }
      else {
        uint64_t v21 = (uint64_t)__p[1];
      }
      BOOL v22 = sub_19E061BA0((const void *)v7, v16, v18, v17, v19, v20, v21, v14);
      uint64_t v8 = a6;
      if (v22) {
        goto LABEL_35;
      }
      int v23 = *(_DWORD *)(*v11 + 52);
      if ((a7 & 0x40000) == 0 && v23 == 1) {
        goto LABEL_35;
      }
      if ((a7 & 0x100000) != 0 && (v23 & 0xFFFFFFFD) == 1) {
        goto LABEL_35;
      }
      uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
      int v25 = (((unint64_t)(2 * v24 - v57) > 1) & ((*(unsigned int (**)(void))(*(void *)*v11 + 160))() | ((a7 & 8) >> 3))) != 0
          ? 2
          : 0;
      uint64_t v7 = v55 | v25;
      bzero(v56, 0x3000uLL);
      unint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void *, uint64_t))(*(void *)*v11 + 88))(*v11, v7, a2, v54, v56, 512);
      if (!(*(unsigned int (**)(void))(*(void *)*v11 + 160))()) {
        break;
      }
      sub_19E061C78((void *)a1, a6, (uint64_t)&v65, v26);
      if (v26) {
        goto LABEL_33;
      }
LABEL_35:
      if ((char)v64 < 0) {
        operator delete(__p[0]);
      }
      v11 += 2;
      if (v11 == v10) {
        goto LABEL_38;
      }
    }
    uint64_t v27 = *v11;
    uint64_t v71 = a6;
    unsigned int v70 = a7;
    uint64_t v69 = v27;
    int v68 = *(_DWORD *)(v27 + 52);
    uint64_t v28 = *(void *)(a6 + 104);
    unint64_t v66 = 0;
    uint64_t v67 = v28;
    if (v26)
    {
      for (unint64_t i = 0; i < v26; v66 = i)
      {
        uint64_t v7 = v69;
        uint64_t v30 = v67;
        int v31 = operator new(0x48uLL);
        *int v31 = &unk_1EF09A900;
        v31[1] = &v71;
        _DWORD v31[2] = &v69;
        v31[3] = &v70;
        void v31[4] = &v67;
        v31[5] = &v66;
        v31[6] = &v68;
        v31[7] = &v65;
        v31[8] = a1;
        char v75 = v31;
        (*(void (**)(uint64_t, unint64_t, uint64_t *))(*(void *)v7 + 144))(v7, v30 + 24 * i, &v72);
        sub_19E0621CC(&v72);
        unint64_t i = v66 + 1;
      }
    }
    uint64_t v8 = a6;
    if (!v26) {
      goto LABEL_35;
    }
LABEL_33:
    uint64_t v7 = 16;
    do
    {
      sub_19E062044((const void **)(*(void *)(v8 + 104) + v7), 0);
      v7 += 24;
      --v26;
    }
    while (v26);
    goto LABEL_35;
  }
LABEL_38:
  __int16 v32 = (__int16)a4;
  if (!a4) {
    return v65;
  }
  unint64_t v33 = a5;
  if ((unint64_t)a4 >= a5)
  {
    uint64_t v38 = 0;
    size_t v35 = a4;
    goto LABEL_66;
  }
  int v34 = *(_DWORD *)(a1 + 248);
  size_t v35 = a4;
  while (1)
  {
    unint64_t v36 = a5 - (void)v35;
    if ((*(_DWORD *)(a1 + 304) - 4) <= 2) {
      break;
    }
    unsigned __int16 v37 = *(unsigned __int8 *)v35;
    if ((*(char *)v35 & 0x80000000) == 0) {
      goto LABEL_45;
    }
    if (v36 >= 2 && (v37 & 0xE0) == 0xC0)
    {
      uint64_t v38 = 2;
      unsigned __int16 v37 = *((unsigned char *)v35 + 1) & 0x3F | ((v37 & 0x1F) << 6);
    }
    else
    {
      if (v36 < 3) {
        goto LABEL_64;
      }
      if ((v37 & 0xF0) == 0xE0)
      {
        unsigned __int16 v37 = (v37 << 12) | ((*((unsigned char *)v35 + 1) & 0x3F) << 6) | v35[1] & 0x3F;
        uint64_t v38 = 3;
      }
      else
      {
        if (v36 < 4) {
          goto LABEL_64;
        }
        if ((v37 & 0xF8) == 0xF0)
        {
          unsigned __int16 v37 = 0;
          uint64_t v38 = 4;
        }
        else
        {
          if (v36 < 5) {
            goto LABEL_64;
          }
          if ((v37 & 0xFC) == 0xF8)
          {
            unsigned __int16 v37 = 0;
            uint64_t v38 = 5;
          }
          else
          {
            if (v36 < 6 || (v37 & 0xFE) != 0xFC)
            {
LABEL_64:
              unsigned __int16 v37 = 0;
LABEL_45:
              uint64_t v38 = 1;
              goto LABEL_49;
            }
            unsigned __int16 v37 = 0;
            uint64_t v38 = 6;
          }
        }
      }
    }
LABEL_49:
    LODWORD(v7) = *(_DWORD *)(*(void *)(a1 + 296) + 4 * v37);
    if ((v34 & v7 & 0x3FFFF) != 0)
    {
      size_t v35 = (unsigned __int16 *)((char *)v35 + v38);
      int v34 = *(_DWORD *)(*(void *)(a1 + 296) + 4 * v37);
      if ((unint64_t)v35 < a5) {
        continue;
      }
    }
    goto LABEL_66;
  }
  if (v36 >= 2)
  {
    unsigned __int16 v37 = *v35;
    uint64_t v38 = 2;
    goto LABEL_49;
  }
  uint64_t v38 = 0;
  LODWORD(v7) = **(_DWORD **)(a1 + 296);
  if ((v34 & v7 & 0x3FFFF) != 0) {
    size_t v35 = 0;
  }
LABEL_66:
  if (*(unsigned char *)(a1 + 105))
  {
    sub_19E0E92C0((uint64_t)&v72, v35, (a5 - (unint64_t)v35) >> 1);
    if (v74)
    {
      sub_19E06207C(a1, v8, *(void *)(a1 + 96) + v72, (__int16)a4, (uint64_t)v35, (_WORD)v35 + 2 * v73, (uint64_t)&v65);
      __int16 v32 = (__int16)a4;
      unint64_t v33 = a5;
      uint64_t v8 = a6;
    }
  }
  uint64_t result = v65;
  if (!v65 || (v7 & 0x80000000) != 0)
  {
    unint64_t v40 = (unsigned __int8 *)v35 + v38;
    if ((unint64_t)v35 + v38 > v33) {
      return sub_19E06207C(a1, v8, (v7 >> 18), v32, (uint64_t)v35, (unsigned __int16)v35 + (unsigned __int16)v38, (uint64_t)&v65);
    }
    if ((v7 & 0x40000000) == 0)
    {
      uint64_t v41 = 0;
      goto LABEL_108;
    }
    if ((unint64_t)v40 >= v33)
    {
      unint64_t v42 = 0;
      uint64_t v41 = (char *)v35 + v38;
      goto LABEL_105;
    }
    unint64_t v42 = 0;
    uint64_t v41 = (char *)v35 + v38;
    int v43 = v7;
    while (2)
    {
      unint64_t v44 = v33 - (void)v41;
      if ((*(_DWORD *)(a1 + 304) - 4) > 2)
      {
        unsigned __int16 v45 = *v41;
        if (*v41 < 0)
        {
          if (v44 >= 2 && (v45 & 0xE0) == 0xC0)
          {
            uint64_t v46 = 2;
            unsigned __int16 v45 = v41[1] & 0x3F | ((v45 & 0x1F) << 6);
            goto LABEL_91;
          }
          if (v44 >= 3)
          {
            if ((v45 & 0xF0) == 0xE0)
            {
              unsigned __int16 v45 = (v45 << 12) | ((v41[1] & 0x3F) << 6) | v41[2] & 0x3F;
              uint64_t v46 = 3;
              goto LABEL_91;
            }
            if (v44 >= 4)
            {
              if ((v45 & 0xF8) == 0xF0)
              {
                unsigned __int16 v45 = 0;
                uint64_t v46 = 4;
                goto LABEL_91;
              }
              if (v44 >= 5)
              {
                if ((v45 & 0xFC) == 0xF8)
                {
                  unsigned __int16 v45 = 0;
                  uint64_t v46 = 5;
                  goto LABEL_91;
                }
                if (v44 >= 6 && (v45 & 0xFE) == 0xFC)
                {
                  unsigned __int16 v45 = 0;
                  uint64_t v46 = 6;
                  goto LABEL_91;
                }
              }
            }
          }
          unsigned __int16 v45 = 0;
        }
        uint64_t v46 = 1;
LABEL_91:
        int v47 = *(_DWORD *)(*(void *)(a1 + 296) + 4 * v45);
        if ((v43 & v47 & 0x3FFFF) == 0) {
          goto LABEL_106;
        }
        v41 += v46;
        ++v42;
        int v43 = v47;
        if ((unint64_t)v41 >= v33) {
          goto LABEL_106;
        }
        continue;
      }
      break;
    }
    if (v44 >= 2)
    {
      unsigned __int16 v45 = *(_WORD *)v41;
      uint64_t v46 = 2;
      goto LABEL_91;
    }
    if ((v43 & **(_DWORD **)(a1 + 296) & 0x3FFFF) == 0)
    {
LABEL_105:
      if (v41)
      {
LABEL_106:
        if (v42 <= *(void *)(a1 + 792)) {
          sub_19E06207C(a1, v8, (v7 >> 18), v32, (uint64_t)v35, (__int16)v41, (uint64_t)&v65);
        }
LABEL_108:
        unint64_t v48 = (v7 >> 26) & 0xF;
        if (v48)
        {
          unint64_t v49 = 1;
          while (1)
          {
            int v50 = (unsigned __int8 *)v41;
            if (v40 != (unsigned __int8 *)v41) {
              break;
            }
LABEL_122:
            if (v49 < v48)
            {
              ++v49;
              unint64_t v40 = v50;
              if ((unint64_t)v50 <= a5) {
                continue;
              }
            }
            goto LABEL_139;
          }
          sub_19E06207C(a1, a6, (v7 >> 18), (__int16)a4, (uint64_t)v35, (__int16)v40, (uint64_t)&v65);
          unint64_t v51 = a5 - (void)v40;
          if ((*(_DWORD *)(a1 + 304) - 4) <= 2)
          {
            if (v51 < 2)
            {
              uint64_t v53 = 0;
              unsigned __int16 v52 = 0;
            }
            else
            {
              unsigned __int16 v52 = *(_WORD *)v40;
              uint64_t v53 = 2;
            }
            goto LABEL_120;
          }
          unsigned __int16 v52 = *v40;
          if ((char)*v40 < 0)
          {
            if (v51 < 2 || (v52 & 0xE0) != 0xC0)
            {
              if (v51 >= 3)
              {
                if ((v52 & 0xF0) == 0xE0)
                {
                  unsigned __int16 v52 = (v52 << 12) | ((v40[1] & 0x3F) << 6) | v40[2] & 0x3F;
                  uint64_t v53 = 3;
                  goto LABEL_120;
                }
                if (v51 >= 4)
                {
                  if ((v52 & 0xF8) == 0xF0)
                  {
                    unsigned __int16 v52 = 0;
                    uint64_t v53 = 4;
                    goto LABEL_120;
                  }
                  if (v51 >= 5)
                  {
                    if ((v52 & 0xFC) == 0xF8)
                    {
                      unsigned __int16 v52 = 0;
                      uint64_t v53 = 5;
                      goto LABEL_120;
                    }
                    if (v51 >= 6 && (v52 & 0xFE) == 0xFC)
                    {
                      unsigned __int16 v52 = 0;
                      uint64_t v53 = 6;
                      goto LABEL_120;
                    }
                  }
                }
              }
              unsigned __int16 v52 = 0;
              goto LABEL_115;
            }
            uint64_t v53 = 2;
            unsigned __int16 v52 = v40[1] & 0x3F | ((v52 & 0x1F) << 6);
          }
          else
          {
LABEL_115:
            uint64_t v53 = 1;
          }
LABEL_120:
          if ((v7 & 0x3FFFF & *(_DWORD *)(*(void *)(a1 + 296) + 4 * v52)) == 0) {
            goto LABEL_138;
          }
          int v50 = &v40[v53];
          goto LABEL_122;
        }
LABEL_138:
        LOWORD(v5sub_19E03D880(&a9, 0) = (_WORD)v40;
LABEL_139:
        uint64_t result = v65;
        if (!v65)
        {
          sub_19E06207C(a1, a6, (v7 >> 18), (__int16)a4, (uint64_t)v35, (__int16)v50, (uint64_t)&v65);
          return v65;
        }
      }
    }
  }
  return result;
}

void sub_19E0633E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E063428()
{
  return &unk_1EF0997C8;
}

uint64_t sub_19E063434(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF0997C8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

int32x2_t sub_19E063474(uint64_t a1, uint64_t *a2, const void **a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v7 = sub_19E0609C8(*(void **)(**(void **)(a1 + 8) + 16));
  *(_OWORD *)(v7 + 96) = 0u;
  *(_OWORD *)(v7 + 112) = 0u;
  *(_OWORD *)(v7 + 64) = 0u;
  *(_OWORD *)(v7 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(v7 + 32) = 0u;
  *(_OWORD *)(v7 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)uint64_t v7 = 0u;
  *(_OWORD *)(v7 + 16) = 0u;
  uint64_t v8 = **(_DWORD ***)(a1 + 16);
  HIDWORD(v9) = *(_DWORD *)v4;
  LODWORD(v9) = *(_DWORD *)v4;
  *(_DWORD *)(v7 + 10sub_19E03D880(&a9, 0) = v9 >> 16;
  *(_DWORD *)(v7 + 64) = *(_DWORD *)(v4 + 8) + (v8[13] << 28);
  int v10 = *(__int16 *)(v4 + 6);
  *(_DWORD *)(v7 + 76) = v10;
  *(_DWORD *)(v7 + 8sub_19E03D880(&a9, 0) = v10;
  *(void *)(v7 + 56) = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)v8 + 152))(v8, v4);
  if (v5) {
    sub_19E062580((const void **)(v7 + 104), v5);
  }
  uint64_t v12 = *(int **)(a1 + 24);
  if ((*(unsigned char *)v12 & 2) == 0)
  {
    uint64_t v13 = *(uint64_t **)(a1 + 32);
    uint64_t v14 = *v13;
    uint64_t v15 = **(void **)(a1 + 40);
    size_t v16 = (unsigned __int8 *)(*v13 + 24 * v15);
    __int16 v17 = *((_WORD *)v16 + 6);
    *(_WORD *)(v7 + 96) = v17;
    *(_WORD *)(v7 + 9++**(_DWORD **)(result + 8) = v17;
    unsigned int v18 = *(int **)(a1 + 48);
    if (*v18 == 2) {
      int v19 = 0;
    }
    else {
      int v19 = *(_DWORD *)(v14 + 24 * v15 + 8) + (*v18 << 28);
    }
    int v20 = *v16;
    *(_DWORD *)(v7 + 72) = v19;
    *(unsigned char *)(v7 + 123) = *(unsigned char *)(**(void **)(a1 + 16) + 656);
    int v21 = *v18;
    __int16 v22 = *(_WORD *)(v4 + 4);
    if (*v18 == 7)
    {
      char v23 = 9;
    }
    else if ((v22 & 2) != 0)
    {
      char v23 = 5;
    }
    else if ((v22 & 3) == 0 || v21 == 6)
    {
      char v23 = 6;
    }
    else
    {
      char v23 = 0;
    }
    *(unsigned char *)(v7 + 124) = v23;
    int v25 = *(uint64_t **)(a1 + 56);
    *(void *)(v7 + 24) = *v25;
    *(unsigned char *)(v7 + 122) = v20;
    if (v21 == 8) {
      v22 |= 0x10u;
    }
    *(_WORD *)(v7 + 12sub_19E03D880(&a9, 0) = v22;
    int v26 = *v12;
    if ((v26 & 0x80) != 0)
    {
      if ((v26 & 0x80000) != 0 && v20 && (v22 & 2) == 0) {
        return result;
      }
    }
    else if ((v26 & 0x1580) == 0)
    {
      int v27 = 0;
      uint64_t v28 = *v13;
LABEL_27:
      if ((v26 & 8) != 0)
      {
        unsigned int v29 = *(unsigned __int16 *)(v28 + 24 * v15 + 14);
        if (v29 >= 2) {
          int v30 = 1000 * (v29 >> 1) + 1000;
        }
        else {
          int v30 = 0;
        }
        v27 += v30;
      }
      v31.i32[0] = *(_DWORD *)(v7 + 80) + v27;
      v31.i32[1] = v27;
      int32x2_t result = vmin_s32(v31, (int32x2_t)0x7F0000007FLL);
      double v32 = *(float *)(v28 + 24 * v15 + 4);
      *(int32x2_t *)(v7 + 8sub_19E03D880(&a9, 0) = result;
      *(double *)(v7 + 8++**(_DWORD **)(result + 8) = v32;
      uint64_t *v25 = v7;
      return result;
    }
    uint64_t v28 = *v13;
    int v27 = *(unsigned __int8 *)(v28 + 24 * v15);
    if (*(unsigned char *)(v28 + 24 * v15)) {
      int v27 = (int)(float)(0.0 - (float)(*(float *)(v28 + 24 * v15 + 4) * (float)*(int *)(v6 + 1280)));
    }
    goto LABEL_27;
  }
  return result;
}

__n128 sub_19E0636CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09A900;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 4sub_19E03D880(&a9, 0) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E06370C(uint64_t a1)
{
  long long v2 = (char *)operator new(0x48uLL);
  *(void *)long long v2 = &unk_1EF09A900;
  *(_OWORD *)(v2 + ++**(_DWORD **)(result + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 4sub_19E03D880(&a9, 0) = *(_OWORD *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(v2 + 56) = result;
  return result;
}

void sub_19E063770()
{
}

uint64_t sub_19E063788(uint64_t a1, unint64_t a2, unsigned __int8 *a3, uint64_t a4, unsigned int a5)
{
  uint64_t v36 = 0;
  if ((unint64_t)&a3[-a2] <= 0xFFFE) {
    unint64_t v9 = a3;
  }
  else {
    unint64_t v9 = (unsigned __int8 *)(a2 + 0xFFFF);
  }
  int v10 = (unsigned __int8 *)a2;
  if ((unint64_t)v9 > a2)
  {
    int v11 = *(_DWORD *)(a1 + 248);
    int v10 = (unsigned __int8 *)a2;
    while (1)
    {
      unint64_t v12 = v9 - v10;
      if ((*(_DWORD *)(a1 + 304) - 4) > 2)
      {
        unsigned __int16 v13 = *v10;
        if (((char)*v10 & 0x80000000) == 0) {
          goto LABEL_10;
        }
        if (v12 >= 2 && (v13 & 0xE0) == 0xC0)
        {
          uint64_t v14 = 2;
          unsigned __int16 v13 = v10[1] & 0x3F | ((v13 & 0x1F) << 6);
        }
        else
        {
          if (v12 < 3) {
            goto LABEL_29;
          }
          if ((v13 & 0xF0) == 0xE0)
          {
            unsigned __int16 v13 = (v13 << 12) | ((v10[1] & 0x3F) << 6) | v10[2] & 0x3F;
            uint64_t v14 = 3;
          }
          else
          {
            if (v12 < 4) {
              goto LABEL_29;
            }
            if ((v13 & 0xF8) == 0xF0)
            {
              unsigned __int16 v13 = 0;
              uint64_t v14 = 4;
            }
            else
            {
              if (v12 < 5) {
                goto LABEL_29;
              }
              if ((v13 & 0xFC) == 0xF8)
              {
                unsigned __int16 v13 = 0;
                uint64_t v14 = 5;
              }
              else
              {
                if (v12 < 6 || (v13 & 0xFE) != 0xFC)
                {
LABEL_29:
                  unsigned __int16 v13 = 0;
LABEL_10:
                  uint64_t v14 = 1;
                  goto LABEL_26;
                }
                unsigned __int16 v13 = 0;
                uint64_t v14 = 6;
              }
            }
          }
        }
      }
      else
      {
        if (v12 < 2)
        {
          if ((v11 & **(_DWORD **)(a1 + 296) & 0x3FFFF) == 0) {
            break;
          }
          return 0;
        }
        unsigned __int16 v13 = *(_WORD *)v10;
        uint64_t v14 = 2;
      }
LABEL_26:
      int v15 = *(_DWORD *)(*(void *)(a1 + 296) + 4 * v13);
      if ((v11 & v15 & 0x3FFFF) != 0)
      {
        v10 += v14;
        int v11 = v15;
        if (v10 < v9) {
          continue;
        }
      }
      break;
    }
  }
  uint64_t result = 0;
  if (v10 && v10 != v9)
  {
    __int16 v17 = *(uint64_t **)(a1 + 8);
    unsigned int v18 = *(uint64_t **)(a1 + 16);
    if (v17 == v18) {
      return 0;
    }
    unint64_t v19 = v9 - v10;
    int v20 = (a5 >> 4) & 8;
    int v21 = (a5 >> 15) & 0x10;
    int v22 = v20 | (a5 >> 2) & 7 | v21 | 2;
    int v23 = v20 | (a5 >> 2) & 4;
    int v24 = v20 | (a5 >> 2) & 1 | v21 | 4;
    int v25 = v23 | v21 | 1;
    int v26 = a5 & 0x18;
    if ((a5 & 8) != 0) {
      int v25 = v22;
    }
    BOOL v27 = v26 == 16;
    BOOL v28 = v26 != 16;
    if (v27) {
      int v25 = v24;
    }
    unsigned int v34 = v25;
    uint64_t v35 = v19;
    int v29 = v19 > 2 || v28;
    do
    {
      int v30 = *(_DWORD *)(*v17 + 52);
      if (((a5 & 0x40000) != 0 || v30 != 1) && ((a5 & 0x100000) == 0 || (v30 & 0xFFFFFFFD) != 1))
      {
        int32x2_t v31 = *(void **)(a4 + 104);
        bzero(v31, 0x3000uLL);
        if (v29)
        {
          unint64_t v32 = (*(uint64_t (**)(uint64_t, void, unsigned __int8 *, uint64_t, void, void, void, void *, uint64_t))(*(void *)*v17 + 80))(*v17, v34, v10, v35, *(void *)(a1 + 1288), *(void *)(a1 + 1296), 0, v31, 512);
          sub_19E061EC4((void *)a1, a4, a2, (uint64_t)v10, v35, a5, v32, *v17, (uint64_t)&v36);
          if (v32)
          {
            uint64_t v33 = 16;
            do
            {
              sub_19E062044((const void **)(*(void *)(a4 + 104) + v33), 0);
              v33 += 24;
              --v32;
            }
            while (v32);
          }
        }
      }
      v17 += 2;
    }
    while (v17 != v18);
    return v36;
  }
  return result;
}

void *sub_19E063AC4(void *__dst, char *__src)
{
  if (*(_WORD *)__src)
  {
    unint64_t v4 = 0;
    do
      uint64_t v5 = &__src[2 * v4++];
    while (*((_WORD *)v5 + 1));
    if (v4 >= 0x7FFFFFFFFFFFFFF8) {
      sub_19E04147C();
    }
    if (v4 >= 0xB)
    {
      uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFFCLL) + 4;
      if ((v4 | 3) != 0xB) {
        uint64_t v7 = v4 | 3;
      }
      uint64_t v6 = sub_19E063B88(v7 + 1);
      __dst[1] = v4;
      __dst[2] = v8 | 0x8000000000000000;
      void *__dst = v6;
    }
    else
    {
      *((unsigned char *)__dst + 23) = v4;
      uint64_t v6 = __dst;
      if (!v4) {
        goto LABEL_9;
      }
    }
    memmove(v6, __src, 2 * v4);
    goto LABEL_14;
  }
  unint64_t v4 = 0;
  *((unsigned char *)__dst + 23) = 0;
LABEL_9:
  uint64_t v6 = __dst;
LABEL_14:
  *((_WORD *)v6 + v4) = 0;
  return __dst;
}

void *sub_19E063B88(uint64_t a1)
{
  if (a1 < 0) {
    sub_19E0416C4();
  }
  return operator new(2 * a1);
}

void *sub_19E063BBC(unint64_t a1)
{
  if (a1 >> 60) {
    sub_19E0416C4();
  }
  return operator new(16 * a1);
}

void *sub_19E063BF4(void *result, void *a2)
{
  long long v3 = (void *)*result;
  long long v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    long long v5 = *((_OWORD *)v2 - 1);
    v2 -= 2;
    *(_OWORD *)(v4 - 16) = v5;
    v4 -= 16;
    void *v2 = 0;
    v2[1] = 0;
  }
  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  *uint64_t result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_19E063C50(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v2 - 8);
    if (v4)
    {
      sub_19E0616BC(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 16;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E063CB4(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF099518)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_19E063CF4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_19E063D24(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E063D60()
{
  v0 = (void *)MEMORY[0x1F4188790]();
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v340 = *MEMORY[0x1E4F143B8];
  sub_19E061474(v0);
  sub_19E06603C((uint64_t)v305, v2, "dicdir");
  sub_19E06603C((uint64_t)&__dst, v2, "dicdir");
  sub_19E0413C8(&__p, "char.bin");
  sub_19E070220(v339, (uint64_t)&__dst, (uint64_t)&__p);
  if (SHIBYTE(v309) < 0) {
    operator delete(__p);
  }
  if ((v339[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v4 = v339;
  }
  else {
    uint64_t v4 = (std::string *)v339[0].__r_.__value_.__r.__words[0];
  }
  char v5 = sub_19E074578((uint64_t)(v3 + 32), (char *)v4);
  if (SHIBYTE(v339[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v339[0].__r_.__value_.__l.__data_);
  }
  if ((SHIBYTE(__dst.__sb_.__binp_) & 0x80000000) == 0)
  {
    if (v5) {
      goto LABEL_10;
    }
LABEL_26:
    if (setjmp((int *)v3 + 272) != 1)
    {
      std::ios_base::clear((std::ios_base *)((char *)v3 + *(void *)(v3[100] - 24) + 800), 0);
      v239 = sub_19E0416F8(v3 + 100, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tokenizer.cpp", 72);
      sub_19E0416F8(v239, (uint64_t)"(", 1);
      v240 = (void *)std::ostream::operator<<();
      v241 = sub_19E0416F8(v240, (uint64_t)") [", 3);
      v242 = sub_19E0416F8(v241, (uint64_t)"property_.open(param)", 21);
      v243 = sub_19E0416F8(v242, (uint64_t)"] ", 2);
      v244 = (char *)sub_19E05E6A8((uint64_t)(v3 + 39));
      v245 = (std::strstreambuf_vtbl *)sub_19E0413C8(&__dst, v244);
      if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
        v246 = v245;
      }
      else {
        v246 = __dst.__sb_.__vftable;
      }
      if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
        uint64_t binp_high = HIBYTE(__dst.__sb_.__binp_);
      }
      else {
        uint64_t binp_high = (uint64_t)__dst.__sb_.__loc_.__locale_;
      }
      sub_19E0416F8(v243, (uint64_t)v246, binp_high);
      if (SHIBYTE(__dst.__sb_.__binp_) < 0) {
        operator delete(__dst.__sb_.__vftable);
      }
      longjmp((int *)v3 + 272, 1);
    }
    goto LABEL_30;
  }
  operator delete(__dst.__sb_.__vftable);
  if ((v5 & 1) == 0) {
    goto LABEL_26;
  }
LABEL_10:
  *((_DWORD *)v3 + 32sub_19E03D880(&a9, 0) = sub_19E05E730(v2, "correction-penalty");
  if (sub_19E06613C(v2, "open-mutable-dictionary")) {
    uint64_t v6 = "r+";
  }
  else {
    uint64_t v6 = "r";
  }
  uint64_t v7 = v3[7];
  sub_19E0413C8(v339, "unk.dic");
  sub_19E070220((std::string *)&__dst, (uint64_t)v305, (uint64_t)v339);
  if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = __dst.__sb_.__vftable;
  }
  char v9 = (*(uint64_t (**)(uint64_t, void *, const char *))(*(void *)v7 + 16))(v7, p_dst, v6);
  if (SHIBYTE(__dst.__sb_.__binp_) < 0) {
    operator delete(__dst.__sb_.__vftable);
  }
  if ((SHIBYTE(v339[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v9) {
      goto LABEL_20;
    }
    goto LABEL_29;
  }
  operator delete(v339[0].__r_.__value_.__l.__data_);
  if ((v9 & 1) == 0)
  {
LABEL_29:
    if (setjmp((int *)v3 + 272) != 1)
    {
      std::ios_base::clear((std::ios_base *)((char *)v3 + *(void *)(v3[100] - 24) + 800), 0);
      v248 = sub_19E0416F8(v3 + 100, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tokenizer.cpp", 72);
      sub_19E0416F8(v248, (uint64_t)"(", 1);
      v249 = (void *)std::ostream::operator<<();
      v250 = sub_19E0416F8(v249, (uint64_t)") [", 3);
      v251 = sub_19E0416F8(v250, (uint64_t)"unkSuccess", 10);
      v252 = sub_19E0416F8(v251, (uint64_t)"] ", 2);
      v253 = (char *)sub_19E05E6A8(v3[7] + 96);
      v254 = (std::strstreambuf_vtbl *)sub_19E0413C8(&__dst, v253);
      if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
        v255 = v254;
      }
      else {
        v255 = __dst.__sb_.__vftable;
      }
      if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
        uint64_t locale = HIBYTE(__dst.__sb_.__binp_);
      }
      else {
        uint64_t locale = (uint64_t)__dst.__sb_.__loc_.__locale_;
      }
      sub_19E0416F8(v252, (uint64_t)v255, locale);
      if (SHIBYTE(__dst.__sb_.__binp_) < 0) {
        operator delete(__dst.__sb_.__vftable);
      }
      longjmp((int *)v3 + 272, 1);
    }
LABEL_30:
    sub_19E061474(v3);
    goto LABEL_31;
  }
LABEL_20:
  sub_19E0413C8(&__dst, "completion-lookahead");
  int v10 = sub_19E05E980(v2 + 8, &__dst);
  if (SHIBYTE(__dst.__sb_.__binp_) < 0) {
    operator delete(__dst.__sb_.__vftable);
  }
  if ((void *)(v2 + 16) == v10) {
    operator new();
  }
  if (*((char *)v10 + 79) < 0) {
    sub_19E03FA9C(v339, (void *)v10[7], v10[8]);
  }
  else {
    v339[0] = *(std::string *)(v10 + 7);
  }
  LODWORD(v303[0]) = 0;
  unint64_t v12 = (void *)(sub_19E05EA00((uint64_t)&__dst) + 16);
  if ((v339[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned __int16 v13 = v339;
  }
  else {
    unsigned __int16 v13 = (std::string *)v339[0].__r_.__value_.__r.__words[0];
  }
  if ((v339[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v339[0].__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v339[0].__r_.__value_.__l.__size_;
  }
  int v15 = sub_19E0416F8(v12, (uint64_t)v13, size);
  if ((*((unsigned char *)v15 + *(void *)(*v15 - 24) + 32) & 5) != 0
    || (size_t v16 = (void *)MEMORY[0x19F3BA470](&__dst, v303), (*((unsigned char *)v16 + *(void *)(*v16 - 24) + 32) & 5) != 0)
    || (__int16 v17 = sub_19E05EB24(&__dst),
        (*((unsigned char *)v17 + (unint64_t)__dst.__sb_.__vftable[-1].pbackfail + 32) & 2) == 0))
  {
    operator new();
  }
  int v54 = (int)v303[0];
  std::strstream::~strstream(&__dst);
  if (SHIBYTE(v339[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v339[0].__r_.__value_.__l.__data_);
  }
  *(_DWORD *)(v3[8] + 676) = v54;
  sub_19E06603C((uint64_t)v303, v2, "lexicon-data-file");
  unint64_t v18 = v304;
  if ((v304 & 0x80u) != 0) {
    unint64_t v18 = (unint64_t)v303[1];
  }
  if (!v18)
  {
    int v22 = (int *)(v3 + 136);
    if (setjmp((int *)v3 + 272) != 1)
    {
      v257 = v3 + 100;
      std::ios_base::clear((std::ios_base *)((char *)v257 + *(void *)(*v257 - 24)), 0);
      v258 = sub_19E0416F8(v257, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tokenizer.cpp", 72);
      sub_19E0416F8(v258, (uint64_t)"(", 1);
      v259 = (void *)std::ostream::operator<<();
      v260 = sub_19E0416F8(v259, (uint64_t)") [", 3);
      v261 = sub_19E0416F8(v260, (uint64_t)"!lexiconDataFile.empty()", 24);
      v262 = sub_19E0416F8(v261, (uint64_t)"] ", 2);
      sub_19E0416F8(v262, (uint64_t)"need lexicon data file path specified", 37);
      longjmp(v22, 1);
    }
    goto LABEL_74;
  }
  sub_19E06603C((uint64_t)&__dst, v2, "dictionary-locale");
  unint64_t v19 = (void **)(v3 + 163);
  if (*((char *)v3 + 1327) < 0) {
    operator delete(*v19);
  }
  *(_OWORD *)unint64_t v19 = *(_OWORD *)&__dst.__sb_.__vftable;
  v3[165] = __dst.__sb_.__binp_;
  uint64_t v20 = v3[8];
  if (*((char *)v3 + 1327) < 0)
  {
    unint64_t v19 = (void **)v3[163];
    uint64_t v21 = v3[164];
  }
  else
  {
    LOWORD(v21) = *((unsigned __int8 *)v3 + 1327);
  }
  sub_19E070220((std::string *)&__dst, (uint64_t)v305, (uint64_t)v303);
  if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
    int v23 = (const char *)&__dst;
  }
  else {
    int v23 = (const char *)__dst.__sb_.__vftable;
  }
  BOOL v24 = sub_19E0A94D8(v20, (char *)v19, v21, v23);
  BOOL v25 = v24;
  if (SHIBYTE(__dst.__sb_.__binp_) < 0)
  {
    operator delete(__dst.__sb_.__vftable);
    if (v25) {
      goto LABEL_63;
    }
LABEL_73:
    if (setjmp((int *)v3 + 272) != 1)
    {
      std::ios_base::clear((std::ios_base *)((char *)v3 + *(void *)(v3[100] - 24) + 800), 0);
      v263 = sub_19E0416F8(v3 + 100, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tokenizer.cpp", 72);
      sub_19E0416F8(v263, (uint64_t)"(", 1);
      v264 = (void *)std::ostream::operator<<();
      v265 = sub_19E0416F8(v264, (uint64_t)") [", 3);
      v266 = sub_19E0416F8(v265, (uint64_t)"sysSuccess", 10);
      v267 = sub_19E0416F8(v266, (uint64_t)"] ", 2);
      v268 = (char *)sub_19E05E6A8(v3[8] + 96);
      v269 = (std::strstreambuf_vtbl *)sub_19E0413C8(&__dst, v268);
      if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
        v270 = v269;
      }
      else {
        v270 = __dst.__sb_.__vftable;
      }
      if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
        uint64_t v271 = HIBYTE(__dst.__sb_.__binp_);
      }
      else {
        uint64_t v271 = (uint64_t)__dst.__sb_.__loc_.__locale_;
      }
      sub_19E0416F8(v267, (uint64_t)v270, v271);
      if (SHIBYTE(__dst.__sb_.__binp_) < 0) {
        operator delete(__dst.__sb_.__vftable);
      }
      longjmp((int *)v3 + 272, 1);
    }
    goto LABEL_74;
  }
  if (!v24) {
    goto LABEL_73;
  }
LABEL_63:
  int v26 = (_DWORD *)v3[8];
  if (v26[13])
  {
    BOOL v27 = (int *)(v3 + 136);
    if (setjmp((int *)v3 + 272) != 1)
    {
      BOOL v28 = v3 + 100;
      std::ios_base::clear((std::ios_base *)((char *)v28 + *(void *)(*v28 - 24)), 0);
      int v29 = sub_19E0416F8(v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tokenizer.cpp", 72);
      sub_19E0416F8(v29, (uint64_t)"(", 1);
      int v30 = (void *)std::ostream::operator<<();
      int32x2_t v31 = sub_19E0416F8(v30, (uint64_t)") [", 3);
      unint64_t v32 = sub_19E0416F8(v31, (uint64_t)"sysdic_->type() == MECAB_SYS_DIC", 32);
      uint64_t v33 = sub_19E0416F8(v32, (uint64_t)"] ", 2);
      unsigned int v34 = sub_19E0416F8(v33, (uint64_t)"not a system dictionary: ", 25);
      if ((v306 & 0x80u) == 0) {
        uint64_t v35 = v305;
      }
      else {
        uint64_t v35 = (void **)v305[0];
      }
      if ((v306 & 0x80u) == 0) {
        uint64_t v36 = v306;
      }
      else {
        uint64_t v36 = (uint64_t)v305[1];
      }
      sub_19E0416F8(v34, (uint64_t)v35, v36);
      longjmp(v27, 1);
    }
LABEL_74:
    sub_19E061474(v3);
    goto LABEL_75;
  }
  unsigned __int16 v37 = (char *)(*(uint64_t (**)(_DWORD *))(*(void *)v26 + 32))(v26);
  sub_19E0413C8(&__dst, v37);
  uint64_t v38 = (std::locale::__imp *)HIBYTE(__dst.__sb_.__binp_);
  BOOL v39 = SHIBYTE(__dst.__sb_.__binp_) < 0;
  unint64_t v40 = __dst.__sb_.__loc_.__locale_;
  if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
    uint64_t v41 = (std::locale::__imp *)HIBYTE(__dst.__sb_.__binp_);
  }
  else {
    uint64_t v41 = __dst.__sb_.__loc_.__locale_;
  }
  if (v41)
  {
    uint64_t v42 = 0;
    int v43 = (std::locale::__imp *)HIBYTE(__dst.__sb_.__binp_);
    do
    {
      uint64_t v44 = v42;
      unsigned __int16 v45 = __dst.__sb_.__vftable;
      if (!v39) {
        unsigned __int16 v45 = &__dst;
      }
      int v46 = v45[v42];
      int v47 = v40;
      unint64_t v48 = v43;
      if ((v46 - 65) <= 0x19)
      {
        v45[v44] = v46 + 32;
        unint64_t v48 = (std::locale::__imp *)HIBYTE(__dst.__sb_.__binp_);
        int v47 = __dst.__sb_.__loc_.__locale_;
      }
      int v43 = v48;
      unint64_t v40 = v47;
      unint64_t v49 = v44 + 1;
      uint64_t v42 = v44 + 1;
      BOOL v39 = (char)v43 < 0;
      if ((char)v43 >= 0) {
        int v50 = v43;
      }
      else {
        int v50 = v40;
      }
      unint64_t v51 = v40;
      uint64_t v38 = v43;
      unsigned __int16 v52 = v43;
      BOOL v53 = (char)v43 < 0;
    }
    while (v49 < (unint64_t)v50);
  }
  else
  {
    unsigned __int16 v52 = (std::locale::__imp *)HIBYTE(__dst.__sb_.__binp_);
    unint64_t v51 = __dst.__sb_.__loc_.__locale_;
    BOOL v53 = SHIBYTE(__dst.__sb_.__binp_) < 0;
  }
  if (v53) {
    unsigned __int16 v52 = v51;
  }
  switch((unint64_t)v52)
  {
    case 3uLL:
      BOOL v58 = !v53;
      int v55 = (unsigned __int16 *)&__dst;
      if (!v58) {
        int v55 = (unsigned __int16 *)__dst.__sb_.__vftable;
      }
      int v56 = *v55;
      int v57 = *((unsigned __int8 *)v55 + 2);
      BOOL v58 = v56 == 30053;
      int v59 = 99;
      goto LABEL_109;
    case 4uLL:
      BOOL v58 = !v53;
      uint64_t v65 = &__dst;
      if (!v58) {
        uint64_t v65 = __dst.__sb_.__vftable;
      }
      if (*v65 == 1936288371) {
        goto LABEL_142;
      }
      goto LABEL_126;
    case 5uLL:
      BOOL v58 = !v53;
      unint64_t v60 = (unsigned __int8 *)&__dst;
      if (!v58) {
        unint64_t v60 = (unsigned __int8 *)__dst.__sb_.__vftable;
      }
      int v61 = *(_DWORD *)v60;
      int v62 = v60[4];
      BOOL v63 = v61 == 859402339;
      int v64 = 50;
      goto LABEL_122;
    case 6uLL:
      BOOL v58 = !v53;
      unint64_t v66 = (unsigned __int16 *)&__dst;
      if (!v58) {
        unint64_t v66 = (unsigned __int16 *)__dst.__sb_.__vftable;
      }
      int v67 = *(_DWORD *)v66;
      int v57 = v66[2];
      BOOL v58 = v67 == 1600353637;
      int v59 = 28778;
LABEL_109:
      if (!v58 || v57 != v59) {
        goto LABEL_126;
      }
      goto LABEL_143;
    case 9uLL:
      BOOL v58 = !v53;
      uint64_t v69 = (unsigned __int8 *)&__dst;
      if (!v58) {
        uint64_t v69 = (unsigned __int8 *)__dst.__sb_.__vftable;
      }
      int v64 = 115;
      if (*(void *)v69 == 0x696A2D7466696873 && v69[8] == 115) {
        goto LABEL_142;
      }
      uint64_t v71 = *(void *)v69;
      int v62 = v69[8];
      BOOL v63 = v71 == 0x696A5F7466696873;
LABEL_122:
      if (v63 && v62 == v64)
      {
LABEL_142:
        int v82 = 1;
        goto LABEL_172;
      }
LABEL_126:
      if ((char)v38 >= 0) {
        unint64_t v51 = v38;
      }
      if (v51 == (std::locale::__imp *)5)
      {
        uint64_t v84 = (unsigned __int8 *)&__dst;
        if ((char)v38 < 0) {
          uint64_t v84 = (unsigned __int8 *)__dst.__sb_.__vftable;
        }
        if (*(_DWORD *)v84 == 1600550005 && v84[4] == 56) {
          goto LABEL_163;
        }
        BOOL v86 = *(_DWORD *)v84 == 761689205 && v84[4] == 56;
        int v82 = 2;
        if (!v86)
        {
          if (*(_DWORD *)v84 ^ 0x69637361 | v84[4] ^ 0x69) {
            int v82 = 2;
          }
          else {
            int v82 = 3;
          }
        }
      }
      else
      {
        if (v51 != (std::locale::__imp *)8)
        {
          if (v51 == (std::locale::__imp *)6)
          {
            uint64_t v73 = (unsigned __int16 *)__dst.__sb_.__vftable;
            char v74 = (unsigned int *)&__dst;
            if ((char)v38 >= 0) {
              uint64_t v73 = (unsigned __int16 *)&__dst;
            }
            int v75 = *(_DWORD *)v73;
            int v76 = v73[2];
            if (v75 == 761492837 && v76 == 28778)
            {
LABEL_143:
              int v82 = 0;
              goto LABEL_172;
            }
            if ((char)v38 < 0) {
              char v74 = (unsigned int *)__dst.__sb_.__vftable;
            }
            unsigned int v78 = 1970562605;
            unsigned int v79 = bswap32(*v74);
            if (v79 == 1970562605)
            {
              unsigned int v80 = bswap32(*((unsigned __int16 *)v74 + 2)) >> 16;
              unsigned int v78 = 12598;
              if (v80 == 12598)
              {
                int v81 = 0;
LABEL_169:
                if (v81) {
                  int v82 = 2;
                }
                else {
                  int v82 = 4;
                }
                goto LABEL_172;
              }
            }
            else
            {
              unsigned int v80 = v79;
            }
            if (v80 < v78) {
              int v81 = -1;
            }
            else {
              int v81 = 1;
            }
            goto LABEL_169;
          }
LABEL_163:
          int v82 = 2;
          goto LABEL_172;
        }
        uint64_t v83 = &__dst.__sb_.~strstreambuf;
        if ((char)v38 >= 0) {
          uint64_t v83 = &__dst;
        }
        if (*v83 == 0x656236312D667475)
        {
          int v82 = 5;
        }
        else if (*v83 == 0x656C36312D667475)
        {
          int v82 = 6;
        }
        else
        {
          int v82 = 2;
        }
      }
LABEL_172:
      int v87 = v82;
      if ((v38 & 0x80) != 0) {
        operator delete(__dst.__sb_.__vftable);
      }
      *((_DWORD *)v3 + 76) = v87;
      long long v88 = *((_OWORD *)v3 + 4);
      uint64_t v89 = v3[9];
      if (v89) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v89 + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v90 = v3 + 1;
      unint64_t v91 = v3[3];
      uint64_t v92 = (_OWORD *)v3[2];
      if ((unint64_t)v92 >= v91)
      {
        long long v298 = v88;
        uint64_t v95 = ((uint64_t)v92 - *v90) >> 4;
        unint64_t v96 = v95 + 1;
        if ((unint64_t)(v95 + 1) >> 60) {
          sub_19E041BEC();
        }
        uint64_t v97 = v91 - *v90;
        if (v97 >> 3 > v96) {
          unint64_t v96 = v97 >> 3;
        }
        if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v98 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v98 = v96;
        }
        __dst.__sb_.__einp_ = (std::streambuf::char_type *)(v3 + 3);
        uint64_t v99 = (std::strstreambuf_vtbl *)sub_19E063BBC(v98);
        uint64_t v100 = (char *)v99 + 16 * v95;
        __dst.__sb_.__vftable = v99;
        __dst.__sb_.__loc_.__locale_ = (std::locale::__imp *)v100;
        __dst.__sb_.__ninp_ = (char *)v99 + 16 * v101;
        *(_OWORD *)uint64_t v100 = v298;
        __dst.__sb_.__binp_ = v100 + 16;
        sub_19E063BF4(v3 + 1, &__dst);
        v102 = (_OWORD *)v3[2];
        sub_19E063C50((uint64_t)&__dst);
        uint64_t v94 = v102;
      }
      else
      {
        *uint64_t v92 = v88;
        uint64_t v93 = v92 + 1;
        v3[2] = v93;
        uint64_t v94 = v93;
      }
      v3[2] = v94;
      sub_19E06603C((uint64_t)&__dst, v2, "additional-dictionary-locale");
      v103 = (void **)(v3 + 166);
      if (*((char *)v3 + 1351) < 0) {
        operator delete(*v103);
      }
      *(_OWORD *)v103 = *(_OWORD *)&__dst.__sb_.__vftable;
      v3[168] = __dst.__sb_.__binp_;
      if (*((char *)v3 + 1351) < 0) {
        uint64_t v104 = v3[167];
      }
      else {
        uint64_t v104 = *((unsigned __int8 *)v3 + 1351);
      }
      if (v104)
      {
        sub_19E066394((uint64_t *)&__dst, 1);
        v105 = __dst.__sb_.__vftable;
        uint64_t v106 = (std::__shared_weak_count *)v3[11];
        *((_OWORD *)v3 + 5) = *(_OWORD *)&__dst.__sb_.__vftable;
        if (v106)
        {
          sub_19E0616BC(v106);
          uint64_t v107 = v3[10];
        }
        else
        {
          uint64_t v107 = (uint64_t)v105;
        }
        if (*((char *)v3 + 1351) < 0)
        {
          unsigned int v109 = (char *)v3[166];
          uint64_t v108 = v3[167];
        }
        else
        {
          LOWORD(v10++**(_DWORD **)(result + 8) = *((unsigned __int8 *)v3 + 1351);
          unsigned int v109 = (char *)(v3 + 166);
        }
        if (!sub_19E0A94D8(v107, v109, v108, 0))
        {
          if (setjmp((int *)v3 + 272) != 1)
          {
            std::ios_base::clear((std::ios_base *)((char *)v3 + *(void *)(v3[100] - 24) + 800), 0);
            v272 = sub_19E0416F8(v3 + 100, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tokenizer.cpp", 72);
            sub_19E0416F8(v272, (uint64_t)"(", 1);
            v273 = (void *)std::ostream::operator<<();
            v274 = sub_19E0416F8(v273, (uint64_t)") [", 3);
            v275 = sub_19E0416F8(v274, (uint64_t)"success", 7);
            v276 = sub_19E0416F8(v275, (uint64_t)"] ", 2);
            v277 = (char *)sub_19E05E6A8(v3[10] + 96);
            v278 = (std::strstreambuf_vtbl *)sub_19E0413C8(&__dst, v277);
            if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
              v279 = v278;
            }
            else {
              v279 = __dst.__sb_.__vftable;
            }
            if (SHIBYTE(__dst.__sb_.__binp_) >= 0) {
              uint64_t v280 = HIBYTE(__dst.__sb_.__binp_);
            }
            else {
              uint64_t v280 = (uint64_t)__dst.__sb_.__loc_.__locale_;
            }
            sub_19E0416F8(v276, (uint64_t)v279, v280);
            if (SHIBYTE(__dst.__sb_.__binp_) < 0) {
              operator delete(__dst.__sb_.__vftable);
            }
            longjmp((int *)v3 + 272, 1);
          }
          goto LABEL_74;
        }
        long long v110 = *((_OWORD *)v3 + 5);
        uint64_t v111 = v3[11];
        if (v111) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v111 + 8), 1uLL, memory_order_relaxed);
        }
        v113 = (_OWORD *)v3[2];
        unint64_t v112 = v3[3];
        if ((unint64_t)v113 >= v112)
        {
          long long v297 = v110;
          uint64_t v116 = ((uint64_t)v113 - *v90) >> 4;
          unint64_t v117 = v116 + 1;
          if ((unint64_t)(v116 + 1) >> 60) {
            sub_19E041BEC();
          }
          uint64_t v118 = v112 - *v90;
          if (v118 >> 3 > v117) {
            unint64_t v117 = v118 >> 3;
          }
          if ((unint64_t)v118 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v119 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v119 = v117;
          }
          __dst.__sb_.__einp_ = (std::streambuf::char_type *)(v3 + 3);
          v120 = (std::strstreambuf_vtbl *)sub_19E063BBC(v119);
          v121 = (char *)v120 + 16 * v116;
          __dst.__sb_.__vftable = v120;
          __dst.__sb_.__loc_.__locale_ = (std::locale::__imp *)v121;
          __dst.__sb_.__ninp_ = (char *)v120 + 16 * v122;
          *(_OWORD *)v121 = v297;
          __dst.__sb_.__binp_ = v121 + 16;
          sub_19E063BF4(v3 + 1, &__dst);
          v123 = (_OWORD *)v3[2];
          sub_19E063C50((uint64_t)&__dst);
          v115 = v123;
        }
        else
        {
          _OWORD *v113 = v110;
          v114 = v113 + 1;
          v3[2] = v114;
          v115 = v114;
        }
        v3[2] = v115;
      }
      v125.n128_f64[0] = sub_19E06603C((uint64_t)__src, v2, "userdic");
      if (v302 < 0)
      {
        if (!__src[1]) {
          goto LABEL_257;
        }
        v299 = v3 + 3;
        v300 = v3 + 1;
        long long v126 = 0uLL;
        long long v337 = 0u;
        long long v338 = 0u;
        long long v335 = 0u;
        long long v336 = 0u;
        long long v333 = 0u;
        long long v334 = 0u;
        long long v331 = 0u;
        long long v332 = 0u;
        long long v329 = 0u;
        long long v330 = 0u;
        long long v327 = 0u;
        long long v328 = 0u;
        long long v325 = 0u;
        long long v326 = 0u;
        long long v323 = 0u;
        long long v324 = 0u;
        long long v321 = 0u;
        long long v322 = 0u;
        long long v319 = 0u;
        long long v320 = 0u;
        long long v317 = 0u;
        long long v318 = 0u;
        long long v315 = 0u;
        long long v316 = 0u;
        long long v313 = 0u;
        long long v314 = 0u;
        memset(&__dst.__sb_.__einp_, 0, 64);
        v127 = __src[0];
      }
      else
      {
        if (!v302) {
          goto LABEL_257;
        }
        v299 = v3 + 3;
        v300 = v3 + 1;
        long long v126 = 0uLL;
        long long v337 = 0u;
        long long v338 = 0u;
        long long v335 = 0u;
        long long v336 = 0u;
        long long v333 = 0u;
        long long v334 = 0u;
        long long v331 = 0u;
        long long v332 = 0u;
        long long v329 = 0u;
        long long v330 = 0u;
        long long v327 = 0u;
        long long v328 = 0u;
        long long v325 = 0u;
        long long v326 = 0u;
        long long v323 = 0u;
        long long v324 = 0u;
        long long v321 = 0u;
        long long v322 = 0u;
        long long v319 = 0u;
        long long v320 = 0u;
        long long v317 = 0u;
        long long v318 = 0u;
        long long v315 = 0u;
        long long v316 = 0u;
        long long v313 = 0u;
        long long v314 = 0u;
        memset(&__dst.__sb_.__einp_, 0, 64);
        v127 = (const char *)__src;
      }
      *(_OWORD *)&__dst.__sb_.__vftable = v126;
      *(_OWORD *)&__dst.__sb_.__binp_ = v126;
      v128 = strncpy((char *)v339, v127, 0x2000uLL);
      int64_t v129 = strlen(v128);
      if (v129 >= 1)
      {
        v130 = (unsigned __int8 *)v339 + v129;
        v131 = v339;
        v132 = &__dst;
        uint64_t v133 = 0x10000;
        uint64_t v134 = 0;
        do
        {
          v135 = v131;
          unint64_t v136 = v133;
          while (1)
          {
            int v137 = v135->__r_.__value_.__s.__data_[0];
            if (v137 != 9 && v137 != 32) {
              break;
            }
            v135 = (std::string *)((char *)v135 + 1);
          }
          if (v137 == 34)
          {
            v135 = (std::string *)((char *)v135 + 1);
            v138 = (unsigned __int8 *)v135;
            v139 = (unsigned __int8 *)v135;
            if (v135 < (std::string *)v130)
            {
              v140 = (unsigned __int8 *)v135;
              v141 = (unsigned __int8 *)v135;
              while (1)
              {
                v138 = v140;
                int v142 = *v141;
                if (v142 == 34)
                {
                  int v143 = *++v141;
                  if (v143 != 34) {
                    break;
                  }
                }
                *v138++ = v142;
                v140 = v138;
                v139 = ++v141;
                if (v141 >= v130) {
                  goto LABEL_235;
                }
              }
              v139 = v141;
            }
LABEL_235:
            v148 = v138;
            v149 = (unsigned __int8 *)memchr(v139, 44, v130 - v139);
            if (v149) {
              v147 = v149;
            }
            else {
              v147 = v130;
            }
            v146 = v148;
          }
          else
          {
            v144 = (unsigned __int8 *)memchr(v135, 44, v130 - (unsigned __int8 *)v135);
            if (v144) {
              v145 = v144;
            }
            else {
              v145 = v130;
            }
            v146 = v145;
            v147 = v145;
          }
          uint64_t v133 = v136 - 1;
          if (v136 < 2)
          {
            v132->__sb_.__vftable = (std::strstreambuf_vtbl *)v135;
            uint64_t v151 = v134 + 1;
            uint64_t v150 = v134 + 1;
            if (!v133) {
              break;
            }
          }
          else
          {
            unsigned __int8 *v146 = 0;
            v132->__sb_.__vftable = (std::strstreambuf_vtbl *)v135;
            uint64_t v150 = v134 + 1;
          }
          uint64_t v134 = v150;
          v132 = (std::strstream *)((char *)v132 + 8);
          v131 = (std::string *)(v147 + 1);
          uint64_t v151 = v134;
        }
        while (v147 + 1 < v130);
        if (v151)
        {
          uint64_t v152 = 0;
          while (1)
          {
            v153 = (std::__shared_weak_count *)operator new(0x2B0uLL);
            v153->__shared_owners_ = 0;
            v153->__shared_weak_owners_ = 0;
            v153->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF09AA60;
            sub_19E06FF10((uint64_t)&v153[1]);
            v154 = (const char *)*((void *)&__dst.__sb_.__vftable + v152);
            if ((((uint64_t (*)(std::__shared_weak_count *, const char *, const char *))v153[1].__on_zero_shared)(&v153[1], v154, v6) & 1) == 0)break; {
            if (HIDWORD(v153[3].__vftable) != 1)
            }
            {
              v238 = (int *)(v3 + 136);
              if (setjmp((int *)v3 + 272) != 1)
              {
                v289 = v3 + 100;
                std::ios_base::clear((std::ios_base *)((char *)v289 + *(void *)(*v289 - 24)), 0);
                v290 = sub_19E0416F8(v289, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tokenizer.cpp", 72);
                sub_19E0416F8(v290, (uint64_t)"(", 1);
                v291 = (void *)std::ostream::operator<<();
                v292 = sub_19E0416F8(v291, (uint64_t)") [", 3);
                v293 = sub_19E0416F8(v292, (uint64_t)"d->type() == MECAB_USR_DIC", 26);
                v294 = sub_19E0416F8(v293, (uint64_t)"] ", 2);
                v295 = sub_19E0416F8(v294, (uint64_t)"not a user dictionary: ", 23);
                size_t v296 = strlen(v154);
                sub_19E0416F8(v295, (uint64_t)v154, v296);
                longjmp(v238, 1);
              }
LABEL_333:
              sub_19E061474(v3);
              sub_19E0616BC(v153);
              goto LABEL_334;
            }
            v155 = (void *)v3[2];
            unint64_t v156 = v3[3];
            if ((unint64_t)v155 >= v156)
            {
              uint64_t v158 = ((uint64_t)v155 - *v300) >> 4;
              unint64_t v159 = v158 + 1;
              if ((unint64_t)(v158 + 1) >> 60) {
                sub_19E041BEC();
              }
              uint64_t v160 = v156 - *v300;
              if (v160 >> 3 > v159) {
                unint64_t v159 = v160 >> 3;
              }
              if ((unint64_t)v160 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v161 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v161 = v159;
              }
              v311 = v299;
              v162 = (char *)sub_19E063BBC(v161);
              *(void *)&long long v163 = v153 + 1;
              *((void *)&v163 + 1) = v153;
              v164 = &v162[16 * v158];
              std::string __p = v162;
              v308 = v164;
              v310 = &v162[16 * v165];
              *(_OWORD *)v164 = v163;
              atomic_fetch_add_explicit(&v153->__shared_owners_, 1uLL, memory_order_relaxed);
              v309 = v164 + 16;
              sub_19E063BF4(v300, &__p);
              v166 = (void *)v3[2];
              sub_19E063C50((uint64_t)&__p);
              v157 = v166;
            }
            else
            {
              void *v155 = v153 + 1;
              v155[1] = v153;
              v157 = v155 + 2;
              atomic_fetch_add_explicit(&v153->__shared_owners_, 1uLL, memory_order_relaxed);
              v3[2] = v157;
            }
            v3[2] = v157;
            sub_19E0616BC(v153);
            if (v151 == ++v152) {
              goto LABEL_257;
            }
          }
          v227 = (int *)(v3 + 136);
          if (setjmp((int *)v3 + 272) != 1)
          {
            v228 = v3 + 100;
            std::ios_base::clear((std::ios_base *)((char *)v228 + *(void *)(*v228 - 24)), 0);
            v229 = sub_19E0416F8(v228, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tokenizer.cpp", 72);
            sub_19E0416F8(v229, (uint64_t)"(", 1);
            v230 = (void *)std::ostream::operator<<();
            v231 = sub_19E0416F8(v230, (uint64_t)") [", 3);
            v232 = sub_19E0416F8(v231, (uint64_t)"d->open(_dic[i], mode)", 22);
            v233 = sub_19E0416F8(v232, (uint64_t)"] ", 2);
            v234 = (char *)sub_19E05E6A8((uint64_t)&v153[5]);
            v235 = sub_19E0413C8(&__p, v234);
            if (SHIBYTE(v309) >= 0) {
              v236 = v235;
            }
            else {
              v236 = __p;
            }
            if (SHIBYTE(v309) >= 0) {
              uint64_t v237 = HIBYTE(v309);
            }
            else {
              uint64_t v237 = (uint64_t)v308;
            }
            sub_19E0416F8(v233, (uint64_t)v236, v237);
            if (SHIBYTE(v309) < 0) {
              operator delete(__p);
            }
            longjmp(v227, 1);
          }
          goto LABEL_333;
        }
      }
LABEL_257:
      v3[30] = 0;
      v3[24] = 0;
      v3[25] = 0;
      uint64_t v167 = ((v3[2] - v3[1]) >> 4) - 1;
      if ((int)v167 >= 0)
      {
        do
        {
          uint64_t v168 = v167;
          uint64_t v169 = v3[25];
          if (v3[24] == v3[26])
          {
            uint64_t v124 = ++v169;
            v3[24] = 0;
            v3[25] = v169;
            uint64_t v170 = 0;
          }
          else
          {
            uint64_t v170 = v3[24];
          }
          uint64_t v171 = v170;
          if (v169 == (uint64_t)(v3[22] - v3[21]) >> 3) {
            operator new[]();
          }
          uint64_t v172 = *(void *)(v3[21] + 8 * v169);
          v3[24] = v170 + 1;
          uint64_t v173 = v172 + 48 * v170;
          *(_OWORD *)(v173 + 16) = 0u;
          *(_OWORD *)(v173 + 32) = 0u;
          *(_OWORD *)uint64_t v173 = 0u;
          *(void *)(v173 + 4sub_19E03D880(&a9, 0) = v3[30];
          v174 = *(char **)(v3[1] + 16 * v167);
          v175 = v174 + 72;
          if (v174[95] < 0) {
            v175 = (void *)*v175;
          }
          *(void *)uint64_t v173 = v175;
          uint64_t v176 = (*(uint64_t (**)(char *, uint64_t))(*(void *)v174 + 32))(v174, v124);
          uint64_t v177 = v172 + 48 * v171;
          *(void *)(v177 + ++**(_DWORD **)(result + 8) = v176;
          uint64_t v178 = *(void *)(v3[1] + 16 * v168);
          __n128 v125 = *(__n128 *)(v178 + 52);
          *(void *)&long long v179 = vrev64q_s32((int32x4_t)v125).u64[0];
          *((void *)&v179 + 1) = *(void *)(v178 + 60);
          *(_OWORD *)(v177 + 16) = v179;
          *(_WORD *)(v177 + 32) = *(_DWORD *)(v178 + 48);
          v3[30] = v173;
          uint64_t v167 = v168 - 1;
        }
        while (v168 > 0);
      }
      v3[28] = v3[27];
      if (!v3[7])
      {
LABEL_318:
        *((_DWORD *)v3 + 62) = *(_DWORD *)(v3[37] + 128);
        sub_19E06603C((uint64_t)&__dst, v2, "bos-feature");
        sub_19E066440();
      }
      for (unint64_t i = 0; ; ++i)
      {
        uint64_t v181 = v3[34];
        if (i >= (v3[35] - v181) >> 3)
        {
          *((unsigned char *)v3 + 105) = 1;
          v3[12] = (uint64_t)(v3[28] - v3[27]) >> 4;
          v204 = &off_1E599C728;
          do
          {
            (*(void (**)(std::strstream *__return_ptr, __n128))(*(void *)v3[7] + 56))(&__dst, v125);
            int v205 = (int)__dst.__sb_.__loc_.__locale_;
            if (LODWORD(__dst.__sb_.__loc_.__locale_))
            {
              uint64_t v206 = (*(uint64_t (**)(void, std::strstream *, void))(*(void *)v3[7] + 128))(v3[7], &__dst, 0);
              uint64_t v207 = (*(uint64_t (**)(void, std::strstream *))(*(void *)v3[7] + 136))(v3[7], &__dst);
              uint64_t v208 = v207;
              v210 = (uint64_t *)v3[28];
              unint64_t v209 = v3[29];
              if ((unint64_t)v210 >= v209)
              {
                uint64_t v212 = v3[27];
                uint64_t v213 = ((uint64_t)v210 - v212) >> 4;
                unint64_t v214 = v213 + 1;
                if ((unint64_t)(v213 + 1) >> 60) {
                  sub_19E041BEC();
                }
                uint64_t v215 = v209 - v212;
                if (v215 >> 3 > v214) {
                  unint64_t v214 = v215 >> 3;
                }
                if ((unint64_t)v215 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v216 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v216 = v214;
                }
                if (v216)
                {
                  v217 = (char *)sub_19E063BBC(v216);
                  uint64_t v219 = v218;
                }
                else
                {
                  uint64_t v219 = 0;
                  v217 = 0;
                }
                v220 = (uint64_t *)&v217[16 * v213];
                v221 = v220;
                uint64_t *v220 = v206;
                v220[1] = v208;
                uint64_t v222 = v3[27];
                uint64_t v223 = v3[28];
                if (v223 == v222)
                {
                  v225 = (void *)v3[28];
                }
                else
                {
                  v224 = (__n128 *)&v217[16 * v213];
                  do
                  {
                    v221 = (uint64_t *)&v224[-1];
                    __n128 v125 = *(__n128 *)(v223 - 16);
                    v224[-1] = v125;
                    v223 -= 16;
                    --v224;
                  }
                  while (v223 != v222);
                  v225 = (void *)v3[27];
                }
                v211 = v220 + 2;
                v3[27] = v221;
                v3[28] = v220 + 2;
                v3[29] = &v217[16 * v219];
                if (v225) {
                  operator delete(v225);
                }
              }
              else
              {
                uint64_t *v210 = v206;
                v210[1] = v207;
                v211 = v210 + 2;
              }
              v3[28] = v211;
            }
            else if (*((unsigned char *)v3 + 105))
            {
              *((unsigned char *)v3 + 105) = 0;
            }
            if (__dst.__sb_.__binp_) {
              CFRelease(__dst.__sb_.__binp_);
            }
            if (!v205) {
              break;
            }
            v204 += 2;
          }
          while (v204 != &off_1E599C748);
          goto LABEL_318;
        }
        v182 = *(const char **)(v181 + 8 * i);
        (*(void (**)(std::strstream *__return_ptr, __n128))(*(void *)v3[7] + 64))(&__dst, v125);
        if (!LODWORD(__dst.__sb_.__loc_.__locale_)) {
          break;
        }
        uint64_t v183 = (*(uint64_t (**)(void, std::strstream *, void))(*(void *)v3[7] + 128))(v3[7], &__dst, 0);
        uint64_t v184 = (*(uint64_t (**)(void, std::strstream *))(*(void *)v3[7] + 136))(v3[7], &__dst);
        uint64_t v185 = v183;
        uint64_t v186 = v184;
        v188 = (uint64_t *)v3[28];
        unint64_t v187 = v3[29];
        if ((unint64_t)v188 >= v187)
        {
          uint64_t v190 = v3[27];
          uint64_t v191 = ((uint64_t)v188 - v190) >> 4;
          unint64_t v192 = v191 + 1;
          if ((unint64_t)(v191 + 1) >> 60) {
            sub_19E041BEC();
          }
          uint64_t v193 = v187 - v190;
          if (v193 >> 3 > v192) {
            unint64_t v192 = v193 >> 3;
          }
          if ((unint64_t)v193 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v194 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v194 = v192;
          }
          if (v194)
          {
            v195 = (char *)sub_19E063BBC(v194);
            uint64_t v197 = v196;
          }
          else
          {
            uint64_t v197 = 0;
            v195 = 0;
          }
          v198 = (uint64_t *)&v195[16 * v191];
          v199 = (char *)v198;
          uint64_t *v198 = v185;
          v198[1] = v186;
          uint64_t v200 = v3[27];
          uint64_t v201 = v3[28];
          if (v201 == v200)
          {
            v203 = (void *)v3[28];
          }
          else
          {
            v202 = (__n128 *)&v195[16 * v191];
            do
            {
              v199 = (char *)&v202[-1];
              __n128 v125 = *(__n128 *)(v201 - 16);
              v202[-1] = v125;
              v201 -= 16;
              --v202;
            }
            while (v201 != v200);
            v203 = (void *)v3[27];
          }
          v189 = v198 + 2;
          v3[27] = v199;
          v3[28] = v198 + 2;
          v3[29] = &v195[16 * v197];
          if (v203) {
            operator delete(v203);
          }
        }
        else
        {
          uint64_t *v188 = v185;
          v188[1] = v184;
          v189 = v188 + 2;
        }
        v3[28] = v189;
        if (__dst.__sb_.__binp_) {
          CFRelease(__dst.__sb_.__binp_);
        }
      }
      v226 = (int *)(v3 + 136);
      if (setjmp((int *)v3 + 272) != 1)
      {
        v281 = v3 + 100;
        std::ios_base::clear((std::ios_base *)((char *)v281 + *(void *)(*v281 - 24)), 0);
        v282 = sub_19E0416F8(v281, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tokenizer.cpp", 72);
        sub_19E0416F8(v282, (uint64_t)"(", 1);
        v283 = (void *)std::ostream::operator<<();
        v284 = sub_19E0416F8(v283, (uint64_t)") [", 3);
        v285 = sub_19E0416F8(v284, (uint64_t)"n.value != 0", 12);
        v286 = sub_19E0416F8(v285, (uint64_t)"] ", 2);
        v287 = sub_19E0416F8(v286, (uint64_t)"cannot find UNK category: ", 26);
        size_t v288 = strlen(v182);
        sub_19E0416F8(v287, (uint64_t)v182, v288);
        longjmp(v226, 1);
      }
      sub_19E061474(v3);
      if (__dst.__sb_.__binp_) {
        CFRelease(__dst.__sb_.__binp_);
      }
LABEL_334:
      if (v302 < 0) {
        operator delete(__src[0]);
      }
LABEL_75:
      if ((char)v304 < 0) {
        operator delete(v303[0]);
      }
LABEL_31:
      if ((char)v306 < 0) {
        operator delete(v305[0]);
      }
      return 0;
    default:
      goto LABEL_126;
  }
}

void sub_19E065D58(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,std::strstream *a37)
{
  if (a2) {
    sub_19E04137C(a1);
  }
  _Unwind_Resume(a1);
}

double sub_19E06603C(uint64_t a1, uint64_t a2, char *__s)
{
  uint64_t v5 = a2 + 8;
  sub_19E0413C8(&__p, __s);
  uint64_t v6 = sub_19E05E980(v5, &__p);
  if (v11 < 0) {
    operator delete(__p);
  }
  if ((void *)(a2 + 16) == v6) {
    operator new();
  }
  if (*((char *)v6 + 79) < 0)
  {
    sub_19E03FA9C(&v8, (void *)v6[7], v6[8]);
  }
  else
  {
    long long v8 = *(_OWORD *)(v6 + 7);
    uint64_t v9 = v6[9];
  }
  double result = *(double *)&v8;
  *(_OWORD *)a1 = v8;
  *(void *)(a1 + 16) = v9;
  return result;
}

BOOL sub_19E06613C(uint64_t a1, char *a2)
{
  uint64_t v3 = a1 + 8;
  sub_19E0413C8(__p, a2);
  uint64_t v4 = sub_19E05E980(v3, __p);
  if (SHIBYTE(__p[0].__sb_.__binp_) < 0) {
    operator delete(__p[0].__sb_.__vftable);
  }
  if ((void *)(a1 + 16) == v4) {
    operator new();
  }
  if (*((char *)v4 + 79) < 0)
  {
    sub_19E03FA9C(v11, (void *)v4[7], v4[8]);
  }
  else
  {
    *(_OWORD *)char v11 = *(_OWORD *)(v4 + 7);
    uint64_t v12 = v4[9];
  }
  sub_19E05EA00((uint64_t)__p);
  char v13 = 0;
  if (v12 >= 0) {
    uint64_t v5 = v11;
  }
  else {
    uint64_t v5 = (void **)v11[0];
  }
  if (v12 >= 0) {
    uint64_t v6 = HIBYTE(v12);
  }
  else {
    uint64_t v6 = (uint64_t)v11[1];
  }
  uint64_t v7 = sub_19E0416F8(&__p[0].__sb_.__binp_, (uint64_t)v5, v6);
  if ((*((unsigned char *)v7 + *(void *)(*v7 - 24) + 32) & 5) != 0
    || (long long v8 = (void *)MEMORY[0x19F3BA440](__p, &v13), (*((unsigned char *)v8 + *(void *)(*v8 - 24) + 32) & 5) != 0)
    || (sub_19E05EB24(__p),
        (*((unsigned char *)&__p[0].__sb_.__einp_ + (unint64_t)__p[0].__sb_.__vftable[-1].pbackfail) & 2) == 0))
  {
    operator new();
  }
  BOOL v10 = v13 != 0;
  std::strstream::~strstream(__p);
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  return v10;
}

void sub_19E066364(_Unwind_Exception *__p, uint64_t a2, int a3, __int16 a4, char a5, char a6, uint64_t a7, uint64_t a8, void *__pa, std::strstream *a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a14 < 0) {
    operator delete(__pa);
  }
  _Unwind_Resume(__p);
}

uint64_t sub_19E066394(uint64_t *a1, char a2)
{
  uint64_t v4 = operator new(0x2C0uLL);
  v4[1] = 0;
  v4[2] = 0;
  *uint64_t v4 = &unk_1EF09AA98;
  uint64_t result = sub_19E06FF10((uint64_t)(v4 + 3));
  v4[3] = &unk_1EF09C2D0;
  v4[86] = 0;
  *((unsigned char *)v4 + 696) = a2 != 0;
  *((_DWORD *)v4 + 175) = -1;
  *a1 = result;
  a1[1] = (uint64_t)v4;
  return result;
}

void sub_19E066428(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_19E066440()
{
}

uint64_t sub_19E0664D0(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  sub_19E0413C8(__p, "max-grouping-size");
  uint64_t v3 = sub_19E05E980(v2, __p);
  if (SHIBYTE(__p[0].__sb_.__binp_) < 0) {
    operator delete(__p[0].__sb_.__vftable);
  }
  if ((void *)(a1 + 16) == v3) {
    operator new();
  }
  if (*((char *)v3 + 79) < 0)
  {
    sub_19E03FA9C(v10, (void *)v3[7], v3[8]);
  }
  else
  {
    *(_OWORD *)BOOL v10 = *(_OWORD *)(v3 + 7);
    uint64_t v11 = v3[9];
  }
  sub_19E05EA00((uint64_t)__p);
  uint64_t v12 = 0;
  if (v11 >= 0) {
    uint64_t v4 = v10;
  }
  else {
    uint64_t v4 = (void **)v10[0];
  }
  if (v11 >= 0) {
    uint64_t v5 = HIBYTE(v11);
  }
  else {
    uint64_t v5 = (uint64_t)v10[1];
  }
  uint64_t v6 = sub_19E0416F8(&__p[0].__sb_.__binp_, (uint64_t)v4, v5);
  if ((*((unsigned char *)v6 + *(void *)(*v6 - 24) + 32) & 5) != 0
    || (uint64_t v7 = (void *)MEMORY[0x19F3BA480](__p, &v12), (*((unsigned char *)v7 + *(void *)(*v7 - 24) + 32) & 5) != 0)
    || (sub_19E05EB24(__p),
        (*((unsigned char *)&__p[0].__sb_.__einp_ + (unint64_t)__p[0].__sb_.__vftable[-1].pbackfail) & 2) == 0))
  {
    operator new();
  }
  uint64_t v9 = v12;
  std::strstream::~strstream(__p);
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[0]);
  }
  return v9;
}

void sub_19E0666F8(_Unwind_Exception *__p, uint64_t a2, int a3, __int16 a4, char a5, char a6, uint64_t a7, uint64_t a8, void *__pa, std::strstream *a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a14 < 0) {
    operator delete(__pa);
  }
  _Unwind_Resume(__p);
}

void sub_19E066728(void *a1)
{
  *a1 = &unk_1EF09C000;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x19F3BA710](v1, 0x1000C4000313F17);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0667A4(void *a1)
{
  *a1 = &unk_1EF09C000;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x19F3BA710](v2, 0x1000C4000313F17);
  }
  return a1;
}

uint64_t sub_19E066804(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E066828(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF09AA60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x19F3BA710);
}

void sub_19E06687C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF09AA60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_19E06689C(void *a1)
{
  *a1 = &unk_1EF099C50;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x19F3BA710](v1, 0x1000C4052888210);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E066918(void *a1)
{
  *a1 = &unk_1EF099C50;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x19F3BA710](v2, 0x1000C4052888210);
  }
  return a1;
}

void sub_19E066974(void *a1)
{
  *a1 = &unk_1EF09BFA0;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x19F3BA710](v1, 0x1000C4077774924);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0669F0(void *a1)
{
  *a1 = &unk_1EF09BFA0;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x19F3BA710](v2, 0x1000C4077774924);
  }
  return a1;
}

void *sub_19E066A4C(void *a1)
{
  *a1 = &unk_1EF09BF80;
  uint64_t v2 = a1[1];
  if (v2)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    MEMORY[0x19F3BA710](v2, 0x1012C40EC159624);
  }
  return a1;
}

void sub_19E066ABC(void *a1)
{
  sub_19E066A4C(a1);

  JUMPOUT(0x19F3BA710);
}

void sub_19E066AF8(void *a1)
{
  *a1 = 0;
  a1[3] = 0;
  a1[4] = 0x1FF00000000;
  operator new[]();
}

void sub_19E066B80(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 48);
  *(void *)(v1 + 4++**(_DWORD **)(result + 8) = 0;
  if (v3) {
    MEMORY[0x19F3BA6E0](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *(void *)(v1 + 40);
  *(void *)(v1 + 4sub_19E03D880(&a9, 0) = 0;
  if (v4) {
    MEMORY[0x19F3BA6E0](v4, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E066BD4()
{
  if (!qword_1E9457340) {
    operator new();
  }
  pthread_mutex_unlock(&stru_1E94571E0);
  return qword_1E9457340;
}

void sub_19E066C74(_Unwind_Exception *a1)
{
  sub_19E067268(*(char **)(v1 + 40));
  sub_19E0672C4(*(char **)(v1 + 16));
  MEMORY[0x19F3BA710](v1, 0x10B3C401829B6ABLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E066CA8(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 64);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 64));
  if (a2)
  {
    uint64_t v5 = *(void **)(a1 + 40);
    if (v5)
    {
      uint64_t v6 = (void *)(a1 + 40);
      do
      {
        unint64_t v7 = v5[4];
        BOOL v8 = v7 >= a2;
        if (v7 >= a2) {
          uint64_t v9 = v5;
        }
        else {
          uint64_t v9 = v5 + 1;
        }
        if (v8) {
          uint64_t v6 = v5;
        }
        uint64_t v5 = (void *)*v9;
      }
      while (*v9);
      if (v6 != (void *)(a1 + 40) && v6[4] <= a2)
      {
        uint64_t v10 = v6[8] - 1;
        v6[8] = v10;
        if (!v10)
        {
          uint64_t v11 = (uint64_t **)(a1 + 8);
          uint64_t v12 = sub_19E05E980(a1 + 8, v6 + 5);
          char v13 = v12;
          uint64_t v14 = (uint64_t *)v12[1];
          if (v14)
          {
            do
            {
              int v15 = v14;
              uint64_t v14 = (uint64_t *)*v14;
            }
            while (v14);
          }
          else
          {
            size_t v16 = v12;
            do
            {
              int v15 = (uint64_t *)v16[2];
              BOOL v17 = *v15 == (void)v16;
              size_t v16 = v15;
            }
            while (!v17);
          }
          if (*v11 == v12) {
            uint64_t *v11 = v15;
          }
          unint64_t v18 = *(uint64_t **)(a1 + 16);
          --*(void *)(a1 + 24);
          sub_19E066E70(v18, v13);
          if (*((char *)v13 + 55) < 0) {
            operator delete((void *)v13[4]);
          }
          operator delete(v13);
          unint64_t v19 = (void *)v6[1];
          if (v19)
          {
            do
            {
              uint64_t v20 = v19;
              unint64_t v19 = (void *)*v19;
            }
            while (v19);
          }
          else
          {
            uint64_t v21 = v6;
            do
            {
              uint64_t v20 = (void *)v21[2];
              BOOL v17 = *v20 == (void)v21;
              uint64_t v21 = v20;
            }
            while (!v17);
          }
          if (*(void **)(a1 + 32) == v6) {
            *(void *)(a1 + 32) = v20;
          }
          int v22 = *(uint64_t **)(a1 + 40);
          --*(void *)(a1 + 48);
          sub_19E066E70(v22, v6);
          if (*((char *)v6 + 63) < 0) {
            operator delete((void *)v6[5]);
          }
          operator delete(v6);
          (*(void (**)(unint64_t))(*(void *)a2 + 8))(a2);
        }
      }
    }
  }

  return pthread_mutex_unlock(v4);
}

uint64_t *sub_19E066E70(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      uint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      uint64_t v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  uint64_t v6 = (uint64_t **)v3[2];
  unint64_t v7 = *v6;
  if (*v6 == v3)
  {
    void *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      unint64_t v7 = 0;
      uint64_t result = (uint64_t *)v2;
    }
    else
    {
      unint64_t v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    uint64_t *v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 != v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v18 = v7[1];
      *(void *)uint64_t v12 = v18;
      if (v18) {
        *(void *)(v18 + 16) = v12;
      }
      v7[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(void *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12) {
        uint64_t result = v7;
      }
      unint64_t v7 = *(uint64_t **)v12;
    }
    unint64_t v19 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v19 + 24)) {
      goto LABEL_68;
    }
    uint64_t v20 = (uint64_t *)v7[1];
    if (v20 && !*((unsigned char *)v20 + 24))
    {
      if (v19 && !*((unsigned char *)v19 + 24))
      {
LABEL_68:
        uint64_t v20 = v7;
      }
      else
      {
        *((unsigned char *)v20 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v26 = *v20;
        v7[1] = *v20;
        if (v26) {
          *(void *)(v26 + 16) = v7;
        }
        void v20[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
        uint64_t *v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        unint64_t v19 = v7;
      }
      uint64_t v23 = v20[2];
      *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v19 + 24) = 1;
      BOOL v24 = *(uint64_t **)v23;
      uint64_t v27 = *(void *)(*(void *)v23 + 8);
      *(void *)uint64_t v23 = v27;
      if (v27) {
        *(void *)(v27 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((unsigned char *)v7 + 24) = 0;
    BOOL v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
LABEL_49:
    unint64_t v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    char v13 = *(uint64_t **)(v12 + 8);
    uint64_t v14 = *v13;
    *(void *)(v12 + ++**(_DWORD **)(result + 8) = *v13;
    if (v14) {
      *(void *)(v14 + 16) = v12;
    }
    v13[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
    *char v13 = v12;
    *(void *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7) {
      uint64_t result = v7;
    }
    unint64_t v7 = *(uint64_t **)(*v7 + 8);
  }
  int v15 = (void *)*v7;
  if (!*v7 || *((unsigned char *)v15 + 24))
  {
    size_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_59;
    }
    *((unsigned char *)v7 + 24) = 0;
    BOOL v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      BOOL v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  size_t v16 = (uint64_t *)v7[1];
  if (v16 && !*((unsigned char *)v16 + 24))
  {
LABEL_59:
    int v15 = v7;
  }
  else
  {
    *((unsigned char *)v15 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v22 = v15[1];
    uint64_t *v7 = v22;
    if (v22) {
      *(void *)(v22 + 16) = v7;
    }
    void v15[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    size_t v16 = v7;
  }
  uint64_t v23 = v15[2];
  *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v16 + 24) = 1;
  BOOL v24 = *(uint64_t **)(v23 + 8);
  uint64_t v25 = *v24;
  *(void *)(v23 + ++**(_DWORD **)(result + 8) = *v24;
  if (v25) {
    *(void *)(v25 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  uint64_t *v24 = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t sub_19E0671F4(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C410;
  sub_19E05DB78(a1 + 72);
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 8), 0);
  return a1;
}

void sub_19E067254(_Unwind_Exception *a1)
{
  sub_19E067320(v1);
  _Unwind_Resume(a1);
}

void sub_19E067268(char *a1)
{
  if (a1)
  {
    sub_19E067268(*(void *)a1);
    sub_19E067268(*((void *)a1 + 1));
    if (a1[63] < 0) {
      operator delete(*((void **)a1 + 5));
    }
    operator delete(a1);
  }
}

void sub_19E0672C4(char *a1)
{
  if (a1)
  {
    sub_19E0672C4(*(void *)a1);
    sub_19E0672C4(*((void *)a1 + 1));
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

uint64_t sub_19E067320(uint64_t a1)
{
  if (*(char *)(a1 + 287) < 0) {
    operator delete(*(void **)(a1 + 264));
  }
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 112);
  return a1;
}

void sub_19E067434(uint64_t a1)
{
  sub_19E06746C(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E06746C(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C410;
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
  if (*(char *)(a1 + 359) < 0) {
    operator delete(*(void **)(a1 + 336));
  }
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 72) = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 72 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8sub_19E03D880(&a9, 0) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 184);
  return a1;
}

void sub_19E0675AC(uint64_t a1)
{
  sub_19E0675E4(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E0675E4(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09BD00;
  uint64_t v2 = (pthread_mutex_t *)(a1 + 64);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 64));
  uint64_t v3 = *(void **)(a1 + 8);
  if (v3 != (void *)(a1 + 16))
  {
    do
    {
      uint64_t v4 = v3[7];
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
      int v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          int v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }
        while (!v7);
      }
      uint64_t v3 = v6;
    }
    while (v6 != (void *)(a1 + 16));
  }
  pthread_mutex_unlock(v2);
  sub_19E06746C(a1 + 56);
  sub_19E067268(*(char **)(a1 + 40));
  sub_19E0672C4(*(char **)(a1 + 16));
  return a1;
}

uint64_t sub_19E0676D4(uint64_t a1)
{
  uint64_t v2 = sub_19E066BD4();
  sub_19E066CA8(v2, *(void *)a1);
  *(void *)a1 = 0;
  if (*(char *)(a1 + 343) < 0) {
    operator delete(*(void **)(a1 + 320));
  }
  uint64_t v3 = MEMORY[0x1E4FBA418];
  uint64_t v4 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 56) = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 56 + *(void *)(v4 - 24)) = *(void *)(v3 + 24);
  *(void *)(a1 + 64) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 168);
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 4++**(_DWORD **)(result + 8) = 0;
  if (v5) {
    MEMORY[0x19F3BA6E0](v5, 0x1000C8052888210);
  }
  uint64_t v6 = *(void *)(a1 + 40);
  *(void *)(a1 + 4sub_19E03D880(&a9, 0) = 0;
  if (v6) {
    MEMORY[0x19F3BA6E0](v6, 0x1000C8052888210);
  }
  return a1;
}

uint64_t sub_19E067840(unint64_t *a1, char *a2, const char *a3)
{
  uint64_t v6 = sub_19E066BD4();
  sub_19E0413C8(v35, a2);
  BOOL v7 = (pthread_mutex_t *)(v6 + 64);
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 64));
  int v8 = sub_19E05E980(v6 + 8, v35);
  if ((void *)(v6 + 16) == v8) {
    operator new();
  }
  unint64_t v9 = v8[7];
  unint64_t v39 = v9;
  uint64_t v10 = sub_19E0687D0((uint64_t **)(v6 + 32), v9, &v39);
  ++*((void *)v10 + 8);
  pthread_mutex_unlock(v7);
  *a1 = v9;
  if (v36 < 0) {
    operator delete(v35[0]);
  }
  pthread_mutex_lock(v7);
  uint64_t v11 = *a1;
  if (*(void *)(*a1 + 8)) {
    goto LABEL_12;
  }
  uint64_t v12 = (char *)sub_19E0413C8(__p, a2);
  if (v38 >= 0) {
    char v13 = v12;
  }
  else {
    char v13 = (char *)__p[0];
  }
  char v14 = sub_19E067E70(v11, v13, a3);
  char v15 = v14;
  if (SHIBYTE(v38) < 0)
  {
    operator delete(__p[0]);
    if (v15) {
      goto LABEL_12;
    }
LABEL_20:
    uint64_t v23 = (char *)sub_19E05E6A8(*a1 + 48);
    BOOL v24 = sub_19E0413C8(__p, v23);
    if (v38 >= 0) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = __p[0];
    }
    if (v38 >= 0) {
      uint64_t v26 = HIBYTE(v38);
    }
    else {
      uint64_t v26 = (uint64_t)__p[1];
    }
    sub_19E0416F8(a1 + 7, (uint64_t)v25, v26);
    if (SHIBYTE(v38) < 0) {
      operator delete(__p[0]);
    }
    pthread_mutex_unlock(v7);
    uint64_t v27 = sub_19E066BD4();
    sub_19E066CA8(v27, *a1);
    uint64_t result = 0;
    *a1 = 0;
    return result;
  }
  if ((v14 & 1) == 0) {
    goto LABEL_20;
  }
LABEL_12:
  pthread_mutex_unlock(v7);
  uint64_t v16 = *(void *)(*a1 + 8);
  if (v16)
  {
    if (*(void *)(*a1 + 16) > 3uLL) {
      return sub_19E068494((uint64_t)a1, v16);
    }
    if (setjmp((int *)a1 + 86) != 1)
    {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(a1[7] - 24) + 56), 0);
      BOOL v28 = sub_19E0416F8(a1 + 7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/compressed_connector.cpp", 83);
      sub_19E0416F8(v28, (uint64_t)"(", 1);
      int v29 = (void *)std::ostream::operator<<();
      int v30 = sub_19E0416F8(v29, (uint64_t)") [", 3);
      int32x2_t v31 = sub_19E0416F8(v30, (uint64_t)"cmmap_->size() >= 2", 19);
      unint64_t v32 = sub_19E0416F8(v31, (uint64_t)"] ", 2);
      uint64_t v33 = sub_19E0416F8(v32, (uint64_t)"file size is invalid: ", 22);
      size_t v34 = strlen(a2);
      sub_19E0416F8(v33, (uint64_t)a2, v34);
      longjmp((int *)a1 + 86, 1);
    }
  }
  else if (setjmp((int *)a1 + 86) != 1)
  {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(a1[7] - 24) + 56), 0);
    uint64_t v18 = sub_19E0416F8(a1 + 7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/compressed_connector.cpp", 83);
    sub_19E0416F8(v18, (uint64_t)"(", 1);
    unint64_t v19 = (void *)std::ostream::operator<<();
    uint64_t v20 = sub_19E0416F8(v19, (uint64_t)") [", 3);
    BOOL v21 = sub_19E0416F8(v20, (uint64_t)"cmmap_->begin()", 15);
    uint64_t v22 = sub_19E0416F8(v21, (uint64_t)"] ", 2);
    sub_19E0416F8(v22, (uint64_t)"matrix is NULL", 14);
    longjmp((int *)a1 + 86, 1);
  }
  return 0;
}

void sub_19E067DE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E067E70(uint64_t a1, char *a2, const char *a3)
{
  sub_19E068788(a1);
  sub_19E0413C8(&v47, a2);
  uint64_t v6 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*v6);
  }
  *(_OWORD *)uint64_t v6 = *(_OWORD *)&v47.st_dev;
  *(void *)(a1 + 4sub_19E03D880(&a9, 0) = *(void *)&v47.st_uid;
  if (!strcmp(a3, "r"))
  {
    *(_DWORD *)(a1 + 532) = 0;
    int v14 = open(a2, 0);
    *(_DWORD *)(a1 + 52++**(_DWORD **)(result + 8) = v14;
    if (v14 < 0)
    {
      if (setjmp((int *)(a1 + 336)) != 1)
      {
        std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
        char v15 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/mmap.h", 65);
        sub_19E0416F8(v15, (uint64_t)"(", 1);
        uint64_t v16 = (void *)std::ostream::operator<<();
        BOOL v17 = sub_19E0416F8(v16, (uint64_t)") [", 3);
        uint64_t v18 = sub_19E0416F8(v17, (uint64_t)"(fd = ::open(filename, flag | O_BINARY)) >= 0", 45);
        unint64_t v19 = sub_19E0416F8(v18, (uint64_t)"] ", 2);
        uint64_t v20 = sub_19E0416F8(v19, (uint64_t)"open failed: ", 13);
        size_t v21 = strlen(a2);
        sub_19E0416F8(v20, (uint64_t)a2, v21);
        longjmp((int *)(a1 + 336), 1);
      }
      goto LABEL_22;
    }
    goto LABEL_11;
  }
  if (!strcmp(a3, "r+"))
  {
    *(_DWORD *)(a1 + 532) = 514;
    int v14 = open(a2, 514, 384);
    *(_DWORD *)(a1 + 52++**(_DWORD **)(result + 8) = v14;
    if (v14 < 0)
    {
      if (setjmp((int *)(a1 + 336)) != 1)
      {
        std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
        uint64_t v33 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/mmap.h", 65);
        sub_19E0416F8(v33, (uint64_t)"(", 1);
        size_t v34 = (void *)std::ostream::operator<<();
        uint64_t v35 = sub_19E0416F8(v34, (uint64_t)") [", 3);
        char v36 = sub_19E0416F8(v35, (uint64_t)"(fd = ::open(filename, flag | O_BINARY, S_IRUSR | S_IWUSR)) >= 0", 64);
        unsigned __int16 v37 = sub_19E0416F8(v36, (uint64_t)"] ", 2);
        uint64_t v38 = sub_19E0416F8(v37, (uint64_t)"open failed: ", 13);
        size_t v39 = strlen(a2);
        sub_19E0416F8(v38, (uint64_t)a2, v39);
        longjmp((int *)(a1 + 336), 1);
      }
      goto LABEL_22;
    }
LABEL_11:
    if (fstat(v14, &v47) < 0)
    {
      if (setjmp((int *)(a1 + 336)) != 1)
      {
        std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
        uint64_t v25 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/mmap.h", 65);
        sub_19E0416F8(v25, (uint64_t)"(", 1);
        uint64_t v26 = (void *)std::ostream::operator<<();
        uint64_t v27 = sub_19E0416F8(v26, (uint64_t)") [", 3);
        BOOL v28 = sub_19E0416F8(v27, (uint64_t)"fstat(fd, &st) >= 0", 19);
        int v29 = sub_19E0416F8(v28, (uint64_t)"] ", 2);
        int v30 = sub_19E0416F8(v29, (uint64_t)"failed to get file size: ", 25);
        size_t v31 = strlen(a2);
        sub_19E0416F8(v30, (uint64_t)a2, v31);
        longjmp((int *)(a1 + 336), 1);
      }
      goto LABEL_22;
    }
    off_t st_size = v47.st_size;
    *(void *)(a1 + 16) = v47.st_size;
    if (st_size)
    {
      uint64_t v23 = mmap(0, st_size, *(_DWORD *)(a1 + 532) & 2 | 1u, 1, *(_DWORD *)(a1 + 528), 0);
      if (v23 == (void *)-1)
      {
        if (setjmp((int *)(a1 + 336)) != 1)
        {
          std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
          unint64_t v40 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/mmap.h", 65);
          sub_19E0416F8(v40, (uint64_t)"(", 1);
          uint64_t v41 = (void *)std::ostream::operator<<();
          uint64_t v42 = sub_19E0416F8(v41, (uint64_t)") [", 3);
          int v43 = sub_19E0416F8(v42, (uint64_t)"(p = reinterpret_cast<char*>(mmap(0, length, prot, MAP_SHARED, fd, 0))) != MAP_FAILED", 85);
          uint64_t v44 = sub_19E0416F8(v43, (uint64_t)"] ", 2);
          unsigned __int16 v45 = sub_19E0416F8(v44, (uint64_t)"mmap() failed: ", 15);
          size_t v46 = strlen(a2);
          sub_19E0416F8(v45, (uint64_t)a2, v46);
          longjmp((int *)(a1 + 336), 1);
        }
        goto LABEL_22;
      }
      BOOL v24 = v23;
      madvise(v23, *(void *)(a1 + 16), 1);
    }
    else
    {
      BOOL v24 = 0;
    }
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = v24;
    close(*(_DWORD *)(a1 + 528));
    *(_DWORD *)(a1 + 52++**(_DWORD **)(result + 8) = -1;
    return 1;
  }
  if (setjmp((int *)(a1 + 336)) != 1)
  {
    std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
    BOOL v7 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/mmap.h", 65);
    sub_19E0416F8(v7, (uint64_t)"(", 1);
    int v8 = (void *)std::ostream::operator<<();
    unint64_t v9 = sub_19E0416F8(v8, (uint64_t)") [", 3);
    uint64_t v10 = sub_19E0416F8(v9, (uint64_t)"false", 5);
    uint64_t v11 = sub_19E0416F8(v10, (uint64_t)"] ", 2);
    uint64_t v12 = sub_19E0416F8(v11, (uint64_t)"unknown open mode: ", 19);
    size_t v13 = strlen(a2);
    sub_19E0416F8(v12, (uint64_t)a2, v13);
    longjmp((int *)(a1 + 336), 1);
  }
LABEL_22:
  sub_19E068788(a1);
  return 0;
}

void sub_19E06847C()
{
  sub_19E05E710(v0);
}

uint64_t sub_19E068494(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int16 *)(a2 + 8);
  *(_WORD *)(a1 + 32) = v3;
  int v4 = *(unsigned __int16 *)(a2 + 10);
  *(_WORD *)(a1 + 34) = v4;
  if (v3)
  {
    if (v4)
    {
      uint64_t v5 = *(unsigned int *)(a2 + 12);
      if (v5)
      {
        uint64_t v6 = a2 + 16 + 4 * v3 + 4;
        *(void *)(a1 + ++**(_DWORD **)(result + 8) = a2 + 16;
        *(void *)(a1 + 16) = v6;
        *(void *)(a1 + 24) = v6 + 2 * v5;
        return 1;
      }
      BOOL v24 = (int *)(a1 + 344);
      if (setjmp((int *)(a1 + 344)) != 1)
      {
        uint64_t v26 = *(void *)(a1 + 56);
        uint64_t v25 = (void *)(a1 + 56);
        std::ios_base::clear((std::ios_base *)((char *)v25 + *(void *)(v26 - 24)), 0);
        uint64_t v27 = sub_19E0416F8(v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/compressed_connector.cpp", 83);
        sub_19E0416F8(v27, (uint64_t)"(", 1);
        BOOL v28 = (void *)std::ostream::operator<<();
        int v29 = sub_19E0416F8(v28, (uint64_t)") [", 3);
        int v30 = sub_19E0416F8(v29, (uint64_t)"num_elements > 0", 16);
        size_t v31 = sub_19E0416F8(v30, (uint64_t)"] ", 2);
        sub_19E0416F8(v31, (uint64_t)"number of elements is invalid", 29);
        longjmp(v24, 1);
      }
    }
    else
    {
      uint64_t v16 = (int *)(a1 + 344);
      if (setjmp((int *)(a1 + 344)) != 1)
      {
        uint64_t v18 = *(void *)(a1 + 56);
        BOOL v17 = (void *)(a1 + 56);
        std::ios_base::clear((std::ios_base *)((char *)v17 + *(void *)(v18 - 24)), 0);
        unint64_t v19 = sub_19E0416F8(v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/compressed_connector.cpp", 83);
        sub_19E0416F8(v19, (uint64_t)"(", 1);
        uint64_t v20 = (void *)std::ostream::operator<<();
        size_t v21 = sub_19E0416F8(v20, (uint64_t)") [", 3);
        uint64_t v22 = sub_19E0416F8(v21, (uint64_t)"rsize_ > 0", 10);
        uint64_t v23 = sub_19E0416F8(v22, (uint64_t)"] ", 2);
        sub_19E0416F8(v23, (uint64_t)"left size is invalid", 20);
        longjmp(v16, 1);
      }
    }
  }
  else
  {
    int v8 = (int *)(a1 + 344);
    if (setjmp((int *)(a1 + 344)) != 1)
    {
      uint64_t v10 = *(void *)(a1 + 56);
      unint64_t v9 = (void *)(a1 + 56);
      std::ios_base::clear((std::ios_base *)((char *)v9 + *(void *)(v10 - 24)), 0);
      uint64_t v11 = sub_19E0416F8(v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/compressed_connector.cpp", 83);
      sub_19E0416F8(v11, (uint64_t)"(", 1);
      uint64_t v12 = (void *)std::ostream::operator<<();
      size_t v13 = sub_19E0416F8(v12, (uint64_t)") [", 3);
      int v14 = sub_19E0416F8(v13, (uint64_t)"lsize_ > 0", 10);
      char v15 = sub_19E0416F8(v14, (uint64_t)"] ", 2);
      sub_19E0416F8(v15, (uint64_t)"left size is invalid", 20);
      longjmp(v8, 1);
    }
  }
  return 0;
}

void sub_19E068778()
{
  sub_19E05E710(v0);
}

void *sub_19E068788(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 528);
  if ((v2 & 0x80000000) == 0)
  {
    close(v2);
    *(_DWORD *)(a1 + 52++**(_DWORD **)(result + 8) = -1;
  }
  uint64_t result = *(void **)(a1 + 8);
  if (result) {
    uint64_t result = (void *)munmap(result, *(void *)(a1 + 16));
  }
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  return result;
}

char *sub_19E0687D0(uint64_t **a1, unint64_t a2, void *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = (char *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = v5;
        unint64_t v8 = *((void *)v5 + 4);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *(char **)v7;
        uint64_t v6 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = (char *)*((void *)v7 + 1);
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v7 = (char *)(a1 + 1);
LABEL_9:
    unint64_t v9 = v7;
    BOOL v7 = (char *)operator new(0x48uLL);
    *((void *)v7 + 4) = *a3;
    *(_OWORD *)(v7 + 4sub_19E03D880(&a9, 0) = 0u;
    *(_OWORD *)(v7 + 56) = 0u;
    *(void *)BOOL v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v9;
    void *v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_19E05D650(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_19E0688A8(uint64_t a1)
{
  sub_19E0688E0(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E0688E0(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C3F0;
  sub_19E068788(a1);
  if (*(char *)(a1 + 335) < 0) {
    operator delete(*(void **)(a1 + 312));
  }
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 4++**(_DWORD **)(result + 8) = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 48 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 56) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 160);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

uint64_t *sub_19E068A30(uint64_t *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA460] + 64;
  a1[53] = MEMORY[0x1E4FBA460] + 64;
  uint64_t v3 = a1 + 2;
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA3F8] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA3F8] + 8);
  *a1 = v5;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = v4;
  a1[1] = 0;
  uint64_t v6 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v6, a1 + 2);
  uint64_t v7 = MEMORY[0x1E4FBA460] + 24;
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *a1 = v7;
  a1[53] = v2;
  MEMORY[0x19F3BA3F0](v3);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_19E068BBC(_Unwind_Exception *a1)
{
  std::istream::~istream();
  MEMORY[0x19F3BA690](v1);
  _Unwind_Resume(a1);
}

void sub_19E068BF4()
{
  std::ios_base::getloc((const std::ios_base *)(MEMORY[0x1E4FBA240] + *(void *)(*MEMORY[0x1E4FBA240] - 24)));
  uint64_t v0 = std::locale::use_facet(&v1, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v0->__vftable[2].~facet_0)(v0, 10);
  std::locale::~locale(&v1);
  std::ostream::put();
  std::ostream::flush();
  exit(-1);
}

void sub_19E068C9C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void *sub_19E068CB8(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA3F8];
  uint64_t v3 = *MEMORY[0x1E4FBA3F8];
  *a1 = *MEMORY[0x1E4FBA3F8];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x19F3BA400](a1 + 2);
  std::istream::~istream();
  MEMORY[0x19F3BA690](a1 + 53);
  return a1;
}

void *sub_19E068D84(unint64_t a1)
{
  if (a1 >> 62) {
    sub_19E0416C4();
  }
  return operator new(4 * a1);
}

void sub_19E068DBC(uint64_t a1)
{
  sub_19E068DF4(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E068DF4(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C020;
  *(void *)(a1 + 192) = &unk_1EF09BF60;
  uint64_t v2 = *(void *)(a1 + 200);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)(a1 + 176) = &unk_1EF09BE80;
  uint64_t v3 = *(void *)(a1 + 184);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(void **)(a1 + 144);
  if (v4)
  {
    *(void *)(a1 + 152) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 120);
  if (v5)
  {
    *(void *)(a1 + 12++**(_DWORD **)(result + 8) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 96);
  if (v6)
  {
    *(void *)(a1 + 104) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(void **)(a1 + 72);
  if (v7)
  {
    *(void *)(a1 + 8sub_19E03D880(&a9, 0) = v7;
    operator delete(v7);
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  return a1;
}

void sub_19E068F1C(void *a1)
{
  *a1 = &unk_1EF09BE80;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E068FA8(void *a1)
{
  *a1 = &unk_1EF09BE80;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_19E069014(void *a1)
{
  *a1 = &unk_1EF09BF60;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0690A0(void *a1)
{
  *a1 = &unk_1EF09BF60;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

std::string *sub_19E069110(std::string *a1, char *a2)
{
  return sub_19E069118(a1 + 2, a2);
}

std::string *sub_19E069118(std::string *a1, char *__s)
{
  size_t v4 = strlen(__s);

  return sub_19E069160(a1, __s, v4);
}

std::string *sub_19E069160(std::string *__dst, const std::string::value_type *__src, size_t __len)
{
  LODWORD(v6) = SHIBYTE(__dst->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = __dst->__r_.__value_.__r.__words[2];
    std::string::size_type v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __len)
    {
      std::string::size_type size = __dst->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    unint64_t v6 = HIBYTE(v10);
    uint64_t v7 = (std::string *)__dst->__r_.__value_.__r.__words[0];
  }
  else
  {
    uint64_t v7 = __dst;
    if (__len > 0x16)
    {
      std::string::size_type size = HIBYTE(__dst->__r_.__value_.__r.__words[2]);
      std::string::size_type v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(__dst, v9, __len - v9, size, 0, size, __len, __src);
      return __dst;
    }
  }
  if (__len)
  {
    memmove(v7, __src, __len);
    LOBYTE(v6) = *((unsigned char *)&__dst->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0) {
    __dst->__r_.__value_.__l.__size_ = __len;
  }
  else {
    *((unsigned char *)&__dst->__r_.__value_.__s + 23) = __len & 0x7F;
  }
  v7->__r_.__value_.__s.__data_[__len] = 0;
  return __dst;
}

uint64_t sub_19E069220(uint64_t a1)
{
  uint64_t result = a1 + 48;
  if (*(char *)(a1 + 71) < 0) {
    return *(void *)result;
  }
  return result;
}

void sub_19E06923C(uint64_t a1, const char *a2)
{
  uint64_t v105 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 200))(a1);
  size_t v5 = strlen(a2) + 1;
  unint64_t v6 = (char *)sub_19E069BA8(v4, v5);
  strncpy(v6, a2, v5);
  size_t v7 = strlen(a2);
  size_t v8 = strlen(v6);
  std::string::size_type v9 = 0;
  unint64_t v10 = 0;
  if (v7)
  {
    unint64_t v11 = 0;
    unint64_t v12 = 0;
    size_t v13 = &v6[v8];
    size_t v88 = v7;
    while (1)
    {
      int v14 = v13;
      if (v6 != v13)
      {
        int v14 = v6;
        while (*v14 != 10)
        {
          if (++v14 == v13)
          {
            int v14 = v13;
            break;
          }
        }
      }
      *int v14 = 0;
      if ((unint64_t)v10 >= v11)
      {
        uint64_t v15 = v10 - v9;
        unint64_t v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 61) {
          sub_19E041BEC();
        }
        if ((uint64_t)(v11 - (void)v9) >> 2 > v16) {
          unint64_t v16 = (uint64_t)(v11 - (void)v9) >> 2;
        }
        if (v11 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v17) {
          unint64_t v17 = (unint64_t)sub_19E060B48(v17);
        }
        else {
          uint64_t v18 = 0;
        }
        unint64_t v19 = (char **)(v17 + 8 * v15);
        void *v19 = v6;
        uint64_t v20 = v19 + 1;
        while (v10 != v9)
        {
          size_t v21 = *--v10;
          *--unint64_t v19 = v21;
        }
        unint64_t v11 = v17 + 8 * v18;
        if (v9) {
          operator delete(v9);
        }
        std::string::size_type v9 = v19;
        unint64_t v10 = v20;
        size_t v7 = v88;
      }
      else
      {
        *v10++ = v6;
      }
      ++v12;
      if (v14 == v13) {
        break;
      }
      unint64_t v6 = v14 + 1;
      if (v12 == v7)
      {
        unint64_t v12 = v7;
        break;
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  if (v12 != v10 - v9)
  {
    unsigned int v80 = sub_19E0416F8(MEMORY[0x1E4FBA240], (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/lattice_impl.cpp", 75);
    sub_19E0416F8(v80, (uint64_t)"(", 1);
    int v81 = (void *)std::ostream::operator<<();
    int v82 = sub_19E0416F8(v81, (uint64_t)") [", 3);
    uint64_t v83 = sub_19E0416F8(v82, (uint64_t)"lsize == lines.size()", 21);
    sub_19E0416F8(v83, (uint64_t)"] ", 2);
    goto LABEL_102;
  }
  memset(&v97, 0, sizeof(v97));
  uint64_t v94 = 0;
  uint64_t v95 = 0;
  unint64_t v96 = 0;
  uint64_t v91 = 0;
  uint64_t v92 = 0;
  unint64_t v93 = 0;
  if (v10 != v9)
  {
    uint64_t v22 = 0;
    uint64_t v23 = v12 <= 1 ? 1 : v12;
    while (2)
    {
      BOOL v24 = v9[v22];
      if (strcmp("EOS", v24))
      {
        v103 = 0;
        uint64_t v104 = 0;
        size_t v25 = strlen(v24);
        char v26 = 0;
        uint64_t v27 = &v24[v25];
        BOOL v28 = (const char **)&v103;
        while (1)
        {
          char v29 = v26;
          if (v24 == v27) {
            break;
          }
          int v30 = v24;
          while (*v30 != 9)
          {
            if (++v30 == v27) {
              goto LABEL_44;
            }
          }
          const char *v30 = 0;
          *v28++ = v24;
          char v26 = 1;
          BOOL v24 = v30 + 1;
          if (v29) {
            goto LABEL_45;
          }
        }
        BOOL v24 = v27;
LABEL_44:
        const char *v27 = 0;
        void *v28 = v24;
        if ((v26 & 1) == 0) {
          break;
        }
LABEL_45:
        size_t v31 = v103;
        std::string::size_type v32 = strlen(v103);
        std::string::append(&v97, v103, v32);
        sub_19E0413C8(__p, v31);
        uint64_t v33 = v95;
        if ((unint64_t)v95 >= v96)
        {
          unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v95[-v94] >> 3);
          unint64_t v36 = v35 + 1;
          if (v35 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_19E041BEC();
          }
          if (0x5555555555555556 * ((uint64_t)(v96 - v94) >> 3) > v36) {
            unint64_t v36 = 0x5555555555555556 * ((uint64_t)(v96 - v94) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v96 - v94) >> 3) >= 0x555555555555555) {
            unint64_t v37 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v37 = v36;
          }
          v102 = &v96;
          if (v37) {
            uint64_t v38 = (void **)sub_19E041C04((uint64_t)&v96, v37);
          }
          else {
            uint64_t v38 = 0;
          }
          size_t v39 = &v38[3 * v35];
          unint64_t v98 = v38;
          uint64_t v99 = v39;
          uint64_t v101 = &v38[3 * v37];
          long long v40 = *(_OWORD *)__p;
          v39[2] = v90;
          *(_OWORD *)size_t v39 = v40;
          __p[1] = 0;
          unint64_t v90 = 0;
          __p[0] = 0;
          uint64_t v100 = v39 + 3;
          sub_19E041B74(&v94, &v98);
          uint64_t v41 = v95;
          sub_19E041D6C((uint64_t)&v98);
          uint64_t v95 = v41;
          if (SHIBYTE(v90) < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          long long v34 = *(_OWORD *)__p;
          *((void *)v95 + 2) = v90;
          *uint64_t v33 = v34;
          uint64_t v95 = (char *)v33 + 24;
        }
        sub_19E0413C8(__p, v104);
        uint64_t v42 = v92;
        if ((unint64_t)v92 >= v93)
        {
          unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v92[-v91] >> 3);
          unint64_t v45 = v44 + 1;
          if (v44 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_19E041BEC();
          }
          if (0x5555555555555556 * ((uint64_t)(v93 - v91) >> 3) > v45) {
            unint64_t v45 = 0x5555555555555556 * ((uint64_t)(v93 - v91) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v93 - v91) >> 3) >= 0x555555555555555) {
            unint64_t v46 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v46 = v45;
          }
          v102 = &v93;
          if (v46) {
            stat v47 = (void **)sub_19E041C04((uint64_t)&v93, v46);
          }
          else {
            stat v47 = 0;
          }
          unint64_t v48 = &v47[3 * v44];
          unint64_t v98 = v47;
          uint64_t v99 = v48;
          uint64_t v101 = &v47[3 * v46];
          long long v49 = *(_OWORD *)__p;
          v48[2] = v90;
          *(_OWORD *)unint64_t v48 = v49;
          __p[1] = 0;
          unint64_t v90 = 0;
          __p[0] = 0;
          uint64_t v100 = v48 + 3;
          sub_19E041B74(&v91, &v98);
          int v50 = v92;
          sub_19E041D6C((uint64_t)&v98);
          uint64_t v92 = v50;
          if (SHIBYTE(v90) < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          long long v43 = *(_OWORD *)__p;
          *((void *)v92 + 2) = v90;
          *uint64_t v42 = v43;
          uint64_t v92 = (char *)v42 + 24;
        }
        if (++v22 != v23) {
          continue;
        }
      }
      break;
    }
  }
  if (&v92[-v91] != &v95[-v94])
  {
    uint64_t v84 = sub_19E0416F8(MEMORY[0x1E4FBA240], (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/lattice_impl.cpp", 75);
    sub_19E0416F8(v84, (uint64_t)"(", 1);
    uint64_t v85 = (void *)std::ostream::operator<<();
    BOOL v86 = sub_19E0416F8(v85, (uint64_t)") [", 3);
    int v87 = sub_19E0416F8(v86, (uint64_t)"features.size() == surfaces.size()", 34);
    sub_19E0416F8(v87, (uint64_t)"] ", 2);
LABEL_102:
    sub_19E068BF4();
  }
  uint64_t v51 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 200))(a1);
  std::string::size_type size = HIBYTE(v97.__r_.__value_.__r.__words[2]);
  int v53 = SHIBYTE(v97.__r_.__value_.__r.__words[2]);
  std::string::size_type v54 = v97.__r_.__value_.__r.__words[0];
  if ((v97.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v97.__r_.__value_.__l.__size_;
  }
  size_t v55 = size + 1;
  int v56 = (char *)sub_19E069BA8(v51, size + 1);
  int v57 = v56;
  if (v53 >= 0) {
    BOOL v58 = &v97;
  }
  else {
    BOOL v58 = (std::string *)v54;
  }
  strncpy(v56, (const char *)v58, v55);
  (*(void (**)(uint64_t, char *))(*(void *)a1 + 72))(a1, v57);
  uint64_t v59 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 200))(a1);
  uint64_t v60 = sub_19E0609C8(*(void **)(v59 + 16));
  *(_OWORD *)(v60 + 96) = 0u;
  *(_OWORD *)(v60 + 112) = 0u;
  *(_OWORD *)(v60 + 64) = 0u;
  *(_OWORD *)(v60 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(v60 + 32) = 0u;
  *(_OWORD *)(v60 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)uint64_t v60 = 0u;
  *(_OWORD *)(v60 + 16) = 0u;
  *(void *)(v60 + 4++**(_DWORD **)(result + 8) = "BOS/EOS";
  *(void *)(v60 + 56) = "BOS/EOS";
  *(unsigned char *)(v60 + 124) = 2;
  uint64_t v61 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 200))(a1);
  uint64_t v62 = sub_19E0609C8(*(void **)(v61 + 16));
  *(_OWORD *)(v62 + 96) = 0u;
  *(_OWORD *)(v62 + 112) = 0u;
  *(_OWORD *)(v62 + 64) = 0u;
  *(_OWORD *)(v62 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(v62 + 32) = 0u;
  *(_OWORD *)(v62 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)uint64_t v62 = 0u;
  *(_OWORD *)(v62 + 16) = 0u;
  *(void *)(v62 + 4++**(_DWORD **)(result + 8) = "BOS/EOS";
  *(void *)(v62 + 56) = "BOS/EOS";
  *(unsigned char *)(v62 + 124) = 3;
  *(void *)(v60 + 4++**(_DWORD **)(result + 8) = *(void *)(a1 + 8);
  **(void **)(a1 + 72) = v60;
  if (v95 == (char *)v94)
  {
    uint64_t v68 = v60;
  }
  else
  {
    uint64_t v63 = 0;
    unint64_t v64 = 0;
    uint64_t v65 = 0;
    do
    {
      uint64_t v66 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 200))(a1);
      uint64_t v67 = sub_19E0609C8(*(void **)(v66 + 16));
      uint64_t v68 = v67;
      *(void *)(v67 + 12sub_19E03D880(&a9, 0) = 0;
      *(_OWORD *)(v67 + 104) = 0u;
      *(_OWORD *)(v67 + 8++**(_DWORD **)(result + 8) = 0u;
      *(_OWORD *)(v67 + 72) = 0u;
      *(_OWORD *)(v67 + 56) = 0u;
      *(_OWORD *)(v67 + 4sub_19E03D880(&a9, 0) = 0u;
      *(_OWORD *)(v67 + 24) = 0u;
      *(_OWORD *)(v67 + ++**(_DWORD **)(result + 8) = 0u;
      *(void *)uint64_t v67 = v60;
      *(void *)(v60 + ++**(_DWORD **)(result + 8) = v67;
      *(void *)(v67 + 4++**(_DWORD **)(result + 8) = *(void *)(a1 + 8) + v65;
      uint64_t v69 = v94;
      uint64_t v70 = v94 + v63;
      if (*(char *)(v94 + v63 + 23) < 0) {
        uint64_t v71 = *(void *)(v70 + 8);
      }
      else {
        LOWORD(v71) = *(unsigned __int8 *)(v94 + v63 + 23);
      }
      *(_WORD *)(v67 + 96) = v71;
      int v72 = *(char *)(v70 + 23);
      if (v72 < 0) {
        uint64_t v73 = *(void *)(v69 + v63 + 8);
      }
      else {
        LOWORD(v73) = v72;
      }
      *(_WORD *)(v67 + 9++**(_DWORD **)(result + 8) = v73;
      *(unsigned char *)(v67 + 124) = 0;
      *(_DWORD *)(v67 + 8sub_19E03D880(&a9, 0) = 0;
      *(void *)(v67 + 112) = 0;
      uint64_t v74 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 200))(a1);
      uint64_t v75 = v91 + v63;
      if (*(char *)(v91 + v63 + 23) < 0)
      {
        uint64_t v77 = *(const char **)v75;
        uint64_t v76 = *(void *)(v75 + 8);
      }
      else
      {
        uint64_t v76 = *(unsigned __int8 *)(v91 + v63 + 23);
        uint64_t v77 = (const char *)(v91 + v63);
      }
      size_t v78 = v76 + 1;
      unsigned int v79 = (char *)sub_19E069BA8(v74, v76 + 1);
      *(void *)(v68 + 56) = strncpy(v79, v77, v78);
      *(void *)(*(void *)(a1 + 96) + 8 * v65) = v68;
      v65 += *(unsigned __int16 *)(v68 + 96);
      *(void *)(*(void *)(a1 + 72) + 8 * v65) = v68;
      ++v64;
      v63 += 24;
      uint64_t v60 = v68;
    }
    while (v64 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v95[-v94] >> 3));
  }
  *(void *)(v68 + ++**(_DWORD **)(result + 8) = v62;
  *(void *)uint64_t v62 = v68;
  unint64_t v98 = (void **)&v91;
  sub_19E041AD0(&v98);
  unint64_t v98 = (void **)&v94;
  sub_19E041AD0(&v98);
  if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v97.__r_.__value_.__l.__data_);
  }
  if (v9) {
    operator delete(v9);
  }
}

void sub_19E069B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char **a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  a10 = &a16;
  sub_19E041AD0((void ***)&a10);
  a16 = &a19;
  sub_19E041AD0((void ***)&a16);
  if (a27 < 0) {
    operator delete(__p);
  }
  if (v28) {
    operator delete(v28);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E069BA8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (!v2) {
    operator new();
  }
  uint64_t v3 = a2 + 1;
  uint64_t v4 = v2[1];
  uint64_t v5 = v2[2] - v4;
  unint64_t v6 = v2[5];
  if (v6 >= v5 >> 4) {
LABEL_7:
  }
    operator new[]();
  uint64_t v7 = v5 >> 4;
  uint64_t v8 = v2[4];
  std::string::size_type v9 = (unint64_t *)(v4 + 16 * v6);
  while (1)
  {
    unint64_t v10 = *v9;
    v9 += 2;
    if (v8 + v3 < v10) {
      break;
    }
    uint64_t v8 = 0;
    ++v6;
    v2[4] = 0;
    v2[5] = v6;
    if (v7 == v6) {
      goto LABEL_7;
    }
  }
  uint64_t result = *(void *)(v4 + 16 * v6 + 8) + v8;
  v2[4] = v8 + v3;
  return result;
}

void sub_19E069DD0(void *a1)
{
  sub_19E069E08(a1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E069E08(void *a1)
{
  *a1 = &unk_1EF09C250;
  a1[5] = 0;
  uint64_t v4 = a1 + 1;
  uint64_t v2 = (char *)a1[1];
  uint64_t v3 = (char *)v4[1];
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (!v3) {
      return a1;
    }
    goto LABEL_7;
  }
  unint64_t v5 = 0;
  do
  {
    if (*(void *)&v2[16 * v5 + 8])
    {
      MEMORY[0x19F3BA6E0](*(void *)&v2[16 * v5 + 8], 0x1000C8077774924);
      unint64_t v5 = a1[5];
      uint64_t v2 = (char *)a1[1];
      uint64_t v3 = (char *)a1[2];
    }
    a1[5] = ++v5;
  }
  while (v5 < (v3 - v2) >> 4);
  if (v2)
  {
LABEL_7:
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void *sub_19E069EB8(void *result, unint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a2 < a3 && a4)
  {
    unint64_t v5 = a3;
    uint64_t v7 = result;
    if (result[15] == result[16])
    {
      uint64_t v10 = (*(uint64_t (**)(void *))(*result + 88))(result);
      unint64_t v11 = v10 + 4;
      uint64_t v13 = v7[15];
      unint64_t v12 = (void *)v7[16];
      unint64_t v14 = ((uint64_t)v12 - v13) >> 3;
      if (v10 + 4 <= v14)
      {
        if (v11 < v14) {
          unsigned char v7[16] = v13 + 8 * v11;
        }
      }
      else
      {
        uint64_t v15 = v10;
        uint64_t v16 = v7[17];
        if (v11 - v14 <= (v16 - (uint64_t)v12) >> 3)
        {
          int v30 = &v12[v11 - v14];
          uint64_t v31 = 8 * v10 - 8 * v14 + 32;
          do
          {
            *v12++ = 0;
            v31 -= 8;
          }
          while (v31);
          unsigned char v7[16] = v30;
        }
        else
        {
          if (v11 >> 61) {
            sub_19E041BEC();
          }
          unint64_t v17 = v16 - v13;
          unint64_t v18 = (v16 - v13) >> 2;
          if (v18 <= v11) {
            unint64_t v18 = v10 + 4;
          }
          if (v17 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v18;
          }
          uint64_t v20 = (char *)sub_19E060B48(v19);
          uint64_t v22 = &v20[8 * v14];
          uint64_t v23 = &v20[8 * v11];
          uint64_t v24 = 8 * v15 - 8 * v14 + 32;
          size_t v25 = v22;
          do
          {
            *(void *)size_t v25 = 0;
            v25 += 8;
            v24 -= 8;
          }
          while (v24);
          char v26 = &v20[8 * v21];
          BOOL v28 = (char *)v7[15];
          uint64_t v27 = (char *)v7[16];
          if (v27 != v28)
          {
            do
            {
              uint64_t v29 = *((void *)v27 - 1);
              v27 -= 8;
              *((void *)v22 - 1) = v29;
              v22 -= 8;
            }
            while (v27 != v28);
            uint64_t v27 = (char *)v7[15];
          }
          v7[15] = v22;
          unsigned char v7[16] = v23;
          v7[17] = v26;
          if (v27) {
            operator delete(v27);
          }
        }
      }
    }
    unint64_t v8 = (*(uint64_t (**)(void *))(*v7 + 88))(v7);
    if (v8 < v5) {
      unint64_t v5 = v8;
    }
    (*(void (**)(void *, unint64_t, uint64_t))(*v7 + 288))(v7, a2, 1);
    uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*v7 + 288))(v7, v5, 1);
    unint64_t v9 = a2 + 1;
    if (a2 + 1 < v5)
    {
      do
        uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*v7 + 288))(v7, v9++, 2);
      while (v5 != v9);
    }
    *(void *)(v7[15] + 8 * a2) = a4;
  }
  return result;
}

void sub_19E06A124(unint64_t *a1, uint64_t a2, char a3)
{
  unint64_t v6 = a1[18];
  unint64_t v5 = a1 + 18;
  if (v6 == a1[19])
  {
    uint64_t v8 = (*(uint64_t (**)(unint64_t *))(*a1 + 88))(a1);
    unint64_t v9 = v8 + 4;
    unint64_t v6 = a1[18];
    uint64_t v10 = (unsigned char *)a1[19];
    unint64_t v11 = &v10[-v6];
    unint64_t v12 = v8 + 4 - (void)&v10[-v6];
    if (v8 + 4 <= (unint64_t)&v10[-v6])
    {
      if (v8 + 4 < (unint64_t)&v10[-v6]) {
        a1[19] = v6 + v9;
      }
    }
    else
    {
      unint64_t v13 = a1[20];
      if (v13 - (unint64_t)v10 >= v12)
      {
        do
        {
          *v10++ = 0;
          --v12;
        }
        while (v12);
        a1[19] = v8 + 4 + v6;
      }
      else
      {
        if ((v9 & 0x8000000000000000) != 0) {
          sub_19E041BEC();
        }
        unint64_t v14 = v13 - v6;
        unint64_t v15 = 2 * (v13 - v6);
        if (v15 <= v9) {
          unint64_t v15 = v8 + 4;
        }
        if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v16 = v15;
        }
        unint64_t v17 = (unint64_t)operator new(v16);
        unint64_t v18 = &v11[v17];
        unint64_t v19 = (char *)(v17 + v9);
        do
          (v11++)[v17] = 0;
        while ((unsigned char *)v9 != v11);
        uint64_t v20 = (char *)(v17 + v16);
        if (v10 == (unsigned char *)v6)
        {
          unint64_t v17 = (unint64_t)v18;
        }
        else
        {
          uint64_t v21 = &v10[~v6];
          do
          {
            char v22 = *--v10;
            (v21--)[v17] = v22;
          }
          while (v10 != (unsigned char *)v6);
          uint64_t v10 = (unsigned char *)*v5;
        }
        a1[18] = v17;
        a1[19] = (unint64_t)v19;
        a1[20] = (unint64_t)v20;
        if (v10) {
          operator delete(v10);
        }
      }
      unint64_t v6 = *v5;
    }
  }
  *(unsigned char *)(v6 + a2) = a3;
}

uint64_t sub_19E06A288(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 120);
  if (v2 == *(void *)(a1 + 128)) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t sub_19E06A2A4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 144);
  if (v2 == *(void *)(a1 + 152)) {
    return 0;
  }
  else {
    return *(unsigned __int8 *)(v2 + a2);
  }
}

BOOL sub_19E06A2C0(uint64_t a1)
{
  return *(void *)(a1 + 144) != *(void *)(a1 + 152);
}

uint64_t sub_19E06A2D0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = &unk_1EF09C1F0;
  v6[1] = 0;
  v6[2] = a4;
  uint64_t v6[3] = a3;
  __int16 v7 = 0;
  uint64_t v4 = sub_19E06A348(a1, a2, (uint64_t)v6);
  sub_19E06FFE8((uint64_t)v6);
  return v4;
}

void sub_19E06A334(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E06FFE8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E06A348(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + ++**(_DWORD **)(result + 8) = 0;
  if ((unint64_t)(a2 - 513) < 0xFFFFFFFFFFFFFE00)
  {
    uint64_t v4 = "nbest size must be 1 <= nbest <= 512";
LABEL_16:
    (*(void (**)(uint64_t *, const char *))(*a1 + 320))(a1, v4);
    return 0;
  }
  uint64_t v6 = a2;
  do
  {
    if (!(*(unsigned int (**)(uint64_t *))(*a1 + 128))(a1)) {
      break;
    }
    uint64_t v7 = a1[21];
    if (v7)
    {
      if ((sub_19E07442C(v7, (uint64_t)a1, a3) & 1) == 0) {
        return 0;
      }
    }
    else
    {
      sub_19E06A524((uint64_t)a1, a3);
    }
    --v6;
  }
  while (v6);
  if (a1[21])
  {
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    BYTE12(v15) = 4;
    uint64_t v8 = (*(uint64_t (**)(uint64_t *))(*a1 + 64))(a1);
    *(void *)&long long v11 = v8 + (*(uint64_t (**)(uint64_t *))(*a1 + 88))(a1);
    if (!sub_19E0744FC(a1[21], (uint64_t)a1, (uint64_t)v10)) {
      return 0;
    }
  }
  if (sub_19E070054(a3, 1)) {
    *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 0;
  }
  if (*(unsigned char *)(a3 + 33) || (uint64_t result = *(void *)(a3 + 24)) == 0)
  {
    uint64_t v4 = "output buffer overflow";
    goto LABEL_16;
  }
  return result;
}

void sub_19E06A508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  sub_19E060B80((const void **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_19E06A524(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1) + 8);
  uint64_t v4 = (uint64_t *)(v3 + 8);
  if (*(void *)(v3 + 8))
  {
    do
    {
      unint64_t v5 = *(const void **)(v3 + 48);
      size_t v6 = *(unsigned __int16 *)(v3 + 96);
      if (sub_19E070054(a2, v6))
      {
        memcpy((void *)(*(void *)(a2 + 24) + *(void *)(a2 + 8)), v5, v6);
        *(void *)(a2 + 8) += v6;
      }
      if (sub_19E070054(a2, 1)) {
        *(unsigned char *)(*(void *)(a2 + 24) + (*(void *)(a2 + 8))++) = 9;
      }
      uint64_t v7 = sub_19E070138(a2, *(char **)(v3 + 56));
      if (sub_19E070054(v7, 1)) {
        *(unsigned char *)(*(void *)(a2 + 24) + (*(void *)(a2 + 8))++) = 10;
      }
      uint64_t v3 = *v4;
      uint64_t v8 = *v4;
      uint64_t v9 = *(void *)(v8 + 8);
      uint64_t v4 = (uint64_t *)(v8 + 8);
    }
    while (v9);
  }

  return sub_19E070138(a2, "EOS\n");
}

uint64_t sub_19E06A658(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = &unk_1EF09C1F0;
  v6[1] = 0;
  v6[2] = a4;
  uint64_t v6[3] = a3;
  __int16 v7 = 0;
  uint64_t v4 = sub_19E06A6D0(a1, a2, (uint64_t)v6);
  sub_19E06FFE8((uint64_t)v6);
  return v4;
}

void sub_19E06A6BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E06FFE8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E06A6D0(void *a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + ++**(_DWORD **)(result + 8) = 0;
  if (!a2)
  {
    __int16 v7 = "node is NULL";
LABEL_15:
    (*(void (**)(void *, const char *))(*a1 + 320))(a1, v7);
    return 0;
  }
  uint64_t v6 = a1[21];
  if (v6)
  {
    if ((sub_19E0744FC(v6, (uint64_t)a1, a2) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    uint64_t v8 = *(const void **)(a2 + 48);
    size_t v9 = *(unsigned __int16 *)(a2 + 96);
    if (sub_19E070054(a3, v9))
    {
      memcpy((void *)(*(void *)(a3 + 24) + *(void *)(a3 + 8)), v8, v9);
      *(void *)(a3 + 8) += v9;
    }
    if (sub_19E070054(a3, 1)) {
      *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 9;
    }
    sub_19E070138(a3, *(char **)(a2 + 56));
  }
  if (sub_19E070054(a3, 1)) {
    *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 0;
  }
  if (*(unsigned char *)(a3 + 33) || (uint64_t result = *(void *)(a3 + 24)) == 0)
  {
    __int16 v7 = "output buffer overflow";
    goto LABEL_15;
  }
  return result;
}

uint64_t sub_19E06A828(void *a1, uint64_t a2, uint64_t a3)
{
  v5[0] = &unk_1EF09C1F0;
  v5[1] = 0;
  v5[2] = a3;
  v5[3] = a2;
  __int16 v6 = 0;
  uint64_t v3 = sub_19E06A8A0(a1, (uint64_t)v5);
  sub_19E06FFE8((uint64_t)v5);
  return v3;
}

void sub_19E06A88C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E06FFE8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E06A8A0(void *a1, uint64_t a2)
{
  *(void *)(a2 + ++**(_DWORD **)(result + 8) = 0;
  uint64_t v4 = a1[21];
  if (v4)
  {
    if ((sub_19E07442C(v4, (uint64_t)a1, a2) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    sub_19E06A524((uint64_t)a1, a2);
  }
  if (sub_19E070054(a2, 1)) {
    *(unsigned char *)(*(void *)(a2 + 24) + (*(void *)(a2 + 8))++) = 0;
  }
  if (*(unsigned char *)(a2 + 33) || (uint64_t result = *(void *)(a2 + 24)) == 0)
  {
    (*(void (**)(void *, const char *))(*a1 + 320))(a1, "output buffer overflow");
    return 0;
  }
  return result;
}

uint64_t sub_19E06A964(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = sub_19E06A9A8((uint64_t)a1);

  return sub_19E06A348(a1, a2, v4);
}

uint64_t sub_19E06A9A8(uint64_t a1)
{
  if (!*(void *)(a1 + 184)) {
    operator new();
  }
  return *(void *)(a1 + 184);
}

uint64_t sub_19E06AA48(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_19E06A9A8((uint64_t)a1);

  return sub_19E06A6D0(a1, a2, v4);
}

uint64_t sub_19E06AA8C(void *a1)
{
  uint64_t v2 = sub_19E06A9A8((uint64_t)a1);

  return sub_19E06A8A0(a1, v2);
}

double sub_19E06AAC8(uint64_t a1)
{
  uint64_t v1 = (_OWORD *)sub_19E0609C8(*(void **)(*(void *)(a1 + 200) + 16));
  double result = 0.0;
  *uint64_t v1 = 0u;
  v1[1] = 0u;
  v1[2] = 0u;
  v1[3] = 0u;
  v1[4] = 0u;
  v1[5] = 0u;
  v1[6] = 0u;
  v1[7] = 0u;
  return result;
}

uint64_t sub_19E06AAFC(uint64_t a1)
{
  return *(void *)(a1 + 200);
}

uint64_t sub_19E06AB04(uint64_t result, int a2)
{
  *(_DWORD *)(result + 40) &= ~a2;
  return result;
}

uint64_t sub_19E06AB14(uint64_t result, int a2)
{
  *(_DWORD *)(result + 40) |= a2;
  return result;
}

uint64_t sub_19E06AB24(uint64_t result, int a2)
{
  *(_DWORD *)(result + 4sub_19E03D880(&a9, 0) = a2;
  return result;
}

BOOL sub_19E06AB2C(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 40) & a2) != 0;
}

uint64_t sub_19E06AB3C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_19E06AB44(uint64_t a1)
{
  return *(void *)(a1 + 208);
}

uint64_t sub_19E06AB4C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 20++**(_DWORD **)(result + 8) = a2;
  return result;
}

uint64_t sub_19E06AB54(void *a1)
{
  if (!a1[26]) {
    return 0;
  }
  uint64_t v1 = (*(uint64_t (**)(void *))(*a1 + 200))(a1);
  uint64_t v2 = (void *)sub_19E06AE14(v1);
  uint64_t v3 = (void *)v2[2];
  uint64_t v4 = v2[3];
  if (v3 == (void *)v4) {
    return 0;
  }
  int v5 = 0;
  while (1)
  {
    __int16 v6 = (void *)*v3;
    if (v4 - (uint64_t)v3 >= 9)
    {
      uint64_t v7 = 0;
      unint64_t v8 = (unint64_t)(v4 - (void)v3) >> 3;
      uint64_t v9 = v8 - 2;
      if (v8 < 2) {
        uint64_t v9 = v8 - 1;
      }
      uint64_t v10 = v9 >> 1;
      long long v11 = v3;
      do
      {
        long long v12 = &v11[v7];
        uint64_t v15 = v12[1];
        long long v13 = v12 + 1;
        uint64_t v14 = v15;
        uint64_t v16 = (2 * v7) | 1;
        uint64_t v17 = 2 * v7 + 2;
        if (v17 < (uint64_t)v8 && *(void *)(v14 + 16) > *(void *)(v13[1] + 16))
        {
          uint64_t v14 = v13[1];
          ++v13;
          uint64_t v16 = v17;
        }
        void *v11 = v14;
        long long v11 = v13;
        uint64_t v7 = v16;
      }
      while (v16 <= v10);
      unint64_t v18 = (void *)(v4 - 8);
      if (v18 == v13)
      {
        *long long v13 = v6;
      }
      else
      {
        *long long v13 = *v18;
        *unint64_t v18 = v6;
        sub_19E07BA3C((uint64_t)v3, (uint64_t)(v13 + 1), v13 + 1 - v3);
      }
    }
    uint64_t v4 = v2[3] - 8;
    v2[3] = v4;
    uint64_t result = *v6;
    uint64_t v20 = v6[1];
    if (*(unsigned char *)(*v6 + 124) == 2) {
      break;
    }
    if (v20 && (unint64_t v21 = *(void *)(v20 + 32), v22 = v2[1], v21 <= v22))
    {
      if (v21 == v22) {
        goto LABEL_44;
      }
      if (v5 > 15) {
        return 0;
      }
      ++v5;
    }
    else
    {
      uint64_t v23 = *(uint64_t **)(result + 40);
      if (v23)
      {
        do
        {
          sub_19E07B8EC(v2 + 6);
          size_t v25 = v24;
          uint64_t v26 = *v23;
          uint64_t v27 = v6[4] - *(unsigned __int16 *)(*v23 + 96);
          uint64_t v28 = *((int *)v23 + 4);
          unsigned char v24[3] = v6[3] + v28;
          uint64_t v29 = *(void *)(v26 + 112) + v28 + v6[3];
          v24[1] = v6;
          v24[2] = v29;
          void *v24 = v26;
          void v24[4] = v27;
          uint64_t v31 = (void *)v2[3];
          unint64_t v30 = v2[4];
          if ((unint64_t)v31 >= v30)
          {
            uint64_t v33 = v2[2];
            uint64_t v34 = ((uint64_t)v31 - v33) >> 3;
            if ((unint64_t)(v34 + 1) >> 61) {
              sub_19E041BEC();
            }
            uint64_t v35 = v30 - v33;
            uint64_t v36 = v35 >> 2;
            if (v35 >> 2 <= (unint64_t)(v34 + 1)) {
              uint64_t v36 = v34 + 1;
            }
            if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v37 = v36;
            }
            if (v37) {
              unint64_t v37 = (unint64_t)sub_19E060B48(v37);
            }
            else {
              uint64_t v38 = 0;
            }
            size_t v39 = (void *)(v37 + 8 * v34);
            *size_t v39 = v25;
            uint64_t v32 = (uint64_t)(v39 + 1);
            uint64_t v41 = (char *)v2[2];
            long long v40 = (char *)v2[3];
            if (v40 != v41)
            {
              do
              {
                uint64_t v42 = *((void *)v40 - 1);
                v40 -= 8;
                *--size_t v39 = v42;
              }
              while (v40 != v41);
              long long v40 = (char *)v2[2];
            }
            v2[2] = v39;
            v2[3] = v32;
            v2[4] = v37 + 8 * v38;
            if (v40) {
              operator delete(v40);
            }
          }
          else
          {
            *uint64_t v31 = v24;
            uint64_t v32 = (uint64_t)(v31 + 1);
          }
          v2[3] = v32;
          sub_19E07BA3C(v2[2], v32, (v32 - v2[2]) >> 3);
          uint64_t v23 = (uint64_t *)v23[1];
        }
        while (v23);
        uint64_t v4 = v2[3];
      }
    }
    uint64_t v3 = (void *)v2[2];
    if (v3 == (void *)v4) {
      return 0;
    }
  }
  if (!v20) {
    return result;
  }
LABEL_44:
  long long v43 = (void *)*v6;
  do
  {
    unint64_t v44 = *(void **)v20;
    v43[1] = *(void *)v20;
    *unint64_t v44 = v43;
    uint64_t v20 = *(void *)(v20 + 8);
    long long v43 = v44;
  }
  while (v20);
  return result;
}

uint64_t sub_19E06AE14(uint64_t a1)
{
  if (!*(void *)(a1 + 64)) {
    operator new();
  }
  return *(void *)(a1 + 64);
}

void sub_19E06AEE4(void *a1)
{
  sub_19E06AF1C(a1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06AF1C(void *a1)
{
  *a1 = &unk_1EF09C4F0;
  a1[5] = 0;
  uint64_t v4 = a1 + 1;
  uint64_t v2 = (void *)a1[1];
  uint64_t v3 = (void *)v4[1];
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (!v3) {
      return a1;
    }
    goto LABEL_7;
  }
  unint64_t v5 = 0;
  do
  {
    if (v2[v5])
    {
      MEMORY[0x19F3BA6E0](v2[v5], 0x1020C80E349F4B1);
      unint64_t v5 = a1[5];
      uint64_t v2 = (void *)a1[1];
      uint64_t v3 = (void *)a1[2];
    }
    a1[5] = ++v5;
  }
  while (v5 < v3 - v2);
  if (v2)
  {
LABEL_7:
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_19E06AFC8(void *a1)
{
  sub_19E06B000(a1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06B000(void *a1)
{
  *a1 = &unk_1EF09C2B0;
  sub_19E06AF1C(a1 + 6);
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_19E06B058()
{
  return 1;
}

float sub_19E06B060(uint64_t a1)
{
  return *(double *)(a1 + 24);
}

double sub_19E06B06C(uint64_t a1, float a2)
{
  double result = a2;
  *(double *)(a1 + 24) = result;
  return result;
}

double sub_19E06B078(uint64_t a1)
{
  return *(double *)(a1 + 32);
}

uint64_t sub_19E06B080(uint64_t result, double a2)
{
  *(double *)(result + 32) = a2;
  return result;
}

uint64_t sub_19E06B088(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void sub_19E06B090(char **a1, const void *a2, size_t a3)
{
  (*(void (**)(char **))*a1)(a1);
  size_t v6 = a3 + 4;
  sub_19E06B1D8(a1 + 9, a3 + 4);
  sub_19E06B1D8(a1 + 12, a3 + 4);
  if (((*((uint64_t (**)(char **, uint64_t))*a1 + 21))(a1, 64) & 1) != 0
    || (*((unsigned int (**)(char **, uint64_t))*a1 + 21))(a1, 4))
  {
    uint64_t v7 = (*((uint64_t (**)(char **))*a1 + 25))(a1);
    unint64_t v8 = (void *)sub_19E069BA8(v7, a3);
    memcpy(v8, a2, a3);
    a2 = v8;
  }
  a1[1] = (char *)a2;
  a1[2] = (char *)a3;
  bzero(a1[9], 8 * v6);
  uint64_t v9 = a1[12];

  bzero(v9, 8 * v6);
}

void sub_19E06B1D8(char **a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    unint64_t v19 = &v3[8 * a2];
    goto LABEL_19;
  }
  unint64_t v6 = a2 - v5;
  uint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 3)
  {
    bzero(a1[1], 8 * v6);
    unint64_t v19 = &v4[8 * v6];
LABEL_19:
    a1[1] = v19;
    return;
  }
  if (a2 >> 61) {
    sub_19E041BEC();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 2;
  if (v8 >> 2 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  long long v11 = (char *)sub_19E060B48(v10);
  long long v12 = &v11[8 * v5];
  uint64_t v14 = &v11[8 * v13];
  bzero(v12, 8 * v6);
  uint64_t v15 = &v12[8 * v6];
  uint64_t v17 = *a1;
  uint64_t v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      uint64_t v18 = *((void *)v16 - 1);
      v16 -= 8;
      *((void *)v12 - 1) = v18;
      v12 -= 8;
    }
    while (v16 != v17);
    uint64_t v16 = *a1;
  }
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v14;
  if (v16)
  {
    operator delete(v16);
  }
}

uint64_t sub_19E06B2E4(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  unint64_t v5 = *(uint64_t (**)(uint64_t, char *, size_t))(*(void *)a1 + 80);

  return v5(a1, __s, v4);
}

uint64_t sub_19E06B34C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_19E06B354(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(a1 + 96) + 8 * a2);
}

uint64_t sub_19E06B360(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(a1 + 72) + 8 * a2);
}

uint64_t sub_19E06B36C(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

uint64_t sub_19E06B374(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t sub_19E06B37C(void *a1)
{
  return *(void *)(a1[12] + 8 * (*(uint64_t (**)(void *))(*a1 + 88))(a1));
}

uint64_t sub_19E06B3C8(uint64_t a1)
{
  return **(void **)(a1 + 72);
}

BOOL sub_19E06B3D4(void *a1)
{
  return a1[1] && a1[12] != a1[13] && a1[9] != a1[10];
}

double sub_19E06B400(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 200);
  uint64_t v2 = v1[2];
  *(void *)(v2 + 32) = 0;
  *(void *)(v2 + 4sub_19E03D880(&a9, 0) = 0;
  uint64_t v3 = v1[4];
  if (v3)
  {
    *(void *)(v3 + 32) = 0;
    *(void *)(v3 + 4sub_19E03D880(&a9, 0) = 0;
  }
  uint64_t v4 = v1[6];
  if (v4)
  {
    *(void *)(v4 + 32) = 0;
    *(void *)(v4 + 4sub_19E03D880(&a9, 0) = 0;
  }
  uint64_t v5 = *(void *)(a1 + 184);
  if (v5) {
    *(void *)(v5 + ++**(_DWORD **)(result + 8) = 0;
  }
  *(void *)(a1 + 104) = *(void *)(a1 + 96);
  *(void *)(a1 + 8sub_19E03D880(&a9, 0) = *(void *)(a1 + 72);
  *(void *)(a1 + 12++**(_DWORD **)(result + 8) = *(void *)(a1 + 120);
  *(void *)(a1 + 152) = *(void *)(a1 + 144);
  double result = 0.75;
  *(_OWORD *)(a1 + 24) = xmmword_19E1240A0;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 20++**(_DWORD **)(result + 8) = 0;
  return result;
}

void sub_19E06B468(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EF09C020;
  *(_OWORD *)(a1 + 24) = xmmword_19E1240A0;
  *(_DWORD *)(a1 + 4sub_19E03D880(&a9, 0) = 1;
  *(_OWORD *)(a1 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 12++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 16sub_19E03D880(&a9, 0) = 0;
  *(void *)(a1 + 16++**(_DWORD **)(result + 8) = a2;
  *(void *)(a1 + 176) = &unk_1EF09BE80;
  *(void *)(a1 + 184) = 0;
  operator new();
}

void sub_19E06B6F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, uint64_t a11, void **a12)
{
  unint64_t v22 = (void *)v13[9];
  if (v22)
  {
    v13[10] = v22;
    operator delete(v22);
  }
  void *v15 = v21;
  if (*v16) {
    (*(void (**)(void))(*(void *)*v16 + 8))(*v16);
  }
  v13[5] = v20;
  uint64_t v23 = v13[6];
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  _OWORD v13[3] = v19;
  uint64_t v24 = v13[4];
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  v13[1] = v18;
  uint64_t v25 = v13[2];
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  MEMORY[0x19F3BA710](v13, 0xB1C40E0AC591ALL);
  *(void *)(v12 + 176) = a11;
  uint64_t v26 = *(void *)(v12 + 184);
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  }
  uint64_t v27 = *(void **)(v12 + 144);
  if (v27)
  {
    *(void *)(v12 + 152) = v27;
    operator delete(v27);
  }
  uint64_t v28 = *(void **)(v12 + 120);
  if (v28)
  {
    *(void *)(v12 + 12++**(_DWORD **)(result + 8) = v28;
    operator delete(v28);
  }
  uint64_t v29 = *v14;
  if (*v14)
  {
    *(void *)(v12 + 104) = v29;
    operator delete(v29);
  }
  unint64_t v30 = *a12;
  if (*a12)
  {
    *(void *)(v12 + 8sub_19E03D880(&a9, 0) = v30;
    operator delete(v30);
  }
  if (*(char *)(v12 + 71) < 0) {
    operator delete(*v17);
  }
  _Unwind_Resume(a1);
}

void sub_19E06B8BC(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)a1;
  if (!((*(void *)(a1 + 16) - *(void *)a1) >> 16))
  {
    uint64_t v3 = *(unsigned char **)(a1 + 8);
    uint64_t v4 = (char *)operator new(0x10000uLL);
    uint64_t v5 = &v4[(v3 - v1) & 0xFFFFFFFFFFFFFFF8];
    unint64_t v6 = v5;
    if (v3 != v1)
    {
      unint64_t v6 = &v4[(v3 - v1) & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v7 = *((void *)v3 - 1);
        v3 -= 8;
        *((void *)v6 - 1) = v7;
        v6 -= 8;
      }
      while (v3 != v1);
    }
    *(void *)a1 = v6;
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = v5;
    *(void *)(a1 + 16) = v4 + 0x10000;
    if (v1)
    {
      operator delete(v1);
    }
  }
}

void sub_19E06B960(void *a1)
{
  sub_19E06B998(a1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06B998(void *a1)
{
  *a1 = &unk_1EF09C210;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v5 = *(void *)(v2 - 8);
    uint64_t v4 = v2 - 8;
    uint64_t v3 = v5;
    if (v5)
    {
      uint64_t v6 = 24 * v3;
      do
      {
        sub_19E062044((const void **)(v4 + v6), 0);
        v6 -= 24;
      }
      while (v6);
    }
    MEMORY[0x19F3BA6E0](v4 - 8, 0x1060C8035ECB431);
  }
  return a1;
}

void sub_19E06BA2C(void *a1)
{
  *a1 = &unk_1EF09BEC0;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06BAB8(void *a1)
{
  *a1 = &unk_1EF09BEC0;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_19E06BB24(void *a1)
{
  *a1 = &unk_1EF09BEA0;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06BBB0(void *a1)
{
  *a1 = &unk_1EF09BEA0;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_19E06BC1C(void *a1)
{
  *a1 = &unk_1EF09BF40;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06BCA8(void *a1)
{
  *a1 = &unk_1EF09BF40;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_19E06BD14(void *a1)
{
  *a1 = &unk_1EF09BF20;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06BDA0(void *a1)
{
  *a1 = &unk_1EF09BF20;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_19E06BE0C(void *a1)
{
  sub_19E06BE44(a1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06BE44(void *a1)
{
  *a1 = &unk_1EF09C490;
  a1[5] = 0;
  uint64_t v4 = a1 + 1;
  uint64_t v2 = (void *)a1[1];
  uint64_t v3 = (void *)v4[1];
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (!v3) {
      return a1;
    }
    goto LABEL_10;
  }
  unint64_t v5 = 0;
  do
  {
    uint64_t v6 = v2[v5];
    if (v6)
    {
      uint64_t v7 = *(void *)(v6 - 8);
      if (v7)
      {
        uint64_t v8 = v7 << 7;
        do
        {
          sub_19E060B80((const void **)(v6 - 24 + v8), 0);
          v8 -= 128;
        }
        while (v8);
      }
      MEMORY[0x19F3BA6E0](v6 - 16, 0x1070C80FE750B47);
      unint64_t v5 = a1[5];
      uint64_t v2 = (void *)a1[1];
      uint64_t v3 = (void *)a1[2];
    }
    a1[5] = ++v5;
  }
  while (v5 < v3 - v2);
  if (v2)
  {
LABEL_10:
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_19E06BF1C(void *a1)
{
  sub_19E06BF54(a1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06BF54(void *a1)
{
  *a1 = &unk_1EF09C510;
  sub_19E06B998(a1 + 12);
  uint64_t v2 = (void *)a1[9];
  if (v2)
  {
    a1[10] = v2;
    operator delete(v2);
  }
  a1[7] = &unk_1EF09BEC0;
  uint64_t v3 = a1[8];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  a1[5] = &unk_1EF09BEA0;
  uint64_t v4 = a1[6];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  a1[3] = &unk_1EF09BF40;
  uint64_t v5 = a1[4];
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  a1[1] = &unk_1EF09BF20;
  uint64_t v6 = a1[2];
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return a1;
}

CFStringRef LXAnalyzerCandidateCopySurface(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0)
  {
    sub_19E06C18C(__p, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 16);
    uint64_t v6 = *(void *)(a1 + 32);
  }
  if (v6 >= 0) {
    uint64_t v1 = __p;
  }
  else {
    uint64_t v1 = (void **)__p[0];
  }
  if (v6 >= 0) {
    CFIndex v2 = HIBYTE(v6);
  }
  else {
    CFIndex v2 = (CFIndex)__p[1];
  }
  CFStringRef v3 = CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UniChar *)v1, v2);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  return v3;
}

void sub_19E06C170(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E06C18C(unsigned char *__dst, void *__src, unint64_t a3)
{
  uint64_t v5 = __dst;
  if (a3 > 0xA)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      sub_19E04147C();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFFCLL) + 4;
    if ((a3 | 3) != 0xB) {
      uint64_t v6 = a3 | 3;
    }
    uint64_t v7 = sub_19E063B88(v6 + 1);
    v5[1] = a3;
    v5[2] = v8 | 0x8000000000000000;
    void *v5 = v7;
    uint64_t v5 = v7;
  }
  else
  {
    __dst[23] = a3;
  }

  return memmove(v5, __src, 2 * a3 + 2);
}

double LXAnalyzerCandidateGetScore(uint64_t a1)
{
  return (float)((float)*(int *)(a1 + 40) / -800.0);
}

uint64_t LXAnalyzerCandidateGetMorphemeCount(uint64_t a1)
{
  return (int)((uint64_t)(*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 4);
}

double LXAnalyzerCandidateGetNodeScore(uint64_t a1)
{
  return *(double *)(a1 + 48);
}

double LXAnalyzerCandidateGetLinguisticScore(uint64_t a1)
{
  return (float)((float)*(int *)(a1 + 56) / -800.0);
}

uint64_t LXAnalyzerCandidateGetFlags(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 64); ; i += 16)
  {
    if (i == *(void *)(a1 + 72)) {
      return 0;
    }
    if (!*(void *)i) {
      __assert_rtn("LXEntryGetMetaFlags", "LXEntry.cpp", 45, "entry");
    }
    if ((*(_WORD *)(*(void *)i + 54) & 0x380) != 0) {
      break;
    }
  }
  return 1;
}

uint64_t LXAnalyzerCandidateEnumerateMorphemeLexiconEntries(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 64);
  uint64_t v3 = *(void *)(result + 72);
  if (v2 != v3)
  {
    uint64_t v5 = v2 + 16;
    do
    {
      char v7 = 0;
      double result = (*(uint64_t (**)(uint64_t, void, char *))(a2 + 16))(a2, *(void *)(v5 - 16), &v7);
      if (v7) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = v5 == v3;
      }
      v5 += 16;
    }
    while (!v6);
  }
  return result;
}

uint64_t LXAnalyzerCandidateEnumerateMorphemeLexiconEntriesAndLengths(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 64);
  uint64_t v3 = *(void *)(result + 72);
  if (v2 != v3)
  {
    do
    {
      char v6 = 0;
      double result = (*(uint64_t (**)(uint64_t, void, void, char *))(a2 + 16))(a2, *(void *)v2, *(unsigned __int16 *)(v2 + 8), &v6);
      v2 += 16;
      if (v6) {
        BOOL v5 = 1;
      }
      else {
        BOOL v5 = v2 == v3;
      }
    }
    while (!v5);
  }
  return result;
}

void *sub_19E06C3C0@<X0>(void *a1@<X8>)
{
  return sub_19E063AC4(a1, byte_19E132984);
}

uint64_t sub_19E06C3D0()
{
  return 0;
}

uint64_t sub_19E06C3D8(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 32) + *(unsigned int *)(a2 + 8);
}

unint64_t sub_19E06C3E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1);
  if (result)
  {
    for (unint64_t i = 0; i < result; ++i)
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)a1 + 128))(a1, a2, i);
      sub_19E06C4BC(*(void *)(a3 + 24), v8, 0);
      unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 136))(a1, a2);
    }
  }
  return result;
}

uint64_t sub_19E06C4BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  if (!a1) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

uint64_t sub_19E06C510(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a2 + 8);
}

uint64_t sub_19E06C518(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a2 + 8);
  if (*(void *)(a1 + 616) - *(void *)(a1 + 608) == 8) {
    return *(void *)(a1 + 24) + 12 * (v3 >> 8) + 12 * a3;
  }
  else {
    return *(void *)(a1 + 24)
  }
         + 12
         * *(unsigned int *)(*(void *)(*(void *)(a1 + 632) + 8 * *(unsigned int *)(a1 + 576))
                           + 4 * (a3 + (v3 >> 8)));
}

uint64_t sub_19E06C56C()
{
  return 1;
}

void sub_19E06C574(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void sub_19E06C580(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t sub_19E06C58C()
{
  return 0;
}

uint64_t sub_19E06C594()
{
  return 0;
}

uint64_t sub_19E06C59C()
{
  return 0;
}

void sub_19E06C5A4(uint64_t a1@<X8>)
{
  *(unsigned char *)a1 = 0;
  *(void *)(a1 + 12) = 0;
  *(void *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 2sub_19E03D880(&a9, 0) = 0;
}

uint64_t sub_19E06C5B8(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  uint64_t v5 = *(uint64_t (**)(uint64_t, char *, size_t))(*(void *)a1 + 56);

  return v5(a1, __s, v4);
}

uint64_t sub_19E06C630@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 12) = 0;
  *(void *)(a4 + 4) = 0;
  *(_DWORD *)(a4 + 2sub_19E03D880(&a9, 0) = 0;
  uint64_t v5 = *(void *)(result + 608);
  uint64_t v6 = *(void *)(result + 616);
  if (v5 != v6)
  {
    unint64_t v7 = *(unsigned int *)(result + 576);
    if (v7 < (v6 - v5) >> 3)
    {
      unint64_t result = *(void *)(v5 + 8 * v7);
      if (result)
      {
        __int16 v8 = a3;
        int v9 = 0;
        unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)result + 80))(result, a2, a3, &v9);
        if (result) {
          *(_DWORD *)(a4 + ++**(_DWORD **)(result + 8) = v9;
        }
        *(_WORD *)(a4 + 12) = v8;
      }
    }
  }
  return result;
}

void sub_19E06C6D0(_Unwind_Exception *a1)
{
  sub_19E062044((const void **)(v1 + 16), 0);
  _Unwind_Resume(a1);
}

uint64_t sub_19E06C6E8()
{
  return 0;
}

uint64_t sub_19E06C6F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _OWORD v9[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 608);
  uint64_t v5 = *(void *)(a1 + 616);
  if (v4 == v5) {
    return 0;
  }
  unint64_t v6 = *(unsigned int *)(a1 + 576);
  if (v6 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t result = *(void *)(v4 + 8 * v6);
  if (result)
  {
    uint64_t v8 = 0;
    v9[0] = &unk_1EF09CE48;
    v9[1] = a4;
    v9[2] = &v8;
    void v9[3] = v9;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)result + 88))(result, a2, a3, v9);
    sub_19E06C7E4(v9);
    return v8;
  }
  return result;
}

void sub_19E06C7D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E06C7E4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_19E06C7E4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_19E06C868()
{
  return &unk_1EF09B788;
}

uint64_t sub_19E06C874(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B788)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

uint64_t sub_19E06C8B4(uint64_t result, int *a2, uint64_t a3)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a3 + 8);
  uint64_t v5 = *(void *)(result + 8);
  unint64_t v6 = *(void **)(result + 16);
  uint64_t v7 = (*v6)++;
  uint64_t v8 = v5 + 24 * v7;
  *(_DWORD *)(v8 + ++**(_DWORD **)(result + 8) = v3;
  *(_WORD *)(v8 + 12) = v4;
  return result;
}

__n128 sub_19E06C8E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09CE48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E06C910(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF09CE48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

void sub_19E06C95C()
{
}

uint64_t sub_19E06C974(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_19E06C980(uint64_t result)
{
  if (*(_DWORD *)(result + 52) != 3)
  {
    uint64_t v1 = (unint64_t *)result;
    __n128 result = (uint64_t)sub_19E06C9E4((void *)(result + 608));
    v1[74] = v1[73];
    v1[80] = v1[79];
    unint64_t v2 = v1[2];
    if (v2)
    {
      if (*(void *)(v2 + 16))
      {
        uint64_t v3 = sub_19E06CA50();
        __n128 result = sub_19E06CB24(v3, v1[2]);
        v1[2] = 0;
      }
    }
  }
  return result;
}

void *sub_19E06C9E4(void *result)
{
  uint64_t v1 = result;
  unint64_t v2 = (void *)*result;
  uint64_t v3 = (void *)result[1];
  while (v3 != v2)
  {
    uint64_t v4 = (void *)*--v3;
    __n128 result = v4;
    void *v3 = 0;
    if (v4) {
      __n128 result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  v1[1] = v2;
  return result;
}

uint64_t sub_19E06CA50()
{
  if (!qword_1E9457428) {
    operator new();
  }
  pthread_mutex_unlock(&stru_1E9457228);
  return qword_1E9457428;
}

void sub_19E06CAF0(_Unwind_Exception *a1)
{
  sub_19E067268(*(char **)(v1 + 40));
  sub_19E0672C4(*(char **)(v1 + 16));
  MEMORY[0x19F3BA710](v1, 0x10B3C401829B6ABLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E06CB24(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 64);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 64));
  if (a2)
  {
    uint64_t v5 = *(void **)(a1 + 40);
    if (v5)
    {
      unint64_t v6 = (void *)(a1 + 40);
      do
      {
        unint64_t v7 = v5[4];
        BOOL v8 = v7 >= a2;
        if (v7 >= a2) {
          int v9 = v5;
        }
        else {
          int v9 = v5 + 1;
        }
        if (v8) {
          unint64_t v6 = v5;
        }
        uint64_t v5 = (void *)*v9;
      }
      while (*v9);
      if (v6 != (void *)(a1 + 40) && v6[4] <= a2)
      {
        uint64_t v10 = v6[8] - 1;
        v6[8] = v10;
        if (!v10)
        {
          long long v11 = (uint64_t **)(a1 + 8);
          uint64_t v12 = sub_19E05E980(a1 + 8, v6 + 5);
          uint64_t v13 = v12;
          uint64_t v14 = (uint64_t *)v12[1];
          if (v14)
          {
            do
            {
              uint64_t v15 = v14;
              uint64_t v14 = (uint64_t *)*v14;
            }
            while (v14);
          }
          else
          {
            uint64_t v16 = v12;
            do
            {
              uint64_t v15 = (uint64_t *)v16[2];
              BOOL v17 = *v15 == (void)v16;
              uint64_t v16 = v15;
            }
            while (!v17);
          }
          if (*v11 == v12) {
            char *v11 = v15;
          }
          uint64_t v18 = *(uint64_t **)(a1 + 16);
          --*(void *)(a1 + 24);
          sub_19E066E70(v18, v13);
          if (*((char *)v13 + 55) < 0) {
            operator delete((void *)v13[4]);
          }
          operator delete(v13);
          uint64_t v19 = (void *)v6[1];
          if (v19)
          {
            do
            {
              uint64_t v20 = v19;
              uint64_t v19 = (void *)*v19;
            }
            while (v19);
          }
          else
          {
            uint64_t v21 = v6;
            do
            {
              uint64_t v20 = (void *)v21[2];
              BOOL v17 = *v20 == (void)v21;
              uint64_t v21 = v20;
            }
            while (!v17);
          }
          if (*(void **)(a1 + 32) == v6) {
            *(void *)(a1 + 32) = v20;
          }
          unint64_t v22 = *(uint64_t **)(a1 + 40);
          --*(void *)(a1 + 48);
          sub_19E066E70(v22, v6);
          if (*((char *)v6 + 63) < 0) {
            operator delete((void *)v6[5]);
          }
          operator delete(v6);
          (*(void (**)(unint64_t))(*(void *)a2 + 8))(a2);
        }
      }
    }
  }

  return pthread_mutex_unlock(v4);
}

void sub_19E06CCEC(uint64_t a1)
{
  sub_19E06CD24(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E06CD24(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09BCE0;
  unint64_t v2 = (pthread_mutex_t *)(a1 + 64);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 64));
  uint64_t v3 = *(void **)(a1 + 8);
  if (v3 != (void *)(a1 + 16))
  {
    do
    {
      uint64_t v4 = v3[7];
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
      uint64_t v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          unint64_t v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          unint64_t v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }
        while (!v7);
      }
      uint64_t v3 = v6;
    }
    while (v6 != (void *)(a1 + 16));
  }
  pthread_mutex_unlock(v2);
  sub_19E06746C(a1 + 56);
  sub_19E067268(*(char **)(a1 + 40));
  sub_19E0672C4(*(char **)(a1 + 16));
  return a1;
}

uint64_t sub_19E06CE14(uint64_t a1, char *a2, const char *a3)
{
  unint64_t v6 = (char **)(a1 + 72);
  sub_19E069118((std::string *)(a1 + 72), a2);
  uint64_t v7 = sub_19E06CA50();
  *(void *)(a1 + 16) = sub_19E06D514(v7, v6);
  BOOL v8 = (pthread_mutex_t *)(v7 + 64);
  pthread_mutex_lock(v8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (*(void *)(v9 + 8)
    || (*(char *)(a1 + 95) < 0 ? (uint64_t v10 = *v6) : (uint64_t v10 = (char *)v6), (sub_19E06D7C4(v9, v10, a3) & 1) != 0))
  {
    pthread_mutex_unlock(v8);
    uint64_t v11 = *(void *)(a1 + 16);
    unint64_t v12 = *(void *)(v11 + 16);
    if (v12 <= 0x63)
    {
      if (setjmp((int *)(a1 + 384)) != 1)
      {
        std::ios_base::clear((std::ios_base *)(a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24)), 0);
        uint64_t v15 = sub_19E0416F8((void *)(a1 + 96), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/dictionary.cpp", 73);
        sub_19E0416F8(v15, (uint64_t)"(", 1);
        uint64_t v16 = (void *)std::ostream::operator<<();
        BOOL v17 = sub_19E0416F8(v16, (uint64_t)") [", 3);
        uint64_t v18 = sub_19E0416F8(v17, (uint64_t)"dmmap_->size() >= 100", 21);
        uint64_t v19 = sub_19E0416F8(v18, (uint64_t)"] ", 2);
        uint64_t v20 = sub_19E0416F8(v19, (uint64_t)"dictionary file is broken: ", 27);
        size_t v21 = strlen(a2);
        sub_19E0416F8(v20, (uint64_t)a2, v21);
        longjmp((int *)(a1 + 384), 1);
      }
    }
    else
    {
      uint64_t v13 = *(unsigned int **)(v11 + 8);
      if (v12 == (*v13 ^ 0xEF718F77))
      {
        *(_DWORD *)(a1 + 4++**(_DWORD **)(result + 8) = v13[1];
        *(_DWORD *)(a1 + 52) = v13[2];
        *(_DWORD *)(a1 + 56) = v13[3];
        *(_DWORD *)(a1 + 6sub_19E03D880(&a9, 0) = v13[4];
        *(_DWORD *)(a1 + 64) = v13[5];
        unsigned int v14 = v13[9];
        if ((v14 & 0x3FFFFF) == 0)
        {
          *(_DWORD *)(a1 + ++**(_DWORD **)(result + 8) = v14 >> 28;
          *(unsigned char *)(a1 + 12) = (v14 >> 26) & 3;
          *(unsigned char *)(a1 + 13) = HIBYTE(v14) & 3;
          *(unsigned char *)(a1 + 14) = (v14 >> 22) & 3;
        }
        *(void *)(a1 + 4sub_19E03D880(&a9, 0) = v13 + 10;
        operator new();
      }
      if (setjmp((int *)(a1 + 384)) != 1)
      {
        std::ios_base::clear((std::ios_base *)(a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24)), 0);
        unint64_t v22 = sub_19E0416F8((void *)(a1 + 96), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/dictionary.cpp", 73);
        sub_19E0416F8(v22, (uint64_t)"(", 1);
        uint64_t v23 = (void *)std::ostream::operator<<();
        uint64_t v24 = sub_19E0416F8(v23, (uint64_t)") [", 3);
        uint64_t v25 = sub_19E0416F8(v24, (uint64_t)"(magic ^ DictionaryMagicID) == dmmap_->size()", 45);
        uint64_t v26 = sub_19E0416F8(v25, (uint64_t)"] ", 2);
        uint64_t v27 = sub_19E0416F8(v26, (uint64_t)"dictionary file is broken: ", 27);
        size_t v28 = strlen(a2);
        sub_19E0416F8(v27, (uint64_t)a2, v28);
        longjmp((int *)(a1 + 384), 1);
      }
    }
  }
  else
  {
    uint64_t v29 = (char *)sub_19E05E6A8(*(void *)(a1 + 16) + 48);
    unint64_t v30 = sub_19E0413C8(__p, v29);
    if ((v35 & 0x80u) == 0) {
      uint64_t v31 = v30;
    }
    else {
      uint64_t v31 = __p[0];
    }
    if ((v35 & 0x80u) == 0) {
      uint64_t v32 = v35;
    }
    else {
      uint64_t v32 = (uint64_t)__p[1];
    }
    sub_19E0416F8((void *)(a1 + 96), (uint64_t)v31, v32);
    if ((char)v35 < 0) {
      operator delete(__p[0]);
    }
    pthread_mutex_unlock(v8);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  return 0;
}

void sub_19E06D4B8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_19E05E710(v15);
}

void sub_19E06D4E0()
{
  (*(void (**)(uint64_t))(*(void *)v0 + 8))(v0);
  JUMPOUT(0x19E06D50CLL);
}

unint64_t sub_19E06D514(uint64_t a1, void *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 64);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 64));
  uint64_t v5 = sub_19E05E980(a1 + 8, a2);
  if ((void *)(a1 + 16) == v5) {
    operator new();
  }
  unint64_t v6 = v5[7];
  unint64_t v9 = v6;
  uint64_t v7 = sub_19E0687D0((uint64_t **)(a1 + 32), v6, &v9);
  ++*((void *)v7 + 8);
  pthread_mutex_unlock(v4);
  return v6;
}

void sub_19E06D774(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E06D7C4(uint64_t a1, char *a2, const char *a3)
{
  sub_19E068788(a1);
  sub_19E0413C8(&v47, a2);
  unint64_t v6 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*v6);
  }
  *(_OWORD *)unint64_t v6 = *(_OWORD *)&v47.st_dev;
  *(void *)(a1 + 4sub_19E03D880(&a9, 0) = *(void *)&v47.st_uid;
  if (!strcmp(a3, "r"))
  {
    *(_DWORD *)(a1 + 532) = 0;
    int v14 = open(a2, 0);
    *(_DWORD *)(a1 + 52++**(_DWORD **)(result + 8) = v14;
    if (v14 < 0)
    {
      if (setjmp((int *)(a1 + 336)) != 1)
      {
        std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
        uint64_t v15 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/mmap.h", 65);
        sub_19E0416F8(v15, (uint64_t)"(", 1);
        uint64_t v16 = (void *)std::ostream::operator<<();
        BOOL v17 = sub_19E0416F8(v16, (uint64_t)") [", 3);
        uint64_t v18 = sub_19E0416F8(v17, (uint64_t)"(fd = ::open(filename, flag | O_BINARY)) >= 0", 45);
        uint64_t v19 = sub_19E0416F8(v18, (uint64_t)"] ", 2);
        uint64_t v20 = sub_19E0416F8(v19, (uint64_t)"open failed: ", 13);
        size_t v21 = strlen(a2);
        sub_19E0416F8(v20, (uint64_t)a2, v21);
        longjmp((int *)(a1 + 336), 1);
      }
      goto LABEL_22;
    }
    goto LABEL_11;
  }
  if (!strcmp(a3, "r+"))
  {
    *(_DWORD *)(a1 + 532) = 514;
    int v14 = open(a2, 514, 384);
    *(_DWORD *)(a1 + 52++**(_DWORD **)(result + 8) = v14;
    if (v14 < 0)
    {
      if (setjmp((int *)(a1 + 336)) != 1)
      {
        std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
        uint64_t v33 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/mmap.h", 65);
        sub_19E0416F8(v33, (uint64_t)"(", 1);
        uint64_t v34 = (void *)std::ostream::operator<<();
        unsigned __int8 v35 = sub_19E0416F8(v34, (uint64_t)") [", 3);
        uint64_t v36 = sub_19E0416F8(v35, (uint64_t)"(fd = ::open(filename, flag | O_BINARY, S_IRUSR | S_IWUSR)) >= 0", 64);
        unint64_t v37 = sub_19E0416F8(v36, (uint64_t)"] ", 2);
        uint64_t v38 = sub_19E0416F8(v37, (uint64_t)"open failed: ", 13);
        size_t v39 = strlen(a2);
        sub_19E0416F8(v38, (uint64_t)a2, v39);
        longjmp((int *)(a1 + 336), 1);
      }
      goto LABEL_22;
    }
LABEL_11:
    if (fstat(v14, &v47) < 0)
    {
      if (setjmp((int *)(a1 + 336)) != 1)
      {
        std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
        uint64_t v25 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/mmap.h", 65);
        sub_19E0416F8(v25, (uint64_t)"(", 1);
        uint64_t v26 = (void *)std::ostream::operator<<();
        uint64_t v27 = sub_19E0416F8(v26, (uint64_t)") [", 3);
        size_t v28 = sub_19E0416F8(v27, (uint64_t)"fstat(fd, &st) >= 0", 19);
        uint64_t v29 = sub_19E0416F8(v28, (uint64_t)"] ", 2);
        unint64_t v30 = sub_19E0416F8(v29, (uint64_t)"failed to get file size: ", 25);
        size_t v31 = strlen(a2);
        sub_19E0416F8(v30, (uint64_t)a2, v31);
        longjmp((int *)(a1 + 336), 1);
      }
      goto LABEL_22;
    }
    off_t st_size = v47.st_size;
    *(void *)(a1 + 16) = v47.st_size;
    if (st_size)
    {
      uint64_t v23 = mmap(0, st_size, *(_DWORD *)(a1 + 532) & 2 | 1u, 1, *(_DWORD *)(a1 + 528), 0);
      if (v23 == (void *)-1)
      {
        if (setjmp((int *)(a1 + 336)) != 1)
        {
          std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
          long long v40 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/mmap.h", 65);
          sub_19E0416F8(v40, (uint64_t)"(", 1);
          uint64_t v41 = (void *)std::ostream::operator<<();
          uint64_t v42 = sub_19E0416F8(v41, (uint64_t)") [", 3);
          long long v43 = sub_19E0416F8(v42, (uint64_t)"(p = reinterpret_cast<char*>(mmap(0, length, prot, MAP_SHARED, fd, 0))) != MAP_FAILED", 85);
          unint64_t v44 = sub_19E0416F8(v43, (uint64_t)"] ", 2);
          unint64_t v45 = sub_19E0416F8(v44, (uint64_t)"mmap() failed: ", 15);
          size_t v46 = strlen(a2);
          sub_19E0416F8(v45, (uint64_t)a2, v46);
          longjmp((int *)(a1 + 336), 1);
        }
        goto LABEL_22;
      }
      uint64_t v24 = v23;
      madvise(v23, *(void *)(a1 + 16), 1);
    }
    else
    {
      uint64_t v24 = 0;
    }
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = v24;
    close(*(_DWORD *)(a1 + 528));
    *(_DWORD *)(a1 + 52++**(_DWORD **)(result + 8) = -1;
    return 1;
  }
  if (setjmp((int *)(a1 + 336)) != 1)
  {
    std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
    uint64_t v7 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/mmap.h", 65);
    sub_19E0416F8(v7, (uint64_t)"(", 1);
    BOOL v8 = (void *)std::ostream::operator<<();
    unint64_t v9 = sub_19E0416F8(v8, (uint64_t)") [", 3);
    uint64_t v10 = sub_19E0416F8(v9, (uint64_t)"false", 5);
    uint64_t v11 = sub_19E0416F8(v10, (uint64_t)"] ", 2);
    unint64_t v12 = sub_19E0416F8(v11, (uint64_t)"unknown open mode: ", 19);
    size_t v13 = strlen(a2);
    sub_19E0416F8(v12, (uint64_t)a2, v13);
    longjmp((int *)(a1 + 336), 1);
  }
LABEL_22:
  sub_19E068788(a1);
  return 0;
}

void sub_19E06DDD0()
{
  sub_19E05E710(v0);
}

uint64_t sub_19E06DDE8(uint64_t a1, uint64_t a2, unint64_t a3)
{
  _OWORD v8[4] = *MEMORY[0x1E4F143B8];
  sub_19E050130(0, 0, a2, a3);
  v6[0] = &unk_1EF09CC38;
  uint64_t v6[3] = v6;
  uint64_t v7 = v4;
  sub_19E06DEB4((uint64_t)v8, (uint64_t)v6);
  sub_19E06DF34(v6);
  sub_19E06DFB8((uint64_t *)(a1 + 8), &v7);
  sub_19E06E0C4(&v7, 0);
  sub_19E06DF34(v8);
  return 1;
}

uint64_t sub_19E06DEB4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void *sub_19E06DF34(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_19E06DFB8(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = a2 + 1;
  sub_19E06E0C4(a1, v4);
  uint64_t v7 = (uint64_t **)(a1 + 4);
  unint64_t v6 = (uint64_t *)a1[4];
  BOOL v8 = a1 + 1;
  a1[4] = 0;
  if (v6 == a1 + 1)
  {
    (*(void (**)(uint64_t *))(*v8 + 32))(a1 + 1);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t *))(*v6 + 40))(v6);
  }
  uint64_t v11 = a2[4];
  uint64_t v10 = a2 + 4;
  unint64_t v9 = (uint64_t *)v11;
  if (v11)
  {
    if (v9 == v5)
    {
      void *v7 = v8;
      (*(void (**)(void, uint64_t *))(*(void *)*v10 + 24))(*v10, a1 + 1);
      return a1;
    }
    void *v7 = v9;
  }
  else
  {
    uint64_t v10 = a1 + 4;
  }
  *uint64_t v10 = 0;
  return a1;
}

uint64_t *sub_19E06E0C4(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *__n128 result = a2;
  if (v2)
  {
    uint64_t v4 = v2;
    uint64_t v3 = result[4];
    if (!v3) {
      sub_19E0483E0();
    }
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, &v4);
  }
  return result;
}

void *sub_19E06E12C()
{
  return &unk_1EF09B728;
}

uint64_t sub_19E06E138(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B728)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_19E06E178(uint64_t a1, void ***a2)
{
}

void sub_19E06E188(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF09CC38;
}

void *sub_19E06E1A8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EF09CC38;
  return result;
}

void sub_19E06E1E0()
{
}

void sub_19E06E1F8(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x2000000000;
  char v6 = 0;
  uint64_t v4 = sub_19E04EE08();
  sub_19E04F024(v4, *(void *)(a1 + 8), a2);
  _Block_object_dispose(v5, 8);
}

void sub_19E06E2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E06E2C8(uint64_t a1, char a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = sub_19E06E314(*(void *)(*(void *)(a1 + 40) + 24), a2);
  *a4 = *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E06E314(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

void sub_19E06E364(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 112))(a1))
  {
    if (a4)
    {
      v10[0] = 0;
      v10[1] = v10;
      _DWORD v10[2] = 0x2000000000;
      char v11 = 0;
      sub_19E04EE08();
      off_1EC301518();
      sub_19E04EFF4(v9, v8, a2);
      _Block_object_dispose(v10, 8);
    }
    else
    {
      LODWORD(v10[0]) = 0;
      char v12 = 0;
      if ((*(unsigned int (**)(uint64_t, uint64_t, void *))(*(void *)a1 + 128))(a1, a2, v10)) {
        sub_19E06E4F4(*(void *)(a3 + 24), v10[0], 0, 0, (uint64_t)&v12);
      }
    }
  }
}

void sub_19E06E4DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E06E4F4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v7[0] = a3;
  v7[1] = a4;
  int v6 = a2;
  if (!a1) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, int *, void *, uint64_t))(*(void *)a1 + 48))(a1, &v6, v7, a5);
}

uint64_t sub_19E06E550(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v6 = off_1EC301518();
  uint64_t result = sub_19E06E4F4(*(void *)(v7 + 24), v8, v6, v9, *(void *)(*(void *)(a1 + 32) + 8) + 24);
  *a4 = *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E06E5B4(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = (*(uint64_t (**)(uint64_t *))(*a1 + 112))(a1);
  if (result)
  {
    uint64_t v7 = sub_19E04EE08();
    int v8 = sub_19E04F054(v7, a1[1], a2);
    *a3 = v8;
    return v8 != 0;
  }
  return result;
}

uint64_t sub_19E06E628(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  long long v10 = *a2;
  if (!a4) {
    return v10;
  }
  uint64_t v4 = a4;
  while (1)
  {
    uint64_t v7 = sub_19E04EE08();
    *(void *)&long long v10 = sub_19E04EFC4(v7, *(void *)(a1 + 8), (uint64_t)&v10);
    *((void *)&v10 + 1) = v8;
    if (!sub_19E04F090((uint64_t)&v10)) {
      break;
    }
    ++a3;
    if (!--v4) {
      return v10;
    }
  }
  return 0;
}

BOOL sub_19E06E6B0(uint64_t a1, uint64_t a2)
{
  return sub_19E04F090(a2);
}

uint64_t sub_19E06E6B8(uint64_t a1)
{
  return sub_19E04ED9C(*(unsigned int **)(a1 + 8));
}

void sub_19E06E6C0(uint64_t a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  v20[4] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104))(a1);
  uint64_t v19 = v10;
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t *, const void *, size_t))(*(void *)a1 + 120))(a1, &v18, a2, a3);
  uint64_t v19 = v11;
  if ((*(unsigned int (**)(uint64_t, uint64_t *))(*(void *)a1 + 112))(a1, &v18))
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      sub_19E04147C();
    }
    if (a3 >= 0x17)
    {
      uint64_t v13 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a3 | 7) != 0x17) {
        uint64_t v13 = a3 | 7;
      }
      uint64_t v14 = v13 + 1;
      char v12 = operator new(v13 + 1);
      __p[1] = (void *)a3;
      unint64_t v17 = v14 | 0x8000000000000000;
      __p[0] = v12;
    }
    else
    {
      HIBYTE(v17) = a3;
      char v12 = __p;
      if (!a3)
      {
LABEL_10:
        *((unsigned char *)v12 + a3) = 0;
        uint64_t v15 = operator new(0x28uLL);
        void *v15 = &unk_1EF09CEA0;
        v15[1] = __p;
        void v15[2] = a2;
        uint64_t v15[3] = a3;
        void v15[4] = a4;
        _OWORD v20[3] = v15;
        (*(void (**)(uint64_t, uint64_t *, void *, uint64_t))(*(void *)a1 + 136))(a1, &v18, v20, a5);
        sub_19E06C7E4(v20);
        if (SHIBYTE(v17) < 0) {
          operator delete(__p[0]);
        }
        return;
      }
    }
    memmove(v12, a2, a3);
    goto LABEL_10;
  }
}

void sub_19E06E8CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_19E06E900()
{
  return &unk_1EF09B7A8;
}

uint64_t sub_19E06E90C(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B7A8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

uint64_t sub_19E06E94C(uint64_t *a1, int *a2, uint64_t a3, uint64_t a4)
{
  size_t v8 = *(void *)(a3 + 8);
  uint64_t v9 = a1[3];
  unint64_t v10 = v9 + v8;
  uint64_t v11 = a1[1];
  int v12 = *(char *)(v11 + 23);
  if (v12 < 0) {
    unint64_t v13 = *(void *)(v11 + 8);
  }
  else {
    unint64_t v13 = *(unsigned __int8 *)(v11 + 23);
  }
  uint64_t v14 = *(const void **)a3;
  if (v13 < v10)
  {
    std::string::resize((std::string *)a1[1], v9 + v8, 0);
    uint64_t v11 = a1[1];
    uint64_t v9 = a1[3];
    LOBYTE(v12) = *(unsigned char *)(v11 + 23);
  }
  uint64_t v15 = v11;
  if ((v12 & 0x80) == 0)
  {
    if (!v8) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v15 = *(void *)v11;
  if (v8)
  {
LABEL_8:
    memmove((void *)(v15 + v9), v14, v8);
    uint64_t v11 = a1[1];
    LOBYTE(v12) = *(unsigned char *)(v11 + 23);
  }
LABEL_9:
  int v16 = *a2;
  if ((v12 & 0x80) != 0) {
    uint64_t v11 = *(void *)v11;
  }
  uint64_t v17 = *(void *)(a1[4] + 24);

  return sub_19E06E4F4(v17, v16, v11, v10, a4);
}

__n128 sub_19E06EA3C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09CEA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E06EA6C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1EF09CEA0;
  *(_OWORD *)(v2 + ++**(_DWORD **)(result + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_19E06EAC0()
{
}

uint64_t sub_19E06EAD8(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v7 = result;
    char v16 = 0;
    uint64_t v8 = 0;
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)result + 104))(result);
    uint64_t v15 = v9;
    int v13 = 0;
    while (1)
    {
      uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)v7 + 120))(v7, &v14, a2 + v8, 1);
      uint64_t v15 = v10;
      __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v7 + 112))(v7, &v14);
      if (!result) {
        break;
      }
      __n128 result = (*(uint64_t (**)(uint64_t, uint64_t *, int *))(*(void *)v7 + 128))(v7, &v14, &v13);
      if (result)
      {
        unint64_t v11 = v8 + 1;
        if (a3 >= v8 + 1) {
          uint64_t v12 = v8 + 1;
        }
        else {
          uint64_t v12 = a3;
        }
        __n128 result = sub_19E06E4F4(*(void *)(a4 + 24), v13, a2, v12, (uint64_t)&v16);
        if (v16) {
          return result;
        }
        ++v8;
        if (v11 >= a3) {
          return result;
        }
      }
      else if (++v8 >= a3)
      {
        return result;
      }
    }
  }
  return result;
}

uint64_t sub_19E06EC38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[0] = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104))(a1);
  v11[1] = v8;
  v12[0] = (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)a1 + 120))(a1, v11, a2, a3);
  v12[1] = v9;
  return (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 128))(a1, v12, a4);
}

BOOL sub_19E06ED04(uint64_t *a1, uint64_t **a2, int **a3)
{
  (*(void (**)(uint64_t *, void, void))(*a1 + 72))(a1, 0, 0);
  uint64_t v38 = 0;
  size_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v6 = *a3;
  uint64_t v7 = a3[1];
  std::string __p = &v38;
  while (v6 != v7)
  {
    int v41 = *v6;
    sub_19E06F008((uint64_t *)&__p, &v41);
    ++v6;
  }
  std::string __p = 0;
  uint64_t v36 = 0;
  unint64_t v37 = 0;
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (*a2 == v9)
  {
    uint64_t v10 = 0;
    uint64_t v32 = 0;
    unint64_t v11 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    unint64_t v12 = 0;
    do
    {
      int v13 = v8;
      if (*((char *)v8 + 23) < 0) {
        int v13 = (uint64_t *)*v8;
      }
      if ((unint64_t)v11 >= v12)
      {
        uint64_t v14 = (v11 - v10) >> 3;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61) {
          sub_19E041BEC();
        }
        if ((uint64_t)(v12 - (void)v10) >> 2 > v15) {
          unint64_t v15 = (uint64_t)(v12 - (void)v10) >> 2;
        }
        if (v12 - (unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v15;
        }
        if (v16) {
          unint64_t v16 = (unint64_t)sub_19E060B48(v16);
        }
        else {
          uint64_t v17 = 0;
        }
        uint64_t v18 = (char *)(v16 + 8 * v14);
        *(void *)uint64_t v18 = v13;
        uint64_t v19 = v18 + 8;
        while (v11 != v10)
        {
          uint64_t v20 = *((void *)v11 - 1);
          v11 -= 8;
          *((void *)v18 - 1) = v20;
          v18 -= 8;
        }
        unint64_t v12 = v16 + 8 * v17;
        if (v10) {
          operator delete(v10);
        }
        uint64_t v10 = v18;
        unint64_t v11 = v19;
      }
      else
      {
        *(void *)unint64_t v11 = v13;
        v11 += 8;
      }
      if (*((char *)v8 + 23) < 0) {
        uint64_t v21 = v8[1];
      }
      else {
        uint64_t v21 = *((unsigned __int8 *)v8 + 23);
      }
      unint64_t v22 = v36;
      if (v36 >= v37)
      {
        uint64_t v24 = (char *)__p;
        uint64_t v25 = (v36 - (unsigned char *)__p) >> 3;
        unint64_t v26 = v25 + 1;
        if ((unint64_t)(v25 + 1) >> 61) {
          sub_19E041BEC();
        }
        uint64_t v27 = v37 - (unsigned char *)__p;
        if ((v37 - (unsigned char *)__p) >> 2 > v26) {
          unint64_t v26 = v27 >> 2;
        }
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28)
        {
          uint64_t v29 = (char *)sub_19E049FB0((uint64_t)&v37, v28);
          uint64_t v24 = (char *)__p;
          unint64_t v22 = v36;
        }
        else
        {
          uint64_t v29 = 0;
        }
        unint64_t v30 = &v29[8 * v25];
        *(void *)unint64_t v30 = v21;
        uint64_t v23 = v30 + 8;
        while (v22 != v24)
        {
          uint64_t v31 = *((void *)v22 - 1);
          v22 -= 8;
          *((void *)v30 - 1) = v31;
          v30 -= 8;
        }
        std::string __p = v30;
        uint64_t v36 = v23;
        unint64_t v37 = &v29[8 * v28];
        if (v24) {
          operator delete(v24);
        }
      }
      else
      {
        *(void *)uint64_t v36 = v21;
        uint64_t v23 = v22 + 8;
      }
      uint64_t v36 = v23;
      v8 += 3;
    }
    while (v8 != v9);
    uint64_t v32 = (uint64_t *)__p;
  }
  int v33 = sub_19E058D94(a1[1], (v11 - v10) >> 3, (unsigned __int8 **)v10, v32, v38);
  if (__p)
  {
    uint64_t v36 = (char *)__p;
    operator delete(__p);
  }
  if (v10) {
    operator delete(v10);
  }
  if (v38)
  {
    size_t v39 = v38;
    operator delete(v38);
  }
  return v33 == 0;
}

void sub_19E06EFB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, void *a15, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  if (v16) {
    operator delete(v16);
  }
  if (a15) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_19E06F008(uint64_t *a1, _DWORD *a2)
{
  uint64_t v4 = *a1;
  uint64_t v6 = *(_DWORD **)(*a1 + 8);
  unint64_t v5 = *(void *)(*a1 + 16);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(_DWORD **)v4;
    uint64_t v9 = ((uint64_t)v6 - *(void *)v4) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      sub_19E041BEC();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    BOOL v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL;
    unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v12) {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v13 = (unint64_t)sub_19E068D84(v13);
      uint64_t v8 = *(_DWORD **)v4;
      uint64_t v6 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      uint64_t v14 = 0;
    }
    unint64_t v15 = (_DWORD *)(v13 + 4 * v9);
    unint64_t v16 = v13 + 4 * v14;
    _DWORD *v15 = *a2;
    uint64_t v7 = v15 + 1;
    while (v6 != v8)
    {
      int v17 = *--v6;
      *--unint64_t v15 = v17;
    }
    *(void *)uint64_t v4 = v15;
    *(void *)(v4 + ++**(_DWORD **)(result + 8) = v7;
    *(void *)(v4 + 16) = v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    _DWORD *v6 = *a2;
    uint64_t v7 = v6 + 1;
  }
  *(void *)(v4 + ++**(_DWORD **)(result + 8) = v7;
  return a1;
}

BOOL sub_19E06F0EC(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = a1;
  (*(void (**)(uint64_t, void, void))(*(void *)a1 + 72))(a1, 0, 0);
  if (a2[1] == *a2)
  {
    uint64_t v4 = 0;
    int v17 = 0;
    size_t v39 = 0;
    uint64_t v18 = 0;
    std::string __p = 0;
    unint64_t v45 = 0;
  }
  else
  {
    uint64_t v42 = v3;
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    unint64_t v6 = 0;
    LODWORD(v7) = 1;
    do
    {
      if ((unint64_t)v5 >= v6)
      {
        uint64_t v9 = (v5 - v4) >> 2;
        unint64_t v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) >> 62) {
          sub_19E041BEC();
        }
        if ((uint64_t)(v6 - (void)v4) >> 1 > v10) {
          unint64_t v10 = (uint64_t)(v6 - (void)v4) >> 1;
        }
        if (v6 - (unint64_t)v4 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v11 = v10;
        }
        if (v11) {
          unint64_t v11 = (unint64_t)sub_19E068D84(v11);
        }
        else {
          uint64_t v12 = 0;
        }
        unint64_t v13 = (char *)(v11 + 4 * v9);
        *(_DWORD *)unint64_t v13 = v7;
        uint64_t v8 = v13 + 4;
        while (v5 != v4)
        {
          int v14 = *((_DWORD *)v5 - 1);
          v5 -= 4;
          *((_DWORD *)v13 - 1) = v14;
          v13 -= 4;
        }
        unint64_t v6 = v11 + 4 * v12;
        if (v4) {
          operator delete(v4);
        }
        uint64_t v4 = v13;
      }
      else
      {
        *(_DWORD *)unint64_t v5 = v7;
        uint64_t v8 = v5 + 4;
      }
      unint64_t v7 = (v7 + 1);
      unint64_t v16 = *a2;
      unint64_t v15 = a2[1];
      unint64_t v5 = v8;
    }
    while (0xAAAAAAAAAAAAAAABLL * (v15 - *a2) >= v7);
    std::string __p = 0;
    unint64_t v44 = 0;
    unint64_t v45 = 0;
    if (v16 == v15)
    {
      int v17 = 0;
      size_t v39 = 0;
      uint64_t v18 = 0;
    }
    else
    {
      int v17 = 0;
      uint64_t v18 = 0;
      unint64_t v19 = 0;
      do
      {
        uint64_t v20 = v16;
        if (*((char *)v16 + 23) < 0) {
          uint64_t v20 = (uint64_t *)*v16;
        }
        if ((unint64_t)v18 >= v19)
        {
          uint64_t v21 = (v18 - v17) >> 3;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 61) {
            sub_19E041BEC();
          }
          if ((uint64_t)(v19 - (void)v17) >> 2 > v22) {
            unint64_t v22 = (uint64_t)(v19 - (void)v17) >> 2;
          }
          if (v19 - (unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v23 = v22;
          }
          if (v23) {
            unint64_t v23 = (unint64_t)sub_19E060B48(v23);
          }
          else {
            uint64_t v24 = 0;
          }
          uint64_t v25 = (char *)(v23 + 8 * v21);
          *(void *)uint64_t v25 = v20;
          unint64_t v26 = v25 + 8;
          while (v18 != v17)
          {
            uint64_t v27 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v25 - 1) = v27;
            v25 -= 8;
          }
          unint64_t v19 = v23 + 8 * v24;
          if (v17) {
            operator delete(v17);
          }
          int v17 = v25;
          uint64_t v18 = v26;
        }
        else
        {
          *(void *)uint64_t v18 = v20;
          v18 += 8;
        }
        if (*((char *)v16 + 23) < 0) {
          uint64_t v28 = v16[1];
        }
        else {
          uint64_t v28 = *((unsigned __int8 *)v16 + 23);
        }
        uint64_t v29 = v44;
        if (v44 >= v45)
        {
          uint64_t v31 = __p;
          uint64_t v32 = (v44 - __p) >> 3;
          unint64_t v33 = v32 + 1;
          if ((unint64_t)(v32 + 1) >> 61) {
            sub_19E041BEC();
          }
          uint64_t v34 = v45 - __p;
          if ((v45 - __p) >> 2 > v33) {
            unint64_t v33 = v34 >> 2;
          }
          if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v35 = v33;
          }
          if (v35)
          {
            uint64_t v36 = (char *)sub_19E049FB0((uint64_t)&v45, v35);
            uint64_t v31 = __p;
            uint64_t v29 = v44;
          }
          else
          {
            uint64_t v36 = 0;
          }
          unint64_t v37 = &v36[8 * v32];
          *(void *)unint64_t v37 = v28;
          unint64_t v30 = v37 + 8;
          while (v29 != v31)
          {
            uint64_t v38 = *((void *)v29 - 1);
            v29 -= 8;
            *((void *)v37 - 1) = v38;
            v37 -= 8;
          }
          std::string __p = v37;
          unint64_t v45 = &v36[8 * v35];
          if (v31) {
            operator delete(v31);
          }
        }
        else
        {
          *(void *)unint64_t v44 = v28;
          unint64_t v30 = v44 + 8;
        }
        unint64_t v44 = v30;
        v16 += 3;
      }
      while (v16 != v15);
      size_t v39 = (uint64_t *)__p;
    }
    uint64_t v3 = v42;
  }
  int v40 = sub_19E058D94(*(void *)(v3 + 8), (v18 - v17) >> 3, (unsigned __int8 **)v17, v39, v4);
  if (__p) {
    operator delete(__p);
  }
  if (v17) {
    operator delete(v17);
  }
  if (v4) {
    operator delete(v4);
  }
  return v40 == 0;
}

void sub_19E06F458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
  {
    operator delete(__p);
    if (!v14)
    {
LABEL_3:
      if (!v13) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if (!v14)
  {
    goto LABEL_3;
  }
  operator delete(v14);
  if (!v13) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_4:
  operator delete(v13);
  goto LABEL_5;
}

void sub_19E06F4A8()
{
  if (!v0) {
    JUMPOUT(0x19E06F484);
  }
  JUMPOUT(0x19E06F47CLL);
}

void *sub_19E06F4B8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  size_t __len = 0;
  uint64_t v3 = (void *)sub_19E050210(*(void **)(a1 + 8), &__len);
  return sub_19E057A94(a2, v3, __len);
}

void *sub_19E06F500(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v5[4] = *MEMORY[0x1E4F143B8];
  v5[0] = &unk_1EF09CEF8;
  v5[1] = a4;
  void v5[3] = v5;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96))(a1, a2, a3, v5);
  return sub_19E06C7E4(v5);
}

void sub_19E06F5A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E06C7E4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_19E06F5B8()
{
  return &unk_1EF09B7B8;
}

uint64_t sub_19E06F5C4(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B7B8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

uint64_t sub_19E06F604(uint64_t a1, int *a2, uint64_t *a3, uint64_t a4)
{
  return sub_19E06F620(*(void *)(*(void *)(a1 + 8) + 24), *a2, *a3, a3[1], a4);
}

uint64_t sub_19E06F620(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v7[0] = a3;
  v7[1] = a4;
  uint64_t v6 = a2;
  if (!a1) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, void *, uint64_t))(*(void *)a1 + 48))(a1, &v6, v7, a5);
}

uint64_t sub_19E06F684(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF09CEF8;
  a2[1] = v2;
  return result;
}

void *sub_19E06F6A8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF09CEF8;
  result[1] = v3;
  return result;
}

void sub_19E06F6F0()
{
}

void *sub_19E06F708(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v5[4] = *MEMORY[0x1E4F143B8];
  v5[0] = &unk_1EF09CF50;
  v5[1] = a4;
  void v5[3] = v5;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 88))(a1, a2, a3, v5);
  return sub_19E06C7E4(v5);
}

void sub_19E06F7AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E06C7E4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_19E06F7C0()
{
  return &unk_1EF09B7C8;
}

uint64_t sub_19E06F7CC(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B7C8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

uint64_t sub_19E06F80C(uint64_t a1, int *a2, uint64_t *a3, uint64_t a4)
{
  return sub_19E06F620(*(void *)(*(void *)(a1 + 8) + 24), *a2, *a3, a3[1], a4);
}

uint64_t sub_19E06F830(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF09CF50;
  a2[1] = v2;
  return result;
}

void *sub_19E06F854(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF09CF50;
  result[1] = v3;
  return result;
}

void sub_19E06F89C()
{
}

uint64_t sub_19E06F8B4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v6 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)a1 + 80))(a1, a2, a3, &v6);
  *a4 = v6;
  return result;
}

BOOL sub_19E06F910(uint64_t *a1, unint64_t a2, unsigned __int8 **a3, uint64_t *a4, void *a5)
{
  (*(void (**)(uint64_t *, void, void))(*a1 + 72))(a1, 0, 0);
  std::string __p = 0;
  uint64_t v27 = 0;
  unint64_t v28 = 0;
  uint64_t v24 = a3;
  uint64_t v25 = a4;
  if (a5)
  {
    p_p = &__p;
    if (a2)
    {
      uint64_t v10 = 8 * a2;
      do
      {
        int v29 = *a5;
        sub_19E06F008((uint64_t *)&p_p, &v29);
        ++a5;
        v10 -= 8;
      }
      while (v10);
    }
  }
  else if (a2)
  {
    unint64_t v11 = 0;
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    LODWORD(v14) = 1;
    do
    {
      if ((unint64_t)v13 >= v12)
      {
        uint64_t v16 = (v13 - v11) >> 2;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 62) {
          sub_19E041BEC();
        }
        if ((uint64_t)(v12 - (void)v11) >> 1 > v17) {
          unint64_t v17 = (uint64_t)(v12 - (void)v11) >> 1;
        }
        if (v12 - (unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v17;
        }
        if (v18) {
          unint64_t v18 = (unint64_t)sub_19E068D84(v18);
        }
        else {
          uint64_t v19 = 0;
        }
        uint64_t v20 = (_DWORD *)(v18 + 4 * v16);
        _DWORD *v20 = v14;
        unint64_t v15 = v20 + 1;
        while (v13 != v11)
        {
          int v21 = *((_DWORD *)v13 - 1);
          v13 -= 4;
          *--uint64_t v20 = v21;
        }
        unint64_t v12 = v18 + 4 * v19;
        std::string __p = v20;
        unint64_t v28 = v12;
        if (v11) {
          operator delete(v11);
        }
        unint64_t v11 = (char *)v20;
      }
      else
      {
        *(_DWORD *)unint64_t v13 = v14;
        unint64_t v15 = v13 + 4;
      }
      uint64_t v27 = v15;
      unint64_t v14 = (v14 + 1);
      unint64_t v13 = (char *)v15;
    }
    while (v14 <= a2);
  }
  int v22 = sub_19E058D94(a1[1], a2, v24, v25, __p);
  if (__p)
  {
    uint64_t v27 = __p;
    operator delete(__p);
  }
  return v22 == 0;
}

void sub_19E06FACC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E06FAF4(void *a1)
{
  *a1 = &unk_1EF09B9F0;
  uint64_t v1 = a1 + 2;
  sub_19E06E0C4(a1 + 1, 0);
  sub_19E06DF34(v1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E06FB6C(void *a1)
{
  *a1 = &unk_1EF09B9F0;
  uint64_t v2 = a1 + 2;
  sub_19E06E0C4(a1 + 1, 0);
  sub_19E06DF34(v2);
  return a1;
}

void sub_19E06FBC4(uint64_t a1)
{
  sub_19E06FBFC(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E06FBFC(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C3D0;
  sub_19E068788(a1);
  if (*(char *)(a1 + 335) < 0) {
    operator delete(*(void **)(a1 + 312));
  }
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 4++**(_DWORD **)(result + 8) = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 48 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 56) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 160);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_19E06FD4C(uint64_t a1)
{
  sub_19E06FD84(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E06FD84(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09BC20;
  sub_19E06C980(a1);
  uint64_t v2 = *(void **)(a1 + 632);
  if (v2)
  {
    *(void *)(a1 + 64sub_19E03D880(&a9, 0) = v2;
    operator delete(v2);
  }
  if (*(void *)(a1 + 608))
  {
    sub_19E06C9E4((void *)(a1 + 608));
    operator delete(*(void **)(a1 + 608));
  }
  uint64_t v3 = *(void **)(a1 + 584);
  if (v3)
  {
    *(void *)(a1 + 592) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 383) < 0) {
    operator delete(*(void **)(a1 + 360));
  }
  uint64_t v4 = MEMORY[0x1E4FBA418];
  uint64_t v5 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 96) = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 96 + *(void *)(v5 - 24)) = *(void *)(v4 + 24);
  *(void *)(a1 + 104) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 208);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  return a1;
}

uint64_t sub_19E06FF10(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09BC20;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 8sub_19E03D880(&a9, 0) = 0;
  *(void *)(a1 + 8++**(_DWORD **)(result + 8) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  sub_19E05DB78(a1 + 96);
  *(void *)(a1 + 36sub_19E03D880(&a9, 0) = 0;
  *(void *)(a1 + 36++**(_DWORD **)(result + 8) = 0;
  *(void *)(a1 + 376) = 0;
  *(_DWORD *)(a1 + 576) = 0;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 60sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 641) = 0u;
  return a1;
}

void sub_19E06FF94(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E06FFB0(uint64_t a1)
{
  sub_19E06FFE8(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E06FFE8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C1F0;
  if (*(unsigned char *)(a1 + 32))
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
    }
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

BOOL sub_19E070054(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v6 = v5 + a2;
  if (v3)
  {
    if (v6 >= v4)
    {
      if (!v4)
      {
        *(void *)(a1 + 16) = 0x2000;
        operator new[]();
      }
      do
      {
        BOOL v7 = v6 >= 2 * v4;
        v4 *= 2;
      }
      while (v7);
      *(void *)(a1 + 16) = v4;
      operator new[]();
    }
    return 1;
  }
  else
  {
    BOOL v7 = v6 >= v4;
    BOOL result = v6 < v4;
    char v9 = v7;
    *(unsigned char *)(a1 + 33) = v9;
  }
  return result;
}

uint64_t sub_19E070138(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (sub_19E070054(a1, v4))
  {
    memcpy((void *)(*(void *)(a1 + 24) + *(void *)(a1 + 8)), __s, v4);
    *(void *)(a1 + 8) += v4;
  }
  return a1;
}

BOOL sub_19E0701A8(const void **a1, char *__s)
{
  int v4 = *((char *)a1 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (v5 != strlen(__s)) {
    return 0;
  }
  if (v4 >= 0) {
    unint64_t v6 = a1;
  }
  else {
    unint64_t v6 = *a1;
  }
  return memcmp(v6, __s, v5) == 0;
}

std::string *sub_19E070220(std::string *__dst, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E03FA9C(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&__dst->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    __dst->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
  if (SHIBYTE(__dst->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = __dst->__r_.__value_.__l.__size_;
    if (!size) {
      goto LABEL_13;
    }
  }
  else
  {
    if (!*((unsigned char *)&__dst->__r_.__value_.__s + 23)) {
      goto LABEL_13;
    }
    std::string::size_type size = HIBYTE(__dst->__r_.__value_.__r.__words[2]);
  }
  if ((__dst->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v6 = __dst;
  }
  else {
    unint64_t v6 = (std::string *)__dst->__r_.__value_.__r.__words[0];
  }
  if (v6->__r_.__value_.__s.__data_[size - 1] != 47) {
    std::string::push_back(__dst, 47);
  }
LABEL_13:
  int v7 = *(char *)(a3 + 23);
  if (v7 >= 0) {
    uint64_t v8 = (const std::string::value_type *)a3;
  }
  else {
    uint64_t v8 = *(const std::string::value_type **)a3;
  }
  if (v7 >= 0) {
    std::string::size_type v9 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v9 = *(void *)(a3 + 8);
  }
  return std::string::append(__dst, v8, v9);
}

void sub_19E0702DC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E0702F8(uint64_t a1, char *a2, uint64_t a3, char a4)
{
  _DWORD v19[2] = *MEMORY[0x1E4F143B8];
  sub_19E0413C8(v17, a2);
  if (a4) {
    goto LABEL_12;
  }
  int v7 = *(void **)(a1 + 16);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = (void *)(a1 + 16);
  do
  {
    char v9 = sub_19E05EE24(v7 + 4, v17);
    if (v9 >= 0) {
      uint64_t v10 = v7;
    }
    else {
      uint64_t v10 = v7 + 1;
    }
    if (v9 >= 0) {
      uint64_t v8 = v7;
    }
    int v7 = (void *)*v10;
  }
  while (*v10);
  if (v8 == (void *)(a1 + 16) || (sub_19E05EE24(v17, v8 + 4) & 0x80) != 0)
  {
LABEL_12:
    if (*(char *)(a3 + 23) < 0)
    {
      sub_19E03FA9C(__p, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a3;
      std::strstream __p[2] = *(void **)(a3 + 16);
    }
    unint64_t v11 = (uint64_t *)__p[0];
    v19[0] = __p[1];
    *(void **)((char *)v19 + 7) = *(void **)((char *)&__p[1] + 7);
    char v12 = HIBYTE(__p[2]);
    memset(__p, 0, 24);
    unint64_t v13 = sub_19E0704A4((uint64_t **)(a1 + 8), v17, (uint64_t)v17);
    unint64_t v14 = v13;
    if (*((char *)v13 + 79) < 0) {
      operator delete(v13[7]);
    }
    unint64_t v15 = (uint64_t *)v19[0];
    v14[7] = v11;
    v14[8] = v15;
    *(uint64_t **)((char *)v14 + 71) = *(uint64_t **)((char *)v19 + 7);
    *((unsigned char *)v14 + 79) = v12;
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
  if (v18 < 0) {
    operator delete(v17[0]);
  }
}

void sub_19E07045C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **sub_19E0704A4(uint64_t **a1, void *a2, uint64_t a3)
{
  unint64_t v6 = a1 + 1;
  size_t v5 = a1[1];
  int v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        uint64_t v10 = v5 + 4;
        if ((sub_19E05EE24(a2, v5 + 4) & 0x80) == 0) {
          break;
        }
        size_t v5 = *v7;
        uint64_t v8 = v7;
        if (!*v7) {
          goto LABEL_7;
        }
      }
      if ((sub_19E05EE24(v10, a2) & 0x80) == 0) {
        return v7;
      }
      uint64_t v8 = v7 + 1;
      size_t v5 = v7[1];
      if (!v5) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    unint64_t v11 = operator new(0x50uLL);
    v16[0] = v11;
    v16[1] = v6;
    char v17 = 0;
    char v12 = v11 + 4;
    if (*(char *)(a3 + 23) < 0)
    {
      sub_19E03FA9C(v12, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)char v12 = *(_OWORD *)a3;
      v11[6] = *(void *)(a3 + 16);
    }
    v11[8] = 0;
    v11[9] = 0;
    v11[7] = 0;
    char v17 = 1;
    void *v11 = 0;
    v11[1] = 0;
    void v11[2] = v7;
    *uint64_t v8 = v11;
    unint64_t v13 = (uint64_t *)**a1;
    unint64_t v14 = v11;
    if (v13)
    {
      *a1 = v13;
      unint64_t v14 = *v8;
    }
    sub_19E05D650(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v16[0] = 0;
    sub_19E0705EC((uint64_t)v16);
  }
  return (uint64_t **)v11;
}

void sub_19E0705D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E0705EC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E0705EC(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_19E070644((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void sub_19E070644(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_19E07069C(void *a1)
{
  sub_19E0706D4(a1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0706D4(void *a1)
{
  *a1 = &unk_1EF09C530;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  a1[1] = 0;
  a1[2] = &unk_1EF09BF00;
  uint64_t v3 = a1[3];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void sub_19E07078C(void *a1)
{
  *a1 = &unk_1EF09BF00;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E070818(void *a1)
{
  *a1 = &unk_1EF09BF00;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_19E070888(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 8) && *(void *)(a1 + 24)) {
    uint64_t v2 = "atomic model replacement is not supported";
  }
  else {
    uint64_t v2 = "current model is not available";
  }
  sub_19E07BA98(v2);
  if (a2) {
    (*(void (**)(uint64_t))(*(void *)a2 + 48))(a2);
  }
  return 0;
}

void sub_19E07092C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 48))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E070968(void *a1)
{
  *a1 = &unk_1EF09BEE0;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 48))(v1);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0709F4(void *a1)
{
  *a1 = &unk_1EF09BEE0;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }
  return a1;
}

uint64_t sub_19E070A60(uint64_t a1)
{
  if (*(void *)(a1 + 8) && *(void *)(a1 + 24)) {
    operator new();
  }
  sub_19E07BA98("Model is not available");
  return 0;
}

void sub_19E070ACC(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA710](v1, 0x10F3C40B77F16BFLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E070AF0(uint64_t a1)
{
  if (*(void *)(a1 + 8) && *(void *)(a1 + 24)) {
    operator new();
  }
  sub_19E07BA98("Model is not available");
  return 0;
}

void sub_19E070C5C(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA710](v1, 0x10F3C4078267834);
  _Unwind_Resume(a1);
}

uint64_t sub_19E070C80(uint64_t a1, unsigned int a2, int a3)
{
  return sub_19E05DDEC(*(void *)(*(void *)(a1 + 8) + 88), a2, a3);
}

uint64_t sub_19E070C8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v1) {
    return *(void *)(v1 + 240);
  }
  else {
    return 0;
  }
}

uint64_t sub_19E070CA8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C430;
  uint64_t v2 = a1 + 128;
  if (*(char *)(a1 + 415) < 0) {
    operator delete(*(void **)(a1 + 392));
  }
  uint64_t v3 = MEMORY[0x1E4FBA418];
  uint64_t v4 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 12++**(_DWORD **)(result + 8) = *MEMORY[0x1E4FBA418];
  *(void *)(v2 + *(void *)(v4 - 24)) = *(void *)(v3 + 24);
  *(void *)(a1 + 136) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 240);
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  unint64_t v6 = (void **)(a1 + 32);
  sub_19E041AD0(&v6);
  sub_19E070E2C(*(void **)(a1 + 16));
  return a1;
}

void sub_19E070E2C(void *a1)
{
  if (a1)
  {
    sub_19E070E2C(*a1);
    sub_19E070E2C(a1[1]);
    sub_19E070644((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_19E070E80(uint64_t a1)
{
  sub_19E070CA8(a1);

  JUMPOUT(0x19F3BA710);
}

void sub_19E070EBC(void *a1)
{
  *a1 = &unk_1EF09BFC0;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x19F3BA710](v1, 0x1000C4000313F17);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E070F38(void *a1)
{
  *a1 = &unk_1EF09BFC0;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x19F3BA710](v2, 0x1000C4000313F17);
  }
  return a1;
}

void sub_19E070F94(const void **a1, CFTypeRef cf)
{
  if (*a1 != cf)
  {
    CFRetain(cf);
    sub_19E041524(a1, cf);
  }
}

uint64_t **sub_19E070FF4(uint64_t **result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *BOOL result = a2;
  if (v2)
  {
    uint64_t v3 = *v2;
    uint64_t *v2 = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 328))(v3);
    }
    JUMPOUT(0x19F3BA710);
  }
  return result;
}

void sub_19E071084(uint64_t a1)
{
  sub_19E0710BC(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E0710BC(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09B7E8;
  uint64_t v2 = (uint64_t **)(a1 + 8);
  sub_19E041524((const void **)(a1 + 24), 0);
  sub_19E03D880((const void **)(a1 + 16), 0);
  sub_19E070FF4(v2, 0);
  return a1;
}

__n128 sub_19E071128(long long *a1)
{
  if (qword_1E9457348 != -1) {
    dispatch_once(&qword_1E9457348, &unk_1EF09D1D8);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  long long v3 = *a1;
  *(void *)(Instance + 32) = *((void *)a1 + 2);
  *(_OWORD *)(Instance + 16) = v3;
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  *(void *)a1 = 0;
  long long v4 = *(long long *)((char *)a1 + 24);
  *(_DWORD *)(Instance + 56) = *((_DWORD *)a1 + 10);
  *(_OWORD *)(Instance + 4sub_19E03D880(&a9, 0) = v4;
  *(void *)(Instance + 72) = 0;
  *(void *)(Instance + 8sub_19E03D880(&a9, 0) = 0;
  *(void *)(Instance + 64) = 0;
  __n128 result = (__n128)a1[3];
  *(__n128 *)(Instance + 64) = result;
  *(void *)(Instance + 8sub_19E03D880(&a9, 0) = *((void *)a1 + 8);
  *((void *)a1 + 6) = 0;
  *((void *)a1 + 7) = 0;
  *((void *)a1 + ++**(_DWORD **)(result + 8) = 0;
  return result;
}

void sub_19E0711DC(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
}

void sub_19E071210(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    size_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 72;
        sub_19E071294(v4);
      }
      while ((void *)v4 != v2);
      size_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_19E071294(uint64_t a1)
{
  long long v3 = (void **)(a1 + 48);
  sub_19E0712F8(&v3);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_19E0712F8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (const void **)**a1;
  if (v2)
  {
    uint64_t v4 = (const void **)v1[1];
    size_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 2;
        sub_19E060B80(v4, 0);
      }
      while (v4 != v2);
      size_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_19E071380()
{
  qword_1E9457350 = 0;
  *(void *)algn_1E9457358 = "_LXAnalyzerCandidate";
  qword_1E9457360 = 0;
  unk_1E9457368 = 0;
  qword_1E9457370 = (uint64_t)sub_19E0713D4;
  unk_1E9457378 = 0u;
  unk_1E9457388 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1E94573B0 = result;
  return result;
}

void sub_19E0713D4(uint64_t a1)
{
  long long v3 = (void **)(a1 + 64);
  sub_19E0712F8(&v3);
  if (*(char *)(a1 + 39) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 16);
    operator delete(v2);
  }
}

void LXAnalyzerCreate(const void *a1)
{
  if (qword_1E94573B8 != -1) {
    dispatch_once(&qword_1E94573B8, &unk_1EF09ABD0);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 16) = &unk_1EF09B7E8;
  *(void *)(Instance + 24) = 0;
  *(void *)(Instance + 4sub_19E03D880(&a9, 0) = 0;
  *(void *)(Instance + 32) = 0;
  sub_19E070F94((const void **)(Instance + 40), a1);
  operator new();
}

void sub_19E071548(_Unwind_Exception *a1)
{
  sub_19E041524(v3, 0);
  sub_19E03D880((const void **)(v1 + 32), 0);
  sub_19E070FF4(v2, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_19E07157C()
{
  qword_1E94573C0 = 0;
  *(void *)algn_1E94573C8 = "LXAnalyzer";
  qword_1E94573D0 = 0;
  unk_1E94573D8 = 0;
  qword_1E94573E0 = (uint64_t)sub_19E0715D0;
  unk_1E94573E8 = 0u;
  unk_1E94573F8 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1E9457420 = result;
  return result;
}

uint64_t sub_19E0715D0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 16))();
}

void LXAnalyzerEnumerateCandidates(uint64_t a1, CFStringRef theString, char a3, uint64_t a4)
{
  int v7 = *(void **)(a1 + 24);
  CharactersPtr = CFStringGetCharactersPtr(theString);
  CFIndex Length = CFStringGetLength(theString);
  if (!CharactersPtr) {
    operator new[]();
  }
  if ((a3 & 0x10) != 0) {
    uint64_t v10 = 156;
  }
  else {
    uint64_t v10 = 148;
  }
  (*(void (**)(void, const UniChar *, CFIndex, void, uint64_t))(*(void *)*v7 + 48))(*v7, CharactersPtr, 2 * Length, 0, v10);
  sub_19E0D5C64((void **)&v18, v7, Length);
  unint64_t v11 = v18;
  for (unint64_t i = v19; v11 != i; v11 = (long long *)((char *)v11 + 72))
  {
    __n128 v13 = sub_19E071128(v11);
    unint64_t v15 = v14;
    uint64_t v20 = v14;
    unsigned __int8 v17 = 0;
    (*(void (**)(uint64_t, void **, unsigned __int8 *, __n128))(a4 + 16))(a4, v14, &v17, v13);
    int v16 = v17;
    if (v15) {
      CFRelease(v15);
    }
    if (v16) {
      break;
    }
  }
  uint64_t v20 = (void **)&v18;
  sub_19E071210(&v20);
}

void sub_19E071784(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA6E0](v1, 0x1000C80BDFB0063);
  _Unwind_Resume(a1);
}

void LXAnalyzerEnumerateCandidatesWithLattice(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  unint64_t v6 = *(void **)(a1 + 24);
  uint64_t v7 = *(void *)(a2 + 16);
  sub_19E0D25D0((uint64_t)__p, v7);
  unint64_t v8 = v21;
  if ((v21 & 0x80u) == 0) {
    char v9 = __p;
  }
  else {
    char v9 = (void **)__p[0];
  }
  if ((v21 & 0x80u) != 0) {
    unint64_t v8 = (unint64_t)__p[1];
  }
  if ((a3 & 0x10) != 0) {
    uint64_t v10 = 156;
  }
  else {
    uint64_t v10 = 148;
  }
  (*(void (**)(void, uint64_t, void **, unint64_t, void, uint64_t))(*(void *)*v6 + 56))(*v6, v7, v9, 2 * v8, 0, v10);
  sub_19E0D5C64((void **)&v18, v6, 0);
  if ((char)v21 < 0) {
    operator delete(__p[0]);
  }
  unint64_t v11 = v18;
  for (unint64_t i = v19; v11 != i; v11 = (long long *)((char *)v11 + 72))
  {
    __n128 v13 = sub_19E071128(v11);
    unint64_t v15 = v14;
    __p[0] = v14;
    unsigned __int8 v17 = 0;
    (*(void (**)(uint64_t, void *, unsigned __int8 *, __n128))(a4 + 16))(a4, v14, &v17, v13);
    int v16 = v17;
    if (v15) {
      CFRelease(v15);
    }
    if (v16) {
      break;
    }
  }
  __p[0] = &v18;
  sub_19E071210((void ***)__p);
}

void sub_19E071918(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E071960(uint64_t a1)
{
  sub_19E071998(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E071998(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C450;
  uint64_t v2 = a1 + 88;
  if (*(char *)(a1 + 375) < 0) {
    operator delete(*(void **)(a1 + 352));
  }
  uint64_t v3 = MEMORY[0x1E4FBA418];
  uint64_t v4 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 8++**(_DWORD **)(result + 8) = *MEMORY[0x1E4FBA418];
  *(void *)(v2 + *(void *)(v4 - 24)) = *(void *)(v3 + 24);
  *(void *)(a1 + 96) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 200);
  *(void *)(a1 + 72) = &unk_1EF09C230;
  uint64_t v5 = *(void *)(a1 + 80);
  if (v5) {
    MEMORY[0x19F3BA6E0](v5, 0x1000C8077774924);
  }
  *(void *)(a1 + 56) = &unk_1EF09C230;
  uint64_t v6 = *(void *)(a1 + 64);
  if (v6) {
    MEMORY[0x19F3BA6E0](v6, 0x1000C8077774924);
  }
  *(void *)(a1 + 4sub_19E03D880(&a9, 0) = &unk_1EF09C230;
  uint64_t v7 = *(void *)(a1 + 48);
  if (v7) {
    MEMORY[0x19F3BA6E0](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 24) = &unk_1EF09C230;
  uint64_t v8 = *(void *)(a1 + 32);
  if (v8) {
    MEMORY[0x19F3BA6E0](v8, 0x1000C8077774924);
  }
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = &unk_1EF09C230;
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9) {
    MEMORY[0x19F3BA6E0](v9, 0x1000C8077774924);
  }
  return a1;
}

uint64_t sub_19E071BFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2) + 8);
  uint64_t v5 = (uint64_t *)(v4 + 8);
  if (*(void *)(v4 + 8))
  {
    do
    {
      uint64_t v6 = *(const void **)(v4 + 48);
      size_t v7 = *(unsigned __int16 *)(v4 + 96);
      if (sub_19E070054(a3, v7))
      {
        memcpy((void *)(*(void *)(a3 + 24) + *(void *)(a3 + 8)), v6, v7);
        *(void *)(a3 + 8) += v7;
      }
      if (sub_19E070054(a3, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 9;
      }
      uint64_t v8 = sub_19E070138(a3, *(char **)(v4 + 56));
      if (sub_19E070054(v8, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 10;
      }
      uint64_t v4 = *v5;
      uint64_t v9 = *v5;
      uint64_t v10 = *(void *)(v9 + 8);
      uint64_t v5 = (uint64_t *)(v9 + 8);
    }
    while (v10);
  }
  sub_19E070138(a3, "EOS\n");
  return 1;
}

uint64_t sub_19E071D2C(uint64_t a1, uint64_t a2)
{
  sub_19E06603C((uint64_t)&v115, a2, "output-format-type");
  *(void *)(a1 + 56++**(_DWORD **)(result + 8) = sub_19E071BFC;
  *(void *)(a1 + 576) = 0;
  std::string::size_type v4 = v117;
  if ((v117 & 0x80u) != 0) {
    std::string::size_type v4 = v116;
  }
  if (v4 != 4)
  {
    if (v4 != 6) {
      goto LABEL_18;
    }
    uint64_t v5 = (void **)&v115;
    if ((v117 & 0x80u) != 0) {
      uint64_t v5 = v115;
    }
    int v6 = *(_DWORD *)v5;
    int v7 = *((unsigned __int16 *)v5 + 2);
    BOOL v8 = v6 == 1634427255 && v7 == 26996;
    uint64_t v9 = sub_19E0731D8;
    if (!v8) {
      goto LABEL_18;
    }
LABEL_89:
    *(void *)(a1 + 56++**(_DWORD **)(result + 8) = v9;
    *(void *)(a1 + 576) = 0;
LABEL_264:
    uint64_t v87 = 1;
    goto LABEL_267;
  }
  if ((v117 & 0x80u) == 0) {
    uint64_t v10 = (void **)&v115;
  }
  else {
    uint64_t v10 = v115;
  }
  uint64_t v9 = sub_19E0731D0;
  if (*(_DWORD *)v10 == 1701736302) {
    goto LABEL_89;
  }
  uint64_t v9 = sub_19E072BF8;
  if (*(_DWORD *)v10 == 1886221668) {
    goto LABEL_89;
  }
LABEL_18:
  sub_19E0413C8(&v114, "%m\\t%H\\n");
  sub_19E0413C8(&v113, "%m\\t%H\\n");
  sub_19E0413C8(&v112, "");
  sub_19E0413C8(&v111, "EOS\\n");
  sub_19E0413C8(&v110, "");
  sub_19E0413C8(&v109, "node-format");
  sub_19E0413C8(&v108, "bos-format");
  sub_19E0413C8(&v107, "eos-format");
  sub_19E0413C8(&v106, "unk-format");
  sub_19E0413C8(&v105, "eon-format");
  std::string::size_type v11 = v117;
  if ((v117 & 0x80u) != 0) {
    std::string::size_type v11 = v116;
  }
  if (v11)
  {
    std::string::append(&v109, "-", 1uLL);
    if ((v117 & 0x80u) == 0) {
      char v12 = (const std::string::value_type *)&v115;
    }
    else {
      char v12 = (const std::string::value_type *)v115;
    }
    if ((v117 & 0x80u) == 0) {
      std::string::size_type v13 = v117;
    }
    else {
      std::string::size_type v13 = v116;
    }
    std::string::append(&v109, v12, v13);
    std::string::append(&v108, "-", 1uLL);
    if ((v117 & 0x80u) == 0) {
      unint64_t v14 = (const std::string::value_type *)&v115;
    }
    else {
      unint64_t v14 = (const std::string::value_type *)v115;
    }
    if ((v117 & 0x80u) == 0) {
      std::string::size_type v15 = v117;
    }
    else {
      std::string::size_type v15 = v116;
    }
    std::string::append(&v108, v14, v15);
    std::string::append(&v107, "-", 1uLL);
    if ((v117 & 0x80u) == 0) {
      int v16 = (const std::string::value_type *)&v115;
    }
    else {
      int v16 = (const std::string::value_type *)v115;
    }
    if ((v117 & 0x80u) == 0) {
      std::string::size_type v17 = v117;
    }
    else {
      std::string::size_type v17 = v116;
    }
    std::string::append(&v107, v16, v17);
    std::string::append(&v106, "-", 1uLL);
    if ((v117 & 0x80u) == 0) {
      char v18 = (const std::string::value_type *)&v115;
    }
    else {
      char v18 = (const std::string::value_type *)v115;
    }
    if ((v117 & 0x80u) == 0) {
      std::string::size_type v19 = v117;
    }
    else {
      std::string::size_type v19 = v116;
    }
    std::string::append(&v106, v18, v19);
    std::string::append(&v105, "-", 1uLL);
    if ((v117 & 0x80u) == 0) {
      uint64_t v20 = (const std::string::value_type *)&v115;
    }
    else {
      uint64_t v20 = (const std::string::value_type *)v115;
    }
    if ((v117 & 0x80u) == 0) {
      std::string::size_type v21 = v117;
    }
    else {
      std::string::size_type v21 = v116;
    }
    std::string::append(&v105, v20, v21);
    if ((v109.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v22 = &v109;
    }
    else {
      int v22 = (std::string *)v109.__r_.__value_.__r.__words[0];
    }
    sub_19E06603C((uint64_t)&__p, a2, (char *)v22);
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    int v24 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    if (!size)
    {
      if (setjmp((int *)(a1 + 376)) != 1)
      {
        uint64_t v89 = (void *)(a1 + 88);
        std::ios_base::clear((std::ios_base *)((char *)v89 + *(void *)(*v89 - 24)), 0);
        unint64_t v90 = sub_19E0416F8(v89, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/writer.cpp", 69);
        sub_19E0416F8(v90, (uint64_t)"(", 1);
        uint64_t v91 = (void *)std::ostream::operator<<();
        uint64_t v92 = sub_19E0416F8(v91, (uint64_t)") [", 3);
        unint64_t v93 = sub_19E0416F8(v92, (uint64_t)"!tmp.empty()", 12);
        uint64_t v94 = sub_19E0416F8(v93, (uint64_t)"] ", 2);
        uint64_t v95 = sub_19E0416F8(v94, (uint64_t)"unkown format type [", 20);
        if ((v117 & 0x80u) == 0) {
          unint64_t v96 = (void **)&v115;
        }
        else {
          unint64_t v96 = v115;
        }
        if ((v117 & 0x80u) == 0) {
          uint64_t v97 = v117;
        }
        else {
          uint64_t v97 = v116;
        }
        unint64_t v98 = sub_19E0416F8(v95, (uint64_t)v96, v97);
        sub_19E0416F8(v98, (uint64_t)"]", 1);
        sub_19E05E710((uint64_t)v89);
      }
      if (v24 < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      char v40 = 0;
      goto LABEL_244;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  if ((v109.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v25 = &v109;
  }
  else {
    uint64_t v25 = (std::string *)v109.__r_.__value_.__r.__words[0];
  }
  sub_19E06603C((uint64_t)&__p, a2, (char *)v25);
  if ((v108.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v26 = &v108;
  }
  else {
    unint64_t v26 = (std::string *)v108.__r_.__value_.__r.__words[0];
  }
  sub_19E06603C((uint64_t)&__str, a2, (char *)v26);
  if ((v107.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v27 = &v107;
  }
  else {
    uint64_t v27 = (std::string *)v107.__r_.__value_.__r.__words[0];
  }
  sub_19E06603C((uint64_t)&v102, a2, (char *)v27);
  if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v28 = &v106;
  }
  else {
    unint64_t v28 = (std::string *)v106.__r_.__value_.__r.__words[0];
  }
  sub_19E06603C((uint64_t)v100, a2, (char *)v28);
  if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v29 = &v105;
  }
  else {
    int v29 = (std::string *)v105.__r_.__value_.__r.__words[0];
  }
  sub_19E06603C((uint64_t)&v99, a2, (char *)v29);
  int v30 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
  uint64_t v31 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
  std::string::size_type v32 = v114.__r_.__value_.__l.__size_;
  if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v33 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v33 = v114.__r_.__value_.__l.__size_;
  }
  std::string::size_type v34 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  int v35 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v34 = __p.__r_.__value_.__l.__size_;
  }
  if (v33 != v34)
  {
    *(void *)(a1 + 56++**(_DWORD **)(result + 8) = sub_19E0732E8;
    *(void *)(a1 + 576) = 0;
LABEL_142:
    std::string::operator=(&v114, &__p);
LABEL_143:
    uint64_t v57 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
    if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v58 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v58 = v112.__r_.__value_.__l.__size_;
    }
    std::string::size_type v59 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v59 = __str.__r_.__value_.__l.__size_;
    }
    if (v58 == v59)
    {
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_str = &__str;
      }
      else {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      if ((*((unsigned char *)&v112.__r_.__value_.__s + 23) & 0x80) != 0)
      {
        if (!memcmp(v112.__r_.__value_.__l.__data_, p_str, v112.__r_.__value_.__l.__size_)) {
          goto LABEL_160;
        }
      }
      else
      {
        if (!*((unsigned char *)&v112.__r_.__value_.__s + 23)) {
          goto LABEL_160;
        }
        uint64_t v61 = &v112;
        uint64_t v62 = p_str;
        while (v61->__r_.__value_.__s.__data_[0] == v62->__r_.__value_.__s.__data_[0])
        {
          uint64_t v61 = (std::string *)((char *)v61 + 1);
          uint64_t v62 = (std::string *)((char *)v62 + 1);
          if (!--v57) {
            goto LABEL_160;
          }
        }
      }
    }
    std::string::operator=(&v112, &__str);
LABEL_160:
    uint64_t v63 = HIBYTE(v111.__r_.__value_.__r.__words[2]);
    if ((v111.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v64 = HIBYTE(v111.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v64 = v111.__r_.__value_.__l.__size_;
    }
    std::string::size_type v65 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
    if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v65 = v102.__r_.__value_.__l.__size_;
    }
    if (v64 == v65)
    {
      if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v66 = &v102;
      }
      else {
        uint64_t v66 = (std::string *)v102.__r_.__value_.__r.__words[0];
      }
      if ((*((unsigned char *)&v111.__r_.__value_.__s + 23) & 0x80) == 0)
      {
        if (*((unsigned char *)&v111.__r_.__value_.__s + 23))
        {
          uint64_t v67 = &v111;
          uint64_t v68 = v66;
          while (v67->__r_.__value_.__s.__data_[0] == v68->__r_.__value_.__s.__data_[0])
          {
            uint64_t v67 = (std::string *)((char *)v67 + 1);
            uint64_t v68 = (std::string *)((char *)v68 + 1);
            if (!--v63) {
              goto LABEL_177;
            }
          }
          goto LABEL_176;
        }
LABEL_177:
        uint64_t v69 = HIBYTE(v113.__r_.__value_.__r.__words[2]);
        if ((v113.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v70 = HIBYTE(v113.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v70 = v113.__r_.__value_.__l.__size_;
        }
        unint64_t v71 = (unint64_t)v100[1];
        if ((v101 & 0x80u) == 0) {
          unint64_t v71 = v101;
        }
        p_p = (const std::string *)v100;
        if (v70 == v71)
        {
          uint64_t v73 = (v101 & 0x80u) == 0 ? v100 : (void **)v100[0];
          if ((*((unsigned char *)&v113.__r_.__value_.__s + 23) & 0x80) != 0)
          {
            if (memcmp(v113.__r_.__value_.__l.__data_, v73, v113.__r_.__value_.__l.__size_))
            {
LABEL_193:
              p_p = (const std::string *)v100;
              goto LABEL_212;
            }
          }
          else if (*((unsigned char *)&v113.__r_.__value_.__s + 23))
          {
            uint64_t v74 = &v113;
            while (v74->__r_.__value_.__s.__data_[0] == *(unsigned __int8 *)v73)
            {
              uint64_t v74 = (std::string *)((char *)v74 + 1);
              uint64_t v73 = (void **)((char *)v73 + 1);
              if (!--v69) {
                goto LABEL_194;
              }
            }
            goto LABEL_193;
          }
LABEL_194:
          uint64_t v75 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
          if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v76 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v76 = v114.__r_.__value_.__l.__size_;
          }
          std::string::size_type v77 = __p.__r_.__value_.__l.__size_;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v77 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }
          p_p = &__p;
          if (v76 == v77)
          {
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t v78 = &__p;
            }
            else {
              size_t v78 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            if ((*((unsigned char *)&v114.__r_.__value_.__s + 23) & 0x80) != 0)
            {
              if (memcmp(v114.__r_.__value_.__l.__data_, v78, v114.__r_.__value_.__l.__size_))
              {
LABEL_210:
                p_p = &__p;
                goto LABEL_212;
              }
            }
            else if (*((unsigned char *)&v114.__r_.__value_.__s + 23))
            {
              unsigned int v79 = &v114;
              while (v79->__r_.__value_.__s.__data_[0] == v78->__r_.__value_.__s.__data_[0])
              {
                unsigned int v79 = (std::string *)((char *)v79 + 1);
                size_t v78 = (std::string *)((char *)v78 + 1);
                if (!--v75) {
                  goto LABEL_211;
                }
              }
              goto LABEL_210;
            }
LABEL_211:
            p_p = &v114;
          }
        }
LABEL_212:
        std::string::operator=(&v113, p_p);
        uint64_t v80 = HIBYTE(v110.__r_.__value_.__r.__words[2]);
        if ((v110.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v81 = HIBYTE(v110.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v81 = v110.__r_.__value_.__l.__size_;
        }
        std::string::size_type v82 = HIBYTE(v99.__r_.__value_.__r.__words[2]);
        if ((v99.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v82 = v99.__r_.__value_.__l.__size_;
        }
        if (v81 == v82)
        {
          if ((v99.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v83 = &v99;
          }
          else {
            uint64_t v83 = (std::string *)v99.__r_.__value_.__r.__words[0];
          }
          if ((*((unsigned char *)&v110.__r_.__value_.__s + 23) & 0x80) != 0)
          {
            if (!memcmp(v110.__r_.__value_.__l.__data_, v83, v110.__r_.__value_.__l.__size_)) {
              goto LABEL_229;
            }
          }
          else
          {
            if (!*((unsigned char *)&v110.__r_.__value_.__s + 23)) {
              goto LABEL_229;
            }
            uint64_t v84 = &v110;
            uint64_t v85 = v83;
            while (v84->__r_.__value_.__s.__data_[0] == v85->__r_.__value_.__s.__data_[0])
            {
              uint64_t v84 = (std::string *)((char *)v84 + 1);
              uint64_t v85 = (std::string *)((char *)v85 + 1);
              if (!--v80) {
                goto LABEL_229;
              }
            }
          }
        }
        std::string::operator=(&v110, &v99);
LABEL_229:
        if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          BOOL v86 = &v114;
        }
        else {
          BOOL v86 = (std::string *)v114.__r_.__value_.__r.__words[0];
        }
        sub_19E0619B4(a1 + 8, (char *)v86);
      }
      if (!memcmp(v111.__r_.__value_.__l.__data_, v66, v111.__r_.__value_.__l.__size_)) {
        goto LABEL_177;
      }
    }
LABEL_176:
    std::string::operator=(&v111, &v102);
    goto LABEL_177;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v36 = &__p;
  }
  else {
    uint64_t v36 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((*((unsigned char *)&v114.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    if (memcmp(v114.__r_.__value_.__l.__data_, v36, v114.__r_.__value_.__l.__size_))
    {
      *(void *)(a1 + 56++**(_DWORD **)(result + 8) = sub_19E0732E8;
      *(void *)(a1 + 576) = 0;
      if (v35 >= 0) {
        int v41 = &__p;
      }
      else {
        int v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      goto LABEL_141;
    }
  }
  else if (*((unsigned char *)&v114.__r_.__value_.__s + 23))
  {
    unint64_t v37 = &v114;
    uint64_t v38 = v36;
    uint64_t v39 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
    while (v37->__r_.__value_.__s.__data_[0] == v38->__r_.__value_.__s.__data_[0])
    {
      unint64_t v37 = (std::string *)((char *)v37 + 1);
      uint64_t v38 = (std::string *)((char *)v38 + 1);
      if (!--v39) {
        goto LABEL_99;
      }
    }
    goto LABEL_132;
  }
LABEL_99:
  uint64_t v42 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
  if ((v112.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v43 = HIBYTE(v112.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v43 = v112.__r_.__value_.__l.__size_;
  }
  std::string::size_type v44 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v44 = __str.__r_.__value_.__l.__size_;
  }
  if (v43 != v44) {
    goto LABEL_132;
  }
  unint64_t v45 = (__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? &__str
      : (std::string *)__str.__r_.__value_.__r.__words[0];
  if ((*((unsigned char *)&v112.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    if (memcmp(v112.__r_.__value_.__l.__data_, v45, v112.__r_.__value_.__l.__size_)) {
      goto LABEL_132;
    }
  }
  else if (*((unsigned char *)&v112.__r_.__value_.__s + 23))
  {
    size_t v46 = &v112;
    stat v47 = v45;
    while (v46->__r_.__value_.__s.__data_[0] == v47->__r_.__value_.__s.__data_[0])
    {
      size_t v46 = (std::string *)((char *)v46 + 1);
      stat v47 = (std::string *)((char *)v47 + 1);
      if (!--v42) {
        goto LABEL_115;
      }
    }
    goto LABEL_132;
  }
LABEL_115:
  uint64_t v48 = HIBYTE(v111.__r_.__value_.__r.__words[2]);
  if ((v111.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v49 = HIBYTE(v111.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v49 = v111.__r_.__value_.__l.__size_;
  }
  std::string::size_type v50 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
  if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v50 = v102.__r_.__value_.__l.__size_;
  }
  if (v49 != v50) {
    goto LABEL_132;
  }
  if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v51 = &v102;
  }
  else {
    uint64_t v51 = (std::string *)v102.__r_.__value_.__r.__words[0];
  }
  if ((*((unsigned char *)&v111.__r_.__value_.__s + 23) & 0x80) == 0)
  {
    if (*((unsigned char *)&v111.__r_.__value_.__s + 23))
    {
      unsigned __int16 v52 = &v111;
      int v53 = v51;
      while (v52->__r_.__value_.__s.__data_[0] == v53->__r_.__value_.__s.__data_[0])
      {
        unsigned __int16 v52 = (std::string *)((char *)v52 + 1);
        int v53 = (std::string *)((char *)v53 + 1);
        if (!--v48) {
          goto LABEL_131;
        }
      }
      goto LABEL_132;
    }
    goto LABEL_131;
  }
  if (memcmp(v111.__r_.__value_.__l.__data_, v51, v111.__r_.__value_.__l.__size_))
  {
LABEL_132:
    *(void *)(a1 + 56++**(_DWORD **)(result + 8) = sub_19E0732E8;
    *(void *)(a1 + 576) = 0;
    std::string::size_type v54 = &__p;
    if (v35 < 0) {
      std::string::size_type v54 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((v30 & 0x80) == 0)
    {
      if (!v30) {
        goto LABEL_143;
      }
      size_t v55 = &v114;
      uint64_t v56 = v31;
      while (v55->__r_.__value_.__s.__data_[0] == v54->__r_.__value_.__s.__data_[0])
      {
        size_t v55 = (std::string *)((char *)v55 + 1);
        std::string::size_type v54 = (std::string *)((char *)v54 + 1);
        if (!--v56) {
          goto LABEL_143;
        }
      }
      goto LABEL_142;
    }
    int v41 = v54;
LABEL_141:
    if (!memcmp(v114.__r_.__value_.__l.__data_, v41, v32)) {
      goto LABEL_143;
    }
    goto LABEL_142;
  }
LABEL_131:
  if (!sub_19E072B54((unsigned __int8 *)&v113, (unsigned __int8 *)v100)) {
    goto LABEL_132;
  }
  if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v99.__r_.__value_.__l.__data_);
  }
  if ((char)v101 < 0) {
    operator delete(v100[0]);
  }
  if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v102.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  char v40 = 1;
LABEL_244:
  if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v105.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v106.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v107.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v108.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v109.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v110.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v111.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v112.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v113.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v114.__r_.__value_.__l.__data_);
    if (v40) {
      goto LABEL_264;
    }
  }
  else if (v40)
  {
    goto LABEL_264;
  }
  uint64_t v87 = 0;
LABEL_267:
  if ((char)v117 < 0) {
    operator delete(v115);
  }
  return v87;
}

void sub_19E0729B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  if (v53 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a53 < 0) {
    operator delete(a48);
  }
  if (*(char *)(v54 - 169) < 0) {
    operator delete(*(void **)(v54 - 192));
  }
  if (*(char *)(v54 - 145) < 0) {
    operator delete(*(void **)(v54 - 168));
  }
  if (*(char *)(v54 - 121) < 0) {
    operator delete(*(void **)(v54 - 144));
  }
  if (*(char *)(v54 - 97) < 0) {
    operator delete(*(void **)(v54 - 120));
  }
  if (*(char *)(v54 - 73) < 0) {
    operator delete(*(void **)(v54 - 96));
  }
  if (*(char *)(v54 - 49) < 0) {
    operator delete(*(void **)(v54 - 72));
  }
  _Unwind_Resume(a1);
}

BOOL sub_19E072B54(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1;
  }
  uint64_t v6 = v2 - 1;
  do
  {
    int v8 = *a1++;
    int v7 = v8;
    int v10 = *a2++;
    int v9 = v10;
    BOOL v12 = v6-- != 0;
    BOOL v13 = v7 == v9;
    BOOL v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

uint64_t sub_19E072BF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  if (v6)
  {
    uint64_t v7 = v6;
    do
    {
      int v8 = *(unsigned __int8 *)(v7 + 124);
      if (v8 == 3)
      {
        uint64_t v9 = a3;
        int v10 = "EOS";
      }
      else
      {
        if (v8 != 2)
        {
          char v18 = *(const void **)(v7 + 48);
          size_t v19 = *(unsigned __int16 *)(v7 + 96);
          if (sub_19E070054(a3, v19))
          {
            memcpy((void *)(*(void *)(a3 + 24) + *(void *)(a3 + 8)), v18, v19);
            *(void *)(a3 + 8) += v19;
          }
          goto LABEL_8;
        }
        uint64_t v9 = a3;
        int v10 = "BOS";
      }
      sub_19E070138(v9, v10);
LABEL_8:
      if (sub_19E070054(a3, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 32;
      }
      uint64_t v11 = sub_19E070138(a3, *(char **)(v7 + 56));
      if (sub_19E070054(v11, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 32;
      }
      uint64_t v12 = sub_19E072EFC(a3, *(_DWORD *)(v7 + 48) - v5);
      if (sub_19E070054(v12, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 32;
      }
      uint64_t v13 = sub_19E072EFC(a3, *(_DWORD *)(v7 + 48) - v5 + *(unsigned __int16 *)(v7 + 96));
      if (sub_19E070054(v13, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 32;
      }
      uint64_t v14 = sub_19E072FF4(a3, *(unsigned __int16 *)(v7 + 100));
      if (sub_19E070054(v14, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 32;
      }
      uint64_t v15 = sub_19E072FF4(a3, *(unsigned __int16 *)(v7 + 102));
      if (sub_19E070054(v15, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 32;
      }
      uint64_t v16 = sub_19E072EFC(a3, *(unsigned __int8 *)(v7 + 124));
      if (sub_19E070054(v16, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 32;
      }
      sub_19E0730DC(a3, *(void *)(v7 + 112));
      for (uint64_t i = *(void *)(v7 + 40); i; uint64_t i = *(void *)(i + 8))
      {
        if (sub_19E070054(a3, 1)) {
          *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 32;
        }
        sub_19E072EFC(a3, *(_DWORD *)(i + 16));
      }
      if (sub_19E070054(a3, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 10;
      }
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7);
  }
  return 1;
}

uint64_t sub_19E072EFC(uint64_t a1, int a2)
{
  *(void *)&v12[63] = *MEMORY[0x1E4F143B8];
  p_s = &__s;
  if (a2 < 0)
  {
    p_s = v12;
    char __s = 45;
    a2 = -a2;
  }
  else if (!a2)
  {
LABEL_8:
    char *p_s = 48;
    uint64_t v3 = p_s + 1;
    goto LABEL_9;
  }
  uint64_t v3 = p_s;
  do
  {
    *v3++ = (char)a2 % 10 + 48;
    unsigned int v4 = a2 + 9;
    a2 /= 10;
  }
  while (v4 > 0x12);
  if (p_s == v3) {
    goto LABEL_8;
  }
LABEL_9:
  BOOL v5 = p_s == v3;
  char *v3 = 0;
  uint64_t v6 = v3 - 1;
  if (!v5 && v6 > p_s)
  {
    uint64_t v7 = p_s + 1;
    do
    {
      char v8 = *(v7 - 1);
      *(v7 - 1) = *v6;
      *v6-- = v8;
    }
    while (v7++ < v6);
  }
  return sub_19E070138(a1, &__s);
}

uint64_t sub_19E072FF4(uint64_t a1, int a2)
{
  *(void *)&v10[63] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    goto LABEL_5;
  }
  p_s = &__s;
  do
  {
    unsigned int v3 = (unsigned __int16)a2;
    *p_s++ = ((unsigned __int16)a2 % 0xAu) | 0x30;
    LOWORD(a2) = (unsigned __int16)a2 / 0xAu;
  }
  while (v3 > 9);
  if (p_s == &__s)
  {
LABEL_5:
    p_s = v10;
    char __s = 48;
  }
  char *p_s = 0;
  unsigned int v4 = p_s - 1;
  if (p_s != &__s && p_s - 1 > &__s)
  {
    BOOL v5 = v10;
    do
    {
      char v6 = *(v5 - 1);
      *(v5 - 1) = *v4;
      *v4-- = v6;
    }
    while (v5++ < v4);
  }
  return sub_19E070138(a1, &__s);
}

uint64_t sub_19E0730DC(uint64_t a1, uint64_t a2)
{
  *(void *)&v12[63] = *MEMORY[0x1E4F143B8];
  p_s = &__s;
  if (a2 < 0)
  {
    p_s = v12;
    char __s = 45;
    a2 = -a2;
  }
  else if (!a2)
  {
LABEL_8:
    char *p_s = 48;
    unsigned int v3 = p_s + 1;
    goto LABEL_9;
  }
  unsigned int v3 = p_s;
  do
  {
    *v3++ = (char)a2 % 10 + 48;
    unint64_t v4 = a2 + 9;
    a2 /= 10;
  }
  while (v4 > 0x12);
  if (p_s == v3) {
    goto LABEL_8;
  }
LABEL_9:
  BOOL v5 = p_s == v3;
  char *v3 = 0;
  char v6 = v3 - 1;
  if (!v5 && v6 > p_s)
  {
    uint64_t v7 = p_s + 1;
    do
    {
      char v8 = *(v7 - 1);
      *(v7 - 1) = *v6;
      *v6-- = v8;
    }
    while (v7++ < v6);
  }
  return sub_19E070138(a1, &__s);
}

uint64_t sub_19E0731D0()
{
  return 1;
}

uint64_t sub_19E0731D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2) + 8);
  BOOL v5 = (uint64_t *)(v4 + 8);
  if (*(void *)(v4 + 8))
  {
    do
    {
      char v6 = *(const void **)(v4 + 48);
      size_t v7 = *(unsigned __int16 *)(v4 + 96);
      if (sub_19E070054(a3, v7))
      {
        memcpy((void *)(*(void *)(a3 + 24) + *(void *)(a3 + 8)), v6, v7);
        *(void *)(a3 + 8) += v7;
      }
      if (sub_19E070054(a3, 1)) {
        *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 32;
      }
      uint64_t v4 = *v5;
      uint64_t v8 = *v5;
      uint64_t v9 = *(void *)(v8 + 8);
      BOOL v5 = (uint64_t *)(v8 + 8);
    }
    while (v9);
  }
  if (sub_19E070054(a3, 1)) {
    *(unsigned char *)(*(void *)(a3 + 24) + (*(void *)(a3 + 8))++) = 10;
  }
  return 1;
}

void sub_19E0732E8(uint64_t a1, uint64_t a2)
{
}

void sub_19E0733FC()
{
}

void sub_19E074104(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a20) {
    MEMORY[0x19F3BA6E0](a20, 0x10C80436913F5);
  }
  if (a23) {
    MEMORY[0x19F3BA6E0](a23, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E07427C(void *a1)
{
  *a1 = &unk_1EF09C390;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x19F3BA6E0](v1, 0x10C80436913F5);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0742F8(void *a1)
{
  *a1 = &unk_1EF09C390;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x19F3BA6E0](v2, 0x10C80436913F5);
  }
  return a1;
}

void sub_19E074354(void *a1)
{
  *a1 = &unk_1EF09C3B0;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x19F3BA6E0](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0743D0(void *a1)
{
  *a1 = &unk_1EF09C3B0;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
  }
  return a1;
}

uint64_t sub_19E07442C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || !(*(unsigned int (**)(uint64_t))(*(void *)a2 + 8))(a2)) {
    return 0;
  }
  char v6 = *(uint64_t (**)(void *, uint64_t, uint64_t))(a1 + 568);
  uint64_t v7 = *(void *)(a1 + 576);
  uint64_t v8 = (void *)(a1 + (v7 >> 1));
  if (v7) {
    char v6 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v8 + v6);
  }

  return v6(v8, a2, a3);
}

uint64_t sub_19E0744FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  switch(*(unsigned char *)(a3 + 124))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      sub_19E0733FC();
    default:
      return 1;
  }
}

uint64_t sub_19E074578(uint64_t a1, char *a2)
{
  uint64_t v4 = sub_19E06CA50();
  sub_19E0413C8(__p, a2);
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = sub_19E06D514(v4, __p);
  if ((char)v49 < 0) {
    operator delete(__p[0]);
  }
  BOOL v5 = (pthread_mutex_t *)(v4 + 64);
  pthread_mutex_lock(v5);
  uint64_t v6 = *(void *)(a1 + 8);
  if (!*(void *)(v6 + 8))
  {
    uint64_t v7 = (char *)sub_19E0413C8(__p, a2);
    if ((v49 & 0x80u) == 0) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = (char *)__p[0];
    }
    char v9 = sub_19E06D7C4(v6, v8, "r");
    char v10 = v9;
    if (((char)v49 & 0x80000000) == 0)
    {
      if (v9) {
        goto LABEL_9;
      }
LABEL_35:
      std::string::size_type v43 = (char *)sub_19E05E6A8(*(void *)(a1 + 8) + 48);
      std::string::size_type v44 = sub_19E0413C8(__p, v43);
      if ((v49 & 0x80u) == 0) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = __p[0];
      }
      if ((v49 & 0x80u) == 0) {
        uint64_t v46 = v49;
      }
      else {
        uint64_t v46 = (uint64_t)__p[1];
      }
      sub_19E0416F8((void *)(a1 + 56), (uint64_t)v45, v46);
      if ((char)v49 < 0) {
        operator delete(__p[0]);
      }
      pthread_mutex_unlock(v5);
      goto LABEL_44;
    }
    operator delete(__p[0]);
    if ((v10 & 1) == 0) {
      goto LABEL_35;
    }
  }
LABEL_9:
  pthread_mutex_unlock(v5);
  uint64_t v11 = *(void *)(a1 + 8);
  uint64_t v12 = *(int **)(v11 + 8);
  int v13 = *v12;
  if (((32 * *v12) | 4u) + 262140 != *(void *)(v11 + 16))
  {
    if (setjmp((int *)(a1 + 344)) != 1)
    {
      std::ios_base::clear((std::ios_base *)(a1 + 56 + *(void *)(*(void *)(a1 + 56) - 24)), 0);
      uint64_t v36 = sub_19E0416F8((void *)(a1 + 56), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/char_property.cpp", 76);
      sub_19E0416F8(v36, (uint64_t)"(", 1);
      unint64_t v37 = (void *)std::ostream::operator<<();
      uint64_t v38 = sub_19E0416F8(v37, (uint64_t)") [", 3);
      uint64_t v39 = sub_19E0416F8(v38, (uint64_t)"fsize == cmmap_->size()", 23);
      char v40 = sub_19E0416F8(v39, (uint64_t)"] ", 2);
      int v41 = sub_19E0416F8(v40, (uint64_t)"invalid file size: ", 19);
      size_t v42 = strlen(a2);
      sub_19E0416F8(v41, (uint64_t)a2, v42);
      longjmp((int *)(a1 + 344), 1);
    }
LABEL_44:
    uint64_t v47 = sub_19E06CA50();
    sub_19E06CB24(v47, *(void *)(a1 + 8));
    uint64_t result = 0;
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
    return result;
  }
  uint64_t v14 = v12 + 1;
  uint64_t v15 = *(void **)(a1 + 16);
  *(void *)(a1 + 24) = v15;
  if (v13)
  {
    int v16 = 0;
    std::string::size_type v17 = v14;
    do
    {
      char v18 = v15;
      unint64_t v19 = *(void *)(a1 + 32);
      if ((unint64_t)v18 >= v19)
      {
        uint64_t v21 = *(void *)(a1 + 16);
        uint64_t v22 = ((uint64_t)v18 - v21) >> 3;
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 61) {
          sub_19E041BEC();
        }
        uint64_t v24 = v19 - v21;
        if (v24 >> 2 > v23) {
          unint64_t v23 = v24 >> 2;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25)
        {
          unint64_t v26 = (char *)sub_19E060B48(v25);
          uint64_t v28 = v27;
        }
        else
        {
          uint64_t v28 = 0;
          unint64_t v26 = 0;
        }
        int v29 = &v26[8 * v22];
        *(void *)int v29 = v17;
        int v30 = v29 + 8;
        uint64_t v31 = *(void *)(a1 + 16);
        uint64_t v32 = *(void *)(a1 + 24);
        if (v32 == v31)
        {
          std::string::size_type v34 = *(void **)(a1 + 24);
        }
        else
        {
          std::string::size_type v33 = &v26[8 * v22];
          do
          {
            *((void *)v33 - 1) = *(void *)(v32 - 8);
            v33 -= 8;
            v32 -= 8;
          }
          while (v32 != v31);
          int v29 = v33;
          std::string::size_type v34 = *(void **)(a1 + 16);
        }
        uint64_t v20 = v30;
        *(void *)(a1 + 16) = v29;
        *(void *)(a1 + 24) = v30;
        *(void *)(a1 + 32) = &v26[8 * v28];
        if (v34) {
          operator delete(v34);
        }
      }
      else
      {
        *char v18 = v17;
        uint64_t v20 = v18 + 1;
      }
      uint64_t v15 = v20;
      *(void *)(a1 + 24) = v20;
      ++v16;
      v17 += 8;
      uint64_t v14 = v17;
    }
    while (v16 != v13);
  }
  *(void *)(a1 + 4sub_19E03D880(&a9, 0) = v14;
  return 1;
}

void sub_19E07490C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void LXLexiconRepositoryCreateView(const __CFString *a1)
{
  if (qword_1EB4FEF30 != -1) {
    dispatch_once(&qword_1EB4FEF30, &unk_1EF098EA8);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  Instance[2] = &unk_1EF09C810;
  unsigned int v3 = (char *)operator new(0x78uLL);
  *(_OWORD *)(v3 + ++**(_DWORD **)(result + 8) = 0u;
  *(void *)unsigned int v3 = &unk_1EF09D068;
  *((void *)v3 + 3) = &unk_1EF09C7E8;
  *((_OWORD *)v3 + 2) = 0u;
  sub_19E039E88(a1, __p);
  if (v6 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  *((void *)v3 + 6) = os_log_create("com.apple.Lexicon", (const char *)v4);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *((void *)v3 + 7) = 850045863;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((void *)v3 + 14) = 0;
  Instance[3] = v3 + 24;
  Instance[4] = v3;
  sub_19E03A61C((int)__p, "root");
}

void sub_19E074F04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  std::mutex::unlock((std::mutex *)&qword_1EB4FEC70);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(a1);
}

void sub_19E074FC8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_1EB4FEC10, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_1EB4FEC10))
  {
    xmmword_1EB4FEC40 = 0u;
    xmmword_1EB4FEC60 = 0u;
    xmmword_1EB4FEC20 = 0u;
    *(_OWORD *)&qword_1EB4FEC30 = 0u;
    LODWORD(xmmword_1EB4FEC4sub_19E03D880(&a9, 0) = 1065353216;
    *(long long *)((char *)&xmmword_1EB4FEC40 + ++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)&qword_1EB4FEC58 = 0u;
    DWORD2(xmmword_1EB4FEC6sub_19E03D880(&a9, 0) = 1065353216;
    qword_1EB4FEC70 = 850045863;
    unk_1EB4FEC78 = 0u;
    unk_1EB4FEC88 = 0u;
    unk_1EB4FEC98 = 0u;
    qword_1EB4FECA8 = 0;
    __cxa_guard_release(qword_1EB4FEC10);
  }
}

uint64_t sub_19E075064()
{
  qword_1EB4FEEB8 = 0;
  unk_1EB4FEEC0 = "LXLexicon";
  qword_1EB4FEEC8 = 0;
  unk_1EB4FEED0 = 0;
  qword_1EB4FEED8 = (uint64_t)sub_19E0750B8;
  unk_1EB4FEEE0 = 0u;
  unk_1EB4FEEF0 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB4FEF18 = result;
  return result;
}

uint64_t sub_19E0750B8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 16))();
}

void LXLexiconRepositoryAddOrUpdate(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  CFStringRef v3 = (const __CFString *)LXLexiconCopyName(a1);
  CFStringRef v20 = v3;
  sub_19E074FC8();
  sub_19E039E88(v3, __p);
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  std::mutex::lock((std::mutex *)&qword_1EB4FEC70);
  uint64_t v4 = sub_19E0A1AE0((uint64_t)__p, (uint64_t)__p);
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v5 = *(std::__shared_weak_count **)(v4 + 48);
  *(void *)(v4 + 4sub_19E03D880(&a9, 0) = v2;
  *(void *)(v4 + 4++**(_DWORD **)(result + 8) = v1;
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  char v6 = (uint64_t *)qword_1EB4FEC30;
  if (qword_1EB4FEC30)
  {
    while (1)
    {
      uint64_t v7 = v6[6];
      if (!v7 || *(void *)(v7 + 8) == -1) {
        break;
      }
      uint64_t v8 = (uint64_t *)*v6;
LABEL_40:
      char v6 = v8;
      if (!v8) {
        goto LABEL_41;
      }
    }
    unint64_t v9 = *((void *)&xmmword_1EB4FEC20 + 1);
    unint64_t v10 = v6[1];
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EB4FEC20 + 8));
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      if (v10 >= *((void *)&xmmword_1EB4FEC20 + 1)) {
        v10 %= *((void *)&xmmword_1EB4FEC20 + 1);
      }
    }
    else
    {
      v10 &= *((void *)&xmmword_1EB4FEC20 + 1) - 1;
    }
    uint64_t v8 = (uint64_t *)*v6;
    uint64_t v12 = *(uint64_t **)(xmmword_1EB4FEC20 + 8 * v10);
    do
    {
      int v13 = v12;
      uint64_t v12 = (uint64_t *)*v12;
    }
    while (v12 != v6);
    if (v13 == &qword_1EB4FEC30) {
      goto LABEL_55;
    }
    unint64_t v14 = v13[1];
    if (v11.u32[0] > 1uLL)
    {
      if (v14 >= *((void *)&xmmword_1EB4FEC20 + 1)) {
        v14 %= *((void *)&xmmword_1EB4FEC20 + 1);
      }
    }
    else
    {
      v14 &= *((void *)&xmmword_1EB4FEC20 + 1) - 1;
    }
    uint64_t v15 = *v6;
    if (v14 != v10)
    {
LABEL_55:
      if (v8)
      {
        unint64_t v16 = v8[1];
        if (v11.u32[0] > 1uLL)
        {
          if (v16 >= *((void *)&xmmword_1EB4FEC20 + 1)) {
            v16 %= *((void *)&xmmword_1EB4FEC20 + 1);
          }
        }
        else
        {
          v16 &= *((void *)&xmmword_1EB4FEC20 + 1) - 1;
        }
        uint64_t v15 = *v6;
        if (v16 == v10) {
          goto LABEL_33;
        }
      }
      *(void *)(xmmword_1EB4FEC20 + 8 * v1sub_19E03D880(&a9, 0) = 0;
      uint64_t v15 = *v6;
    }
    if (!v15)
    {
LABEL_39:
      *int v13 = v15;
      uint64_t *v6 = 0;
      --qword_1EB4FEC38;
      v22[0] = (uint64_t)v6;
      v22[1] = (uint64_t)&qword_1EB4FEC30;
      char v23 = 1;
      sub_19E0A2680(v22);
      goto LABEL_40;
    }
LABEL_33:
    unint64_t v17 = *(void *)(v15 + 8);
    if (v11.u32[0] > 1uLL)
    {
      if (v17 >= v9) {
        v17 %= v9;
      }
    }
    else
    {
      v17 &= v9 - 1;
    }
    if (v17 != v10)
    {
      *(void *)(xmmword_1EB4FEC20 + 8 * v17) = v13;
      uint64_t v15 = *v6;
    }
    goto LABEL_39;
  }
LABEL_41:
  v21[0] = v2;
  v21[1] = (uint64_t)v1;
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_19E0A1F74((uint64_t)__p, v21);
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
    std::mutex::unlock((std::mutex *)&qword_1EB4FEC70);
    std::__shared_weak_count::__release_weak(v1);
  }
  else
  {
    std::mutex::unlock((std::mutex *)&qword_1EB4FEC70);
  }
  if (v19 < 0)
  {
    operator delete(__p[0]);
    if (!v3) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  if (v3) {
LABEL_50:
  }
    CFRelease(v3);
LABEL_51:
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_19E075394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16)
{
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  std::mutex::unlock((std::mutex *)&qword_1EB4FEC70);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_19E03D880(&a16, 0);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(a1);
}

uint64_t LXCompileUnigramsFile(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  return LXCompileUnigramsFileWithError(a1, a2, a3, 0);
}

uint64_t LXCompileUnigramsFileWithError(const __CFString *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  if (a1 && CFStringGetLength(a1))
  {
    atomic_store((a3 & 0x100000) != 0, byte_1E94578A0);
    atomic_store((a3 & 0x80000) == 0, byte_1E9457268);
    LODWORD(v28[0]) = 0x100000;
    WORD2(v28[0]) = 0;
    BYTE6(v28[0]) = 1;
    v28[1] = 0;
    sub_19E03F6F8(v28, (uint64_t)"Unigrams", 0, 8u);
    int v29 = 0x100000;
    __int16 v30 = 0;
    char v31 = 0;
    uint64_t v32 = 0;
    char v33 = 0;
    int v34 = 0x100000;
    __int16 v35 = 0;
    char v36 = 0;
    unint64_t v37 = 0;
    v38[0] = 0;
    int v39 = 0x100000;
    __int16 v40 = 0;
    char v41 = 0;
    size_t v42 = 0;
    char v43 = 0;
    char v6 = getenv("BUILT_PRODUCTS_DIR");
    sub_19E0B1358((uint64_t)valuePtr, v6);
    uint64_t v7 = getenv("WRAPPER_NAME");
    sub_19E0B1358((uint64_t)v68, v7);
    if (*(_WORD *)valuePtr) {
      BOOL v8 = v68[0] == 0;
    }
    else {
      BOOL v8 = 1;
    }
    int v9 = !v8;
    if (v8)
    {
      LODWORD(__dst) = 0x100000;
      WORD2(__dst) = 0;
      BYTE6(__dst) = 1;
      uint64_t v67 = 0;
      sub_19E03F6F8(&__dst, (uint64_t)"Output", 0, 6u);
    }
    else
    {
      sub_19E0B237C((uint64_t)v63, (unsigned __int16 *)valuePtr, "/");
      sub_19E0B23D4((uint64_t)&__dst, v63, (uint64_t)v68);
    }
    sub_19E03CED8((uint64_t)&v29, (unsigned __int16 *)&__dst);
    if (v67 && BYTE6(__dst) == 1) {
      free(v67);
    }
    if (v9 && v65 && v64 == 1) {
      free(v65);
    }
    uint64_t v12 = getenv("SRCROOT");
    sub_19E0B1358((uint64_t)&__dst, v12);
    int v13 = getenv("TEXTINPUT_LANGUAGE");
    sub_19E0B1358((uint64_t)&v61, v13);
    unint64_t v14 = getenv("PRECOMPILED_DATA");
    sub_19E0B1358((uint64_t)&v59, v14);
    sub_19E0B237C((uint64_t)v47, (unsigned __int16 *)&__dst, "/");
    sub_19E0B23D4((uint64_t)v50, v47, (uint64_t)&v59);
    sub_19E0B237C((uint64_t)&v53, v50, "/");
    sub_19E0B23D4((uint64_t)buf, (unsigned __int16 *)&v53, (uint64_t)&v61);
    sub_19E03CED8((uint64_t)&v34, (unsigned __int16 *)buf);
    if (*(void *)&v56[4] && v56[2] == 1) {
      free(*(void **)&v56[4]);
    }
    if (v54 && BYTE6(v53) == 1) {
      free(v54);
    }
    if (v52 && v51 == 1) {
      free(v52);
    }
    if (v49 && v48 == 1) {
      free(v49);
    }
    if (v37) {
      uint64_t v15 = (const char *)v37;
    }
    else {
      uint64_t v15 = v38;
    }
    int v16 = mkpath_np(v15, 0x1EDu);
    int v17 = v16;
    if (v16)
    {
      if (v16 != 17)
      {
        unsigned __int8 v18 = atomic_load(byte_1E9457268);
        if (v18)
        {
          unsigned __int8 v19 = atomic_load(byte_1E94578A0);
          if (v19)
          {
            uint64_t v24 = (const char *)v37;
            unint64_t v25 = strerror(v16);
            if (v24) {
              unint64_t v26 = v24;
            }
            else {
              unint64_t v26 = v38;
            }
            printf("couldn't create directory '%s': %s (%d)", v26, v25, v17);
            putchar(10);
          }
          else
          {
            CFStringRef v20 = sub_19E08D084();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              uint64_t v21 = v37;
              uint64_t v22 = strerror(v17);
              if (v21) {
                char v23 = v21;
              }
              else {
                char v23 = v38;
              }
              *(_DWORD *)buf = 136315650;
              *(void *)uint64_t v56 = v23;
              *(_WORD *)&v56[8] = 2080;
              *(void *)&v56[10] = v22;
              __int16 v57 = 1024;
              int v58 = v17;
              _os_log_impl(&dword_19E038000, v20, OS_LOG_TYPE_ERROR, "couldn't create directory '%s': %s (%d)", buf, 0x1Cu);
            }
          }
        }
      }
    }
    uint64_t v27 = getenv("DERIVED_SOURCES_DIR");
    sub_19E0B1358((uint64_t)buf, v27);
    if (*(_WORD *)buf)
    {
      sub_19E039858((uint64_t)&v53, (unsigned __int16 *)buf);
    }
    else
    {
      LODWORD(v53) = 0x100000;
      WORD2(v53) = 0;
      BYTE6(v53) = 1;
      uint64_t v54 = 0;
      sub_19E03F6F8(&v53, (uint64_t)"Deps", 0, 4u);
    }
    sub_19E03CED8((uint64_t)&v39, (unsigned __int16 *)&v53);
    if (v54 && BYTE6(v53) == 1) {
      free(v54);
    }
    if (*(void *)&v56[4] && v56[2] == 1) {
      free(*(void **)&v56[4]);
    }
    if (v60 && BYTE6(v59) == 1) {
      free(v60);
    }
    if (v62 && BYTE6(v61) == 1) {
      free(v62);
    }
    if (v67 && BYTE6(__dst) == 1) {
      free(v67);
    }
    if (v70 && v69 == 1) {
      free(v70);
    }
    if (v72)
    {
      if (valuePtr[6] == 1) {
        free(v72);
      }
    }
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    uint64_t v44 = a3 | 0x10;
    operator new();
  }
  if (!a4) {
    return 0;
  }
  CFErrorRef v10 = sub_19E0A4344(@"missing source path");
  uint64_t result = 0;
  *a4 = v10;
  return result;
}

void sub_19E07686C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  sub_19E03D880((const void **)(v18 - 176), 0);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_19E0768A4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_19E04137C(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E0768C0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 2008);
  if (v2)
  {
    *(void *)(a1 + 2016) = v2;
    operator delete(v2);
  }
  CFStringRef v3 = *(void **)(a1 + 1984);
  if (v3)
  {
    *(void *)(a1 + 1992) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 1936);
  if (v4 && *(unsigned char *)(a1 + 1934) == 1) {
    free(v4);
  }
  BOOL v5 = *(void **)(a1 + 1904);
  if (v5 && *(unsigned char *)(a1 + 1902) == 1) {
    free(v5);
  }
  char v6 = *(void **)(a1 + 1856);
  if (v6)
  {
    *(void *)(a1 + 1864) = v6;
    operator delete(v6);
  }
  sub_19E076AD0(a1 + 1816);
  sub_19E076B34(a1 + 1776);
  *(void *)(a1 + 32++**(_DWORD **)(result + 8) = &unk_1EF09C9E8;
  sub_19E03A444(a1 + 1720);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 1712);
  if (v7) {
    sub_19E0616BC(v7);
  }
  *(void *)(a1 + 32++**(_DWORD **)(result + 8) = &unk_1EF09C8E8;
  BOOL v8 = *(void **)(a1 + 1680);
  if (v8 && *(unsigned char *)(a1 + 1678) == 1) {
    free(v8);
  }
  sub_19E03A444(a1 + 1624);
  sub_19E076B80(a1 + 288);
  uint64_t v9 = *(void *)(a1 + 280);
  if (v9) {
    sub_19E076BBC((atomic_uint *)(v9 + 24));
  }
  uint64_t v10 = *(void *)(a1 + 272);
  if (v10) {
    sub_19E076C68(v10);
  }
  uint64_t v11 = *(void *)(a1 + 264);
  *(void *)(a1 + 264) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 256);
  if (v12) {
    sub_19E0616BC(v12);
  }
  int v13 = *(void **)(a1 + 216);
  if (v13 && *(unsigned char *)(a1 + 214) == 1) {
    free(v13);
  }
  unint64_t v14 = *(void **)(a1 + 184);
  if (v14 && *(unsigned char *)(a1 + 182) == 1) {
    free(v14);
  }
  uint64_t v15 = *(void **)(a1 + 152);
  if (v15 && *(unsigned char *)(a1 + 150) == 1) {
    free(v15);
  }
  int v16 = *(void **)(a1 + 120);
  if (v16 && *(unsigned char *)(a1 + 118) == 1) {
    free(v16);
  }
  int v17 = *(void **)(a1 + 88);
  if (v17 && *(unsigned char *)(a1 + 86) == 1) {
    free(v17);
  }
  uint64_t v18 = *(void **)(a1 + 56);
  if (v18 && *(unsigned char *)(a1 + 54) == 1) {
    free(v18);
  }
  unsigned __int8 v19 = *(void **)(a1 + 24);
  if (v19 && *(unsigned char *)(a1 + 22) == 1) {
    free(v19);
  }
  return a1;
}

uint64_t sub_19E076AD0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      CFStringRef v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[3];
      if (v4) {
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  BOOL v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

uint64_t sub_19E076B34(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      CFStringRef v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_19E076B80(uint64_t a1)
{
  sub_19E076FC8(*(atomic_uint **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

atomic_uint *sub_19E076BBC(atomic_uint *result)
{
  if (atomic_fetch_add(result, 0xFFFFFFFF) == 1)
  {
    uint64_t v1 = result;
    uint64_t v2 = (void **)(result - 6);
    uint64_t v3 = *((void *)result - 3);
    if (v3)
    {
      uint64_t v4 = *((void *)result - 2);
      BOOL v5 = (void *)*((void *)result - 3);
      if (v4 != v3)
      {
        do
        {
          uint64_t v7 = *(void *)(v4 - 8);
          v4 -= 8;
          uint64_t v6 = v7;
          if (v7) {
            sub_19E076DB4(v6 + 84);
          }
        }
        while (v4 != v3);
        BOOL v5 = *v2;
      }
      *((void *)v1 - 2) = v3;
      operator delete(v5);
    }
    JUMPOUT(0x19F3BA710);
  }
  return result;
}

uint64_t sub_19E076C68(uint64_t result)
{
  unsigned int add = atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF);
  if (result && add == 1)
  {
    uint64_t v2 = result;
    BOOL v5 = (void **)(result + 72);
    sub_19E076D30(&v5);
    if (*(unsigned __int16 *)(v2 + 48) >= 0xFu)
    {
      uint64_t v3 = *(void *)(v2 + 56);
      if (v3) {
        MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
      }
    }
    uint64_t v4 = *(void *)(v2 + 32);
    if (v4) {
      sub_19E076BBC(v4 + 24);
    }
    BOOL v5 = (void **)(v2 + 8);
    sub_19E076D30(&v5);
    JUMPOUT(0x19F3BA710);
  }
  return result;
}

void sub_19E076D30(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    BOOL v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = *((void *)v4 - 1);
        v4 -= 8;
        if (v6) {
          sub_19E076C68();
        }
      }
      while (v4 != v2);
      BOOL v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_19E076DB4(uint64_t result)
{
  if (atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF) == 1)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(std::__shared_weak_count **)(result + 236);
    if (v2) {
      sub_19E0616BC(v2);
    }
    uint64_t v12 = (void **)(v1 + 196);
    sub_19E076F34(&v12);
    uint64_t v12 = (void **)(v1 + 172);
    sub_19E076F34(&v12);
    uint64_t v3 = *(void *)(v1 + 156);
    if (v3) {
      sub_19E076BBC(v3 + 24);
    }
    uint64_t v4 = *(void *)(v1 + 148);
    if (v4) {
      sub_19E076BBC(v4 + 24);
    }
    uint64_t v5 = *(void *)(v1 + 140);
    if (v5) {
      sub_19E076C68(v5);
    }
    uint64_t v6 = *(void **)(v1 + 116);
    if (v6)
    {
      *(void *)(v1 + 124) = v6;
      operator delete(v6);
    }
    if (*(unsigned __int16 *)(v1 + 92) >= 0xFu)
    {
      uint64_t v7 = *(void *)(v1 + 100);
      if (v7) {
        MEMORY[0x19F3BA6E0](v7, 0x1000C8077774924);
      }
    }
    if (*(unsigned __int16 *)(v1 + 68) >= 0xFu)
    {
      uint64_t v8 = *(void *)(v1 + 76);
      if (v8) {
        MEMORY[0x19F3BA6E0](v8, 0x1000C8077774924);
      }
    }
    if (*(unsigned __int16 *)(v1 + 52) >= 0xFu)
    {
      uint64_t v9 = *(void *)(v1 + 60);
      if (v9) {
        MEMORY[0x19F3BA6E0](v9, 0x1000C8077774924);
      }
    }
    uint64_t v10 = *(void **)(v1 + 28);
    if (v10 && *(unsigned char *)(v1 + 26) == 1) {
      free(v10);
    }
    uint64_t v11 = *(void **)(v1 - 76);
    if (v11 && *(unsigned char *)(v1 - 78) == 1) {
      free(v11);
    }
    JUMPOUT(0x19F3BA710);
  }
  return result;
}

void sub_19E076F34(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 3);
        if (v6 && *(v4 - 26) == 1) {
          free(v6);
        }
        v4 -= 32;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_19E076FC8(atomic_uint *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      uint64_t v2 = *(atomic_uint **)v1;
      sub_19E07700C(v1 + 4);
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

atomic_uint *sub_19E07700C(atomic_uint *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *((void *)result + 2);
  if (v2) {
    uint64_t result = sub_19E076BBC((atomic_uint *)(v2 + 24));
  }
  if (*(unsigned __int16 *)v1 >= 0xFu)
  {
    uint64_t result = (atomic_uint *)*((void *)v1 + 1);
    if (result)
    {
      JUMPOUT(0x19F3BA6E0);
    }
  }
  return result;
}

void sub_19E07707C(uint64_t a1)
{
  sub_19E03A3C0(a1);
  *(_OWORD *)(a1 + 1432) = 0u;

  sub_19E0770C0(a1 + 1392);
}

void sub_19E0770C0(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_19E03A480(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void sub_19E077118(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C9E8;
  sub_19E03A444(a1 + 1392);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 1384);
  if (v2) {
    sub_19E0616BC(v2);
  }
  *(void *)a1 = &unk_1EF09C8E8;
  uint64_t v3 = *(void **)(a1 + 1352);
  if (v3 && *(unsigned char *)(a1 + 1350) == 1) {
    free(v3);
  }
  sub_19E03A444(a1 + 1296);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E0771C8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C9E8;
  sub_19E03A444(a1 + 1392);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 1384);
  if (v2) {
    sub_19E0616BC(v2);
  }
  *(void *)a1 = &unk_1EF09C8E8;
  uint64_t v3 = *(void **)(a1 + 1352);
  if (v3 && *(unsigned char *)(a1 + 1350) == 1) {
    free(v3);
  }
  sub_19E03A444(a1 + 1296);
  return a1;
}

void LXCompileStemSuffixTokenIDConversionMap(const __CFURL *a1)
{
}

void sub_19E07764C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const void *a18, const void *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,long long buf)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((v28 & 1) == 0)
    {
LABEL_6:
      sub_19E0A3A68(&a18);
      sub_19E07C5F0(v26);
      sub_19E041524(&a19, 0);
      if (a2 == 1)
      {
        char v31 = __cxa_begin_catch(a1);
        if (qword_1E9457450 != -1) {
          dispatch_once(&qword_1E9457450, &unk_1EF09D238);
        }
        uint64_t v32 = qword_1E9457448;
        if (os_log_type_enabled((os_log_t)qword_1E9457448, OS_LOG_TYPE_ERROR))
        {
          uint64_t v33 = (*(uint64_t (**)(void *))(*(void *)v31 + 16))(v31);
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v33;
          _os_log_error_impl(&dword_19E038000, v32, OS_LOG_TYPE_ERROR, "Failed to compile the stem-suffix tokenID conversion map: %s", (uint8_t *)&buf, 0xCu);
        }
        __cxa_end_catch();
        JUMPOUT(0x19E077504);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v28)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v27);
  goto LABEL_6;
}

void sub_19E0778CC()
{
}

os_log_t sub_19E0778D4()
{
  os_log_t result = os_log_create("com.apple.Lexicon", "StemSuffixTokenIDConverter");
  qword_1E9457448 = (uint64_t)result;
  return result;
}

CFStringRef LXUnigramsCompilerCopyVersion()
{
  void v16[2] = *MEMORY[0x1E4F143B8];
  sub_19E0538DC((uint64_t)v10);
  uint64_t v0 = (void *)std::ostream::operator<<();
  sub_19E0416F8(v0, (uint64_t)".", 1);
  std::ostream::operator<<();
  sub_19E05EEA4(__p, (uint64_t)v11);
  if (v9 >= 0) {
    uint64_t v1 = (char *)__p;
  }
  else {
    uint64_t v1 = (char *)__p[0];
  }
  sub_19E0B1358((uint64_t)v14, v1);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  v10[0] = *MEMORY[0x1E4FBA408];
  uint64_t v2 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v10 + *(void *)(v10[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  _DWORD v10[2] = v2;
  v11[0] = MEMORY[0x1E4FBA470] + 16;
  if (v12 < 0) {
    operator delete((void *)v11[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x19F3BA690](&v13);
  if (v15) {
    uint64_t v3 = v15;
  }
  else {
    uint64_t v3 = (char *)v16;
  }
  sub_19E0413C8(v6, v3);
  CFStringRef v4 = sub_19E040B4C((uint64_t)v6);
  if (v7 < 0) {
    operator delete(v6[0]);
  }
  if (v15 && v14[6] == 1) {
    free(v15);
  }
  return v4;
}

void sub_19E077B34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  char v23 = *(void **)(v21 - 80);
  if (v23)
  {
    if (*(unsigned char *)(v21 - 82) == 1) {
      free(v23);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t LXUnigramsCompilerGetSupportedTries()
{
  if (qword_1E9457440 != -1) {
    dispatch_once(&qword_1E9457440, &unk_1EF098EC8);
  }
  return qword_1E9457438;
}

void sub_19E077BE8()
{
  qword_1E9457438 = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v15 = 0;
  int v16 = 0;
  unint64_t v17 = 0;
  uint64_t v0 = operator new(0x20uLL);
  uint64_t v1 = 0;
  _OWORD *v0 = xmmword_19E125D00;
  v0[1] = unk_19E125D10;
  do
  {
    int v20 = *(_DWORD *)((char *)v0 + v1);
    sub_19E059E8C(&v20, __p);
    uint64_t v2 = v16;
    if ((unint64_t)v16 >= v17)
    {
      unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v16[-v15] >> 3);
      unint64_t v5 = v4 + 1;
      if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_19E041BEC();
      }
      if (0x5555555555555556 * ((uint64_t)(v17 - v15) >> 3) > v5) {
        unint64_t v5 = 0x5555555555555556 * ((uint64_t)(v17 - v15) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v17 - v15) >> 3) >= 0x555555555555555) {
        unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v6 = v5;
      }
      void v21[4] = (void **)&v17;
      if (v6) {
        char v7 = (void **)sub_19E041C04((uint64_t)&v17, v6);
      }
      else {
        char v7 = 0;
      }
      uint64_t v8 = &v7[3 * v4];
      v21[0] = v7;
      v21[1] = v8;
      void v21[3] = &v7[3 * v6];
      long long v9 = *(_OWORD *)__p;
      void v8[2] = v19;
      *(_OWORD *)uint64_t v8 = v9;
      __p[1] = 0;
      unsigned __int8 v19 = 0;
      __p[0] = 0;
      uint64_t v21[2] = v8 + 3;
      sub_19E041B74(&v15, v21);
      uint64_t v10 = v16;
      sub_19E041D6C((uint64_t)v21);
      int v16 = v10;
      if (SHIBYTE(v19) < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      long long v3 = *(_OWORD *)__p;
      *((void *)v16 + 2) = v19;
      _OWORD *v2 = v3;
      int v16 = (char *)v2 + 24;
    }
    v1 += 4;
  }
  while (v1 != 32);
  operator delete(v0);
  uint64_t v11 = v15;
  char v12 = v16;
  while ((char *)v11 != v12)
  {
    uint64_t v13 = (__CFArray *)qword_1E9457438;
    CFStringRef v14 = sub_19E040B4C(v11);
    CFArrayAppendValue(v13, v14);
    v11 += 24;
  }
  v21[0] = (void **)&v15;
  sub_19E041AD0(v21);
}

void sub_19E077DE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19)
{
  std::string __p = &a9;
  sub_19E041AD0((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t LXCreateWordModerationLexicon(CFDictionaryRef theDict, CFErrorRef *a2)
{
  void v15[4] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  if (theDict)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"dataFile");
    if (Value)
    {
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Value);
      CFStringRef v14 = Copy;
      v15[0] = 0;
      CFTypeRef cf = 0;
LABEL_7:
      CFStringRef v8 = sub_19E039FA8(theDict);
      v15[0] = v8;
      if (v8)
      {
        Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        uint64_t v10 = (const void *)MEMORY[0x19F3B9E50](v8);
        CFDictionaryAddValue(Mutable, @"locale", v10);
        CFTypeRef cf = (CFTypeRef)LXLexiconCreate(Mutable, a2);
        if (Mutable) {
          CFRelease(Mutable);
        }
      }
      goto LABEL_10;
    }
  }
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFLocaleRef v7 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"root");
  v15[0] = &unk_1EF098970;
  uint64_t v15[3] = v15;
  CFStringRef Copy = (const __CFString *)sub_19E0F4688(0, v7);
  sub_19E0F4820(v15);
  if (v7) {
    CFRelease(v7);
  }
  CFStringRef v14 = Copy;
  v15[0] = 0;
  CFTypeRef cf = 0;
  if (theDict) {
    goto LABEL_7;
  }
LABEL_10:
  if (!Copy || !CFStringGetLength(Copy))
  {
    if (a2)
    {
      uint64_t Instance = 0;
      *a2 = sub_19E0A4344(@"Could not determine the location of the word moderation lexicon file, or one was not provided.");
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (qword_1EB4FEF30 != -1) {
    dispatch_once(&qword_1EB4FEF30, &unk_1EF098EE8);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  sub_19E0A5878((char *)(Instance + 16), (uint64_t)v15[0], v14, 0, 0);
  *(void *)(Instance + 16) = &unk_1EF0986E0;
  *(void *)(Instance + 3028sub_19E03D880(&a9, 0) = &unk_1EF0986C0;
  *(void *)(Instance + 3028++**(_DWORD **)(result + 8) = uspoof_open();
  *(void *)(Instance + 30296) = 0;
  if (cf)
  {
    CFRetain(cf);
    sub_19E078268((const void **)(Instance + 30296), cf);
  }
  if (((*(uint64_t (**)(uint64_t, CFErrorRef *))(*(void *)(Instance + 16) + 16))(Instance + 16, a2) & 1) == 0)
  {
    CFRelease((CFTypeRef)Instance);
LABEL_20:
    uint64_t Instance = 0;
  }
LABEL_21:
  if (cf) {
    CFRelease(cf);
  }
  if (v15[0]) {
    CFRelease(v15[0]);
  }
  if (v14) {
    CFRelease(v14);
  }
  return Instance;
}

void sub_19E078148(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    sub_19E04137C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E078268(const void **a1, const void *a2)
{
  unint64_t v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

void sub_19E0782A0(const void **a1, const void *a2)
{
  unint64_t v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

uint64_t sub_19E0782D8()
{
  qword_1EB4FEEB8 = 0;
  unk_1EB4FEEC0 = "LXLexicon";
  qword_1EB4FEEC8 = 0;
  unk_1EB4FEED0 = 0;
  qword_1EB4FEED8 = (uint64_t)sub_19E0750B8;
  unk_1EB4FEEE0 = 0u;
  unk_1EB4FEEF0 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB4FEF18 = result;
  return result;
}

void sub_19E07832C(uint64_t a1)
{
  sub_19E078364(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E078364(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09BD20;
  uint64_t v2 = a1 + 48;
  if (*(char *)(a1 + 335) < 0) {
    operator delete(*(void **)(a1 + 312));
  }
  uint64_t v3 = MEMORY[0x1E4FBA418];
  uint64_t v4 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + 4++**(_DWORD **)(result + 8) = *MEMORY[0x1E4FBA418];
  *(void *)(v2 + *(void *)(v4 - 24)) = *(void *)(v3 + 24);
  *(void *)(a1 + 56) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x19F3BA690](a1 + 160);
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 336))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
  }
  return a1;
}

void **sub_19E078504(uint64_t a1)
{
  return sub_19E05E6A8(a1 + 48);
}

uint64_t sub_19E07850C(uint64_t a1)
{
  return *(void *)(*(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 80) + 240);
}

uint64_t sub_19E078520(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 32;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 32) = *(_DWORD *)(result + 32) & 0xFFFFFFDF | v2;
  return result;
}

uint64_t sub_19E078540(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 32) >> 5) & 1;
}

uint64_t sub_19E07854C(uint64_t result, unsigned int a2)
{
  if (a2 <= 2) {
    *(_DWORD *)(result + 32) |= dword_19E124DBC[a2];
  }
  return result;
}

uint64_t sub_19E078570(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 32);
  if ((v1 & 8) != 0) {
    return 2;
  }
  else {
    return (v1 >> 1) & 1;
  }
}

double sub_19E078588(uint64_t a1, float a2)
{
  double result = a2;
  *(double *)(a1 + 4sub_19E03D880(&a9, 0) = result;
  return result;
}

float sub_19E078594(uint64_t a1)
{
  return *(double *)(a1 + 40);
}

uint64_t sub_19E0785A0(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 4;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 32) = *(_DWORD *)(result + 32) & 0xFFFFFFFB | v2;
  return result;
}

uint64_t sub_19E0785C0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 32) >> 2) & 1;
}

uint64_t sub_19E0785CC(uint64_t a1)
{
  unsigned int v1 = *(uint64_t (**)(void))(*(void *)sub_19E078614(a1) + 136);

  return v1();
}

uint64_t sub_19E078614(uint64_t a1)
{
  if (!*(void *)(a1 + 24)) {
    operator new();
  }
  return *(void *)(a1 + 24);
}

void sub_19E0786A0(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA710](v1, 0x10F3C40B77F16BFLL);
  _Unwind_Resume(a1);
}

BOOL sub_19E0786C4(uint64_t a1)
{
  uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 304))(a1);
  if (!v1) {
    return 0;
  }
  while (1)
  {
    BOOL v2 = *(_DWORD *)(v1 + 20) == 9;
    if (*(_DWORD *)(v1 + 20) == 9) {
      break;
    }
    uint64_t v1 = *(void *)(v1 + 40);
    if (!v1) {
      return 0;
    }
  }
  return v2;
}

BOOL sub_19E078728(uint64_t a1)
{
  return *(void *)(*(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 80) + 1296) != 0;
}

uint64_t sub_19E078744(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(*(void *)(result + 8) + 8) + 80) + 1296) = a2;
  return result;
}

uint64_t sub_19E078758(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(*(void *)(result + 8) + 8) + 80) + 128++**(_DWORD **)(result + 8) = a2;
  return result;
}

uint64_t sub_19E07876C(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(*(void *)(result + 8) + 8) + 80) + 12sub_19E03D880(&a9, 0) = a2;
  return result;
}

uint64_t sub_19E078780(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(*(void *)(result + 8) + 8) + 80) + 112) = a2;
  return result;
}

uint64_t sub_19E078794(uint64_t a1, uint64_t a2)
{
  BOOL v2 = *(void **)(*(void *)(*(void *)(a1 + 8) + 8) + 80);
  uint64_t v4 = (void *)v2[1];
  uint64_t v3 = (void *)v2[2];
  if (v4 == v3) {
    return 0;
  }
  uint64_t v6 = v2 + 169;
  while (1)
  {
    uint64_t v8 = *v4;
    CFLocaleRef v7 = (std::__shared_weak_count *)v4[1];
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_19E0616BC(v7);
    }
    if (v8 == a2) {
      break;
    }
    v4 += 2;
    if (v4 == v3)
    {
      uint64_t v4 = v3;
      break;
    }
  }
  long long v9 = (void *)v2[2];
  if (v4 == v9) {
    return 0;
  }
  int v10 = *(unsigned __int8 *)(*v4 + 656);
  if (v10 != 255)
  {
    uint64_t v11 = (char *)v2[171];
    char v12 = (char *)v2[170];
    uint64_t v13 = v11 - v12;
    if (v11 == v12) {
      uint64_t v14 = 0;
    }
    else {
      uint64_t v14 = ((v11 - v12) << 9) - 1;
    }
    unint64_t v15 = v2[173];
    unint64_t v16 = v2[174] + v15;
    if (v14 == v16)
    {
      if (v15 < 0x1000)
      {
        unint64_t v119 = (void **)(v2 + 169);
        uint64_t v31 = v13 >> 3;
        uint64_t v32 = (char *)v2[172];
        uint64_t v33 = (char *)v2[169];
        uint64_t v34 = v32 - v33;
        if (v13 >> 3 >= (unint64_t)((v32 - v33) >> 3))
        {
          if (v32 == v33) {
            unint64_t v37 = 1;
          }
          else {
            unint64_t v37 = v34 >> 2;
          }
          uint64_t v38 = (char *)sub_19E060B48(v37);
          uint64_t v40 = v39;
          char v41 = &v38[8 * v31];
          *(void *)&long long v42 = v38;
          *((void *)&v42 + 1) = v41;
          long long v123 = v42;
          char v43 = operator new(0x1000uLL);
          *(void *)&long long v44 = v41;
          *((void *)&v44 + 1) = &v38[8 * v40];
          if (v31 == v40)
          {
            uint64_t v45 = 8 * v31;
            *(void *)&long long v46 = v123;
            if (v13 < 1)
            {
              std::string::size_type v81 = v43;
              uint64_t v82 = v45 >> 2;
              if (v11 == v12) {
                unint64_t v83 = 1;
              }
              else {
                unint64_t v83 = v82;
              }
              uint64_t v84 = (char *)sub_19E060B48(v83);
              char v41 = &v84[8 * (v83 >> 2)];
              *(void *)&long long v46 = v84;
              *((void *)&v46 + 1) = v41;
              *(void *)&long long v44 = v41;
              *((void *)&v44 + 1) = &v84[8 * v85];
              if (v38)
              {
                long long v120 = v44;
                long long v124 = v46;
                operator delete(v38);
                long long v44 = v120;
                long long v46 = v124;
              }
              char v43 = v81;
            }
            else
            {
              uint64_t v47 = v45 >> 3;
              if (v47 >= -1) {
                unint64_t v48 = v47 + 1;
              }
              else {
                unint64_t v48 = v47 + 2;
              }
              v41 -= 8 * (v48 >> 1);
              *(void *)&long long v44 = v41;
              *((void *)&v46 + 1) = v41;
            }
          }
          else
          {
            long long v46 = v123;
          }
          *(void *)char v41 = v43;
          *(void *)&long long v44 = v44 + 8;
          for (uint64_t i = v2[171]; i != v2[170]; i -= 8)
          {
            uint64_t v87 = (void *)*((void *)&v46 + 1);
            if (*((void *)&v46 + 1) == (void)v46)
            {
              uint64_t v89 = (unsigned char *)v44;
              if ((unint64_t)v44 >= *((void *)&v44 + 1))
              {
                if (*((void *)&v44 + 1) == *((void *)&v46 + 1)) {
                  unint64_t v94 = 1;
                }
                else {
                  unint64_t v94 = (uint64_t)(*((void *)&v44 + 1) - *((void *)&v46 + 1)) >> 2;
                }
                uint64_t v95 = (char *)sub_19E060B48(v94);
                size_t v88 = &v95[(2 * v94 + 6) & 0xFFFFFFFFFFFFFFF8];
                uint64_t v97 = v88;
                uint64_t v98 = v89 - (unsigned char *)v87;
                if (v89 != (unsigned char *)v87)
                {
                  uint64_t v97 = &v88[v98 & 0xFFFFFFFFFFFFFFF8];
                  uint64_t v99 = 8 * (v98 >> 3);
                  uint64_t v100 = v88;
                  unsigned __int8 v101 = v87;
                  do
                  {
                    uint64_t v102 = *v101++;
                    *(void *)uint64_t v100 = v102;
                    v100 += 8;
                    v99 -= 8;
                  }
                  while (v99);
                }
                *(void *)&long long v46 = v95;
                *((void *)&v46 + 1) = v88;
                *(void *)&long long v44 = v97;
                *((void *)&v44 + 1) = &v95[8 * v96];
                if (v87)
                {
                  long long v121 = v44;
                  long long v126 = v46;
                  operator delete(v87);
                  long long v44 = v121;
                  long long v46 = v126;
                }
              }
              else
              {
                uint64_t v90 = (uint64_t)(*((void *)&v44 + 1) - v44) >> 3;
                if (v90 >= -1) {
                  uint64_t v91 = v90 + 1;
                }
                else {
                  uint64_t v91 = v90 + 2;
                }
                uint64_t v92 = v91 >> 1;
                uint64_t v93 = v44 + 8 * (v91 >> 1);
                size_t v88 = (char *)(v93 - (v44 - *((void *)&v46 + 1)));
                if ((void)v44 == *((void *)&v46 + 1))
                {
                  uint64_t v89 = (unsigned char *)*((void *)&v46 + 1);
                }
                else
                {
                  uint64_t v122 = *((void *)&v44 + 1);
                  uint64_t v125 = v46;
                  memmove((void *)(v93 - (v44 - *((void *)&v46 + 1))), *((const void **)&v46 + 1), v44 - *((void *)&v46 + 1));
                  *((void *)&v44 + 1) = v122;
                  *(void *)&long long v46 = v125;
                }
                *((void *)&v46 + 1) = v88;
                *(void *)&long long v44 = &v89[8 * v92];
              }
            }
            else
            {
              size_t v88 = (char *)*((void *)&v46 + 1);
            }
            uint64_t v103 = *(void *)(i - 8);
            *((void *)v88 - 1) = v103;
            *((void *)&v46 + 1) -= 8;
          }
          uint64_t v104 = *v119;
          *(_OWORD *)unint64_t v119 = v46;
          *(_OWORD *)(v2 + 171) = v44;
          if (v104) {
            operator delete(v104);
          }
        }
        else
        {
          __int16 v35 = operator new(0x1000uLL);
          char v36 = v35;
          if (v32 == v11)
          {
            if (v33 == v12)
            {
              if (v11 == v12) {
                unint64_t v59 = 1;
              }
              else {
                unint64_t v59 = v34 >> 2;
              }
              uint64_t v60 = 2 * v59;
              uint64_t v61 = (char *)sub_19E060B48(v59);
              char v12 = &v61[(v60 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v63 = (uint64_t *)v2[170];
              char v64 = v12;
              uint64_t v65 = v2[171] - (void)v63;
              if (v65)
              {
                char v64 = &v12[v65 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v66 = 8 * (v65 >> 3);
                uint64_t v67 = v12;
                do
                {
                  uint64_t v68 = *v63++;
                  *(void *)uint64_t v67 = v68;
                  v67 += 8;
                  v66 -= 8;
                }
                while (v66);
              }
              char v69 = (void *)v2[169];
              v2[169] = v61;
              v2[170] = v12;
              v2[171] = v64;
              v2[172] = &v61[8 * v62];
              if (v69)
              {
                operator delete(v69);
                char v12 = (char *)v2[170];
              }
            }
            *((void *)v12 - 1) = v36;
            std::string::size_type v70 = (char *)v2[170];
            v2[170] = v70 - 8;
            uint64_t v71 = *((void *)v70 - 1);
            v2[170] = v70;
            int v72 = (char *)v2[171];
            if (v72 == (char *)v2[172])
            {
              uint64_t v73 = v70 - (unsigned char *)*v119;
              if (v70 <= *v119)
              {
                if (v72 == *v119) {
                  unint64_t v109 = 1;
                }
                else {
                  unint64_t v109 = (v72 - (unsigned char *)*v119) >> 2;
                }
                std::string v110 = (char *)sub_19E060B48(v109);
                std::string v112 = &v110[8 * (v109 >> 2)];
                std::string v113 = (uint64_t *)v2[170];
                int v72 = v112;
                uint64_t v114 = v2[171] - (void)v113;
                if (v114)
                {
                  int v72 = &v112[v114 & 0xFFFFFFFFFFFFFFF8];
                  uint64_t v115 = 8 * (v114 >> 3);
                  std::string::size_type v116 = &v110[8 * (v109 >> 2)];
                  do
                  {
                    uint64_t v117 = *v113++;
                    *(void *)std::string::size_type v116 = v117;
                    v116 += 8;
                    v115 -= 8;
                  }
                  while (v115);
                }
                uint64_t v118 = (void *)v2[169];
                v2[169] = v110;
                v2[170] = v112;
                v2[171] = v72;
                v2[172] = &v110[8 * v111];
                if (v118)
                {
                  operator delete(v118);
                  int v72 = (char *)v2[171];
                }
              }
              else
              {
                uint64_t v74 = v73 >> 3;
                BOOL v22 = v73 >> 3 < -1;
                uint64_t v75 = (v73 >> 3) + 2;
                if (v22) {
                  uint64_t v76 = v75;
                }
                else {
                  uint64_t v76 = v74 + 1;
                }
                uint64_t v77 = -(v76 >> 1);
                uint64_t v78 = v76 >> 1;
                unsigned int v79 = &v70[-8 * v78];
                int64_t v80 = v72 - v70;
                if (v72 != v70)
                {
                  memmove(&v70[-8 * v78], v70, v72 - v70);
                  std::string::size_type v70 = (char *)v2[170];
                }
                int v72 = &v79[v80];
                v2[171] = &v79[v80];
                v2[170] = &v70[8 * v77];
              }
            }
            *(void *)int v72 = v71;
            v2[171] += 8;
          }
          else
          {
            *(void *)uint64_t v11 = v35;
            v2[171] += 8;
          }
        }
      }
      else
      {
        v2[173] = v15 - 4096;
        uint64_t v19 = *(void *)v12;
        unint64_t v17 = v12 + 8;
        uint64_t v18 = v19;
        v2[170] = v17;
        if ((char *)v2[172] == v11)
        {
          uint64_t v20 = (uint64_t)&v17[-*v6];
          if ((unint64_t)v17 <= *v6)
          {
            if (v11 == (char *)*v6) {
              unint64_t v49 = 1;
            }
            else {
              unint64_t v49 = (uint64_t)&v11[-*v6] >> 2;
            }
            std::string::size_type v50 = (char *)sub_19E060B48(v49);
            unsigned __int16 v52 = &v50[8 * (v49 >> 2)];
            uint64_t v53 = (uint64_t *)v2[170];
            uint64_t v11 = v52;
            uint64_t v54 = v2[171] - (void)v53;
            if (v54)
            {
              uint64_t v11 = &v52[v54 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v55 = 8 * (v54 >> 3);
              uint64_t v56 = &v50[8 * (v49 >> 2)];
              do
              {
                uint64_t v57 = *v53++;
                *(void *)uint64_t v56 = v57;
                v56 += 8;
                v55 -= 8;
              }
              while (v55);
            }
            int v58 = (void *)v2[169];
            v2[169] = v50;
            v2[170] = v52;
            v2[171] = v11;
            v2[172] = &v50[8 * v51];
            if (v58)
            {
              operator delete(v58);
              uint64_t v11 = (char *)v2[171];
            }
          }
          else
          {
            uint64_t v21 = v20 >> 3;
            BOOL v22 = v20 >> 3 < -1;
            uint64_t v23 = (v20 >> 3) + 2;
            if (v22) {
              uint64_t v24 = v23;
            }
            else {
              uint64_t v24 = v21 + 1;
            }
            uint64_t v25 = -(v24 >> 1);
            uint64_t v26 = v24 >> 1;
            uint64_t v27 = &v17[-8 * v26];
            int64_t v28 = v11 - v17;
            if (v11 == v17)
            {
              int v29 = v11;
            }
            else
            {
              memmove(&v17[-8 * v26], v17, v11 - v17);
              int v29 = (char *)v2[170];
            }
            uint64_t v11 = &v27[v28];
            v2[171] = &v27[v28];
            v2[170] = &v29[8 * v25];
          }
        }
        *(void *)uint64_t v11 = v18;
        v2[171] += 8;
      }
      char v12 = (char *)v2[170];
      unint64_t v16 = v2[174] + v2[173];
    }
    *(unsigned char *)(*(void *)&v12[(v16 >> 9) & 0x7FFFFFFFFFFFF8] + (v16 & 0xFFF)) = v10;
    ++v2[174];
    long long v9 = (void *)v2[2];
  }
  std::string v105 = v4 + 2;
  if (v4 + 2 != v9)
  {
    do
    {
      uint64_t v4 = v105;
      long long v106 = *(_OWORD *)v105;
      void *v105 = 0;
      v105[1] = 0;
      std::string v107 = (std::__shared_weak_count *)*(v105 - 1);
      *((_OWORD *)v105 - 1) = v106;
      if (v107) {
        sub_19E0616BC(v107);
      }
      std::string v105 = v4 + 2;
    }
    while (v4 + 2 != v9);
    long long v9 = (void *)v2[2];
  }
  while (v9 != v4)
  {
    std::string v108 = (std::__shared_weak_count *)*(v9 - 1);
    if (v108) {
      sub_19E0616BC(v108);
    }
    v9 -= 2;
  }
  v2[2] = v4;
  return 1;
}

void sub_19E078E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, long long a13)
{
  operator delete(v13);
  if ((void)a13) {
    operator delete((void *)a13);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E078E4C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 80);
  uint64_t v4 = *(uint64_t **)(v3 + 8);
  uint64_t v5 = *(uint64_t **)(v3 + 16);
  if (v4 == v5) {
    goto LABEL_9;
  }
  while (1)
  {
    uint64_t v7 = *v4;
    uint64_t v6 = (std::__shared_weak_count *)v4[1];
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_19E0616BC(v6);
    }
    if (v7 == a2) {
      break;
    }
    v4 += 2;
    if (v4 == v5)
    {
      uint64_t v4 = v5;
      break;
    }
  }
  if (v4 == *(uint64_t **)(v3 + 16)) {
LABEL_9:
  }
    operator new();
  return 0;
}

void sub_19E079074(_Unwind_Exception *a1)
{
  sub_19E0616BC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0790BC(uint64_t a1)
{
  uint64_t v1 = *(void **)(*(void *)(*(void *)(a1 + 8) + 8) + 80);
  BOOL v2 = (void *)v1[1];
  uint64_t v3 = (void *)v1[2];
  while (v2 != v3)
  {
    uint64_t v4 = (uint64_t *)v1[4];
    uint64_t v5 = (uint64_t *)v1[5];
    if (v4 == v5) {
      goto LABEL_20;
    }
    do
    {
      uint64_t v7 = *v4;
      uint64_t v6 = (std::__shared_weak_count *)v4[1];
      if (v6)
      {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v8 = *v2;
        sub_19E0616BC(v6);
        if (v8 == v7) {
          goto LABEL_9;
        }
      }
      else if (*v2 == v7)
      {
        goto LABEL_9;
      }
      v4 += 2;
    }
    while (v4 != v5);
    uint64_t v4 = v5;
LABEL_9:
    uint64_t v3 = (void *)v1[2];
    if (v4 == (uint64_t *)v1[5])
    {
LABEL_20:
      v2 += 2;
    }
    else
    {
      long long v9 = v2 + 2;
      int v10 = v2;
      if (v2 + 2 != v3)
      {
        do
        {
          int v10 = v9;
          long long v11 = *(_OWORD *)v9;
          *long long v9 = 0;
          v9[1] = 0;
          char v12 = (std::__shared_weak_count *)*(v9 - 1);
          *((_OWORD *)v9 - 1) = v11;
          if (v12) {
            sub_19E0616BC(v12);
          }
          long long v9 = v10 + 2;
        }
        while (v10 + 2 != v3);
        uint64_t v3 = (void *)v1[2];
      }
      while (v3 != v10)
      {
        uint64_t v13 = (std::__shared_weak_count *)*(v3 - 1);
        if (v13) {
          sub_19E0616BC(v13);
        }
        v3 -= 2;
      }
      v1[2] = v10;
      uint64_t v3 = v10;
    }
  }
  sub_19E061784(v1 + 4);
  return 1;
}

void sub_19E0791E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 8) + 8);
  std::mutex::lock((std::mutex *)(v1 + 16));
  if (*(_DWORD *)(v1 + 8)) {
    *(_DWORD *)(v1 + ++**(_DWORD **)(result + 8) = 2;
  }

  std::mutex::unlock((std::mutex *)(v1 + 16));
}

uint64_t sub_19E079238(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 80);
  BOOL v2 = *(uint64_t **)(v1 + 8);
  uint64_t v3 = *(uint64_t **)(v1 + 16);
  uint64_t result = 0xFFFFFFFFLL;
  while (v2 != v3)
  {
    uint64_t v5 = *v2;
    v2 += 2;
    unsigned int v6 = *(_DWORD *)(v5 + 576);
    if (result == v6) {
      unsigned int v7 = result;
    }
    else {
      unsigned int v7 = -1;
    }
    if (result == -1) {
      unsigned int v7 = v6;
    }
    if (v6 == -1) {
      uint64_t result = result;
    }
    else {
      uint64_t result = v7;
    }
  }
  return result;
}

uint64_t sub_19E07927C(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 80);
  uint64_t v3 = *(uint64_t **)(v2 + 8);
  for (uint64_t i = *(uint64_t **)(v2 + 16); v3 != i; *(_DWORD *)(v5 + 576) = v7)
  {
    uint64_t v6 = *v3;
    v3 += 2;
    uint64_t v5 = v6;
    if (a2 >= (unint64_t)((uint64_t)(*(void *)(v6 + 616) - *(void *)(v6 + 608)) >> 3)) {
      int v7 = 0;
    }
    else {
      int v7 = a2;
    }
  }
  return 0;
}

uint64_t sub_19E0792C4()
{
  return 0;
}

uint64_t sub_19E0792CC()
{
  return 1;
}

void *sub_19E0792D4@<X0>(void *a1@<X8>)
{
  return sub_19E063AC4(a1, byte_19E132984);
}

uint64_t sub_19E0792E4(uint64_t a1, uint64_t a2, void *a3, unsigned int *a4)
{
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 80);
  uint64_t v6 = *(void *)(v5 + 8);
  uint64_t v7 = *(void *)(v5 + 16);
  if (v6 != v7)
  {
    while (*(unsigned __int8 *)(*(void *)v6 + 656) != *(unsigned __int8 *)(a2 + 123))
    {
      v6 += 16;
      if (v6 == v7) {
        return *a4;
      }
    }
    (*(void (**)(void *__return_ptr))(**(void **)v6 + 168))(v14);
    int v9 = (char)v15;
    long long v11 = (void *)v14[0];
    uint64_t v10 = v14[1];
    if ((v15 & 0x80u) == 0) {
      char v12 = v14;
    }
    else {
      char v12 = (void *)v14[0];
    }
    if ((v15 & 0x80u) == 0) {
      uint64_t v10 = v15;
    }
    memcpy(&unk_1E94572C0, v12, 2 * v10);
    *a3 = &unk_1E94572C0;
    *a4 *= 2;
    if (v9 < 0) {
      operator delete(v11);
    }
  }
  return *a4;
}

unint64_t sub_19E0793E4(uint64_t a1, void *__src, size_t __n, int a4, int a5, unsigned int a6, void *__dst, unint64_t a8)
{
  unint64_t result = 0;
  if (__n && a4)
  {
    if (a6)
    {
      uint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 80);
      uint64_t v13 = *(void **)(v12 + 8);
      uint64_t v14 = *(void **)(v12 + 16);
      if (v13 == v14)
      {
LABEL_7:
        unint64_t result = 0;
      }
      else
      {
        while (*(unsigned __int8 *)(*v13 + 656) != a5)
        {
          v13 += 2;
          if (v13 == v14) {
            goto LABEL_7;
          }
        }
        unint64_t result = (*(uint64_t (**)(void, void, void *, size_t, void, void *))(*(void *)*v13 + 96))(*v13, (a6 >> 4) & 8 | (a6 >> 2) & 4 | (a6 >> 15) & 0x10 | 1, __src, __n, a4 & 0xFFFFFFF, __dst);
      }
      if ((result > a8) | result & 1) {
        return 0;
      }
      else {
        return result;
      }
    }
    else if (a8 >= __n)
    {
      memcpy(__dst, __src, __n);
      return __n;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_19E0794F0(uint64_t a1)
{
  uint64_t v1 = sub_19E078614(a1);
  (*(void (**)(uint64_t))(*(void *)v1 + 200))(v1);
  return 0;
}

uint64_t sub_19E079530(uint64_t a1)
{
  uint64_t v2 = (void (***)(void))sub_19E078614(a1);
  (**v2)(v2);
  uint64_t v3 = sub_19E078614(a1);
  uint64_t v4 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 200))(v3);
  uint64_t v5 = (void *)v4[2];
  void v5[4] = 0;
  void v5[5] = 0;
  uint64_t v7 = v5[1];
  uint64_t v6 = v5[2];
  if (v6 == v7)
  {
    uint64_t v7 = v5[2];
  }
  else
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = *(void *)(v7 + 8 * v8);
      if (v9)
      {
        uint64_t v10 = *(void *)(v9 - 8);
        if (v10)
        {
          uint64_t v11 = v10 << 7;
          do
          {
            sub_19E060B80((const void **)(v9 - 24 + v11), 0);
            v11 -= 128;
          }
          while (v11);
        }
        MEMORY[0x19F3BA6E0](v9 - 16, 0x1070C80FE750B47);
        uint64_t v7 = v5[1];
        uint64_t v6 = v5[2];
      }
      ++v8;
    }
    while (v8 < (v6 - v7) >> 3);
  }
  v5[2] = v7;
  uint64_t v12 = (void *)v4[4];
  if (v12)
  {
    v12[4] = 0;
    void v12[5] = 0;
    uint64_t v14 = v12[1];
    uint64_t v13 = v12[2];
    if (v13 == v14)
    {
      uint64_t v14 = v12[2];
    }
    else
    {
      unint64_t v15 = 0;
      do
      {
        uint64_t v16 = *(void *)(v14 + 8 * v15);
        if (v16)
        {
          MEMORY[0x19F3BA6E0](v16, 0x1020C80EDCEB4C7);
          uint64_t v14 = v12[1];
          uint64_t v13 = v12[2];
        }
        ++v15;
      }
      while (v15 < (v13 - v14) >> 3);
    }
    void v12[2] = v14;
  }
  uint64_t v17 = v4[6];
  if (v17)
  {
    *(void *)(v17 + 32) = 0;
    *(void *)(v17 + 4sub_19E03D880(&a9, 0) = 0;
  }
  uint64_t v18 = v4[8];
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  v4[8] = 0;
  return 0;
}

uint64_t sub_19E0796CC(uint64_t a1, unsigned __int16 a2, unsigned __int16 a3)
{
  return sub_19E05DDEC(*(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 88), a2, a3);
}

uint64_t sub_19E0796E4(uint64_t a1, const UChar *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if ((*(int (**)(uint64_t))(*(void *)a1 + 272))(a1) <= 0)
  {
    if (setjmp((int *)(a1 + 336)) != 1)
    {
      std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
      uint64_t v16 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tagger.cpp", 69);
      sub_19E0416F8(v16, (uint64_t)"(", 1);
      uint64_t v17 = (void *)std::ostream::operator<<();
      uint64_t v18 = sub_19E0416F8(v17, (uint64_t)") [", 3);
      uint64_t v19 = sub_19E0416F8(v18, (uint64_t)"lattice_level() >= 1", 20);
      uint64_t v20 = sub_19E0416F8(v19, (uint64_t)"] ", 2);
      sub_19E0416F8(v20, (uint64_t)"use -l option to obtain N-Best results. e.g., mecab -N10 -l1", 60);
      longjmp((int *)(a1 + 336), 1);
    }
    return 0;
  }
  if (a4)
  {
    uint64_t v14 = sub_19E078614(a1);
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 152))(v14);
  }
  else
  {
    uint64_t v15 = (*(uint64_t (**)(uint64_t, const UChar *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 16))(a1, a2, a3, a5, a6, a7);
  }
  uint64_t v21 = v15;
  if (!v15) {
    return 0;
  }
  uint64_t v22 = sub_19E078614(a1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v22 + 144))(v22, v21);
  First = u_strFindFirst(a2, (unint64_t)(int)a3 >> 1, (const UChar *)"\t", 1);
  int64_t v24 = 0;
  if (First) {
    int64_t v24 = (char *)First - (char *)a2;
  }
  uint64_t v25 = v24 + a4;
  uint64_t v26 = -16;
  if (!First) {
    uint64_t v26 = -8;
  }
  uint64_t v27 = v26 + a3;
  uint64_t v28 = sub_19E078614(a1);
  uint64_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v28 + 200))(v28);
  __int16 v30 = (void *)sub_19E06AE14(v29);
  sub_19E07B798(v30, v21, v25, v27);
  return 1;
}

void sub_19E079978()
{
  sub_19E05E710(v0);
}

uint64_t sub_19E079980(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  if ((*(int (**)(void *))(*a1 + 272))(a1) < 1) {
    return 0;
  }
  uint64_t v12 = sub_19E078614((uint64_t)a1);
  uint64_t v13 = v12;
  if (a5)
  {
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 152))(v12);
    goto LABEL_44;
  }
  sub_19E07A100((uint64_t)a1);
  if ((a6 & 2) == 0) {
    (**(void (***)(uint64_t))v13)(v13);
  }
  if (!a4) {
    a4 = 2 * (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13 + 80))(v13, a3, a4);
  uint64_t v15 = *(void *)(a1[1] + 8);
  v49[0] = MEMORY[0x1E4F143A8];
  v49[1] = 0x40000000;
  std::string::size_type v50 = sub_19E0610EC;
  uint64_t v51 = &unk_1E599B628;
  uint64_t v52 = v15;
  std::mutex::lock((std::mutex *)(v15 + 16));
  *(_DWORD *)(v15 + ++**(_DWORD **)(result + 8) = 1;
  std::mutex::unlock((std::mutex *)(v15 + 16));
  if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13 + 168))(v13, 2) & 1) != 0
    || (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v13 + 168))(v13, 8))
  {
    *(void *)(v15 + 12sub_19E03D880(&a9, 0) = sub_19E060BB8;
    *(void *)(v15 + 12++**(_DWORD **)(result + 8) = 0;
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v13 + 168))(v13, 4)
    && !sub_19E05FECC(v13))
  {
    goto LABEL_41;
  }
  uint64_t v47 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 64))(v13);
  uint64_t v45 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 88))(v13);
  uint64_t v16 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v13 + 40))(v13);
  unint64_t v48 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v13 + 32))(v13);
  uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 200))(v13);
  uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
  uint64_t v19 = *(void *)(v15 + 80);
  uint64_t v20 = sub_19E0609C8(*(void **)(v17 + 16));
  *(_OWORD *)(v20 + 96) = 0u;
  *(_OWORD *)(v20 + 112) = 0u;
  *(_OWORD *)(v20 + 64) = 0u;
  *(_OWORD *)(v20 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(v20 + 32) = 0u;
  *(_OWORD *)(v20 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)uint64_t v20 = 0u;
  *(_OWORD *)(v20 + 16) = 0u;
  *(void *)(v20 + 4++**(_DWORD **)(result + 8) = "BOS/EOS";
  *(void *)(v20 + 56) = *(void *)(v19 + 136);
  *(unsigned char *)(v20 + 124) = 2;
  uint64_t *v16 = v20;
  int v21 = sub_19E0608F8(v20);
  *(_DWORD *)(v15 + 112) = v21;
  if (v21 == -1) {
    goto LABEL_16;
  }
  if (!v21)
  {
LABEL_41:
    int v30 = 0;
    goto LABEL_42;
  }
  int v21 = 0;
LABEL_16:
  unint64_t v22 = 2 * v18;
  *(_DWORD *)(v15 + 116) = v21;
  if (v22)
  {
    if (*(_DWORD *)(v15 + 8) != 2)
    {
      unint64_t v23 = 0;
      unint64_t v46 = v47 + v45;
      do
      {
        if (v16[v23])
        {
          if (v23 || !*v48)
          {
            uint64_t v24 = *(void *)(v15 + 80);
            if (v47) {
              uint64_t v25 = sub_19E062AAC(v24, a2, v23, (unsigned __int16 *)(v47 + v23), v46, v17, a6);
            }
            else {
              uint64_t v25 = sub_19E062AAC(v24, a2, v23, 0, 0, v17, a6);
            }
            v48[v23] = v25;
          }
          uint64_t v26 = *(unsigned int (**)(void *, unint64_t))(v15 + 120);
          uint64_t v27 = *(void *)(v15 + 128);
          uint64_t v28 = (void *)(v15 + (v27 >> 1));
          if (v27) {
            uint64_t v26 = *(unsigned int (**)(void *, unint64_t))(*v28 + v26);
          }
          if (!v26(v28, v23)) {
            break;
          }
          int v29 = *(_DWORD *)(v15 + 116);
          if (v29 != -1 && v29 >= *(_DWORD *)(v15 + 112)) {
            goto LABEL_35;
          }
        }
        v23 += 2;
        if (v22 <= v23) {
          goto LABEL_35;
        }
      }
      while (*(_DWORD *)(v15 + 8) != 2);
    }
    int v30 = 0;
    a5 = 0;
    goto LABEL_42;
  }
LABEL_35:
  uint64_t v31 = *(void *)(v15 + 80);
  a5 = 0;
  uint64_t v32 = sub_19E0609C8(*(void **)(v17 + 16));
  *(_OWORD *)(v32 + 96) = 0u;
  *(_OWORD *)(v32 + 112) = 0u;
  *(_OWORD *)(v32 + 64) = 0u;
  *(_OWORD *)(v32 + 8sub_19E03D880(&a9, 0) = 0u;
  *(_OWORD *)(v32 + 32) = 0u;
  *(_OWORD *)(v32 + 4++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)uint64_t v32 = 0u;
  *(_OWORD *)(v32 + 16) = 0u;
  *(void *)(v32 + 4++**(_DWORD **)(result + 8) = "BOS/EOS";
  *(void *)(v32 + 56) = *(void *)(v31 + 136);
  *(unsigned char *)(v32 + 124) = 3;
  v48[v22] = v32;
  if (v16[v22])
  {
    uint64_t v33 = *(unsigned int (**)(void *, unint64_t, uint64_t, uint64_t *, uint64_t, uint64_t))(v15 + 120);
    uint64_t v34 = *(void *)(v15 + 128);
    __int16 v35 = (void *)(v15 + (v34 >> 1));
    if (v34) {
      uint64_t v33 = *(unsigned int (**)(void *, unint64_t, uint64_t, uint64_t *, uint64_t, uint64_t))(*v35 + v33);
    }
    if (!v33(v35, v22, v32, v16, v17, v15 + 116)) {
      goto LABEL_41;
    }
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13 + 168))(v13, 32, v32))
  {
    sub_19E0607DC(v13);
  }
  else
  {
    char v43 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v13 + 24))(v13);
    long long v44 = (void *)*v43;
    if (*v43)
    {
      do
      {
        v44[1] = v43;
        char v43 = v44;
        long long v44 = (void *)*v44;
      }
      while (v44);
      int v30 = 1;
      goto LABEL_42;
    }
  }
  int v30 = 1;
LABEL_42:
  v50((uint64_t)v49);
  if (!v30) {
    return 0;
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
LABEL_44:
  uint64_t v36 = v14;
  if (v14)
  {
    uint64_t v37 = sub_19E078614((uint64_t)a1);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v37 + 144))(v37, v36);
    uint64_t v38 = sub_19E078614((uint64_t)a1);
    uint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)v38 + 200))(v38);
    uint64_t v40 = (void *)sub_19E06AE14(v39);
    uint64_t v41 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
    sub_19E07B798(v40, v36, a5, 2 * v41);
    return 1;
  }
  return 0;
}

void sub_19E07A0DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void (*a16)(char *))
{
}

uint64_t sub_19E07A100(uint64_t a1)
{
  uint64_t v2 = sub_19E078614(a1);
  (*(void (**)(uint64_t, void))(*(void *)v2 + 176))(v2, *(unsigned int *)(a1 + 32));
  uint64_t v3 = sub_19E078614(a1);
  v4.n128_u64[0] = *(void *)(a1 + 40);
  v4.n128_f32[0] = v4.n128_f64[0];
  uint64_t v5 = *(uint64_t (**)(__n128))(*(void *)v3 + 112);

  return v5(v4);
}

uint64_t sub_19E07A18C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((*(int (**)(uint64_t))(*(void *)a1 + 272))(a1) < 1) {
    return 0;
  }
  if (a4)
  {
    uint64_t v10 = sub_19E078614(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 152))(v10);
  }
  else
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 8))(a1, a2, a3, a5);
  }
  uint64_t v12 = v11;
  if (!v11) {
    return 0;
  }
  uint64_t v13 = sub_19E078614(a1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 144))(v13, v12);
  uint64_t v14 = sub_19E078614(a1);
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 200))(v14);
  uint64_t v16 = (void *)sub_19E06AE14(v15);
  sub_19E07B798(v16, v12, a4, a3);
  return 1;
}

uint64_t sub_19E07A2EC()
{
  return 0;
}

uint64_t sub_19E07A2F4()
{
  return 0;
}

uint64_t sub_19E07A2FC(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!a2) {
    return 0;
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 8);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
  if (result)
  {
    uint64_t v7 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 200))(a2);
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 88))(a2);
    unint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
    uint64_t v11 = *(void *)(v5 + 80);
    uint64_t v12 = sub_19E0609C8(*(void **)(v8 + 16));
    *(_OWORD *)(v12 + 96) = 0u;
    *(_OWORD *)(v12 + 112) = 0u;
    *(unsigned char *)(v12 + 124) = 2;
    *(_OWORD *)uint64_t v12 = 0u;
    *(_OWORD *)(v12 + 16) = 0u;
    *(_OWORD *)(v12 + 64) = 0u;
    *(_OWORD *)(v12 + 8sub_19E03D880(&a9, 0) = 0u;
    *(_OWORD *)(v12 + 32) = 0u;
    *(_OWORD *)(v12 + 4++**(_DWORD **)(result + 8) = 0u;
    uint64_t v13 = *(void *)(v11 + 136);
    *(void *)(v12 + 4++**(_DWORD **)(result + 8) = v10;
    *(void *)(v12 + 56) = v13;
    uint64_t *v7 = v12;
    uint64_t result = sub_19E063788(*(void *)(v5 + 80), v10, (unsigned __int8 *)(v10 + v9), v8, a3);
    if (result)
    {
      void v7[2] = result;
      uint64_t v14 = *(void *)(v5 + 80);
      uint64_t v15 = sub_19E0609C8(*(void **)(v8 + 16));
      *(_OWORD *)(v15 + 96) = 0u;
      *(_OWORD *)(v15 + 112) = 0u;
      *(unsigned char *)(v15 + 124) = 3;
      *(_OWORD *)uint64_t v15 = 0u;
      *(_OWORD *)(v15 + 16) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_OWORD *)(v15 + 8sub_19E03D880(&a9, 0) = 0u;
      *(_OWORD *)(v15 + 32) = 0u;
      *(_OWORD *)(v15 + 4++**(_DWORD **)(result + 8) = 0u;
      uint64_t v16 = *(void *)(v14 + 136);
      *(void *)(v15 + 4++**(_DWORD **)(result + 8) = v10 + v9;
      *(void *)(v15 + 56) = v16;
      v7[v9 + 2] = v15;
      *(void *)(v12 + ++**(_DWORD **)(result + 8) = v7[2];
      for (uint64_t i = v7[2]; i; uint64_t i = *(void *)(i + 24))
        *(void *)(i + ++**(_DWORD **)(result + 8) = v7[*(unsigned __int16 *)(i + 96) + 2];
      return 1;
    }
  }
  return result;
}

uint64_t sub_19E07A4F4(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (a2)
  {
    uint64_t v8 = sub_19E078614(a1);
    sub_19E07A100(a1);
    if ((a4 & 2) == 0) {
      (**(void (***)(uint64_t))v8)(v8);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 80))(v8, a2, a3);
    if (sub_19E05EF80(*(void *)(*(void *)(a1 + 8) + 8), v8, a4)) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
    }
  }
  else
  {
    uint64_t v9 = (int *)(a1 + 336);
    if (setjmp((int *)(a1 + 336)) != 1)
    {
      std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
      unint64_t v10 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tagger.cpp", 69);
      sub_19E0416F8(v10, (uint64_t)"(", 1);
      uint64_t v11 = (void *)std::ostream::operator<<();
      uint64_t v12 = sub_19E0416F8(v11, (uint64_t)") [", 3);
      uint64_t v13 = sub_19E0416F8(v12, (uint64_t)"str", 3);
      uint64_t v14 = sub_19E0416F8(v13, (uint64_t)"] ", 2);
      sub_19E0416F8(v14, (uint64_t)"NULL pointer is given", 21);
      longjmp(v9, 1);
    }
  }
  return 0;
}

void sub_19E07A6D8()
{
  sub_19E05E710(v0);
}

uint64_t sub_19E07A6E0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (a2)
  {
    uint64_t v8 = sub_19E078614(a1);
    sub_19E07A100(a1);
    if ((a4 & 2) == 0) {
      (**(void (***)(uint64_t))v8)(v8);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 80))(v8, a2, a3);
    if (sub_19E05EF80(*(void *)(*(void *)(a1 + 8) + 8), v8, a4)) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
    }
  }
  else
  {
    uint64_t v9 = (int *)(a1 + 336);
    if (setjmp((int *)(a1 + 336)) != 1)
    {
      std::ios_base::clear((std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24)), 0);
      unint64_t v10 = sub_19E0416F8((void *)(a1 + 48), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/tagger.cpp", 69);
      sub_19E0416F8(v10, (uint64_t)"(", 1);
      uint64_t v11 = (void *)std::ostream::operator<<();
      uint64_t v12 = sub_19E0416F8(v11, (uint64_t)") [", 3);
      uint64_t v13 = sub_19E0416F8(v12, (uint64_t)"str", 3);
      uint64_t v14 = sub_19E0416F8(v13, (uint64_t)"] ", 2);
      sub_19E0416F8(v14, (uint64_t)"NULL pointer is given", 21);
      longjmp(v9, 1);
    }
  }
  return 0;
}

void sub_19E07A8B4()
{
  sub_19E05E710(v0);
}

uint64_t sub_19E07A8BC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
  uint64_t v3 = (void *)*v2;
  if (*v2)
  {
    do
    {
      v3[1] = v2;
      uint64_t v2 = v3;
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
  }
  return 1;
}

uint64_t sub_19E07A914(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09BD20;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 1;
  *(void *)(a1 + 4sub_19E03D880(&a9, 0) = 0x3FE8000000000000;
  sub_19E05DB78(a1 + 48);
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 32sub_19E03D880(&a9, 0) = 0;
  *(void *)(a1 + 32++**(_DWORD **)(result + 8) = 0;
  return a1;
}

void sub_19E07A978(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 24);
  *(void *)(v1 + 24) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 336))(v3);
  }
  uint64_t v4 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_19E07A9EC(uint64_t a1, const char *a2)
{
  v62[19] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = sub_19E068A30(v60);
  if ((*((unsigned char *)v3 + *(void *)(v60[0] - 24) + 32) & 5) != 0)
  {
    if (setjmp((int *)(a1 + 416)) != 1)
    {
      std::ios_base::clear((std::ios_base *)(a1 + 128 + *(void *)(*(void *)(a1 + 128) - 24)), 0);
      uint64_t v40 = sub_19E0416F8((void *)(a1 + 128), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/param.cpp", 68);
      sub_19E0416F8(v40, (uint64_t)"(", 1);
      uint64_t v41 = (void *)std::ostream::operator<<();
      long long v42 = sub_19E0416F8(v41, (uint64_t)") [", 3);
      char v43 = sub_19E0416F8(v42, (uint64_t)"ifs", 3);
      long long v44 = sub_19E0416F8(v43, (uint64_t)"] ", 2);
      uint64_t v45 = sub_19E0416F8(v44, (uint64_t)"no such file or directory: ", 27);
      size_t v46 = strlen(a2);
      sub_19E0416F8(v45, (uint64_t)a2, v46);
      longjmp((int *)(a1 + 416), 1);
    }
    BOOL v4 = 0;
    goto LABEL_76;
  }
  memset(&v58, 0, sizeof(v58));
  uint64_t v5 = MEMORY[0x1E4F14390];
  uint64_t v6 = v60[0];
  while (1)
  {
LABEL_5:
    std::ios_base::getloc((const std::ios_base *)((char *)v60 + *(void *)(v6 - 24)));
    uint64_t v7 = std::locale::use_facet((const std::locale *)&v57, MEMORY[0x1E4FBA258]);
    char v8 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10);
    std::locale::~locale((std::locale *)&v57);
    MEMORY[0x19F3BA420]();
    if (!v57.__r_.__value_.__s.__data_[0]) {
      goto LABEL_22;
    }
    if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
    {
      *v58.__r_.__value_.__l.__data_ = 0;
      v58.__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      v58.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&v58.__r_.__value_.__s + 23) = 0;
    }
    uint64_t v9 = 0;
    while (1)
    {
      unint64_t v10 = *(void **)&v61[*(void *)(v60[0] - 24) + 24];
      uint64_t v11 = (std::string::value_type *)v10[3];
      if (v11 != (std::string::value_type *)v10[4])
      {
        void v10[3] = v11 + 1;
        std::string::value_type v12 = *v11;
        goto LABEL_13;
      }
      int v13 = (*(uint64_t (**)(void *))(*v10 + 80))(v10);
      std::string::value_type v12 = v13;
      if (v13 == -1) {
        break;
      }
LABEL_13:
      if (v8 == v12)
      {
        int v15 = 0;
        goto LABEL_21;
      }
      std::string::push_back(&v58, v12);
      uint64_t v14 = ++v9;
      if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
      {
        uint64_t v9 = v14;
        if (v58.__r_.__value_.__l.__size_ == 0x7FFFFFFFFFFFFFF7)
        {
          int v15 = 4;
          goto LABEL_21;
        }
      }
    }
    if (v9) {
      int v15 = 2;
    }
    else {
      int v15 = 6;
    }
LABEL_21:
    std::ios_base::clear((std::ios_base *)((char *)v60 + *(void *)(v60[0] - 24)), *(_DWORD *)&v61[*(void *)(v60[0] - 24) + 16] | v15);
LABEL_22:
    BOOL v16 = (*(_DWORD *)&v61[*(void *)(v60[0] - 24) + 16] & 5) != 0;
    if ((*(_DWORD *)&v61[*(void *)(v60[0] - 24) + 16] & 5) != 0) {
      goto LABEL_73;
    }
    if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v6 = v60[0];
      if (v58.__r_.__value_.__l.__size_)
      {
        int v17 = *v58.__r_.__value_.__l.__data_;
        goto LABEL_28;
      }
      continue;
    }
    uint64_t v6 = v60[0];
    if (*((unsigned char *)&v58.__r_.__value_.__s + 23))
    {
      int v17 = v58.__r_.__value_.__s.__data_[0];
LABEL_28:
      uint64_t v6 = v60[0];
      if (v17 != 59)
      {
        uint64_t v6 = v60[0];
        if (v17 != 35) {
          break;
        }
      }
    }
  }
  if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v58.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v58.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    uint64_t v19 = (v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v58
        : (std::string *)v58.__r_.__value_.__r.__words[0];
    uint64_t v20 = memchr(v19, 61, size);
    if (v20)
    {
      int v21 = v20;
      if (v20 - (unsigned char *)v19 != -1)
      {
        unint64_t v22 = v20 - (unsigned char *)v19 + 1;
        do
        {
          std::string::size_type v23 = v22;
          std::string::size_type v24 = HIBYTE(v58.__r_.__value_.__r.__words[2]);
          if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v24 = v58.__r_.__value_.__l.__size_;
          }
          if (v22 >= v24) {
            break;
          }
          uint64_t v25 = (v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &v58
              : (std::string *)v58.__r_.__value_.__r.__words[0];
          unsigned int v26 = v25->__r_.__value_.__s.__data_[v23];
          int v27 = (v26 & 0x80000000) != 0 ? __maskrune(v26, 0x4000uLL) : *(_DWORD *)(v5 + 4 * v26 + 60) & 0x4000;
          int v28 = v27;
          unint64_t v22 = v23 + 1;
        }
        while (v28);
        uint64_t v29 = (uint64_t)&v21[~(unint64_t)v19];
        while (1)
        {
          uint64_t v30 = v29;
          std::string::size_type v31 = HIBYTE(v58.__r_.__value_.__r.__words[2]);
          if (v29 < 0) {
            break;
          }
          if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v32 = &v58;
          }
          else {
            uint64_t v32 = (std::string *)v58.__r_.__value_.__r.__words[0];
          }
          unsigned int v33 = v32->__r_.__value_.__s.__data_[v30];
          if ((v33 & 0x80000000) != 0) {
            int v34 = __maskrune(v33, 0x4000uLL);
          }
          else {
            int v34 = *(_DWORD *)(v5 + 4 * v33 + 60) & 0x4000;
          }
          int v35 = v34;
          uint64_t v29 = v30 - 1;
          if (!v35)
          {
            std::string::size_type v36 = v30 + 1;
            std::string::size_type v31 = HIBYTE(v58.__r_.__value_.__r.__words[2]);
            goto LABEL_61;
          }
        }
        std::string::size_type v36 = v29 + 1;
LABEL_61:
        if ((v31 & 0x80u) == 0) {
          std::string::size_type v37 = v31;
        }
        else {
          std::string::size_type v37 = v58.__r_.__value_.__l.__size_;
        }
        std::string::basic_string(&v57, &v58, v23, v37 - v23, (std::allocator<char> *)&__p);
        std::string::basic_string(&__p, &v58, 0, v36, (std::allocator<char> *)&v59);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        sub_19E0702F8(a1, (char *)p_p, (uint64_t)&v57, 0);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v57.__r_.__value_.__l.__data_);
        }
        uint64_t v6 = v60[0];
        goto LABEL_5;
      }
    }
  }
  if (setjmp((int *)(a1 + 416)) != 1)
  {
    std::ios_base::clear((std::ios_base *)(a1 + 128 + *(void *)(*(void *)(a1 + 128) - 24)), 0);
    uint64_t v47 = sub_19E0416F8((void *)(a1 + 128), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Lexicon/Source/MeCab/param.cpp", 68);
    sub_19E0416F8(v47, (uint64_t)"(", 1);
    unint64_t v48 = (void *)std::ostream::operator<<();
    unint64_t v49 = sub_19E0416F8(v48, (uint64_t)") [", 3);
    std::string::size_type v50 = sub_19E0416F8(v49, (uint64_t)"pos != std::string::npos", 24);
    uint64_t v51 = sub_19E0416F8(v50, (uint64_t)"] ", 2);
    uint64_t v52 = sub_19E0416F8(v51, (uint64_t)"format error: ", 14);
    if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v53 = &v58;
    }
    else {
      uint64_t v53 = (std::string *)v58.__r_.__value_.__r.__words[0];
    }
    if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v54 = HIBYTE(v58.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v54 = v58.__r_.__value_.__l.__size_;
    }
    sub_19E0416F8(v52, (uint64_t)v53, v54);
    longjmp((int *)(a1 + 416), 1);
  }
LABEL_73:
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v58.__r_.__value_.__l.__data_);
  }
  BOOL v4 = v16;
LABEL_76:
  v60[0] = *MEMORY[0x1E4FBA3F8];
  *(uint64_t *)((char *)v60 + *(void *)(v60[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
  MEMORY[0x19F3BA400](v61);
  std::istream::~istream();
  MEMORY[0x19F3BA690](v62);
  return v4;
}

void sub_19E07B1E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  sub_19E068CB8(&a26);
  _Unwind_Resume(a1);
}

void sub_19E07B1F4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_19E04137C(a1);
  }
  _Unwind_Resume(a1);
}

void sub_19E07B208()
{
  sub_19E05E710(v0);
}

void sub_19E07B21C()
{
}

void sub_19E07B22C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  sub_19E068CB8(&a32);
  _Unwind_Resume(a1);
}

void sub_19E07B268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::locale a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26)
{
  if (a24 < 0) {
    operator delete(a19);
  }
  sub_19E068CB8(&a26);
  _Unwind_Resume(a1);
}

void sub_19E07B29C(uint64_t a1, char *a2)
{
  v28[2] = *MEMORY[0x1E4F143B8];
  sub_19E0413C8(__p, a2);
  sub_19E05EA00((uint64_t)&v26);
  memset(&v25, 0, sizeof(v25));
  uint64_t v3 = (void *)std::ostream::operator<<();
  if ((*((unsigned char *)v3 + *(void *)(*v3 - 24) + 32) & 5) != 0) {
    goto LABEL_30;
  }
  MEMORY[0x19F3BA420](&v27, &v26, 0);
  if (!v27) {
    goto LABEL_28;
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
  {
    *v25.__r_.__value_.__l.__data_ = 0;
    v25.__r_.__value_.__l.__size_ = 0;
  }
  else
  {
    v25.__r_.__value_.__s.__data_[0] = 0;
    *((unsigned char *)&v25.__r_.__value_.__s + 23) = 0;
  }
  BOOL v4 = (const std::ios_base *)((char *)&v26 + (unint64_t)v26.__sb_.__vftable[-1].pbackfail);
  uint64_t width = v4->__width_;
  if (width <= 1) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = v4->__width_;
  }
  std::ios_base::getloc(v4);
  uint64_t v7 = std::locale::use_facet(&v24, MEMORY[0x1E4FBA258]);
  std::locale::~locale(&v24);
  uint64_t v8 = 0;
  if (width >= 1) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = 0x7FFFFFFFFFFFFFF7;
  }
  while (1)
  {
    unint64_t v10 = *(std::streambuf::char_type **)((char *)&v26.__sb_.__bout_
                                        + (unint64_t)v26.__sb_.__vftable[-1].pbackfail);
    uint64_t v11 = (unsigned char *)v10[3];
    if (v11 == (unsigned char *)v10[4]) {
      break;
    }
    LOBYTE(v12) = *v11;
LABEL_16:
    if ((v12 & 0x80) == 0 && (*((_DWORD *)&v7[1].~facet + v12) & 0x4000) != 0)
    {
      int v15 = 0;
      goto LABEL_25;
    }
    std::string::push_back(&v25, v12);
    int v13 = *(std::streambuf::char_type **)((char *)&v26.__sb_.__bout_
                                        + (unint64_t)v26.__sb_.__vftable[-1].pbackfail);
    uint64_t v14 = v13[3];
    if (v14 == v13[4]) {
      (*(void (**)(void *))(*v13 + 80))(v13);
    }
    else {
      _OWORD v13[3] = v14 + 1;
    }
    if (v9 == ++v8)
    {
      int v15 = 0;
      uint64_t v8 = 1;
      goto LABEL_25;
    }
  }
  int v12 = (*(uint64_t (**)(void *))(*v10 + 72))(v10);
  if (v12 != -1) {
    goto LABEL_16;
  }
  int v15 = 2;
LABEL_25:
  BOOL v16 = v26.__sb_.__vftable;
  *(std::streambuf::char_type **)((char *)&v26.__sb_.__ninp_ + (unint64_t)v26.__sb_.__vftable[-1].pbackfail) = 0;
  if (!v8) {
    v15 |= 4u;
  }
  std::ios_base::clear((std::ios_base *)((char *)&v26 + (unint64_t)v16[-1].pbackfail), *(_DWORD *)((char *)&v26.__sb_.__einp_ + (unint64_t)v16[-1].pbackfail) | v15);
LABEL_28:
  if ((*((unsigned char *)&v26.__sb_.__einp_ + (unint64_t)v26.__sb_.__vftable[-1].pbackfail) & 5) != 0
    || (sub_19E05EB24(&v26),
        (*((unsigned char *)&v26.__sb_.__einp_ + (unint64_t)v26.__sb_.__vftable[-1].pbackfail) & 2) == 0))
  {
LABEL_30:
    operator new();
  }
  v28[0] = v25.__r_.__value_.__l.__size_;
  std::string::size_type v20 = v25.__r_.__value_.__r.__words[0];
  *(void *)((char *)v28 + 7) = *(std::string::size_type *)((char *)&v25.__r_.__value_.__r.__words[1] + 7);
  char v21 = HIBYTE(v25.__r_.__value_.__r.__words[2]);
  std::strstream::~strstream(&v26);
  int v17 = sub_19E0704A4((uint64_t **)(a1 + 8), __p, (uint64_t)__p);
  uint64_t v18 = v17;
  if (*((char *)v17 + 79) < 0) {
    operator delete(v17[7]);
  }
  uint64_t v19 = (uint64_t *)v28[0];
  v18[7] = (uint64_t *)v20;
  v18[8] = v19;
  *(uint64_t **)((char *)v18 + 71) = *(uint64_t **)((char *)v28 + 7);
  *((unsigned char *)v18 + 79) = v21;
  if (v23 < 0) {
    operator delete(__p[0]);
  }
}

void sub_19E07B678(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,std::strstream *a23)
{
  if (a2)
  {
    std::locale::~locale(&a15);
    __cxa_begin_catch(exception_object);
    std::locale v24 = a23;
    *(_DWORD *)((char *)&a23 + a23[-1].__sb_.__alsize_ + 32) |= 1u;
    if ((*((unsigned char *)&a23 + v24[-1].__sb_.__alsize_ + 36) & 1) == 0)
    {
      __cxa_end_catch();
      JUMPOUT(0x19E07B4F8);
    }
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E07B798(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = (char **)(a1 + 2);
  uint64_t v8 = (void *)a1[2];
  v9[8] = 0;
  v9[9] = 0;
  if (v8)
  {
    a1[3] = v8;
    operator delete(v8);
  }
  *uint64_t v9 = 0;
  v9[1] = 0;
  v9[2] = 0;
  do
  {
    uint64_t v10 = a2;
    a2 = *(void *)(a2 + 8);
  }
  while (a2);
  sub_19E07B8EC(v9 + 4);
  int v12 = v11;
  void *v11 = v10;
  v11[1] = 0;
  void v11[2] = 0;
  v11[3] = 0;
  v11[4] = a4;
  a1[1] = a3;
  uint64_t v14 = (char *)a1[3];
  unint64_t v13 = a1[4];
  if ((unint64_t)v14 >= v13)
  {
    uint64_t v16 = (v14 - *v9) >> 3;
    if ((unint64_t)(v16 + 1) >> 61) {
      sub_19E041BEC();
    }
    uint64_t v17 = v13 - (void)*v9;
    uint64_t v18 = v17 >> 2;
    if (v17 >> 2 <= (unint64_t)(v16 + 1)) {
      uint64_t v18 = v16 + 1;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v18;
    }
    if (v19) {
      unint64_t v19 = (unint64_t)sub_19E060B48(v19);
    }
    else {
      uint64_t v20 = 0;
    }
    char v21 = (void *)(v19 + 8 * v16);
    unint64_t v22 = v19 + 8 * v20;
    void *v21 = v12;
    uint64_t v15 = (uint64_t)(v21 + 1);
    std::locale v24 = (char *)a1[2];
    char v23 = (char *)a1[3];
    if (v23 != v24)
    {
      do
      {
        uint64_t v25 = *((void *)v23 - 1);
        v23 -= 8;
        *--char v21 = v25;
      }
      while (v23 != v24);
      char v23 = *v9;
    }
    a1[2] = v21;
    a1[3] = v15;
    a1[4] = v22;
    if (v23) {
      operator delete(v23);
    }
  }
  else
  {
    *(void *)uint64_t v14 = v11;
    uint64_t v15 = (uint64_t)(v14 + 8);
  }
  a1[3] = v15;
  uint64_t v26 = a1[2];

  return sub_19E07BA3C(v26, v15, (v15 - v26) >> 3);
}

double sub_19E07B8EC(void *a1)
{
  uint64_t v1 = a1[5];
  unint64_t v2 = a1[6];
  uint64_t v3 = a1[4];
  if (v3 == v2)
  {
    uint64_t v3 = 0;
    ++v1;
    a1[4] = 0;
    a1[5] = v1;
  }
  uint64_t v4 = a1[1];
  if (v1 == (a1[2] - v4) >> 3)
  {
    is_mul_ok(v2, 0x28uLL);
    operator new[]();
  }
  uint64_t v5 = *(void *)(v4 + 8 * v1);
  a1[4] = v3 + 1;
  uint64_t v6 = v5 + 40 * v3;
  *(void *)(v6 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)uint64_t v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  return result;
}

uint64_t sub_19E07BA3C(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = (unint64_t)(a3 - 2) >> 1;
    uint64_t v4 = (void *)(result + 8 * v3);
    uint64_t v5 = *v4;
    uint64_t v8 = *(void *)(a2 - 8);
    uint64_t v6 = (void *)(a2 - 8);
    uint64_t v7 = v8;
    uint64_t v9 = *(void *)(v8 + 16);
    if (*(void *)(*v4 + 16) > v9)
    {
      do
      {
        uint64_t v10 = v4;
        void *v6 = v5;
        if (!v3) {
          break;
        }
        unint64_t v3 = (v3 - 1) >> 1;
        uint64_t v4 = (void *)(result + 8 * v3);
        uint64_t v5 = *v4;
        uint64_t v6 = v10;
      }
      while (*(void *)(*v4 + 16) > v9);
      *uint64_t v10 = v7;
    }
  }
  return result;
}

uint64_t sub_19E07BA98(char *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E94576A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E94576A0))
  {
    sub_19E0671F4((uint64_t)&unk_1E9457478);
    __cxa_atexit((void (*)(void *))sub_19E0675A8, &unk_1E9457478, &dword_19E038000);
    __cxa_guard_release(&qword_1E94576A0);
  }
  pthread_mutex_lock((pthread_mutex_t *)&unk_1E9457480);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9457470, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9457470))
  {
    __cxa_atexit(MEMORY[0x1E4FBA210], &stru_1E9457458, &dword_19E038000);
    __cxa_guard_release(&qword_1E9457470);
  }
  sub_19E069118(&stru_1E9457458, a1);

  return pthread_mutex_unlock((pthread_mutex_t *)&unk_1E9457480);
}

void sub_19E07BBA0(_Unwind_Exception *a1)
{
}

void sub_19E07BBB8(void *a1)
{
  *a1 = &unk_1EF099C90;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_19E0616BC(v1);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E07BC24(void *a1)
{
  *a1 = &unk_1EF099C90;
  unint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_19E0616BC(v2);
  }
  return a1;
}

uint64_t sub_19E07BC70()
{
  uint64_t result = ucol_strcollUTF8();
  if ((result + 1) >= 3) {
    __assert_rtn("compareInCollation", "ICUCollatorWrapper.cpp", 128, "false && \"invalid return value from ucol_strcollUTF8()\"");
  }
  return result;
}

void sub_19E07BD24(uint64_t a1@<X0>, UChar32 a2@<W1>, _WORD *a3@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    __assert_rtn("computeSortKey", "ICUCollatorWrapper.cpp", 73, "c != 0");
  }
  UChar32 src = a2;
  *(void *)pErrorCode = 0;
  u_strFromUTF32(dest, 2, (int32_t *)pErrorCode, &src, 1, &pErrorCode[1]);
  if (pErrorCode[1] >= U_ILLEGAL_ARGUMENT_ERROR)
  {
    if (qword_1E9457798 != -1) {
      dispatch_once(&qword_1E9457798, &unk_1EF09E558);
    }
    uint64_t v6 = qword_1E9457790;
    if (os_log_type_enabled((os_log_t)qword_1E9457790, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = u_errorName(pErrorCode[1]);
      *(_DWORD *)buf = 67109378;
      UChar32 v17 = a2;
      __int16 v18 = 2080;
      unint64_t v19 = v10;
      _os_log_error_impl(&dword_19E038000, v6, OS_LOG_TYPE_ERROR, "u_strFromUTF32 failed to convert %u (%s)", buf, 0x12u);
    }
    goto LABEL_7;
  }
  if (!*(void *)(a1 + 8))
  {
LABEL_7:
    *a3 = 0;
    return;
  }
  unsigned int SortKey = ucol_getSortKey();
  if (SortKey >= 9) {
    operator new[]();
  }
  if (SortKey)
  {
    unint64_t v9 = SortKey - 1;
    if (buf[v9]) {
      __assert_rtn("computeSortKey", "ICUCollatorWrapper.cpp", 110, "keyBuffer[key_len - 1] == 0");
    }
    sub_19E03E82C(a3, v9, buf, SortKey - 1);
  }
  else
  {
    if (qword_1E9457798 != -1) {
      dispatch_once(&qword_1E9457798, &unk_1EF09E558);
    }
    uint64_t v8 = qword_1E9457790;
    if (os_log_type_enabled((os_log_t)qword_1E9457790, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v14 = 67109120;
      UErrorCode v15 = pErrorCode[0];
      _os_log_error_impl(&dword_19E038000, v8, OS_LOG_TYPE_ERROR, "ucol_getSortKey failed compute collation key of string (len=%d)", v14, 8u);
    }
    *a3 = 0;
  }
}

void sub_19E07BFD4(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA6E0](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t sub_19E07C00C(uint64_t (***a1)(void, unsigned __int16 *, void), unsigned __int16 *a2)
{
  unint64_t v2 = (unsigned __int16 *)*((void *)a2 + 1);
  if (!v2) {
    unint64_t v2 = a2 + 8;
  }
  return (**a1)(a1, v2, *a2);
}

void sub_19E07C048(uint64_t a1@<X0>, const char *a2@<X1>, uint64_t a3@<X2>, _WORD *a4@<X8>)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    *a4 = 0;
    return;
  }
  int32_t v5 = a3;
  sub_19E07C428(&dest, a3);
  *(void *)pErrorCode = 0;
  u_strFromUTF8(dest, (unint64_t)((char *)v33 - (char *)dest) >> 1, (int32_t *)pErrorCode, a2, v5, &pErrorCode[1]);
  UErrorCode v8 = pErrorCode[1];
  if (pErrorCode[1] == U_BUFFER_OVERFLOW_ERROR)
  {
    uint64_t v9 = pErrorCode[0];
    uint64_t v10 = v33;
    unint64_t v11 = v33 - dest;
    if ((int)pErrorCode[0] <= v11)
    {
      if ((int)pErrorCode[0] >= v11)
      {
LABEL_21:
        pErrorCode[1] = U_ZERO_ERROR;
        u_strFromUTF8(dest, (unint64_t)((char *)v10 - (char *)dest) >> 1, (int32_t *)pErrorCode, a2, v5, &pErrorCode[1]);
        UErrorCode v8 = pErrorCode[1];
        goto LABEL_22;
      }
      uint64_t v10 = &dest[pErrorCode[0]];
    }
    else
    {
      unint64_t v12 = (int)pErrorCode[0] - v11;
      if (v12 > (v34 - (char *)v33) >> 1)
      {
        if (pErrorCode[0] < 0) {
          sub_19E041BEC();
        }
        if (v34 - (char *)dest > (unint64_t)(int)pErrorCode[0]) {
          uint64_t v9 = v34 - (char *)dest;
        }
        if ((unint64_t)(v34 - (char *)dest) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v13 = v9;
        }
        uint64_t v14 = (char *)sub_19E063B88(v13);
        UErrorCode v15 = dest;
        uint64_t v16 = v33;
        UChar32 v17 = &v14[2 * v11];
        unint64_t v19 = &v14[2 * v18];
        bzero(v17, 2 * v12);
        uint64_t v10 = (UChar *)&v17[2 * v12];
        while (v16 != v15)
        {
          __int16 v20 = *--v16;
          *((_WORD *)v17 - 1) = v20;
          v17 -= 2;
        }
        dest = (UChar *)v17;
        unsigned int v33 = v10;
        int v34 = v19;
        if (v15)
        {
          operator delete(v15);
          uint64_t v10 = v33;
        }
        goto LABEL_21;
      }
      bzero(v33, 2 * v12);
      v10 += v12;
    }
    unsigned int v33 = v10;
    goto LABEL_21;
  }
LABEL_22:
  if (v8 < U_ILLEGAL_ARGUMENT_ERROR)
  {
    if ((int)pErrorCode[0] > (unint64_t)(v33 - dest)) {
      __assert_rtn("computeSortKey", "ICUCollatorWrapper.cpp", 40, "ustr_len <= ustr.size()");
    }
    if (*(void *)(a1 + 8))
    {
      std::string __p = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      if (pErrorCode[0])
      {
        size_t v21 = 3 * (int)pErrorCode[0];
        sub_19E05B210(&__p, v21);
        unint64_t v22 = (char *)v29 + v21;
        bzero(v29, v21);
        uint64_t v29 = v22;
      }
      unsigned int SortKey = ucol_getSortKey();
      if (SortKey > (unint64_t)((unsigned char *)v29 - (unsigned char *)__p))
      {
        sub_19E07C4B4((unint64_t *)&__p, SortKey - ((unsigned char *)v29 - (unsigned char *)__p));
        unsigned int SortKey = ucol_getSortKey();
      }
      if (SortKey)
      {
        if ((unsigned char *)v29 - (unsigned char *)__p < (unint64_t)SortKey)
        {
          uint64_t v26 = "key_len <= key.size()";
          int v27 = 60;
        }
        else
        {
          unint64_t v24 = SortKey - 1;
          if (!*((unsigned char *)__p + v24))
          {
            sub_19E03E82C(a4, v24, __p, v24);
LABEL_42:
            if (__p)
            {
              uint64_t v29 = __p;
              operator delete(__p);
            }
            goto LABEL_24;
          }
          uint64_t v26 = "key[key_len - 1] == 0";
          int v27 = 61;
        }
        __assert_rtn("computeSortKey", "ICUCollatorWrapper.cpp", v27, v26);
      }
      if (qword_1E9457798 != -1) {
        dispatch_once(&qword_1E9457798, &unk_1EF09E558);
      }
      uint64_t v25 = qword_1E9457790;
      if (os_log_type_enabled((os_log_t)qword_1E9457790, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        UErrorCode v36 = pErrorCode[0];
        _os_log_error_impl(&dword_19E038000, v25, OS_LOG_TYPE_ERROR, "ucol_getSortKey failed compute collation key of string (len=%d)", buf, 8u);
      }
      *a4 = 0;
      goto LABEL_42;
    }
  }
  *a4 = 0;
LABEL_24:
  if (dest)
  {
    unsigned int v33 = dest;
    operator delete(dest);
  }
}

void sub_19E07C3E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E07C428(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 < 0) {
      sub_19E041BEC();
    }
    uint64_t v4 = (char *)sub_19E063B88(a2);
    *a1 = v4;
    a1[2] = &v4[2 * v5];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_19E07C498(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + ++**(_DWORD **)(result + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E07C4B4(unint64_t *a1, size_t a2)
{
  uint64_t v5 = (char *)a1[1];
  uint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      sub_19E041BEC();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    unint64_t v12 = &v7[v11];
    uint64_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      uint64_t v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      uint64_t v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_19E07C5F0(uint64_t a1)
{
  sub_19E07D4F0((const void **)(a1 + 136), 0);
  sub_19E0782A0((const void **)(a1 + 128), 0);
  uint64_t v5 = (void **)(a1 + 104);
  sub_19E07D528(&v5);
  uint64_t v5 = (void **)(a1 + 80);
  sub_19E076F34(&v5);
  unint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  unint64_t v3 = *(void **)(a1 + 32);
  if (v3)
  {
    *(void *)(a1 + 4sub_19E03D880(&a9, 0) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    *(void *)(a1 + 16) = v4;
    operator delete(v4);
  }

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E07C6A4(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 14352);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_1EF09D258[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 14352) = -1;
  return a1;
}

void sub_19E07C700(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 1488);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 1472);
  *(void *)(a2 + 1472) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 1464);
  *(void *)(a2 + 1464) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 8++**(_DWORD **)(result + 8) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 1440);
  if (v6 && *(unsigned char *)(a2 + 1438) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1384);
  *(void *)(a2 + 4sub_19E03D880(&a9, 0) = &unk_1EF09F270;
  sub_19E06E0C4((uint64_t *)(a2 + 48), 0);
  sub_19E06DF34((void *)(a2 + 56));
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07C820(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 1504);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 1488);
  *(void *)(a2 + 148++**(_DWORD **)(result + 8) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 1480);
  *(void *)(a2 + 148sub_19E03D880(&a9, 0) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 104) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 1456);
  if (v6 && *(unsigned char *)(a2 + 1454) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1400);
  sub_19E10410C((void *)(a2 + 40));
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07C914(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 1504);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 1488);
  *(void *)(a2 + 148++**(_DWORD **)(result + 8) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 1480);
  *(void *)(a2 + 148sub_19E03D880(&a9, 0) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 104) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 1456);
  if (v6 && *(unsigned char *)(a2 + 1454) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1400);
  sub_19E1033E4((void *)(a2 + 40));
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07CA08(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 2048);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 2032);
  *(void *)(a2 + 2032) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 2024);
  *(void *)(a2 + 2024) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 64++**(_DWORD **)(result + 8) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 2000);
  if (v6 && *(unsigned char *)(a2 + 1998) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1944);
  sub_19E101020((void *)(a2 + 40));
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07CAFC(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 1480);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 1464);
  *(void *)(a2 + 1464) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 1456);
  *(void *)(a2 + 1456) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 8sub_19E03D880(&a9, 0) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 1432);
  if (v6 && *(unsigned char *)(a2 + 1430) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1376);
  sub_19E0FF618((void *)(a2 + 40));
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07CBF0(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 1544);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 1528);
  *(void *)(a2 + 152++**(_DWORD **)(result + 8) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 1520);
  *(void *)(a2 + 152sub_19E03D880(&a9, 0) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 144) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 1496);
  if (v6 && *(unsigned char *)(a2 + 1494) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1440);
  *(void *)(a2 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A1760;
  sub_19E0CA6D4(a2 + 48);
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07CD04(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 1520);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 1504);
  *(void *)(a2 + 1504) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 1496);
  *(void *)(a2 + 1496) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 12sub_19E03D880(&a9, 0) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 1472);
  if (v6 && *(unsigned char *)(a2 + 1470) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1416);
  *(void *)(a2 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A1508;
  sub_19E0672C4(*(char **)(a2 + 104));
  *(void *)(a2 + 4++**(_DWORD **)(result + 8) = &unk_1EF09B9F0;
  sub_19E06E0C4((uint64_t *)(a2 + 56), 0);
  sub_19E06DF34((void *)(a2 + 64));
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07CE4C(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 1536);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 1520);
  *(void *)(a2 + 152sub_19E03D880(&a9, 0) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 1512);
  *(void *)(a2 + 1512) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 136) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 1488);
  if (v6 && *(unsigned char *)(a2 + 1486) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1432);
  *(void *)(a2 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A1288;
  sub_19E0672C4(*(char **)(a2 + 120));
  sub_19E0C2DB0((void *)(a2 + 48));
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07CF68(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 1536);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 1520);
  *(void *)(a2 + 152sub_19E03D880(&a9, 0) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 1512);
  *(void *)(a2 + 1512) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 136) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 1488);
  if (v6 && *(unsigned char *)(a2 + 1486) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1432);
  *(void *)(a2 + 4sub_19E03D880(&a9, 0) = &unk_1EF099BA8;
  sub_19E0672C4(*(char **)(a2 + 120));
  sub_19E0B3FD0((void *)(a2 + 48));
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07D084(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 2080);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 2064);
  *(void *)(a2 + 2064) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 2056);
  *(void *)(a2 + 2056) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 68sub_19E03D880(&a9, 0) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 2032);
  if (v6 && *(unsigned char *)(a2 + 2030) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1976);
  *(void *)(a2 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A0DA8;
  sub_19E0672C4(*(char **)(a2 + 664));
  sub_19E0B76A4((void *)(a2 + 48));
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07D1A0(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 1576);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 1560);
  *(void *)(a2 + 156sub_19E03D880(&a9, 0) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 1552);
  *(void *)(a2 + 1552) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 176) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 1528);
  if (v6 && *(unsigned char *)(a2 + 1526) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1472);
  *(void *)(a2 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A0328;
  sub_19E0672C4(*(char **)(a2 + 160));
  *(void *)(a2 + 4++**(_DWORD **)(result + 8) = &unk_1EF0A0400;
  sub_19E0CA6D4(a2 + 56);
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07D2DC(uint64_t a1, uint64_t a2)
{
  sub_19E0FD62C(a2);
  unint64_t v3 = *(std::__shared_weak_count **)(a2 + 1512);
  if (v3) {
    sub_19E0616BC(v3);
  }
  uint64_t v4 = *(void *)(a2 + 1496);
  *(void *)(a2 + 1496) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 1488);
  *(void *)(a2 + 148++**(_DWORD **)(result + 8) = 0;
  if (v5) {
    sub_19E0DF24C(v5);
  }
  *(void *)(a2 + 112) = &unk_1EF09C8E8;
  unint64_t v6 = *(void **)(a2 + 1464);
  if (v6 && *(unsigned char *)(a2 + 1462) == 1) {
    free(v6);
  }
  sub_19E03A444(a2 + 1408);
  *(void *)(a2 + 4sub_19E03D880(&a9, 0) = &unk_1EF0A0868;
  sub_19E0672C4(*(char **)(a2 + 96));
  sub_19E0C2E10((void *)(a2 + 48));
  uint64_t v7 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  if (v7) {
    sub_19E0D054C(v7);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v8)
  {
    sub_19E0D054C(v8);
  }
}

void sub_19E07D3F8(uint64_t a1, uint64_t a2)
{
  v3.n128_f64[0] = sub_19E03A4E4(a2);
  uint64_t v4 = *(std::__shared_weak_count **)(a2 + 14344);
  if (v4) {
    sub_19E0616BC(v4);
  }
  uint64_t v5 = *(void *)(a2 + 14320);
  *(void *)(a2 + 1432sub_19E03D880(&a9, 0) = 0;
  if (v5) {
    (*(void (**)(uint64_t, __n128))(*(void *)v5 + 8))(v5, v3);
  }
  uint64_t v6 = *(void *)(a2 + 14312);
  *(void *)(a2 + 14312) = 0;
  if (v6) {
    sub_19E0DF24C(v6);
  }
  *(void *)(a2 + 1292sub_19E03D880(&a9, 0) = &unk_1EF09C8E8;
  uint64_t v7 = *(void **)(a2 + 14272);
  if (v7 && *(unsigned char *)(a2 + 14270) == 1) {
    free(v7);
  }
  sub_19E03A444(a2 + 14216);
  uint64_t v8 = *(void *)(a2 + 8);
  *(void *)(a2 + ++**(_DWORD **)(result + 8) = 0;
  if (v8) {
    sub_19E0D054C(v8);
  }
  uint64_t v9 = *(void *)a2;
  *(void *)a2 = 0;
  if (v9)
  {
    sub_19E0D054C(v9);
  }
}

void sub_19E07D4F0(const void **a1, const void *a2)
{
  uint64_t v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  *a1 = a2;
}

void sub_19E07D528(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (unsigned __int16 *)**a1;
  if (v2)
  {
    uint64_t v4 = (unsigned __int16 *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (unsigned __int16 *)v1[1];
      do
      {
        unsigned int v7 = *(v6 - 8);
        v6 -= 8;
        if (v7 >= 0xF)
        {
          uint64_t v8 = *((void *)v4 - 1);
          if (v8) {
            MEMORY[0x19F3BA6E0](v8, 0x1000C8077774924);
          }
        }
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_19E07D5D0()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA4F0] + 16;
  __cxa_throw(exception, MEMORY[0x1E4FBA340], (void (*)(void *))std::exception::~exception);
}

void sub_19E07D61C(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D624(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D62C(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D634(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D63C(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D644(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D64C(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D654(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D65C(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D664(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D66C(uint64_t a1, uint64_t a2)
{
}

void sub_19E07D674(uint64_t a1, uint64_t a2)
{
}

double sub_19E07D67C(uint64_t a1, uint64_t a2)
{
  return sub_19E03A4E4(a2);
}

uint64_t sub_19E07D688(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 14352);
  if (v1 == -1
    || (unint64_t v12 = &v11,
        ((void (*)(char **, uint64_t))off_1EF09D7A0[v1])(&v12, a1),
        uint64_t v3 = *(unsigned int *)(a1 + 28712),
        v3 == -1))
  {
    sub_19E07D5D0();
  }
  unint64_t v12 = &v11;
  ((void (*)(char **, uint64_t))off_1EF09D7A0[v3])(&v12, a1 + 14360);
  sub_19E03A3C0(a1 + 28744);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 28728);
  *(_OWORD *)(a1 + 2872sub_19E03D880(&a9, 0) = 0u;
  if (v4) {
    sub_19E0616BC(v4);
  }
  uint64_t v5 = *(void *)(a1 + 30120);
  *(void *)(a1 + 3012sub_19E03D880(&a9, 0) = 0;
  if (v5)
  {
    sub_19E07C5F0(v5);
    uint64_t v6 = *(void *)(a1 + 30120);
    *(void *)(a1 + 3012sub_19E03D880(&a9, 0) = 0;
    if (v6) {
      sub_19E07C5F0(v6);
    }
  }
  else
  {
    *(void *)(a1 + 3012sub_19E03D880(&a9, 0) = 0;
  }
  *(void *)(a1 + 28744) = &unk_1EF09C8E8;
  unsigned int v7 = *(void **)(a1 + 30096);
  if (v7 && *(unsigned char *)(a1 + 30094) == 1) {
    free(v7);
  }
  sub_19E03A444(a1 + 30040);
  uint64_t v8 = *(void *)(a1 + 28736);
  *(void *)(a1 + 28736) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 28728);
  if (v9) {
    sub_19E0616BC(v9);
  }
  sub_19E07C6A4(a1 + 14360);

  return sub_19E07C6A4(a1);
}

uint64_t sub_19E07D808(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 14352);
  if (v1 == -1) {
    sub_19E07D5D0();
  }
  uint64_t v4 = &v3;
  return ((uint64_t (*)(char **, uint64_t))off_1EF09D600[v1])(&v4, a1);
}

double sub_19E07D854@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0FD558(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07D9F4(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07DA18@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0FC8C4(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07DBB8(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07DBDC@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0FC8C4(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07DD7C(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07DDA0@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0FBEC0(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07DF40(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07DF64@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0FB748(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07E104(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07E128@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0FB088(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07E2C8(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07E2EC@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0FA9C0(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07E48C(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07E4B0@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0F9ED0(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07E650(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07E674@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0F9ED0(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07E814(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07E838@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0F9774(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07E9D8(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07E9FC@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0F90B0(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07EB9C(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07EBC0@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)a2) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 20) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 12);
  if (!v8) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 654, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 24);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  double result = sub_19E0F8A70(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "LXWordTrie.cpp", 670, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07ED60(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_19E07ED84@<D0>(unsigned int **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(unsigned char *)(a2 + 20)) {
    goto LABEL_31;
  }
  int v4 = *(_DWORD *)(a2 + 12904);
  if ((v4 & 0x10000) == 0) {
    goto LABEL_31;
  }
  unsigned int v5 = **a1;
  unsigned int v6 = *(_DWORD *)(a2 + 14304);
  int v7 = v5 - v6;
  if (v5 < v6 || *(_DWORD *)(a2 + 14308) + v6 <= v5) {
    goto LABEL_31;
  }
  int v8 = *(_DWORD *)(a2 + 14300);
  if (!v8) {
    __assert_rtn("word_with_id", "TIWordTrie.cpp", 878, "m_word_id_map_offset > 0");
  }
  if ((v4 & 0x20000) != 0) {
    int v9 = 4;
  }
  else {
    int v9 = 3;
  }
  unint64_t v10 = (v8 + v7 * v9);
  char v11 = *(uint64_t **)(a2 + 8);
  uint64_t v12 = *v11;
  unint64_t v13 = v11[1];
  if ((v4 & 0x20000) != 0)
  {
    if (v13 >= v10)
    {
      if (v10 + 4 > v13 && v13 != 0 || v12 == 0) {
        goto LABEL_31;
      }
      unsigned int v16 = bswap32(*(_DWORD *)(v12 + v10));
      goto LABEL_28;
    }
LABEL_34:
    __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
  }
  if (v13 < v10) {
    goto LABEL_34;
  }
  if (v10 + 3 > v13 && v13 != 0 || v12 == 0) {
    goto LABEL_31;
  }
  unsigned int v16 = (*(unsigned __int8 *)(v12 + v10) << 16) | (*(unsigned __int8 *)(v12 + v10 + 1) << 8) | *(unsigned __int8 *)(v12 + v10 + 2);
LABEL_28:
  if (!v16)
  {
LABEL_31:
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 4++**(_DWORD **)(result + 8) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(void *)(a3 + 8sub_19E03D880(&a9, 0) = 0;
    *(_WORD *)(a3 + 2) = 16;
    *(unsigned char *)(a3 + 6) = 0;
    *(unsigned char *)(a3 + 16) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 37) = 0;
    *(void *)(a3 + 4++**(_DWORD **)(result + 8) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)&double result = 0xFFFFFFFFLL;
    *(void *)(a3 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a3 + 76) = 0;
    return result;
  }
  v20[0] = 0;
  sub_19E0DF140(a3, a2, v16, &v21, v20);
  if (*(_DWORD *)(a3 + 60) != v5) {
    __assert_rtn("word_with_id", "TIWordTrie.cpp", 893, "result.word_id() == word_id");
  }
  return result;
}

void sub_19E07EF24(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E07EF48(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EF50(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EF58(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EF60(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EF68(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EF70(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EF78(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EF80(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EF88(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EF90(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EF98(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EFA0(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

uint64_t sub_19E07EFA8(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a2 + 20);
}

uint64_t sub_19E07EFB0(unsigned __int16 *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v5 = a4;
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  if (!a5)
  {
    uint64_t v46 = *(unsigned int *)(a4 + 14352);
    if (v46 != -1)
    {
      v60[0] = v59;
      ((void (*)(void ***__return_ptr, void **, uint64_t))off_1EF09D328[v46])(&v64, v60, a4);
      v60[0] = &v64;
      v60[1] = a2;
      int v61 = 0;
      uint64_t v47 = *(unsigned int *)(v5 + 14352);
      if (v47 == -1
        || (*(void *)&v59[0] = v60,
            ((void (*)(_OWORD *, uint64_t))off_1EF09D598[v47])(v59, v5),
            v66 == -1))
      {
        sub_19E07D5D0();
      }
      v60[0] = v59;
      if (((unsigned int (*)(void **, void ***))off_1EF09D390[v66])(v60, &v64)) {
        uint64_t v39 = sub_19E07F8C4(a1, (void **)&v64, a2, v5);
      }
      else {
        uint64_t v39 = 0;
      }
      unint64_t v48 = (void **)&v64;
      goto LABEL_88;
    }
LABEL_93:
    sub_19E07D5D0();
  }
  uint64_t v8 = *(unsigned int *)(a4 + 14352);
  if (v8 == -1) {
    goto LABEL_93;
  }
  char v64 = (void **)v59;
  ((void (*)(void **__return_ptr, void ***, uint64_t))off_1EF09D328[v8])(v60, &v64, a4);
  std::string::size_type v50 = (unsigned __int16 *)a2;
  uint64_t v51 = a1;
  memset(v59, 0, 24);
  uint64_t v11 = *(unsigned __int16 *)a2;
  if (v11 <= 0xE) {
    uint64_t v12 = a2 + 2;
  }
  else {
    uint64_t v12 = (unsigned __int8 *)*((void *)a2 + 1);
  }
  if (*(_WORD *)a2)
  {
    char v13 = 0;
    uint64_t v52 = &v12[v11];
    uint64_t v53 = v5;
    do
    {
      uint64_t v14 = *v12;
      uint64_t v15 = *((void *)&v59[0] + 1);
      uint64_t v16 = *(void *)&v59[0];
      if (*(void *)&v59[0] != *((void *)&v59[0] + 1))
      {
        do
        {
          sub_19E0DA108(v16, a3, v14);
          v16 += 96;
        }
        while (v16 != v15);
        uint64_t v17 = *((void *)&v59[0] + 1);
        uint64_t v16 = *(void *)&v59[0];
        if (*(void *)&v59[0] != *((void *)&v59[0] + 1))
        {
          while (sub_19E0DA1A4(v16))
          {
            v16 += 96;
            if (v16 == v17)
            {
              uint64_t v16 = v17;
              goto LABEL_20;
            }
          }
          if (v16 != v17)
          {
            for (uint64_t i = v16 + 96; i != v17; i += 96)
            {
              if (sub_19E0DA1A4(i))
              {
                sub_19E0D8810(v16, i);
                v16 += 96;
              }
            }
          }
        }
      }
LABEL_20:
      uint64_t v19 = *((void *)&v59[0] + 1);
      if (v16 != *((void *)&v59[0] + 1))
      {
        while (v19 != v16)
        {
          v19 -= 96;
          sub_19E080648(v19);
        }
        *((void *)&v59[0] + 1) = v16;
      }
      uint64_t v5 = v53;
      if (v62 == -1) {
        goto LABEL_89;
      }
      char v64 = (void **)&v56;
      if (((unsigned int (*)(void ***, void **))off_1EF09D390[v62])(&v64, v60))
      {
        char v64 = v60;
        v65[0] = v14;
        uint64_t v20 = *(unsigned int *)(v53 + 14352);
        if (v20 == -1) {
          goto LABEL_89;
        }
        v56.n128_u64[0] = (unint64_t)&v64;
        ((void (*)(__n128 *, uint64_t))off_1EF09D3F8[v20])(&v56, v53);
      }
      v56.n128_u64[0] = (unint64_t)v60;
      uint64_t v21 = *(unsigned int *)(v53 + 14352);
      if (v21 == -1) {
LABEL_89:
      }
        sub_19E07D5D0();
      char v64 = (void **)&v56;
      ++v13;
      if (((unsigned int (*)(void ***, uint64_t))off_1EF09D460[v21])(&v64, v53))
      {
        v56.n128_u16[0] = 1;
        v56.n128_u8[2] = 32;
        char v64 = v60;
        *(void *)uint64_t v65 = &v56;
        uint64_t v22 = *(unsigned int *)(v53 + 14352);
        if (v22 == -1) {
          sub_19E07D5D0();
        }
        uint64_t v63 = (void **)&v64;
        ((void (*)(uint64_t *__return_ptr, void ***, uint64_t))off_1EF09D4C8[v22])(&v57, &v63, v53);
        if (v56.n128_u16[0] >= 0xFu && v56.n128_u64[1]) {
          MEMORY[0x19F3BA6E0](v56.n128_u64[1], 0x1000C8077774924);
        }
        uint64_t v24 = v57;
        uint64_t v23 = v58;
        if (v57 != v58)
        {
          uint64_t v54 = v58;
          do
          {
            LODWORD(v63) = 0;
            if (sub_19E0A3620(a5, *(_DWORD *)(v24 + 60), &v63, 0))
            {
              sub_19E0A379C(&v56, (uint64_t)a5, (int)v63);
              if (v56.n128_u16[0])
              {
                uint64_t v25 = *((void *)&v59[0] + 1);
                if (*((void *)&v59[0] + 1) >= *(void *)&v59[1])
                {
                  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v59[0] + 1) - *(void *)&v59[0]) >> 5);
                  unint64_t v28 = v27 + 1;
                  if (v27 + 1 > 0x2AAAAAAAAAAAAAALL) {
                    sub_19E041BEC();
                  }
                  if (0x5555555555555556 * ((uint64_t)(*(void *)&v59[1] - *(void *)&v59[0]) >> 5) > v28) {
                    unint64_t v28 = 0x5555555555555556 * ((uint64_t)(*(void *)&v59[1] - *(void *)&v59[0]) >> 5);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v59[1] - *(void *)&v59[0]) >> 5) >= 0x155555555555555) {
                    unint64_t v29 = 0x2AAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v29 = v28;
                  }
                  uint64_t v66 = &v59[1];
                  if (v29)
                  {
                    if (v29 > 0x2AAAAAAAAAAAAAALL) {
                      sub_19E0416C4();
                    }
                    uint64_t v30 = (void **)operator new(96 * v29);
                  }
                  else
                  {
                    uint64_t v30 = 0;
                  }
                  char v64 = v30;
                  *(void *)uint64_t v65 = &v30[12 * v27];
                  *(void *)&v65[8] = *(void *)v65;
                  *(void *)&v65[16] = &v30[12 * v29];
                  sub_19E0D85E8(*(uint64_t *)v65, a3, (uint64_t)v60, v13, 0, (uint64_t)&v56, 0.0);
                  uint64_t v31 = *(void *)v65;
                  *(void *)&v65[8] += 96;
                  long long v32 = v59[0];
                  for (uint64_t j = 96; ; j -= 96)
                  {
                    uint64_t v34 = v31 + j;
                    if (*((void *)&v32 + 1) + j - 96 == (void)v32) {
                      break;
                    }
                    uint64_t v35 = *((void *)&v32 + 1) + j - 192;
                    sub_19E0D870C(v34 - 192, v35);
                  }
                  uint64_t v36 = *(void *)&v59[1];
                  uint64_t v55 = *(void *)&v65[8];
                  long long v37 = *(_OWORD *)&v65[8];
                  long long v38 = v59[0];
                  *(void *)&v59[0] = v34 - 96;
                  *(_OWORD *)uint64_t v65 = v38;
                  *(_OWORD *)((char *)v59 + ++**(_DWORD **)(result + 8) = v37;
                  *(void *)&v65[16] = v36;
                  char v64 = (void **)v38;
                  sub_19E080700((uint64_t)&v64);
                  uint64_t v26 = v55;
                  uint64_t v23 = v54;
                }
                else
                {
                  sub_19E0D85E8(*((uint64_t *)&v59[0] + 1), a3, (uint64_t)v60, v13, 0, (uint64_t)&v56, 0.0);
                  uint64_t v26 = v25 + 96;
                }
                *((void *)&v59[0] + 1) = v26;
                if (v56.n128_u16[0] >= 0xFu && v56.n128_u64[1]) {
                  MEMORY[0x19F3BA6E0](v56.n128_u64[1], 0x1000C8077774924);
                }
              }
            }
            v24 += 88;
          }
          while (v24 != v23);
        }
        char v64 = (void **)&v57;
        sub_19E07F830(&v64);
        uint64_t v5 = v53;
      }
      ++v12;
    }
    while (v12 != v52);
  }
  if (v62 == -1) {
    sub_19E07D5D0();
  }
  char v64 = (void **)&v56;
  if (!((unsigned int (*)(void ***, void **))off_1EF09D390[v62])(&v64, v60)
    || (uint64_t v39 = sub_19E07F8C4(v51, v60, v50, v5), !v39))
  {
    uint64_t v40 = *((void *)&v59[0] + 1);
    uint64_t v41 = *(void *)&v59[0];
    if (*(void *)&v59[0] == *((void *)&v59[0] + 1))
    {
LABEL_78:
      uint64_t v39 = 0;
    }
    else
    {
      while ((sub_19E0DA1A4(v41) & 1) == 0)
      {
LABEL_77:
        v41 += 96;
        if (v41 == v40) {
          goto LABEL_78;
        }
      }
      sub_19E0DBD60(&v57, v41, a3, v50);
      uint64_t v42 = v57;
      uint64_t v43 = v58;
      while (1)
      {
        if (v42 == v43)
        {
          char v64 = (void **)&v57;
          sub_19E07F830(&v64);
          goto LABEL_77;
        }
        sub_19E08E71C((uint64_t)&v64, (unsigned __int16 *)v42);
        BOOL v44 = sub_19E0B2428((unsigned __int16 *)&v64, v51);
        if (*(void *)v65 && BYTE6(v64) == 1) {
          free(*(void **)v65);
        }
        if (v44) {
          break;
        }
        v42 += 88;
      }
      uint64_t v39 = *(unsigned int *)(v42 + 60);
      char v64 = (void **)&v57;
      sub_19E07F830(&v64);
    }
  }
  char v64 = (void **)v59;
  sub_19E07F9E8(&v64);
  unint64_t v48 = v60;
LABEL_88:
  sub_19E07FA6C((uint64_t)v48);
  return v39;
}

void sub_19E07F704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void **a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  a20 = (void **)&a23;
  sub_19E07F9E8(&a20);
  sub_19E07FA6C((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_19E07F830(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    int v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unsigned int v6 = (void *)*((void *)v4 - 10);
        if (v6 && *(v4 - 82) == 1) {
          free(v6);
        }
        v4 -= 88;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_19E07F8C4(unsigned __int16 *a1, void **a2, void *a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t v15 = a3;
  uint64_t v4 = *(unsigned int *)(a4 + 14352);
  if (v4 == -1) {
    sub_19E07D5D0();
  }
  char v13 = &v14;
  ((void (*)(void *__return_ptr, void ****, uint64_t))off_1EF09D4C8[v4])(v12, &v13, a4);
  uint64_t v6 = v12[0];
  uint64_t v7 = v12[1];
  while (1)
  {
    if (v6 == v7)
    {
      uint64_t v10 = 0;
      goto LABEL_14;
    }
    sub_19E08E71C((uint64_t)&v14, (unsigned __int16 *)v6);
    BOOL v8 = sub_19E0B2428((unsigned __int16 *)&v14, a1);
    if (v15 && BYTE6(v14) == 1) {
      free(v15);
    }
    if (v8) {
      break;
    }
    v6 += 88;
  }
  uint64_t v10 = *(unsigned int *)(v6 + 60);
LABEL_14:
  uint64_t v14 = (void **)v12;
  sub_19E07F830(&v14);
  return v10;
}

void sub_19E07F9C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
}

void sub_19E07F9E8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 96;
        sub_19E080648(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_19E07FA6C(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_1EF09D530[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 32) = -1;
  return a1;
}

float sub_19E07FAC8(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 12) {
    sub_19E07D5D0();
  }
  char v4 = (unsigned __int16 *)v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(_DWORD *)(v3 + 12) != -1 && v5 < v6; ++v5)
  {
    if (*v4 <= 0xEu) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
    sub_19E0FD0A8(v3, a2, *((unsigned char *)v10 + v5));
    float i = i * 0.0;
  }
  return i;
}

float sub_19E07FBA4(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 11) {
    sub_19E07D5D0();
  }
  char v4 = (unsigned __int16 *)v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(void *)v3 != -1 && v5 < v6; ++v5)
  {
    if (*v4 <= 0xEu) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
    sub_19E0FB3A4((void *)v3, *(void *)(a2 + 64), *((unsigned __int8 *)v10 + v5));
    float i = i * 0.0;
  }
  return i;
}

float sub_19E07FC80(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 10) {
    sub_19E07D5D0();
  }
  char v4 = (unsigned __int16 *)v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(void *)v3 != 0xFFFFFFFFLL && v5 < v6; ++v5)
  {
    if (*v4 <= 0xEu) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
    sub_19E0FC260((uint64_t *)v3, a2, *((unsigned char *)v10 + v5));
    float i = i * 0.0;
  }
  return i;
}

float sub_19E07FD6C(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 9) {
    sub_19E07D5D0();
  }
  char v4 = (unsigned __int16 *)v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(void *)v3 != -1 && v5 < v6; ++v5)
  {
    if (*v4 <= 0xEu) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
    sub_19E0FBA5C((unint64_t *)v3, a2, *((unsigned char *)v10 + v5));
    float i = i * 0.0;
  }
  return i;
}

float sub_19E07FE48(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 8) {
    sub_19E07D5D0();
  }
  char v4 = (unsigned __int16 *)v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(void *)v3 != -1 && v5 < v6; ++v5)
  {
    if (*v4 <= 0xEu) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
    sub_19E0FB3A4((void *)v3, *(void *)(a2 + 64), *((unsigned __int8 *)v10 + v5));
    float i = i * 0.0;
  }
  return i;
}

float sub_19E07FF24(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 7) {
    sub_19E07D5D0();
  }
  char v4 = (unsigned __int16 *)v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(void *)v3 != -1 && v5 < v6; ++v5)
  {
    if (*v4 <= 0xEu) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
    sub_19E0FACD4((uint64_t *)v3, a2, *((unsigned char *)v10 + v5));
    float i = i * 0.0;
  }
  return i;
}

float sub_19E080000(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 6) {
    sub_19E07D5D0();
  }
  char v4 = (unsigned __int16 *)v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(_DWORD *)(v3 + 12) != -1 && v5 < v6; float i = i * sub_19E0FA690(v3, a2, *((unsigned char *)v10 + v5++)))
  {
    if (*v4 <= 0xEu) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
  }
  return i;
}

float sub_19E0800D8(unsigned int ***a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (v3[8] != 5) {
    sub_19E07D5D0();
  }
  char v4 = v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *(unsigned __int16 *)v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(void *)v3 != -1 && v5 < v6; ++v5)
  {
    if (*(unsigned __int16 *)v4 <= 0xEu) {
      uint64_t v10 = (unsigned __int16 *)v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
    sub_19E0F875C(v3, a2, *((unsigned __int8 *)v10 + v5));
    float i = i * v11;
  }
  return i;
}

float sub_19E0801B0(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 4) {
    sub_19E07D5D0();
  }
  char v4 = (unsigned __int16 *)v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(void *)v3 != 0xFFFFFFFFLL && v5 < v6; float i = i * sub_19E0F99F8(v3, a2, *((unsigned char *)v10 + v5++)))
  {
    if (*v4 <= 0xEu) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
  }
  return i;
}

float sub_19E080298(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 3) {
    sub_19E07D5D0();
  }
  char v4 = (unsigned __int16 *)v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(void *)v3 != -1 && v5 < v6; float i = i
                                                     * sub_19E0F9448((unint64_t *)v3, a2, *((unsigned char *)v10 + v5++)))
  {
    if (*v4 <= 0xEu) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
  }
  return i;
}

float sub_19E080370(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 2) {
    sub_19E07D5D0();
  }
  char v4 = (unsigned __int16 *)v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(void *)v3 != -1 && v5 < v6; float i = i * sub_19E0F8D84((uint64_t *)v3, a2, *((unsigned char *)v10 + v5++)))
  {
    if (*v4 <= 0xEu) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
  }
  return i;
}

float sub_19E080448(unsigned int ***a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (v3[8] != 1) {
    sub_19E07D5D0();
  }
  char v4 = v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *(unsigned __int16 *)v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "LXWordTrie.cpp", 71, "from_depth <= to_depth");
  }
  for (float i = 1.0; *(void *)v3 != -1 && v5 < v6; ++v5)
  {
    if (*(unsigned __int16 *)v4 <= 0xEu) {
      uint64_t v10 = (unsigned __int16 *)v4 + 1;
    }
    else {
      uint64_t v10 = (unsigned __int16 *)*((void *)v4 + 1);
    }
    sub_19E0F875C(v3, a2, *((unsigned __int8 *)v10 + v5));
    float i = i * v11;
  }
  return i;
}

float sub_19E080520(unsigned int ***a1, uint64_t **a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  if (v3[8]) {
    sub_19E07D5D0();
  }
  char v4 = v2[1];
  uint64_t v5 = *((int *)v2 + 4);
  uint64_t v6 = *(unsigned __int16 *)v4;
  if ((int)v5 > (int)v6) {
    __assert_rtn("advance_to_sort_key", "TIWordTrie.cpp", 220, "from_depth <= to_depth");
  }
  float v7 = 1.0;
  if ((*(char *)v3 & 0x80000000) == 0 && (int)v5 < (int)v6)
  {
    do
    {
      if (*(unsigned __int16 *)v4 <= 0xEu) {
        int v9 = (unsigned __int16 *)v4 + 1;
      }
      else {
        int v9 = (unsigned __int16 *)*((void *)v4 + 1);
      }
      sub_19E0DE9B0(v3, a2, *((unsigned __int8 *)v9 + v5));
      float v7 = v7 * v10;
      if (*(char *)v3 < 0) {
        break;
      }
      ++v5;
    }
    while (v5 < v6);
  }
  return v7;
}

void sub_19E0805FC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 31) < 0) {
    operator delete(*(void **)(a2 + 8));
  }
}

void sub_19E080624(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 31) < 0) {
    operator delete(*(void **)(a2 + 8));
  }
}

uint64_t sub_19E080648(uint64_t a1)
{
  sub_19E080690((uint64_t *)(a1 + 80), 0);
  sub_19E07FA6C(a1 + 40);

  return sub_19E07FA6C(a1);
}

uint64_t *sub_19E080690(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *double result = a2;
  if (v2)
  {
    sub_19E080690(v2 + 80, 0);
    sub_19E07FA6C(v2 + 40);
    sub_19E07FA6C(v2);
    JUMPOUT(0x19F3BA710);
  }
  return result;
}

uint64_t sub_19E080700(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 96;
    sub_19E080648(i - 96);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_19E080750(uint64_t **a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (*(_DWORD *)(v4 + 32) != 12) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  int v25 = 0;
  if (!*(unsigned char *)a2) {
    goto LABEL_29;
  }
  BOOL v7 = *(_DWORD *)(v4 + 12) == -1 || *v6 == 0;
  if (v7 || (sub_19E0FCE84(a2 + 5, v4, &v25) & 1) == 0) {
    goto LABEL_29;
  }
  if (*(unsigned char *)(v4 + 9)) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  unsigned int v8 = v25 & 0x3FFFFFFF;
  if ((v25 & 0x3FFFFFFF) != 0)
  {
    int v9 = *(unsigned __int8 *)a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v9)
    {
      unsigned int v10 = 0;
      unsigned int v28 = v8;
      float v11 = 0.0;
      do
      {
        sub_19E0FD558((uint64_t)v38, (uint64_t)a2, v8, (int *)&v28, v6);
        float v12 = *(float *)&v41;
        if (v38[0])
        {
          unint64_t v13 = a3[1];
          if (v13 >= a3[2])
          {
            uint64_t v17 = sub_19E086C04(a3, (uint64_t)v38);
          }
          else
          {
            sub_19E039858(a3[1], v38);
            long long v15 = v42;
            long long v14 = v43;
            long long v16 = v41;
            *(_WORD *)(v13 + 8sub_19E03D880(&a9, 0) = v44;
            *(_OWORD *)(v13 + 4++**(_DWORD **)(result + 8) = v15;
            *(_OWORD *)(v13 + 64) = v14;
            *(_OWORD *)(v13 + 32) = v16;
            uint64_t v17 = v13 + 88;
            a3[1] = v13 + 88;
          }
          a3[1] = v17;
        }
        if (v40) {
          BOOL v18 = v39 == 1;
        }
        else {
          BOOL v18 = 0;
        }
        if (v18) {
          free(v40);
        }
        float v11 = v11 + v12;
        unsigned int v8 = v28;
        if (!v28) {
          break;
        }
      }
      while (v10++ < 0xFF);
      uint64_t v20 = *a3;
      uint64_t v21 = a3[1];
      uint64_t v22 = v21 - *a3;
      if (v22 == 88)
      {
        *(_DWORD *)(v20 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v22 >> 3)) >= 2)
      {
        if (v11 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v20 != v21)
        {
          *(float *)(v20 + 32) = *(float *)(v20 + 32) / v11;
          v20 += 88;
        }
      }
    }
    return;
  }
  if (sub_19E0FCEF8((uint64_t)(a2 + 5), v4))
  {
LABEL_29:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return;
  }
  sub_19E0D2DEC((uint64_t)v35, (uint64_t)(a2 + 11), v6);
  if (!v35[0]) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
  }
  sub_19E039858((uint64_t)v38, v35);
  BYTE4(v41) = 0;
  *(void *)((char *)&v41 + 5) = 0;
  long long v42 = 0uLL;
  *(void *)&long long v43 = 0xFFFFFFFFLL;
  BYTE8(v43) = 0;
  HIDWORD(v43) = 0;
  __int16 v44 = 0;
  LODWORD(v41) = 1065353216;
  if (*((unsigned char *)a2 + 6)) {
    HIDWORD(v42) = -1;
  }
  sub_19E039858((uint64_t)&v28, v38);
  long long v31 = v41;
  long long v32 = v42;
  long long v33 = v43;
  __int16 v34 = v44;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  uint64_t v26 = a3;
  char v27 = 0;
  uint64_t v23 = operator new(0x58uLL);
  *a3 = (uint64_t)v23;
  a3[1] = (uint64_t)v23;
  a3[2] = (uint64_t)v23 + 88;
  sub_19E039858((uint64_t)v23, (unsigned __int16 *)&v28);
  long long v24 = v32;
  _DWORD v23[2] = v31;
  v23[3] = v24;
  v23[4] = v33;
  *((_WORD *)v23 + 4sub_19E03D880(&a9, 0) = v34;
  a3[1] = (uint64_t)v23 + 88;
  if (v30 && v29 == 1) {
    free(v30);
  }
  if (v40 && v39 == 1) {
    free(v40);
  }
  if (v37 && v36 == 1) {
    free(v37);
  }
}

void sub_19E080B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,char a31,int a32,char a33,char a34)
{
  *(void *)(v34 + ++**(_DWORD **)(result + 8) = v35;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  long long v38 = *(void **)(v36 + 8);
  if (v38 && BYTE2(a32) == 1) {
    free(v38);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E080BCC(unsigned int ***a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (v4[8] != 11) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  int v25 = 0;
  if (!*a2) {
    goto LABEL_29;
  }
  BOOL v7 = *(void *)v4 == -1 || *v6 == 0;
  if (v7 || (sub_19E0FB15C((void *)a2 + 5, v4, &v25) & 1) == 0) {
    goto LABEL_29;
  }
  if (!*(void *)v4) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  unsigned int v8 = v25 & 0x3FFFFFFF;
  if ((v25 & 0x3FFFFFFF) != 0)
  {
    int v9 = *a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v9)
    {
      unsigned int v10 = 0;
      unsigned int v28 = v8;
      float v11 = 0.0;
      do
      {
        sub_19E0FC8C4((uint64_t)v38, (uint64_t)a2, v8, (int *)&v28, v6);
        float v12 = *(float *)&v41;
        if (v38[0])
        {
          unint64_t v13 = a3[1];
          if (v13 >= a3[2])
          {
            uint64_t v17 = sub_19E086C04(a3, (uint64_t)v38);
          }
          else
          {
            sub_19E039858(a3[1], v38);
            long long v15 = v42;
            long long v14 = v43;
            long long v16 = v41;
            *(_WORD *)(v13 + 8sub_19E03D880(&a9, 0) = v44;
            *(_OWORD *)(v13 + 4++**(_DWORD **)(result + 8) = v15;
            *(_OWORD *)(v13 + 64) = v14;
            *(_OWORD *)(v13 + 32) = v16;
            uint64_t v17 = v13 + 88;
            a3[1] = v13 + 88;
          }
          a3[1] = v17;
        }
        if (v40) {
          BOOL v18 = v39 == 1;
        }
        else {
          BOOL v18 = 0;
        }
        if (v18) {
          free(v40);
        }
        float v11 = v11 + v12;
        unsigned int v8 = v28;
        if (!v28) {
          break;
        }
      }
      while (v10++ < 0xFF);
      uint64_t v20 = *a3;
      uint64_t v21 = a3[1];
      uint64_t v22 = v21 - *a3;
      if (v22 == 88)
      {
        *(_DWORD *)(v20 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v22 >> 3)) >= 2)
      {
        if (v11 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v20 != v21)
        {
          *(float *)(v20 + 32) = *(float *)(v20 + 32) / v11;
          v20 += 88;
        }
      }
    }
    return;
  }
  if (sub_19E0FC998((uint64_t)(a2 + 40), (uint64_t)v4))
  {
LABEL_29:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return;
  }
  sub_19E0D2DEC((uint64_t)v35, (uint64_t)(a2 + 104), v6);
  if (!v35[0]) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
  }
  sub_19E039858((uint64_t)v38, v35);
  BYTE4(v41) = 0;
  *(void *)((char *)&v41 + 5) = 0;
  long long v42 = 0uLL;
  *(void *)&long long v43 = 0xFFFFFFFFLL;
  BYTE8(v43) = 0;
  HIDWORD(v43) = 0;
  __int16 v44 = 0;
  LODWORD(v41) = 1065353216;
  if (a2[6]) {
    HIDWORD(v42) = -1;
  }
  sub_19E039858((uint64_t)&v28, v38);
  long long v31 = v41;
  long long v32 = v42;
  long long v33 = v43;
  __int16 v34 = v44;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  uint64_t v26 = a3;
  char v27 = 0;
  uint64_t v23 = operator new(0x58uLL);
  *a3 = (uint64_t)v23;
  a3[1] = (uint64_t)v23;
  a3[2] = (uint64_t)v23 + 88;
  sub_19E039858((uint64_t)v23, (unsigned __int16 *)&v28);
  long long v24 = v32;
  _DWORD v23[2] = v31;
  v23[3] = v24;
  v23[4] = v33;
  *((_WORD *)v23 + 4sub_19E03D880(&a9, 0) = v34;
  a3[1] = (uint64_t)v23 + 88;
  if (v30 && v29 == 1) {
    free(v30);
  }
  if (v40 && v39 == 1) {
    free(v40);
  }
  if (v37 && v36 == 1) {
    free(v37);
  }
}

void sub_19E080F80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,char a31,int a32,char a33,char a34)
{
  *(void *)(v34 + ++**(_DWORD **)(result + 8) = v35;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  long long v38 = *(void **)(v36 + 8);
  if (v38 && BYTE2(a32) == 1) {
    free(v38);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E081048(uint64_t **a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (*(_DWORD *)(v4 + 32) != 10) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  int v25 = 0;
  if (!*(unsigned char *)a2) {
    goto LABEL_29;
  }
  BOOL v7 = *(void *)v4 == 0xFFFFFFFFLL || *v6 == 0;
  if (v7 || (sub_19E0FBF94(a2 + 5, v4, &v25) & 1) == 0) {
    goto LABEL_29;
  }
  if (!*(void *)v4) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  unsigned int v8 = v25 & 0x3FFFFFFF;
  if ((v25 & 0x3FFFFFFF) != 0)
  {
    int v9 = *(unsigned __int8 *)a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v9)
    {
      unsigned int v10 = 0;
      unsigned int v28 = v8;
      float v11 = 0.0;
      do
      {
        sub_19E0FC8C4((uint64_t)v38, (uint64_t)a2, v8, (int *)&v28, v6);
        float v12 = *(float *)&v41;
        if (v38[0])
        {
          unint64_t v13 = a3[1];
          if (v13 >= a3[2])
          {
            uint64_t v17 = sub_19E086C04(a3, (uint64_t)v38);
          }
          else
          {
            sub_19E039858(a3[1], v38);
            long long v15 = v42;
            long long v14 = v43;
            long long v16 = v41;
            *(_WORD *)(v13 + 8sub_19E03D880(&a9, 0) = v44;
            *(_OWORD *)(v13 + 4++**(_DWORD **)(result + 8) = v15;
            *(_OWORD *)(v13 + 64) = v14;
            *(_OWORD *)(v13 + 32) = v16;
            uint64_t v17 = v13 + 88;
            a3[1] = v13 + 88;
          }
          a3[1] = v17;
        }
        if (v40) {
          BOOL v18 = v39 == 1;
        }
        else {
          BOOL v18 = 0;
        }
        if (v18) {
          free(v40);
        }
        float v11 = v11 + v12;
        unsigned int v8 = v28;
        if (!v28) {
          break;
        }
      }
      while (v10++ < 0xFF);
      uint64_t v20 = *a3;
      uint64_t v21 = a3[1];
      uint64_t v22 = v21 - *a3;
      if (v22 == 88)
      {
        *(_DWORD *)(v20 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v22 >> 3)) >= 2)
      {
        if (v11 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v20 != v21)
        {
          *(float *)(v20 + 32) = *(float *)(v20 + 32) / v11;
          v20 += 88;
        }
      }
    }
    return;
  }
  if (sub_19E0FC02C((uint64_t)(a2 + 5), v4))
  {
LABEL_29:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return;
  }
  sub_19E0D2DEC((uint64_t)v35, (uint64_t)(a2 + 13), v6);
  if (!v35[0]) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
  }
  sub_19E039858((uint64_t)v38, v35);
  BYTE4(v41) = 0;
  *(void *)((char *)&v41 + 5) = 0;
  long long v42 = 0uLL;
  *(void *)&long long v43 = 0xFFFFFFFFLL;
  BYTE8(v43) = 0;
  HIDWORD(v43) = 0;
  __int16 v44 = 0;
  LODWORD(v41) = 1065353216;
  if (*((unsigned char *)a2 + 6)) {
    HIDWORD(v42) = -1;
  }
  sub_19E039858((uint64_t)&v28, v38);
  long long v31 = v41;
  long long v32 = v42;
  long long v33 = v43;
  __int16 v34 = v44;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  uint64_t v26 = a3;
  char v27 = 0;
  uint64_t v23 = operator new(0x58uLL);
  *a3 = (uint64_t)v23;
  a3[1] = (uint64_t)v23;
  a3[2] = (uint64_t)v23 + 88;
  sub_19E039858((uint64_t)v23, (unsigned __int16 *)&v28);
  long long v24 = v32;
  _DWORD v23[2] = v31;
  v23[3] = v24;
  v23[4] = v33;
  *((_WORD *)v23 + 4sub_19E03D880(&a9, 0) = v34;
  a3[1] = (uint64_t)v23 + 88;
  if (v30 && v29 == 1) {
    free(v30);
  }
  if (v40 && v39 == 1) {
    free(v40);
  }
  if (v37 && v36 == 1) {
    free(v37);
  }
}

void sub_19E081400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,char a31,int a32,char a33,char a34)
{
  *(void *)(v34 + ++**(_DWORD **)(result + 8) = v35;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  long long v38 = *(void **)(v36 + 8);
  if (v38 && BYTE2(a32) == 1) {
    free(v38);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E0814C8(uint64_t **a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (*(_DWORD *)(v4 + 32) != 9) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  int v25 = 0;
  if (!*a2) {
    goto LABEL_29;
  }
  BOOL v7 = *(void *)v4 == -1 || *v6 == 0;
  if (v7 || (sub_19E0FB81C((uint64_t)(a2 + 40), (unint64_t *)v4, &v25) & 1) == 0) {
    goto LABEL_29;
  }
  if (!*(void *)v4) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  unsigned int v8 = v25 & 0x3FFFFFFF;
  if ((v25 & 0x3FFFFFFF) != 0)
  {
    int v9 = *a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v9)
    {
      unsigned int v10 = 0;
      unsigned int v28 = v8;
      float v11 = 0.0;
      do
      {
        sub_19E0FBEC0((uint64_t)v38, (uint64_t)a2, v8, (int *)&v28, v6);
        float v12 = *(float *)&v41;
        if (v38[0])
        {
          unint64_t v13 = a3[1];
          if (v13 >= a3[2])
          {
            uint64_t v17 = sub_19E086C04(a3, (uint64_t)v38);
          }
          else
          {
            sub_19E039858(a3[1], v38);
            long long v15 = v42;
            long long v14 = v43;
            long long v16 = v41;
            *(_WORD *)(v13 + 8sub_19E03D880(&a9, 0) = v44;
            *(_OWORD *)(v13 + 4++**(_DWORD **)(result + 8) = v15;
            *(_OWORD *)(v13 + 64) = v14;
            *(_OWORD *)(v13 + 32) = v16;
            uint64_t v17 = v13 + 88;
            a3[1] = v13 + 88;
          }
          a3[1] = v17;
        }
        if (v40) {
          BOOL v18 = v39 == 1;
        }
        else {
          BOOL v18 = 0;
        }
        if (v18) {
          free(v40);
        }
        float v11 = v11 + v12;
        unsigned int v8 = v28;
        if (!v28) {
          break;
        }
      }
      while (v10++ < 0xFF);
      uint64_t v20 = *a3;
      uint64_t v21 = a3[1];
      uint64_t v22 = v21 - *a3;
      if (v22 == 88)
      {
        *(_DWORD *)(v20 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v22 >> 3)) >= 2)
      {
        if (v11 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v20 != v21)
        {
          *(float *)(v20 + 32) = *(float *)(v20 + 32) / v11;
          v20 += 88;
        }
      }
    }
    return;
  }
  if (sub_19E0FB8AC((uint64_t)(a2 + 40), v4))
  {
LABEL_29:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return;
  }
  sub_19E0D2DEC((uint64_t)v35, (uint64_t)(a2 + 648), v6);
  if (!v35[0]) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
  }
  sub_19E039858((uint64_t)v38, v35);
  BYTE4(v41) = 0;
  *(void *)((char *)&v41 + 5) = 0;
  long long v42 = 0uLL;
  *(void *)&long long v43 = 0xFFFFFFFFLL;
  BYTE8(v43) = 0;
  HIDWORD(v43) = 0;
  __int16 v44 = 0;
  LODWORD(v41) = 1065353216;
  if (a2[6]) {
    HIDWORD(v42) = -1;
  }
  sub_19E039858((uint64_t)&v28, v38);
  long long v31 = v41;
  long long v32 = v42;
  long long v33 = v43;
  __int16 v34 = v44;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  uint64_t v26 = a3;
  char v27 = 0;
  uint64_t v23 = operator new(0x58uLL);
  *a3 = (uint64_t)v23;
  a3[1] = (uint64_t)v23;
  a3[2] = (uint64_t)v23 + 88;
  sub_19E039858((uint64_t)v23, (unsigned __int16 *)&v28);
  long long v24 = v32;
  _DWORD v23[2] = v31;
  v23[3] = v24;
  v23[4] = v33;
  *((_WORD *)v23 + 4sub_19E03D880(&a9, 0) = v34;
  a3[1] = (uint64_t)v23 + 88;
  if (v30 && v29 == 1) {
    free(v30);
  }
  if (v40 && v39 == 1) {
    free(v40);
  }
  if (v37 && v36 == 1) {
    free(v37);
  }
}

void sub_19E08187C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,char a31,int a32,char a33,char a34)
{
  *(void *)(v34 + ++**(_DWORD **)(result + 8) = v35;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  long long v38 = *(void **)(v36 + 8);
  if (v38 && BYTE2(a32) == 1) {
    free(v38);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E081944(unsigned int ***a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (v4[8] != 8) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  int v25 = 0;
  if (!*a2) {
    goto LABEL_29;
  }
  BOOL v7 = *(void *)v4 == -1 || *v6 == 0;
  if (v7 || (sub_19E0FB15C((void *)a2 + 5, v4, &v25) & 1) == 0) {
    goto LABEL_29;
  }
  if (!*(void *)v4) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  unsigned int v8 = v25 & 0x3FFFFFFF;
  if ((v25 & 0x3FFFFFFF) != 0)
  {
    int v9 = *a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v9)
    {
      unsigned int v10 = 0;
      unsigned int v28 = v8;
      float v11 = 0.0;
      do
      {
        sub_19E0FB748((uint64_t)v38, (uint64_t)a2, v8, (int *)&v28, v6);
        float v12 = *(float *)&v41;
        if (v38[0])
        {
          unint64_t v13 = a3[1];
          if (v13 >= a3[2])
          {
            uint64_t v17 = sub_19E086C04(a3, (uint64_t)v38);
          }
          else
          {
            sub_19E039858(a3[1], v38);
            long long v15 = v42;
            long long v14 = v43;
            long long v16 = v41;
            *(_WORD *)(v13 + 8sub_19E03D880(&a9, 0) = v44;
            *(_OWORD *)(v13 + 4++**(_DWORD **)(result + 8) = v15;
            *(_OWORD *)(v13 + 64) = v14;
            *(_OWORD *)(v13 + 32) = v16;
            uint64_t v17 = v13 + 88;
            a3[1] = v13 + 88;
          }
          a3[1] = v17;
        }
        if (v40) {
          BOOL v18 = v39 == 1;
        }
        else {
          BOOL v18 = 0;
        }
        if (v18) {
          free(v40);
        }
        float v11 = v11 + v12;
        unsigned int v8 = v28;
        if (!v28) {
          break;
        }
      }
      while (v10++ < 0xFF);
      uint64_t v20 = *a3;
      uint64_t v21 = a3[1];
      uint64_t v22 = v21 - *a3;
      if (v22 == 88)
      {
        *(_DWORD *)(v20 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v22 >> 3)) >= 2)
      {
        if (v11 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v20 != v21)
        {
          *(float *)(v20 + 32) = *(float *)(v20 + 32) / v11;
          v20 += 88;
        }
      }
    }
    return;
  }
  if (sub_19E0FB1F4((uint64_t)(a2 + 40), (uint64_t)v4))
  {
LABEL_29:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return;
  }
  sub_19E0D2DEC((uint64_t)v35, (uint64_t)(a2 + 80), v6);
  if (!v35[0]) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
  }
  sub_19E039858((uint64_t)v38, v35);
  BYTE4(v41) = 0;
  *(void *)((char *)&v41 + 5) = 0;
  long long v42 = 0uLL;
  *(void *)&long long v43 = 0xFFFFFFFFLL;
  BYTE8(v43) = 0;
  HIDWORD(v43) = 0;
  __int16 v44 = 0;
  LODWORD(v41) = 1065353216;
  if (a2[6]) {
    HIDWORD(v42) = -1;
  }
  sub_19E039858((uint64_t)&v28, v38);
  long long v31 = v41;
  long long v32 = v42;
  long long v33 = v43;
  __int16 v34 = v44;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  uint64_t v26 = a3;
  char v27 = 0;
  uint64_t v23 = operator new(0x58uLL);
  *a3 = (uint64_t)v23;
  a3[1] = (uint64_t)v23;
  a3[2] = (uint64_t)v23 + 88;
  sub_19E039858((uint64_t)v23, (unsigned __int16 *)&v28);
  long long v24 = v32;
  _DWORD v23[2] = v31;
  v23[3] = v24;
  v23[4] = v33;
  *((_WORD *)v23 + 4sub_19E03D880(&a9, 0) = v34;
  a3[1] = (uint64_t)v23 + 88;
  if (v30 && v29 == 1) {
    free(v30);
  }
  if (v40 && v39 == 1) {
    free(v40);
  }
  if (v37 && v36 == 1) {
    free(v37);
  }
}

void sub_19E081CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,char a31,int a32,char a33,char a34)
{
  *(void *)(v34 + ++**(_DWORD **)(result + 8) = v35;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  long long v38 = *(void **)(v36 + 8);
  if (v38 && BYTE2(a32) == 1) {
    free(v38);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E081DC0(uint64_t **a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (*(_DWORD *)(v4 + 32) != 7) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  int v25 = 0;
  if (!*(unsigned char *)a2) {
    goto LABEL_29;
  }
  BOOL v7 = *(void *)v4 == -1 || *v6 == 0;
  if (v7 || (sub_19E0FAA94(a2 + 5, (uint64_t *)v4, &v25) & 1) == 0) {
    goto LABEL_29;
  }
  if (!*(void *)v4) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  unsigned int v8 = v25 & 0x3FFFFFFF;
  if ((v25 & 0x3FFFFFFF) != 0)
  {
    int v9 = *(unsigned __int8 *)a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v9)
    {
      unsigned int v10 = 0;
      unsigned int v28 = v8;
      float v11 = 0.0;
      do
      {
        sub_19E0FB088((uint64_t)v38, (uint64_t)a2, v8, (int *)&v28, v6);
        float v12 = *(float *)&v41;
        if (v38[0])
        {
          unint64_t v13 = a3[1];
          if (v13 >= a3[2])
          {
            uint64_t v17 = sub_19E086C04(a3, (uint64_t)v38);
          }
          else
          {
            sub_19E039858(a3[1], v38);
            long long v15 = v42;
            long long v14 = v43;
            long long v16 = v41;
            *(_WORD *)(v13 + 8sub_19E03D880(&a9, 0) = v44;
            *(_OWORD *)(v13 + 4++**(_DWORD **)(result + 8) = v15;
            *(_OWORD *)(v13 + 64) = v14;
            *(_OWORD *)(v13 + 32) = v16;
            uint64_t v17 = v13 + 88;
            a3[1] = v13 + 88;
          }
          a3[1] = v17;
        }
        if (v40) {
          BOOL v18 = v39 == 1;
        }
        else {
          BOOL v18 = 0;
        }
        if (v18) {
          free(v40);
        }
        float v11 = v11 + v12;
        unsigned int v8 = v28;
        if (!v28) {
          break;
        }
      }
      while (v10++ < 0xFF);
      uint64_t v20 = *a3;
      uint64_t v21 = a3[1];
      uint64_t v22 = v21 - *a3;
      if (v22 == 88)
      {
        *(_DWORD *)(v20 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v22 >> 3)) >= 2)
      {
        if (v11 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v20 != v21)
        {
          *(float *)(v20 + 32) = *(float *)(v20 + 32) / v11;
          v20 += 88;
        }
      }
    }
    return;
  }
  if (sub_19E0FAB24((uint64_t)(a2 + 5), v4))
  {
LABEL_29:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return;
  }
  sub_19E0D2DEC((uint64_t)v35, (uint64_t)(a2 + 18), v6);
  if (!v35[0]) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
  }
  sub_19E039858((uint64_t)v38, v35);
  BYTE4(v41) = 0;
  *(void *)((char *)&v41 + 5) = 0;
  long long v42 = 0uLL;
  *(void *)&long long v43 = 0xFFFFFFFFLL;
  BYTE8(v43) = 0;
  HIDWORD(v43) = 0;
  __int16 v44 = 0;
  LODWORD(v41) = 1065353216;
  if (*((unsigned char *)a2 + 6)) {
    HIDWORD(v42) = -1;
  }
  sub_19E039858((uint64_t)&v28, v38);
  long long v31 = v41;
  long long v32 = v42;
  long long v33 = v43;
  __int16 v34 = v44;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  uint64_t v26 = a3;
  char v27 = 0;
  uint64_t v23 = operator new(0x58uLL);
  *a3 = (uint64_t)v23;
  a3[1] = (uint64_t)v23;
  a3[2] = (uint64_t)v23 + 88;
  sub_19E039858((uint64_t)v23, (unsigned __int16 *)&v28);
  long long v24 = v32;
  _DWORD v23[2] = v31;
  v23[3] = v24;
  v23[4] = v33;
  *((_WORD *)v23 + 4sub_19E03D880(&a9, 0) = v34;
  a3[1] = (uint64_t)v23 + 88;
  if (v30 && v29 == 1) {
    free(v30);
  }
  if (v40 && v39 == 1) {
    free(v40);
  }
  if (v37 && v36 == 1) {
    free(v37);
  }
}

void sub_19E082174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,char a31,int a32,char a33,char a34)
{
  *(void *)(v34 + ++**(_DWORD **)(result + 8) = v35;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  long long v38 = *(void **)(v36 + 8);
  if (v38 && BYTE2(a32) == 1) {
    free(v38);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E08223C(uint64_t **a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (*(_DWORD *)(v4 + 32) != 6) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  if (*(unsigned char *)a2) {
    BOOL v7 = *(_DWORD *)(v4 + 12) == -1;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || *v6 == 0) {
    goto LABEL_11;
  }
  *(_DWORD *)uint64_t v36 = 0;
  if (!sub_19E06E5B4(a2 + 6, v4, v36) || (~*(_DWORD *)v36 & 0x7FFFFF) == 0) {
    goto LABEL_11;
  }
  if (*(unsigned char *)(v4 + 9)) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  if ((*(_DWORD *)v36 & 0x400000) != 0 || (unsigned int v9 = *(_DWORD *)v36 & 0x1FFFFF, (*(_DWORD *)v36 & 0x1FFFFF) == 0))
  {
    if (*(_DWORD *)v36 & 0x400000) == 0 && (sub_19E0FA45C((uint64_t)(a2 + 5), v4))
    {
LABEL_11:
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      return;
    }
    sub_19E0D2DEC((uint64_t)v33, (uint64_t)(a2 + 15), v6);
    if (!v33[0]) {
      __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
    }
    sub_19E039858((uint64_t)v36, v33);
    BYTE4(v39) = 0;
    *(void *)((char *)&v39 + 5) = 0;
    long long v40 = 0uLL;
    *(void *)&long long v41 = 0xFFFFFFFFLL;
    BYTE8(v41) = 0;
    HIDWORD(v41) = 0;
    __int16 v42 = 0;
    LODWORD(v39) = 1065353216;
    if (*((unsigned char *)a2 + 6)) {
      HIDWORD(v4sub_19E03D880(&a9, 0) = -1;
    }
    sub_19E039858((uint64_t)&v26, v36);
    long long v29 = v39;
    long long v30 = v40;
    long long v31 = v41;
    __int16 v32 = v42;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    long long v24 = operator new(0x58uLL);
    *a3 = (uint64_t)v24;
    a3[1] = (uint64_t)v24;
    a3[2] = (uint64_t)v24 + 88;
    sub_19E039858((uint64_t)v24, (unsigned __int16 *)&v26);
    long long v25 = v30;
    v24[2] = v29;
    unsigned char v24[3] = v25;
    void v24[4] = v31;
    *((_WORD *)v24 + 4sub_19E03D880(&a9, 0) = v32;
    a3[1] = (uint64_t)v24 + 88;
    if (v28 && v27 == 1) {
      free(v28);
    }
    if (v38 && v37 == 1) {
      free(v38);
    }
    if (v35 && v34 == 1) {
      free(v35);
    }
  }
  else
  {
    int v10 = *(unsigned __int8 *)a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v10)
    {
      unsigned int v11 = 0;
      unsigned int v26 = v9;
      float v12 = 0.0;
      do
      {
        sub_19E0FA9C0((uint64_t)v36, (uint64_t)a2, v9, (int *)&v26, v6);
        float v13 = *(float *)&v39;
        if (v36[0])
        {
          unint64_t v14 = a3[1];
          if (v14 >= a3[2])
          {
            uint64_t v18 = sub_19E086C04(a3, (uint64_t)v36);
          }
          else
          {
            sub_19E039858(a3[1], v36);
            long long v16 = v40;
            long long v15 = v41;
            long long v17 = v39;
            *(_WORD *)(v14 + 8sub_19E03D880(&a9, 0) = v42;
            *(_OWORD *)(v14 + 4++**(_DWORD **)(result + 8) = v16;
            *(_OWORD *)(v14 + 64) = v15;
            *(_OWORD *)(v14 + 32) = v17;
            uint64_t v18 = v14 + 88;
            a3[1] = v14 + 88;
          }
          a3[1] = v18;
        }
        if (v38) {
          BOOL v19 = v37 == 1;
        }
        else {
          BOOL v19 = 0;
        }
        if (v19) {
          free(v38);
        }
        float v12 = v12 + v13;
        unsigned int v9 = v26;
        if (!v26) {
          break;
        }
      }
      while (v11++ < 0xFF);
      uint64_t v21 = *a3;
      uint64_t v22 = a3[1];
      uint64_t v23 = v22 - *a3;
      if (v23 == 88)
      {
        *(_DWORD *)(v21 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v23 >> 3)) >= 2)
      {
        if (v12 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v21 != v22)
        {
          *(float *)(v21 + 32) = *(float *)(v21 + 32) / v12;
          v21 += 88;
        }
      }
    }
  }
}

void sub_19E0825FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  *(void *)(v32 + ++**(_DWORD **)(result + 8) = v33;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  if (a32 && BYTE6(a31) == 1) {
    free(a32);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E0826C4(unsigned int ***a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (v4[8] != 5) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  if (*a2) {
    BOOL v7 = *(void *)v4 == -1;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || *v6 == 0) {
    goto LABEL_11;
  }
  int v36 = 0;
  if (!sub_19E0C3B60((void *)a2 + 6, v4, &v36) || (~v36 & 0x7FFFFF) == 0) {
    goto LABEL_11;
  }
  if (!*(void *)v4) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  if ((v36 & 0x400000) != 0 || (unsigned int v9 = v36 & 0x1FFFFF, (v36 & 0x1FFFFF) == 0))
  {
    if (v36 & 0x400000) == 0 && (sub_19E0F9FA4((uint64_t)(a2 + 40), (uint64_t)v4))
    {
LABEL_11:
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      return;
    }
    sub_19E0D2DEC((uint64_t)v33, (uint64_t)(a2 + 136), v6);
    if (!v33[0]) {
      __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
    }
    sub_19E039858((uint64_t)&v36, v33);
    BYTE4(v39) = 0;
    *(void *)((char *)&v39 + 5) = 0;
    long long v40 = 0uLL;
    *(void *)&long long v41 = 0xFFFFFFFFLL;
    BYTE8(v41) = 0;
    HIDWORD(v41) = 0;
    __int16 v42 = 0;
    LODWORD(v39) = 1065353216;
    if (a2[6]) {
      HIDWORD(v4sub_19E03D880(&a9, 0) = -1;
    }
    sub_19E039858((uint64_t)&v26, (unsigned __int16 *)&v36);
    long long v29 = v39;
    long long v30 = v40;
    long long v31 = v41;
    __int16 v32 = v42;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    long long v24 = operator new(0x58uLL);
    *a3 = (uint64_t)v24;
    a3[1] = (uint64_t)v24;
    a3[2] = (uint64_t)v24 + 88;
    sub_19E039858((uint64_t)v24, (unsigned __int16 *)&v26);
    long long v25 = v30;
    v24[2] = v29;
    unsigned char v24[3] = v25;
    void v24[4] = v31;
    *((_WORD *)v24 + 4sub_19E03D880(&a9, 0) = v32;
    a3[1] = (uint64_t)v24 + 88;
    if (v28 && v27 == 1) {
      free(v28);
    }
    if (v38 && v37 == 1) {
      free(v38);
    }
    if (v35 && v34 == 1) {
      free(v35);
    }
  }
  else
  {
    int v10 = *a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v10)
    {
      unsigned int v11 = 0;
      unsigned int v26 = v9;
      float v12 = 0.0;
      do
      {
        sub_19E0F9ED0((uint64_t)&v36, (uint64_t)a2, v9, (int *)&v26, v6);
        float v13 = *(float *)&v39;
        if ((_WORD)v36)
        {
          unint64_t v14 = a3[1];
          if (v14 >= a3[2])
          {
            uint64_t v18 = sub_19E086C04(a3, (uint64_t)&v36);
          }
          else
          {
            sub_19E039858(a3[1], (unsigned __int16 *)&v36);
            long long v16 = v40;
            long long v15 = v41;
            long long v17 = v39;
            *(_WORD *)(v14 + 8sub_19E03D880(&a9, 0) = v42;
            *(_OWORD *)(v14 + 4++**(_DWORD **)(result + 8) = v16;
            *(_OWORD *)(v14 + 64) = v15;
            *(_OWORD *)(v14 + 32) = v17;
            uint64_t v18 = v14 + 88;
            a3[1] = v14 + 88;
          }
          a3[1] = v18;
        }
        if (v38) {
          BOOL v19 = v37 == 1;
        }
        else {
          BOOL v19 = 0;
        }
        if (v19) {
          free(v38);
        }
        float v12 = v12 + v13;
        unsigned int v9 = v26;
        if (!v26) {
          break;
        }
      }
      while (v11++ < 0xFF);
      uint64_t v21 = *a3;
      uint64_t v22 = a3[1];
      uint64_t v23 = v22 - *a3;
      if (v23 == 88)
      {
        *(_DWORD *)(v21 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v23 >> 3)) >= 2)
      {
        if (v12 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v21 != v22)
        {
          *(float *)(v21 + 32) = *(float *)(v21 + 32) / v12;
          v21 += 88;
        }
      }
    }
  }
}

void sub_19E082A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  *(void *)(v32 + ++**(_DWORD **)(result + 8) = v33;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  if (a32 && BYTE6(a31) == 1) {
    free(a32);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E082B4C(uint64_t **a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (*(_DWORD *)(v4 + 32) != 4) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  if (*(unsigned char *)a2) {
    BOOL v7 = *(void *)v4 == 0xFFFFFFFFLL;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || *v6 == 0) {
    goto LABEL_11;
  }
  *(_DWORD *)int v36 = 0;
  if (!sub_19E0B4630(a2 + 6, v4, v36) || (~*(_DWORD *)v36 & 0xFFFFFF) == 0) {
    goto LABEL_11;
  }
  if (!*(void *)v4) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  if ((*(_DWORD *)v36 & 0x400000) != 0 || (unsigned int v9 = *(_DWORD *)v36 & 0x1FFFFF, (*(_DWORD *)v36 & 0x1FFFFF) == 0))
  {
    if (*(_DWORD *)v36 & 0x400000) == 0 && (sub_19E0F9848((uint64_t)(a2 + 5), v4))
    {
LABEL_11:
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      return;
    }
    sub_19E0D2DEC((uint64_t)v33, (uint64_t)(a2 + 17), v6);
    if (!v33[0]) {
      __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
    }
    sub_19E039858((uint64_t)v36, v33);
    BYTE4(v39) = 0;
    *(void *)((char *)&v39 + 5) = 0;
    long long v40 = 0uLL;
    *(void *)&long long v41 = 0xFFFFFFFFLL;
    BYTE8(v41) = 0;
    HIDWORD(v41) = 0;
    __int16 v42 = 0;
    LODWORD(v39) = 1065353216;
    if (*((unsigned char *)a2 + 6)) {
      HIDWORD(v4sub_19E03D880(&a9, 0) = -1;
    }
    sub_19E039858((uint64_t)&v26, v36);
    long long v29 = v39;
    long long v30 = v40;
    long long v31 = v41;
    __int16 v32 = v42;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    long long v24 = operator new(0x58uLL);
    *a3 = (uint64_t)v24;
    a3[1] = (uint64_t)v24;
    a3[2] = (uint64_t)v24 + 88;
    sub_19E039858((uint64_t)v24, (unsigned __int16 *)&v26);
    long long v25 = v30;
    v24[2] = v29;
    unsigned char v24[3] = v25;
    void v24[4] = v31;
    *((_WORD *)v24 + 4sub_19E03D880(&a9, 0) = v32;
    a3[1] = (uint64_t)v24 + 88;
    if (v28 && v27 == 1) {
      free(v28);
    }
    if (v38 && v37 == 1) {
      free(v38);
    }
    if (v35 && v34 == 1) {
      free(v35);
    }
  }
  else
  {
    int v10 = *(unsigned __int8 *)a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v10)
    {
      unsigned int v11 = 0;
      unsigned int v26 = v9;
      float v12 = 0.0;
      do
      {
        sub_19E0F9ED0((uint64_t)v36, (uint64_t)a2, v9, (int *)&v26, v6);
        float v13 = *(float *)&v39;
        if (v36[0])
        {
          unint64_t v14 = a3[1];
          if (v14 >= a3[2])
          {
            uint64_t v18 = sub_19E086C04(a3, (uint64_t)v36);
          }
          else
          {
            sub_19E039858(a3[1], v36);
            long long v16 = v40;
            long long v15 = v41;
            long long v17 = v39;
            *(_WORD *)(v14 + 8sub_19E03D880(&a9, 0) = v42;
            *(_OWORD *)(v14 + 4++**(_DWORD **)(result + 8) = v16;
            *(_OWORD *)(v14 + 64) = v15;
            *(_OWORD *)(v14 + 32) = v17;
            uint64_t v18 = v14 + 88;
            a3[1] = v14 + 88;
          }
          a3[1] = v18;
        }
        if (v38) {
          BOOL v19 = v37 == 1;
        }
        else {
          BOOL v19 = 0;
        }
        if (v19) {
          free(v38);
        }
        float v12 = v12 + v13;
        unsigned int v9 = v26;
        if (!v26) {
          break;
        }
      }
      while (v11++ < 0xFF);
      uint64_t v21 = *a3;
      uint64_t v22 = a3[1];
      uint64_t v23 = v22 - *a3;
      if (v23 == 88)
      {
        *(_DWORD *)(v21 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v23 >> 3)) >= 2)
      {
        if (v12 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v21 != v22)
        {
          *(float *)(v21 + 32) = *(float *)(v21 + 32) / v12;
          v21 += 88;
        }
      }
    }
  }
}

void sub_19E082F10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  *(void *)(v32 + ++**(_DWORD **)(result + 8) = v33;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  if (a32 && BYTE6(a31) == 1) {
    free(a32);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E082FD8(uint64_t **a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (*(_DWORD *)(v4 + 32) != 3) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  if (*a2) {
    BOOL v7 = *(void *)v4 == -1;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || *v6 == 0) {
    goto LABEL_11;
  }
  *(_DWORD *)int v36 = 0;
  if (!sub_19E0B92A8((uint64_t)(a2 + 48), (unint64_t *)v4, v36)
    || (~*(_DWORD *)v36 & 0x7FFFFF) == 0)
  {
    goto LABEL_11;
  }
  if (!*(void *)v4) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  if ((*(_DWORD *)v36 & 0x400000) != 0 || (unsigned int v9 = *(_DWORD *)v36 & 0x1FFFFF, (*(_DWORD *)v36 & 0x1FFFFF) == 0))
  {
    if (*(_DWORD *)v36 & 0x400000) == 0 && (sub_19E0F9214((uint64_t)(a2 + 40), v4))
    {
LABEL_11:
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      return;
    }
    sub_19E0D2DEC((uint64_t)v33, (uint64_t)(a2 + 680), v6);
    if (!v33[0]) {
      __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
    }
    sub_19E039858((uint64_t)v36, v33);
    BYTE4(v39) = 0;
    *(void *)((char *)&v39 + 5) = 0;
    long long v40 = 0uLL;
    *(void *)&long long v41 = 0xFFFFFFFFLL;
    BYTE8(v41) = 0;
    HIDWORD(v41) = 0;
    __int16 v42 = 0;
    LODWORD(v39) = 1065353216;
    if (a2[6]) {
      HIDWORD(v4sub_19E03D880(&a9, 0) = -1;
    }
    sub_19E039858((uint64_t)&v26, v36);
    long long v29 = v39;
    long long v30 = v40;
    long long v31 = v41;
    __int16 v32 = v42;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    long long v24 = operator new(0x58uLL);
    *a3 = (uint64_t)v24;
    a3[1] = (uint64_t)v24;
    a3[2] = (uint64_t)v24 + 88;
    sub_19E039858((uint64_t)v24, (unsigned __int16 *)&v26);
    long long v25 = v30;
    v24[2] = v29;
    unsigned char v24[3] = v25;
    void v24[4] = v31;
    *((_WORD *)v24 + 4sub_19E03D880(&a9, 0) = v32;
    a3[1] = (uint64_t)v24 + 88;
    if (v28 && v27 == 1) {
      free(v28);
    }
    if (v38 && v37 == 1) {
      free(v38);
    }
    if (v35 && v34 == 1) {
      free(v35);
    }
  }
  else
  {
    int v10 = *a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v10)
    {
      unsigned int v11 = 0;
      unsigned int v26 = v9;
      float v12 = 0.0;
      do
      {
        sub_19E0F9774((uint64_t)v36, (uint64_t)a2, v9, (int *)&v26, v6);
        float v13 = *(float *)&v39;
        if (v36[0])
        {
          unint64_t v14 = a3[1];
          if (v14 >= a3[2])
          {
            uint64_t v18 = sub_19E086C04(a3, (uint64_t)v36);
          }
          else
          {
            sub_19E039858(a3[1], v36);
            long long v16 = v40;
            long long v15 = v41;
            long long v17 = v39;
            *(_WORD *)(v14 + 8sub_19E03D880(&a9, 0) = v42;
            *(_OWORD *)(v14 + 4++**(_DWORD **)(result + 8) = v16;
            *(_OWORD *)(v14 + 64) = v15;
            *(_OWORD *)(v14 + 32) = v17;
            uint64_t v18 = v14 + 88;
            a3[1] = v14 + 88;
          }
          a3[1] = v18;
        }
        if (v38) {
          BOOL v19 = v37 == 1;
        }
        else {
          BOOL v19 = 0;
        }
        if (v19) {
          free(v38);
        }
        float v12 = v12 + v13;
        unsigned int v9 = v26;
        if (!v26) {
          break;
        }
      }
      while (v11++ < 0xFF);
      uint64_t v21 = *a3;
      uint64_t v22 = a3[1];
      uint64_t v23 = v22 - *a3;
      if (v23 == 88)
      {
        *(_DWORD *)(v21 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v23 >> 3)) >= 2)
      {
        if (v12 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v21 != v22)
        {
          *(float *)(v21 + 32) = *(float *)(v21 + 32) / v12;
          v21 += 88;
        }
      }
    }
  }
}

void sub_19E083398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  *(void *)(v32 + ++**(_DWORD **)(result + 8) = v33;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  if (a32 && BYTE6(a31) == 1) {
    free(a32);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E083460(uint64_t **a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (*(_DWORD *)(v4 + 32) != 2) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  if (*(unsigned char *)a2) {
    BOOL v7 = *(void *)v4 == -1;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || *v6 == 0) {
    goto LABEL_11;
  }
  *(_DWORD *)int v36 = 0;
  if (!sub_19E0CB364(a2 + 6, (uint64_t *)v4, v36) || (~*(_DWORD *)v36 & 0x7FFFFF) == 0) {
    goto LABEL_11;
  }
  if (!*(void *)v4) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  if ((*(_DWORD *)v36 & 0x400000) != 0 || (unsigned int v9 = *(_DWORD *)v36 & 0x1FFFFF, (*(_DWORD *)v36 & 0x1FFFFF) == 0))
  {
    if (*(_DWORD *)v36 & 0x400000) == 0 && (sub_19E0F8BD4((uint64_t)(a2 + 5), v4))
    {
LABEL_11:
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      return;
    }
    sub_19E0D2DEC((uint64_t)v33, (uint64_t)(a2 + 22), v6);
    if (!v33[0]) {
      __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
    }
    sub_19E039858((uint64_t)v36, v33);
    BYTE4(v39) = 0;
    *(void *)((char *)&v39 + 5) = 0;
    long long v40 = 0uLL;
    *(void *)&long long v41 = 0xFFFFFFFFLL;
    BYTE8(v41) = 0;
    HIDWORD(v41) = 0;
    __int16 v42 = 0;
    LODWORD(v39) = 1065353216;
    if (*((unsigned char *)a2 + 6)) {
      HIDWORD(v4sub_19E03D880(&a9, 0) = -1;
    }
    sub_19E039858((uint64_t)&v26, v36);
    long long v29 = v39;
    long long v30 = v40;
    long long v31 = v41;
    __int16 v32 = v42;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    long long v24 = operator new(0x58uLL);
    *a3 = (uint64_t)v24;
    a3[1] = (uint64_t)v24;
    a3[2] = (uint64_t)v24 + 88;
    sub_19E039858((uint64_t)v24, (unsigned __int16 *)&v26);
    long long v25 = v30;
    v24[2] = v29;
    unsigned char v24[3] = v25;
    void v24[4] = v31;
    *((_WORD *)v24 + 4sub_19E03D880(&a9, 0) = v32;
    a3[1] = (uint64_t)v24 + 88;
    if (v28 && v27 == 1) {
      free(v28);
    }
    if (v38 && v37 == 1) {
      free(v38);
    }
    if (v35 && v34 == 1) {
      free(v35);
    }
  }
  else
  {
    int v10 = *(unsigned __int8 *)a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v10)
    {
      unsigned int v11 = 0;
      unsigned int v26 = v9;
      float v12 = 0.0;
      do
      {
        sub_19E0F90B0((uint64_t)v36, (uint64_t)a2, v9, (int *)&v26, v6);
        float v13 = *(float *)&v39;
        if (v36[0])
        {
          unint64_t v14 = a3[1];
          if (v14 >= a3[2])
          {
            uint64_t v18 = sub_19E086C04(a3, (uint64_t)v36);
          }
          else
          {
            sub_19E039858(a3[1], v36);
            long long v16 = v40;
            long long v15 = v41;
            long long v17 = v39;
            *(_WORD *)(v14 + 8sub_19E03D880(&a9, 0) = v42;
            *(_OWORD *)(v14 + 4++**(_DWORD **)(result + 8) = v16;
            *(_OWORD *)(v14 + 64) = v15;
            *(_OWORD *)(v14 + 32) = v17;
            uint64_t v18 = v14 + 88;
            a3[1] = v14 + 88;
          }
          a3[1] = v18;
        }
        if (v38) {
          BOOL v19 = v37 == 1;
        }
        else {
          BOOL v19 = 0;
        }
        if (v19) {
          free(v38);
        }
        float v12 = v12 + v13;
        unsigned int v9 = v26;
        if (!v26) {
          break;
        }
      }
      while (v11++ < 0xFF);
      uint64_t v21 = *a3;
      uint64_t v22 = a3[1];
      uint64_t v23 = v22 - *a3;
      if (v23 == 88)
      {
        *(_DWORD *)(v21 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v23 >> 3)) >= 2)
      {
        if (v12 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v21 != v22)
        {
          *(float *)(v21 + 32) = *(float *)(v21 + 32) / v12;
          v21 += 88;
        }
      }
    }
  }
}

void sub_19E083820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  *(void *)(v32 + ++**(_DWORD **)(result + 8) = v33;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  if (a32 && BYTE6(a31) == 1) {
    free(a32);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E0838E8(unsigned int ***a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (v4[8] != 1) {
    sub_19E07D5D0();
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  if (*a2) {
    BOOL v7 = *(void *)v4 == -1;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || *v6 == 0) {
    goto LABEL_11;
  }
  int v36 = 0;
  if (!sub_19E0C3B60((void *)a2 + 6, v4, &v36) || (~v36 & 0x7FFFFF) == 0) {
    goto LABEL_11;
  }
  if (!*(void *)v4) {
    __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 531, "!cursor.is_root()");
  }
  if ((v36 & 0x400000) != 0 || (unsigned int v9 = v36 & 0x1FFFFF, (v36 & 0x1FFFFF) == 0))
  {
    if (v36 & 0x400000) == 0 && (sub_19E0F85AC((uint64_t)(a2 + 40), (uint64_t)v4))
    {
LABEL_11:
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      return;
    }
    sub_19E0D2DEC((uint64_t)v33, (uint64_t)(a2 + 112), v6);
    if (!v33[0]) {
      __assert_rtn("derive_words_at_cursor", "LXWordTrie.cpp", 542, "!derived_base_form.is_empty()");
    }
    sub_19E039858((uint64_t)&v36, v33);
    BYTE4(v39) = 0;
    *(void *)((char *)&v39 + 5) = 0;
    long long v40 = 0uLL;
    *(void *)&long long v41 = 0xFFFFFFFFLL;
    BYTE8(v41) = 0;
    HIDWORD(v41) = 0;
    __int16 v42 = 0;
    LODWORD(v39) = 1065353216;
    if (a2[6]) {
      HIDWORD(v4sub_19E03D880(&a9, 0) = -1;
    }
    sub_19E039858((uint64_t)&v26, (unsigned __int16 *)&v36);
    long long v29 = v39;
    long long v30 = v40;
    long long v31 = v41;
    __int16 v32 = v42;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    long long v24 = operator new(0x58uLL);
    *a3 = (uint64_t)v24;
    a3[1] = (uint64_t)v24;
    a3[2] = (uint64_t)v24 + 88;
    sub_19E039858((uint64_t)v24, (unsigned __int16 *)&v26);
    long long v25 = v30;
    v24[2] = v29;
    unsigned char v24[3] = v25;
    void v24[4] = v31;
    *((_WORD *)v24 + 4sub_19E03D880(&a9, 0) = v32;
    a3[1] = (uint64_t)v24 + 88;
    if (v28 && v27 == 1) {
      free(v28);
    }
    if (v38 && v37 == 1) {
      free(v38);
    }
    if (v35 && v34 == 1) {
      free(v35);
    }
  }
  else
  {
    int v10 = *a2;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    if (v10)
    {
      unsigned int v11 = 0;
      unsigned int v26 = v9;
      float v12 = 0.0;
      do
      {
        sub_19E0F8A70((uint64_t)&v36, (uint64_t)a2, v9, (int *)&v26, v6);
        float v13 = *(float *)&v39;
        if ((_WORD)v36)
        {
          unint64_t v14 = a3[1];
          if (v14 >= a3[2])
          {
            uint64_t v18 = sub_19E086C04(a3, (uint64_t)&v36);
          }
          else
          {
            sub_19E039858(a3[1], (unsigned __int16 *)&v36);
            long long v16 = v40;
            long long v15 = v41;
            long long v17 = v39;
            *(_WORD *)(v14 + 8sub_19E03D880(&a9, 0) = v42;
            *(_OWORD *)(v14 + 4++**(_DWORD **)(result + 8) = v16;
            *(_OWORD *)(v14 + 64) = v15;
            *(_OWORD *)(v14 + 32) = v17;
            uint64_t v18 = v14 + 88;
            a3[1] = v14 + 88;
          }
          a3[1] = v18;
        }
        if (v38) {
          BOOL v19 = v37 == 1;
        }
        else {
          BOOL v19 = 0;
        }
        if (v19) {
          free(v38);
        }
        float v12 = v12 + v13;
        unsigned int v9 = v26;
        if (!v26) {
          break;
        }
      }
      while (v11++ < 0xFF);
      uint64_t v21 = *a3;
      uint64_t v22 = a3[1];
      uint64_t v23 = v22 - *a3;
      if (v23 == 88)
      {
        *(_DWORD *)(v21 + 32) = 1065353216;
      }
      else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v23 >> 3)) >= 2)
      {
        if (v12 <= 0.0) {
          __assert_rtn("derive_words_at_offset", "LXWordTrie.cpp", 616, "termination_prob > 0");
        }
        while (v21 != v22)
        {
          *(float *)(v21 + 32) = *(float *)(v21 + 32) / v12;
          v21 += 88;
        }
      }
    }
  }
}

void sub_19E083CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  *(void *)(v32 + ++**(_DWORD **)(result + 8) = v33;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  if (a32 && BYTE6(a31) == 1) {
    free(a32);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E083D70(char ***a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **a1;
  if (*((_DWORD *)v4 + 8)) {
    sub_19E07D5D0();
  }
  if (!*(unsigned char *)(a2 + 20)) {
    goto LABEL_6;
  }
  if (*v4 < 0) {
    goto LABEL_6;
  }
  uint64_t v6 = (unsigned __int16 *)(*a1)[1];
  if (!*v6) {
    goto LABEL_6;
  }
  unsigned int v7 = *((_DWORD *)v4 + 2);
  if ((HIBYTE(v7) & 3) > *v4) {
    goto LABEL_6;
  }
  if (*v4) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = v7 == 0;
  }
  if (v8)
  {
    if (!v4[24]) {
      __assert_rtn("derive_words_at_cursor", "TIWordTrie.cpp", 788, "!cursor.is_root()");
    }
  }
  else
  {
    if ((v7 & 0x20000000) != 0)
    {
      unsigned int v9 = *((_DWORD *)v4 + 4) & 0x7FFFFFFF;
      if (v9)
      {
        unsigned int v10 = 0;
        *a3 = 0;
        a3[1] = 0;
        a3[2] = 0;
        unsigned int v28 = v9;
        float v11 = 0.0;
        do
        {
          sub_19E0DF140((uint64_t)v38, a2, v9, (int *)&v28, v6);
          float v12 = *(float *)&v41;
          if (v38[0])
          {
            unint64_t v13 = a3[1];
            if (v13 >= a3[2])
            {
              uint64_t v17 = sub_19E086C04(a3, (uint64_t)v38);
            }
            else
            {
              sub_19E039858(a3[1], v38);
              long long v15 = v42;
              long long v14 = v43;
              long long v16 = v41;
              *(_WORD *)(v13 + 8sub_19E03D880(&a9, 0) = v44;
              *(_OWORD *)(v13 + 4++**(_DWORD **)(result + 8) = v15;
              *(_OWORD *)(v13 + 64) = v14;
              *(_OWORD *)(v13 + 32) = v16;
              uint64_t v17 = v13 + 88;
              a3[1] = v13 + 88;
            }
            a3[1] = v17;
          }
          if (v40) {
            BOOL v18 = v39 == 1;
          }
          else {
            BOOL v18 = 0;
          }
          if (v18) {
            free(v40);
          }
          float v11 = v11 + v12;
          unsigned int v9 = v28;
          if (!v28) {
            break;
          }
        }
        while (v10++ < 0xFF);
        uint64_t v20 = *a3;
        uint64_t v21 = a3[1];
        uint64_t v22 = v21 - *a3;
        if (v22 == 88)
        {
          *(_DWORD *)(v20 + 32) = 1065353216;
        }
        else if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * (v22 >> 3)) >= 2)
        {
          if (v11 <= 0.0) {
            __assert_rtn("derive_words_at_offset", "TIWordTrie.cpp", 855, "termination_prob > 0");
          }
          while (v20 != v21)
          {
            *(float *)(v20 + 32) = *(float *)(v20 + 32) / v11;
            v20 += 88;
          }
        }
        return;
      }
    }
    if ((v7 & 0x10000000) != 0) {
      goto LABEL_37;
    }
    if ((v7 & 0xFFFFFF) != 0)
    {
LABEL_6:
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      return;
    }
  }
  if (!v4[20]) {
    goto LABEL_6;
  }
LABEL_37:
  sub_19E0D2DEC((uint64_t)v35, a2 + 12920, v6);
  if (!v35[0]) {
    __assert_rtn("derive_words_at_cursor", "TIWordTrie.cpp", 798, "!derived_base_form.is_empty()");
  }
  sub_19E039858((uint64_t)v38, v35);
  BYTE4(v41) = 0;
  *(void *)((char *)&v41 + 5) = 0;
  long long v42 = 0uLL;
  *(void *)&long long v43 = 0xFFFFFFFFLL;
  BYTE8(v43) = 0;
  HIDWORD(v43) = 0;
  __int16 v44 = 0;
  LODWORD(v41) = 1065353216;
  if ((*(unsigned char *)(a2 + 12906) & 1) == 0) {
    goto LABEL_56;
  }
  int v23 = *((_DWORD *)v4 + 2);
  if ((v23 & 0xFFFFFF) == 0)
  {
    uint64_t v25 = *((void *)v4 + 2);
    if ((v23 & 0x10000000) == 0)
    {
      int v24 = 0;
      if ((v25 & 0xFF00000000) == 0) {
        goto LABEL_55;
      }
    }
    goto LABEL_46;
  }
  if ((v23 & 0x10000000) != 0)
  {
    LODWORD(v25) = *((_DWORD *)v4 + 4);
LABEL_46:
    if ((v25 & 0x8000) != 0) {
      int v24 = v25 & 0x7F00 | BYTE2(v25);
    }
    else {
      int v24 = BYTE1(v25);
    }
    goto LABEL_55;
  }
  int v24 = 0;
LABEL_55:
  HIDWORD(v42) = v24;
LABEL_56:
  sub_19E039858((uint64_t)&v28, v38);
  long long v31 = v41;
  long long v32 = v42;
  long long v33 = v43;
  __int16 v34 = v44;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  unsigned int v26 = operator new(0x58uLL);
  *a3 = (uint64_t)v26;
  a3[1] = (uint64_t)v26;
  a3[2] = (uint64_t)v26 + 88;
  sub_19E039858((uint64_t)v26, (unsigned __int16 *)&v28);
  long long v27 = v32;
  v26[2] = v31;
  v26[3] = v27;
  v26[4] = v33;
  *((_WORD *)v26 + 4sub_19E03D880(&a9, 0) = v34;
  a3[1] = (uint64_t)v26 + 88;
  if (v30 && v29 == 1) {
    free(v30);
  }
  if (v40 && v39 == 1) {
    free(v40);
  }
  if (v37 && v36 == 1) {
    free(v37);
  }
}

void sub_19E08416C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t a11, int a12, __int16 a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  *(void *)(v32 + ++**(_DWORD **)(result + 8) = v33;
  sub_19E07F830(&a10);
  if (a15 && a14 == 1) {
    free(a15);
  }
  if (a32 && BYTE6(a31) == 1) {
    free(a32);
  }
  if (a28)
  {
    if (a27 == 1) {
      free(a28);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E084234(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 12) {
    sub_19E07D5D0();
  }
  int v5 = 0;
  if (*(_DWORD *)(v3 + 12) == -1 || *(unsigned char *)(v3 + 9)) {
    return 0;
  }
  uint64_t result = sub_19E0FCE84((uint64_t *)(a2 + 40), v3, &v5);
  if (result) {
    return (HIBYTE(v5) >> 6) & 1;
  }
  return result;
}

uint64_t sub_19E0842A4(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (v3[8] != 11) {
    sub_19E07D5D0();
  }
  uint64_t result = 0;
  int v5 = 0;
  if ((unint64_t)(*(void *)v3 + 1) >= 2)
  {
    uint64_t result = sub_19E0FB15C((void *)(a2 + 40), v3, &v5);
    if (result) {
      return (HIBYTE(v5) >> 6) & 1;
    }
  }
  return result;
}

uint64_t sub_19E084310(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 10) {
    sub_19E07D5D0();
  }
  uint64_t result = 0;
  int v6 = 0;
  if (*(void *)v3) {
    BOOL v5 = *(void *)v3 == 0xFFFFFFFFLL;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t result = sub_19E0FBF94((uint64_t *)(a2 + 40), v3, &v6);
    if (result) {
      return (HIBYTE(v6) >> 6) & 1;
    }
  }
  return result;
}

uint64_t sub_19E084380(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 9) {
    sub_19E07D5D0();
  }
  uint64_t result = 0;
  int v5 = 0;
  if ((unint64_t)(*(void *)v3 + 1) >= 2)
  {
    uint64_t result = sub_19E0FB81C(a2 + 40, (unint64_t *)v3, &v5);
    if (result) {
      return (HIBYTE(v5) >> 6) & 1;
    }
  }
  return result;
}

uint64_t sub_19E0843EC(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (v3[8] != 8) {
    sub_19E07D5D0();
  }
  uint64_t result = 0;
  int v5 = 0;
  if ((unint64_t)(*(void *)v3 + 1) >= 2)
  {
    uint64_t result = sub_19E0FB15C((void *)(a2 + 40), v3, &v5);
    if (result) {
      return (HIBYTE(v5) >> 6) & 1;
    }
  }
  return result;
}

uint64_t sub_19E084458(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 7) {
    sub_19E07D5D0();
  }
  uint64_t result = 0;
  int v5 = 0;
  if ((unint64_t)(*(void *)v3 + 1) >= 2)
  {
    uint64_t result = sub_19E0FAA94((uint64_t *)(a2 + 40), (uint64_t *)v3, &v5);
    if (result) {
      return (HIBYTE(v5) >> 6) & 1;
    }
  }
  return result;
}

BOOL sub_19E0844C4(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 6) {
    sub_19E07D5D0();
  }
  if (*(_DWORD *)(v3 + 12) != -1
    && !*(unsigned char *)(v3 + 9)
    && (int v5 = 0, sub_19E06E5B4((uint64_t *)(a2 + 48), v3, &v5))
    && (~v5 & 0x7FFFFF) != 0)
  {
    return (v5 & 0x600000) == 0x200000;
  }
  else
  {
    return 0;
  }
}

BOOL sub_19E084548(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (v3[8] != 5) {
    sub_19E07D5D0();
  }
  if ((unint64_t)(*(void *)v3 + 1) >= 2
    && (int v5 = 0, sub_19E0C3B60((void *)(a2 + 48), v3, &v5))
    && (~v5 & 0x7FFFFF) != 0)
  {
    return (v5 & 0x600000) == 0x200000;
  }
  else
  {
    return 0;
  }
}

BOOL sub_19E0845C8(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 4) {
    sub_19E07D5D0();
  }
  if (*(void *)v3) {
    BOOL v4 = *(void *)v3 == 0xFFFFFFFFLL;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4 && (v7 = 0, int v6 = sub_19E0B4630((uint64_t *)(a2 + 48), v3, &v7), v6 && (~v7 & 0xFFFFFF) != 0)) {
    return (v7 & 0x600000) == 0x200000;
  }
  else {
    return 0;
  }
}

BOOL sub_19E08464C(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 3) {
    sub_19E07D5D0();
  }
  if ((unint64_t)(*(void *)v3 + 1) >= 2
    && (int v5 = 0, sub_19E0B92A8(a2 + 48, (unint64_t *)v3, &v5))
    && (~v5 & 0x7FFFFF) != 0)
  {
    return (v5 & 0x600000) == 0x200000;
  }
  else
  {
    return 0;
  }
}

BOOL sub_19E0846CC(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 2) {
    sub_19E07D5D0();
  }
  if ((unint64_t)(*(void *)v3 + 1) >= 2
    && (int v5 = 0, sub_19E0CB364((uint64_t *)(a2 + 48), (uint64_t *)v3, &v5))
    && (~v5 & 0x7FFFFF) != 0)
  {
    return (v5 & 0x600000) == 0x200000;
  }
  else
  {
    return 0;
  }
}

BOOL sub_19E08474C(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = **a1;
  if (v3[8] != 1) {
    sub_19E07D5D0();
  }
  if ((unint64_t)(*(void *)v3 + 1) >= 2
    && (int v5 = 0, sub_19E0C3B60((void *)(a2 + 48), v3, &v5))
    && (~v5 & 0x7FFFFF) != 0)
  {
    return (v5 & 0x600000) == 0x200000;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E0847CC(char ***a1)
{
  uint64_t v1 = **a1;
  if (*((_DWORD *)v1 + 8)) {
    sub_19E07D5D0();
  }
  if (*v1 < 0) {
    return 0;
  }
  unsigned int v2 = *((_DWORD *)v1 + 2);
  if (!*v1 && v2 == 0)
  {
    unsigned int v2 = 0;
    if (!v1[24]) {
      return 0;
    }
  }
  if ((HIBYTE(v2) & 3) > *v1) {
    return 0;
  }
  else {
    return v1[19] >> 7;
  }
}

double sub_19E084838(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 12) {
    sub_19E07D5D0();
  }
  sub_19E0FD0A8(v3, a2, *((unsigned char *)v2 + 8));
  return 0.0;
}

double sub_19E084870(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 11) {
    sub_19E07D5D0();
  }
  sub_19E0FB3A4((void *)v3, *(void *)(a2 + 64), *((unsigned __int8 *)v2 + 8));
  return 0.0;
}

double sub_19E0848AC(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 10) {
    sub_19E07D5D0();
  }
  sub_19E0FC260((uint64_t *)v3, a2, *((unsigned char *)v2 + 8));
  return 0.0;
}

double sub_19E0848E4(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 9) {
    sub_19E07D5D0();
  }
  sub_19E0FBA5C((unint64_t *)v3, a2, *((unsigned char *)v2 + 8));
  return 0.0;
}

double sub_19E08491C(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 8) {
    sub_19E07D5D0();
  }
  sub_19E0FB3A4((void *)v3, *(void *)(a2 + 64), *((unsigned __int8 *)v2 + 8));
  return 0.0;
}

double sub_19E084958(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 7) {
    sub_19E07D5D0();
  }
  sub_19E0FACD4((uint64_t *)v3, a2, *((unsigned char *)v2 + 8));
  return 0.0;
}

float sub_19E084990(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 6) {
    sub_19E07D5D0();
  }
  char v4 = *((unsigned char *)v2 + 8);

  return sub_19E0FA690(v3, a2, v4);
}

void sub_19E0849D0(unsigned int ***a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (v3[8] != 5) {
    sub_19E07D5D0();
  }
  int v4 = *((unsigned __int8 *)v2 + 8);

  sub_19E0F875C(v3, a2, v4);
}

float sub_19E084A10(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 4) {
    sub_19E07D5D0();
  }
  char v4 = *((unsigned char *)v2 + 8);

  return sub_19E0F99F8(v3, a2, v4);
}

float sub_19E084A50(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 3) {
    sub_19E07D5D0();
  }
  char v4 = *((unsigned char *)v2 + 8);

  return sub_19E0F9448((unint64_t *)v3, a2, v4);
}

float sub_19E084A90(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (*(_DWORD *)(v3 + 32) != 2) {
    sub_19E07D5D0();
  }
  char v4 = *((unsigned char *)v2 + 8);

  return sub_19E0F8D84((uint64_t *)v3, a2, v4);
}

void sub_19E084AD0(unsigned int ***a1, uint64_t a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (v3[8] != 1) {
    sub_19E07D5D0();
  }
  int v4 = *((unsigned __int8 *)v2 + 8);

  sub_19E0F875C(v3, a2, v4);
}

unsigned int *sub_19E084B10(unsigned int ***a1, uint64_t **a2)
{
  unsigned int v2 = *a1;
  uint64_t v3 = **a1;
  if (v3[8]) {
    sub_19E07D5D0();
  }
  int v4 = *((unsigned __int8 *)v2 + 8);

  return sub_19E0DE9B0(v3, a2, v4);
}

BOOL sub_19E084B4C(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 12) != -1;
}

BOOL sub_19E084B5C(uint64_t a1, void *a2)
{
  return *a2 != -1;
}

BOOL sub_19E084B6C(uint64_t a1, void *a2)
{
  return *a2 != 0xFFFFFFFFLL;
}

BOOL sub_19E084B80(uint64_t a1, void *a2)
{
  return *a2 != -1;
}

BOOL sub_19E084B90(uint64_t a1, void *a2)
{
  return *a2 != -1;
}

BOOL sub_19E084BA0(uint64_t a1, void *a2)
{
  return *a2 != -1;
}

BOOL sub_19E084BB0(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 12) != -1;
}

BOOL sub_19E084BC0(uint64_t a1, void *a2)
{
  return *a2 != -1;
}

BOOL sub_19E084BD0(uint64_t a1, void *a2)
{
  return *a2 != 0xFFFFFFFFLL;
}

BOOL sub_19E084BE4(uint64_t a1, void *a2)
{
  return *a2 != -1;
}

BOOL sub_19E084BF4(uint64_t a1, void *a2)
{
  return *a2 != -1;
}

BOOL sub_19E084C04(uint64_t a1, void *a2)
{
  return *a2 != -1;
}

uint64_t sub_19E084C14(uint64_t a1, unsigned __int8 *a2)
{
  return (*a2 >> 7) ^ 1u;
}

uint64_t sub_19E084C24@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v5[0] = sub_19E04ED9C(*(unsigned int **)(a1 + 48));
  v5[1] = v3;
  int v6 = 12;
  sub_19E105F34(a2, (uint64_t)v5);
  return sub_19E07FA6C((uint64_t)v5);
}

void sub_19E084C74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E084C88@<X0>(uint64_t a1@<X8>)
{
  v2[0] = 0;
  int v3 = 11;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E084CCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E084CE0@<X0>(uint64_t a1@<X8>)
{
  memset(v2, 0, sizeof(v2));
  int v3 = 10;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E084D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E084D3C@<X0>(uint64_t a1@<X8>)
{
  v2[0] = 0;
  int v3 = 9;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E084D80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E084D94@<X0>(uint64_t a1@<X8>)
{
  v2[0] = 0;
  int v3 = 8;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E084DD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E084DEC@<X0>(uint64_t a1@<X8>)
{
  v2[0] = 0;
  int v3 = 7;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E084E30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E084E44@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v5[0] = sub_19E04ED9C(*(unsigned int **)(a1 + 56));
  v5[1] = v3;
  int v6 = 6;
  sub_19E105F34(a2, (uint64_t)v5);
  return sub_19E07FA6C((uint64_t)v5);
}

void sub_19E084E94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E084EA8@<X0>(uint64_t a1@<X8>)
{
  v2[0] = 0;
  int v3 = 5;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E084EEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E084F00@<X0>(uint64_t a1@<X8>)
{
  memset(v2, 0, sizeof(v2));
  int v3 = 4;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E084F48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E084F5C@<X0>(uint64_t a1@<X8>)
{
  v2[0] = 0;
  int v3 = 3;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E084FA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E084FB4@<X0>(uint64_t a1@<X8>)
{
  v2[0] = 0;
  int v3 = 2;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E084FF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E08500C@<X0>(uint64_t a1@<X8>)
{
  v2[0] = 0;
  int v3 = 1;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E085050(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E085064@<X0>(uint64_t a1@<X8>)
{
  v2[0] = 0;
  int v3 = 0;
  uint64_t v4 = 0;
  int v5 = 0;
  int v6 = 0;
  sub_19E105F34(a1, (uint64_t)v2);
  return sub_19E07FA6C((uint64_t)v2);
}

void sub_19E0850B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E07FA6C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E0850C4(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 1488);
  *a2 = *(void *)(a1 + 1480);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E0850E4(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 1504);
  *a2 = *(void *)(a1 + 1496);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E085104(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 1504);
  *a2 = *(void *)(a1 + 1496);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E085124(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 2048);
  *a2 = *(void *)(a1 + 2040);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E085144(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 1480);
  *a2 = *(void *)(a1 + 1472);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E085164(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 1544);
  *a2 = *(void *)(a1 + 1536);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E085184(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 1520);
  *a2 = *(void *)(a1 + 1512);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E0851A4(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 1536);
  *a2 = *(void *)(a1 + 1528);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E0851C4(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 1536);
  *a2 = *(void *)(a1 + 1528);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E0851E4(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 2080);
  *a2 = *(void *)(a1 + 2072);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E085204(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 1576);
  *a2 = *(void *)(a1 + 1568);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E085224(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 1512);
  *a2 = *(void *)(a1 + 1504);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_19E085244(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 14344);
  *a2 = *(void *)(a1 + 14336);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
}

BOOL sub_19E085264(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 1480) != 0;
}

BOOL sub_19E085274(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 1496) != 0;
}

BOOL sub_19E085284(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 1496) != 0;
}

BOOL sub_19E085294(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 2040) != 0;
}

BOOL sub_19E0852A4(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 1472) != 0;
}

BOOL sub_19E0852B4(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 1536) != 0;
}

BOOL sub_19E0852C4(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 1512) != 0;
}

BOOL sub_19E0852D4(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 1528) != 0;
}

BOOL sub_19E0852E4(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 1528) != 0;
}

BOOL sub_19E0852F4(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 2072) != 0;
}

BOOL sub_19E085304(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 1568) != 0;
}

BOOL sub_19E085314(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 1504) != 0;
}

BOOL sub_19E085324(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 14336) != 0;
}

os_log_t sub_19E085334()
{
  os_log_t result = os_log_create("com.apple.Lexicon", "StaticDictionaryImpl");
  qword_1EB4FED68 = (uint64_t)result;
  return result;
}

void sub_19E085364(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)a2;
  uint64_t v5 = a2 + 16;
  unsigned int v4 = *(unsigned __int16 *)(a2 + 16);
  if (v4 <= 0xE) {
    int v6 = (unsigned __int8 *)(v5 + 2);
  }
  else {
    int v6 = *(unsigned __int8 **)(v5 + 8);
  }
  unint64_t v45 = sub_19E0B24AC(v6, v4);
  *(void *)(v5 - ++**(_DWORD **)(result + 8) = v45;
  unint64_t v7 = *(void *)(a1 + 8);
  float v8 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v9 = *(float *)(a1 + 32);
  if (!v7 || (float)(v9 * (float)v7) < v8)
  {
    BOOL v10 = 1;
    if (v7 >= 3) {
      BOOL v10 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v11 = v10 | (2 * v7);
    unint64_t v12 = vcvtps_u32_f32(v8 / v9);
    if (v11 <= v12) {
      int8x8_t prime = (int8x8_t)v12;
    }
    else {
      int8x8_t prime = (int8x8_t)v11;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_102;
    }
    if (*(void *)&prime >= v7) {
      goto LABEL_63;
    }
    unint64_t v21 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v7 < 3 || (uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v22.i16[0] = vaddlv_u8(v22), v22.u32[0] > 1uLL))
    {
      unint64_t v21 = std::__next_prime(v21);
    }
    else
    {
      uint64_t v23 = 1 << -(char)__clz(v21 - 1);
      if (v21 >= 2) {
        unint64_t v21 = v23;
      }
    }
    if (*(void *)&prime <= v21) {
      int8x8_t prime = (int8x8_t)v21;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = *(void *)(a1 + 8);
      goto LABEL_63;
    }
    if (prime)
    {
LABEL_102:
      if (*(void *)&prime >> 61) {
        sub_19E0416C4();
      }
      long long v14 = operator new(8 * *(void *)&prime);
      long long v15 = *(void **)a1;
      *(void *)a1 = v14;
      if (v15) {
        operator delete(v15);
      }
      uint64_t v43 = v5;
      uint64_t v16 = 0;
      *(int8x8_t *)(a1 + ++**(_DWORD **)(result + 8) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v16++) = 0;
      while (*(void *)&prime != v16);
      uint64_t v17 = *(uint64_t **)(a1 + 16);
      if (v17)
      {
        unint64_t v18 = v17[1];
        uint8x8_t v19 = (uint8x8_t)vcnt_s8(prime);
        v19.i16[0] = vaddlv_u8(v19);
        unint64_t v20 = v19.u32[0];
        long long v42 = v2;
        if (v19.u32[0] > 1uLL)
        {
          if (v18 >= *(void *)&prime) {
            v18 %= *(void *)&prime;
          }
        }
        else
        {
          v18 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)a1 + 8 * v1++**(_DWORD **)(result + 8) = a1 + 16;
        uint64_t v24 = *v17;
        if (*v17)
        {
          unint64_t v44 = v19.u32[0];
          do
          {
            unint64_t v25 = *(void *)(v24 + 8);
            if (v20 > 1)
            {
              if (v25 >= *(void *)&prime) {
                v25 %= *(void *)&prime;
              }
            }
            else
            {
              v25 &= *(void *)&prime - 1;
            }
            if (v25 == v18)
            {
              uint64_t v17 = (uint64_t *)v24;
            }
            else if (*(void *)(*(void *)a1 + 8 * v25))
            {
              unsigned int v26 = *(void **)v24;
              if (*(void *)v24)
              {
                long long v27 = (void *)v24;
                while (1)
                {
                  unsigned int v28 = v26;
                  if (!sub_19E0A7134((unsigned __int16 *)(v24 + 16), (unsigned __int16 *)v26 + 8)) {
                    break;
                  }
                  unsigned int v26 = (void *)*v28;
                  long long v27 = v28;
                  if (!*v28) {
                    goto LABEL_50;
                  }
                }
                unsigned int v26 = v28;
                unsigned int v28 = v27;
LABEL_50:
                unint64_t v20 = v44;
              }
              else
              {
                unsigned int v28 = (void *)v24;
              }
              *uint64_t v17 = (uint64_t)v26;
              void *v28 = **(void **)(*(void *)a1 + 8 * v25);
              **(void **)(*(void *)a1 + 8 * v25) = v24;
            }
            else
            {
              *(void *)(*(void *)a1 + 8 * v25) = v17;
              uint64_t v17 = (uint64_t *)v24;
              unint64_t v18 = v25;
            }
            uint64_t v24 = *v17;
          }
          while (*v17);
        }
        unint64_t v7 = (unint64_t)prime;
        uint64_t v2 = v42;
        uint64_t v5 = v43;
      }
      else
      {
        unint64_t v7 = (unint64_t)prime;
        uint64_t v5 = v43;
      }
    }
    else
    {
      char v29 = *(void **)a1;
      *(void *)a1 = 0;
      if (v29) {
        operator delete(v29);
      }
      unint64_t v7 = 0;
      *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
    }
  }
LABEL_63:
  uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
  v30.i16[0] = vaddlv_u8(v30);
  unint64_t v31 = v30.u32[0];
  if (v30.u32[0] > 1uLL)
  {
    unint64_t v32 = v45;
    if (v7 <= v45) {
      unint64_t v32 = v45 % v7;
    }
  }
  else
  {
    unint64_t v32 = (v7 - 1) & v45;
  }
  uint64_t v33 = *(unsigned __int16 **)(*(void *)a1 + 8 * v32);
  if (v33)
  {
    __int16 v34 = *(unsigned __int16 **)v33;
    if (*(void *)v33)
    {
      int v35 = 0;
      do
      {
        char v36 = v34;
        unint64_t v37 = *((void *)v34 + 1);
        if (v31 > 1)
        {
          unint64_t v38 = v37;
          if (v37 >= v7) {
            unint64_t v38 = v37 % v7;
          }
        }
        else
        {
          unint64_t v38 = v37 & (v7 - 1);
        }
        if (v38 != v32) {
          break;
        }
        BOOL v39 = v37 == v45 && sub_19E0A7134(v36 + 8, (unsigned __int16 *)v5);
        if (v35 & !v39) {
          break;
        }
        v35 |= v39;
        __int16 v34 = *(unsigned __int16 **)v36;
        uint64_t v33 = v36;
      }
      while (*(void *)v36);
    }
  }
  unint64_t v40 = v2[1];
  if (v31 > 1)
  {
    if (v40 >= v7) {
      v40 %= v7;
    }
  }
  else
  {
    v40 &= v7 - 1;
  }
  if (!v33)
  {
    void *v2 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v2;
    *(void *)(*(void *)a1 + 8 * v4sub_19E03D880(&a9, 0) = a1 + 16;
    if (!*v2) {
      goto LABEL_98;
    }
    unint64_t v41 = *(void *)(*v2 + 8);
    if (v31 > 1)
    {
      if (v41 >= v7) {
        v41 %= v7;
      }
    }
    else
    {
      v41 &= v7 - 1;
    }
LABEL_97:
    *(void *)(*(void *)a1 + 8 * v41) = v2;
    goto LABEL_98;
  }
  void *v2 = *(void *)v33;
  *(void *)uint64_t v33 = v2;
  if (*v2)
  {
    unint64_t v41 = *(void *)(*v2 + 8);
    if (v31 > 1)
    {
      if (v41 >= v7) {
        v41 %= v7;
      }
    }
    else
    {
      v41 &= v7 - 1;
    }
    if (v41 != v40) {
      goto LABEL_97;
    }
  }
LABEL_98:
  ++*(void *)(a1 + 24);
}

void sub_19E085810(char a1, void *__p)
{
  if (a1)
  {
    if (*((unsigned __int16 *)__p + 8) >= 0xFu)
    {
      uint64_t v3 = __p[3];
      if (v3) {
        MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
      }
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t sub_19E085888(uint64_t a1, uint64_t a2)
{
  return a2 + 88;
}

uint64_t sub_19E085890(uint64_t a1, uint64_t a2)
{
  return a2 + 104;
}

uint64_t sub_19E085898(uint64_t a1, uint64_t a2)
{
  return a2 + 104;
}

uint64_t sub_19E0858A0(uint64_t a1, uint64_t a2)
{
  return a2 + 648;
}

uint64_t sub_19E0858A8(uint64_t a1, uint64_t a2)
{
  return a2 + 80;
}

uint64_t sub_19E0858B0(uint64_t a1, uint64_t a2)
{
  return a2 + 144;
}

uint64_t sub_19E0858B8(uint64_t a1, uint64_t a2)
{
  return a2 + 120;
}

uint64_t sub_19E0858C0(uint64_t a1, uint64_t a2)
{
  return a2 + 136;
}

uint64_t sub_19E0858C8(uint64_t a1, uint64_t a2)
{
  return a2 + 136;
}

uint64_t sub_19E0858D0(uint64_t a1, uint64_t a2)
{
  return a2 + 680;
}

uint64_t sub_19E0858D8(uint64_t a1, uint64_t a2)
{
  return a2 + 176;
}

uint64_t sub_19E0858E0(uint64_t a1, uint64_t a2)
{
  return a2 + 112;
}

uint64_t sub_19E0858E8(uint64_t a1, uint64_t a2)
{
  return a2 + 12920;
}

void sub_19E0858F4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E0859A4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E085A54(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E085B04(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E085BB4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E085C64(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E085D14(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E085DC4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E085E74(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E085F24(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E085FD4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E086084(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (mlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for words file");
    if (mlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"mlock() failed for index file");
  }
}

void sub_19E086134(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 20))
  {
    uint64_t v3 = (unsigned char *)(a2 + 14328);
    sub_19E0413C8(__p, "words");
    sub_19E03D510(v3, *(void *)(a2 + 8), (uint64_t)__p);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
    sub_19E0413C8(__p, "index");
    sub_19E03D510((unsigned char *)(a2 + 14329), *(void *)a2, (uint64_t)__p);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_19E0861D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E0861F4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E0862A4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E086354(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E086404(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E0864B4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E086564(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E086614(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E0866C4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E086774(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E086824(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E0868D4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E086984(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (munlock(**(const void ***)(a2 + 24), *(void *)(*(void *)(a2 + 24) + 8)))
    {
      uint64_t v3 = *__error();
      unsigned int v4 = std::generic_category();
    }
    else
    {
      unsigned int v4 = std::system_category();
      uint64_t v3 = 0;
    }
    *(void *)&v7.__val_ = v3;
    v7.__cat_ = v4;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for words file");
    if (munlock(**(const void ***)(a2 + 32), *(void *)(*(void *)(a2 + 32) + 8)))
    {
      uint64_t v5 = *__error();
      int v6 = std::generic_category();
    }
    else
    {
      int v6 = std::system_category();
      uint64_t v5 = 0;
    }
    *(void *)&v7.__val_ = v5;
    v7.__cat_ = v6;
    sub_19E0FDDD0(&v7, (uint64_t)"munlock() failed for index file");
  }
}

void sub_19E086A34(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 20))
  {
    uint64_t v3 = (unsigned char *)(a2 + 14328);
    sub_19E0413C8(&__p, "words");
    sub_19E0DFD18(v3, *(void *)(a2 + 8), &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_19E0413C8(&__p, "index");
    sub_19E0DFD18((unsigned char *)(a2 + 14329), *(void *)a2, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_19E086AD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E086AF4(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t *)result;
    unint64_t v6 = *(void *)(result + 8);
    do
    {
      for (uint64_t i = *v5; i != v6; i += 88)
      {
        if (i != v4)
        {
          os_log_t result = sub_19E0B2428((unsigned __int16 *)i, (unsigned __int16 *)v4);
          if (!result) {
            continue;
          }
        }
        if (*(_DWORD *)(i + 40) == *(_DWORD *)(v4 + 40))
        {
          if (i != v6)
          {
            *(float *)(i + 32) = *(float *)(i + 32) + *(float *)(v4 + 32);
            *(_DWORD *)(i + 36) = *(_DWORD *)(v4 + 36);
            *(_DWORD *)(i + 56) = *(_DWORD *)(v4 + 56);
            goto LABEL_15;
          }
          break;
        }
      }
      if (v6 >= v5[2])
      {
        os_log_t result = sub_19E086C04(v5, v4);
        unint64_t v6 = result;
      }
      else
      {
        os_log_t result = sub_19E039858(v6, (unsigned __int16 *)v4);
        long long v8 = *(_OWORD *)(v4 + 32);
        long long v9 = *(_OWORD *)(v4 + 48);
        long long v10 = *(_OWORD *)(v4 + 64);
        *(_WORD *)(v6 + 8sub_19E03D880(&a9, 0) = *(_WORD *)(v4 + 80);
        *(_OWORD *)(v6 + 4++**(_DWORD **)(result + 8) = v9;
        *(_OWORD *)(v6 + 64) = v10;
        *(_OWORD *)(v6 + 32) = v8;
        v6 += 88;
        v5[1] = v6;
      }
      v5[1] = v6;
LABEL_15:
      v4 += 88;
    }
    while (v4 != a3);
  }
  return result;
}

void sub_19E086BFC(_Unwind_Exception *a1)
{
  *(void *)(v1 + ++**(_DWORD **)(result + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_19E086C04(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_19E041BEC();
  }
  unint64_t v6 = a1 + 2;
  if (0x5D1745D1745D1746 * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5D1745D1745D1746 * ((a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((a1[2] - *a1) >> 3)) >= 0x1745D1745D1745DLL) {
    unint64_t v7 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v7 = v3;
  }
  unint64_t v20 = v6;
  if (v7)
  {
    long long v9 = (char *)sub_19E086D44(v7);
  }
  else
  {
    long long v9 = 0;
    uint64_t v8 = 0;
  }
  uint64_t v16 = v9;
  uint64_t v17 = &v9[88 * v2];
  uint64_t v18 = (uint64_t)v17;
  uint8x8_t v19 = &v9[88 * v8];
  sub_19E039858((uint64_t)v17, (unsigned __int16 *)a2);
  uint64_t v10 = (uint64_t)v17;
  long long v12 = *(_OWORD *)(a2 + 48);
  long long v11 = *(_OWORD *)(a2 + 64);
  __int16 v13 = *(_WORD *)(a2 + 80);
  *((_OWORD *)v17 + 2) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v10 + 4++**(_DWORD **)(result + 8) = v12;
  *(_WORD *)(v10 + 8sub_19E03D880(&a9, 0) = v13;
  *(_OWORD *)(v10 + 64) = v11;
  v18 += 88;
  sub_19E086D90(a1, &v16);
  uint64_t v14 = a1[1];
  sub_19E086E98((uint64_t)&v16);
  return v14;
}

void sub_19E086D30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E086E98((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_19E086D44(unint64_t a1)
{
  if (a1 >= 0x2E8BA2E8BA2E8BBLL) {
    sub_19E0416C4();
  }
  return operator new(88 * a1);
}

uint64_t *sub_19E086D90(uint64_t *result, void *a2)
{
  unint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = v6 + v7;
      os_log_t result = (uint64_t *)sub_19E039858(v6 + v7 - 88, (unsigned __int16 *)(v4 + v7 - 88));
      long long v9 = *(_OWORD *)(v4 + v7 - 56);
      long long v10 = *(_OWORD *)(v4 + v7 - 40);
      long long v11 = *(_OWORD *)(v4 + v7 - 24);
      *(_WORD *)(v8 - ++**(_DWORD **)(result + 8) = *(_WORD *)(v4 + v7 - 8);
      *(_OWORD *)(v8 - 24) = v11;
      *(_OWORD *)(v8 - 4sub_19E03D880(&a9, 0) = v10;
      *(_OWORD *)(v8 - 56) = v9;
      v7 -= 88;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v12 = *v3;
  uint64_t *v3 = v6;
  a2[1] = v12;
  uint64_t v13 = v3[1];
  v3[1] = a2[2];
  a2[2] = v13;
  uint64_t v14 = v3[2];
  v3[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return result;
}

uint64_t sub_19E086E98(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 88;
      *(void *)(a1 + 16) = v2 - 88;
      uint64_t v5 = *(void **)(v2 - 80);
      if (v5 && *(unsigned char *)(v2 - 82) == 1)
      {
        free(v5);
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

unint64_t sub_19E086F04(uint64_t a1)
{
  size_t v2 = *(unsigned __int16 *)(a1 + 152);
  if (v2 < 0xF) {
    uint64_t v3 = (void *)(a1 + 154);
  }
  else {
    uint64_t v3 = *(void **)(a1 + 160);
  }
  sub_19E057A94(__p, v3, v2);
  if ((v10 & 0x80u) == 0) {
    uint64_t v4 = (uint64_t *)__p;
  }
  else {
    uint64_t v4 = (uint64_t *)__p[0];
  }
  if ((v10 & 0x80u) == 0) {
    unint64_t v5 = v10;
  }
  else {
    unint64_t v5 = (unint64_t)__p[1];
  }
  unint64_t v6 = sub_19E086FCC(v4, v5);
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 112))(*(void *)(a1 + 8));
  if ((char)v10 < 0) {
    operator delete(__p[0]);
  }
  return v7 ^ v6;
}

void sub_19E086FB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_19E086FCC(uint64_t *a1, unint64_t a2)
{
  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      uint64_t v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      uint64_t v6 = *a1 - 0x3C5A37A36834CED9 * (v5 + a2);
      uint64_t v8 = a1[2];
      uint64_t v7 = a1[3];
      uint64_t v9 = __ROR8__(v6 + v7, 52);
      uint64_t v10 = v6 + a1[1];
      uint64_t v11 = __ROR8__(v10, 7);
      uint64_t v12 = v10 + v8;
      uint64_t v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      uint64_t v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      uint64_t v15 = __ROR8__(v14 + v13, 52);
      uint64_t v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v5 + a2), 37) + v9;
      uint64_t v17 = __ROR8__(v13, 37);
      uint64_t v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      uint64_t v19 = __ROR8__(v18, 7);
      uint64_t v20 = v16 + __ROR8__(v12, 31);
      uint64_t v21 = v18 + v5;
      uint64_t v22 = v21 + v14;
      unint64_t v23 = 0x9AE16A3B2F90404FLL;
      unint64_t v24 = 0xC3A5C85C97CB3127 * (v22 + v20) - 0x651E95C4D06FBFB1 * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      unint64_t v25 = v20 - 0x3C5A37A36834CED9 * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }
    unint64_t v4 = 0x9DDFEA08EB382D69;
    uint64_t v32 = *(uint64_t *)((char *)a1 + a2 - 48);
    uint64_t v33 = *(uint64_t *)((char *)a1 + a2 - 40);
    uint64_t v34 = *(uint64_t *)((char *)a1 + a2 - 24);
    uint64_t v36 = *(uint64_t *)((char *)a1 + a2 - 64);
    uint64_t v35 = *(uint64_t *)((char *)a1 + a2 - 56);
    uint64_t v37 = *(uint64_t *)((char *)a1 + a2 - 16);
    uint64_t v38 = *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v39 = v35 + v37;
    unint64_t v40 = 0x9DDFEA08EB382D69
        * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))));
    unint64_t v41 = 0x9DDFEA08EB382D69 * (v40 ^ (v40 >> 47));
    unint64_t v42 = v36 + a2 + v35 + v32;
    uint64_t v43 = v42 + v33;
    unint64_t v44 = __ROR8__(v42, 44) + v36 + a2 + __ROR8__(v33 + v36 + a2 - 0x622015F714C7D297 * (v40 ^ (v40 >> 47)), 21);
    uint64_t v45 = v35 + v37 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    uint64_t v46 = v45 + v34 + v37;
    uint64_t v47 = __ROR8__(v46, 44);
    uint64_t v48 = v46 + v38;
    uint64_t v49 = v47 + v45 + __ROR8__(v45 + v33 + v38, 21);
    uint64_t v51 = *a1;
    std::string::size_type v50 = a1 + 4;
    unint64_t v52 = v51 - 0x4B6D499041670D8DLL * v33;
    uint64_t v53 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      uint64_t v54 = *(v50 - 3);
      uint64_t v55 = v52 + v43 + v39 + v54;
      uint64_t v56 = v50[2];
      uint64_t v57 = v50[3];
      uint64_t v58 = v50[1];
      unint64_t v39 = v58 + v43 - 0x4B6D499041670D8DLL * __ROR8__(v39 + v44 + v56, 42);
      uint64_t v59 = v41 + v48;
      uint64_t v60 = *(v50 - 2);
      uint64_t v61 = *(v50 - 1);
      uint64_t v62 = *(v50 - 4) - 0x4B6D499041670D8DLL * v44;
      uint64_t v63 = v62 + v48 + v61;
      uint64_t v64 = v62 + v54 + v60;
      uint64_t v43 = v64 + v61;
      uint64_t v65 = __ROR8__(v64, 44) + v62;
      unint64_t v66 = (0xB492B66FBE98F273 * __ROR8__(v55, 37)) ^ v49;
      unint64_t v52 = 0xB492B66FBE98F273 * __ROR8__(v59, 33);
      unint64_t v44 = v65 + __ROR8__(v63 + v66, 21);
      unint64_t v67 = v52 + v49 + *v50;
      uint64_t v48 = v67 + v58 + v56 + v57;
      uint64_t v49 = __ROR8__(v67 + v58 + v56, 44) + v67 + __ROR8__(v39 + v60 + v67 + v57, 21);
      v50 += 8;
      unint64_t v41 = v66;
      v53 += 64;
    }
    while (v53);
    unint64_t v68 = v52
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) >> 47));
    unint64_t v69 = 0x9DDFEA08EB382D69
        * (v68 ^ (v66
                - 0x4B6D499041670D8DLL * (v39 ^ (v39 >> 47))
                - 0x622015F714C7D297
                * ((0x9DDFEA08EB382D69
                  * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) ^ ((0x9DDFEA08EB382D69 * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) >> 47))));
    unint64_t v70 = 0x9DDFEA08EB382D69 * (v68 ^ (v69 >> 47) ^ v69);
    goto LABEL_13;
  }
  if (a2 > 0x10)
  {
    uint64_t v26 = a1[1];
    unint64_t v27 = 0xB492B66FBE98F273 * *a1;
    uint64_t v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    unint64_t v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v23 = 0x9DDFEA08EB382D69;
    unint64_t v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v28 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a1 + a2 - 16)));
    unint64_t v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    unint64_t v25 = 0x9DDFEA08EB382D69 * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }
  if (a2 < 9)
  {
    if (a2 >= 4)
    {
      uint64_t v72 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v23 = 0x9DDFEA08EB382D69;
      unint64_t v73 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a1) + a2) ^ v72);
      unint64_t v31 = v72 ^ (v73 >> 47) ^ v73;
      goto LABEL_8;
    }
    unint64_t v4 = 0x9AE16A3B2F90404FLL;
    if (!a2) {
      return v4;
    }
    unint64_t v70 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v4 *= v70 ^ (v70 >> 47);
    return v4;
  }
  uint64_t v2 = *(uint64_t *)((char *)a1 + a2 - 8);
  uint64_t v3 = __ROR8__(v2 + a2, a2);
  return (0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) >> 47))) ^ v2;
}

uint64_t sub_19E087400(uint64_t a1)
{
  if (*(int *)(a1 + 104) > 0) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v6 = a1 + 16;
  uint64_t v4 = *(unsigned int *)(v3 + 14360);
  if (v4 == -1) {
    goto LABEL_9;
  }
  uint64_t v7 = &v6;
  if (((uint64_t (*)(uint64_t **, uint64_t))off_1EF09EDD0[v4])(&v7, v3 + 8)) {
    return 1;
  }
  uint64_t v6 = a1 + 56;
  uint64_t v5 = *(unsigned int *)(v3 + 28720);
  if (v5 == -1) {
LABEL_9:
  }
    sub_19E07D5D0();
  uint64_t v7 = &v6;
  return ((uint64_t (*)(uint64_t **, uint64_t))off_1EF09EDD0[v5])(&v7, v3 + 14368);
}

uint64_t sub_19E0874C0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 192);
}

const void *sub_19E0874C8(uint64_t a1)
{
  sub_19E03FD18((CFStringRef *)&v3, (unsigned __int16 *)(a1 + 120));
  uint64_t v1 = v3;
  uint64_t v3 = 0;
  sub_19E040A10(&v3);
  return v1;
}

uint64_t sub_19E08750C()
{
  return 0;
}

uint64_t sub_19E087514()
{
  return 0;
}

double sub_19E08751C(uint64_t a1)
{
  float v1 = sub_19E0E5BFC(a1 + 16, *(void *)(a1 + 8) + 8);
  return log10f(v1);
}

double sub_19E08754C(uint64_t a1)
{
  return *(double *)(a1 + 208);
}

double sub_19E087554(uint64_t a1)
{
  return *(double *)(a1 + 200);
}

void sub_19E08755C(uint64_t a1, uint64_t a2)
{
  char v4 = 0;
  uint64_t v2 = *(void *)(a1 + 8) + 8;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = sub_19E087634;
  v3[3] = &unk_1E599BD28;
  v3[4] = a2;
  v3[5] = a1;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = sub_19E087730;
  void v5[3] = &unk_1E599BDA0;
  v5[6] = a1 + 152;
  v5[7] = a1 + 120;
  unsigned char v5[8] = 0;
  v5[9] = &v4;
  void v5[4] = v3;
  void v5[5] = v2;
  sub_19E0E5CE4((int *)(a1 + 16), v2, (uint64_t)v5);
}

void sub_19E087634(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4, double a5)
{
  uint64_t v10 = *(void *)(a1 + 40);
  double v11 = *(double *)(v10 + 208);
  if (qword_1EB4FEE18 != -1) {
    dispatch_once(&qword_1EB4FEE18, &unk_1EF09AC10);
  }
  uint64_t Instance = (const void *)_CFRuntimeCreateInstance();
  sub_19E087A54((uint64_t)Instance + 16, *(void *)(v10 + 8), a2, a3, a4, a5, v11 + a5);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

  CFRelease(Instance);
}

void sub_19E087730(uint64_t a1, uint64_t a2, BOOL *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  sub_19E0D29A8((uint64_t)&v17, *(void *)(a1 + 40) + 28744, *(unsigned __int16 **)(a1 + 48), *(unsigned char *)(a2 + 84));
  if (v21 == -1)
  {
    sub_19E0D29A8((uint64_t)&v22, *(void *)(a1 + 40) + 28744, *(unsigned __int16 **)(a1 + 48), *(unsigned char *)(a2 + 84));
    if ((unsigned __int16)v25 >= 0xFu && v26) {
      MEMORY[0x19F3BA6E0](v26, 0x1000C8077774924);
    }
    if ((unsigned __int16)v22 >= 0xFu && v23) {
      MEMORY[0x19F3BA6E0](v23, 0x1000C8077774924);
    }
  }
  else if (v21 == -2)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 56);
    double v8 = *(double *)(a1 + 64);
    float v9 = sub_19E0E5450(a2, v6);
    float v10 = log10f(v9);
    uint64_t v11 = *(void *)(a1 + 72);
    uint64_t v12 = *(void *)(a1 + 32);
    uint64_t v22 = MEMORY[0x1E4F143A8];
    unint64_t v23 = (void *)0x40000000;
    unint64_t v24 = sub_19E087730;
    unint64_t v25 = &unk_1E599BDA0;
    uint64_t v28 = &v17;
    uint64_t v29 = v7;
    double v30 = v8 + v10;
    uint64_t v31 = v11;
    uint64_t v26 = v12;
    uint64_t v27 = v6;
    sub_19E0E5CE4((int *)a2, v6, (uint64_t)&v22);
  }
  else
  {
    uint64_t v13 = *(void *)(a1 + 32);
    sub_19E0B2328((uint64_t)&v22, *(unsigned __int16 **)(a1 + 56), v21);
    double v14 = *(double *)(a1 + 64);
    float v15 = sub_19E0E5450(a2, *(void *)(a1 + 40));
    float v16 = log10f(v15);
    (*(void (**)(uint64_t, uint64_t, uint64_t *, unsigned __int16 *, void, double))(v13 + 16))(v13, a2, &v22, &v17, *(void *)(a1 + 72), v14 + v16);
    if (v23 && BYTE6(v22) == 1) {
      free(v23);
    }
  }
  *a3 = **(unsigned char **)(a1 + 72) != 0;
  if (v19 >= 0xFu && v20) {
    MEMORY[0x19F3BA6E0](v20, 0x1000C8077774924);
  }
  if (v17 >= 0xFu)
  {
    if (v18) {
      MEMORY[0x19F3BA6E0](v18, 0x1000C8077774924);
    }
  }
}

void sub_19E08799C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, unsigned __int16 a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, void *a19)
{
}

unsigned __int16 *sub_19E0879E0(unsigned __int16 *a1)
{
  if (a1[12] >= 0xFu)
  {
    uint64_t v2 = *((void *)a1 + 4);
    if (v2) {
      MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
    }
  }
  if (*a1 >= 0xFu)
  {
    uint64_t v3 = *((void *)a1 + 1);
    if (v3) {
      MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
    }
  }
  return a1;
}

uint64_t sub_19E087A54(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, unsigned __int16 *a5, double a6, double a7)
{
  *(void *)a1 = &unk_1EF09B808;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = a2;
  sub_19E0E5AF0(a1 + 16, a3);
  sub_19E039858(a1 + 120, a4);
  uint64_t v12 = (_WORD *)(a1 + 152);
  unint64_t v13 = *a5;
  if (v13 >= 0xF)
  {
    _WORD *v12 = v13;
    operator new[]();
  }
  *(_OWORD *)uint64_t v12 = *(_OWORD *)a5;
  *(unsigned char *)(a1 + 16++**(_DWORD **)(result + 8) = *((unsigned char *)a5 + 16);
  double v14 = (_WORD *)(a1 + 176);
  unint64_t v15 = a5[12];
  if (v15 >= 0xF)
  {
    *double v14 = v15;
    operator new[]();
  }
  *(_OWORD *)double v14 = *(_OWORD *)(a5 + 12);
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a5 + 10);
  *(double *)(a1 + 20sub_19E03D880(&a9, 0) = a6;
  *(double *)(a1 + 20++**(_DWORD **)(result + 8) = a7;
  return a1;
}

void sub_19E087B70(_Unwind_Exception *a1)
{
  if (*v3 >= 0xFu)
  {
    uint64_t v5 = *(void *)(v1 + 160);
    if (v5) {
      MEMORY[0x19F3BA6E0](v5, 0x1000C8077774924);
    }
  }
  uint64_t v6 = *(void **)(v1 + 128);
  if (v6)
  {
    if (*(unsigned char *)(v1 + 126) == 1) {
      free(v6);
    }
  }
  sub_19E087BD4(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_19E087BD4(uint64_t a1)
{
  sub_19E080690((uint64_t *)(a1 + 96), 0);
  sub_19E07FA6C(a1 + 40);

  return sub_19E07FA6C(a1);
}

uint64_t sub_19E087C1C()
{
  qword_1EB4FEE20 = 0;
  *(void *)algn_1EB4FEE28 = "LXCursor";
  qword_1EB4FEE30 = 0;
  unk_1EB4FEE38 = 0;
  qword_1EB4FEE40 = (uint64_t)sub_19E087C70;
  *(_OWORD *)algn_1EB4FEE48 = 0u;
  *(_OWORD *)&algn_1EB4FEE48[16] = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB4FEE80 = result;
  return result;
}

uint64_t sub_19E087C70(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 16))();
}

uint64_t sub_19E087C94(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 112);
  if (v3 && (sub_19E0DB784(v3, v2 + 8) & 1) != 0) {
    return 1;
  }
  uint64_t v7 = a1 + 16;
  uint64_t v4 = *(unsigned int *)(v2 + 14360);
  if (v4 == -1) {
    goto LABEL_9;
  }
  double v8 = &v7;
  if (((uint64_t (*)(uint64_t **, uint64_t))off_1EF09EF70[v4])(&v8, v2 + 8)) {
    return 1;
  }
  uint64_t v7 = a1 + 56;
  uint64_t v6 = *(unsigned int *)(v2 + 28720);
  if (v6 == -1) {
LABEL_9:
  }
    sub_19E07D5D0();
  double v8 = &v7;
  return ((uint64_t (*)(uint64_t **, uint64_t))off_1EF09EF70[v6])(&v8, v2 + 14368);
}

void sub_19E087D58(uint64_t a1, uint64_t a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 0x40000000;
  _OWORD v2[2] = sub_19E087DC4;
  v2[3] = &unk_1E599BD50;
  void v2[4] = a2;
  sub_19E087E54(a1, (uint64_t)v2);
}

void sub_19E087DC4(uint64_t a1, uint64_t a2, double a3)
{
  double v5 = a3;
  uint64_t v4 = (const void *)sub_19E0882F8(a2, (uint64_t *)&v5);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
  if (v4) {
    CFRelease(v4);
  }
}

void sub_19E087E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_19E087E54(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void **)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = (unsigned __int16 *)(a1 + 152);
  uint64_t v36 = (void **)(a1 + 16);
  uint64_t v37 = (void **)(a1 + 152);
  uint64_t v5 = *(unsigned int *)(v3 + 14360);
  if (v5 == -1) {
    sub_19E07D5D0();
  }
  uint64_t v8 = v3 + 8;
  uint64_t v34 = &v36;
  ((void (*)(uint64_t *__return_ptr, void ****, uint64_t))off_1EF09EE38[v5])(&v32, &v34, v3 + 8);
  float v9 = sub_19E0E5BFC((uint64_t)v2, v3 + 8);
  float v10 = sub_19E0E501C((uint64_t)v2, v3 + 8);
  if (v9 > 0.0)
  {
    uint64_t v34 = (void ***)v2;
    uint64_t v11 = *(unsigned int *)(v3 + 14360);
    if (v11 == -1) {
      sub_19E07D5D0();
    }
    uint64_t v36 = (void **)&v34;
    float v10 = (float)(v10 * ((float (*)(void ***, uint64_t))off_1EF09ED00[v11])(&v36, v3 + 8)) / v9;
  }
  if ((LODWORD(v10) & 0x7FFFFFFFu) >= 0x7F800000) {
    __assert_rtn("probability_of_baseline_given_termination", "TIStaticDictionaryImplCursor.cpp", 124, "isfinite(result)");
  }
  uint64_t v12 = v32;
  uint64_t v13 = v33;
  while (v12 != v13)
  {
    *(float *)(v12 + 32) = v10 * *(float *)(v12 + 32);
    v12 += 88;
  }
  uint64_t v34 = (void ***)(a1 + 56);
  uint64_t v35 = v4;
  uint64_t v14 = *(unsigned int *)(v3 + 28720);
  if (v14 == -1) {
    sub_19E07D5D0();
  }
  uint64_t v38 = (void ***)&v34;
  ((void (*)(void ***__return_ptr, void ****, uint64_t))off_1EF09EE38[v14])(&v36, &v38, v3 + 14368);
  unint64_t v15 = v36;
  uint64_t v16 = (uint64_t)v37;
  if (v36 != v37)
  {
    unsigned __int16 v17 = v36;
    do
    {
      *((float *)v17 + ++**(_DWORD **)(result + 8) = (float)(1.0 - v10) * *((float *)v17 + 8);
      v17 += 11;
    }
    while (v17 != (void **)v16);
  }
  sub_19E086AF4((uint64_t)&v32, (uint64_t)v15, v16);
  if (*(int *)(a1 + 104) > 0)
  {
    uint64_t v18 = *(unsigned int **)(v3 + 30128);
    if (!v18) {
      __assert_rtn("derive_words", "TIStaticDictionaryImplCursor.cpp", 347, "converter");
    }
    uint64_t v19 = v32;
    uint64_t v20 = v33;
    while (v19 != v20)
    {
      if (*(unsigned char *)(v19 + 59) & 0x20) != 0 || (sub_19E0A36C0(v18, *(_DWORD *)(v19 + 60), 0, 0))
      {
        if (v19 != v20)
        {
          uint64_t v21 = v19 + 88;
          if (v19 + 88 != v20)
          {
            do
            {
              if ((*(unsigned char *)(v21 + 59) & 0x20) == 0 && (sub_19E0A36C0(v18, *(_DWORD *)(v21 + 60), 0, 0) & 1) == 0)
              {
                sub_19E03CED8(v19, (unsigned __int16 *)v21);
                long long v22 = *(_OWORD *)(v21 + 32);
                long long v23 = *(_OWORD *)(v21 + 48);
                long long v24 = *(_OWORD *)(v21 + 64);
                *(_WORD *)(v19 + 8sub_19E060B80(&a9, 0) = *(_WORD *)(v21 + 80);
                *(_OWORD *)(v19 + 4++**(_DWORD **)(result + 8) = v23;
                *(_OWORD *)(v19 + 64) = v24;
                *(_OWORD *)(v19 + 32) = v22;
                v19 += 88;
              }
              v21 += 88;
            }
            while (v21 != v20);
            uint64_t v20 = v33;
          }
        }
        if (v19 != v20)
        {
          while (v20 != v19)
          {
            unint64_t v25 = *(void **)(v20 - 80);
            if (v25 && *(unsigned char *)(v20 - 82) == 1) {
              free(v25);
            }
            v20 -= 88;
          }
          uint64_t v33 = v19;
        }
        break;
      }
      v19 += 88;
    }
    uint64_t v26 = *(void *)(a1 + 112);
    if (v26)
    {
      sub_19E0DBD60(&v34, v26, v8, v4);
      sub_19E086AF4((uint64_t)&v32, (uint64_t)v34, (uint64_t)v35);
      unint64_t v39 = (void ***)&v34;
      sub_19E07F830((void ***)&v39);
    }
  }
  uint64_t v34 = &v36;
  sub_19E07F830((void ***)&v34);
  LOBYTE(v36) = 0;
  uint64_t v27 = v32;
  for (uint64_t i = v33; v27 != i; v27 += 88)
  {
    double v29 = (*(double (**)(uint64_t))(*(void *)a1 + 80))(a1);
    double v30 = v29 + (*(double (**)(uint64_t))(*(void *)a1 + 88))(a1);
    float v31 = log10f(*(float *)(v27 + 32));
    (*(void (**)(uint64_t, uint64_t, void ***, double))(a2 + 16))(a2, v27, &v36, v30 + v31);
    if ((_BYTE)v36) {
      break;
    }
  }
  uint64_t v36 = (void **)&v32;
  sub_19E07F830(&v36);
}

void sub_19E08828C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void ***a20)
{
  a20 = &a13;
  sub_19E07F830((void ***)&a20);
  a13 = (void **)&a16;
  sub_19E07F830(&a13);
  a20 = (void ***)&a10;
  sub_19E07F830((void ***)&a20);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0882F8(uint64_t a1, uint64_t *a2)
{
  if (qword_1EB4FED88 != -1) {
    dispatch_once(&qword_1EB4FED88, &unk_1EF09AC30);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v5 = *a2;
  sub_19E039858(Instance + 16, (unsigned __int16 *)a1);
  long long v6 = *(_OWORD *)(a1 + 32);
  long long v7 = *(_OWORD *)(a1 + 48);
  long long v8 = *(_OWORD *)(a1 + 64);
  *(_WORD *)(Instance + 96) = *(_WORD *)(a1 + 80);
  *(_OWORD *)(Instance + 64) = v7;
  *(_OWORD *)(Instance + 8sub_19E060B80(&a9, 0) = v8;
  *(_OWORD *)(Instance + 4++**(_DWORD **)(result + 8) = v6;
  *(void *)(Instance + 104) = v5;
  *(void *)(Instance + 112) = 0;
  *(_DWORD *)(Instance + 12sub_19E060B80(&a9, 0) = 0;
  return Instance;
}

uint64_t sub_19E0883C4()
{
  qword_1EB4FED90 = 0;
  *(void *)algn_1EB4FED98 = "LXEntry";
  qword_1EB4FEDA0 = 0;
  unk_1EB4FEDA8 = 0;
  qword_1EB4FEDB0 = (uint64_t)sub_19E088418;
  unk_1EB4FEDB8 = 0u;
  unk_1EB4FEDC8 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB4FEDF0 = result;
  return result;
}

void sub_19E088418(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 22) == 1) {
      free(v2);
    }
  }
}

uint64_t sub_19E088438(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = v2 + 8;
  int v4 = *(_DWORD *)(a1 + 104);
  if (v4 < 1)
  {
    uint64_t v8 = a1 + 16;
    uint64_t v6 = *(unsigned int *)(v2 + 14360);
    if (v6 != -1)
    {
      float v9 = &v8;
      if (((uint64_t (*)(uint64_t **, uint64_t))off_1EF09ED68[v6])(&v9, v3)) {
        return 1;
      }
      uint64_t v8 = a1 + 56;
      uint64_t v7 = *(unsigned int *)(v2 + 28720);
      if (v7 != -1)
      {
        float v9 = &v8;
        return ((uint64_t (*)(uint64_t **, uint64_t))off_1EF09ED68[v7])(&v9, v2 + 14368);
      }
    }
    sub_19E07D5D0();
  }
  if (v4 == 2) {
    return 1;
  }
  uint64_t result = *(void *)(a1 + 112);
  if (result)
  {
    return sub_19E0DCBA4(result, v3);
  }
  return result;
}

uint64_t sub_19E088524(uint64_t a1)
{
  return sub_19E0E5530(a1 + 16);
}

BOOL sub_19E08852C(uint64_t a1, uint64_t a2)
{
  return a2 + 16 == a1;
}

uint64_t sub_19E08853C(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  sub_19E0E5AF0((uint64_t)v32, a1 + 16);
  if (*(unsigned __int16 *)(a1 + 152) >= 0xFuLL)
  {
    LOWORD(v2++**(_DWORD **)(result + 8) = *(_WORD *)(a1 + 152);
    operator new[]();
  }
  long long v28 = *(_OWORD *)(a1 + 152);
  unint64_t v4 = *(unsigned __int16 *)(a1 + 176);
  char v29 = *(unsigned char *)(a1 + 168);
  if (v4 >= 0xF)
  {
    LOWORD(v3sub_19E060B80(&a9, 0) = v4;
    operator new[]();
  }
  long long v30 = *(_OWORD *)(a1 + 176);
  int v31 = *(_DWORD *)(a1 + 192);
  if (*((void *)a2 + 1)) {
    uint64_t v5 = *((void *)a2 + 1);
  }
  else {
    uint64_t v5 = (uint64_t)(a2 + 8);
  }
  uint64_t v24 = v5;
  int v6 = *a2;
  int v25 = 0;
  int v26 = v6;
  unsigned int v27 = 0;
  sub_19E03E768(&v24);
  uint64_t v20 = v5;
  int v21 = v6;
  int v22 = v6;
  int v23 = 0;
  sub_19E03E768(&v20);
  uint64_t v7 = v20;
  double v8 = 0.0;
  int v9 = v21;
  while (1)
  {
    if (v24 != v7) {
      __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
    }
    if (v25 == v9) {
      break;
    }
    uint64_t v10 = v27;
    sub_19E03F97C((uint64_t)&v35, *(void *)(a1 + 8) + 8);
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v35 + 16))(&v18);
    if (*((void *)&v35 + 1)) {
      sub_19E0616BC(*((std::__shared_weak_count **)&v35 + 1));
    }
    unint64_t v11 = (unsigned __int16)v28;
    sub_19E03EB40((uint64_t)&v35, *(void *)(a1 + 8) + 28752, (uint64_t)&v28, v10, (unsigned __int16 *)&v18);
    if (v11 >= 0xF && *((void *)&v28 + 1)) {
      MEMORY[0x19F3BA6E0](*((void *)&v28 + 1), 0x1000C8077774924);
    }
    long long v28 = v35;
    if ((unsigned __int16)v35 >= 0xFu) {
      LOWORD(v35) = 0;
    }
    char v29 = v36;
    if ((unsigned __int16)v30 >= 0xFu && *((void *)&v30 + 1)) {
      MEMORY[0x19F3BA6E0](*((void *)&v30 + 1), 0x1000C8077774924);
    }
    long long v30 = v37;
    if ((unsigned __int16)v37 >= 0xFu) {
      LOWORD(v37) = 0;
    }
    int v31 = v38;
    if ((unsigned __int16)v35 >= 0xFu && *((void *)&v35 + 1)) {
      MEMORY[0x19F3BA6E0](*((void *)&v35 + 1), 0x1000C8077774924);
    }
    while (sub_19E0E4E50((uint64_t)v32) && v11 < (unsigned __int16)v28)
    {
      if ((unsigned __int16)v28 <= 0xEu) {
        uint64_t v12 = (char *)&v28 + 2;
      }
      else {
        uint64_t v12 = (char *)*((void *)&v28 + 1);
      }
      float v13 = sub_19E0E4EE8((unint64_t)v32, *(void *)(a1 + 8) + 8, v12[v11]);
      double v8 = v8 + log10f(v13);
      ++v11;
    }
    int v14 = sub_19E0E4E50((uint64_t)v32);
    if ((unsigned __int16)v18 >= 0xFu && v19) {
      MEMORY[0x19F3BA6E0](v19, 0x1000C8077774924);
    }
    if (!v14)
    {
      uint64_t Instance = 0;
      goto LABEL_44;
    }
    sub_19E03E768(&v24);
  }
  if ((sub_19E0E4E50((uint64_t)v32) & 1) == 0) {
    __assert_rtn("create_child", "LXCursor.cpp", 170, "impl.valid()");
  }
  sub_19E0B23D4((uint64_t)&v35, (unsigned __int16 *)(a1 + 120), (uint64_t)a2);
  double v15 = *(double *)(a1 + 208);
  if (qword_1EB4FEE18 != -1) {
    dispatch_once(&qword_1EB4FEE18, &unk_1EF09AC10);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  sub_19E087A54(Instance + 16, *(void *)(a1 + 8), (uint64_t)v32, (unsigned __int16 *)&v35, (unsigned __int16 *)&v28, v8, v15 + v8);
  if (*((void *)&v35 + 1) && BYTE6(v35) == 1) {
    free(*((void **)&v35 + 1));
  }
LABEL_44:
  if ((unsigned __int16)v30 >= 0xFu && *((void *)&v30 + 1)) {
    MEMORY[0x19F3BA6E0](*((void *)&v30 + 1), 0x1000C8077774924);
  }
  if ((unsigned __int16)v28 >= 0xFu && *((void *)&v28 + 1)) {
    MEMORY[0x19F3BA6E0](*((void *)&v28 + 1), 0x1000C8077774924);
  }
  sub_19E080690(&v34, 0);
  sub_19E07FA6C((uint64_t)&v33);
  sub_19E07FA6C((uint64_t)v32);
  return Instance;
}

void sub_19E088A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned __int16 a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  if (a10 >= 0xFu)
  {
    if (a11) {
      MEMORY[0x19F3BA6E0](a11, 0x1000C8077774924);
    }
  }
  sub_19E087BD4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E088AD8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09B808;
  if (*(unsigned __int16 *)(a1 + 176) >= 0xFu)
  {
    uint64_t v2 = *(void *)(a1 + 184);
    if (v2) {
      MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
    }
  }
  if (*(unsigned __int16 *)(a1 + 152) >= 0xFu)
  {
    uint64_t v3 = *(void *)(a1 + 160);
    if (v3) {
      MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
    }
  }
  unint64_t v4 = *(void **)(a1 + 128);
  if (v4 && *(unsigned char *)(a1 + 126) == 1) {
    free(v4);
  }
  sub_19E080690((uint64_t *)(a1 + 112), 0);
  sub_19E07FA6C(a1 + 56);
  sub_19E07FA6C(a1 + 16);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E088BC0(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09B808;
  if (*(unsigned __int16 *)(a1 + 176) >= 0xFu)
  {
    uint64_t v2 = *(void *)(a1 + 184);
    if (v2) {
      MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
    }
  }
  if (*(unsigned __int16 *)(a1 + 152) >= 0xFu)
  {
    uint64_t v3 = *(void *)(a1 + 160);
    if (v3) {
      MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
    }
  }
  unint64_t v4 = *(void **)(a1 + 128);
  if (v4 && *(unsigned char *)(a1 + 126) == 1) {
    free(v4);
  }
  sub_19E080690((uint64_t *)(a1 + 112), 0);
  sub_19E07FA6C(a1 + 56);
  sub_19E07FA6C(a1 + 16);
  return a1;
}

uint64_t sub_19E088C88(uint64_t result, unsigned char *a2, uint64_t a3)
{
  uint64_t v5 = result;
  v6[6] = MEMORY[0x1E4F143A8];
  v6[7] = 0x40000000;
  v6[8] = sub_19E088DB8;
  v6[9] = &unk_1E599BC88;
  v6[10] = a3;
  v6[11] = a2;
  if (result) {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(result + 16) + 48))();
  }
  if (!*a2)
  {
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    v6[2] = sub_19E088DF8;
    uint64_t v6[3] = &unk_1E599BCB0;
    void v6[4] = a3;
    uint64_t v6[5] = a2;
    if (v5) {
      return (*(uint64_t (**)(uint64_t, void *))(*(void *)(v5 + 16) + 64))(v5 + 16, v6);
    }
  }
  return result;
}

uint64_t sub_19E088DB8(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  **(unsigned char **)(a1 + 4sub_19E060B80(&a9, 0) = *a3;
  return result;
}

uint64_t sub_19E088DF8(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = sub_19E088C88(a2, a3, *(void *)(a1 + 32));
  **(unsigned char **)(a1 + 4sub_19E060B80(&a9, 0) = *a3;
  return result;
}

uint64_t LXCursorEnumerateEntries(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 48))();
  }
  return result;
}

uint64_t LXCursorEnumerateChildren(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 64))();
  }
  return result;
}

void sub_19E088E90(const void *a1, uint64_t a2)
{
  uint64_t v99 = 0;
  uint64_t v100 = &v99;
  uint64_t v101 = 0x4802000000;
  uint64_t v102 = sub_19E089784;
  uint64_t v103 = sub_19E0897B0;
  uint64_t v104 = 0;
  std::string v105 = 0;
  unint64_t v106 = 0;
  std::string v107 = &unk_19E124E7B;
  uint64_t v90 = 0;
  uint64_t v91 = &v90;
  uint64_t v92 = 0x4802000000;
  uint64_t v93 = sub_19E0897C8;
  unint64_t v94 = sub_19E0897F4;
  std::string __p = 0;
  uint64_t v96 = 0;
  uint64_t v97 = 0;
  uint64_t v98 = &unk_19E124E7C;
  CFTypeRef v3 = CFRetain(a1);
  CFTypeRef v4 = v3;
  uint64_t v5 = v105;
  if ((unint64_t)v105 >= v106)
  {
    uint64_t v7 = (v105 - v104) >> 3;
    if ((unint64_t)(v7 + 1) >> 61) {
      sub_19E041BEC();
    }
    unint64_t v8 = (uint64_t)(v106 - (void)v104) >> 2;
    if (v8 <= v7 + 1) {
      unint64_t v8 = v7 + 1;
    }
    if (v106 - (unint64_t)v104 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9) {
      unint64_t v9 = (unint64_t)sub_19E060B48(v9);
    }
    else {
      uint64_t v10 = 0;
    }
    unint64_t v11 = (char *)(v9 + 8 * v7);
    unint64_t v12 = v9 + 8 * v10;
    *(void *)unint64_t v11 = v4;
    uint64_t v6 = (uint64_t)(v11 + 8);
    int v14 = v104;
    float v13 = v105;
    if (v105 != v104)
    {
      do
      {
        uint64_t v15 = *((void *)v13 - 1);
        v13 -= 8;
        *((void *)v11 - 1) = v15;
        v11 -= 8;
      }
      while (v13 != v14);
      float v13 = v104;
    }
    uint64_t v104 = v11;
    std::string v105 = (char *)v6;
    unint64_t v106 = v12;
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    *(void *)std::string v105 = v3;
    uint64_t v6 = (uint64_t)(v5 + 8);
  }
  std::string v105 = (char *)v6;
  sub_19E08980C((uint64_t)v104, v6, (v6 - (uint64_t)v104) >> 3);
  unsigned __int8 v89 = 0;
  uint64_t v16 = v100;
  unsigned __int16 v17 = (CFTypeRef *)v100[5];
  uint64_t v19 = v100 + 6;
  uint64_t v18 = (CFTypeRef *)v100[6];
  if (v17 == v18) {
    goto LABEL_61;
  }
  do
  {
    CFTypeRef v20 = *v17;
    CFTypeRef cf = *v17;
    uint64_t v21 = (char *)v18 - (char *)v17;
    if ((char *)v18 - (char *)v17 < 9) {
      goto LABEL_32;
    }
    CFTypeRef v78 = v20;
    unsigned int v79 = v18;
    uint64_t v22 = 0;
    uint64_t v23 = v21 >> 3;
    int64_t v24 = (unint64_t)((v21 >> 3) - 2) >> 1;
    uint64_t v77 = (uint64_t)v17;
    do
    {
      uint64_t v25 = (uint64_t)&v17[v22 + 1];
      uint64_t v26 = (2 * v22) | 1;
      uint64_t v27 = 2 * v22 + 2;
      if (v27 >= v23) {
        goto LABEL_28;
      }
      long long v28 = v17[v22 + 2];
      if (*(void *)v25)
      {
        double v29 = (*(double (**)(void))(*(void *)(*(void *)v25 + 16) + 80))();
        if (v28) {
          goto LABEL_23;
        }
      }
      else
      {
        double v29 = -INFINITY;
        if (v28)
        {
LABEL_23:
          (*(void (**)(void *))(v28[2] + 80))(v28 + 2);
          goto LABEL_26;
        }
      }
      double v30 = -INFINITY;
LABEL_26:
      if (v29 < v30)
      {
        v25 += 8;
        uint64_t v26 = v27;
      }
LABEL_28:
      *unsigned __int16 v17 = *(CFTypeRef *)v25;
      unsigned __int16 v17 = (CFTypeRef *)v25;
      uint64_t v22 = v26;
    }
    while (v26 <= v24);
    int v31 = v79 - 1;
    if ((CFTypeRef *)v25 == v79 - 1)
    {
      *(void *)uint64_t v25 = v78;
    }
    else
    {
      *(void *)uint64_t v25 = *v31;
      *int v31 = v78;
      sub_19E08980C(v77, v25 + 8, (v25 + 8 - v77) >> 3);
    }
LABEL_32:
    *v19 -= 8;
    v87[0] = MEMORY[0x1E4F143A8];
    v87[1] = 0x40000000;
    v87[2] = sub_19E08998C;
    v87[3] = &unk_1E599BCD8;
    v87[4] = &v90;
    if (cf)
    {
      uint64_t v32 = (char *)cf + 16;
      (*(void (**)(char *, void *))(*((void *)cf + 2) + 48))((char *)cf + 16, v87);
      uint64_t v82 = MEMORY[0x1E4F143A8];
      uint64_t v83 = 0x40000000;
      uint64_t v84 = sub_19E089AA4;
      uint64_t v85 = &unk_1E599BD00;
      BOOL v86 = &v99;
      (*(void (**)(char *, uint64_t *))(*(void *)v32 + 64))(v32, &v82);
    }
    else
    {
      uint64_t v82 = MEMORY[0x1E4F143A8];
      uint64_t v83 = 0x40000000;
      uint64_t v84 = sub_19E089AA4;
      uint64_t v85 = &unk_1E599BD00;
      BOOL v86 = &v99;
    }
    uint64_t v33 = v91;
    uint64_t v34 = v100;
    do
    {
      uint64_t v35 = v33[5];
      uint64_t v36 = v33[6];
      if (v35 == v36) {
        break;
      }
      uint64_t v37 = v34[5];
      if (v37 != v34[6])
      {
        double v38 = *(double *)(*(void *)v35 + 104);
        if (v38 >= (*(double (**)(void))(*(void *)(*(void *)v37 + 16) + 80))())
        {
          uint64_t v35 = v33[5];
          uint64_t v36 = v33[6];
        }
        else
        {
          if ((unint64_t)(v34[6] - v34[5]) < 0x27101) {
            break;
          }
          uint64_t v35 = v33[5];
          uint64_t v36 = v33[6];
          if ((unint64_t)(v36 - v35) < 0x3E81) {
            break;
          }
        }
      }
      uint64_t v39 = *(void *)v35;
      std::string v108 = *(const void **)v35;
      if (v36 - v35 >= 9)
      {
        uint64_t v40 = 0;
        uint64_t v41 = (v36 - v35) >> 3;
        unint64_t v42 = (void *)v35;
        do
        {
          uint64_t v43 = v42;
          v42 += v40 + 1;
          uint64_t v44 = 2 * v40;
          uint64_t v40 = (2 * v40) | 1;
          uint64_t v45 = v44 + 2;
          if (v45 < v41 && *(double *)(*v42 + 104) < *(double *)(v42[1] + 104))
          {
            ++v42;
            uint64_t v40 = v45;
          }
          *uint64_t v43 = *v42;
        }
        while (v40 <= (uint64_t)((unint64_t)(v41 - 2) >> 1));
        uint64_t v46 = (void *)(v36 - 8);
        if (v42 == v46)
        {
          *unint64_t v42 = v39;
        }
        else
        {
          *unint64_t v42 = *v46;
          *uint64_t v46 = v39;
          sub_19E089BA0(v35, (uint64_t)(v42 + 1), ((uint64_t)v42 - v35 + 8) >> 3);
        }
      }
      v33[6] -= 8;
      uint64_t v47 = v108;
      (*(void (**)(uint64_t, const void *, unsigned __int8 *))(a2 + 16))(a2, v108, &v89);
      int v48 = v89;
      if (v47) {
        CFRelease(v47);
      }
    }
    while (!v48);
    if (cf) {
      CFRelease(cf);
    }
    uint64_t v16 = v100;
    unsigned __int16 v17 = (CFTypeRef *)v100[5];
    uint64_t v19 = v100 + 6;
    uint64_t v18 = (CFTypeRef *)v100[6];
  }
  while (v17 != v18 && v89 == 0);
LABEL_61:
  std::string::size_type v50 = (CFTypeRef *)v91[5];
  if (v50 != (CFTypeRef *)v91[6])
  {
    do
    {
      CFRelease(*v50);
      uint64_t v51 = v91;
      unint64_t v52 = (uint64_t *)v91[5];
      uint64_t v53 = v91[6];
      if (v53 - (uint64_t)v52 >= 9)
      {
        uint64_t v54 = 0;
        uint64_t v55 = (v53 - (uint64_t)v52) >> 3;
        uint64_t v56 = *v52;
        uint64_t v57 = (void *)v91[5];
        do
        {
          uint64_t v58 = v57;
          v57 += v54 + 1;
          uint64_t v59 = 2 * v54;
          uint64_t v54 = (2 * v54) | 1;
          uint64_t v60 = v59 + 2;
          if (v60 < v55 && *(double *)(*v57 + 104) < *(double *)(v57[1] + 104))
          {
            ++v57;
            uint64_t v54 = v60;
          }
          *uint64_t v58 = *v57;
        }
        while (v54 <= (uint64_t)((unint64_t)(v55 - 2) >> 1));
        uint64_t v61 = (void *)(v53 - 8);
        if (v57 == v61)
        {
          void *v57 = v56;
        }
        else
        {
          void *v57 = *v61;
          *uint64_t v61 = v56;
          sub_19E089BA0((uint64_t)v52, (uint64_t)(v57 + 1), v57 + 1 - v52);
        }
      }
      v51[6] -= 8;
      std::string::size_type v50 = (CFTypeRef *)v91[5];
    }
    while (v50 != (CFTypeRef *)v91[6]);
    goto LABEL_74;
  }
LABEL_75:
  uint64_t v62 = (CFTypeRef *)v16[5];
  if (v62 != (CFTypeRef *)v16[6])
  {
    CFRelease(*v62);
    uint64_t v63 = v100;
    uint64_t v64 = (uint64_t *)v100[5];
    uint64_t v65 = v100[6] - (void)v64;
    if (v65 < 9) {
      goto LABEL_90;
    }
    uint64_t v80 = v100[6];
    uint64_t v66 = 0;
    uint64_t v67 = v65 >> 3;
    uint64_t v81 = *v64;
    int64_t v68 = (unint64_t)((v65 >> 3) - 2) >> 1;
    unint64_t v69 = (void *)v100[5];
    while (1)
    {
      uint64_t v70 = (uint64_t)&v69[v66 + 1];
      uint64_t v71 = (2 * v66) | 1;
      uint64_t v72 = 2 * v66 + 2;
      if (v72 < v67) {
        break;
      }
LABEL_86:
      void *v69 = *(void *)v70;
      unint64_t v69 = (void *)v70;
      uint64_t v66 = v71;
      if (v71 > v68)
      {
        uint64_t v76 = (void *)(v80 - 8);
        if (v70 == v80 - 8)
        {
          *(void *)uint64_t v70 = v81;
        }
        else
        {
          *(void *)uint64_t v70 = *v76;
          *uint64_t v76 = v81;
          sub_19E08980C((uint64_t)v64, v70 + 8, (v70 + 8 - (uint64_t)v64) >> 3);
        }
LABEL_90:
        v63[6] -= 8;
LABEL_74:
        uint64_t v16 = v100;
        goto LABEL_75;
      }
    }
    uint64_t v73 = v69[v66 + 2];
    if (*(void *)v70)
    {
      double v74 = (*(double (**)(void))(*(void *)(*(void *)v70 + 16) + 80))();
      if (v73) {
        goto LABEL_81;
      }
LABEL_83:
      double v75 = -INFINITY;
    }
    else
    {
      double v74 = -INFINITY;
      if (!v73) {
        goto LABEL_83;
      }
LABEL_81:
      (*(void (**)(uint64_t))(*(void *)(v73 + 16) + 80))(v73 + 16);
    }
    if (v74 < v75)
    {
      v70 += 8;
      uint64_t v71 = v72;
    }
    goto LABEL_86;
  }
  _Block_object_dispose(&v90, 8);
  if (__p)
  {
    uint64_t v96 = __p;
    operator delete(__p);
  }
  _Block_object_dispose(&v99, 8);
  if (v104)
  {
    std::string v105 = v104;
    operator delete(v104);
  }
}

__n128 sub_19E089784(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 4sub_19E060B80(&a9, 0) = 0;
  *(void *)(a2 + 4++**(_DWORD **)(result + 8) = 0;
  *(void *)(a2 + 56) = 0;
  a1[8] = *(void *)(a2 + 64);
  return result;
}

void sub_19E0897B0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 4++**(_DWORD **)(result + 8) = v2;
    operator delete(v2);
  }
}

__n128 sub_19E0897C8(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 4sub_19E060B80(&a9, 0) = 0;
  *(void *)(a2 + 4++**(_DWORD **)(result + 8) = 0;
  *(void *)(a2 + 56) = 0;
  a1[8] = *(void *)(a2 + 64);
  return result;
}

void sub_19E0897F4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 4++**(_DWORD **)(result + 8) = v2;
    operator delete(v2);
  }
}

void sub_19E08980C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a3 - 2;
  if (a3 >= 2)
  {
    unint64_t v5 = v3 >> 1;
    uint64_t v6 = (uint64_t *)(a1 + 8 * (v3 >> 1));
    uint64_t v7 = (uint64_t *)(a2 - 8);
    uint64_t v8 = *(void *)(a2 - 8);
    if (*v6)
    {
      double v9 = (*(double (**)(void))(*(void *)(*v6 + 16) + 80))();
      if (v8)
      {
LABEL_4:
        (*(void (**)(uint64_t))(*(void *)(v8 + 16) + 80))(v8 + 16);
LABEL_7:
        if (v9 >= v10) {
          return;
        }
        uint64_t v11 = *v7;
        uint64_t v12 = *v7 + 16;
        while (1)
        {
          float v13 = v6;
          uint64_t *v7 = *v6;
          if (!v5)
          {
LABEL_16:
            *float v13 = v11;
            return;
          }
          unint64_t v5 = (v5 - 1) >> 1;
          uint64_t v6 = (uint64_t *)(a1 + 8 * v5);
          if (*v6)
          {
            double v14 = (*(double (**)(void))(*(void *)(*v6 + 16) + 80))();
            if (!v11) {
              goto LABEL_14;
            }
          }
          else
          {
            double v14 = -INFINITY;
            if (!v11)
            {
LABEL_14:
              double v15 = -INFINITY;
              goto LABEL_15;
            }
          }
          (*(void (**)(uint64_t))(*(void *)v12 + 80))(v12);
LABEL_15:
          uint64_t v7 = v13;
          if (v14 >= v15) {
            goto LABEL_16;
          }
        }
      }
    }
    else
    {
      double v9 = -INFINITY;
      if (v8) {
        goto LABEL_4;
      }
    }
    double v10 = -INFINITY;
    goto LABEL_7;
  }
}

uint64_t sub_19E08998C(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 8);
  CFTypeRef v3 = CFRetain(cf);
  CFTypeRef v4 = v3;
  uint64_t v6 = (void *)v2[6];
  unint64_t v5 = v2[7];
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = (void *)v2[5];
    uint64_t v9 = v6 - v8;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_19E041BEC();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        sub_19E0416C4();
      }
      float v13 = (char *)operator new(8 * v12);
    }
    else
    {
      float v13 = 0;
    }
    double v14 = &v13[8 * v9];
    *(void *)double v14 = v4;
    uint64_t v7 = (uint64_t)(v14 + 8);
    if (v6 != v8)
    {
      do
      {
        uint64_t v15 = *--v6;
        *((void *)v14 - 1) = v15;
        v14 -= 8;
      }
      while (v6 != v8);
      uint64_t v6 = (void *)v2[5];
    }
    void v2[5] = v14;
    v2[6] = v7;
    v2[7] = &v13[8 * v12];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    void *v6 = v3;
    uint64_t v7 = (uint64_t)(v6 + 1);
  }
  v2[6] = v7;
  uint64_t v16 = v2[5];

  return sub_19E089BA0(v16, v7, (v7 - v16) >> 3);
}

void sub_19E089AA4(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 8);
  CFTypeRef v3 = CFRetain(cf);
  CFTypeRef v4 = v3;
  uint64_t v6 = (void *)v2[6];
  unint64_t v5 = v2[7];
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = v2[5];
    uint64_t v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_19E041BEC();
    }
    uint64_t v10 = v5 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      unint64_t v12 = (unint64_t)sub_19E060B48(v12);
    }
    else {
      uint64_t v13 = 0;
    }
    double v14 = (void *)(v12 + 8 * v9);
    unint64_t v15 = v12 + 8 * v13;
    *double v14 = v4;
    uint64_t v7 = (uint64_t)(v14 + 1);
    unsigned __int16 v17 = (char *)v2[5];
    uint64_t v16 = (char *)v2[6];
    if (v16 != v17)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *--double v14 = v18;
      }
      while (v16 != v17);
      uint64_t v16 = (char *)v2[5];
    }
    void v2[5] = v14;
    v2[6] = v7;
    v2[7] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    void *v6 = v3;
    uint64_t v7 = (uint64_t)(v6 + 1);
  }
  v2[6] = v7;
  uint64_t v19 = v2[5];

  sub_19E08980C(v19, v7, (v7 - v19) >> 3);
}

uint64_t sub_19E089BA0(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = (unint64_t)(a3 - 2) >> 1;
    CFTypeRef v4 = (void *)(result + 8 * v3);
    uint64_t v5 = *v4;
    uint64_t v8 = *(void *)(a2 - 8);
    uint64_t v6 = (void *)(a2 - 8);
    uint64_t v7 = v8;
    double v9 = *(double *)(v8 + 104);
    if (*(double *)(*v4 + 104) < v9)
    {
      do
      {
        uint64_t v10 = v4;
        void *v6 = v5;
        if (!v3) {
          break;
        }
        unint64_t v3 = (v3 - 1) >> 1;
        CFTypeRef v4 = (void *)(result + 8 * v3);
        uint64_t v5 = *v4;
        uint64_t v6 = v10;
      }
      while (*(double *)(*v4 + 104) < v9);
      *uint64_t v10 = v7;
    }
  }
  return result;
}

uint64_t LXCursorIsRoot(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 32))();
  }
  return result;
}

uint64_t LXCursorCopyTraversedCharacters(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 112))();
  }
  return result;
}

uint64_t LXCursorLastTraversedCharacter(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 120))();
  }
  return result;
}

double LXCursorConditionalProbability(uint64_t a1)
{
  if (!a1) {
    return -INFINITY;
  }
  (*(void (**)(void))(*(void *)(a1 + 16) + 72))();
  return result;
}

double LXCursorPrefixProbability(uint64_t a1)
{
  if (!a1) {
    return -INFINITY;
  }
  (*(void (**)(void))(*(void *)(a1 + 16) + 80))();
  return result;
}

uint64_t LXCursorUsageCount(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 96))();
  }
  return result;
}

uint64_t LXCursorUsageCountRecursive(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 104))();
  }
  return result;
}

double LXCursorTerminationProbability(uint64_t a1)
{
  if (!a1) {
    return -INFINITY;
  }
  (*(void (**)(void))(*(void *)(a1 + 16) + 88))();
  return result;
}

uint64_t LXCursorTerminatesWordStem(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 128))();
  }
  return result;
}

uint64_t LXCursorCreateByAdvancing(uint64_t a1, const __CFString *a2)
{
  uint64_t v2 = a1;
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    sub_19E03F0BC((uint64_t)v4, a2);
    uint64_t v2 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)(v2 + 16) + 16))(v2 + 16, v4);
    if (v5)
    {
      if (v4[6] == 1) {
        free(v5);
      }
    }
  }
  return v2;
}

void sub_19E089E74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, void *a13)
{
  if (a13)
  {
    if (a12 == 1) {
      free(a13);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t LXCursorCreateByAdvancingWithUTF8(uint64_t a1, char *a2, unsigned __int16 a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    sub_19E0B13C0((uint64_t)&v7, a2, a3);
    uint64_t v4 = (*(uint64_t (**)(uint64_t, int *))(*(void *)(a1 + 16) + 16))(a1 + 16, &v7);
    if (*(void *)&v8[4] && v8[2] == 1) {
      free(*(void **)&v8[4]);
    }
  }
  else
  {
    if (qword_1E94576B0 != -1) {
      dispatch_once(&qword_1E94576B0, &unk_1EF098F28);
    }
    uint64_t v5 = qword_1E94576A8;
    if (os_log_type_enabled((os_log_t)qword_1E94576A8, OS_LOG_TYPE_FAULT))
    {
      int v7 = 136315138;
      *(void *)uint64_t v8 = "LXCursorCreateByAdvancingWithUTF8";
      _os_log_fault_impl(&dword_19E038000, v5, OS_LOG_TYPE_FAULT, "%s: Missing cursor", (uint8_t *)&v7, 0xCu);
    }
    return 0;
  }
  return v4;
}

void sub_19E089FD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, void *a12)
{
  if (a12)
  {
    if (a11 == 1) {
      free(a12);
    }
  }
  _Unwind_Resume(exception_object);
}

os_log_t sub_19E08A004()
{
  os_log_t result = os_log_create("com.apple.Lexicon", "Cursor");
  qword_1E94576A8 = (uint64_t)result;
  return result;
}

uint64_t LXCursorCreateByAdvancingWithUTF16(uint64_t a1, UChar *a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    __assert_rtn("LXCursorCreateByAdvancingWithUTF16", "LXCursor.cpp", 391, "false && \"missing cursor\"");
  }
  int v6 = 0x100000;
  __int16 v7 = 0;
  char v8 = 0;
  uint64_t v9 = 0;
  char v10 = 0;
  sub_19E0B1F50((unsigned __int16 *)&v6, a2, a3);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, int *))(*(void *)(a1 + 16) + 16))(a1 + 16, &v6);
  if (v9 && v8 == 1) {
    free(v9);
  }
  return v4;
}

void sub_19E08A118(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, void *a13)
{
  if (a13) {
    BOOL v14 = a12 == 1;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14) {
    free(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LXCursorCreateByAdvancingWithUTF32(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    __assert_rtn("LXCursorCreateByAdvancingWithUTF32", "LXCursor.cpp", 402, "false && \"missing cursor\"");
  }
  uint64_t v3 = a3;
  int v9 = 0x100000;
  __int16 v10 = 0;
  char v11 = 0;
  unint64_t v12 = 0;
  for (char i = 0; v3; --v3)
  {
    unsigned int v6 = *a2++;
    sub_19E0B14D0((unsigned __int16 *)&v9, v6);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, int *))(*(void *)(a1 + 16) + 16))(a1 + 16, &v9);
  if (v12 && v11 == 1) {
    free(v12);
  }
  return v7;
}

void sub_19E08A240(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, void *a13)
{
  if (a13) {
    BOOL v14 = a12 == 1;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14) {
    free(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LXCursorHasChildren(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 56))();
  }
  return result;
}

void LXCursorEnumerateEntriesRecursively(const void *a1, uint64_t a2)
{
  if (a1) {
    sub_19E088E90(a1, a2);
  }
}

void LXCursorEnumerateEntriesRecursivelyWithPolicy(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2 == 1)
    {
      sub_19E088E90(a1, a3);
    }
    else
    {
      if (a2)
      {
        if (qword_1E94576B0 != -1) {
          dispatch_once(&qword_1E94576B0, &unk_1EF098F28);
        }
        uint64_t v3 = qword_1E94576A8;
        if (os_log_type_enabled((os_log_t)qword_1E94576A8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134217984;
          uint64_t v6 = a2;
          _os_log_error_impl(&dword_19E038000, v3, OS_LOG_TYPE_ERROR, "Unsupported enumeration policy: %ld", buf, 0xCu);
        }
        __assert_rtn("LXCursorEnumerateEntriesRecursivelyWithPolicy", "LXCursor.cpp", 450, "false && \"unsupported enumeration policy\"");
      }
      buf[0] = 0;
      sub_19E088C88((uint64_t)a1, buf, a3);
    }
  }
}

uint64_t LXCursorHasEntries(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 40))();
  }
  return result;
}

void LXCursorsAreEqual()
{
}

uint64_t LXCursorCopyFirstEntry(uint64_t a1)
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  uint64_t v6 = 0;
  if (a1)
  {
    (*(void (**)(void))(*(void *)(a1 + 16) + 48))();
    uint64_t v1 = v4[3];
  }
  else
  {
    uint64_t v1 = 0;
  }
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_19E08A534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFTypeRef sub_19E08A54C(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  CFTypeRef result = CFRetain(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  *a3 = 1;
  return result;
}

uint64_t LXCursorHash(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 136))();
  }
  return result;
}

void sub_19E08A5BC(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      uint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    sub_19E0416C4();
  }
  uint64_t v5 = operator new(8 * prime);
  uint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  char v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    BOOL v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *char v8 = *v14;
          *BOOL v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          BOOL v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        char v8 = v14;
        BOOL v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

uint64_t sub_19E08A7B8(uint64_t a1, int a2, int a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v6 = operator new(8uLL);
  _DWORD *v6 = a2;
  v6[1] = 0;
  *(void *)a1 = v6;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = v6 + 2;
  *(void *)(a1 + 16) = v6 + 2;
  *(_DWORD *)(a1 + 24) = a3;
  return a1;
}

void *sub_19E08A810(unint64_t a1)
{
  if (a1 >> 59) {
    sub_19E0416C4();
  }
  return operator new(32 * a1);
}

uint64_t *sub_19E08A848(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      *(void *)(v6 - 32) = 0;
      *(void *)(v6 - 24) = 0;
      *(void *)(v6 - 16) = 0;
      *(_OWORD *)(v6 - 32) = *(_OWORD *)(v2 + v5 - 32);
      *(void *)(v6 - 16) = *(void *)(v2 + v5 - 16);
      *(void *)(v7 - 32) = 0;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(_DWORD *)(v6 - ++**(_DWORD **)(result + 8) = *(_DWORD *)(v2 + v5 - 8);
      v5 -= 32;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v8 = *result;
  *CFTypeRef result = v4;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t sub_19E08A8DC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v4 = *(void **)(v2 - 32);
    *(void *)(a1 + 16) = v2 - 32;
    if (v4)
    {
      *(void *)(v2 - 24) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

__n128 sub_19E08A940(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a3 - 2;
  if (a3 >= 2)
  {
    unint64_t v5 = v3 >> 1;
    unsigned int v6 = *(_DWORD *)(a2 - 8);
    if (*(_DWORD *)(a1 + 32 * (v3 >> 1) + 24) > v6)
    {
      uint64_t v7 = a2 - 32;
      __n128 v12 = *(__n128 *)(a2 - 32);
      uint64_t v8 = *(void *)(a2 - 16);
      *(void *)uint64_t v7 = 0;
      *(void *)(v7 + ++**(_DWORD **)(result + 8) = 0;
      *(void *)(v7 + 16) = 0;
      while (1)
      {
        uint64_t v9 = a1 + 32 * v5;
        *(_OWORD *)uint64_t v7 = *(_OWORD *)v9;
        *(void *)(v7 + 16) = *(void *)(v9 + 16);
        *(void *)uint64_t v9 = 0;
        *(void *)(v9 + ++**(_DWORD **)(result + 8) = 0;
        *(void *)(v9 + 16) = 0;
        *(_DWORD *)(v7 + 24) = *(_DWORD *)(v9 + 24);
        if (!v5) {
          break;
        }
        unint64_t v5 = (v5 - 1) >> 1;
        if (*(_DWORD *)(a1 + 32 * v5 + 24) <= v6) {
          break;
        }
        uint64_t v10 = *(void **)v9;
        uint64_t v7 = v9;
        if (*(void *)v9)
        {
          *(void *)(v9 + ++**(_DWORD **)(result + 8) = v10;
          operator delete(v10);
          *(void *)uint64_t v7 = 0;
          *(void *)(v7 + ++**(_DWORD **)(result + 8) = 0;
          *(void *)(v7 + 16) = 0;
        }
      }
      __n128 result = v12;
      *(__n128 *)uint64_t v9 = v12;
      *(void *)(v9 + 16) = v8;
      *(_DWORD *)(v9 + 24) = v6;
    }
  }
  return result;
}

char *sub_19E08AA30(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    unsigned int v6 = result;
    __n128 result = sub_19E08BE98(result, a4);
    uint64_t v7 = (void *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_19E08AA88(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + ++**(_DWORD **)(result + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E08AAA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 >= 2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(void *)(a1 + 16);
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    uint64_t v7 = a1;
    int v8 = *(_DWORD *)(a1 + 24);
    do
    {
      uint64_t v9 = v7 + 32 * (v3 + 1);
      uint64_t v10 = (2 * v3) | 1;
      uint64_t v11 = 2 * v3 + 2;
      if (v11 < a3)
      {
        unsigned int v12 = *(_DWORD *)(v9 + 24);
        unsigned int v13 = *(_DWORD *)(v9 + 56);
        v9 += 32 * (v12 > v13);
        if (v12 > v13) {
          uint64_t v10 = v11;
        }
      }
      int v14 = *(_DWORD *)(v9 + 24);
      *(_OWORD *)uint64_t v7 = *(_OWORD *)v9;
      *(void *)(v7 + 16) = *(void *)(v9 + 16);
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + ++**(_DWORD **)(result + 8) = 0;
      *(void *)(v9 + 16) = 0;
      *(_DWORD *)(v7 + 24) = v14;
      uint64_t v7 = v9;
      uint64_t v3 = v10;
    }
    while (v10 <= (uint64_t)((unint64_t)(a3 - 2) >> 1));
    if (a2 - 32 == v9)
    {
      *(void *)uint64_t v9 = v4;
      *(void *)(v9 + ++**(_DWORD **)(result + 8) = v5;
      *(void *)(v9 + 16) = v6;
      *(_DWORD *)(v9 + 24) = v8;
    }
    else
    {
      int v15 = *(_DWORD *)(a2 - 8);
      *(_OWORD *)uint64_t v9 = *(_OWORD *)(a2 - 32);
      *(void *)(v9 + 16) = *(void *)(a2 - 16);
      *(_DWORD *)(v9 + 24) = v15;
      *(void *)(a2 - 32) = v4;
      *(void *)(a2 - 24) = v5;
      *(void *)(a2 - 16) = v6;
      *(_DWORD *)(a2 - ++**(_DWORD **)(result + 8) = v8;
      sub_19E08A940(a1, v9 + 32, (v9 + 32 - a1) >> 5);
    }
  }
}

char *sub_19E08AB88(void *a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1[2];
  __n128 result = (char *)*a1;
  if (a4 <= (v8 - (uint64_t)result) >> 3)
  {
    uint64_t v18 = (char *)a1[1];
    unsigned int v13 = a1 + 1;
    unsigned int v12 = v18;
    unint64_t v19 = (v18 - result) >> 3;
    if (v19 >= a4)
    {
      uint64_t v25 = result;
      while (v6 != a3)
      {
        uint64_t v26 = *v6++;
        *(void *)uint64_t v25 = v26;
        v25 += 8;
      }
      unsigned __int16 v17 = (char *)(v25 - result);
      unsigned int v12 = result;
    }
    else
    {
      CFTypeRef v20 = &a2[v19];
      if (v12 != result)
      {
        uint64_t v21 = 8 * v19;
        do
        {
          uint64_t v22 = *v6++;
          *(void *)__n128 result = v22;
          result += 8;
          v21 -= 8;
        }
        while (v21);
      }
      uint64_t v23 = v12;
      while (v20 != a3)
      {
        uint64_t v24 = *v20++;
        *(void *)uint64_t v23 = v24;
        v23 += 8;
      }
      unsigned __int16 v17 = (char *)(v23 - v12);
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 61) {
      sub_19E041BEC();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = sub_19E08BE98(a1, v11);
    int v14 = (char *)a1[1];
    unsigned int v13 = a1 + 1;
    unsigned int v12 = v14;
    int v15 = v14;
    if (v6 != a3)
    {
      int v15 = v12;
      do
      {
        uint64_t v16 = *v6++;
        *(void *)int v15 = v16;
        v15 += 8;
      }
      while (v6 != a3);
    }
    unsigned __int16 v17 = (char *)(v15 - v12);
  }
  *unsigned int v13 = &v17[(void)v12];
  return result;
}

uint64_t sub_19E08ACC0(uint64_t result, int *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t v11 = (int *)result;
  while (2)
  {
    unsigned int v12 = a2 - 2;
    int64_t v68 = a2;
    uint64_t v70 = a2 - 4;
    uint64_t v67 = a2 - 6;
    unsigned int v13 = v11;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v11 = v13;
          uint64_t v14 = (char *)a2 - (char *)v13;
          unint64_t v15 = ((char *)a2 - (char *)v13) >> 3;
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                if (result)
                {
                  int v30 = *v11;
                  int *v11 = *(a2 - 2);
                  *(a2 - 2) = v30;
                  int v31 = v11[1];
                  v11[1] = *(a2 - 1);
                  *(a2 - 1) = v31;
                }
                break;
              case 3uLL:
                __n128 result = sub_19E08B8F4(v11, v11 + 2, v12, a3);
                break;
              case 4uLL:
                __n128 result = sub_19E08BA40(v11, v11 + 2, v11 + 4, v12, a3);
                break;
              case 5uLL:
                __n128 result = sub_19E08BB3C(v11, v11 + 2, v11 + 4, v11 + 6, v12, a3);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v14 <= 191)
          {
            if (a5)
            {
              if (v11 != a2)
              {
                uint64_t v32 = v11 + 2;
                if (v11 + 2 != a2)
                {
                  uint64_t v33 = 0;
                  do
                  {
                    uint64_t v34 = v32;
                    __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                    if (result)
                    {
                      uint64_t v74 = *(void *)v34;
                      uint64_t v35 = v33;
                      while (1)
                      {
                        uint64_t v36 = (char *)v11 + v35;
                        int v37 = *(int *)((char *)v11 + v35 + 4);
                        *((_DWORD *)v36 + 2) = *(int *)((char *)v11 + v35);
                        *((_DWORD *)v36 + 3) = v37;
                        if (!v35) {
                          break;
                        }
                        v35 -= 8;
                        __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                        if ((result & 1) == 0)
                        {
                          double v38 = (int *)((char *)v11 + v35 + 8);
                          goto LABEL_74;
                        }
                      }
                      double v38 = v11;
LABEL_74:
                      *(void *)double v38 = v74;
                    }
                    uint64_t v32 = v34 + 2;
                    v33 += 8;
                  }
                  while (v34 + 2 != a2);
                }
              }
            }
            else if (v11 != a2)
            {
              uint64_t v62 = v11 + 2;
              if (v11 + 2 != a2)
              {
                uint64_t v63 = v11 - 2;
                do
                {
                  uint64_t v64 = v62;
                  __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                  if (result)
                  {
                    uint64_t v77 = *(void *)v64;
                    uint64_t v65 = v63;
                    do
                    {
                      int v66 = v65[3];
                      v65[4] = v65[2];
                      v65[5] = v66;
                      __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                      v65 -= 2;
                    }
                    while ((result & 1) != 0);
                    *((void *)v65 + 2) = v77;
                  }
                  uint64_t v62 = v64 + 2;
                  v63 += 2;
                }
                while (v64 + 2 != a2);
              }
            }
            return result;
          }
          if (!a4)
          {
            if (v11 != a2)
            {
              int64_t v39 = (v15 - 2) >> 1;
              int64_t v71 = v39;
              do
              {
                int64_t v40 = v39;
                if (v71 >= v39)
                {
                  uint64_t v41 = (2 * v39) | 1;
                  unint64_t v42 = &v11[2 * v41];
                  if (2 * v39 + 2 < (uint64_t)v15 && (*(unsigned int (**)(void))(*(void *)a3 + 16))())
                  {
                    v42 += 2;
                    uint64_t v41 = 2 * v40 + 2;
                  }
                  uint64_t v43 = &v11[2 * v40];
                  __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                  if ((result & 1) == 0)
                  {
                    uint64_t v75 = *(void *)v43;
                    do
                    {
                      uint64_t v44 = v42;
                      *uint64_t v43 = *v42;
                      v43[1] = v42[1];
                      if (v71 < v41) {
                        break;
                      }
                      uint64_t v45 = (2 * v41) | 1;
                      unint64_t v42 = &v11[2 * v45];
                      uint64_t v46 = 2 * v41 + 2;
                      if (v46 < (uint64_t)v15 && (*(unsigned int (**)(void))(*(void *)a3 + 16))())
                      {
                        v42 += 2;
                        uint64_t v45 = v46;
                      }
                      __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                      uint64_t v43 = v44;
                      uint64_t v41 = v45;
                    }
                    while (!result);
                    *(void *)uint64_t v44 = v75;
                  }
                }
                int64_t v39 = v40 - 1;
              }
              while (v40);
              uint64_t v47 = (unint64_t)v14 >> 3;
              int v48 = v68;
              do
              {
                uint64_t v49 = 0;
                uint64_t v50 = *(void *)v11;
                uint64_t v51 = v47 - 2;
                unint64_t v69 = v48;
                if (v47 < 2) {
                  uint64_t v51 = v47 - 1;
                }
                uint64_t v52 = v51 >> 1;
                uint64_t v53 = v11;
                do
                {
                  uint64_t v54 = &v53[2 * v49 + 2];
                  uint64_t v55 = (2 * v49) | 1;
                  uint64_t v56 = 2 * v49 + 2;
                  if (v56 < v47)
                  {
                    __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                    if (result)
                    {
                      v54 += 2;
                      uint64_t v55 = v56;
                    }
                  }
                  *uint64_t v53 = *v54;
                  v53[1] = v54[1];
                  uint64_t v53 = v54;
                  uint64_t v49 = v55;
                }
                while (v55 <= v52);
                int v48 = v69 - 2;
                if (v54 == v69 - 2)
                {
                  *(void *)uint64_t v54 = v50;
                }
                else
                {
                  *uint64_t v54 = *(v69 - 2);
                  v54[1] = *(v69 - 1);
                  *((void *)v69 - 1) = v50;
                  uint64_t v57 = (char *)v54 - (char *)v11 + 8;
                  if (v57 >= 9)
                  {
                    unint64_t v58 = (unint64_t)((v57 >> 3) - 2) >> 1;
                    uint64_t v59 = &v11[2 * v58];
                    __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                    if (result)
                    {
                      uint64_t v76 = *(void *)v54;
                      do
                      {
                        uint64_t v60 = v59;
                        *uint64_t v54 = *v59;
                        v54[1] = v59[1];
                        if (!v58) {
                          break;
                        }
                        unint64_t v58 = (v58 - 1) >> 1;
                        uint64_t v59 = &v11[2 * v58];
                        __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
                        uint64_t v54 = v60;
                      }
                      while ((result & 1) != 0);
                      *(void *)uint64_t v60 = v76;
                    }
                  }
                }
              }
              while (v47-- > 2);
            }
            return result;
          }
          unint64_t v16 = v15 >> 1;
          unsigned __int16 v17 = &v11[2 * (v15 >> 1)];
          if ((unint64_t)v14 >= 0x401)
          {
            sub_19E08B8F4(v11, &v11[2 * (v15 >> 1)], v12, a3);
            sub_19E08B8F4(v11 + 2, v17 - 2, v70, a3);
            sub_19E08B8F4(v11 + 4, &v11[2 * v16 + 2], v67, a3);
            sub_19E08B8F4(v17 - 2, v17, &v11[2 * v16 + 2], a3);
            uint64_t v18 = *(void *)v11;
            *(void *)unint64_t v11 = *(void *)v17;
            *(void *)unsigned __int16 v17 = v18;
          }
          else
          {
            sub_19E08B8F4(&v11[2 * (v15 >> 1)], v11, v12, a3);
          }
          --a4;
          a2 = v68;
          if (a5 & 1) != 0 || ((*(uint64_t (**)(void))(*(void *)a3 + 16))()) {
            break;
          }
          uint64_t v73 = *(void *)v11;
          __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
          if (result)
          {
            unsigned int v13 = v11;
            do
            {
              v13 += 2;
              __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
            }
            while ((result & 1) == 0);
          }
          else
          {
            uint64_t v26 = v11 + 2;
            do
            {
              unsigned int v13 = v26;
              if (v26 >= v68) {
                break;
              }
              __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
              uint64_t v26 = v13 + 2;
            }
            while (!result);
          }
          uint64_t v27 = v68;
          if (v13 < v68)
          {
            uint64_t v27 = v68;
            do
            {
              v27 -= 2;
              __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
            }
            while ((result & 1) != 0);
          }
          while (v13 < v27)
          {
            int v28 = *v13;
            *unsigned int v13 = *v27;
            int *v27 = v28;
            int v29 = v13[1];
            v13[1] = v27[1];
            v27[1] = v29;
            do
              v13 += 2;
            while (!(*(unsigned int (**)(void))(*(void *)a3 + 16))());
            do
            {
              v27 -= 2;
              __n128 result = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
            }
            while ((result & 1) != 0);
          }
          BOOL v5 = v13 - 2 >= v11;
          BOOL v6 = v13 - 2 == v11;
          if (v13 - 2 != v11)
          {
            int *v11 = *(v13 - 2);
            v11[1] = *(v13 - 1);
          }
          a5 = 0;
          *((void *)v13 - 1) = v73;
        }
        uint64_t v72 = *(void *)v11;
        unint64_t v19 = v11;
        do
        {
          CFTypeRef v20 = v19;
          v19 += 2;
        }
        while (((*(uint64_t (**)(void))(*(void *)a3 + 16))() & 1) != 0);
        uint64_t v21 = v68;
        if (v20 == v11)
        {
          uint64_t v21 = v68;
          do
          {
            if (v19 >= v21) {
              break;
            }
            v21 -= 2;
          }
          while (((*(uint64_t (**)(void))(*(void *)a3 + 16))() & 1) == 0);
        }
        else
        {
          do
            v21 -= 2;
          while (!(*(unsigned int (**)(void))(*(void *)a3 + 16))());
        }
        unsigned int v13 = v19;
        if (v19 < v21)
        {
          uint64_t v22 = v21;
          do
          {
            int v23 = *v13;
            *unsigned int v13 = *v22;
            int *v22 = v23;
            int v24 = v13[1];
            v13[1] = v22[1];
            v22[1] = v24;
            do
              v13 += 2;
            while (((*(uint64_t (**)(void))(*(void *)a3 + 16))() & 1) != 0);
            do
              v22 -= 2;
            while (!(*(unsigned int (**)(void))(*(void *)a3 + 16))());
          }
          while (v13 < v22);
        }
        if (v13 - 2 != v11)
        {
          int *v11 = *(v13 - 2);
          v11[1] = *(v13 - 1);
        }
        *((void *)v13 - 1) = v72;
        if (v19 >= v21) {
          break;
        }
LABEL_31:
        __n128 result = sub_19E08ACC0(v11, v13 - 2, a3, a4, a5 & 1);
        a5 = 0;
      }
      BOOL v25 = sub_19E08BC78(v11, v13 - 2, a3);
      __n128 result = sub_19E08BC78(v13, v68, a3);
      if (result) {
        break;
      }
      if (!v25) {
        goto LABEL_31;
      }
    }
    a2 = v13 - 2;
    if (!v25) {
      continue;
    }
    return result;
  }
}

void sub_19E08B608(uint64_t a1, unsigned char *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  if (v4 != v5 << 6) {
    goto LABEL_37;
  }
  if ((uint64_t)(v4 + 1) < 0) {
    goto LABEL_9;
  }
  if (v4 > 0x3FFFFFFFFFFFFFFELL)
  {
    unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    if (v4 < 0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_11;
    }
  }
  else
  {
    unint64_t v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0) + 64) {
      unint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFC0) + 64;
    }
    else {
      unint64_t v7 = v6;
    }
    if (v4 < v7)
    {
      if ((v7 & 0x8000000000000000) != 0) {
LABEL_9:
      }
        sub_19E041BEC();
LABEL_11:
      int v29 = 0;
      long long v30 = 0uLL;
      sub_19E08B8B0(&v29, v7);
      uint64_t v8 = *(void **)a1;
      unint64_t v9 = *(void *)(a1 + 8);
      unint64_t v10 = v30;
      unint64_t v11 = v30 + v9;
      *(void *)&long long v30 = v30 + v9;
      if (v10)
      {
        unint64_t v12 = v11 - 1;
        if (((v11 - 1) ^ (v10 - 1)) < 0x40)
        {
LABEL_19:
          int v15 = v9 & 0x3F;
          unint64_t v16 = v29;
          if (v9 > 0x3F || (v9 & 0x3F) != 0)
          {
            int v17 = 0;
            uint64_t v18 = &v8[v9 >> 6];
            int v19 = v10 & 0x3F;
            CFTypeRef v20 = &v29[v10 >> 6];
            do
            {
              uint64_t v21 = 1 << v19;
              if ((*v8 >> v17)) {
                uint64_t v22 = *v20 | v21;
              }
              else {
                uint64_t v22 = *v20 & ~v21;
              }
              uint64_t *v20 = v22;
              v8 += v17 == 63;
              if (v17 == 63) {
                int v17 = 0;
              }
              else {
                ++v17;
              }
              v20 += v19 == 63;
              if (v19 == 63) {
                int v19 = 0;
              }
              else {
                ++v19;
              }
            }
            while (v8 != v18 || v17 != v15);
            unint64_t v16 = v29;
          }
          int v23 = *(void **)a1;
          *(void *)a1 = v16;
          int v29 = v23;
          long long v24 = *(_OWORD *)(a1 + 8);
          *(_OWORD *)(a1 + ++**(_DWORD **)(result + 8) = v30;
          long long v30 = v24;
          if (v23) {
            operator delete(v23);
          }
          goto LABEL_36;
        }
      }
      else
      {
        unint64_t v12 = v11 - 1;
      }
      unint64_t v13 = v12 >> 6;
      if (v11 >= 0x41) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = 0;
      }
      v29[v14] = 0;
      goto LABEL_19;
    }
  }
LABEL_36:
  unint64_t v4 = *(void *)(a1 + 8);
LABEL_37:
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = v4 + 1;
  BOOL v25 = *(void **)a1;
  unint64_t v26 = v4 >> 6;
  uint64_t v27 = 1 << v4;
  if (*a2) {
    uint64_t v28 = v25[v26] | v27;
  }
  else {
    uint64_t v28 = v25[v26] & ~v27;
  }
  v25[v26] = v28;
}

void sub_19E08B7C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E08B7DC(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = a2 - 1;
    while (1)
    {
      unint64_t v3 = v2 >> 6;
      uint64_t v4 = 1 << v2;
      uint64_t v5 = *(void *)(result + 8 * (v2 >> 6));
      if ((v5 & (1 << v2)) == 0) {
        break;
      }
      *(void *)(result + 8 * v3) = v5 & ~v4;
      if (--v2 == -1) {
        return result;
      }
    }
    *(void *)(result + 8 * v3) = v5 | v4;
  }
  return result;
}

void sub_19E08B820(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      unint64_t v6 = (char *)v1[1];
      do
      {
        uint64_t v8 = (void *)*((void *)v6 - 4);
        v6 -= 32;
        unint64_t v7 = v8;
        if (v8)
        {
          *((void *)v4 - 3) = v7;
          operator delete(v7);
        }
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_19E08B8B0(void *a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_19E041BEC();
  }
  __n128 result = sub_19E049FB0((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

uint64_t sub_19E08B8F4(int *a1, int *a2, int *a3, uint64_t a4)
{
  char v8 = (*(uint64_t (**)(void))(*(void *)a4 + 16))();
  uint64_t result = (*(uint64_t (**)(void))(*(void *)a4 + 16))();
  if (v8)
  {
    int v10 = *a1;
    if (result)
    {
      *a1 = *a3;
      *a3 = v10;
      unint64_t v11 = a3 + 1;
      unint64_t v12 = a1 + 1;
    }
    else
    {
      *a1 = *a2;
      *a2 = v10;
      int v17 = a1[1];
      a1[1] = a2[1];
      a2[1] = v17;
      uint64_t result = (*(uint64_t (**)(void))(*(void *)a4 + 16))();
      if (!result) {
        return result;
      }
      int v18 = *a2;
      *a2 = *a3;
      *a3 = v18;
      unint64_t v11 = a3 + 1;
      unint64_t v12 = a2 + 1;
    }
    int v15 = v11;
    goto LABEL_10;
  }
  if (result)
  {
    int v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    int v15 = a2 + 1;
    int v14 = a2[1];
    a2[1] = a3[1];
    a3[1] = v14;
    uint64_t result = (*(uint64_t (**)(void))(*(void *)a4 + 16))();
    if (result)
    {
      int v16 = *a1;
      *a1 = *a2;
      unint64_t v12 = a1 + 1;
      *a2 = v16;
LABEL_10:
      int v19 = *v12;
      int *v12 = *v15;
      int *v15 = v19;
    }
  }
  return result;
}

uint64_t sub_19E08BA40(int *a1, int *a2, int *a3, int *a4, uint64_t a5)
{
  sub_19E08B8F4(a1, a2, a3, a5);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16))();
  if (result)
  {
    int v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    int v12 = a3[1];
    a3[1] = a4[1];
    a4[1] = v12;
    uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16))();
    if (result)
    {
      int v13 = *a2;
      *a2 = *a3;
      *a3 = v13;
      int v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      uint64_t result = (*(uint64_t (**)(void))(*(void *)a5 + 16))();
      if (result)
      {
        int v15 = *a1;
        *a1 = *a2;
        *a2 = v15;
        int v16 = a1[1];
        a1[1] = a2[1];
        a2[1] = v16;
      }
    }
  }
  return result;
}

uint64_t sub_19E08BB3C(int *a1, int *a2, int *a3, int *a4, int *a5, uint64_t a6)
{
  sub_19E08BA40(a1, a2, a3, a4, a6);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)a6 + 16))();
  if (result)
  {
    int v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    int v14 = a4[1];
    a4[1] = a5[1];
    a5[1] = v14;
    uint64_t result = (*(uint64_t (**)(void))(*(void *)a6 + 16))();
    if (result)
    {
      int v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      int v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      uint64_t result = (*(uint64_t (**)(void))(*(void *)a6 + 16))();
      if (result)
      {
        int v17 = *a2;
        *a2 = *a3;
        *a3 = v17;
        int v18 = a2[1];
        a2[1] = a3[1];
        a3[1] = v18;
        uint64_t result = (*(uint64_t (**)(void))(*(void *)a6 + 16))();
        if (result)
        {
          int v19 = *a1;
          *a1 = *a2;
          *a2 = v19;
          int v20 = a1[1];
          a1[1] = a2[1];
          a2[1] = v20;
        }
      }
    }
  }
  return result;
}

BOOL sub_19E08BC78(int *a1, int *a2, uint64_t a3)
{
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if ((*(unsigned int (**)(void))(*(void *)a3 + 16))())
      {
        int v8 = *a1;
        *a1 = *(a2 - 2);
        *(a2 - 2) = v8;
        int v9 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v9;
      }
      return 1;
    case 3:
      sub_19E08B8F4(a1, a1 + 2, a2 - 2, a3);
      return 1;
    case 4:
      sub_19E08BA40(a1, a1 + 2, a1 + 4, a2 - 2, a3);
      return 1;
    case 5:
      sub_19E08BB3C(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2, a3);
      return 1;
    default:
      sub_19E08B8F4(a1, a1 + 2, a1 + 4, a3);
      int v10 = (uint64_t *)(a1 + 6);
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if ((*(unsigned int (**)(void))(*(void *)a3 + 16))())
    {
      uint64_t v17 = *v10;
      uint64_t v13 = v11;
      while (1)
      {
        int v14 = (char *)a1 + v13;
        int v15 = *(int *)((char *)a1 + v13 + 20);
        *((_DWORD *)v14 + 6) = *(int *)((char *)a1 + v13 + 16);
        *((_DWORD *)v14 + 7) = v15;
        if (v13 == -16) {
          break;
        }
        v13 -= 8;
        if (((*(uint64_t (**)(void))(*(void *)a3 + 16))() & 1) == 0)
        {
          int v16 = (int *)((char *)a1 + v13 + 24);
          goto LABEL_12;
        }
      }
      int v16 = a1;
LABEL_12:
      *(void *)int v16 = v17;
      if (++v12 == 8) {
        return v10 + 1 == (uint64_t *)a2;
      }
    }
    v11 += 8;
    if (++v10 == (uint64_t *)a2) {
      return 1;
    }
  }
}

BOOL sub_19E08BE78(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3 = a2[1];
  unsigned int v4 = a3[1];
  BOOL v5 = v3 == v4;
  BOOL v6 = v3 < v4;
  if (v5) {
    return *a2 < *a3;
  }
  else {
    return v6;
  }
}

char *sub_19E08BE98(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_19E041BEC();
  }
  BOOL result = (char *)sub_19E060B48(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

char **sub_19E08BED8(char **a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a1 == (char **)a2)
  {
    BOOL v6 = 0;
    unint64_t v7 = 0;
  }
  else
  {
    sub_19E08AB88(a1, *(uint64_t **)a2, *(uint64_t **)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
    unint64_t v7 = *a1;
    BOOL v6 = a1[1];
  }
  int v9 = *(uint64_t **)a3;
  int v8 = *(uint64_t **)(a3 + 8);
  uint64_t v10 = (uint64_t)v8 - *(void *)a3;
  if (v10 >= 1)
  {
    uint64_t v11 = v10 >> 3;
    uint64_t v12 = (v6 - v7) >> 3;
    uint64_t v13 = &v7[(v6 - v7) & 0xFFFFFFFFFFFFFFF8];
    int v14 = a1[2];
    if (v11 <= (v14 - v6) >> 3)
    {
      uint64_t v19 = (v6 - v13) >> 3;
      if (v19 >= v11)
      {
        int v20 = &v9[v11];
        uint64_t v22 = v6;
      }
      else
      {
        int v20 = &v9[v19];
        if (v20 == v8)
        {
          uint64_t v22 = v6;
        }
        else
        {
          uint64_t v21 = v20;
          uint64_t v22 = v6;
          do
          {
            uint64_t v23 = *v21++;
            *(void *)uint64_t v22 = v23;
            v22 += 8;
          }
          while (v21 != v8);
        }
        a1[1] = v22;
        if (v6 - v13 < 1)
        {
          BOOL v6 = v22;
          goto LABEL_41;
        }
      }
      uint64_t v35 = &v13[8 * v11];
      uint64_t v36 = &v22[-8 * v11];
      int v37 = v22;
      if (v36 < v6)
      {
        int v37 = v22;
        do
        {
          uint64_t v38 = *(void *)v36;
          v36 += 8;
          *(void *)int v37 = v38;
          v37 += 8;
        }
        while (v36 < v6);
      }
      a1[1] = v37;
      if (v22 != v35)
      {
        uint64_t v39 = 8 * ((v22 - v35) >> 3);
        int64_t v40 = v22 - 4;
        uint64_t v41 = (uint64_t)&v7[8 * v12 - 4];
        do
        {
          *((_DWORD *)v40 - 1) = *(_DWORD *)(v41 + v39 - 4);
          *(_DWORD *)int64_t v40 = *(_DWORD *)(v41 + v39);
          v40 -= 8;
          v39 -= 8;
        }
        while (v39);
      }
      for (; v9 != v20; v13 += 8)
      {
        uint64_t v42 = *v9++;
        *(void *)uint64_t v13 = v42;
      }
      BOOL v6 = v37;
    }
    else
    {
      unint64_t v15 = v11 + ((v6 - v7) >> 3);
      if (v15 >> 61) {
        sub_19E041BEC();
      }
      uint64_t v16 = v14 - v7;
      if (v16 >> 2 > v15) {
        unint64_t v15 = v16 >> 2;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v15;
      }
      if (v17) {
        unint64_t v17 = (unint64_t)sub_19E060B48(v17);
      }
      else {
        uint64_t v18 = 0;
      }
      long long v24 = (void *)(v17 + 8 * v12);
      BOOL v6 = (char *)&v24[v11];
      uint64_t v25 = 8 * v11;
      unint64_t v26 = v24;
      do
      {
        uint64_t v27 = *v9++;
        *v26++ = v27;
        v25 -= 8;
      }
      while (v25);
      uint64_t v28 = *a1;
      if (*a1 != v13)
      {
        int v29 = v13;
        do
        {
          uint64_t v30 = *((void *)v29 - 1);
          v29 -= 8;
          *--long long v24 = v30;
        }
        while (v29 != v28);
      }
      unint64_t v31 = v17 + 8 * v18;
      for (char i = a1[1]; v13 != i; v6 += 8)
      {
        uint64_t v33 = *(void *)v13;
        v13 += 8;
        *(void *)BOOL v6 = v33;
      }
      uint64_t v34 = *a1;
      *a1 = (char *)v24;
      a1[1] = v6;
      a1[2] = (char *)v31;
      if (v34)
      {
        operator delete(v34);
        BOOL v6 = a1[1];
      }
    }
  }
LABEL_41:
  for (uint64_t j = *a1; j != v6; j += 8)
    ++*((_DWORD *)j + 1);
  *((_DWORD *)a1 + 6) = *(_DWORD *)(a3 + 24) + *(_DWORD *)(a2 + 24);
  return a1;
}

void sub_19E08C158(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + ++**(_DWORD **)(result + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_19E08C178(void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_19E041BEC();
  }
  BOOL result = (char *)sub_19E068D84(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

__n128 sub_19E08C1B8(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 4sub_19E060B80(&a9, 0) = 0;
  *(void *)(a1 + 4++**(_DWORD **)(result + 8) = 0;
  *(void *)(a1 + 56) = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 4sub_19E060B80(&a9, 0) = result;
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 4sub_19E060B80(&a9, 0) = 0;
  *(void *)(a2 + 4++**(_DWORD **)(result + 8) = 0;
  *(void *)(a2 + 56) = 0;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  return result;
}

void sub_19E08C1E4(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 4++**(_DWORD **)(result + 8) = v2;
    operator delete(v2);
  }
}

void sub_19E08C1FC(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = sub_19E08C5B8((void *)(*(void *)(a1 + 40) + 40), a2);
  if (!v3) {
    __assert_rtn("encode_block_invoke", "TIHuffmanCoder.cpp", 207, "it != m_dictionary.end()");
  }
  unint64_t v4 = v3[4];
  int v5 = v4 & 0x3F;
  if (v4 > 0x3F || v5 != 0)
  {
    int v7 = 0;
    int v8 = 0;
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v28 = (unint64_t *)(v9 + 40);
    uint64_t v10 = (uint64_t *)v3[3];
    uint64_t v11 = &v10[v4 >> 6];
    int v12 = *(_DWORD *)(v9 + 64);
    int v27 = v5;
    do
    {
      uint64_t v13 = *v10;
      if (v12 == 8)
      {
        *(_DWORD *)(v9 + 64) = 0;
        unint64_t v15 = *(unsigned char **)(v9 + 48);
        unint64_t v14 = *(void *)(v9 + 56);
        if ((unint64_t)v15 >= v14)
        {
          unint64_t v17 = *v28;
          uint64_t v18 = &v15[-*v28];
          unint64_t v19 = (unint64_t)(v18 + 1);
          if ((uint64_t)(v18 + 1) < 0) {
            sub_19E041BEC();
          }
          unint64_t v20 = v14 - v17;
          if (2 * v20 > v19) {
            unint64_t v19 = 2 * v20;
          }
          if (v20 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v21 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v21 = v19;
          }
          if (v21) {
            uint64_t v22 = (char *)operator new(v21);
          }
          else {
            uint64_t v22 = 0;
          }
          uint64_t v23 = &v18[(void)v22];
          long long v24 = &v18[(void)v22];
          unsigned char *v24 = 0;
          uint64_t v16 = v24 + 1;
          if (v15 != (unsigned char *)v17)
          {
            uint64_t v25 = &v15[~v17];
            do
            {
              char v26 = *--v15;
              (v25--)[(void)v22] = v26;
            }
            while (v15 != (unsigned char *)v17);
            unint64_t v15 = (unsigned char *)*v28;
            uint64_t v23 = v22;
          }
          *(void *)(v9 + 4sub_19E060B80(&a9, 0) = v23;
          *(void *)(v9 + 4++**(_DWORD **)(result + 8) = v16;
          *(void *)(v9 + 56) = &v22[v21];
          if (v15) {
            operator delete(v15);
          }
          int v5 = v27;
        }
        else
        {
          unsigned char *v15 = 0;
          uint64_t v16 = v15 + 1;
        }
        *(void *)(v9 + 4++**(_DWORD **)(result + 8) = v16;
        int v12 = *(_DWORD *)(v9 + 64);
      }
      if ((v13 & (1 << v8)) != 0)
      {
        *(unsigned char *)(*(void *)(v9 + 48) - 1) |= 1 << v12;
        int v12 = *(_DWORD *)(v9 + 64);
      }
      *(_DWORD *)(v9 + 64) = ++v12;
      v10 += v7 == 63;
      if (v7 == 63) {
        int v8 = 0;
      }
      else {
        ++v8;
      }
      int v7 = v8;
    }
    while (v10 != v11 || v5 != v8);
  }
}

uint64_t sub_19E08C3E8(uint64_t a1, unsigned __int16 *a2)
{
  if (!*(void *)(a1 + 64)) {
    __assert_rtn("encoded_size", "TIHuffmanCoder.cpp", 223, "is_compiled()");
  }
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 0x40000000;
  uint64_t v18 = sub_19E08C570;
  unint64_t v19 = &unk_1E599BE68;
  uint64_t v20 = a1;
  if (*((void *)a2 + 1)) {
    uint64_t v2 = *((void *)a2 + 1);
  }
  else {
    uint64_t v2 = (uint64_t)(a2 + 8);
  }
  uint64_t v13 = v2;
  int v3 = *a2;
  int v14 = 0;
  int v15 = v3;
  unsigned int v16 = 0;
  sub_19E03E768(&v13);
  uint64_t v9 = v2;
  int v10 = v3;
  int v11 = v3;
  int v12 = 0;
  sub_19E03E768(&v9);
  uint64_t v4 = v13;
  if (v13 != v9) {
LABEL_9:
  }
    __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
  int v5 = 0;
  int v6 = v10;
  while (v14 != v6)
  {
    v5 += v18((uint64_t)v17, v16);
    sub_19E03E768(&v13);
    if (v13 != v4) {
      goto LABEL_9;
    }
  }
  int v7 = v5 + v18((uint64_t)v17, 0);
  if (!v7) {
    __assert_rtn("encoded_size", "TIHuffmanCoder.cpp", 234, "bit_count > 0");
  }
  return ((v7 - 1) >> 3) + 1;
}

uint64_t sub_19E08C570(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = sub_19E08C5B8((void *)(*(void *)(a1 + 32) + 40), a2);
  if (!v2) {
    __assert_rtn("encoded_size_block_invoke", "TIHuffmanCoder.cpp", 227, "it != m_dictionary.end()");
  }
  return v2[4];
}

uint64_t *sub_19E08C5B8(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  int v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (__n128 result = *v5; result; __n128 result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void *sub_19E08C66C(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4) {
    return a1;
  }
  sub_19E08B8B0(a1, v4);
  int v5 = *(void **)a2;
  unint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = a1[1];
  unint64_t v8 = v7 + v6;
  a1[1] = v7 + v6;
  if (v7)
  {
    unint64_t v9 = v8 - 1;
    if (((v8 - 1) ^ (v7 - 1)) < 0x40) {
      goto LABEL_10;
    }
  }
  else
  {
    unint64_t v9 = v8 - 1;
  }
  unint64_t v10 = v9 >> 6;
  if (v8 >= 0x41) {
    unint64_t v11 = v10;
  }
  else {
    unint64_t v11 = 0;
  }
  *(void *)(*a1 + 8 * v11) = 0;
LABEL_10:
  int v12 = v6 & 0x3F;
  if (v6 > 0x3F || (v6 & 0x3F) != 0)
  {
    int v13 = 0;
    int v14 = 0;
    int v15 = &v5[v6 >> 6];
    int v16 = v7 & 0x3F;
    unint64_t v17 = (uint64_t *)(*a1 + 8 * (v7 >> 6));
    do
    {
      uint64_t v18 = 1 << v16;
      if ((*v5 >> v14)) {
        uint64_t v19 = *v17 | v18;
      }
      else {
        uint64_t v19 = *v17 & ~v18;
      }
      *unint64_t v17 = v19;
      ++v14;
      v5 += v13 == 63;
      if (v13 == 63) {
        int v14 = 0;
      }
      v17 += v16 == 63;
      if (v16 == 63) {
        int v16 = 0;
      }
      else {
        ++v16;
      }
      int v13 = v14;
    }
    while (v5 != v15 || v12 != v14);
  }
  return a1;
}

void sub_19E08C784(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = (void *)*((void *)v4 - 3);
        if (v6)
        {
          *((void *)v4 - 2) = v6;
          operator delete(v6);
        }
        v4 -= 32;
      }
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_19E08C810(void ***a1)
{
  unint64_t v2 = *a1;
  if (*v2)
  {
    sub_19E08C864((uint64_t *)v2);
    uint8x8_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_19E08C864(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 32)
  {
    int v5 = *(void **)(i - 32);
    uint64_t v4 = v5;
    if (v5) {
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

unint64_t sub_19E08C8AC(int64x2_t *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (a2 >= a3
    || (uint64_t v4 = a3, v6 = a1->i64[1],
                 uint64_t v56 = a3,
                 a3 > (unint64_t)((a1[1].i64[0] - v6) >> 5)))
  {
    __assert_rtn("build_lookup_tables", "TIHuffmanCoder.cpp", 351, "lo < hi && hi <= m_codebook.size()");
  }
  unint64_t v8 = *(void *)(v6 + 32 * (a3 - 1) + 8);
  if (v8 <= a4) {
    __assert_rtn("build_lookup_tables", "TIHuffmanCoder.cpp", 354, "longest_codeword_length > depth");
  }
  uint64_t v9 = a2;
  unint64_t v64 = a4;
  unint64_t v10 = a1[3].u64[0];
  if (v8 - a4 >= 8) {
    uint64_t v11 = 8;
  }
  else {
    uint64_t v11 = v8 - a4;
  }
  uint64_t v12 = a1[2].i64[0];
  unint64_t v13 = a1[2].u64[1];
  unint64_t v55 = v13 - v12;
  uint64_t v14 = (uint64_t)(v13 - v12) >> 5;
  uint64_t v63 = v11;
  if (v13 >= v10)
  {
    if ((unint64_t)(v14 + 1) >> 59) {
      sub_19E041BEC();
    }
    uint64_t v16 = v10 - v12;
    uint64_t v17 = v16 >> 4;
    if (v16 >> 4 <= (unint64_t)(v14 + 1)) {
      uint64_t v17 = v14 + 1;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v18 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v17;
    }
    uint64_t v74 = a1 + 3;
    if (v18)
    {
      if (v18 >> 59) {
        sub_19E0416C4();
      }
      int v19 = v11;
      uint64_t v20 = (char *)operator new(32 * v18);
      LODWORD(v11) = v19;
    }
    else
    {
      uint64_t v20 = 0;
    }
    int64_t v71 = v20;
    v72.i64[0] = (uint64_t)&v20[32 * v14];
    uint64_t v73 = &v20[32 * v18];
    sub_19E08CDF8(v72.i64[0], v11);
    uint64_t v21 = v72.i64[0];
    unint64_t v15 = v72.i64[0] + 32;
    v72.i64[1] = v72.i64[0] + 32;
    uint64_t v23 = a1[2].i64[0];
    unint64_t v22 = a1[2].u64[1];
    if (v22 == v23)
    {
      int64x2_t v27 = vdupq_n_s64(v22);
    }
    else
    {
      uint64_t v24 = 0;
      do
      {
        uint64_t v25 = v21 + v24;
        uint64_t v26 = v22 + v24;
        *(_DWORD *)(v25 - 32) = *(_DWORD *)(v22 + v24 - 32);
        *(void *)(v25 - 16) = 0;
        *(void *)(v25 - ++**(_DWORD **)(result + 8) = 0;
        *(void *)(v25 - 24) = 0;
        *(_OWORD *)(v25 - 24) = *(_OWORD *)(v22 + v24 - 24);
        *(void *)(v25 - ++**(_DWORD **)(result + 8) = *(void *)(v22 + v24 - 8);
        *(void *)(v26 - 24) = 0;
        *(void *)(v26 - 16) = 0;
        *(void *)(v26 - ++**(_DWORD **)(result + 8) = 0;
        v24 -= 32;
      }
      while (v22 + v24 != v23);
      v21 += v24;
      int64x2_t v27 = a1[2];
      unint64_t v15 = v72.u64[1];
    }
    a1[2].i64[0] = v21;
    a1[2].i64[1] = v15;
    int64x2_t v72 = v27;
    uint64_t v28 = (char *)a1[3].i64[0];
    a1[3].i64[0] = (uint64_t)v73;
    uint64_t v73 = v28;
    int64_t v71 = (char *)v27.i64[0];
    sub_19E08CEB4((uint64_t)&v71);
  }
  else
  {
    sub_19E08CDF8(v13, v11);
    unint64_t v15 = v13 + 32;
    a1[2].i64[1] = v13 + 32;
  }
  a1[2].i64[1] = v15;
  uint64_t v29 = v63;
  unsigned int v61 = v64 & 0x3F;
  unint64_t v62 = v64 >> 6;
  unint64_t v30 = v63 + (v64 & 0x3F);
  unsigned int v58 = v30 & 0x3F;
  unint64_t v59 = v30 >> 6;
  unsigned int v60 = a4;
  unsigned int v57 = v63 + a4;
  do
  {
    uint64_t v31 = v4;
    uint64_t v32 = a1->i64[1];
    uint64_t v33 = (void *)(v32 + 32 * v9);
    unint64_t v34 = v33[1];
    if (v34 <= v64) {
      __assert_rtn("build_lookup_tables", "TIHuffmanCoder.cpp", 361, "codeword.size() > depth");
    }
    if (v34 <= v63 + v64)
    {
      int v46 = sub_19E08CF18(*v33 + 8 * v62, v61, (void *)(*v33 + 8 * (v34 >> 6)), v34 & 0x3F);
      uint64_t v29 = v63;
      char v47 = v34 - v64;
      int v48 = *(_DWORD *)(v32 + 32 * v9 + 24);
      unsigned int v49 = 1;
      do
      {
        uint64_t v50 = *(void *)(a1[2].i64[0] + 32 * v14 + 8) + 12 * (((v49 - 1) << v47) | v46);
        *(_DWORD *)uint64_t v50 = 0;
        *(unsigned char *)(v50 + 4) = v47;
        *(_DWORD *)(v50 + ++**(_DWORD **)(result + 8) = v48;
        LODWORD(v5sub_19E060B80(&a9, 0) = v49++ >> (v63 - (v34 - v64));
      }
      while (!v50);
    }
    else
    {
      v65[0] = MEMORY[0x1E4F143A8];
      v65[1] = 0x40000000;
      int v66 = sub_19E08CF78;
      uint64_t v67 = &unk_1E599BE88;
      unsigned int v70 = v60;
      int64_t v68 = (void *)(v32 + 32 * v9);
      uint64_t v69 = v29;
      uint64_t v35 = v68;
      if (v9 != v4)
      {
        uint64_t v36 = (void *)(v32 + 32 * v56);
        uint64_t v35 = v33;
        uint64_t v37 = 32 * v56 - 32 * v9;
        while (v66((uint64_t)v65, v35))
        {
          v35 += 4;
          v37 -= 32;
          if (!v37)
          {
            uint64_t v35 = v36;
            break;
          }
        }
        uint64_t v32 = a1->i64[1];
      }
      unint64_t v38 = ((unint64_t)v35 - v32) >> 5;
      if (v9 >= v38) {
        __assert_rtn("build_lookup_tables", "TIHuffmanCoder.cpp", 381, "sub_lo < sub_hi");
      }
      unsigned int v39 = sub_19E08CF18(*v33 + 8 * v62, v61, (void *)(*v33 + 8 * v62 + 8 * v59), v58);
      int v40 = sub_19E08C8AC(a1, v9, v38, v57);
      uint64_t v41 = *(void *)(a1[2].i64[0] + 32 * v14 + 8);
      uint64_t v42 = v41 + 12 * v39;
      int v44 = *(unsigned __int8 *)(v42 + 4);
      uint64_t v43 = (unsigned char *)(v42 + 4);
      if (v44) {
        __assert_rtn("build_lookup_tables", "TIHuffmanCoder.cpp", 385, "entry.empty()");
      }
      uint64_t v45 = (_DWORD *)(v41 + 12 * v39);
      *uint64_t v45 = 1;
      v45[2] = v40;
      uint64_t v29 = v63;
      *uint64_t v43 = v63;
      LODWORD(v9) = v38 - 1;
    }
    uint64_t v4 = v31;
    uint64_t v9 = (v9 + 1);
  }
  while (v9 < v31);
  uint64_t v51 = a1[2].i64[0] + 32 * v14;
  uint64_t v52 = *(void *)(v51 + 8);
  uint64_t v53 = *(void *)(v51 + 16);
  while (v52 != v53)
  {
    if (!*(unsigned char *)(v52 + 4)) {
      __assert_rtn("build_lookup_tables", "TIHuffmanCoder.cpp", 392, "std::all_of(m_tables[table_index].entries.begin(), m_tables[table_index].entries.end(), ^(const HuffmanDecoderTableEntry &entry) { return !entry.empty(); })");
    }
    v52 += 12;
  }
  return v55 >> 5;
}

void sub_19E08CD84(_Unwind_Exception *a1)
{
  sub_19E08CEB4(v1 - 144);
  _Unwind_Resume(a1);
}

uint64_t sub_19E08CDA4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    int v5 = *(void **)(v2 - 32);
    v2 -= 32;
    uint64_t v4 = v5;
    *(void *)(a1 + 16) = v2;
    if (v5)
    {
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E08CDF8(uint64_t a1, int a2)
{
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  uint64_t v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  int v5 = operator new(12 << a2);
  *uint64_t v4 = v5;
  uint64_t v6 = (char *)&v5[3 * (1 << a2)];
  uint64_t v7 = 12 * (1 << a2);
  *(void *)(a1 + 16) = v5;
  *(void *)(a1 + 24) = v6;
  do
  {
    v5[2] = 0;
    *(void *)int v5 = 0;
    v5 += 3;
    v7 -= 12;
  }
  while (v7);
  *(void *)(a1 + 16) = v6;
  if (!a2) {
    __assert_rtn("HuffmanDecoderTable", "TIHuffmanCoder.h", 66, "bl > 0");
  }
  return a1;
}

void sub_19E08CE98(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E08CEB4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 32;
    uint64_t v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E08CF18(uint64_t a1, unsigned int a2, void *a3, unsigned int a4)
{
  uint64_t result = 0;
  for (unsigned int i = 0; ; ++i)
  {
    uint64_t v7 = (void *)(a1 + (((a2 + (unint64_t)i) >> 3) & 0x3FFFFFF8));
    unsigned int v8 = ((_BYTE)a2 + (_BYTE)i) & 0x3F;
    if (v7 >= a3 && (v7 != a3 || v8 >= a4)) {
      break;
    }
    if ((*v7 >> v8)) {
      int v10 = 1 << i;
    }
    else {
      int v10 = 0;
    }
    uint64_t result = v10 | result;
  }
  return result;
}

uint64_t sub_19E08CF78(uint64_t a1, void *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 48);
  uint64_t v3 = v2 & 0x3F;
  uint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = v3 + v4;
  uint64_t v6 = v3 + v4 - 63;
  if (v6 < 0) {
    uint64_t v6 = (v2 & 0x3F) + v4;
  }
  uint64_t v7 = v6 >> 6;
  if (v4 >= 0) {
    unint64_t v8 = v5 >> 6;
  }
  else {
    unint64_t v8 = v7;
  }
  uint64_t v9 = (v5 & 0x3F) - v3 + (v8 << 6);
  if (v9 >= 1)
  {
    uint64_t v10 = (v2 >> 3) & 0x1FFFFFF8;
    uint64_t v11 = (void *)(**(void **)(a1 + 32) + v10);
    uint64_t v12 = (void *)(*a2 + v10);
    if (v3)
    {
      if (v9 >= (unint64_t)(64 - v3)) {
        uint64_t v13 = 64 - v3;
      }
      else {
        uint64_t v13 = v9;
      }
      if (((0xFFFFFFFFFFFFFFFFLL >> (64 - v3 - v13)) & (-1 << v3) & (*v11 ^ *v12)) != 0) {
        return 0;
      }
      v9 -= v13;
      ++v12;
      ++v11;
    }
    if (v9 >= 64)
    {
      while (*v12 == *v11)
      {
        uint64_t v14 = v9 - 64;
        ++v11;
        ++v12;
        BOOL v15 = v9 <= 127;
        v9 -= 64;
        if (v15) {
          goto LABEL_19;
        }
      }
      return 0;
    }
    uint64_t v14 = v9;
LABEL_19:
    if (v14 >= 1 && (*v11 ^ *v12) << -(char)v14) {
      return 0;
    }
  }
  return 1;
}

uint64_t sub_19E08D084()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E94578B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E94578B0))
  {
    sub_19E08D0F4();
    __cxa_guard_release(&qword_1E94578B0);
  }
  return qword_1E94578A8;
}

void sub_19E08D0DC(_Unwind_Exception *a1)
{
}

void sub_19E08D0F4()
{
  sub_19E0413C8(__p, "DefaultLogger");
  if (v2 >= 0) {
    uint64_t v0 = __p;
  }
  else {
    uint64_t v0 = (void **)__p[0];
  }
  qword_1E94578A8 = (uint64_t)os_log_create("com.apple.Lexicon", (const char *)v0);
  if (v2 < 0) {
    operator delete(__p[0]);
  }
}

uint64_t sub_19E08D160(uint64_t a1)
{
  char v2 = *(void **)(a1 + 16);
  while (v2)
  {
    uint64_t v3 = v2;
    char v2 = (void *)*v2;
    if (*((unsigned __int16 *)v3 + 8) >= 0xFu)
    {
      uint64_t v4 = v3[3];
      if (v4) {
        MEMORY[0x19F3BA6E0](v4, 0x1000C8077774924);
      }
    }
    operator delete(v3);
  }
  unint64_t v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

__n128 sub_19E08D1E0(__n128 *a1, uint64_t a2, uint64_t a3)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E94576E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E94576E0))
  {
    xmmword_1E94576B8 = 0u;
    *(_OWORD *)&qword_1E94576C8 = 0u;
    dword_1E94576D8 = 1065353216;
    __cxa_guard_release(&qword_1E94576E0);
  }
  unint64_t v7 = *((void *)&xmmword_1E94576B8 + 1);
  if (!*((void *)&xmmword_1E94576B8 + 1)) {
    goto LABEL_19;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1E94576B8 + 8));
  v8.i16[0] = vaddlv_u8(v8);
  unint64_t v9 = v8.u32[0];
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v10 = a3;
    if (*((void *)&xmmword_1E94576B8 + 1) <= (unint64_t)a3) {
      unint64_t v10 = (unint64_t)a3 % *((void *)&xmmword_1E94576B8 + 1);
    }
  }
  else
  {
    unint64_t v10 = (DWORD2(xmmword_1E94576B8) - 1) & a3;
  }
  uint64_t v11 = *(uint64_t ***)(xmmword_1E94576B8 + 8 * v10);
  if (!v11 || (uint64_t v12 = *v11) == 0)
  {
LABEL_19:
    (*(void (**)(void, uint64_t))(**(void **)(a2 + 1376) + 16))(*(void *)(a2 + 1376), a3);
    unint64_t v16 = *((void *)&xmmword_1E94576B8 + 1);
    if (*((void *)&xmmword_1E94576B8 + 1))
    {
      result.n128_u64[0] = (unint64_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1E94576B8 + 8));
      result.n128_u16[0] = vaddlv_u8((uint8x8_t)result.n128_u64[0]);
      if (result.n128_u32[0] > 1uLL)
      {
        unint64_t v3 = a3;
        if (*((void *)&xmmword_1E94576B8 + 1) <= (unint64_t)a3) {
          unint64_t v3 = (unint64_t)a3 % *((void *)&xmmword_1E94576B8 + 1);
        }
      }
      else
      {
        unint64_t v3 = (DWORD2(xmmword_1E94576B8) - 1) & a3;
      }
      uint64_t v17 = *(uint64_t ***)(xmmword_1E94576B8 + 8 * v3);
      if (v17)
      {
        for (unsigned int i = *v17; i; unsigned int i = (uint64_t *)*i)
        {
          unint64_t v19 = i[1];
          if (v19 == a3)
          {
            if (*((_DWORD *)i + 4) == a3) {
              goto LABEL_60;
            }
          }
          else
          {
            if (result.n128_u32[0] > 1uLL)
            {
              if (v19 >= *((void *)&xmmword_1E94576B8 + 1)) {
                v19 %= *((void *)&xmmword_1E94576B8 + 1);
              }
            }
            else
            {
              v19 &= *((void *)&xmmword_1E94576B8 + 1) - 1;
            }
            if (v19 != v3) {
              break;
            }
          }
        }
      }
    }
    uint64_t v20 = (char *)operator new(0x28uLL);
    *(void *)uint64_t v20 = 0;
    *((void *)v20 + 1) = a3;
    *((_DWORD *)v20 + 4) = a3;
    uint64_t v21 = (__n128 *)(v20 + 24);
    unint64_t v22 = a1->n128_u16[0];
    if (v22 >= 0xF)
    {
      v21->n128_u16[0] = v22;
      operator new[]();
    }
    __n128 result = *a1;
    __n128 *v21 = *a1;
    result.n128_f32[0] = (float)(unint64_t)(qword_1E94576D0 + 1);
    if (!v16 || (float)(*(float *)&dword_1E94576D8 * (float)v16) < result.n128_f32[0])
    {
      BOOL v23 = 1;
      if (v16 >= 3) {
        BOOL v23 = (v16 & (v16 - 1)) != 0;
      }
      unint64_t v24 = v23 | (2 * v16);
      unint64_t v25 = vcvtps_u32_f32(result.n128_f32[0] / *(float *)&dword_1E94576D8);
      if (v24 <= v25) {
        size_t v26 = v25;
      }
      else {
        size_t v26 = v24;
      }
      sub_19E08D7E4(v26);
      unint64_t v16 = *((void *)&xmmword_1E94576B8 + 1);
      if ((v16 & (v16 - 1)) != 0)
      {
        if (*((void *)&xmmword_1E94576B8 + 1) <= (unint64_t)a3) {
          unint64_t v3 = (unint64_t)a3 % *((void *)&xmmword_1E94576B8 + 1);
        }
        else {
          unint64_t v3 = a3;
        }
      }
      else
      {
        unint64_t v3 = (DWORD2(xmmword_1E94576B8) - 1) & a3;
      }
    }
    uint64_t v27 = xmmword_1E94576B8;
    uint64_t v28 = *(void **)(xmmword_1E94576B8 + 8 * v3);
    if (v28)
    {
      *(void *)uint64_t v20 = *v28;
    }
    else
    {
      *(void *)uint64_t v20 = qword_1E94576C8;
      qword_1E94576C8 = (uint64_t)v20;
      *(void *)(v27 + 8 * v3) = &qword_1E94576C8;
      if (!*(void *)v20) {
        goto LABEL_59;
      }
      unint64_t v29 = *(void *)(*(void *)v20 + 8);
      if ((v16 & (v16 - 1)) != 0)
      {
        if (v29 >= v16) {
          v29 %= v16;
        }
      }
      else
      {
        v29 &= v16 - 1;
      }
      uint64_t v28 = (void *)(xmmword_1E94576B8 + 8 * v29);
    }
    void *v28 = v20;
LABEL_59:
    ++qword_1E94576D0;
LABEL_60:
    if (a1->n128_u16[0] >= 3u) {
      ++*(_DWORD *)(a2 + 8);
    }
    return result;
  }
  uint64_t v13 = *((void *)&xmmword_1E94576B8 + 1) - 1;
  while (1)
  {
    unint64_t v14 = v12[1];
    if (v14 == a3) {
      break;
    }
    if (v8.u32[0] > 1uLL)
    {
      if (v14 >= *((void *)&xmmword_1E94576B8 + 1)) {
        v14 %= *((void *)&xmmword_1E94576B8 + 1);
      }
    }
    else
    {
      v14 &= v13;
    }
    if (v14 != v10) {
      goto LABEL_19;
    }
LABEL_18:
    uint64_t v12 = (uint64_t *)*v12;
    if (!v12) {
      goto LABEL_19;
    }
  }
  if (*((_DWORD *)v12 + 4) != a3) {
    goto LABEL_18;
  }
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v30 = a3;
    if (*((void *)&xmmword_1E94576B8 + 1) <= (unint64_t)a3) {
      unint64_t v30 = (unint64_t)a3 % *((void *)&xmmword_1E94576B8 + 1);
    }
  }
  else
  {
    unint64_t v30 = (DWORD2(xmmword_1E94576B8) - 1) & a3;
  }
  uint64_t v31 = *(void ***)(xmmword_1E94576B8 + 8 * v30);
  if (v31)
  {
    uint64_t v32 = (char *)*v31;
    if (*v31)
    {
      do
      {
        unint64_t v33 = *((void *)v32 + 1);
        if (v33 == a3)
        {
          if (*((_DWORD *)v32 + 4) == a3) {
            goto LABEL_103;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v33 >= *((void *)&xmmword_1E94576B8 + 1)) {
              v33 %= *((void *)&xmmword_1E94576B8 + 1);
            }
          }
          else
          {
            v33 &= v13;
          }
          if (v33 != v30) {
            break;
          }
        }
        uint64_t v32 = *(char **)v32;
      }
      while (v32);
    }
  }
  uint64_t v32 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v32 = 0;
  *((void *)v32 + 1) = a3;
  *((_DWORD *)v32 + 4) = a3;
  float v34 = (float)(unint64_t)(qword_1E94576D0 + 1);
  *((_WORD *)v32 + 12) = 0;
  if ((float)(*(float *)&dword_1E94576D8 * (float)v7) < v34)
  {
    BOOL v36 = v7 < 3 || v9 > 1;
    unint64_t v37 = v36 | (2 * v7);
    unint64_t v38 = vcvtps_u32_f32(v34 / *(float *)&dword_1E94576D8);
    if (v37 <= v38) {
      size_t v39 = v38;
    }
    else {
      size_t v39 = v37;
    }
    sub_19E08D7E4(v39);
    unint64_t v7 = *((void *)&xmmword_1E94576B8 + 1);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (*((void *)&xmmword_1E94576B8 + 1) <= (unint64_t)a3) {
        unint64_t v30 = (unint64_t)a3 % *((void *)&xmmword_1E94576B8 + 1);
      }
      else {
        unint64_t v30 = a3;
      }
    }
    else
    {
      unint64_t v30 = (DWORD2(xmmword_1E94576B8) - 1) & a3;
    }
  }
  uint64_t v40 = xmmword_1E94576B8;
  uint64_t v41 = *(void **)(xmmword_1E94576B8 + 8 * v30);
  if (v41)
  {
    *(void *)uint64_t v32 = *v41;
    goto LABEL_101;
  }
  *(void *)uint64_t v32 = qword_1E94576C8;
  qword_1E94576C8 = (uint64_t)v32;
  *(void *)(v40 + 8 * v3sub_19E060B80(&a9, 0) = &qword_1E94576C8;
  if (*(void *)v32)
  {
    unint64_t v42 = *(void *)(*(void *)v32 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v42 >= v7) {
        v42 %= v7;
      }
    }
    else
    {
      v42 &= v7 - 1;
    }
    uint64_t v41 = (void *)(xmmword_1E94576B8 + 8 * v42);
LABEL_101:
    *uint64_t v41 = v32;
  }
  ++qword_1E94576D0;
LABEL_103:
  int v44 = (__n128 *)(v32 + 24);
  unint64_t v43 = *((unsigned __int16 *)v32 + 12);
  if (v43 >= 0xF)
  {
    a1->n128_u16[0] = v43;
    operator new[]();
  }
  __n128 result = *v44;
  *a1 = *v44;
  return result;
}

void sub_19E08D77C(_Unwind_Exception *a1)
{
  sub_19E08D9F8(1, v1);
  _Unwind_Resume(a1);
}

void sub_19E08D7E4(size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  size_t v2 = *((void *)&xmmword_1E94576B8 + 1);
  if (prime <= *((void *)&xmmword_1E94576B8 + 1))
  {
    if (prime >= *((void *)&xmmword_1E94576B8 + 1)) {
      return;
    }
    unint64_t v9 = vcvtps_u32_f32((float)(unint64_t)qword_1E94576D0 / *(float *)&dword_1E94576D8);
    if (*((void *)&xmmword_1E94576B8 + 1) < 3uLL
      || (uint8x8_t v10 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1E94576B8 + 8)),
          v10.i16[0] = vaddlv_u8(v10),
          v10.u32[0] > 1uLL))
    {
      unint64_t v9 = std::__next_prime(v9);
    }
    else
    {
      uint64_t v11 = 1 << -(char)__clz(v9 - 1);
      if (v9 >= 2) {
        unint64_t v9 = v11;
      }
    }
    if (prime <= v9) {
      size_t prime = v9;
    }
    if (prime >= v2) {
      return;
    }
    if (!prime)
    {
      unint64_t v14 = (void *)xmmword_1E94576B8;
      *(void *)&xmmword_1E94576B8 = 0;
      if (v14) {
        operator delete(v14);
      }
      *((void *)&xmmword_1E94576B8 + 1) = 0;
      return;
    }
  }
  if (prime >> 61) {
    sub_19E0416C4();
  }
  unint64_t v3 = operator new(8 * prime);
  uint64_t v4 = (void *)xmmword_1E94576B8;
  *(void *)&xmmword_1E94576B8 = v3;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = 0;
  *((void *)&xmmword_1E94576B8 + 1) = prime;
  do
    *(void *)(xmmword_1E94576B8 + 8 * v5++) = 0;
  while (prime != v5);
  uint64_t v6 = (void **)qword_1E94576C8;
  if (qword_1E94576C8)
  {
    size_t v7 = *(void *)(qword_1E94576C8 + 8);
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      if (v7 >= prime) {
        v7 %= prime;
      }
    }
    else
    {
      v7 &= prime - 1;
    }
    *(void *)(xmmword_1E94576B8 + 8 * v7) = &qword_1E94576C8;
    for (i = *v6; i; size_t v7 = v13)
    {
      size_t v13 = i[1];
      if (v8.u32[0] > 1uLL)
      {
        if (v13 >= prime) {
          v13 %= prime;
        }
      }
      else
      {
        v13 &= prime - 1;
      }
      if (v13 != v7)
      {
        if (!*(void *)(xmmword_1E94576B8 + 8 * v13))
        {
          *(void *)(xmmword_1E94576B8 + 8 * v13) = v6;
          goto LABEL_31;
        }
        char *v6 = (void *)*i;
        *unsigned int i = **(void **)(xmmword_1E94576B8 + 8 * v13);
        **(void **)(xmmword_1E94576B8 + 8 * v13) = i;
        unsigned int i = v6;
      }
      size_t v13 = v7;
LABEL_31:
      uint64_t v6 = (void **)i;
      unsigned int i = (void *)*i;
    }
  }
}

void sub_19E08D9F8(char a1, void *__p)
{
  if (a1)
  {
    if (*((unsigned __int16 *)__p + 12) >= 0xFu)
    {
      uint64_t v3 = __p[4];
      if (v3) {
        MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
      }
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void *sub_19E08DA70(void *a1, long long *a2)
{
  *a1 = &unk_1EF09CB40;
  uint64_t v3 = a1 + 1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_19E03FA9C(v3, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    v3[2] = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }
  return a1;
}

void sub_19E08DAD8(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E08DAEC(void *a1)
{
  if (a1)
  {
    sub_19E08DAEC(*a1);
    sub_19E08DAEC(a1[1]);
    if (*((unsigned __int16 *)a1 + 20) >= 0xFu)
    {
      uint64_t v2 = a1[6];
      if (v2) {
        MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
      }
    }
    operator delete(a1);
  }
}

void sub_19E08DB60(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF09CB40;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }

  std::exception::~exception(this);
}

uint64_t sub_19E08DBC0(uint64_t a1)
{
  uint64_t result = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

void sub_19E08DBDC(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF09CB40;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::exception::~exception(this);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E08DC50(uint64_t a1, uint64_t *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 6) = 0;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 37) = 0;
  *(void *)(a1 + 4++**(_DWORD **)(result + 8) = 0;
  *(void *)(a1 + 56) = 0;
  HIDWORD(v13) = 0;
  *(void *)(a1 + 64) = 0xFFFFFFFFLL;
  *(unsigned char *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_WORD *)(a1 + 8sub_19E060B80(&a9, 0) = 0;
  unint64_t v14 = a2[1];
  uint64_t v15 = a2[2];
  unint64_t v16 = v15 + 1;
  if (v14 && v16 > v14) {
    return a1;
  }
  uint64_t v17 = *a2;
  a2[2] = v16;
  if (!v17) {
    return a1;
  }
  unint64_t v18 = v15 + 2;
  if (v14)
  {
    if (v18 > v14) {
      return a1;
    }
  }
  a2[2] = v18;
  char v20 = *(unsigned char *)(v17 + v16);
  *(unsigned char *)(a1 + 44) = v20;
  LODWORD(v13) = 1.0;
  if ((v20 & 4) != 0)
  {
    unint64_t v21 = v15 + 3;
    if (v14 && v21 > v14) {
      return a1;
    }
    a2[2] = v21;
    LOBYTE(v13) = *(unsigned char *)(v17 + v18);
    float v22 = (double)v13 * 0.00392156863;
    *(float *)&unint64_t v13 = v22 * v22;
    unint64_t v18 = v21;
  }
  *(_DWORD *)(a1 + 32) = v13;
  if ((v20 & 0x20) != 0)
  {
    unint64_t v24 = v18 + 1;
    if (v14 && v24 > v14) {
      return a1;
    }
    a2[2] = v24;
    uint64_t v23 = *(unsigned __int8 *)(v17 + v18);
  }
  else
  {
    uint64_t v23 = 0;
  }
  int v25 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a6 + 16))(a6, v23);
  *(_DWORD *)(a1 + 36) = v25;
  if (v25) {
    *(_DWORD *)(a1 + 4sub_19E060B80(&a9, 0) = 1;
  }
  char v26 = *(unsigned char *)(a1 + 44);
  if (v26)
  {
    unint64_t v28 = a2[1];
    uint64_t v27 = a2[2];
    unint64_t v29 = v27 + 4;
    if (v28 && v29 > v28) {
      return a1;
    }
    uint64_t v30 = *a2;
    a2[2] = v29;
    if (!v30) {
      return a1;
    }
    unsigned int v31 = bswap32(*(_DWORD *)(v30 + v27));
    *(_DWORD *)(a1 + 36) = v25 | 0x200000;
    *(_DWORD *)(a1 + 4sub_19E060B80(&a9, 0) = v31;
  }
  if ((v26 & 0x40) != 0)
  {
    unint64_t v33 = a2[1];
    uint64_t v32 = a2[2];
    unint64_t v34 = v32 + 4;
    if (v33 && v34 > v33) {
      return a1;
    }
    uint64_t v35 = *a2;
    a2[2] = v34;
    if (!v35) {
      return a1;
    }
    *(_DWORD *)(a1 + 56) = bswap32(*(_DWORD *)(v35 + v32));
  }
  if ((v26 & 0x10) == 0)
  {
    if (*a3)
    {
      sub_19E0D2DEC((uint64_t)v99, a4, a3);
      if (!v99[0]) {
        __assert_rtn("Word", "TIWord.cpp", 157, "!common_letter_base.is_empty()");
      }
      if ((*(unsigned char *)(a1 + 44) & 8) != 0)
      {
        int v107 = 0x100000;
        __int16 v108 = 0;
        unsigned __int8 v109 = 0;
        std::string v110 = 0;
        char v111 = 0;
        unint64_t v55 = v102;
        if (!v102) {
          unint64_t v55 = v103;
        }
        uint64_t v95 = v55;
        int v96 = 0;
        int v97 = v99[0];
        unsigned int v98 = 0;
        sub_19E03E768((uint64_t *)&v95);
        unsigned int v56 = 0;
        BOOL v57 = 1;
        while (1)
        {
          BOOL v58 = v57;
          if (!v57) {
            break;
          }
          unint64_t v60 = a2[1];
          uint64_t v59 = a2[2];
          unint64_t v61 = v59 + 1;
          if (v60) {
            BOOL v62 = v61 > v60;
          }
          else {
            BOOL v62 = 0;
          }
          if (!v62)
          {
            uint64_t v63 = *a2;
            a2[2] = v61;
            if (v63)
            {
              char v64 = *(unsigned char *)(v63 + v59);
              v93[0] = 0;
              v93[1] = 0;
              uint64_t v94 = 0;
              char v65 = sub_19E0F15E0(a2, (uint64_t)v93);
              if (v65)
              {
                if (v94 >= 0) {
                  int v66 = (char *)v93;
                }
                else {
                  int v66 = (char *)v93[0];
                }
                sub_19E0B1358((uint64_t)&__p, v66);
                if (v56 < (v64 & 0x1Fu))
                {
                  while (1)
                  {
                    uint64_t v67 = v102;
                    if (!v102) {
                      uint64_t v67 = v103;
                    }
                    unsigned __int8 v89 = v67;
                    int v90 = v99[0];
                    int v91 = v99[0];
                    int v92 = 0;
                    sub_19E03E768((uint64_t *)&v89);
                    if (v95 != v89) {
                      __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
                    }
                    if (v96 == v90) {
                      break;
                    }
                    sub_19E0B14D0((unsigned __int16 *)&v107, v98);
                    sub_19E03E768((uint64_t *)&v95);
                    if ((v64 & 0x1F) == ++v56)
                    {
                      unsigned int v56 = v64 & 0x1F;
                      break;
                    }
                  }
                }
                sub_19E0B1EE0((unsigned __int16 *)&v107, (uint64_t)&__p);
                if ((v64 & 0x20) != 0)
                {
                  sub_19E03E768((uint64_t *)&v95);
                  sub_19E03E768((uint64_t *)&v95);
                  v56 += 2;
                }
                else if ((v64 & 0x40) != 0)
                {
                  *(_DWORD *)(a1 + 36) |= 0x400000u;
                }
                else
                {
                  unsigned int v68 = 0;
                  unsigned int v69 = WORD2(__p);
                  if (WORD2(__p)) {
                    goto LABEL_90;
                  }
LABEL_89:
                  sub_19E0398F4((unsigned __int16 *)&__p);
                  unsigned int v69 = WORD2(__p);
LABEL_90:
                  while (v68 < v69)
                  {
                    sub_19E03E768((uint64_t *)&v95);
                    ++v68;
                    if (!v69) {
                      goto LABEL_89;
                    }
                  }
                  v56 += v68;
                }
                BOOL v57 = v64 < 0;
                if (v105) {
                  BOOL v70 = BYTE6(__p) == 1;
                }
                else {
                  BOOL v70 = 0;
                }
                if (v70) {
                  free(v105);
                }
              }
              else
              {
                BOOL v57 = 1;
              }
              if (SHIBYTE(v94) < 0) {
                operator delete(v93[0]);
              }
              if (v65) {
                continue;
              }
            }
          }
          goto LABEL_114;
        }
        while (1)
        {
          int64_t v71 = v102;
          if (!v102) {
            int64_t v71 = v103;
          }
          std::string __p = v71;
          LODWORD(v105) = v99[0];
          HIDWORD(v105) = v99[0];
          LODWORD(v106) = 0;
          sub_19E03E768((uint64_t *)&__p);
          if (v95 != __p) {
            __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
          }
          if (v96 == v105) {
            break;
          }
          sub_19E0B14D0((unsigned __int16 *)&v107, v98);
          sub_19E03E768((uint64_t *)&v95);
          ++v56;
        }
        int v72 = v100;
        if (!v100)
        {
          sub_19E0398F4(v99);
          int v72 = v100;
        }
        if (v56 != v72) {
          __assert_rtn("parse_substitution_list", "TIWord.cpp", 79, "count == base_surface_form.length()");
        }
        sub_19E03CD54(a1, (unsigned __int16 *)&v107);
LABEL_114:
        if (v110) {
          BOOL v73 = v109 == 1;
        }
        else {
          BOOL v73 = 0;
        }
        if (v73) {
          free(v110);
        }
        if (v58)
        {
          uint64_t v74 = v102;
          if (v102)
          {
            int v75 = v101;
LABEL_147:
            if (v75 == 1) {
              free(v74);
            }
          }
          return a1;
        }
      }
      else
      {
        sub_19E03CD54(a1, v99);
      }
      uint64_t v76 = v102;
      if (v102)
      {
        int v77 = v101;
LABEL_125:
        if (v77 == 1) {
          free(v76);
        }
      }
      goto LABEL_127;
    }
    uint64_t v87 = "!sort_key_for_derivation.empty()";
    int v88 = 155;
LABEL_160:
    __assert_rtn("Word", "TIWord.cpp", v88, v87);
  }
  if ((a7 & 0x40000) == 0)
  {
    std::string __p = 0;
    std::string v105 = 0;
    uint64_t v106 = 0;
    if (sub_19E0F15E0(a2, (uint64_t)&__p))
    {
      if (v106 >= 0) {
        p_p = (char *)&__p;
      }
      else {
        p_p = (char *)__p;
      }
      sub_19E0B1358((uint64_t)&v107, p_p);
      sub_19E03CD54(a1, (unsigned __int16 *)&v107);
      if (v110 && v109 == 1) {
        free(v110);
      }
      if (SHIBYTE(v106) < 0) {
        operator delete(__p);
      }
      goto LABEL_127;
    }
    if (SHIBYTE(v106) < 0) {
      operator delete(__p);
    }
    return a1;
  }
  if (!a5)
  {
    uint64_t v87 = "huffman_decoder";
    int v88 = 143;
    goto LABEL_160;
  }
  int v107 = 0x100000;
  __int16 v108 = 0;
  unsigned __int8 v109 = 0;
  std::string v110 = 0;
  char v111 = 0;
  unint64_t v37 = *(unsigned int **)(a5 + 32);
  if (v37 == *(unsigned int **)(a5 + 40))
  {
    unint64_t v42 = "valid()";
    int v54 = 399;
    goto LABEL_63;
  }
  unsigned int v38 = *v37;
  if (!*v37)
  {
    unint64_t v42 = "table.bit_length >= 1";
LABEL_62:
    int v54 = 407;
LABEL_63:
    __assert_rtn("decode", "TIHuffmanCoder.cpp", v54, v42);
  }
  uint64_t v39 = 0;
  unsigned int v40 = 0;
  unsigned int v41 = 0;
  unint64_t v42 = "table.bit_length >= 1";
  while (1)
  {
    if (v40 >= v38)
    {
LABEL_54:
      unsigned int v46 = v40;
      unsigned int v45 = v41;
    }
    else
    {
      uint64_t v44 = *a2;
      unint64_t v43 = a2[1];
      unsigned int v45 = v41;
      unsigned int v46 = v40;
      uint64_t v47 = a2[2];
      do
      {
        unint64_t v48 = v47 + 1;
        if (v43 && v48 > v43) {
          break;
        }
        a2[2] = v48;
        if (!v44) {
          goto LABEL_54;
        }
        v45 |= *(unsigned __int8 *)(v44 + v47) << v46;
        v46 += 8;
        ++v47;
      }
      while (v46 < v38);
    }
    unsigned int v49 = v45 & ~(-1 << v38);
    uint64_t v50 = *(void *)&v37[8 * v39 + 2];
    unsigned int v51 = *(unsigned __int8 *)(v50 + 12 * v49 + 4);
    unsigned int v40 = v46 - v51;
    if (v46 < v51)
    {
      uint64_t v74 = v110;
      if (!v110) {
        return a1;
      }
      int v75 = v109;
      goto LABEL_147;
    }
    int v52 = *(_DWORD *)(v50 + 12 * v49);
    if (v52 == 1)
    {
      uint64_t v39 = *(unsigned int *)(v50 + 12 * v49 + 8);
      goto LABEL_61;
    }
    if (!v52) {
      break;
    }
LABEL_61:
    unsigned int v41 = v45 >> v51;
    unsigned int v38 = v37[8 * v39];
    if (!v38) {
      goto LABEL_62;
    }
  }
  unsigned int v53 = *(_DWORD *)(v50 + 12 * v49 + 8);
  if (v53)
  {
    sub_19E0B14D0((unsigned __int16 *)&v107, v53);
    uint64_t v39 = 0;
    unint64_t v37 = *(unsigned int **)(a5 + 32);
    goto LABEL_61;
  }
  if (v40 >= 8) {
    a2[2] -= v40 >> 3;
  }
  sub_19E03CD54(a1, (unsigned __int16 *)&v107);
  uint64_t v76 = v110;
  if (v110)
  {
    int v77 = v109;
    goto LABEL_125;
  }
LABEL_127:
  if ((a7 & 0x10000) != 0)
  {
    int v107 = 0;
    if (sub_19E0F16E0(a2, &v107))
    {
      *(_DWORD *)(a1 + 6sub_19E060B80(&a9, 0) = v107;
      goto LABEL_130;
    }
LABEL_144:
    sub_19E03CE84(a1);
    return a1;
  }
LABEL_130:
  if ((a7 & 0x200000) == 0)
  {
    if ((a7 & 0x80000) == 0) {
      return a1;
    }
    unint64_t v78 = a2[1];
    unint64_t v79 = a2[2];
    goto LABEL_137;
  }
  unint64_t v78 = a2[1];
  uint64_t v80 = a2[2];
  unint64_t v79 = v80 + 4;
  if (v78 && v79 > v78) {
    goto LABEL_144;
  }
  uint64_t v81 = *a2;
  a2[2] = v79;
  if (!v81) {
    goto LABEL_144;
  }
  *(_DWORD *)(a1 + 64) = bswap32(*(_DWORD *)(v81 + v80));
  if ((a7 & 0x80000) != 0)
  {
LABEL_137:
    *(unsigned char *)(a1 + 72) = 1;
    unint64_t v82 = v79 + 4;
    if (!v78 || v82 <= v78)
    {
      uint64_t v83 = *a2;
      a2[2] = v82;
      if (v83)
      {
        unsigned int v84 = bswap32(*(_DWORD *)(v83 + v79));
        *(unsigned char *)(a1 + 72) = 1;
        *(_DWORD *)(a1 + 76) = v84;
        unint64_t v85 = v79 + 6;
        if (!v78 || v85 <= v78)
        {
          uint64_t v86 = *a2;
          a2[2] = v85;
          if (v86) {
            *(_WORD *)(a1 + 8sub_19E060B80(&a9, 0) = bswap32(*(unsigned __int16 *)(v86 + v82)) >> 16;
          }
        }
      }
    }
  }
  return a1;
}

void sub_19E08E4F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,void *a25,uint64_t a26,uint64_t a27,void *__p,void *a29,int a30,__int16 a31,char a32,char a33)
{
  BOOL v36 = *(void **)(v34 - 120);
  if (v36 && *(unsigned char *)(v34 - 122) == 1) {
    free(v36);
  }
  if (a33 < 0) {
    operator delete(__p);
  }
  unint64_t v37 = *(void **)(v33 + 8);
  if (v37)
  {
    if (*(unsigned char *)(v33 + 6) == 1) {
      free(v37);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E08E5F8(uint64_t a1, float *a2, unsigned int a3, int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *(float *)(a1 + 32) = *(float *)(a1 + 32) * a2[8];
  sub_19E03FB9C(&v9, (unsigned __int16 *)a2, a3, *(unsigned __int16 *)a2);
  sub_19E0B1EE0((unsigned __int16 *)a1, (uint64_t)&v9);
  if (v10) {
    BOOL v7 = BYTE6(v9) == 1;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    free(v10);
  }
  *(_DWORD *)(a1 + 56) &= ~0x20000000u;
  *(_DWORD *)(a1 + 6sub_19E060B80(&a9, 0) = a4;
  int v8 = *((_DWORD *)a2 + 9);
  if ((v8 & 2) != 0)
  {
    *(_DWORD *)(a1 + 36) |= 2u;
    int v8 = *((_DWORD *)a2 + 9);
    if ((v8 & 0x80) == 0)
    {
LABEL_9:
      if ((v8 & 4) == 0) {
        return;
      }
      goto LABEL_10;
    }
  }
  else if ((v8 & 0x80) == 0)
  {
    goto LABEL_9;
  }
  *(_DWORD *)(a1 + 36) |= 0x80u;
  if ((a2[9] & 4) == 0) {
    return;
  }
LABEL_10:
  *(_DWORD *)(a1 + 36) |= 4u;
}

void sub_19E08E6F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, void *a13)
{
  if (a13) {
    BOOL v14 = a12 == 1;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14) {
    free(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_19E08E71C(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a2 + 10))
  {
    *(_DWORD *)a1 = 0x100000;
    *(_WORD *)(a1 + 4) = 0;
    *(unsigned char *)(a1 + 6) = 0;
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
    *(unsigned char *)(a1 + 16) = 0;
    if (*((void *)a2 + 1)) {
      uint64_t v4 = *((void *)a2 + 1);
    }
    else {
      uint64_t v4 = (uint64_t)(a2 + 8);
    }
    uint64_t v15 = v4;
    int v5 = *a2;
    int v16 = 0;
    int v17 = v5;
    UChar32 c = 0;
    sub_19E03E768(&v15);
    uint64_t v11 = v4;
    int v12 = v5;
    int v13 = v5;
    int v14 = 0;
    uint64_t result = sub_19E03E768(&v11);
    unsigned int v7 = 0;
    uint64_t v8 = v11;
    int v9 = v12;
    while (1)
    {
      if (v15 != v8) {
        __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
      }
      if (v16 == v9) {
        break;
      }
      UChar32 v10 = c;
      if (v7 <= 0x1F && ((*((_DWORD *)a2 + 10) >> v7) & 1) != 0 && !u_istitle(c))
      {
        sub_19E0DD598((uint64_t)v19, v10, 0);
        sub_19E0B1EE0((unsigned __int16 *)a1, (uint64_t)v19);
        if (v20)
        {
          if (v19[6] == 1) {
            free(v20);
          }
        }
      }
      else
      {
        sub_19E0B14D0((unsigned __int16 *)a1, v10);
      }
      ++v7;
      uint64_t result = sub_19E03E768(&v15);
    }
  }
  else
  {
    return (uint64_t *)sub_19E039858(a1, a2);
  }
  return result;
}

void sub_19E08E8E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, void *a19)
{
  if (a19 && a18 == 1) {
    free(a19);
  }
  uint64_t v21 = *(void **)(v19 + 8);
  if (v21)
  {
    if (*(unsigned char *)(v19 + 6) == 1) {
      free(v21);
    }
  }
  _Unwind_Resume(exception_object);
}

void LXLatticeCreateMutable()
{
  if (qword_1E94576E8 != -1) {
    dispatch_once(&qword_1E94576E8, &unk_1EF098F68);
  }
  *(void *)(_CFRuntimeCreateInstance() + 16) = 0;
  operator new();
}

void sub_19E08EA28(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E08EA68()
{
  qword_1E94576F0 = 0;
  *(void *)algn_1E94576F8 = "LXLattice";
  qword_1E9457700 = 0;
  unk_1E9457708 = 0;
  qword_1E9457710 = (uint64_t)sub_19E08EABC;
  unk_1E9457718 = 0u;
  unk_1E9457728 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1E9457750 = result;
  return result;
}

uint64_t sub_19E08EABC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t LXLatticeAddNode(uint64_t a1, unint64_t a2, const __CFString *a3, uint64_t a4, double a5)
{
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16)) <= a2) {
    sub_19E0D23BC(*(void *)(a1 + 16), a2 + 1);
  }
  CFIndex Length = CFStringGetLength(a3);
  CharactersPtr = CFStringGetCharactersPtr(a3);
  if (!CharactersPtr) {
    operator new[]();
  }
  int v12 = (UniChar *)CharactersPtr;
  if ((*(uint64_t (**)(void, unint64_t))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), a2)) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = Length == a4;
  }
  if (!v13) {
    return 0;
  }
  uint64_t v14 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v15 = v14 + 24 * a2;
  unint64_t v18 = *(void *)(v15 + 8);
  int v17 = (double **)(v15 + 8);
  unint64_t v16 = v18;
  char v20 = (char **)(v17 + 1);
  uint64_t v19 = v17[1];
  if (v18 >= (unint64_t)v19)
  {
    unint64_t v24 = (double **)(v14 + 24 * a2);
    unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v16 - (void)*v24) >> 3);
    if (v25 + 1 > 0x666666666666666) {
      sub_19E041BEC();
    }
    unint64_t v26 = 0xCCCCCCCCCCCCCCCDLL * (v19 - *v24);
    uint64_t v27 = 2 * v26;
    if (2 * v26 <= v25 + 1) {
      uint64_t v27 = v25 + 1;
    }
    if (v26 >= 0x333333333333333) {
      unint64_t v28 = 0x666666666666666;
    }
    else {
      unint64_t v28 = v27;
    }
    unsigned int v41 = v17 + 1;
    if (v28)
    {
      if (v28 > 0x666666666666666) {
        sub_19E0416C4();
      }
      unint64_t v29 = (double *)operator new(40 * v28);
    }
    else
    {
      unint64_t v29 = 0;
    }
    unint64_t v37 = v29;
    unsigned int v38 = &v29[5 * v25];
    uint64_t v39 = v38;
    unsigned int v40 = (char *)&v29[5 * v28];
    sub_19E0D2320(v38, v12, Length);
    uint64_t v30 = v38;
    unsigned __int16 v38[3] = a5;
    *((void *)v30 + 4) = a4;
    unsigned int v31 = v38;
    uint64_t v21 = v39 + 5;
    uint64_t v32 = *v17;
    uint64_t v33 = *v24;
    if (*v17 == *v24)
    {
      uint64_t v35 = *v17;
    }
    else
    {
      do
      {
        long long v34 = *(_OWORD *)(v32 - 5);
        *(v31 - 3) = *(v32 - 3);
        *(_OWORD *)(v31 - 5) = v34;
        *(v32 - 4) = 0.0;
        *(v32 - 3) = 0.0;
        *(v32 - 5) = 0.0;
        *((_OWORD *)v31 - 1) = *((_OWORD *)v32 - 1);
        v31 -= 5;
        v32 -= 5;
      }
      while (v32 != v33);
      uint64_t v35 = *v24;
      uint64_t v32 = *v17;
    }
    unsigned char *v24 = v31;
    unsigned int v38 = v35;
    *int v17 = v21;
    uint64_t v39 = v32;
    BOOL v36 = *v20;
    void *v20 = v40;
    unsigned int v40 = v36;
    unint64_t v37 = v35;
    sub_19E08EE48((uint64_t)&v37);
  }
  else
  {
    sub_19E0D2320((void *)v16, v12, Length);
    *(double *)(v16 + 24) = a5;
    *(void *)(v16 + 32) = a4;
    uint64_t v21 = (double *)(v16 + 40);
    *int v17 = (double *)(v16 + 40);
  }
  *int v17 = v21;
  return 1;
}

void sub_19E08EDFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E08EE48((uint64_t)va);
  if (v2) {
    MEMORY[0x19F3BA6E0](v2, 0x1000C80BDFB0063);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E08EE48(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 5;
      *(void *)(a1 + 16) = v2 - 5;
      if (*((char *)v2 - 17) < 0)
      {
        operator delete(*v4);
        uint64_t v4 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_19E08EEAC()
{
}

uint64_t sub_19E08EEC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 8))(&v9);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 8))(&v7, a1, a3);
  if (sub_19E0A70C4((unsigned __int16 *)&v9, (unsigned __int16 *)&v7)) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = !sub_19E0A7134((unsigned __int16 *)&v9, (unsigned __int16 *)&v7);
  }
  if ((unsigned __int16)v7 >= 0xFu && v8) {
    MEMORY[0x19F3BA6E0](v8, 0x1000C8077774924);
  }
  if ((unsigned __int16)v9 >= 0xFu && v10) {
    MEMORY[0x19F3BA6E0](v10, 0x1000C8077774924);
  }
  return v5;
}

void sub_19E08EFC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, unsigned __int16 a11, uint64_t a12)
{
  if (a11 >= 0xFu)
  {
    if (a12) {
      MEMORY[0x19F3BA6E0](a12, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E08EFF8(uint64_t a1, char *a2, unsigned __int16 a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  sub_19E0B13C0((uint64_t)v5, a2, a3);
  (*(void (**)(uint64_t, unsigned char *))(*(void *)a1 + 8))(a1, v5);
  if (v6) {
    BOOL v4 = v5[6] == 1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    free(v6);
  }
}

void sub_19E08F0A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, void *a13)
{
  if (a13) {
    BOOL v14 = a12 == 1;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14) {
    free(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E08F0D0(uint64_t result)
{
  int add = atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF);
  if (add <= 0) {
    __assert_rtn("derefBase", "WTFRefCounted.h", 70, "new_count >= 0");
  }
  uint64_t v2 = result;
  if (result && add == 1)
  {
    uint64_t v3 = *(void **)(result + 16);
    if (v3 && *(unsigned char *)(v2 + 14) == 1) {
      free(v3);
    }
    JUMPOUT(0x19F3BA710);
  }
  return result;
}

uint64_t sub_19E08F174(uint64_t result)
{
  int add = atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF);
  if (add <= 0) {
    __assert_rtn("derefBase", "WTFRefCounted.h", 70, "new_count >= 0");
  }
  if (add == 1)
  {
    uint64_t v2 = result;
    uint64_t v3 = result + 24;
    uint64_t v4 = *(unsigned int *)(result + 16);
    if (v4)
    {
      uint64_t v5 = 8 * v4;
      uint64_t v6 = (uint64_t *)(result + 24);
      do
      {
        if (*v6) {
          sub_19E08F0D0(*v6);
        }
        ++v6;
        v5 -= 8;
      }
      while (v5);
      uint64_t v7 = *(unsigned int *)(v2 + 16);
    }
    else
    {
      uint64_t v7 = 0;
    }
    uint64_t v8 = *(unsigned int *)(v2 + 20);
    if (v8)
    {
      uint64_t v9 = 8 * v8;
      uint64_t v10 = (void *)(v3 + 8 * v7);
      do
      {
        if (*v10) {
          sub_19E08F174();
        }
        ++v10;
        v9 -= 8;
      }
      while (v9);
    }
    JUMPOUT(0x19F3BA710);
  }
  return result;
}

void sub_19E08F270(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &v14;
    uint64_t v16 = 0x2000000000;
    char v17 = 0;
    uint64_t v4 = a1 + 24;
    uint64_t v5 = *(unsigned int *)(a1 + 16);
    uint64_t v6 = *(unsigned int *)(a1 + 20);
    if (v6)
    {
      uint64_t v7 = (uint64_t *)(v4 + 8 * v5);
      uint64_t v8 = MEMORY[0x1E4F143A8];
      uint64_t v9 = 8 * v6;
      while (1)
      {
        uint64_t v10 = *v7;
        v13[0] = v8;
        v13[1] = 0x40000000;
        v13[2] = sub_19E08F3D4;
        _OWORD v13[3] = &unk_1E599BED0;
        v13[4] = a2;
        v13[5] = &v14;
        sub_19E08F270(v10, v13);
        if (*((unsigned char *)v15 + 24)) {
          break;
        }
        ++v7;
        v9 -= 8;
        if (!v9)
        {
          uint64_t v5 = *(unsigned int *)(a1 + 16);
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      char v18 = 0;
      if (v5)
      {
        uint64_t v11 = 8 * v5 - 8;
        do
        {
          (*(void (**)(uint64_t, uint64_t, char *))(a2 + 16))(a2, v4, &v18);
          v4 += 8;
          if (v18) {
            BOOL v12 = 1;
          }
          else {
            BOOL v12 = v11 == 0;
          }
          v11 -= 8;
        }
        while (!v12);
      }
    }
    _Block_object_dispose(&v14, 8);
  }
}

void sub_19E08F3B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E08F3D4(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (a3)
  {
    if (*a3) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    }
  }
  return result;
}

void sub_19E08F424(uint64_t *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, size_t a6)
{
  uint64_t v169 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (char *)(a2 + 8);
  unint64_t v12 = *(unsigned __int8 *)(a2 + 15);
  size_t v13 = v12 - a6;
  size_t v14 = 0;
  if (v12 >= a6) {
    size_t v15 = a6;
  }
  else {
    size_t v15 = *(unsigned __int8 *)(a2 + 15);
  }
  if (v15)
  {
    while (v11[v14] == *(unsigned char *)(a5 + v14))
    {
      if (v15 == ++v14)
      {
        size_t v14 = v15;
        break;
      }
    }
  }
  if (*(unsigned char *)(a2 + 15)) {
    BOOL v16 = v14 == 0;
  }
  else {
    BOOL v16 = 0;
  }
  if (v16) {
    __assert_rtn("merge", "TIDynamicTrie.cpp", 123, "is_root() || lcp_size > 0");
  }
  uint64_t v158 = 0;
  if (a6 > v14 && v12 > v14)
  {
    unint64_t v18 = *(unsigned int *)(a2 + 16);
    uint64_t v157 = 0;
    long long v156 = 0uLL;
    sub_19E0903C4(&v156, a2 + 24, a2 + 24 + 8 * v18, v18);
    unint64_t v19 = *(unsigned int *)(a2 + 20);
    uint64_t v20 = a2 + 24 + 8 * *(unsigned int *)(a2 + 16);
    uint64_t v155 = 0;
    long long v154 = 0uLL;
    sub_19E0904CC((uint64_t)&v154, v20, v20 + 8 * v19, v19);
    sub_19E09055C(&v133, &v11[v14], v12 - v14, &v156, &v154);
    uint64_t v160 = (void **)&v154;
    sub_19E0907E0(&v160);
    uint64_t v160 = (void **)&v156;
    sub_19E090860(&v160);
    sub_19E0908E0(&v159, *(void *)(a4 + 24), (char *)(a5 + v14), a6 - v14);
    unsigned int v21 = v11[v14];
    unsigned int v22 = *(unsigned __int8 *)(a5 + v14);
    BOOL v23 = v21 > v22;
    if (v21 == v22) {
      __assert_rtn("merge", "TIDynamicTrie.cpp", 133, "child1_key[0] != child2_key[0]");
    }
    uint64_t v24 = v133;
    if (v23) {
      uint64_t v25 = v133;
    }
    else {
      uint64_t v25 = (uint64_t)v159;
    }
    if (v23) {
      uint64_t v24 = (uint64_t)v159;
    }
    uint64_t v152 = 0;
    uint64_t v150 = 0;
    long long v151 = 0uLL;
    *(void *)&long long v133 = 0;
    uint64_t v165 = (void **)v24;
    *(void *)&long long v166 = v25;
    long long v149 = 0uLL;
    unint64_t v159 = 0;
    uint64_t v160 = (void **)&v149;
    v161.i8[0] = 0;
    *(void *)&long long v149 = operator new(0x10uLL);
    *((void *)&v149 + 1) = v149;
    uint64_t v150 = v149 + 16;
    *((void *)&v149 + 1) = sub_19E090AC0((uint64_t)&v165, (uint64_t)&v166 + 8, v149);
    sub_19E09055C(&v153, v11, v14, &v151, &v149);
    uint64_t v26 = v153;
    uint64_t v153 = 0;
    uint64_t v158 = v26;
    uint64_t v160 = (void **)&v149;
    sub_19E0907E0(&v160);
    for (uint64_t i = 1; i != -1; --i)
    {
      uint64_t v28 = (uint64_t)(&v165)[i];
      if (v28) {
        sub_19E08F174(v28);
      }
    }
    uint64_t v160 = (void **)&v151;
    sub_19E090860(&v160);
    if (v159) {
      sub_19E08F174((uint64_t)v159);
    }
    uint64_t v29 = v133;
    if (!(void)v133) {
      goto LABEL_165;
    }
    goto LABEL_27;
  }
  if (a6 != v14)
  {
    if (v12 == v14) {
      int v34 = 156;
    }
    else {
      int v34 = 155;
    }
    if (v12 == v14) {
      uint64_t v35 = "lcp_size < new_key.size()";
    }
    else {
      uint64_t v35 = "lcp_size == m_key_size";
    }
    if (v12 != v14 || a6 <= v14) {
      goto LABEL_171;
    }
    uint64_t v36 = a4;
    unint64_t v37 = (char *)(a5 + v12);
    unint64_t v38 = *(unsigned int *)(a2 + 20);
    uint64_t v39 = a2 + 24 + 8 * *(unsigned int *)(a2 + 16);
    uint64_t v40 = v39 + 8 * v38;
    if (v38)
    {
      uint64_t v40 = a2 + 24 + 8 * *(unsigned int *)(a2 + 16);
      unint64_t v41 = *(unsigned int *)(a2 + 20);
      do
      {
        unint64_t v42 = v41 >> 1;
        unint64_t v43 = (uint64_t *)(v40 + 8 * (v41 >> 1));
        uint64_t v45 = *v43;
        uint64_t v44 = v43 + 1;
        v41 += ~(v41 >> 1);
        if (*(unsigned __int8 *)(v45 + 8) < *v37) {
          uint64_t v40 = (uint64_t)v44;
        }
        else {
          unint64_t v41 = v42;
        }
      }
      while (v41);
    }
    long long v133 = 0uLL;
    uint64_t v134 = 0;
    sub_19E0904CC((uint64_t)&v133, v39, v39 + 8 * v38, v38);
    size_t v46 = a6 - v12;
    unint64_t v47 = (v40 - v39) >> 3;
    uint64_t v48 = v133;
    if (v47 < (uint64_t)(*((void *)&v133 + 1) - v133) >> 3
      && *(unsigned __int8 *)(*(void *)(v133 + 8 * v47) + 8) == *v37)
    {
      sub_19E08F424(&v160);
      unsigned int v49 = v160;
      if (*((_DWORD *)v160 + 4) || *((_DWORD *)v160 + 5))
      {
        uint64_t v160 = 0;
        uint64_t v50 = *(void *)(v133 + 8 * v47);
        *(void *)(v133 + 8 * v47) = v49;
        if (v50) {
          sub_19E08F174(v50);
        }
      }
      else
      {
        sub_19E090D7C((uint64_t)&v133, (uint64_t *)(v133 + 8 * v47));
      }
      unsigned int v51 = v160;
      if (!v160) {
        goto LABEL_164;
      }
    }
    else
    {
      sub_19E0908E0(&v159, *(void *)(v36 + 24), v37, v46);
      uint64_t v52 = v48 + 8 * v47;
      long long v53 = v133;
      uint64_t v54 = v52 - v133;
      uint64_t v55 = (v52 - (uint64_t)v133) >> 3;
      unsigned int v56 = (uint64_t *)(v133 + ((v52 - v133) & 0xFFFFFFFFFFFFFFF8));
      if (*((void *)&v133 + 1) >= (unint64_t)v134)
      {
        unint64_t v68 = ((uint64_t)(*((void *)&v133 + 1) - v133) >> 3) + 1;
        if (v68 >> 61) {
          sub_19E041BEC();
        }
        uint64_t v69 = (uint64_t)v134 - v133;
        if ((uint64_t)((uint64_t)v134 - v133) >> 2 > v68) {
          unint64_t v68 = v69 >> 2;
        }
        if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v70 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v70 = v68;
        }
        uint64_t v168 = (char *)&v134;
        if (v70) {
          unint64_t v70 = (unint64_t)sub_19E060B48(v70);
        }
        else {
          uint64_t v71 = 0;
        }
        unint64_t v82 = (uint64_t *)(v70 + 8 * v55);
        uint64_t v165 = (void **)v70;
        *(void *)&long long v166 = v82;
        *((void *)&v166 + 1) = v82;
        uint64_t v167 = (void **)(v70 + 8 * v71);
        if (v55 == v71)
        {
          if (v54 < 1)
          {
            if (v52 == (void)v53) {
              unint64_t v95 = 1;
            }
            else {
              unint64_t v95 = v54 >> 2;
            }
            long long v163 = v168;
            int v96 = (void **)sub_19E060B48(v95);
            unsigned int v98 = (void **)v166;
            uint64_t v99 = *((void *)&v166 + 1) - v166;
            if (*((void *)&v166 + 1) == (void)v166)
            {
              int64x2_t v105 = vdupq_n_s64(v166);
              unint64_t v101 = (unint64_t)&v96[v95 >> 2];
            }
            else
            {
              uint64_t v100 = v99 >> 3;
              unint64_t v101 = (unint64_t)&v96[v95 >> 2] + (v99 & 0xFFFFFFFFFFFFFFF8);
              uint64_t v102 = 8 * v100;
              uint64_t v103 = &v96[v95 >> 2];
              do
              {
                uint64_t v104 = *v98;
                *v98++ = 0;
                *v103++ = v104;
                v102 -= 8;
              }
              while (v102);
              int64x2_t v105 = (int64x2_t)v166;
            }
            uint64_t v114 = v165;
            uint64_t v115 = v167;
            uint64_t v165 = v96;
            *(void *)&long long v166 = &v96[v95 >> 2];
            int64x2_t v161 = v105;
            *((void *)&v166 + 1) = v101;
            uint64_t v167 = &v96[v97];
            uint64_t v160 = v114;
            unint64_t v162 = (unint64_t)v115;
            sub_19E090DD8((uint64_t)&v160);
            unsigned int v84 = (uint64_t *)*((void *)&v166 + 1);
            unint64_t v82 = (uint64_t *)v166;
          }
          else
          {
            if (v55 >= -1) {
              uint64_t v83 = v55 + 1;
            }
            else {
              uint64_t v83 = v55 + 2;
            }
            unsigned int v84 = sub_19E090E48((uint64_t *)(v70 + 8 * v55), v82, &v82[-(v83 >> 1)]);
            unint64_t v82 = (uint64_t *)(v166 - 8 * (v83 >> 1));
            *(void *)&long long v166 = v82;
          }
        }
        else
        {
          unsigned int v84 = (uint64_t *)(v70 + 8 * v55);
        }
        uint64_t v116 = (uint64_t)v159;
        unint64_t v159 = 0;
        *unsigned int v84 = v116;
        uint64_t v117 = v84 + 1;
        *((void *)&v166 + 1) = v117;
        uint64_t v118 = (uint64_t *)v133;
        if (v56 != (uint64_t *)v133)
        {
          uint64_t v119 = 0;
          do
          {
            long long v120 = (atomic_uint *)v56[v119 - 1];
            v82[v119 - 1] = (uint64_t)v120;
            if (v120 && (int)atomic_fetch_add(v120, 1u) <= 0) {
              __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
            }
            --v119;
          }
          while (&v56[v119] != v118);
          unint64_t v82 = (uint64_t *)((char *)v82 + v119 * 8);
          uint64_t v117 = (uint64_t *)*((void *)&v166 + 1);
        }
        *(void *)&long long v166 = v82;
        long long v121 = (uint64_t *)*((void *)&v133 + 1);
        if (v56 != *((uint64_t **)&v133 + 1))
        {
          uint64_t v122 = 0;
          do
          {
            long long v123 = (atomic_uint *)v56[v122];
            v117[v122] = (uint64_t)v123;
            if (v123 && (int)atomic_fetch_add(v123, 1u) <= 0) {
              __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
            }
            ++v122;
          }
          while (&v56[v122] != v121);
          uint64_t v117 = (uint64_t *)((char *)v117 + v122 * 8);
          unint64_t v82 = (uint64_t *)v166;
          unsigned int v56 = (uint64_t *)*((void *)&v133 + 1);
        }
        uint64_t v124 = v133;
        uint64_t v125 = v134;
        *(void *)&long long v133 = v82;
        *((void *)&v133 + 1) = v117;
        uint64_t v134 = v167;
        *((void *)&v166 + 1) = v56;
        uint64_t v167 = v125;
        uint64_t v165 = (void **)v124;
        *(void *)&long long v166 = v124;
        sub_19E090DD8((uint64_t)&v165);
      }
      else if (v56 == *((uint64_t **)&v133 + 1))
      {
        uint64_t v81 = (uint64_t)v159;
        unint64_t v159 = 0;
        *unsigned int v56 = v81;
        *((void *)&v133 + 1) = v56 + 1;
      }
      else
      {
        BOOL v57 = v56 + 1;
        BOOL v58 = (uint64_t *)(*((void *)&v133 + 1) - 8);
        if (*((void *)&v133 + 1) < 8uLL)
        {
          unint64_t v60 = (void *)*((void *)&v133 + 1);
        }
        else
        {
          uint64_t v59 = (uint64_t *)(*((void *)&v133 + 1) - 8);
          unint64_t v60 = (void *)*((void *)&v133 + 1);
          do
          {
            uint64_t v61 = *v59;
            *v59++ = 0;
            *v60++ = v61;
          }
          while ((unint64_t)v59 < *((void *)&v53 + 1));
        }
        *((void *)&v133 + 1) = v60;
        if (*((void **)&v53 + 1) != v57)
        {
          uint64_t v89 = 8 * ((uint64_t)(*((void *)&v53 + 1) - (void)v57) >> 3);
          uint64_t v90 = v53 + 8 * v55 - 8;
          do
          {
            uint64_t v91 = *(void *)(v90 + v89);
            *(void *)(v90 + v89) = 0;
            uint64_t v92 = *v58;
            *BOOL v58 = v91;
            if (v92) {
              sub_19E08F174(v92);
            }
            --v58;
            v89 -= 8;
          }
          while (v89);
        }
        uint64_t v93 = (uint64_t)v159;
        unint64_t v159 = 0;
        uint64_t v94 = *v56;
        *unsigned int v56 = v93;
        if (v94) {
          sub_19E08F174(v94);
        }
      }
      unsigned int v51 = v159;
      if (!v159) {
        goto LABEL_164;
      }
    }
    sub_19E08F174((uint64_t)v51);
LABEL_164:
    size_t v126 = *(unsigned __int8 *)(a2 + 15);
    unint64_t v127 = *(unsigned int *)(a2 + 16);
    uint64_t v132 = 0;
    long long v131 = 0uLL;
    sub_19E0903C4(&v131, a2 + 24, a2 + 24 + 8 * v127, v127);
    long long v129 = v133;
    v130 = v134;
    uint64_t v134 = 0;
    long long v133 = 0uLL;
    sub_19E09055C(&v165, v11, v126, &v131, &v129);
    uint64_t v26 = (uint64_t)v165;
    uint64_t v165 = 0;
    uint64_t v160 = (void **)&v129;
    sub_19E0907E0(&v160);
    uint64_t v160 = (void **)&v131;
    sub_19E090860(&v160);
    uint64_t v160 = (void **)&v133;
    sub_19E0907E0(&v160);
    goto LABEL_165;
  }
  if (a6 != v12)
  {
    if (a6 < v12)
    {
      unint64_t v63 = *(unsigned int *)(a2 + 16);
      uint64_t v142 = 0;
      long long v141 = 0uLL;
      sub_19E0903C4(&v141, a2 + 24, a2 + 24 + 8 * v63, v63);
      unint64_t v64 = *(unsigned int *)(a2 + 20);
      uint64_t v65 = a2 + 24 + 8 * *(unsigned int *)(a2 + 16);
      uint64_t v140 = 0;
      long long v139 = 0uLL;
      sub_19E0904CC((uint64_t)&v139, v65, v65 + 8 * v64, v64);
      sub_19E09055C(&v159, &v11[a6], v13, &v141, &v139);
      uint64_t v160 = (void **)&v139;
      sub_19E0907E0(&v160);
      uint64_t v160 = (void **)&v141;
      sub_19E090860(&v160);
      uint64_t v165 = 0;
      long long v166 = 0uLL;
      sub_19E090BAC((uint64_t)&v133, *(void *)(a4 + 24), 0);
      uint64_t v66 = v133;
      uint64_t v67 = v166;
      if ((void)v133)
      {
        if ((unint64_t)v166 >= *((void *)&v166 + 1))
        {
          uint64_t v77 = (uint64_t)(v166 - (void)v165) >> 3;
          if ((unint64_t)(v77 + 1) >> 61) {
            sub_19E041BEC();
          }
          unint64_t v78 = (uint64_t)(*((void *)&v166 + 1) - (void)v165) >> 2;
          if (v78 <= v77 + 1) {
            unint64_t v78 = v77 + 1;
          }
          if (*((void *)&v166 + 1) - (void)v165 >= 0x7FFFFFFFFFFFFFF8uLL) {
            unint64_t v79 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v79 = v78;
          }
          long long v163 = (char *)&v166 + 8;
          if (v79)
          {
            unint64_t v79 = (unint64_t)sub_19E060B48(v79);
            uint64_t v66 = v133;
          }
          else
          {
            uint64_t v80 = 0;
          }
          uint64_t v106 = (void *)(v79 + 8 * v77);
          uint64_t v160 = (void **)v79;
          v161.i64[0] = (uint64_t)v106;
          unint64_t v162 = v79 + 8 * v80;
          *(void *)&long long v133 = 0;
          *uint64_t v106 = v66;
          v161.i64[1] = (uint64_t)(v106 + 1);
          sub_19E090C08((uint64_t *)&v165, &v160);
          uint64_t v67 = v166;
          sub_19E090CF8((uint64_t)&v160);
        }
        else
        {
          *(void *)&long long v133 = 0;
          *(void *)long long v166 = v66;
          v67 += 8;
        }
        *(void *)&long long v166 = v67;
      }
      *(void *)&long long v137 = v165;
      *((void *)&v137 + 1) = v67;
      uint64_t v138 = *((void *)&v166 + 1);
      long long v166 = 0uLL;
      v164 = v159;
      uint64_t v165 = 0;
      uint64_t v136 = 0;
      long long v135 = 0uLL;
      unint64_t v159 = 0;
      uint64_t v160 = (void **)&v135;
      v161.i8[0] = 0;
      *(void *)&long long v135 = operator new(8uLL);
      *((void *)&v135 + 1) = v135;
      uint64_t v136 = v135 + 8;
      *((void *)&v135 + 1) = sub_19E090AC0((uint64_t)&v164, (uint64_t)&v165, v135);
      sub_19E09055C(&v153, v11, a6, &v137, &v135);
      uint64_t v26 = v153;
      uint64_t v153 = 0;
      uint64_t v158 = v26;
      uint64_t v160 = (void **)&v135;
      sub_19E0907E0(&v160);
      if (v164) {
        sub_19E08F174((uint64_t)v164);
      }
      uint64_t v160 = (void **)&v137;
      sub_19E090860(&v160);
      if ((void)v133) {
        sub_19E08F0D0(v133);
      }
      uint64_t v160 = (void **)&v165;
      sub_19E090860(&v160);
      uint64_t v29 = (uint64_t)v159;
      if (!v159) {
        goto LABEL_165;
      }
LABEL_27:
      sub_19E08F174(v29);
LABEL_165:
      *a1 = v26;
      return;
    }
    uint64_t v35 = "lcp_size < m_key_size";
    int v34 = 143;
LABEL_171:
    __assert_rtn("merge", "TIDynamicTrie.cpp", v34, v35);
  }
  unint64_t v31 = *(unsigned int *)(a2 + 16);
  long long v146 = 0uLL;
  v145 = 0;
  sub_19E0903C4(&v145, a2 + 24, a2 + 24 + 8 * v31, v31);
  uint64_t v32 = v145;
  long long v148 = v146;
  v145 = 0;
  long long v146 = 0uLL;
  v147 = v32;
  uint64_t v165 = (void **)MEMORY[0x1E4F143A8];
  *(void *)&long long v166 = 0x40000000;
  *((void *)&v166 + 1) = sub_19E090ECC;
  uint64_t v167 = (void **)&unk_1E599BEF0;
  uint64_t v168 = a3;
  uint64_t v33 = (uint64_t *)v148;
  while (v32 != v33)
  {
    if ((*((uint64_t (**)(void ***, uint64_t *))&v166 + 1))(&v165, v32))
    {
      if (v32 != v33)
      {
        sub_19E090BAC((uint64_t)&v160, *(void *)(a4 + 24), *v32);
        int v72 = v160;
        if (v160)
        {
          if ((int)atomic_fetch_add((atomic_uint *volatile)v160, 1u) <= 0) {
            __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
          }
          uint64_t v73 = *v32;
          *uint64_t v32 = (uint64_t)v72;
          if (v73) {
            sub_19E08F0D0(v73);
          }
        }
        else
        {
          __int16 v108 = v32 + 1;
          unsigned __int8 v109 = (uint64_t *)v148;
          if (v32 + 1 != (uint64_t *)v148)
          {
            do
            {
              uint64_t v110 = *(v108 - 1);
              *(v108 - 1) = *v108;
              *__int16 v108 = 0;
              if (v110) {
                sub_19E08F0D0(v110);
              }
              ++v108;
            }
            while (v108 != v109);
            uint64_t v32 = v108 - 1;
          }
          while (v109 != v32)
          {
            uint64_t v111 = *--v109;
            sub_19E090EAC(v111);
          }
          *(void *)&long long v148 = v32;
        }
        if (v160) {
          sub_19E08F0D0((uint64_t)v160);
        }
        goto LABEL_145;
      }
      break;
    }
    ++v32;
  }
  sub_19E090BAC((uint64_t)&v133, *(void *)(a4 + 24), 0);
  uint64_t v74 = v133;
  if ((void)v133)
  {
    uint64_t v75 = v148;
    if ((unint64_t)v148 >= *((void *)&v148 + 1))
    {
      uint64_t v85 = (uint64_t)(v148 - (void)v147) >> 3;
      if ((unint64_t)(v85 + 1) >> 61) {
        sub_19E041BEC();
      }
      unint64_t v86 = (uint64_t)(*((void *)&v148 + 1) - (void)v147) >> 2;
      if (v86 <= v85 + 1) {
        unint64_t v86 = v85 + 1;
      }
      if (*((void *)&v148 + 1) - (void)v147 >= 0x7FFFFFFFFFFFFFF8uLL) {
        unint64_t v87 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v87 = v86;
      }
      long long v163 = (char *)&v148 + 8;
      if (v87)
      {
        unint64_t v87 = (unint64_t)sub_19E060B48(v87);
        uint64_t v74 = v133;
      }
      else
      {
        uint64_t v88 = 0;
      }
      int v107 = (void *)(v87 + 8 * v85);
      uint64_t v160 = (void **)v87;
      v161.i64[0] = (uint64_t)v107;
      unint64_t v162 = v87 + 8 * v88;
      *(void *)&long long v133 = 0;
      *int v107 = v74;
      v161.i64[1] = (uint64_t)(v107 + 1);
      sub_19E090C08((uint64_t *)&v147, &v160);
      uint64_t v76 = v148;
      sub_19E090CF8((uint64_t)&v160);
    }
    else
    {
      *(void *)&long long v133 = 0;
      *(void *)long long v148 = v74;
      uint64_t v76 = v75 + 8;
    }
    *(void *)&long long v148 = v76;
    if ((void)v133) {
      sub_19E08F0D0(v133);
    }
  }
LABEL_145:
  unint64_t v112 = *(unsigned int *)(a2 + 20);
  uint64_t v113 = a2 + 24 + 8 * *(unsigned int *)(a2 + 16);
  uint64_t v144 = 0;
  long long v143 = 0uLL;
  sub_19E0904CC((uint64_t)&v143, v113, v113 + 8 * v112, v112);
  sub_19E09055C(a1, v11, a6, (long long *)&v147, &v143);
  uint64_t v160 = (void **)&v143;
  sub_19E0907E0(&v160);
  uint64_t v160 = (void **)&v147;
  sub_19E090860(&v160);
  uint64_t v160 = (void **)&v145;
  sub_19E090860(&v160);
}

void sub_19E0900F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  sub_19E090B78((uint64_t *)(v17 - 192));
  *(void *)(v17 - 20sub_19E060B80(&a9, 0) = &a17;
  sub_19E0907E0((void ***)(v17 - 200));
  sub_19E090B78((uint64_t *)(v17 - 208));
  _Unwind_Resume(a1);
}

void *sub_19E0903C4(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_19E060B48(a4);
    uint64_t v7 = (char *)result;
    void *v6 = result;
    v6[1] = result;
    v6[2] = &result[v8];
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t v10 = *(atomic_uint **)(a2 + v9 * 8);
        result[v9] = v10;
        if (v10)
        {
          if ((int)atomic_fetch_add(v10, 1u) <= 0) {
            __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
          }
        }
        ++v9;
      }
      while (a2 + v9 * 8 != a3);
      uint64_t v7 = (char *)&result[v9];
    }
    v6[1] = v7;
  }
  return result;
}

void sub_19E090490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_19E0904CC(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = (void *)result;
    uint64_t v7 = (char *)sub_19E060B48(a4);
    void *v6 = v7;
    v6[1] = v7;
    v6[2] = &v7[8 * v8];
    uint64_t result = sub_19E090AC0(a2, a3, (uint64_t)v7);
    v6[1] = result;
  }
  return result;
}

void sub_19E09053C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + ++**(_DWORD **)(result + 8) = v10;
  sub_19E0907E0(&a9);
  _Unwind_Resume(a1);
}

void sub_19E09055C(void *a1, char *a2, size_t a3, long long *a4, long long *a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  if (a3 <= 7)
  {
    long long v19 = *a4;
    uint64_t v20 = *((void *)a4 + 2);
    *((void *)a4 + 1) = 0;
    *((void *)a4 + 2) = 0;
    *(void *)a4 = 0;
    long long v17 = *a5;
    uint64_t v18 = *((void *)a5 + 2);
    *((void *)a5 + 1) = 0;
    *((void *)a5 + 2) = 0;
    *(void *)a5 = 0;
    sub_19E090EF0(&v21, a2, a3, &v19, &v17);
    *a1 = v21;
    unsigned int v22 = (char **)&v17;
    sub_19E0907E0((void ***)&v22);
    unsigned int v22 = (char **)&v19;
    sub_19E090860((void ***)&v22);
  }
  else
  {
    long long v15 = *a4;
    uint64_t v16 = *((void *)a4 + 2);
    *((void *)a4 + 1) = 0;
    *((void *)a4 + 2) = 0;
    *(void *)a4 = 0;
    long long v13 = *a5;
    uint64_t v14 = *((void *)a5 + 2);
    *((void *)a5 + 1) = 0;
    *((void *)a5 + 2) = 0;
    *(void *)a5 = 0;
    sub_19E09055C(&v21, a2 + 7, a3 - 7, &v15, &v13);
    unsigned int v22 = (char **)&v13;
    sub_19E0907E0((void ***)&v22);
    unsigned int v22 = (char **)&v15;
    sub_19E090860((void ***)&v22);
    uint64_t v10 = 0;
    memset(v11, 0, sizeof(v11));
    uint64_t v24 = v21;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v21 = 0;
    unsigned int v22 = &v8;
    char v23 = 0;
    uint64_t v8 = (char *)operator new(8uLL);
    uint64_t v9 = (uint64_t)v8;
    uint64_t v10 = v8 + 8;
    uint64_t v9 = sub_19E090AC0((uint64_t)&v24, (uint64_t)&v25, (uint64_t)v8);
    sub_19E090EF0(&v12, a2, 7uLL, v11, &v8);
    uint64_t v7 = v12;
    uint64_t v12 = 0;
    *a1 = v7;
    unsigned int v22 = &v8;
    sub_19E0907E0((void ***)&v22);
    if (v24) {
      sub_19E08F174(v24);
    }
    unsigned int v22 = (char **)v11;
    sub_19E090860((void ***)&v22);
    if (v21) {
      sub_19E08F174(v21);
    }
  }
}

void sub_19E090754(_Unwind_Exception *a1)
{
  *(void *)(v4 - 8sub_19E060B80(&a9, 0) = v3;
  sub_19E0907E0((void ***)(v4 - 80));
  *(void *)(v4 - 8sub_19E060B80(&a9, 0) = v2;
  sub_19E090860((void ***)(v4 - 80));
  sub_19E090B78(v1);
  _Unwind_Resume(a1);
}

void sub_19E0907E0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = *((void *)v4 - 1);
        v4 -= 8;
        sub_19E090E28(v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_19E090860(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = *((void *)v4 - 1);
        v4 -= 8;
        sub_19E090EAC(v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_19E0908E0(void *a1, uint64_t a2, char *a3, size_t a4)
{
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  sub_19E090BAC((uint64_t)&v22, a2, 0);
  uint64_t v7 = v22;
  uint64_t v8 = 0;
  if (v22)
  {
    uint64_t v9 = (v19 - v18) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_19E041BEC();
    }
    unint64_t v10 = (v20 - v18) >> 2;
    if (v10 <= v9 + 1) {
      unint64_t v10 = v9 + 1;
    }
    if ((unint64_t)(v20 - v18) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    void v21[4] = (void **)&v20;
    if (v11)
    {
      unint64_t v11 = (unint64_t)sub_19E060B48(v11);
      uint64_t v7 = v22;
    }
    else
    {
      uint64_t v12 = 0;
    }
    long long v13 = (void **)(v11 + 8 * v9);
    v21[0] = (void **)v11;
    v21[1] = v13;
    void v21[3] = (void **)(v11 + 8 * v12);
    uint64_t v22 = 0;
    *long long v13 = (void *)v7;
    uint64_t v21[2] = v13 + 1;
    sub_19E090C08(&v18, v21);
    uint64_t v8 = v19;
    sub_19E090CF8((uint64_t)v21);
    uint64_t v19 = v8;
  }
  *(void *)&long long v16 = v18;
  *((void *)&v16 + 1) = v8;
  uint64_t v17 = v20;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v15 = 0;
  long long v14 = 0uLL;
  sub_19E09055C(a1, a3, a4, &v16, &v14);
  v21[0] = (void **)&v14;
  sub_19E0907E0(v21);
  v21[0] = (void **)&v16;
  sub_19E090860(v21);
  if (v22) {
    sub_19E08F0D0(v22);
  }
  v21[0] = (void **)&v18;
  sub_19E090860(v21);
}

void sub_19E090A60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  sub_19E090CF8((uint64_t)va1);
  sub_19E090D48((uint64_t *)(v8 - 56));
  *(void *)(v8 - 56) = va;
  sub_19E090860((void ***)(v8 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_19E090AC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (a1 != a2)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(atomic_uint **)(a1 + v4);
      *(void *)(a3 + v4) = v5;
      if (v5 && (int)atomic_fetch_add(v5, 1u) <= 0) {
        __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
      }
      v4 += 8;
    }
    while (a1 + v4 != a2);
    return a3 + v4;
  }
  return v3;
}

uint64_t *sub_19E090B78(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_19E08F174(v2);
  }
  return a1;
}

uint64_t sub_19E090BAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  if (!a2) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a2 + 48))(a2, &v4);
}

uint64_t *sub_19E090C08(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = *(atomic_uint **)(v2 + v5 - 8);
      *(void *)(v4 + v5 - ++**(_DWORD **)(result + 8) = v6;
      if (v6 && (int)atomic_fetch_add(v6, 1u) <= 0) {
        __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
      }
      v5 -= 8;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v7 = *result;
  *uint64_t result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t sub_19E090CF8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(a1 + 16) = i - 8;
    sub_19E090EAC(v4);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *sub_19E090D48(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_19E08F0D0(v2);
  }
  return a1;
}

uint64_t sub_19E090D7C(uint64_t a1, uint64_t *a2)
{
  uint64_t result = (uint64_t)sub_19E090E48(a2 + 1, *(uint64_t **)(a1 + 8), a2);
  uint64_t v4 = result;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5 != result)
  {
    do
    {
      uint64_t v6 = *(void *)(v5 - 8);
      v5 -= 8;
      uint64_t result = sub_19E090E28(v6);
    }
    while (v5 != v4);
  }
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = v4;
  return result;
}

uint64_t sub_19E090DD8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(a1 + 16) = i - 8;
    sub_19E090E28(v4);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E090E28(uint64_t result)
{
  if (result) {
    return sub_19E08F174(result);
  }
  return result;
}

uint64_t *sub_19E090E48(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      uint64_t v6 = *v5;
      uint64_t *v5 = 0;
      uint64_t v7 = *a3;
      *a3 = v6;
      if (v7) {
        sub_19E08F174(v7);
      }
      ++v5;
      ++a3;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t sub_19E090EAC(uint64_t result)
{
  if (result) {
    return sub_19E08F0D0(result);
  }
  return result;
}

BOOL sub_19E090ECC(uint64_t a1, void *a2)
{
  uint64_t v3 = (unsigned __int16 *)(*a2 + 8);
  uint64_t v4 = *(unsigned __int16 **)(a1 + 32);
  return v3 == v4 || sub_19E0B2428(v3, v4);
}

void sub_19E090EF0(void *a1, const void *a2, size_t a3, void *a4, void *a5)
{
  if (a3 >= 8) {
    __assert_rtn("create_single", "TIDynamicTrie.cpp", 213, "key.size() <= max_key_size()");
  }
  uint64_t v10 = (char *)operator new(((a4[1] + a5[1] - (*a4 + *a5)) & 0xFFFFFFFFFFFFFFF8) + 24);
  unint64_t v11 = v10;
  long long v32 = *(_OWORD *)a4;
  long long v12 = v32;
  uint64_t v33 = a4[2];
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  long long v30 = *(_OWORD *)a5;
  long long v13 = v30;
  uint64_t v31 = a5[2];
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  *(void *)uint64_t v10 = 1;
  v10[15] = a3;
  uint64_t v14 = *((void *)&v12 + 1);
  uint64_t v15 = v12;
  uint64_t v16 = *((void *)&v12 + 1) - v12;
  uint64_t v17 = *((void *)&v13 + 1);
  uint64_t v18 = v13;
  uint64_t v19 = *((void *)&v13 + 1) - v13;
  *((_DWORD *)v10 + 4) = (*((void *)&v12 + 1) - (void)v12) >> 3;
  *((_DWORD *)v10 + 5) = (*((void *)&v13 + 1) - (void)v13) >> 3;
  if (a3) {
    memmove(v10 + 8, a2, a3);
  }
  if (v14 != v15)
  {
    uint64_t v20 = 0;
    do
    {
      uint64_t v21 = *(void *)(v15 + 8 * v20);
      *(void *)(v15 + 8 * v2sub_19E060B80(&a9, 0) = 0;
      *(void *)&v11[8 * v20++ + 24] = v21;
    }
    while (v16 >> 3 > (unint64_t)v20);
  }
  uint64_t v22 = *((unsigned int *)v11 + 4);
  if (v17 == v18)
  {
    int v24 = 0;
  }
  else
  {
    uint64_t v23 = 0;
    int v24 = 0;
    do
    {
      uint64_t v25 = *(void *)(v18 + 8 * v23);
      *(void *)(v18 + 8 * v23) = 0;
      *(void *)&v11[8 * v22 + 24 + 8 * v23] = v25;
      v24 += *(_DWORD *)(v25 + 4);
      *((_DWORD *)v11 + 1) = v24;
      ++v23;
    }
    while (v19 >> 3 > (unint64_t)v23);
  }
  int v26 = 0;
  if (v22)
  {
    uint64_t v27 = (uint64_t *)(v11 + 24);
    uint64_t v28 = 8 * v22;
    do
    {
      uint64_t v29 = *v27++;
      v26 += *(_DWORD *)(v29 + 48);
      v28 -= 8;
    }
    while (v28);
  }
  *((_DWORD *)v11 + 1) = v24 + v26;
  int v34 = (void **)&v30;
  sub_19E0907E0(&v34);
  int v34 = (void **)&v32;
  sub_19E090860(&v34);
  *a1 = v11;
}

void sub_19E0910D4(void *a1)
{
  long long v3 = 0uLL;
  uint64_t v4 = 0;
  uint64_t v2 = 0;
  long long v1 = 0uLL;
  sub_19E09055C(a1, 0, 0, &v3, &v1);
  uint64_t v5 = (void **)&v1;
  sub_19E0907E0(&v5);
  uint64_t v5 = (void **)&v3;
  sub_19E090860(&v5);
}

void sub_19E091144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v14 - 4sub_19E060B80(&a9, 0) = v13;
  sub_19E0907E0((void ***)(v14 - 40));
  *(void *)(v14 - 4sub_19E060B80(&a9, 0) = &a13;
  sub_19E090860((void ***)(v14 - 40));
  _Unwind_Resume(a1);
}

void *sub_19E09116C(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_19E0910D4(a1 + 2);
  return a1;
}

void sub_19E0911AC(_Unwind_Exception *exception_object)
{
  long long v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_19E0616BC(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0911C4(uint64_t result, char *a2, uint64_t a3)
{
  if (*(unsigned __int16 *)a2 <= 0x200u)
  {
    uint64_t v5 = result;
    (*(void (**)(uint64_t *__return_ptr))(**(void **)result + 8))(&v9);
    if ((unsigned __int16)v9 <= 0xEuLL) {
      uint64_t v6 = (char *)&v9 + 2;
    }
    else {
      uint64_t v6 = v10;
    }
    sub_19E08F424(&v8, *(void *)(v5 + 16), a2, a3, (uint64_t)v6, (unsigned __int16)v9);
    uint64_t v7 = v8;
    uint64_t v8 = 0;
    uint64_t result = *(void *)(v5 + 16);
    *(void *)(v5 + 16) = v7;
    if (result)
    {
      sub_19E08F174(result);
      uint64_t result = v8;
      if (v8) {
        uint64_t result = sub_19E08F174(v8);
      }
    }
    if ((unsigned __int16)v9 >= 0xFu)
    {
      uint64_t result = (uint64_t)v10;
      if (v10) {
        return MEMORY[0x19F3BA6E0](v10, 0x1000C8077774924);
      }
    }
  }
  return result;
}

void sub_19E0912B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, unsigned __int16 a11, uint64_t a12)
{
  if (a11 >= 0xFu)
  {
    if (a12) {
      MEMORY[0x19F3BA6E0](a12, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E0912F4(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = *(void *)a2;
  if (!*(void *)a2) {
    goto LABEL_20;
  }
  unint64_t v4 = *(unsigned __int8 *)(a2 + 8) + 1;
  if (v4 < *(unsigned __int8 *)(v3 + 15))
  {
    if (*(unsigned __int8 *)(v3 + v4 + 8) == a3)
    {
      uint64_t v16 = *(void *)a2;
      if ((int)atomic_fetch_add((atomic_uint *volatile)v3, 1u) > 0)
      {
        sub_19E091498(result, &v16, *(unsigned char *)(a2 + 8) + 1);
        uint64_t result = v16;
        if (v16) {
          return sub_19E08F174(v16);
        }
        return result;
      }
LABEL_22:
      __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
    }
LABEL_20:
    *(void *)uint64_t result = 0;
    *(unsigned char *)(result + ++**(_DWORD **)(result + 8) = 0;
    return result;
  }
  unint64_t v5 = *(unsigned int *)(v3 + 20);
  uint64_t v6 = v3 + 8 * *(unsigned int *)(v3 + 16) + 24;
  if (v5)
  {
    uint64_t v7 = v6;
    unint64_t v8 = v5;
    do
    {
      unint64_t v9 = v8 >> 1;
      uint64_t v10 = (uint64_t *)(v7 + 8 * (v8 >> 1));
      uint64_t v12 = *v10;
      unint64_t v11 = v10 + 1;
      v8 += ~(v8 >> 1);
      if (*(unsigned __int8 *)(v12 + 8) < a3) {
        uint64_t v7 = (uint64_t)v11;
      }
      else {
        unint64_t v8 = v9;
      }
    }
    while (v8);
  }
  else
  {
    uint64_t v7 = v6 + 8 * v5;
  }
  unint64_t v13 = (v7 - v6) >> 3;
  if (v13 >= v5) {
    goto LABEL_20;
  }
  uint64_t v14 = *(void *)(v6 + 8 * v13);
  if (*(unsigned __int8 *)(v14 + 8) != a3) {
    goto LABEL_20;
  }
  uint64_t v15 = v14;
  if ((int)atomic_fetch_add((atomic_uint *volatile)v14, 1u) <= 0) {
    goto LABEL_22;
  }
  sub_19E091498(result, &v15, 0);
  uint64_t result = v15;
  if (v15) {
    return sub_19E08F174(v15);
  }
  return result;
}

void sub_19E091440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_19E091464(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_19E08F174(v2);
  }
  return a1;
}

uint64_t sub_19E091498(uint64_t result, uint64_t *a2, unsigned __int8 a3)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  *(void *)uint64_t result = v3;
  *(unsigned char *)(result + ++**(_DWORD **)(result + 8) = a3;
  if (*(unsigned __int8 *)(v3 + 15) <= (unint64_t)a3) {
    __assert_rtn("DynamicTrieCursor", "TIDynamicTrie.h", 211, "m_key_index < m_trie_node->key_size()");
  }
  return result;
}

void sub_19E0914FC(_Unwind_Exception *a1)
{
  sub_19E090B78(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E091510(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_19E08F174(v2);
  }
  return a1;
}

uint64_t sub_19E091544(uint64_t a1)
{
  sub_19E0910D4(&v4);
  uint64_t v2 = v4;
  uint64_t v4 = 0;
  uint64_t result = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v2;
  if (result)
  {
    sub_19E08F174(result);
    uint64_t result = v4;
    if (v4) {
      return sub_19E08F174(v4);
    }
  }
  return result;
}

void sub_19E09159C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E090B78((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0915B0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)result;
  if (*(void *)result)
  {
    if (a2)
    {
      if ((unint64_t)*(unsigned __int8 *)(result + 8) + 1 >= *(unsigned __int8 *)(v2 + 15))
      {
        char v8 = 0;
        uint64_t v4 = *(unsigned int *)(v2 + 16);
        if (v4)
        {
          uint64_t v5 = v2 + 24;
          uint64_t v6 = 8 * v4 - 8;
          do
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(a2 + 16))(a2, v5, &v8);
            v5 += 8;
            if (v8) {
              BOOL v7 = 1;
            }
            else {
              BOOL v7 = v6 == 0;
            }
            v6 -= 8;
          }
          while (!v7);
        }
      }
    }
  }
  return result;
}

uint64_t sub_19E091648(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)result;
  if (!*(void *)result) {
    return result;
  }
  char v13 = 0;
  if ((unint64_t)*(unsigned __int8 *)(result + 8) + 1 >= *(unsigned __int8 *)(v2 + 15))
  {
    uint64_t v4 = *(unsigned int *)(v2 + 20);
    if (!v4) {
      return result;
    }
    uint64_t v5 = (atomic_uint **)(v2 + 8 * *(unsigned int *)(v2 + 16) + 24);
    uint64_t v6 = 8 * v4 - 8;
    while (1)
    {
      BOOL v7 = *v5;
      unint64_t v9 = v7;
      if (v7)
      {
        if ((int)atomic_fetch_add(v7, 1u) <= 0) {
          break;
        }
      }
      sub_19E091498((uint64_t)v10, (uint64_t *)&v9, 0);
      (*(void (**)(uint64_t, uint64_t *, char *))(a2 + 16))(a2, v10, &v13);
      if (v10[0]) {
        sub_19E08F174(v10[0]);
      }
      uint64_t result = (uint64_t)v9;
      if (v9) {
        uint64_t result = sub_19E08F174((uint64_t)v9);
      }
      if (!v13)
      {
        ++v5;
        uint64_t v8 = v6;
        v6 -= 8;
        if (v8) {
          continue;
        }
      }
      return result;
    }
LABEL_19:
    __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
  }
  uint64_t v11 = v2;
  if ((int)atomic_fetch_add((atomic_uint *volatile)v2, 1u) <= 0) {
    goto LABEL_19;
  }
  sub_19E091498((uint64_t)v12, &v11, *(unsigned char *)(result + 8) + 1);
  (*(void (**)(uint64_t, uint64_t *, char *))(a2 + 16))(a2, v12, &v13);
  if (v12[0]) {
    sub_19E08F174(v12[0]);
  }
  uint64_t result = v11;
  if (v11) {
    return sub_19E08F174(v11);
  }
  return result;
}

void sub_19E0917B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  sub_19E091464((uint64_t *)va1);
  sub_19E091510((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0917FC(void *a1, void *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  uint64_t v4 = (unsigned __int16 *)(*a1 + 136);
  uint64_t v5 = (unsigned __int16 *)(*a2 + 136);
  if (!sub_19E0A7134(v4, v5)) {
    return sub_19E0A70C4(v4, v5);
  }
  if (*(void *)(v2 + 112)) {
    uint64_t v6 = *(const char **)(v2 + 112);
  }
  else {
    uint64_t v6 = (const char *)(v2 + 120);
  }
  if (*(void *)(v3 + 112)) {
    BOOL v7 = *(const char **)(v3 + 112);
  }
  else {
    BOOL v7 = (const char *)(v3 + 120);
  }
  unsigned int v8 = strcmp(v6, v7);
  if (v8) {
    return v8 >> 31;
  }
  unint64_t v9 = *(void *)(v2 + 8) ? *(const char **)(v2 + 8) : (const char *)(v2 + 16);
  uint64_t v10 = *(void *)(v3 + 8) ? *(const char **)(v3 + 8) : (const char *)(v3 + 16);
  unsigned int v8 = strcmp(v9, v10);
  if (v8) {
    return v8 >> 31;
  }
  unsigned int v12 = *(_DWORD *)(v2 + 40) - *(_DWORD *)(v3 + 40);
  if (v12) {
    return v12 >> 31;
  }
  else {
    return *(_DWORD *)(v2 + 56) < *(_DWORD *)(v3 + 56);
  }
}

void sub_19E0918D0(uint64_t a1)
{
  uint64_t v451 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (const char *)(a1 + 1912);
  if (*(void *)(a1 + 1904)) {
    uint64_t v4 = *(char **)(a1 + 1904);
  }
  else {
    uint64_t v4 = (char *)(a1 + 1912);
  }
  sub_19E0413C8(&md, v4);
  sub_19E039A88((uint64_t)buf, (long long *)&md, 0);
  if (SHIBYTE(md.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(md.__r_.__value_.__l.__data_);
  }
  *(_OWORD *)&md.__r_.__value_.__l.__data_ = 0uLL;
  if (buf[24]) {
    CC_MD5(v450, len, (unsigned __int8 *)&md);
  }
  *(_OWORD *)a1 = *(_OWORD *)&md.__r_.__value_.__l.__data_;
  sub_19E040984((uint64_t)buf);
  *(_DWORD *)buf = 0x100000;
  *(_WORD *)&uint8_t buf[4] = 0;
  buf[6] = 1;
  *(void *)&uint8_t buf[8] = 0;
  sub_19E03F6F8(buf, (uint64_t)"dat", 0, 3u);
  sub_19E095668((uint64_t)v425, a1, buf);
  if (*(void *)&buf[8] && buf[6] == 1) {
    free(*(void **)&buf[8]);
  }
  *(_DWORD *)buf = 0x100000;
  *(_WORD *)&uint8_t buf[4] = 0;
  buf[6] = 1;
  *(void *)&uint8_t buf[8] = 0;
  sub_19E03F6F8(buf, (uint64_t)"idx", 0, 3u);
  sub_19E095668((uint64_t)v423, a1, buf);
  if (*(void *)&buf[8] && buf[6] == 1) {
    free(*(void **)&buf[8]);
  }
  int v415 = 0;
  int v416 = 0;
  ucol_getVersion();
  ucol_getUCAVersion();
  uint64_t v5 = *(void *)(a1 + 240);
  if ((v5 & 0x40000) != 0) {
    goto LABEL_93;
  }
  if (!*(unsigned char *)(a1 + 1964) && !*(unsigned char *)(a1 + 1965))
  {
    if ((v5 & 0x4000) == 0
      && sub_19E0E66F4((const uint8_t *)&v416, &v415, (char *)a1, (uint64_t)v425)
      && sub_19E0E66F4((const uint8_t *)&v416, &v415, (char *)a1, (uint64_t)v423))
    {
      unsigned __int8 v47 = atomic_load(byte_1E9457268);
      if (v47)
      {
        unsigned __int8 v48 = atomic_load(byte_1E94578A0);
        if (v48)
        {
          v339 = *(const char **)(a1 + 1904);
          if (!v339) {
            v339 = v3;
          }
          uint64_t v340 = *(void *)(a1 + 24);
          if (!v340) {
            uint64_t v340 = a1 + 32;
          }
          printf("Nothing to be done for %s (%s) ", v339, v340);
          putchar(10);
        }
        else
        {
          unsigned int v49 = sub_19E08D084();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v50 = *(const char **)(a1 + 1904);
            if (!v50) {
              uint64_t v50 = v3;
            }
            uint64_t v51 = *(void *)(a1 + 24);
            if (!v51) {
              uint64_t v51 = a1 + 32;
            }
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = v50;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v51;
            _os_log_impl(&dword_19E038000, v49, OS_LOG_TYPE_DEFAULT, "Nothing to be done for %s (%s) ", buf, 0x16u);
          }
        }
      }
      goto LABEL_93;
    }
    unsigned __int8 v52 = atomic_load(byte_1E9457268);
    if (v52)
    {
      unsigned __int8 v53 = atomic_load(byte_1E94578A0);
      if (v53)
      {
        BOOL v57 = *(const char **)(a1 + 1904);
        if (!v57) {
          BOOL v57 = v3;
        }
        BOOL v58 = *(const char **)(a1 + 24);
        if (!v58) {
          BOOL v58 = (const char *)(a1 + 32);
        }
        printf("Compiling %s (%s) ", v57, v58);
        putchar(10);
      }
      else
      {
        uint64_t v54 = sub_19E08D084();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v55 = *(const char **)(a1 + 1904);
          if (!v55) {
            uint64_t v55 = v3;
          }
          uint64_t v56 = *(void *)(a1 + 24);
          if (!v56) {
            uint64_t v56 = a1 + 32;
          }
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = v55;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = v56;
          _os_log_impl(&dword_19E038000, v54, OS_LOG_TYPE_DEFAULT, "Compiling %s (%s) ", buf, 0x16u);
        }
      }
    }
    sub_19E095BF4(a1);
    if ((*(unsigned char *)(a1 + 243) & 2) == 0)
    {
      *(void *)(a1 + 1992) = *(void *)(a1 + 1984);
      *(_OWORD *)&md.__r_.__value_.__r.__words[1] = 0uLL;
      md.__r_.__value_.__r.__words[0] = (std::string::size_type)&md.__r_.__value_.__l.__size_;
      uint64_t v59 = a1 + 1736;
      while (1)
      {
        uint64_t v59 = *(void *)v59;
        if (!v59) {
          break;
        }
        unint64_t v60 = (unsigned __int16 *)(v59 + 16);
        uint64_t v61 = (uint64_t **)sub_19E09D6CC((uint64_t)&md, buf, (unsigned __int16 *)(v59 + 16));
        if (!*v61)
        {
          BOOL v62 = v61;
          unint64_t v63 = (uint64_t *)operator new(0x30uLL);
          unint64_t v64 = v63 + 4;
          unint64_t v65 = *v60;
          if (v65 >= 0xF)
          {
            *unint64_t v64 = v65;
            operator new[]();
          }
          *(_OWORD *)unint64_t v64 = *(_OWORD *)v60;
          uint64_t v66 = *(void *)buf;
          uint64_t *v63 = 0;
          v63[1] = 0;
          v63[2] = v66;
          int *v62 = v63;
          if (*(void *)md.__r_.__value_.__l.__data_)
          {
            md.__r_.__value_.__r.__words[0] = *(void *)md.__r_.__value_.__l.__data_;
            unint64_t v63 = *v62;
          }
          sub_19E05D650((uint64_t *)md.__r_.__value_.__l.__size_, v63);
          ++md.__r_.__value_.__r.__words[2];
        }
      }
      if (*(void *)(a1 + 24)) {
        uint64_t v67 = *(const char **)(a1 + 24);
      }
      else {
        uint64_t v67 = (const char *)(a1 + 32);
      }
      if (!strcmp(v67, "ta"))
      {
        for (uint64_t i = 0; i != 212; i += 4)
        {
          (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 248) + 16))(buf);
          uint64_t v69 = (uint64_t **)sub_19E09D6CC((uint64_t)&md, &__dst, (unsigned __int16 *)buf);
          if (!*v69)
          {
            unint64_t v70 = v69;
            uint64_t v71 = (uint64_t *)operator new(0x30uLL);
            int v72 = v71 + 4;
            if (*(unsigned __int16 *)buf >= 0xFuLL)
            {
              _WORD *v72 = *(_WORD *)buf;
              operator new[]();
            }
            unint64_t size = (unint64_t)v427;
            *(_OWORD *)int v72 = *(_OWORD *)buf;
            std::string::size_type v73 = __dst.__r_.__value_.__r.__words[0];
            uint64_t *v71 = 0;
            v71[1] = 0;
            v71[2] = v73;
            *unint64_t v70 = v71;
            if (*(void *)md.__r_.__value_.__l.__data_)
            {
              md.__r_.__value_.__r.__words[0] = *(void *)md.__r_.__value_.__l.__data_;
              uint64_t v71 = *v70;
            }
            sub_19E05D650((uint64_t *)md.__r_.__value_.__l.__size_, v71);
            ++md.__r_.__value_.__r.__words[2];
          }
          if (*(unsigned __int16 *)buf >= 0xFu && *(void *)&buf[8]) {
            MEMORY[0x19F3BA6E0](*(void *)&buf[8], 0x1000C8077774924);
          }
        }
      }
      v410 = (unint64_t *)(a1 + 2008);
      v411 = &buf[4];
      unsigned int v74 = 1;
      while (1)
      {
        if ((v74 & 0xF800 | 0x400) != 0xDC00)
        {
          (*(void (**)(size_t *__return_ptr))(**(void **)(a1 + 248) + 16))(&__n);
          unsigned int v75 = (unsigned __int16)__n;
          if (v74 < 0x10000)
          {
            if ((_WORD)__n)
            {
LABEL_156:
              unint64_t size = md.__r_.__value_.__l.__size_;
              if (!md.__r_.__value_.__l.__size_) {
                goto LABEL_199;
              }
              uint64_t v76 = (std::string *)&md.__r_.__value_.__r.__words[1];
              do
              {
                uint64_t v77 = v76;
                unint64_t v78 = (unsigned __int16 *)(size + 32);
                int v79 = sub_19E0A70C4((unsigned __int16 *)(size + 32), (unsigned __int16 *)&__n);
                if (v79) {
                  uint64_t v80 = (unint64_t *)(size + 8);
                }
                else {
                  uint64_t v80 = (unint64_t *)size;
                }
                if (v79) {
                  uint64_t v76 = v77;
                }
                else {
                  uint64_t v76 = (std::string *)size;
                }
                unint64_t size = *v80;
              }
              while (*v80);
              if (v76 == (std::string *)&md.__r_.__value_.__r.__words[1]
                || (!v79 ? (uint64_t v81 = v78) : (uint64_t v81 = (unsigned __int16 *)&v77[1].__r_.__value_.__r.__words[1]),
                    (sub_19E0A70C4((unsigned __int16 *)&__n, v81) & 1) != 0))
              {
LABEL_199:
                if ((unsigned __int16)__n >= 0xFu && *(void *)v437) {
                  MEMORY[0x19F3BA6E0](*(void *)v437, 0x1000C8077774924);
                }
                goto LABEL_150;
              }
              uint64_t v88 = *(unsigned char **)v437;
              if (v75 <= 0xE) {
                uint64_t v88 = (char *)&__n + 2;
              }
              if (*v88 == 2)
              {
                exception = __cxa_allocate_exception(0x20uLL);
                sub_19E0413C8(buf, "Sort key top byte collides with 0x02!!");
                sub_19E08DA70(exception, (long long *)buf);
                __cxa_throw(exception, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
              }
              if (v75 >= 5)
              {
                unsigned __int8 v89 = atomic_load(byte_1E9457268);
                if (v89)
                {
                  unsigned __int8 v90 = atomic_load(byte_1E94578A0);
                  if (v90)
                  {
                    sub_19E0A7188((uint64_t)buf, (unsigned __int16 *)&__n, v82, v83, v84, v85, v86, v87);
                    unint64_t v112 = *(const char **)&buf[8];
                    if (!*(void *)&buf[8]) {
                      unint64_t v112 = (const char *)&buf[16];
                    }
                    printf("U+%04X: long sort key : %s", v74, v112);
                    if (*(void *)&buf[8] && buf[6] == 1) {
                      free(*(void **)&buf[8]);
                    }
                    putchar(10);
                  }
                  else
                  {
                    uint64_t v91 = sub_19E08D084();
                    if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
                    {
                      sub_19E0A7188((uint64_t)buf, (unsigned __int16 *)&__n, v92, v93, v94, v95, v96, v97);
                      unsigned int v98 = *(uint8_t **)&buf[8];
                      if (!*(void *)&buf[8]) {
                        unsigned int v98 = &buf[16];
                      }
                      LODWORD(__dst.__r_.__value_.__l.__data_) = 67109378;
                      HIDWORD(__dst.__r_.__value_.__r.__words[0]) = v74;
                      LOWORD(__dst.__r_.__value_.__r.__words[1]) = 2080;
                      *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v98;
                      _os_log_impl(&dword_19E038000, v91, OS_LOG_TYPE_DEFAULT, "U+%04X: long sort key : %s", (uint8_t *)&__dst, 0x12u);
                      if (*(void *)&buf[8] && buf[6] == 1) {
                        free(*(void **)&buf[8]);
                      }
                    }
                  }
                }
                uint64_t v113 = *(void *)(a1 + 2008);
                uint64_t v114 = *(void *)(a1 + 2016) - v113;
                unsigned __int8 v115 = atomic_load(byte_1E9457268);
                if (v115)
                {
                  unsigned __int8 v116 = atomic_load(byte_1E94578A0);
                  if (v116)
                  {
                    printf(" offset=%X", *(_DWORD *)(a1 + 2016) - v113);
                    putchar(10);
                  }
                  else
                  {
                    uint64_t v117 = sub_19E08D084();
                    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 67109120;
                      *(_DWORD *)&uint8_t buf[4] = v114;
                      _os_log_impl(&dword_19E038000, v117, OS_LOG_TYPE_DEFAULT, " offset=%X", buf, 8u);
                    }
                  }
                }
                uint64_t v118 = v74 | 0x1000000;
                uint64_t v119 = *(uint64_t **)(a1 + 1992);
                unint64_t v120 = *(void *)(a1 + 2000);
                if ((unint64_t)v119 >= v120)
                {
                  uint64_t v122 = *(void *)(a1 + 1984);
                  uint64_t v123 = ((uint64_t)v119 - v122) >> 3;
                  if ((unint64_t)(v123 + 1) >> 61) {
                    sub_19E041BEC();
                  }
                  uint64_t v124 = v120 - v122;
                  uint64_t v125 = v124 >> 2;
                  if (v124 >> 2 <= (unint64_t)(v123 + 1)) {
                    uint64_t v125 = v123 + 1;
                  }
                  if ((unint64_t)v124 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v126 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v126 = v125;
                  }
                  if (v126) {
                    unint64_t v126 = (unint64_t)sub_19E060B48(v126);
                  }
                  else {
                    uint64_t v127 = 0;
                  }
                  v128 = (uint64_t *)(v126 + 8 * v123);
                  uint64_t *v128 = v118 | (v114 << 32);
                  long long v121 = v128 + 1;
                  long long v129 = *(char **)(a1 + 1992);
                  v130 = *(char **)(a1 + 1984);
                  if (v129 != v130)
                  {
                    do
                    {
                      uint64_t v131 = *((void *)v129 - 1);
                      v129 -= 8;
                      *--v128 = v131;
                    }
                    while (v129 != v130);
                    long long v129 = *(char **)(a1 + 1984);
                  }
                  *(void *)(a1 + 1984) = v128;
                  *(void *)(a1 + 1992) = v121;
                  *(void *)(a1 + 200sub_19E060B80(&a9, 0) = v126 + 8 * v127;
                  if (v129) {
                    operator delete(v129);
                  }
                }
                else
                {
                  *uint64_t v119 = v118 | (v114 << 32);
                  long long v121 = v119 + 1;
                }
                *(void *)(a1 + 1992) = v121;
                size_t v132 = (unsigned __int16)__n;
                if ((unsigned __int16)__n <= 0xEu) {
                  long long v133 = (char *)&__n + 2;
                }
                else {
                  long long v133 = *(char **)v437;
                }
                if ((_WORD)__n)
                {
                  uint64_t v134 = *(char **)(a1 + 2016);
                  uint64_t v135 = *(void *)(a1 + 2024);
                  if (v135 - (uint64_t)v134 >= (unsigned __int16)__n)
                  {
                    uint64_t v142 = (unsigned __int16)__n;
                    memmove(*(void **)(a1 + 2016), v133, (unsigned __int16)__n);
                    *(void *)(a1 + 2016) = &v134[v142];
                  }
                  else
                  {
                    char __src = v133;
                    uint64_t v136 = *(char **)(a1 + 2008);
                    long long v137 = (char *)(v134 - v136);
                    uint64_t v138 = v134 - v136 + (unsigned __int16)__n;
                    if (v138 < 0) {
                      sub_19E041BEC();
                    }
                    unint64_t v139 = v135 - (void)v136;
                    if (2 * v139 > v138) {
                      uint64_t v138 = 2 * v139;
                    }
                    if (v139 >= 0x3FFFFFFFFFFFFFFFLL) {
                      size_t v140 = 0x7FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      size_t v140 = v138;
                    }
                    size_t v408 = v140;
                    if (v140) {
                      long long v141 = (char *)operator new(v140);
                    }
                    else {
                      long long v141 = 0;
                    }
                    long long v143 = &v137[(void)v141];
                    memcpy(&v137[(void)v141], __src, v132);
                    if (v136 == v134)
                    {
                      uint64_t v144 = v134;
                      v145 = &v137[(void)v141];
                    }
                    else
                    {
                      do
                      {
                        v137[(void)v141 - 1] = v137[(void)(v136 - 1)];
                        --v137;
                      }
                      while (v137);
                      uint64_t v144 = *(unsigned char **)(a1 + 2016);
                      v145 = v141;
                    }
                    long long v146 = &v143[v132];
                    uint64_t v147 = v144 - v134;
                    if (v144 != v134) {
                      memmove(v146, v134, v144 - v134);
                    }
                    long long v148 = *(void **)(a1 + 2008);
                    *(void *)(a1 + 200++**(_DWORD **)(result + 8) = v145;
                    *(void *)(a1 + 2016) = &v146[v147];
                    *(void *)(a1 + 2024) = &v141[v408];
                    if (v148) {
                      operator delete(v148);
                    }
                  }
                }
                unint64_t size = *(void *)(a1 + 2016);
                unint64_t v149 = *(void *)(a1 + 2024);
                if (size >= v149)
                {
                  unint64_t v151 = *v410;
                  unint64_t v152 = size - *v410;
                  unint64_t v153 = v152 + 1;
                  if ((uint64_t)(v152 + 1) < 0) {
                    sub_19E041BEC();
                  }
                  unint64_t v154 = v149 - v151;
                  if (2 * v154 > v153) {
                    unint64_t v153 = 2 * v154;
                  }
                  if (v154 >= 0x3FFFFFFFFFFFFFFFLL) {
                    size_t v155 = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    size_t v155 = v153;
                  }
                  if (v155) {
                    long long v156 = (char *)operator new(v155);
                  }
                  else {
                    long long v156 = 0;
                  }
                  uint64_t v157 = &v156[v152];
                  uint64_t v158 = &v156[v152];
                  *uint64_t v158 = 0;
                  uint64_t v150 = v158 + 1;
                  if (size != v151)
                  {
                    unint64_t v159 = ~v151 + size;
                    do
                    {
                      char v160 = *(unsigned char *)--size;
                      v156[v159--] = v160;
                    }
                    while (size != v151);
                    unint64_t size = *v410;
                    uint64_t v157 = v156;
                  }
                  *(void *)(a1 + 200++**(_DWORD **)(result + 8) = v157;
                  *(void *)(a1 + 2016) = v150;
                  *(void *)(a1 + 2024) = &v156[v155];
                  if (size) {
                    operator delete((void *)size);
                  }
                }
                else
                {
                  *(unsigned char *)size++ = 0;
                  uint64_t v150 = (unsigned char *)size;
                }
                *(void *)(a1 + 2016) = v150;
                goto LABEL_199;
              }
            }
            *(_DWORD *)buf = v74;
            *(_DWORD *)&uint8_t buf[4] = 0;
            strncpy((char *)&buf[4], (const char *)&__n + 2, v75);
            uint64_t v99 = *(void **)(a1 + 1992);
            unint64_t v100 = *(void *)(a1 + 2000);
            if ((unint64_t)v99 >= v100)
            {
              uint64_t v102 = *(void *)(a1 + 1984);
              uint64_t v103 = ((uint64_t)v99 - v102) >> 3;
              if ((unint64_t)(v103 + 1) >> 61) {
                sub_19E041BEC();
              }
              uint64_t v104 = v100 - v102;
              uint64_t v105 = v104 >> 2;
              if (v104 >> 2 <= (unint64_t)(v103 + 1)) {
                uint64_t v105 = v103 + 1;
              }
              if ((unint64_t)v104 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v106 = v105;
              }
              if (v106) {
                unint64_t v106 = (unint64_t)sub_19E060B48(v106);
              }
              else {
                uint64_t v107 = 0;
              }
              __int16 v108 = (void *)(v106 + 8 * v103);
              *__int16 v108 = *(void *)buf;
              unint64_t v101 = v108 + 1;
              unsigned __int8 v109 = *(char **)(a1 + 1992);
              uint64_t v110 = *(char **)(a1 + 1984);
              if (v109 != v110)
              {
                do
                {
                  uint64_t v111 = *((void *)v109 - 1);
                  v109 -= 8;
                  *--__int16 v108 = v111;
                }
                while (v109 != v110);
                unsigned __int8 v109 = *(char **)(a1 + 1984);
              }
              *(void *)(a1 + 1984) = v108;
              *(void *)(a1 + 1992) = v101;
              *(void *)(a1 + 200sub_19E060B80(&a9, 0) = v106 + 8 * v107;
              if (v109) {
                operator delete(v109);
              }
            }
            else
            {
              *uint64_t v99 = *(void *)buf;
              unint64_t v101 = v99 + 1;
            }
            *(void *)(a1 + 1992) = v101;
            goto LABEL_199;
          }
          if ((_WORD)__n) {
            goto LABEL_156;
          }
        }
LABEL_150:
        if (++v74 == 196608)
        {
          sub_19E09D658((void *)md.__r_.__value_.__l.__size_);
          uint64_t v161 = *(void *)(a1 + 1984);
          uint64_t v162 = (*(void *)(a1 + 1992) - v161) >> 3;
          long long v163 = *(void (**)(uint64_t))(a1 + 2008);
          v164 = (char *)(*(void *)(a1 + 2016) - (void)v163);
          *(void *)buf = &unk_1EF099DA8;
          *(void *)&uint8_t buf[8] = a1 + 328;
          *(void *)&uint8_t buf[16] = v161;
          *(void *)&buf[24] = v162;
          v445 = v163;
          v446 = v164;
          uint64_t v165 = *(uint64_t ***)(a1 + 280);
          uint64_t v167 = *v165;
          long long v166 = v165[1];
          while (v167 != v166)
          {
            uint64_t v168 = *v167;
            (*(void (**)(std::string *__return_ptr, uint8_t *, uint64_t))(*(void *)buf + 8))(&md, buf, *v167 + 104);
            BOOL v169 = sub_19E0A7134((unsigned __int16 *)&md, (unsigned __int16 *)(v168 + 136));
            if (LOWORD(md.__r_.__value_.__l.__data_) >= 0xFu && md.__r_.__value_.__l.__size_) {
              MEMORY[0x19F3BA6E0](md.__r_.__value_.__l.__size_, 0x1000C8077774924);
            }
            if (!v169)
            {
              uint64_t v341 = *v167;
              uint64_t v342 = *(void *)(*v167 + 112);
              uint64_t v343 = *v167 + 120;
              if (!v342) {
                uint64_t v342 = *v167 + 120;
              }
              v431.n128_u64[0] = v342;
              unsigned __int32 v344 = *(unsigned __int16 *)(v341 + 104);
              v431.n128_u32[2] = 0;
              v431.n128_u32[3] = v344;
              v432[0] = 0;
              sub_19E03E768((uint64_t *)&v431);
              int v345 = *(unsigned __int16 *)(v341 + 104);
              uint64_t v346 = *(void *)(v341 + 112);
              if (!v346) {
                uint64_t v346 = v343;
              }
              *(void *)v427 = v346;
              *(_DWORD *)&v427[8] = v345;
              *(_DWORD *)v428 = v345;
              *(_DWORD *)&v428[4] = 0;
              sub_19E03E768((uint64_t *)v427);
              while (v431.n128_u64[0] == *(void *)v427)
              {
                if (v431.n128_u32[2] == *(_DWORD *)&v427[8])
                {
                  unsigned __int8 v395 = atomic_load(byte_1E9457268);
                  if (v395)
                  {
                    unsigned __int8 v398 = atomic_load(byte_1E94578A0);
                    if (v398)
                    {
                      sub_19E0A7188((uint64_t)&md, (unsigned __int16 *)(*v167 + 136), v347, v348, v349, v350, v351, v352);
                      v407 = (const char *)md.__r_.__value_.__l.__size_;
                      if (!md.__r_.__value_.__l.__size_) {
                        v407 = &md.__r_.__value_.__s.__data_[16];
                      }
                      printf("  ICU collator's original sort key: %s", v407);
                      if (md.__r_.__value_.__l.__size_ && md.__r_.__value_.__s.__data_[6] == 1) {
                        free((void *)md.__r_.__value_.__l.__size_);
                      }
                      putchar(10);
                    }
                    else
                    {
                      v399 = sub_19E08D084();
                      if (os_log_type_enabled(v399, OS_LOG_TYPE_DEFAULT))
                      {
                        sub_19E0A7188((uint64_t)&md, (unsigned __int16 *)(*v167 + 136), v400, v401, v402, v403, v404, v405);
                        v406 = (std::string::value_type *)md.__r_.__value_.__l.__size_;
                        if (!md.__r_.__value_.__l.__size_) {
                          v406 = &md.__r_.__value_.__s.__data_[16];
                        }
                        LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
                        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v406;
                        _os_log_impl(&dword_19E038000, v399, OS_LOG_TYPE_DEFAULT, "  ICU collator's original sort key: %s", (uint8_t *)&__dst, 0xCu);
                        if (md.__r_.__value_.__l.__size_ && md.__r_.__value_.__s.__data_[6] == 1) {
                          free((void *)md.__r_.__value_.__l.__size_);
                        }
                      }
                    }
                  }
                  v396 = __cxa_allocate_exception(0x20uLL);
                  if (*(void *)(*v167 + 112)) {
                    v397 = *(char **)(*v167 + 112);
                  }
                  else {
                    v397 = (char *)(*v167 + 120);
                  }
                  sub_19E0413C8(&__dst, v397);
                  sub_19E09D5F4(&md, "sort key not matching for ", &__dst);
                  sub_19E08DA70(v396, (long long *)&md);
                  __cxa_throw(v396, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
                }
                unsigned int v353 = v432[0];
                sub_19E03E980(buf, v432[0], &v418);
                (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 248) + 16))(&v421);
                unsigned __int8 v360 = atomic_load(byte_1E9457268);
                if (v360)
                {
                  unsigned __int8 v361 = atomic_load(byte_1E94578A0);
                  if (v361)
                  {
                    sub_19E0A7188((uint64_t)&md, (unsigned __int16 *)&v418, v354, v355, v356, v357, v358, v359);
                    std::string::size_type v378 = md.__r_.__value_.__l.__size_;
                    sub_19E0A7188((uint64_t)&__dst, (unsigned __int16 *)&v421, v379, v380, v381, v382, v383, v384);
                    if (v378) {
                      v385 = (const char *)v378;
                    }
                    else {
                      v385 = &md.__r_.__value_.__s.__data_[16];
                    }
                    v386 = (const char *)__dst.__r_.__value_.__l.__size_;
                    if (!__dst.__r_.__value_.__l.__size_) {
                      v386 = &__dst.__r_.__value_.__s.__data_[16];
                    }
                    printf("  Sort key mapping: U+%04X -> %s : %s", v353, v385, v386);
                    if (__dst.__r_.__value_.__l.__size_ && __dst.__r_.__value_.__s.__data_[6] == 1) {
                      free((void *)__dst.__r_.__value_.__l.__size_);
                    }
                    if (md.__r_.__value_.__l.__size_ && md.__r_.__value_.__s.__data_[6] == 1) {
                      free((void *)md.__r_.__value_.__l.__size_);
                    }
                    putchar(10);
                  }
                  else
                  {
                    v362 = sub_19E08D084();
                    if (os_log_type_enabled(v362, OS_LOG_TYPE_DEFAULT))
                    {
                      sub_19E0A7188((uint64_t)&md, (unsigned __int16 *)&v418, v363, v364, v365, v366, v367, v368);
                      std::string::size_type v369 = md.__r_.__value_.__l.__size_;
                      sub_19E0A7188((uint64_t)&__dst, (unsigned __int16 *)&v421, v370, v371, v372, v373, v374, v375);
                      v376 = (std::string::value_type *)__dst.__r_.__value_.__l.__size_;
                      if (v369) {
                        v377 = (std::string::value_type *)v369;
                      }
                      else {
                        v377 = &md.__r_.__value_.__s.__data_[16];
                      }
                      LODWORD(__n) = 67109634;
                      if (!__dst.__r_.__value_.__l.__size_) {
                        v376 = &__dst.__r_.__value_.__s.__data_[16];
                      }
                      HIDWORD(__n) = v353;
                      *(_WORD *)v437 = 2080;
                      *(void *)&v437[2] = v377;
                      __int16 v438 = 2080;
                      v439 = v376;
                      _os_log_impl(&dword_19E038000, v362, OS_LOG_TYPE_DEFAULT, "  Sort key mapping: U+%04X -> %s : %s", (uint8_t *)&__n, 0x1Cu);
                      if (__dst.__r_.__value_.__l.__size_ && __dst.__r_.__value_.__s.__data_[6] == 1) {
                        free((void *)__dst.__r_.__value_.__l.__size_);
                      }
                      if (md.__r_.__value_.__l.__size_ && md.__r_.__value_.__s.__data_[6] == 1) {
                        free((void *)md.__r_.__value_.__l.__size_);
                      }
                    }
                  }
                }
                if ((unsigned __int16)v421 >= 0xFu && v422) {
                  MEMORY[0x19F3BA6E0](v422, 0x1000C8077774924);
                }
                if ((unsigned __int16)v418 >= 0xFu && v419) {
                  MEMORY[0x19F3BA6E0](v419, 0x1000C8077774924);
                }
                sub_19E03E768((uint64_t *)&v431);
              }
              __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
            }
            ++v167;
          }
          break;
        }
      }
    }
    uint64_t v170 = *(uint64_t **)(a1 + 280);
    uint64_t v171 = *v170;
    uint64_t v172 = (uint64_t *)v170[1];
    unint64_t v173 = 126 - 2 * __clz(((uint64_t)v172 - *v170) >> 3);
    *(void *)buf = sub_19E0917FC;
    if (v172 == (uint64_t *)v171) {
      uint64_t v174 = 0;
    }
    else {
      uint64_t v174 = v173;
    }
    sub_19E09C724(v171, v172, (uint64_t (**)(uint64_t *, uint64_t *))buf, v174, 1);
    uint64_t v180 = **(void **)(a1 + 280);
    if (*(void *)(*(void *)(a1 + 280) + 8) != v180)
    {
      unint64_t v181 = 0;
      unsigned int v182 = 1;
      do
      {
        sub_19E0F2014(*(void *)(a1 + 272), *(void *)(v180 + 8 * v181), 0, v175, v176, v177, v178, v179);
        unint64_t v181 = v182;
        uint64_t v180 = **(void **)(a1 + 280);
        ++v182;
      }
      while (v181 < (*(void *)(*(void *)(a1 + 280) + 8) - v180) >> 3);
    }
    unsigned __int8 v183 = atomic_load(byte_1E9457268);
    if (v183)
    {
      unsigned __int8 v184 = atomic_load(byte_1E94578A0);
      if (v184)
      {
        printf("\tInserted %d trie nodes.", dword_1E9457878);
        putchar(10);
      }
      else
      {
        uint64_t v185 = sub_19E08D084();
        if (os_log_type_enabled(v185, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = dword_1E9457878;
          _os_log_impl(&dword_19E038000, v185, OS_LOG_TYPE_DEFAULT, "\tInserted %d trie nodes.", buf, 8u);
        }
      }
    }
    if (*(unsigned char *)(a1 + 240))
    {
      int v186 = sub_19E0F2F20(*(void *)(a1 + 272));
      unsigned __int8 v187 = atomic_load(byte_1E9457268);
      if (v187)
      {
        int v188 = v186;
        unsigned __int8 v189 = atomic_load(byte_1E94578A0);
        if (v189)
        {
          printf("\tCondensed %d nodes into patricia nodes.", v186);
          putchar(10);
        }
        else
        {
          uint64_t v190 = sub_19E08D084();
          if (os_log_type_enabled(v190, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v188;
            _os_log_impl(&dword_19E038000, v190, OS_LOG_TYPE_DEFAULT, "\tCondensed %d nodes into patricia nodes.", buf, 8u);
          }
        }
      }
    }
    *(_DWORD *)buf = 0x100000;
    *(_WORD *)&uint8_t buf[4] = 0;
    buf[6] = 1;
    *(void *)&uint8_t buf[8] = 0;
    sub_19E03F6F8(buf, (uint64_t)"dat", 0, 3u);
    sub_19E095668((uint64_t)&__n, a1, buf);
    if (*(void *)&buf[8] && buf[6] == 1) {
      free(*(void **)&buf[8]);
    }
    unsigned __int8 v191 = atomic_load(byte_1E9457268);
    if (v191)
    {
      unsigned __int8 v192 = atomic_load(byte_1E94578A0);
      if (v192)
      {
        v195 = *(const char **)v437;
        if (!*(void *)v437) {
          v195 = &v437[8];
        }
        printf("writing: %s", v195);
        putchar(10);
      }
      else
      {
        uint64_t v193 = sub_19E08D084();
        if (os_log_type_enabled(v193, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v194 = *(unsigned char **)v437;
          if (!*(void *)v437) {
            unint64_t v194 = &v437[8];
          }
          *(_DWORD *)buf = 136315138;
          *(void *)&uint8_t buf[4] = v194;
          _os_log_impl(&dword_19E038000, v193, OS_LOG_TYPE_DEFAULT, "writing: %s", buf, 0xCu);
        }
      }
    }
    uint64_t v196 = &v437[8];
    if (*(void *)v437) {
      uint64_t v197 = *(char **)v437;
    }
    else {
      uint64_t v197 = &v437[8];
    }
    sub_19E0F17CC(&md, v197);
    if (!v434)
    {
      sub_19E0538DC((uint64_t)buf);
      v387 = sub_19E0416F8(&buf[16], (uint64_t)"Failed to open data file at ", 28);
      if (*(void *)v437) {
        uint64_t v196 = *(const char **)v437;
      }
      size_t v388 = strlen(v196);
      v389 = sub_19E0416F8(v387, (uint64_t)v196, v388);
      sub_19E0416F8(v389, (uint64_t)" (errno=", 8);
      v390 = (void *)std::ostream::operator<<();
      sub_19E0416F8(v390, (uint64_t)")", 1);
      v391 = __cxa_allocate_exception(0x20uLL);
      sub_19E05EEA4(&__dst, (uint64_t)&buf[24]);
      sub_19E08DA70(v391, (long long *)&__dst);
      __cxa_throw(v391, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
    }
    sub_19E09BB14(a1, (ssize_t)&md, 0);
    v198 = *(uint64_t **)(a1 + 280);
    uint64_t v199 = *v198;
    uint64_t v200 = v198[1] - *v198;
    if (v200)
    {
      unint64_t v201 = 0;
      unsigned int v202 = 0;
      unint64_t v203 = v200 >> 3;
      uint64_t v414 = a1 + 328;
      uint64_t v412 = a1 + 1776;
      do
      {
        unint64_t size = v201;
        unsigned int v204 = v202 + 1;
        do
        {
          unsigned int v202 = v204;
          unint64_t v201 = v204;
          if (v203 <= v204) {
            break;
          }
          ++v204;
        }
        while (*(unsigned char *)(*(void *)(v199 + 8 * v201) + 304));
        int v205 = *(unsigned __int16 **)(v199 + 8 * size);
        if (*((unsigned char *)v205 + 304)) {
          goto LABEL_446;
        }
        uint64_t v206 = *((void *)v205 + 41);
        if ((v206 & 0x20) == 0) {
          goto LABEL_341;
        }
        if ((v206 & 0x100) != 0 && (*((_DWORD *)v205 + 15) > 0x3FFEu || *(_DWORD *)(a1 + 1960) != 5)) {
          goto LABEL_341;
        }
        if ((v206 & 0x200000) != 0 && *((_DWORD *)v205 + 19) || *((_DWORD *)v205 + 16) != -1) {
          goto LABEL_341;
        }
        uint64_t v208 = (atomic_uint *)*((void *)v205 + 28);
        if (v208)
        {
          if ((int)atomic_fetch_add(v208, 1u) <= 0) {
            __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
          }
          uint64_t v209 = *((void *)v205 + 28);
          if ((int)atomic_fetch_add((atomic_uint *volatile)v209, 1u) < 1) {
            __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
          }
          v411 = (uint8_t *)v209;
          v210 = *(void **)(v209 + 32);
          if (v210)
          {
            if (((v210[1] - *v210) & 0x7FFFFFFF0) != 0)
            {
              LOBYTE(v211) = 1;
              uint64_t v212 = v209;
LABEL_337:
              v411 = (uint8_t *)v212;
              sub_19E076C68(v212);
              sub_19E076C68((uint64_t)v208);
              v198 = *(uint64_t **)(a1 + 280);
              if (v211) {
                goto LABEL_340;
              }
              goto LABEL_446;
            }
          }
        }
        if ((*((_DWORD *)v205 + 9) & 1) != 0
          || *(void *)(v205 + 18)
          || *((_DWORD *)v205 + 14)
          || *((void *)v205 + 25) == *((void *)v205 + 26)
          || !*(_DWORD *)(a1 + 1648))
        {
          goto LABEL_334;
        }
        LODWORD(__dst.__r_.__value_.__l.__data_) = 0x100000;
        WORD2(__dst.__r_.__value_.__r.__words[0]) = 0;
        __dst.__r_.__value_.__s.__data_[6] = 0;
        __dst.__r_.__value_.__l.__size_ = 0;
        __dst.__r_.__value_.__s.__data_[16] = 0;
        sub_19E039858((uint64_t)buf, v205);
        unsigned int v267 = 0;
        LODWORD(v445) = 0;
        while (1)
        {
          unsigned int v268 = *(unsigned __int16 *)&buf[4];
          if (!*(_WORD *)&buf[4])
          {
            sub_19E0398F4((unsigned __int16 *)buf);
            unsigned int v268 = *(unsigned __int16 *)&buf[4];
          }
          if (v267 >= v268)
          {
            BOOL v271 = sub_19E0B2428((unsigned __int16 *)&__dst, v205);
            goto LABEL_467;
          }
          uint64_t v269 = sub_19E0DE8C0((uint64_t)buf);
          sub_19E08D1E0(&v431, v414, v269);
          unsigned int v270 = sub_19E0EFBE0(v414, (unsigned __int16 *)&v431);
          if (sub_19E0D35FC(v414, (unsigned __int16 *)&v431)) {
            break;
          }
          if (v270) {
            sub_19E0B14D0((unsigned __int16 *)&__dst, v270);
          }
          if (v431.n128_u16[0] >= 0xFu && v431.n128_u64[1]) {
            MEMORY[0x19F3BA6E0](v431.n128_u64[1], 0x1000C8077774924);
          }
          unsigned int v267 = WORD1(v445);
        }
        if (v431.n128_u16[0] >= 0xFu && v431.n128_u64[1]) {
          MEMORY[0x19F3BA6E0](v431.n128_u64[1], 0x1000C8077774924);
        }
        BOOL v271 = 0;
LABEL_467:
        if (*(void *)&buf[8] && buf[6] == 1) {
          free(*(void **)&buf[8]);
        }
        if (__dst.__r_.__value_.__l.__size_ && __dst.__r_.__value_.__s.__data_[6] == 1) {
          free((void *)__dst.__r_.__value_.__l.__size_);
        }
        if (!v271)
        {
LABEL_334:
          if (!v208)
          {
            v198 = *(uint64_t **)(a1 + 280);
LABEL_340:
            int v205 = *(unsigned __int16 **)(v199 + 8 * size);
            uint64_t v199 = *v198;
LABEL_341:
            if (v201 < (v198[1] - v199) >> 3 && (uint64_t v213 = *((void *)v205 + 29)) != 0)
            {
              uint64_t v215 = *(void **)v213;
              unint64_t v214 = *(void **)(v213 + 8);
              if (v215 != v214)
              {
                do
                {
                  if (*v215 == *(void *)(v199 + 8 * v201)) {
                    goto LABEL_347;
                  }
                  ++v215;
                }
                while (v215 != v214);
                uint64_t v215 = v214;
              }
LABEL_347:
              BOOL v216 = v215 != v214;
            }
            else
            {
              BOOL v216 = 0;
            }
            uint64_t v217 = *(void *)(a1 + 264);
            *((_DWORD *)v205 + 62) = sub_19E0F1A04(v435);
            double v218 = *((double *)v205 + 11);
            double v219 = 0.0;
            if (v218 != 0.0)
            {
              uint64_t v220 = *((void *)v205 + 28);
              if (v220)
              {
                double v221 = *(double *)(v220 + 40);
                goto LABEL_354;
              }
              int v222 = *((_DWORD *)v205 + 84);
              if (v222)
              {
                double v221 = (double)v222;
LABEL_354:
                double v219 = v218 / v221;
              }
              else
              {
                double v219 = 1.0;
              }
            }
            if (*((_DWORD *)v205 + 10) == 1) {
              *((_DWORD *)v205 + 9) |= 1u;
            }
            v418 = 0;
            v419 = 0;
            uint64_t v420 = 0;
            int v417 = 0;
            if ((v205[164] & 0x20) == 0 || !sub_19E0EFC28((uint64_t)v205, v414, (uint64_t *)&v418, &v417)) {
              goto LABEL_367;
            }
            uint64_t v223 = v418;
            unsigned int v224 = 0;
            if (v419 != v418)
            {
              unsigned int v225 = 1;
              do
              {
                int v226 = *v223;
                v223 += 20;
                v224 += v226 + 2;
                BOOL v33 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v419 - (char *)v418) >> 3) > v225++;
              }
              while (v33);
            }
            unsigned int v227 = (v205[164] & 8) != 0 ? sub_19E08C3E8(v412, v205) : *v205 + 1;
            if (v224 < v227)
            {
              int v228 = 0;
              BOOL v229 = v418 != v419;
            }
            else
            {
LABEL_367:
              BOOL v229 = 0;
              int v228 = 1;
            }
            unint64_t size = sub_19E0F1A04(v435);
            __dst.__r_.__value_.__s.__data_[0] = 0;
            sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 1);
            v230 = (void *)*((void *)v205 + 29);
            if (v230)
            {
              unint64_t v231 = v230[1] - *v230;
              if (v216) {
                char v232 = -126;
              }
              else {
                char v232 = 2;
              }
              if (v231 <= 8) {
                char v233 = 0;
              }
              else {
                char v233 = v232;
              }
            }
            else
            {
              char v233 = 0;
            }
            int v234 = (*(uint64_t (**)(uint64_t, void))(*(void *)v217 + 40))(v217, *((unsigned int *)v205 + 9));
            char v235 = v233 | 4;
            if (v219 >= 1.0) {
              char v235 = v233;
            }
            if (v234) {
              v235 |= 0x20u;
            }
            std::string::value_type v236 = v235 | (*((_DWORD *)v205 + 10) > 1u);
            if (*((_DWORD *)v205 + 14)) {
              v236 |= 0x40u;
            }
            if (v229) {
              v236 |= 8u;
            }
            if (v228) {
              std::string::value_type v237 = v236 | 0x10;
            }
            else {
              std::string::value_type v237 = v236;
            }
            __dst.__r_.__value_.__s.__data_[0] = v237;
            sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 1);
            *((unsigned char *)v205 + 44) = v237;
            if (v219 < 1.0)
            {
              unsigned int v238 = (sqrt(v219) * 255.0);
              if (v238 >= 0xFF) {
                char v239 = -1;
              }
              else {
                char v239 = v238;
              }
              if (v238) {
                BOOL v240 = 1;
              }
              else {
                BOOL v240 = v219 <= 0.0;
              }
              if (v240) {
                std::string::value_type v241 = v239;
              }
              else {
                std::string::value_type v241 = 1;
              }
              __dst.__r_.__value_.__s.__data_[0] = v241;
              sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 1);
            }
            int v242 = (*(uint64_t (**)(uint64_t, void))(*(void *)v217 + 40))(v217, *((unsigned int *)v205 + 9));
            if (v242)
            {
              __dst.__r_.__value_.__s.__data_[0] = v242;
              sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 1);
            }
            unsigned int v243 = *((_DWORD *)v205 + 10);
            if (v243 >= 2)
            {
              LODWORD(__dst.__r_.__value_.__l.__data_) = bswap32(v243);
              sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 4);
            }
            unsigned int v244 = *((_DWORD *)v205 + 14);
            if (v244)
            {
              LODWORD(__dst.__r_.__value_.__l.__data_) = bswap32(v244);
              sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 4);
            }
            if (v229)
            {
              uint64_t v245 = (uint64_t)v418;
              if (v419 != v418)
              {
                unint64_t v246 = 0;
                unint64_t v247 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v419 - (char *)v418) >> 3);
                unsigned int v248 = 1;
                do
                {
                  int v249 = *(_DWORD *)(v245 + 40 * v246 + 32);
                  if (v247 > v248) {
                    LOBYTE(v249) = v249 | 0x80;
                  }
                  __dst.__r_.__value_.__s.__data_[0] = v249;
                  sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 1);
                  v250 = &v418[20 * v246];
                  v251 = (char *)*((void *)v250 + 1);
                  v252 = (char *)(v250 + 8);
                  if (v251) {
                    v253 = v251;
                  }
                  else {
                    v253 = v252;
                  }
                  sub_19E0F18BC((ssize_t)&md, v253);
                  unint64_t v246 = v248;
                  uint64_t v245 = (uint64_t)v418;
                  unint64_t v247 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v419 - (char *)v418) >> 3);
                  ++v248;
                }
                while (v247 > v246);
              }
            }
            else if (v228)
            {
              if ((v205[164] & 8) != 0)
              {
                if (!*(void *)(a1 + 1840)) {
                  __assert_rtn("encode", "TIHuffmanCoder.cpp", 203, "is_compiled()");
                }
                *(void *)buf = 0;
                *(void *)&uint8_t buf[8] = buf;
                *(void *)&uint8_t buf[16] = 0x4802000000;
                *(void *)&buf[24] = sub_19E08C1B8;
                v445 = sub_19E08C1E4;
                v447 = 0;
                uint64_t v448 = 0;
                v446 = 0;
                CC_LONG len = 8;
                __dst.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
                __dst.__r_.__value_.__l.__size_ = 0x40000000;
                __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)sub_19E08C1FC;
                v441 = &unk_1E599BE48;
                v442 = buf;
                uint64_t v443 = a1 + 1776;
                unint64_t v255 = *((void *)v205 + 1);
                if (!v255) {
                  unint64_t v255 = (unint64_t)(v205 + 8);
                }
                v431.n128_u64[0] = v255;
                v431.n128_u32[2] = 0;
                v431.n128_u32[3] = *v205;
                v432[0] = 0;
                sub_19E03E768((uint64_t *)&v431);
                int v256 = *v205;
                v257 = (unsigned __int16 *)*((void *)v205 + 1);
                if (!v257) {
                  v257 = v205 + 8;
                }
                *(void *)v427 = v257;
                *(_DWORD *)&v427[8] = v256;
                *(_DWORD *)v428 = v256;
                *(_DWORD *)&v428[4] = 0;
                sub_19E03E768((uint64_t *)v427);
                uint64_t v258 = *(void *)v427;
                int v259 = *(_DWORD *)&v427[8];
                while (1)
                {
                  if (v431.n128_u64[0] != v258) {
                    __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
                  }
                  if (v431.n128_u32[2] == v259) {
                    break;
                  }
                  ((void (*)(std::string *, void))__dst.__r_.__value_.__r.__words[2])(&__dst, v432[0]);
                  sub_19E03E768((uint64_t *)&v431);
                }
                ((void (*)(std::string *, void))__dst.__r_.__value_.__r.__words[2])(&__dst, 0);
                uint64_t v260 = *(void *)&buf[8];
                uint64_t v262 = *(void *)(*(void *)&buf[8] + 40);
                uint64_t v261 = *(void *)(*(void *)&buf[8] + 48);
                if (v261 - v262 != sub_19E08C3E8(v412, v205)) {
                  __assert_rtn("encode", "TIHuffmanCoder.cpp", 215, "bytes.size() == encoded_size(str)");
                }
                sub_19E03E82C(&v421, *(void *)(v260 + 48) - *(void *)(v260 + 40), *(void **)(v260 + 40), *(void *)(v260 + 48) - *(void *)(v260 + 40));
                _Block_object_dispose(buf, 8);
                if (v446)
                {
                  v447 = v446;
                  operator delete(v446);
                }
                if ((unsigned __int16)v421 <= 0xEuLL) {
                  v263 = (char *)&v421 + 2;
                }
                else {
                  v263 = v422;
                }
                sub_19E0F185C((ssize_t)&md, (uint64_t)v263, (unsigned __int16)v421);
                if ((unsigned __int16)v421 >= 0xFu && v422) {
                  MEMORY[0x19F3BA6E0](v422, 0x1000C8077774924);
                }
              }
              else
              {
                if (*((void *)v205 + 1)) {
                  v254 = (char *)*((void *)v205 + 1);
                }
                else {
                  v254 = (char *)(v205 + 8);
                }
                sub_19E0F18BC((ssize_t)&md, v254);
              }
            }
            uint64_t v264 = *((void *)v205 + 41);
            if ((v264 & 0x100) != 0)
            {
              int v265 = *((_DWORD *)v205 + 15);
              __dst.__r_.__value_.__s.__data_[0] = BYTE2(v265);
              __dst.__r_.__value_.__s.__data_[1] = BYTE1(v265);
              __dst.__r_.__value_.__s.__data_[2] = v265;
              sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 3);
              uint64_t v264 = *((void *)v205 + 41);
            }
            if ((v264 & 0x1000000) != 0)
            {
              LODWORD(__dst.__r_.__value_.__l.__data_) = bswap32(*((_DWORD *)v205 + 16));
              sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 4);
              uint64_t v264 = *((void *)v205 + 41);
            }
            if ((v264 & 0x200000) != 0)
            {
              LODWORD(__dst.__r_.__value_.__l.__data_) = bswap32(*((_DWORD *)v205 + 19));
              sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 4);
              LOWORD(__dst.__r_.__value_.__l.__data_) = bswap32(v205[40]) >> 16;
              sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 2);
            }
            off_t v266 = sub_19E0F1A04(v435);
            if (((v266 - size) & 0xFFFFFF00) != 0) {
              __assert_rtn("write_unigram_record_v2", "UnigramWord.cpp", 726, "record_length <= 0xff");
            }
            sub_19E0F1A4C(v435, size);
            __dst.__r_.__value_.__s.__data_[0] = v266 - size;
            sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 1);
            sub_19E0F1A4C(v435, v266);
            *(void *)buf = &v418;
            sub_19E09FE3C((void ***)buf);
            ++*(_DWORD *)(a1 + 1888);
            v198 = *(uint64_t **)(a1 + 280);
            goto LABEL_446;
          }
          LODWORD(v211) = 1;
        }
        else
        {
          unint64_t v272 = *((void *)v205 + 41);
          if (!v208)
          {
            v198 = *(uint64_t **)(a1 + 280);
            if ((v272 & 0x800) != 0) {
              goto LABEL_340;
            }
            goto LABEL_446;
          }
          uint64_t v211 = (v272 >> 11) & 1;
        }
        uint64_t v212 = (uint64_t)v411;
        if (v411) {
          goto LABEL_337;
        }
        sub_19E076C68((uint64_t)v208);
        v198 = *(uint64_t **)(a1 + 280);
        if (v211) {
          goto LABEL_340;
        }
LABEL_446:
        uint64_t v199 = *v198;
        unint64_t v203 = (v198[1] - *v198) >> 3;
      }
      while (v203 > v201);
    }
    *(_DWORD *)buf = 0;
    sub_19E0F185C((ssize_t)&md, (uint64_t)buf, 4);
    unsigned int v273 = sub_19E0F1A04(v435);
    unsigned int v274 = v273;
    if ((*(unsigned char *)(a1 + 241) & 0x10) != 0) {
      unsigned int v275 = 0x80000000;
    }
    else {
      unsigned int v275 = 0x800000;
    }
    if (v275 < v273)
    {
      sub_19E0538DC((uint64_t)buf);
      sub_19E0416F8(&buf[16], (uint64_t)"Unigram index length=", 21);
      v392 = (void *)std::ostream::operator<<();
      sub_19E0416F8(v392, (uint64_t)" bytes exceeds trie addressing capacity=", 40);
      std::ostream::operator<<();
      if ((*(unsigned char *)(a1 + 241) & 0x10) == 0) {
        sub_19E0416F8(&buf[16], (uint64_t)" (try passing the '-4' option when compiling)", 45);
      }
      v393 = __cxa_allocate_exception(0x20uLL);
      sub_19E05EEA4(&__dst, (uint64_t)&buf[24]);
      sub_19E08DA70(v393, (long long *)&__dst);
      __cxa_throw(v393, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
    }
    unsigned __int8 v276 = atomic_load(byte_1E9457268);
    if (v276)
    {
      unsigned __int8 v277 = atomic_load(byte_1E94578A0);
      if (v277)
      {
        printf("\tWrote %d non-derivable words in %d bytes", *(_DWORD *)(a1 + 1888), v273);
        putchar(10);
      }
      else
      {
        v278 = sub_19E08D084();
        if (os_log_type_enabled(v278, OS_LOG_TYPE_DEFAULT))
        {
          int v279 = *(_DWORD *)(a1 + 1888);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v279;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v274;
          _os_log_impl(&dword_19E038000, v278, OS_LOG_TYPE_DEFAULT, "\tWrote %d non-derivable words in %d bytes", buf, 0xEu);
        }
      }
    }
    unsigned __int8 v280 = atomic_load(byte_1E9457268);
    if (v280)
    {
      unsigned __int8 v281 = atomic_load(byte_1E94578A0);
      if (v281)
      {
        putchar(10);
      }
      else
      {
        v282 = sub_19E08D084();
        if (os_log_type_enabled(v282, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_19E038000, v282, OS_LOG_TYPE_DEFAULT, (const char *)&unk_19E1315F5, buf, 2u);
        }
      }
    }
    uint64_t v283 = *(void *)(a1 + 240);
    if ((v283 & 0x100) != 0)
    {
      unsigned int v284 = sub_19E0F1A04(v435);
      memset(buf, 0, sizeof(buf));
      LODWORD(v445) = 1065353216;
      v285 = *(unsigned __int16 ****)(a1 + 280);
      v286 = *v285;
      v287 = v285[1];
      unsigned int v413 = v284;
      unsigned int v288 = 0;
      if (*v285 != v287)
      {
        unsigned int v289 = -1;
        while (1)
        {
          v290 = *v286;
          unint64_t v291 = *((unsigned int *)*v286 + 15);
          LODWORD(v41++**(_DWORD **)(result + 8) = v291;
          if (v291)
          {
            uint64_t v293 = *(void *)buf;
            unint64_t v292 = *(void *)&buf[8];
            if (!sub_19E09C460(*(uint64_t *)buf, *(unint64_t *)&buf[8], v291))
            {
              if (v292)
              {
                uint8x8_t v294 = (uint8x8_t)vcnt_s8((int8x8_t)v292);
                v294.i16[0] = vaddlv_u8(v294);
                if (v294.u32[0] > 1uLL)
                {
                  unint64_t size = v291;
                  if (v292 <= v291) {
                    unint64_t size = v291 % v292;
                  }
                }
                else
                {
                  unint64_t size = (v292 - 1) & v291;
                }
                v303 = *(uint64_t ***)(v293 + 8 * size);
                if (v303)
                {
                  for (uint64_t j = *v303; j; uint64_t j = (uint64_t *)*j)
                  {
                    unint64_t v305 = j[1];
                    if (v305 == v291)
                    {
                      if (*((_DWORD *)j + 4) == v291) {
                        goto LABEL_563;
                      }
                    }
                    else
                    {
                      if (v294.u32[0] > 1uLL)
                      {
                        if (v305 >= v292) {
                          v305 %= v292;
                        }
                      }
                      else
                      {
                        v305 &= v292 - 1;
                      }
                      if (v305 != size) {
                        break;
                      }
                    }
                  }
                }
              }
              unsigned __int8 v306 = operator new(0x20uLL);
              *unsigned __int8 v306 = 0;
              v306[1] = v291;
              *((_DWORD *)v306 + 4) = v291;
              v306[3] = v290;
              float v307 = (float)(unint64_t)(*(void *)&buf[24] + 1);
              if (!v292 || (float)(*(float *)&v445 * (float)v292) < v307)
              {
                BOOL v308 = (v292 & (v292 - 1)) != 0;
                if (v292 < 3) {
                  BOOL v308 = 1;
                }
                unint64_t v309 = v308 | (2 * v292);
                unint64_t v310 = vcvtps_u32_f32(v307 / *(float *)&v445);
                if (v309 <= v310) {
                  size_t v311 = v310;
                }
                else {
                  size_t v311 = v309;
                }
                sub_19E08A5BC((uint64_t)buf, v311);
                unint64_t v292 = *(void *)&buf[8];
                if ((v292 & (v292 - 1)) != 0)
                {
                  if (*(void *)&buf[8] <= v291) {
                    unint64_t size = v291 % *(void *)&buf[8];
                  }
                  else {
                    unint64_t size = v291;
                  }
                }
                else
                {
                  unint64_t size = (*(_DWORD *)&buf[8] - 1) & v291;
                }
              }
              uint64_t v317 = *(void *)buf;
              long long v318 = *(void **)(*(void *)buf + 8 * size);
              if (v318)
              {
                *unsigned __int8 v306 = *v318;
                goto LABEL_561;
              }
              *unsigned __int8 v306 = *(void *)&buf[16];
              *(void *)&uint8_t buf[16] = v306;
              *(void *)(v317 + 8 * size) = &buf[16];
              if (*v306)
              {
                unint64_t v319 = *(void *)(*v306 + 8);
                if ((v292 & (v292 - 1)) != 0)
                {
                  if (v319 >= v292) {
                    v319 %= v292;
                  }
                }
                else
                {
                  v319 &= v292 - 1;
                }
                long long v318 = (void *)(*(void *)buf + 8 * v319);
LABEL_561:
                *long long v318 = v306;
              }
              ++*(void *)&buf[24];
LABEL_563:
              if (v291 < v289) {
                unsigned int v289 = v291;
              }
              if (v288 <= v291) {
                unsigned int v288 = v291;
              }
              goto LABEL_567;
            }
            if (*((unsigned char *)v290 + 96))
            {
              sub_19E09C50C((uint64_t)buf, v291, &v418)[3] = v290;
            }
            else
            {
              unsigned __int8 v295 = atomic_load(byte_1E9457268);
              if (v295)
              {
                unsigned __int8 v296 = atomic_load(byte_1E94578A0);
                if (v296)
                {
                  int v312 = (int)v418;
                  long long v313 = sub_19E09C50C((uint64_t)buf, v418, &v418);
                  sub_19E08E71C((uint64_t)&__dst, (unsigned __int16 *)v313[3]);
                  unint64_t size = (unint64_t)v427;
                  std::string::size_type v314 = __dst.__r_.__value_.__l.__size_;
                  sub_19E08E71C((uint64_t)&v431, *v286);
                  long long v315 = &__dst.__r_.__value_.__s.__data_[16];
                  if (v314) {
                    long long v315 = (const char *)v314;
                  }
                  long long v316 = (const char *)v431.n128_u64[1];
                  if (!v431.n128_u64[1]) {
                    long long v316 = (const char *)v432;
                  }
                  printf("WARNING: words [%s] and [%s] share word id %u; only former is stored in word id map",
                    v315,
                    v316,
                    v312);
                  if (v431.n128_u64[1] && v431.n128_u8[6] == 1) {
                    free((void *)v431.n128_u64[1]);
                  }
                  if (__dst.__r_.__value_.__l.__size_ && __dst.__r_.__value_.__s.__data_[6] == 1) {
                    free((void *)__dst.__r_.__value_.__l.__size_);
                  }
                  putchar(10);
                }
                else
                {
                  long long v297 = sub_19E08D084();
                  if (os_log_type_enabled(v297, OS_LOG_TYPE_DEFAULT))
                  {
                    int v298 = (int)v418;
                    v299 = sub_19E09C50C((uint64_t)buf, v418, &v418);
                    sub_19E08E71C((uint64_t)&__dst, (unsigned __int16 *)v299[3]);
                    unint64_t size = (unint64_t)v427;
                    std::string::size_type v300 = __dst.__r_.__value_.__l.__size_;
                    sub_19E08E71C((uint64_t)&v431, *v286);
                    v301 = (unsigned int *)v431.n128_u64[1];
                    char v302 = &__dst.__r_.__value_.__s.__data_[16];
                    if (v300) {
                      char v302 = (std::string::value_type *)v300;
                    }
                    *(_DWORD *)v427 = 136315650;
                    if (!v431.n128_u64[1]) {
                      v301 = v432;
                    }
                    *(void *)&v427[4] = v302;
                    *(_WORD *)v428 = 2080;
                    *(void *)&v428[2] = v301;
                    __int16 v429 = 1024;
                    int v430 = v298;
                    _os_log_impl(&dword_19E038000, v297, OS_LOG_TYPE_DEFAULT, "WARNING: words [%s] and [%s] share word id %u; only former is stored in word id map",
                      v427,
                      0x1Cu);
                    if (v431.n128_u64[1] && v431.n128_u8[6] == 1) {
                      free((void *)v431.n128_u64[1]);
                    }
                    if (__dst.__r_.__value_.__l.__size_ && __dst.__r_.__value_.__s.__data_[6] == 1) {
                      free((void *)__dst.__r_.__value_.__l.__size_);
                    }
                  }
                }
              }
            }
          }
LABEL_567:
          if (++v286 == v287) {
            goto LABEL_570;
          }
        }
      }
      unsigned int v289 = -1;
LABEL_570:
      __dst.__r_.__value_.__s.__data_[0] = (v288 - v289 + 1) >> 16;
      __dst.__r_.__value_.__s.__data_[1] = (unsigned __int16)(v288 - v289 + 1) >> 8;
      __dst.__r_.__value_.__s.__data_[2] = v288 - v289 + 1;
      sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 3);
      __dst.__r_.__value_.__s.__data_[0] = BYTE2(v289);
      __dst.__r_.__value_.__s.__data_[1] = BYTE1(v289);
      __dst.__r_.__value_.__s.__data_[2] = v289;
      sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 3);
      while (1)
      {
        v431.n128_u32[0] = v289;
        if (v289 > v288) {
          break;
        }
        if (sub_19E09C460(*(uint64_t *)buf, *(unint64_t *)&buf[8], v289)) {
          unsigned int v320 = *(_DWORD *)(sub_19E09C50C((uint64_t)buf, v289, &v431)[3] + 248);
        }
        else {
          unsigned int v320 = 0;
        }
        if ((*(unsigned char *)(a1 + 241) & 0x10) != 0)
        {
          LODWORD(__dst.__r_.__value_.__l.__data_) = bswap32(v320);
          sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 4);
        }
        else
        {
          __dst.__r_.__value_.__s.__data_[0] = BYTE2(v320);
          __dst.__r_.__value_.__s.__data_[1] = BYTE1(v320);
          __dst.__r_.__value_.__s.__data_[2] = v320;
          sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 3);
        }
        ++v289;
      }
      sub_19E0F1A4C(v435, 72);
      LODWORD(__dst.__r_.__value_.__l.__data_) = bswap32(v413);
      sub_19E0F185C((ssize_t)&md, (uint64_t)&__dst, 4);
      sub_19E0F1A90(v435);
      sub_19E076B34((uint64_t)buf);
      uint64_t v283 = *(void *)(a1 + 240);
    }
    if ((v283 & 8) != 0)
    {
      unsigned int v321 = sub_19E0F1A04(v435);
      if (!*(void *)(a1 + 1840)) {
        __assert_rtn("write_unigram_data", "UnigramsCompiler.cpp", 1047, "m_huffman_coder.is_compiled()");
      }
      unsigned int v322 = v321;
      uint64_t v323 = *(void *)(a1 + 1864);
      unsigned int v324 = *(_DWORD *)(v323 - 4);
      if (v324 == -1)
      {
        long long v325 = 0;
      }
      else
      {
        long long v326 = (char *)sub_19E068D84(v324 + 1);
        long long v325 = v326;
        uint64_t v327 = 0;
        do
        {
          *(_DWORD *)&v326[v327] = 0;
          v327 += 4;
        }
        while (4 * (v324 + 1) != v327);
        uint64_t v323 = *(void *)(a1 + 1864);
      }
      for (uint64_t k = *(void *)(a1 + 1856); k != v323; k += 8)
        ++v325[*(unsigned int *)(k + 4)];
      buf[0] = v324;
      sub_19E0F185C((ssize_t)&md, (uint64_t)buf, 1);
      if (v324)
      {
        for (unsigned int m = 1; m <= v324; ++m)
        {
          unsigned int v330 = v325[m];
          if (v330 >= 0x10000) {
            __assert_rtn("write", "TIHuffmanCoder.cpp", 191, "num_chars_in_depth[depth] <= 0xffff");
          }
          *(_WORD *)buf = bswap32(v330) >> 16;
          sub_19E0F185C((ssize_t)&md, (uint64_t)buf, 2);
        }
      }
      long long v331 = *(unsigned int **)(a1 + 1856);
      long long v332 = *(unsigned int **)(a1 + 1864);
      while (v331 != v332)
      {
        *(_DWORD *)buf = bswap32(*v331);
        sub_19E0F185C((ssize_t)&md, (uint64_t)buf, 4);
        v331 += 2;
      }
      if (v325) {
        operator delete(v325);
      }
      sub_19E0F1A4C(v435, 76);
      *(_DWORD *)buf = bswap32(v322);
      sub_19E0F185C((ssize_t)&md, (uint64_t)buf, 4);
      sub_19E0F1A90(v435);
    }
    unsigned int v333 = sub_19E0F1A04(v435);
    (*(void (**)(void, std::string *))(**(void **)(a1 + 264) + 48))(*(void *)(a1 + 264), &md);
    sub_19E0F1A4C(v435, 80);
    *(_DWORD *)buf = bswap32(v333);
    sub_19E0F185C((ssize_t)&md, (uint64_t)buf, 4);
    sub_19E0F1A90(v435);
    if ((*(unsigned char *)(a1 + 243) & 2) == 0)
    {
      while ((uint64_t)(sub_19E0F1A04(v435) & 0x8000000000000003) >= 1)
      {
        buf[0] = 0;
        sub_19E0F185C((ssize_t)&md, (uint64_t)buf, 1);
      }
      unsigned int v334 = sub_19E0F1A04(v435);
      uint64_t v335 = *(void *)(a1 + 1992) - *(void *)(a1 + 1984);
      unsigned __int8 v336 = atomic_load(byte_1E9457268);
      if (v336)
      {
        unsigned __int8 v337 = atomic_load(byte_1E94578A0);
        if (v337)
        {
          printf("sort key mapping table = %d bytes", v335 & 0xFFFFFFF8);
          putchar(10);
        }
        else
        {
          long long v338 = sub_19E08D084();
          if (os_log_type_enabled(v338, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v335 & 0xFFFFFFF8;
            _os_log_impl(&dword_19E038000, v338, OS_LOG_TYPE_DEFAULT, "sort key mapping table = %d bytes", buf, 8u);
          }
        }
      }
      *(_DWORD *)buf = bswap32(v335 & 0xFFFFFFF8);
      sub_19E0F185C((ssize_t)&md, (uint64_t)buf, 4);
      sub_19E0F185C((ssize_t)&md, *(void *)(a1 + 1984), v335 & 0xFFFFFFF8);
      *(_DWORD *)buf = bswap32(*(_DWORD *)(a1 + 2016) - *(_DWORD *)(a1 + 2008));
      sub_19E0F185C((ssize_t)&md, (uint64_t)buf, 4);
      sub_19E0F185C((ssize_t)&md, *(void *)(a1 + 2008), *(void *)(a1 + 2016) - *(void *)(a1 + 2008));
      sub_19E0F1A4C(v435, 64);
      *(_DWORD *)buf = bswap32(v334);
      sub_19E0F185C((ssize_t)&md, (uint64_t)buf, 4);
      sub_19E0F1A90(v435);
    }
    sub_19E039A20((uint64_t)&md);
    if (*(void *)v437 && BYTE6(__n) == 1) {
      free(*(void **)v437);
    }
    sub_19E099200();
  }
  unsigned __int8 v6 = atomic_load(byte_1E9457268);
  if (v6)
  {
    unsigned __int8 v7 = atomic_load(byte_1E94578A0);
    if (v7)
    {
      unsigned int v12 = *(const char **)(a1 + 1904);
      if (!v12) {
        unsigned int v12 = v3;
      }
      char v13 = *(const char **)(a1 + 24);
      if (!v13) {
        char v13 = (const char *)(a1 + 32);
      }
      printf("Printing active unigrams from %s (%s) with prefix=%s, length<>%d, suffix=%s", v12, v13, "", *(_DWORD *)(a1 + 1968), "");
      putchar(10);
    }
    else
    {
      unsigned int v8 = sub_19E08D084();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v9 = *(const char **)(a1 + 1904);
        if (!v9) {
          unint64_t v9 = v3;
        }
        uint64_t v10 = *(void *)(a1 + 24);
        if (!v10) {
          uint64_t v10 = a1 + 32;
        }
        int v11 = *(_DWORD *)(a1 + 1968);
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v10;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = "";
        LOWORD(v445) = 1024;
        *(_DWORD *)((char *)&v445 + 2) = v11;
        HIWORD(v445) = 2080;
        v446 = "";
        _os_log_impl(&dword_19E038000, v8, OS_LOG_TYPE_DEFAULT, "Printing active unigrams from %s (%s) with prefix=%s, length<>%d, suffix=%s", buf, 0x30u);
      }
    }
  }
  sub_19E095BF4(a1);
  LODWORD(md.__r_.__value_.__l.__data_) = 0x100000;
  WORD2(md.__r_.__value_.__r.__words[0]) = 0;
  unsigned int v14 = 1;
  md.__r_.__value_.__s.__data_[6] = 1;
  md.__r_.__value_.__l.__size_ = 0;
  sub_19E03F6F8(&md, (uint64_t)"", 0, 0);
  int v15 = *(_DWORD *)(a1 + 1968);
  LODWORD(__dst.__r_.__value_.__l.__data_) = 0x100000;
  WORD2(__dst.__r_.__value_.__r.__words[0]) = 0;
  __dst.__r_.__value_.__s.__data_[6] = 1;
  __dst.__r_.__value_.__l.__size_ = 0;
  sub_19E03F6F8(&__dst, (uint64_t)"", 0, 0);
  uint64_t v16 = *(uint64_t **)(a1 + 280);
  uint64_t v17 = *v16;
  uint64_t v18 = (uint64_t *)v16[1];
  unint64_t v19 = 126 - 2 * __clz(((uint64_t)v18 - *v16) >> 3);
  *(void *)buf = sub_19E0917FC;
  if (v18 == (uint64_t *)v17) {
    uint64_t v20 = 0;
  }
  else {
    uint64_t v20 = v19;
  }
  sub_19E09C724(v17, v18, (uint64_t (**)(uint64_t *, uint64_t *))buf, v20, 1);
  (*(void (**)(size_t *__return_ptr))(**(void **)(a1 + 248) + 8))(&__n);
  uint64_t v27 = *(uint64_t **)(a1 + 280);
  uint64_t v28 = *v27;
  if (v27[1] != *v27)
  {
    unint64_t v29 = 0;
    do
    {
      uint64_t v30 = *(void *)(v28 + 8 * v29);
      int v31 = *(unsigned __int16 *)(v30 + 4);
      if (!*(_WORD *)(v30 + 4))
      {
        sub_19E0398F4(*(unsigned __int16 **)(v28 + 8 * v29));
        int v31 = *(unsigned __int16 *)(v30 + 4);
      }
      if (v15 < 1 || v15 >= v31)
      {
        BOOL v33 = v15 >= 0 || v15 < v31;
        int v32 = !v33;
      }
      else
      {
        int v32 = 1;
      }
      int v34 = (unsigned __int16)__n;
      if ((_WORD)__n) {
        BOOL v35 = sub_19E0A7064((unsigned __int16 *)(*(void *)(v28 + 8 * v29) + 136), (unsigned __int16 *)&__n);
      }
      else {
        BOOL v35 = 0;
      }
      int data_low = LOWORD(__dst.__r_.__value_.__l.__data_);
      if (LOWORD(__dst.__r_.__value_.__l.__data_))
      {
        BOOL v37 = sub_19E03FB3C(*(unsigned __int16 **)(v28 + 8 * v29), (unsigned __int16 *)&__dst);
        if (v15) {
          goto LABEL_59;
        }
      }
      else
      {
        BOOL v37 = 0;
        if (v15) {
          goto LABEL_59;
        }
      }
      if (v34)
      {
LABEL_59:
        if ((v32 | v35 | v37) != 1) {
          goto LABEL_83;
        }
        goto LABEL_60;
      }
      if (data_low) {
        int v38 = v32;
      }
      else {
        int v38 = 1;
      }
      if (((v38 | (v35 || v37)) & 1) == 0) {
        goto LABEL_83;
      }
LABEL_60:
      int v39 = *(unsigned __int8 *)(a1 + 1965);
      unsigned __int8 v40 = atomic_load(byte_1E9457268);
      if (v39)
      {
        if (v40)
        {
          unsigned __int8 v41 = atomic_load(byte_1E94578A0);
          if (v41)
          {
            sub_19E0F08B4(buf, *(void *)(v28 + 8 * v29), v21, v22, v23, v24, v25, v26);
LABEL_77:
            uint64_t v45 = *(const char **)&buf[8];
            if (!*(void *)&buf[8]) {
              uint64_t v45 = (const char *)&buf[16];
            }
            printf("%s", v45);
            if (*(void *)&buf[8] && buf[6] == 1) {
              free(*(void **)&buf[8]);
            }
            putchar(10);
            goto LABEL_83;
          }
          unint64_t v42 = sub_19E08D084();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            sub_19E0F08B4(buf, *(void *)(v28 + 8 * v29), v21, v22, v23, v24, v25, v26);
            unint64_t v43 = *(uint8_t **)&buf[8];
            if (!*(void *)&buf[8]) {
              unint64_t v43 = &buf[16];
            }
LABEL_72:
            v431.n128_u32[0] = 136315138;
            *(unint64_t *)((char *)v431.n128_u64 + 4) = (unint64_t)v43;
            _os_log_impl(&dword_19E038000, v42, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&v431, 0xCu);
            if (*(void *)&buf[8] && buf[6] == 1) {
              free(*(void **)&buf[8]);
            }
          }
        }
      }
      else if (v40)
      {
        unsigned __int8 v44 = atomic_load(byte_1E94578A0);
        if (v44)
        {
          sub_19E0F0434(buf, *(void *)(v28 + 8 * v29));
          goto LABEL_77;
        }
        unint64_t v42 = sub_19E08D084();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          sub_19E0F0434(buf, *(void *)(v28 + 8 * v29));
          unint64_t v43 = *(uint8_t **)&buf[8];
          if (!*(void *)&buf[8]) {
            unint64_t v43 = &buf[16];
          }
          goto LABEL_72;
        }
      }
LABEL_83:
      unint64_t v29 = v14;
      size_t v46 = *(uint64_t **)(a1 + 280);
      uint64_t v28 = *v46;
      ++v14;
    }
    while (v29 < (v46[1] - *v46) >> 3);
  }
  if ((unsigned __int16)__n >= 0xFu && *(void *)v437) {
    MEMORY[0x19F3BA6E0](*(void *)v437, 0x1000C8077774924);
  }
  if (__dst.__r_.__value_.__l.__size_ && __dst.__r_.__value_.__s.__data_[6] == 1) {
    free((void *)__dst.__r_.__value_.__l.__size_);
  }
  if (md.__r_.__value_.__l.__size_ && md.__r_.__value_.__s.__data_[6] == 1) {
    free((void *)md.__r_.__value_.__l.__size_);
  }
LABEL_93:
  if (v424 && v423[6] == 1) {
    free(v424);
  }
  if (v426)
  {
    if (v425[6] == 1) {
      free(v426);
    }
  }
}

void sub_19E095068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,unsigned __int16 a36,uint64_t a37,uint64_t a38,unsigned __int16 a39,uint64_t a40,int a41,__int16 a42,char a43,void *a44,uint64_t a45,uint64_t a46,int a47,__int16 a48,char a49,void *a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,int a61,__int16 a62,char a63)
{
  unint64_t v65 = *(void **)(v63 + 72);
  if (v65 && a63 == 1) {
    free(v65);
  }
  if (a39 >= 0xFu && a40) {
    MEMORY[0x19F3BA6E0](a40, 0x1000C8077774924);
  }
  if (a36 >= 0xFu && a37) {
    MEMORY[0x19F3BA6E0](a37, 0x1000C8077774924);
  }
  if (a44) {
    BOOL v66 = a43 == 1;
  }
  else {
    BOOL v66 = 0;
  }
  if (v66) {
    free(a44);
  }
  if (a50)
  {
    if (a49 == 1) {
      free(a50);
    }
  }
  _Unwind_Resume(a1);
}

void sub_19E095668(uint64_t a1, uint64_t a2, _WORD *a3)
{
  v40[2] = *MEMORY[0x1E4F143B8];
  int v25 = 0x100000;
  __int16 v26 = 0;
  char v27 = 0;
  uint64_t v28 = 0;
  char v29 = 0;
  if (*(_WORD *)(a2 + 1928))
  {
    sub_19E03CD54((uint64_t)&v25, (unsigned __int16 *)(a2 + 1928));
    goto LABEL_61;
  }
  LODWORD(v3++**(_DWORD **)(result + 8) = 0x100000;
  WORD2(v3++**(_DWORD **)(result + 8) = 0;
  BYTE6(v3++**(_DWORD **)(result + 8) = 1;
  int v39 = 0;
  sub_19E03F6F8(&v38, (uint64_t)"/", 0, 1u);
  if (*(void *)(a2 + 1904)) {
    unsigned __int8 v6 = *(char **)(a2 + 1904);
  }
  else {
    unsigned __int8 v6 = (char *)(a2 + 1912);
  }
  unsigned __int8 v7 = v39;
  if (v39) {
    unsigned int v8 = (const char *)v39;
  }
  else {
    unsigned int v8 = (const char *)v40;
  }
  unint64_t v9 = strstr(v6, v8);
  if (v9) {
    BOOL v10 = (unsigned __int16)((_WORD)v9 - (_WORD)v6) == 0xFFFFLL;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10) {
    __assert_rtn("default_output_path", "UnigramsCompiler.cpp", 1090, "m_unigrams_path.find(String(\"/\")) != String::NotAnIndex");
  }
  if (v7 && BYTE6(v38) == 1) {
    free(v7);
  }
  LODWORD(v35) = 0x100000;
  WORD2(v35) = 0;
  BYTE6(v35) = 1;
  uint64_t v36 = 0;
  sub_19E03F6F8(&v35, (uint64_t)"/", 0, 1u);
  int v11 = *(unsigned __int8 **)(a2 + 1904);
  if (!v11) {
    int v11 = (unsigned __int8 *)(a2 + 1912);
  }
  uint64_t v12 = *(unsigned __int16 *)(a2 + 1896);
  char v13 = &v11[v12];
  unsigned int v14 = (unsigned __int8 *)&v37;
  if (v36) {
    unsigned int v14 = (unsigned __int8 *)v36;
  }
  if (*(_WORD *)(a2 + 1896) && (_WORD)v35)
  {
    int v15 = v11;
    uint64_t v16 = &v11[v12];
    do
    {
      if (*v15 == *v14)
      {
        uint64_t v17 = 1;
        while ((unsigned __int16)v35 != v17)
        {
          if (&v15[v17] == v13) {
            goto LABEL_34;
          }
          int v18 = v15[v17];
          int v19 = v14[v17++];
          if (v18 != v19) {
            goto LABEL_24;
          }
        }
        uint64_t v16 = v15;
      }
LABEL_24:
      ++v15;
    }
    while (v15 != v13);
LABEL_34:
    BOOL v10 = v16 == v13;
    LOWORD(v13) = (_WORD)v16;
    if (!v10) {
      goto LABEL_35;
    }
LABEL_33:
    __int16 v20 = -1;
    goto LABEL_36;
  }
  if ((_WORD)v35) {
    goto LABEL_33;
  }
LABEL_35:
  __int16 v20 = (_WORD)v13 - (_WORD)v11;
LABEL_36:
  sub_19E03FB9C(&v38, (unsigned __int16 *)(a2 + 1896), (unsigned __int16)(v20 + 1), v12);
  if (v36 && BYTE6(v35) == 1) {
    free(v36);
  }
  LODWORD(v35) = 0x100000;
  WORD2(v35) = 0;
  BYTE6(v35) = 1;
  uint64_t v36 = 0;
  sub_19E03F6F8(&v35, (uint64_t)"words", 0, 5u);
  if (!sub_19E03FB3C((unsigned __int16 *)&v38, (unsigned __int16 *)&v35)) {
    __assert_rtn("default_output_path", "UnigramsCompiler.cpp", 1092, "input_filename.ends_with(String(\"words\"))");
  }
  if (v36 && BYTE6(v35) == 1) {
    free(v36);
  }
  __int16 v21 = v38;
  LODWORD(v33) = 0x100000;
  WORD2(v33) = 0;
  BYTE6(v33) = 1;
  int v34 = 0;
  sub_19E03F6F8(&v33, (uint64_t)"dat", 0, 3u);
  sub_19E0B1DD8((uint64_t)&v35, (unsigned __int16 *)&v38, (unsigned __int16)(v21 - 5), 5, &v33);
  if (v34 && BYTE6(v33) == 1) {
    free(v34);
  }
  sub_19E039858((uint64_t)v30, (unsigned __int16 *)(a2 + 176));
  sub_19E0B237C((uint64_t)&v33, v30, "/");
  sub_19E0B23D4((uint64_t)v22, (unsigned __int16 *)&v33, (uint64_t)&v35);
  if (v34 && BYTE6(v33) == 1) {
    free(v34);
  }
  if (v32 && v31 == 1) {
    free(v32);
  }
  if (v36 && BYTE6(v35) == 1) {
    free(v36);
  }
  if (v39 && BYTE6(v38) == 1) {
    free(v39);
  }
  sub_19E03CED8((uint64_t)&v25, v22);
  if (v24 && v23 == 1) {
    free(v24);
  }
LABEL_61:
  LODWORD(v3++**(_DWORD **)(result + 8) = 0x100000;
  WORD2(v3++**(_DWORD **)(result + 8) = 0;
  BYTE6(v3++**(_DWORD **)(result + 8) = 1;
  int v39 = 0;
  sub_19E03F6F8(&v38, (uint64_t)".dat", 0, 4u);
  if (!sub_19E03FB3C((unsigned __int16 *)&v25, (unsigned __int16 *)&v38)) {
    __assert_rtn("output_path", "UnigramsCompiler.cpp", 1107, "dat_path.ends_with(String(\".dat\"))");
  }
  if (v39 && BYTE6(v38) == 1) {
    free(v39);
  }
  sub_19E0B1DD8(a1, (unsigned __int16 *)&v25, (unsigned __int16)(v25 - 3), 3, a3);
  if (v28)
  {
    if (v27 == 1) {
      free(v28);
    }
  }
}

void sub_19E095B10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, void *a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,void *a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,void *a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,void *a35)
{
  if (a29 && a28 == 1) {
    free(a29);
  }
  if (a23 && a22 == 1) {
    free(a23);
  }
  if (a35 && a34 == 1) {
    free(a35);
  }
  uint64_t v37 = *(void **)(v35 - 96);
  if (v37 && *(unsigned char *)(v35 - 98) == 1) {
    free(v37);
  }
  if (a17)
  {
    if (a16 == 1) {
      free(a17);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E095BF4(uint64_t a1)
{
  uint64_t v301 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t **)(a1 + 280);
  uint64_t v4 = *v2;
  for (uint64_t i = v2[1]; i != v4; i -= 8)
  {
    uint64_t v6 = *(void *)(i - 8);
    uint64_t v5 = v6;
    if (v6) {
      sub_19E076DB4(v5 + 84);
    }
  }
  v2[1] = v4;
  if (*(void *)(a1 + 312))
  {
    sub_19E076FC8(*(atomic_uint **)(a1 + 304));
    *(void *)(a1 + 304) = 0;
    uint64_t v7 = *(void *)(a1 + 296);
    if (v7)
    {
      for (uint64_t j = 0; j != v7; ++j)
        *(void *)(*(void *)(a1 + 288) + 8 * j) = 0;
    }
    *(void *)(a1 + 312) = 0;
  }
  if (*(void *)(a1 + 1904)) {
    unint64_t v9 = *(const char **)(a1 + 1904);
  }
  else {
    unint64_t v9 = (const char *)(a1 + 1912);
  }
  BOOL v10 = fopen(v9, "r");
  if (!v10)
  {
    sub_19E0538DC((uint64_t)v289);
    unsigned __int8 v280 = sub_19E0416F8(&v289[16], (uint64_t)"Failed to open ", 15);
    if (*(void *)(a1 + 1904)) {
      unsigned __int8 v281 = *(const char **)(a1 + 1904);
    }
    else {
      unsigned __int8 v281 = (const char *)(a1 + 1912);
    }
    size_t v282 = strlen(v281);
    uint64_t v283 = sub_19E0416F8(v280, (uint64_t)v281, v282);
    sub_19E0416F8(v283, (uint64_t)" (errno=", 8);
    __error();
    unsigned int v284 = (void *)std::ostream::operator<<();
    sub_19E0416F8(v284, (uint64_t)")", 1);
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E05EEA4(buf, (uint64_t)&v290);
    sub_19E08DA70(exception, (long long *)buf);
    __cxa_throw(exception, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
  }
  int v11 = v10;
  v288[0] = &unk_1EF0986C0;
  *(_DWORD *)unsigned int v289 = 0;
  v288[1] = uspoof_open();
  uint64_t v12 = (uint64_t)byte_1E94578A0;
  while (!feof(v11) && !ferror(v11))
  {
    char v13 = fgets((char *)v289, 256, v11);
    if (v13)
    {
      uint64_t v14 = (uint64_t)v13;
      unint64_t v1 = (unint64_t)&v299;
      *(_DWORD *)buf = 0x100000;
      *(_WORD *)&uint8_t buf[4] = 0;
      buf[6] = 1;
      *(void *)&uint8_t buf[8] = 0;
      unsigned __int16 v15 = strlen(v13);
      sub_19E03F6F8(buf, v14, 0, v15);
      LODWORD(v297) = 0x100000;
      WORD2(v297) = 0;
      BYTE6(v297) = 1;
      int v298 = 0;
      sub_19E03F6F8(&v297, (uint64_t)" \t\n", 0, 3u);
      sub_19E0B1AD4(&v292, (unsigned __int16 *)buf, (unsigned __int16 *)&v297);
      if (v298 && BYTE6(v297) == 1) {
        free(v298);
      }
      if (*(void *)&buf[8] && buf[6] == 1) {
        free(*(void **)&buf[8]);
      }
      if ((_WORD)v292)
      {
        LODWORD(v297) = 0x100000;
        WORD2(v297) = 0;
        BYTE6(v297) = 1;
        int v298 = 0;
        sub_19E03F6F8(&v297, (uint64_t)" \t\n", 0, 3u);
        if ((_WORD)v297)
        {
          *(_DWORD *)buf = 0x100000;
          *(_WORD *)&uint8_t buf[4] = 0;
          buf[6] = 0;
          *(void *)&uint8_t buf[8] = 0;
          uint8_t buf[16] = 0;
          sub_19E03F794((uint64_t)buf, v292);
          unsigned __int16 v16 = v292;
          if ((_WORD)v292)
          {
            unint64_t v17 = 0;
            do
            {
              int v18 = (long long *)*((void *)&v292 + 1);
              if (!*((void *)&v292 + 1)) {
                int v18 = &v293;
              }
              unsigned int v19 = *((char *)v18 + v17);
              uint64_t v20 = (unsigned __int16)v297;
              if ((_WORD)v297)
              {
                __int16 v21 = (unsigned __int8 *)v298;
                if (!v298) {
                  __int16 v21 = (unsigned __int8 *)&v299;
                }
                while (1)
                {
                  int v22 = *v21++;
                  if (v22 == v19) {
                    break;
                  }
                  if (!--v20) {
                    goto LABEL_35;
                  }
                }
              }
              else
              {
LABEL_35:
                sub_19E0B14D0((unsigned __int16 *)buf, v19);
                unsigned __int16 v16 = v292;
              }
              ++v17;
            }
            while (v17 < v16);
          }
        }
        else
        {
          sub_19E039858((uint64_t)buf, (unsigned __int16 *)&v292);
        }
        if (*(_WORD *)buf)
        {
          if (!(_WORD)v292)
          {
            if (BYTE6(v292) || (sub_19E0B12F4((unsigned __int16 *)&v292), (unsigned __int16)v292 < 2uLL))
            {
              sub_19E03F794((uint64_t)&v292, 1);
              uint64_t v24 = (long long *)*((void *)&v292 + 1);
              if (!*((void *)&v292 + 1)) {
                uint64_t v24 = &v293;
              }
              bzero((char *)v24 + (unsigned __int16)v292, 1 - (unsigned __int16)v292);
            }
            else
            {
              if (*((void *)&v292 + 1)) {
                char v23 = (char *)(*((void *)&v292 + 1) + 1);
              }
              else {
                char v23 = (char *)&v293 + 1;
              }
              bzero(v23, (unsigned __int16)v292 - 1);
            }
            LOWORD(v292) = 1;
            WORD2(v292) = 0;
          }
          int v25 = (unsigned __int8 *)*((void *)&v292 + 1);
          if (!*((void *)&v292 + 1)) {
            int v25 = (unsigned __int8 *)&v293;
          }
          int v26 = *v25;
          if (*(void *)&buf[8] && buf[6] == 1) {
            free(*(void **)&buf[8]);
          }
          if (v298 && BYTE6(v297) == 1) {
            free(v298);
          }
          if (v26 != 35)
          {
            uint64_t v27 = *(void *)(a1 + 256);
            if (v27) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
            }
            operator new();
          }
        }
        else
        {
          if (*(void *)&buf[8] && buf[6] == 1) {
            free(*(void **)&buf[8]);
          }
          if (v298 && BYTE6(v297) == 1) {
            free(v298);
          }
        }
      }
      if (*((void *)&v292 + 1) && BYTE6(v292) == 1) {
        free(*((void **)&v292 + 1));
      }
    }
  }
  unsigned __int8 v28 = atomic_load(byte_1E9457268);
  if (v28)
  {
    unsigned __int8 v29 = atomic_load(byte_1E94578A0);
    if (v29)
    {
      printf("    Read %d unigrams.  Registered %lu words.", 0, (uint64_t)(*(void *)(*(void *)(a1 + 280) + 8) - **(void **)(a1 + 280)) >> 3);
      putchar(10);
    }
    else
    {
      uint64_t v30 = sub_19E08D084();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = (uint64_t)(*(void *)(*(void *)(a1 + 280) + 8) - **(void **)(a1 + 280)) >> 3;
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2048;
        *(void *)&buf[10] = v31;
        _os_log_impl(&dword_19E038000, v30, OS_LOG_TYPE_DEFAULT, "    Read %d unigrams.  Registered %lu words.", buf, 0x12u);
      }
    }
  }
  if (*(_DWORD *)(a1 + 1880))
  {
    unsigned __int8 v32 = atomic_load(byte_1E9457268);
    if (v32)
    {
      unsigned __int8 v33 = atomic_load(byte_1E94578A0);
      if (v33)
      {
        printf("        Excluded %d 0-frequency neighbor-key macros.", *(_DWORD *)(a1 + 1880));
        putchar(10);
      }
      else
      {
        int v34 = sub_19E08D084();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          int v35 = *(_DWORD *)(a1 + 1880);
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v35;
          _os_log_impl(&dword_19E038000, v34, OS_LOG_TYPE_DEFAULT, "        Excluded %d 0-frequency neighbor-key macros.", buf, 8u);
        }
      }
    }
  }
  unsigned __int8 v36 = atomic_load(byte_1E9457268);
  if (v36)
  {
    unsigned __int8 v37 = atomic_load(byte_1E94578A0);
    if (v37)
    {
      printf("        Merged %d duplicate surface forms.  %d shared sort-key strings remain", 0, *(_DWORD *)(a1 + 1884));
      putchar(10);
    }
    else
    {
      uint64_t v38 = sub_19E08D084();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        int v39 = *(_DWORD *)(a1 + 1884);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v39;
        _os_log_impl(&dword_19E038000, v38, OS_LOG_TYPE_DEFAULT, "        Merged %d duplicate surface forms.  %d shared sort-key strings remain", buf, 0xEu);
      }
    }
  }
  sub_19E0A3B5C(v288);
  memset(buf, 0, sizeof(buf));
  LODWORD(v296) = 1065353216;
  unsigned __int8 v40 = *(uint64_t ***)(a1 + 280);
  unsigned __int8 v41 = *v40;
  unint64_t v42 = v40[1];
  if (*v40 != v42)
  {
    do
    {
      uint64_t v43 = *v41;
      uint64_t v45 = *(unsigned __int16 **)(*v41 + 256);
      unsigned __int8 v44 = *(unsigned __int16 **)(*v41 + 264);
      if (v45 != v44)
      {
        do
        {
          sub_19E0A00E4((uint64_t)buf, v45, v45);
          v45 += 16;
        }
        while (v45 != v44);
        uint64_t v43 = *v41;
      }
      unsigned __int8 v47 = *(unsigned __int16 **)(v43 + 280);
      size_t v46 = *(unsigned __int16 **)(v43 + 288);
      while (v47 != v46)
      {
        sub_19E0A00E4((uint64_t)buf, v47, v47);
        v47 += 16;
      }
      ++v41;
    }
    while (v41 != v42);
    if (*(void *)&buf[24])
    {
      if (*(void *)&buf[24] >= 0xDuLL) {
        __assert_rtn("convert_combining_classes_to_bits", "UnigramsCompiler.cpp", 357, "classes.size() <= Word::MaxCombiningClassCount");
      }
      unsigned __int8 v48 = *(unsigned __int16 **)&buf[16];
      int v298 = 0;
      v299 = 0;
      long long v297 = 0;
      if (*(void *)&buf[16])
      {
        unint64_t v49 = -1;
        uint64_t v50 = *(void **)&buf[16];
        do
        {
          unint64_t v51 = v49;
          uint64_t v50 = (void *)*v50;
          ++v49;
        }
        while (v50);
        *(void *)unsigned int v289 = &v297;
        v289[8] = 0;
        if (v49 >= 0x7FFFFFFFFFFFFFFLL) {
          sub_19E041BEC();
        }
        unsigned __int8 v52 = (unsigned __int16 *)sub_19E08A810(v51 + 2);
        unint64_t v1 = 0;
        long long v297 = v52;
        int v298 = v52;
        v299 = (char *)&v52[16 * v53];
        do
        {
          sub_19E039858((uint64_t)v52 + v1, v48 + 8);
          unsigned __int8 v48 = *(unsigned __int16 **)v48;
          v1 += 32;
        }
        while (v48);
        unint64_t v54 = (unint64_t)v52 + v1;
        uint64_t v55 = v297;
        int v298 = (unsigned __int16 *)((char *)v52 + v1);
      }
      else
      {
        unint64_t v54 = 0;
        uint64_t v55 = 0;
      }
      unint64_t v56 = 126 - 2 * __clz((uint64_t)(v54 - (void)v55) >> 5);
      if ((unsigned __int16 *)v54 == v55) {
        uint64_t v57 = 0;
      }
      else {
        uint64_t v57 = v56;
      }
      sub_19E0A0358(v55, v54, v57, 1);
      long long v292 = 0u;
      long long v293 = 0u;
      float v294 = 1.0;
      uint64_t v59 = v297;
      BOOL v58 = v298;
      if (v298 != v297)
      {
        LODWORD(v6sub_19E060B80(&a9, 0) = 0;
        unint64_t v61 = 0;
        do
        {
          BOOL v62 = &v59[16 * v61];
          if (*((void *)v62 + 1)) {
            uint64_t v63 = (unsigned __int8 *)*((void *)v62 + 1);
          }
          else {
            uint64_t v63 = (unsigned __int8 *)(v62 + 8);
          }
          unsigned int v64 = sub_19E0B24AC(v63, *v62);
          unint64_t v65 = v64;
          unint64_t v66 = *((void *)&v292 + 1);
          if (*((void *)&v292 + 1))
          {
            uint8x8_t v67 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v292 + 8));
            v67.i16[0] = vaddlv_u8(v67);
            unint64_t v68 = v67.u32[0];
            if (v67.u32[0] > 1uLL)
            {
              unint64_t v1 = v64;
              if (*((void *)&v292 + 1) <= (unint64_t)v64) {
                unint64_t v1 = (unint64_t)v64 % *((void *)&v292 + 1);
              }
            }
            else
            {
              unint64_t v1 = (DWORD2(v292) - 1) & v64;
            }
            uint64_t v69 = *(unsigned __int16 ***)(v292 + 8 * v1);
            if (v69)
            {
              for (uint64_t k = *v69; k; uint64_t k = *(unsigned __int16 **)k)
              {
                unint64_t v71 = *((void *)k + 1);
                if (v71 == v65)
                {
                  if (k + 8 == v62 || sub_19E0B2428(k + 8, v62)) {
                    goto LABEL_154;
                  }
                }
                else
                {
                  if (v68 > 1)
                  {
                    if (v71 >= v66) {
                      v71 %= v66;
                    }
                  }
                  else
                  {
                    v71 &= v66 - 1;
                  }
                  if (v71 != v1) {
                    break;
                  }
                }
              }
            }
          }
          int v72 = operator new(0x38uLL);
          *(void *)unsigned int v289 = v72;
          *(void *)&v289[8] = &v293;
          v289[16] = 0;
          void *v72 = 0;
          v72[1] = v65;
          sub_19E039858((uint64_t)(v72 + 2), v62);
          *((_DWORD *)v72 + 12) = v60;
          v289[16] = 1;
          float v73 = (float)(unint64_t)(*((void *)&v293 + 1) + 1);
          if (!v66 || (float)(v294 * (float)v66) < v73)
          {
            BOOL v74 = (v66 & (v66 - 1)) != 0;
            if (v66 < 3) {
              BOOL v74 = 1;
            }
            unint64_t v75 = v74 | (2 * v66);
            unint64_t v76 = vcvtps_u32_f32(v73 / v294);
            if (v75 <= v76) {
              size_t v77 = v76;
            }
            else {
              size_t v77 = v75;
            }
            sub_19E08A5BC((uint64_t)&v292, v77);
            unint64_t v66 = *((void *)&v292 + 1);
            if ((v66 & (v66 - 1)) != 0)
            {
              if (*((void *)&v292 + 1) <= v65) {
                unint64_t v1 = v65 % *((void *)&v292 + 1);
              }
              else {
                unint64_t v1 = v65;
              }
            }
            else
            {
              unint64_t v1 = (DWORD2(v292) - 1) & v65;
            }
          }
          unint64_t v78 = *(void **)(v292 + 8 * v1);
          uint64_t v79 = *(void *)v289;
          if (v78)
          {
            **(void **)unsigned int v289 = *v78;
          }
          else
          {
            **(void **)unsigned int v289 = v293;
            *(void *)&long long v293 = v79;
            *(void *)(v292 + 8 * v1) = &v293;
            if (!*(void *)v79) {
              goto LABEL_153;
            }
            unint64_t v80 = *(void *)(*(void *)v79 + 8);
            if ((v66 & (v66 - 1)) != 0)
            {
              if (v80 >= v66) {
                v80 %= v66;
              }
            }
            else
            {
              v80 &= v66 - 1;
            }
            unint64_t v78 = (void *)(v292 + 8 * v80);
          }
          void *v78 = v79;
LABEL_153:
          *(void *)unsigned int v289 = 0;
          ++*((void *)&v293 + 1);
          sub_19E0A1244((uint64_t *)v289);
          uint64_t v59 = v297;
          BOOL v58 = v298;
LABEL_154:
          unint64_t v60 = (v60 + 1);
          unint64_t v61 = v60;
        }
        while (v60 < ((char *)v58 - (char *)v59) >> 5);
      }
      *(void *)unsigned int v289 = MEMORY[0x1E4F143A8];
      *(void *)&v289[8] = 1174405120;
      *(void *)&v289[16] = sub_19E0A0E7C;
      uint64_t v290 = (uint64_t)&unk_1EF098D78;
      sub_19E0A0F14((uint64_t)v291, (uint64_t)&v292);
      uint64_t v81 = *(uint64_t ***)(a1 + 280);
      uint64_t v82 = *v81;
      uint64_t v83 = v81[1];
      while (v82 != v83)
      {
        uint64_t v84 = *v82;
        *(_DWORD *)(v84 + 56) = *(_DWORD *)(v84 + 56) & 0xFFFFF000 | (*(uint64_t (**)(uint8_t *, uint64_t))&v289[16])(v289, *v82 + 256) & 0xFFF;
        uint64_t v85 = *v82;
        *(_DWORD *)(v85 + 56) = *(_DWORD *)(v85 + 56) & 0xFF000FFF | (((*(uint64_t (**)(uint8_t *, uint64_t))&v289[16])(v289, *v82 + 280) & 0xFFF) << 12);
        uint64_t v86 = *v82;
        uint64_t v87 = *(void *)(*v82 + 256);
        uint64_t v88 = *(void *)(*v82 + 264);
        uint64_t v89 = *v82;
        if (v88 != v87)
        {
          do
          {
            unsigned __int8 v90 = *(void **)(v88 - 24);
            if (v90 && *(unsigned char *)(v88 - 26) == 1) {
              free(v90);
            }
            v88 -= 32;
          }
          while (v88 != v87);
          uint64_t v89 = *v82;
        }
        *(void *)(v86 + 264) = v87;
        uint64_t v91 = *(void *)(v89 + 280);
        for (uint64_t m = *(void *)(v89 + 288); m != v91; m -= 32)
        {
          uint64_t v93 = *(void **)(m - 24);
          if (v93 && *(unsigned char *)(m - 26) == 1) {
            free(v93);
          }
        }
        *(void *)(v89 + 28++**(_DWORD **)(result + 8) = v91;
        ++v82;
      }
      sub_19E0A11D4((uint64_t)v291);
      uint64_t v94 = (void ***)sub_19E0A11D4((uint64_t)&v292);
      *(void *)&long long v292 = &v297;
      sub_19E076F34(v94);
      uint64_t v12 = (uint64_t)byte_1E94578A0;
    }
  }
  sub_19E0A11D4((uint64_t)buf);
  uint64_t v95 = *(void *)(a1 + 240);
  if ((v95 & 0xC00000) != 0)
  {
    unsigned __int8 v96 = atomic_load(byte_1E9457268);
    if (v96)
    {
      unsigned __int8 v97 = atomic_load(byte_1E94578A0);
      if (v97)
      {
        printf("    Calculating emission cost per each head POS");
        putchar(10);
      }
      else
      {
        unsigned int v98 = sub_19E08D084();
        if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unsigned int v289 = 0;
          _os_log_impl(&dword_19E038000, v98, OS_LOG_TYPE_DEFAULT, "    Calculating emission cost per each head POS", v289, 2u);
        }
      }
    }
    *(void *)&v289[8] = 0;
    *(void *)&v289[16] = 0;
    *(void *)unsigned int v289 = &v289[8];
    *(void *)&uint8_t buf[8] = 0;
    *(void *)&uint8_t buf[16] = 0;
    *(void *)buf = &buf[8];
    uint64_t v102 = *(uint64_t **)(a1 + 280);
    uint64_t v103 = *v102;
    uint64_t v104 = v102[1];
    if (*v102 != v104)
    {
      do
      {
        if ((v95 & 0x400000) != 0)
        {
          int v105 = *(unsigned __int16 *)(*(void *)v103 + 76);
          double v106 = *(double *)(*(void *)v103 + 88);
          LODWORD(v292) = v105;
          uint64_t v107 = sub_19E09FED0((uint64_t **)v289, v105, &v292);
          *((double *)v107 + 5) = v106 + *((double *)v107 + 5);
        }
        if ((v95 & 0x800000) != 0)
        {
          double v108 = *(double *)(*(void *)v103 + 88);
          LODWORD(v292) = HIWORD(*(_DWORD *)(*(void *)v103 + 76));
          unsigned __int8 v109 = sub_19E09FED0((uint64_t **)buf, v292, &v292);
          *((double *)v109 + 5) = v108 + *((double *)v109 + 5);
        }
        v103 += 8;
      }
      while (v103 != v104);
      uint64_t v110 = *(uint64_t ***)(a1 + 280);
      uint64_t v111 = *v110;
      unint64_t v112 = v110[1];
      if (*v110 != v112)
      {
        uint64_t v12 = -32768;
        while (1)
        {
          uint64_t v113 = *v111;
          unsigned int v114 = *(_DWORD *)(*v111 + 76);
          if (((v95 & 0x400000) == 0 || (unsigned __int16)*(_DWORD *)(*v111 + 76))
            && ((v95 & 0x800000) == 0 || v114 >= 0x10000))
          {
            break;
          }
          LOWORD(v115) = 0x7FFF;
LABEL_210:
          *(_WORD *)(v113 + 8sub_19E060B80(&a9, 0) = v115;
          if (++v111 == v112) {
            goto LABEL_211;
          }
        }
        if ((v95 & 0x400000) != 0)
        {
          LODWORD(v292) = (unsigned __int16)*(_DWORD *)(*v111 + 76);
          unsigned __int8 v116 = sub_19E09FED0((uint64_t **)v289, (unsigned __int16)v114, &v292);
          uint64_t v113 = *v111;
          uint64_t v117 = llround((log(*(double *)(*v111 + 88) / *((double *)v116 + 5)) + -0.0001) * (double)-*(__int16 *)(a1 + 1976));
          if ((v95 & 0x800000) == 0)
          {
LABEL_205:
            if (v117 >= 0x7FFF) {
              uint64_t v115 = 0x7FFFLL;
            }
            else {
              uint64_t v115 = v117;
            }
            if (v115 <= -32768) {
              LOWORD(v115) = 0x8000;
            }
            goto LABEL_210;
          }
        }
        else
        {
          uint64_t v117 = 0;
          if ((v95 & 0x800000) == 0) {
            goto LABEL_205;
          }
        }
        LODWORD(v292) = HIWORD(v114);
        uint64_t v118 = sub_19E09FED0((uint64_t **)buf, HIWORD(v114), &v292);
        uint64_t v113 = *v111;
        v117 += llround((log(*(double *)(*v111 + 88) / *((double *)v118 + 5)) + -0.0001) * (double)-*(__int16 *)(a1 + 1976));
        if ((v95 & 0xC00000) == 0xC00000)
        {
          if (v117 >= 0) {
            uint64_t v119 = v117;
          }
          else {
            uint64_t v119 = v117 + 1;
          }
          uint64_t v117 = v119 >> 1;
        }
        goto LABEL_205;
      }
    }
LABEL_211:
    sub_19E09FFA0(*(void **)&buf[8]);
    sub_19E09FFA0(*(void **)&v289[8]);
  }
  else
  {
    *(void *)&v289[8] = 0;
    *(void *)&v289[16] = 0;
    *(void *)unsigned int v289 = &v289[8];
    unsigned __int8 v99 = atomic_load(byte_1E9457268);
    if (v99)
    {
      unsigned __int8 v100 = atomic_load(byte_1E94578A0);
      if (v100)
      {
        printf("    Calculating emission cost per Head/Tail POS");
        putchar(10);
      }
      else
      {
        unint64_t v101 = sub_19E08D084();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_19E038000, v101, OS_LOG_TYPE_DEFAULT, "    Calculating emission cost per Head/Tail POS", buf, 2u);
        }
      }
    }
    unint64_t v120 = *(uint64_t **)(a1 + 280);
    uint64_t v121 = *v120;
    uint64_t v122 = v120[1];
    if (*v120 != v122)
    {
      do
      {
        int v123 = HIWORD(*(_DWORD *)(*(void *)v121 + 76));
        double v124 = *(double *)(*(void *)v121 + 88);
        int v125 = (unsigned __int16)*(_DWORD *)(*(void *)v121 + 76);
        *(_DWORD *)buf = v125;
        *(_DWORD *)&uint8_t buf[4] = v123;
        unint64_t v126 = sub_19E09FFEC((uint64_t **)v289, v125, v123, (uint64_t **)buf);
        *((double *)v126 + 5) = v124 + *((double *)v126 + 5);
        v121 += 8;
      }
      while (v121 != v122);
      uint64_t v127 = *(uint64_t ***)(a1 + 280);
      v128 = *v127;
      long long v129 = v127[1];
      if (*v127 != v129)
      {
        do
        {
          uint64_t v130 = *v128;
          unsigned int v131 = *(_DWORD *)(*v128 + 76);
          if (v131 < 0x10000 || (unsigned __int16)v131 == 0)
          {
            LOWORD(v133) = 0x7FFF;
          }
          else
          {
            *(_DWORD *)buf = (unsigned __int16)*(_DWORD *)(*v128 + 76);
            *(_DWORD *)&uint8_t buf[4] = HIWORD(v131);
            uint64_t v134 = sub_19E09FFEC((uint64_t **)v289, (unsigned __int16)v131, HIWORD(v131), (uint64_t **)buf);
            uint64_t v130 = *v128;
            float v135 = *(double *)(*v128 + 88);
            uint64_t v133 = llround((log(v135 / *((double *)v134 + 5)) + -0.0001) * (double)-*(__int16 *)(a1 + 1976));
            if (v133 <= -32768) {
              uint64_t v133 = -32768;
            }
            if (v133 >= 0x7FFF) {
              LOWORD(v133) = 0x7FFF;
            }
          }
          *(_WORD *)(v130 + 8sub_19E060B80(&a9, 0) = v133;
          ++v128;
        }
        while (v128 != v129);
      }
    }
    sub_19E09FFA0(*(void **)&v289[8]);
  }
  uint64_t v136 = **(void **)(a1 + 280);
  uint64_t v137 = *(void *)(*(void *)(a1 + 280) + 8) - v136;
  if (v137)
  {
    uint64_t v138 = 0;
    unint64_t v139 = v137 >> 3;
    double v140 = 0.0;
    double v141 = 0.0;
    do
    {
      double v142 = *(double *)(*(void *)(v136 + 8 * v138) + 88);
      if (v142 > 0.0)
      {
        if (v142 < v140 || v140 <= 0.0) {
          double v140 = *(double *)(*(void *)(v136 + 8 * v138) + 88);
        }
        if (v142 > v141) {
          double v141 = *(double *)(*(void *)(v136 + 8 * v138) + 88);
        }
      }
      ++v138;
    }
    while (v139 > v138);
    uint64_t v144 = 0;
    double v145 = 0.0;
    do
    {
      uint64_t v146 = *(void *)(v136 + 8 * v144);
      double v147 = *(double *)(v146 + 88);
      if ((v147 < v145 || v145 <= 0.0) && v147 > v140) {
        double v145 = *(double *)(v146 + 88);
      }
      ++v144;
    }
    while (v139 > v144);
  }
  else
  {
    double v140 = 0.0;
    double v141 = 0.0;
    double v145 = 0.0;
  }
  unsigned __int8 v150 = atomic_load(byte_1E9457268);
  if (v150)
  {
    unsigned __int8 v151 = atomic_load(byte_1E94578A0);
    if (v151)
    {
      printf("    Frequency distribution:  Lowest=%lf, NextLowest=%lf, Highest=%lf", v140, v145, v141);
      putchar(10);
    }
    else
    {
      unint64_t v152 = sub_19E08D084();
      if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unsigned int v289 = 134218496;
        *(double *)&v289[4] = v140;
        *(_WORD *)&v289[12] = 2048;
        *(double *)&v289[14] = v145;
        *(_WORD *)&v289[22] = 2048;
        uint64_t v290 = *(void *)&v141;
        _os_log_impl(&dword_19E038000, v152, OS_LOG_TYPE_DEFAULT, "    Frequency distribution:  Lowest=%lf, NextLowest=%lf, Highest=%lf", v289, 0x20u);
      }
    }
  }
  if (v140 != 1.0 || v145 != 2.0)
  {
    double v153 = 2.0;
    if (v145 > 2.0) {
      double v153 = 2.0 / v145 + 1.0;
    }
    uint64_t v154 = **(void **)(a1 + 280);
    uint64_t v155 = *(void *)(*(void *)(a1 + 280) + 8);
    uint64_t v156 = v155 - v154;
    if (v155 != v154)
    {
      uint64_t v157 = 0;
      unint64_t v158 = v156 >> 3;
      while (1)
      {
        uint64_t v159 = *(void *)(v154 + 8 * v157);
        double v160 = *(double *)(v159 + 88);
        if (v160 == v140) {
          break;
        }
        double v161 = v153;
        if (v160 == v145) {
          goto LABEL_268;
        }
        if (v145 > 0.0)
        {
          double v161 = v153 * v160 / v145;
LABEL_268:
          *(double *)(v159 + 8++**(_DWORD **)(result + 8) = v161;
        }
LABEL_269:
        if (v158 <= ++v157) {
          goto LABEL_270;
        }
      }
      double v161 = 1.0;
      if (v140 == 1.0) {
        goto LABEL_269;
      }
      goto LABEL_268;
    }
LABEL_270:
    if (v145 > 0.0) {
      double v141 = v141 * v153 / v145;
    }
  }
  if (v141 > 65000.0)
  {
    double v162 = log(v141);
    unsigned __int8 v163 = atomic_load(byte_1E9457268);
    double v164 = 11.0821425 / v162;
    if (v163)
    {
      unsigned __int8 v165 = atomic_load(byte_1E94578A0);
      if (v165)
      {
        printf("Squashing with root power %.3lf to achieve frequency target range %.0f to %.0f", 11.0821425 / v162, 1.0, 65000.0);
        putchar(10);
      }
      else
      {
        long long v166 = sub_19E08D084();
        if (os_log_type_enabled(v166, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unsigned int v289 = 134218496;
          *(double *)&v289[4] = v164;
          *(_WORD *)&v289[12] = 2048;
          *(void *)&v289[14] = 0x3FF0000000000000;
          *(_WORD *)&v289[22] = 2048;
          uint64_t v290 = 0x40EFBD0000000000;
          _os_log_impl(&dword_19E038000, v166, OS_LOG_TYPE_DEFAULT, "Squashing with root power %.3lf to achieve frequency target range %.0f to %.0f", v289, 0x20u);
        }
      }
    }
    uint64_t v167 = *(uint64_t **)(a1 + 280);
    uint64_t v168 = *v167;
    uint64_t v169 = v167[1] - *v167;
    if (v169)
    {
      uint64_t v170 = 0;
      unint64_t v171 = v169 >> 3;
      do
      {
        uint64_t v172 = *(void *)(v168 + 8 * v170);
        *(long double *)(v172 + 8++**(_DWORD **)(result + 8) = pow(*(long double *)(v172 + 88), v164);
        ++v170;
      }
      while (v171 > v170);
    }
  }
  sub_19E09D7D8(a1);
  unint64_t v173 = *(uint64_t **)(a1 + 280);
  uint64_t v175 = *v173;
  uint64_t v174 = v173[1];
  if (*v173 == v174) {
    goto LABEL_363;
  }
  uint64_t v176 = (void ****)(a1 + 1776);
  uint64_t v177 = (void **)(a1 + 1792);
  uint64_t v286 = v173[1];
  do
  {
    uint64_t v178 = *(unsigned __int16 **)v175;
    if (*(unsigned char *)(*(void *)v175 + 304)) {
      goto LABEL_362;
    }
    if (*(void *)(a1 + 1840)) {
      __assert_rtn("train", "TIHuffmanCoder.cpp", 73, "!is_compiled()");
    }
    uint64_t v179 = (unsigned __int16 *)*((void *)v178 + 1);
    if (!v179) {
      uint64_t v179 = v178 + 8;
    }
    *(void *)unsigned int v289 = v179;
    *(_DWORD *)&v289[8] = 0;
    *(_DWORD *)&v289[12] = *v178;
    *(_DWORD *)&v289[16] = 0;
    sub_19E03E768((uint64_t *)v289);
    int v180 = *v178;
    unint64_t v181 = (unsigned __int16 *)*((void *)v178 + 1);
    if (!v181) {
      unint64_t v181 = v178 + 8;
    }
    *(void *)buf = v181;
    *(_DWORD *)&uint8_t buf[8] = v180;
    *(_DWORD *)&buf[12] = v180;
    *(_DWORD *)&uint8_t buf[16] = 0;
    sub_19E03E768((uint64_t *)buf);
    uint64_t v182 = *(void *)v289;
    if (*(void *)v289 != *(void *)buf) {
LABEL_526:
    }
      __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
    int v183 = *(_DWORD *)&buf[8];
    while (*(_DWORD *)&v289[8] != v183)
    {
      unint64_t v184 = *(unsigned int *)&v289[16];
      unint64_t v185 = *(void *)(a1 + 1784);
      if (v185)
      {
        uint8x8_t v186 = (uint8x8_t)vcnt_s8((int8x8_t)v185);
        v186.i16[0] = vaddlv_u8(v186);
        if (v186.u32[0] > 1uLL)
        {
          uint64_t v12 = *(unsigned int *)&v289[16];
          if (v185 <= *(unsigned int *)&v289[16]) {
            uint64_t v12 = *(unsigned int *)&v289[16] % v185;
          }
        }
        else
        {
          uint64_t v12 = (v185 - 1) & *(_DWORD *)&v289[16];
        }
        unsigned __int8 v187 = (*v176)[v12];
        if (v187)
        {
          int v188 = *v187;
          if (*v187)
          {
            do
            {
              unint64_t v189 = v188[1];
              if (v189 == *(unsigned int *)&v289[16])
              {
                if (*((_DWORD *)v188 + 4) == *(_DWORD *)&v289[16]) {
                  goto LABEL_329;
                }
              }
              else
              {
                if (v186.u32[0] > 1uLL)
                {
                  if (v189 >= v185) {
                    v189 %= v185;
                  }
                }
                else
                {
                  v189 &= v185 - 1;
                }
                if (v189 != v12) {
                  break;
                }
              }
              int v188 = (void *)*v188;
            }
            while (v188);
          }
        }
      }
      int v188 = operator new(0x18uLL);
      void *v188 = 0;
      v188[1] = v184;
      float v190 = (float)(unint64_t)(*(void *)(a1 + 1800) + 1);
      *((_DWORD *)v188 + 4) = v184;
      *((_DWORD *)v188 + 5) = 0;
      float v191 = *(float *)(a1 + 1808);
      if ((((float)(v191 * (float)v185) >= v190) & ~(v185 == 0)) == 0)
      {
        BOOL v192 = (v185 & (v185 - 1)) != 0;
        if (v185 < 3) {
          BOOL v192 = 1;
        }
        unint64_t v193 = v192 | (2 * v185);
        unint64_t v194 = vcvtps_u32_f32(v190 / v191);
        if (v193 <= v194) {
          size_t v195 = v194;
        }
        else {
          size_t v195 = v193;
        }
        sub_19E08A5BC((uint64_t)v176, v195);
        unint64_t v185 = *(void *)(a1 + 1784);
        if ((v185 & (v185 - 1)) != 0)
        {
          if (v185 <= v184) {
            uint64_t v12 = v184 % v185;
          }
          else {
            uint64_t v12 = v184;
          }
        }
        else
        {
          uint64_t v12 = (v185 - 1) & v184;
        }
      }
      uint64_t v196 = *v176;
      uint64_t v197 = (void ***)(*v176)[v12];
      if (v197)
      {
        void *v188 = *v197;
      }
      else
      {
        void *v188 = *v177;
        *uint64_t v177 = v188;
        v196[v12] = v177;
        if (!*v188) {
          goto LABEL_328;
        }
        unint64_t v198 = *(void *)(*v188 + 8);
        if ((v185 & (v185 - 1)) != 0)
        {
          if (v198 >= v185) {
            v198 %= v185;
          }
        }
        else
        {
          v198 &= v185 - 1;
        }
        uint64_t v197 = &(*v176)[v198];
      }
      *uint64_t v197 = (void **)v188;
LABEL_328:
      ++*(void *)(a1 + 1800);
LABEL_329:
      ++*((_DWORD *)v188 + 5);
      sub_19E03E768((uint64_t *)v289);
      if (*(void *)v289 != v182) {
        goto LABEL_526;
      }
    }
    unint64_t v199 = *(void *)(a1 + 1784);
    if (v199)
    {
      uint64_t v200 = **v176;
      if (v200)
      {
        unint64_t v201 = *v200;
        if (*v200)
        {
          uint8x8_t v202 = (uint8x8_t)vcnt_s8((int8x8_t)v199);
          v202.i16[0] = vaddlv_u8(v202);
          do
          {
            unint64_t v203 = v201[1];
            if (v203)
            {
              if (v202.u32[0] > 1uLL)
              {
                if (v203 < v199 || v203 % v199) {
                  break;
                }
              }
              else if ((v203 & (v199 - 1)) != 0)
              {
                break;
              }
            }
            else if (!*((_DWORD *)v201 + 4))
            {
              uint64_t v213 = a1;
              goto LABEL_361;
            }
            unint64_t v201 = (void *)*v201;
          }
          while (v201);
        }
      }
    }
    unint64_t v201 = operator new(0x18uLL);
    *unint64_t v201 = 0;
    v201[1] = 0;
    float v204 = (float)(unint64_t)(*(void *)(a1 + 1800) + 1);
    v201[2] = 0;
    float v205 = *(float *)(a1 + 1808);
    if ((((float)(v205 * (float)v199) >= v204) & ~(v199 == 0)) == 0)
    {
      BOOL v206 = (v199 & (v199 - 1)) != 0;
      if (v199 < 3) {
        BOOL v206 = 1;
      }
      unint64_t v207 = v206 | (2 * v199);
      unint64_t v208 = vcvtps_u32_f32(v204 / v205);
      if (v207 <= v208) {
        size_t v209 = v208;
      }
      else {
        size_t v209 = v207;
      }
      sub_19E08A5BC((uint64_t)v176, v209);
      unint64_t v199 = *(void *)(a1 + 1784);
    }
    v210 = *v176;
    uint64_t v211 = **v176;
    if (v211)
    {
      *unint64_t v201 = *v211;
      goto LABEL_359;
    }
    *unint64_t v201 = *v177;
    *uint64_t v177 = v201;
    void *v210 = v177;
    if (*v201)
    {
      unint64_t v212 = *(void *)(*v201 + 8);
      if ((v199 & (v199 - 1)) != 0)
      {
        if (v212 >= v199) {
          v212 %= v199;
        }
      }
      else
      {
        v212 &= v199 - 1;
      }
      uint64_t v211 = (void **)&(*v176)[v212];
LABEL_359:
      void *v211 = v201;
    }
    uint64_t v213 = a1;
    ++*(void *)(a1 + 1800);
LABEL_361:
    ++*((_DWORD *)v201 + 5);
    (*(void (**)(void, void))(**(void **)(v213 + 264) + 16))(*(void *)(v213 + 264), *(unsigned int *)(*(void *)v175 + 36));
    uint64_t v174 = v286;
LABEL_362:
    v175 += 8;
  }
  while (v175 != v174);
LABEL_363:
  if (*(void *)(a1 + 1840)) {
    __assert_rtn("compile", "TIHuffmanCoder.cpp", 128, "!is_compiled()");
  }
  if (*(void *)(a1 + 1800) <= 1uLL) {
    __assert_rtn("compile", "TIHuffmanCoder.cpp", 129, "m_freq_table.size() >= 2");
  }
  memset(buf, 0, 24);
  unint64_t v214 = *(uint64_t **)(a1 + 1792);
  if (v214)
  {
    do
    {
      int v215 = *((_DWORD *)v214 + 4);
      int v216 = *((_DWORD *)v214 + 5);
      uint64_t v175 = *(void *)&buf[8];
      if (*(void *)&buf[8] >= *(void *)&buf[16])
      {
        uint64_t v175 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 5;
        if ((unint64_t)(v175 + 1) >> 59) {
          sub_19E041BEC();
        }
        unint64_t v218 = (uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 4;
        if (v218 <= v175 + 1) {
          unint64_t v218 = v175 + 1;
        }
        if (*(void *)&buf[16] - *(void *)buf >= 0x7FFFFFFFFFFFFFE0uLL) {
          unint64_t v219 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v219 = v218;
        }
        v291[0] = &buf[16];
        if (v219) {
          unint64_t v219 = (unint64_t)sub_19E08A810(v219);
        }
        else {
          uint64_t v220 = 0;
        }
        *(void *)unsigned int v289 = v219;
        *(void *)&v289[8] = v219 + 32 * v175;
        *(void *)&v289[16] = *(void *)&v289[8];
        uint64_t v290 = v219 + 32 * v220;
        sub_19E08A7B8(*(uint64_t *)&v289[8], v215, v216);
        *(void *)&v289[16] += 32;
        sub_19E08A848((uint64_t *)buf, v289);
        uint64_t v217 = *(void *)&buf[8];
        sub_19E08A8DC((uint64_t)v289);
      }
      else
      {
        sub_19E08A7B8(*(uint64_t *)&buf[8], *((_DWORD *)v214 + 4), *((_DWORD *)v214 + 5));
        uint64_t v217 = v175 + 32;
      }
      *(void *)&uint8_t buf[8] = v217;
      sub_19E08A940(*(uint64_t *)buf, v217, (v217 - *(void *)buf) >> 5);
      unint64_t v214 = (uint64_t *)*v214;
    }
    while (v214);
    uint64_t v222 = *(void *)buf;
    uint64_t v221 = *(void *)&buf[8];
  }
  else
  {
    uint64_t v222 = 0;
    uint64_t v221 = 0;
  }
  uint64_t v223 = v221 - v222;
  if ((unint64_t)(v221 - v222) >= 0x21)
  {
    uint64_t v175 = (uint64_t)&buf[16];
    do
    {
      long long v292 = 0uLL;
      *(void *)&long long v293 = 0;
      sub_19E08AA30((char *)&v292, *(uint64_t **)v222, *(uint64_t **)(v222 + 8), (uint64_t)(*(void *)(v222 + 8) - *(void *)v222) >> 3);
      DWORD2(v293) = *(_DWORD *)(v222 + 24);
      sub_19E08AAA4(*(uint64_t *)buf, *(uint64_t *)&buf[8], (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 5);
      uint64_t v225 = *(void *)&buf[8] - 32;
      unsigned int v224 = *(void **)(*(void *)&buf[8] - 32);
      if (v224)
      {
        *(void *)(*(void *)&buf[8] - 24) = v224;
        operator delete(v224);
      }
      *(void *)&uint8_t buf[8] = v225;
      uint64_t v226 = *(void *)buf;
      int v298 = 0;
      v299 = 0;
      long long v297 = 0;
      sub_19E08AA30((char *)&v297, **(uint64_t ***)buf, *(uint64_t **)(*(void *)buf + 8), (uint64_t)(*(void *)(*(void *)buf + 8) - **(void **)buf) >> 3);
      int v300 = *(_DWORD *)(v226 + 24);
      sub_19E08AAA4(*(uint64_t *)buf, *(uint64_t *)&buf[8], (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 5);
      uint64_t v227 = *(void *)&buf[8];
      BOOL v229 = (char **)(*(void *)&buf[8] - 32);
      int v228 = *(void **)(*(void *)&buf[8] - 32);
      if (v228)
      {
        *(void *)(*(void *)&buf[8] - 24) = v228;
        operator delete(v228);
      }
      *(void *)&uint8_t buf[8] = v229;
      if ((unint64_t)v229 >= *(void *)&buf[16])
      {
        uint64_t v230 = ((uint64_t)v229 - *(void *)buf) >> 5;
        if ((unint64_t)(v230 + 1) >> 59) {
          sub_19E041BEC();
        }
        unint64_t v231 = (uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 4;
        if (v231 <= v230 + 1) {
          unint64_t v231 = v230 + 1;
        }
        if (*(void *)&buf[16] - *(void *)buf >= 0x7FFFFFFFFFFFFFE0uLL) {
          unint64_t v232 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v232 = v231;
        }
        v291[0] = &buf[16];
        if (v232) {
          unint64_t v232 = (unint64_t)sub_19E08A810(v232);
        }
        else {
          uint64_t v233 = 0;
        }
        *(void *)unsigned int v289 = v232;
        *(void *)&v289[8] = v232 + 32 * v230;
        *(void *)&v289[16] = *(void *)&v289[8];
        uint64_t v290 = v232 + 32 * v233;
        sub_19E08BED8(*(char ***)&v289[8], (uint64_t)&v292, (uint64_t)&v297);
        *(void *)&v289[16] += 32;
        sub_19E08A848((uint64_t *)buf, v289);
        uint64_t v227 = *(void *)&buf[8];
        sub_19E08A8DC((uint64_t)v289);
      }
      else
      {
        sub_19E08BED8(v229, (uint64_t)&v292, (uint64_t)&v297);
      }
      *(void *)&uint8_t buf[8] = v227;
      sub_19E08A940(*(uint64_t *)buf, v227, (v227 - *(void *)buf) >> 5);
      if (v297) {
        operator delete(v297);
      }
      if ((void)v292)
      {
        *((void *)&v292 + 1) = v292;
        operator delete((void *)v292);
      }
      uint64_t v222 = *(void *)buf;
      uint64_t v221 = *(void *)&buf[8];
      uint64_t v223 = *(void *)&buf[8] - *(void *)buf;
    }
    while (*(void *)&buf[8] - *(void *)buf > 0x20uLL);
  }
  if (v223 != 32) {
    __assert_rtn("compile", "TIHuffmanCoder.cpp", 145, "queue.size() == 1");
  }
  if (a1 + 1856 != v222)
  {
    sub_19E08AB88((void *)(a1 + 1856), *(uint64_t **)v222, *(uint64_t **)(v222 + 8), (uint64_t)(*(void *)(v222 + 8) - *(void *)v222) >> 3);
    uint64_t v222 = *(void *)buf;
    uint64_t v221 = *(void *)&buf[8];
  }
  sub_19E08AAA4(v222, v221, (v221 - v222) >> 5);
  uint64_t v235 = *(void *)&buf[8] - 32;
  int v234 = *(void **)(*(void *)&buf[8] - 32);
  if (v234)
  {
    *(void *)(*(void *)&buf[8] - 24) = v234;
    operator delete(v234);
  }
  uint64_t v236 = *(void *)(a1 + 1856);
  std::string::value_type v237 = *(int **)(a1 + 1864);
  unint64_t v238 = 126 - 2 * __clz(((uint64_t)v237 - v236) >> 3);
  *(void *)&uint8_t buf[8] = v235;
  *(void *)unsigned int v289 = &unk_1EF098F48;
  if (v237 == (int *)v236) {
    uint64_t v239 = 0;
  }
  else {
    uint64_t v239 = v238;
  }
  sub_19E08ACC0(v236, v237, (uint64_t)v289, v239, 1);
  memset(v289, 0, sizeof(v289));
  BOOL v240 = *(unsigned int **)(a1 + 1856);
  std::string::value_type v241 = *(unsigned int **)(a1 + 1864);
  if (v240 != v241)
  {
    unint64_t v242 = 0;
    unsigned int v243 = (void *)(a1 + 1832);
    while (1)
    {
      unint64_t v245 = *v240;
      unint64_t v244 = v240[1];
      while (v242 < v244)
      {
        LOBYTE(v292) = 0;
        sub_19E08B608((uint64_t)v289, &v292);
        unint64_t v242 = *(void *)&v289[8];
      }
      unint64_t v246 = *(void *)(a1 + 1824);
      if (v246)
      {
        uint8x8_t v247 = (uint8x8_t)vcnt_s8((int8x8_t)v246);
        v247.i16[0] = vaddlv_u8(v247);
        if (v247.u32[0] > 1uLL)
        {
          uint64_t v175 = v245;
          if (v246 <= v245) {
            uint64_t v175 = v245 % v246;
          }
        }
        else
        {
          uint64_t v175 = (v246 - 1) & v245;
        }
        unsigned int v248 = *(void ***)(*(void *)(a1 + 1816) + 8 * v175);
        if (v248)
        {
          int v249 = (char *)*v248;
          if (*v248)
          {
            do
            {
              unint64_t v250 = *((void *)v249 + 1);
              if (v250 == v245)
              {
                if (*((_DWORD *)v249 + 4) == v245) {
                  goto LABEL_489;
                }
              }
              else
              {
                if (v247.u32[0] > 1uLL)
                {
                  if (v250 >= v246) {
                    v250 %= v246;
                  }
                }
                else
                {
                  v250 &= v246 - 1;
                }
                if (v250 != v175) {
                  break;
                }
              }
              int v249 = *(char **)v249;
            }
            while (v249);
          }
        }
      }
      int v249 = (char *)operator new(0x30uLL);
      *(void *)int v249 = 0;
      *((void *)v249 + 1) = v245;
      *((_DWORD *)v249 + 4) = v245;
      *((void *)v249 + 3) = 0;
      *((void *)v249 + 4) = 0;
      *((void *)v249 + 5) = 0;
      float v251 = (float)(unint64_t)(*(void *)(a1 + 1840) + 1);
      float v252 = *(float *)(a1 + 1848);
      if (v246 && (float)(v252 * (float)v246) >= v251)
      {
        unint64_t v245 = v175;
        goto LABEL_479;
      }
      BOOL v253 = (v246 & (v246 - 1)) != 0;
      if (v246 < 3) {
        BOOL v253 = 1;
      }
      unint64_t v254 = v253 | (2 * v246);
      unint64_t v255 = vcvtps_u32_f32(v251 / v252);
      if (v254 <= v255) {
        int8x8_t prime = (int8x8_t)v255;
      }
      else {
        int8x8_t prime = (int8x8_t)v254;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v246 = *(void *)(a1 + 1824);
      }
      if (*(void *)&prime <= v246)
      {
        if (*(void *)&prime >= v246) {
          goto LABEL_475;
        }
        unint64_t v263 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 1840) / *(float *)(a1 + 1848));
        if (v246 < 3 || (uint8x8_t v264 = (uint8x8_t)vcnt_s8((int8x8_t)v246), v264.i16[0] = vaddlv_u8(v264), v264.u32[0] > 1uLL))
        {
          unint64_t v263 = std::__next_prime(v263);
        }
        else
        {
          uint64_t v265 = 1 << -(char)__clz(v263 - 1);
          if (v263 >= 2) {
            unint64_t v263 = v265;
          }
        }
        if (*(void *)&prime <= v263) {
          int8x8_t prime = (int8x8_t)v263;
        }
        if (*(void *)&prime >= v246)
        {
          unint64_t v246 = *(void *)(a1 + 1824);
          goto LABEL_475;
        }
        if (!*(void *)&prime)
        {
          unsigned int v273 = *(void **)(a1 + 1816);
          *(void *)(a1 + 1816) = 0;
          if (v273) {
            operator delete(v273);
          }
          unint64_t v246 = 0;
          *(void *)(a1 + 1824) = 0;
          goto LABEL_475;
        }
      }
      if (*(void *)&prime >> 61) {
        sub_19E0416C4();
      }
      v257 = operator new(8 * *(void *)&prime);
      uint64_t v258 = *(void **)(a1 + 1816);
      *(void *)(a1 + 1816) = v257;
      if (v258) {
        operator delete(v258);
      }
      uint64_t v259 = 0;
      *(int8x8_t *)(a1 + 1824) = prime;
      do
        *(void *)(*(void *)(a1 + 1816) + 8 * v259++) = 0;
      while (*(void *)&prime != v259);
      uint64_t v260 = (void *)*v243;
      if (*v243)
      {
        unint64_t v261 = v260[1];
        uint8x8_t v262 = (uint8x8_t)vcnt_s8(prime);
        v262.i16[0] = vaddlv_u8(v262);
        if (v262.u32[0] > 1uLL)
        {
          if (v261 >= *(void *)&prime) {
            v261 %= *(void *)&prime;
          }
        }
        else
        {
          v261 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)(a1 + 1816) + 8 * v261) = v243;
        off_t v266 = (void *)*v260;
        if (*v260)
        {
          do
          {
            unint64_t v267 = v266[1];
            if (v262.u32[0] > 1uLL)
            {
              if (v267 >= *(void *)&prime) {
                v267 %= *(void *)&prime;
              }
            }
            else
            {
              v267 &= *(void *)&prime - 1;
            }
            if (v267 != v261)
            {
              uint64_t v268 = *(void *)(a1 + 1816);
              if (!*(void *)(v268 + 8 * v267))
              {
                *(void *)(v268 + 8 * v267) = v260;
                goto LABEL_471;
              }
              void *v260 = *v266;
              void *v266 = **(void **)(*(void *)(a1 + 1816) + 8 * v267);
              **(void **)(*(void *)(a1 + 1816) + 8 * v267) = v266;
              off_t v266 = v260;
            }
            unint64_t v267 = v261;
LABEL_471:
            uint64_t v260 = v266;
            off_t v266 = (void *)*v266;
            unint64_t v261 = v267;
          }
          while (v266);
        }
      }
      unint64_t v246 = (unint64_t)prime;
LABEL_475:
      if ((v246 & (v246 - 1)) != 0)
      {
        if (v246 <= v245) {
          v245 %= v246;
        }
      }
      else
      {
        unint64_t v245 = (v246 - 1) & v245;
      }
LABEL_479:
      uint64_t v269 = *(void *)(a1 + 1816);
      unsigned int v270 = *(void **)(v269 + 8 * v245);
      if (v270)
      {
        *(void *)int v249 = *v270;
      }
      else
      {
        *(void *)int v249 = *v243;
        void *v243 = v249;
        *(void *)(v269 + 8 * v245) = v243;
        if (!*(void *)v249) {
          goto LABEL_488;
        }
        unint64_t v271 = *(void *)(*(void *)v249 + 8);
        if ((v246 & (v246 - 1)) != 0)
        {
          if (v271 >= v246) {
            v271 %= v246;
          }
        }
        else
        {
          v271 &= v246 - 1;
        }
        unsigned int v270 = (void *)(*(void *)(a1 + 1816) + 8 * v271);
      }
      void *v270 = v249;
LABEL_488:
      ++*(void *)(a1 + 1840);
LABEL_489:
      if (v242)
      {
        unint64_t v272 = (void **)(v249 + 24);
        if (v242 > *((void *)v249 + 5) << 6)
        {
          if (*v272)
          {
            operator delete(*v272);
            void *v272 = 0;
            *((void *)v249 + 4) = 0;
            *((void *)v249 + 5) = 0;
          }
          sub_19E08B8B0((void *)v249 + 3, v242);
          unint64_t v242 = *(void *)&v289[8];
        }
        uint64_t v175 = *(void *)v289;
        memmove(*v272, *(const void **)v289, (((v242 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8) + 8);
      }
      else
      {
        uint64_t v175 = *(void *)v289;
      }
      *((void *)v249 + 4) = v242;
      sub_19E08B7DC(v175, v242);
      v240 += 2;
      if (v240 == v241)
      {
        unsigned int v274 = (unint64_t *)v175;
        unint64_t v275 = *(void *)&v289[8];
        if (*(void *)&v289[8] < 0x40uLL)
        {
LABEL_511:
          if (v275)
          {
            int v276 = __clz(__rbit64(*v274 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v275)));
            if ((*v274 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v275)) != 0) {
              LODWORD(v275) = v276;
            }
          }
        }
        else
        {
          unsigned int v274 = (unint64_t *)v175;
          unint64_t v275 = *(void *)&v289[8];
          while (!*v274)
          {
            ++v274;
            v275 -= 64;
            if (v275 <= 0x3F) {
              goto LABEL_511;
            }
          }
          LODWORD(v275) = __clz(__rbit64(*v274));
        }
        if (v274 != (unint64_t *)(v175 + 8 * (*(void *)&v289[8] >> 6)) || (v289[8] & 0x3F) != v275) {
          __assert_rtn("compile", "TIHuffmanCoder.cpp", 169, "std::find(cur_word.begin(), cur_word.end(), true) == cur_word.end()");
        }
        if (v175) {
          operator delete((void *)v175);
        }
        break;
      }
    }
  }
  *(void *)unsigned int v289 = buf;
  sub_19E08B820((void ***)v289);
  v278 = *(uint64_t (**)(void))(**(void **)(a1 + 264) + 32);

  return v278();
}

void sub_19E098B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a15) {
    sub_19E076BBC((atomic_uint *)(a15 + 24));
  }
  sub_19E076DB4(a17 + 84);
  uint64_t v45 = *(void **)(v43 - 248);
  if (v45)
  {
    if (*(unsigned char *)(v43 - 250) == 1) {
      free(v45);
    }
  }
  sub_19E0A3B5C(&a25);
  _Unwind_Resume(a1);
}

void sub_19E099200()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  v239[1610] = *MEMORY[0x1E4F143B8];
  *(_DWORD *)buf = 0x100000;
  *(_WORD *)&uint8_t buf[4] = 0;
  buf[6] = 1;
  *(void *)&long long v232 = 0;
  sub_19E03F6F8(buf, (uint64_t)"idx", 0, 3u);
  sub_19E095668((uint64_t)v228, v0, buf);
  if ((void)v232 && buf[6] == 1) {
    free((void *)v232);
  }
  *(_DWORD *)versionArray = 0;
  ucol_getVersion();
  u_versionToString(versionArray, versionString);
  ucol_getUCAVersion();
  u_versionToString(versionArray, v226);
  unsigned __int8 v1 = atomic_load(byte_1E9457268);
  if (v1)
  {
    unsigned __int8 v2 = atomic_load(byte_1E94578A0);
    if (v2)
    {
      if (v229) {
        uint64_t v5 = (const char *)v229;
      }
      else {
        uint64_t v5 = v230;
      }
      printf("writing version %x.%x, collator v%s, UCA v%s, %s", 3, 21, versionString, v226, v5);
      putchar(10);
    }
    else
    {
      uint64_t v3 = sub_19E08D084();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v4 = v229;
        if (!v229) {
          uint64_t v4 = v230;
        }
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = 3;
        LOWORD(v232) = 1024;
        *(_DWORD *)((char *)&v232 + 2) = 21;
        WORD3(v232) = 2080;
        *((void *)&v232 + 1) = versionString;
        LOWORD(v233[0]) = 2080;
        *(void *)((char *)v233 + 2) = v226;
        WORD1(v233[1]) = 2080;
        *(void *)((char *)&v233[1] + 4) = v4;
        _os_log_impl(&dword_19E038000, v3, OS_LOG_TYPE_DEFAULT, "writing version %x.%x, collator v%s, UCA v%s, %s", buf, 0x2Cu);
      }
    }
  }
  uint64_t v6 = v230;
  if (v229) {
    uint64_t v7 = (char *)v229;
  }
  else {
    uint64_t v7 = v230;
  }
  sub_19E0F17CC(v213, v7);
  if (!v214)
  {
    sub_19E0538DC((uint64_t)buf);
    unint64_t v203 = sub_19E0416F8((void *)&v232 + 1, (uint64_t)"invalid index file at ", 22);
    if (v229) {
      uint64_t v6 = (const char *)v229;
    }
    size_t v204 = strlen(v6);
    sub_19E0416F8(v203, (uint64_t)v6, v204);
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E05EEA4(__dst, (uint64_t)v233);
    sub_19E08DA70(exception, (long long *)__dst);
    __cxa_throw(exception, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
  }
  unsigned __int8 v8 = atomic_load(byte_1E9457268);
  if (v8)
  {
    unsigned __int8 v9 = atomic_load(byte_1E94578A0);
    if (v9)
    {
      printf("\tAllocating trie slots: magic_number=%u, root_usage_sum=%f", 1, *(double *)(*(void *)(v0 + 272) + 40));
      putchar(10);
    }
    else
    {
      BOOL v10 = sub_19E08D084();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(*(void *)(v0 + 272) + 40);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = 1;
        LOWORD(v232) = 2048;
        *(void *)((char *)&v232 + 2) = v11;
        _os_log_impl(&dword_19E038000, v10, OS_LOG_TYPE_DEFAULT, "\tAllocating trie slots: magic_number=%u, root_usage_sum=%f", buf, 0x12u);
      }
    }
  }
  sub_19E09BB14(v0, (ssize_t)v213, 1);
  off_t v12 = sub_19E0F1A04(v215);
  unint64_t v13 = *(void *)(v0 + 240);
  uint64_t v14 = (v13 & 0x100) != 0 && *(_DWORD *)(v0 + 1960) == 5;
  sub_19E0F320C(*(void **)(v0 + 272), v12, (v13 >> 12) & 1, v14);
  sub_19E0F3130(*(void *)(v0 + 272));
  if (sub_19E0F320C(*(void **)(v0 + 272), v12, (*(void *)(v0 + 240) >> 12) & 1, v14) >= 0x1000001)
  {
    sub_19E0538DC((uint64_t)buf);
    sub_19E0416F8((void *)&v232 + 1, (uint64_t)"Trie size=", 10);
    BOOL v206 = (void *)std::ostream::operator<<();
    sub_19E0416F8(v206, (uint64_t)" bytes exceeds trie addressing capacity=", 40);
    std::ostream::operator<<();
    unint64_t v207 = __cxa_allocate_exception(0x20uLL);
    sub_19E05EEA4(__dst, (uint64_t)v233);
    sub_19E08DA70(v207, (long long *)__dst);
    __cxa_throw(v207, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
  }
  int v15 = *(_DWORD *)(v0 + 1960);
  unsigned __int16 v16 = *(uint64_t **)(v0 + 280);
  uint64_t v212 = *(void *)(v0 + 248);
  if ((*(void *)(v0 + 240) & 0x800) == 0)
  {
    uint64_t v208 = v0;
    if (v15 == 5)
    {
      int v209 = *(void *)(v0 + 240);
      *((void *)&__p + 1) = 0;
      uint64_t v223 = 0;
      *(void *)&long long __p = (char *)&__p + 8;
      uint64_t v17 = *v16;
      if (v16[1] != *v16)
      {
        for (unint64_t i = 0; i < (v16[1] - *v16) >> 3; ++i)
        {
          uint64_t v19 = *(void *)(v17 + 8 * i);
          uint64_t v20 = (unsigned __int16 *)(v19 + 136);
          if ((long long *)((char *)&__p + 8) == (long long *)sub_19E0B336C((uint64_t)&__p, (unsigned __int16 *)(v19 + 136)))
          {
            memset(v233, 0, sizeof(v233));
            long long v232 = 0u;
            uint64_t v26 = *(void *)(v17 + 8 * i);
            int v27 = *(_DWORD *)(v26 + 248);
            LODWORD(v26) = *(_DWORD *)(v26 + 60);
            *(_DWORD *)buf = v27;
            *(_DWORD *)&uint8_t buf[4] = v26;
            unint64_t v28 = *v20;
            if (v28 < 0xF) {
              unsigned __int8 v29 = (char *)(v19 + 138);
            }
            else {
              unsigned __int8 v29 = *(char **)(v19 + 144);
            }
            sub_19E05B100(&v232, v29, &v29[v28], v28);
            uint64_t v30 = *(void *)(v17 + 8 * i);
            __dst[0] = 0;
            __dst[1] = 0;
            uint64_t v225 = 0;
            sub_19E05D05C(__dst, *(const void **)(v30 + 200), *(void *)(v30 + 208), *(void *)(v30 + 208) - *(void *)(v30 + 200));
            if (v233[1])
            {
              v233[2] = v233[1];
              operator delete((void *)v233[1]);
            }
            *(_OWORD *)&v233[1] = *(_OWORD *)__dst;
            v233[3] = v225;
            uint64_t v31 = *(void *)(v17 + 8 * i);
            uint64_t v234 = *(void *)(v31 + 88);
            int v235 = 1;
            BOOL v236 = (*(_DWORD *)(v31 + 56) & 0xFFF000) != 0;
            sub_19E0B38DC((uint64_t **)&__p, (unsigned __int16 *)(v19 + 136), (unsigned __int16 *)(v19 + 136), (uint64_t)buf);
            if (v233[1])
            {
              v233[2] = v233[1];
              operator delete((void *)v233[1]);
            }
            unsigned __int8 v32 = (void *)v232;
            if (!(void)v232) {
              goto LABEL_77;
            }
            *((void *)&v232 + 1) = v232;
          }
          else
          {
            __int16 v21 = (void **)sub_19E09D6CC((uint64_t)&__p, __dst, (unsigned __int16 *)(v19 + 136));
            int v22 = (char *)*v21;
            if (!*v21)
            {
              char v23 = v21;
              int v22 = (char *)operator new(0x78uLL);
              *(void *)buf = v22;
              *(void *)&long long v232 = (char *)&__p + 8;
              BYTE8(v232) = 0;
              uint64_t v24 = v22 + 32;
              unint64_t v25 = *v20;
              if (v25 >= 0xF)
              {
                _WORD *v24 = v25;
                operator new[]();
              }
              *(_OWORD *)uint64_t v24 = *(_OWORD *)v20;
              *((void *)v22 + 14) = 0;
              *((_OWORD *)v22 + 5) = 0u;
              *((_OWORD *)v22 + 6) = 0u;
              *((_OWORD *)v22 + 3) = 0u;
              *((_OWORD *)v22 + 4) = 0u;
              BYTE8(v232) = 1;
              unsigned __int8 v33 = __dst[0];
              *(void *)int v22 = 0;
              *((void *)v22 + 1) = 0;
              *((void *)v22 + 2) = v33;
              *char v23 = v22;
              int v34 = (uint64_t *)v22;
              if (*(void *)__p)
              {
                *(void *)&long long __p = *(void *)__p;
                int v34 = (uint64_t *)*v23;
              }
              sub_19E05D650(*((uint64_t **)&__p + 1), v34);
              ++v223;
              *(void *)buf = 0;
              sub_19E0D020C((uint64_t)buf);
            }
            uint64_t v35 = *(void *)(v17 + 8 * i);
            unsigned int v36 = *(_DWORD *)(v35 + 248);
            if (v36 >= *((_DWORD *)v22 + 12)) {
              unsigned int v36 = *((_DWORD *)v22 + 12);
            }
            *((_DWORD *)v22 + 12) = v36;
            ++*((_DWORD *)v22 + 28);
            v22[116] |= (*(_DWORD *)(v35 + 56) & 0xFFF000) != 0;
            *((double *)v22 + 13) = *(double *)(v35 + 88) + *((double *)v22 + 13);
            *(void *)buf = 0;
            long long v232 = 0uLL;
            sub_19E05D05C(buf, *(const void **)(v35 + 200), *(void *)(v35 + 208), *(void *)(v35 + 208) - *(void *)(v35 + 200));
            unsigned __int8 v37 = (unsigned char *)v232;
            if ((void)v232 != *(void *)buf)
            {
              unint64_t v38 = 0;
              unsigned __int8 v37 = *(unsigned char **)buf;
              do
              {
                unint64_t v39 = *((void *)v22 + 10);
                unsigned __int8 v40 = (unsigned char *)*((void *)v22 + 11);
                unsigned __int8 v41 = &v40[-v39];
                if (v38 >= (unint64_t)&v40[-v39])
                {
                  unint64_t v43 = *((void *)v22 + 12);
                  if ((unint64_t)v40 >= v43)
                  {
                    unint64_t v45 = (unint64_t)(v41 + 1);
                    if ((uint64_t)(v41 + 1) < 0) {
                      sub_19E041BEC();
                    }
                    unint64_t v46 = v43 - v39;
                    if (2 * v46 > v45) {
                      unint64_t v45 = 2 * v46;
                    }
                    if (v46 >= 0x3FFFFFFFFFFFFFFFLL) {
                      size_t v47 = 0x7FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      size_t v47 = v45;
                    }
                    if (v47) {
                      unsigned __int8 v48 = (char *)operator new(v47);
                    }
                    else {
                      unsigned __int8 v48 = 0;
                    }
                    unint64_t v49 = &v41[(void)v48];
                    v41[(void)v48] = v37[v38];
                    uint64_t v44 = (uint64_t)&v41[(void)v48 + 1];
                    if (v40 != (unsigned char *)v39)
                    {
                      uint64_t v50 = &v40[~v39];
                      do
                      {
                        char v51 = *--v40;
                        (v50--)[(void)v48] = v51;
                      }
                      while (v40 != (unsigned char *)v39);
                      unsigned __int8 v40 = (unsigned char *)*((void *)v22 + 10);
                      unint64_t v49 = v48;
                    }
                    *((void *)v22 + 1sub_19E060B80(&a9, 0) = v49;
                    *((void *)v22 + 11) = v44;
                    *((void *)v22 + 12) = &v48[v47];
                    if (v40) {
                      operator delete(v40);
                    }
                  }
                  else
                  {
                    *unsigned __int8 v40 = v37[v38];
                    uint64_t v44 = (uint64_t)(v40 + 1);
                  }
                  *((void *)v22 + 11) = v44;
                }
                else
                {
                  unsigned int v42 = v37[v38];
                  if (v42 >= *(unsigned __int8 *)(v39 + v38)) {
                    LOBYTE(v42) = *(unsigned char *)(v39 + v38);
                  }
                  *(unsigned char *)(v39 + v3++**(_DWORD **)(result + 8) = v42;
                }
                ++v38;
                unsigned __int8 v37 = *(unsigned char **)buf;
              }
              while (v38 < (void)v232 - *(void *)buf);
            }
            if (!v37) {
              goto LABEL_77;
            }
            *(void *)&long long v232 = v37;
            unsigned __int8 v32 = v37;
          }
          operator delete(v32);
LABEL_77:
          uint64_t v17 = *v16;
        }
      }
      if (*(_DWORD *)(v208 + 1768))
      {
        *(void *)buf = &unk_1EF099FB8;
        *(void *)&long long v232 = &__p;
        *((void *)&v232 + 1) = v208 + 328;
        v233[0] = buf;
        sub_19E0B34E8(v16, v212, (uint64_t)buf);
        sub_19E0B3858(buf);
      }
      long long v220 = 0uLL;
      uint64_t v221 = 0;
      unsigned __int8 v52 = (long long *)__p;
      if ((long long *)__p != (long long *)((char *)&__p + 8))
      {
        uint64_t v53 = 0;
        do
        {
          if (v53 >= v221)
          {
            unint64_t v54 = 0x8E38E38E38E38E39 * ((uint64_t)&v53[-v220] >> 3);
            unint64_t v55 = v54 + 1;
            if (v54 + 1 > 0x38E38E38E38E38ELL) {
              sub_19E041BEC();
            }
            if (0x1C71C71C71C71C72 * ((uint64_t)&v221[-v220] >> 3) > v55) {
              unint64_t v55 = 0x1C71C71C71C71C72 * ((uint64_t)&v221[-v220] >> 3);
            }
            if (0x8E38E38E38E38E39 * ((uint64_t)&v221[-v220] >> 3) >= 0x1C71C71C71C71C7) {
              unint64_t v56 = 0x38E38E38E38E38ELL;
            }
            else {
              unint64_t v56 = v55;
            }
            v233[1] = &v221;
            if (v56) {
              uint64_t v57 = (char *)sub_19E05CED0((uint64_t)&v221, v56);
            }
            else {
              uint64_t v57 = 0;
            }
            *(void *)buf = v57;
            *(void *)&long long v232 = &v57[72 * v54];
            *((void *)&v232 + 1) = v232;
            v233[0] = &v57[72 * v56];
            sub_19E0B3A08((void *)v232, (uint64_t *)v52 + 6);
            *((void *)&v232 + 1) += 72;
            sub_19E0BD220((uint64_t *)&v220, buf);
            uint64_t v53 = (char *)*((void *)&v220 + 1);
            sub_19E0BD2E0((uint64_t)buf);
          }
          else
          {
            sub_19E0B3A08(v53, (uint64_t *)v52 + 6);
            v53 += 72;
          }
          *((void *)&v220 + 1) = v53;
          BOOL v58 = (long long *)*((void *)v52 + 1);
          if (v58)
          {
            do
            {
              uint64_t v59 = v58;
              BOOL v58 = *(long long **)v58;
            }
            while (v58);
          }
          else
          {
            do
            {
              uint64_t v59 = (long long *)*((void *)v52 + 2);
              BOOL v60 = *(void *)v59 == (void)v52;
              unsigned __int8 v52 = v59;
            }
            while (!v60);
          }
          unsigned __int8 v52 = v59;
        }
        while (v59 != (long long *)((char *)&__p + 8));
      }
      unint64_t v218 = 0;
      uint64_t v219 = 0;
      uint64_t v217 = &v218;
      unint64_t v61 = *(uint64_t **)(v208 + 1640);
      if (!v61)
      {
LABEL_119:
        long long v232 = 0u;
        memset(v233, 0, 24);
        *(void *)buf = &unk_1EF09DED8;
        LODWORD(v233[3]) = v209 | 1;
        sub_19E05D254(&v234, (uint64_t)&v217);
        char v237 = 0;
        int v238 = 0;
        sub_19E0BDC20((uint64_t)v239);
        sub_19E05D848((uint64_t)&v217, v218);
        LODWORD(v233[3]) = v233[3] & 0xFFFFFFFE | v209 & 1;
        sub_19E0B3AA4();
      }
      while (1)
      {
        unsigned int v62 = *((_DWORD *)v61 + 8);
        size_t v63 = *((unsigned __int16 *)v61 + 8);
        if (v63 >= 0xF) {
          break;
        }
        __dst[0] = 0;
        __dst[1] = 0;
        uint64_t v225 = 0;
        if (v63)
        {
          unsigned int v64 = (char *)v61 + 18;
          goto LABEL_105;
        }
LABEL_106:
        unint64_t v66 = v218;
        uint8x8_t v67 = &v218;
        unint64_t v68 = &v218;
        if (v218)
        {
          do
          {
            while (1)
            {
              unint64_t v68 = (uint64_t **)v66;
              unsigned int v69 = *((_DWORD *)v66 + 8);
              if (v62 >= v69) {
                break;
              }
              unint64_t v66 = *v68;
              uint8x8_t v67 = v68;
              if (!*v68) {
                goto LABEL_113;
              }
            }
            if (v69 >= v62) {
              goto LABEL_116;
            }
            unint64_t v66 = v68[1];
          }
          while (v66);
          uint8x8_t v67 = v68 + 1;
        }
LABEL_113:
        unint64_t v70 = (char *)operator new(0x40uLL);
        *((_DWORD *)v70 + ++**(_DWORD **)(result + 8) = v62;
        *(_OWORD *)(v70 + 4sub_19E060B80(&a9, 0) = *(_OWORD *)__dst;
        *((void *)v70 + 7) = v225;
        __dst[0] = 0;
        __dst[1] = 0;
        uint64_t v225 = 0;
        *(void *)unint64_t v70 = 0;
        *((void *)v70 + 1) = 0;
        *((void *)v70 + 2) = v68;
        *uint8x8_t v67 = (uint64_t *)v70;
        if (*v217)
        {
          uint64_t v217 = (uint64_t **)*v217;
          unint64_t v70 = (char *)*v67;
        }
        sub_19E05D650(v218, (uint64_t *)v70);
        ++v219;
LABEL_116:
        if (__dst[0])
        {
          __dst[1] = __dst[0];
          operator delete(__dst[0]);
        }
        unint64_t v61 = (uint64_t *)*v61;
        if (!v61) {
          goto LABEL_119;
        }
      }
      unsigned int v64 = (const void *)v61[3];
      __dst[1] = 0;
      uint64_t v225 = 0;
      __dst[0] = 0;
LABEL_105:
      sub_19E05B210(__dst, v63);
      unint64_t v65 = (char *)__dst[1];
      memmove(__dst[1], v64, v63);
      __dst[1] = &v65[v63];
      goto LABEL_106;
    }
    int v211 = *(_DWORD *)(v0 + 1960);
    __dst[1] = 0;
    uint64_t v225 = 0;
    uint64_t v223 = 0;
    __dst[0] = &__dst[1];
    *(void *)&long long __p = (char *)&__p + 8;
    *((void *)&__p + 1) = 0;
    uint64_t v124 = *v16;
    uint64_t v125 = v16[1];
    if (*v16 == v125)
    {
LABEL_260:
      if (*(_DWORD *)(v208 + 1768))
      {
        *(void *)buf = &unk_1EF09A068;
        *(void *)&long long v232 = __dst;
        v233[0] = buf;
        sub_19E0B34E8(v16, v212, (uint64_t)buf);
        sub_19E0B3858(buf);
      }
      long long v220 = 0uLL;
      uint64_t v221 = 0;
      unsigned __int8 v163 = (void **)__dst[0];
      if (__dst[0] != &__dst[1])
      {
        double v164 = 0;
        unsigned __int8 v165 = 0;
        unint64_t v166 = 0;
        uint64_t v167 = 0;
        uint64_t v168 = 0;
        unint64_t v169 = 0;
        do
        {
          if (*((unsigned __int16 *)v163 + 16) < 0xFu) {
            uint64_t v170 = (char *)v163 + 34;
          }
          else {
            uint64_t v170 = (char *)v163[5];
          }
          if ((unint64_t)v165 >= v166)
          {
            uint64_t v171 = (v165 - v164) >> 3;
            unint64_t v172 = v171 + 1;
            if ((unint64_t)(v171 + 1) >> 61) {
              sub_19E041BEC();
            }
            if ((uint64_t)(v166 - (void)v164) >> 2 > v172) {
              unint64_t v172 = (uint64_t)(v166 - (void)v164) >> 2;
            }
            if (v166 - (unint64_t)v164 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v173 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v173 = v172;
            }
            if (v173) {
              unint64_t v173 = (unint64_t)sub_19E060B48(v173);
            }
            else {
              uint64_t v174 = 0;
            }
            uint64_t v175 = (char *)(v173 + 8 * v171);
            *(void *)uint64_t v175 = v170;
            uint64_t v176 = v175 + 8;
            while (v165 != v164)
            {
              uint64_t v177 = *((void *)v165 - 1);
              v165 -= 8;
              *((void *)v175 - 1) = v177;
              v175 -= 8;
            }
            unint64_t v166 = v173 + 8 * v174;
            if (v164) {
              operator delete(v164);
            }
            double v164 = v175;
            unsigned __int8 v165 = v176;
          }
          else
          {
            *(void *)unsigned __int8 v165 = v170;
            v165 += 8;
          }
          uint64_t v178 = *((unsigned __int16 *)v163 + 16);
          uint64_t v179 = (char *)*((void *)&v220 + 1);
          if (*((void *)&v220 + 1) >= (unint64_t)v221)
          {
            unint64_t v181 = (char *)v220;
            uint64_t v182 = (uint64_t)(*((void *)&v220 + 1) - v220) >> 3;
            unint64_t v183 = v182 + 1;
            if ((unint64_t)(v182 + 1) >> 61) {
              sub_19E041BEC();
            }
            uint64_t v184 = (uint64_t)&v221[-v220];
            if ((uint64_t)&v221[-v220] >> 2 > v183) {
              unint64_t v183 = v184 >> 2;
            }
            if ((unint64_t)v184 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v185 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v185 = v183;
            }
            if (v185)
            {
              uint8x8_t v186 = (char *)sub_19E049FB0((uint64_t)&v221, v185);
              uint64_t v179 = (char *)*((void *)&v220 + 1);
              unint64_t v181 = (char *)v220;
            }
            else
            {
              uint8x8_t v186 = 0;
            }
            unsigned __int8 v187 = &v186[8 * v182];
            *(void *)unsigned __int8 v187 = v178;
            int v180 = v187 + 8;
            while (v179 != v181)
            {
              uint64_t v188 = *((void *)v179 - 1);
              v179 -= 8;
              *((void *)v187 - 1) = v188;
              v187 -= 8;
            }
            *(void *)&long long v220 = v187;
            *((void *)&v220 + 1) = v180;
            uint64_t v221 = &v186[8 * v185];
            if (v181) {
              operator delete(v181);
            }
          }
          else
          {
            **((void **)&v220 + 1) = v178;
            int v180 = v179 + 8;
          }
          *((void *)&v220 + 1) = v180;
          uint64_t v189 = *((unsigned int *)v163 + 12);
          if ((unint64_t)v168 >= v169)
          {
            uint64_t v190 = (v168 - v167) >> 3;
            unint64_t v191 = v190 + 1;
            if ((unint64_t)(v190 + 1) >> 61) {
              sub_19E041BEC();
            }
            if ((uint64_t)(v169 - (void)v167) >> 2 > v191) {
              unint64_t v191 = (uint64_t)(v169 - (void)v167) >> 2;
            }
            if (v169 - (unint64_t)v167 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v192 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v192 = v191;
            }
            if (v192) {
              unint64_t v192 = (unint64_t)sub_19E060B48(v192);
            }
            else {
              uint64_t v193 = 0;
            }
            unint64_t v194 = (char *)(v192 + 8 * v190);
            *(void *)unint64_t v194 = v189;
            size_t v195 = v194 + 8;
            while (v168 != v167)
            {
              uint64_t v196 = *((void *)v168 - 1);
              v168 -= 8;
              *((void *)v194 - 1) = v196;
              v194 -= 8;
            }
            unint64_t v169 = v192 + 8 * v193;
            if (v167) {
              operator delete(v167);
            }
            uint64_t v167 = v194;
            uint64_t v168 = v195;
          }
          else
          {
            *(void *)uint64_t v168 = v189;
            v168 += 8;
          }
          uint64_t v197 = (void **)v163[1];
          if (v197)
          {
            do
            {
              unint64_t v198 = v197;
              uint64_t v197 = (void **)*v197;
            }
            while (v197);
          }
          else
          {
            do
            {
              unint64_t v198 = (void **)v163[2];
              BOOL v60 = *v198 == v163;
              unsigned __int8 v163 = v198;
            }
            while (!v60);
          }
          unsigned __int8 v163 = v198;
        }
        while (v198 != &__dst[1]);
      }
      switch(v211)
      {
        case 2:
          operator new();
        case 3:
          operator new();
        case 4:
          operator new();
        case 5:
          operator new();
        case 6:
          operator new();
        case 7:
          operator new();
        case 8:
          operator new();
        default:
          operator new();
      }
    }
    while (1)
    {
      uint64_t v126 = *(void *)v124;
      unsigned int v127 = *(_DWORD *)(*(void *)v124 + 248);
      if (v127 >= 0x200000)
      {
        sub_19E0538DC((uint64_t)buf);
        sub_19E0416F8((void *)&v232 + 1, (uint64_t)"Unigram index length=", 21);
        unint64_t v201 = (void *)std::ostream::operator<<();
        sub_19E0416F8(v201, (uint64_t)" bytes exceeds trie addressing capacity=", 40);
        std::ostream::operator<<();
        uint8x8_t v202 = __cxa_allocate_exception(0x20uLL);
        sub_19E05EEA4(&v220, (uint64_t)v233);
        sub_19E08DA70(v202, &v220);
        __cxa_throw(v202, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
      }
      double v128 = *(double *)(v126 + 88);
      uint64_t v129 = *(unsigned __int16 *)(v126 + 136);
      if (v129 < 0xF)
      {
        HIBYTE(v232) = *(_WORD *)(v126 + 136);
        size_t v132 = buf;
        if (!v129) {
          goto LABEL_215;
        }
        uint64_t v130 = (char *)(v126 + 138);
        unsigned int v131 = (char *)(v126 + 138 + v129);
      }
      else
      {
        uint64_t v130 = *(char **)(v126 + 144);
        unsigned int v131 = &v130[v129];
        if (v129 > 0x16)
        {
          uint64_t v133 = ((unsigned __int16)v129 & 0xFFF8) + 8;
          if ((v129 | 7) != 0x17) {
            uint64_t v133 = v129 | 7;
          }
          uint64_t v134 = v133 + 1;
          size_t v132 = operator new(v133 + 1);
          *(void *)&long long v232 = v129;
          *((void *)&v232 + 1) = v134 | 0x8000000000000000;
          *(void *)buf = v132;
        }
        else
        {
          HIBYTE(v232) = *(_WORD *)(v126 + 136);
          size_t v132 = buf;
        }
      }
      do
      {
        char v135 = *v130++;
        *v132++ = v135;
      }
      while (v130 != v131);
LABEL_215:
      unsigned char *v132 = 0;
      *(void *)&long long v220 = buf;
      uint64_t v136 = (double *)sub_19E0B3CA4((uint64_t **)&__p, buf, (_OWORD **)&v220);
      v136[7] = v128 + v136[7];
      if (SHIBYTE(v232) < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v137 = *(void *)v124;
      uint64_t v138 = *(void *)(*(void *)v124 + 224);
      if (v138)
      {
        if ((int)atomic_fetch_add((atomic_uint *volatile)v138, 1u) < 1) {
          __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
        }
        uint64_t v137 = *(void *)v124;
      }
      unint64_t v139 = (unsigned __int16 *)(v126 + 136);
      if (*(unsigned char *)(v137 + 304) || *(_DWORD *)(v137 + 248))
      {
        if (!v138) {
          goto LABEL_224;
        }
LABEL_223:
        sub_19E076C68(v138);
        goto LABEL_224;
      }
      if (((*(void *)(v138 + 16) - *(void *)(v138 + 8)) & 0x7FFFFFFF8) == 0) {
        goto LABEL_223;
      }
      double v145 = *(void **)(v138 + 32);
      if (!v145) {
        goto LABEL_223;
      }
      uint64_t v146 = (v145[1] - *v145) & 0x7FFFFFFF8;
      sub_19E076C68(v138);
      if (v146 == 8)
      {
        uint64_t v147 = *(void *)v124;
        double v148 = *(double *)(*(void *)v124 + 88);
        double v149 = 0.0;
        if (v148 != 0.0)
        {
          uint64_t v150 = *(void *)(v147 + 224);
          if (v150)
          {
            double v151 = *(double *)(v150 + 40);
            goto LABEL_252;
          }
          int v159 = *(_DWORD *)(v147 + 336);
          if (v159)
          {
            double v151 = (double)v159;
LABEL_252:
            double v149 = v148 / v151;
          }
          else
          {
            double v149 = 1.0;
          }
        }
        int v160 = (int)(sqrt(v149) * 255.0);
        if (v160) {
          BOOL v161 = 1;
        }
        else {
          BOOL v161 = v149 <= 0.0;
        }
        int v162 = v160 | 0x400000;
        if (!v161) {
          int v162 = 4194305;
        }
        *(_DWORD *)buf = v162;
        sub_19E0B3D34((uint64_t **)__dst, (unsigned __int16 *)(v126 + 136), (unsigned __int16 *)(v126 + 136), buf);
        goto LABEL_247;
      }
LABEL_224:
      if (&__dst[1] != (void **)sub_19E0B336C((uint64_t)__dst, (unsigned __int16 *)(v126 + 136)))
      {
        double v140 = (void **)sub_19E09D6CC((uint64_t)__dst, buf, (unsigned __int16 *)(v126 + 136));
        double v141 = (char *)*v140;
        if (!*v140)
        {
          double v142 = v140;
          double v141 = (char *)operator new(0x38uLL);
          long long v143 = v141 + 32;
          unint64_t v144 = *v139;
          if (v144 >= 0xF)
          {
            *long long v143 = v144;
            operator new[]();
          }
          *(_OWORD *)long long v143 = *(_OWORD *)v139;
          *((_DWORD *)v141 + 12) = 0;
          unint64_t v152 = *(void **)buf;
          *(void *)double v141 = 0;
          *((void *)v141 + 1) = 0;
          *((void *)v141 + 2) = v152;
          *double v142 = v141;
          double v153 = (uint64_t *)v141;
          if (*(void *)__dst[0])
          {
            __dst[0] = *(void **)__dst[0];
            double v153 = (uint64_t *)*v142;
          }
          sub_19E05D650((uint64_t *)__dst[1], v153);
          ++v225;
        }
        int v154 = *((_DWORD *)v141 + 12);
        unsigned int v155 = v154 & 0x1FFFFF;
        if ((v154 & 0x400000) != 0) {
          unsigned int v155 = 0;
        }
        if (v127 < v155) {
          unsigned int v155 = v127;
        }
        unsigned int v156 = v154 & 0xFFE00000 | v155;
        *((_DWORD *)v141 + 12) = v156;
        if ((v154 & 0x600000) == 0x200000)
        {
          unsigned int v157 = v156 & 0xFFDFFFFF;
          goto LABEL_245;
        }
        unsigned int v157 = v156 & 0xFFDFFFFF;
        if ((*(_DWORD *)(*(void *)v124 + 56) & 0xFFF000) != 0) {
LABEL_245:
        }
          int v158 = 0x200000;
        else {
          int v158 = 0;
        }
        *((_DWORD *)v141 + 12) = v158 | v157;
        goto LABEL_247;
      }
      *(_DWORD *)buf = v127 & 0x1FFFFF | (((*(_DWORD *)(*(void *)v124 + 56) & 0xFFF000) != 0) << 21);
      sub_19E0B3D34((uint64_t **)__dst, (unsigned __int16 *)(v126 + 136), (unsigned __int16 *)(v126 + 136), buf);
LABEL_247:
      v124 += 8;
      if (v124 == v125) {
        goto LABEL_260;
      }
    }
  }
  __dst[1] = 0;
  uint64_t v225 = 0;
  __dst[0] = &__dst[1];
  uint64_t v71 = *v16;
  uint64_t v72 = v16[1];
  while (1)
  {
    if (v71 == v72)
    {
      if (*(_DWORD *)(v0 + 1768))
      {
        *(void *)buf = &unk_1EF09A010;
        *(void *)&long long v232 = __dst;
        v233[0] = buf;
        sub_19E0B34E8(v16, v212, (uint64_t)buf);
        sub_19E0B3858(buf);
      }
      int v210 = v15;
      long long __p = 0uLL;
      uint64_t v223 = 0;
      uint64_t v88 = (void **)__dst[0];
      if (__dst[0] != &__dst[1])
      {
        uint64_t v89 = 0;
        unsigned __int8 v90 = 0;
        unint64_t v91 = 0;
        uint64_t v92 = 0;
        uint64_t v93 = 0;
        unint64_t v94 = 0;
        do
        {
          if (*((unsigned __int16 *)v88 + 16) < 0xFu) {
            uint64_t v95 = (char *)v88 + 34;
          }
          else {
            uint64_t v95 = (char *)v88[5];
          }
          if ((unint64_t)v90 >= v91)
          {
            uint64_t v96 = (v90 - v89) >> 3;
            unint64_t v97 = v96 + 1;
            if ((unint64_t)(v96 + 1) >> 61) {
              sub_19E041BEC();
            }
            if ((uint64_t)(v91 - (void)v89) >> 2 > v97) {
              unint64_t v97 = (uint64_t)(v91 - (void)v89) >> 2;
            }
            if (v91 - (unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v98 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v98 = v97;
            }
            if (v98) {
              unint64_t v98 = (unint64_t)sub_19E060B48(v98);
            }
            else {
              uint64_t v99 = 0;
            }
            unsigned __int8 v100 = (char *)(v98 + 8 * v96);
            *(void *)unsigned __int8 v100 = v95;
            unint64_t v101 = v100 + 8;
            while (v90 != v89)
            {
              uint64_t v102 = *((void *)v90 - 1);
              v90 -= 8;
              *((void *)v100 - 1) = v102;
              v100 -= 8;
            }
            unint64_t v91 = v98 + 8 * v99;
            if (v89) {
              operator delete(v89);
            }
            uint64_t v89 = v100;
            unsigned __int8 v90 = v101;
          }
          else
          {
            *(void *)unsigned __int8 v90 = v95;
            v90 += 8;
          }
          uint64_t v103 = *((unsigned __int16 *)v88 + 16);
          uint64_t v104 = (char *)*((void *)&__p + 1);
          if (*((void *)&__p + 1) >= (unint64_t)v223)
          {
            double v106 = (char *)__p;
            uint64_t v107 = (uint64_t)(*((void *)&__p + 1) - __p) >> 3;
            unint64_t v108 = v107 + 1;
            if ((unint64_t)(v107 + 1) >> 61) {
              sub_19E041BEC();
            }
            uint64_t v109 = (uint64_t)&v223[-__p];
            if ((uint64_t)&v223[-__p] >> 2 > v108) {
              unint64_t v108 = v109 >> 2;
            }
            if ((unint64_t)v109 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v110 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v110 = v108;
            }
            if (v110)
            {
              uint64_t v111 = (char *)sub_19E049FB0((uint64_t)&v223, v110);
              uint64_t v104 = (char *)*((void *)&__p + 1);
              double v106 = (char *)__p;
            }
            else
            {
              uint64_t v111 = 0;
            }
            unint64_t v112 = &v111[8 * v107];
            *(void *)unint64_t v112 = v103;
            int v105 = v112 + 8;
            while (v104 != v106)
            {
              uint64_t v113 = *((void *)v104 - 1);
              v104 -= 8;
              *((void *)v112 - 1) = v113;
              v112 -= 8;
            }
            *(void *)&long long __p = v112;
            *((void *)&__p + 1) = v105;
            uint64_t v223 = &v111[8 * v110];
            if (v106) {
              operator delete(v106);
            }
          }
          else
          {
            **((void **)&__p + 1) = v103;
            int v105 = v104 + 8;
          }
          *((void *)&__p + 1) = v105;
          uint64_t v114 = *((unsigned int *)v88 + 12);
          if ((unint64_t)v93 >= v94)
          {
            uint64_t v115 = (v93 - v92) >> 3;
            unint64_t v116 = v115 + 1;
            if ((unint64_t)(v115 + 1) >> 61) {
              sub_19E041BEC();
            }
            if ((uint64_t)(v94 - (void)v92) >> 2 > v116) {
              unint64_t v116 = (uint64_t)(v94 - (void)v92) >> 2;
            }
            if (v94 - (unint64_t)v92 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v117 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v117 = v116;
            }
            if (v117) {
              unint64_t v117 = (unint64_t)sub_19E060B48(v117);
            }
            else {
              uint64_t v118 = 0;
            }
            uint64_t v119 = (char *)(v117 + 8 * v115);
            *(void *)uint64_t v119 = v114;
            unint64_t v120 = v119 + 8;
            while (v93 != v92)
            {
              uint64_t v121 = *((void *)v93 - 1);
              v93 -= 8;
              *((void *)v119 - 1) = v121;
              v119 -= 8;
            }
            unint64_t v94 = v117 + 8 * v118;
            if (v92) {
              operator delete(v92);
            }
            uint64_t v92 = v119;
            uint64_t v93 = v120;
          }
          else
          {
            *(void *)uint64_t v93 = v114;
            v93 += 8;
          }
          uint64_t v122 = (void **)v88[1];
          if (v122)
          {
            do
            {
              int v123 = v122;
              uint64_t v122 = (void **)*v122;
            }
            while (v122);
          }
          else
          {
            do
            {
              int v123 = (void **)v88[2];
              BOOL v60 = *v123 == v88;
              uint64_t v88 = v123;
            }
            while (!v60);
          }
          uint64_t v88 = v123;
        }
        while (v123 != &__dst[1]);
      }
      switch(v210)
      {
        case 2:
          operator new();
        case 3:
          operator new();
        case 4:
          operator new();
        case 5:
          operator new();
        case 6:
          operator new();
        case 7:
          operator new();
        case 8:
          operator new();
        default:
          operator new();
      }
    }
    uint64_t v73 = *(void *)v71;
    unsigned int v74 = *(_DWORD *)(*(void *)v71 + 248);
    if (v74 >= 0x200000)
    {
      sub_19E0538DC((uint64_t)buf);
      sub_19E0416F8((void *)&v232 + 1, (uint64_t)"Unigram index length=", 21);
      unint64_t v199 = (void *)std::ostream::operator<<();
      sub_19E0416F8(v199, (uint64_t)" bytes exceeds trie addressing capacity=", 40);
      std::ostream::operator<<();
      uint64_t v200 = __cxa_allocate_exception(0x20uLL);
      sub_19E05EEA4(&__p, (uint64_t)v233);
      sub_19E08DA70(v200, &__p);
      __cxa_throw(v200, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
    }
    unint64_t v75 = (unsigned __int16 *)(v73 + 136);
    if (&__dst[1] == (void **)sub_19E0B336C((uint64_t)__dst, (unsigned __int16 *)(v73 + 136)))
    {
      *(_DWORD *)buf = v74 & 0x1FFFFF | (((*(_DWORD *)(v73 + 56) & 0xFFF000) != 0) << 21);
      sub_19E0B33E8((uint64_t **)__dst, (unsigned __int16 *)(v73 + 136), (unsigned __int16 *)(v73 + 136), buf);
      goto LABEL_139;
    }
    unint64_t v76 = (void **)sub_19E09D6CC((uint64_t)__dst, buf, (unsigned __int16 *)(v73 + 136));
    size_t v77 = (char *)*v76;
    if (!*v76)
    {
      unint64_t v78 = v76;
      size_t v77 = (char *)operator new(0x38uLL);
      uint64_t v79 = v77 + 32;
      unint64_t v80 = *v75;
      if (v80 >= 0xF)
      {
        *uint64_t v79 = v80;
        operator new[]();
      }
      *(_OWORD *)uint64_t v79 = *(_OWORD *)v75;
      *((_DWORD *)v77 + 12) = 0;
      uint64_t v81 = *(void **)buf;
      *(void *)size_t v77 = 0;
      *((void *)v77 + 1) = 0;
      *((void *)v77 + 2) = v81;
      void *v78 = v77;
      uint64_t v82 = (uint64_t *)v77;
      if (*(void *)__dst[0])
      {
        __dst[0] = *(void **)__dst[0];
        uint64_t v82 = (uint64_t *)*v78;
      }
      sub_19E05D650((uint64_t *)__dst[1], v82);
      ++v225;
    }
    int v83 = *((_DWORD *)v77 + 12);
    int v84 = v83 & 0x3FFFFFFF;
    if (v74 < (v83 & 0x3FFFFFFFu)) {
      int v84 = v74;
    }
    unsigned int v85 = v84 | v83 & 0xC0000000;
    *((_DWORD *)v77 + 12) = v85;
    if ((v83 & 0x40000000) != 0) {
      break;
    }
    unsigned int v86 = v85 & 0xBFFFFFFF;
    if ((*(_DWORD *)(*(void *)v71 + 56) & 0xFFF000) != 0) {
      goto LABEL_137;
    }
    int v87 = 0;
LABEL_138:
    *((_DWORD *)v77 + 12) = v87 | v86;
LABEL_139:
    v71 += 8;
  }
  unsigned int v86 = v85 & 0xBFFFFFFF;
LABEL_137:
  int v87 = 0x40000000;
  goto LABEL_138;
}

void sub_19E09B2F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,int a48,__int16 a49,char a50,void *a51,uint64_t a52,uint64_t a53,void *a54)
{
  if (a42 < 0)
  {
    operator delete(__p);
    if ((v55 & 1) == 0)
    {
LABEL_6:
      sub_19E053BB4((uint64_t)&a54);
      sub_19E039A20((uint64_t)&a19);
      if (a51)
      {
        if (a50 == 1) {
          free(a51);
        }
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v55)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v54);
  goto LABEL_6;
}

void sub_19E09BB14(uint64_t a1, ssize_t a2, int a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  unsigned int v32 = 0x1000000;
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  unsigned int v32 = 50331648;
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  unsigned int v32 = 352321536;
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  int v30 = 0;
  ucol_getVersion();
  sub_19E0F185C(a2, (uint64_t)&v30, 4);
  ucol_getUCAVersion();
  sub_19E0F185C(a2, (uint64_t)&v30, 4);
  sub_19E0F185C(a2, a1, 16);
  if (a3)
  {
    *(float *)&unsigned int v6 = *(double *)(*(void *)(a1 + 272) + 40);
    unsigned int v32 = bswap32(v6);
  }
  else
  {
    unsigned int v32 = bswap32((*(void *)(*(void *)(a1 + 280) + 8) - **(void **)(a1 + 280)) >> 3);
  }
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  uint64_t v7 = *(void *)(a1 + 240);
  if ((v7 & 0x20) != 0) {
    int v8 = 24596;
  }
  else {
    int v8 = 24580;
  }
  int8x16_t v9 = vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v7), (uint32x4_t)xmmword_19E1240C0), (int8x16_t)xmmword_19E1240D0);
  int8x8_t v10 = vorr_s8(*(int8x8_t *)v9.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
  int v11 = v10.i32[0] | v7 & 0x400 | v10.i32[1] | (v7 >> 3) & 2 | (v7 >> 4) & 8 | v8 & 0xFFFBFFFF | (((v7 >> 3) & 1) << 18);
  if (!*(_DWORD *)(a1 + 1764)) {
    v11 |= 0x100u;
  }
  if (*(_DWORD *)(a1 + 1768)) {
    v11 |= 0x1000u;
  }
  if ((v7 & 0x2000000) != 0) {
    unsigned int v12 = (v7 >> 2) & 0x80000 | (((v7 >> 11) & 1) << 20) | v11;
  }
  else {
    unsigned int v12 = (v7 >> 2) & 0x80000 | (((v7 >> 11) & 1) << 20) | v11 | 0x400000;
  }
  unsigned int v32 = bswap32(v12);
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  if (!a3)
  {
    unsigned int v32 = bswap32(*(_DWORD *)(a1 + 1960));
    sub_19E0F185C(a2, (uint64_t)&v32, 4);
    unsigned int v32 = 0;
    sub_19E0F185C(a2, (uint64_t)&v32, 4);
    unsigned int v32 = 0;
    sub_19E0F185C(a2, (uint64_t)&v32, 4);
    unsigned int v32 = 0x80000000;
    sub_19E0F185C(a2, (uint64_t)&v32, 4);
    unsigned int v32 = 0;
    sub_19E0F185C(a2, (uint64_t)&v32, 4);
LABEL_65:
    unsigned int v18 = 0;
    goto LABEL_67;
  }
  unsigned int v32 = 0x100000;
  __int16 v33 = 0;
  char v34 = 0;
  uint64_t v35 = 0;
  LOBYTE(v36) = 0;
  if (v12) {
    sub_19E039CC0((unsigned __int16 *)&v32, " DenseKeyCodes,", 0xFFFFuLL);
  }
  if ((v12 & 2) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " CommonLetterForms,", 0xFFFFuLL);
  }
  if ((v12 & 8) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " SubstitutionLists,", 0xFFFFuLL);
  }
  if ((v12 & 4) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " UnigramRecordV2,", 0xFFFFuLL);
  }
  if ((v12 & 0x2000) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " VarByteTrieNodesV2,", 0xFFFFuLL);
  }
  if ((v12 & 0x4000) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " RelativeChildOffsetsV2,", 0xFFFFuLL);
  }
  if ((v12 & 0x10) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " SkipDerivableUnigrams,", 0xFFFFuLL);
  }
  if ((v12 & 0x40) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " PatriciaTrieRuns,", 0xFFFFuLL);
  }
  if ((v12 & 0x80) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " CompressTrieTails,", 0xFFFFuLL);
  }
  if ((v12 & 0x20) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " NonDerivablePrefixUnigrams,", 0xFFFFuLL);
  }
  if ((v12 & 0x400) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " Exclude0FreqWords,", 0xFFFFuLL);
  }
  if ((v12 & 0x100) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " AllSortKeysAreDistributive,", 0xFFFFuLL);
  }
  if ((v12 & 0x1000) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " SortKeysChangeRetroactively", 0xFFFFuLL);
  }
  if ((v12 & 0x10000) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " WriteWordIds", 0xFFFFuLL);
  }
  if ((v12 & 0x20000) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " Write4ByteUnigramOffsets", 0xFFFFuLL);
  }
  if ((v12 & 0x40000) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " HuffmanEncodeSurfaceForms", 0xFFFFuLL);
  }
  if ((v12 & 0x400000) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " CollationMappingTable", 0xFFFFuLL);
  }
  if ((*(unsigned char *)(a1 + 243) & 4) != 0) {
    sub_19E039CC0((unsigned __int16 *)&v32, " EnableVisuallyConfusableLookup", 0xFFFFuLL);
  }
  unsigned __int8 v13 = atomic_load(byte_1E9457268);
  if (v13)
  {
    unsigned __int8 v14 = atomic_load(byte_1E94578A0);
    if (v14)
    {
      uint64_t v17 = (const char *)v35;
      if (!v35) {
        uint64_t v17 = (const char *)&v36;
      }
      printf("    Options: %s", v17);
      putchar(10);
    }
    else
    {
      int v15 = sub_19E08D084();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        unsigned __int16 v16 = (uint64_t *)v35;
        if (!v35) {
          unsigned __int16 v16 = &v36;
        }
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = v16;
        _os_log_impl(&dword_19E038000, v15, OS_LOG_TYPE_DEFAULT, "    Options: %s", buf, 0xCu);
      }
    }
  }
  if (v35 && v34 == 1) {
    free(v35);
  }
  unsigned int v32 = bswap32(*(_DWORD *)(a1 + 1960));
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  unsigned int v32 = 0;
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  unsigned int v32 = 0;
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  unsigned int v32 = 0x80000000;
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  unsigned int v32 = 0;
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  if ((*(unsigned char *)(a1 + 240) & 0x10) == 0) {
    goto LABEL_65;
  }
  unsigned int v18 = 8 * *(_DWORD *)(a1 + 1648) + 8;
LABEL_67:
  unsigned int v32 = bswap32(v18);
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  unsigned int v32 = bswap32(v18 + 128);
  sub_19E0F185C(a2, (uint64_t)&v32, 4);
  sub_19E0F1A4C(*(_DWORD *)(a2 + 32), 128);
  if (v18)
  {
    unsigned int v32 = bswap32(*(_DWORD *)(a1 + 1648));
    sub_19E0F185C(a2, (uint64_t)&v32, 4);
    unsigned int v32 = 0;
    sub_19E0F185C(a2, (uint64_t)&v32, 4);
    sub_19E0D36C4((unsigned __int16 *)buf, a1 + 328);
    uint64_t v19 = *(uint8_t **)buf;
    if (*(uint8_t **)buf == &buf[8])
    {
      int v20 = 0;
    }
    else
    {
      int v20 = 0;
      do
      {
        unint64_t v21 = *((unsigned __int16 *)v19 + 20);
        if (v21 <= 4)
        {
          unsigned int v22 = *((_DWORD *)v19 + 8);
          sub_19E0F185C(a2, (uint64_t)(v19 + 42), v21);
          unsigned int v23 = *((unsigned __int16 *)v19 + 20);
          if (v23 <= 3)
          {
            int v24 = 5 - v23;
            do
            {
              LOBYTE(v32) = 0;
              sub_19E0F185C(a2, (uint64_t)&v32, 1);
              --v24;
            }
            while (v24 > 1);
          }
          unsigned int v32 = bswap32(v22);
          sub_19E0F185C(a2, (uint64_t)&v32, 4);
          ++v20;
        }
        unint64_t v25 = (uint8_t *)*((void *)v19 + 1);
        if (v25)
        {
          do
          {
            uint64_t v26 = v25;
            unint64_t v25 = *(uint8_t **)v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            uint64_t v26 = (uint8_t *)*((void *)v19 + 2);
            BOOL v27 = *(void *)v26 == (void)v19;
            uint64_t v19 = v26;
          }
          while (!v27);
        }
        uint64_t v19 = v26;
      }
      while (v26 != &buf[8]);
    }
    if (v20 != *(_DWORD *)(a1 + 1648))
    {
      sub_19E0538DC((uint64_t)&v32);
      sub_19E0416F8(&v36, (uint64_t)"Common sort-key letter form table wrote ", 40);
      unint64_t v28 = (void *)std::ostream::operator<<();
      sub_19E0416F8(v28, (uint64_t)" entries, expected ", 19);
      std::ostream::operator<<();
      exception = __cxa_allocate_exception(0x20uLL);
      sub_19E05EEA4(&__dst, (uint64_t)&v37);
      sub_19E08DA70(exception, &__dst);
      __cxa_throw(exception, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
    }
    sub_19E08DAEC(*(void **)&buf[8]);
  }
}

void sub_19E09C2D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((v38 & 1) == 0)
    {
LABEL_6:
      a17 = *MEMORY[0x1E4FBA408];
      uint64_t v40 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      *(uint64_t *)((char *)&a17 + *(void *)(a17 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
      a19 = v40;
      a20 = MEMORY[0x1E4FBA470] + 16;
      if (a33 < 0) {
        operator delete(a28);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x19F3BA690](&a36);
      sub_19E08DAEC(*(void **)(v37 + 8));
      _Unwind_Resume(a1);
    }
  }
  else if (!v38)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v36);
  goto LABEL_6;
}

uint64_t *sub_19E09C460(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  uint64_t v5 = *(uint64_t ***)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (uint64_t result = *v5; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a3)
    {
      if (*((_DWORD *)result + 4) == a3) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2) {
          v7 %= a2;
        }
      }
      else
      {
        v7 &= a2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void *sub_19E09C50C(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int8x16_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int8x8_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          int8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  int8x8_t v10 = operator new(0x20uLL);
  *int8x8_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  void v10[3] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_19E08A5BC(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *int8x8_t v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  *int8x8_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_19E09C710(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E09C724(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t *), uint64_t a4, char a5)
{
  unint64_t v11 = (uint64_t *)result;
LABEL_2:
  uint64_t v96 = a2 - 2;
  unint64_t v97 = a2 - 1;
  uint64_t v95 = a2 - 3;
  float v12 = v11;
  uint64_t v99 = a2;
  while (1)
  {
    unint64_t v11 = v12;
    uint64_t v13 = (char *)a2 - (char *)v12;
    unint64_t v14 = a2 - v12;
    if (v6 || !v5)
    {
      switch(v14)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t result = (*a3)(v97, v11);
          if (result)
          {
            uint64_t v38 = *v11;
            uint64_t *v11 = *v97;
            *unint64_t v97 = v38;
          }
          break;
        case 3uLL:
          uint64_t result = sub_19E09D144(v11, v11 + 1, v97, a3);
          break;
        case 4uLL:
          uint64_t result = sub_19E09D228(v11, v11 + 1, v11 + 2, v97, a3);
          break;
        case 5uLL:
          uint64_t result = sub_19E09D2DC(v11, v11 + 1, v11 + 2, v11 + 3, v97, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v13 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v11 == a2) {
        return result;
      }
      int64_t v53 = (v14 - 2) >> 1;
      int64_t v98 = v53;
      do
      {
        int64_t v54 = v53;
        if (v98 >= v53)
        {
          uint64_t v55 = (2 * v53) | 1;
          unint64_t v56 = &v11[v55];
          if (2 * v53 + 2 < (uint64_t)v14 && (*a3)(&v11[v55], v56 + 1))
          {
            ++v56;
            uint64_t v55 = 2 * v54 + 2;
          }
          uint64_t v57 = &v11[v54];
          uint64_t result = (*a3)(v56, v57);
          a2 = v99;
          if (!result)
          {
            uint64_t v58 = *v57;
            uint64_t *v57 = 0;
            uint64_t v101 = v58;
            do
            {
              uint64_t v59 = v56;
              uint64_t v60 = *v56;
              *unint64_t v56 = 0;
              uint64_t v61 = *v57;
              uint64_t *v57 = v60;
              if (v61) {
                uint64_t result = sub_19E076DB4(v61 + 84);
              }
              if (v98 < v55) {
                break;
              }
              uint64_t v62 = (2 * v55) | 1;
              unint64_t v56 = &v11[v62];
              uint64_t v55 = 2 * v55 + 2;
              if (v55 < (uint64_t)v14)
              {
                if ((*a3)(&v11[v62], v56 + 1)) {
                  ++v56;
                }
                else {
                  uint64_t v55 = v62;
                }
              }
              else
              {
                uint64_t v55 = v62;
              }
              uint64_t result = (*a3)(v56, &v101);
              uint64_t v57 = v59;
            }
            while (!result);
            uint64_t v63 = v101;
            uint64_t v101 = 0;
            uint64_t v64 = *v59;
            *uint64_t v59 = v63;
            if (v64) {
              uint64_t result = sub_19E076DB4(v64 + 84);
            }
            a2 = v99;
            if (v101) {
              uint64_t result = sub_19E076DB4(v101 + 84);
            }
          }
        }
        int64_t v53 = v54 - 1;
      }
      while (v54);
      uint64_t v65 = (unint64_t)v13 >> 3;
      while (2)
      {
        unsigned __int8 v100 = a2;
        if (v65 >= 2)
        {
          uint64_t v66 = 0;
          uint64_t v67 = *v11;
          uint64_t *v11 = 0;
          unint64_t v68 = v11;
          do
          {
            unsigned int v69 = &v68[v66 + 1];
            uint64_t v70 = 2 * v66;
            uint64_t v66 = (2 * v66) | 1;
            uint64_t v71 = v70 + 2;
            if (v70 + 2 < v65)
            {
              uint64_t result = (*a3)(v69, v69 + 1);
              if (result)
              {
                ++v69;
                uint64_t v66 = v71;
              }
            }
            uint64_t v72 = *v69;
            uint64_t *v69 = 0;
            uint64_t v73 = *v68;
            *unint64_t v68 = v72;
            if (v73) {
              uint64_t result = sub_19E076DB4(v73 + 84);
            }
            unint64_t v68 = v69;
          }
          while (v66 <= (uint64_t)((unint64_t)(v65 - 2) >> 1));
          unsigned int v74 = a2 - 1;
          if (v69 == a2 - 1)
          {
            uint64_t v87 = *v69;
            uint64_t *v69 = v67;
            if (!v87) {
              goto LABEL_145;
            }
          }
          else
          {
            uint64_t v75 = *v74;
            *unsigned int v74 = 0;
            uint64_t v76 = *v69;
            uint64_t *v69 = v75;
            if (v76) {
              uint64_t result = sub_19E076DB4(v76 + 84);
            }
            uint64_t v77 = *v74;
            *unsigned int v74 = v67;
            if (v77) {
              uint64_t result = sub_19E076DB4(v77 + 84);
            }
            uint64_t v78 = (char *)v69 - (char *)v11 + 8;
            if (v78 < 9) {
              goto LABEL_145;
            }
            unint64_t v79 = (unint64_t)((v78 >> 3) - 2) >> 1;
            unint64_t v80 = &v11[v79];
            uint64_t result = (*a3)(v80, v69);
            if (!result) {
              goto LABEL_145;
            }
            uint64_t v81 = *v69;
            uint64_t *v69 = 0;
            uint64_t v101 = v81;
            do
            {
              uint64_t v82 = v80;
              uint64_t v83 = *v80;
              uint64_t *v80 = 0;
              uint64_t v84 = *v69;
              uint64_t *v69 = v83;
              if (v84) {
                uint64_t result = sub_19E076DB4(v84 + 84);
              }
              if (!v79) {
                break;
              }
              unint64_t v79 = (v79 - 1) >> 1;
              unint64_t v80 = &v11[v79];
              uint64_t result = (*a3)(v80, &v101);
              unsigned int v69 = v82;
            }
            while (result);
            uint64_t v85 = v101;
            uint64_t v101 = 0;
            uint64_t v86 = *v82;
            *uint64_t v82 = v85;
            if (!v86) {
              goto LABEL_145;
            }
            uint64_t result = sub_19E076DB4(v86 + 84);
            uint64_t v87 = v101;
            if (!v101) {
              goto LABEL_145;
            }
          }
          uint64_t result = sub_19E076DB4(v87 + 84);
        }
LABEL_145:
        a2 = v100 - 1;
        if ((unint64_t)v65-- <= 2) {
          return result;
        }
        continue;
      }
    }
    unint64_t v15 = &v11[v14 >> 1];
    if ((unint64_t)v13 >= 0x401)
    {
      sub_19E09D144(v11, &v11[v14 >> 1], v97, a3);
      sub_19E09D144(v11 + 1, v15 - 1, v96, a3);
      sub_19E09D144(v11 + 2, &v11[(v14 >> 1) + 1], v95, a3);
      sub_19E09D144(v15 - 1, &v11[v14 >> 1], &v11[(v14 >> 1) + 1], a3);
      uint64_t v16 = *v11;
      uint64_t *v11 = *v15;
      uint64_t *v15 = v16;
    }
    else
    {
      sub_19E09D144(&v11[v14 >> 1], v11, v97, a3);
    }
    --a4;
    a2 = v99;
    if ((a5 & 1) != 0 || (*a3)(v11 - 1, v11))
    {
      uint64_t v17 = *v11;
      uint64_t *v11 = 0;
      uint64_t v101 = v17;
      uint64_t v18 = v11;
      do
        ++v18;
      while ((*a3)(v18, &v101));
      uint64_t v19 = v18 - 1;
      unint64_t v20 = v99;
      if (v18 - 1 == v11)
      {
        unint64_t v20 = v99;
        do
        {
          if (v18 >= v20) {
            break;
          }
          --v20;
        }
        while (!(*a3)(v20, &v101));
      }
      else
      {
        do
          --v20;
        while (!(*a3)(v20, &v101));
      }
      if (v18 < v20)
      {
        unint64_t v21 = v18;
        unsigned int v22 = v20;
        do
        {
          uint64_t v23 = *v21;
          uint64_t *v21 = *v22;
          uint64_t *v22 = v23;
          do
            ++v21;
          while ((*a3)(v21, &v101));
          uint64_t v19 = v21 - 1;
          do
            --v22;
          while (!(*a3)(v22, &v101));
        }
        while (v21 < v22);
      }
      if (v19 != v11)
      {
        uint64_t v24 = *v19;
        uint64_t *v19 = 0;
        uint64_t v25 = *v11;
        uint64_t *v11 = v24;
        if (v25) {
          sub_19E076DB4(v25 + 84);
        }
      }
      uint64_t v26 = v101;
      uint64_t v101 = 0;
      uint64_t v27 = *v19;
      uint64_t *v19 = v26;
      if (v27) {
        sub_19E076DB4(v27 + 84);
      }
      if (v101) {
        sub_19E076DB4(v101 + 84);
      }
      if (v18 < v20) {
        goto LABEL_37;
      }
      BOOL v28 = sub_19E09D3B8(v11, v19, a3);
      float v12 = v19 + 1;
      uint64_t result = sub_19E09D3B8(v19 + 1, v99, a3);
      if (result)
      {
        a2 = v19;
        if (v28) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v28)
      {
LABEL_37:
        uint64_t result = sub_19E09C724(v11, v19, a3, a4, a5 & 1);
        a5 = 0;
        float v12 = v19 + 1;
      }
    }
    else
    {
      uint64_t v29 = *v11;
      uint64_t *v11 = 0;
      uint64_t v101 = v29;
      uint64_t result = (*a3)(&v101, v97);
      float v12 = v11;
      if (result)
      {
        do
          uint64_t result = (*a3)(&v101, ++v12);
        while (!result);
      }
      else
      {
        int v30 = v11 + 1;
        do
        {
          float v12 = v30;
          if (v30 >= v99) {
            break;
          }
          uint64_t result = (*a3)(&v101, v30);
          int v30 = v12 + 1;
        }
        while (!result);
      }
      uint64_t v31 = v99;
      if (v12 < v99)
      {
        uint64_t v31 = v99;
        do
          uint64_t result = (*a3)(&v101, --v31);
        while (result);
      }
      while (v12 < v31)
      {
        uint64_t v32 = *v12;
        uint64_t *v12 = *v31;
        *uint64_t v31 = v32;
        do
          ++v12;
        while (!(*a3)(&v101, v12));
        do
          uint64_t result = (*a3)(&v101, --v31);
        while (result);
      }
      __int16 v33 = v12 - 1;
      BOOL v5 = v12 - 1 >= v11;
      BOOL v6 = v12 - 1 == v11;
      if (v12 - 1 != v11)
      {
        uint64_t v34 = *v33;
        *__int16 v33 = 0;
        uint64_t v35 = *v11;
        uint64_t *v11 = v34;
        if (v35) {
          uint64_t result = sub_19E076DB4(v35 + 84);
        }
      }
      uint64_t v36 = v101;
      uint64_t v101 = 0;
      uint64_t v37 = *v33;
      *__int16 v33 = v36;
      if (v37) {
        uint64_t result = sub_19E076DB4(v37 + 84);
      }
      if (v101) {
        uint64_t result = sub_19E076DB4(v101 + 84);
      }
      a5 = 0;
    }
  }
  uint64_t v39 = v11 + 1;
  BOOL v41 = v11 == a2 || v39 == a2;
  if (a5)
  {
    if (!v41)
    {
      uint64_t v42 = 0;
      unint64_t v43 = v11;
      do
      {
        uint64_t v44 = v43;
        unint64_t v43 = v39;
        uint64_t result = (*a3)(v39, v44);
        if (result)
        {
          uint64_t v45 = 0;
          uint64_t v46 = *v43;
          *unint64_t v43 = 0;
          uint64_t v101 = v46;
          for (uint64_t i = v42; ; i -= 8)
          {
            unsigned __int8 v48 = (uint64_t *)((char *)v11 + i);
            uint64_t v49 = *(uint64_t *)((char *)v11 + i);
            *unsigned __int8 v48 = 0;
            v48[1] = v49;
            if (v45) {
              uint64_t result = sub_19E076DB4(v45 + 84);
            }
            if (!i)
            {
              uint64_t v50 = v11;
              goto LABEL_92;
            }
            uint64_t result = (*a3)(&v101, (uint64_t *)((char *)v11 + i - 8));
            if (!result) {
              break;
            }
            uint64_t v45 = *v48;
          }
          uint64_t v50 = (uint64_t *)((char *)v11 + i);
LABEL_92:
          a2 = v99;
          uint64_t v51 = v101;
          uint64_t v101 = 0;
          uint64_t v52 = *v50;
          *uint64_t v50 = v51;
          if (v52)
          {
            uint64_t result = sub_19E076DB4(v52 + 84);
            if (v101) {
              uint64_t result = sub_19E076DB4(v101 + 84);
            }
          }
        }
        uint64_t v39 = v43 + 1;
        v42 += 8;
      }
      while (v43 + 1 != a2);
    }
  }
  else if (!v41)
  {
    do
    {
      uint64_t v89 = v39;
      uint64_t result = (*a3)(v39, v11);
      if (result)
      {
        uint64_t v90 = 0;
        uint64_t v91 = *v89;
        uint64_t *v89 = 0;
        uint64_t v101 = v91;
        while (1)
        {
          uint64_t v92 = *v11;
          uint64_t *v11 = 0;
          v11[1] = v92;
          if (v90) {
            sub_19E076DB4(v90 + 84);
          }
          uint64_t result = (*a3)(&v101, v11 - 1);
          if (!result) {
            break;
          }
          uint64_t v90 = *v11--;
        }
        uint64_t v93 = v101;
        uint64_t v101 = 0;
        uint64_t v94 = *v11;
        uint64_t *v11 = v93;
        if (v94)
        {
          uint64_t result = sub_19E076DB4(v94 + 84);
          if (v101) {
            uint64_t result = sub_19E076DB4(v101 + 84);
          }
        }
      }
      uint64_t v39 = v89 + 1;
      unint64_t v11 = v89;
    }
    while (v89 + 1 != a2);
  }
  return result;
}

void sub_19E09D0C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    sub_19E076DB4(a14 + 84);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E09D144(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t (**a4)(uint64_t *, uint64_t *))
{
  int v8 = (*a4)(a2, a1);
  uint64_t result = (*a4)(a3, a2);
  if (v8)
  {
    uint64_t v10 = *a1;
    if (result)
    {
      *a1 = *a3;
    }
    else
    {
      *a1 = *a2;
      *a2 = v10;
      uint64_t result = (*a4)(a3, a2);
      if (!result) {
        return result;
      }
      uint64_t v10 = *a2;
      *a2 = *a3;
    }
    *a3 = v10;
  }
  else if (result)
  {
    uint64_t v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    uint64_t result = (*a4)(a2, a1);
    if (result)
    {
      uint64_t v12 = *a1;
      *a1 = *a2;
      *a2 = v12;
    }
  }
  return result;
}

uint64_t sub_19E09D228(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t (**a5)(uint64_t *, uint64_t *))
{
  sub_19E09D144(a1, a2, a3, a5);
  uint64_t result = (*a5)(a4, a3);
  if (result)
  {
    uint64_t v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    uint64_t result = (*a5)(a3, a2);
    if (result)
    {
      uint64_t v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      uint64_t result = (*a5)(a2, a1);
      if (result)
      {
        uint64_t v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

uint64_t sub_19E09D2DC(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t (**a6)(uint64_t *, uint64_t *))
{
  sub_19E09D228(a1, a2, a3, a4, a6);
  uint64_t result = (*a6)(a5, a4);
  if (result)
  {
    uint64_t v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    uint64_t result = (*a6)(a4, a3);
    if (result)
    {
      uint64_t v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      uint64_t result = (*a6)(a3, a2);
      if (result)
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        uint64_t result = (*a6)(a2, a1);
        if (result)
        {
          uint64_t v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

BOOL sub_19E09D3B8(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t *))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v8 = a2 - 1;
      if ((*a3)(a2 - 1, a1))
      {
        uint64_t v9 = *a1;
        *a1 = *v8;
        *int v8 = v9;
      }
      return 1;
    case 3:
      sub_19E09D144(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      sub_19E09D228(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      sub_19E09D2DC(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      sub_19E09D144(a1, a1 + 1, a1 + 2, a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v11, v10))
    {
      uint64_t v14 = 0;
      uint64_t v15 = *v11;
      uint64_t *v11 = 0;
      uint64_t v22 = v15;
      for (uint64_t i = v12; ; i -= 8)
      {
        uint64_t v17 = (char *)a1 + i;
        uint64_t v18 = *(uint64_t *)((char *)a1 + i + 16);
        *((void *)v17 + 2) = 0;
        *((void *)v17 + 3) = v18;
        if (v14) {
          sub_19E076DB4(v14 + 84);
        }
        if (i == -16)
        {
          uint64_t v19 = a1;
          goto LABEL_15;
        }
        if (!(*a3)(&v22, (uint64_t *)((char *)a1 + i + 8))) {
          break;
        }
        uint64_t v14 = *((void *)v17 + 2);
      }
      uint64_t v19 = (uint64_t *)((char *)a1 + i + 16);
LABEL_15:
      uint64_t v20 = v22;
      uint64_t v22 = 0;
      uint64_t v21 = *v19;
      uint64_t *v19 = v20;
      if (v21) {
        sub_19E076DB4(v21 + 84);
      }
      if (v22) {
        sub_19E076DB4(v22 + 84);
      }
      if (++v13 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
}

void sub_19E09D5C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_19E076DB4(a10 + 84);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_19E09D5F4(std::string *a1, char *__s, std::string *a3)
{
  std::string::size_type v6 = strlen(__s);
  unint64_t v7 = (__n128 *)std::string::insert(a3, 0, __s, v6);
  __n128 result = *v7;
  *a1 = *(std::string *)v7->n128_u8;
  v7->n128_u64[0] = 0;
  v7->n128_u64[1] = 0;
  v7[1].n128_u64[0] = 0;
  return result;
}

void sub_19E09D658(void *a1)
{
  if (a1)
  {
    sub_19E09D658(*a1);
    sub_19E09D658(a1[1]);
    if (*((unsigned __int16 *)a1 + 16) >= 0xFu)
    {
      uint64_t v2 = a1[5];
      if (v2) {
        MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
      }
    }
    operator delete(a1);
  }
}

void *sub_19E09D6CC(uint64_t a1, void *a2, unsigned __int16 *a3)
{
  BOOL v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        unint64_t v7 = (void *)v4;
        int v8 = (unsigned __int16 *)(v4 + 32);
        if (!sub_19E0A70C4(a3, (unsigned __int16 *)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v7;
        BOOL v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_19E0A70C4(v8, a3)) {
        break;
      }
      BOOL v5 = v7 + 1;
      uint64_t v4 = v7[1];
    }
    while (v4);
  }
  else
  {
    unint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void sub_19E09D760(char a1, void *__p)
{
  if (a1)
  {
    if (*((unsigned __int16 *)__p + 16) >= 0xFu)
    {
      uint64_t v3 = __p[5];
      if (v3) {
        MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
      }
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_19E09D7D8(uint64_t a1)
{
  uint64_t v377 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = **(void **)(a1 + 280);
  if (*(void *)(*(void *)(a1 + 280) + 8) != v3)
  {
    unint64_t v4 = 0;
    int v5 = 0;
    uint64_t v352 = (void *)(a1 + 1736);
    uint64_t v351 = a1 + 328;
    while (1)
    {
      int v349 = v5;
      uint64_t v6 = *(void *)(v3 + 8 * v4);
      unsigned __int16 v360 = 0;
      v375.n128_u32[0] = 0x100000;
      v375.n128_u16[2] = 0;
      v375.n128_u8[6] = 0;
      v375.n128_u64[1] = 0;
      LOBYTE(v376[0]) = 0;
      v373.n128_u32[0] = 0x100000;
      v373.n128_u16[2] = 0;
      v373.n128_u8[6] = 0;
      v373.n128_u64[1] = 0;
      v374[0] = 0;
      sub_19E039858((uint64_t)v371, (unsigned __int16 *)v6);
      unsigned int v7 = 0;
      for (i = 0; ; unsigned int v7 = HIWORD(i))
      {
        unsigned int v8 = *(unsigned __int16 *)&v371[4];
        if (!*(_WORD *)&v371[4])
        {
          sub_19E0398F4((unsigned __int16 *)v371);
          unsigned int v8 = *(unsigned __int16 *)&v371[4];
        }
        if (v7 >= v8) {
          break;
        }
        unsigned int v9 = sub_19E0DE8C0((uint64_t)v371);
        sub_19E0B14D0((unsigned __int16 *)&v373, v9);
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(v6 + 312) + 8))(&v358);
        if (v360 && !sub_19E0A7064((unsigned __int16 *)&v358, &v360))
        {
          if ((*(unsigned char *)(v6 + 329) & 0x80) != 0)
          {
            unsigned __int8 v15 = atomic_load(byte_1E9457268);
            if (v15)
            {
              unsigned __int8 v16 = atomic_load(byte_1E94578A0);
              if (v16)
              {
                if (v375.n128_u64[1]) {
                  uint64_t v36 = (const char *)v375.n128_u64[1];
                }
                else {
                  uint64_t v36 = (const char *)v376;
                }
                if (v373.n128_u64[1]) {
                  uint64_t v37 = (const char *)v373.n128_u64[1];
                }
                else {
                  uint64_t v37 = v374;
                }
                if (*(void *)(v6 + 8)) {
                  uint64_t v38 = *(const char **)(v6 + 8);
                }
                else {
                  uint64_t v38 = (const char *)(v6 + 16);
                }
                if (v360 <= 0xEu) {
                  uint64_t v39 = v361;
                }
                else {
                  uint64_t v39 = v362;
                }
                sub_19E0DD6FC((uint64_t)buf, v39, v360, v10, v11, v12, v13, v14);
                uint64_t v45 = *(const char **)&buf[8];
                if ((unsigned __int16)v358 <= 0xEu) {
                  uint64_t v46 = (char *)&v358 + 2;
                }
                else {
                  uint64_t v46 = v359;
                }
                sub_19E0DD6FC((uint64_t)&__p, v46, (unsigned __int16)v358, v40, v41, v42, v43, v44);
                size_t v47 = &buf[16];
                if (v45) {
                  size_t v47 = v45;
                }
                unsigned __int8 v48 = (const char *)v367;
                if (!v367) {
                  unsigned __int8 v48 = (const char *)v368;
                }
                printf("NOTE: Prefix sort-key changed retroactively at %s -> %s for %s:  0x%s -> 0x%s ", v36, v37, v38, v47, v48);
                if (v367 && BYTE6(__p) == 1) {
                  free(v367);
                }
                if (*(void *)&buf[8] && buf[6] == 1) {
                  free(*(void **)&buf[8]);
                }
                putchar(10);
              }
              else
              {
                uint64_t v17 = sub_19E08D084();
                if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
                {
                  if (v375.n128_u64[1]) {
                    uint64_t v23 = (_DWORD *)v375.n128_u64[1];
                  }
                  else {
                    uint64_t v23 = v376;
                  }
                  if (v373.n128_u64[1]) {
                    uint64_t v24 = (unsigned char *)v373.n128_u64[1];
                  }
                  else {
                    uint64_t v24 = v374;
                  }
                  if (*(void *)(v6 + 8)) {
                    uint64_t v25 = *(void *)(v6 + 8);
                  }
                  else {
                    uint64_t v25 = v6 + 16;
                  }
                  if (v360 <= 0xEu) {
                    uint64_t v26 = v361;
                  }
                  else {
                    uint64_t v26 = v362;
                  }
                  sub_19E0DD6FC((uint64_t)&__p, v26, v360, v18, v19, v20, v21, v22);
                  uint64_t v32 = v367;
                  if ((unsigned __int16)v358 <= 0xEu) {
                    __int16 v33 = (char *)&v358 + 2;
                  }
                  else {
                    __int16 v33 = v359;
                  }
                  sub_19E0DD6FC((uint64_t)&v363, v33, (unsigned __int16)v358, v27, v28, v29, v30, v31);
                  uint64_t v34 = (uint64_t *)v364;
                  uint64_t v35 = v368;
                  if (v32) {
                    uint64_t v35 = v32;
                  }
                  *(_DWORD *)buf = 136316162;
                  if (!v364) {
                    uint64_t v34 = &v365;
                  }
                  *(void *)&uint8_t buf[4] = v23;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v24;
                  *(_WORD *)&buf[22] = 2080;
                  *(void *)&uint8_t buf[24] = v25;
                  *(_WORD *)&uint8_t buf[32] = 2080;
                  *(void *)&buf[34] = v35;
                  *(_WORD *)&buf[42] = 2080;
                  uint64_t v370 = v34;
                  _os_log_impl(&dword_19E038000, v17, OS_LOG_TYPE_DEFAULT, "NOTE: Prefix sort-key changed retroactively at %s -> %s for %s:  0x%s -> 0x%s ", buf, 0x34u);
                  if (v364 && BYTE6(v363) == 1) {
                    free(v364);
                  }
                  if (v367 && BYTE6(__p) == 1) {
                    free(v367);
                  }
                }
              }
            }
          }
          if ((unsigned __int16)v358 >= 0xFu && v359) {
            MEMORY[0x19F3BA6E0](v359, 0x1000C8077774924);
          }
          break;
        }
        sub_19E03CD54((uint64_t)&v375, (unsigned __int16 *)&v373);
        sub_19E0A6FD4(&v360, (unsigned __int16 *)&v358);
        if ((unsigned __int16)v358 >= 0xFu)
        {
          if (v359) {
            MEMORY[0x19F3BA6E0](v359, 0x1000C8077774924);
          }
        }
      }
      if (*(void *)&v371[8]) {
        BOOL v49 = v371[6] == 1;
      }
      else {
        BOOL v49 = 0;
      }
      if (v49) {
        free(*(void **)&v371[8]);
      }
      if (v373.n128_u64[1] && v373.n128_u8[6] == 1) {
        free((void *)v373.n128_u64[1]);
      }
      if (v375.n128_u64[1] && v375.n128_u8[6] == 1) {
        free((void *)v375.n128_u64[1]);
      }
      if (v360 >= 0xFu && v362) {
        MEMORY[0x19F3BA6E0](v362, 0x1000C8077774924);
      }
      if (v7 < v8) {
        ++*(_DWORD *)(a1 + 1768);
      }
      uint64_t v50 = *(void *)(v6 + 112);
      unint64_t v51 = v6 + 120;
      if (!v50) {
        uint64_t v50 = v6 + 120;
      }
      *(void *)uint64_t v371 = v50;
      unsigned int v52 = *(unsigned __int16 *)(v6 + 104);
      *(_DWORD *)&v371[8] = 0;
      *(void *)&v371[12] = v52;
      sub_19E03E768((uint64_t *)v371);
      unsigned __int32 v53 = *(unsigned __int16 *)(v6 + 104);
      unint64_t v54 = *(void *)(v6 + 112);
      if (!v54) {
        unint64_t v54 = v6 + 120;
      }
      v375.n128_u64[0] = v54;
      v375.n128_u32[2] = v53;
      v375.n128_u32[3] = v53;
      v376[0] = 0;
      sub_19E03E768((uint64_t *)&v375);
      uint64_t v355 = *(void *)v371;
      uint64_t v55 = v351;
      if (*(void *)v371 != v375.n128_u64[0]) {
        goto LABEL_503;
      }
      unsigned __int32 v357 = v375.n128_u32[2];
LABEL_94:
      if (*(_DWORD *)&v371[8] != v357) {
        break;
      }
      unint64_t v4 = (v349 + 1);
      uint64_t v3 = **(void **)(a1 + 280);
      int v5 = v349 + 1;
      if (v4 >= (*(void *)(*(void *)(a1 + 280) + 8) - v3) >> 3) {
        goto LABEL_192;
      }
    }
    uint64_t v56 = *(unsigned int *)&v371[16];
    sub_19E08D1E0(&v373, v55, *(unsigned int *)&v371[16]);
    if (v373.n128_u16[0] >= 0xFu)
    {
      *(_WORD *)buf = v373.n128_u16[0];
      operator new[]();
    }
    *(__n128 *)buf = v373;
    unsigned int v57 = v373.n128_u16[0];
    *(_DWORD *)&uint8_t buf[16] = v56;
    unsigned int v58 = sub_19E0B24AC(&buf[2], v373.n128_u16[0]);
    unint64_t v1 = v56 + v58;
    unint64_t v59 = *(void *)(a1 + 1728);
    if (v59)
    {
      uint8x8_t v60 = (uint8x8_t)vcnt_s8((int8x8_t)v59);
      v60.i16[0] = vaddlv_u8(v60);
      unint64_t v61 = v60.u32[0];
      if (v60.u32[0] > 1uLL)
      {
        unint64_t v51 = v56 + v58;
        if (v1 >= v59) {
          unint64_t v51 = v1 % v59;
        }
      }
      else
      {
        unint64_t v51 = (v59 - 1) & v1;
      }
      uint64_t v62 = *(void ***)(*(void *)(a1 + 1720) + 8 * v51);
      if (v62)
      {
        uint64_t v63 = (char *)*v62;
        if (*v62)
        {
          while (1)
          {
            unint64_t v64 = *((void *)v63 + 1);
            if (v64 == v1)
            {
              if (sub_19E0A7134((unsigned __int16 *)v63 + 8, (unsigned __int16 *)buf)
                && *((_DWORD *)v63 + 8) == v56)
              {
                uint64_t v55 = v351;
LABEL_174:
                ++*((_DWORD *)v63 + 10);
                if (v57 >= 0xF && *(void *)&buf[8]) {
                  MEMORY[0x19F3BA6E0](*(void *)&buf[8], 0x1000C8077774924);
                }
                if (v373.n128_u16[0] >= 0xFu && v373.n128_u64[1]) {
                  MEMORY[0x19F3BA6E0](v373.n128_u64[1], 0x1000C8077774924);
                }
                sub_19E03E768((uint64_t *)v371);
                if (*(void *)v371 != v355) {
LABEL_503:
                }
                  __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
                goto LABEL_94;
              }
            }
            else
            {
              if (v61 > 1)
              {
                if (v64 >= v59) {
                  v64 %= v59;
                }
              }
              else
              {
                v64 &= v59 - 1;
              }
              if (v64 != v51)
              {
LABEL_114:
                uint64_t v55 = v351;
                break;
              }
            }
            uint64_t v63 = *(char **)v63;
            if (!v63) {
              goto LABEL_114;
            }
          }
        }
      }
    }
    uint64_t v63 = (char *)operator new(0x30uLL);
    *(void *)uint64_t v63 = 0;
    *((void *)v63 + 1) = v1;
    uint64_t v65 = v63 + 16;
    if (v57 >= 0xF)
    {
      _WORD *v65 = v57;
      operator new[]();
    }
    *(_OWORD *)uint64_t v65 = *(_OWORD *)buf;
    *((_DWORD *)v63 + ++**(_DWORD **)(result + 8) = v56;
    *((_DWORD *)v63 + 1sub_19E060B80(&a9, 0) = 0;
    float v66 = (float)(unint64_t)(*(void *)(a1 + 1744) + 1);
    float v67 = *(float *)(a1 + 1752);
    if (v59 && (float)(v67 * (float)v59) >= v66)
    {
LABEL_164:
      uint64_t v84 = *(void *)(a1 + 1720);
      uint64_t v85 = *(void **)(v84 + 8 * v51);
      if (v85)
      {
        *(void *)uint64_t v63 = *v85;
      }
      else
      {
        *(void *)uint64_t v63 = *v352;
        *uint64_t v352 = v63;
        *(void *)(v84 + 8 * v51) = v352;
        if (!*(void *)v63)
        {
LABEL_173:
          ++*(void *)(a1 + 1744);
          unsigned int v57 = *(unsigned __int16 *)buf;
          goto LABEL_174;
        }
        unint64_t v86 = *(void *)(*(void *)v63 + 8);
        if ((v59 & (v59 - 1)) != 0)
        {
          if (v86 >= v59) {
            v86 %= v59;
          }
        }
        else
        {
          v86 &= v59 - 1;
        }
        uint64_t v85 = (void *)(*(void *)(a1 + 1720) + 8 * v86);
      }
      *uint64_t v85 = v63;
      goto LABEL_173;
    }
    BOOL v68 = (v59 & (v59 - 1)) != 0;
    if (v59 < 3) {
      BOOL v68 = 1;
    }
    unint64_t v69 = v68 | (2 * v59);
    unint64_t v70 = vcvtps_u32_f32(v66 / v67);
    if (v69 <= v70) {
      int8x8_t prime = (int8x8_t)v70;
    }
    else {
      int8x8_t prime = (int8x8_t)v69;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v59 = *(void *)(a1 + 1728);
    if (*(void *)&prime > v59) {
      goto LABEL_130;
    }
    if (*(void *)&prime < v59)
    {
      unint64_t v78 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 1744) / *(float *)(a1 + 1752));
      if (v59 < 3 || (uint8x8_t v79 = (uint8x8_t)vcnt_s8((int8x8_t)v59), v79.i16[0] = vaddlv_u8(v79), v79.u32[0] > 1uLL))
      {
        unint64_t v78 = std::__next_prime(v78);
      }
      else
      {
        uint64_t v80 = 1 << -(char)__clz(v78 - 1);
        if (v78 >= 2) {
          unint64_t v78 = v80;
        }
      }
      if (*(void *)&prime <= v78) {
        int8x8_t prime = (int8x8_t)v78;
      }
      if (*(void *)&prime >= v59)
      {
        unint64_t v59 = *(void *)(a1 + 1728);
      }
      else
      {
        if (prime)
        {
LABEL_130:
          if (*(void *)&prime >> 61) {
            sub_19E0416C4();
          }
          uint64_t v72 = operator new(8 * *(void *)&prime);
          uint64_t v73 = *(void **)(a1 + 1720);
          *(void *)(a1 + 172sub_19E060B80(&a9, 0) = v72;
          if (v73) {
            operator delete(v73);
          }
          uint64_t v74 = 0;
          *(int8x8_t *)(a1 + 172++**(_DWORD **)(result + 8) = prime;
          do
            *(void *)(*(void *)(a1 + 1720) + 8 * v74++) = 0;
          while (*(void *)&prime != v74);
          uint64_t v75 = (void *)*v352;
          if (*v352)
          {
            unint64_t v76 = v75[1];
            uint8x8_t v77 = (uint8x8_t)vcnt_s8(prime);
            v77.i16[0] = vaddlv_u8(v77);
            if (v77.u32[0] > 1uLL)
            {
              if (v76 >= *(void *)&prime) {
                v76 %= *(void *)&prime;
              }
            }
            else
            {
              v76 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)(a1 + 1720) + 8 * v76) = v352;
            uint64_t v81 = (void *)*v75;
            if (*v75)
            {
              do
              {
                unint64_t v82 = v81[1];
                if (v77.u32[0] > 1uLL)
                {
                  if (v82 >= *(void *)&prime) {
                    v82 %= *(void *)&prime;
                  }
                }
                else
                {
                  v82 &= *(void *)&prime - 1;
                }
                if (v82 != v76)
                {
                  uint64_t v83 = *(void *)(a1 + 1720);
                  if (!*(void *)(v83 + 8 * v82))
                  {
                    *(void *)(v83 + 8 * v82) = v75;
                    goto LABEL_155;
                  }
                  *uint64_t v75 = *v81;
                  void *v81 = **(void **)(*(void *)(a1 + 1720) + 8 * v82);
                  **(void **)(*(void *)(a1 + 1720) + 8 * v82) = v81;
                  uint64_t v81 = v75;
                }
                unint64_t v82 = v76;
LABEL_155:
                uint64_t v75 = v81;
                uint64_t v81 = (void *)*v81;
                unint64_t v76 = v82;
              }
              while (v81);
            }
          }
          unint64_t v59 = (unint64_t)prime;
          goto LABEL_159;
        }
        uint64_t v87 = *(void **)(a1 + 1720);
        *(void *)(a1 + 172sub_19E060B80(&a9, 0) = 0;
        if (v87) {
          operator delete(v87);
        }
        unint64_t v59 = 0;
        *(void *)(a1 + 172++**(_DWORD **)(result + 8) = 0;
      }
    }
LABEL_159:
    if ((v59 & (v59 - 1)) != 0)
    {
      if (v1 >= v59) {
        unint64_t v51 = v1 % v59;
      }
      else {
        unint64_t v51 = v1;
      }
    }
    else
    {
      unint64_t v51 = (v59 - 1) & v1;
    }
    goto LABEL_164;
  }
LABEL_192:
  uint64_t v356 = a1 + 328;
  memset(buf, 0, 32);
  *(_DWORD *)&uint8_t buf[32] = 1065353216;
  uint64_t v88 = *(uint64_t **)(a1 + 1736);
  if (v88)
  {
    uint64_t v89 = 0;
    while (1)
    {
      uint64_t v91 = (unsigned __int16 *)(v88 + 2);
      unsigned int v90 = *((unsigned __int16 *)v88 + 8);
      if (v90 <= 0xE) {
        uint64_t v92 = (unsigned __int8 *)v88 + 18;
      }
      else {
        uint64_t v92 = (unsigned __int8 *)v88[3];
      }
      unsigned int v93 = sub_19E0B24AC(v92, v90);
      unint64_t v94 = v93;
      unint64_t v95 = *(void *)&buf[8];
      if (*(void *)&buf[8])
      {
        uint8x8_t v96 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&buf[8]);
        v96.i16[0] = vaddlv_u8(v96);
        unint64_t v97 = v96.u32[0];
        if (v96.u32[0] > 1uLL)
        {
          unint64_t v1 = v93;
          if (*(void *)&buf[8] <= (unint64_t)v93) {
            unint64_t v1 = (unint64_t)v93 % *(void *)&buf[8];
          }
        }
        else
        {
          unint64_t v1 = (*(_DWORD *)&buf[8] - 1) & v93;
        }
        int64_t v98 = *(void ***)(*(void *)buf + 8 * v1);
        if (v98)
        {
          uint64_t v99 = (char *)*v98;
          if (*v98)
          {
            do
            {
              unint64_t v100 = *((void *)v99 + 1);
              if (v100 == v94)
              {
                if (sub_19E0A7134((unsigned __int16 *)v99 + 8, (unsigned __int16 *)v88 + 8))
                {
                  uint64_t v123 = a1 + 328;
                  goto LABEL_272;
                }
              }
              else
              {
                if (v97 > 1)
                {
                  if (v100 >= v95) {
                    v100 %= v95;
                  }
                }
                else
                {
                  v100 &= v95 - 1;
                }
                if (v100 != v1) {
                  break;
                }
              }
              uint64_t v99 = *(char **)v99;
            }
            while (v99);
          }
        }
      }
      uint64_t v99 = (char *)operator new(0x28uLL);
      *(void *)uint64_t v99 = 0;
      *((void *)v99 + 1) = v94;
      uint64_t v101 = v99 + 16;
      unint64_t v102 = *v91;
      if (v102 >= 0xF)
      {
        *uint64_t v101 = v102;
        operator new[]();
      }
      *(_OWORD *)uint64_t v101 = *(_OWORD *)v91;
      uint64_t v123 = a1 + 328;
      *((void *)v99 + 4) = 0;
      float v103 = (float)(unint64_t)(v89 + 1);
      if (!v95 || (float)(*(float *)&buf[32] * (float)v95) < v103) {
        break;
      }
LABEL_262:
      uint64_t v119 = *(void *)buf;
      unint64_t v120 = *(void **)(*(void *)buf + 8 * v1);
      if (v120)
      {
        *(void *)uint64_t v99 = *v120;
      }
      else
      {
        *(void *)uint64_t v99 = *(void *)&buf[16];
        *(void *)&uint8_t buf[16] = v99;
        *(void *)(v119 + 8 * v1) = &buf[16];
        if (!*(void *)v99) {
          goto LABEL_271;
        }
        unint64_t v121 = *(void *)(*(void *)v99 + 8);
        if ((v95 & (v95 - 1)) != 0)
        {
          if (v121 >= v95) {
            v121 %= v95;
          }
        }
        else
        {
          v121 &= v95 - 1;
        }
        unint64_t v120 = (void *)(*(void *)buf + 8 * v121);
      }
      void *v120 = v99;
LABEL_271:
      uint64_t v89 = ++*(void *)&buf[24];
LABEL_272:
      unsigned int v122 = *((_DWORD *)v88 + 10);
      if (v122 > *((_DWORD *)v99 + 9))
      {
        *((_DWORD *)v99 + ++**(_DWORD **)(result + 8) = *((_DWORD *)v88 + 8);
        *((_DWORD *)v99 + 9) = v122;
      }
      uint64_t v88 = (uint64_t *)*v88;
      if (!v88)
      {
        uint64_t v125 = *(uint64_t **)&buf[16];
        if (*(void *)&buf[16])
        {
          do
          {
            sub_19E0D3120(v123, (unsigned __int16 *)v125 + 8, *((_DWORD *)v125 + 8));
            uint64_t v125 = (uint64_t *)*v125;
          }
          while (v125);
        }
        goto LABEL_287;
      }
    }
    BOOL v104 = (v95 & (v95 - 1)) != 0;
    if (v95 < 3) {
      BOOL v104 = 1;
    }
    unint64_t v105 = v104 | (2 * v95);
    unint64_t v106 = vcvtps_u32_f32(v103 / *(float *)&buf[32]);
    if (v105 <= v106) {
      int8x8_t v107 = (int8x8_t)v106;
    }
    else {
      int8x8_t v107 = (int8x8_t)v105;
    }
    if (*(void *)&v107 == 1)
    {
      int8x8_t v107 = (int8x8_t)2;
    }
    else if ((*(void *)&v107 & (*(void *)&v107 - 1)) != 0)
    {
      int8x8_t v107 = (int8x8_t)std::__next_prime(*(void *)&v107);
    }
    unint64_t v95 = *(void *)&buf[8];
    if (*(void *)&v107 > *(void *)&buf[8])
    {
LABEL_227:
      if (*(void *)&v107 >> 61) {
        sub_19E0416C4();
      }
      unint64_t v108 = operator new(8 * *(void *)&v107);
      uint64_t v109 = *(void **)buf;
      *(void *)buf = v108;
      if (v109) {
        operator delete(v109);
      }
      uint64_t v110 = 0;
      *(int8x8_t *)&uint8_t buf[8] = v107;
      do
        *(void *)(*(void *)buf + 8 * v110++) = 0;
      while (*(void *)&v107 != v110);
      uint64_t v111 = *(void ***)&buf[16];
      if (*(void *)&buf[16])
      {
        unint64_t v112 = *(void *)(*(void *)&buf[16] + 8);
        uint8x8_t v113 = (uint8x8_t)vcnt_s8(v107);
        v113.i16[0] = vaddlv_u8(v113);
        if (v113.u32[0] > 1uLL)
        {
          if (v112 >= *(void *)&v107) {
            v112 %= *(void *)&v107;
          }
        }
        else
        {
          v112 &= *(void *)&v107 - 1;
        }
        *(void *)(*(void *)buf + 8 * v112) = &buf[16];
        for (uint64_t j = *v111; j; v112 = v118)
        {
          unint64_t v118 = j[1];
          if (v113.u32[0] > 1uLL)
          {
            if (v118 >= *(void *)&v107) {
              v118 %= *(void *)&v107;
            }
          }
          else
          {
            v118 &= *(void *)&v107 - 1;
          }
          if (v118 != v112)
          {
            if (!*(void *)(*(void *)buf + 8 * v118))
            {
              *(void *)(*(void *)buf + 8 * v11++**(_DWORD **)(result + 8) = v111;
              goto LABEL_252;
            }
            *uint64_t v111 = (void *)*j;
            *uint64_t j = **(void **)(*(void *)buf + 8 * v118);
            **(void **)(*(void *)buf + 8 * v11++**(_DWORD **)(result + 8) = j;
            uint64_t j = v111;
          }
          unint64_t v118 = v112;
LABEL_252:
          uint64_t v111 = (void **)j;
          uint64_t j = (void *)*j;
        }
      }
      unint64_t v95 = (unint64_t)v107;
      goto LABEL_256;
    }
    if (*(void *)&v107 < *(void *)&buf[8])
    {
      unint64_t v114 = vcvtps_u32_f32((float)*(unint64_t *)&buf[24] / *(float *)&buf[32]);
      if (*(void *)&buf[8] < 3uLL
        || (uint8x8_t v115 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&buf[8]), v115.i16[0] = vaddlv_u8(v115), v115.u32[0] > 1uLL))
      {
        unint64_t v114 = std::__next_prime(v114);
      }
      else
      {
        uint64_t v116 = 1 << -(char)__clz(v114 - 1);
        if (v114 >= 2) {
          unint64_t v114 = v116;
        }
      }
      if (*(void *)&v107 <= v114) {
        int8x8_t v107 = (int8x8_t)v114;
      }
      if (*(void *)&v107 < v95)
      {
        if (!*(void *)&v107)
        {
          uint64_t v124 = *(void **)buf;
          *(void *)buf = 0;
          uint64_t v123 = a1 + 328;
          if (v124) {
            operator delete(v124);
          }
          unint64_t v95 = 0;
          *(void *)&uint8_t buf[8] = 0;
          goto LABEL_257;
        }
        goto LABEL_227;
      }
      unint64_t v95 = *(void *)&buf[8];
    }
LABEL_256:
    uint64_t v123 = a1 + 328;
LABEL_257:
    if ((v95 & (v95 - 1)) != 0)
    {
      if (v95 <= v94) {
        unint64_t v1 = v94 % v95;
      }
      else {
        unint64_t v1 = v94;
      }
    }
    else
    {
      unint64_t v1 = (v95 - 1) & v94;
    }
    goto LABEL_262;
  }
LABEL_287:
  int v350 = *(_DWORD *)(a1 + 1648);
  sub_19E08D160((uint64_t)buf);
  uint64_t v126 = *(void *)(a1 + 280);
  unsigned int v127 = *(void **)v126;
  unsigned int v353 = *(void **)(v126 + 8);
  if (*(void **)v126 != v353)
  {
    uint64_t v128 = a1 + 328;
    do
    {
      uint64_t v354 = v127;
      uint64_t v129 = *v127;
      uint64_t v130 = (unsigned __int16 *)(*v127 + 152);
      if (*v130 >= 0xFu)
      {
        uint64_t v131 = *(void *)(v129 + 160);
        if (v131) {
          MEMORY[0x19F3BA6E0](v131, 0x1000C8077774924);
        }
      }
      *(void *)uint64_t v130 = 0;
      *((void *)v130 + 1) = 0;
      uint64_t v133 = (void *)(v129 + 176);
      unsigned int v132 = *(unsigned __int16 *)(v129 + 176);
      *(unsigned char *)(v129 + 16++**(_DWORD **)(result + 8) = 0;
      if (v132 >= 0xF)
      {
        uint64_t v134 = *(void *)(v129 + 184);
        if (v134) {
          MEMORY[0x19F3BA6E0](v134, 0x1000C8077774924);
        }
      }
      *uint64_t v133 = 0;
      *(void *)(v129 + 184) = 0;
      *(_DWORD *)(v129 + 192) = 0;
      long long __p = 0;
      uint64_t v367 = 0;
      v368[0] = 0;
      sub_19E039858((uint64_t)v371, (unsigned __int16 *)v129);
      unsigned int v135 = 0;
      uint64_t v136 = 0;
      uint64_t v137 = 0;
      for (int i = 0; ; v135 = HIWORD(i))
      {
        unsigned int v138 = *(unsigned __int16 *)&v371[4];
        if (!*(_WORD *)&v371[4])
        {
          sub_19E0398F4((unsigned __int16 *)v371);
          unsigned int v138 = *(unsigned __int16 *)&v371[4];
        }
        if (v135 >= v138) {
          break;
        }
        __int16 v139 = *v130;
        if ((unint64_t)v137 >= v368[0])
        {
          unint64_t v140 = (unint64_t)__p;
          uint64_t v141 = v137 - (unsigned char *)__p;
          uint64_t v142 = v137 - (unsigned char *)__p + 1;
          if (v142 < 0) {
            sub_19E041BEC();
          }
          unint64_t v143 = v368[0] - (void)__p;
          if (2 * (v368[0] - (void)__p) > (unint64_t)v142) {
            uint64_t v142 = 2 * v143;
          }
          if (v143 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v144 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v144 = v142;
          }
          if (v144) {
            double v145 = operator new(v144);
          }
          else {
            double v145 = 0;
          }
          uint64_t v136 = &v145[v141];
          *uint64_t v136 = v139;
          uint64_t v146 = v136 + 1;
          if (v137 != (unsigned char *)v140)
          {
            uint64_t v147 = &v137[~v140];
            do
            {
              char v148 = *--v137;
              (v147--)[(void)v145] = v148;
            }
            while (v137 != (unsigned char *)v140);
            uint64_t v137 = __p;
            uint64_t v136 = v145;
          }
          long long __p = v136;
          uint64_t v367 = v146;
          v368[0] = &v145[v144];
          if (v137) {
            operator delete(v137);
          }
          uint64_t v137 = v146;
          uint64_t v128 = a1 + 328;
        }
        else
        {
          *v137++ = v139;
        }
        uint64_t v367 = v137;
        uint64_t v149 = sub_19E0DE8C0((uint64_t)v371);
        sub_19E08D1E0(&v375, v128, v149);
        sub_19E03EB40((uint64_t)buf, v128, (uint64_t)v130, v149, (unsigned __int16 *)&v375);
        if (*v130 >= 0xFu)
        {
          uint64_t v150 = *(void *)(v129 + 160);
          if (v150) {
            MEMORY[0x19F3BA6E0](v150, 0x1000C8077774924);
          }
        }
        unsigned int v151 = *(unsigned __int16 *)buf;
        *(_OWORD *)uint64_t v130 = *(_OWORD *)buf;
        if (v151 >= 0xF) {
          *(_WORD *)buf = 0;
        }
        *(unsigned char *)(v129 + 16++**(_DWORD **)(result + 8) = buf[16];
        if (*(unsigned __int16 *)(v129 + 176) >= 0xFu)
        {
          uint64_t v152 = *(void *)(v129 + 184);
          if (v152) {
            MEMORY[0x19F3BA6E0](v152, 0x1000C8077774924);
          }
        }
        unsigned int v153 = *(unsigned __int16 *)&buf[24];
        *(_OWORD *)uint64_t v133 = *(_OWORD *)&buf[24];
        if (v153 >= 0xF) {
          *(_WORD *)&uint8_t buf[24] = 0;
        }
        *(_DWORD *)(v129 + 192) = *(_DWORD *)&buf[40];
        if (*(unsigned __int16 *)buf >= 0xFu && *(void *)&buf[8]) {
          MEMORY[0x19F3BA6E0](*(void *)&buf[8], 0x1000C8077774924);
        }
        if (v375.n128_u16[0] >= 0xFu && v375.n128_u64[1]) {
          MEMORY[0x19F3BA6E0](v375.n128_u64[1], 0x1000C8077774924);
        }
      }
      BOOL v154 = sub_19E0A7134((unsigned __int16 *)(v129 + 136), v130);
      unsigned int v155 = (unint64_t *)(v129 + 200);
      unsigned int v156 = *(unsigned char **)(v129 + 200);
      *(void *)(v129 + 20++**(_DWORD **)(result + 8) = v156;
      if (v154)
      {
        if (v137 != v136)
        {
          uint64_t v157 = 0;
          unsigned int v158 = 0;
          unsigned int v159 = 0;
          do
          {
            if (v159 <= v136[v157])
            {
              do
              {
                unsigned int v160 = v159;
                unint64_t v161 = *(void *)(v129 + 216);
                if ((unint64_t)v156 >= v161)
                {
                  unint64_t v162 = *v155;
                  unsigned __int8 v163 = &v156[-*v155];
                  unint64_t v164 = (unint64_t)(v163 + 1);
                  if ((uint64_t)(v163 + 1) < 0) {
                    sub_19E041BEC();
                  }
                  unint64_t v165 = v161 - v162;
                  if (2 * v165 > v164) {
                    unint64_t v164 = 2 * v165;
                  }
                  if (v165 >= 0x3FFFFFFFFFFFFFFFLL) {
                    size_t v166 = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    size_t v166 = v164;
                  }
                  if (v166) {
                    uint64_t v167 = (char *)operator new(v166);
                  }
                  else {
                    uint64_t v167 = 0;
                  }
                  uint64_t v168 = &v163[(void)v167];
                  unint64_t v169 = &v163[(void)v167];
                  *unint64_t v169 = v158;
                  uint64_t v170 = v169 + 1;
                  if (v156 != (unsigned char *)v162)
                  {
                    uint64_t v171 = &v156[~v162];
                    do
                    {
                      char v172 = *--v156;
                      (v171--)[(void)v167] = v172;
                    }
                    while (v156 != (unsigned char *)v162);
                    unsigned int v156 = (unsigned char *)*v155;
                    uint64_t v168 = v167;
                  }
                  *(void *)(v129 + 20sub_19E060B80(&a9, 0) = v168;
                  *(void *)(v129 + 20++**(_DWORD **)(result + 8) = v170;
                  *(void *)(v129 + 216) = &v167[v166];
                  if (v156) {
                    operator delete(v156);
                  }
                  unsigned int v156 = v170;
                }
                else
                {
                  *v156++ = v158;
                }
                *(void *)(v129 + 20++**(_DWORD **)(result + 8) = v156;
                unsigned int v159 = v160 + 1;
                uint64_t v136 = __p;
              }
              while (v160 < *((unsigned __int8 *)__p + v157));
              uint64_t v137 = v367;
            }
            uint64_t v157 = ++v158;
          }
          while (v137 - v136 > (unint64_t)v158);
        }
      }
      else
      {
        ++*(_DWORD *)(a1 + 1760);
        (*(void (**)(unsigned char *__return_ptr))(**(void **)(v129 + 312) + 8))(buf);
        BOOL v178 = sub_19E0A7134(v130, (unsigned __int16 *)buf);
        if (*(unsigned __int16 *)buf >= 0xFu && *(void *)&buf[8]) {
          MEMORY[0x19F3BA6E0](*(void *)&buf[8], 0x1000C8077774924);
        }
        if (!v178)
        {
          unsigned int v180 = *(_DWORD *)(a1 + 1764) + 1;
          *(_DWORD *)(a1 + 1764) = v180;
          if ((*(unsigned char *)(v129 + 329) & 0x80) != 0 && v180 <= 0x13)
          {
            unsigned __int8 v181 = atomic_load(byte_1E9457268);
            if (v181)
            {
              unsigned __int8 v182 = atomic_load(byte_1E94578A0);
              if (v182)
              {
                if (*(void *)(v129 + 112)) {
                  uint8x8_t v202 = *(const char **)(v129 + 112);
                }
                else {
                  uint8x8_t v202 = (const char *)(v129 + 120);
                }
                if (*(void *)(v129 + 8)) {
                  unint64_t v203 = *(const char **)(v129 + 8);
                }
                else {
                  unint64_t v203 = (const char *)(v129 + 16);
                }
                double v204 = *(double *)(v129 + 88);
                uint64_t v205 = *(unsigned __int16 *)(v129 + 152);
                if (v205 <= 0xE) {
                  BOOL v206 = (char *)(v129 + 154);
                }
                else {
                  BOOL v206 = *(char **)(v129 + 160);
                }
                sub_19E0DD6FC((uint64_t)buf, v206, v205, v173, v174, v175, v176, v177);
                if (*(void *)&buf[8]) {
                  unint64_t v207 = *(const char **)&buf[8];
                }
                else {
                  unint64_t v207 = &buf[16];
                }
                (*(void (**)(__n128 *__return_ptr))(**(void **)(v129 + 312) + 8))(&v373);
                if (v373.n128_u16[0] <= 0xEu) {
                  uint64_t v213 = &v373.n128_i8[2];
                }
                else {
                  uint64_t v213 = (char *)v373.n128_u64[1];
                }
                sub_19E0DD6FC((uint64_t)&v375, v213, v373.n128_u16[0], v208, v209, v210, v211, v212);
                char v214 = (const char *)v375.n128_u64[1];
                if (!v375.n128_u64[1]) {
                  char v214 = (const char *)v376;
                }
                printf("NOTE:  Sort key for %s->%s freq=%.1f is not distributive:\n    0x%s / 0x%s", v202, v203, v204, v207, v214);
                if (v375.n128_u64[1] && v375.n128_u8[6] == 1) {
                  free((void *)v375.n128_u64[1]);
                }
                if (v373.n128_u16[0] >= 0xFu && v373.n128_u64[1]) {
                  MEMORY[0x19F3BA6E0](v373.n128_u64[1], 0x1000C8077774924);
                }
                if (*(void *)&buf[8] && buf[6] == 1) {
                  free(*(void **)&buf[8]);
                }
                putchar(10);
              }
              else
              {
                unint64_t v183 = sub_19E08D084();
                if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
                {
                  if (*(void *)(v129 + 112)) {
                    uint64_t v189 = *(void *)(v129 + 112);
                  }
                  else {
                    uint64_t v189 = v129 + 120;
                  }
                  if (*(void *)(v129 + 8)) {
                    uint64_t v190 = *(void *)(v129 + 8);
                  }
                  else {
                    uint64_t v190 = v129 + 16;
                  }
                  uint64_t v191 = *(void *)(v129 + 88);
                  uint64_t v192 = *(unsigned __int16 *)(v129 + 152);
                  if (v192 <= 0xE) {
                    uint64_t v193 = (char *)(v129 + 154);
                  }
                  else {
                    uint64_t v193 = *(char **)(v129 + 160);
                  }
                  sub_19E0DD6FC((uint64_t)&v375, v193, v192, v184, v185, v186, v187, v188);
                  if (v375.n128_u64[1]) {
                    unint64_t v194 = (_DWORD *)v375.n128_u64[1];
                  }
                  else {
                    unint64_t v194 = v376;
                  }
                  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v129 + 312) + 8))(&v363);
                  if ((unsigned __int16)v363 <= 0xEu) {
                    uint64_t v200 = (char *)&v363 + 2;
                  }
                  else {
                    uint64_t v200 = (char *)v364;
                  }
                  sub_19E0DD6FC((uint64_t)&v373, v200, (unsigned __int16)v363, v195, v196, v197, v198, v199);
                  unint64_t v201 = (uint64_t *)v373.n128_u64[1];
                  if (!v373.n128_u64[1]) {
                    unint64_t v201 = (uint64_t *)v374;
                  }
                  *(_DWORD *)buf = 136316162;
                  *(void *)&uint8_t buf[4] = v189;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v190;
                  *(_WORD *)&buf[22] = 2048;
                  *(void *)&uint8_t buf[24] = v191;
                  *(_WORD *)&uint8_t buf[32] = 2080;
                  *(void *)&buf[34] = v194;
                  *(_WORD *)&buf[42] = 2080;
                  uint64_t v370 = v201;
                  _os_log_impl(&dword_19E038000, v183, OS_LOG_TYPE_DEFAULT, "NOTE:  Sort key for %s->%s freq=%.1f is not distributive:\n    0x%s / 0x%s", buf, 0x34u);
                  if (v373.n128_u64[1] && v373.n128_u8[6] == 1) {
                    free((void *)v373.n128_u64[1]);
                  }
                  if ((unsigned __int16)v363 >= 0xFu && v364) {
                    MEMORY[0x19F3BA6E0](v364, 0x1000C8077774924);
                  }
                  if (v375.n128_u64[1] && v375.n128_u8[6] == 1) {
                    free((void *)v375.n128_u64[1]);
                  }
                }
              }
            }
          }
        }
      }
      if (*(void *)&v371[8]) {
        BOOL v179 = v371[6] == 1;
      }
      else {
        BOOL v179 = 0;
      }
      if (v179) {
        free(*(void **)&v371[8]);
      }
      if (__p) {
        operator delete(__p);
      }
      unsigned int v127 = v354 + 1;
      uint64_t v128 = a1 + 328;
    }
    while (v354 + 1 != v353);
    uint64_t v215 = *(void *)(a1 + 280);
    int v216 = *(void **)v215;
    uint64_t v217 = *(void **)(v215 + 8);
    if (*(void **)v215 != v217)
    {
      do
      {
        uint64_t v218 = *v216;
        uint64_t v219 = *(void *)(a1 + 240);
        long long v220 = (unsigned __int16 *)(*v216 + 136);
        sub_19E0D2DEC((uint64_t)v371, v356, v220);
        (*(void (**)(void **__return_ptr))(**(void **)(a1 + 1704) + 8))(&__p);
        if (!sub_19E0A7134(v220, (unsigned __int16 *)&__p))
        {
          unsigned int v226 = *(_DWORD *)(a1 + 1772) + 1;
          *(_DWORD *)(a1 + 1772) = v226;
          if ((v219 & 0x8000) != 0 && v226 <= 0x13)
          {
            unsigned __int8 v227 = atomic_load(byte_1E9457268);
            if (v227)
            {
              unsigned __int8 v228 = atomic_load(byte_1E94578A0);
              if (v228)
              {
                if (*(void *)(v218 + 112)) {
                  int v249 = *(const char **)(v218 + 112);
                }
                else {
                  int v249 = (const char *)(v218 + 120);
                }
                uint64_t v250 = *(unsigned __int16 *)(v218 + 136);
                if (v250 <= 0xE) {
                  float v251 = (char *)(v218 + 138);
                }
                else {
                  float v251 = *(char **)(v218 + 144);
                }
                sub_19E0DD6FC((uint64_t)buf, v251, v250, v221, v222, v223, v224, v225);
                v257 = *(const char **)&buf[8];
                uint64_t v258 = *(const char **)&v371[8];
                if ((unsigned __int16)__p <= 0xEu) {
                  uint64_t v259 = (char *)&__p + 2;
                }
                else {
                  uint64_t v259 = (char *)v367;
                }
                sub_19E0DD6FC((uint64_t)&v375, v259, (unsigned __int16)__p, v252, v253, v254, v255, v256);
                if (v258) {
                  uint64_t v260 = v258;
                }
                else {
                  uint64_t v260 = &v371[16];
                }
                unint64_t v261 = &buf[16];
                if (v257) {
                  unint64_t v261 = v257;
                }
                uint8x8_t v262 = (const char *)v375.n128_u64[1];
                if (!v375.n128_u64[1]) {
                  uint8x8_t v262 = (const char *)v376;
                }
                printf("WARNING:  Derivation of base form failed.  Expected %s (0x%s).  Got %s (0x%s).  ", v249, v261, v260, v262);
                if (v375.n128_u64[1] && v375.n128_u8[6] == 1) {
                  free((void *)v375.n128_u64[1]);
                }
                if (*(void *)&buf[8] && buf[6] == 1) {
                  free(*(void **)&buf[8]);
                }
                putchar(10);
              }
              else
              {
                BOOL v229 = sub_19E08D084();
                if (os_log_type_enabled(v229, OS_LOG_TYPE_DEFAULT))
                {
                  if (*(void *)(v218 + 112)) {
                    uint64_t v235 = *(void *)(v218 + 112);
                  }
                  else {
                    uint64_t v235 = v218 + 120;
                  }
                  uint64_t v236 = *(unsigned __int16 *)(v218 + 136);
                  if (v236 <= 0xE) {
                    char v237 = (char *)(v218 + 138);
                  }
                  else {
                    char v237 = *(char **)(v218 + 144);
                  }
                  sub_19E0DD6FC((uint64_t)&v375, v237, v236, v230, v231, v232, v233, v234);
                  unint64_t v243 = v375.n128_u64[1];
                  unint64_t v244 = *(unsigned char **)&v371[8];
                  if ((unsigned __int16)__p <= 0xEu) {
                    unint64_t v245 = (char *)&__p + 2;
                  }
                  else {
                    unint64_t v245 = (char *)v367;
                  }
                  sub_19E0DD6FC((uint64_t)&v373, v245, (unsigned __int16)__p, v238, v239, v240, v241, v242);
                  unint64_t v246 = (unsigned char *)v373.n128_u64[1];
                  if (v244) {
                    uint8x8_t v247 = v244;
                  }
                  else {
                    uint8x8_t v247 = &v371[16];
                  }
                  *(_DWORD *)buf = 136315906;
                  if (v243) {
                    unsigned int v248 = (_DWORD *)v243;
                  }
                  else {
                    unsigned int v248 = v376;
                  }
                  *(void *)&uint8_t buf[4] = v235;
                  if (!v373.n128_u64[1]) {
                    unint64_t v246 = v374;
                  }
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v248;
                  *(_WORD *)&buf[22] = 2080;
                  *(void *)&uint8_t buf[24] = v247;
                  *(_WORD *)&uint8_t buf[32] = 2080;
                  *(void *)&buf[34] = v246;
                  _os_log_impl(&dword_19E038000, v229, OS_LOG_TYPE_DEFAULT, "WARNING:  Derivation of base form failed.  Expected %s (0x%s).  Got %s (0x%s).  ", buf, 0x2Au);
                  if (v373.n128_u64[1] && v373.n128_u8[6] == 1) {
                    free((void *)v373.n128_u64[1]);
                  }
                  if (v375.n128_u64[1] && v375.n128_u8[6] == 1) {
                    free((void *)v375.n128_u64[1]);
                  }
                }
              }
            }
          }
        }
        if ((unsigned __int16)__p >= 0xFu && v367) {
          MEMORY[0x19F3BA6E0](v367, 0x1000C8077774924);
        }
        if (*(void *)&v371[8] && v371[6] == 1) {
          free(*(void **)&v371[8]);
        }
        ++v216;
      }
      while (v216 != v217);
    }
  }
  int v263 = *(_DWORD *)(a1 + 1764);
  unsigned __int8 v264 = atomic_load(byte_1E9457268);
  if (v263)
  {
    uint64_t v265 = a1 + 328;
    if ((v264 & 1) == 0) {
      goto LABEL_507;
    }
    unsigned __int8 v266 = atomic_load(byte_1E94578A0);
    if ((v266 & 1) == 0)
    {
      unint64_t v267 = sub_19E08D084();
      if (os_log_type_enabled(v267, OS_LOG_TYPE_DEFAULT))
      {
        int v268 = *(_DWORD *)(a1 + 1764);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v268;
        uint64_t v269 = "    %d surface-forms sort-keys are non-distributive.";
        unsigned int v270 = v267;
        uint32_t v271 = 8;
LABEL_502:
        _os_log_impl(&dword_19E038000, v270, OS_LOG_TYPE_DEFAULT, v269, buf, v271);
        goto LABEL_507;
      }
      goto LABEL_507;
    }
    printf("    %d surface-forms sort-keys are non-distributive.");
LABEL_506:
    putchar(10);
    goto LABEL_507;
  }
  uint64_t v265 = a1 + 328;
  if ((v264 & 1) == 0) {
    goto LABEL_507;
  }
  unsigned __int8 v272 = atomic_load(byte_1E94578A0);
  if (v272)
  {
    printf("    ALL surface-form sort-keys are distributive!");
    goto LABEL_506;
  }
  unsigned int v273 = sub_19E08D084();
  if (os_log_type_enabled(v273, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    uint64_t v269 = "    ALL surface-form sort-keys are distributive!";
    unsigned int v270 = v273;
    uint32_t v271 = 2;
    goto LABEL_502;
  }
LABEL_507:
  if (*(_DWORD *)(a1 + 1768))
  {
    unsigned __int8 v274 = atomic_load(byte_1E9457268);
    if (v274)
    {
      unsigned __int8 v275 = atomic_load(byte_1E94578A0);
      if (v275)
      {
        printf("    %d unigram sort-keys do not build cumulatively. They change retroactively!", *(_DWORD *)(a1 + 1768));
        putchar(10);
      }
      else
      {
        int v276 = sub_19E08D084();
        uint64_t v265 = a1 + 328;
        if (os_log_type_enabled(v276, OS_LOG_TYPE_DEFAULT))
        {
          int v277 = *(_DWORD *)(a1 + 1768);
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v277;
          _os_log_impl(&dword_19E038000, v276, OS_LOG_TYPE_DEFAULT, "    %d unigram sort-keys do not build cumulatively. They change retroactively!", buf, 8u);
        }
      }
    }
  }
  if (*(_DWORD *)(a1 + 1772))
  {
    unsigned __int8 v278 = atomic_load(byte_1E9457268);
    if (v278)
    {
      unsigned __int8 v279 = atomic_load(byte_1E94578A0);
      if (v279)
      {
        printf("    %d unigram base forms are not derivable from their sort-keys!", *(_DWORD *)(a1 + 1772));
        putchar(10);
      }
      else
      {
        unsigned __int8 v280 = sub_19E08D084();
        uint64_t v265 = a1 + 328;
        if (os_log_type_enabled(v280, OS_LOG_TYPE_DEFAULT))
        {
          int v281 = *(_DWORD *)(a1 + 1772);
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v281;
          _os_log_impl(&dword_19E038000, v280, OS_LOG_TYPE_DEFAULT, "    %d unigram base forms are not derivable from their sort-keys!", buf, 8u);
        }
      }
    }
  }
  int v282 = *(_DWORD *)(a1 + 1760) - *(_DWORD *)(a1 + 1764);
  if (v282 >= 1)
  {
    unsigned __int8 v283 = atomic_load(byte_1E9457268);
    if (v283)
    {
      unsigned __int8 v284 = atomic_load(byte_1E94578A0);
      if (v284)
      {
        printf("    %d surface forms don't align with their dict/sort keys.", v282);
        putchar(10);
      }
      else
      {
        v285 = sub_19E08D084();
        uint64_t v265 = a1 + 328;
        if (os_log_type_enabled(v285, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v282;
          _os_log_impl(&dword_19E038000, v285, OS_LOG_TYPE_DEFAULT, "    %d surface forms don't align with their dict/sort keys.", buf, 8u);
        }
      }
    }
  }
  unsigned __int8 v286 = atomic_load(byte_1E9457268);
  if (v286)
  {
    unsigned __int8 v287 = atomic_load(byte_1E94578A0);
    if (v287)
    {
      printf("Mapped %d sort key units to letter forms.", v350);
      putchar(10);
    }
    else
    {
      unsigned int v288 = sub_19E08D084();
      uint64_t v265 = a1 + 328;
      if (os_log_type_enabled(v288, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v350;
        _os_log_impl(&dword_19E038000, v288, OS_LOG_TYPE_DEFAULT, "Mapped %d sort key units to letter forms.", buf, 8u);
      }
    }
  }
  uint64_t v289 = *(void *)(a1 + 240);
  if ((v289 & 0x28000) != 0)
  {
    sub_19E0D36C4((unsigned __int16 *)&v375, v265);
    unint64_t v295 = v375.n128_u64[0];
    if ((__int8 *)v375.n128_u64[0] != &v375.n128_i8[8])
    {
      do
      {
        uint64_t v296 = *(unsigned __int16 *)(v295 + 40);
        if (v296 <= 0xE) {
          long long v297 = (char *)(v295 + 42);
        }
        else {
          long long v297 = *(char **)(v295 + 48);
        }
        sub_19E0DD6FC((uint64_t)buf, v297, v296, v290, v291, v292, v293, v294);
        int v298 = *(const char **)&buf[8];
        sub_19E040834((uint64_t)v371, *(_DWORD *)(v295 + 32));
        if (v298) {
          v299 = v298;
        }
        else {
          v299 = &buf[16];
        }
        int v300 = *(const char **)&v371[8];
        if (!*(void *)&v371[8]) {
          int v300 = &v371[16];
        }
        printf("\tSK=0x%s: %s\n", v299, v300);
        if (*(void *)&v371[8] && v371[6] == 1) {
          free(*(void **)&v371[8]);
        }
        if (*(void *)&buf[8] && buf[6] == 1) {
          free(*(void **)&buf[8]);
        }
        uint64_t v301 = *(__n128 **)(v295 + 8);
        if (v301)
        {
          do
          {
            char v302 = v301;
            uint64_t v301 = (__n128 *)v301->n128_u64[0];
          }
          while (v301);
        }
        else
        {
          do
          {
            char v302 = *(__n128 **)(v295 + 16);
            BOOL v49 = v302->n128_u64[0] == v295;
            unint64_t v295 = (unint64_t)v302;
          }
          while (!v49);
        }
        unint64_t v295 = (unint64_t)v302;
      }
      while (v302 != (__n128 *)&v375.n128_i8[8]);
    }
    sub_19E08DAEC((void *)v375.n128_u64[1]);
    uint64_t v289 = *(void *)(a1 + 240);
  }
  if ((v289 & 0x28080) != 0)
  {
    unsigned __int8 v303 = atomic_load(byte_1E9457268);
    if (v303)
    {
      unsigned __int8 v304 = atomic_load(byte_1E94578A0);
      if (v304)
      {
        printf("Non-empty surface-form substitution lists:");
        putchar(10);
      }
      else
      {
        unint64_t v305 = sub_19E08D084();
        if (os_log_type_enabled(v305, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_19E038000, v305, OS_LOG_TYPE_DEFAULT, "Non-empty surface-form substitution lists:", buf, 2u);
        }
      }
    }
    unsigned __int8 v306 = *(uint64_t **)(a1 + 280);
    uint64_t v307 = *v306;
    if (v306[1] != *v306)
    {
      uint64_t v308 = 0;
      unsigned int v309 = 0;
      while (1)
      {
        memset(buf, 0, 24);
        v375.n128_u32[0] = 0;
        sub_19E0EFC28(*(void *)(v307 + 8 * v308), v356, (uint64_t *)buf, &v375);
        if (*(void *)&buf[8] != *(void *)buf)
        {
          unsigned __int8 v310 = atomic_load(byte_1E9457268);
          if (v310)
          {
            unsigned __int8 v311 = atomic_load(byte_1E94578A0);
            if (v311)
            {
              uint64_t v317 = *(void *)(v307 + 8 * v308);
              long long v318 = *(const char **)(v317 + 112);
              if (!v318) {
                long long v318 = (const char *)(v317 + 120);
              }
              unint64_t v319 = *(const char **)(v317 + 8);
              unsigned int v320 = (const char *)(v317 + 16);
              if (v319) {
                unsigned int v320 = v319;
              }
              printf("    %s -> %s            ", v318, v320);
              putchar(10);
            }
            else
            {
              int v312 = sub_19E08D084();
              if (os_log_type_enabled(v312, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v313 = *(void *)(v307 + 8 * v308);
                uint64_t v314 = *(void *)(v313 + 112);
                if (!v314) {
                  uint64_t v314 = v313 + 120;
                }
                uint64_t v315 = *(void *)(v313 + 8);
                uint64_t v316 = v313 + 16;
                if (v315) {
                  uint64_t v316 = v315;
                }
                *(_DWORD *)uint64_t v371 = 136315394;
                *(void *)&v371[4] = v314;
                *(_WORD *)&v371[12] = 2080;
                *(void *)&v371[14] = v316;
                _os_log_impl(&dword_19E038000, v312, OS_LOG_TYPE_DEFAULT, "    %s -> %s            ", v371, 0x16u);
              }
            }
          }
          uint64_t v321 = *(void *)buf;
          if (*(void *)&buf[8] != *(void *)buf) {
            break;
          }
        }
LABEL_603:
        *(void *)uint64_t v371 = buf;
        sub_19E09FE3C((void ***)v371);
        int v345 = *(uint64_t **)(a1 + 280);
        uint64_t v307 = *v345;
        uint64_t v308 = ++v309;
        if (v309 >= (unint64_t)((v345[1] - *v345) >> 3)) {
          goto LABEL_604;
        }
      }
      uint64_t v322 = 0;
      unsigned int v323 = 1;
      while (1)
      {
        int v324 = *(_DWORD *)(v321 + 40 * v322 + 32);
        if ((v324 & 0x20) != 0)
        {
          unsigned __int8 v333 = atomic_load(byte_1E9457268);
          if (v333)
          {
            unsigned __int8 v334 = atomic_load(byte_1E94578A0);
            if (v334)
            {
              printf("<%d: %s  ");
LABEL_601:
              putchar(10);
              goto LABEL_602;
            }
            uint64_t v335 = sub_19E08D084();
            if (os_log_type_enabled(v335, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v336 = *(void *)buf + 40 * v322;
              uint64_t v337 = *(void *)(v336 + 8);
              uint64_t v338 = v336 + 16;
              if (v337) {
                uint64_t v338 = v337;
              }
              *(_DWORD *)uint64_t v371 = 67109378;
              *(_DWORD *)&v371[4] = v324 & 0xFFFFFFDF;
              *(_WORD *)&v371[8] = 2080;
              *(void *)&v371[10] = v338;
              long long v331 = v335;
              long long v332 = "<%d: %s  ";
              goto LABEL_597;
            }
          }
        }
        else
        {
          unsigned __int8 v325 = atomic_load(byte_1E9457268);
          if ((v324 & 0x40) != 0)
          {
            if (v325)
            {
              unsigned __int8 v339 = atomic_load(byte_1E94578A0);
              if (v339)
              {
                printf("^%d: %s  ");
                goto LABEL_601;
              }
              uint64_t v340 = sub_19E08D084();
              if (os_log_type_enabled(v340, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v341 = *(void *)buf + 40 * v322;
                uint64_t v342 = *(void *)(v341 + 8);
                uint64_t v343 = v341 + 16;
                if (v342) {
                  uint64_t v343 = v342;
                }
                *(_DWORD *)uint64_t v371 = 67109378;
                *(_DWORD *)&v371[4] = v324 & 0xFFFFFFBF;
                *(_WORD *)&v371[8] = 2080;
                *(void *)&v371[10] = v343;
                long long v331 = v340;
                long long v332 = "^%d: %s  ";
                goto LABEL_597;
              }
            }
          }
          else if (v325)
          {
            unsigned __int8 v326 = atomic_load(byte_1E94578A0);
            if (v326)
            {
              printf("@%d: %s  ");
              goto LABEL_601;
            }
            uint64_t v327 = sub_19E08D084();
            if (os_log_type_enabled(v327, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v328 = *(void *)buf + 40 * v322;
              uint64_t v329 = *(void *)(v328 + 8);
              uint64_t v330 = v328 + 16;
              if (v329) {
                uint64_t v330 = v329;
              }
              *(_DWORD *)uint64_t v371 = 67109378;
              *(_DWORD *)&v371[4] = v324;
              *(_WORD *)&v371[8] = 2080;
              *(void *)&v371[10] = v330;
              long long v331 = v327;
              long long v332 = "@%d: %s  ";
LABEL_597:
              _os_log_impl(&dword_19E038000, v331, OS_LOG_TYPE_DEFAULT, v332, v371, 0x12u);
            }
          }
        }
LABEL_602:
        uint64_t v322 = v323;
        uint64_t v321 = *(void *)buf;
        if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3) <= v323++) {
          goto LABEL_603;
        }
      }
    }
LABEL_604:
    unsigned __int8 v346 = atomic_load(byte_1E9457268);
    if (v346)
    {
      unsigned __int8 v347 = atomic_load(byte_1E94578A0);
      if (v347)
      {
        putchar(10);
      }
      else
      {
        uint64_t v348 = sub_19E08D084();
        if (os_log_type_enabled(v348, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_19E038000, v348, OS_LOG_TYPE_DEFAULT, (const char *)&unk_19E1315F5, buf, 2u);
        }
      }
    }
  }
}

void sub_19E09FAC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,__int16 a35,uint64_t a36,__int16 a37,uint64_t a38,unsigned __int16 a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,void *a44,uint64_t a45,uint64_t a46,char a47,int a48,char a49,char a50,uint64_t a51)
{
  if (a39 >= 0xFu && a40) {
    MEMORY[0x19F3BA6E0](a40, 0x1000C8077774924);
  }
  unsigned __int32 v53 = *(void **)(v51 - 144);
  if (v53 && *(unsigned char *)(v51 - 146) == 1) {
    free(v53);
  }
  unint64_t v54 = *(void **)(v51 - 216);
  if (v54 && *(unsigned char *)(v51 - 218) == 1) {
    free(v54);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E09FE3C(void ***a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 4);
        if (v6 && *(v4 - 34) == 1) {
          free(v6);
        }
        v4 -= 40;
      }
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t **sub_19E09FED0(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unsigned int v7 = a1 + 1;
LABEL_9:
    unsigned int v9 = (uint64_t *)v7;
    unsigned int v7 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v7 + ++**(_DWORD **)(result + 8) = *a3;
    void v7[5] = 0;
    void *v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    void *v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_19E05D650(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_19E09FFA0(void *a1)
{
  if (a1)
  {
    sub_19E09FFA0(*a1);
    sub_19E09FFA0(a1[1]);
    operator delete(a1);
  }
}

uint64_t **sub_19E09FFEC(uint64_t **a1, int a2, int a3, uint64_t **a4)
{
  unsigned int v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = (uint64_t **)v6;
        int v8 = *((_DWORD *)v6 + 8);
        if (v8 == a2) {
          break;
        }
        if (v8 <= a2)
        {
          if (v8 >= a2) {
            char v13 = 1;
          }
          else {
            char v13 = -1;
          }
          if ((v13 & 0x80) == 0) {
            return v7;
          }
          goto LABEL_18;
        }
LABEL_12:
        uint64_t v6 = *v7;
        uint64_t v12 = v7;
        if (!*v7) {
          goto LABEL_21;
        }
      }
      int v9 = *((_DWORD *)v7 + 9);
      BOOL v10 = v9 == a3;
      if (v9 > a3) {
        goto LABEL_12;
      }
      if (v9 >= a3) {
        char v11 = 1;
      }
      else {
        char v11 = -1;
      }
      if (v10) {
        char v11 = 0;
      }
      if ((v11 & 0x80) == 0) {
        return v7;
      }
LABEL_18:
      uint64_t v12 = v7 + 1;
      uint64_t v6 = v7[1];
      if (!v6) {
        goto LABEL_21;
      }
    }
  }
  uint64_t v12 = a1 + 1;
LABEL_21:
  uint64_t v14 = (uint64_t *)v7;
  unsigned int v7 = (uint64_t **)operator new(0x30uLL);
  v7[4] = *a4;
  void v7[5] = 0;
  void *v7 = 0;
  v7[1] = 0;
  void v7[2] = v14;
  uint64_t *v12 = (uint64_t *)v7;
  unsigned __int8 v15 = (uint64_t *)**a1;
  unsigned __int8 v16 = (uint64_t *)v7;
  if (v15)
  {
    *a1 = v15;
    unsigned __int8 v16 = *v12;
  }
  sub_19E05D650(a1[1], v16);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v7;
}

void sub_19E0A00E4(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  if (*((void *)a2 + 1)) {
    unsigned int v7 = (unsigned __int8 *)*((void *)a2 + 1);
  }
  else {
    unsigned int v7 = (unsigned __int8 *)(a2 + 8);
  }
  unsigned int v8 = sub_19E0B24AC(v7, *a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v10 <= v8) {
        unint64_t v3 = v8 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }
    char v13 = *(unsigned __int16 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (int i = *v13; i; int i = *(unsigned __int16 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if (i + 8 == a2 || sub_19E0B2428(i + 8, a2)) {
            return;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }
  unsigned __int8 v16 = (void *)(a1 + 16);
  uint64_t v17 = operator new(0x30uLL);
  v27[0] = (uint64_t)v17;
  v27[1] = a1 + 16;
  *uint64_t v17 = 0;
  v17[1] = v9;
  sub_19E039858((uint64_t)(v17 + 2), a3);
  char v28 = 1;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    BOOL v20 = 1;
    if (v10 >= 3) {
      BOOL v20 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v10);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    sub_19E08A5BC(a1, v23);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v10 <= v9) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  uint64_t v24 = *(void *)a1;
  uint64_t v25 = *(void **)(*(void *)a1 + 8 * v3);
  if (v25)
  {
    *uint64_t v17 = *v25;
LABEL_42:
    void *v25 = v17;
    goto LABEL_43;
  }
  *uint64_t v17 = *v16;
  void *v16 = v17;
  *(void *)(v24 + 8 * v3) = v16;
  if (*v17)
  {
    unint64_t v26 = *(void *)(*v17 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v26 >= v10) {
        v26 %= v10;
      }
    }
    else
    {
      v26 &= v10 - 1;
    }
    uint64_t v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_42;
  }
LABEL_43:
  v27[0] = 0;
  ++*(void *)(a1 + 24);
  sub_19E0A1244(v27);
}

void sub_19E0A0340(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E0A1244((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E0A0358(unsigned __int16 *a1, unint64_t a2, uint64_t a3, char a4)
{
  v157[2] = *MEMORY[0x1E4F143B8];
LABEL_2:
  uint64_t v9 = (uint64_t)a1;
  uint64_t v143 = (uint64_t)(a1 + 32);
  uint64_t v144 = (uint64_t)(a1 + 16);
  uint64_t v141 = a1 + 8;
  uint64_t v142 = a1 - 8;
  double v145 = a1 + 24;
  while (1)
  {
    uint64_t v10 = a2 - v9;
    uint64_t v11 = (uint64_t)(a2 - v9) >> 5;
    if (v5 || !v4)
    {
      switch(v11)
      {
        case 0:
        case 1:
          return;
        case 2:
          if (*(void *)(a2 - 24)) {
            BOOL v68 = *(const char **)(a2 - 24);
          }
          else {
            BOOL v68 = (const char *)(a2 - 16);
          }
          if (*(void *)(v9 + 8)) {
            unint64_t v69 = *(const char **)(v9 + 8);
          }
          else {
            unint64_t v69 = (const char *)(v9 + 16);
          }
          if (strcmp(v68, v69) < 0) {
            sub_19E0A13D4((unsigned __int16 *)v9, (unsigned __int16 *)(a2 - 32));
          }
          break;
        case 3:
          sub_19E0A147C(v9, v9 + 32, a2 - 32);
          break;
        case 4:
          sub_19E0A15A8(v9, v9 + 32, v9 + 64, a2 - 32);
          break;
        case 5:
          sub_19E0A169C(v9, v9 + 32, v9 + 64, v9 + 96, a2 - 32);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v10 <= 767) {
      break;
    }
    if (!a3)
    {
      if (v9 != a2)
      {
        int64_t v85 = (unint64_t)(v11 - 2) >> 1;
        uint64_t v147 = (unsigned __int16 *)a2;
        int64_t v86 = v85;
        do
        {
          int64_t v87 = v86;
          if (v85 >= v86)
          {
            uint64_t v88 = (2 * v86) | 1;
            uint64_t v89 = v9 + 32 * v88;
            if (2 * v86 + 2 < v11)
            {
              unsigned int v90 = *(void *)(v89 + 8) ? *(const char **)(v89 + 8) : (const char *)(v89 + 16);
              uint64_t v91 = *(void *)(v89 + 40) ? *(const char **)(v89 + 40) : (const char *)(v89 + 48);
              int v92 = strcmp(v90, v91);
              v89 += 32 * (v92 >> 31);
              if (v92 < 0) {
                uint64_t v88 = 2 * v87 + 2;
              }
            }
            if (*(void *)(v89 + 8)) {
              unsigned int v93 = *(const char **)(v89 + 8);
            }
            else {
              unsigned int v93 = (const char *)(v89 + 16);
            }
            uint64_t v94 = v9 + 32 * v87;
            unint64_t v95 = *(const char **)(v94 + 8);
            uint8x8_t v96 = (const char *)(v94 + 16);
            if (v95) {
              unint64_t v97 = v95;
            }
            else {
              unint64_t v97 = v96;
            }
            if ((strcmp(v93, v97) & 0x80000000) == 0)
            {
              int v153 = 0x100000;
              __int16 v154 = 0;
              int64_t v98 = (unsigned __int16 *)(v9 + 32 * v87);
              char v155 = 0;
              unsigned int v156 = 0;
              sub_19E03CED8((uint64_t)&v153, v98);
              do
              {
                uint64_t v99 = v89;
                sub_19E03CED8((uint64_t)v98, (unsigned __int16 *)v89);
                if (v85 < v88) {
                  break;
                }
                uint64_t v100 = (2 * v88) | 1;
                uint64_t v89 = v9 + 32 * v100;
                if (2 * v88 + 2 < v11)
                {
                  uint64_t v101 = *(void *)(v89 + 8) ? *(const char **)(v89 + 8) : (const char *)(v89 + 16);
                  unint64_t v102 = *(void *)(v89 + 40) ? *(const char **)(v89 + 40) : (const char *)(v89 + 48);
                  int v103 = strcmp(v101, v102);
                  v89 += 32 * (v103 >> 31);
                  if (v103 < 0) {
                    uint64_t v100 = 2 * v88 + 2;
                  }
                }
                BOOL v104 = *(void *)(v89 + 8) ? *(const char **)(v89 + 8) : (const char *)(v89 + 16);
                unint64_t v105 = (const char *)(v156 ? v156 : v157);
                int64_t v98 = (unsigned __int16 *)v99;
                uint64_t v88 = v100;
              }
              while ((strcmp(v104, v105) & 0x80000000) == 0);
              sub_19E03CED8(v99, (unsigned __int16 *)&v153);
              if (v156) {
                BOOL v106 = v155 == 1;
              }
              else {
                BOOL v106 = 0;
              }
              if (v106) {
                free(v156);
              }
            }
          }
          int64_t v86 = v87 - 1;
        }
        while (v87);
        uint64_t v107 = (unint64_t)v10 >> 5;
        unint64_t v108 = v147;
        do
        {
          int v149 = 0x100000;
          __int16 v150 = 0;
          char v151 = 0;
          uint64_t v152 = 0;
          sub_19E03CED8((uint64_t)&v149, (unsigned __int16 *)v9);
          uint64_t v109 = 0;
          uint64_t v110 = v107 - 2;
          if (v107 < 2) {
            uint64_t v110 = v107 - 1;
          }
          uint64_t v111 = v110 >> 1;
          uint64_t v112 = v9;
          do
          {
            uint64_t v113 = v112 + 32 * (v109 + 1);
            uint64_t v114 = (2 * v109) | 1;
            uint64_t v115 = 2 * v109 + 2;
            if (v115 < v107)
            {
              uint64_t v116 = *(void *)(v113 + 8) ? *(const char **)(v113 + 8) : (const char *)(v113 + 16);
              unint64_t v117 = *(void *)(v113 + 40) ? *(const char **)(v113 + 40) : (const char *)(v113 + 48);
              int v118 = strcmp(v116, v117);
              v113 += 32 * (v118 >> 31);
              if (v118 < 0) {
                uint64_t v114 = v115;
              }
            }
            sub_19E03CED8(v112, (unsigned __int16 *)v113);
            uint64_t v112 = v113;
            uint64_t v109 = v114;
          }
          while (v114 <= v111);
          v108 -= 16;
          if ((unsigned __int16 *)v113 == v108)
          {
            sub_19E03CED8(v113, (unsigned __int16 *)&v149);
          }
          else
          {
            sub_19E03CED8(v113, v108);
            sub_19E03CED8((uint64_t)v108, (unsigned __int16 *)&v149);
            uint64_t v119 = v113 - v9 + 32;
            if (v119 >= 33)
            {
              unint64_t v120 = (unint64_t)((v119 >> 5) - 2) >> 1;
              unint64_t v121 = v9 + 32 * v120;
              unint64_t v122 = *(void *)(v121 + 8);
              unint64_t v123 = v121 + 16;
              uint64_t v124 = (const char *)(v122 ? v122 : v123);
              uint64_t v125 = *(void *)(v113 + 8) ? *(const char **)(v113 + 8) : (const char *)(v113 + 16);
              if (strcmp(v124, v125) < 0)
              {
                int v153 = 0x100000;
                __int16 v154 = 0;
                char v155 = 0;
                unsigned int v156 = 0;
                sub_19E03CED8((uint64_t)&v153, (unsigned __int16 *)v113);
                do
                {
                  uint64_t v126 = v113;
                  uint64_t v113 = v9 + 32 * v120;
                  sub_19E03CED8(v126, (unsigned __int16 *)v113);
                  if (!v120) {
                    break;
                  }
                  unint64_t v120 = (v120 - 1) >> 1;
                  unint64_t v127 = v9 + 32 * v120;
                  unint64_t v128 = *(void *)(v127 + 8);
                  unint64_t v129 = v127 + 16;
                  uint64_t v130 = (const char *)(v128 ? v128 : v129);
                  uint64_t v131 = (const char *)(v156 ? v156 : v157);
                }
                while (strcmp(v130, v131) < 0);
                sub_19E03CED8(v113, (unsigned __int16 *)&v153);
                if (v156 && v155 == 1) {
                  free(v156);
                }
              }
            }
          }
          if (v152 && v151 == 1) {
            free(v152);
          }
        }
        while (v107-- > 2);
      }
      return;
    }
    unint64_t v12 = (unsigned __int16 *)(v9 + 32 * ((unint64_t)v11 >> 1));
    uint64_t v13 = a2 - 32;
    if ((unint64_t)v10 <= 0x1000)
    {
      sub_19E0A147C((uint64_t)v12, v9, v13);
    }
    else
    {
      sub_19E0A147C(v9, (uint64_t)v12, v13);
      sub_19E0A147C(v144, (uint64_t)(v12 - 16), a2 - 64);
      sub_19E0A147C(v143, (uint64_t)(v12 + 16), a2 - 96);
      sub_19E0A147C((uint64_t)(v12 - 16), (uint64_t)v12, (uint64_t)(v12 + 16));
      int v153 = 0x100000;
      __int16 v154 = 0;
      char v155 = 0;
      unsigned int v156 = 0;
      sub_19E03CED8((uint64_t)&v153, (unsigned __int16 *)v9);
      sub_19E03CED8(v9, v12);
      sub_19E03CED8((uint64_t)v12, (unsigned __int16 *)&v153);
      if (v156 && v155 == 1) {
        free(v156);
      }
    }
    --a3;
    if ((a4 & 1) == 0)
    {
      uint64_t v14 = *(void *)(v9 - 24) ? *(const char **)(v9 - 24) : (const char *)v142;
      unint64_t v15 = *(void *)(v9 + 8) ? *(const char **)(v9 + 8) : (const char *)v141;
      if ((strcmp(v14, v15) & 0x80000000) == 0)
      {
        int v153 = 0x100000;
        __int16 v154 = 0;
        char v155 = 0;
        unsigned int v156 = 0;
        sub_19E03CED8((uint64_t)&v153, (unsigned __int16 *)v9);
        if (v156) {
          unsigned __int8 v48 = (const char *)v156;
        }
        else {
          unsigned __int8 v48 = (const char *)v157;
        }
        if (*(void *)(a2 - 24)) {
          BOOL v49 = *(const char **)(a2 - 24);
        }
        else {
          BOOL v49 = (const char *)(a2 - 16);
        }
        uint64_t v50 = (const char *)(v9 + 48);
        if (strcmp(v48, v49) < 0)
        {
          do
          {
            if (*((void *)v50 - 1)) {
              uint64_t v51 = (const char *)*((void *)v50 - 1);
            }
            else {
              uint64_t v51 = v50;
            }
            v50 += 32;
          }
          while ((strcmp(v48, v51) & 0x80000000) == 0);
          a1 = (unsigned __int16 *)(v50 - 48);
        }
        else
        {
          do
          {
            a1 = (unsigned __int16 *)(v50 - 16);
            if ((unint64_t)(v50 - 16) >= a2) {
              break;
            }
            unsigned int v52 = *((void *)v50 - 1) ? (const char *)*((void *)v50 - 1) : v50;
            v50 += 32;
          }
          while ((strcmp(v48, v52) & 0x80000000) == 0);
        }
        unsigned __int32 v53 = (unsigned __int16 *)a2;
        if ((unint64_t)a1 < a2)
        {
          unint64_t v54 = a2;
          do
          {
            unsigned __int32 v53 = (unsigned __int16 *)(v54 - 32);
            uint64_t v55 = *(const char **)(v54 - 24);
            uint64_t v56 = (const char *)(v54 - 16);
            if (v55) {
              unsigned int v57 = v55;
            }
            else {
              unsigned int v57 = v56;
            }
            int v58 = strcmp(v48, v57);
            unint64_t v54 = (unint64_t)v53;
          }
          while (v58 < 0);
        }
        while (a1 < v53)
        {
          sub_19E0A13D4(a1, v53);
          if (v156) {
            unint64_t v59 = (const char *)v156;
          }
          else {
            unint64_t v59 = (const char *)v157;
          }
          uint8x8_t v60 = a1 + 24;
          do
          {
            unint64_t v61 = (const char *)v60;
            uint64_t v62 = (const char *)*((void *)v60 - 1);
            if (v62) {
              uint64_t v63 = v62;
            }
            else {
              uint64_t v63 = v61;
            }
            int v64 = strcmp(v59, v63);
            uint8x8_t v60 = (unsigned __int16 *)(v61 + 32);
          }
          while ((v64 & 0x80000000) == 0);
          a1 = (unsigned __int16 *)(v61 - 16);
          do
          {
            uint64_t v65 = (const char *)*((void *)v53 - 3);
            float v66 = (const char *)(v53 - 8);
            v53 -= 16;
            if (v65) {
              float v67 = v65;
            }
            else {
              float v67 = v66;
            }
          }
          while (strcmp(v59, v67) < 0);
        }
        if (a1 - 16 != (unsigned __int16 *)v9) {
          sub_19E03CED8(v9, a1 - 16);
        }
        sub_19E03CED8((uint64_t)(a1 - 16), (unsigned __int16 *)&v153);
        if (v156)
        {
          BOOL v4 = v155 != 0;
          BOOL v5 = v155 == 1;
          if (v155 == 1) {
            free(v156);
          }
        }
        a4 = 0;
        goto LABEL_2;
      }
    }
    int v153 = 0x100000;
    __int16 v154 = 0;
    char v155 = 0;
    unsigned int v156 = 0;
    sub_19E03CED8((uint64_t)&v153, (unsigned __int16 *)v9);
    if (v156) {
      unsigned __int8 v16 = (const char *)v156;
    }
    else {
      unsigned __int8 v16 = (const char *)v157;
    }
    uint64_t v17 = (const char *)v145;
    do
    {
      float v18 = v17;
      float v19 = (const char *)*((void *)v17 - 1);
      if (v19) {
        BOOL v20 = v19;
      }
      else {
        BOOL v20 = v18;
      }
      int v21 = strcmp(v20, v16);
      uint64_t v17 = v18 + 32;
    }
    while (v21 < 0);
    unint64_t v22 = (unsigned __int16 *)(v18 - 48);
    size_t v23 = v18 - 16;
    unint64_t v24 = a2;
    if (v18 - 48 == (const char *)v9)
    {
      unint64_t v30 = a2;
      while ((unint64_t)v23 < v30)
      {
        uint64_t v25 = (unsigned __int16 *)(v30 - 32);
        uint64_t v31 = *(const char **)(v30 - 24);
        uint64_t v32 = (const char *)(v30 - 16);
        if (v31) {
          __int16 v33 = v31;
        }
        else {
          __int16 v33 = v32;
        }
        int v34 = strcmp(v33, v16);
        unint64_t v30 = (unint64_t)v25;
        if (v34 < 0) {
          goto LABEL_42;
        }
      }
      uint64_t v25 = (unsigned __int16 *)v30;
    }
    else
    {
      do
      {
        uint64_t v25 = (unsigned __int16 *)(v24 - 32);
        unint64_t v26 = *(const char **)(v24 - 24);
        uint64_t v27 = (const char *)(v24 - 16);
        if (v26) {
          char v28 = v26;
        }
        else {
          char v28 = v27;
        }
        int v29 = strcmp(v28, v16);
        unint64_t v24 = (unint64_t)v25;
      }
      while ((v29 & 0x80000000) == 0);
    }
LABEL_42:
    uint64_t v148 = a3;
    unint64_t v35 = a2;
    if (v23 < (const char *)v25)
    {
      uint64_t v36 = (unsigned __int16 *)(v18 - 16);
      uint64_t v37 = v25;
      do
      {
        sub_19E0A13D4(v36, v37);
        if (v156) {
          uint64_t v38 = (const char *)v156;
        }
        else {
          uint64_t v38 = (const char *)v157;
        }
        uint64_t v39 = v36 + 24;
        do
        {
          uint64_t v40 = (const char *)v39;
          uint64_t v41 = (const char *)*((void *)v39 - 1);
          if (v41) {
            uint64_t v42 = v41;
          }
          else {
            uint64_t v42 = v40;
          }
          int v43 = strcmp(v42, v38);
          uint64_t v39 = (unsigned __int16 *)(v40 + 32);
        }
        while (v43 < 0);
        unint64_t v22 = (unsigned __int16 *)(v40 - 48);
        uint64_t v36 = (unsigned __int16 *)(v40 - 16);
        do
        {
          uint64_t v44 = (const char *)*((void *)v37 - 3);
          uint64_t v45 = (const char *)(v37 - 8);
          v37 -= 16;
          if (v44) {
            uint64_t v46 = v44;
          }
          else {
            uint64_t v46 = v45;
          }
        }
        while ((strcmp(v46, v38) & 0x80000000) == 0);
      }
      while (v36 < v37);
    }
    if (v22 != (unsigned __int16 *)v9) {
      sub_19E03CED8(v9, v22);
    }
    sub_19E03CED8((uint64_t)v22, (unsigned __int16 *)&v153);
    a2 = v35;
    if (v156 && v155 == 1) {
      free(v156);
    }
    a3 = v148;
    if (v23 < (const char *)v25) {
      goto LABEL_68;
    }
    char v47 = sub_19E0A17C4(v9, (uint64_t)v22);
    a1 = v22 + 16;
    if (!sub_19E0A17C4((uint64_t)(v22 + 16), a2))
    {
      if (v47) {
        goto LABEL_2;
      }
LABEL_68:
      sub_19E0A0358(v9, v22, v148, a4 & 1);
      a4 = 0;
      a1 = v22 + 16;
      goto LABEL_2;
    }
    a2 = (unint64_t)v22;
    if (v47) {
      return;
    }
  }
  if (a4)
  {
    if (v9 != a2)
    {
      uint64_t v70 = v9 + 32;
      if (v9 + 32 != a2)
      {
        uint64_t v71 = 0;
        uint64_t v72 = v9;
        do
        {
          uint64_t v73 = *(const char **)(v72 + 40);
          uint64_t v74 = (const char *)(v72 + 48);
          uint64_t v75 = *(const char **)(v72 + 8);
          unint64_t v76 = (const char *)(v72 + 16);
          uint64_t v72 = v70;
          if (v73) {
            uint8x8_t v77 = v73;
          }
          else {
            uint8x8_t v77 = v74;
          }
          if (v75) {
            unint64_t v78 = v75;
          }
          else {
            unint64_t v78 = v76;
          }
          if (strcmp(v77, v78) < 0)
          {
            int v153 = 0x100000;
            __int16 v154 = 0;
            char v155 = 0;
            unsigned int v156 = 0;
            sub_19E03CED8((uint64_t)&v153, (unsigned __int16 *)v72);
            uint64_t v79 = v71;
            while (1)
            {
              uint64_t v80 = v9 + v79;
              sub_19E03CED8(v9 + v79 + 32, (unsigned __int16 *)(v9 + v79));
              if (!v79) {
                break;
              }
              if (v156) {
                uint64_t v81 = (const char *)v156;
              }
              else {
                uint64_t v81 = (const char *)v157;
              }
              if (*(void *)(v80 - 24)) {
                unint64_t v82 = *(const char **)(v80 - 24);
              }
              else {
                unint64_t v82 = (const char *)(v80 - 16);
              }
              v79 -= 32;
              if ((strcmp(v81, v82) & 0x80000000) == 0)
              {
                uint64_t v83 = v9 + v79 + 32;
                goto LABEL_147;
              }
            }
            uint64_t v83 = v9;
LABEL_147:
            sub_19E03CED8(v83, (unsigned __int16 *)&v153);
            if (v156) {
              BOOL v84 = v155 == 1;
            }
            else {
              BOOL v84 = 0;
            }
            if (v84) {
              free(v156);
            }
          }
          uint64_t v70 = v72 + 32;
          v71 += 32;
        }
        while (v72 + 32 != a2);
      }
    }
  }
  else if (v9 != a2)
  {
    uint64_t v134 = (unsigned __int16 *)(v9 + 32);
    if (v9 + 32 != a2)
    {
      do
      {
        unsigned int v135 = v134;
        if (*(void *)(v9 + 40)) {
          uint64_t v136 = *(const char **)(v9 + 40);
        }
        else {
          uint64_t v136 = (const char *)(v9 + 48);
        }
        if (*(void *)(v9 + 8)) {
          uint64_t v137 = *(const char **)(v9 + 8);
        }
        else {
          uint64_t v137 = (const char *)(v9 + 16);
        }
        if (strcmp(v136, v137) < 0)
        {
          int v153 = 0x100000;
          __int16 v154 = 0;
          char v155 = 0;
          unsigned int v156 = 0;
          sub_19E03CED8((uint64_t)&v153, v135);
          do
          {
            uint64_t v138 = v9;
            sub_19E03CED8(v9 + 32, (unsigned __int16 *)v9);
            v9 -= 32;
            if (v156) {
              __int16 v139 = (const char *)v156;
            }
            else {
              __int16 v139 = (const char *)v157;
            }
            if (*(void *)(v138 - 24)) {
              unint64_t v140 = *(const char **)(v138 - 24);
            }
            else {
              unint64_t v140 = (const char *)(v138 - 16);
            }
          }
          while (strcmp(v139, v140) < 0);
          sub_19E03CED8(v138, (unsigned __int16 *)&v153);
          if (v156)
          {
            if (v155 == 1) {
              free(v156);
            }
          }
        }
        uint64_t v134 = v135 + 16;
        uint64_t v9 = (uint64_t)v135;
      }
      while (v135 + 16 != (unsigned __int16 *)a2);
    }
  }
}

uint64_t sub_19E0A0E7C(uint64_t a1, unsigned __int16 **a2)
{
  uint64_t v2 = *a2;
  unint64_t v3 = a2[1];
  if (*a2 == v3) {
    return 0;
  }
  LODWORD(v4) = 0;
  BOOL v5 = (void *)(a1 + 32);
  do
  {
    uint64_t v6 = sub_19E0A12C0(v5, v2);
    if (!v6) {
      __assert_rtn("convert_combining_classes_to_bits_block_invoke", "UnigramsCompiler.cpp", 370, "class_ids.count(class_name)");
    }
    uint64_t v4 = (1 << *((_DWORD *)v6 + 12)) | v4;
    v2 += 16;
  }
  while (v2 != v3);
  return v4;
}

uint64_t sub_19E0A0F14(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_19E08A5BC(a1, *(void *)(a2 + 8));
  for (int i = *(unsigned __int16 **)(a2 + 16); i; int i = *(unsigned __int16 **)i)
  {
    if (*((void *)i + 3)) {
      uint64_t v6 = (unsigned __int8 *)*((void *)i + 3);
    }
    else {
      uint64_t v6 = (unsigned __int8 *)(i + 16);
    }
    unsigned int v7 = sub_19E0B24AC(v6, i[8]);
    unint64_t v8 = v7;
    unint64_t v9 = *(void *)(a1 + 8);
    if (v9)
    {
      uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
      v10.i16[0] = vaddlv_u8(v10);
      unint64_t v11 = v10.u32[0];
      if (v10.u32[0] > 1uLL)
      {
        unint64_t v2 = v7;
        if (v9 <= v7) {
          unint64_t v2 = v7 % v9;
        }
      }
      else
      {
        unint64_t v2 = (v9 - 1) & v7;
      }
      unint64_t v12 = *(unsigned __int16 ***)(*(void *)a1 + 8 * v2);
      if (v12)
      {
        for (uint64_t j = *v12; j; uint64_t j = *(unsigned __int16 **)j)
        {
          unint64_t v14 = *((void *)j + 1);
          if (v14 == v8)
          {
            if (j == i || sub_19E0B2428(j + 8, i + 8)) {
              goto LABEL_44;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9) {
                v14 %= v9;
              }
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v2) {
              break;
            }
          }
        }
      }
    }
    unint64_t v15 = operator new(0x38uLL);
    v26[0] = (uint64_t)v15;
    v26[1] = a1 + 16;
    char v27 = 0;
    void *v15 = 0;
    v15[1] = v8;
    sub_19E039858((uint64_t)(v15 + 2), i + 8);
    *((_DWORD *)v15 + 12) = *((_DWORD *)i + 12);
    char v27 = 1;
    float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
    float v17 = *(float *)(a1 + 32);
    if (!v9 || (float)(v17 * (float)v9) < v16)
    {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
      if (v9 < 3) {
        BOOL v18 = 1;
      }
      unint64_t v19 = v18 | (2 * v9);
      unint64_t v20 = vcvtps_u32_f32(v16 / v17);
      if (v19 <= v20) {
        size_t v21 = v20;
      }
      else {
        size_t v21 = v19;
      }
      sub_19E08A5BC(a1, v21);
      unint64_t v9 = *(void *)(a1 + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v9 <= v8) {
          unint64_t v2 = v8 % v9;
        }
        else {
          unint64_t v2 = v8;
        }
      }
      else
      {
        unint64_t v2 = (v9 - 1) & v8;
      }
    }
    unint64_t v22 = *(uint64_t **)(*(void *)a1 + 8 * v2);
    uint64_t v23 = v26[0];
    if (v22)
    {
      *(void *)v26[0] = *v22;
    }
    else
    {
      *(void *)v26[0] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v23;
      *(void *)(*(void *)a1 + 8 * v2) = a1 + 16;
      if (!*(void *)v23) {
        goto LABEL_43;
      }
      unint64_t v24 = *(void *)(*(void *)v23 + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v24 >= v9) {
          v24 %= v9;
        }
      }
      else
      {
        v24 &= v9 - 1;
      }
      unint64_t v22 = (uint64_t *)(*(void *)a1 + 8 * v24);
    }
    uint64_t *v22 = v23;
LABEL_43:
    v26[0] = 0;
    ++*(void *)(a1 + 24);
    sub_19E0A1244(v26);
LABEL_44:
    ;
  }
  return a1;
}

void sub_19E0A11A8(_Unwind_Exception *a1)
{
  sub_19E0A11D4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0A11D4(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  while (v2)
  {
    unint64_t v3 = v2;
    unint64_t v2 = (void *)*v2;
    uint64_t v4 = (void *)v3[3];
    if (v4 && *((unsigned char *)v3 + 22) == 1) {
      free(v4);
    }
    operator delete(v3);
  }
  BOOL v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

void sub_19E0A1244(uint64_t *a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    if (*((unsigned char *)a1 + 16))
    {
      unint64_t v2 = *(void **)(v1 + 24);
      if (v2)
      {
        if (*(unsigned char *)(v1 + 22) == 1) {
          free(v2);
        }
      }
    }
    operator delete((void *)v1);
  }
}

uint64_t sub_19E0A12AC(uint64_t a1)
{
  return sub_19E0A11D4(a1 + 32);
}

uint64_t sub_19E0A12B4(uint64_t a1, uint64_t a2)
{
  return sub_19E0A0F14(a1 + 32, a2 + 32);
}

unsigned __int16 *sub_19E0A12C0(void *a1, unsigned __int16 *a2)
{
  if (*((void *)a2 + 1)) {
    uint64_t v4 = (unsigned __int8 *)*((void *)a2 + 1);
  }
  else {
    uint64_t v4 = (unsigned __int8 *)(a2 + 8);
  }
  unsigned int v5 = sub_19E0B24AC(v4, *a2);
  unint64_t v6 = a1[1];
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v5;
  uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v8.i16[0] = vaddlv_u8(v8);
  unint64_t v9 = v8.u32[0];
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v10 = v5;
    if (v6 <= v5) {
      unint64_t v10 = v5 % v6;
    }
  }
  else
  {
    unint64_t v10 = (v6 - 1) & v5;
  }
  unint64_t v11 = *(unsigned __int16 ***)(*a1 + 8 * v10);
  if (!v11) {
    return 0;
  }
  for (int i = *v11; i; int i = *(unsigned __int16 **)i)
  {
    unint64_t v13 = *((void *)i + 1);
    if (v13 == v7)
    {
      if (i + 8 == a2 || sub_19E0B2428(i + 8, a2)) {
        return i;
      }
    }
    else
    {
      if (v9 > 1)
      {
        if (v13 >= v6) {
          v13 %= v6;
        }
      }
      else
      {
        v13 &= v6 - 1;
      }
      if (v13 != v10) {
        return 0;
      }
    }
  }
  return i;
}

void sub_19E0A13D4(unsigned __int16 *a1, unsigned __int16 *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v5 = 0x100000;
  __int16 v6 = 0;
  char v7 = 0;
  uint8x8_t v8 = 0;
  sub_19E03CED8((uint64_t)&v5, a1);
  sub_19E03CED8((uint64_t)a1, a2);
  sub_19E03CED8((uint64_t)a2, (unsigned __int16 *)&v5);
  if (v8) {
    BOOL v4 = v7 == 1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    free(v8);
  }
}

void sub_19E0A147C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 v6 = (const char *)(a2 + 16);
  if (*(void *)(a2 + 8)) {
    char v7 = *(const char **)(a2 + 8);
  }
  else {
    char v7 = (const char *)(a2 + 16);
  }
  uint64_t v8 = a1 + 16;
  if (*(void *)(a1 + 8)) {
    uint64_t v9 = *(const char **)(a1 + 8);
  }
  else {
    uint64_t v9 = (const char *)(a1 + 16);
  }
  int v10 = strcmp(v7, v9);
  if (*(void *)(a3 + 8)) {
    unint64_t v11 = *(const char **)(a3 + 8);
  }
  else {
    unint64_t v11 = (const char *)(a3 + 16);
  }
  int v12 = strcmp(v11, v7);
  if (v10 < 0)
  {
    if (v12 < 0)
    {
      unint64_t v13 = (unsigned __int16 *)a1;
LABEL_30:
      float v16 = (unsigned __int16 *)a3;
      goto LABEL_31;
    }
    sub_19E0A13D4((unsigned __int16 *)a1, (unsigned __int16 *)a2);
    if (*(void *)(a3 + 8)) {
      float v17 = *(const char **)(a3 + 8);
    }
    else {
      float v17 = (const char *)(a3 + 16);
    }
    if (*(void *)(a2 + 8)) {
      BOOL v18 = *(const char **)(a2 + 8);
    }
    else {
      BOOL v18 = v6;
    }
    if (strcmp(v17, v18) < 0)
    {
      unint64_t v13 = (unsigned __int16 *)a2;
      goto LABEL_30;
    }
  }
  else if (v12 < 0)
  {
    sub_19E0A13D4((unsigned __int16 *)a2, (unsigned __int16 *)a3);
    unint64_t v14 = *(void *)(a2 + 8) ? *(const char **)(a2 + 8) : v6;
    unint64_t v15 = *(void *)(a1 + 8) ? *(const char **)(a1 + 8) : (const char *)v8;
    if (strcmp(v14, v15) < 0)
    {
      unint64_t v13 = (unsigned __int16 *)a1;
      float v16 = (unsigned __int16 *)a2;
LABEL_31:
      sub_19E0A13D4(v13, v16);
    }
  }
}

void sub_19E0A15A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_19E0A147C(a1, a2, a3);
  if (*(void *)(a4 + 8)) {
    uint64_t v8 = *(const char **)(a4 + 8);
  }
  else {
    uint64_t v8 = (const char *)(a4 + 16);
  }
  if (*(void *)(a3 + 8)) {
    uint64_t v9 = *(const char **)(a3 + 8);
  }
  else {
    uint64_t v9 = (const char *)(a3 + 16);
  }
  if (strcmp(v8, v9) < 0)
  {
    sub_19E0A13D4((unsigned __int16 *)a3, (unsigned __int16 *)a4);
    int v10 = *(void *)(a3 + 8) ? *(const char **)(a3 + 8) : (const char *)(a3 + 16);
    unint64_t v11 = *(void *)(a2 + 8) ? *(const char **)(a2 + 8) : (const char *)(a2 + 16);
    if (strcmp(v10, v11) < 0)
    {
      sub_19E0A13D4((unsigned __int16 *)a2, (unsigned __int16 *)a3);
      int v12 = *(void *)(a2 + 8) ? *(const char **)(a2 + 8) : (const char *)(a2 + 16);
      unint64_t v13 = *(void *)(a1 + 8) ? *(const char **)(a1 + 8) : (const char *)(a1 + 16);
      if (strcmp(v12, v13) < 0)
      {
        sub_19E0A13D4((unsigned __int16 *)a1, (unsigned __int16 *)a2);
      }
    }
  }
}

void sub_19E0A169C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_19E0A15A8(a1, a2, a3, a4);
  if (*(void *)(a5 + 8)) {
    int v10 = *(const char **)(a5 + 8);
  }
  else {
    int v10 = (const char *)(a5 + 16);
  }
  if (*(void *)(a4 + 8)) {
    unint64_t v11 = *(const char **)(a4 + 8);
  }
  else {
    unint64_t v11 = (const char *)(a4 + 16);
  }
  if (strcmp(v10, v11) < 0)
  {
    sub_19E0A13D4((unsigned __int16 *)a4, (unsigned __int16 *)a5);
    int v12 = *(void *)(a4 + 8) ? *(const char **)(a4 + 8) : (const char *)(a4 + 16);
    unint64_t v13 = *(void *)(a3 + 8) ? *(const char **)(a3 + 8) : (const char *)(a3 + 16);
    if (strcmp(v12, v13) < 0)
    {
      sub_19E0A13D4((unsigned __int16 *)a3, (unsigned __int16 *)a4);
      unint64_t v14 = *(void *)(a3 + 8) ? *(const char **)(a3 + 8) : (const char *)(a3 + 16);
      unint64_t v15 = *(void *)(a2 + 8) ? *(const char **)(a2 + 8) : (const char *)(a2 + 16);
      if (strcmp(v14, v15) < 0)
      {
        sub_19E0A13D4((unsigned __int16 *)a2, (unsigned __int16 *)a3);
        float v16 = *(void *)(a2 + 8) ? *(const char **)(a2 + 8) : (const char *)(a2 + 16);
        float v17 = *(void *)(a1 + 8) ? *(const char **)(a1 + 8) : (const char *)(a1 + 16);
        if (strcmp(v16, v17) < 0)
        {
          sub_19E0A13D4((unsigned __int16 *)a1, (unsigned __int16 *)a2);
        }
      }
    }
  }
}

uint64_t sub_19E0A17C4(uint64_t a1, uint64_t a2)
{
  _DWORD v23[2] = *MEMORY[0x1E4F143B8];
  BOOL v4 = 1;
  switch((a2 - a1) >> 5)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      if (*(void *)(a2 - 24)) {
        int v5 = *(const char **)(a2 - 24);
      }
      else {
        int v5 = (const char *)(a2 - 16);
      }
      if (*(void *)(a1 + 8)) {
        __int16 v6 = *(const char **)(a1 + 8);
      }
      else {
        __int16 v6 = (const char *)(a1 + 16);
      }
      if (strcmp(v5, v6) < 0) {
        sub_19E0A13D4((unsigned __int16 *)a1, (unsigned __int16 *)(a2 - 32));
      }
      return v4;
    case 3:
      sub_19E0A147C(a1, a1 + 32, a2 - 32);
      return v4;
    case 4:
      sub_19E0A15A8(a1, a1 + 32, a1 + 64, a2 - 32);
      return v4;
    case 5:
      sub_19E0A169C(a1, a1 + 32, a1 + 64, a1 + 96, a2 - 32);
      return v4;
    default:
      uint64_t v7 = a1 + 64;
      sub_19E0A147C(a1, a1 + 32, a1 + 64);
      uint64_t v8 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    unint64_t v11 = *(void *)(v8 + 8) ? *(const char **)(v8 + 8) : (const char *)(v8 + 16);
    int v12 = *(void *)(v7 + 8) ? *(const char **)(v7 + 8) : (const char *)(v7 + 16);
    if (strcmp(v11, v12) < 0) {
      break;
    }
LABEL_34:
    uint64_t v7 = v8;
    v9 += 32;
    v8 += 32;
    if (v8 == a2) {
      return 1;
    }
  }
  int v19 = 0x100000;
  __int16 v20 = 0;
  char v21 = 0;
  unint64_t v22 = 0;
  sub_19E03CED8((uint64_t)&v19, (unsigned __int16 *)v8);
  uint64_t v13 = v9;
  while (1)
  {
    uint64_t v14 = a1 + v13;
    sub_19E03CED8(a1 + v13 + 96, (unsigned __int16 *)(a1 + v13 + 64));
    if (v13 == -64) {
      break;
    }
    if (v22) {
      unint64_t v15 = (const char *)v22;
    }
    else {
      unint64_t v15 = (const char *)v23;
    }
    if (*(void *)(v14 + 40)) {
      float v16 = *(const char **)(v14 + 40);
    }
    else {
      float v16 = (const char *)(v14 + 48);
    }
    v13 -= 32;
    if ((strcmp(v15, v16) & 0x80000000) == 0)
    {
      uint64_t v17 = a1 + v13 + 96;
      goto LABEL_30;
    }
  }
  uint64_t v17 = a1;
LABEL_30:
  sub_19E03CED8(v17, (unsigned __int16 *)&v19);
  if (++v10 != 8)
  {
    if (v22 && v21 == 1) {
      free(v22);
    }
    goto LABEL_34;
  }
  BOOL v4 = v8 + 32 == a2;
  if (v22 && v21 == 1) {
    free(v22);
  }
  return v4;
}

char *sub_19E0A1A48(void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_19E041BEC();
  }
  __n128 result = (char *)sub_19E08A810(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void sub_19E0A1A88(uint64_t a1)
{
  uint64_t v1 = *(atomic_uint **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_19E07700C(v1 + 4);
    }
    operator delete(v1);
  }
}

uint64_t sub_19E0A1AE0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (unsigned __int8 *)a1;
  unint64_t v5 = *(void *)(a1 + 8);
  if (*(char *)(a1 + 23) >= 0)
  {
    unint64_t v6 = *(unsigned __int8 *)(a1 + 23);
  }
  else
  {
    a1 = *(void *)a1;
    unint64_t v6 = v5;
  }
  unint64_t v7 = sub_19E086FCC((uint64_t *)a1, v6);
  unint64_t v8 = v7;
  unint64_t v9 = *((void *)&xmmword_1EB4FEC20 + 1);
  if (*((void *)&xmmword_1EB4FEC20 + 1))
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EB4FEC20 + 8));
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v2 = v7;
      if (v7 >= *((void *)&xmmword_1EB4FEC20 + 1)) {
        unint64_t v2 = v7 % *((void *)&xmmword_1EB4FEC20 + 1);
      }
    }
    else
    {
      unint64_t v2 = (*((void *)&xmmword_1EB4FEC20 + 1) - 1) & v7;
    }
    int v12 = *(uint64_t **)(xmmword_1EB4FEC20 + 8 * v2);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(void *)i)
      {
        unint64_t v14 = *(void *)(i + 8);
        if (v14 == v8)
        {
          if (sub_19E072B54((unsigned __int8 *)(i + 16), v4)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v2) {
            break;
          }
        }
      }
    }
  }
  unint64_t v15 = operator new(0x38uLL);
  v37[0] = (uint64_t)v15;
  v37[1] = (uint64_t)&qword_1EB4FEC30;
  char v38 = 0;
  void *v15 = 0;
  v15[1] = v8;
  float v16 = v15 + 2;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E03FA9C(v16, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)float v16 = *(_OWORD *)a2;
    void v15[4] = *(void *)(a2 + 16);
  }
  CFTypeRef v15[5] = 0;
  v15[6] = 0;
  char v38 = 1;
  float v17 = (float)(unint64_t)(qword_1EB4FEC38 + 1);
  if (!v9 || (float)(*(float *)&xmmword_1EB4FEC40 * (float)v9) < v17)
  {
    BOOL v18 = 1;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v17 / *(float *)&xmmword_1EB4FEC40);
    if (v19 <= v20) {
      int8x8_t prime = (int8x8_t)v20;
    }
    else {
      int8x8_t prime = (int8x8_t)v19;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v9 = *((void *)&xmmword_1EB4FEC20 + 1);
    if (*(void *)&prime > *((void *)&xmmword_1EB4FEC20 + 1)) {
      goto LABEL_36;
    }
    if (*(void *)&prime < *((void *)&xmmword_1EB4FEC20 + 1))
    {
      unint64_t v28 = vcvtps_u32_f32((float)(unint64_t)qword_1EB4FEC38 / *(float *)&xmmword_1EB4FEC40);
      if (*((void *)&xmmword_1EB4FEC20 + 1) < 3uLL
        || (uint8x8_t v29 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EB4FEC20 + 8)),
            v29.i16[0] = vaddlv_u8(v29),
            v29.u32[0] > 1uLL))
      {
        unint64_t v28 = std::__next_prime(v28);
      }
      else
      {
        uint64_t v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2) {
          unint64_t v28 = v30;
        }
      }
      if (*(void *)&prime <= v28) {
        int8x8_t prime = (int8x8_t)v28;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = *((void *)&xmmword_1EB4FEC20 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_36:
          if (*(void *)&prime >> 61) {
            sub_19E0416C4();
          }
          unint64_t v22 = operator new(8 * *(void *)&prime);
          uint64_t v23 = (void *)xmmword_1EB4FEC20;
          *(void *)&xmmword_1EB4FEC20 = v22;
          if (v23) {
            operator delete(v23);
          }
          uint64_t v24 = 0;
          *((int8x8_t *)&xmmword_1EB4FEC20 + 1) = prime;
          do
            *(void *)(xmmword_1EB4FEC20 + 8 * v24++) = 0;
          while (*(void *)&prime != v24);
          uint64_t v25 = (void **)qword_1EB4FEC30;
          if (qword_1EB4FEC30)
          {
            unint64_t v26 = *(void *)(qword_1EB4FEC30 + 8);
            uint8x8_t v27 = (uint8x8_t)vcnt_s8(prime);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= *(void *)&prime) {
                v26 %= *(void *)&prime;
              }
            }
            else
            {
              v26 &= *(void *)&prime - 1;
            }
            *(void *)(xmmword_1EB4FEC20 + 8 * v26) = &qword_1EB4FEC30;
            for (uint64_t j = *v25; j; v26 = v32)
            {
              unint64_t v32 = j[1];
              if (v27.u32[0] > 1uLL)
              {
                if (v32 >= *(void *)&prime) {
                  v32 %= *(void *)&prime;
                }
              }
              else
              {
                v32 &= *(void *)&prime - 1;
              }
              if (v32 != v26)
              {
                if (!*(void *)(xmmword_1EB4FEC20 + 8 * v32))
                {
                  *(void *)(xmmword_1EB4FEC20 + 8 * v32) = v25;
                  goto LABEL_61;
                }
                unsigned __int16 *v25 = (void *)*j;
                *uint64_t j = **(void **)(xmmword_1EB4FEC20 + 8 * v32);
                **(void **)(xmmword_1EB4FEC20 + 8 * v32) = j;
                uint64_t j = v25;
              }
              unint64_t v32 = v26;
LABEL_61:
              uint64_t v25 = (void **)j;
              uint64_t j = (void *)*j;
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_65;
        }
        uint64_t v36 = (void *)xmmword_1EB4FEC20;
        *(void *)&xmmword_1EB4FEC20 = 0;
        if (v36) {
          operator delete(v36);
        }
        unint64_t v9 = 0;
        *((void *)&xmmword_1EB4FEC20 + 1) = 0;
      }
    }
LABEL_65:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v2 = v8 % v9;
      }
      else {
        unint64_t v2 = v8;
      }
    }
    else
    {
      unint64_t v2 = (v9 - 1) & v8;
    }
  }
  __int16 v33 = *(uint64_t **)(xmmword_1EB4FEC20 + 8 * v2);
  uint64_t i = v37[0];
  if (v33)
  {
    *(void *)v37[0] = *v33;
LABEL_78:
    *__int16 v33 = i;
    goto LABEL_79;
  }
  *(void *)v37[0] = qword_1EB4FEC30;
  qword_1EB4FEC30 = i;
  *(void *)(xmmword_1EB4FEC20 + 8 * v2) = &qword_1EB4FEC30;
  if (*(void *)i)
  {
    unint64_t v34 = *(void *)(*(void *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v34 >= v9) {
        v34 %= v9;
      }
    }
    else
    {
      v34 &= v9 - 1;
    }
    __int16 v33 = (uint64_t *)(xmmword_1EB4FEC20 + 8 * v34);
    goto LABEL_78;
  }
LABEL_79:
  v37[0] = 0;
  ++qword_1EB4FEC38;
  sub_19E0A2680(v37);
  return i;
}

void sub_19E0A1F5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E0A2680((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E0A1F74(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = (unsigned __int8 *)a1;
  unint64_t v4 = *(void *)(a1 + 8);
  if (*(char *)(a1 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else
  {
    a1 = *(void *)a1;
    unint64_t v5 = v4;
  }
  unint64_t v6 = sub_19E086FCC((uint64_t *)a1, v5);
  unint64_t v7 = qword_1EB4FEC50;
  if (qword_1EB4FEC50)
  {
    unint64_t v8 = v6;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1EB4FEC50);
    v9.i16[0] = vaddlv_u8(v9);
    unint64_t v10 = v9.u32[0];
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v11 = v6;
      if (v6 >= qword_1EB4FEC50) {
        unint64_t v11 = v6 % qword_1EB4FEC50;
      }
    }
    else
    {
      unint64_t v11 = (qword_1EB4FEC50 - 1) & v6;
    }
    int v12 = *(unsigned __int8 ***)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v11);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v8 == v14)
        {
          if (sub_19E072B54(i + 16, v3))
          {
            uint64_t v15 = sub_19E0A2140((uint64_t)v3, (uint64_t)v3);
            float v16 = *(uint64_t **)(v15 + 40);
            for (uint64_t j = *(uint64_t **)(v15 + 48); v16 != j; v16 += 2)
            {
              BOOL v18 = (std::__shared_weak_count *)v16[1];
              if (v18)
              {
                unint64_t v19 = std::__shared_weak_count::lock(v18);
                if (v19)
                {
                  unint64_t v20 = v19;
                  uint64_t v21 = *v16;
                  if (*v16)
                  {
                    unint64_t v22 = (std::__shared_weak_count *)a2[1];
                    uint64_t v23 = *a2;
                    uint64_t v24 = v22;
                    if (v22) {
                      atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                    }
                    (*(void (**)(uint64_t, uint64_t *))(*(void *)v21 + 16))(v21, &v23);
                    if (v24) {
                      std::__shared_weak_count::__release_weak(v24);
                    }
                  }
                  sub_19E0616BC(v20);
                }
              }
            }
            return;
          }
        }
        else
        {
          if (v10 > 1)
          {
            if (v14 >= v7) {
              v14 %= v7;
            }
          }
          else
          {
            v14 &= v7 - 1;
          }
          if (v14 != v11) {
            return;
          }
        }
      }
    }
  }
}

void sub_19E0A2120(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  sub_19E0616BC(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0A2140(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (unsigned __int8 *)a1;
  unint64_t v5 = *(void *)(a1 + 8);
  if (*(char *)(a1 + 23) >= 0)
  {
    unint64_t v6 = *(unsigned __int8 *)(a1 + 23);
  }
  else
  {
    a1 = *(void *)a1;
    unint64_t v6 = v5;
  }
  unint64_t v7 = sub_19E086FCC((uint64_t *)a1, v6);
  unint64_t v8 = v7;
  unint64_t v9 = qword_1EB4FEC50;
  if (qword_1EB4FEC50)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1EB4FEC50);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v2 = v7;
      if (v7 >= qword_1EB4FEC50) {
        unint64_t v2 = v7 % qword_1EB4FEC50;
      }
    }
    else
    {
      unint64_t v2 = (qword_1EB4FEC50 - 1) & v7;
    }
    int v12 = *(uint64_t **)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v2);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(void *)i)
      {
        unint64_t v14 = *(void *)(i + 8);
        if (v14 == v8)
        {
          if (sub_19E072B54((unsigned __int8 *)(i + 16), v4)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v2) {
            break;
          }
        }
      }
    }
  }
  uint64_t v15 = operator new(0x40uLL);
  v37[0] = (uint64_t)v15;
  v37[1] = (uint64_t)&qword_1EB4FEC58;
  char v38 = 0;
  void *v15 = 0;
  v15[1] = v8;
  float v16 = v15 + 2;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E03FA9C(v16, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)float v16 = *(_OWORD *)a2;
    void v15[4] = *(void *)(a2 + 16);
  }
  CFTypeRef v15[5] = 0;
  v15[6] = 0;
  v15[7] = 0;
  char v38 = 1;
  float v17 = (float)(unint64_t)(xmmword_1EB4FEC60 + 1);
  if (!v9 || (float)(*((float *)&xmmword_1EB4FEC60 + 2) * (float)v9) < v17)
  {
    BOOL v18 = 1;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v17 / *((float *)&xmmword_1EB4FEC60 + 2));
    if (v19 <= v20) {
      unint64_t prime = v20;
    }
    else {
      unint64_t prime = v19;
    }
    if (prime == 1)
    {
      unint64_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      unint64_t prime = std::__next_prime(prime);
    }
    unint64_t v9 = qword_1EB4FEC50;
    if (prime > qword_1EB4FEC50) {
      goto LABEL_36;
    }
    if (prime < qword_1EB4FEC50)
    {
      unint64_t v28 = vcvtps_u32_f32((float)(unint64_t)xmmword_1EB4FEC60 / *((float *)&xmmword_1EB4FEC60 + 2));
      if ((unint64_t)qword_1EB4FEC50 < 3
        || (uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1EB4FEC50), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
      {
        unint64_t v28 = std::__next_prime(v28);
      }
      else
      {
        uint64_t v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2) {
          unint64_t v28 = v30;
        }
      }
      if (prime <= v28) {
        unint64_t prime = v28;
      }
      if (prime >= v9)
      {
        unint64_t v9 = qword_1EB4FEC50;
      }
      else
      {
        if (prime)
        {
LABEL_36:
          if (prime >> 61) {
            sub_19E0416C4();
          }
          unint64_t v22 = operator new(8 * prime);
          uint64_t v23 = (void *)*((void *)&xmmword_1EB4FEC40 + 1);
          *((void *)&xmmword_1EB4FEC40 + 1) = v22;
          if (v23) {
            operator delete(v23);
          }
          uint64_t v24 = 0;
          qword_1EB4FEC50 = prime;
          do
            *(void *)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v24++) = 0;
          while (prime != v24);
          uint64_t v25 = (void **)qword_1EB4FEC58;
          if (qword_1EB4FEC58)
          {
            unint64_t v26 = *(void *)(qword_1EB4FEC58 + 8);
            uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= prime) {
                v26 %= prime;
              }
            }
            else
            {
              v26 &= prime - 1;
            }
            *(void *)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v26) = &qword_1EB4FEC58;
            for (uint64_t j = *v25; j; v26 = v32)
            {
              unint64_t v32 = j[1];
              if (v27.u32[0] > 1uLL)
              {
                if (v32 >= prime) {
                  v32 %= prime;
                }
              }
              else
              {
                v32 &= prime - 1;
              }
              if (v32 != v26)
              {
                if (!*(void *)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v32))
                {
                  *(void *)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v32) = v25;
                  goto LABEL_61;
                }
                unsigned __int16 *v25 = (void *)*j;
                *uint64_t j = **(void **)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v32);
                **(void **)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v32) = j;
                uint64_t j = v25;
              }
              unint64_t v32 = v26;
LABEL_61:
              uint64_t v25 = (void **)j;
              uint64_t j = (void *)*j;
            }
          }
          unint64_t v9 = prime;
          goto LABEL_65;
        }
        uint64_t v36 = (void *)*((void *)&xmmword_1EB4FEC40 + 1);
        *((void *)&xmmword_1EB4FEC40 + 1) = 0;
        if (v36) {
          operator delete(v36);
        }
        unint64_t v9 = 0;
        qword_1EB4FEC50 = 0;
      }
    }
LABEL_65:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v2 = v8 % v9;
      }
      else {
        unint64_t v2 = v8;
      }
    }
    else
    {
      unint64_t v2 = (v9 - 1) & v8;
    }
  }
  __int16 v33 = *(uint64_t **)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v2);
  uint64_t i = v37[0];
  if (v33)
  {
    *(void *)v37[0] = *v33;
LABEL_78:
    *__int16 v33 = i;
    goto LABEL_79;
  }
  *(void *)v37[0] = qword_1EB4FEC58;
  qword_1EB4FEC58 = i;
  *(void *)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v2) = &qword_1EB4FEC58;
  if (*(void *)i)
  {
    unint64_t v34 = *(void *)(*(void *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v34 >= v9) {
        v34 %= v9;
      }
    }
    else
    {
      v34 &= v9 - 1;
    }
    __int16 v33 = (uint64_t *)(*((void *)&xmmword_1EB4FEC40 + 1) + 8 * v34);
    goto LABEL_78;
  }
LABEL_79:
  v37[0] = 0;
  *(void *)&xmmword_1EB4FEC60 = xmmword_1EB4FEC60 + 1;
  sub_19E0A25D8(v37);
  return i;
}

void sub_19E0A25C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E0A25D8((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E0A25D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v2 = *(void *)(v1 + 40);
      if (v2)
      {
        uint64_t v3 = *(void *)(v1 + 48);
        unint64_t v4 = *(void **)(v1 + 40);
        if (v3 != v2)
        {
          do
          {
            unint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
            if (v5) {
              std::__shared_weak_count::__release_weak(v5);
            }
            v3 -= 16;
          }
          while (v3 != v2);
          unint64_t v4 = *(void **)(v1 + 40);
        }
        *(void *)(v1 + 4++**(_DWORD **)(result + 8) = v2;
        operator delete(v4);
      }
      if (*(char *)(v1 + 39) < 0) {
        operator delete(*(void **)(v1 + 16));
      }
    }
    operator delete((void *)v1);
  }
}

void sub_19E0A2680(uint64_t *a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v2 = *(std::__shared_weak_count **)(v1 + 48);
      if (v2) {
        std::__shared_weak_count::__release_weak(v2);
      }
      if (*(char *)(v1 + 39) < 0) {
        operator delete(*(void **)(v1 + 16));
      }
    }
    operator delete((void *)v1);
  }
}

uint64_t sub_19E0A26EC(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"Locale");
  if (sub_19E0A3160(Value))
  {
    CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NonStemSuffixCount");
    if (v5)
    {
      CFNumberRef v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 == CFNumberGetTypeID())
      {
        CFArrayRef v8 = (const __CFArray *)CFDictionaryGetValue(theDict, @"StemSuffixClasses");
        if (v8)
        {
          CFArrayRef v9 = v8;
          CFTypeID v10 = CFGetTypeID(v8);
          if (v10 == CFArrayGetTypeID())
          {
            int valuePtr = 0;
            CFNumberGetValue(v6, kCFNumberSInt32Type, &valuePtr);
            if (valuePtr >= 1)
            {
              CFLocaleRef v11 = CFLocaleCreate(0, Value);
              sub_19E0782A0((const void **)(a1 + 128), v11);
              *(_DWORD *)a1 = CFArrayGetCount(v9);
              uint64_t v13 = *(char **)(a1 + 16);
              unint64_t v12 = *(void *)(a1 + 24);
              if ((unint64_t)v13 >= v12)
              {
                float v16 = *(char **)(a1 + 8);
                uint64_t v17 = (v13 - v16) >> 2;
                unint64_t v18 = v17 + 1;
                if ((unint64_t)(v17 + 1) >> 62) {
                  sub_19E041BEC();
                }
                uint64_t v19 = v12 - (void)v16;
                if (v19 >> 1 > v18) {
                  unint64_t v18 = v19 >> 1;
                }
                BOOL v20 = (unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL;
                unint64_t v21 = 0x3FFFFFFFFFFFFFFFLL;
                if (!v20) {
                  unint64_t v21 = v18;
                }
                if (v21)
                {
                  unint64_t v21 = (unint64_t)sub_19E068D84(v21);
                  float v16 = *(char **)(a1 + 8);
                  uint64_t v13 = *(char **)(a1 + 16);
                }
                else
                {
                  uint64_t v22 = 0;
                }
                uint64_t v23 = (_DWORD *)(v21 + 4 * v17);
                unint64_t v24 = v21 + 4 * v22;
                *uint64_t v23 = 0;
                unint64_t v14 = v23 + 1;
                while (v13 != v16)
                {
                  int v25 = *((_DWORD *)v13 - 1);
                  v13 -= 4;
                  *--uint64_t v23 = v25;
                }
                *(void *)(a1 + ++**(_DWORD **)(result + 8) = v23;
                *(void *)(a1 + 16) = v14;
                *(void *)(a1 + 24) = v24;
                if (v16) {
                  operator delete(v16);
                }
              }
              else
              {
                *(_DWORD *)uint64_t v13 = 0;
                unint64_t v14 = v13 + 4;
              }
              *(void *)(a1 + 16) = v14;
              uint8x8_t v27 = *(char **)(a1 + 40);
              unint64_t v26 = *(void *)(a1 + 48);
              if ((unint64_t)v27 >= v26)
              {
                uint8x8_t v29 = *(char **)(a1 + 32);
                uint64_t v30 = (v27 - v29) >> 2;
                unint64_t v31 = v30 + 1;
                if ((unint64_t)(v30 + 1) >> 62) {
                  sub_19E041BEC();
                }
                uint64_t v32 = v26 - (void)v29;
                if (v32 >> 1 > v31) {
                  unint64_t v31 = v32 >> 1;
                }
                BOOL v20 = (unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL;
                unint64_t v33 = 0x3FFFFFFFFFFFFFFFLL;
                if (!v20) {
                  unint64_t v33 = v31;
                }
                if (v33)
                {
                  unint64_t v33 = (unint64_t)sub_19E068D84(v33);
                  uint8x8_t v29 = *(char **)(a1 + 32);
                  uint8x8_t v27 = *(char **)(a1 + 40);
                }
                else
                {
                  uint64_t v34 = 0;
                }
                unint64_t v35 = (_DWORD *)(v33 + 4 * v30);
                unint64_t v36 = v33 + 4 * v34;
                *unint64_t v35 = 0;
                unint64_t v28 = v35 + 1;
                while (v27 != v29)
                {
                  int v37 = *((_DWORD *)v27 - 1);
                  v27 -= 4;
                  *--unint64_t v35 = v37;
                }
                *(void *)(a1 + 32) = v35;
                *(void *)(a1 + 4sub_19E060B80(&a9, 0) = v28;
                *(void *)(a1 + 4++**(_DWORD **)(result + 8) = v36;
                if (v29) {
                  operator delete(v29);
                }
              }
              else
              {
                *(_DWORD *)uint8x8_t v27 = 0;
                unint64_t v28 = v27 + 4;
              }
              *(void *)(a1 + 4sub_19E060B80(&a9, 0) = v28;
              uint64_t v39 = *(char **)(a1 + 64);
              unint64_t v38 = *(void *)(a1 + 72);
              if ((unint64_t)v39 >= v38)
              {
                uint64_t v41 = *(char **)(a1 + 56);
                uint64_t v42 = (v39 - v41) >> 2;
                unint64_t v43 = v42 + 1;
                if ((unint64_t)(v42 + 1) >> 62) {
                  sub_19E041BEC();
                }
                uint64_t v44 = v38 - (void)v41;
                if (v44 >> 1 > v43) {
                  unint64_t v43 = v44 >> 1;
                }
                BOOL v20 = (unint64_t)v44 >= 0x7FFFFFFFFFFFFFFCLL;
                unint64_t v45 = 0x3FFFFFFFFFFFFFFFLL;
                if (!v20) {
                  unint64_t v45 = v43;
                }
                if (v45)
                {
                  unint64_t v45 = (unint64_t)sub_19E068D84(v45);
                  uint64_t v41 = *(char **)(a1 + 56);
                  uint64_t v39 = *(char **)(a1 + 64);
                }
                else
                {
                  uint64_t v46 = 0;
                }
                char v47 = (_DWORD *)(v45 + 4 * v42);
                unint64_t v48 = v45 + 4 * v46;
                *char v47 = 0;
                uint64_t v40 = v47 + 1;
                while (v39 != v41)
                {
                  int v49 = *((_DWORD *)v39 - 1);
                  v39 -= 4;
                  *--char v47 = v49;
                }
                *(void *)(a1 + 56) = v47;
                *(void *)(a1 + 64) = v40;
                *(void *)(a1 + 72) = v48;
                if (v41) {
                  operator delete(v41);
                }
              }
              else
              {
                *(_DWORD *)uint64_t v39 = 0;
                uint64_t v40 = v39 + 4;
              }
              *(void *)(a1 + 64) = v40;
              sub_19E039E88(Value, __p);
              if (v53 >= 0) {
                uint64_t v50 = (char *)__p;
              }
              else {
                uint64_t v50 = (char *)__p[0];
              }
              sub_19E03A61C((int)&v51, v50);
            }
          }
        }
      }
    }
  }
  return 0;
}

void sub_19E0A309C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unsigned __int16 a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  if (a15 >= 0xFu && a16) {
    MEMORY[0x19F3BA6E0](a16, 0x1000C8077774924);
  }
  uint64_t v34 = *(void **)(v32 - 120);
  if (v34 && *(unsigned char *)(v32 - 122) == 1) {
    free(v34);
  }
  if (a19) {
    sub_19E0616BC(a19);
  }
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFStringRef sub_19E0A3160(const __CFString *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFStringGetTypeID()) {
      return (const __CFString *)(CFStringGetLength(v1) > 0);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t sub_19E0A31B4(void *a1, unsigned __int16 *a2)
{
  unint64_t v4 = a1 + 2;
  unint64_t v5 = a1[2];
  unint64_t v6 = a1[1];
  if (v6 >= v5)
  {
    uint64_t v9 = (uint64_t)(v6 - *a1) >> 5;
    if ((unint64_t)(v9 + 1) >> 59) {
      sub_19E041BEC();
    }
    uint64_t v10 = v5 - *a1;
    uint64_t v11 = v10 >> 4;
    if (v10 >> 4 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v23 = v4;
    if (v12) {
      unint64_t v12 = (unint64_t)sub_19E08A810(v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v21 = v12;
    *(void *)uint64_t v22 = v12 + 32 * v9;
    *(void *)&v22[16] = v12 + 32 * v13;
    sub_19E039858(*(uint64_t *)v22, a2);
    uint64_t v14 = 0;
    *(void *)&v22[8] = *(void *)v22 + 32;
    uint64_t v16 = *a1;
    for (uint64_t i = a1[1]; i + v14 != v16; sub_19E039858(*(void *)v22 + v14, (unsigned __int16 *)(v14 + i)))
      v14 -= 32;
    uint64_t v17 = a1[2];
    long long v18 = *(_OWORD *)&v22[8];
    unint64_t v20 = *(void *)&v22[8];
    long long v19 = *(_OWORD *)a1;
    *a1 = *(void *)v22 + v14;
    *(_OWORD *)uint64_t v22 = v19;
    *(_OWORD *)(a1 + 1) = v18;
    *(void *)&v22[16] = v17;
    unint64_t v21 = v19;
    uint64_t result = sub_19E0A3448((uint64_t)&v21);
    unint64_t v8 = v20;
  }
  else
  {
    uint64_t result = sub_19E039858(a1[1], a2);
    unint64_t v8 = v6 + 32;
    a1[1] = v6 + 32;
  }
  a1[1] = v8;
  return result;
}

void sub_19E0A32FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E0A3448((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0A3354(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 16;
      *(void *)(a1 + 16) = v2 - 16;
      if (*(unsigned __int16 *)(v2 - 16) >= 0xFu)
      {
        uint64_t v5 = *(void *)(v2 - 8);
        if (v5)
        {
          MEMORY[0x19F3BA6E0](v5, 0x1000C8077774924);
          uint64_t v4 = *(void *)(a1 + 16);
        }
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E0A33D0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = *(unsigned __int16 **)(*(void *)(a1 + 16) + 8);
    uint64_t v4 = *(unsigned __int16 **)(*(void *)(a1 + 8) + 8);
    while (v3 != v4)
    {
      if (*v3 >= 0xFu)
      {
        uint64_t v5 = *((void *)v3 + 1);
        if (v5) {
          MEMORY[0x19F3BA6E0](v5, 0x1000C8077774924);
        }
      }
      v3 += 8;
    }
  }
  return a1;
}

uint64_t sub_19E0A3448(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 32;
      *(void *)(a1 + 16) = v2 - 32;
      uint64_t v5 = *(void **)(v2 - 24);
      if (v5 && *(unsigned char *)(v2 - 26) == 1)
      {
        free(v5);
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_19E0A34B4(void *a1, long long *a2)
{
  *a1 = &unk_1EF09B9C8;
  uint64_t v3 = a1 + 1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_19E03FA9C(v3, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    v3[2] = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }
  return a1;
}

void sub_19E0A351C(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E0A3530(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF09B9C8;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }

  std::exception::~exception(this);
}

uint64_t sub_19E0A3590(uint64_t a1)
{
  uint64_t result = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

void sub_19E0A35AC(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1EF09B9C8;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::exception::~exception(this);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E0A3620(unsigned int *a1, unsigned int a2, _DWORD *a3, _DWORD *a4)
{
  long long v4 = (char *)*((void *)a1 + 1);
  if (*(_DWORD *)v4 > a2 || *(_DWORD *)&v4[4 * *a1] <= a2) {
    return 0;
  }
  uint64_t v5 = *((void *)a1 + 2) - (void)v4;
  if (v5)
  {
    unint64_t v6 = v5 >> 2;
    CFTypeID v7 = (_DWORD *)*((void *)a1 + 1);
    do
    {
      unint64_t v8 = v6 >> 1;
      uint64_t v9 = &v7[v6 >> 1];
      unsigned int v11 = *v9;
      uint64_t v10 = v9 + 1;
      v6 += ~(v6 >> 1);
      if (v11 > a2) {
        unint64_t v6 = v8;
      }
      else {
        CFTypeID v7 = v10;
      }
    }
    while (v6);
  }
  else
  {
    CFTypeID v7 = (_DWORD *)*((void *)a1 + 1);
  }
  uint64_t v13 = (char *)(v7 - 1);
  if (a3) {
    *a3 = a1[1] + ((unint64_t)(v13 - v4) >> 2);
  }
  if (a4) {
    *a4 = a2 - *(_DWORD *)v13;
  }
  return 1;
}

uint64_t sub_19E0A36C0(unsigned int *a1, unsigned int a2, _DWORD *a3, _DWORD *a4)
{
  long long v4 = (char *)*((void *)a1 + 4);
  if (*(_DWORD *)v4 > a2 || *(_DWORD *)&v4[4 * *a1] <= a2) {
    return 0;
  }
  uint64_t v5 = *((void *)a1 + 5) - (void)v4;
  if (v5)
  {
    unint64_t v6 = v5 >> 2;
    CFTypeID v7 = (_DWORD *)*((void *)a1 + 4);
    do
    {
      unint64_t v8 = v6 >> 1;
      uint64_t v9 = &v7[v6 >> 1];
      unsigned int v11 = *v9;
      uint64_t v10 = v9 + 1;
      v6 += ~(v6 >> 1);
      if (v11 > a2) {
        unint64_t v6 = v8;
      }
      else {
        CFTypeID v7 = v10;
      }
    }
    while (v6);
  }
  else
  {
    CFTypeID v7 = (_DWORD *)*((void *)a1 + 4);
  }
  uint64_t v13 = (char *)(v7 - 1);
  if (a3) {
    *a3 = a1[1] + ((unint64_t)(v13 - v4) >> 2);
  }
  if (a4) {
    *a4 = a2 - *(_DWORD *)v13;
  }
  return 1;
}

uint64_t sub_19E0A3760(uint64_t result, uint64_t a2, int a3)
{
  unint64_t v3 = (a3 - *(_DWORD *)(a2 + 4));
  uint64_t v4 = *(void *)(a2 + 80);
  if (v3 < (*(void *)(a2 + 88) - v4) >> 5) {
    return sub_19E039858(result, (unsigned __int16 *)(v4 + 32 * v3));
  }
  *(_DWORD *)uint64_t result = 0x100000;
  *(_WORD *)(result + 4) = 0;
  *(unsigned char *)(result + 6) = 0;
  *(void *)(result + ++**(_DWORD **)(result + 8) = 0;
  *(unsigned char *)(result + 16) = 0;
  return result;
}

__n128 sub_19E0A379C(__n128 *a1, uint64_t a2, int a3)
{
  unint64_t v3 = (a3 - *(_DWORD *)(a2 + 4));
  uint64_t v4 = *(void *)(a2 + 104);
  if (v3 >= (*(void *)(a2 + 112) - v4) >> 4)
  {
    a1->n128_u16[0] = 0;
  }
  else
  {
    uint64_t v5 = (__n128 *)(v4 + 16 * v3);
    unint64_t v6 = v5->n128_u16[0];
    if (v6 >= 0xF)
    {
      a1->n128_u16[0] = v6;
      operator new[]();
    }
    __n128 result = *v5;
    *a1 = *v5;
  }
  return result;
}

uint64_t sub_19E0A3844(uint64_t a1, const void **a2, CFErrorRef err)
{
  uint64_t v21[2] = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1EF09B9C8;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  uint64_t v5 = (void **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  CFStringRef v6 = CFErrorCopyDescription(err);
  CFStringRef v20 = v6;
  if (*((char *)a2 + 23) >= 0) {
    size_t v7 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v7 = (size_t)a2[1];
  }
  unint64_t v8 = &v19;
  sub_19E0A3A9C((uint64_t)&v19, v7 + 2);
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    unint64_t v8 = (std::string *)v19.__r_.__value_.__r.__words[0];
  }
  if (v7)
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *a2;
    }
    memmove(v8, v9, v7);
  }
  strcpy((char *)v8 + v7, ": ");
  sub_19E039E88(v6, __p);
  if ((v18 & 0x80u) == 0) {
    uint64_t v10 = __p;
  }
  else {
    uint64_t v10 = (void **)__p[0];
  }
  if ((v18 & 0x80u) == 0) {
    std::string::size_type v11 = v18;
  }
  else {
    std::string::size_type v11 = (std::string::size_type)__p[1];
  }
  unint64_t v12 = std::string::append(&v19, (const std::string::value_type *)v10, v11);
  std::string::size_type v13 = v12->__r_.__value_.__r.__words[0];
  v21[0] = v12->__r_.__value_.__l.__size_;
  *(void *)((char *)v21 + 7) = *(std::string::size_type *)((char *)&v12->__r_.__value_.__r.__words[1] + 7);
  char v14 = HIBYTE(v12->__r_.__value_.__r.__words[2]);
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*v5);
  }
  uint64_t v15 = v21[0];
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = v13;
  *(void *)(a1 + 16) = v15;
  *(void *)(a1 + 23) = *(void *)((char *)v21 + 7);
  *(unsigned char *)(a1 + 31) = v14;
  if ((char)v18 < 0) {
    operator delete(__p[0]);
  }
  if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v6) {
      return a1;
    }
    goto LABEL_25;
  }
  operator delete(v19.__r_.__value_.__l.__data_);
  if (v6) {
LABEL_25:
  }
    CFRelease(v6);
  return a1;
}

void sub_19E0A39F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a2) {
    sub_19E04137C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E0A3A68(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
}

uint64_t sub_19E0A3A9C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E04147C();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    CFStringRef v6 = operator new(v4 + 1);
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    *(unsigned char *)(a1 + 23) = a2;
  }
  return a1;
}

void sub_19E0A3B24(void *a1)
{
  sub_19E0A3B5C(a1);

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0A3B5C(void *a1)
{
  *a1 = &unk_1EF0986C0;
  if (a1[1]) {
    uspoof_close();
  }
  return a1;
}

void sub_19E0A3BB0(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 8))
  {
    int v8 = 0;
    int SkeletonUTF8 = uspoof_getSkeletonUTF8();
    sub_19E041A24(&__p, SkeletonUTF8 + 1, 32);
    int v8 = 0;
    uspoof_getSkeletonUTF8();
    if (v8)
    {
      sub_19E0413C8(&v6, "");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      std::string::resize(&__p, SkeletonUTF8, 0);
      std::string v6 = __p;
    }
  }
  else
  {
    sub_19E0413C8(&v6, "");
  }
  if ((v6.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v4 = &v6;
  }
  else {
    uint64_t v4 = (std::string *)v6.__r_.__value_.__r.__words[0];
  }
  unsigned __int16 v5 = HIBYTE(v6.__r_.__value_.__r.__words[2]);
  if ((v6.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    unsigned __int16 v5 = v6.__r_.__value_.__r.__words[1];
  }
  sub_19E0B13C0(a1, (char *)v4, v5);
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
}

void sub_19E0A3D18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0A3D48(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  sub_19E03F0BC((uint64_t)v10, a2);
  sub_19E03F0BC((uint64_t)v8, a3);
  int v5 = (*(uint64_t (**)(uint64_t, unsigned char *, unsigned char *))(*(void *)a1 + 24))(a1, v10, v8);
  if (v9 && v8[6] == 1) {
    free(v9);
  }
  if (v11 && v10[6] == 1) {
    free(v11);
  }
  uint64_t v6 = -1;
  if (v5 >= 0) {
    uint64_t v6 = 1;
  }
  if (v5) {
    return v6;
  }
  else {
    return 0;
  }
}

void sub_19E0A3E28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, void *a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, void *a19)
{
  if (a13 && a12 == 1) {
    free(a13);
  }
  if (a19)
  {
    if (a18 == 1) {
      free(a19);
    }
  }
  _Unwind_Resume(exception_object);
}

CFStringRef sub_19E0A3E74(const __CFDictionary *a1, const __CFLocale *a2)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"type");
  if (Value)
  {
    CFStringRef Copy = 0;
    if (CFStringCompare(Value, @"morphemes", 0)) {
      return Copy;
    }
  }
  CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(a1, @"dataFile");
  if (v6)
  {
    CFStringRef Copy = v6;
    CFStringRef v7 = 0;
  }
  else
  {
    CFStringRef v7 = sub_19E0F4D8C(a1, a2);
    CFStringRef Copy = v7;
    if (!v7) {
      return Copy;
    }
  }
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFURLRef v9 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Copy, kCFURLPOSIXPathStyle, 0);
  CFURLRef v10 = v9;
  if (!v9)
  {
    CFStringRef Copy = 0;
    if (!v7) {
      return Copy;
    }
LABEL_18:
    CFRelease(v7);
    return Copy;
  }
  if (!CFURLResourceIsReachable(v9, 0)) {
    goto LABEL_14;
  }
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(v8, v10);
  CFURLRef v12 = CFURLCreateCopyAppendingPathComponent(v8, PathComponent, @"transition_trie.dat", 0);
  int IsReachable = CFURLResourceIsReachable(v12, 0);
  if (v12) {
    CFRelease(v12);
  }
  if (PathComponent) {
    CFRelease(PathComponent);
  }
  if (IsReachable) {
    CFStringRef Copy = CFStringCreateCopy(v8, Copy);
  }
  else {
LABEL_14:
  }
    CFStringRef Copy = 0;
  CFRelease(v10);
  if (v7) {
    goto LABEL_18;
  }
  return Copy;
}

void sub_19E0A3FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, const void *a11, const void *a12)
{
}

uint64_t sub_19E0A405C(const __CFDictionary *a1, const __CFLocale *a2)
{
  _OWORD v19[4] = *MEMORY[0x1E4F143B8];
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"dataFile");
  if (!Value)
  {
    CFStringRef v12 = (const __CFString *)CFLocaleGetValue(a2, (CFLocaleKey)*MEMORY[0x1E4F1D220]);
    CFStringRef v13 = v12;
    CFLocaleRef cf = 0;
    if (a2)
    {
      CFRetain(a2);
      CFLocaleRef cf = a2;
      CFLocaleRef v14 = a2;
      if (!v13)
      {
LABEL_17:
        v19[0] = &unk_1EF0989C8;
        void v19[3] = v19;
        uint64_t Copy = sub_19E0F4688(a1, v14);
        sub_19E0F4820(v19);
        if (cf) {
          CFRelease(cf);
        }
        return Copy;
      }
    }
    else
    {
      CFLocaleRef v14 = 0;
      if (!v12) {
        goto LABEL_17;
      }
    }
    if (CFEqual(v13, @"Latn"))
    {
      CFStringRef v15 = (const __CFString *)CFLocaleGetValue(a2, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
      CFLocaleRef v16 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v15);
      if (v14) {
        CFRelease(v14);
      }
      CFLocaleRef cf = v16;
      CFLocaleRef v14 = v16;
    }
    goto LABEL_17;
  }
  CFStringRef v5 = Value;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFURLRef v7 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Value, kCFURLPOSIXPathStyle, 0);
  v19[0] = v7;
  if (v7)
  {
    CFURLRef v8 = v7;
    CFStringRef PathComponent = CFURLCopyLastPathComponent(v7);
    CFStringRef v10 = (const __CFString *)CFDictionaryGetValue(a1, @"type");
    if (v10 && CFEqual(v10, @"unified_transliteration")
      || CFStringHasPrefix(PathComponent, @"UnifiedTransliteration"))
    {
      uint64_t Copy = (uint64_t)CFStringCreateCopy(v6, v5);
      if (!PathComponent) {
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t Copy = 0;
      if (!PathComponent)
      {
LABEL_21:
        CFRelease(v8);
        return Copy;
      }
    }
    CFRelease(PathComponent);
    goto LABEL_21;
  }
  return 0;
}

void sub_19E0A4270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_19E04137C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

double sub_19E0A42E4(int a1, int a2)
{
  if (a1 < 0 || a1 > a2) {
    __assert_rtn("safe_probability", "LXUtils.cpp", 192, "0 <= numerator && numerator <= denominator && \"invalid probability calculation\"");
  }
  if (!a1) {
    return 0.0;
  }
  if (a2) {
    return (double)a1 / (double)a2;
  }
  return 1.0;
}

CFErrorRef sub_19E0A4344(const void *a1)
{
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F1D170], a1);
  CFErrorRef v3 = CFErrorCreate(0, @"com.apple.Lexicon.ErrorDomain", 0, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v3;
}

void sub_19E0A43D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E041344((const void **)va, 0);
  _Unwind_Resume(a1);
}

void sub_19E0A43EC(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  CFStringRef v5 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  uint64_t v6 = LXCursorCreateByAdvancing((uint64_t)v5, a2);
  CFURLRef v7 = (const void *)v6;
  if (v6)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 + 16) + 48))(v6 + 16, a3);
    CFRelease(v7);
  }
  if (v5) {
    CFRelease(v5);
  }
}

void sub_19E0A44A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_19E0A44D4()
{
}

void sub_19E0A4500()
{
}

void sub_19E0A452C()
{
}

void sub_19E0A4558()
{
}

void sub_19E0A4584()
{
}

void sub_19E0A45B0()
{
}

void sub_19E0A45DC()
{
}

void sub_19E0A4608()
{
}

void sub_19E0A4634()
{
}

unint64_t sub_19E0A4660(unint64_t a1)
{
  unint64_t v1 = 0x9DDFEA08EB382D69 * (((8 * a1) + 8) ^ HIDWORD(a1));
  unint64_t v2 = 0x9DDFEA08EB382D69 * (HIDWORD(a1) ^ (v1 >> 47) ^ v1);
  return 0x9DDFEA08EB382D69 * (v2 ^ (v2 >> 47));
}

uint64_t sub_19E0A469C(uint64_t a1, char *a2, unsigned __int16 a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  sub_19E0B13C0((uint64_t)v12, a2, a3);
  sub_19E03F97C((uint64_t)&v7, a1 + 8);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v7 + 8))(&v9);
  if (v8) {
    sub_19E0616BC(v8);
  }
  uint64_t v4 = sub_19E07EFB0(v12, (unsigned __int8 *)&v9, a1 + 8, a1 + 8, *(unsigned int **)(a1 + 30128));
  if (!v4)
  {
    uint64_t v5 = *(unsigned int *)(a1 + 28720);
    if (v5 == -1) {
      sub_19E07D5D0();
    }
    CFURLRef v7 = &v11;
    if (((unsigned int (*)(char **, uint64_t))off_1EF09D600[v5])(&v7, a1 + 14368)) {
      uint64_t v4 = sub_19E07EFB0(v12, (unsigned __int8 *)&v9, a1 + 8, a1 + 14368, *(unsigned int **)(a1 + 30128));
    }
    else {
      uint64_t v4 = 0;
    }
  }
  if ((unsigned __int16)v9 >= 0xFu && v10) {
    MEMORY[0x19F3BA6E0](v10, 0x1000C8077774924);
  }
  if (v14 && v13 == 1) {
    free(v14);
  }
  return v4;
}

void sub_19E0A4818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, __int16 a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, void *a17)
{
  if (a10) {
    sub_19E0616BC(a10);
  }
  if (a17) {
    BOOL v18 = a16 == 1;
  }
  else {
    BOOL v18 = 0;
  }
  if (v18) {
    free(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0A4888(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  sub_19E03F97C((uint64_t)&v7, a1 + 8);
  uint64_t v5 = sub_19E0A3D48(v7, a2, a3);
  if (v8) {
    sub_19E0616BC(v8);
  }
  return v5;
}

void sub_19E0A48E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_19E0616BC(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E0A48FC(uint64_t a1, uint64_t a2)
{
  sub_19E0D36C4((unsigned __int16 *)&v8, a1 + 28752);
  CFErrorRef v3 = v8;
  if (v8 != v9)
  {
    do
    {
      if (*((unsigned __int16 *)v3 + 20) < 0xFu) {
        uint64_t v4 = (char *)v3 + 42;
      }
      else {
        uint64_t v4 = (char *)v3[6];
      }
      (*(void (**)(uint64_t, void, char *))(a2 + 16))(a2, *((unsigned int *)v3 + 8), v4);
      uint64_t v5 = v3[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = (void **)v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void **)v3[2];
          BOOL v7 = *v6 == v3;
          CFErrorRef v3 = v6;
        }
        while (!v7);
      }
      CFErrorRef v3 = v6;
    }
    while (v6 != v9);
  }
  sub_19E08DAEC(v9[0]);
}

void sub_19E0A49BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
}

uint64_t sub_19E0A49D0(uint64_t a1)
{
  if (qword_1EB4FEE18 != -1) {
    dispatch_once(&qword_1EB4FEE18, &unk_1EF098E28);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 16) = &unk_1EF09B808;
  *(void *)(Instance + 24) = a1;
  sub_19E0E5740(Instance + 32, a1 + 8);
  *(_DWORD *)(Instance + 136) = 0x100000;
  *(_WORD *)(Instance + 14sub_19E062044(&a9, 0) = 0;
  *(unsigned char *)(Instance + 142) = 0;
  *(void *)(Instance + 144) = 0;
  *(unsigned char *)(Instance + 152) = 0;
  *(_OWORD *)(Instance + 16++**(_DWORD **)(result + 8) = 0u;
  *(_OWORD *)(Instance + 184) = 0u;
  *(_OWORD *)(Instance + 20sub_19E062044(&a9, 0) = 0u;
  *(_OWORD *)(Instance + 216) = 0u;
  return Instance;
}

uint64_t sub_19E0A4A9C()
{
  qword_1EB4FEE20 = 0;
  *(void *)algn_1EB4FEE28 = "LXCursor";
  qword_1EB4FEE30 = 0;
  unk_1EB4FEE38 = 0;
  qword_1EB4FEE40 = (uint64_t)sub_19E087C70;
  *(_OWORD *)algn_1EB4FEE48 = 0u;
  *(_OWORD *)&algn_1EB4FEE48[16] = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB4FEE80 = result;
  return result;
}

CFStringRef sub_19E0A4AF0(uint64_t a1)
{
  sub_19E0413C8(&v8, "Static-");
  if (*(void *)(a1 + 30144)) {
    unint64_t v2 = *(const char **)(a1 + 30144);
  }
  else {
    unint64_t v2 = (const char *)(a1 + 30152);
  }
  std::string::size_type v3 = strlen(v2);
  uint64_t v4 = std::string::append(&v8, v2, v3);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  std::string::size_type v10 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v8.__r_.__value_.__l.__data_);
  }
  CFStringRef v6 = sub_19E040B4C((uint64_t)__p);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  return v6;
}

void sub_19E0A4B9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0A4BCC(uint64_t a1, unsigned int a2)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a1 + 8;
  if (sub_19E07D808(a1 + 8))
  {
    LODWORD(v45) = a2;
    uint64_t v5 = *(unsigned int *)(a1 + 28720);
    if (v5 == -1) {
      sub_19E07D5D0();
    }
    char v47 = &v45;
    ((void (*)(uint64_t *__return_ptr, int ****, uint64_t))off_1EF09D2C0[v5])(&v53, &v47, a1 + 14368);
    if ((_WORD)v53) {
      goto LABEL_9;
    }
    LODWORD(v3++**(_DWORD **)(result + 8) = a2;
    uint64_t v6 = *(unsigned int *)(a1 + 14360);
    if (v6 == -1) {
      sub_19E07D5D0();
    }
    unint64_t v45 = &v38;
    ((void (*)(int ****__return_ptr, int ***, uint64_t))off_1EF09D2C0[v6])(&v47, &v45, v4);
    sub_19E03CED8((uint64_t)&v53, (unsigned __int16 *)&v47);
    long long v55 = v49;
    long long v56 = v50;
    long long v57 = v51;
    __int16 v58 = v52;
    if (v48 && BYTE6(v47) == 1) {
      free(v48);
    }
    if ((_WORD)v53)
    {
LABEL_9:
      LODWORD(v39[0]) = 0x100000;
      WORD2(v39[0]) = 0;
      BYTE6(v39[0]) = 0;
      v39[1] = 0;
      sub_19E03CED8((uint64_t)v39, (unsigned __int16 *)&v53);
      long long v41 = v55;
      long long v42 = v56;
      long long v43 = v57;
      LOWORD(v44) = v58;
    }
    else
    {
      char v13 = *(unsigned int **)(a1 + 30128);
      if (v13 && (CFLocaleRef v14 = (unsigned int *)*((void *)v13 + 7), *v14 <= a2) && v14[*v13] > a2)
      {
        uint64_t v15 = *((void *)v13 + 8) - (void)v14;
        if (v15)
        {
          unint64_t v16 = v15 >> 2;
          uint64_t v17 = (_DWORD *)*((void *)v13 + 7);
          do
          {
            unint64_t v18 = v16 >> 1;
            std::string v19 = &v17[v16 >> 1];
            unsigned int v21 = *v19;
            CFStringRef v20 = v19 + 1;
            v16 += ~(v16 >> 1);
            if (v21 > a2) {
              unint64_t v16 = v18;
            }
            else {
              uint64_t v17 = v20;
            }
          }
          while (v16);
        }
        else
        {
          uint64_t v17 = (_DWORD *)*((void *)v13 + 7);
        }
        int v35 = *(v17 - 1);
        unint64_t v22 = (char *)(v17 - 1) - (char *)v14;
        unint64_t v23 = v22 >> 2;
        uint64_t v24 = *((void *)v13 + 4);
        int v25 = *(_DWORD *)(v24 + 4 * ((v22 >> 2) + 1));
        v22 &= 0x3FFFFFFFCuLL;
        int v26 = *(_DWORD *)(v24 + v22);
        int v27 = *(_DWORD *)(*((void *)v13 + 1) + v22);
        sub_19E0A3760((uint64_t)&v45, (uint64_t)v13, v13[1] + v23);
        unsigned int v28 = a2 - v35;
        int v34 = v26;
        int v36 = v25 - v26;
        unsigned int v33 = v28;
        unsigned int v29 = v28 / (v25 - v26);
        int v37 = v29 + v27;
        uint64_t v30 = *(unsigned int *)(a1 + 28720);
        if (v30 == -1) {
          sub_19E07D5D0();
        }
        unint64_t v38 = &v37;
        ((void (*)(int ****__return_ptr, int **, uint64_t))off_1EF09D2C0[v30])(&v47, &v38, a1 + 14368);
        sub_19E03CED8((uint64_t)&v53, (unsigned __int16 *)&v47);
        long long v55 = v49;
        long long v56 = v50;
        long long v57 = v51;
        __int16 v58 = v52;
        if (v48 && BYTE6(v47) == 1) {
          free(v48);
        }
        if ((_WORD)v53) {
          goto LABEL_45;
        }
        int v37 = v29 + v27;
        uint64_t v31 = *(unsigned int *)(a1 + 14360);
        if (v31 == -1) {
          sub_19E07D5D0();
        }
        unint64_t v38 = &v37;
        ((void (*)(int ****__return_ptr, int **, uint64_t))off_1EF09D2C0[v31])(&v47, &v38, v4);
        sub_19E03CED8((uint64_t)&v53, (unsigned __int16 *)&v47);
        long long v55 = v49;
        long long v56 = v50;
        long long v57 = v51;
        __int16 v58 = v52;
        if (v48 && BYTE6(v47) == 1) {
          free(v48);
        }
        if ((_WORD)v53)
        {
LABEL_45:
          int v37 = v33 - v29 * v36 + v34;
          uint64_t v32 = *(unsigned int *)(a1 + 14360);
          if (v32 == -1) {
            sub_19E07D5D0();
          }
          unint64_t v38 = &v37;
          ((void (*)(int ****__return_ptr, int **, uint64_t))off_1EF09D2C0[v32])(&v47, &v38, v4);
          if ((unsigned __int16)v47 >= (unsigned __int16)v45) {
            sub_19E08E5F8((uint64_t)&v53, (float *)&v47, (unsigned __int16)v45, a2);
          }
          LODWORD(v39[0]) = 0x100000;
          WORD2(v39[0]) = 0;
          BYTE6(v39[0]) = 0;
          v39[1] = 0;
          sub_19E03CED8((uint64_t)v39, (unsigned __int16 *)&v53);
          long long v41 = v55;
          long long v42 = v56;
          long long v43 = v57;
          LOWORD(v44) = v58;
          if (v48 && BYTE6(v47) == 1) {
            free(v48);
          }
        }
        else
        {
          *(_OWORD *)uint64_t v39 = 0u;
          long long v40 = 0u;
          HIDWORD(v41) = 0;
          uint64_t v44 = 0;
          WORD1(v39[0]) = 16;
          BYTE6(v39[0]) = 0;
          *(void *)&long long v41 = 0;
          *(void *)((char *)&v41 + 5) = 0;
          long long v42 = 0uLL;
          long long v43 = 0xFFFFFFFFuLL;
        }
        if (v46 && BYTE6(v45) == 1) {
          free(v46);
        }
      }
      else
      {
        *(_OWORD *)uint64_t v39 = 0u;
        long long v40 = 0u;
        HIDWORD(v41) = 0;
        uint64_t v44 = 0;
        WORD1(v39[0]) = 16;
        BYTE6(v39[0]) = 0;
        *(void *)&long long v41 = 0;
        *(void *)((char *)&v41 + 5) = 0;
        long long v42 = 0uLL;
        long long v43 = 0xFFFFFFFFuLL;
      }
    }
    if (v54 && BYTE6(v53) == 1) {
      free(v54);
    }
    if (LOWORD(v39[0]))
    {
      float v7 = log10f(*(float *)&v41);
      if (qword_1EB4FED88 != -1) {
        dispatch_once(&qword_1EB4FED88, &unk_1EF098E08);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      sub_19E039858(Instance + 16, (unsigned __int16 *)v39);
      __int16 v9 = v44;
      long long v11 = v42;
      long long v10 = v43;
      *(_OWORD *)(Instance + 4++**(_DWORD **)(result + 8) = v41;
      *(_OWORD *)(Instance + 64) = v11;
      *(_OWORD *)(Instance + 8sub_19E062044(&a9, 0) = v10;
      *(_WORD *)(Instance + 96) = v9;
      *(double *)(Instance + 104) = v7;
      *(void *)(Instance + 112) = 0;
      *(_DWORD *)(Instance + 12sub_19E062044(&a9, 0) = 0;
    }
    else
    {
      uint64_t Instance = 0;
    }
  }
  else
  {
    uint64_t Instance = 0;
    *(_OWORD *)uint64_t v39 = 0u;
    long long v40 = 0u;
    WORD1(v39[0]) = 16;
    HIDWORD(v41) = 0;
    uint64_t v44 = 0;
    BYTE6(v39[0]) = 0;
    *(void *)&long long v41 = 0;
    *(void *)((char *)&v41 + 5) = 0;
    long long v42 = 0uLL;
    long long v43 = 0xFFFFFFFFuLL;
  }
  if (v39[1] && BYTE6(v39[0]) == 1) {
    free(v39[1]);
  }
  return Instance;
}

void sub_19E0A51A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,void *a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34)
{
  int v37 = *(void **)(v34 + 8);
  if (v37 && a34 == 1) {
    free(v37);
  }
  if (a29 && a28 == 1) {
    free(a29);
  }
  unint64_t v38 = *(void **)(v34 + 96);
  if (v38)
  {
    if (*(unsigned char *)(v35 - 202) == 1) {
      free(v38);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0A5234()
{
  qword_1EB4FED90 = 0;
  *(void *)algn_1EB4FED98 = "LXEntry";
  qword_1EB4FEDA0 = 0;
  unk_1EB4FEDA8 = 0;
  qword_1EB4FEDB0 = (uint64_t)sub_19E088418;
  unk_1EB4FEDB8 = 0u;
  unk_1EB4FEDC8 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB4FEDF0 = result;
  return result;
}

uint64_t sub_19E0A5288(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 14360);
  if (v1 == -1
    || (uint64_t v6 = &v5,
        ((void (*)(char **, uint64_t))off_1EF09D870[v1])(&v6, a1 + 8),
        uint64_t v3 = *(unsigned int *)(a1 + 28720),
        v3 == -1))
  {
    sub_19E07D5D0();
  }
  uint64_t v6 = &v5;
  return ((uint64_t (*)(char **, uint64_t))off_1EF09D870[v3])(&v6, a1 + 14368);
}

void sub_19E0A5310()
{
}

uint64_t sub_19E0A5340(unsigned __int16 *a1, CFErrorRef *a2)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  int v19 = 0x100000;
  __int16 v20 = 0;
  char v21 = 0;
  unint64_t v22 = 0;
  char v23 = 0;
  int v24 = 0x100000;
  __int16 v25 = 0;
  char v26 = 0;
  int v27 = 0;
  char v28 = 0;
  int v29 = 0x100000;
  __int16 v30 = 0;
  char v31 = 0;
  uint64_t v32 = 0;
  char v33 = 0;
  int v34 = 0x100000;
  __int16 v35 = 0;
  char v36 = 0;
  int v37 = 0;
  char v38 = 0;
  int v39 = 0x100000;
  __int16 v40 = 0;
  char v41 = 0;
  long long v42 = 0;
  char v43 = 0;
  int v44 = 0x100000;
  __int16 v45 = 0;
  char v46 = 0;
  char v47 = 0;
  char v48 = 0;
  sub_19E03CD54((uint64_t)&v19, a1 + 15068);
  sub_19E03CD54((uint64_t)&v24, a1 + 15084);
  sub_19E03CD54((uint64_t)&v29, a1 + 15100);
  sub_19E03CD54((uint64_t)&v44, a1 + 15116);
  int v49 = 1065353216;
  sub_19E039744((uint64_t)&v7, (uint64_t)&v19);
  uint64_t v4 = sub_19E038DD8((uint64_t)(a1 + 4), &v7);
  if (v18 && v17 == 1) {
    free(v18);
  }
  if (v16 && v15 == 1) {
    free(v16);
  }
  if (v14 && v13 == 1) {
    free(v14);
  }
  if (v12 && v11 == 1) {
    free(v12);
  }
  if (v10 && v9 == 1) {
    free(v10);
  }
  if (v8 && BYTE6(v7) == 1) {
    free(v8);
  }
  if (a2) {
    char v5 = v4;
  }
  else {
    char v5 = 1;
  }
  if ((v5 & 1) == 0) {
    *a2 = sub_19E0A4344(@"Failed to load the immutable lexicon");
  }
  if (v47 && v46 == 1) {
    free(v47);
  }
  if (v42 && v41 == 1) {
    free(v42);
  }
  if (v37 && v36 == 1) {
    free(v37);
  }
  if (v32 && v31 == 1) {
    free(v32);
  }
  if (v27 && v26 == 1) {
    free(v27);
  }
  if (v22 && v21 == 1) {
    free(v22);
  }
  return v4;
}

void sub_19E0A55C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

uint64_t sub_19E0A55EC(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 168);
  if (v2 && *(unsigned char *)(a1 + 166) == 1) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 136);
  if (v3 && *(unsigned char *)(a1 + 134) == 1) {
    free(v3);
  }
  uint64_t v4 = *(void **)(a1 + 104);
  if (v4 && *(unsigned char *)(a1 + 102) == 1) {
    free(v4);
  }
  char v5 = *(void **)(a1 + 72);
  if (v5 && *(unsigned char *)(a1 + 70) == 1) {
    free(v5);
  }
  uint64_t v6 = *(void **)(a1 + 40);
  if (v6 && *(unsigned char *)(a1 + 38) == 1) {
    free(v6);
  }
  uint64_t v7 = *(void **)(a1 + 8);
  if (v7 && *(unsigned char *)(a1 + 6) == 1) {
    free(v7);
  }
  return a1;
}

void sub_19E0A56A0(void *a1)
{
  unint64_t v2 = (char *)a1 + 30142;
  *a1 = &unk_1EF09B8A8;
  uint64_t v3 = (void *)a1[3780];
  if (v3 && v2[96] == 1) {
    free(v3);
  }
  uint64_t v4 = (void *)a1[3776];
  if (v4 && v2[64] == 1) {
    free(v4);
  }
  char v5 = (void *)a1[3772];
  if (v5 && v2[32] == 1) {
    free(v5);
  }
  uint64_t v6 = (void *)a1[3768];
  if (v6 && *v2 == 1) {
    free(v6);
  }
  sub_19E07D688((uint64_t)(a1 + 1));

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0A5770(void *a1)
{
  unint64_t v2 = (char *)a1 + 30142;
  *a1 = &unk_1EF09B8A8;
  uint64_t v3 = (void *)a1[3780];
  if (v3 && v2[96] == 1) {
    free(v3);
  }
  uint64_t v4 = (void *)a1[3776];
  if (v4 && v2[64] == 1) {
    free(v4);
  }
  char v5 = (void *)a1[3772];
  if (v5 && v2[32] == 1) {
    free(v5);
  }
  uint64_t v6 = (void *)a1[3768];
  if (v6 && *v2 == 1) {
    free(v6);
  }
  sub_19E07D688((uint64_t)(a1 + 1));
  return a1;
}

void sub_19E0A5820()
{
}

void sub_19E0A584C()
{
}

char *sub_19E0A5878(char *a1, uint64_t a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (uint64_t)(a1 + 30136);
  *(void *)a1 = &unk_1EF09B8A8;
  sub_19E03A080((uint64_t)(a1 + 8));
  if (a2)
  {
    CFStringRef v11 = (const __CFString *)MEMORY[0x19F3B9E50](a2);
    sub_19E03F0BC(v10, v11);
  }
  else
  {
    *(_DWORD *)uint64_t v10 = 0x100000;
    *(_WORD *)(v10 + 4) = 0;
    *(unsigned char *)(v10 + 6) = 0;
    *((void *)a1 + 376++**(_DWORD **)(result + 8) = 0;
    *(unsigned char *)(v10 + 16) = 0;
  }
  sub_19E03F0BC((uint64_t)(a1 + 30168), a3);
  if (a4)
  {
    sub_19E03F0BC(v10 + 64, a4);
  }
  else
  {
    *(_DWORD *)(v10 + 64) = 0x100000;
    *(_WORD *)(v10 + 6++**(_DWORD **)(result + 8) = 0;
    *(unsigned char *)(v10 + 7sub_19E062044(&a9, 0) = 0;
    *((void *)a1 + 3776) = 0;
    *(unsigned char *)(v10 + 8sub_19E062044(&a9, 0) = 0;
  }
  if (a5)
  {
    sub_19E03F0BC(v10 + 96, a5);
  }
  else
  {
    *(_DWORD *)(v10 + 96) = 0x100000;
    *(_WORD *)(v10 + 10sub_19E062044(&a9, 0) = 0;
    *(unsigned char *)(v10 + 102) = 0;
    *((void *)a1 + 378sub_19E062044(&a9, 0) = 0;
    *(unsigned char *)(v10 + 112) = 0;
  }
  sub_19E0538DC((uint64_t)v31);
  CFStringRef v12 = sub_19E0416F8(&v32, (uint64_t)"creating static lexicon with locale=", 36);
  if (*((void *)a1 + 3768)) {
    char v13 = (const char *)*((void *)a1 + 3768);
  }
  else {
    char v13 = a1 + 30152;
  }
  size_t v14 = strlen(v13);
  char v15 = sub_19E0416F8(v12, (uint64_t)v13, v14);
  unint64_t v16 = sub_19E0416F8(v15, (uint64_t)", baseline_path=", 16);
  if (*((void *)a1 + 3772)) {
    char v17 = (const char *)*((void *)a1 + 3772);
  }
  else {
    char v17 = a1 + 30184;
  }
  size_t v18 = strlen(v17);
  sub_19E0416F8(v16, (uint64_t)v17, v18);
  if (*(_WORD *)(v10 + 64))
  {
    int v19 = sub_19E0416F8(&v32, (uint64_t)", delta_path=", 13);
    if (*((void *)a1 + 3776)) {
      __int16 v20 = (const char *)*((void *)a1 + 3776);
    }
    else {
      __int16 v20 = a1 + 30216;
    }
    size_t v21 = strlen(v20);
    sub_19E0416F8(v19, (uint64_t)v20, v21);
  }
  if (*(_WORD *)(v10 + 96))
  {
    unint64_t v22 = sub_19E0416F8(&v32, (uint64_t)", stem_suffix_id_map_path=", 26);
    if (*((void *)a1 + 3780)) {
      char v23 = (const char *)*((void *)a1 + 3780);
    }
    else {
      char v23 = a1 + 30248;
    }
    size_t v24 = strlen(v23);
    sub_19E0416F8(v22, (uint64_t)v23, v24);
  }
  if (qword_1EB4FEEB0 != -1) {
    dispatch_once(&qword_1EB4FEEB0, &unk_1EF098F88);
  }
  __int16 v25 = qword_1EB4FEEA8;
  if (os_log_type_enabled((os_log_t)qword_1EB4FEEA8, OS_LOG_TYPE_INFO))
  {
    sub_19E05EEA4(__p, (uint64_t)v33);
    char v26 = v30 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)buf = 136315138;
    int v37 = v26;
    _os_log_impl(&dword_19E038000, v25, OS_LOG_TYPE_INFO, "%s", buf, 0xCu);
    if (v30 < 0) {
      operator delete(__p[0]);
    }
  }
  v31[0] = *MEMORY[0x1E4FBA408];
  uint64_t v27 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v31 + *(void *)(v31[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  uint64_t v32 = v27;
  v33[0] = MEMORY[0x1E4FBA470] + 16;
  if (v34 < 0) {
    operator delete((void *)v33[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x19F3BA690](&v35);
  return a1;
}

void sub_19E0A5CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E053BB4((uint64_t)va);
  std::string v8 = (void *)v4[3780];
  if (v8 && v6[102] == 1) {
    free(v8);
  }
  char v9 = (void *)v4[3776];
  if (v9 && v6[70] == 1) {
    free(v9);
  }
  uint64_t v10 = (void *)v4[3772];
  if (v10 && v6[38] == 1) {
    free(v10);
  }
  CFStringRef v11 = (void *)v4[3768];
  if (v11)
  {
    if (v6[6] == 1) {
      free(v11);
    }
  }
  sub_19E07D688(v5);
  _Unwind_Resume(a1);
}

os_log_t sub_19E0A5D5C()
{
  os_log_t result = os_log_create("com.apple.Lexicon", "Immutable");
  qword_1EB4FEEA8 = (uint64_t)result;
  return result;
}

uint64_t sub_19E0A5D8C()
{
  qword_1EB4FEEB8 = 0;
  unk_1EB4FEEC0 = "LXLexicon";
  qword_1EB4FEEC8 = 0;
  unk_1EB4FEED0 = 0;
  qword_1EB4FEED8 = (uint64_t)sub_19E0750B8;
  unk_1EB4FEEE0 = 0u;
  unk_1EB4FEEF0 = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB4FEF18 = result;
  return result;
}

uint64_t LXLexiconCreateMutable(const __CFDictionary *a1, CFErrorRef *a2)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"name");
  if (Value)
  {
    uint64_t v5 = (uint64_t)Value;
    if (CFStringGetLength(Value))
    {
      uint64_t v6 = CFDictionaryGetValue(a1, @"dataFile");
      sub_19E039FA8(a1);
      CFBooleanRef v7 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"threadSafeTokenSpace");
      if (v7 && CFBooleanGetValue(v7)) {
        operator new();
      }
      std::string v8 = operator new(0x58uLL);
      v8[1] = 0;
      void v8[2] = 0;
      *std::string v8 = &unk_1EF09D0A0;
      sub_19E0F1410(v8 + 3, 0xFFFFFF00C00000uLL);
      if (qword_1EB4FEF30 != -1) {
        dispatch_once(&qword_1EB4FEF30, &unk_1EF098E48);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      atomic_fetch_add_explicit(v8 + 1, 1uLL, memory_order_relaxed);
      sub_19E0DCED8((void *)(Instance + 16), v5, (uint64_t)v6, (uint64_t)(v8 + 3), (uint64_t)v8);
    }
  }
  if (a2) {
    *a2 = sub_19E0A4344(@"A name is required when creating a mutable lexicon");
  }
  return 0;
}

void sub_19E0A6070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  sub_19E0782A0((const void **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0A6130(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E0A6154(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF09D0A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x19F3BA710);
}

void sub_19E0A61A8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF09D0A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_19E0A61CC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E0A61F0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF098CE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x19F3BA710);
}

void sub_19E0A6244(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF098CE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_19E0A6264()
{
}

void sub_19E0A62B0(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA710](v1, 0x10A1C40D4518434);
  _Unwind_Resume(a1);
}

void sub_19E0A62D4(uint64_t a1)
{
  qword_1EB4FECB8 = a1;
  operator new();
}

void sub_19E0A633C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0A6378(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B578)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_19E0A63B8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_19E0A63E8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t LXLexiconCopyEntryForTokenID(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 56))();
  }
  return result;
}

uint64_t LXLexiconCopyName(uint64_t a1)
{
  if (!a1) {
    __assert_rtn("LXLexiconCopyName", "LXLexicon.cpp", 421, "lexicon && \"Missing lexicon\"");
  }
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 64);

  return v1();
}

uint64_t LXLexiconCreateRootCursor(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 72))();
  }
  return result;
}

uint64_t LXLexiconEnumerateEntriesForString(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 192))();
  }
  return result;
}

uint64_t LXLexiconGetFirstTokenIDForString(uint64_t a1)
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = 0;
  if (a1)
  {
    (*(void (**)(void))(*(void *)(a1 + 16) + 192))();
    uint64_t v1 = *((unsigned int *)v4 + 6);
  }
  else
  {
    uint64_t v1 = 0;
  }
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_19E0A65E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0A65F8(uint64_t result, uint64_t a2, unsigned char *a3)
{
  if (!a2) {
    __assert_rtn("LXEntryGetTokenID", "LXEntry.cpp", 71, "entry");
  }
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(a2 + 76);
  *a3 = 1;
  return result;
}

uint64_t LXLexiconGetTokenIDForUTF8String(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 104))();
}

uint64_t LXLexiconAddWithCreationTime(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 120))();
}

uint64_t LXLexiconAddEntryWithTokenID(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 136))();
}

uint64_t LXLexiconUpdateMetaFlags(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 160))();
}

uint64_t LXLexiconIncrementPenaltyCount(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 152))();
}

uint64_t LXLexiconSetUserBitfield(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 168))();
}

uint64_t LXLexiconRemoveEntry(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 176))();
}

uint64_t LXLexiconCompareStrings(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 88))();
}

uint64_t LXLexiconWrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 24))();
}

void LXLexiconWriteDebugDump(void *a1, const __CFURL *a2)
{
  uint64_t v7 = 0;
  std::string v8 = &v7;
  uint64_t v9 = 0x2000000000;
  CFMutableDictionaryRef Mutable = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  char v6 = 0;
  if (a1) {
    a1 = (void *)(*(uint64_t (**)(void *))(a1[2] + 72))(a1 + 2);
  }
  void v5[4] = &v7;
  void v5[5] = a1;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = sub_19E0A6914;
  void v5[3] = &unk_1E599BF98;
  sub_19E088C88((uint64_t)a1, &v6, (uint64_t)v5);
  uint64_t v4 = (const void *)v8[3];
  if (a1) {
    CFRelease(a1);
  }
  _Block_object_dispose(&v7, 8);
  sub_19E040C48(v4, a2, kCFPropertyListXMLFormat_v1_0, 1, 0);
  if (v4) {
    CFRelease(v4);
  }
}

void sub_19E0A68D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19E0A6914(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    __assert_rtn("LXEntryGetTokenID", "LXEntry.cpp", 71, "entry");
  }
  uint64_t v3 = *(__CFDictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  int v4 = *(_DWORD *)(a2 + 76);
  int v18 = *(_DWORD *)(a2 + 52) & 0x3FA000EF;
  int valuePtr = v4;
  int v5 = *(_DWORD *)(a2 + 64);
  int v16 = *(_DWORD *)(a2 + 68);
  int v17 = v5;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberIntType, &v18);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberIntType, &v17);
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberIntType, &v16);
  CFDateRef v10 = CFDateCreate(0, *(CFAbsoluteTime *)(a2 + 112));
  CFLocaleRef v11 = CFLocaleCreate(0, @"en_US");
  CFStringRef v12 = CFDateFormatterCreate(0, v11, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
  CFDateFormatterSetFormat(v12, @"yyyy-MM-dd HH:mm:ss zzz");
  CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(0, v12, v10);
  if (v12) {
    CFRelease(v12);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v10) {
    CFRelease(v10);
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, @"ID", v6);
  CFDictionarySetValue(Mutable, @"flags", v7);
  CFDictionarySetValue(Mutable, @"usageCount", v8);
  CFDictionarySetValue(Mutable, @"penaltyCount", v9);
  CFDictionarySetValue(Mutable, @"timestamp", StringWithDate);
  char v15 = LXEntryCopyString(a2);
  CFDictionarySetValue(v3, v15, Mutable);
  if (v15) {
    CFRelease(v15);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (StringWithDate) {
    CFRelease(StringWithDate);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v6) {
    CFRelease(v6);
  }
}

void sub_19E0A6B94(_Unwind_Exception *exception_object)
{
  if (v5) {
    CFRelease(v5);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v2) {
    CFRelease(v2);
  }
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LXLexiconClear(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 184))();
}

uint64_t LXLexiconSerializedSize(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 32))();
}

uint64_t LXLexiconUnlockMemory(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 48))();
}

os_log_t sub_19E0A6CF8()
{
  os_log_t result = os_log_create("com.apple.Lexicon", "Validation");
  qword_1E9457760 = (uint64_t)result;
  return result;
}

const void **sub_19E0A6D28(CFStringRef *a1, const UInt8 *a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex v4 = *((void *)a2 + 1);
  if (*((char *)a2 + 23) >= 0)
  {
    CFIndex v5 = a2[23];
  }
  else
  {
    a2 = *(const UInt8 **)a2;
    CFIndex v5 = v4;
  }
  CFNumberRef v7 = 0;
  *a1 = CFStringCreateWithBytes(v3, a2, v5, 0x8000100u, 1u);
  return sub_19E040A10(&v7);
}

const void **sub_19E0A6D94(uint64_t a1, unsigned __int16 *a2, const __CFLocale *a3)
{
  v18[1] = *(const void **)MEMORY[0x1E4F143B8];
  int v6 = *a2;
  int v7 = a2[2];
  if (a2[2])
  {
    if (a3) {
      goto LABEL_16;
    }
  }
  else
  {
    sub_19E0398F4(a2);
    int v7 = a2[2];
    if (a3)
    {
LABEL_16:
      CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
      v18[0] = Mutable;
      if (*((void *)a2 + 1)) {
        int v17 = (const char *)*((void *)a2 + 1);
      }
      else {
        int v17 = (const char *)(a2 + 8);
      }
      CFStringAppendCString(Mutable, v17, 0x8000100u);
      CFStringLowercase((CFMutableStringRef)v18[0], a3);
      sub_19E03F0BC(a1, (CFStringRef)v18[0]);
      return sub_19E0A6F6C(v18);
    }
  }
  if (v6 != v7) {
    goto LABEL_16;
  }
  uint64_t v8 = *a2;
  MEMORY[0x1F4188790]();
  CFDateRef v10 = (char *)v18 - v9;
  if (v8)
  {
    for (uint64_t i = 0; i != v8; ++i)
    {
      CFStringRef v12 = (unsigned __int16 *)*((void *)a2 + 1);
      if (!v12) {
        CFStringRef v12 = a2 + 8;
      }
      v10[i] = __tolower(*((char *)v12 + i));
    }
  }
  v10[v8] = 0;
  if (*((void *)a2 + 1)) {
    char v13 = (const char *)*((void *)a2 + 1);
  }
  else {
    char v13 = (const char *)(a2 + 8);
  }
  if (!strcmp(v13, v10)) {
    return (const void **)sub_19E039858(a1, a2);
  }
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 6) = 1;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  unsigned __int16 v14 = strlen(v10);
  return (const void **)sub_19E03F6F8((void *)a1, (uint64_t)v10, 0, v14);
}

void sub_19E0A6F4C(_Unwind_Exception *exception_object)
{
}

const void **sub_19E0A6F6C(const void **a1)
{
  unint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

os_log_t sub_19E0A6FA4()
{
  os_log_t result = os_log_create("com.apple.Lexicon", "ByteString");
  qword_1E9457770 = (uint64_t)result;
  return result;
}

unsigned __int16 *sub_19E0A6FD4(unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (*a1 >= 0xFu)
  {
    uint64_t v4 = *((void *)a1 + 1);
    if (v4) {
      MEMORY[0x19F3BA6E0](v4, 0x1000C8077774924);
    }
  }
  unint64_t v5 = *a2;
  if (v5 >= 0xF)
  {
    *a1 = v5;
    operator new[]();
  }
  *(_OWORD *)a1 = *(_OWORD *)a2;
  return a1;
}

BOOL sub_19E0A7064(unsigned __int16 *a1, unsigned __int16 *a2)
{
  size_t v2 = *a2;
  unsigned int v3 = *a1;
  if (v2 > v3) {
    return 0;
  }
  unint64_t v5 = (const void *)*((void *)a2 + 1);
  if (v2 <= 0xE) {
    unint64_t v5 = a2 + 1;
  }
  if (v3 < 0xF) {
    int v6 = a1 + 1;
  }
  else {
    int v6 = (const void *)*((void *)a1 + 1);
  }
  return memcmp(v5, v6, v2) == 0;
}

uint64_t sub_19E0A70C4(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unint64_t v2 = *a1;
  unsigned int v3 = (unsigned __int8 *)*((void *)a1 + 1);
  if (v2 <= 0xE) {
    unsigned int v3 = (unsigned __int8 *)(a1 + 1);
  }
  uint64_t v4 = *a2;
  unint64_t v5 = (unsigned __int8 *)*((void *)a2 + 1);
  if (v4 <= 0xE) {
    unint64_t v5 = (unsigned __int8 *)(a2 + 1);
  }
  if (!*a2) {
    return 0;
  }
  for (uint64_t i = v4 - 1; v2; --i)
  {
    unsigned int v7 = *v3;
    unsigned int v8 = *v5;
    if (v7 < v8) {
      break;
    }
    ++v3;
    ++v5;
    --v2;
    if (v8 < v7 || i == 0) {
      return 0;
    }
  }
  return 1;
}

BOOL sub_19E0A7134(unsigned __int16 *a1, unsigned __int16 *a2)
{
  size_t v2 = *a1;
  if (v2 != *a2) {
    return 0;
  }
  if (v2 <= 0xE) {
    unsigned int v3 = a1 + 1;
  }
  else {
    unsigned int v3 = (const void *)*((void *)a1 + 1);
  }
  if (v2 <= 0xE) {
    uint64_t v4 = a2 + 1;
  }
  else {
    uint64_t v4 = (const void *)*((void *)a2 + 1);
  }
  return memcmp(v3, v4, v2) == 0;
}

uint64_t sub_19E0A7188(uint64_t result, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_DWORD *)os_log_t result = 0x100000;
  *(_WORD *)(result + 4) = 0;
  *(unsigned char *)(result + 6) = 0;
  *(void *)(result + ++**(_DWORD **)(result + 8) = 0;
  *(unsigned char *)(result + 16) = 0;
  LODWORD(v++**(_DWORD **)(result + 8) = *a2;
  if (*a2)
  {
    CFDateRef v10 = (const void *)result;
    unint64_t v11 = 0;
    CFStringRef v12 = a2 + 1;
    do
    {
      char v13 = v12;
      if (v8 >= 0xF) {
        char v13 = (unsigned __int16 *)*((void *)a2 + 1);
      }
      os_log_t result = sub_19E0B2180(v10, "%02x", a3, a4, a5, a6, a7, a8, *((unsigned char *)v13 + v11++));
      unint64_t v8 = *a2;
    }
    while (v11 < v8);
  }
  return result;
}

void sub_19E0A7228(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0A724C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 672);
}

uint64_t sub_19E0A7254()
{
  return 0;
}

void *sub_19E0A725C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void v6[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 1174405120;
    v5[2] = sub_19E0A735C;
    void v5[3] = &unk_1EF09ABA0;
    void v5[4] = a2;
    sub_19E0A7414((uint64_t)v6, a3);
    (*(void (**)(uint64_t, void *))(*(void *)(v3 + 16) + 48))(v3 + 16, v5);
    return sub_19E0621CC(v6);
  }
  return result;
}

void sub_19E0A7340(_Unwind_Exception *a1)
{
  sub_19E0621CC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0A735C(uint64_t a1, uint64_t a2)
{
  int v9 = 0;
  if (!a2) {
    __assert_rtn("LXEntryGetEmissionCost", "LXEntry.cpp", 119, "entry");
  }
  LOWORD(v2) = *(unsigned __int8 *)(a2 + 88);
  if (*(unsigned char *)(a2 + 88))
  {
    unsigned __int16 v3 = *(_WORD *)(a2 + 96);
    if (v3 >= 0x7FFFu) {
      unsigned __int16 v3 = 0x7FFF;
    }
    __int16 v8 = v3;
    unsigned int v2 = *(_DWORD *)(a2 + 92);
    unsigned int v4 = HIWORD(v2);
  }
  else
  {
    LOWORD(v4) = 0;
    __int16 v8 = 0x7FFF;
  }
  v7[0] = v2;
  v7[1] = v4;
  if (*(_WORD *)(*(void *)(a1 + 32) + 14)) {
    __int16 v5 = 11;
  }
  else {
    __int16 v5 = 9;
  }
  void v7[2] = v5;
  return sub_19E06C4BC(*(void *)(a1 + 64), (uint64_t)v7, a2);
}

uint64_t sub_19E0A7414(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_19E0A74AC(uint64_t a1)
{
  return sub_19E0621CC((void *)(a1 + 40));
}

uint64_t sub_19E0A74B4(uint64_t a1, uint64_t a2)
{
  return sub_19E0A7414(a1 + 40, a2 + 40);
}

uint64_t sub_19E0A74C0(uint64_t a1, char a2, uint64_t a3, int a4, uint64_t a5, const void *a6)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a5;
  if (!*(void *)(a1 + 664)) {
    return 0;
  }
  uint64_t v36 = 0;
  unint64_t v11 = (CFTypeRef *)operator new(0x20uLL);
  CFTypeRef *v11 = &unk_1EF099F60;
  v11[1] = a6;
  void v11[2] = &v36;
  void v11[3] = &v37;
  int v44 = v11;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v40 = 0u;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a3 + 24))(a3) > (unint64_t)a4)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, a4);
    uint64_t v13 = *(void *)(a1 + 664);
    if (v13) {
      unsigned __int16 v14 = (const void *)(*(uint64_t (**)(void))(*(void *)(v13 + 16) + 72))();
    }
    else {
      unsigned __int16 v14 = 0;
    }
    v39[2] = v14;
    if (v12)
    {
      int v16 = (CFTypeRef *)(v12 - 1);
      do
      {
        cf[0] = 0;
        sub_19E0A7B48(cf, v14);
        CFTypeRef v17 = cf[0];
        cf[0] = 0;
        v45[0] = v17;
        v45[1] = 0;
        v45[2] = (CFTypeRef)a4;
        char v46 = v16;
        sub_19E0A7BA8((uint64_t)&v40, (uint64_t *)v45);
        if (v45[0]) {
          CFRelease(v45[0]);
        }
        int v16 = (CFTypeRef *)((char *)v16 - 1);
      }
      while (v16 != (CFTypeRef *)-1);
    }
    uint64_t v18 = *((void *)&v42 + 1);
    while (*((void *)&v42 + 1))
    {
      uint64_t v19 = *(void *)(*((void *)&v40 + 1) + (((unint64_t)(v18 + v42 - 1) >> 4) & 0xFFFFFFFFFFFFFF8))
          + 32 * ((v18 + v42 - 1) & 0x7F);
      uint64_t v20 = *(void *)(v19 + 16);
      double v21 = *(double *)(v19 + 8);
      double v22 = (*(double (**)(uint64_t, uint64_t, void))(*(void *)a3 + 48))(a3, v20, *(void *)(v19 + 24));
      char v23 = (UChar *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)a3 + 32))(a3, *(void *)(v19 + 16), *(void *)(v19 + 24));
      __int16 v25 = (void *)LXCursorCreateByAdvancingWithUTF16(*(void *)v19, v23, v24);
      v39[1] = v25;
      uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a3 + 40))(a3, v20, *(void *)(v19 + 24));
      sub_19E062044((const void **)(*(void *)(*((void *)&v40 + 1)+ (((unint64_t)(*((void *)&v42 + 1) + v42 - 1) >> 4) & 0xFFFFFFFFFFFFFF8))+ 32 * ((*((void *)&v42 + 1) + v42 - 1) & 0x7F)), 0);
      long long v27 = v42;
      --*((void *)&v42 + 1);
      uint64_t v28 = 16 * (v41 - *((void *)&v40 + 1)) - 1;
      if ((void)v41 == *((void *)&v40 + 1)) {
        uint64_t v28 = 0;
      }
      if ((unint64_t)(v28 - (*((void *)&v27 + 1) + v27) - 255) <= 0xFFFFFFFFFFFFFEFFLL)
      {
        operator delete(*(void **)(v41 - 8));
        *(void *)&long long v41 = v41 - 8;
      }
      if (!v25) {
        goto LABEL_41;
      }
      double v29 = v21 + v22;
      char v30 = (const void *)(v26 + v20);
      if ((a2 & 5) == 1)
      {
        if (v30 != (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a3 + 24))(a3)) {
          goto LABEL_23;
        }
      }
      else if ((a2 & 4) == 0)
      {
        goto LABEL_23;
      }
      if ((sub_19E0A8104((uint64_t)v44, (uint64_t)v25, (uint64_t)v30 - a4, 0, v29) & 1) == 0)
      {
        int v34 = 1;
        goto LABEL_39;
      }
LABEL_23:
      if ((unint64_t)v30 >= (*(uint64_t (**)(uint64_t))(*(void *)a3 + 24))(a3))
      {
        if ((a2 & 2) != 0)
        {
          uint64_t v35 = v44;
          if (!v44) {
            goto LABEL_34;
          }
          if (v44 == v43)
          {
            char v46 = v45;
            (*(void (**)(void *, CFTypeRef *))(v43[0] + 24))(v43, v45);
          }
          else
          {
            uint64_t v35 = (CFTypeRef *)(*((uint64_t (**)(void))*v44 + 2))();
LABEL_34:
            char v46 = v35;
          }
          sub_19E0A8168(a1, v25, (uint64_t)v30 - a4, (uint64_t)v45, v29);
          sub_19E0A7AC4(v45);
        }
        int v34 = 5;
        goto LABEL_39;
      }
      uint64_t v31 = (*(uint64_t (**)(uint64_t, const void *))(*(void *)a3 + 16))(a3, v30);
      if (v31)
      {
        uint64_t v32 = (char *)(v31 - 1);
        do
        {
          v39[0] = 0;
          sub_19E0A7B48(v39, v25);
          char v33 = v39[0];
          cf[3] = v32;
          v39[0] = 0;
          cf[0] = v33;
          cf[1] = *(CFTypeRef *)&v29;
          cf[2] = v30;
          sub_19E0A7BA8((uint64_t)&v40, (uint64_t *)cf);
          if (cf[0]) {
            CFRelease(cf[0]);
          }
          --v32;
        }
        while (v32 != (char *)-1);
      }
      int v34 = 0;
LABEL_39:
      CFRelease(v25);
      if (v34 != 5 && v34) {
        break;
      }
LABEL_41:
      uint64_t v18 = *((void *)&v42 + 1);
    }
    if (v14) {
      CFRelease(v14);
    }
  }
  sub_19E0A84F4((uint64_t)&v40);
  sub_19E0A7AC4(v43);
  return v36;
}

void sub_19E0A7A04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  if (a2) {
    sub_19E04137C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E0A7AC4(void *a1)
{
  unsigned int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_19E0A7B48(const void **a1, CFTypeRef cf)
{
  if (*a1 != cf)
  {
    CFRetain(cf);
    sub_19E062044(a1, cf);
  }
}

__n128 sub_19E0A7BA8(uint64_t a1, uint64_t *a2)
{
  unsigned int v4 = *(char **)(a1 + 16);
  __int16 v5 = *(char **)(a1 + 8);
  uint64_t v6 = v4 - v5;
  if (v4 == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 16 * (v4 - v5) - 1;
  }
  unint64_t v8 = *(void *)(a1 + 32);
  if (v7 == *(void *)(a1 + 40) + v8)
  {
    BOOL v9 = v8 >= 0x80;
    unint64_t v10 = v8 - 128;
    if (v9)
    {
      *(void *)(a1 + 32) = v10;
      uint64_t v13 = *(void *)v5;
      unint64_t v11 = v5 + 8;
      uint64_t v12 = v13;
      *(void *)(a1 + ++**(_DWORD **)(result + 8) = v11;
      if (v4 == *(char **)(a1 + 24))
      {
        unsigned __int16 v14 = *(char **)a1;
        if ((unint64_t)v11 <= *(void *)a1)
        {
          if (v4 == v14) {
            unint64_t v36 = 1;
          }
          else {
            unint64_t v36 = (v4 - v14) >> 2;
          }
          if (v36 >> 61) {
            goto LABEL_98;
          }
          uint64_t v37 = (char *)operator new(8 * v36);
          uint64_t v38 = &v37[8 * (v36 >> 2)];
          uint64_t v40 = v4 - v11;
          BOOL v39 = v4 == v11;
          unsigned int v4 = v38;
          if (!v39)
          {
            unsigned int v4 = &v38[v40 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v41 = 8 * (v40 >> 3);
            long long v42 = &v37[8 * (v36 >> 2)];
            do
            {
              uint64_t v43 = *(void *)v11;
              v11 += 8;
              *(void *)long long v42 = v43;
              v42 += 8;
              v41 -= 8;
            }
            while (v41);
          }
          *(void *)a1 = v37;
          *(void *)(a1 + ++**(_DWORD **)(result + 8) = v38;
          *(void *)(a1 + 16) = v4;
          *(void *)(a1 + 24) = &v37[8 * v36];
          if (v14)
          {
            operator delete(v14);
            unsigned int v4 = *(char **)(a1 + 16);
          }
        }
        else
        {
          uint64_t v15 = (uint64_t)&v11[-*(void *)a1] >> 3;
          if (v15 >= -1) {
            uint64_t v16 = v15 + 1;
          }
          else {
            uint64_t v16 = v15 + 2;
          }
          uint64_t v17 = -(v16 >> 1);
          uint64_t v18 = v16 >> 1;
          uint64_t v19 = &v11[-8 * v18];
          int64_t v20 = v4 - v11;
          if (v4 != v11)
          {
            memmove(&v11[-8 * v18], v11, v4 - v11);
            unsigned int v4 = *(char **)(a1 + 8);
          }
          double v21 = &v4[8 * v17];
          unsigned int v4 = &v19[v20];
          *(void *)(a1 + ++**(_DWORD **)(result + 8) = v21;
          *(void *)(a1 + 16) = &v19[v20];
        }
      }
      *(void *)unsigned int v4 = v12;
      goto LABEL_37;
    }
    uint64_t v22 = v6 >> 3;
    char v23 = *(char **)(a1 + 24);
    uint64_t v24 = *(char **)a1;
    uint64_t v25 = (uint64_t)&v23[-*(void *)a1];
    if (v6 >> 3 < (unint64_t)(v25 >> 3))
    {
      uint64_t v26 = operator new(0x1000uLL);
      long long v27 = v26;
      if (v23 != v4)
      {
        *(void *)unsigned int v4 = v26;
LABEL_37:
        *(void *)(a1 + 16) += 8;
        goto LABEL_38;
      }
      if (v5 == v24)
      {
        if (v4 == v5) {
          unint64_t v65 = 1;
        }
        else {
          unint64_t v65 = (v23 - v5) >> 2;
        }
        if (v65 >> 61) {
          goto LABEL_98;
        }
        float v66 = (char *)operator new(8 * v65);
        char v48 = &v66[(2 * v65 + 6) & 0xFFFFFFFFFFFFFFF8];
        float v67 = v48;
        if (v4 != v5)
        {
          uint64_t v68 = 8 * v22;
          unint64_t v69 = &v66[(2 * v65 + 6) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v70 = v5;
          float v67 = &v48[8 * v22];
          do
          {
            uint64_t v71 = *(void *)v70;
            v70 += 8;
            *(void *)unint64_t v69 = v71;
            v69 += 8;
            v68 -= 8;
          }
          while (v68);
        }
        *(void *)a1 = v66;
        *(void *)(a1 + ++**(_DWORD **)(result + 8) = v48;
        *(void *)(a1 + 16) = v67;
        *(void *)(a1 + 24) = &v66[8 * v65];
        if (v5)
        {
          operator delete(v5);
          char v48 = *(char **)(a1 + 8);
        }
      }
      else
      {
        char v48 = v5;
      }
      *((void *)v48 - 1) = v27;
      uint64_t v72 = *(char **)(a1 + 8);
      uint64_t v73 = *(char **)(a1 + 16);
      *(void *)(a1 + ++**(_DWORD **)(result + 8) = v72 - 8;
      uint64_t v74 = *((void *)v72 - 1);
      *(void *)(a1 + ++**(_DWORD **)(result + 8) = v72;
      if (v73 != *(char **)(a1 + 24))
      {
LABEL_96:
        *(void *)uint64_t v73 = v74;
        goto LABEL_37;
      }
      uint64_t v75 = *(char **)a1;
      if ((unint64_t)v72 > *(void *)a1)
      {
        uint64_t v76 = (uint64_t)&v72[-*(void *)a1] >> 3;
        if (v76 >= -1) {
          uint64_t v77 = v76 + 1;
        }
        else {
          uint64_t v77 = v76 + 2;
        }
        uint64_t v78 = -(v77 >> 1);
        uint64_t v79 = v77 >> 1;
        uint64_t v80 = &v72[-8 * v79];
        size_t v81 = v73 - v72;
        if (v81)
        {
          memmove(&v72[-8 * v79], v72, v81);
          uint64_t v72 = *(char **)(a1 + 8);
        }
        uint64_t v73 = &v80[v81];
        *(void *)(a1 + ++**(_DWORD **)(result + 8) = &v72[8 * v78];
        *(void *)(a1 + 16) = v73;
        goto LABEL_96;
      }
      if (v73 == v75) {
        unint64_t v82 = 1;
      }
      else {
        unint64_t v82 = (v73 - v75) >> 2;
      }
      if (!(v82 >> 61))
      {
        uint64_t v83 = (char *)operator new(8 * v82);
        BOOL v84 = &v83[8 * (v82 >> 2)];
        uint64_t v85 = v73 - v72;
        BOOL v39 = v73 == v72;
        uint64_t v73 = v84;
        if (!v39)
        {
          uint64_t v73 = &v84[v85 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v86 = 8 * (v85 >> 3);
          int64_t v87 = &v83[8 * (v82 >> 2)];
          do
          {
            uint64_t v88 = *(void *)v72;
            v72 += 8;
            *(void *)int64_t v87 = v88;
            v87 += 8;
            v86 -= 8;
          }
          while (v86);
        }
        *(void *)a1 = v83;
        *(void *)(a1 + ++**(_DWORD **)(result + 8) = v84;
        *(void *)(a1 + 16) = v73;
        *(void *)(a1 + 24) = &v83[8 * v82];
        if (v75)
        {
          operator delete(v75);
          uint64_t v73 = *(char **)(a1 + 16);
        }
        goto LABEL_96;
      }
LABEL_98:
      sub_19E0416C4();
    }
    uint64_t v28 = v25 >> 2;
    if (v23 == v24) {
      unint64_t v29 = 1;
    }
    else {
      unint64_t v29 = v28;
    }
    if (v29 >> 61) {
      goto LABEL_98;
    }
    char v30 = (char *)operator new(8 * v29);
    uint64_t v31 = operator new(0x1000uLL);
    uint64_t v32 = &v30[8 * v22];
    char v33 = &v30[8 * v29];
    if (v22 == v29)
    {
      int v34 = v31;
      if (v6 < 1)
      {
        if (v4 == v5) {
          unint64_t v49 = 1;
        }
        else {
          unint64_t v49 = v6 >> 2;
        }
        if (v49 >> 61) {
          sub_19E0416C4();
        }
        uint64_t v32 = (char *)operator new(8 * v49);
        char v33 = &v32[8 * v49];
        operator delete(v30);
        __int16 v5 = *(char **)(a1 + 8);
        unsigned int v4 = *(char **)(a1 + 16);
        char v30 = v32;
      }
      else
      {
        unint64_t v35 = v22 + 2;
        if (v22 >= -1) {
          unint64_t v35 = v22 + 1;
        }
        v32 -= 8 * (v35 >> 1);
      }
      uint64_t v31 = v34;
    }
    *(void *)uint64_t v32 = v31;
    uint64_t v50 = v32 + 8;
    if (v4 == v5)
    {
      uint64_t v63 = v32;
      __int16 v52 = v32 + 8;
    }
    else
    {
      do
      {
        if (v32 == v30)
        {
          if (v50 >= v33)
          {
            if (v33 == v32) {
              unint64_t v55 = 1;
            }
            else {
              unint64_t v55 = (v33 - v32) >> 2;
            }
            if (v55 >> 61) {
              sub_19E0416C4();
            }
            long long v56 = (char *)operator new(8 * v55);
            char v30 = v56;
            long long v51 = &v56[(2 * v55 + 6) & 0xFFFFFFFFFFFFFFF8];
            __int16 v52 = v51;
            uint64_t v57 = v50 - v32;
            if (v50 != v32)
            {
              __int16 v52 = &v51[v57 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v58 = 8 * (v57 >> 3);
              uint64_t v59 = &v56[(2 * v55 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint8x8_t v60 = v32;
              do
              {
                uint64_t v61 = *(void *)v60;
                v60 += 8;
                *(void *)uint64_t v59 = v61;
                v59 += 8;
                v58 -= 8;
              }
              while (v58);
            }
            char v33 = &v56[8 * v55];
            operator delete(v32);
          }
          else
          {
            uint64_t v53 = (v33 - v50) >> 3;
            if (v53 >= -1) {
              unint64_t v54 = v53 + 1;
            }
            else {
              unint64_t v54 = v53 + 2;
            }
            __int16 v52 = &v50[8 * (v54 >> 1)];
            long long v51 = &v32[8 * (v54 >> 1)];
            if (v50 == v32)
            {
              char v30 = v50;
            }
            else
            {
              memmove(&v32[8 * (v54 >> 1)], v32, v50 - v32);
              char v30 = v32;
            }
          }
        }
        else
        {
          long long v51 = v32;
          __int16 v52 = v50;
        }
        uint64_t v62 = *((void *)v4 - 1);
        v4 -= 8;
        *((void *)v51 - 1) = v62;
        uint64_t v63 = v51 - 8;
        uint64_t v50 = v52;
        uint64_t v32 = v63;
      }
      while (v4 != *(char **)(a1 + 8));
    }
    int v64 = *(char **)a1;
    *(void *)a1 = v30;
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = v63;
    *(void *)(a1 + 16) = v52;
    *(void *)(a1 + 24) = v33;
    if (v64) {
      operator delete(v64);
    }
  }
LABEL_38:
  unint64_t v44 = *(void *)(a1 + 40) + *(void *)(a1 + 32);
  uint64_t v45 = *(void *)(*(void *)(a1 + 8) + ((v44 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v44 & 0x7F);
  uint64_t v46 = *a2;
  *a2 = 0;
  *(void *)uint64_t v45 = v46;
  __n128 result = *(__n128 *)(a2 + 1);
  *(void *)(v45 + 24) = a2[3];
  *(__n128 *)(v45 + ++**(_DWORD **)(result + 8) = result;
  ++*(void *)(a1 + 40);
  return result;
}

void sub_19E0A80D0(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0A8104(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t v9 = a2;
  double v8 = a5;
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  if (!a1) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, double *, uint64_t *, uint64_t *))(*(void *)a1 + 48))(a1, &v9, &v8, &v7, &v6);
}

uint64_t sub_19E0A8168(uint64_t result, void *a2, uint64_t a3, uint64_t a4, double a5)
{
  if (a2)
  {
    uint64_t v9 = result;
    uint64_t v31 = 0;
    uint64_t v32 = &v31;
    uint64_t v33 = 0x5802000000;
    int v34 = sub_19E0A8650;
    unint64_t v35 = sub_19E0A8694;
    memset(v36, 0, sizeof(v36));
    CFStringRef v10 = (const __CFString *)(*(uint64_t (**)(void))(a2[2] + 112))();
    v30[1] = v10;
    CFIndex Length = CFStringGetLength(v10);
    uint64_t v12 = v32;
    v30[0] = CFRetain(a2);
    sub_19E0A869C(v12 + 5, v30);
    uint64_t v13 = v32;
    uint64_t v14 = v32[10];
    if (v14)
    {
      while (1)
      {
        unint64_t v15 = v14 + v13[9] - 1;
        uint64_t v16 = *(void *)(v13[6] + ((v15 >> 6) & 0x3FFFFFFFFFFFFF8));
        unint64_t v17 = v15 & 0x1FF;
        uint64_t v18 = *(void **)(v16 + 8 * v17);
        *(void *)(v16 + 8 * v17) = 0;
        v30[0] = v18;
        uint64_t v19 = v32;
        unint64_t v20 = v32[10] + v32[9] - 1;
        sub_19E062044((const void **)(*(void *)(v32[6] + ((v20 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v20 & 0x1FF)), 0);
        uint64_t v22 = v19[6];
        uint64_t v21 = v19[7];
        if (v21 == v22) {
          uint64_t v23 = 0;
        }
        else {
          uint64_t v23 = ((v21 - v22) << 6) - 1;
        }
        uint64_t v24 = v19[9];
        uint64_t v25 = v19[10] - 1;
        v19[10] = v25;
        if ((unint64_t)(v23 - (v25 + v24)) >= 0x400)
        {
          operator delete(*(void **)(v21 - 8));
          v19[7] -= 8;
        }
        CFStringRef v26 = v18 ? (const __CFString *)(*(uint64_t (**)(void))(v18[2] + 112))() : 0;
        v29[5] = v26;
        uint64_t v27 = CFStringGetLength(v26) - Length;
        if (v27 >= 1 && (sub_19E0A8104(*(void *)(a4 + 24), (uint64_t)v18, a3, v27, a5) & 1) == 0) {
          break;
        }
        uint64_t v28 = *(unsigned int *)(v9 + 676);
        if ((v28 & 0x80000000) != 0 || v27 < v28)
        {
          v29[0] = MEMORY[0x1E4F143A8];
          v29[1] = 0x40000000;
          v29[2] = sub_19E0A8C20;
          v29[3] = &unk_1E599C068;
          void v29[4] = &v31;
          if (v18) {
            (*(void (**)(void *, void *))(v18[2] + 64))(v18 + 2, v29);
          }
        }
        if (v26) {
          CFRelease(v26);
        }
        if (v18) {
          CFRelease(v18);
        }
        uint64_t v13 = v32;
        uint64_t v14 = v32[10];
        if (!v14) {
          goto LABEL_27;
        }
      }
      if (v26) {
        CFRelease(v26);
      }
      if (v18) {
        CFRelease(v18);
      }
    }
LABEL_27:
    if (v10) {
      CFRelease(v10);
    }
    _Block_object_dispose(&v31, 8);
    return sub_19E0A8C68((uint64_t)v36);
  }
  return result;
}

void sub_19E0A848C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  unint64_t v11 = va_arg(va1, const void *);
  sub_19E03D880((const void **)va, 0);
  _Block_object_dispose(va1, 8);
  sub_19E0A8C68(a3);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0A84F4(uint64_t a1)
{
  unsigned int v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    unsigned int v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    unsigned int v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 >> 7];
    uint64_t v7 = (const void **)((char *)*v6 + 32 * (v5 & 0x7F));
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v5) >> 4) & 0xFFFFFFFFFFFFFF8))
       + 32 * ((*(void *)(a1 + 40) + v5) & 0x7F);
    if (v7 != (const void **)v8)
    {
      do
      {
        sub_19E062044(v7, 0);
        v7 += 4;
        if ((char *)v7 - (unsigned char *)*v6 == 4096)
        {
          uint64_t v9 = (const void **)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }
      while (v7 != (const void **)v8);
      unsigned int v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  *unsigned int v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      unsigned int v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + ++**(_DWORD **)(result + 8) = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 64;
    goto LABEL_14;
  }
  if (v11 == 2)
  {
    uint64_t v12 = 128;
LABEL_14:
    *(void *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

double sub_19E0A8650(void *a1, void *a2)
{
  a1[5] = a2[5];
  a1[6] = a2[6];
  a1[7] = a2[7];
  a1[8] = a2[8];
  double result = 0.0;
  *(_OWORD *)(a2 + 7) = 0u;
  *(_OWORD *)(a2 + 5) = 0u;
  a1[9] = a2[9];
  a1[10] = a2[10];
  a2[9] = 0;
  a2[10] = 0;
  return result;
}

uint64_t sub_19E0A8694(uint64_t a1)
{
  return sub_19E0A8C68(a1 + 40);
}

void sub_19E0A869C(void *a1, void *a2)
{
  unsigned int v4 = (char *)a1[2];
  unint64_t v5 = (char *)a1[1];
  uint64_t v6 = v4 - v5;
  if (v4 == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = ((v4 - v5) << 6) - 1;
  }
  unint64_t v9 = a1[4];
  uint64_t v8 = a1[5];
  unint64_t v10 = v8 + v9;
  if (v7 == v8 + v9)
  {
    if (v9 >= 0x200)
    {
      a1[4] = v9 - 512;
      uint64_t v13 = *(void *)v5;
      unint64_t v11 = v5 + 8;
      uint64_t v12 = v13;
      a1[1] = v11;
      if ((char *)a1[3] == v4)
      {
        uint64_t v14 = (uint64_t)&v11[-*a1];
        if ((unint64_t)v11 <= *a1)
        {
          if (v4 == (char *)*a1) {
            unint64_t v42 = 1;
          }
          else {
            unint64_t v42 = (uint64_t)&v4[-*a1] >> 2;
          }
          uint64_t v43 = (char *)sub_19E060B48(v42);
          uint64_t v45 = &v43[8 * (v42 >> 2)];
          uint64_t v46 = (uint64_t *)a1[1];
          unsigned int v4 = v45;
          uint64_t v47 = a1[2] - (void)v46;
          if (v47)
          {
            unsigned int v4 = &v45[v47 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v48 = 8 * (v47 >> 3);
            unint64_t v49 = &v43[8 * (v42 >> 2)];
            do
            {
              uint64_t v50 = *v46++;
              *(void *)unint64_t v49 = v50;
              v49 += 8;
              v48 -= 8;
            }
            while (v48);
          }
          long long v51 = (char *)*a1;
          *a1 = v43;
          a1[1] = v45;
          a1[2] = v4;
          a1[3] = &v43[8 * v44];
          if (v51)
          {
            operator delete(v51);
            unsigned int v4 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v15 = v14 >> 3;
          BOOL v16 = v14 >> 3 < -1;
          uint64_t v17 = (v14 >> 3) + 2;
          if (v16) {
            uint64_t v18 = v17;
          }
          else {
            uint64_t v18 = v15 + 1;
          }
          uint64_t v19 = -(v18 >> 1);
          uint64_t v20 = v18 >> 1;
          uint64_t v21 = &v11[-8 * v20];
          int64_t v22 = v4 - v11;
          if (v4 == v11)
          {
            uint64_t v23 = v4;
          }
          else
          {
            memmove(&v11[-8 * v20], v11, v4 - v11);
            uint64_t v23 = (char *)a1[1];
          }
          unsigned int v4 = &v21[v22];
          a1[1] = &v23[8 * v19];
          a1[2] = &v21[v22];
        }
      }
      *(void *)unsigned int v4 = v12;
LABEL_82:
      a1[2] += 8;
LABEL_83:
      uint64_t v8 = a1[5];
      unint64_t v5 = (char *)a1[1];
      unint64_t v10 = a1[4] + v8;
      goto LABEL_84;
    }
    uint64_t v24 = v6 >> 3;
    uint64_t v25 = (char *)a1[3];
    CFStringRef v26 = (char *)*a1;
    uint64_t v27 = (uint64_t)&v25[-*a1];
    if (v6 >> 3 < (unint64_t)(v27 >> 3))
    {
      uint64_t v28 = operator new(0x1000uLL);
      unint64_t v29 = v28;
      if (v25 == v4)
      {
        if (v26 == v5)
        {
          if (v4 == v5) {
            unint64_t v52 = 1;
          }
          else {
            unint64_t v52 = v27 >> 2;
          }
          uint64_t v53 = 2 * v52;
          unint64_t v54 = (char *)sub_19E060B48(v52);
          unint64_t v5 = &v54[(v53 + 6) & 0xFFFFFFFFFFFFFFF8];
          long long v56 = (uint64_t *)a1[1];
          uint64_t v57 = v5;
          uint64_t v58 = a1[2] - (void)v56;
          if (v58)
          {
            uint64_t v57 = &v5[v58 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v59 = 8 * (v58 >> 3);
            uint8x8_t v60 = v5;
            do
            {
              uint64_t v61 = *v56++;
              *(void *)uint8x8_t v60 = v61;
              v60 += 8;
              v59 -= 8;
            }
            while (v59);
          }
          uint64_t v62 = (char *)*a1;
          *a1 = v54;
          a1[1] = v5;
          a1[2] = v57;
          a1[3] = &v54[8 * v55];
          if (v62)
          {
            operator delete(v62);
            unint64_t v5 = (char *)a1[1];
          }
        }
        *((void *)v5 - 1) = v29;
        uint64_t v63 = (char *)a1[1];
        int v64 = (char *)a1[2];
        a1[1] = v63 - 8;
        uint64_t v65 = *((void *)v63 - 1);
        a1[1] = v63;
        if (v64 == (char *)a1[3])
        {
          uint64_t v66 = (uint64_t)&v63[-*a1];
          if ((unint64_t)v63 <= *a1)
          {
            if (v64 == (char *)*a1) {
              unint64_t v97 = 1;
            }
            else {
              unint64_t v97 = (uint64_t)&v64[-*a1] >> 2;
            }
            int64_t v98 = (char *)sub_19E060B48(v97);
            uint64_t v100 = &v98[8 * (v97 >> 2)];
            uint64_t v101 = (uint64_t *)a1[1];
            int v64 = v100;
            uint64_t v102 = a1[2] - (void)v101;
            if (v102)
            {
              int v64 = &v100[v102 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v103 = 8 * (v102 >> 3);
              BOOL v104 = &v98[8 * (v97 >> 2)];
              do
              {
                uint64_t v105 = *v101++;
                *(void *)BOOL v104 = v105;
                v104 += 8;
                v103 -= 8;
              }
              while (v103);
            }
            BOOL v106 = (char *)*a1;
            *a1 = v98;
            a1[1] = v100;
            a1[2] = v64;
            a1[3] = &v98[8 * v99];
            if (v106)
            {
              operator delete(v106);
              int v64 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v67 = v66 >> 3;
            BOOL v16 = v66 >> 3 < -1;
            uint64_t v68 = (v66 >> 3) + 2;
            if (v16) {
              uint64_t v69 = v68;
            }
            else {
              uint64_t v69 = v67 + 1;
            }
            uint64_t v70 = -(v69 >> 1);
            uint64_t v71 = v69 >> 1;
            uint64_t v72 = &v63[-8 * v71];
            int64_t v73 = v64 - v63;
            if (v64 != v63)
            {
              memmove(&v63[-8 * v71], v63, v64 - v63);
              uint64_t v63 = (char *)a1[1];
            }
            int v64 = &v72[v73];
            a1[1] = &v63[8 * v70];
            a1[2] = &v72[v73];
          }
        }
        *(void *)int v64 = v65;
      }
      else
      {
        *(void *)unsigned int v4 = v28;
      }
      goto LABEL_82;
    }
    if (v25 == v26) {
      unint64_t v30 = 1;
    }
    else {
      unint64_t v30 = v27 >> 2;
    }
    uint64_t v31 = (char *)sub_19E060B48(v30);
    uint64_t v33 = v32;
    int v34 = &v31[8 * v24];
    *(void *)&long long v35 = v31;
    *((void *)&v35 + 1) = v34;
    long long v110 = v35;
    unint64_t v36 = operator new(0x1000uLL);
    *(void *)&long long v37 = v34;
    *((void *)&v37 + 1) = &v31[8 * v33];
    if (v24 == v33)
    {
      uint64_t v38 = 8 * v24;
      *(void *)&long long v39 = v110;
      if (v6 >= 1)
      {
        uint64_t v40 = v38 >> 3;
        if (v40 >= -1) {
          unint64_t v41 = v40 + 1;
        }
        else {
          unint64_t v41 = v40 + 2;
        }
        v34 -= 8 * (v41 >> 1);
        *(void *)&long long v37 = v34;
        *((void *)&v39 + 1) = v34;
        goto LABEL_56;
      }
      uint64_t v74 = v38 >> 2;
      if (v4 == v5) {
        unint64_t v75 = 1;
      }
      else {
        unint64_t v75 = v74;
      }
      uint64_t v76 = (char *)sub_19E060B48(v75);
      int v34 = &v76[8 * (v75 >> 2)];
      *(void *)&long long v39 = v76;
      *((void *)&v39 + 1) = v34;
      *(void *)&long long v37 = v34;
      *((void *)&v37 + 1) = &v76[8 * v77];
      if (!v31) {
        goto LABEL_56;
      }
      long long v107 = v37;
      long long v110 = v39;
      operator delete(v31);
      long long v37 = v107;
    }
    long long v39 = v110;
LABEL_56:
    *(void *)int v34 = v36;
    *(void *)&long long v37 = v37 + 8;
    for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
    {
      uint64_t v79 = (void *)*((void *)&v39 + 1);
      if (*((void *)&v39 + 1) == (void)v39)
      {
        size_t v81 = (unsigned char *)v37;
        if ((unint64_t)v37 >= *((void *)&v37 + 1))
        {
          if (*((void *)&v37 + 1) == *((void *)&v39 + 1)) {
            unint64_t v86 = 1;
          }
          else {
            unint64_t v86 = (uint64_t)(*((void *)&v37 + 1) - *((void *)&v39 + 1)) >> 2;
          }
          int64_t v87 = (char *)sub_19E060B48(v86);
          uint64_t v80 = &v87[(2 * v86 + 6) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v89 = v80;
          uint64_t v90 = v81 - (unsigned char *)v79;
          if (v81 != (unsigned char *)v79)
          {
            uint64_t v89 = &v80[v90 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v91 = 8 * (v90 >> 3);
            int v92 = v80;
            unsigned int v93 = v79;
            do
            {
              uint64_t v94 = *v93++;
              *(void *)int v92 = v94;
              v92 += 8;
              v91 -= 8;
            }
            while (v91);
          }
          *(void *)&long long v39 = v87;
          *((void *)&v39 + 1) = v80;
          *(void *)&long long v37 = v89;
          *((void *)&v37 + 1) = &v87[8 * v88];
          if (v79)
          {
            long long v108 = v37;
            long long v112 = v39;
            operator delete(v79);
            long long v37 = v108;
            long long v39 = v112;
          }
        }
        else
        {
          uint64_t v82 = (uint64_t)(*((void *)&v37 + 1) - v37) >> 3;
          if (v82 >= -1) {
            uint64_t v83 = v82 + 1;
          }
          else {
            uint64_t v83 = v82 + 2;
          }
          uint64_t v84 = v83 >> 1;
          uint64_t v85 = v37 + 8 * (v83 >> 1);
          uint64_t v80 = (char *)(v85 - (v37 - *((void *)&v39 + 1)));
          if ((void)v37 == *((void *)&v39 + 1))
          {
            size_t v81 = (unsigned char *)*((void *)&v39 + 1);
          }
          else
          {
            uint64_t v109 = *((void *)&v37 + 1);
            uint64_t v111 = v39;
            memmove((void *)(v85 - (v37 - *((void *)&v39 + 1))), *((const void **)&v39 + 1), v37 - *((void *)&v39 + 1));
            *((void *)&v37 + 1) = v109;
            *(void *)&long long v39 = v111;
          }
          *((void *)&v39 + 1) = v80;
          *(void *)&long long v37 = &v81[8 * v84];
        }
      }
      else
      {
        uint64_t v80 = (char *)*((void *)&v39 + 1);
      }
      uint64_t v95 = *(void *)(i - 8);
      *((void *)v80 - 1) = v95;
      *((void *)&v39 + 1) -= 8;
    }
    uint8x8_t v96 = (char *)*a1;
    *(_OWORD *)a1 = v39;
    *((_OWORD *)a1 + 1) = v37;
    if (v96) {
      operator delete(v96);
    }
    goto LABEL_83;
  }
LABEL_84:
  *(void *)(*(void *)&v5[(v10 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v10 & 0x1FF)) = *a2;
  a1[5] = v8 + 1;
}

void sub_19E0A8BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11)
{
  operator delete(v11);
  if ((void)a11) {
    operator delete((void *)a11);
  }
  _Unwind_Resume(a1);
}

void sub_19E0A8C20(uint64_t a1, CFTypeRef cf)
{
  unsigned int v2 = (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  CFTypeRef v3 = CFRetain(cf);
  sub_19E0A869C(v2, &v3);
}

uint64_t sub_19E0A8C68(uint64_t a1)
{
  unsigned int v2 = *(void ***)(a1 + 8);
  CFTypeRef v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    unsigned int v4 = (void *)(a1 + 40);
    CFTypeRef v3 = *(void ***)(a1 + 8);
  }
  else
  {
    unsigned int v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 >> 9];
    uint64_t v7 = (const void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v5) >> 6) & 0x3FFFFFFFFFFFFF8))
       + 8 * ((*(void *)(a1 + 40) + v5) & 0x1FF);
    if (v7 != (const void **)v8)
    {
      do
      {
        sub_19E062044(v7++, 0);
        if ((char *)v7 - (unsigned char *)*v6 == 4096)
        {
          unint64_t v9 = (const void **)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }
      while (v7 != (const void **)v8);
      unsigned int v2 = *(void ***)(a1 + 8);
      CFTypeRef v3 = *(void ***)(a1 + 16);
    }
  }
  *unsigned int v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      CFTypeRef v3 = *(void ***)(a1 + 16);
      unsigned int v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + ++**(_DWORD **)(result + 8) = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 256;
    goto LABEL_14;
  }
  if (v11 == 2)
  {
    uint64_t v12 = 512;
LABEL_14:
    *(void *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_19E0A8DC4()
{
  return &unk_1EF099608;
}

uint64_t sub_19E0A8DD0(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF099608)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

BOOL sub_19E0A8E10(uint64_t a1, void **a2, double *a3, uint64_t *a4, uint64_t *a5)
{
  unint64_t v5 = *a2;
  unint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = **(void **)(a1 + 16);
  if (v7 < v6 && v5 != 0)
  {
    double v10 = *a3;
    uint64_t v11 = *a4;
    uint64_t v12 = *a5;
    if ((*(unsigned int (**)(void))(v5[2] + 40))())
    {
      uint64_t v13 = *(void **)(a1 + 16);
      uint64_t v14 = **(void **)(a1 + 24);
      uint64_t v15 = (*v13)++;
      uint64_t v16 = v14 + 24 * v15;
      sub_19E0A7B48((const void **)(v16 + 16), v5);
      *(_WORD *)(v16 + 12) = 2 * v11;
      *(unsigned char *)uint64_t v16 = v10 < -0.0000001;
      float v17 = v10;
      *(float *)(v16 + 4) = v17;
      *(_WORD *)(v16 + 14) = 2 * v12;
    }
  }
  return v7 < v6;
}

__n128 sub_19E0A8EFC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF099F60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E0A8F2C(uint64_t a1)
{
  unsigned int v2 = (char *)operator new(0x20uLL);
  *(void *)unsigned int v2 = &unk_1EF099F60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++**(_DWORD **)(result + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E0A8F80()
{
}

unint64_t sub_19E0A8F98(uint64_t a1, char a2, UChar *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v27 = a8;
  uint64_t v10 = *(void *)(a1 + 664);
  if (!v10) {
    return 0;
  }
  unint64_t v26 = 0;
  uint64_t v14 = 0;
  CFTypeRef cf = (CFTypeRef)(*(uint64_t (**)(void))(*(void *)(v10 + 16) + 72))();
  uint64_t v15 = a4 >> 1;
  while (v15)
  {
    if (!*a3 || !cf)
    {
      uint64_t v15 = 1;
      break;
    }
    uint64_t v16 = (void *)LXCursorCreateByAdvancingWithUTF16((uint64_t)cf, a3, 1);
    if (!v16) {
      goto LABEL_29;
    }
    ++v14;
    ++a3;
    if ((a2 & 4) != 0)
    {
      --v15;
      sub_19E0A7B48(&cf, v16);
LABEL_12:
      unint64_t v18 = v26;
      if (v26 >= a9)
      {
        int v17 = 3;
      }
      else if ((*(unsigned int (**)(void))(v16[2] + 40))())
      {
        unint64_t v26 = v18 + 1;
        uint64_t v19 = v27 + 24 * v18;
        sub_19E0A7B48((const void **)(v19 + 16), v16);
        int v17 = 0;
        *(_WORD *)(v19 + 12) = 2 * v14;
        *(_WORD *)(v19 + 14) = 0;
      }
      else
      {
        int v17 = 0;
      }
      goto LABEL_18;
    }
    sub_19E0A7B48(&cf, v16);
    int v17 = 0;
    if ((a2 & 1) != 0 && v15 == 1)
    {
      uint64_t v15 = 0;
      goto LABEL_12;
    }
    --v15;
LABEL_18:
    CFRelease(v16);
    if (v17) {
      break;
    }
  }
  unint64_t v20 = v26;
  if ((a2 & 2) != 0 && v26 < a9 && v15 == 0)
  {
    int64_t v22 = cf;
    unint64_t v29 = 0;
    uint64_t v23 = operator new(0x20uLL);
    *uint64_t v23 = &unk_1EF099F08;
    v23[1] = a9;
    _DWORD v23[2] = &v26;
    void v23[3] = &v27;
    unint64_t v29 = v23;
    sub_19E0A8168(a1, v22, v14, (uint64_t)v28, 0.0);
    sub_19E0A7AC4(v28);
LABEL_29:
    unint64_t v20 = v26;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v20;
}

void sub_19E0A91F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  unsigned int v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_19E0A7AC4((uint64_t *)va1);
  sub_19E062044((const void **)va, 0);
  _Unwind_Resume(a1);
}

void *sub_19E0A9248()
{
  return &unk_1EF09B798;
}

uint64_t sub_19E0A9254(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B798)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

BOOL sub_19E0A9294(uint64_t a1, void **a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  unint64_t v5 = *a2;
  unint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = **(void **)(a1 + 16);
  if (v7 < v6 && v5 != 0)
  {
    uint64_t v10 = *a4;
    uint64_t v11 = *a5;
    if ((*(unsigned int (**)(void))(v5[2] + 40))())
    {
      uint64_t v12 = *(void **)(a1 + 16);
      uint64_t v13 = **(void **)(a1 + 24);
      uint64_t v14 = (*v12)++;
      uint64_t v15 = v13 + 24 * v14;
      sub_19E0A7B48((const void **)(v15 + 16), v5);
      *(_WORD *)(v15 + 12) = 2 * v10;
      *(_WORD *)(v15 + 14) = 2 * v11;
    }
  }
  return v7 < v6;
}

__n128 sub_19E0A9358(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF099F08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E0A9388(uint64_t a1)
{
  unsigned int v2 = (char *)operator new(0x20uLL);
  *(void *)unsigned int v2 = &unk_1EF099F08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++**(_DWORD **)(result + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E0A93DC()
{
}

uint64_t sub_19E0A93F4()
{
  return 0;
}

const char *sub_19E0A93FC()
{
  return "utf-16le";
}

void sub_19E0A940C(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C2D0;
  sub_19E078268((const void **)(a1 + 664), 0);
  sub_19E06FD84(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E0A947C(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C2D0;
  sub_19E078268((const void **)(a1 + 664), 0);

  return sub_19E06FD84(a1);
}

BOOL sub_19E0A94D8(uint64_t a1, char *a2, unsigned __int16 a3, const char *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  value[1] = Mutable;
  sub_19E0B13C0((uint64_t)&cf, a2, a3);
  sub_19E03FD18((CFStringRef *)value, (unsigned __int16 *)&cf);
  if (v15 && BYTE6(cf) == 1) {
    free(v15);
  }
  CFDictionaryAddValue(Mutable, @"locale", value[0]);
  if (a4)
  {
    CFStringRef v9 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a4, 0x8000100u);
    CFTypeRef cf = v9;
    CFDictionaryAddValue(Mutable, @"dataFile", v9);
    if (v9) {
      CFRelease(v9);
    }
  }
  CFTypeRef cf = 0;
  uint64_t v10 = (const void *)LXLexiconCreate(Mutable, (CFErrorRef *)&cf);
  sub_19E078268((const void **)(a1 + 664), v10);
  CFTypeRef v11 = cf;
  if (cf) {
    CFRelease(cf);
  }
  else {
    *(_DWORD *)(a1 + 52) = 0;
  }
  sub_19E040A10((const void **)value);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v11 == 0;
}

void sub_19E0A964C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, char a20,char a21,void *a22)
{
  if (a2) {
    sub_19E04137C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0A96C4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    sub_19E0483E0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_19E0A9718(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_19E0A97B0(uint64_t a1)
{
  return sub_19E0626C4((void *)(a1 + 32));
}

uint64_t sub_19E0A97B8(uint64_t a1, uint64_t a2)
{
  return sub_19E0A9718(a1 + 32, a2 + 32);
}

uint64_t sub_19E0A97C4(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (a2 >= (unint64_t)((*(void *)(a1 + 16) - v2) >> 2)) {
    __assert_rtn("decode", "LXCodebookCoder.cpp", 81, "false && \"Invalid index for meta flags codebook\"");
  }
  return *(unsigned int *)(v2 + 4 * a2);
}

void sub_19E0A9810(void *a1)
{
  *a1 = &unk_1EF09C5C0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0A9880(void *a1)
{
  *a1 = &unk_1EF09C5C0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

ssize_t sub_19E0A98D0(uint64_t a1, ssize_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
  unsigned int v7 = bswap32(v4);
  sub_19E0F185C(a2, (uint64_t)&v7, 4);
  uint64_t v5 = *(void *)(a1 + 32);

  return sub_19E0F185C(a2, v5, v4);
}

uint64_t sub_19E0A9940(uint64_t a1, __int32 a2)
{
  uint64_t v3 = *(__int32 **)(a1 + 32);
  uint64_t v4 = *(__int32 **)(a1 + 40);
  if (v3 == v4) {
    __assert_rtn("encode", "LXCodebookCoder.cpp", 48, "!m_flagsCodebook.empty()");
  }
  uint64_t v5 = wmemchr(v3, a2, v4 - v3);
  if (v5) {
    unint64_t v6 = v5;
  }
  else {
    unint64_t v6 = v4;
  }
  if (v6 == *(__int32 **)(a1 + 40)) {
    __assert_rtn("encode", "LXCodebookCoder.cpp", 51, "false && \"Unknown LXMetaFlags value\"");
  }
  return ((v6 - *(_DWORD *)(a1 + 32)) >> 2);
}

void sub_19E0A99DC(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (char **)(a1 + 4);
  if (a1[4] != a1[5]) {
    __assert_rtn("compile", "LXCodebookCoder.cpp", 36, "m_flagsCodebook.empty()");
  }
  unsigned __int8 v3 = atomic_load(byte_1E9457268);
  if (v3)
  {
    unsigned __int8 v4 = atomic_load(byte_1E94578A0);
    if (v4)
    {
      printf("Compiling %lu distinct metadata flags values", (uint64_t)(a1[2] - a1[1]) >> 4);
      putchar(10);
    }
    else
    {
      uint64_t v5 = sub_19E08D084();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = (uint64_t)(a1[2] - a1[1]) >> 4;
        *(_DWORD *)buf = 134217984;
        uint64_t v16 = v6;
        _os_log_impl(&dword_19E038000, v5, OS_LOG_TYPE_DEFAULT, "Compiling %lu distinct metadata flags values", buf, 0xCu);
      }
    }
  }
  uint64_t v7 = a1[1];
  unint64_t v8 = a1[2];
  unint64_t v9 = 126 - 2 * __clz((uint64_t)(v8 - v7) >> 4);
  if (v8 == v7) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v9;
  }
  sub_19E0A9B60(v7, v8, v10, 1);
  sub_19E0AA338(v1, (uint64_t)(a1[2] - a1[1]) >> 4);
  CFTypeRef v11 = (int *)a1[1];
  uint64_t v12 = (int *)a1[2];
  if (v11 != v12)
  {
    uint64_t v13 = *v1;
    do
    {
      int v14 = *v11;
      v11 += 4;
      *(_DWORD *)uint64_t v13 = v14;
      v13 += 4;
    }
    while (v11 != v12);
  }
}

uint64_t sub_19E0A9B60(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = (uint64_t)(a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unint64_t v44 = *(void *)(a2 - 8);
                unint64_t v45 = *(void *)(v10 + 8);
                if (v44 > v45)
                {
                  int v46 = *(_DWORD *)v10;
                  *(_DWORD *)unint64_t v10 = *(_DWORD *)(a2 - 16);
                  *(_DWORD *)(a2 - 16) = v46;
                  *(void *)(v10 + ++**(_DWORD **)(result + 8) = v44;
                  *(void *)(a2 - ++**(_DWORD **)(result + 8) = v45;
                }
                break;
              case 3uLL:
                __n128 result = (uint64_t)sub_19E0AA44C((int *)v10, (int *)(v10 + 16), (int *)(a2 - 16));
                break;
              case 4uLL:
                __n128 result = (uint64_t)sub_19E0AA504(v10, v10 + 16, v10 + 32, a2 - 16);
                break;
              case 5uLL:
                __n128 result = (uint64_t)sub_19E0AA504(v10, v10 + 16, v10 + 32, v10 + 48);
                unint64_t v47 = *(void *)(a2 - 8);
                unint64_t v48 = *(void *)(v10 + 56);
                if (v47 > v48)
                {
                  int v49 = *(_DWORD *)(v10 + 48);
                  *(_DWORD *)(v10 + 4++**(_DWORD **)(result + 8) = *(_DWORD *)(a2 - 16);
                  *(_DWORD *)(a2 - 16) = v49;
                  *(void *)(v10 + 56) = v47;
                  *(void *)(a2 - ++**(_DWORD **)(result + 8) = v48;
                  unint64_t v50 = *(void *)(v10 + 56);
                  unint64_t v51 = *(void *)(v10 + 40);
                  if (v50 > v51)
                  {
                    int v52 = *(_DWORD *)(v10 + 32);
                    int v53 = *(_DWORD *)(v10 + 48);
                    *(_DWORD *)(v10 + 32) = v53;
                    *(_DWORD *)(v10 + 4++**(_DWORD **)(result + 8) = v52;
                    *(void *)(v10 + 4sub_19E062044(&a9, 0) = v50;
                    *(void *)(v10 + 56) = v51;
                    unint64_t v54 = *(void *)(v10 + 24);
                    if (v50 > v54)
                    {
                      int v55 = *(_DWORD *)(v10 + 16);
                      *(_DWORD *)(v10 + 16) = v53;
                      *(_DWORD *)(v10 + 32) = v55;
                      *(void *)(v10 + 24) = v50;
                      *(void *)(v10 + 4sub_19E062044(&a9, 0) = v54;
                      unint64_t v56 = *(void *)(v10 + 8);
                      if (v50 > v56)
                      {
                        int v57 = *(_DWORD *)v10;
                        *(_DWORD *)unint64_t v10 = v53;
                        *(_DWORD *)(v10 + 16) = v57;
                        *(void *)(v10 + ++**(_DWORD **)(result + 8) = v50;
                        *(void *)(v10 + 24) = v56;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 383)
          {
            uint64_t v58 = (_DWORD *)(v10 + 16);
            BOOL v60 = v10 == a2 || v58 == (_DWORD *)a2;
            if (a4)
            {
              if (!v60)
              {
                uint64_t v61 = 0;
                uint64_t v62 = (_DWORD *)v10;
                do
                {
                  unint64_t v63 = *((void *)v62 + 3);
                  unint64_t v64 = *((void *)v62 + 1);
                  uint64_t v62 = v58;
                  if (v63 > v64)
                  {
                    int v65 = *v58;
                    uint64_t v66 = v61;
                    while (1)
                    {
                      uint64_t v67 = v10 + v66;
                      *(_DWORD *)(v67 + 16) = *(_DWORD *)(v10 + v66);
                      *(void *)(v67 + 24) = *(void *)(v10 + v66 + 8);
                      if (!v66) {
                        break;
                      }
                      v66 -= 16;
                      if (v63 <= *(void *)(v67 - 8))
                      {
                        uint64_t v68 = v10 + v66 + 16;
                        goto LABEL_85;
                      }
                    }
                    uint64_t v68 = v10;
LABEL_85:
                    *(_DWORD *)uint64_t v68 = v65;
                    *(void *)(v68 + ++**(_DWORD **)(result + 8) = v63;
                  }
                  uint64_t v58 = v62 + 4;
                  v61 += 16;
                }
                while (v62 + 4 != (_DWORD *)a2);
              }
            }
            else if (!v60)
            {
              unint64_t v97 = v10 + 8;
              do
              {
                unint64_t v98 = *(void *)(v9 + 24);
                unint64_t v99 = *(void *)(v9 + 8);
                unint64_t v9 = (unint64_t)v58;
                if (v98 > v99)
                {
                  int v100 = *v58;
                  unint64_t v101 = v97;
                  do
                  {
                    *(_DWORD *)(v101 + ++**(_DWORD **)(result + 8) = *(_DWORD *)(v101 - 8);
                    *(void *)(v101 + 16) = *(void *)v101;
                    unint64_t v102 = *(void *)(v101 - 16);
                    v101 -= 16;
                  }
                  while (v98 > v102);
                  *(_DWORD *)(v101 + ++**(_DWORD **)(result + 8) = v100;
                  *(void *)(v101 + 16) = v98;
                }
                uint64_t v58 = (_DWORD *)(v9 + 16);
                v97 += 16;
              }
              while (v9 + 16 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v69 = (v12 - 2) >> 1;
              int64_t v70 = v69;
              do
              {
                int64_t v71 = v70;
                if (v69 >= v70)
                {
                  uint64_t v72 = (2 * v70) | 1;
                  unint64_t v73 = v10 + 16 * v72;
                  if (2 * v71 + 2 < (uint64_t)v12)
                  {
                    BOOL v74 = *(void *)(v73 + 8) > *(void *)(v73 + 24);
                    v73 += 16 * v74;
                    if (v74) {
                      uint64_t v72 = 2 * v71 + 2;
                    }
                  }
                  unint64_t v75 = *(void *)(v73 + 8);
                  unint64_t v76 = *(void *)(v10 + 16 * v71 + 8);
                  if (v75 <= v76)
                  {
                    uint64_t v77 = v10 + 16 * v71;
                    int v78 = *(_DWORD *)v77;
                    do
                    {
                      __n128 result = v77;
                      uint64_t v77 = v73;
                      *(_DWORD *)__n128 result = *(_DWORD *)v73;
                      *(void *)(result + ++**(_DWORD **)(result + 8) = v75;
                      if (v69 < v72) {
                        break;
                      }
                      __n128 result = (2 * v72) | 1;
                      unint64_t v73 = v10 + 16 * result;
                      uint64_t v79 = 2 * v72 + 2;
                      if (v79 < (uint64_t)v12)
                      {
                        BOOL v74 = *(void *)(v73 + 8) > *(void *)(v73 + 24);
                        v73 += 16 * v74;
                        if (v74) {
                          __n128 result = v79;
                        }
                      }
                      unint64_t v75 = *(void *)(v73 + 8);
                      uint64_t v72 = result;
                    }
                    while (v75 <= v76);
                    *(_DWORD *)uint64_t v77 = v78;
                    *(void *)(v77 + ++**(_DWORD **)(result + 8) = v76;
                  }
                }
                int64_t v70 = v71 - 1;
              }
              while (v71);
              uint64_t v80 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v81 = 0;
                int v82 = *(_DWORD *)v10;
                uint64_t v83 = *(void *)(v10 + 8);
                unint64_t v84 = v10;
                do
                {
                  unint64_t v85 = v84 + 16 * (v81 + 1);
                  uint64_t v86 = (2 * v81) | 1;
                  uint64_t v87 = 2 * v81 + 2;
                  if (v87 < v80)
                  {
                    unint64_t v88 = *(void *)(v85 + 8);
                    unint64_t v89 = *(void *)(v85 + 24);
                    v85 += 16 * (v88 > v89);
                    if (v88 > v89) {
                      uint64_t v86 = v87;
                    }
                  }
                  *(_DWORD *)unint64_t v84 = *(_DWORD *)v85;
                  *(void *)(v84 + ++**(_DWORD **)(result + 8) = *(void *)(v85 + 8);
                  unint64_t v84 = v85;
                  uint64_t v81 = v86;
                }
                while (v86 <= (uint64_t)((unint64_t)(v80 - 2) >> 1));
                if (v85 == a2 - 16)
                {
                  *(_DWORD *)unint64_t v85 = v82;
                  *(void *)(v85 + ++**(_DWORD **)(result + 8) = v83;
                }
                else
                {
                  *(_DWORD *)unint64_t v85 = *(_DWORD *)(a2 - 16);
                  *(void *)(v85 + ++**(_DWORD **)(result + 8) = *(void *)(a2 - 8);
                  *(_DWORD *)(a2 - 16) = v82;
                  *(void *)(a2 - ++**(_DWORD **)(result + 8) = v83;
                  uint64_t v90 = v85 - v10 + 16;
                  if (v90 >= 17)
                  {
                    unint64_t v91 = (((unint64_t)v90 >> 4) - 2) >> 1;
                    unint64_t v92 = *(void *)(v10 + 16 * v91 + 8);
                    unint64_t v93 = *(void *)(v85 + 8);
                    if (v92 > v93)
                    {
                      int v94 = *(_DWORD *)v85;
                      do
                      {
                        unint64_t v95 = v91;
                        unint64_t v96 = v85;
                        unint64_t v85 = v10 + 16 * v95;
                        *(_DWORD *)unint64_t v96 = *(_DWORD *)v85;
                        *(void *)(v96 + ++**(_DWORD **)(result + 8) = v92;
                        if (!v95) {
                          break;
                        }
                        unint64_t v91 = (v95 - 1) >> 1;
                        unint64_t v92 = *(void *)(v10 + 16 * v91 + 8);
                      }
                      while (v92 > v93);
                      *(_DWORD *)unint64_t v85 = v94;
                      *(void *)(v10 + 16 * v95 + ++**(_DWORD **)(result + 8) = v93;
                    }
                  }
                }
                a2 -= 16;
                BOOL v74 = v80-- <= 2;
              }
              while (!v74);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 16 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x801)
          {
            sub_19E0AA44C((int *)v9, (int *)(v9 + 16 * (v12 >> 1)), (int *)(a2 - 16));
            sub_19E0AA44C((int *)(v9 + 16), (int *)(v14 - 16), (int *)(a2 - 32));
            sub_19E0AA44C((int *)(v9 + 32), (int *)(v9 + 16 + 16 * v13), (int *)(a2 - 48));
            __n128 result = (uint64_t)sub_19E0AA44C((int *)(v14 - 16), (int *)v14, (int *)(v9 + 16 + 16 * v13));
            int v15 = *(_DWORD *)v9;
            *(_DWORD *)unint64_t v9 = *(_DWORD *)v14;
            *(_DWORD *)unint64_t v14 = v15;
            uint64_t v16 = *(void *)(v9 + 8);
            *(void *)(v9 + ++**(_DWORD **)(result + 8) = *(void *)(v14 + 8);
            *(void *)(v14 + ++**(_DWORD **)(result + 8) = v16;
          }
          else
          {
            __n128 result = (uint64_t)sub_19E0AA44C((int *)(v9 + 16 * (v12 >> 1)), (int *)v9, (int *)(a2 - 16));
          }
          --a3;
          if (a4) {
            break;
          }
          unint64_t v17 = *(void *)(v9 + 8);
          if (*(void *)(v9 - 8) > v17) {
            goto LABEL_13;
          }
          if (v17 <= *(void *)(a2 - 8))
          {
            unint64_t v34 = v9 + 16;
            do
            {
              unint64_t v10 = v34;
              if (v34 >= a2) {
                break;
              }
              unint64_t v35 = *(void *)(v34 + 8);
              v34 += 16;
            }
            while (v17 <= v35);
          }
          else
          {
            unint64_t v32 = v9;
            do
            {
              unint64_t v10 = v32 + 16;
              unint64_t v33 = *(void *)(v32 + 24);
              v32 += 16;
            }
            while (v17 <= v33);
          }
          unint64_t v36 = a2;
          if (v10 < a2)
          {
            unint64_t v37 = a2;
            do
            {
              unint64_t v36 = v37 - 16;
              unint64_t v38 = *(void *)(v37 - 8);
              v37 -= 16;
            }
            while (v17 > v38);
          }
          int v39 = *(_DWORD *)v9;
          while (v10 < v36)
          {
            int v40 = *(_DWORD *)v10;
            *(_DWORD *)unint64_t v10 = *(_DWORD *)v36;
            *(_DWORD *)unint64_t v36 = v40;
            uint64_t v41 = *(void *)(v10 + 8);
            *(void *)(v10 + ++**(_DWORD **)(result + 8) = *(void *)(v36 + 8);
            *(void *)(v36 + ++**(_DWORD **)(result + 8) = v41;
            do
            {
              unint64_t v42 = *(void *)(v10 + 24);
              v10 += 16;
            }
            while (v17 <= v42);
            do
            {
              unint64_t v43 = *(void *)(v36 - 8);
              v36 -= 16;
            }
            while (v17 > v43);
          }
          BOOL v4 = v10 - 16 >= v9;
          BOOL v5 = v10 - 16 == v9;
          if (v10 - 16 != v9)
          {
            *(_DWORD *)unint64_t v9 = *(_DWORD *)(v10 - 16);
            *(void *)(v9 + ++**(_DWORD **)(result + 8) = *(void *)(v10 - 8);
          }
          a4 = 0;
          *(_DWORD *)(v10 - 16) = v39;
          *(void *)(v10 - ++**(_DWORD **)(result + 8) = v17;
        }
        unint64_t v17 = *(void *)(v9 + 8);
LABEL_13:
        int v18 = *(_DWORD *)v9;
        unint64_t v19 = v9;
        do
        {
          unint64_t v20 = v19;
          v19 += 16;
        }
        while (*(void *)(v20 + 24) > v17);
        unint64_t v21 = a2;
        if (v20 == v9)
        {
          unint64_t v24 = a2;
          while (v19 < v24)
          {
            unint64_t v22 = v24 - 16;
            unint64_t v25 = *(void *)(v24 - 8);
            v24 -= 16;
            if (v25 > v17) {
              goto LABEL_23;
            }
          }
          unint64_t v22 = v24;
        }
        else
        {
          do
          {
            unint64_t v22 = v21 - 16;
            unint64_t v23 = *(void *)(v21 - 8);
            v21 -= 16;
          }
          while (v23 <= v17);
        }
LABEL_23:
        unint64_t v10 = v19;
        if (v19 < v22)
        {
          unint64_t v26 = v22;
          do
          {
            int v27 = *(_DWORD *)v10;
            *(_DWORD *)unint64_t v10 = *(_DWORD *)v26;
            *(_DWORD *)unint64_t v26 = v27;
            uint64_t v28 = *(void *)(v10 + 8);
            *(void *)(v10 + ++**(_DWORD **)(result + 8) = *(void *)(v26 + 8);
            *(void *)(v26 + ++**(_DWORD **)(result + 8) = v28;
            do
            {
              unint64_t v29 = *(void *)(v10 + 24);
              v10 += 16;
            }
            while (v29 > v17);
            do
            {
              unint64_t v30 = *(void *)(v26 - 8);
              v26 -= 16;
            }
            while (v30 <= v17);
          }
          while (v10 < v26);
        }
        if (v10 - 16 != v9)
        {
          *(_DWORD *)unint64_t v9 = *(_DWORD *)(v10 - 16);
          *(void *)(v9 + ++**(_DWORD **)(result + 8) = *(void *)(v10 - 8);
        }
        *(_DWORD *)(v10 - 16) = v18;
        *(void *)(v10 - ++**(_DWORD **)(result + 8) = v17;
        if (v19 >= v22) {
          break;
        }
LABEL_34:
        __n128 result = sub_19E0A9B60(v9, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v31 = sub_19E0AA5B4(v9, v10 - 16);
      __n128 result = sub_19E0AA5B4(v10, a2);
      if (result) {
        break;
      }
      if (!v31) {
        goto LABEL_34;
      }
    }
    a2 = v10 - 16;
    if (!v31) {
      continue;
    }
    return result;
  }
}

void sub_19E0AA338(char **a1, unint64_t a2)
{
  unsigned __int8 v3 = *a1;
  BOOL v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 2;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    unint64_t v19 = &v3[4 * a2];
    goto LABEL_15;
  }
  unint64_t v6 = a2 - v5;
  uint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 2)
  {
    bzero(a1[1], 4 * v6);
    unint64_t v19 = &v4[4 * v6];
LABEL_15:
    a1[1] = v19;
    return;
  }
  if (a2 >> 62) {
    sub_19E041BEC();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 1;
  if (v8 >> 1 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v10 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  uint64_t v11 = (char *)sub_19E068D84(v10);
  unint64_t v12 = *a1;
  unint64_t v13 = a1[1];
  unint64_t v14 = &v11[4 * v5];
  uint64_t v16 = &v11[4 * v15];
  bzero(v14, 4 * v6);
  unint64_t v17 = &v14[4 * v6];
  while (v13 != v12)
  {
    int v18 = *((_DWORD *)v13 - 1);
    v13 -= 4;
    *((_DWORD *)v14 - 1) = v18;
    v14 -= 4;
  }
  *a1 = v14;
  a1[1] = v17;
  a1[2] = v16;
  if (v12)
  {
    operator delete(v12);
  }
}

int *sub_19E0AA44C(int *result, int *a2, int *a3)
{
  unint64_t v3 = *((void *)a2 + 1);
  unint64_t v4 = *((void *)result + 1);
  unint64_t v5 = *((void *)a3 + 1);
  if (v3 <= v4)
  {
    if (v5 > v3)
    {
      int v7 = *a2;
      *a2 = *a3;
      *a3 = v7;
      *((void *)a2 + 1) = v5;
      *((void *)a3 + 1) = v3;
      unint64_t v8 = *((void *)a2 + 1);
      unint64_t v9 = *((void *)result + 1);
      if (v8 > v9)
      {
        int v10 = *result;
        *__n128 result = *a2;
        *a2 = v10;
        *((void *)result + 1) = v8;
        *((void *)a2 + 1) = v9;
      }
    }
  }
  else
  {
    int v6 = *result;
    if (v5 <= v3)
    {
      *__n128 result = *a2;
      *a2 = v6;
      *((void *)result + 1) = v3;
      *((void *)a2 + 1) = v4;
      unint64_t v11 = *((void *)a3 + 1);
      if (v11 <= v4) {
        return result;
      }
      *a2 = *a3;
      *a3 = v6;
      *((void *)a2 + 1) = v11;
    }
    else
    {
      *__n128 result = *a3;
      *a3 = v6;
      *((void *)result + 1) = v5;
    }
    *((void *)a3 + 1) = v4;
  }
  return result;
}

int *sub_19E0AA504(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result = sub_19E0AA44C((int *)a1, (int *)a2, (int *)a3);
  unint64_t v9 = *(void *)(a4 + 8);
  unint64_t v10 = *(void *)(a3 + 8);
  if (v9 > v10)
  {
    int v11 = *(_DWORD *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(_DWORD *)a4 = v11;
    *(void *)(a3 + ++**(_DWORD **)(result + 8) = v9;
    *(void *)(a4 + ++**(_DWORD **)(result + 8) = v10;
    unint64_t v12 = *(void *)(a3 + 8);
    unint64_t v13 = *(void *)(a2 + 8);
    if (v12 > v13)
    {
      int v14 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v14;
      *(void *)(a2 + ++**(_DWORD **)(result + 8) = v12;
      *(void *)(a3 + ++**(_DWORD **)(result + 8) = v13;
      unint64_t v15 = *(void *)(a2 + 8);
      unint64_t v16 = *(void *)(a1 + 8);
      if (v15 > v16)
      {
        int v17 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v17;
        *(void *)(a1 + ++**(_DWORD **)(result + 8) = v15;
        *(void *)(a2 + ++**(_DWORD **)(result + 8) = v16;
      }
    }
  }
  return result;
}

BOOL sub_19E0AA5B4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *(void *)(a2 - 8);
      unint64_t v7 = *(void *)(a1 + 8);
      if (v6 > v7)
      {
        int v8 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v8;
        *(void *)(a1 + ++**(_DWORD **)(result + 8) = v6;
        *(void *)(a2 - ++**(_DWORD **)(result + 8) = v7;
      }
      return result;
    case 3:
      sub_19E0AA44C((int *)a1, (int *)(a1 + 16), (int *)(a2 - 16));
      return 1;
    case 4:
      sub_19E0AA504(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      sub_19E0AA504(a1, a1 + 16, a1 + 32, a1 + 48);
      unint64_t v18 = *(void *)(a2 - 8);
      unint64_t v19 = *(void *)(a1 + 56);
      if (v18 > v19)
      {
        int v20 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)(a1 + 4++**(_DWORD **)(result + 8) = *(_DWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v20;
        *(void *)(a1 + 56) = v18;
        *(void *)(a2 - ++**(_DWORD **)(result + 8) = v19;
        unint64_t v21 = *(void *)(a1 + 56);
        unint64_t v22 = *(void *)(a1 + 40);
        if (v21 > v22)
        {
          int v23 = *(_DWORD *)(a1 + 32);
          int v24 = *(_DWORD *)(a1 + 48);
          *(_DWORD *)(a1 + 32) = v24;
          *(_DWORD *)(a1 + 4++**(_DWORD **)(result + 8) = v23;
          *(void *)(a1 + 4sub_19E062044(&a9, 0) = v21;
          *(void *)(a1 + 56) = v22;
          unint64_t v25 = *(void *)(a1 + 24);
          if (v21 > v25)
          {
            int v26 = *(_DWORD *)(a1 + 16);
            *(_DWORD *)(a1 + 16) = v24;
            *(_DWORD *)(a1 + 32) = v26;
            *(void *)(a1 + 24) = v21;
            *(void *)(a1 + 4sub_19E062044(&a9, 0) = v25;
            unint64_t v27 = *(void *)(a1 + 8);
            if (v21 > v27)
            {
              int v28 = *(_DWORD *)a1;
              *(_DWORD *)a1 = v24;
              *(_DWORD *)(a1 + 16) = v28;
              *(void *)(a1 + ++**(_DWORD **)(result + 8) = v21;
              *(void *)(a1 + 24) = v27;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v9 = a1 + 32;
      sub_19E0AA44C((int *)a1, (int *)(a1 + 16), (int *)(a1 + 32));
      uint64_t v10 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    unint64_t v13 = *(void *)(v10 + 8);
    if (v13 > *(void *)(v9 + 8))
    {
      int v14 = *(_DWORD *)v10;
      uint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        *(_DWORD *)(v16 + 4++**(_DWORD **)(result + 8) = *(_DWORD *)(a1 + v15 + 32);
        *(void *)(v16 + 56) = *(void *)(a1 + v15 + 40);
        if (v15 == -32) {
          break;
        }
        v15 -= 16;
        if (v13 <= *(void *)(v16 + 24))
        {
          uint64_t v17 = a1 + v15 + 48;
          goto LABEL_13;
        }
      }
      uint64_t v17 = a1;
LABEL_13:
      *(_DWORD *)uint64_t v17 = v14;
      *(void *)(v17 + ++**(_DWORD **)(result + 8) = v13;
      if (++v12 == 8) {
        return v10 + 16 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2) {
      return 1;
    }
  }
}

uint64_t sub_19E0AA7E8(uint64_t a1)
{
  return (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 4;
}

void sub_19E0AA7F8(void *a1, int a2)
{
  if (a1[4] != a1[5]) {
    __assert_rtn("train", "LXCodebookCoder.cpp", 19, "false && \"Metaflags codebook has already been compiled\"");
  }
  uint64_t v4 = (char *)a1[1];
  unint64_t v5 = (char *)a1[2];
  unint64_t v6 = v4;
  if (v4 != v5)
  {
    unint64_t v6 = (char *)a1[1];
    while (*(_DWORD *)v6 != a2)
    {
      v6 += 16;
      if (v6 == v5) {
        goto LABEL_9;
      }
    }
  }
  if (v6 == v5)
  {
LABEL_9:
    unint64_t v7 = a1[3];
    if ((unint64_t)v5 >= v7)
    {
      uint64_t v9 = (v5 - v4) >> 4;
      unint64_t v10 = v9 + 1;
      if ((unint64_t)(v9 + 1) >> 60) {
        sub_19E041BEC();
      }
      uint64_t v11 = v7 - (void)v4;
      if (v11 >> 3 > v10) {
        unint64_t v10 = v11 >> 3;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v10;
      }
      if (v12 >> 60) {
        sub_19E0416C4();
      }
      unint64_t v13 = (char *)operator new(16 * v12);
      int v14 = &v13[16 * v9];
      *(_DWORD *)int v14 = a2;
      *((void *)v14 + 1) = 1;
      int v8 = v14 + 16;
      if (v4 == v5)
      {
        uint64_t v15 = &v13[16 * v9];
      }
      else
      {
        do
        {
          uint64_t v15 = v14 - 16;
          *((_OWORD *)v14 - 1) = *((_OWORD *)v5 - 1);
          v5 -= 16;
          v14 -= 16;
        }
        while (v5 != v4);
      }
      a1[1] = v15;
      a1[2] = v8;
      a1[3] = &v13[16 * v12];
      if (v4) {
        operator delete(v4);
      }
    }
    else
    {
      *(_DWORD *)unint64_t v5 = a2;
      *((void *)v5 + 1) = 1;
      int v8 = v5 + 16;
    }
    a1[2] = v8;
    unint64_t v5 = v8;
  }
  else
  {
    ++*((void *)v6 + 1);
  }
  if ((unint64_t)&v5[-a1[1]] >= 0xFF1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E0413C8(&v17, "Too many metadata flag combinations to encode as an 8-bit integer");
    sub_19E08DA70(exception, &v17);
    __cxa_throw(exception, (struct type_info *)&unk_1EF09B3A0, (void (*)(void *))sub_19E08DB60);
  }
}

void sub_19E0AA9DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void sub_19E0AAA14(void *a1)
{
  *a1 = &unk_1EF09C5E8;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }

  JUMPOUT(0x19F3BA710);
}

void *sub_19E0AAA94(void *a1)
{
  *a1 = &unk_1EF09C5E8;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void *sub_19E0AAAF4(void *a1, uint64_t *a2)
{
  *a1 = &unk_1EF09C5C0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  unint64_t v3 = a2[1];
  uint64_t v4 = a2[2];
  unint64_t v5 = v4 + 4;
  if (v3) {
    BOOL v6 = v5 > v3;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6 || (uint64_t v7 = *a2, a2[2] = v5, !v7))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E0413C8(&v14, "Corrupt input stream: failed to read meta flags codebook length");
    sub_19E0A34B4(exception, &v14);
    __cxa_throw(exception, (struct type_info *)&unk_1EF09ADF8, (void (*)(void *))sub_19E0A3530);
  }
  uint64_t v8 = bswap32(*(_DWORD *)(v7 + v4));
  if (v3 && v5 + v8 > v3)
  {
    unint64_t v13 = __cxa_allocate_exception(0x20uLL);
    sub_19E0413C8(&v14, "Corrupt input stream: cannot read meta flags codebook");
    sub_19E0A34B4(v13, &v14);
    __cxa_throw(v13, (struct type_info *)&unk_1EF09ADF8, (void (*)(void *))sub_19E0A3530);
  }
  uint64_t v9 = v8 >> 2;
  if (v8 > 3)
  {
    sub_19E08C178(a1 + 1, v8 >> 2);
    unint64_t v10 = (char *)a1[2];
    memmove(v10, (const void *)(v7 + v5), 4 * v9);
  }
  else
  {
    unint64_t v10 = 0;
  }
  a1[2] = &v10[4 * v9];
  return a1;
}

void sub_19E0AAC74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  unint64_t v18 = *v16;
  if (*v16)
  {
    *(void *)(v15 + 16) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E0AACCC(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  uint64_t v3 = *(void *)(a1 + 120);
  if (*(void *)(v3 + 56))
  {
    (*(void (**)(void))(**(void **)(v3 + 64) + 40))(*(void *)(v3 + 64));
    sub_19E091544(*(void *)(v3 + 56));
    if (*(void *)(v3 + 32)) {
      unint64_t v5 = *(const std::__fs::filesystem::path **)(v3 + 32);
    }
    else {
      unint64_t v5 = (const std::__fs::filesystem::path *)(v3 + 40);
    }
    remove(v5, v4);
    *(unsigned char *)(v3 + 16) = 1;
  }
  if (*(void *)(a1 + 1584))
  {
    sub_19E0AADB8(*(void **)(a1 + 1576));
    *(void *)(a1 + 1576) = 0;
    uint64_t v6 = *(void *)(a1 + 1568);
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
        *(void *)(*(void *)(a1 + 1560) + 8 * i) = 0;
    }
    *(void *)(a1 + 1584) = 0;
  }

  std::mutex::unlock(v2);
}

void sub_19E0AADA4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E0AADB8(void *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      uint64_t v2 = v1;
      uint64_t v1 = (void *)*v1;
      uint64_t v3 = (void *)v2[4];
      if (v3)
      {
        if (*((unsigned char *)v2 + 30) == 1) {
          free(v3);
        }
      }
      operator delete(v2);
    }
    while (v1);
  }
}

BOOL sub_19E0AAE0C(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v13 = a2;
  uint64_t v4 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  unint64_t v5 = sub_19E08C5B8((void *)(a1 + 1560), a2);
  if (v5)
  {
    uint64_t v6 = (char *)sub_19E0AAFBC(a1 + 1560, a2, &v13);
    sub_19E0AB210(*(void *)(a1 + 120), v6 + 24);
    sub_19E03FC9C();
    uint64_t v7 = qword_1EB4FED50;
    if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *(void *)(a1 + 80);
      unint64_t v10 = sub_19E0AAFBC(a1 + 1560, a2, &v13);
      uint64_t v11 = a1 + 88;
      if (v9) {
        uint64_t v11 = v9;
      }
      unint64_t v12 = (void *)v10[4];
      if (!v12) {
        unint64_t v12 = v10 + 5;
      }
      *(_DWORD *)buf = 136315394;
      uint64_t v15 = v11;
      __int16 v16 = 2080;
      long long v17 = v12;
      _os_log_debug_impl(&dword_19E038000, v7, OS_LOG_TYPE_DEBUG, "%s: removed '%s'", buf, 0x16u);
    }
    sub_19E0AB2BC((void *)(a1 + 1560), a2);
    (*(void (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 120) + 64) + 32))(*(void *)(*(void *)(a1 + 120) + 64), a2);
  }
  std::mutex::unlock(v4);
  return v5 != 0;
}

void sub_19E0AAFA0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void *sub_19E0AAFBC(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v12 = (void *)(a1 + 16);
  unint64_t v10 = operator new(0x38uLL);
  v23[0] = (uint64_t)v10;
  v23[1] = a1 + 16;
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 6) = 0x100000;
  *((_WORD *)v10 + 14) = 0;
  *((unsigned char *)v10 + 3sub_19E062044(&a9, 0) = 0;
  v10[4] = 0;
  *((unsigned char *)v10 + 4sub_19E062044(&a9, 0) = 0;
  char v24 = 1;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_19E08A5BC(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v19 = *(void *)a1;
  int v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    *unint64_t v10 = *v20;
LABEL_38:
    void *v20 = v10;
    goto LABEL_39;
  }
  *unint64_t v10 = *v12;
  void *v12 = v10;
  *(void *)(v19 + 8 * v3) = v12;
  if (*v10)
  {
    unint64_t v21 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    int v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  v23[0] = 0;
  ++*(void *)(a1 + 24);
  sub_19E0AB424(v23);
  return v10;
}

void sub_19E0AB1FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E0AB424((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_19E0AB210(uint64_t a1, char *a2)
{
  _OWORD v4[4] = *MEMORY[0x1E4F143B8];
  v4[0] = &unk_1EF09A278;
  v4[3] = v4;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {
    *(unsigned char *)(a1 + 16) = 1;
    sub_19E0911C4(v2, a2, (uint64_t)v4);
  }
  return sub_19E0AB4F8(v4);
}

void sub_19E0AB2A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E0AB4F8((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E0AB2BC(void *a1, unsigned int a2)
{
  unint64_t v3 = sub_19E08C5B8(a1, a2);
  if (v3)
  {
    int8x8_t v4 = (int8x8_t)a1[1];
    unint64_t v5 = v3[1];
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      if (v5 >= *(void *)&v4) {
        v5 %= *(void *)&v4;
      }
    }
    else
    {
      v5 &= *(void *)&v4 - 1;
    }
    unint64_t v7 = *(uint64_t **)(*a1 + 8 * v5);
    do
    {
      uint8x8_t v8 = v7;
      unint64_t v7 = (uint64_t *)*v7;
    }
    while (v7 != v3);
    if (v8 == a1 + 2) {
      goto LABEL_19;
    }
    unint64_t v9 = v8[1];
    if (v6.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v4) {
        v9 %= *(void *)&v4;
      }
    }
    else
    {
      v9 &= *(void *)&v4 - 1;
    }
    if (v9 != v5)
    {
LABEL_19:
      if (!*v3) {
        goto LABEL_20;
      }
      unint64_t v10 = *(void *)(*v3 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(void *)&v4) {
          v10 %= *(void *)&v4;
        }
      }
      else
      {
        v10 &= *(void *)&v4 - 1;
      }
      if (v10 != v5) {
LABEL_20:
      }
        *(void *)(*a1 + 8 * v5) = 0;
    }
    uint64_t v11 = *v3;
    if (*v3)
    {
      unint64_t v12 = *(void *)(v11 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v12 >= *(void *)&v4) {
          v12 %= *(void *)&v4;
        }
      }
      else
      {
        v12 &= *(void *)&v4 - 1;
      }
      if (v12 != v5)
      {
        *(void *)(*a1 + 8 * v12) = v8;
        uint64_t v11 = *v3;
      }
    }
    *uint8x8_t v8 = v11;
    uint64_t *v3 = 0;
    --a1[3];
    v13[0] = (uint64_t)v3;
    v13[1] = (uint64_t)(a1 + 2);
    char v14 = 1;
    sub_19E0AB424(v13);
  }
}

void sub_19E0AB424(uint64_t *a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v2 = *(void **)(v1 + 32);
      if (v2)
      {
        if (*(unsigned char *)(v1 + 30) == 1) {
          free(v2);
        }
      }
    }
    operator delete((void *)v1);
  }
}

void sub_19E0AB48C()
{
  sub_19E0413C8(__p, "Mutable");
  if (v2 >= 0) {
    uint64_t v0 = __p;
  }
  else {
    uint64_t v0 = (void **)__p[0];
  }
  qword_1EB4FED50 = (uint64_t)os_log_create("com.apple.Lexicon", (const char *)v0);
  if (v2 < 0) {
    operator delete(__p[0]);
  }
}

void *sub_19E0AB4F8(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_19E0AB57C()
{
  return &unk_1EF099698;
}

uint64_t sub_19E0AB588(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF099698)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_19E0AB5C8(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_19E0AB5D8(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF09A278;
}

void *sub_19E0AB5F8()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1EF09A278;
  return result;
}

void sub_19E0AB630()
{
}

void sub_19E0AB648(uint64_t a1, const __CFString *a2, int a3)
{
  uint64_t v21[2] = *MEMORY[0x1E4F143B8];
  int v12 = a3;
  unint64_t v5 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  sub_19E03F0BC((uint64_t)v19, a2);
  uint64_t v6 = *(void *)(a1 + 120);
  unint64_t v7 = operator new(0x20uLL);
  void *v7 = &unk_1EF09A118;
  v7[1] = &v12;
  void v7[2] = a1;
  _WORD v7[3] = v19;
  *(void *)&v18[4] = v7;
  uint64_t v8 = *(void *)(v6 + 56);
  if (v8)
  {
    *(unsigned char *)(v6 + 16) = 1;
    sub_19E0911C4(v8, v19, (uint64_t)buf);
  }
  sub_19E0AB4F8(buf);
  sub_19E03FC9C();
  unint64_t v9 = qword_1EB4FED50;
  if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = *(void *)(a1 + 80);
    if (!v10) {
      uint64_t v10 = a1 + 88;
    }
    uint64_t v11 = v20;
    if (!v20) {
      uint64_t v11 = v21;
    }
    *(_DWORD *)buf = 136315650;
    uint64_t v14 = v10;
    __int16 v15 = 1024;
    int v16 = v12;
    __int16 v17 = 2080;
    *(void *)size_t v18 = v11;
    _os_log_debug_impl(&dword_19E038000, v9, OS_LOG_TYPE_DEBUG, "%s: updated user bitfield to %u for '%s'", buf, 0x1Cu);
  }
  if (v20 && v19[6] == 1) {
    free(v20);
  }
  std::mutex::unlock(v5);
}

void sub_19E0AB7D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, void *a19)
{
  sub_19E0AB4F8(&a11);
  if (a19)
  {
    if (a18 == 1) {
      free(a19);
    }
  }
  std::mutex::unlock(v19);
  _Unwind_Resume(a1);
}

void *sub_19E0AB81C()
{
  return &unk_1EF099658;
}

uint64_t sub_19E0AB828(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF099658)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_19E0AB868(uint64_t a1, void *a2)
{
  if (*a2)
  {
    sub_19E0AB994();
  }
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 16) + 120) + 64);
  (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *(void *)(a1 + 24));
  CFAbsoluteTimeGetCurrent();
  sub_19E0AB994();
}

void sub_19E0AB97C(_Unwind_Exception *a1)
{
  sub_19E08F0D0(v1);
  _Unwind_Resume(a1);
}

void sub_19E0AB994()
{
}

void sub_19E0ABA3C(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BA710](v1, 0x1010C403B695573);
  _Unwind_Resume(a1);
}

void *sub_19E0ABA60(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  int v12 = (void *)(a1 + 16);
  uint64_t v10 = operator new(0x38uLL);
  v23[0] = (uint64_t)v10;
  v23[1] = a1 + 16;
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 6) = 0x100000;
  *((_WORD *)v10 + 14) = 0;
  *((unsigned char *)v10 + 3sub_19E062044(&a9, 0) = 0;
  v10[4] = 0;
  *((unsigned char *)v10 + 4sub_19E062044(&a9, 0) = 0;
  char v24 = 1;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_19E08A5BC(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v19 = *(void *)a1;
  int v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    *uint64_t v10 = *v20;
LABEL_38:
    void *v20 = v10;
    goto LABEL_39;
  }
  *uint64_t v10 = *v12;
  void *v12 = v10;
  *(void *)(v19 + 8 * v3) = v12;
  if (*v10)
  {
    unint64_t v21 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    int v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  v23[0] = 0;
  ++*(void *)(a1 + 24);
  sub_19E0AB424(v23);
  return v10;
}

void sub_19E0ABCA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E0AB424((uint64_t *)va);
  _Unwind_Resume(a1);
}

__n128 sub_19E0ABCBC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09A118;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E0ABCEC(uint64_t a1)
{
  char v2 = (char *)operator new(0x20uLL);
  *(void *)char v2 = &unk_1EF09A118;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++**(_DWORD **)(result + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E0ABD40()
{
}

void sub_19E0ABD58(uint64_t a1, const __CFString *a2, int a3)
{
  uint64_t v21[2] = *MEMORY[0x1E4F143B8];
  int v12 = a3;
  unint64_t v5 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  sub_19E03F0BC((uint64_t)v19, a2);
  uint64_t v6 = *(void *)(a1 + 120);
  unint64_t v7 = operator new(0x20uLL);
  void *v7 = &unk_1EF09A170;
  v7[1] = &v12;
  void v7[2] = a1;
  _WORD v7[3] = v19;
  *(void *)&v18[4] = v7;
  uint64_t v8 = *(void *)(v6 + 56);
  if (v8)
  {
    *(unsigned char *)(v6 + 16) = 1;
    sub_19E0911C4(v8, v19, (uint64_t)buf);
  }
  sub_19E0AB4F8(buf);
  sub_19E03FC9C();
  unint64_t v9 = qword_1EB4FED50;
  if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = *(void *)(a1 + 80);
    if (!v10) {
      uint64_t v10 = a1 + 88;
    }
    unint64_t v11 = v20;
    if (!v20) {
      unint64_t v11 = v21;
    }
    *(_DWORD *)buf = 136315650;
    uint64_t v14 = v10;
    __int16 v15 = 1024;
    int v16 = v12;
    __int16 v17 = 2080;
    *(void *)size_t v18 = v11;
    _os_log_debug_impl(&dword_19E038000, v9, OS_LOG_TYPE_DEBUG, "%s: updated meta flags to %u for '%s'", buf, 0x1Cu);
  }
  if (v20 && v19[6] == 1) {
    free(v20);
  }
  std::mutex::unlock(v5);
}

void sub_19E0ABEE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, void *a19)
{
  sub_19E0AB4F8(&a11);
  if (a19)
  {
    if (a18 == 1) {
      free(a19);
    }
  }
  std::mutex::unlock(v19);
  _Unwind_Resume(a1);
}

void *sub_19E0ABF2C()
{
  return &unk_1EF099668;
}

uint64_t sub_19E0ABF38(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF099668)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_19E0ABF78(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  if (*a2)
  {
    sub_19E0AB994();
  }
  sub_19E0D7B68(a3, *(void *)(*(void *)(*(void *)(a1 + 16) + 120) + 64), *(void *)(a1 + 24));
}

void sub_19E0AC040(_Unwind_Exception *a1)
{
  sub_19E08F0D0(v1);
  _Unwind_Resume(a1);
}

__n128 sub_19E0AC060(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09A170;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E0AC090(uint64_t a1)
{
  char v2 = (char *)operator new(0x20uLL);
  *(void *)char v2 = &unk_1EF09A170;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++**(_DWORD **)(result + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E0AC0E4()
{
}

void sub_19E0AC0FC(uint64_t a1, const __CFString *a2, int a3)
{
  uint64_t v21[2] = *MEMORY[0x1E4F143B8];
  int v12 = a3;
  unint64_t v5 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  sub_19E03F0BC((uint64_t)v19, a2);
  uint64_t v6 = *(void *)(a1 + 120);
  unint64_t v7 = operator new(0x20uLL);
  void *v7 = &unk_1EF09A220;
  v7[1] = &v12;
  void v7[2] = a1;
  _WORD v7[3] = v19;
  *(void *)&v18[4] = v7;
  uint64_t v8 = *(void *)(v6 + 56);
  if (v8)
  {
    *(unsigned char *)(v6 + 16) = 1;
    sub_19E0911C4(v8, v19, (uint64_t)buf);
  }
  sub_19E0AB4F8(buf);
  sub_19E03FC9C();
  unint64_t v9 = qword_1EB4FED50;
  if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = *(void *)(a1 + 80);
    if (!v10) {
      uint64_t v10 = a1 + 88;
    }
    unint64_t v11 = v20;
    if (!v20) {
      unint64_t v11 = v21;
    }
    *(_DWORD *)buf = 136315650;
    uint64_t v14 = v10;
    __int16 v15 = 1024;
    int v16 = v12;
    __int16 v17 = 2080;
    *(void *)size_t v18 = v11;
    _os_log_debug_impl(&dword_19E038000, v9, OS_LOG_TYPE_DEBUG, "%s: incremented penalty count by %d for '%s'", buf, 0x1Cu);
  }
  if (v20 && v19[6] == 1) {
    free(v20);
  }
  std::mutex::unlock(v5);
}

void sub_19E0AC288(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, void *a19)
{
  sub_19E0AB4F8(&a11);
  if (a19)
  {
    if (a18 == 1) {
      free(a19);
    }
  }
  std::mutex::unlock(v19);
  _Unwind_Resume(a1);
}

void *sub_19E0AC2D0()
{
  return &unk_1EF099688;
}

uint64_t sub_19E0AC2DC(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF099688)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_19E0AC31C(uint64_t a1, void *a2)
{
  if (*a2)
  {
    sub_19E0AB994();
  }
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 16) + 120) + 64);
  if ((*(unsigned int (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *(void *)(a1 + 24)))
  {
    CFAbsoluteTimeGetCurrent();
    sub_19E0AB994();
  }
  __assert_rtn("make_entry", "TIDynamicDictionaryImpl.cpp", 635, "tokenID != kLXTokenIDUNK && \"generated an invalid tokenID\"");
}

void sub_19E0AC45C(_Unwind_Exception *a1)
{
  sub_19E08F0D0(v1);
  _Unwind_Resume(a1);
}

__n128 sub_19E0AC47C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09A220;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E0AC4AC(uint64_t a1)
{
  char v2 = (char *)operator new(0x20uLL);
  *(void *)char v2 = &unk_1EF09A220;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++**(_DWORD **)(result + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E0AC500()
{
}

void sub_19E0AC518(uint64_t a1, const __CFString *a2, int a3)
{
  uint64_t v21[2] = *MEMORY[0x1E4F143B8];
  int v12 = a3;
  unint64_t v5 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  sub_19E03F0BC((uint64_t)v19, a2);
  uint64_t v6 = *(void *)(a1 + 120);
  unint64_t v7 = operator new(0x20uLL);
  void *v7 = &unk_1EF09A1C8;
  v7[1] = &v12;
  void v7[2] = a1;
  _WORD v7[3] = v19;
  *(void *)&v18[4] = v7;
  uint64_t v8 = *(void *)(v6 + 56);
  if (v8)
  {
    *(unsigned char *)(v6 + 16) = 1;
    sub_19E0911C4(v8, v19, (uint64_t)buf);
  }
  sub_19E0AB4F8(buf);
  sub_19E03FC9C();
  unint64_t v9 = qword_1EB4FED50;
  if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = *(void *)(a1 + 80);
    if (!v10) {
      uint64_t v10 = a1 + 88;
    }
    unint64_t v11 = v20;
    if (!v20) {
      unint64_t v11 = v21;
    }
    *(_DWORD *)buf = 136315650;
    uint64_t v14 = v10;
    __int16 v15 = 1024;
    int v16 = v12;
    __int16 v17 = 2080;
    *(void *)size_t v18 = v11;
    _os_log_debug_impl(&dword_19E038000, v9, OS_LOG_TYPE_DEBUG, "%s: incremented usage count by %d for '%s'", buf, 0x1Cu);
  }
  if (v20 && v19[6] == 1) {
    free(v20);
  }
  std::mutex::unlock(v5);
}

void sub_19E0AC6A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, void *a19)
{
  sub_19E0AB4F8(&a11);
  if (a19)
  {
    if (a18 == 1) {
      free(a19);
    }
  }
  std::mutex::unlock(v19);
  _Unwind_Resume(a1);
}

void *sub_19E0AC6EC()
{
  return &unk_1EF099678;
}

uint64_t sub_19E0AC6F8(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF099678)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_19E0AC738(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  if (*a2)
  {
    sub_19E0AB994();
  }
  sub_19E0D7B68(a3, *(void *)(*(void *)(*(void *)(a1 + 16) + 120) + 64), *(void *)(a1 + 24));
}

void sub_19E0AC804(_Unwind_Exception *a1)
{
  sub_19E08F0D0(v1);
  _Unwind_Resume(a1);
}

__n128 sub_19E0AC824(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09A1C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E0AC854(uint64_t a1)
{
  char v2 = (char *)operator new(0x20uLL);
  *(void *)char v2 = &unk_1EF09A1C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++**(_DWORD **)(result + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E0AC8A8()
{
}

uint64_t sub_19E0AC8C0(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a2;
  int v16 = a3;
  double v15 = a4;
  unint64_t v7 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 120) + 64) + 24))(*(void *)(*(void *)(a1 + 120) + 64), a3);
  if (v8)
  {
    CFStringRef v9 = (const __CFString *)LXEntryCopyString(a2);
    sub_19E03F0BC((uint64_t)v19, v9);
    uint64_t v10 = sub_19E0AAFBC(a1 + 1560, a3, &v16);
    sub_19E03CD54((uint64_t)(v10 + 3), v19);
    uint64_t v11 = *(void *)(a1 + 120);
    int v12 = operator new(0x28uLL);
    void *v12 = &unk_1EF09A0C0;
    v12[1] = v19;
    uint64_t v12[2] = &v16;
    unsigned __int16 v12[3] = &v17;
    v12[4] = &v15;
    _OWORD v18[3] = v12;
    uint64_t v13 = *(void *)(v11 + 56);
    if (v13)
    {
      *(unsigned char *)(v11 + 16) = 1;
      sub_19E0911C4(v13, (char *)v19, (uint64_t)v18);
    }
    sub_19E0AB4F8(v18);
    if (v21 && v20 == 1) {
      free(v21);
    }
    if (v9) {
      CFRelease(v9);
    }
  }
  std::mutex::unlock(v7);
  return v8;
}

void sub_19E0ACA4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,void *a21)
{
  if (a2) {
    sub_19E04137C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E0ACABC()
{
  return &unk_1EF099648;
}

uint64_t sub_19E0ACAC8(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF099648)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_19E0ACB08(uint64_t a1)
{
  if (**(void **)(a1 + 24))
  {
    sub_19E0AB994();
  }
  __assert_rtn("LXEntryGetMetaFlags", "LXEntry.cpp", 45, "entry");
}

__n128 sub_19E0ACB8C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09A0C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E0ACBBC(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = &unk_1EF09A0C0;
  *(_OWORD *)(v2 + ++**(_DWORD **)(result + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_19E0ACC10()
{
}

uint64_t sub_19E0ACC28(uint64_t a1, const __CFString *a2, int a3)
{
  double Current = CFAbsoluteTimeGetCurrent();

  return sub_19E0ACC78(a1, a2, a3, Current);
}

uint64_t sub_19E0ACC78(uint64_t a1, const __CFString *a2, int a3, double a4)
{
  int v34[2] = *MEMORY[0x1E4F143B8];
  double v24 = a4;
  int v23 = a3;
  uint64_t v6 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  unsigned int v22 = 0;
  char v21 = 1;
  sub_19E03F0BC((uint64_t)v31, a2);
  uint64_t v7 = *(void *)(a1 + 120);
  uint64_t v8 = operator new(0x38uLL);
  *uint64_t v8 = &unk_1EF09ACA8;
  v8[1] = &v21;
  void v8[2] = a1;
  long long v8[3] = v31;
  _OWORD v8[4] = &v23;
  void v8[5] = &v24;
  v8[6] = &v22;
  unint64_t v30 = v8;
  uint64_t v9 = *(void *)(v7 + 56);
  if (v9)
  {
    *(unsigned char *)(v7 + 16) = 1;
    sub_19E0911C4(v9, (char *)v31, (uint64_t)buf);
  }
  sub_19E0AB4F8(buf);
  if (v22)
  {
    uint64_t v10 = sub_19E0AAFBC(a1 + 1560, v22, &v22);
    sub_19E03CD54((uint64_t)(v10 + 3), v31);
    if (v21)
    {
      sub_19E03FC9C();
      uint64_t v11 = qword_1EB4FED50;
      if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *(void *)(a1 + 80);
        if (!v12) {
          uint64_t v12 = a1 + 88;
        }
        CFStringRef v13 = (const __CFString *)v33;
        if (!v33) {
          CFStringRef v13 = (const __CFString *)v34;
        }
        *(_DWORD *)buf = 136315650;
        uint64_t v26 = v12;
        __int16 v27 = 2080;
        CFStringRef v28 = v13;
        __int16 v29 = 1024;
        LODWORD(v3sub_19E062044(&a9, 0) = v22;
        uint64_t v14 = "%s: added new entry '%s' with tokenID=%u";
LABEL_27:
        _os_log_debug_impl(&dword_19E038000, v11, OS_LOG_TYPE_DEBUG, v14, buf, 0x1Cu);
      }
    }
    else
    {
      sub_19E03FC9C();
      uint64_t v11 = qword_1EB4FED50;
      if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v19 = *(void *)(a1 + 80);
        if (!v19) {
          uint64_t v19 = a1 + 88;
        }
        CFStringRef v20 = (const __CFString *)v33;
        if (!v33) {
          CFStringRef v20 = (const __CFString *)v34;
        }
        *(_DWORD *)buf = 136315650;
        uint64_t v26 = v19;
        __int16 v27 = 2080;
        CFStringRef v28 = v20;
        __int16 v29 = 1024;
        LODWORD(v3sub_19E062044(&a9, 0) = v22;
        uint64_t v14 = "%s: entry '%s' already exists with tokenID=%u";
        goto LABEL_27;
      }
    }
    uint64_t v17 = v22;
    goto LABEL_18;
  }
  sub_19E03FC9C();
  double v15 = qword_1EB4FED50;
  if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = *(void *)(a1 + 80);
    if (!v16) {
      uint64_t v16 = a1 + 88;
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v26 = v16;
    __int16 v27 = 2112;
    CFStringRef v28 = a2;
    _os_log_impl(&dword_19E038000, v15, OS_LOG_TYPE_DEFAULT, "%s: failed to add '%@' to the lexicon", buf, 0x16u);
  }
  sub_19E0AB210(*(void *)(a1 + 120), (char *)v31);
  uint64_t v17 = 0;
LABEL_18:
  if (v33 && v32 == 1) {
    free(v33);
  }
  std::mutex::unlock(v6);
  return v17;
}

void sub_19E0ACF58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,void *a21)
{
  if (a21)
  {
    if (a20 == 1) {
      free(a21);
    }
  }
  std::mutex::unlock(v21);
  _Unwind_Resume(a1);
}

void *sub_19E0ACFAC()
{
  return &unk_1EF09AC88;
}

uint64_t sub_19E0ACFB8(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09AC88)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_19E0ACFF8(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 16);
  *a3 = 0;
  if (v4)
  {
    **(unsigned char **)(a1 + ++**(_DWORD **)(result + 8) = 0;
    sub_19E0AB994();
  }
  (*(void (**)(void, void))(**(void **)(*(void *)(v5 + 120) + 64) + 16))(*(void *)(*(void *)(v5 + 120) + 64), *(void *)(a1 + 24));
  sub_19E0AB994();
}

void sub_19E0AD114(_Unwind_Exception *a1)
{
  sub_19E08F0D0(v1);
  _Unwind_Resume(a1);
}

__n128 sub_19E0AD134(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF09ACA8;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 4sub_19E062044(&a9, 0) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + ++**(_DWORD **)(result + 8) = result;
  return result;
}

__n128 sub_19E0AD16C(uint64_t a1)
{
  char v2 = (char *)operator new(0x38uLL);
  *(void *)char v2 = &unk_1EF09ACA8;
  *(_OWORD *)(v2 + ++**(_DWORD **)(result + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 4sub_19E062044(&a9, 0) = result;
  return result;
}

void sub_19E0AD1C8()
{
}

uint64_t sub_19E0AD1E0(uint64_t a1, char *a2, unsigned __int16 a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  sub_19E0B13C0((uint64_t)v24, a2, a3);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 1512) + 8))(&v19);
  uint64_t v7 = *(atomic_uint **)(*(void *)(*(void *)(a1 + 120) + 56) + 16);
  if (v7 && (int)atomic_fetch_add(v7, 1u) <= 0) {
    __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
  }
  uint64_t v17 = v7;
  char v18 = 0;
  uint64_t v8 = (unsigned __int16)v19;
  if ((unsigned __int16)v19 <= 0xEu) {
    uint64_t v9 = (unsigned __int8 *)&v19 + 2;
  }
  else {
    uint64_t v9 = v20;
  }
  if ((_WORD)v19)
  {
    do
    {
      sub_19E0912F4((uint64_t)&v13, (uint64_t)&v17, *v9);
      uint64_t v10 = v13;
      uint64_t v13 = 0;
      uint64_t v17 = (atomic_uint *)v10;
      if (v7)
      {
        sub_19E08F174((uint64_t)v7);
        char v18 = (char)v14;
        if (v13) {
          sub_19E08F174(v13);
        }
        uint64_t v7 = v17;
        if (!v17)
        {
LABEL_14:
          uint64_t v11 = 0;
          goto LABEL_20;
        }
      }
      else
      {
        char v18 = (char)v14;
        uint64_t v7 = (atomic_uint *)v10;
        if (!v10) {
          goto LABEL_14;
        }
      }
      ++v9;
      --v8;
    }
    while (v8);
  }
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  int v16 = 0;
  v21[0] = MEMORY[0x1E4F143A8];
  v21[1] = 1174405120;
  uint64_t v21[2] = sub_19E0AD52C;
  void v21[3] = &unk_1EF098D10;
  sub_19E039858((uint64_t)v22, v24);
  void v21[4] = &v13;
  sub_19E0915B0((uint64_t)&v17, (uint64_t)v21);
  uint64_t v11 = *((unsigned int *)v14 + 6);
  if (v23 && v22[6] == 1) {
    free(v23);
  }
  _Block_object_dispose(&v13, 8);
  if (v7) {
    sub_19E08F174((uint64_t)v7);
  }
LABEL_20:
  if ((unsigned __int16)v19 >= 0xFu && v20) {
    MEMORY[0x19F3BA6E0](v20, 0x1000C8077774924);
  }
  if (v26 && v25 == 1) {
    free(v26);
  }
  std::mutex::unlock(v6);
  return v11;
}

void sub_19E0AD460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, __int16 a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,void *a25)
{
  if (a2) {
    sub_19E04137C(exception_object);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int16 *sub_19E0AD52C(uint64_t a1, void *a2, unsigned char *a3)
{
  uint64_t v5 = *a2;
  __n128 result = (unsigned __int16 *)(*a2 + 8);
  if (result == (unsigned __int16 *)(a1 + 40)
    || (__n128 result = (unsigned __int16 *)sub_19E0B2428(result, (unsigned __int16 *)(a1 + 40)), result))
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(v5 + 40);
    *a3 = 1;
  }
  return result;
}

void sub_19E0AD58C(uint64_t a1)
{
  char v2 = *(void **)(a1 + 48);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 46) == 1) {
      free(v2);
    }
  }
}

uint64_t sub_19E0AD5AC(uint64_t a1, uint64_t a2)
{
  return sub_19E039858(a1 + 40, (unsigned __int16 *)(a2 + 40));
}

void sub_19E0AD5B8(uint64_t a1@<X0>, const __CFString *a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_19E0AD5C8(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  return sub_19E0A3D48(*(void *)(a1 + 1512), a2, a3);
}

void sub_19E0AD5D0(std::mutex *a1, uint64_t a2)
{
  uint64_t v4 = a1 + 25;
  std::mutex::lock(a1 + 25);
  sub_19E0D36C4((unsigned __int16 *)&v10, (uint64_t)a1[2].__m_.__opaque);
  uint64_t v5 = v10;
  if (v10 != v11)
  {
    do
    {
      if (*((unsigned __int16 *)v5 + 20) < 0xFu) {
        uint64_t v6 = (char *)v5 + 42;
      }
      else {
        uint64_t v6 = (char *)v5[6];
      }
      (*(void (**)(uint64_t, void, char *))(a2 + 16))(a2, *((unsigned int *)v5 + 8), v6);
      uint64_t v7 = v5[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = (void **)v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void **)v5[2];
          BOOL v9 = *v8 == v5;
          uint64_t v5 = v8;
        }
        while (!v9);
      }
      uint64_t v5 = v8;
    }
    while (v8 != v11);
  }
  sub_19E08DAEC(v11[0]);
  std::mutex::unlock(v4);
}

void sub_19E0AD6AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  std::mutex::unlock(v11);
  _Unwind_Resume(a1);
}

void *sub_19E0AD6D0(std::mutex *a1)
{
  char v2 = a1 + 25;
  std::mutex::lock(a1 + 25);
  long long v3 = sub_19E0AD728(a1);
  std::mutex::unlock(v2);
  return v3;
}

void sub_19E0AD714(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void *sub_19E0AD728(void *a1)
{
  char v2 = *(atomic_uint **)(*(void *)(a1[15] + 56) + 16);
  if (v2 && (int)atomic_fetch_add(v2, 1u) <= 0) {
    __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
  }
  if (qword_1EB4FEE18 != -1) {
    dispatch_once(&qword_1EB4FEE18, &unk_1EF098DA8);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  uint64_t v4 = Instance;
  uint64_t v5 = a1[193];
  uint64_t v6 = (std::__shared_weak_count *)a1[194];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  Instance[2] = &unk_1EF09CAA0;
  Instance[3] = v5;
  Instance[4] = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  Instance[5] = v2;
  if (v2)
  {
    if ((int)atomic_fetch_add(v2, 1u) < 1) {
      __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
    }
    uint64_t v7 = (uint64_t)v2;
  }
  else
  {
    uint64_t v7 = 0;
  }
  *((unsigned char *)v4 + 4++**(_DWORD **)(result + 8) = 0;
  *((_DWORD *)v4 + 14) = 0x100000;
  *((_WORD *)v4 + 3sub_19E062044(&a9, 0) = 0;
  *((unsigned char *)v4 + 62) = 0;
  unsigned char v4[8] = 0;
  *((unsigned char *)v4 + 72) = 0;
  *((_WORD *)v4 + 44) = 0;
  *((unsigned char *)v4 + 104) = 0;
  *((_WORD *)v4 + 56) = 0;
  *((_DWORD *)v4 + 32) = 0;
  v4[17] = 0;
  v4[18] = 0;
  *((unsigned char *)v4 + 152) = 1;
  if (v7) {
    sub_19E08F174(v7);
  }
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  return v4;
}

void sub_19E0AD8FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_19E0AD938()
{
  qword_1EB4FEE20 = 0;
  *(void *)algn_1EB4FEE28 = "LXCursor";
  qword_1EB4FEE30 = 0;
  unk_1EB4FEE38 = 0;
  qword_1EB4FEE40 = (uint64_t)sub_19E087C70;
  *(_OWORD *)algn_1EB4FEE48 = 0u;
  *(_OWORD *)&algn_1EB4FEE48[16] = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB4FEE80 = result;
  return result;
}

CFStringRef sub_19E0AD98C(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    uint64_t v1 = *(char **)(a1 + 80);
  }
  else {
    uint64_t v1 = (char *)(a1 + 88);
  }
  sub_19E0413C8(__p, v1);
  CFStringRef v2 = sub_19E040B4C((uint64_t)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_19E0AD9E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0ADA04(uint64_t a1, unsigned int a2)
{
  v24[2] = *(const void **)MEMORY[0x1E4F143B8];
  uint64_t v4 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  unint64_t v5 = *(void *)(a1 + 1568);
  if (!v5) {
    goto LABEL_17;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = a2;
    if (v5 <= a2) {
      unint64_t v7 = a2 % v5;
    }
  }
  else
  {
    unint64_t v7 = (v5 - 1) & a2;
  }
  uint64_t v8 = *(uint64_t ***)(*(void *)(a1 + 1560) + 8 * v7);
  if (!v8 || (BOOL v9 = *v8) == 0)
  {
LABEL_17:
    uint64_t v11 = 0;
    goto LABEL_18;
  }
  while (1)
  {
    unint64_t v10 = v9[1];
    if (v10 == a2) {
      break;
    }
    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= v5) {
        v10 %= v5;
      }
    }
    else
    {
      v10 &= v5 - 1;
    }
    if (v10 != v7) {
      goto LABEL_17;
    }
LABEL_16:
    BOOL v9 = (uint64_t *)*v9;
    if (!v9) {
      goto LABEL_17;
    }
  }
  if (*((_DWORD *)v9 + 4) != a2) {
    goto LABEL_16;
  }
  sub_19E03FD18(&v18, (unsigned __int16 *)v9 + 12);
  CFStringRef v13 = v18;
  if (v18)
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x3002000000;
    unsigned int v22 = sub_19E0ADD68;
    int v23 = sub_19E0ADD78;
    v24[0] = 0;
    CFTypeRef cf = sub_19E0AD728((void *)a1);
    uint64_t v14 = (const void *)LXCursorCreateByAdvancing((uint64_t)cf, v13);
    v19[0] = v14;
    if (cf)
    {
      CFRelease(cf);
      uint64_t v14 = v19[0];
    }
    v19[0] = 0;
    CFTypeRef cf = v14;
    sub_19E0ADD80(v19);
    v19[0] = (const void *)MEMORY[0x1E4F143A8];
    v19[1] = (const void *)0x40000000;
    _DWORD v19[2] = sub_19E0ADDB8;
    unsigned __int16 v19[3] = &unk_1E599C0C0;
    _OWORD v19[4] = buf;
    void v19[5] = v13;
    if (cf) {
      (*(void (**)(char *, const void **))(*((void *)cf + 2) + 48))((char *)cf + 16, v19);
    }
    uint64_t v11 = *(void *)(*(void *)&buf[8] + 40);
    *(void *)(*(void *)&buf[8] + 4sub_19E062044(&a9, 0) = 0;
    sub_19E0ADD80(&cf);
    _Block_object_dispose(buf, 8);
    sub_19E0ADE64(v24);
  }
  else
  {
    sub_19E03FC9C();
    uint64_t v15 = qword_1EB4FED50;
    if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(void *)(a1 + 80);
      if (!v16) {
        uint64_t v16 = a1 + 88;
      }
      uint64_t v17 = (uint64_t *)v9[4];
      if (!v17) {
        uint64_t v17 = v9 + 5;
      }
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = v16;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v17;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v22) = a2;
      _os_log_error_impl(&dword_19E038000, v15, OS_LOG_TYPE_ERROR, "%s: could not create CFString for string='%s' and token_id=%d", buf, 0x1Cu);
    }
    uint64_t v11 = 0;
  }
  sub_19E040A10((const void **)&v18);
LABEL_18:
  std::mutex::unlock(v4);
  return v11;
}

void sub_19E0ADD04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_19E040A10(&a9);
  std::mutex::unlock(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0ADD68(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a2 + 4sub_19E062044(&a9, 0) = 0;
  *(void *)(result + 4sub_19E062044(&a9, 0) = v2;
  return result;
}

const void **sub_19E0ADD78(uint64_t a1)
{
  return sub_19E0ADE64((const void **)(a1 + 40));
}

const void **sub_19E0ADD80(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

const void **sub_19E0ADDB8(uint64_t a1, const void *a2, unsigned char *a3)
{
  CFStringRef v6 = (const __CFString *)LXEntryCopyString((uint64_t)a2);
  CFStringRef v10 = v6;
  if (v6 && CFEqual(v6, *(CFStringRef *)(a1 + 40)))
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v8 = *(const void **)(v7 + 40);
    if (v8 != a2)
    {
      if (a2)
      {
        CFRetain(a2);
        uint64_t v8 = *(const void **)(v7 + 40);
      }
      if (v8) {
        CFRelease(v8);
      }
      *(void *)(v7 + 4sub_19E062044(&a9, 0) = a2;
    }
    *a3 = 1;
  }
  return sub_19E040A10((const void **)&v10);
}

void sub_19E0ADE50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E040A10((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_19E0ADE64(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

uint64_t sub_19E0ADE9C(std::mutex *a1)
{
  v7[19] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1 + 25;
  std::mutex::lock(a1 + 25);
  sub_19E068A30(v5);
  if ((v6[*(void *)(v5[0] - 24) + 16] & 5) != 0)
  {
    uint64_t v2 = 0;
  }
  else
  {
    std::istream::tellg();
    uint64_t v2 = v4;
  }
  v5[0] = *MEMORY[0x1E4FBA3F8];
  *(uint64_t *)((char *)v5 + *(void *)(v5[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
  MEMORY[0x19F3BA400](v6);
  std::istream::~istream();
  MEMORY[0x19F3BA690](v7);
  std::mutex::unlock(v1);
  return v2;
}

void sub_19E0AE028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  sub_19E068CB8(&a26);
  std::mutex::unlock(v26);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0AE04C(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (std::mutex *)(a1 + 1600);
  std::mutex::lock((std::mutex *)(a1 + 1600));
  uint64_t v3 = *(void *)(a1 + 120);
  if (!*(unsigned char *)(v3 + 16) || (uint64_t v4 = *(void **)(v3 + 56)) == 0 || *(unsigned char *)(v3 + 17))
  {
LABEL_4:
    LOBYTE(v1++**(_DWORD **)(result + 8) = 0;
    char v23 = 0;
    goto LABEL_5;
  }
  CFStringRef v13 = (unsigned __int16 *)(v3 + 24);
  if (!*(_WORD *)(v3 + 24))
  {
    if (qword_1E94577A8[0] != -1) {
      dispatch_once(qword_1E94577A8, &unk_1EF09E598);
    }
    uint64_t v17 = qword_1E94577A0;
    if (os_log_type_enabled((os_log_t)qword_1E94577A0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_19E038000, v17, OS_LOG_TYPE_ERROR, "cannot store dynamic dictionary: empty path", buf, 2u);
    }
    goto LABEL_4;
  }
  *(_WORD *)(v3 + 16) = 256;
  uint64_t v14 = v4[1];
  *(void *)buf = *v4;
  *(void *)&uint8_t buf[8] = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = (atomic_uint *)v4[2];
  *(void *)&uint8_t buf[16] = v15;
  if (v15 && (int)atomic_fetch_add(v15, 1u) <= 0) {
    __assert_rtn("ref", "WTFRefCounted.h", 42, "old_count > 0");
  }
  sub_19E039858((uint64_t)v25, v13);
  long long v18 = *(_OWORD *)buf;
  uint64_t v16 = *(void *)&buf[16];
  memset(buf, 0, sizeof(buf));
  uint64_t v19 = v16;
  int v20 = 0x100000;
  LOWORD(bufLen[0]) = 0;
  BYTE2(bufLen[0]) = 0;
  *(void *)&bufLen[1] = 0;
  sub_19E03CED8((uint64_t)&v20, v25);
  char v23 = 1;
  if (v27 && v26 == 1) {
    free(v27);
  }
  if (*(void *)&buf[16]) {
    sub_19E08F174(*(uint64_t *)&buf[16]);
  }
  if (*(void *)&buf[8]) {
    sub_19E0616BC(*(std::__shared_weak_count **)&buf[8]);
  }
LABEL_5:
  std::mutex::unlock(v2);
  if (v23)
  {
    sub_19E03FC9C();
    unint64_t v5 = qword_1EB4FED50;
    if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = *(void *)(a1 + 80);
      if (!v6) {
        uint64_t v6 = a1 + 88;
      }
      uint64_t v7 = *(void *)(a1 + 1584);
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = v6;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v7;
      _os_log_impl(&dword_19E038000, v5, OS_LOG_TYPE_INFO, "%s: storing %lu entries", buf, 0x16u);
    }
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (*(void *)&bufLen[1]) {
      BOOL v9 = *(const UInt8 **)&bufLen[1];
    }
    else {
      BOOL v9 = (const UInt8 *)&v22;
    }
    unsigned int v10 = LOWORD(bufLen[0]);
    if (!LOWORD(bufLen[0]))
    {
      sub_19E0398F4((unsigned __int16 *)&v20);
      unsigned int v10 = LOWORD(bufLen[0]);
    }
    CFURLRef v11 = CFURLCreateFromFileSystemRepresentation(v8, v9, v10, 0);
    CFURLCreateCopyDeletingLastPathComponent(v8, v11);
    sub_19E040B98();
  }
  return sub_19E0AEC90((uint64_t)&v18);
}

void sub_19E0AEA80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFTypeRef cf, uint64_t a12, CFTypeRef *a13, CFTypeRef a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,void *a35,uint64_t a36,uint64_t a37,void *__p,void *a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47)
{
  if (a43 < 0) {
    operator delete(__p);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v49) {
    CFRelease(v49);
  }
  if (v48) {
    CFRelease(v48);
  }
  sub_19E0D7360(&a13);
  if (a35 && a34 == 1) {
    free(a35);
  }
  if (a14) {
    CFRelease(a14);
  }
  if (v47) {
    CFRelease(v47);
  }
  sub_19E0AEC90((uint64_t)&a24);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0AEC90(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2 && *(unsigned char *)(a1 + 30) == 1) {
      free(v2);
    }
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3) {
      sub_19E08F174(v3);
    }
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
    if (v4) {
      sub_19E0616BC(v4);
    }
  }
  return a1;
}

__n128 sub_19E0AECF0(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 4sub_19E062044(&a9, 0) = 0;
  *(void *)(a2 + 4++**(_DWORD **)(result + 8) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void sub_19E0AED14(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 40);
  sub_19E0AEFF8(&v1);
}

void sub_19E0AED40(uint64_t a1, uint64_t *a2)
{
  uint64_t v37[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *a2;
  unsigned int v6 = *(_DWORD *)(*a2 + 40);
  if (sub_19E08C5B8((void *)(v4 + 1560), v6))
  {
    sub_19E039858((uint64_t)v34, (unsigned __int16 *)(v5 + 8));
    unsigned int v22 = *(_DWORD *)(*a2 + 40);
    uint64_t v7 = (unsigned __int16 *)sub_19E0ABA60(v4 + 1560, v22, &v22);
    sub_19E039858((uint64_t)v30, v7 + 12);
    sub_19E03FC9C();
    CFAllocatorRef v8 = qword_1EB4FED50;
    if (os_log_type_enabled((os_log_t)qword_1EB4FED50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(v4 + 80);
      if (!v9) {
        uint64_t v9 = v4 + 88;
      }
      unsigned int v10 = v36;
      if (!v36) {
        unsigned int v10 = v37;
      }
      CFURLRef v11 = (uint64_t *)v32;
      int v12 = *(_DWORD *)(*a2 + 40);
      if (!v32) {
        CFURLRef v11 = &v33;
      }
      unsigned int v22 = 136315906;
      uint64_t v23 = v9;
      __int16 v24 = 2080;
      char v25 = v10;
      __int16 v26 = 2080;
      uint64_t v27 = v11;
      __int16 v28 = 1024;
      int v29 = v12;
      _os_log_impl(&dword_19E038000, v8, OS_LOG_TYPE_DEFAULT, "%s: collision for strings '%s' and '%s': tokenID=%u", (uint8_t *)&v22, 0x26u);
    }
    CFStringRef v13 = *(void **)(*(void *)(a1 + 32) + 8);
    int v14 = *(_DWORD *)(*a2 + 40);
    uint64_t v15 = (int *)v13[6];
    if ((unint64_t)v15 >= v13[7])
    {
      uint64_t v16 = sub_19E0AF08C(v13 + 5, v14, v34);
    }
    else
    {
      int *v15 = v14;
      sub_19E039858((uint64_t)(v15 + 2), v34);
      uint64_t v16 = (uint64_t)(v15 + 10);
      void v13[6] = v15 + 10;
    }
    void v13[6] = v16;
    long long v18 = *(void **)(*(void *)(a1 + 32) + 8);
    int v19 = *(_DWORD *)(*a2 + 40);
    int v20 = (int *)v18[6];
    if ((unint64_t)v20 >= v18[7])
    {
      uint64_t v21 = sub_19E0AF08C(v18 + 5, v19, v30);
    }
    else
    {
      int *v20 = v19;
      sub_19E039858((uint64_t)(v20 + 2), v30);
      uint64_t v21 = (uint64_t)(v20 + 10);
      v18[6] = v20 + 10;
    }
    v18[6] = v21;
    if (v32 && v31 == 1) {
      free(v32);
    }
    if (v36)
    {
      if (v35 == 1) {
        free(v36);
      }
    }
  }
  else
  {
    unsigned int v22 = v6;
    uint64_t v17 = sub_19E0ABA60(v4 + 1560, v6, &v22);
    sub_19E03CD54((uint64_t)(v17 + 3), (unsigned __int16 *)(v5 + 8));
  }
}

void sub_19E0AEF8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, void *a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,void *a23)
{
  if (a17 && a16 == 1) {
    free(a17);
  }
  if (a23)
  {
    if (a22 == 1) {
      free(a23);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_19E0AEFF8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unsigned int v6 = (void *)*((void *)v4 - 3);
        if (v6 && *(v4 - 26) == 1) {
          free(v6);
        }
        v4 -= 40;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_19E0AF08C(void *a1, int a2, unsigned __int16 *a3)
{
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x666666666666666) {
    sub_19E041BEC();
  }
  if (0x999999999999999ALL * ((uint64_t)(a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x999999999999999ALL * ((uint64_t)(a1[2] - *a1) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[2] - *a1) >> 3) >= 0x333333333333333) {
    unint64_t v8 = 0x666666666666666;
  }
  else {
    unint64_t v8 = v4;
  }
  __int16 v24 = a1 + 2;
  if (v8)
  {
    if (v8 > 0x666666666666666) {
      sub_19E0416C4();
    }
    uint64_t v9 = (char *)operator new(40 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  unsigned int v10 = &v9[40 * v3];
  unsigned int v22 = v9;
  *(void *)uint64_t v23 = v10;
  *(void *)&v23[8] = v10;
  *(void *)&unsigned char v23[16] = &v9[40 * v8];
  *(_DWORD *)unsigned int v10 = a2;
  sub_19E039858((uint64_t)(v10 + 8), a3);
  uint64_t v11 = 0;
  uint64_t v12 = *(void *)v23;
  *(void *)&v23[8] += 40;
  uint64_t v14 = *a1;
  uint64_t v13 = a1[1];
  while (1)
  {
    uint64_t v15 = v12 + v11;
    uint64_t v16 = v13 + v11;
    if (v13 + v11 == v14) {
      break;
    }
    *(_DWORD *)(v15 - 4sub_19E062044(&a9, 0) = *(_DWORD *)(v16 - 40);
    v11 -= 40;
    sub_19E039858(v15 - 32, (unsigned __int16 *)(v16 - 32));
  }
  uint64_t v17 = a1[2];
  long long v18 = *(_OWORD *)&v23[8];
  uint64_t v21 = *(void *)&v23[8];
  long long v19 = *(_OWORD *)a1;
  *a1 = v15;
  *(_OWORD *)uint64_t v23 = v19;
  *(_OWORD *)(a1 + 1) = v18;
  *(void *)&unsigned char v23[16] = v17;
  unsigned int v22 = (char *)v19;
  sub_19E0AF240((uint64_t)&v22);
  return v21;
}

void sub_19E0AF1F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E0AF240((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0AF240(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 40;
      *(void *)(a1 + 16) = v2 - 40;
      uint64_t v5 = *(void **)(v2 - 24);
      if (v5 && *(unsigned char *)(v2 - 26) == 1)
      {
        free(v5);
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E0AF2AC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(void *)(a1 + 8)) {
    uint64_t v7 = *(char **)(a1 + 8);
  }
  else {
    uint64_t v7 = (char *)(a1 + 16);
  }
  if (!*v7 || !strcmp(v7, "root"))
  {
    uint64_t v9 = uset_openEmpty();
    uint64_t v15 = (uint64_t (*)(uint64_t))MEMORY[0x1E4FBA6B8];
    if (!v9) {
      __assert_rtn("quicktype_exemplars", "LXMutableLexiconImpl.cpp", 304, "quicktype_exemplars");
    }
    for (uint64_t i = 0; i != 17; ++i)
    {
      sub_19E0AF660(v16, off_1E599C0E0[i], a4);
      uint64_t v11 = v16[0];
      if (v16[0])
      {
        MEMORY[0x19F3BAFD0](v9, v16[0]);
        ((void (*)(uint64_t))v16[1])(v11);
      }
    }
    uint64_t result = MEMORY[0x19F3BB000](v9);
  }
  else
  {
    uint64_t result = sub_19E0AF660(&v14, v7, a4);
    uint64_t v9 = v14;
  }
  if (v9)
  {
    for (uint64_t j = 0; (int)j < (int)MEMORY[0x19F3BB030](v9); uint64_t j = (j + 1))
    {
      uint64_t v13 = MEMORY[0x19F3BAFE0](v9, j);
      if ((v13 & 0x80000000) == 0) {
        sub_19E0AF46C(a2, a3, v13);
      }
    }
    return v15(v9);
  }
  return result;
}

void sub_19E0AF418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void (*a12)(uint64_t))
{
  a12(v13);
  if (v12) {
    uset_close();
  }
  _Unwind_Resume(a1);
}

void sub_19E0AF46C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 16))(&v6, a2, a3);
  unsigned int v5 = (unsigned __int16)v6;
  if ((_WORD)v6)
  {
    if (!sub_19E0AF554((void *)(a1 + 1296), (unsigned __int16 *)&v6))
    {
      sub_19E0D3120(a1, (unsigned __int16 *)&v6, v3);
      unsigned int v5 = (unsigned __int16)v6;
    }
    if (v5 >= 0xF)
    {
      if (v7) {
        MEMORY[0x19F3BA6E0](v7, 0x1000C8077774924);
      }
    }
  }
}

void sub_19E0AF520(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, unsigned __int16 a9, uint64_t a10)
{
  if (a9 >= 0xFu)
  {
    if (a10) {
      MEMORY[0x19F3BA6E0](a10, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(exception_object);
}

unsigned __int16 *sub_19E0AF554(void *a1, unsigned __int16 *a2)
{
  unsigned int v4 = *a2;
  if (v4 <= 0xE) {
    unsigned int v5 = (unsigned __int8 *)(a2 + 1);
  }
  else {
    unsigned int v5 = (unsigned __int8 *)*((void *)a2 + 1);
  }
  unsigned int v6 = sub_19E0B24AC(v5, v4);
  unint64_t v7 = a1[1];
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v6;
  uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
  v9.i16[0] = vaddlv_u8(v9);
  unint64_t v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    unint64_t v11 = v6;
    if (v7 <= v6) {
      unint64_t v11 = v6 % v7;
    }
  }
  else
  {
    unint64_t v11 = (v7 - 1) & v6;
  }
  uint64_t v12 = *(unsigned __int16 ***)(*a1 + 8 * v11);
  if (!v12) {
    return 0;
  }
  for (uint64_t i = *v12; i; uint64_t i = *(unsigned __int16 **)i)
  {
    unint64_t v14 = *((void *)i + 1);
    if (v14 == v8)
    {
      if (sub_19E0A7134(i + 8, a2)) {
        return i;
      }
    }
    else
    {
      if (v10 > 1)
      {
        if (v14 >= v7) {
          v14 %= v7;
        }
      }
      else
      {
        v14 &= v7 - 1;
      }
      if (v14 != v11) {
        return 0;
      }
    }
  }
  return i;
}

uint64_t sub_19E0AF660(uint64_t *a1, char *__s1, int a3)
{
  if (!a3 && !strncmp(__s1, "ko", 2uLL))
  {
    uint64_t result = uset_open();
    uint64_t v7 = MEMORY[0x1E4FBA6B8];
    *a1 = result;
    a1[1] = v7;
  }
  else
  {
    if (!ulocdata_open()) {
      __assert_rtn("icu_exemplars", "LXMutableLexiconImpl.cpp", 261, "ulocdata");
    }
    uint64_t ExemplarSet = ulocdata_getExemplarSet();
    uint64_t v5 = MEMORY[0x1E4FBA6B8];
    *a1 = ExemplarSet;
    a1[1] = v5;
    if (!ExemplarSet) {
      __assert_rtn("icu_exemplars", "LXMutableLexiconImpl.cpp", 270, "exemplar_set");
    }
    return ulocdata_close();
  }
  return result;
}

void sub_19E0AF7CC(_Unwind_Exception *a1)
{
}

uint64_t sub_19E0AF818(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_19E07D688(result);
    JUMPOUT(0x19F3BA710);
  }
  return result;
}

void sub_19E0AF868(uint64_t a1)
{
  sub_19E0AF8A0(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E0AF8A0(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C710;
  std::mutex::~mutex((std::mutex *)(a1 + 1600));
  sub_19E0AF9B4(a1 + 1560);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 1552);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 1536);
  if (v3) {
    sub_19E0616BC(v3);
  }
  unsigned int v4 = *(std::__shared_weak_count **)(a1 + 1520);
  if (v4) {
    sub_19E0616BC(v4);
  }
  *(void *)(a1 + 136) = &unk_1EF09C8E8;
  uint64_t v5 = *(void **)(a1 + 1488);
  if (v5 && *(unsigned char *)(a1 + 1486) == 1) {
    free(v5);
  }
  sub_19E03A444(a1 + 1432);
  unsigned int v6 = *(std::__shared_weak_count **)(a1 + 128);
  if (v6) {
    sub_19E0616BC(v6);
  }
  sub_19E0AF818((uint64_t *)(a1 + 112), 0);
  uint64_t v7 = *(void **)(a1 + 80);
  if (v7 && *(unsigned char *)(a1 + 78) == 1) {
    free(v7);
  }
  uint64_t v8 = *(void **)(a1 + 48);
  if (v8 && *(unsigned char *)(a1 + 46) == 1) {
    free(v8);
  }
  uint8x8_t v9 = *(void **)(a1 + 16);
  if (v9 && *(unsigned char *)(a1 + 14) == 1) {
    free(v9);
  }
  return a1;
}

uint64_t sub_19E0AF9B4(uint64_t a1)
{
  sub_19E0AADB8(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_19E0AF9F8(uint64_t a1, uint64_t a2)
{
  if (sub_19E055AE4(a2, (uint64_t)&unk_1EF09B590)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_19E0AFA38(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_19E0AFA68(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E0AFAA4(uint64_t a1)
{
  *(void *)a1 = &unk_1EF09C8E8;
  uint64_t v2 = *(void **)(a1 + 1352);
  if (v2 && *(unsigned char *)(a1 + 1350) == 1) {
    free(v2);
  }
  sub_19E03A444(a1 + 1296);
  return a1;
}

unint64_t sub_19E0AFB04(uint64_t a1)
{
  size_t v2 = *(unsigned __int16 *)(a1 + 80);
  if (v2 < 0xF) {
    int v3 = (void *)(a1 + 82);
  }
  else {
    int v3 = *(void **)(a1 + 88);
  }
  sub_19E057A94(__p, v3, v2);
  if ((v10 & 0x80u) == 0) {
    unsigned int v4 = (uint64_t *)__p;
  }
  else {
    unsigned int v4 = (uint64_t *)__p[0];
  }
  if ((v10 & 0x80u) == 0) {
    unint64_t v5 = v10;
  }
  else {
    unint64_t v5 = (unint64_t)__p[1];
  }
  unint64_t v6 = sub_19E086FCC(v4, v5);
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 112))(*(void *)(a1 + 8));
  if ((char)v10 < 0) {
    operator delete(__p[0]);
  }
  return v7 ^ v6;
}

void sub_19E0AFBB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0AFBCC()
{
  return 0;
}

uint64_t sub_19E0AFBD4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 120);
}

const void *sub_19E0AFBDC(uint64_t a1)
{
  sub_19E03FD18((CFStringRef *)&v3, (unsigned __int16 *)(a1 + 48));
  uint64_t v1 = v3;
  int v3 = 0;
  sub_19E040A10(&v3);
  return v1;
}

uint64_t sub_19E0AFC20()
{
  return 0;
}

uint64_t sub_19E0AFC28()
{
  return 0;
}

double sub_19E0AFC30(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 16);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  int v22 = 0;
  uint64_t v3 = *(void *)(v2 + 8 * *(unsigned __int8 *)(v2 + 84));
  int v4 = (*(uint64_t (**)(uint64_t, void *, int *))(*(void *)v3 + 128))(v3, v1, &v22);
  float v5 = 0.0;
  if (v4)
  {
    if (*v1 && *v1 != 0xFFFFFFFFLL)
    {
      uint64_t v7 = 20;
      if (!*(unsigned char *)(v2 + 84)) {
        uint64_t v7 = 16;
      }
      unsigned int v8 = *(_DWORD *)(v2 + v7) + v22;
      if (v8)
      {
        unsigned int v9 = 0;
        unsigned __int8 v10 = *(uint64_t **)(v2 + 64);
        uint64_t v11 = *v10;
        unint64_t v12 = v10[1];
        unint64_t v13 = v12 - 1;
        while (1)
        {
          if (v12 < v8) {
LABEL_32:
          }
            __assert_rtn("InputStream", "TIDataFile.cpp", 314, "m_offset <= m_size");
          if (v13 < v8 || v11 == 0) {
            break;
          }
          unint64_t v15 = v8 + 1;
          unint64_t v16 = v10[1];
          if (v16 < v15) {
            goto LABEL_32;
          }
          if (v16 - 1 < v15) {
            break;
          }
          int v17 = *(unsigned __int8 *)(v11 + v8);
          char v18 = *(unsigned char *)(v11 + v15);
          if ((v18 & 4) != 0)
          {
            unint64_t v19 = v8 + 2;
            if (v12 < v19) {
              goto LABEL_32;
            }
            if (v13 < v19) {
              return log10f(v5);
            }
            v9 += *(unsigned __int8 *)(v11 + v19) * *(unsigned __int8 *)(v11 + v19);
            if ((v18 & 0x80) == 0) {
              goto LABEL_30;
            }
          }
          else
          {
            unsigned int v9 = 65025;
            if ((v18 & 0x80) == 0) {
              goto LABEL_30;
            }
          }
          v8 += v17;
          if (v8) {
            BOOL v20 = v17 == 0;
          }
          else {
            BOOL v20 = 1;
          }
          if (v20) {
            goto LABEL_30;
          }
        }
      }
      else
      {
        unsigned int v9 = 0;
LABEL_30:
        float v5 = (double)v9 * 0.0000153787005;
      }
    }
  }
  return log10f(v5);
}

double sub_19E0AFDA8(uint64_t a1)
{
  return *(double *)(a1 + 136);
}

double sub_19E0AFDB0(uint64_t a1)
{
  return *(double *)(a1 + 128);
}

void sub_19E0AFDB8(uint64_t a1, uint64_t a2)
{
  char v4 = 0;
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = sub_19E0AFE4C;
  v3[3] = &unk_1E599C190;
  v3[4] = a2;
  v3[5] = a1;
  sub_19E0AFF48(v2, (void *)(a1 + 16), (unsigned __int16 *)(a1 + 48), (unsigned __int16 *)(a1 + 80), &v4, (uint64_t)v3, 0.0);
}

void sub_19E0AFE4C(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4, double a5)
{
  uint64_t v10 = *(void *)(a1 + 40);
  double v11 = *(double *)(v10 + 136);
  if (qword_1EB4FEE18 != -1) {
    dispatch_once(&qword_1EB4FEE18, &unk_1EF098DC8);
  }
  uint64_t Instance = (const void *)_CFRuntimeCreateInstance();
  sub_19E0B02F0((uint64_t)Instance + 16, *(void *)(v10 + 8), a2, a3, a4, a5, v11 + a5);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

  CFRelease(Instance);
}

void sub_19E0AFF48(uint64_t a1, void *a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned char *a5, uint64_t a6, double a7)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v7 = *(unsigned __int8 *)(a1 + 84);
  unsigned int v8 = *(uint64_t **)a1;
  unsigned int v9 = *(uint64_t **)(a1 + 8);
  v26[0] = 0;
  v26[1] = 0;
  uint64_t v27 = 0;
  if (*a2 == 0xFFFFFFFFLL)
  {
    long long v24 = 0uLL;
    uint64_t v25 = 0;
    __int16 v28 = v26;
    sub_19E0B0264(&v28);
  }
  else
  {
    if (v7) {
      unint64_t v16 = v9;
    }
    else {
      unint64_t v16 = v8;
    }
    __int16 v28 = (void **)&unk_1EF09AA08;
    int v29 = v26;
    unint64_t v30 = &v28;
    (*(void (**)(uint64_t *))(*v16 + 144))(v16);
    sub_19E0B4198(&v28);
    long long v24 = *(_OWORD *)v26;
    uint64_t v25 = v27;
    v26[0] = 0;
    v26[1] = 0;
    uint64_t v27 = 0;
    int v17 = (char *)v24;
    __int16 v28 = v26;
    sub_19E0B0264(&v28);
    if ((void)v24 != *((void *)&v24 + 1))
    {
      do
      {
        if (*a5) {
          break;
        }
        sub_19E0D29A8((uint64_t)&v28, a1 + 88, a4, *v17);
        if (v32 == -2)
        {
          char v18 = (uint64_t **)(*(unsigned char *)(a1 + 84) ? a1 + 8 : a1);
          float v19 = sub_19E0F6CC4(*v18, (uint64_t)(v17 + 8));
          float v20 = log10f(v19);
          sub_19E0AFF48(a1, v17 + 8, a3, &v28, a5, a6, v20 + a7);
        }
        else
        {
          sub_19E0B2328((uint64_t)v26, a3, v32);
          if (*(unsigned char *)(a1 + 84)) {
            uint64_t v21 = (uint64_t **)(a1 + 8);
          }
          else {
            uint64_t v21 = (uint64_t **)a1;
          }
          float v22 = sub_19E0F6CC4(*v21, (uint64_t)(v17 + 8));
          float v23 = log10f(v22);
          (*(void (**)(uint64_t, char *, void **, void ***, unsigned char *, double))(a6 + 16))(a6, v17 + 8, v26, &v28, a5, v23 + a7);
          if (v26[1] && BYTE6(v26[0]) == 1) {
            free(v26[1]);
          }
        }
        if ((unsigned __int16)v30 >= 0xFu && v31) {
          MEMORY[0x19F3BA6E0](v31, 0x1000C8077774924);
        }
        if ((unsigned __int16)v28 >= 0xFu && v29) {
          MEMORY[0x19F3BA6E0](v29, 0x1000C8077774924);
        }
        v17 += 40;
      }
      while (v17 != *((char **)&v24 + 1));
    }
  }
  __int16 v28 = (void **)&v24;
  sub_19E0B0264(&v28);
}

void sub_19E0B0200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
}

void sub_19E0B0264(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    char v4 = (void **)v1[1];
    float v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 1) < 0) {
          operator delete(*(v4 - 3));
        }
        v4 -= 5;
      }
      while (v4 != v2);
      float v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_19E0B02F0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, unsigned __int16 *a5, double a6, double a7)
{
  *(void *)a1 = &unk_1EF0998E0;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = a2;
  *(void *)(a1 + 16) = *(void *)a3;
  if (*(char *)(a3 + 31) < 0)
  {
    sub_19E03FA9C((unsigned char *)(a1 + 24), *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v12 = *(_OWORD *)(a3 + 8);
    *(void *)(a1 + 4sub_19E062044(&a9, 0) = *(void *)(a3 + 24);
    *(_OWORD *)(a1 + 24) = v12;
  }
  sub_19E039858(a1 + 48, a4);
  unint64_t v13 = (_WORD *)(a1 + 80);
  unint64_t v14 = *a5;
  if (v14 >= 0xF)
  {
    *unint64_t v13 = v14;
    operator new[]();
  }
  *(_OWORD *)unint64_t v13 = *(_OWORD *)a5;
  *(unsigned char *)(a1 + 96) = *((unsigned char *)a5 + 16);
  unint64_t v15 = (_WORD *)(a1 + 104);
  unint64_t v16 = a5[12];
  if (v16 >= 0xF)
  {
    _WORD *v15 = v16;
    operator new[]();
  }
  *(_OWORD *)unint64_t v15 = *(_OWORD *)(a5 + 12);
  *(_DWORD *)(a1 + 12sub_19E062044(&a9, 0) = *((_DWORD *)a5 + 10);
  *(double *)(a1 + 12++**(_DWORD **)(result + 8) = a6;
  *(double *)(a1 + 136) = a7;
  return a1;
}

void sub_19E0B0434(_Unwind_Exception *exception_object)
{
  if (*v3 >= 0xFu)
  {
    uint64_t v5 = *(void *)(v1 + 88);
    if (v5) {
      MEMORY[0x19F3BA6E0](v5, 0x1000C8077774924);
    }
  }
  unint64_t v6 = *(void **)(v1 + 56);
  if (v6 && *(unsigned char *)(v1 + 54) == 1) {
    free(v6);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E0B04A0()
{
  qword_1EB4FEE20 = 0;
  *(void *)algn_1EB4FEE28 = "LXCursor";
  qword_1EB4FEE30 = 0;
  unk_1EB4FEE38 = 0;
  qword_1EB4FEE40 = (uint64_t)sub_19E087C70;
  *(_OWORD *)algn_1EB4FEE48 = 0u;
  *(_OWORD *)&algn_1EB4FEE48[16] = 0u;
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB4FEE80 = result;
  return result;
}

uint64_t sub_19E0B04F4(uint64_t a1)
{
  void v5[4] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1 + 16;
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 8) + 8)
                 + 8 * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 8) + 8) + 84));
  unsigned __int8 v4 = 0;
  v5[0] = &unk_1EF09F1F0;
  v5[1] = &v4;
  void v5[3] = v5;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v2 + 144))(v2, v1, v5);
  sub_19E0B4198(v5);
  return v4;
}

void sub_19E0B05B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E0B4198((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E0B05CC(uint64_t a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a1 + 16;
  uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 8);
  char v35 = 0;
  unint64_t v36 = 0;
  uint64_t v34 = 0;
  if (*(unsigned char *)(v5 + 84)) {
    unint64_t v6 = (uint64_t *)(v5 + 8);
  }
  else {
    unint64_t v6 = (uint64_t *)v5;
  }
  uint64_t v7 = *v6;
  int v38 = 0;
  if ((*(unsigned int (**)(uint64_t, uint64_t, int *))(*(void *)v7 + 128))(v7, v4, &v38))
  {
    float v8 = 0.0;
    while (1)
    {
      unsigned int v37 = 0;
      uint64_t v9 = *(unsigned char *)(v5 + 84) ? 20 : 16;
      sub_19E0F72BC((uint64_t)&v43, v5, *(_DWORD *)(v5 + v9) + v38, (int *)&v37, (unsigned __int16 *)(a1 + 80));
      if (v37)
      {
        unsigned int v10 = *(_DWORD *)(v5 + v9);
        int v11 = v37 >= v10 ? v37 - v10 : 0;
        unsigned int v37 = v11;
      }
      else
      {
        int v11 = 0;
      }
      float v12 = *(float *)&v45;
      uint64_t v13 = (uint64_t)v35;
      if ((unint64_t)v35 >= v36)
      {
        uint64_t v19 = 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v35 - v34) >> 3);
        unint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) > 0x2E8BA2E8BA2E8BALL) {
          sub_19E041BEC();
        }
        if (0x5D1745D1745D1746 * ((uint64_t)(v36 - v34) >> 3) > v20) {
          unint64_t v20 = 0x5D1745D1745D1746 * ((uint64_t)(v36 - v34) >> 3);
        }
        uint64_t v21 = (char *)((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v36 - v34) >> 3)) >= 0x1745D1745D1745DLL
                     ? 0x2E8BA2E8BA2E8BALL
                     : v20);
        unint64_t v42 = &v36;
        if (v21) {
          uint64_t v21 = (char *)sub_19E086D44((unint64_t)v21);
        }
        else {
          uint64_t v22 = 0;
        }
        uint64_t v23 = (uint64_t)&v21[88 * v19];
        v39[0] = v21;
        v39[1] = v23;
        uint64_t v40 = v23;
        uint64_t v41 = &v21[88 * v22];
        *(_DWORD *)uint64_t v23 = 0x100000;
        *(_WORD *)(v23 + 4) = 0;
        *(unsigned char *)(v23 + 6) = 0;
        *(void *)(v23 + ++**(_DWORD **)(result + 8) = 0;
        sub_19E03CED8(v23, (unsigned __int16 *)&v43);
        long long v25 = v46;
        long long v24 = v47;
        __int16 v26 = v48;
        *(_OWORD *)(v23 + 32) = v45;
        *(_OWORD *)(v23 + 4++**(_DWORD **)(result + 8) = v25;
        *(_WORD *)(v23 + 8sub_19E062044(&a9, 0) = v26;
        *(_OWORD *)(v23 + 64) = v24;
        v40 += 88;
        sub_19E086D90(&v34, v39);
        char v18 = v35;
        sub_19E086E98((uint64_t)v39);
        int v11 = v37;
      }
      else
      {
        *char v35 = 0x100000;
        *(_WORD *)(v13 + 4) = 0;
        *(unsigned char *)(v13 + 6) = 0;
        *(void *)(v13 + ++**(_DWORD **)(result + 8) = 0;
        uint64_t v14 = sub_19E03CED8(v13, (unsigned __int16 *)&v43);
        long long v15 = v45;
        long long v16 = v46;
        long long v17 = v47;
        *(_WORD *)(v14 + 8sub_19E062044(&a9, 0) = v48;
        *(_OWORD *)(v14 + 4++**(_DWORD **)(result + 8) = v16;
        *(_OWORD *)(v14 + 64) = v17;
        *(_OWORD *)(v14 + 32) = v15;
        char v18 = (_DWORD *)(v14 + 88);
      }
      float v8 = v8 + v12;
      char v35 = v18;
      if (!v11) {
        break;
      }
      int v38 = v11;
      if (v44)
      {
        if (BYTE6(v43) == 1) {
          free(v44);
        }
      }
    }
    if (v44 && BYTE6(v43) == 1)
    {
      free(v44);
      char v18 = v35;
    }
    uint64_t v27 = v34;
  }
  else
  {
    uint64_t v27 = 0;
    char v18 = 0;
    float v8 = 0.0;
  }
  uint64_t v28 = 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v18 - v27) >> 3);
  if (v28)
  {
    if (v28 == 1)
    {
      *(_DWORD *)(v27 + 32) = 1065353216;
    }
    else
    {
      if (v8 <= 0.0) {
        __assert_rtn("derive_words", "CombinedTransliterationLexicon.cpp", 70, "terminationProb > 0");
      }
      while ((_DWORD *)v27 != v18)
      {
        *(float *)(v27 + 32) = *(float *)(v27 + 32) / v8;
        v27 += 88;
      }
    }
  }
  LOBYTE(v39[0]) = 0;
  uint64_t v29 = v34;
  for (uint64_t i = v35; (_DWORD *)v29 != i; v29 += 88)
  {
    double v31 = (*(double (**)(uint64_t))(*(void *)a1 + 80))(a1);
    double v32 = v31 + (*(double (**)(uint64_t))(*(void *)a1 + 88))(a1);
    double v43 = v32 + log10f(*(float *)(v29 + 32));
    uint64_t v33 = (const void *)sub_19E0882F8(v29, (uint64_t *)&v43);
    (*(void (**)(uint64_t, const void *, void *))(a2 + 16))(a2, v33, v39);
    CFRelease(v33);
    if (LOBYTE(v39[0])) {
      break;
    }
  }
  double v43 = COERCE_DOUBLE(&v34);
  sub_19E07F830((void ***)&v43);
}

void sub_19E0B0A14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char *a20,void *a21)
{
  if (a21)
  {
    if (BYTE6(a20) == 1) {
      free(a21);
    }
  }
  a20 = &a11;
  sub_19E07F830((void ***)&a20);
  _Unwind_Resume(a1);
}

uint64_t sub_19E0B0A70(uint64_t a1)
{
  uint64_t v1 = a1 + 16;
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2) {
    BOOL v3 = v2 == 0xFFFFFFFFLL;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 8) + 8)
                 + 8 * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 8) + 8) + 84));
  int v6 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)v4 + 128))(v4, v1, &v6);
}

BOOL sub_19E0B0AE8(uint64_t a1)
{
  return *(void *)(a1 + 16) == 0;
}

BOOL sub_19E0B0AF8(uint64_t a1, uint64_t a2)
{
  return a2 + 16 == a1;
}

uint64_t sub_19E0B0B08(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v40 = *(void *)(a1 + 16);
  if (*(char *)(a1 + 47) < 0) {
    sub_19E03FA9C(&__p, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else {
    std::string __p = *(std::string *)(a1 + 24);
  }
  if (*(unsigned __int16 *)(a1 + 80) >= 0xFuLL)
  {
    LOWORD(v36) = *(_WORD *)(a1 + 80);
    operator new[]();
  }
  long long v36 = *(_OWORD *)(a1 + 80);
  unint64_t v4 = *(unsigned __int16 *)(a1 + 104);
  char v37 = *(unsigned char *)(a1 + 96);
  uint64_t v5 = &v38;
  if (v4 >= 0xF)
  {
    LOWORD(v3++**(_DWORD **)(result + 8) = v4;
    operator new[]();
  }
  long long v38 = *(_OWORD *)(a1 + 104);
  int v39 = *(_DWORD *)(a1 + 120);
  if (*((void *)a2 + 1)) {
    uint64_t v6 = *((void *)a2 + 1);
  }
  else {
    uint64_t v6 = (uint64_t)(a2 + 8);
  }
  uint64_t v32 = v6;
  uint64_t v23 = (uint64_t)a2;
  int v7 = *a2;
  int v33 = 0;
  int v34 = v7;
  unsigned int v35 = 0;
  sub_19E03E768(&v32);
  uint64_t v28 = v6;
  int v29 = v7;
  int v30 = v7;
  int v31 = 0;
  sub_19E03E768(&v28);
  uint64_t v8 = v28;
  int v25 = v29;
  double v9 = 0.0;
  uint64_t v24 = v28;
  while (1)
  {
    if (v32 != v8) {
      __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
    }
    if (v33 == v25) {
      break;
    }
    uint64_t v10 = v35;
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(*(void *)(*(void *)(a1 + 8) + 8) + 1480) + 16))(&v26);
    uint64_t v11 = (unsigned __int16)v36;
    sub_19E03EB40((uint64_t)&v43, *(void *)(*(void *)(a1 + 8) + 8) + 88, (uint64_t)&v36, v10, (unsigned __int16 *)&v26);
    if (v11 >= 0xF && *((void *)&v36 + 1)) {
      MEMORY[0x19F3BA6E0](*((void *)&v36 + 1), 0x1000C8077774924);
    }
    long long v36 = v43;
    if ((unsigned __int16)v43 >= 0xFu) {
      LOWORD(v43) = 0;
    }
    char v37 = v44;
    if ((unsigned __int16)v38 >= 0xFu && *((void *)&v38 + 1)) {
      MEMORY[0x19F3BA6E0](*((void *)&v38 + 1), 0x1000C8077774924);
    }
    unsigned int v12 = (unsigned __int16)v45;
    long long *v5 = v45;
    if (v12 >= 0xF) {
      LOWORD(v45) = 0;
    }
    int v39 = v46;
    if ((unsigned __int16)v43 >= 0xFu && *((void *)&v43 + 1)) {
      MEMORY[0x19F3BA6E0](*((void *)&v43 + 1), 0x1000C8077774924);
    }
    if (v40 == 0xFFFFFFFFLL)
    {
      BOOL v13 = 1;
    }
    else
    {
      uint64_t v14 = v5;
      unsigned int v15 = (unsigned __int16)v36;
      if (v11 <= (unsigned __int16)v36) {
        uint64_t v16 = (unsigned __int16)v36;
      }
      else {
        uint64_t v16 = v11;
      }
      while (1)
      {
        BOOL v13 = v16 != v11;
        if (v16 == v11) {
          break;
        }
        long long v17 = *(uint64_t **)(*(void *)(*(void *)(a1 + 8) + 8)
                          + 8 * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 8) + 8) + 84));
        char v18 = (char *)*((void *)&v36 + 1);
        if (v15 <= 0xE) {
          char v18 = (char *)&v36 + 2;
        }
        char v42 = v18[v11];
        (*(void (**)(long long *__return_ptr, uint64_t *, uint64_t *, char *, uint64_t))(*v17 + 120))(&v43, v17, &v40, &v42, 1);
        uint64_t v40 = v43;
        std::string::operator=(&__p, (const std::string *)((char *)&v43 + 8));
        if (SBYTE7(v45) < 0) {
          operator delete(*((void **)&v43 + 1));
        }
        float v19 = sub_19E0F6CC4(v17, (uint64_t)&v40);
        double v9 = v9 + log10f(v19);
        ++v11;
        if (v40 == 0xFFFFFFFFLL)
        {
          BOOL v13 = 1;
          break;
        }
      }
      uint64_t v5 = v14;
      uint64_t v8 = v24;
    }
    if ((unsigned __int16)v26 >= 0xFu && v27) {
      MEMORY[0x19F3BA6E0](v27, 0x1000C8077774924);
    }
    if (v13)
    {
      uint64_t Instance = 0;
      goto LABEL_52;
    }
    sub_19E03E768(&v32);
  }
  if (v40 == 0xFFFFFFFFLL) {
    __assert_rtn("create_child", "TransliterationCursorImpl.cpp", 60, "impl.valid()");
  }
  sub_19E0B23D4((uint64_t)&v43, (unsigned __int16 *)(a1 + 48), v23);
  double v20 = *(double *)(a1 + 136);
  if (qword_1EB4FEE18 != -1) {
    dispatch_once(&qword_1EB4FEE18, &unk_1EF098DC8);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  sub_19E0B02F0(Instance + 16, *(void *)(a1 + 8), (uint64_t)&v40, (unsigned __int16 *)&v43, (unsigned __int16 *)&v36, v9, v20 + v9);
  if (*((void *)&v43 + 1) && BYTE6(v43) == 1) {
    free(*((void **)&v43 + 1));
  }
LABEL_52:
  if ((unsigned __int16)v38 >= 0xFu && *((void *)&v38 + 1)) {
    MEMORY[0x19F3BA6E0](*((void *)&v38 + 1), 0x1000C8077774924);
  }
  if ((unsigned __int16)v36 >= 0xFu && *((void *)&v36 + 1)) {
    MEMORY[0x19F3BA6E0](*((void *)&v36 + 1), 0x1000C8077774924);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return Instance;
}

void sub_19E0B1088(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int16 a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,__int16 a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
}

void sub_19E0B1164(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0998E0;
  if (*(unsigned __int16 *)(a1 + 104) >= 0xFu)
  {
    uint64_t v2 = *(void *)(a1 + 112);
    if (v2) {
      MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
    }
  }
  if (*(unsigned __int16 *)(a1 + 80) >= 0xFu)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3) {
      MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
    }
  }
  unint64_t v4 = *(void **)(a1 + 56);
  if (v4 && *(unsigned char *)(a1 + 54) == 1) {
    free(v4);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  JUMPOUT(0x19F3BA710);
}

uint64_t sub_19E0B123C(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0998E0;
  if (*(unsigned __int16 *)(a1 + 104) >= 0xFu)
  {
    uint64_t v2 = *(void *)(a1 + 112);
    if (v2) {
      MEMORY[0x19F3BA6E0](v2, 0x1000C8077774924);
    }
  }
  if (*(unsigned __int16 *)(a1 + 80) >= 0xFu)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3) {
      MEMORY[0x19F3BA6E0](v3, 0x1000C8077774924);
    }
  }
  unint64_t v4 = *(void **)(a1 + 56);
  if (v4 && *(unsigned char *)(a1 + 54) == 1) {
    free(v4);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

uint64_t sub_19E0B12F4(unsigned __int16 *a1)
{
  if (*((unsigned char *)a1 + 6)) {
    __assert_rtn("internalize_buffer", "TIString.cpp", 240, "m_buffer_type == External");
  }
  *((unsigned char *)a1 + 6) = 1;
  uint64_t v1 = *((void *)a1 + 1);
  *((void *)a1 + 1) = 0;
  uint64_t v2 = *a1;

  return sub_19E03F6F8(a1, v1, 0, v2);
}

uint64_t sub_19E0B1358(uint64_t a1, char *__s)
{
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 6) = 1;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  if (__s)
  {
    unsigned __int16 v4 = strlen(__s);
    sub_19E03F6F8((void *)a1, (uint64_t)__s, 0, v4);
  }
  else
  {
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_19E0B13C0(uint64_t a1, char *__s1, size_t __n)
{
  unsigned int v3 = __n;
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 6) = 1;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  if (!__s1)
  {
    if (!__n)
    {
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
      return a1;
    }
LABEL_8:
    __assert_rtn("String", "TIString.cpp", 88, "str && len <= strnlen(str, len) || len == 0");
  }
  size_t v6 = strnlen(__s1, __n);
  if (v3 && v6 < v3) {
    goto LABEL_8;
  }
  sub_19E03F6F8((void *)a1, (uint64_t)__s1, 0, v3);
  return a1;
}

uint64_t sub_19E0B146C(_DWORD *a1)
{
  int v3 = a1[2];
  uint64_t result = a1[3];
  if (v3 <= (int)result)
  {
    unsigned int v4 = a1[4];
    if (v4 >= 0x10000) {
      int v5 = -4;
    }
    else {
      int v5 = -3;
    }
    if (v4 - 1114112 >= 0xFFEFE000) {
      int v6 = v5;
    }
    else {
      int v6 = 0;
    }
    if (v4 >> 11 >= 0x1B) {
      int v7 = v6;
    }
    else {
      int v7 = -3;
    }
    if (v4 >= 0x800) {
      int v8 = v7;
    }
    else {
      int v8 = -2;
    }
    if (v4 >= 0x80) {
      int v9 = v8;
    }
    else {
      int v9 = -1;
    }
    return (v9 + v3);
  }
  return result;
}

void sub_19E0B14D0(unsigned __int16 *a1, unsigned int a2)
{
  if (!*((unsigned char *)a1 + 6)) {
    sub_19E0B12F4(a1);
  }
  unsigned __int16 v4 = *a1;
  if (a2 > 0x7F)
  {
    sub_19E03F794((uint64_t)a1, v4 + 4);
    int v6 = (unsigned __int16 *)*((void *)a1 + 1);
    if (!v6) {
      int v6 = a1 + 8;
    }
    if (a2 > 0x7FF)
    {
      uint64_t v8 = *a1;
      *a1 = v8 + 1;
      if (HIWORD(a2))
      {
        *((unsigned char *)v6 + v++**(_DWORD **)(result + 8) = (a2 >> 18) | 0xF0;
        uint64_t v9 = *a1;
        *a1 = v9 + 1;
        *((unsigned char *)v6 + v9) = (a2 >> 12) & 0x3F | 0x80;
      }
      else
      {
        *((unsigned char *)v6 + v++**(_DWORD **)(result + 8) = (a2 >> 12) | 0xE0;
      }
      unsigned int v7 = (a2 >> 6) & 0x3F | 0xFFFFFF80;
    }
    else
    {
      unsigned int v7 = (a2 >> 6) | 0xFFFFFFC0;
    }
    uint64_t v10 = *a1;
    *a1 = v10 + 1;
    *((unsigned char *)v6 + v1sub_19E062044(&a9, 0) = v7;
    uint64_t v11 = *a1;
    *a1 = v11 + 1;
    *((unsigned char *)v6 + v11) = a2 & 0x3F | 0x80;
  }
  else
  {
    unsigned __int16 v5 = v4 + 1;
    sub_19E03F794((uint64_t)a1, v4 + 1);
    int v6 = (unsigned __int16 *)*((void *)a1 + 1);
    if (!v6) {
      int v6 = a1 + 8;
    }
    *a1 = v5;
    *((unsigned char *)v6 + v5 - 1) = a2;
  }
  *((unsigned char *)v6 + *a1) = 0;
  a1[2] = 0;
}

_DWORD *sub_19E0B15FC(_DWORD *a1)
{
  int v2 = sub_19E0B146C(a1);
  if (v2)
  {
    a1[2] = v2;
    uint64_t v3 = *(void *)a1;
    int v4 = *(char *)(*(void *)a1 + (v2 - 1));
    int v5 = *(unsigned __int8 *)(*(void *)a1 + (v2 - 1));
    a1[4] = v5;
    if (v4 <= -65)
    {
      int v6 = v5 & 0x3F;
      a1[4] = v6;
      unsigned int v7 = *(unsigned __int8 *)(v3 + (v2 - 2));
      if (v7 <= 0xBF)
      {
        unsigned int v10 = v2 - 3;
        char v11 = 1;
        char v12 = 6;
        do
        {
          v6 |= (v7 & 0x3F) << v12;
          a1[4] = v6;
          ++v11;
          v12 += 6;
          unsigned int v7 = *(unsigned __int8 *)(v3 + v10--);
        }
        while (v7 <= 0xBF);
        char v9 = 6 - v11;
        char v8 = v12;
      }
      else
      {
        char v8 = 6;
        char v9 = 5;
      }
      a1[4] = v6 | ((v7 & ~(-1 << v9)) << v8);
    }
  }
  return a1;
}

uint64_t sub_19E0B16C4(unsigned __int16 *a1, unsigned __int16 *a2, unsigned int a3)
{
  unsigned int v3 = *a1;
  if (v3 > a3 && *a2 != 0)
  {
    uint64_t v9 = *((void *)a1 + 1);
    unsigned int v10 = a1 + 8;
    if (v9) {
      uint64_t v11 = *((void *)a1 + 1);
    }
    else {
      uint64_t v11 = (uint64_t)(a1 + 8);
    }
    uint64_t v22 = v11;
    int v23 = a3;
    int v24 = v3;
    unsigned int v25 = 0;
    sub_19E03E768(&v22);
    while (1)
    {
      if (v9) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = (uint64_t)v10;
      }
      uint64_t v18 = v12;
      unsigned int v19 = v3;
      unsigned int v20 = v3;
      int v21 = 0;
      sub_19E03E768(&v18);
      if (v22 != v18) {
        __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
      }
      if (v23 == v19) {
        break;
      }
      if (sub_19E0B1820(a2, v25))
      {
        unsigned __int16 v5 = v24;
        if (v23 <= v24)
        {
          if (v25 >= 0x10000) {
            __int16 v13 = -4;
          }
          else {
            __int16 v13 = -3;
          }
          if (v25 - 1114112 >= 0xFFEFE000) {
            __int16 v14 = v13;
          }
          else {
            __int16 v14 = 0;
          }
          if (v25 >> 11 >= 0x1B) {
            __int16 v15 = v14;
          }
          else {
            __int16 v15 = -3;
          }
          if (v25 >= 0x800) {
            __int16 v16 = v15;
          }
          else {
            __int16 v16 = -2;
          }
          if (v25 >= 0x80) {
            __int16 v17 = v16;
          }
          else {
            __int16 v17 = -1;
          }
          return (unsigned __int16)(v17 + v23);
        }
        return v5;
      }
      sub_19E03E768(&v22);
      unsigned int v3 = *a1;
      uint64_t v9 = *((void *)a1 + 1);
    }
  }
  return (unsigned __int16)-1;
}

BOOL sub_19E0B1820(unsigned __int16 *a1, unsigned int a2)
{
  if (*((void *)a1 + 1)) {
    uint64_t v3 = *((void *)a1 + 1);
  }
  else {
    uint64_t v3 = (uint64_t)(a1 + 8);
  }
  if (a2 > 0x7F)
  {
    *(void *)&long long v18 = v3;
    int v7 = *a1;
    DWORD2(v1++**(_DWORD **)(result + 8) = 0;
    HIDWORD(v1++**(_DWORD **)(result + 8) = v7;
    LODWORD(v19) = 0;
    sub_19E03E768((uint64_t *)&v18);
    uint64_t v14 = v3;
    int v15 = v7;
    int v16 = v7;
    int v17 = 0;
    sub_19E03E768(&v14);
    long long v20 = v18;
    uint64_t v21 = v19;
    uint64_t v8 = v14;
    if ((void)v18 != v14) {
      goto LABEL_17;
    }
    int v9 = v15;
    while (1)
    {
      int v10 = DWORD2(v20);
      if (DWORD2(v20) == v9 || v21 == a2) {
        break;
      }
      sub_19E03E768((uint64_t *)&v20);
      if ((void)v20 != v8) {
        goto LABEL_17;
      }
    }
    *(void *)&long long v20 = v3;
    DWORD2(v2sub_19E062044(&a9, 0) = v7;
    HIDWORD(v2sub_19E062044(&a9, 0) = v7;
    LODWORD(v21) = 0;
    sub_19E03E768((uint64_t *)&v20);
    if (v8 != (void)v20) {
LABEL_17:
    }
      __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
    BOOL v12 = v10 == DWORD2(v20);
  }
  else
  {
    int v4 = (char *)*a1;
    if (*a1)
    {
      uint64_t v5 = *a1;
      int v6 = (char *)v3;
      while (*v6 != a2)
      {
        ++v6;
        if (!--v5)
        {
          int v6 = &v4[v3];
          break;
        }
      }
    }
    else
    {
      int v6 = (char *)v3;
    }
    BOOL v12 = &v6[-v3] == v4;
  }
  return !v12;
}

uint64_t sub_19E0B1978(unsigned __int16 *a1, unsigned __int16 *a2, unsigned int a3)
{
  unsigned int v3 = *a1;
  if (v3 > a3 && *a2 != 0)
  {
    uint64_t v9 = *((void *)a1 + 1);
    int v10 = a1 + 8;
    if (v9) {
      uint64_t v11 = *((void *)a1 + 1);
    }
    else {
      uint64_t v11 = (uint64_t)(a1 + 8);
    }
    uint64_t v22 = v11;
    int v23 = a3;
    int v24 = v3;
    unsigned int v25 = 0;
    sub_19E03E768(&v22);
    while (1)
    {
      if (v9) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = (uint64_t)v10;
      }
      uint64_t v18 = v12;
      unsigned int v19 = v3;
      unsigned int v20 = v3;
      int v21 = 0;
      sub_19E03E768(&v18);
      if (v22 != v18) {
        __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
      }
      if (v23 == v19) {
        break;
      }
      if (!sub_19E0B1820(a2, v25))
      {
        unsigned __int16 v5 = v24;
        if (v23 <= v24)
        {
          if (v25 >= 0x10000) {
            __int16 v13 = -4;
          }
          else {
            __int16 v13 = -3;
          }
          if (v25 - 1114112 >= 0xFFEFE000) {
            __int16 v14 = v13;
          }
          else {
            __int16 v14 = 0;
          }
          if (v25 >> 11 >= 0x1B) {
            __int16 v15 = v14;
          }
          else {
            __int16 v15 = -3;
          }
          if (v25 >= 0x800) {
            __int16 v16 = v15;
          }
          else {
            __int16 v16 = -2;
          }
          if (v25 >= 0x80) {
            __int16 v17 = v16;
          }
          else {
            __int16 v17 = -1;
          }
          return (unsigned __int16)(v17 + v23);
        }
        return v5;
      }
      sub_19E03E768(&v22);
      unsigned int v3 = *a1;
      uint64_t v9 = *((void *)a1 + 1);
    }
  }
  return (unsigned __int16)-1;
}

void *sub_19E0B1AD4(void *result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  uint64_t v3 = (uint64_t)result;
  if (!*a2 || (uint64_t result = (void *)sub_19E0B1978(a2, a3, 0), result == 0xFFFF))
  {
    *(_DWORD *)uint64_t v3 = 0x100000;
    *(_WORD *)(v3 + 4) = 0;
    *(unsigned char *)(v3 + 6) = 0;
    *(void *)(v3 + ++**(_DWORD **)(result + 8) = 0;
    *(unsigned char *)(v3 + 16) = 0;
  }
  else
  {
    int v6 = *a2;
    if (!*a2 || !*a3) {
      goto LABEL_58;
    }
    unsigned int v7 = result;
    uint64_t v8 = (unsigned __int16 *)*((void *)a2 + 1);
    uint64_t v9 = v8 ? (unsigned __int16 *)*((void *)a2 + 1) : a2 + 8;
    *(void *)&long long v24 = v9;
    DWORD2(v24) = v6;
    HIDWORD(v24) = v6;
    LODWORD(v25) = 0;
    sub_19E03E768((uint64_t *)&v24);
    while (1)
    {
      if (v8) {
        int v10 = v8;
      }
      else {
        int v10 = a2 + 8;
      }
      *(void *)&long long v22 = v10;
      DWORD2(v22) = 0;
      HIDWORD(v22) = v6;
      LODWORD(v23) = 0;
      sub_19E03E768((uint64_t *)&v22);
      if ((void)v24 != (void)v22) {
        __assert_rtn("operator!=", "TIString.h", 194, "p==rhs.p");
      }
      if (DWORD2(v24) == DWORD2(v22)) {
        goto LABEL_58;
      }
      long long v22 = v24;
      uint64_t v23 = v25;
      sub_19E0B15FC(&v22);
      if (!sub_19E0B1820(a3, v23)) {
        break;
      }
      sub_19E0B15FC(&v24);
      uint64_t v8 = (unsigned __int16 *)*((void *)a2 + 1);
      int v6 = *a2;
    }
    long long v22 = v24;
    uint64_t v23 = v25;
    sub_19E0B15FC(&v22);
    unsigned __int16 v11 = WORD6(v22);
    if (SDWORD2(v22) <= SHIDWORD(v22))
    {
      if (v23 >= 0x10000) {
        __int16 v12 = -4;
      }
      else {
        __int16 v12 = -3;
      }
      if ((v23 - 1114112) >= 0xFFEFE000) {
        __int16 v13 = v12;
      }
      else {
        __int16 v13 = 0;
      }
      if (v23 >> 11 >= 0x1B) {
        __int16 v14 = v13;
      }
      else {
        __int16 v14 = -3;
      }
      if (v23 >= 0x800) {
        __int16 v15 = v14;
      }
      else {
        __int16 v15 = -2;
      }
      if (v23 >= 0x80) {
        __int16 v16 = v15;
      }
      else {
        __int16 v16 = -1;
      }
      unsigned __int16 v11 = v16 + WORD4(v22);
    }
    unsigned int v17 = v11;
    if (v11 == 0xFFFF) {
LABEL_58:
    }
      __assert_rtn("trim", "TIString.cpp", 559, "e != NotAnIndex");
    unsigned int v18 = *a2;
    if (v18 <= v11) {
      __assert_rtn("trim", "TIString.cpp", 560, "e < size()");
    }
    unsigned int v19 = (unsigned __int16 *)*((void *)a2 + 1);
    if (!v19) {
      unsigned int v19 = a2 + 8;
    }
    *(void *)&long long v22 = v19;
    *((void *)&v22 + 1) = __PAIR64__(v18, v17);
    LODWORD(v23) = 0;
    sub_19E03E768((uint64_t *)&v22);
    long long v24 = v22;
    uint64_t v25 = v23;
    sub_19E03E768((uint64_t *)&v24);
    unsigned __int16 v20 = WORD6(v24);
    if (SDWORD2(v24) <= SHIDWORD(v24))
    {
      if (v25 >= 0x80)
      {
        if (v25 >= 0x800)
        {
          if (v25 >> 11 >= 0x1B)
          {
            if ((v25 - 1114112) >= 0xFFEFE000)
            {
              if (v25 >= 0x10000) {
                __int16 v21 = -4;
              }
              else {
                __int16 v21 = -3;
              }
            }
            else
            {
              __int16 v21 = 0;
            }
          }
          else
          {
            __int16 v21 = -3;
          }
        }
        else
        {
          __int16 v21 = -2;
        }
      }
      else
      {
        __int16 v21 = -1;
      }
      unsigned __int16 v20 = v21 + WORD4(v24);
    }
    if (v7 || v18 != v20) {
      return sub_19E03FB9C((void *)v3, a2, v7, (unsigned __int16)(v20 - v7));
    }
    else {
      return (void *)sub_19E039858(v3, a2);
    }
  }
  return result;
}

unsigned __int16 *sub_19E0B1DD8(uint64_t a1, unsigned __int16 *a2, size_t a3, int a4, _WORD *a5)
{
  unsigned int v5 = *a2;
  if (a4 + (int)a3 > v5) {
    __assert_rtn("replace", "TIString.cpp", 596, "pos + size_replaced <= size()");
  }
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 6) = 0;
  *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  sub_19E03F794(a1, v5 - a4 + *a5);
  if (*((void *)a2 + 1)) {
    unsigned __int16 v11 = (char *)*((void *)a2 + 1);
  }
  else {
    unsigned __int16 v11 = (char *)(a2 + 8);
  }
  sub_19E039CC0((unsigned __int16 *)a1, v11, a3);
  sub_19E0B1EE0((unsigned __int16 *)a1, (uint64_t)a5);
  __int16 v12 = (unsigned __int16 *)*((void *)a2 + 1);
  if (!v12) {
    __int16 v12 = a2 + 8;
  }
  return sub_19E039CC0((unsigned __int16 *)a1, (char *)v12 + a3 + a4, 0xFFFFuLL);
}

void sub_19E0B1EBC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

unsigned __int16 *sub_19E0B1EE0(unsigned __int16 *result, uint64_t a2)
{
  if (*(_WORD *)a2)
  {
    uint64_t v3 = result;
    if (!*((unsigned char *)result + 6)) {
      sub_19E0B12F4(result);
    }
    if (*(void *)(a2 + 8)) {
      int v4 = *(char **)(a2 + 8);
    }
    else {
      int v4 = (char *)(a2 + 16);
    }
    return sub_19E039CC0(v3, v4, 0xFFFFuLL);
  }
  return result;
}

void sub_19E0B1F50(unsigned __int16 *a1, UChar *src, uint64_t srcLength)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (src)
  {
    int32_t v3 = srcLength;
    if (srcLength)
    {
      *(void *)pErrorCode = 0;
      u_strToUTF8(0, 0, (int32_t *)&pErrorCode[1], src, srcLength, pErrorCode);
      if (pErrorCode[0] < U_ILLEGAL_ARGUMENT_ERROR || pErrorCode[0] == U_BUFFER_OVERFLOW_ERROR)
      {
        pErrorCode[0] = U_ZERO_ERROR;
        if (!*((unsigned char *)a1 + 6)) {
          sub_19E0B12F4(a1);
        }
        sub_19E03F794((uint64_t)a1, *a1 + LOWORD(pErrorCode[1]));
        unsigned int v7 = (unsigned __int16 *)*((void *)a1 + 1);
        if (!v7) {
          unsigned int v7 = a1 + 8;
        }
        u_strToUTF8((char *)v7 + *a1, pErrorCode[1] + 1, 0, src, v3, pErrorCode);
        if (pErrorCode[0] < U_ILLEGAL_ARGUMENT_ERROR)
        {
          *a1 += LOWORD(pErrorCode[1]);
          a1[2] = 0;
        }
        else
        {
          if (qword_1E9457798 != -1) {
            dispatch_once(&qword_1E9457798, &unk_1EF09E558);
          }
          uint64_t v8 = qword_1E9457790;
          if (os_log_type_enabled((os_log_t)qword_1E9457790, OS_LOG_TYPE_ERROR))
          {
            uint64_t v9 = u_errorName(pErrorCode[0]);
            *(_DWORD *)buf = 136315394;
            __int16 v14 = "append";
            __int16 v15 = 2080;
            __int16 v16 = v9;
            int v10 = "%s: u_strToUTF8() failed with '%s'";
LABEL_21:
            _os_log_error_impl(&dword_19E038000, v8, OS_LOG_TYPE_ERROR, v10, buf, 0x16u);
          }
        }
      }
      else
      {
        if (qword_1E9457798 != -1) {
          dispatch_once(&qword_1E9457798, &unk_1EF09E558);
        }
        uint64_t v8 = qword_1E9457790;
        if (os_log_type_enabled((os_log_t)qword_1E9457790, OS_LOG_TYPE_ERROR))
        {
          unsigned __int16 v11 = u_errorName(pErrorCode[0]);
          *(_DWORD *)buf = 136315394;
          __int16 v14 = "append";
          __int16 v15 = 2080;
          __int16 v16 = v11;
          int v10 = "%s: u_strToUTF8() (length preflight) failed with '%s'";
          goto LABEL_21;
        }
      }
    }
  }
}

uint64_t sub_19E0B2180(const void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_19E0B21AC(a1, a2, &a9);
}

uint64_t sub_19E0B21AC(const void *a1, const char *a2, va_list a3)
{
  unsigned int v5 = funopen(a1, 0, (int (__cdecl *)(void *, const char *, int))sub_19E0B227C, 0, 0);
  if (!v5) {
    __assert_rtn("append_format", "TIString.cpp", 744, "string_pseudofile");
  }
  int v6 = v5;
  if (vfprintf(v5, a2, a3) < 0) {
    __assert_rtn("append_format", "TIString.cpp", 746, "status >= 0");
  }
  uint64_t result = fclose(v6);
  if (result) {
    __assert_rtn("append_format", "TIString.cpp", 748, "status == 0");
  }
  return result;
}

uint64_t sub_19E0B227C(unsigned __int16 *a1, char *a2, uint64_t a3)
{
  return a3;
}

uint64_t sub_19E0B22A8@<X0>(_WORD *a1@<X8>, char a2)
{
  *(_DWORD *)a1 = 0x100000;
  a1[2] = 0;
  *((unsigned char *)a1 + 6) = 0;
  *((void *)a1 + 1) = 0;
  *((unsigned char *)a1 + 16) = 0;
  return sub_19E0B21AC(a1, "%s%d", &a2);
}

void sub_19E0B2304(_Unwind_Exception *exception_object)
{
  int32_t v3 = *(void **)(v1 + 8);
  if (v3) {
    BOOL v4 = *(unsigned char *)(v1 + 6) == 1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E0B2328(uint64_t a1, unsigned __int16 *a2, unsigned int a3)
{
  BOOL v4 = (unsigned __int16 *)sub_19E039858(a1, a2);
  sub_19E0B14D0(v4, a3);
}

void sub_19E0B2358(_Unwind_Exception *exception_object)
{
  int32_t v3 = *(void **)(v1 + 8);
  if (v3) {
    BOOL v4 = *(unsigned char *)(v1 + 6) == 1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int16 *sub_19E0B237C(uint64_t a1, unsigned __int16 *a2, char *a3)
{
  BOOL v4 = (unsigned __int16 *)sub_19E039858(a1, a2);
  return sub_19E039CC0(v4, a3, 0xFFFFuLL);
}

void sub_19E0B23B0(_Unwind_Exception *exception_object)
{
  int32_t v3 = *(void **)(v1 + 8);
  if (v3) {
    BOOL v4 = *(unsigned char *)(v1 + 6) == 1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int16 *sub_19E0B23D4(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  BOOL v4 = (unsigned __int16 *)sub_19E039858(a1, a2);
  return sub_19E0B1EE0(v4, a3);
}

void sub_19E0B2404(_Unwind_Exception *exception_object)
{
  int32_t v3 = *(void **)(v1 + 8);
  if (v3) {
    BOOL v4 = *(unsigned char *)(v1 + 6) == 1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_19E0B2428(unsigned __int16 *a1, unsigned __int16 *a2)
{
  if (!(*((unsigned __int8 *)a1 + 6) | *((unsigned __int8 *)a2 + 6)) && *((void *)a1 + 1) == *((void *)a2 + 1)) {
    return 1;
  }
  if (*a1 != *a2) {
    return 0;
  }
  if (!*a1) {
    return 1;
  }
  if (*((void *)a1 + 1)) {
    int v2 = (const char *)*((void *)a1 + 1);
  }
  else {
    int v2 = (const char *)(a1 + 8);
  }
  if (*((void *)a2 + 1)) {
    int32_t v3 = (const char *)*((void *)a2 + 1);
  }
  else {
    int32_t v3 = (const char *)(a2 + 8);
  }
  return strcmp(v2, v3) == 0;
}

uint64_t sub_19E0B24AC(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v2 = -1640531527;
  if (a2 >= 2)
  {
    unsigned int v3 = a2 >> 1;
    BOOL v4 = a1;
    do
    {
      unsigned int v5 = v2 + *v4;
      int v6 = (v5 << 16) ^ (v4[1] << 11);
      v4 += 2;
      unsigned int v2 = (v6 ^ v5) + ((v6 ^ v5) >> 11);
      --v3;
    }
    while (v3);
    a1 += 2 * (a2 >> 1);
  }
  if (a2) {
    unsigned int v2 = ((v2 + *a1) ^ ((v2 + *a1) << 11)) + (((v2 + *a1) ^ ((v2 + *a1) << 11)) >> 17);
  }
  unsigned int v7 = (v2 ^ (8 * v2)) + ((v2 ^ (8 * v2)) >> 5);
  unsigned int v8 = (v7 ^ (4 * v7)) + ((v7 ^ (4 * v7)) >> 15);
  return v8 ^ (v8 << 10);
}

void *sub_19E0B2528(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1EB4FEBF8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    uint64_t v5[2] = 0x40000000;
    void v5[3] = sub_19E0B2668;
    void v5[4] = &unk_1E599C230;
    void v5[5] = v5;
    long long v6 = xmmword_1E599C218;
    uint64_t v7 = 0;
    qword_1EB4FEBF8 = _sl_dlopen();
    unsigned int v3 = (void *)v5[0];
    unsigned int v2 = (void *)qword_1EB4FEBF8;
    if (qword_1EB4FEBF8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      unsigned int v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  unsigned int v2 = (void *)qword_1EB4FEBF8;
LABEL_5:
  uint64_t result = dlsym(v2, "MKBDeviceUnlockedSinceBoot");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EB4FEC00 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E0B2668()
{
  uint64_t result = _sl_dlopen();
  qword_1EB4FEBF8 = result;
  return result;
}

void sub_19E0B26DC(uint64_t a1, CFDictionaryRef theDict)
{
  if (theDict)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"wordReading");
    sub_19E03F0BC(a1, Value);
  }
  else
  {
    *(_DWORD *)a1 = 0x100000;
    *(_WORD *)(a1 + 4) = 0;
    *(unsigned char *)(a1 + 6) = 0;
    *(void *)(a1 + ++**(_DWORD **)(result + 8) = 0;
    *(unsigned char *)(a1 + 16) = 0;
  }
}

void sub_19E0B2750(unsigned int a1, CFStringRef theString, CFErrorRef *a3)
{
  void v17[2] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v6 = atomic_load(byte_1E9457268);
  if (v6)
  {
    unsigned __int8 v7 = atomic_load(byte_1E94578A0);
    if (v7)
    {
      sub_19E03F0BC((uint64_t)&v15, theString);
      int v10 = (const char *)v16;
      if (!v16) {
        int v10 = (const char *)v17;
      }
      printf("%s", v10);
      if (v16 && BYTE6(v15) == 1) {
        free(v16);
      }
      putchar(10);
    }
    else
    {
      uint64_t v8 = sub_19E08D084();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        sub_19E03F0BC((uint64_t)&v15, theString);
        uint64_t v9 = v16;
        if (!v16) {
          uint64_t v9 = v17;
        }
        *(_DWORD *)buf = 136315138;
        __int16 v14 = v9;
        _os_log_impl(&dword_19E038000, v8, OS_LOG_TYPE_ERROR, "%s", buf, 0xCu);
        if (v16 && BYTE6(v15) == 1) {
          free(v16);
        }
      }
    }
  }
  if (a3)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
    __int16 v15 = Mutable;
    CFDictionarySetValue(Mutable, @"errorMessageKey", theString);
    CFIndex v12 = a1;
    switch(a1)
    {
      case 0u:
        break;
      case 1u:
      case 2u:
      case 0x10u:
        CFIndex v12 = 2;
        break;
      case 3u:
      case 5u:
      case 6u:
      case 8u:
      case 0xEu:
      case 0x17u:
      case 0x1Au:
        CFIndex v12 = 3;
        break;
      case 4u:
      case 9u:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xFu:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x18u:
      case 0x19u:
      case 0x1Bu:
      case 0x1Cu:
        goto LABEL_17;
      case 7u:
      case 0xAu:
        CFIndex v12 = 5;
        break;
      default:
        if (a1 - 100 < 2) {
LABEL_17:
        }
          CFIndex v12 = 4;
        else {
          CFIndex v12 = 6;
        }
        break;
    }
    *a3 = CFErrorCreate(0, @"com.apple.LXVulgarWordUsageDatabase", v12, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
}